package #
Locale::Codes::Script_Codes;

# This file was automatically generated.  Any changes to this file will
# be lost the next time 'harvest_data' is run.
#    Generated on: Tue Dec  1 14:44:11 EST 2015

use strict;
require 5.006;
use warnings;
use utf8;

our($VERSION);
$VERSION='3.37';

$Locale::Codes::Data{'script'}{'id'} = '0175';

$Locale::Codes::Data{'script'}{'id2names'} = {
   q(0001) => [
      q(Adlam),
      ],
   q(0002) => [
      q(Afaka),
      ],
   q(0003) => [
      q(Caucasian Albanian),
      ],
   q(0004) => [
      q(Ahom, Tai Ahom),
      q(Ahom),
      q(Tai Ahom),
      ],
   q(0005) => [
      q(Arabic),
      ],
   q(0006) => [
      q(Arabic (Nastaliq variant)),
      ],
   q(0007) => [
      q(Imperial Aramaic),
      ],
   q(0008) => [
      q(Armenian),
      ],
   q(0009) => [
      q(Avestan),
      ],
   q(0010) => [
      q(Balinese),
      ],
   q(0011) => [
      q(Bamum),
      ],
   q(0012) => [
      q(Bassa Vah),
      ],
   q(0013) => [
      q(Batak),
      ],
   q(0014) => [
      q(Bengali),
      ],
   q(0015) => [
      q(Bhaiksuki),
      ],
   q(0016) => [
      q(Blissymbols),
      ],
   q(0017) => [
      q(Bopomofo),
      ],
   q(0018) => [
      q(Brahmi),
      ],
   q(0019) => [
      q(Braille),
      ],
   q(0020) => [
      q(Buginese),
      ],
   q(0021) => [
      q(Buhid),
      ],
   q(0022) => [
      q(Chakma),
      ],
   q(0023) => [
      q(Unified Canadian Aboriginal Syllabics),
      ],
   q(0024) => [
      q(Carian),
      ],
   q(0025) => [
      q(Cham),
      ],
   q(0026) => [
      q(Cherokee),
      ],
   q(0027) => [
      q(Cirth),
      ],
   q(0028) => [
      q(Coptic),
      ],
   q(0029) => [
      q(Cypriot),
      ],
   q(0030) => [
      q(Cyrillic),
      ],
   q(0031) => [
      q(Cyrillic (Old Church Slavonic variant)),
      ],
   q(0032) => [
      q(Devanagari (Nagari)),
      q(Devanagari),
      q(Nagari),
      ],
   q(0033) => [
      q(Deseret (Mormon)),
      q(Deseret),
      q(Mormon),
      ],
   q(0034) => [
      q(Duployan shorthand, Duployan stenography),
      q(Duployan shorthand),
      q(Duployan stenography),
      ],
   q(0035) => [
      q(Egyptian demotic),
      ],
   q(0036) => [
      q(Egyptian hieratic),
      ],
   q(0037) => [
      q(Egyptian hieroglyphs),
      ],
   q(0038) => [
      q(Elbasan),
      ],
   q(0039) => [
      q(Ethiopic (Geez)),
      q(Ethiopic),
      q(Ge'ez),
      ],
   q(0040) => [
      q(Khutsuri (Asomtavruli and Nuskhuri)),
      ],
   q(0041) => [
      q(Georgian (Mkhedruli)),
      ],
   q(0042) => [
      q(Glagolitic),
      ],
   q(0043) => [
      q(Gothic),
      ],
   q(0044) => [
      q(Grantha),
      ],
   q(0045) => [
      q(Greek),
      ],
   q(0046) => [
      q(Gujarati),
      ],
   q(0047) => [
      q(Gurmukhi),
      ],
   q(0048) => [
      q(Hangul (Hangul, Hangeul)),
      q(Hangul),
      q(Hangeul),
      ],
   q(0049) => [
      q(Han (Hanzi, Kanji, Hanja)),
      q(Han),
      q(Hanzi),
      q(Kanji),
      q(Hanja),
      ],
   q(0050) => [
      q(Hanunoo (Hanunoo)),
      q(Hanunoo),
      ],
   q(0051) => [
      q(Han (Simplified variant)),
      ],
   q(0052) => [
      q(Han (Traditional variant)),
      ],
   q(0053) => [
      q(Hatran),
      ],
   q(0054) => [
      q(Hebrew),
      ],
   q(0055) => [
      q(Hiragana),
      ],
   q(0056) => [
      q(Anatolian Hieroglyphs (Luwian Hieroglyphs, Hittite Hieroglyphs)),
      q(Anatolian Hieroglyphs),
      q(Luwian Hieroglyphs),
      q(Hittite Hieroglyphs),
      ],
   q(0057) => [
      q(Pahawh Hmong),
      ],
   q(0058) => [
      q(Japanese syllabaries (alias for Hiragana + Katakana)),
      ],
   q(0059) => [
      q(Old Hungarian (Hungarian Runic)),
      q(Old Hungarian),
      q(Hungarian Runic),
      ],
   q(0060) => [
      q(Indus (Harappan)),
      q(Indus),
      q(Harappan),
      ],
   q(0061) => [
      q(Old Italic (Etruscan, Oscan, etc.)),
      ],
   q(0062) => [
      q(Javanese),
      ],
   q(0063) => [
      q(Japanese (alias for Han + Hiragana + Katakana)),
      ],
   q(0064) => [
      q(Jurchen),
      ],
   q(0065) => [
      q(Kayah Li),
      ],
   q(0066) => [
      q(Katakana),
      ],
   q(0067) => [
      q(Kharoshthi),
      ],
   q(0068) => [
      q(Khmer),
      ],
   q(0069) => [
      q(Khojki),
      ],
   q(0070) => [
      q(Khitan large script),
      ],
   q(0071) => [
      q(Khitan small script),
      ],
   q(0072) => [
      q(Kannada),
      ],
   q(0073) => [
      q(Korean (alias for Hangul + Han)),
      ],
   q(0074) => [
      q(Kpelle),
      ],
   q(0075) => [
      q(Kaithi),
      ],
   q(0076) => [
      q(Tai Tham (Lanna)),
      q(Tai Tham),
      q(Lanna),
      ],
   q(0077) => [
      q(Lao),
      ],
   q(0078) => [
      q(Latin (Fraktur variant)),
      ],
   q(0079) => [
      q(Latin (Gaelic variant)),
      ],
   q(0080) => [
      q(Latin),
      ],
   q(0081) => [
      q(Leke),
      ],
   q(0082) => [
      q(Lepcha (Rong)),
      q(Lepcha),
      q(Rong),
      ],
   q(0083) => [
      q(Limbu),
      ],
   q(0084) => [
      q(Linear A),
      ],
   q(0085) => [
      q(Linear B),
      ],
   q(0086) => [
      q(Lisu (Fraser)),
      q(Lisu),
      q(Fraser),
      ],
   q(0087) => [
      q(Loma),
      ],
   q(0088) => [
      q(Lycian),
      ],
   q(0089) => [
      q(Lydian),
      ],
   q(0090) => [
      q(Mahajani),
      ],
   q(0091) => [
      q(Mandaic, Mandaean),
      q(Mandaic),
      q(Mandaean),
      ],
   q(0092) => [
      q(Manichaean),
      ],
   q(0093) => [
      q(Marchen),
      ],
   q(0094) => [
      q(Mayan hieroglyphs),
      ],
   q(0095) => [
      q(Mende Kikakui),
      ],
   q(0096) => [
      q(Meroitic Cursive),
      ],
   q(0097) => [
      q(Meroitic Hieroglyphs),
      ],
   q(0098) => [
      q(Malayalam),
      ],
   q(0099) => [
      q(Modi, Modi),
      q(Modi),
      ],
   q(0100) => [
      q(Mongolian),
      ],
   q(0101) => [
      q(Moon (Moon code, Moon script, Moon type)),
      q(Moon),
      q(Moon code),
      q(Moon script),
      q(Moon type),
      ],
   q(0102) => [
      q(Mro, Mru),
      q(Mro),
      q(Mru),
      ],
   q(0103) => [
      q(Meitei Mayek (Meithei, Meetei)),
      q(Meitei Mayek),
      q(Meithei),
      q(Meetei),
      ],
   q(0104) => [
      q(Multani),
      ],
   q(0105) => [
      q(Myanmar (Burmese)),
      q(Myanmar),
      q(Burmese),
      ],
   q(0106) => [
      q(Old North Arabian (Ancient North Arabian)),
      q(Old North Arabian),
      q(Ancient North Arabian),
      ],
   q(0107) => [
      q(Nabataean),
      ],
   q(0108) => [
      q(Nakhi Geba ('Na-'Khi Ggo-baw, Naxi Geba)),
      q(Nakhi Geba),
      q('Na-'Khi Ggo-baw),
      q(Naxi Geba),
      ],
   q(0109) => [
      q(N'Ko),
      ],
   q(0110) => [
      q(Nushu),
      ],
   q(0111) => [
      q(Ogham),
      ],
   q(0112) => [
      q(Ol Chiki (Ol Cemet, Ol, Santali)),
      q(Ol Chiki),
      q(Ol Cemet'),
      q(Ol),
      q(Santali),
      ],
   q(0113) => [
      q(Old Turkic, Orkhon Runic),
      q(Old Turkic),
      q(Orkhon Runic),
      ],
   q(0114) => [
      q(Oriya),
      ],
   q(0115) => [
      q(Osage),
      ],
   q(0116) => [
      q(Osmanya),
      ],
   q(0117) => [
      q(Palmyrene),
      ],
   q(0118) => [
      q(Pau Cin Hau),
      ],
   q(0119) => [
      q(Old Permic),
      ],
   q(0120) => [
      q(Phags-pa),
      ],
   q(0121) => [
      q(Inscriptional Pahlavi),
      ],
   q(0122) => [
      q(Psalter Pahlavi),
      ],
   q(0123) => [
      q(Book Pahlavi),
      ],
   q(0124) => [
      q(Phoenician),
      ],
   q(0125) => [
      q(Miao (Pollard)),
      q(Miao),
      q(Pollard),
      ],
   q(0126) => [
      q(Inscriptional Parthian),
      ],
   q(0127) => [
      q(Reserved for private use (start)),
      ],
   q(0128) => [
      q(Reserved for private use (end)),
      ],
   q(0129) => [
      q(Rejang (Redjang, Kaganga)),
      q(Rejang),
      q(Redjang),
      q(Kaganga),
      ],
   q(0130) => [
      q(Rongorongo),
      ],
   q(0131) => [
      q(Runic),
      ],
   q(0132) => [
      q(Samaritan),
      ],
   q(0133) => [
      q(Sarati),
      ],
   q(0134) => [
      q(Old South Arabian),
      ],
   q(0135) => [
      q(Saurashtra),
      ],
   q(0136) => [
      q(SignWriting),
      ],
   q(0137) => [
      q(Shavian (Shaw)),
      q(Shavian),
      q(Shaw),
      ],
   q(0138) => [
      q(Sharada, Sarada),
      q(Sharada),
      q(Sarada),
      ],
   q(0139) => [
      q(Siddham, Siddham, Siddhamatrka),
      q(Siddham),
      q(Siddhamatrka),
      ],
   q(0140) => [
      q(Khudawadi, Sindhi),
      q(Khudawadi),
      q(Sindhi),
      ],
   q(0141) => [
      q(Sinhala),
      ],
   q(0142) => [
      q(Sora Sompeng),
      ],
   q(0143) => [
      q(Sundanese),
      ],
   q(0144) => [
      q(Syloti Nagri),
      ],
   q(0145) => [
      q(Syriac),
      ],
   q(0146) => [
      q(Syriac (Estrangelo variant)),
      ],
   q(0147) => [
      q(Syriac (Western variant)),
      ],
   q(0148) => [
      q(Syriac (Eastern variant)),
      ],
   q(0149) => [
      q(Tagbanwa),
      ],
   q(0150) => [
      q(Takri, Takri, Tankri),
      q(Takri),
      q(Tankri),
      ],
   q(0151) => [
      q(Tai Le),
      ],
   q(0152) => [
      q(New Tai Lue),
      ],
   q(0153) => [
      q(Tamil),
      ],
   q(0154) => [
      q(Tangut),
      ],
   q(0155) => [
      q(Tai Viet),
      ],
   q(0156) => [
      q(Telugu),
      ],
   q(0157) => [
      q(Tengwar),
      ],
   q(0158) => [
      q(Tifinagh (Berber)),
      q(Tifinagh),
      q(Berber),
      ],
   q(0159) => [
      q(Tagalog (Baybayin, Alibata)),
      q(Tagalog),
      q(Baybayin),
      q(Alibata),
      ],
   q(0160) => [
      q(Thaana),
      ],
   q(0161) => [
      q(Thai),
      ],
   q(0162) => [
      q(Tibetan),
      ],
   q(0163) => [
      q(Tirhuta),
      ],
   q(0164) => [
      q(Ugaritic),
      ],
   q(0165) => [
      q(Vai),
      ],
   q(0166) => [
      q(Visible Speech),
      ],
   q(0167) => [
      q(Warang Citi (Varang Kshiti)),
      q(Warang Citi),
      q(Varang Kshiti),
      ],
   q(0168) => [
      q(Woleai),
      ],
   q(0169) => [
      q(Old Persian),
      ],
   q(0170) => [
      q(Cuneiform, Sumero-Akkadian),
      q(Sumero-Akkadian cuneiform),
      ],
   q(0171) => [
      q(Yi),
      ],
   q(0172) => [
      q(Code for inherited script),
      ],
   q(0173) => [
      q(Mathematical notation),
      ],
   q(0174) => [
      q(Symbols),
      ],
};

$Locale::Codes::Data{'script'}{'alias2id'} = {
   q('na-'khi ggo-baw) => [
      q(0108),
      q(2),
      ],
   q(adlam) => [
      q(0001),
      q(0),
      ],
   q(afaka) => [
      q(0002),
      q(0),
      ],
   q(ahom) => [
      q(0004),
      q(1),
      ],
   q(ahom, tai ahom) => [
      q(0004),
      q(0),
      ],
   q(alibata) => [
      q(0159),
      q(3),
      ],
   q(anatolian hieroglyphs) => [
      q(0056),
      q(1),
      ],
   q(anatolian hieroglyphs (luwian hieroglyphs, hittite hieroglyphs)) => [
      q(0056),
      q(0),
      ],
   q(ancient north arabian) => [
      q(0106),
      q(2),
      ],
   q(arabic) => [
      q(0005),
      q(0),
      ],
   q(arabic (nastaliq variant)) => [
      q(0006),
      q(0),
      ],
   q(armenian) => [
      q(0008),
      q(0),
      ],
   q(avestan) => [
      q(0009),
      q(0),
      ],
   q(balinese) => [
      q(0010),
      q(0),
      ],
   q(bamum) => [
      q(0011),
      q(0),
      ],
   q(bassa vah) => [
      q(0012),
      q(0),
      ],
   q(batak) => [
      q(0013),
      q(0),
      ],
   q(baybayin) => [
      q(0159),
      q(2),
      ],
   q(bengali) => [
      q(0014),
      q(0),
      ],
   q(berber) => [
      q(0158),
      q(2),
      ],
   q(bhaiksuki) => [
      q(0015),
      q(0),
      ],
   q(blissymbols) => [
      q(0016),
      q(0),
      ],
   q(book pahlavi) => [
      q(0123),
      q(0),
      ],
   q(bopomofo) => [
      q(0017),
      q(0),
      ],
   q(brahmi) => [
      q(0018),
      q(0),
      ],
   q(braille) => [
      q(0019),
      q(0),
      ],
   q(buginese) => [
      q(0020),
      q(0),
      ],
   q(buhid) => [
      q(0021),
      q(0),
      ],
   q(burmese) => [
      q(0105),
      q(2),
      ],
   q(carian) => [
      q(0024),
      q(0),
      ],
   q(caucasian albanian) => [
      q(0003),
      q(0),
      ],
   q(chakma) => [
      q(0022),
      q(0),
      ],
   q(cham) => [
      q(0025),
      q(0),
      ],
   q(cherokee) => [
      q(0026),
      q(0),
      ],
   q(cirth) => [
      q(0027),
      q(0),
      ],
   q(code for inherited script) => [
      q(0172),
      q(0),
      ],
   q(coptic) => [
      q(0028),
      q(0),
      ],
   q(cuneiform, sumero-akkadian) => [
      q(0170),
      q(0),
      ],
   q(cypriot) => [
      q(0029),
      q(0),
      ],
   q(cyrillic) => [
      q(0030),
      q(0),
      ],
   q(cyrillic (old church slavonic variant)) => [
      q(0031),
      q(0),
      ],
   q(deseret) => [
      q(0033),
      q(1),
      ],
   q(deseret (mormon)) => [
      q(0033),
      q(0),
      ],
   q(devanagari) => [
      q(0032),
      q(1),
      ],
   q(devanagari (nagari)) => [
      q(0032),
      q(0),
      ],
   q(duployan shorthand) => [
      q(0034),
      q(1),
      ],
   q(duployan shorthand, duployan stenography) => [
      q(0034),
      q(0),
      ],
   q(duployan stenography) => [
      q(0034),
      q(2),
      ],
   q(egyptian demotic) => [
      q(0035),
      q(0),
      ],
   q(egyptian hieratic) => [
      q(0036),
      q(0),
      ],
   q(egyptian hieroglyphs) => [
      q(0037),
      q(0),
      ],
   q(elbasan) => [
      q(0038),
      q(0),
      ],
   q(ethiopic) => [
      q(0039),
      q(1),
      ],
   q(ethiopic (geez)) => [
      q(0039),
      q(0),
      ],
   q(fraser) => [
      q(0086),
      q(2),
      ],
   q(ge'ez) => [
      q(0039),
      q(2),
      ],
   q(georgian (mkhedruli)) => [
      q(0041),
      q(0),
      ],
   q(glagolitic) => [
      q(0042),
      q(0),
      ],
   q(gothic) => [
      q(0043),
      q(0),
      ],
   q(grantha) => [
      q(0044),
      q(0),
      ],
   q(greek) => [
      q(0045),
      q(0),
      ],
   q(gujarati) => [
      q(0046),
      q(0),
      ],
   q(gurmukhi) => [
      q(0047),
      q(0),
      ],
   q(han) => [
      q(0049),
      q(1),
      ],
   q(han (hanzi, kanji, hanja)) => [
      q(0049),
      q(0),
      ],
   q(han (simplified variant)) => [
      q(0051),
      q(0),
      ],
   q(han (traditional variant)) => [
      q(0052),
      q(0),
      ],
   q(hangeul) => [
      q(0048),
      q(2),
      ],
   q(hangul) => [
      q(0048),
      q(1),
      ],
   q(hangul (hangul, hangeul)) => [
      q(0048),
      q(0),
      ],
   q(hanja) => [
      q(0049),
      q(4),
      ],
   q(hanunoo) => [
      q(0050),
      q(1),
      ],
   q(hanunoo (hanunoo)) => [
      q(0050),
      q(0),
      ],
   q(hanzi) => [
      q(0049),
      q(2),
      ],
   q(harappan) => [
      q(0060),
      q(2),
      ],
   q(hatran) => [
      q(0053),
      q(0),
      ],
   q(hebrew) => [
      q(0054),
      q(0),
      ],
   q(hiragana) => [
      q(0055),
      q(0),
      ],
   q(hittite hieroglyphs) => [
      q(0056),
      q(3),
      ],
   q(hungarian runic) => [
      q(0059),
      q(2),
      ],
   q(imperial aramaic) => [
      q(0007),
      q(0),
      ],
   q(indus) => [
      q(0060),
      q(1),
      ],
   q(indus (harappan)) => [
      q(0060),
      q(0),
      ],
   q(inscriptional pahlavi) => [
      q(0121),
      q(0),
      ],
   q(inscriptional parthian) => [
      q(0126),
      q(0),
      ],
   q(japanese (alias for han + hiragana + katakana)) => [
      q(0063),
      q(0),
      ],
   q(japanese syllabaries (alias for hiragana + katakana)) => [
      q(0058),
      q(0),
      ],
   q(javanese) => [
      q(0062),
      q(0),
      ],
   q(jurchen) => [
      q(0064),
      q(0),
      ],
   q(kaganga) => [
      q(0129),
      q(3),
      ],
   q(kaithi) => [
      q(0075),
      q(0),
      ],
   q(kanji) => [
      q(0049),
      q(3),
      ],
   q(kannada) => [
      q(0072),
      q(0),
      ],
   q(katakana) => [
      q(0066),
      q(0),
      ],
   q(kayah li) => [
      q(0065),
      q(0),
      ],
   q(kharoshthi) => [
      q(0067),
      q(0),
      ],
   q(khitan large script) => [
      q(0070),
      q(0),
      ],
   q(khitan small script) => [
      q(0071),
      q(0),
      ],
   q(khmer) => [
      q(0068),
      q(0),
      ],
   q(khojki) => [
      q(0069),
      q(0),
      ],
   q(khudawadi) => [
      q(0140),
      q(1),
      ],
   q(khudawadi, sindhi) => [
      q(0140),
      q(0),
      ],
   q(khutsuri (asomtavruli and nuskhuri)) => [
      q(0040),
      q(0),
      ],
   q(korean (alias for hangul + han)) => [
      q(0073),
      q(0),
      ],
   q(kpelle) => [
      q(0074),
      q(0),
      ],
   q(lanna) => [
      q(0076),
      q(2),
      ],
   q(lao) => [
      q(0077),
      q(0),
      ],
   q(latin) => [
      q(0080),
      q(0),
      ],
   q(latin (fraktur variant)) => [
      q(0078),
      q(0),
      ],
   q(latin (gaelic variant)) => [
      q(0079),
      q(0),
      ],
   q(leke) => [
      q(0081),
      q(0),
      ],
   q(lepcha) => [
      q(0082),
      q(1),
      ],
   q(lepcha (rong)) => [
      q(0082),
      q(0),
      ],
   q(limbu) => [
      q(0083),
      q(0),
      ],
   q(linear a) => [
      q(0084),
      q(0),
      ],
   q(linear b) => [
      q(0085),
      q(0),
      ],
   q(lisu) => [
      q(0086),
      q(1),
      ],
   q(lisu (fraser)) => [
      q(0086),
      q(0),
      ],
   q(loma) => [
      q(0087),
      q(0),
      ],
   q(luwian hieroglyphs) => [
      q(0056),
      q(2),
      ],
   q(lycian) => [
      q(0088),
      q(0),
      ],
   q(lydian) => [
      q(0089),
      q(0),
      ],
   q(mahajani) => [
      q(0090),
      q(0),
      ],
   q(malayalam) => [
      q(0098),
      q(0),
      ],
   q(mandaean) => [
      q(0091),
      q(2),
      ],
   q(mandaic) => [
      q(0091),
      q(1),
      ],
   q(mandaic, mandaean) => [
      q(0091),
      q(0),
      ],
   q(manichaean) => [
      q(0092),
      q(0),
      ],
   q(marchen) => [
      q(0093),
      q(0),
      ],
   q(mathematical notation) => [
      q(0173),
      q(0),
      ],
   q(mayan hieroglyphs) => [
      q(0094),
      q(0),
      ],
   q(meetei) => [
      q(0103),
      q(3),
      ],
   q(meitei mayek) => [
      q(0103),
      q(1),
      ],
   q(meitei mayek (meithei, meetei)) => [
      q(0103),
      q(0),
      ],
   q(meithei) => [
      q(0103),
      q(2),
      ],
   q(mende kikakui) => [
      q(0095),
      q(0),
      ],
   q(meroitic cursive) => [
      q(0096),
      q(0),
      ],
   q(meroitic hieroglyphs) => [
      q(0097),
      q(0),
      ],
   q(miao) => [
      q(0125),
      q(1),
      ],
   q(miao (pollard)) => [
      q(0125),
      q(0),
      ],
   q(modi) => [
      q(0099),
      q(1),
      ],
   q(modi, modi) => [
      q(0099),
      q(0),
      ],
   q(mongolian) => [
      q(0100),
      q(0),
      ],
   q(moon) => [
      q(0101),
      q(1),
      ],
   q(moon (moon code, moon script, moon type)) => [
      q(0101),
      q(0),
      ],
   q(moon code) => [
      q(0101),
      q(2),
      ],
   q(moon script) => [
      q(0101),
      q(3),
      ],
   q(moon type) => [
      q(0101),
      q(4),
      ],
   q(mormon) => [
      q(0033),
      q(2),
      ],
   q(mro) => [
      q(0102),
      q(1),
      ],
   q(mro, mru) => [
      q(0102),
      q(0),
      ],
   q(mru) => [
      q(0102),
      q(2),
      ],
   q(multani) => [
      q(0104),
      q(0),
      ],
   q(myanmar) => [
      q(0105),
      q(1),
      ],
   q(myanmar (burmese)) => [
      q(0105),
      q(0),
      ],
   q(n'ko) => [
      q(0109),
      q(0),
      ],
   q(nabataean) => [
      q(0107),
      q(0),
      ],
   q(nagari) => [
      q(0032),
      q(2),
      ],
   q(nakhi geba) => [
      q(0108),
      q(1),
      ],
   q(nakhi geba ('na-'khi ggo-baw, naxi geba)) => [
      q(0108),
      q(0),
      ],
   q(naxi geba) => [
      q(0108),
      q(3),
      ],
   q(new tai lue) => [
      q(0152),
      q(0),
      ],
   q(nushu) => [
      q(0110),
      q(0),
      ],
   q(ogham) => [
      q(0111),
      q(0),
      ],
   q(ol) => [
      q(0112),
      q(3),
      ],
   q(ol cemet') => [
      q(0112),
      q(2),
      ],
   q(ol chiki) => [
      q(0112),
      q(1),
      ],
   q(ol chiki (ol cemet, ol, santali)) => [
      q(0112),
      q(0),
      ],
   q(old hungarian) => [
      q(0059),
      q(1),
      ],
   q(old hungarian (hungarian runic)) => [
      q(0059),
      q(0),
      ],
   q(old italic (etruscan, oscan, etc.)) => [
      q(0061),
      q(0),
      ],
   q(old north arabian) => [
      q(0106),
      q(1),
      ],
   q(old north arabian (ancient north arabian)) => [
      q(0106),
      q(0),
      ],
   q(old permic) => [
      q(0119),
      q(0),
      ],
   q(old persian) => [
      q(0169),
      q(0),
      ],
   q(old south arabian) => [
      q(0134),
      q(0),
      ],
   q(old turkic) => [
      q(0113),
      q(1),
      ],
   q(old turkic, orkhon runic) => [
      q(0113),
      q(0),
      ],
   q(oriya) => [
      q(0114),
      q(0),
      ],
   q(orkhon runic) => [
      q(0113),
      q(2),
      ],
   q(osage) => [
      q(0115),
      q(0),
      ],
   q(osmanya) => [
      q(0116),
      q(0),
      ],
   q(pahawh hmong) => [
      q(0057),
      q(0),
      ],
   q(palmyrene) => [
      q(0117),
      q(0),
      ],
   q(pau cin hau) => [
      q(0118),
      q(0),
      ],
   q(phags-pa) => [
      q(0120),
      q(0),
      ],
   q(phoenician) => [
      q(0124),
      q(0),
      ],
   q(pollard) => [
      q(0125),
      q(2),
      ],
   q(psalter pahlavi) => [
      q(0122),
      q(0),
      ],
   q(redjang) => [
      q(0129),
      q(2),
      ],
   q(rejang) => [
      q(0129),
      q(1),
      ],
   q(rejang (redjang, kaganga)) => [
      q(0129),
      q(0),
      ],
   q(reserved for private use (end)) => [
      q(0128),
      q(0),
      ],
   q(reserved for private use (start)) => [
      q(0127),
      q(0),
      ],
   q(rong) => [
      q(0082),
      q(2),
      ],
   q(rongorongo) => [
      q(0130),
      q(0),
      ],
   q(runic) => [
      q(0131),
      q(0),
      ],
   q(samaritan) => [
      q(0132),
      q(0),
      ],
   q(santali) => [
      q(0112),
      q(4),
      ],
   q(sarada) => [
      q(0138),
      q(2),
      ],
   q(sarati) => [
      q(0133),
      q(0),
      ],
   q(saurashtra) => [
      q(0135),
      q(0),
      ],
   q(sharada) => [
      q(0138),
      q(1),
      ],
   q(sharada, sarada) => [
      q(0138),
      q(0),
      ],
   q(shavian) => [
      q(0137),
      q(1),
      ],
   q(shavian (shaw)) => [
      q(0137),
      q(0),
      ],
   q(shaw) => [
      q(0137),
      q(2),
      ],
   q(siddham) => [
      q(0139),
      q(1),
      ],
   q(siddham, siddham, siddhamatrka) => [
      q(0139),
      q(0),
      ],
   q(siddhamatrka) => [
      q(0139),
      q(2),
      ],
   q(signwriting) => [
      q(0136),
      q(0),
      ],
   q(sindhi) => [
      q(0140),
      q(2),
      ],
   q(sinhala) => [
      q(0141),
      q(0),
      ],
   q(sora sompeng) => [
      q(0142),
      q(0),
      ],
   q(sumero-akkadian cuneiform) => [
      q(0170),
      q(1),
      ],
   q(sundanese) => [
      q(0143),
      q(0),
      ],
   q(syloti nagri) => [
      q(0144),
      q(0),
      ],
   q(symbols) => [
      q(0174),
      q(0),
      ],
   q(syriac) => [
      q(0145),
      q(0),
      ],
   q(syriac (eastern variant)) => [
      q(0148),
      q(0),
      ],
   q(syriac (estrangelo variant)) => [
      q(0146),
      q(0),
      ],
   q(syriac (western variant)) => [
      q(0147),
      q(0),
      ],
   q(tagalog) => [
      q(0159),
      q(1),
      ],
   q(tagalog (baybayin, alibata)) => [
      q(0159),
      q(0),
      ],
   q(tagbanwa) => [
      q(0149),
      q(0),
      ],
   q(tai ahom) => [
      q(0004),
      q(2),
      ],
   q(tai le) => [
      q(0151),
      q(0),
      ],
   q(tai tham) => [
      q(0076),
      q(1),
      ],
   q(tai tham (lanna)) => [
      q(0076),
      q(0),
      ],
   q(tai viet) => [
      q(0155),
      q(0),
      ],
   q(takri) => [
      q(0150),
      q(1),
      ],
   q(takri, takri, tankri) => [
      q(0150),
      q(0),
      ],
   q(tamil) => [
      q(0153),
      q(0),
      ],
   q(tangut) => [
      q(0154),
      q(0),
      ],
   q(tankri) => [
      q(0150),
      q(2),
      ],
   q(telugu) => [
      q(0156),
      q(0),
      ],
   q(tengwar) => [
      q(0157),
      q(0),
      ],
   q(thaana) => [
      q(0160),
      q(0),
      ],
   q(thai) => [
      q(0161),
      q(0),
      ],
   q(tibetan) => [
      q(0162),
      q(0),
      ],
   q(tifinagh) => [
      q(0158),
      q(1),
      ],
   q(tifinagh (berber)) => [
      q(0158),
      q(0),
      ],
   q(tirhuta) => [
      q(0163),
      q(0),
      ],
   q(ugaritic) => [
      q(0164),
      q(0),
      ],
   q(unified canadian aboriginal syllabics) => [
      q(0023),
      q(0),
      ],
   q(vai) => [
      q(0165),
      q(0),
      ],
   q(varang kshiti) => [
      q(0167),
      q(2),
      ],
   q(visible speech) => [
      q(0166),
      q(0),
      ],
   q(warang citi) => [
      q(0167),
      q(1),
      ],
   q(warang citi (varang kshiti)) => [
      q(0167),
      q(0),
      ],
   q(woleai) => [
      q(0168),
      q(0),
      ],
   q(yi) => [
      q(0171),
      q(0),
      ],
};

$Locale::Codes::Data{'script'}{'code2id'} = {
   q(alpha) => {
      q(Adlm) => [
         q(0001),
         q(0),
         ],
      q(Afak) => [
         q(0002),
         q(0),
         ],
      q(Aghb) => [
         q(0003),
         q(0),
         ],
      q(Ahom) => [
         q(0004),
         q(1),
         ],
      q(Arab) => [
         q(0005),
         q(0),
         ],
      q(Aran) => [
         q(0006),
         q(0),
         ],
      q(Armi) => [
         q(0007),
         q(0),
         ],
      q(Armn) => [
         q(0008),
         q(0),
         ],
      q(Avst) => [
         q(0009),
         q(0),
         ],
      q(Bali) => [
         q(0010),
         q(0),
         ],
      q(Bamu) => [
         q(0011),
         q(0),
         ],
      q(Bass) => [
         q(0012),
         q(0),
         ],
      q(Batk) => [
         q(0013),
         q(0),
         ],
      q(Beng) => [
         q(0014),
         q(0),
         ],
      q(Bhks) => [
         q(0015),
         q(0),
         ],
      q(Blis) => [
         q(0016),
         q(0),
         ],
      q(Bopo) => [
         q(0017),
         q(0),
         ],
      q(Brah) => [
         q(0018),
         q(0),
         ],
      q(Brai) => [
         q(0019),
         q(0),
         ],
      q(Bugi) => [
         q(0020),
         q(0),
         ],
      q(Buhd) => [
         q(0021),
         q(0),
         ],
      q(Cakm) => [
         q(0022),
         q(0),
         ],
      q(Cans) => [
         q(0023),
         q(0),
         ],
      q(Cari) => [
         q(0024),
         q(0),
         ],
      q(Cham) => [
         q(0025),
         q(0),
         ],
      q(Cher) => [
         q(0026),
         q(0),
         ],
      q(Cirt) => [
         q(0027),
         q(0),
         ],
      q(Copt) => [
         q(0028),
         q(0),
         ],
      q(Cprt) => [
         q(0029),
         q(0),
         ],
      q(Cyrl) => [
         q(0030),
         q(0),
         ],
      q(Cyrs) => [
         q(0031),
         q(0),
         ],
      q(Deva) => [
         q(0032),
         q(1),
         ],
      q(Dsrt) => [
         q(0033),
         q(1),
         ],
      q(Dupl) => [
         q(0034),
         q(1),
         ],
      q(Egyd) => [
         q(0035),
         q(0),
         ],
      q(Egyh) => [
         q(0036),
         q(0),
         ],
      q(Egyp) => [
         q(0037),
         q(0),
         ],
      q(Elba) => [
         q(0038),
         q(0),
         ],
      q(Ethi) => [
         q(0039),
         q(1),
         ],
      q(Geok) => [
         q(0040),
         q(0),
         ],
      q(Geor) => [
         q(0041),
         q(0),
         ],
      q(Glag) => [
         q(0042),
         q(0),
         ],
      q(Goth) => [
         q(0043),
         q(0),
         ],
      q(Gran) => [
         q(0044),
         q(0),
         ],
      q(Grek) => [
         q(0045),
         q(0),
         ],
      q(Gujr) => [
         q(0046),
         q(0),
         ],
      q(Guru) => [
         q(0047),
         q(0),
         ],
      q(Hang) => [
         q(0048),
         q(1),
         ],
      q(Hani) => [
         q(0049),
         q(1),
         ],
      q(Hano) => [
         q(0050),
         q(1),
         ],
      q(Hans) => [
         q(0051),
         q(0),
         ],
      q(Hant) => [
         q(0052),
         q(0),
         ],
      q(Hatr) => [
         q(0053),
         q(0),
         ],
      q(Hebr) => [
         q(0054),
         q(0),
         ],
      q(Hira) => [
         q(0055),
         q(0),
         ],
      q(Hluw) => [
         q(0056),
         q(1),
         ],
      q(Hmng) => [
         q(0057),
         q(0),
         ],
      q(Hrkt) => [
         q(0058),
         q(0),
         ],
      q(Hung) => [
         q(0059),
         q(1),
         ],
      q(Inds) => [
         q(0060),
         q(1),
         ],
      q(Ital) => [
         q(0061),
         q(0),
         ],
      q(Java) => [
         q(0062),
         q(0),
         ],
      q(Jpan) => [
         q(0063),
         q(0),
         ],
      q(Jurc) => [
         q(0064),
         q(0),
         ],
      q(Kali) => [
         q(0065),
         q(0),
         ],
      q(Kana) => [
         q(0066),
         q(0),
         ],
      q(Khar) => [
         q(0067),
         q(0),
         ],
      q(Khmr) => [
         q(0068),
         q(0),
         ],
      q(Khoj) => [
         q(0069),
         q(0),
         ],
      q(Kitl) => [
         q(0070),
         q(0),
         ],
      q(Kits) => [
         q(0071),
         q(0),
         ],
      q(Knda) => [
         q(0072),
         q(0),
         ],
      q(Kore) => [
         q(0073),
         q(0),
         ],
      q(Kpel) => [
         q(0074),
         q(0),
         ],
      q(Kthi) => [
         q(0075),
         q(0),
         ],
      q(Lana) => [
         q(0076),
         q(1),
         ],
      q(Laoo) => [
         q(0077),
         q(0),
         ],
      q(Latf) => [
         q(0078),
         q(0),
         ],
      q(Latg) => [
         q(0079),
         q(0),
         ],
      q(Latn) => [
         q(0080),
         q(0),
         ],
      q(Leke) => [
         q(0081),
         q(0),
         ],
      q(Lepc) => [
         q(0082),
         q(1),
         ],
      q(Limb) => [
         q(0083),
         q(0),
         ],
      q(Lina) => [
         q(0084),
         q(0),
         ],
      q(Linb) => [
         q(0085),
         q(0),
         ],
      q(Lisu) => [
         q(0086),
         q(1),
         ],
      q(Loma) => [
         q(0087),
         q(0),
         ],
      q(Lyci) => [
         q(0088),
         q(0),
         ],
      q(Lydi) => [
         q(0089),
         q(0),
         ],
      q(Mahj) => [
         q(0090),
         q(0),
         ],
      q(Mand) => [
         q(0091),
         q(1),
         ],
      q(Mani) => [
         q(0092),
         q(0),
         ],
      q(Marc) => [
         q(0093),
         q(0),
         ],
      q(Maya) => [
         q(0094),
         q(0),
         ],
      q(Mend) => [
         q(0095),
         q(0),
         ],
      q(Merc) => [
         q(0096),
         q(0),
         ],
      q(Mero) => [
         q(0097),
         q(0),
         ],
      q(Mlym) => [
         q(0098),
         q(0),
         ],
      q(Modi) => [
         q(0099),
         q(1),
         ],
      q(Mong) => [
         q(0100),
         q(0),
         ],
      q(Moon) => [
         q(0101),
         q(1),
         ],
      q(Mroo) => [
         q(0102),
         q(1),
         ],
      q(Mtei) => [
         q(0103),
         q(1),
         ],
      q(Mult) => [
         q(0104),
         q(0),
         ],
      q(Mymr) => [
         q(0105),
         q(1),
         ],
      q(Narb) => [
         q(0106),
         q(1),
         ],
      q(Nbat) => [
         q(0107),
         q(0),
         ],
      q(Nkgb) => [
         q(0108),
         q(1),
         ],
      q(Nkoo) => [
         q(0109),
         q(0),
         ],
      q(Nshu) => [
         q(0110),
         q(0),
         ],
      q(Ogam) => [
         q(0111),
         q(0),
         ],
      q(Olck) => [
         q(0112),
         q(1),
         ],
      q(Orkh) => [
         q(0113),
         q(1),
         ],
      q(Orya) => [
         q(0114),
         q(0),
         ],
      q(Osge) => [
         q(0115),
         q(0),
         ],
      q(Osma) => [
         q(0116),
         q(0),
         ],
      q(Palm) => [
         q(0117),
         q(0),
         ],
      q(Pauc) => [
         q(0118),
         q(0),
         ],
      q(Perm) => [
         q(0119),
         q(0),
         ],
      q(Phag) => [
         q(0120),
         q(0),
         ],
      q(Phli) => [
         q(0121),
         q(0),
         ],
      q(Phlp) => [
         q(0122),
         q(0),
         ],
      q(Phlv) => [
         q(0123),
         q(0),
         ],
      q(Phnx) => [
         q(0124),
         q(0),
         ],
      q(Plrd) => [
         q(0125),
         q(1),
         ],
      q(Prti) => [
         q(0126),
         q(0),
         ],
      q(Qaaa) => [
         q(0127),
         q(0),
         ],
      q(Qabx) => [
         q(0128),
         q(0),
         ],
      q(Rjng) => [
         q(0129),
         q(1),
         ],
      q(Roro) => [
         q(0130),
         q(0),
         ],
      q(Runr) => [
         q(0131),
         q(0),
         ],
      q(Samr) => [
         q(0132),
         q(0),
         ],
      q(Sara) => [
         q(0133),
         q(0),
         ],
      q(Sarb) => [
         q(0134),
         q(0),
         ],
      q(Saur) => [
         q(0135),
         q(0),
         ],
      q(Sgnw) => [
         q(0136),
         q(0),
         ],
      q(Shaw) => [
         q(0137),
         q(1),
         ],
      q(Shrd) => [
         q(0138),
         q(1),
         ],
      q(Sidd) => [
         q(0139),
         q(1),
         ],
      q(Sind) => [
         q(0140),
         q(1),
         ],
      q(Sinh) => [
         q(0141),
         q(0),
         ],
      q(Sora) => [
         q(0142),
         q(0),
         ],
      q(Sund) => [
         q(0143),
         q(0),
         ],
      q(Sylo) => [
         q(0144),
         q(0),
         ],
      q(Syrc) => [
         q(0145),
         q(0),
         ],
      q(Syre) => [
         q(0146),
         q(0),
         ],
      q(Syrj) => [
         q(0147),
         q(0),
         ],
      q(Syrn) => [
         q(0148),
         q(0),
         ],
      q(Tagb) => [
         q(0149),
         q(0),
         ],
      q(Takr) => [
         q(0150),
         q(1),
         ],
      q(Tale) => [
         q(0151),
         q(0),
         ],
      q(Talu) => [
         q(0152),
         q(0),
         ],
      q(Taml) => [
         q(0153),
         q(0),
         ],
      q(Tang) => [
         q(0154),
         q(0),
         ],
      q(Tavt) => [
         q(0155),
         q(0),
         ],
      q(Telu) => [
         q(0156),
         q(0),
         ],
      q(Teng) => [
         q(0157),
         q(0),
         ],
      q(Tfng) => [
         q(0158),
         q(1),
         ],
      q(Tglg) => [
         q(0159),
         q(1),
         ],
      q(Thaa) => [
         q(0160),
         q(0),
         ],
      q(Thai) => [
         q(0161),
         q(0),
         ],
      q(Tibt) => [
         q(0162),
         q(0),
         ],
      q(Tirh) => [
         q(0163),
         q(0),
         ],
      q(Ugar) => [
         q(0164),
         q(0),
         ],
      q(Vaii) => [
         q(0165),
         q(0),
         ],
      q(Visp) => [
         q(0166),
         q(0),
         ],
      q(Wara) => [
         q(0167),
         q(1),
         ],
      q(Wole) => [
         q(0168),
         q(0),
         ],
      q(Xpeo) => [
         q(0169),
         q(0),
         ],
      q(Xsux) => [
         q(0170),
         q(1),
         ],
      q(Yiii) => [
         q(0171),
         q(0),
         ],
      q(Zinh) => [
         q(0172),
         q(0),
         ],
      q(Zmth) => [
         q(0173),
         q(0),
         ],
      q(Zsym) => [
         q(0174),
         q(0),
         ],
      },
   q(num) => {
      q(020) => [
         q(0170),
         q(0),
         ],
      q(030) => [
         q(0169),
         q(0),
         ],
      q(040) => [
         q(0164),
         q(0),
         ],
      q(050) => [
         q(0037),
         q(0),
         ],
      q(060) => [
         q(0036),
         q(0),
         ],
      q(070) => [
         q(0035),
         q(0),
         ],
      q(080) => [
         q(0056),
         q(0),
         ],
      q(090) => [
         q(0094),
         q(0),
         ],
      q(095) => [
         q(0136),
         q(0),
         ],
      q(100) => [
         q(0097),
         q(0),
         ],
      q(101) => [
         q(0096),
         q(0),
         ],
      q(105) => [
         q(0134),
         q(0),
         ],
      q(106) => [
         q(0106),
         q(0),
         ],
      q(115) => [
         q(0124),
         q(0),
         ],
      q(116) => [
         q(0089),
         q(0),
         ],
      q(120) => [
         q(0158),
         q(0),
         ],
      q(123) => [
         q(0132),
         q(0),
         ],
      q(124) => [
         q(0007),
         q(0),
         ],
      q(125) => [
         q(0054),
         q(0),
         ],
      q(126) => [
         q(0117),
         q(0),
         ],
      q(127) => [
         q(0053),
         q(0),
         ],
      q(130) => [
         q(0126),
         q(0),
         ],
      q(131) => [
         q(0121),
         q(0),
         ],
      q(132) => [
         q(0122),
         q(0),
         ],
      q(133) => [
         q(0123),
         q(0),
         ],
      q(134) => [
         q(0009),
         q(0),
         ],
      q(135) => [
         q(0145),
         q(0),
         ],
      q(136) => [
         q(0148),
         q(0),
         ],
      q(137) => [
         q(0147),
         q(0),
         ],
      q(138) => [
         q(0146),
         q(0),
         ],
      q(139) => [
         q(0092),
         q(0),
         ],
      q(140) => [
         q(0091),
         q(0),
         ],
      q(145) => [
         q(0100),
         q(0),
         ],
      q(159) => [
         q(0107),
         q(0),
         ],
      q(160) => [
         q(0005),
         q(0),
         ],
      q(161) => [
         q(0006),
         q(0),
         ],
      q(165) => [
         q(0109),
         q(0),
         ],
      q(166) => [
         q(0001),
         q(0),
         ],
      q(170) => [
         q(0160),
         q(0),
         ],
      q(175) => [
         q(0113),
         q(0),
         ],
      q(176) => [
         q(0059),
         q(0),
         ],
      q(199) => [
         q(0102),
         q(0),
         ],
      q(200) => [
         q(0045),
         q(0),
         ],
      q(201) => [
         q(0024),
         q(0),
         ],
      q(202) => [
         q(0088),
         q(0),
         ],
      q(204) => [
         q(0028),
         q(0),
         ],
      q(206) => [
         q(0043),
         q(0),
         ],
      q(210) => [
         q(0061),
         q(0),
         ],
      q(211) => [
         q(0131),
         q(0),
         ],
      q(212) => [
         q(0111),
         q(0),
         ],
      q(215) => [
         q(0080),
         q(0),
         ],
      q(216) => [
         q(0079),
         q(0),
         ],
      q(217) => [
         q(0078),
         q(0),
         ],
      q(218) => [
         q(0101),
         q(0),
         ],
      q(219) => [
         q(0115),
         q(0),
         ],
      q(220) => [
         q(0030),
         q(0),
         ],
      q(221) => [
         q(0031),
         q(0),
         ],
      q(225) => [
         q(0042),
         q(0),
         ],
      q(226) => [
         q(0038),
         q(0),
         ],
      q(227) => [
         q(0119),
         q(0),
         ],
      q(230) => [
         q(0008),
         q(0),
         ],
      q(239) => [
         q(0003),
         q(0),
         ],
      q(240) => [
         q(0041),
         q(0),
         ],
      q(241) => [
         q(0040),
         q(0),
         ],
      q(250) => [
         q(0033),
         q(0),
         ],
      q(259) => [
         q(0012),
         q(0),
         ],
      q(260) => [
         q(0116),
         q(0),
         ],
      q(261) => [
         q(0112),
         q(0),
         ],
      q(262) => [
         q(0167),
         q(0),
         ],
      q(263) => [
         q(0118),
         q(0),
         ],
      q(280) => [
         q(0166),
         q(0),
         ],
      q(281) => [
         q(0137),
         q(0),
         ],
      q(282) => [
         q(0125),
         q(0),
         ],
      q(285) => [
         q(0017),
         q(0),
         ],
      q(286) => [
         q(0048),
         q(0),
         ],
      q(287) => [
         q(0073),
         q(0),
         ],
      q(288) => [
         q(0071),
         q(0),
         ],
      q(290) => [
         q(0157),
         q(0),
         ],
      q(291) => [
         q(0027),
         q(0),
         ],
      q(292) => [
         q(0133),
         q(0),
         ],
      q(300) => [
         q(0018),
         q(0),
         ],
      q(302) => [
         q(0139),
         q(0),
         ],
      q(305) => [
         q(0067),
         q(0),
         ],
      q(310) => [
         q(0047),
         q(0),
         ],
      q(314) => [
         q(0090),
         q(0),
         ],
      q(315) => [
         q(0032),
         q(0),
         ],
      q(316) => [
         q(0144),
         q(0),
         ],
      q(317) => [
         q(0075),
         q(0),
         ],
      q(318) => [
         q(0140),
         q(0),
         ],
      q(319) => [
         q(0138),
         q(0),
         ],
      q(320) => [
         q(0046),
         q(0),
         ],
      q(321) => [
         q(0150),
         q(0),
         ],
      q(322) => [
         q(0069),
         q(0),
         ],
      q(323) => [
         q(0104),
         q(0),
         ],
      q(324) => [
         q(0099),
         q(0),
         ],
      q(325) => [
         q(0014),
         q(0),
         ],
      q(326) => [
         q(0163),
         q(0),
         ],
      q(327) => [
         q(0114),
         q(0),
         ],
      q(330) => [
         q(0162),
         q(0),
         ],
      q(331) => [
         q(0120),
         q(0),
         ],
      q(332) => [
         q(0093),
         q(0),
         ],
      q(334) => [
         q(0015),
         q(0),
         ],
      q(335) => [
         q(0082),
         q(0),
         ],
      q(336) => [
         q(0083),
         q(0),
         ],
      q(337) => [
         q(0103),
         q(0),
         ],
      q(338) => [
         q(0004),
         q(0),
         ],
      q(340) => [
         q(0156),
         q(0),
         ],
      q(343) => [
         q(0044),
         q(0),
         ],
      q(344) => [
         q(0135),
         q(0),
         ],
      q(345) => [
         q(0072),
         q(0),
         ],
      q(346) => [
         q(0153),
         q(0),
         ],
      q(347) => [
         q(0098),
         q(0),
         ],
      q(348) => [
         q(0141),
         q(0),
         ],
      q(349) => [
         q(0022),
         q(0),
         ],
      q(350) => [
         q(0105),
         q(0),
         ],
      q(351) => [
         q(0076),
         q(0),
         ],
      q(352) => [
         q(0161),
         q(0),
         ],
      q(353) => [
         q(0151),
         q(0),
         ],
      q(354) => [
         q(0152),
         q(0),
         ],
      q(355) => [
         q(0068),
         q(0),
         ],
      q(356) => [
         q(0077),
         q(0),
         ],
      q(357) => [
         q(0065),
         q(0),
         ],
      q(358) => [
         q(0025),
         q(0),
         ],
      q(359) => [
         q(0155),
         q(0),
         ],
      q(360) => [
         q(0010),
         q(0),
         ],
      q(361) => [
         q(0062),
         q(0),
         ],
      q(362) => [
         q(0143),
         q(0),
         ],
      q(363) => [
         q(0129),
         q(0),
         ],
      q(364) => [
         q(0081),
         q(0),
         ],
      q(365) => [
         q(0013),
         q(0),
         ],
      q(367) => [
         q(0020),
         q(0),
         ],
      q(370) => [
         q(0159),
         q(0),
         ],
      q(371) => [
         q(0050),
         q(0),
         ],
      q(372) => [
         q(0021),
         q(0),
         ],
      q(373) => [
         q(0149),
         q(0),
         ],
      q(398) => [
         q(0142),
         q(0),
         ],
      q(399) => [
         q(0086),
         q(0),
         ],
      q(400) => [
         q(0084),
         q(0),
         ],
      q(401) => [
         q(0085),
         q(0),
         ],
      q(403) => [
         q(0029),
         q(0),
         ],
      q(410) => [
         q(0055),
         q(0),
         ],
      q(411) => [
         q(0066),
         q(0),
         ],
      q(412) => [
         q(0058),
         q(0),
         ],
      q(413) => [
         q(0063),
         q(0),
         ],
      q(420) => [
         q(0108),
         q(0),
         ],
      q(430) => [
         q(0039),
         q(0),
         ],
      q(435) => [
         q(0011),
         q(0),
         ],
      q(436) => [
         q(0074),
         q(0),
         ],
      q(437) => [
         q(0087),
         q(0),
         ],
      q(438) => [
         q(0095),
         q(0),
         ],
      q(439) => [
         q(0002),
         q(0),
         ],
      q(440) => [
         q(0023),
         q(0),
         ],
      q(445) => [
         q(0026),
         q(0),
         ],
      q(450) => [
         q(0057),
         q(0),
         ],
      q(460) => [
         q(0171),
         q(0),
         ],
      q(470) => [
         q(0165),
         q(0),
         ],
      q(480) => [
         q(0168),
         q(0),
         ],
      q(499) => [
         q(0110),
         q(0),
         ],
      q(500) => [
         q(0049),
         q(0),
         ],
      q(501) => [
         q(0051),
         q(0),
         ],
      q(502) => [
         q(0052),
         q(0),
         ],
      q(505) => [
         q(0070),
         q(0),
         ],
      q(510) => [
         q(0064),
         q(0),
         ],
      q(520) => [
         q(0154),
         q(0),
         ],
      q(550) => [
         q(0016),
         q(0),
         ],
      q(570) => [
         q(0019),
         q(0),
         ],
      q(610) => [
         q(0060),
         q(0),
         ],
      q(620) => [
         q(0130),
         q(0),
         ],
      q(755) => [
         q(0034),
         q(0),
         ],
      q(900) => [
         q(0127),
         q(0),
         ],
      q(949) => [
         q(0128),
         q(0),
         ],
      q(994) => [
         q(0172),
         q(0),
         ],
      q(995) => [
         q(0173),
         q(0),
         ],
      q(996) => [
         q(0174),
         q(0),
         ],
      },
};

$Locale::Codes::Data{'script'}{'id2code'} = {
   q(alpha) => {
      q(0001) => q(Adlm),
      q(0002) => q(Afak),
      q(0003) => q(Aghb),
      q(0004) => q(Ahom),
      q(0005) => q(Arab),
      q(0006) => q(Aran),
      q(0007) => q(Armi),
      q(0008) => q(Armn),
      q(0009) => q(Avst),
      q(0010) => q(Bali),
      q(0011) => q(Bamu),
      q(0012) => q(Bass),
      q(0013) => q(Batk),
      q(0014) => q(Beng),
      q(0015) => q(Bhks),
      q(0016) => q(Blis),
      q(0017) => q(Bopo),
      q(0018) => q(Brah),
      q(0019) => q(Brai),
      q(0020) => q(Bugi),
      q(0021) => q(Buhd),
      q(0022) => q(Cakm),
      q(0023) => q(Cans),
      q(0024) => q(Cari),
      q(0025) => q(Cham),
      q(0026) => q(Cher),
      q(0027) => q(Cirt),
      q(0028) => q(Copt),
      q(0029) => q(Cprt),
      q(0030) => q(Cyrl),
      q(0031) => q(Cyrs),
      q(0032) => q(Deva),
      q(0033) => q(Dsrt),
      q(0034) => q(Dupl),
      q(0035) => q(Egyd),
      q(0036) => q(Egyh),
      q(0037) => q(Egyp),
      q(0038) => q(Elba),
      q(0039) => q(Ethi),
      q(0040) => q(Geok),
      q(0041) => q(Geor),
      q(0042) => q(Glag),
      q(0043) => q(Goth),
      q(0044) => q(Gran),
      q(0045) => q(Grek),
      q(0046) => q(Gujr),
      q(0047) => q(Guru),
      q(0048) => q(Hang),
      q(0049) => q(Hani),
      q(0050) => q(Hano),
      q(0051) => q(Hans),
      q(0052) => q(Hant),
      q(0053) => q(Hatr),
      q(0054) => q(Hebr),
      q(0055) => q(Hira),
      q(0056) => q(Hluw),
      q(0057) => q(Hmng),
      q(0058) => q(Hrkt),
      q(0059) => q(Hung),
      q(0060) => q(Inds),
      q(0061) => q(Ital),
      q(0062) => q(Java),
      q(0063) => q(Jpan),
      q(0064) => q(Jurc),
      q(0065) => q(Kali),
      q(0066) => q(Kana),
      q(0067) => q(Khar),
      q(0068) => q(Khmr),
      q(0069) => q(Khoj),
      q(0070) => q(Kitl),
      q(0071) => q(Kits),
      q(0072) => q(Knda),
      q(0073) => q(Kore),
      q(0074) => q(Kpel),
      q(0075) => q(Kthi),
      q(0076) => q(Lana),
      q(0077) => q(Laoo),
      q(0078) => q(Latf),
      q(0079) => q(Latg),
      q(0080) => q(Latn),
      q(0081) => q(Leke),
      q(0082) => q(Lepc),
      q(0083) => q(Limb),
      q(0084) => q(Lina),
      q(0085) => q(Linb),
      q(0086) => q(Lisu),
      q(0087) => q(Loma),
      q(0088) => q(Lyci),
      q(0089) => q(Lydi),
      q(0090) => q(Mahj),
      q(0091) => q(Mand),
      q(0092) => q(Mani),
      q(0093) => q(Marc),
      q(0094) => q(Maya),
      q(0095) => q(Mend),
      q(0096) => q(Merc),
      q(0097) => q(Mero),
      q(0098) => q(Mlym),
      q(0099) => q(Modi),
      q(0100) => q(Mong),
      q(0101) => q(Moon),
      q(0102) => q(Mroo),
      q(0103) => q(Mtei),
      q(0104) => q(Mult),
      q(0105) => q(Mymr),
      q(0106) => q(Narb),
      q(0107) => q(Nbat),
      q(0108) => q(Nkgb),
      q(0109) => q(Nkoo),
      q(0110) => q(Nshu),
      q(0111) => q(Ogam),
      q(0112) => q(Olck),
      q(0113) => q(Orkh),
      q(0114) => q(Orya),
      q(0115) => q(Osge),
      q(0116) => q(Osma),
      q(0117) => q(Palm),
      q(0118) => q(Pauc),
      q(0119) => q(Perm),
      q(0120) => q(Phag),
      q(0121) => q(Phli),
      q(0122) => q(Phlp),
      q(0123) => q(Phlv),
      q(0124) => q(Phnx),
      q(0125) => q(Plrd),
      q(0126) => q(Prti),
      q(0127) => q(Qaaa),
      q(0128) => q(Qabx),
      q(0129) => q(Rjng),
      q(0130) => q(Roro),
      q(0131) => q(Runr),
      q(0132) => q(Samr),
      q(0133) => q(Sara),
      q(0134) => q(Sarb),
      q(0135) => q(Saur),
      q(0136) => q(Sgnw),
      q(0137) => q(Shaw),
      q(0138) => q(Shrd),
      q(0139) => q(Sidd),
      q(0140) => q(Sind),
      q(0141) => q(Sinh),
      q(0142) => q(Sora),
      q(0143) => q(Sund),
      q(0144) => q(Sylo),
      q(0145) => q(Syrc),
      q(0146) => q(Syre),
      q(0147) => q(Syrj),
      q(0148) => q(Syrn),
      q(0149) => q(Tagb),
      q(0150) => q(Takr),
      q(0151) => q(Tale),
      q(0152) => q(Talu),
      q(0153) => q(Taml),
      q(0154) => q(Tang),
      q(0155) => q(Tavt),
      q(0156) => q(Telu),
      q(0157) => q(Teng),
      q(0158) => q(Tfng),
      q(0159) => q(Tglg),
      q(0160) => q(Thaa),
      q(0161) => q(Thai),
      q(0162) => q(Tibt),
      q(0163) => q(Tirh),
      q(0164) => q(Ugar),
      q(0165) => q(Vaii),
      q(0166) => q(Visp),
      q(0167) => q(Wara),
      q(0168) => q(Wole),
      q(0169) => q(Xpeo),
      q(0170) => q(Xsux),
      q(0171) => q(Yiii),
      q(0172) => q(Zinh),
      q(0173) => q(Zmth),
      q(0174) => q(Zsym),
      },
   q(num) => {
      q(0001) => q(166),
      q(0002) => q(439),
      q(0003) => q(239),
      q(0004) => q(338),
      q(0005) => q(160),
      q(0006) => q(161),
      q(0007) => q(124),
      q(0008) => q(230),
      q(0009) => q(134),
      q(0010) => q(360),
      q(0011) => q(435),
      q(0012) => q(259),
      q(0013) => q(365),
      q(0014) => q(325),
      q(0015) => q(334),
      q(0016) => q(550),
      q(0017) => q(285),
      q(0018) => q(300),
      q(0019) => q(570),
      q(0020) => q(367),
      q(0021) => q(372),
      q(0022) => q(349),
      q(0023) => q(440),
      q(0024) => q(201),
      q(0025) => q(358),
      q(0026) => q(445),
      q(0027) => q(291),
      q(0028) => q(204),
      q(0029) => q(403),
      q(0030) => q(220),
      q(0031) => q(221),
      q(0032) => q(315),
      q(0033) => q(250),
      q(0034) => q(755),
      q(0035) => q(070),
      q(0036) => q(060),
      q(0037) => q(050),
      q(0038) => q(226),
      q(0039) => q(430),
      q(0040) => q(241),
      q(0041) => q(240),
      q(0042) => q(225),
      q(0043) => q(206),
      q(0044) => q(343),
      q(0045) => q(200),
      q(0046) => q(320),
      q(0047) => q(310),
      q(0048) => q(286),
      q(0049) => q(500),
      q(0050) => q(371),
      q(0051) => q(501),
      q(0052) => q(502),
      q(0053) => q(127),
      q(0054) => q(125),
      q(0055) => q(410),
      q(0056) => q(080),
      q(0057) => q(450),
      q(0058) => q(412),
      q(0059) => q(176),
      q(0060) => q(610),
      q(0061) => q(210),
      q(0062) => q(361),
      q(0063) => q(413),
      q(0064) => q(510),
      q(0065) => q(357),
      q(0066) => q(411),
      q(0067) => q(305),
      q(0068) => q(355),
      q(0069) => q(322),
      q(0070) => q(505),
      q(0071) => q(288),
      q(0072) => q(345),
      q(0073) => q(287),
      q(0074) => q(436),
      q(0075) => q(317),
      q(0076) => q(351),
      q(0077) => q(356),
      q(0078) => q(217),
      q(0079) => q(216),
      q(0080) => q(215),
      q(0081) => q(364),
      q(0082) => q(335),
      q(0083) => q(336),
      q(0084) => q(400),
      q(0085) => q(401),
      q(0086) => q(399),
      q(0087) => q(437),
      q(0088) => q(202),
      q(0089) => q(116),
      q(0090) => q(314),
      q(0091) => q(140),
      q(0092) => q(139),
      q(0093) => q(332),
      q(0094) => q(090),
      q(0095) => q(438),
      q(0096) => q(101),
      q(0097) => q(100),
      q(0098) => q(347),
      q(0099) => q(324),
      q(0100) => q(145),
      q(0101) => q(218),
      q(0102) => q(199),
      q(0103) => q(337),
      q(0104) => q(323),
      q(0105) => q(350),
      q(0106) => q(106),
      q(0107) => q(159),
      q(0108) => q(420),
      q(0109) => q(165),
      q(0110) => q(499),
      q(0111) => q(212),
      q(0112) => q(261),
      q(0113) => q(175),
      q(0114) => q(327),
      q(0115) => q(219),
      q(0116) => q(260),
      q(0117) => q(126),
      q(0118) => q(263),
      q(0119) => q(227),
      q(0120) => q(331),
      q(0121) => q(131),
      q(0122) => q(132),
      q(0123) => q(133),
      q(0124) => q(115),
      q(0125) => q(282),
      q(0126) => q(130),
      q(0127) => q(900),
      q(0128) => q(949),
      q(0129) => q(363),
      q(0130) => q(620),
      q(0131) => q(211),
      q(0132) => q(123),
      q(0133) => q(292),
      q(0134) => q(105),
      q(0135) => q(344),
      q(0136) => q(095),
      q(0137) => q(281),
      q(0138) => q(319),
      q(0139) => q(302),
      q(0140) => q(318),
      q(0141) => q(348),
      q(0142) => q(398),
      q(0143) => q(362),
      q(0144) => q(316),
      q(0145) => q(135),
      q(0146) => q(138),
      q(0147) => q(137),
      q(0148) => q(136),
      q(0149) => q(373),
      q(0150) => q(321),
      q(0151) => q(353),
      q(0152) => q(354),
      q(0153) => q(346),
      q(0154) => q(520),
      q(0155) => q(359),
      q(0156) => q(340),
      q(0157) => q(290),
      q(0158) => q(120),
      q(0159) => q(370),
      q(0160) => q(170),
      q(0161) => q(352),
      q(0162) => q(330),
      q(0163) => q(326),
      q(0164) => q(040),
      q(0165) => q(470),
      q(0166) => q(280),
      q(0167) => q(262),
      q(0168) => q(480),
      q(0169) => q(030),
      q(0170) => q(020),
      q(0171) => q(460),
      q(0172) => q(994),
      q(0173) => q(995),
      q(0174) => q(996),
      },
};

1;
                                                                                                                                                                                                                                                                                                                                        package #
Locale::Codes::Script_Retired;

# This file was automatically generated.  Any changes to this file will
# be lost the next time 'deprecate_codes' is run.
#    Generated on: Tue Dec  1 14:45:28 EST 2015

use strict;
require 5.006;
use warnings;
use utf8;

our($VERSION);
$VERSION='3.37';

$Locale::Codes::Retired{'script'}{'alpha'}{'code'} = {
};

$Locale::Codes::Retired{'script'}{'num'}{'code'} = {
};

$Locale::Codes::Retired{'script'}{'alpha'}{'name'} = {
   q( multani) => [ q(Mult), q( Multani) ],
   q((alias for hiragana + katakana)) => [ q(Hrkt), q((alias for Hiragana + Katakana)) ],
   q(ahom, tai ahom) => [ q(Ahom), q(Ahom, Tai Ahom) ],
   q(cuneiform, sumero-akkadian) => [ q(Xsux), q(Cuneiform, Sumero-Akkadian) ],
   q(deseret (mormon)) => [ q(Dsrt), q(Deseret (Mormon)) ],
   q(devanagari (nagari)) => [ q(Deva), q(Devanagari (Nagari)) ],
   q(duployan shorthand, duployan stenography) => [ q(Dupl), q(Duployan shorthand, Duployan stenography) ],
   q(ethiopic (geez)) => [ q(Ethi), q(Ethiopic (Geez)) ],
   q(han (hanzi, kanji, hanja)) => [ q(Hani), q(Han (Hanzi, Kanji, Hanja)) ],
   q(hangul (hangul, hangeul)) => [ q(Hang), q(Hangul (Hangul, Hangeul)) ],
   q(hanunoo (hanunoo)) => [ q(Hano), q(Hanunoo (Hanunoo)) ],
   q(indus (harappan)) => [ q(Inds), q(Indus (Harappan)) ],
   q(khudawadi, sindhi) => [ q(Sind), q(Khudawadi, Sindhi) ],
   q(lepcha (rong)) => [ q(Lepc), q(Lepcha (Rong)) ],
   q(lisu (fraser)) => [ q(Lisu), q(Lisu (Fraser)) ],
   q(mandaic, mandaean) => [ q(Mand), q(Mandaic, Mandaean) ],
   q(meitei mayek (meithei, meetei)) => [ q(Mtei), q(Meitei Mayek (Meithei, Meetei)) ],
   q(mende) => [ q(Mend), q(Mende) ],
   q(miao (pollard)) => [ q(Plrd), q(Miao (Pollard)) ],
   q(modi, modi) => [ q(Mult), q(Modi, Modi) ],
   q(moon (moon code, moon script, moon type)) => [ q(Moon), q(Moon (Moon code, Moon script, Moon type)) ],
   q(mro, mru) => [ q(Mroo), q(Mro, Mru) ],
   q(myanmar (burmese)) => [ q(Mymr), q(Myanmar (Burmese)) ],
   q(nakhi geba ('na-'khi ggo-baw, naxi geba)) => [ q(Nkgb), q(Nakhi Geba ('Na-'Khi Ggo-baw, Naxi Geba)) ],
   q(ol chiki (ol cemet, ol, santali)) => [ q(Olck), q(Ol Chiki (Ol Cemet, Ol, Santali)) ],
   q(old north arabian (ancient north arabian)) => [ q(Narb), q(Old North Arabian (Ancient North Arabian)) ],
   q(old turkic, orkhon runic) => [ q(Orkh), q(Old Turkic, Orkhon Runic) ],
   q(rejang (redjang, kaganga)) => [ q(Rjng), q(Rejang (Redjang, Kaganga)) ],
   q(sharada, sarada) => [ q(Shrd), q(Sharada, Sarada) ],
   q(shavian (shaw)) => [ q(Shaw), q(Shavian (Shaw)) ],
   q(siddham, siddham, siddhamatrka) => [ q(Sidd), q(Siddham, Siddham, Siddhamatrka) ],
   q(sindhi) => [ q(Sind), q(Sindhi) ],
   q(tagalog (baybayin, alibata)) => [ q(Tglg), q(Tagalog (Baybayin, Alibata)) ],
   q(tai tham (lanna)) => [ q(Lana), q(Tai Tham (Lanna)) ],
   q(takri, takri, tankri) => [ q(Takr), q(Takri, Takri, Tankri) ],
   q(tifinagh (berber)) => [ q(Tfng), q(Tifinagh (Berber)) ],
   q(tiruta) => [ q(Tirh), q(Tiruta) ],
   q(warang citi (varang kshiti)) => [ q(Wara), q(Warang Citi (Varang Kshiti)) ],
};

$Locale::Codes::Retired{'script'}{'num'}{'name'} = {
   q( multani) => [ q(323), q( Multani) ],
   q(mende) => [ q(438), q(Mende) ],
   q(old hungarian) => [ q(176), q(Old Hungarian) ],
   q(tiruta) => [ q(326), q(Tiruta) ],
};


1;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # This document contains text in Perl "POD" format.
# Use a POD viewer like perldoc or perlman to render it.

=encoding utf-8

=head1 NAME

Locale::Maketext::Cookbook - recipes for using Locale::Maketext

=head1 INTRODUCTION

This is a work in progress. Not much progress by now :-)

=head1 ONESIDED LEXICONS

I<Adapted from a suggestion by Dan Muey>

It may be common (for example at your main lexicon) that
the hash keys and values coincide. Like that

    q{Hello, tell me your name} 
      => q{Hello, tell me your name}

It would be nice to just write:

    q{Hello, tell me your name} => ''

and have this magically inflated to the first form.
Among the advantages of such representation, that would
lead to  
smaller files, less prone to mistyping or mispasting, 
and handy to someone translating it which can simply 
copy the main lexicon and enter the translation 
instead of having to remove the value first.

That can be achieved by overriding C<init>
in your class and working on the main lexicon
with code like that:

    package My::I18N;
    ...

    sub init {
        my $lh = shift; # a newborn handle
        $lh->SUPER::init();
        inflate_lexicon(\%My::I18N::en::Lexicon);
        return;
    }

    sub inflate_lexicon {
        my $lex = shift;
        while (my ($k, $v) = each %$lex) {
            $v = $k if !defined $v || $v eq '';
        }
    }

Here we are assuming C<My::I18N::en> to own the
main lexicon.

There are some downsides here: the size economy
will not stand at runtime after this C<init()>
runs. But it should not be that critical, since
if you don't have space for that, you won't have
space for any other language besides the main one
as well. You could do that too with ties,
expanding the value at lookup time which
should be more time expensive as an option.

=head1 DECIMAL PLACES IN NUMBER FORMATTING

I<After CPAN RT #36136 (https://rt.cpan.org/Ticket/Display.html?id=36136)>

The documentation of L<Locale::Maketext> advises that 
the standard bracket method C<numf> is limited and that
you must override that for better results. It even
suggests the use of L<Number::Format>.

One such defect of standard C<numf> is to not be
able to use a certain decimal precision.
For example, 

    $lh->maketext('pi is [numf,_1]', 355/113);

outputs

    pi is 3.14159292035398 

Since pi  355/116 is only accurate 
to 6 decimal places, you would want to say:

    $lh->maketext('pi is [numf,_1,6]', 355/113); 

and get "pi is 3.141592".

One solution for that could use C<Number::Format>
like that:

    package Wuu;

    use base qw(Locale::Maketext);

    use Number::Format;

    # can be overridden according to language conventions
    sub _numf_params {
        return (
            -thousands_sep  => '.',
            -decimal_point  => ',',
            -decimal_digits => 2,
        );
    }

    # builds a Number::Format
    sub _numf_formatter {
        my ($lh, $scale) = @_;
        my @params = $lh->_numf_params;
        if ($scale) { # use explicit scale rather than default
            push @params, (-decimal_digits => $scale);
        }
        return Number::Format->new(@params);
    }

    sub numf {
        my ($lh, $n, $scale) = @_;
        # get the (cached) formatter
        my $nf = $lh->{__nf}{$scale} ||= $lh->_numf_formatter($scale);
        # format the number itself
        return $nf->format_number($n);
    }

    package Wuu::pt;

    use base qw(Wuu);

and then 

    my $lh = Wuu->get_handle('pt');
    $lh->maketext('A [numf,_1,3] km de distncia', 1550.2222);

would return "A 1.550,222 km de distncia".

Notice that the standard utility methods of 
C<Locale::Maketext> are irremediably limited
because they could not aim to do everything
that could be expected from them in different languages,
cultures and applications. So extending C<numf>,
C<quant>, and C<sprintf> is natural as soon
as your needs exceed what the standard ones do.


                                                                                                                                                                  # This document contains text in Perl "POD" format.
# Use a POD viewer like perldoc or perlman to render it.

=head1 NAME

Locale::Maketext::TPJ13 -- article about software localization

=head1 SYNOPSIS

  # This an article, not a module.

=head1 DESCRIPTION

The following article by Sean M. Burke and Jordan Lachler
first appeared in I<The Perl Journal> #13
and is copyright 1999 The Perl Journal. It appears
courtesy of Jon Orwant and The Perl Journal.  This document may be
distributed under the same terms as Perl itself.

=head1 Localization and Perl: gettext breaks, Maketext fixes

by Sean M. Burke and Jordan Lachler

This article points out cases where gettext (a common system for
localizing software interfaces -- i.e., making them work in the user's
language of choice) fails because of basic differences between human
languages.  This article then describes Maketext, a new system capable
of correctly treating these differences.

=head2 A Localization Horror Story: It Could Happen To You

=over

"There are a number of languages spoken by human beings in this
world."

-- Harald Tveit Alvestrand, in RFC 1766, "Tags for the
Identification of Languages"

=back

Imagine that your task for the day is to localize a piece of software
-- and luckily for you, the only output the program emits is two
messages, like this:

  I scanned 12 directories.

  Your query matched 10 files in 4 directories.

So how hard could that be?  You look at the code that
produces the first item, and it reads:

  printf("I scanned %g directories.",
         $directory_count);

You think about that, and realize that it doesn't even work right for
English, as it can produce this output:

  I scanned 1 directories.

So you rewrite it to read:

  printf("I scanned %g %s.",
         $directory_count,
         $directory_count == 1 ?
           "directory" : "directories",
  );

...which does the Right Thing.  (In case you don't recall, "%g" is for
locale-specific number interpolation, and "%s" is for string
interpolation.)

But you still have to localize it for all the languages you're
producing this software for, so you pull Locale::gettext off of CPAN
so you can access the C<gettext> C functions you've heard are standard
for localization tasks.

And you write:

  printf(gettext("I scanned %g %s."),
         $dir_scan_count,
         $dir_scan_count == 1 ?
           gettext("directory") : gettext("directories"),
  );

But you then read in the gettext manual (Drepper, Miller, and Pinard 1995)
that this is not a good idea, since how a single word like "directory"
or "directories" is translated may depend on context -- and this is
true, since in a case language like German or Russian, you'd may need
these words with a different case ending in the first instance (where the
word is the object of a verb) than in the second instance, which you haven't even
gotten to yet (where the word is the object of a preposition, "in %g
directories") -- assuming these keep the same syntax when translated
into those languages.

So, on the advice of the gettext manual, you rewrite:

  printf( $dir_scan_count == 1 ?
           gettext("I scanned %g directory.") :
           gettext("I scanned %g directories."),
         $dir_scan_count );

So, you email your various translators (the boss decides that the
languages du jour are Chinese, Arabic, Russian, and Italian, so you
have one translator for each), asking for translations for "I scanned
%g directory." and "I scanned %g directories.".  When they reply,
you'll put that in the lexicons for gettext to use when it localizes
your software, so that when the user is running under the "zh"
(Chinese) locale, gettext("I scanned %g directory.") will return the
appropriate Chinese text, with a "%g" in there where printf can then
interpolate $dir_scan.

Your Chinese translator emails right back -- he says both of these
phrases translate to the same thing in Chinese, because, in linguistic
jargon, Chinese "doesn't have number as a grammatical category" --
whereas English does.  That is, English has grammatical rules that
refer to "number", i.e., whether something is grammatically singular
or plural; and one of these rules is the one that forces nouns to take
a plural suffix (generally "s") when in a plural context, as they are when
they follow a number other than "one" (including, oddly enough, "zero").
Chinese has no such rules, and so has just the one phrase where English
has two.  But, no problem, you can have this one Chinese phrase appear
as the translation for the two English phrases in the "zh" gettext
lexicon for your program.

Emboldened by this, you dive into the second phrase that your software
needs to output: "Your query matched 10 files in 4 directories.".  You notice
that if you want to treat phrases as indivisible, as the gettext
manual wisely advises, you need four cases now, instead of two, to
cover the permutations of singular and plural on the two items,
$dir_count and $file_count.  So you try this:

  printf( $file_count == 1 ?
    ( $directory_count == 1 ?
     gettext("Your query matched %g file in %g directory.") :
     gettext("Your query matched %g file in %g directories.") ) :
    ( $directory_count == 1 ?
     gettext("Your query matched %g files in %g directory.") :
     gettext("Your query matched %g files in %g directories.") ),
   $file_count, $directory_count,
  );

(The case of "1 file in 2 [or more] directories" could, I suppose,
occur in the case of symlinking or something of the sort.)

It occurs to you that this is not the prettiest code you've ever
written, but this seems the way to go.  You mail off to the
translators asking for translations for these four cases.  The
Chinese guy replies with the one phrase that these all translate to in
Chinese, and that phrase has two "%g"s in it, as it should -- but
there's a problem.  He translates it word-for-word back: "In %g
directories contains %g files match your query."  The %g
slots are in an order reverse to what they are in English.  You wonder
how you'll get gettext to handle that.

But you put it aside for the moment, and optimistically hope that the
other translators won't have this problem, and that their languages
will be better behaved -- i.e., that they will be just like English.

But the Arabic translator is the next to write back.  First off, your
code for "I scanned %g directory." or "I scanned %g directories."
assumes there's only singular or plural.  But, to use linguistic
jargon again, Arabic has grammatical number, like English (but unlike
Chinese), but it's a three-term category: singular, dual, and plural.
In other words, the way you say "directory" depends on whether there's
one directory, or I<two> of them, or I<more than two> of them.  Your
test of C<($directory == 1)> no longer does the job.  And it means
that where English's grammatical category of number necessitates
only the two permutations of the first sentence based on "directory
[singular]" and "directories [plural]", Arabic has three -- and,
worse, in the second sentence ("Your query matched %g file in %g
directory."), where English has four, Arabic has nine.  You sense
an unwelcome, exponential trend taking shape.

Your Italian translator emails you back and says that "I searched 0
directories" (a possible English output of your program) is stilted,
and if you think that's fine English, that's your problem, but that
I<just will not do> in the language of Dante.  He insists that where
$directory_count is 0, your program should produce the Italian text
for "I I<didn't> scan I<any> directories.".  And ditto for "I didn't
match any files in any directories", although he says the last part
about "in any directories" should probably just be left off.

You wonder how you'll get gettext to handle this; to accommodate the
ways Arabic, Chinese, and Italian deal with numbers in just these few
very simple phrases, you need to write code that will ask gettext for
different queries depending on whether the numerical values in
question are 1, 2, more than 2, or in some cases 0, and you still haven't
figured out the problem with the different word order in Chinese.

Then your Russian translator calls on the phone, to I<personally> tell
you the bad news about how really unpleasant your life is about to
become:

Russian, like German or Latin, is an inflectional language; that is, nouns
and adjectives have to take endings that depend on their case
(i.e., nominative, accusative, genitive, etc...) -- which is roughly a matter of
what role they have in syntax of the sentence --
as well as on the grammatical gender (i.e., masculine, feminine, neuter)
and number (i.e., singular or plural) of the noun, as well as on the
declension class of the noun.  But unlike with most other inflected languages,
putting a number-phrase (like "ten" or "forty-three", or their Arabic
numeral equivalents) in front of noun in Russian can change the case and
number that noun is, and therefore the endings you have to put on it.

He elaborates:  In "I scanned %g directories", you'd I<expect>
"directories" to be in the accusative case (since it is the direct
object in the sentence) and the plural number,
except where $directory_count is 1, then you'd expect the singular, of
course.  Just like Latin or German.  I<But!>  Where $directory_count %
10 is 1 ("%" for modulo, remember), assuming $directory count is an
integer, and except where $directory_count % 100 is 11, "directories"
is forced to become grammatically singular, which means it gets the
ending for the accusative singular...  You begin to visualize the code
it'd take to test for the problem so far, I<and still work for Chinese
and Arabic and Italian>, and how many gettext items that'd take, but
he keeps going...  But where $directory_count % 10 is 2, 3, or 4
(except where $directory_count % 100 is 12, 13, or 14), the word for
"directories" is forced to be genitive singular -- which means another
ending... The room begins to spin around you, slowly at first...  But
with I<all other> integer values, since "directory" is an inanimate
noun, when preceded by a number and in the nominative or accusative
cases (as it is here, just your luck!), it does stay plural, but it is
forced into the genitive case -- yet another ending...  And
you never hear him get to the part about how you're going to run into
similar (but maybe subtly different) problems with other Slavic
languages like Polish, because the floor comes up to meet you, and you
fade into unconsciousness.


The above cautionary tale relates how an attempt at localization can
lead from programmer consternation, to program obfuscation, to a need
for sedation.  But careful evaluation shows that your choice of tools
merely needed further consideration.

=head2 The Linguistic View

=over

"It is more complicated than you think." 

-- The Eighth Networking Truth, from RFC 1925

=back

The field of Linguistics has expended a great deal of effort over the
past century trying to find grammatical patterns which hold across
languages; it's been a constant process
of people making generalizations that should apply to all languages,
only to find out that, all too often, these generalizations fail --
sometimes failing for just a few languages, sometimes whole classes of
languages, and sometimes nearly every language in the world except
English.  Broad statistical trends are evident in what the "average
language" is like as far as what its rules can look like, must look
like, and cannot look like.  But the "average language" is just as
unreal a concept as the "average person" -- it runs up against the
fact no language (or person) is, in fact, average.  The wisdom of past
experience leads us to believe that any given language can do whatever
it wants, in any order, with appeal to any kind of grammatical
categories wants -- case, number, tense, real or metaphoric
characteristics of the things that words refer to, arbitrary or
predictable classifications of words based on what endings or prefixes
they can take, degree or means of certainty about the truth of
statements expressed, and so on, ad infinitum.

Mercifully, most localization tasks are a matter of finding ways to
translate whole phrases, generally sentences, where the context is
relatively set, and where the only variation in content is I<usually>
in a number being expressed -- as in the example sentences above.
Translating specific, fully-formed sentences is, in practice, fairly
foolproof -- which is good, because that's what's in the phrasebooks
that so many tourists rely on.  Now, a given phrase (whether in a
phrasebook or in a gettext lexicon) in one language I<might> have a
greater or lesser applicability than that phrase's translation into
another language -- for example, strictly speaking, in Arabic, the
"your" in "Your query matched..." would take a different form
depending on whether the user is male or female; so the Arabic
translation "your[feminine] query" is applicable in fewer cases than
the corresponding English phrase, which doesn't distinguish the user's
gender.  (In practice, it's not feasible to have a program know the
user's gender, so the masculine "you" in Arabic is usually used, by
default.)

But in general, such surprises are rare when entire sentences are
being translated, especially when the functional context is restricted
to that of a computer interacting with a user either to convey a fact
or to prompt for a piece of information.  So, for purposes of
localization, translation by phrase (generally by sentence) is both the
simplest and the least problematic.

=head2 Breaking gettext

=over

"It Has To Work."

-- First Networking Truth, RFC 1925

=back

Consider that sentences in a tourist phrasebook are of two types: ones
like "How do I get to the marketplace?" that don't have any blanks to
fill in, and ones like "How much do these ___ cost?", where there's
one or more blanks to fill in (and these are usually linked to a
list of words that you can put in that blank: "fish", "potatoes",
"tomatoes", etc.)  The ones with no blanks are no problem, but the
fill-in-the-blank ones may not be really straightforward. If it's a
Swahili phrasebook, for example, the authors probably didn't bother to
tell you the complicated ways that the verb "cost" changes its
inflectional prefix depending on the noun you're putting in the blank.
The trader in the marketplace will still understand what you're saying if
you say "how much do these potatoes cost?" with the wrong
inflectional prefix on "cost".  After all, I<you> can't speak proper Swahili,
I<you're> just a tourist.  But while tourists can be stupid, computers
are supposed to be smart; the computer should be able to fill in the
blank, and still have the results be grammatical.

In other words, a phrasebook entry takes some values as parameters
(the things that you fill in the blank or blanks), and provides a value
based on these parameters, where the way you get that final value from
the given values can, properly speaking, involve an arbitrarily
complex series of operations.  (In the case of Chinese, it'd be not at
all complex, at least in cases like the examples at the beginning of
this article; whereas in the case of Russian it'd be a rather complex
series of operations.  And in some languages, the
complexity could be spread around differently: while the act of
putting a number-expression in front of a noun phrase might not be
complex by itself, it may change how you have to, for example, inflect
a verb elsewhere in the sentence.  This is what in syntax is called
"long-distance dependencies".)

This talk of parameters and arbitrary complexity is just another way
to say that an entry in a phrasebook is what in a programming language
would be called a "function".  Just so you don't miss it, this is the
crux of this article: I<A phrase is a function; a phrasebook is a
bunch of functions.>

The reason that using gettext runs into walls (as in the above
second-person horror story) is that you're trying to use a string (or
worse, a choice among a bunch of strings) to do what you really need a
function for -- which is futile.  Preforming (s)printf interpolation
on the strings which you get back from gettext does allow you to do I<some>
common things passably well... sometimes... sort of; but, to paraphrase
what some people say about C<csh> script programming, "it fools you
into thinking you can use it for real things, but you can't, and you
don't discover this until you've already spent too much time trying,
and by then it's too late."

=head2 Replacing gettext

So, what needs to replace gettext is a system that supports lexicons
of functions instead of lexicons of strings.  An entry in a lexicon
from such a system should I<not> look like this:

  "J'ai trouv\xE9 %g fichiers dans %g r\xE9pertoires"

[\xE9 is e-acute in Latin-1.  Some pod renderers would
scream if I used the actual character here. -- SB]

but instead like this, bearing in mind that this is just a first stab:

  sub I_found_X1_files_in_X2_directories {
    my( $files, $dirs ) = @_[0,1];
    $files = sprintf("%g %s", $files,
      $files == 1 ? 'fichier' : 'fichiers');
    $dirs = sprintf("%g %s", $dirs,
      $dirs == 1 ? "r\xE9pertoire" : "r\xE9pertoires");
    return "J'ai trouv\xE9 $files dans $dirs.";
  }

Now, there's no particularly obvious way to store anything but strings
in a gettext lexicon; so it looks like we just have to start over and
make something better, from scratch.  I call my shot at a
gettext-replacement system "Maketext", or, in CPAN terms,
Locale::Maketext.

When designing Maketext, I chose to plan its main features in terms of
"buzzword compliance".  And here are the buzzwords:

=head2 Buzzwords: Abstraction and Encapsulation

The complexity of the language you're trying to output a phrase in is
entirely abstracted inside (and encapsulated within) the Maketext module
for that interface.  When you call:

  print $lang->maketext("You have [quant,_1,piece] of new mail.",
                       scalar(@messages));

you don't know (and in fact can't easily find out) whether this will
involve lots of figuring, as in Russian (if $lang is a handle to the
Russian module), or relatively little, as in Chinese.  That kind of
abstraction and encapsulation may encourage other pleasant buzzwords
like modularization and stratification, depending on what design
decisions you make.

=head2 Buzzword: Isomorphism

"Isomorphism" means "having the same structure or form"; in discussions
of program design, the word takes on the special, specific meaning that
your implementation of a solution to a problem I<has the same
structure> as, say, an informal verbal description of the solution, or
maybe of the problem itself.  Isomorphism is, all things considered,
a good thing -- it's what problem-solving (and solution-implementing)
should look like.

What's wrong the with gettext-using code like this...

  printf( $file_count == 1 ?
    ( $directory_count == 1 ?
     "Your query matched %g file in %g directory." :
     "Your query matched %g file in %g directories." ) :
    ( $directory_count == 1 ?
     "Your query matched %g files in %g directory." :
     "Your query matched %g files in %g directories." ),
   $file_count, $directory_count,
  );

is first off that it's not well abstracted -- these ways of testing
for grammatical number (as in the expressions like C<foo == 1 ?
singular_form : plural_form>) should be abstracted to each language
module, since how you get grammatical number is language-specific.

But second off, it's not isomorphic -- the "solution" (i.e., the
phrasebook entries) for Chinese maps from these four English phrases to
the one Chinese phrase that fits for all of them.  In other words, the
informal solution would be "The way to say what you want in Chinese is
with the one phrase 'For your question, in Y directories you would
find X files'" -- and so the implemented solution should be,
isomorphically, just a straightforward way to spit out that one
phrase, with numerals properly interpolated.  It shouldn't have to map
from the complexity of other languages to the simplicity of this one.

=head2 Buzzword: Inheritance

There's a great deal of reuse possible for sharing of phrases between
modules for related dialects, or for sharing of auxiliary functions
between related languages.  (By "auxiliary functions", I mean
functions that don't produce phrase-text, but which, say, return an
answer to "does this number require a plural noun after it?".  Such
auxiliary functions would be used in the internal logic of functions
that actually do produce phrase-text.)

In the case of sharing phrases, consider that you have an interface
already localized for American English (probably by having been
written with that as the native locale, but that's incidental).
Localizing it for UK English should, in practical terms, be just a
matter of running it past a British person with the instructions to
indicate what few phrases would benefit from a change in spelling or
possibly minor rewording.  In that case, you should be able to put in
the UK English localization module I<only> those phrases that are
UK-specific, and for all the rest, I<inherit> from the American
English module.  (And I expect this same situation would apply with
Brazilian and Continental Portugese, possibly with some I<very>
closely related languages like Czech and Slovak, and possibly with the
slightly different "versions" of written Mandarin Chinese, as I hear exist in
Taiwan and mainland China.)

As to sharing of auxiliary functions, consider the problem of Russian
numbers from the beginning of this article; obviously, you'd want to
write only once the hairy code that, given a numeric value, would
return some specification of which case and number a given quantified
noun should use.  But suppose that you discover, while localizing an
interface for, say, Ukranian (a Slavic language related to Russian,
spoken by several million people, many of whom would be relieved to
find that your Web site's or software's interface is available in
their language), that the rules in Ukranian are the same as in Russian
for quantification, and probably for many other grammatical functions.
While there may well be no phrases in common between Russian and
Ukranian, you could still choose to have the Ukranian module inherit
from the Russian module, just for the sake of inheriting all the
various grammatical methods.  Or, probably better organizationally,
you could move those functions to a module called C<_E_Slavic> or
something, which Russian and Ukrainian could inherit useful functions
from, but which would (presumably) provide no lexicon.

=head2 Buzzword: Concision

Okay, concision isn't a buzzword.  But it should be, so I decree that
as a new buzzword, "concision" means that simple common things should
be expressible in very few lines (or maybe even just a few characters)
of code -- call it a special case of "making simple things easy and
hard things possible", and see also the role it played in the
MIDI::Simple language, discussed elsewhere in this issue [TPJ#13].

Consider our first stab at an entry in our "phrasebook of functions":

  sub I_found_X1_files_in_X2_directories {
    my( $files, $dirs ) = @_[0,1];
    $files = sprintf("%g %s", $files,
      $files == 1 ? 'fichier' : 'fichiers');
    $dirs = sprintf("%g %s", $dirs,
      $dirs == 1 ? "r\xE9pertoire" : "r\xE9pertoires");
    return "J'ai trouv\xE9 $files dans $dirs.";
  }

You may sense that a lexicon (to use a non-committal catch-all term for a
collection of things you know how to say, regardless of whether they're
phrases or words) consisting of functions I<expressed> as above would
make for rather long-winded and repetitive code -- even if you wisely
rewrote this to have quantification (as we call adding a number
expression to a noun phrase) be a function called like:

  sub I_found_X1_files_in_X2_directories {
    my( $files, $dirs ) = @_[0,1];
    $files = quant($files, "fichier");
    $dirs =  quant($dirs,  "r\xE9pertoire");
    return "J'ai trouv\xE9 $files dans $dirs.";
  }

And you may also sense that you do not want to bother your translators
with having to write Perl code -- you'd much rather that they spend
their I<very costly time> on just translation.  And this is to say
nothing of the near impossibility of finding a commercial translator
who would know even simple Perl.

In a first-hack implementation of Maketext, each language-module's
lexicon looked like this:

 %Lexicon = (
   "I found %g files in %g directories"
   => sub {
      my( $files, $dirs ) = @_[0,1];
      $files = quant($files, "fichier");
      $dirs =  quant($dirs,  "r\xE9pertoire");
      return "J'ai trouv\xE9 $files dans $dirs.";
    },
  ... and so on with other phrase => sub mappings ...
 );

but I immediately went looking for some more concise way to basically
denote the same phrase-function -- a way that would also serve to
concisely denote I<most> phrase-functions in the lexicon for I<most>
languages.  After much time and even some actual thought, I decided on
this system:

* Where a value in a %Lexicon hash is a contentful string instead of
an anonymous sub (or, conceivably, a coderef), it would be interpreted
as a sort of shorthand expression of what the sub does.  When accessed
for the first time in a session, it is parsed, turned into Perl code,
and then eval'd into an anonymous sub; then that sub replaces the
original string in that lexicon.  (That way, the work of parsing and
evaling the shorthand form for a given phrase is done no more than
once per session.)

* Calls to C<maketext> (as Maketext's main function is called) happen
thru a "language session handle", notionally very much like an IO
handle, in that you open one at the start of the session, and use it
for "sending signals" to an object in order to have it return the text
you want.

So, this:

  $lang->maketext("You have [quant,_1,piece] of new mail.",
                 scalar(@messages));

basically means this: look in the lexicon for $lang (which may inherit
from any number of other lexicons), and find the function that we
happen to associate with the string "You have [quant,_1,piece] of new
mail" (which is, and should be, a functioning "shorthand" for this
function in the native locale -- English in this case).  If you find
such a function, call it with $lang as its first parameter (as if it
were a method), and then a copy of scalar(@messages) as its second,
and then return that value.  If that function was found, but was in
string shorthand instead of being a fully specified function, parse it
and make it into a function before calling it the first time.

* The shorthand uses code in brackets to indicate method calls that
should be performed.  A full explanation is not in order here, but a
few examples will suffice:

  "You have [quant,_1,piece] of new mail."

The above code is shorthand for, and will be interpreted as,
this:

  sub {
    my $handle = $_[0];
    my(@params) = @_;
    return join '',
      "You have ",
      $handle->quant($params[1], 'piece'),
      "of new mail.";
  }

where "quant" is the name of a method you're using to quantify the
noun "piece" with the number $params[0].

A string with no brackety calls, like this:

  "Your search expression was malformed."

is somewhat of a degenerate case, and just gets turned into:

  sub { return "Your search expression was malformed." }

However, not everything you can write in Perl code can be written in
the above shorthand system -- not by a long shot.  For example, consider
the Italian translator from the beginning of this article, who wanted
the Italian for "I didn't find any files" as a special case, instead
of "I found 0 files".  That couldn't be specified (at least not easily
or simply) in our shorthand system, and it would have to be written
out in full, like this:

  sub {  # pretend the English strings are in Italian
    my($handle, $files, $dirs) = @_[0,1,2];
    return "I didn't find any files" unless $files;
    return join '',
      "I found ",
      $handle->quant($files, 'file'),
      " in ",
      $handle->quant($dirs,  'directory'),
      ".";
  }

Next to a lexicon full of shorthand code, that sort of sticks out like a
sore thumb -- but this I<is> a special case, after all; and at least
it's possible, if not as concise as usual.

As to how you'd implement the Russian example from the beginning of
the article, well, There's More Than One Way To Do It, but it could be
something like this (using English words for Russian, just so you know
what's going on):

  "I [quant,_1,directory,accusative] scanned."

This shifts the burden of complexity off to the quant method.  That
method's parameters are: the numeric value it's going to use to
quantify something; the Russian word it's going to quantify; and the
parameter "accusative", which you're using to mean that this
sentence's syntax wants a noun in the accusative case there, although
that quantification method may have to overrule, for grammatical
reasons you may recall from the beginning of this article.

Now, the Russian quant method here is responsible not only for
implementing the strange logic necessary for figuring out how Russian
number-phrases impose case and number on their noun-phrases, but also
for inflecting the Russian word for "directory".  How that inflection
is to be carried out is no small issue, and among the solutions I've
seen, some (like variations on a simple lookup in a hash where all
possible forms are provided for all necessary words) are
straightforward but I<can> become cumbersome when you need to inflect
more than a few dozen words; and other solutions (like using
algorithms to model the inflections, storing only root forms and
irregularities) I<can> involve more overhead than is justifiable for
all but the largest lexicons.

Mercifully, this design decision becomes crucial only in the hairiest
of inflected languages, of which Russian is by no means the I<worst> case
scenario, but is worse than most.  Most languages have simpler
inflection systems; for example, in English or Swahili, there are
generally no more than two possible inflected forms for a given noun
("error/errors"; "kosa/makosa"), and the
rules for producing these forms are fairly simple -- or at least,
simple rules can be formulated that work for most words, and you can
then treat the exceptions as just "irregular", at least relative to
your ad hoc rules.  A simpler inflection system (simpler rules, fewer
forms) means that design decisions are less crucial to maintaining
sanity, whereas the same decisions could incur
overhead-versus-scalability problems in languages like Russian.  It
may I<also> be likely that code (possibly in Perl, as with
Lingua::EN::Inflect, for English nouns) has already
been written for the language in question, whether simple or complex.

Moreover, a third possibility may even be simpler than anything
discussed above: "Just require that all possible (or at least
applicable) forms be provided in the call to the given language's quant
method, as in:"

  "I found [quant,_1,file,files]."

That way, quant just has to chose which form it needs, without having
to look up or generate anything.  While possibly not optimal for
Russian, this should work well for most other languages, where
quantification is not as complicated an operation.

=head2 The Devil in the Details

There's plenty more to Maketext than described above -- for example,
there's the details of how language tags ("en-US", "i-pwn", "fi",
etc.) or locale IDs ("en_US") interact with actual module naming
("BogoQuery/Locale/en_us.pm"), and what magic can ensue; there's the
details of how to record (and possibly negotiate) what character
encoding Maketext will return text in (UTF8? Latin-1? KOI8?).  There's
the interesting fact that Maketext is for localization, but nowhere
actually has a "C<use locale;>" anywhere in it.  For the curious,
there's the somewhat frightening details of how I actually
implement something like data inheritance so that searches across
modules' %Lexicon hashes can parallel how Perl implements method
inheritance.

And, most importantly, there's all the practical details of how to
actually go about deriving from Maketext so you can use it for your
interfaces, and the various tools and conventions for starting out and
maintaining individual language modules.

That is all covered in the documentation for Locale::Maketext and the
modules that come with it, available in CPAN.  After having read this
article, which covers the why's of Maketext, the documentation,
which covers the how's of it, should be quite straightforward.

=head2 The Proof in the Pudding: Localizing Web Sites

Maketext and gettext have a notable difference: gettext is in C,
accessible thru C library calls, whereas Maketext is in Perl, and
really can't work without a Perl interpreter (although I suppose
something like it could be written for C).  Accidents of history (and
not necessarily lucky ones) have made C++ the most common language for
the implementation of applications like word processors, Web browsers,
and even many in-house applications like custom query systems.  Current
conditions make it somewhat unlikely that the next one of any of these
kinds of applications will be written in Perl, albeit clearly more for
reasons of custom and inertia than out of consideration of what is the
right tool for the job.

However, other accidents of history have made Perl a well-accepted
language for design of server-side programs (generally in CGI form)
for Web site interfaces.  Localization of static pages in Web sites is
trivial, feasible either with simple language-negotiation features in
servers like Apache, or with some kind of server-side inclusions of
language-appropriate text into layout templates.  However, I think
that the localization of Perl-based search systems (or other kinds of
dynamic content) in Web sites, be they public or access-restricted,
is where Maketext will see the greatest use.

I presume that it would be only the exceptional Web site that gets
localized for English I<and> Chinese I<and> Italian I<and> Arabic
I<and> Russian, to recall the languages from the beginning of this
article -- to say nothing of German, Spanish, French, Japanese,
Finnish, and Hindi, to name a few languages that benefit from large
numbers of programmers or Web viewers or both.

However, the ever-increasing internationalization of the Web (whether
measured in terms of amount of content, of numbers of content writers
or programmers, or of size of content audiences) makes it increasingly
likely that the interface to the average Web-based dynamic content
service will be localized for two or maybe three languages.  It is my
hope that Maketext will make that task as simple as possible, and will
remove previous barriers to localization for languages dissimilar to
English.

 __END__

Sean M. Burke (sburkeE<64>cpan.org) has a Master's in linguistics
from Northwestern University; he specializes in language technology.
Jordan Lachler (lachlerE<64>unm.edu) is a PhD student in the Department of
Linguistics at the University of New Mexico; he specializes in
morphology and pedagogy of North American native languages.

=head2 References

Alvestrand, Harald Tveit.  1995.  I<RFC 1766: Tags for the
Identification of Languages.>
C<http://www.ietf.org/rfc/rfc1766.txt>
[Now see RFC 3066.]

Callon, Ross, editor.  1996.  I<RFC 1925: The Twelve
Networking Truths.>
C<http://www.ietf.org/rfc/rfc1925.txt>

Drepper, Ulrich, Peter Miller,
and FranE<ccedil>ois Pinard.  1995-2001.  GNU
C<gettext>.  Available in C<ftp://prep.ai.mit.edu/pub/gnu/>, with
extensive docs in the distribution tarball.  [Since
I wrote this article in 1998, I now see that the
gettext docs are now trying more to come to terms with
plurality.  Whether useful conclusions have come from it
is another question altogether. -- SMB, May 2001]

Forbes, Nevill.  1964.  I<Russian Grammar.>  Third Edition, revised
by J. C. Dumbreck.  Oxford University Press.

=cut

#End

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                package Math::BigFloat;

# 
# Mike grinned. 'Two down, infinity to go' - Mike Nostrus in 'Before and After'
#

# The following hash values are internally used:
#   _e	: exponent (ref to $CALC object)
#   _m	: mantissa (ref to $CALC object)
#   _es	: sign of _e
# sign	: +,-,+inf,-inf, or "NaN" if not a number
#   _a	: accuracy
#   _p	: precision

use 5.006001;
use strict;
use warnings;

our $VERSION = '1.999715';
$VERSION = eval $VERSION;

require Exporter;
our @ISA	= qw/Math::BigInt/;
our @EXPORT_OK	= qw/bpi/;

# $_trap_inf/$_trap_nan are internal and should never be accessed from outside
our ($AUTOLOAD, $accuracy, $precision, $div_scale, $round_mode, $rnd_mode,
     $upgrade, $downgrade, $_trap_nan, $_trap_inf);

my $class = "Math::BigFloat";

use overload
  '<=>'	=>	sub { my $rc = $_[2] ? ref($_[0])->bcmp($_[1], $_[0])
                                     : ref($_[0])->bcmp($_[0], $_[1]);
		      $rc = 1 unless defined $rc;
		      $rc <=> 0;
		},
# we need '>=' to get things like "1 >= NaN" right:
  '>='	=>	sub { my $rc = $_[2] ? ref($_[0])->bcmp($_[1],$_[0])
                                     : ref($_[0])->bcmp($_[0],$_[1]);
		      # if there was a NaN involved, return false
		      return '' unless defined $rc;
		      $rc >= 0;
		},
  'int'	=>	sub { $_[0]->as_number() },		# 'trunc' to bigint
;

##############################################################################
# global constants, flags and assorted stuff

# the following are public, but their usage is not recommended. Use the
# accessor methods instead.

# class constants, use Class->constant_name() to access
# one of 'even', 'odd', '+inf', '-inf', 'zero', 'trunc' or 'common'
$round_mode = 'even';
$accuracy   = undef;
$precision  = undef;
$div_scale  = 40;

$upgrade = undef;
$downgrade = undef;
# the package we are using for our private parts, defaults to:
# Math::BigInt->config()->{lib}
my $MBI = 'Math::BigInt::Calc';

# are NaNs ok? (otherwise it dies when encountering an NaN) set w/ config()
$_trap_nan = 0;
# the same for infinity
$_trap_inf = 0;

# constant for easier life
my $nan = 'NaN'; 

my $IMPORT = 0;	# was import() called yet? used to make require work

# some digits of accuracy for blog(undef,10); which we use in blog() for speed
my $LOG_10 = 
 '2.3025850929940456840179914546843642076011014886287729760333279009675726097';
my $LOG_10_A = length($LOG_10)-1;
# ditto for log(2)
my $LOG_2 = 
 '0.6931471805599453094172321214581765680755001343602552541206800094933936220';
my $LOG_2_A = length($LOG_2)-1;
my $HALF = '0.5';			# made into an object if nec.

##############################################################################
# the old code had $rnd_mode, so we need to support it, too

sub TIESCALAR   { my ($class) = @_; bless \$round_mode, $class; }
sub FETCH       { return $round_mode; }
sub STORE       { $rnd_mode = $_[0]->round_mode($_[1]); }

BEGIN
  {
  # when someone sets $rnd_mode, we catch this and check the value to see
  # whether it is valid or not. 
  $rnd_mode   = 'even'; tie $rnd_mode, 'Math::BigFloat';

  # we need both of them in this package:
  *as_int = \&as_number;
  }
 
##############################################################################

{
  # valid method aliases for AUTOLOAD
  my %methods = map { $_ => 1 }  
   qw / fadd fsub fmul fdiv fround ffround fsqrt fmod fstr fsstr fpow fnorm
        fint facmp fcmp fzero fnan finf finc fdec ffac fneg
	fceil ffloor frsft flsft fone flog froot fexp
      /;
  # valid methods that can be handed up (for AUTOLOAD)
  my %hand_ups = map { $_ => 1 }  
   qw / is_nan is_inf is_negative is_positive is_pos is_neg
        accuracy precision div_scale round_mode fabs fnot
        objectify upgrade downgrade
	bone binf bnan bzero
	bsub
      /;

  sub _method_alias { exists $methods{$_[0]||''}; } 
  sub _method_hand_up { exists $hand_ups{$_[0]||''}; } 
}

##############################################################################
# constructors

sub new {
    # Create a new BigFloat object from a string or another bigfloat object.
    # _e: exponent
    # _m: mantissa
    # sign  => sign ("+", "-", "+inf", "-inf", or "NaN"

    my $self    = shift;
    my $selfref = ref $self;
    my $class   = $selfref || $self;

    my ($wanted, @r) = @_;

    # avoid numify-calls by not using || on $wanted!

    unless (defined $wanted) {
        require Carp;
        Carp::carp("Use of uninitialized value in new");
        return $self->bzero(@r);
    }

    # Using $wanted->isa("Math::BigFloat") here causes a 'Deep recursion on
    # subroutine "Math::BigFloat::as_number"' in some tests. Fixme!

    if (UNIVERSAL::isa($wanted, 'Math::BigFloat')) {
        my $copy = $wanted -> copy();
        if ($selfref) {                 # if new() called as instance method
            %$self = %$copy;
        } else {                        # if new() called as class method
            $self = $copy;
        }
        return $copy;
    }

    $class->import() if $IMPORT == 0;             # make require work

    # If called as a class method, initialize a new object.

    $self = bless {}, $class unless $selfref;

    # shortcut for bigints and its subclasses
    if ((ref($wanted)) && $wanted -> can("as_number")) {
        $self->{_m} = $wanted->as_number()->{value};  # get us a bigint copy
        $self->{_e} = $MBI->_zero();
        $self->{_es} = '+';
        $self->{sign} = $wanted->sign();
        return $self->bnorm();
    }

    # else: got a string or something masquerading as number (with overload)

    # Handle Infs.

    if ($wanted =~ /^\s*([+-]?)inf(inity)?\s*\z/i) {
        return $downgrade->new($wanted) if $downgrade;
        my $sgn = $1 || '+';
        $self->{sign} = $sgn . 'inf';   # set a default sign for bstr()
        return $self->binf($sgn);
    }

    # Shortcut for simple forms like '12' that have no trailing zeros.
    if ($wanted =~ /^([+-]?)0*([1-9][0-9]*[1-9])$/) {
        $self->{_e} = $MBI->_zero();
        $self->{_es} = '+';
        $self->{sign} = $1 || '+';
        $self->{_m} = $MBI->_new($2);
        return $self->round(@r) if !$downgrade;
    }

  my ($mis,$miv,$mfv,$es,$ev) = Math::BigInt::_split($wanted);
  if (!ref $mis)
    {
    if ($_trap_nan)
      {
      require Carp;
      Carp::croak ("$wanted is not a number initialized to $class");
      }
    
    return $downgrade->bnan() if $downgrade;
    
    $self->{_e} = $MBI->_zero();
    $self->{_es} = '+';
    $self->{_m} = $MBI->_zero();
    $self->{sign} = $nan;
    }
  else
    {
    # make integer from mantissa by adjusting exp, then convert to int
    $self->{_e} = $MBI->_new($$ev);		# exponent
    $self->{_es} = $$es || '+';
    my $mantissa = "$$miv$$mfv"; 		# create mant.
    $mantissa =~ s/^0+(\d)/$1/;			# strip leading zeros
    $self->{_m} = $MBI->_new($mantissa); 	# create mant.

    # 3.123E0 = 3123E-3, and 3.123E-2 => 3123E-5
    if (CORE::length($$mfv) != 0)
      {
      my $len = $MBI->_new( CORE::length($$mfv));
      ($self->{_e}, $self->{_es}) =
	_e_sub ($self->{_e}, $len, $self->{_es}, '+');
      }
    # we can only have trailing zeros on the mantissa if $$mfv eq ''
    else
      {
      # Use a regexp to count the trailing zeros in $$miv instead of _zeros()
      # because that is faster, especially when _m is not stored in base 10.
      my $zeros = 0; $zeros = CORE::length($1) if $$miv =~ /[1-9](0*)$/; 
      if ($zeros != 0)
        {
        my $z = $MBI->_new($zeros);
        # turn '120e2' into '12e3'
        $MBI->_rsft ( $self->{_m}, $z, 10);
        ($self->{_e}, $self->{_es}) =
	  _e_add ( $self->{_e}, $z, $self->{_es}, '+');
        }
      }
    $self->{sign} = $$mis;

    # for something like 0Ey, set y to 0, and -0 => +0
    # Check $$miv for being '0' and $$mfv eq '', because otherwise _m could not
    # have become 0. That's faster than to call $MBI->_is_zero().
    $self->{sign} = '+', $self->{_e} = $MBI->_zero()
     if $$miv eq '0' and $$mfv eq '';

    return $self->round(@r) if !$downgrade;
    }
  # if downgrade, inf, NaN or integers go down

  if ($downgrade && $self->{_es} eq '+')
    {
    if ($MBI->_is_zero( $self->{_e} ))
      {
      return $downgrade->new($$mis . $MBI->_str( $self->{_m} ));
      }
    return $downgrade->new($self->bsstr()); 
    }
  $self->bnorm()->round(@r);			# first normalize, then round
  }

sub copy {
    my $self    = shift;
    my $selfref = ref $self;
    my $class   = $selfref || $self;

    # If called as a class method, the object to copy is the next argument.

    $self = shift() unless $selfref;

    my $copy = bless {}, $class;

    $copy->{sign} = $self->{sign};
    $copy->{_es}  = $self->{_es};
    $copy->{_m}   = $MBI->_copy($self->{_m});
    $copy->{_e}   = $MBI->_copy($self->{_e});
    $copy->{_a}   = $self->{_a} if exists $self->{_a};
    $copy->{_p}   = $self->{_p} if exists $self->{_p};

    return $copy;
}

sub _bnan
  {
  # used by parent class bone() to initialize number to NaN
  my $self = shift;
  
  if ($_trap_nan)
    {
    require Carp;
    my $class = ref($self);
    Carp::croak ("Tried to set $self to NaN in $class\::_bnan()");
    }

  $IMPORT=1;					# call our import only once
  $self->{_m} = $MBI->_zero();
  $self->{_e} = $MBI->_zero();
  $self->{_es} = '+';
  }

sub _binf
  {
  # used by parent class bone() to initialize number to +-inf
  my $self = shift;
  
  if ($_trap_inf)
    {
    require Carp;
    my $class = ref($self);
    Carp::croak ("Tried to set $self to +-inf in $class\::_binf()");
    }

  $IMPORT=1;					# call our import only once
  $self->{_m} = $MBI->_zero();
  $self->{_e} = $MBI->_zero();
  $self->{_es} = '+';
  }

sub _bone
  {
  # used by parent class bone() to initialize number to 1
  my $self = shift;
  $IMPORT=1;					# call our import only once
  $self->{_m} = $MBI->_one();
  $self->{_e} = $MBI->_zero();
  $self->{_es} = '+';
  }

sub _bzero
  {
  # used by parent class bzero() to initialize number to 0
  my $self = shift;
  $IMPORT=1;					# call our import only once
  $self->{_m} = $MBI->_zero();
  $self->{_e} = $MBI->_zero();
  $self->{_es} = '+';
  }

sub isa
  {
  my ($self,$class) = @_;
  return if $class =~ /^Math::BigInt/;		# we aren't one of these
  UNIVERSAL::isa($self,$class);
  }

sub config
  {
  # return (later set?) configuration data as hash ref
  my $class = shift || 'Math::BigFloat';

  if (@_ == 1 && ref($_[0]) ne 'HASH')
    {
    my $cfg = $class->SUPER::config();
    return $cfg->{$_[0]};
    }

  my $cfg = $class->SUPER::config(@_);

  # now we need only to override the ones that are different from our parent
  $cfg->{class} = $class;
  $cfg->{with} = $MBI;
  $cfg;
  }

##############################################################################
# string conversion

sub bstr 
  {
  # (ref to BFLOAT or num_str ) return num_str
  # Convert number from internal format to (non-scientific) string format.
  # internal format is always normalized (no leading zeros, "-0" => "+0")
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);

  if ($x->{sign} !~ /^[+-]$/)
    {
    return $x->{sign} unless $x->{sign} eq '+inf';      # -inf, NaN
    return 'inf';                                       # +inf
    }

  my $es = '0'; my $len = 1; my $cad = 0; my $dot = '.';

  # $x is zero?
  my $not_zero = !($x->{sign} eq '+' && $MBI->_is_zero($x->{_m}));
  if ($not_zero)
    {
    $es = $MBI->_str($x->{_m});
    $len = CORE::length($es);
    my $e = $MBI->_num($x->{_e});	
    $e = -$e if $x->{_es} eq '-';
    if ($e < 0)
      {
      $dot = '';
      # if _e is bigger than a scalar, the following will blow your memory
      if ($e <= -$len)
        {
        my $r = abs($e) - $len;
        $es = '0.'. ('0' x $r) . $es; $cad = -($len+$r);
        }
      else
        {
        substr($es,$e,0) = '.'; $cad = $MBI->_num($x->{_e});
        $cad = -$cad if $x->{_es} eq '-';
        }
      }
    elsif ($e > 0)
      {
      # expand with zeros
      $es .= '0' x $e; $len += $e; $cad = 0;
      }
    } # if not zero

  $es = '-'.$es if $x->{sign} eq '-';
  # if set accuracy or precision, pad with zeros on the right side
  if ((defined $x->{_a}) && ($not_zero))
    {
    # 123400 => 6, 0.1234 => 4, 0.001234 => 4
    my $zeros = $x->{_a} - $cad;		# cad == 0 => 12340
    $zeros = $x->{_a} - $len if $cad != $len;
    $es .= $dot.'0' x $zeros if $zeros > 0;
    }
  elsif ((($x->{_p} || 0) < 0))
    {
    # 123400 => 6, 0.1234 => 4, 0.001234 => 6
    my $zeros = -$x->{_p} + $cad;
    $es .= $dot.'0' x $zeros if $zeros > 0;
    }
  $es;
  }

sub bsstr
  {
  # (ref to BFLOAT or num_str ) return num_str
  # Convert number from internal format to scientific string format.
  # internal format is always normalized (no leading zeros, "-0E0" => "+0E0")
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);

  if ($x->{sign} !~ /^[+-]$/)
    {
    return $x->{sign} unless $x->{sign} eq '+inf';      # -inf, NaN
    return 'inf';                                       # +inf
    }
  my $sep = 'e'.$x->{_es};
  my $sign = $x->{sign}; $sign = '' if $sign eq '+';
  $sign . $MBI->_str($x->{_m}) . $sep . $MBI->_str($x->{_e});
  }
    
sub numify 
  {
  # Make a Perl scalar number from a Math::BigFloat object.
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);

  if ($x -> is_nan()) {
      require Math::Complex;
      my $inf = Math::Complex::Inf();
      return $inf - $inf;
  }

  if ($x -> is_inf()) {
      require Math::Complex;
      my $inf = Math::Complex::Inf();
      return $x -> is_negative() ? -$inf : $inf;
  }

  # Create a string and let Perl's atoi()/atof() handle the rest.
  return 0 + $x -> bsstr();
  }

##############################################################################
# public stuff (usually prefixed with "b")

sub bneg
  {
  # (BINT or num_str) return BINT
  # negate number or make a negated number from string
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);

  return $x if $x->modify('bneg');

  # for +0 do not negate (to have always normalized +0). Does nothing for 'NaN'
  $x->{sign} =~ tr/+-/-+/ unless ($x->{sign} eq '+' && $MBI->_is_zero($x->{_m}));
  $x;
  }

# tels 2001-08-04 
# XXX TODO this must be overwritten and return NaN for non-integer values
# band(), bior(), bxor(), too
#sub bnot
#  {
#  $class->SUPER::bnot($class,@_);
#  }

sub bcmp 
  {
  # Compares 2 values.  Returns one of undef, <0, =0, >0. (suitable for sort)

  # set up parameters
  my ($self,$x,$y) = (ref($_[0]),@_);

  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y) = objectify(2,@_);
    }

  return $upgrade->bcmp($x,$y) if defined $upgrade &&
    ((!$x->isa($self)) || (!$y->isa($self)));

  # Handle all 'nan' cases.

  return undef if ($x->{sign} eq $nan) || ($y->{sign} eq $nan);

  # Handle all '+inf' and '-inf' cases.

  return  0 if ($x->{sign} eq '+inf' && $y->{sign} eq '+inf' ||
                $x->{sign} eq '-inf' && $y->{sign} eq '-inf');
  return +1 if $x->{sign} eq '+inf';    # x = +inf and y < +inf
  return -1 if $x->{sign} eq '-inf';    # x = -inf and y > -inf
  return -1 if $y->{sign} eq '+inf';    # x < +inf and y = +inf
  return +1 if $y->{sign} eq '-inf';    # x > -inf and y = -inf

  # Handle all cases with opposite signs.

  return +1 if $x->{sign} eq '+' && $y->{sign} eq '-';  # also does 0 <=> -y
  return -1 if $x->{sign} eq '-' && $y->{sign} eq '+';  # also does -x <=> 0

  # Handle all remaining zero cases.

  my $xz = $x->is_zero();
  my $yz = $y->is_zero();
  return  0 if $xz && $yz;                              # 0 <=> 0
  return -1 if $xz && $y->{sign} eq '+';                # 0 <=> +y
  return +1 if $yz && $x->{sign} eq '+';                # +x <=> 0

  # Both arguments are now finite, non-zero numbers with the same sign.

  my $cmp;

  # The next step is to compare the exponents, but since each mantissa is an
  # integer of arbitrary value, the exponents must be normalized by the length
  # of the mantissas before we can compare them.

  my $mxl = $MBI->_len($x->{_m});
  my $myl = $MBI->_len($y->{_m});

  # If the mantissas have the same length, there is no point in normalizing the
  # exponents by the length of the mantissas, so treat that as a special case.

  if ($mxl == $myl) {

      # First handle the two cases where the exponents have different signs.

      if ($x->{_es} eq '+' && $y->{_es} eq '-') {
          $cmp = +1;
      }

      elsif ($x->{_es} eq '-' && $y->{_es} eq '+') {
          $cmp = -1;
      }

      # Then handle the case where the exponents have the same sign.

      else {
          $cmp = $MBI->_acmp($x->{_e}, $y->{_e});
          $cmp = -$cmp if $x->{_es} eq '-';
      }

      # Adjust for the sign, which is the same for x and y, and bail out if
      # we're done.

      $cmp = -$cmp if $x->{sign} eq '-';        # 124 > 123, but -124 < -123
      return $cmp if $cmp;

  }

  # We must normalize each exponent by the length of the corresponding
  # mantissa. Life is a lot easier if we first make both exponents
  # non-negative. We do this by adding the same positive value to both
  # exponent. This is safe, because when comparing the exponents, only the
  # relative difference is important.

  my $ex;
  my $ey;

  if ($x->{_es} eq '+') {

      # If the exponent of x is >= 0 and the exponent of y is >= 0, there is no
      # need to do anything special.

      if ($y->{_es} eq '+') {
          $ex = $MBI->_copy($x->{_e});
          $ey = $MBI->_copy($y->{_e});
      }

      # If the exponent of x is >= 0 and the exponent of y is < 0, add the
      # absolute value of the exponent of y to both.

      else {
          $ex = $MBI->_copy($x->{_e});
          $ex = $MBI->_add($ex, $y->{_e});      # ex + |ey|
          $ey = $MBI->_zero();                  # -ex + |ey| = 0
      }

  } else {

      # If the exponent of x is < 0 and the exponent of y is >= 0, add the
      # absolute value of the exponent of x to both.

      if ($y->{_es} eq '+') {
          $ex = $MBI->_zero();                  # -ex + |ex| = 0
          $ey = $MBI->_copy($y->{_e});
          $ey = $MBI->_add($ey, $x->{_e});      # ey + |ex|
      }

      # If the exponent of x is < 0 and the exponent of y is < 0, add the
      # absolute values of both exponents to both exponents.

      else {
          $ex = $MBI->_copy($y->{_e});          # -ex + |ey| + |ex| = |ey|
          $ey = $MBI->_copy($x->{_e});          # -ey + |ex| + |ey| = |ex|
      }

  }

  # Now we can normalize the exponents by adding lengths of the mantissas.

  $MBI->_add($ex, $MBI->_new($mxl));
  $MBI->_add($ey, $MBI->_new($myl));

  # We're done if the exponents are different.

  $cmp = $MBI->_acmp($ex, $ey);
  $cmp = -$cmp if $x->{sign} eq '-';            # 124 > 123, but -124 < -123
  return $cmp if $cmp;

  # Compare the mantissas, but first normalize them by padding the shorter
  # mantissa with zeros (shift left) until it has the same length as the longer
  # mantissa.

  my $mx = $x->{_m};
  my $my = $y->{_m};

  if ($mxl > $myl) {
      $my = $MBI->_lsft($MBI->_copy($my), $MBI->_new($mxl - $myl), 10);
  } elsif ($mxl < $myl) {
      $mx = $MBI->_lsft($MBI->_copy($mx), $MBI->_new($myl - $mxl), 10);
  }

  $cmp = $MBI->_acmp($mx, $my);
  $cmp = -$cmp if $x->{sign} eq '-';            # 124 > 123, but -124 < -123
  return $cmp;

  }

sub bacmp 
  {
  # Compares 2 values, ignoring their signs. 
  # Returns one of undef, <0, =0, >0. (suitable for sort)
  
  # set up parameters
  my ($self,$x,$y) = (ref($_[0]),@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y) = objectify(2,@_);
    }

  return $upgrade->bacmp($x,$y) if defined $upgrade &&
    ((!$x->isa($self)) || (!$y->isa($self)));

  # handle +-inf and NaN's
  if ($x->{sign} !~ /^[+-]$/ || $y->{sign} !~ /^[+-]$/)
    {
    return undef if (($x->{sign} eq $nan) || ($y->{sign} eq $nan));
    return 0 if ($x->is_inf() && $y->is_inf());
    return 1 if ($x->is_inf() && !$y->is_inf());
    return -1;
    }

  # shortcut 
  my $xz = $x->is_zero();
  my $yz = $y->is_zero();
  return 0 if $xz && $yz;				# 0 <=> 0
  return -1 if $xz && !$yz;				# 0 <=> +y
  return 1 if $yz && !$xz;				# +x <=> 0

  # adjust so that exponents are equal
  my $lxm = $MBI->_len($x->{_m});
  my $lym = $MBI->_len($y->{_m});
  my ($xes,$yes) = (1,1);
  $xes = -1 if $x->{_es} ne '+';
  $yes = -1 if $y->{_es} ne '+';
  # the numify somewhat limits our length, but makes it much faster
  my $lx = $lxm + $xes * $MBI->_num($x->{_e});
  my $ly = $lym + $yes * $MBI->_num($y->{_e});
  my $l = $lx - $ly;
  return $l <=> 0 if $l != 0;
  
  # lengths (corrected by exponent) are equal
  # so make mantissa equal-length by padding with zero (shift left)
  my $diff = $lxm - $lym;
  my $xm = $x->{_m};		# not yet copy it
  my $ym = $y->{_m};
  if ($diff > 0)
    {
    $ym = $MBI->_copy($y->{_m});
    $ym = $MBI->_lsft($ym, $MBI->_new($diff), 10);
    }
  elsif ($diff < 0)
    {
    $xm = $MBI->_copy($x->{_m});
    $xm = $MBI->_lsft($xm, $MBI->_new(-$diff), 10);
    }
  $MBI->_acmp($xm,$ym);
  }

sub badd 
  {
  # add second arg (BFLOAT or string) to first (BFLOAT) (modifies first)
  # return result as BFLOAT

  # set up parameters
  my ($self,$x,$y,@r) = (ref($_[0]),@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@r) = objectify(2,@_);
    }
 
  return $x if $x->modify('badd');

  # inf and NaN handling
  if (($x->{sign} !~ /^[+-]$/) || ($y->{sign} !~ /^[+-]$/))
    {
    # NaN first
    return $x->bnan() if (($x->{sign} eq $nan) || ($y->{sign} eq $nan));
    # inf handling
    if (($x->{sign} =~ /^[+-]inf$/) && ($y->{sign} =~ /^[+-]inf$/))
      {
      # +inf++inf or -inf+-inf => same, rest is NaN
      return $x if $x->{sign} eq $y->{sign};
      return $x->bnan();
      }
    # +-inf + something => +inf; something +-inf => +-inf
    $x->{sign} = $y->{sign}, return $x if $y->{sign} =~ /^[+-]inf$/;
    return $x;
    }

  return $upgrade->badd($x,$y,@r) if defined $upgrade &&
   ((!$x->isa($self)) || (!$y->isa($self)));

  $r[3] = $y;						# no push!

  # speed: no add for 0+y or x+0
  return $x->bround(@r) if $y->is_zero();		# x+0
  if ($x->is_zero())					# 0+y
    {
    # make copy, clobbering up x (modify in place!)
    $x->{_e} = $MBI->_copy($y->{_e});
    $x->{_es} = $y->{_es};
    $x->{_m} = $MBI->_copy($y->{_m});
    $x->{sign} = $y->{sign} || $nan;
    return $x->round(@r);
    }
 
  # take lower of the two e's and adapt m1 to it to match m2
  my $e = $y->{_e};
  $e = $MBI->_zero() if !defined $e;		# if no BFLOAT?
  $e = $MBI->_copy($e);				# make copy (didn't do it yet)

  my $es;

  ($e,$es) = _e_sub($e, $x->{_e}, $y->{_es} || '+', $x->{_es});

  my $add = $MBI->_copy($y->{_m});

  if ($es eq '-')				# < 0
    {
    $MBI->_lsft( $x->{_m}, $e, 10);
    ($x->{_e},$x->{_es}) = _e_add($x->{_e}, $e, $x->{_es}, $es);
    }
  elsif (!$MBI->_is_zero($e))			# > 0
    {
    $MBI->_lsft($add, $e, 10);
    }
  # else: both e are the same, so just leave them

  if ($x->{sign} eq $y->{sign})
    {
    # add
    $x->{_m} = $MBI->_add($x->{_m}, $add);
    }
  else
    {
    ($x->{_m}, $x->{sign}) = 
     _e_add($x->{_m}, $add, $x->{sign}, $y->{sign});
    }

  # delete trailing zeros, then round
  $x->bnorm()->round(@r);
  }

# sub bsub is inherited from Math::BigInt!

sub binc
  {
  # increment arg by one
  my ($self,$x,@r) = ref($_[0]) ? (ref($_[0]),@_) : objectify(1,@_);

  return $x if $x->modify('binc');

  if ($x->{_es} eq '-')
    {
    return $x->badd($self->bone(),@r);	#  digits after dot
    }

  if (!$MBI->_is_zero($x->{_e}))		# _e == 0 for NaN, inf, -inf
    {
    # 1e2 => 100, so after the shift below _m has a '0' as last digit
    $x->{_m} = $MBI->_lsft($x->{_m}, $x->{_e},10);	# 1e2 => 100
    $x->{_e} = $MBI->_zero();				# normalize
    $x->{_es} = '+';
    # we know that the last digit of $x will be '1' or '9', depending on the
    # sign
    }
  # now $x->{_e} == 0
  if ($x->{sign} eq '+')
    {
    $MBI->_inc($x->{_m});
    return $x->bnorm()->bround(@r);
    }
  elsif ($x->{sign} eq '-')
    {
    $MBI->_dec($x->{_m});
    $x->{sign} = '+' if $MBI->_is_zero($x->{_m}); # -1 +1 => -0 => +0
    return $x->bnorm()->bround(@r);
    }
  # inf, nan handling etc
  $x->badd($self->bone(),@r);			# badd() does round 
  }

sub bdec
  {
  # decrement arg by one
  my ($self,$x,@r) = ref($_[0]) ? (ref($_[0]),@_) : objectify(1,@_);

  return $x if $x->modify('bdec');

  if ($x->{_es} eq '-')
    {
    return $x->badd($self->bone('-'),@r);	#  digits after dot
    }

  if (!$MBI->_is_zero($x->{_e}))
    {
    $x->{_m} = $MBI->_lsft($x->{_m}, $x->{_e},10);	# 1e2 => 100
    $x->{_e} = $MBI->_zero();				# normalize
    $x->{_es} = '+';
    }
  # now $x->{_e} == 0
  my $zero = $x->is_zero();
  # <= 0
  if (($x->{sign} eq '-') || $zero)
    {
    $MBI->_inc($x->{_m});
    $x->{sign} = '-' if $zero;				# 0 => 1 => -1
    $x->{sign} = '+' if $MBI->_is_zero($x->{_m});	# -1 +1 => -0 => +0
    return $x->bnorm()->round(@r);
    }
  # > 0
  elsif ($x->{sign} eq '+')
    {
    $MBI->_dec($x->{_m});
    return $x->bnorm()->round(@r);
    }
  # inf, nan handling etc
  $x->badd($self->bone('-'),@r);		# does round
  } 

sub DEBUG () { 0; }

sub blog
  {
  my ($self,$x,$base,$a,$p,$r) = ref($_[0]) ? (ref($_[0]),@_) : objectify(1,@_);

  # If called as $x -> blog() or $x -> blog(undef), don't objectify the
  # undefined base, since undef signals that the base is Euler's number.
  #unless (ref($x) && !defined($base)) {
  #    # objectify is costly, so avoid it
  #    if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1]))) {
  #        ($self,$x,$base,$a,$p,$r) = objectify(2,@_);
  #    }
  #}

  return $x if $x->modify('blog');

  return $x -> bnan() if $x -> is_nan();

  # we need to limit the accuracy to protect against overflow
  my $fallback = 0;
  my ($scale,@params);
  ($x,@params) = $x->_find_round_parameters($a,$p,$r);

  # no rounding at all, so must use fallback
  if (scalar @params == 0)
    {
    # simulate old behaviour
    $params[0] = $self->div_scale();	# and round to it as accuracy
    $params[1] = undef;			# P = undef
    $scale = $params[0]+4; 		# at least four more for proper round
    $params[2] = $r;			# round mode by caller or undef
    $fallback = 1;			# to clear a/p afterwards
    }
  else
    {
    # the 4 below is empirical, and there might be cases where it is not
    # enough...
    $scale = abs($params[0] || $params[1]) + 4;	# take whatever is defined
    }

  my $done = 0;
  if (defined $base) {
      $base = $self -> new($base) unless ref $base;
      if ($base -> is_nan() || $base -> is_one()) {
          $x -> bnan();
          $done = 1;
      } elsif ($base -> is_inf() || $base -> is_zero()) {
          if ($x -> is_inf() || $x -> is_zero()) {
              $x -> bnan();
          } else {
              $x -> bzero(@params);
          }
          $done = 1;
      } elsif ($base -> is_negative()) {        # -inf < base < 0
          if ($x -> is_one()) {                 #     x = 1
              $x -> bzero(@params);
          } elsif ($x == $base) {
              $x -> bone('+', @params);         #     x = base
          } else {
              $x -> bnan();                     #     otherwise
          }
          $done = 1;
      } elsif ($x == $base) {
          $x -> bone('+', @params);             # 0 < base && 0 < x < inf
          $done = 1;
      }
  }

  # We now know that the base is either undefined or positive and finite.

  unless ($done) {
      if ($x -> is_inf()) {             #   x = +/-inf
          my $sign = defined $base && $base < 1 ? '-' : '+';
          $x -> binf($sign);
          $done = 1;
      } elsif ($x -> is_neg()) {        #   -inf < x < 0
          $x -> bnan();
          $done = 1;
      } elsif ($x -> is_one()) {        #   x = 1
          $x -> bzero(@params);
          $done = 1;
      } elsif ($x -> is_zero()) {       #   x = 0
          my $sign = defined $base && $base < 1 ? '+' : '-';
          $x -> binf($sign);
          $done = 1;
      }
  }

  if ($done) {
      if ($fallback) {
        # clear a/p after round, since user did not request it
          delete $x->{_a};
          delete $x->{_p};
        }
      return $x;
      }

  # when user set globals, they would interfere with our calculation, so
  # disable them and later re-enable them
  no strict 'refs';
  my $abr = "$self\::accuracy"; my $ab = $$abr; $$abr = undef;
  my $pbr = "$self\::precision"; my $pb = $$pbr; $$pbr = undef;
  # we also need to disable any set A or P on $x (_find_round_parameters took
  # them already into account), since these would interfere, too
  delete $x->{_a}; delete $x->{_p};
  # need to disable $upgrade in BigInt, to avoid deep recursion
  local $Math::BigInt::upgrade = undef;
  local $Math::BigFloat::downgrade = undef;

  # upgrade $x if $x is not a BigFloat (handle BigInt input)
  # XXX TODO: rebless!
  if (!$x->isa('Math::BigFloat'))
    {
    $x = Math::BigFloat->new($x);
    $self = ref($x);
    }
  
  $done = 0;

  # If the base is defined and an integer, try to calculate integer result
  # first. This is very fast, and in case the real result was found, we can
  # stop right here.
  if (defined $base && $base->is_int() && $x->is_int())
    {
    my $i = $MBI->_copy( $x->{_m} );
    $MBI->_lsft( $i, $x->{_e}, 10 ) unless $MBI->_is_zero($x->{_e});
    my $int = Math::BigInt->bzero();
    $int->{value} = $i;
    $int->blog($base->as_number());
    # if ($exact)
    if ($base->as_number()->bpow($int) == $x)
      {
      # found result, return it
      $x->{_m} = $int->{value};
      $x->{_e} = $MBI->_zero();
      $x->{_es} = '+';
      $x->bnorm();
      $done = 1;
      }
    }

  if ($done == 0)
    {
    # base is undef, so base should be e (Euler's number), so first calculate the
    # log to base e (using reduction by 10 (and probably 2)):
    $self->_log_10($x,$scale);

    # and if a different base was requested, convert it
    if (defined $base)
      {
      $base = Math::BigFloat->new($base) unless $base->isa('Math::BigFloat');
      # not ln, but some other base (don't modify $base)
      $x->bdiv( $base->copy()->blog(undef,$scale), $scale );
      }
    }
 
  # shortcut to not run through _find_round_parameters again
  if (defined $params[0])
    {
    $x->bround($params[0],$params[2]);		# then round accordingly
    }
  else
    {
    $x->bfround($params[1],$params[2]);		# then round accordingly
    }
  if ($fallback)
    {
    # clear a/p after round, since user did not request it
    delete $x->{_a}; delete $x->{_p};
    }
  # restore globals
  $$abr = $ab; $$pbr = $pb;

  $x;
  }

sub _len_to_steps
  {
  # Given D (digits in decimal), compute N so that N! (N factorial) is
  # at least D digits long. D should be at least 50.
  my $d = shift;

  # two constants for the Ramanujan estimate of ln(N!)
  my $lg2 = log(2 * 3.14159265) / 2;
  my $lg10 = log(10);

  # D = 50 => N => 42, so L = 40 and R = 50
  my $l = 40; my $r = $d;

  # Otherwise this does not work under -Mbignum and we do not yet have "no bignum;" :(
  $l = $l->numify if ref($l);
  $r = $r->numify if ref($r);
  $lg2 = $lg2->numify if ref($lg2);
  $lg10 = $lg10->numify if ref($lg10);

  # binary search for the right value (could this be written as the reverse of lg(n!)?)
  while ($r - $l > 1)
    {
    my $n = int(($r - $l) / 2) + $l;
    my $ramanujan = 
      int(($n * log($n) - $n + log( $n * (1 + 4*$n*(1+2*$n)) ) / 6 + $lg2) / $lg10);
    $ramanujan > $d ? $r = $n : $l = $n;
    }
  $l;
  }

sub bnok
  {
  # Calculate n over k (binomial coefficient or "choose" function) as integer.
  # set up parameters
  my ($self,$x,$y,@r) = (ref($_[0]),@_);

  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@r) = objectify(2,@_);
    }

  return $x if $x->modify('bnok');

  return $x->bnan() if $x->is_nan() || $y->is_nan();
  return $x->binf() if $x->is_inf();

  my $u = $x->as_int();
  $u->bnok($y->as_int());

  $x->{_m} = $u->{value};
  $x->{_e} = $MBI->_zero();
  $x->{_es} = '+';
  $x->{sign} = '+';
  $x->bnorm(@r);
  }

sub bexp
  {
  # Calculate e ** X (Euler's number to the power of X)
  my ($self,$x,$a,$p,$r) = ref($_[0]) ? (ref($_[0]),@_) : objectify(1,@_);

  return $x if $x->modify('bexp');

  return $x->binf() if $x->{sign} eq '+inf';
  return $x->bzero() if $x->{sign} eq '-inf';

  # we need to limit the accuracy to protect against overflow
  my $fallback = 0;
  my ($scale,@params);
  ($x,@params) = $x->_find_round_parameters($a,$p,$r);

  # also takes care of the "error in _find_round_parameters?" case
  return $x if $x->{sign} eq 'NaN';

  # no rounding at all, so must use fallback
  if (scalar @params == 0)
    {
    # simulate old behaviour
    $params[0] = $self->div_scale();	# and round to it as accuracy
    $params[1] = undef;			# P = undef
    $scale = $params[0]+4; 		# at least four more for proper round
    $params[2] = $r;			# round mode by caller or undef
    $fallback = 1;			# to clear a/p afterwards
    }
  else
    {
    # the 4 below is empirical, and there might be cases where it's not enough...
    $scale = abs($params[0] || $params[1]) + 4;	# take whatever is defined
    }

  return $x->bone(@params) if $x->is_zero();

  if (!$x->isa('Math::BigFloat'))
    {
    $x = Math::BigFloat->new($x);
    $self = ref($x);
    }
  
  # when user set globals, they would interfere with our calculation, so
  # disable them and later re-enable them
  no strict 'refs';
  my $abr = "$self\::accuracy"; my $ab = $$abr; $$abr = undef;
  my $pbr = "$self\::precision"; my $pb = $$pbr; $$pbr = undef;
  # we also need to disable any set A or P on $x (_find_round_parameters took
  # them already into account), since these would interfere, too
  delete $x->{_a}; delete $x->{_p};
  # need to disable $upgrade in BigInt, to avoid deep recursion
  local $Math::BigInt::upgrade = undef;
  local $Math::BigFloat::downgrade = undef;

  my $x_org = $x->copy();

  # We use the following Taylor series:

  #           x    x^2   x^3   x^4
  #  e = 1 + --- + --- + --- + --- ...
  #           1!    2!    3!    4!

  # The difference for each term is X and N, which would result in:
  # 2 copy, 2 mul, 2 add, 1 inc, 1 div operations per term

  # But it is faster to compute exp(1) and then raising it to the
  # given power, esp. if $x is really big and an integer because:

  #  * The numerator is always 1, making the computation faster
  #  * the series converges faster in the case of x == 1
  #  * We can also easily check when we have reached our limit: when the
  #    term to be added is smaller than "1E$scale", we can stop - f.i.
  #    scale == 5, and we have 1/40320, then we stop since 1/40320 < 1E-5.
  #  * we can compute the *exact* result by simulating bigrat math:

  #  1   1    gcd(3,4) = 1    1*24 + 1*6    5
  #  - + -                  = ---------- =  --                 
  #  6   24                      6*24       24

  # We do not compute the gcd() here, but simple do:
  #  1   1    1*24 + 1*6   30
  #  - + -  = --------- =  --                 
  #  6   24       6*24     144

  # In general:
  #  a   c    a*d + c*b 	and note that c is always 1 and d = (b*f)
  #  - + -  = ---------
  #  b   d       b*d

  # This leads to:         which can be reduced by b to:
  #  a   1     a*b*f + b    a*f + 1
  #  - + -   = --------- =  -------
  #  b   b*f     b*b*f        b*f

  # The first terms in the series are:

  # 1     1    1    1    1    1     1     1     13700
  # -- + -- + -- + -- + -- + --- + --- + ---- = -----
  # 1     1    2    6   24   120   720   5040   5040

  # Note that we cannot simple reduce 13700/5040 to 685/252, but must keep A and B!

  if ($scale <= 75)
    {
    # set $x directly from a cached string form
    $x->{_m} = $MBI->_new(
    "27182818284590452353602874713526624977572470936999595749669676277240766303535476");
    $x->{sign} = '+';
    $x->{_es} = '-';
    $x->{_e} = $MBI->_new(79);
    }
  else
    {
    # compute A and B so that e = A / B.
 
    # After some terms we end up with this, so we use it as a starting point:
    my $A = $MBI->_new("90933395208605785401971970164779391644753259799242");
    my $F = $MBI->_new(42); my $step = 42;

    # Compute how many steps we need to take to get $A and $B sufficiently big
    my $steps = _len_to_steps($scale - 4);
#    print STDERR "# Doing $steps steps for ", $scale-4, " digits\n";
    while ($step++ <= $steps)
      {
      # calculate $a * $f + 1
      $A = $MBI->_mul($A, $F);
      $A = $MBI->_inc($A);
      # increment f
      $F = $MBI->_inc($F);
      }
    # compute $B as factorial of $steps (this is faster than doing it manually)
    my $B = $MBI->_fac($MBI->_new($steps));
    
#  print "A ", $MBI->_str($A), "\nB ", $MBI->_str($B), "\n";

    # compute A/B with $scale digits in the result (truncate, not round)
    $A = $MBI->_lsft( $A, $MBI->_new($scale), 10);
    $A = $MBI->_div( $A, $B );

    $x->{_m} = $A;
    $x->{sign} = '+';
    $x->{_es} = '-';
    $x->{_e} = $MBI->_new($scale);
    }

  # $x contains now an estimate of e, with some surplus digits, so we can round
  if (!$x_org->is_one())
    {
    # Reduce size of fractional part, followup with integer power of two.
    my $lshift = 0;
    while ($lshift < 30 && $x_org->bacmp(2 << $lshift) > 0)
      {
        $lshift++;
      }
    # Raise $x to the wanted power and round it.
    if ($lshift == 0)
      {
        $x->bpow($x_org, @params);
      }
    else
      {
        my($mul, $rescale) = (1 << $lshift, $scale+1+$lshift);
        $x->bpow(scalar $x_org->bdiv($mul,$rescale),$rescale)->bpow($mul, @params);
      }
    }
  else
    {
    # else just round the already computed result
    delete $x->{_a}; delete $x->{_p};
    # shortcut to not run through _find_round_parameters again
    if (defined $params[0])
      {
      $x->bround($params[0],$params[2]);		# then round accordingly
      }
    else
      {
      $x->bfround($params[1],$params[2]);		# then round accordingly
      }
    }
  if ($fallback)
    {
    # clear a/p after round, since user did not request it
    delete $x->{_a}; delete $x->{_p};
    }
  # restore globals
  $$abr = $ab; $$pbr = $pb;

  $x;						# return modified $x
  }

sub _log
  {
  # internal log function to calculate ln() based on Taylor series.
  # Modifies $x in place.
  my ($self,$x,$scale) = @_;

  # in case of $x == 1, result is 0
  return $x->bzero() if $x->is_one();

  # XXX TODO: rewrite this in a similar manner to bexp()

  # http://www.efunda.com/math/taylor_series/logarithmic.cfm?search_string=log

  # u = x-1, v = x+1
  #              _                               _
  # Taylor:     |    u    1   u^3   1   u^5       |
  # ln (x)  = 2 |   --- + - * --- + - * --- + ... |  x > 0
  #             |_   v    3   v^3   5   v^5      _|

  # This takes much more steps to calculate the result and is thus not used
  # u = x-1
  #              _                               _
  # Taylor:     |    u    1   u^2   1   u^3       |
  # ln (x)  = 2 |   --- + - * --- + - * --- + ... |  x > 1/2
  #             |_   x    2   x^2   3   x^3      _|

  my ($limit,$v,$u,$below,$factor,$two,$next,$over,$f);

  $v = $x->copy(); $v->binc();		# v = x+1
  $x->bdec(); $u = $x->copy();		# u = x-1; x = x-1
  $x->bdiv($v,$scale);			# first term: u/v
  $below = $v->copy();
  $over = $u->copy();
  $u *= $u; $v *= $v;				# u^2, v^2
  $below->bmul($v);				# u^3, v^3
  $over->bmul($u);
  $factor = $self->new(3); $f = $self->new(2);

  my $steps = 0;
  $limit = $self->new("1E-". ($scale-1));
  while (3 < 5)
    {
    # we calculate the next term, and add it to the last
    # when the next term is below our limit, it won't affect the outcome
    # anymore, so we stop

    # calculating the next term simple from over/below will result in quite
    # a time hog if the input has many digits, since over and below will
    # accumulate more and more digits, and the result will also have many
    # digits, but in the end it is rounded to $scale digits anyway. So if we
    # round $over and $below first, we save a lot of time for the division
    # (not with log(1.2345), but try log (123**123) to see what I mean. This
    # can introduce a rounding error if the division result would be f.i.
    # 0.1234500000001 and we round it to 5 digits it would become 0.12346, but
    # if we truncated $over and $below we might get 0.12345. Does this matter
    # for the end result? So we give $over and $below 4 more digits to be
    # on the safe side (unscientific error handling as usual... :+D

    $next = $over->copy->bround($scale+4)->bdiv(
      $below->copy->bmul($factor)->bround($scale+4), 
      $scale);

## old version:    
##    $next = $over->copy()->bdiv($below->copy()->bmul($factor),$scale);

    last if $next->bacmp($limit) <= 0;

    delete $next->{_a}; delete $next->{_p};
    $x->badd($next);
    # calculate things for the next term
    $over *= $u; $below *= $v; $factor->badd($f);
    if (DEBUG)
      {
      $steps++; print "step $steps = $x\n" if $steps % 10 == 0;
      }
    }
  print "took $steps steps\n" if DEBUG;
  $x->bmul($f);					# $x *= 2
  }

sub _log_10
  {
  # Internal log function based on reducing input to the range of 0.1 .. 9.99
  # and then "correcting" the result to the proper one. Modifies $x in place.
  my ($self,$x,$scale) = @_;

  # Taking blog() from numbers greater than 10 takes a *very long* time, so we
  # break the computation down into parts based on the observation that:
  #  blog(X*Y) = blog(X) + blog(Y)
  # We set Y here to multiples of 10 so that $x becomes below 1 - the smaller
  # $x is the faster it gets. Since 2*$x takes about 10 times as
  # long, we make it faster by about a factor of 100 by dividing $x by 10.

  # The same observation is valid for numbers smaller than 0.1, e.g. computing
  # log(1) is fastest, and the further away we get from 1, the longer it takes.
  # So we also 'break' this down by multiplying $x with 10 and subtract the
  # log(10) afterwards to get the correct result.

  # To get $x even closer to 1, we also divide by 2 and then use log(2) to
  # correct for this. For instance if $x is 2.4, we use the formula:
  #  blog(2.4 * 2) == blog (1.2) + blog(2)
  # and thus calculate only blog(1.2) and blog(2), which is faster in total
  # than calculating blog(2.4).

  # In addition, the values for blog(2) and blog(10) are cached.

  # Calculate nr of digits before dot:
  my $dbd = $MBI->_num($x->{_e});
  $dbd = -$dbd if $x->{_es} eq '-';
  $dbd += $MBI->_len($x->{_m});

  # more than one digit (e.g. at least 10), but *not* exactly 10 to avoid
  # infinite recursion

  my $calc = 1;					# do some calculation?

  # disable the shortcut for 10, since we need log(10) and this would recurse
  # infinitely deep
  if ($x->{_es} eq '+' && $MBI->_is_one($x->{_e}) && $MBI->_is_one($x->{_m}))
    {
    $dbd = 0;					# disable shortcut
    # we can use the cached value in these cases
    if ($scale <= $LOG_10_A)
      {
      $x->bzero(); $x->badd($LOG_10);		# modify $x in place
      $calc = 0; 				# no need to calc, but round
      }
    # if we can't use the shortcut, we continue normally
    }
  else
    {
    # disable the shortcut for 2, since we maybe have it cached
    if (($MBI->_is_zero($x->{_e}) && $MBI->_is_two($x->{_m})))
      {
      $dbd = 0;					# disable shortcut
      # we can use the cached value in these cases
      if ($scale <= $LOG_2_A)
        {
        $x->bzero(); $x->badd($LOG_2);		# modify $x in place
        $calc = 0; 				# no need to calc, but round
        }
      # if we can't use the shortcut, we continue normally
      }
    }

  # if $x = 0.1, we know the result must be 0-log(10)
  if ($calc != 0 && $x->{_es} eq '-' && $MBI->_is_one($x->{_e}) &&
      $MBI->_is_one($x->{_m}))
    {
    $dbd = 0;					# disable shortcut
    # we can use the cached value in these cases
    if ($scale <= $LOG_10_A)
      {
      $x->bzero(); $x->bsub($LOG_10);
      $calc = 0; 				# no need to calc, but round
      }
    }

  return if $calc == 0;				# already have the result

  # default: these correction factors are undef and thus not used
  my $l_10;				# value of ln(10) to A of $scale
  my $l_2;				# value of ln(2) to A of $scale

  my $two = $self->new(2);

  # $x == 2 => 1, $x == 13 => 2, $x == 0.1 => 0, $x == 0.01 => -1
  # so don't do this shortcut for 1 or 0
  if (($dbd > 1) || ($dbd < 0))
    {
    # convert our cached value to an object if not already (avoid doing this
    # at import() time, since not everybody needs this)
    $LOG_10 = $self->new($LOG_10,undef,undef) unless ref $LOG_10;

    #print "x = $x, dbd = $dbd, calc = $calc\n";
    # got more than one digit before the dot, or more than one zero after the
    # dot, so do:
    #  log(123)    == log(1.23) + log(10) * 2
    #  log(0.0123) == log(1.23) - log(10) * 2
  
    if ($scale <= $LOG_10_A)
      {
      # use cached value
      $l_10 = $LOG_10->copy();		# copy for mul
      }
    else
      {
      # else: slower, compute and cache result
      # also disable downgrade for this code path
      local $Math::BigFloat::downgrade = undef;

      # shorten the time to calculate log(10) based on the following:
      # log(1.25 * 8) = log(1.25) + log(8)
      #               = log(1.25) + log(2) + log(2) + log(2)

      # first get $l_2 (and possible compute and cache log(2))
      $LOG_2 = $self->new($LOG_2,undef,undef) unless ref $LOG_2;
      if ($scale <= $LOG_2_A)
        {
        # use cached value
        $l_2 = $LOG_2->copy();			# copy() for the mul below
        }
      else
        {
        # else: slower, compute and cache result
        $l_2 = $two->copy(); $self->_log($l_2, $scale); # scale+4, actually
        $LOG_2 = $l_2->copy();			# cache the result for later
						# the copy() is for mul below
        $LOG_2_A = $scale;
        }

      # now calculate log(1.25):
      $l_10 = $self->new('1.25'); $self->_log($l_10, $scale); # scale+4, actually

      # log(1.25) + log(2) + log(2) + log(2):
      $l_10->badd($l_2);
      $l_10->badd($l_2);
      $l_10->badd($l_2);
      $LOG_10 = $l_10->copy();		# cache the result for later
					# the copy() is for mul below
      $LOG_10_A = $scale;
      }
    $dbd-- if ($dbd > 1); 		# 20 => dbd=2, so make it dbd=1	
    $l_10->bmul( $self->new($dbd));	# log(10) * (digits_before_dot-1)
    my $dbd_sign = '+';
    if ($dbd < 0)
      {
      $dbd = -$dbd;
      $dbd_sign = '-';
      }
    ($x->{_e}, $x->{_es}) = 
	_e_sub( $x->{_e}, $MBI->_new($dbd), $x->{_es}, $dbd_sign); # 123 => 1.23
 
    }

  # Now: 0.1 <= $x < 10 (and possible correction in l_10)

  ### Since $x in the range 0.5 .. 1.5 is MUCH faster, we do a repeated div
  ### or mul by 2 (maximum times 3, since x < 10 and x > 0.1)

  $HALF = $self->new($HALF) unless ref($HALF);

  my $twos = 0;				# default: none (0 times)	
  while ($x->bacmp($HALF) <= 0)		# X <= 0.5
    {
    $twos--; $x->bmul($two);
    }
  while ($x->bacmp($two) >= 0)		# X >= 2
    {
    $twos++; $x->bdiv($two,$scale+4);		# keep all digits
    }
  $x->bround($scale+4);
  # $twos > 0 => did mul 2, < 0 => did div 2 (but we never did both)
  # So calculate correction factor based on ln(2):
  if ($twos != 0)
    {
    $LOG_2 = $self->new($LOG_2,undef,undef) unless ref $LOG_2;
    if ($scale <= $LOG_2_A)
      {
      # use cached value
      $l_2 = $LOG_2->copy();			# copy() for the mul below
      }
    else
      {
      # else: slower, compute and cache result
      # also disable downgrade for this code path
      local $Math::BigFloat::downgrade = undef;
      $l_2 = $two->copy(); $self->_log($l_2, $scale); # scale+4, actually
      $LOG_2 = $l_2->copy();			# cache the result for later
						# the copy() is for mul below
      $LOG_2_A = $scale;
      }
    $l_2->bmul($twos);		# * -2 => subtract, * 2 => add
    }
  else
    {
      undef $l_2;
    }
  
  $self->_log($x,$scale);			# need to do the "normal" way
  $x->badd($l_10) if defined $l_10; 		# correct it by ln(10)
  $x->badd($l_2) if defined $l_2;		# and maybe by ln(2)

  # all done, $x contains now the result
  $x;
  }

sub blcm 
  { 
  # (BFLOAT or num_str, BFLOAT or num_str) return BFLOAT
  # does not modify arguments, but returns new object
  # Lowest Common Multiplicator

  my ($self,@arg) = objectify(0,@_);
  my $x = $self->new(shift @arg);
  while (@arg) { $x = Math::BigInt::__lcm($x,shift @arg); } 
  $x;
  }

sub bgcd
  {
  # (BINT or num_str, BINT or num_str) return BINT
  # does not modify arguments, but returns new object

  my $y = shift;
  $y = __PACKAGE__->new($y) if !ref($y);
  my $self = ref($y);
  my $x = $y->copy()->babs();			# keep arguments

  return $x->bnan() if $x->{sign} !~ /^[+-]$/	# x NaN?
	|| !$x->is_int();			# only for integers now

  while (@_)
    {
    my $t = shift; $t = $self->new($t) if !ref($t);
    $y = $t->copy()->babs();
    
    return $x->bnan() if $y->{sign} !~ /^[+-]$/	# y NaN?
     	|| !$y->is_int();			# only for integers now

    # greatest common divisor
    while (! $y->is_zero())
      {
      ($x,$y) = ($y->copy(), $x->copy()->bmod($y));
      }

    last if $x->is_one();
    }
  $x;
  }

##############################################################################

sub _e_add {
    # Internal helper sub to take two positive integers and their signs and
    # then add them. Input ($CALC, $CALC, ('+'|'-'), ('+'|'-')), output
    # ($CALC, ('+'|'-')).

    my ($x, $y, $xs, $ys) = @_;

    # if the signs are equal we can add them (-5 + -3 => -(5 + 3) => -8)
    if ($xs eq $ys) {
        $x = $MBI->_add($x, $y);                # +a + +b or -a + -b
    } else {
        my $a = $MBI->_acmp($x, $y);
        if ($a == 0) {
            # This does NOT modify $x in-place. TODO: Fix this?
            $x = $MBI->_zero();                 # result is 0
            $xs = '+';
            return ($x, $xs);
        }
        if ($a > 0) {
            $x = $MBI->_sub($x, $y);            # abs sub
        } else {                                # a < 0
            $x = $MBI->_sub ( $y, $x, 1 );      # abs sub
            $xs = $ys;
        }
    }

    $xs = '+' if $xs eq '-' && $MBI->_is_zero($x);      # no "-0"

    return ($x, $xs);
}

sub _e_sub {
  # Internal helper sub to take two positive integers and their signs and
  # then subtract them. Input ($CALC,$CALC,('+'|'-'),('+'|'-')), 
  # output ($CALC,('+'|'-'))
  my ($x,$y,$xs,$ys) = @_;

  # flip sign
    $ys = $ys eq '+' ? '-' : '+';       # swap sign of second operand ...
    _e_add($x, $y, $xs, $ys);           # ... and let _e_add() do the job
  }

###############################################################################
# is_foo methods (is_negative, is_positive are inherited from BigInt)

sub is_int
  {
  # return true if arg (BFLOAT or num_str) is an integer
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);

  (($x->{sign} =~ /^[+-]$/) &&			# NaN and +-inf aren't
   ($x->{_es} eq '+')) ? 1 : 0;			# 1e-1 => no integer
  }

sub is_zero
  {
  # return true if arg (BFLOAT or num_str) is zero
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);

  ($x->{sign} eq '+' && $MBI->_is_zero($x->{_m})) ? 1 : 0;
  }

sub is_one
  {
  # return true if arg (BFLOAT or num_str) is +1 or -1 if signis given
  my ($self,$x,$sign) = ref($_[0]) ? (undef,@_) : objectify(1,@_);

  $sign = '+' if !defined $sign || $sign ne '-';

  ($x->{sign} eq $sign && 
   $MBI->_is_zero($x->{_e}) &&
   $MBI->_is_one($x->{_m}) ) ? 1 : 0; 
  }

sub is_odd
  {
  # return true if arg (BFLOAT or num_str) is odd or false if even
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);
  
  (($x->{sign} =~ /^[+-]$/) &&		# NaN & +-inf aren't
   ($MBI->_is_zero($x->{_e})) &&
   ($MBI->_is_odd($x->{_m}))) ? 1 : 0; 
  }

sub is_even
  {
  # return true if arg (BINT or num_str) is even or false if odd
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);

  (($x->{sign} =~ /^[+-]$/) &&			# NaN & +-inf aren't
   ($x->{_es} eq '+') &&	 		# 123.45 isn't
   ($MBI->_is_even($x->{_m}))) ? 1 : 0;		# but 1200 is
  }

sub bmul
  { 
  # multiply two numbers
  
  # set up parameters
  my ($self,$x,$y,@r) = (ref($_[0]),@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@r) = objectify(2,@_);
    }

  return $x if $x->modify('bmul');

  return $x->bnan() if (($x->{sign} eq $nan) || ($y->{sign} eq $nan));

  # inf handling
  if (($x->{sign} =~ /^[+-]inf$/) || ($y->{sign} =~ /^[+-]inf$/))
    {
    return $x->bnan() if $x->is_zero() || $y->is_zero(); 
    # result will always be +-inf:
    # +inf * +/+inf => +inf, -inf * -/-inf => +inf
    # +inf * -/-inf => -inf, -inf * +/+inf => -inf
    return $x->binf() if ($x->{sign} =~ /^\+/ && $y->{sign} =~ /^\+/);
    return $x->binf() if ($x->{sign} =~ /^-/ && $y->{sign} =~ /^-/);
    return $x->binf('-');
    }
  
  return $upgrade->bmul($x,$y,@r) if defined $upgrade &&
   ((!$x->isa($self)) || (!$y->isa($self)));

  # aEb * cEd = (a*c)E(b+d)
  $MBI->_mul($x->{_m},$y->{_m});
  ($x->{_e}, $x->{_es}) = _e_add($x->{_e}, $y->{_e}, $x->{_es}, $y->{_es});

  $r[3] = $y;				# no push!

  # adjust sign:
  $x->{sign} = $x->{sign} ne $y->{sign} ? '-' : '+';
  $x->bnorm->round(@r);
  }

sub bmuladd
  { 
  # multiply two numbers and add the third to the result
  
  # set up parameters
  my ($self,$x,$y,$z,@r) = objectify(3,@_);

  return $x if $x->modify('bmuladd');

  return $x->bnan() if (($x->{sign} eq $nan) ||
			($y->{sign} eq $nan) ||
			($z->{sign} eq $nan));

  # inf handling
  if (($x->{sign} =~ /^[+-]inf$/) || ($y->{sign} =~ /^[+-]inf$/))
    {
    return $x->bnan() if $x->is_zero() || $y->is_zero(); 
    # result will always be +-inf:
    # +inf * +/+inf => +inf, -inf * -/-inf => +inf
    # +inf * -/-inf => -inf, -inf * +/+inf => -inf
    return $x->binf() if ($x->{sign} =~ /^\+/ && $y->{sign} =~ /^\+/);
    return $x->binf() if ($x->{sign} =~ /^-/ && $y->{sign} =~ /^-/);
    return $x->binf('-');
    }

  return $upgrade->bmul($x,$y,@r) if defined $upgrade &&
   ((!$x->isa($self)) || (!$y->isa($self)));

  # aEb * cEd = (a*c)E(b+d)
  $MBI->_mul($x->{_m},$y->{_m});
  ($x->{_e}, $x->{_es}) = _e_add($x->{_e}, $y->{_e}, $x->{_es}, $y->{_es});

  $r[3] = $y;				# no push!

  # adjust sign:
  $x->{sign} = $x->{sign} ne $y->{sign} ? '-' : '+';

  # z=inf handling (z=NaN handled above)
  $x->{sign} = $z->{sign}, return $x if $z->{sign} =~ /^[+-]inf$/;

  # take lower of the two e's and adapt m1 to it to match m2
  my $e = $z->{_e};
  $e = $MBI->_zero() if !defined $e;		# if no BFLOAT?
  $e = $MBI->_copy($e);				# make copy (didn't do it yet)

  my $es;

  ($e,$es) = _e_sub($e, $x->{_e}, $z->{_es} || '+', $x->{_es});

  my $add = $MBI->_copy($z->{_m});

  if ($es eq '-')				# < 0
    {
    $MBI->_lsft( $x->{_m}, $e, 10);
    ($x->{_e},$x->{_es}) = _e_add($x->{_e}, $e, $x->{_es}, $es);
    }
  elsif (!$MBI->_is_zero($e))			# > 0
    {
    $MBI->_lsft($add, $e, 10);
    }
  # else: both e are the same, so just leave them

  if ($x->{sign} eq $z->{sign})
    {
    # add
    $x->{_m} = $MBI->_add($x->{_m}, $add);
    }
  else
    {
    ($x->{_m}, $x->{sign}) = 
     _e_add($x->{_m}, $add, $x->{sign}, $z->{sign});
    }

  # delete trailing zeros, then round
  $x->bnorm()->round(@r);
  }

sub bdiv 
  {
  # (dividend: BFLOAT or num_str, divisor: BFLOAT or num_str) return 
    # (BFLOAT, BFLOAT) (quo, rem) or BFLOAT (only quo)

  # set up parameters
  my ($self,$x,$y,$a,$p,$r) = (ref($_[0]),@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,$a,$p,$r) = objectify(2,@_);
    }

  return $x if $x->modify('bdiv');

    my $wantarray = wantarray;          # call only once

    # At least one argument is NaN. This is handled the same way as in
    # Math::BigInt -> bdiv().

    if ($x -> is_nan() || $y -> is_nan()) {
        return $wantarray ? ($x -> bnan(), $self -> bnan()) : $x -> bnan();
    }

    # Divide by zero and modulo zero. This is handled the same way as in
    # Math::BigInt -> bdiv(). See the comment in the code for Math::BigInt ->
    # bdiv() for further details.

    if ($y -> is_zero()) {
        my ($quo, $rem);
        if ($wantarray) {
            $rem = $x -> copy();
        }
        if ($x -> is_zero()) {
            $quo = $x -> bnan();
        } else {
            $quo = $x -> binf($x -> {sign});
        }
        return $wantarray ? ($quo, $rem) : $quo;
    }

    # Numerator (dividend) is +/-inf. This is handled the same way as in
    # Math::BigInt -> bdiv(). See the comment in the code for Math::BigInt ->
    # bdiv() for further details.

    if ($x -> is_inf()) {
        my ($quo, $rem);
        $rem = $self -> bnan() if $wantarray;
        if ($y -> is_inf()) {
            $quo = $x -> bnan();
        } else {
            my $sign = $x -> bcmp(0) == $y -> bcmp(0) ? '+' : '-';
            $quo = $x -> binf($sign);
        }
        return $wantarray ? ($quo, $rem) : $quo;
    }

  # Denominator (divisor) is +/-inf. This is handled the same way as in
  # Math::BigInt -> bdiv(), with one exception: In scalar context,
  # Math::BigFloat does true division (although rounded), not floored division
  # (F-division), so a finite number divided by +/-inf is always zero. See the
  # comment in the code for Math::BigInt -> bdiv() for further details.

  if ($y -> is_inf()) {
      my ($quo, $rem);
      if ($wantarray) {
          if ($x -> is_zero() || $x -> bcmp(0) == $y -> bcmp(0)) {
              $rem = $x -> copy();
              $quo = $x -> bzero();
          } else {
              $rem = $self -> binf($y -> {sign});
              $quo = $x -> bone('-');
          }
          return ($quo, $rem);
      } else {
        if ($y -> is_inf()) {
            if ($x -> is_nan() || $x -> is_inf()) {
                return $x -> bnan();
            } else {
                return $x -> bzero();
            }
        }
    }
    }

  # At this point, both the numerator and denominator are finite numbers, and
  # the denominator (divisor) is non-zero.

  # x == 0?
  return wantarray ? ($x,$self->bzero()) : $x if $x->is_zero();

  # upgrade ?
  return $upgrade->bdiv($upgrade->new($x),$y,$a,$p,$r) if defined $upgrade;

  # we need to limit the accuracy to protect against overflow
  my $fallback = 0;
  my (@params,$scale);
  ($x,@params) = $x->_find_round_parameters($a,$p,$r,$y);

  return $x if $x->is_nan();		# error in _find_round_parameters?

  # no rounding at all, so must use fallback
    if (scalar @params == 0)
    {
    # simulate old behaviour
    $params[0] = $self->div_scale();	# and round to it as accuracy
    $scale = $params[0]+4; 		# at least four more for proper round
    $params[2] = $r;			# round mode by caller or undef
    $fallback = 1;			# to clear a/p afterwards
    } else {
    # the 4 below is empirical, and there might be cases where it is not
    # enough...
    $scale = abs($params[0] || $params[1]) + 4;	# take whatever is defined
    }

    my $rem;
    $rem = $self -> bzero() if wantarray;

  $y = $self->new($y) unless $y->isa('Math::BigFloat');

  my $lx = $MBI -> _len($x->{_m}); my $ly = $MBI -> _len($y->{_m});
  $scale = $lx if $lx > $scale;
  $scale = $ly if $ly > $scale;
  my $diff = $ly - $lx;
  $scale += $diff if $diff > 0;		# if lx << ly, but not if ly << lx!

  # check that $y is not 1 nor -1 and cache the result:
  my $y_not_one = !($MBI->_is_zero($y->{_e}) && $MBI->_is_one($y->{_m}));

  # flipping the sign of $y will also flip the sign of $x for the special
  # case of $x->bsub($x); so we can catch it below:
  my $xsign = $x->{sign};
  $y->{sign} =~ tr/+-/-+/;

  if ($xsign ne $x->{sign})
    {
    # special case of $x /= $x results in 1
    $x->bone();			# "fixes" also sign of $y, since $x is $y
    }
  else
    {
    # correct $y's sign again
    $y->{sign} =~ tr/+-/-+/;
    # continue with normal div code:

    # make copy of $x in case of list context for later remainder calculation
    if (wantarray && $y_not_one)
      {
      $rem = $x->copy();
      }

    $x->{sign} = $x->{sign} ne $y->sign() ? '-' : '+'; 

    # check for / +-1 ( +/- 1E0)
    if ($y_not_one)
      {
      # promote BigInts and it's subclasses (except when already a BigFloat)
      $y = $self->new($y) unless $y->isa('Math::BigFloat'); 

      # calculate the result to $scale digits and then round it
      # a * 10 ** b / c * 10 ** d => a/c * 10 ** (b-d)
      $MBI->_lsft($x->{_m},$MBI->_new($scale),10);
      $MBI->_div ($x->{_m},$y->{_m});	# a/c

      # correct exponent of $x
      ($x->{_e},$x->{_es}) = _e_sub($x->{_e}, $y->{_e}, $x->{_es}, $y->{_es});
      # correct for 10**scale
      ($x->{_e},$x->{_es}) = _e_sub($x->{_e}, $MBI->_new($scale), $x->{_es}, '+');
      $x->bnorm();		# remove trailing 0's
      }
    } # end else $x != $y

  # shortcut to not run through _find_round_parameters again
  if (defined $params[0])
    {
    delete $x->{_a}; 				# clear before round
    $x->bround($params[0],$params[2]);		# then round accordingly
    }
  else
    {
    delete $x->{_p}; 				# clear before round
    $x->bfround($params[1],$params[2]);		# then round accordingly
    }
  if ($fallback)
    {
    # clear a/p after round, since user did not request it
    delete $x->{_a}; delete $x->{_p};
    }

  if (wantarray)
    {
    if ($y_not_one)
      {
      $x -> bfloor();
      $rem->bmod($y,@params);			# copy already done
      }
    if ($fallback)
      {
      # clear a/p after round, since user did not request it
      delete $rem->{_a}; delete $rem->{_p};
      }
    return ($x,$rem);
    }
  $x;
  }

sub bmod 
  {
  # (dividend: BFLOAT or num_str, divisor: BFLOAT or num_str) return remainder

  # set up parameters
  my ($self,$x,$y,$a,$p,$r) = (ref($_[0]),@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,$a,$p,$r) = objectify(2,@_);
    }

  return $x if $x->modify('bmod');

    # At least one argument is NaN. This is handled the same way as in
    # Math::BigInt -> bmod().

    if ($x -> is_nan() || $y -> is_nan()) {
        return $x -> bnan();
    } 

    # Modulo zero. This is handled the same way as in Math::BigInt -> bmod().

    if ($y -> is_zero()) {
    return $x;
    }

    # Numerator (dividend) is +/-inf. This is handled the same way as in
    # Math::BigInt -> bmod().

    if ($x -> is_inf()) {
        return $x -> bnan();
    }

    # Denominator (divisor) is +/-inf. This is handled the same way as in
    # Math::BigInt -> bmod().

    if ($y -> is_inf()) {
        if ($x -> is_zero() || $x -> bcmp(0) == $y -> bcmp(0)) {
            return $x;
        } else {
            return $x -> binf($y -> sign());
        }
    }

  return $x->bzero() if $x->is_zero()
 || ($x->is_int() &&
  # check that $y == +1 or $y == -1:
    ($MBI->_is_zero($y->{_e}) && $MBI->_is_one($y->{_m})));

  my $cmp = $x->bacmp($y);			# equal or $x < $y?
    if ($cmp == 0) {                            # $x == $y => result 0
        return $x -> bzero($a, $p);
    }

  # only $y of the operands negative? 
    my $neg = $x->{sign} ne $y->{sign} ? 1 : 0;

  $x->{sign} = $y->{sign};				# calc sign first
    if ($cmp < 0 && $neg == 0) {                # $x < $y => result $x
        return $x -> round($a, $p, $r);
    }
  
  my $ym = $MBI->_copy($y->{_m});
  
  # 2e1 => 20
  $MBI->_lsft( $ym, $y->{_e}, 10) 
   if $y->{_es} eq '+' && !$MBI->_is_zero($y->{_e});
 
  # if $y has digits after dot
  my $shifty = 0;			# correct _e of $x by this
  if ($y->{_es} eq '-')			# has digits after dot
    {
    # 123 % 2.5 => 1230 % 25 => 5 => 0.5
    $shifty = $MBI->_num($y->{_e}); 	# no more digits after dot
    $MBI->_lsft($x->{_m}, $y->{_e}, 10);# 123 => 1230, $y->{_m} is already 25
    }
  # $ym is now mantissa of $y based on exponent 0

  my $shiftx = 0;			# correct _e of $x by this
  if ($x->{_es} eq '-')			# has digits after dot
    {
    # 123.4 % 20 => 1234 % 200
    $shiftx = $MBI->_num($x->{_e});	# no more digits after dot
    $MBI->_lsft($ym, $x->{_e}, 10);	# 123 => 1230
    }
  # 123e1 % 20 => 1230 % 20
  if ($x->{_es} eq '+' && !$MBI->_is_zero($x->{_e}))
    {
    $MBI->_lsft( $x->{_m}, $x->{_e},10);	# es => '+' here
    }

  $x->{_e} = $MBI->_new($shiftx);
  $x->{_es} = '+'; 
  $x->{_es} = '-' if $shiftx != 0 || $shifty != 0;
  $MBI->_add( $x->{_e}, $MBI->_new($shifty)) if $shifty != 0;
  
  # now mantissas are equalized, exponent of $x is adjusted, so calc result

  $x->{_m} = $MBI->_mod( $x->{_m}, $ym);

  $x->{sign} = '+' if $MBI->_is_zero($x->{_m});		# fix sign for -0
  $x->bnorm();

    if ($neg != 0 && ! $x -> is_zero())   # one of them negative => correct in place
    {
    my $r = $y - $x;
    $x->{_m} = $r->{_m};
    $x->{_e} = $r->{_e};
    $x->{_es} = $r->{_es};
    $x->{sign} = '+' if $MBI->_is_zero($x->{_m});	# fix sign for -0
    $x->bnorm();
    }

  $x->round($a,$p,$r,$y);	# round and return
  }

sub broot
  {
  # calculate $y'th root of $x
  
  # set up parameters
  my ($self,$x,$y,$a,$p,$r) = (ref($_[0]),@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,$a,$p,$r) = objectify(2,@_);
    }

  return $x if $x->modify('broot');

  # NaN handling: $x ** 1/0, x or y NaN, or y inf/-inf or y == 0
  return $x->bnan() if $x->{sign} !~ /^\+/ || $y->is_zero() ||
         $y->{sign} !~ /^\+$/;

  return $x if $x->is_zero() || $x->is_one() || $x->is_inf() || $y->is_one();
  
  # we need to limit the accuracy to protect against overflow
  my $fallback = 0;
  my (@params,$scale);
  ($x,@params) = $x->_find_round_parameters($a,$p,$r);

  return $x if $x->is_nan();		# error in _find_round_parameters?

  # no rounding at all, so must use fallback
  if (scalar @params == 0) 
    {
    # simulate old behaviour
    $params[0] = $self->div_scale();	# and round to it as accuracy
    $scale = $params[0]+4; 		# at least four more for proper round
    $params[2] = $r;			# round mode by caller or undef
    $fallback = 1;			# to clear a/p afterwards
    }
  else
    {
    # the 4 below is empirical, and there might be cases where it is not
    # enough...
    $scale = abs($params[0] || $params[1]) + 4; # take whatever is defined
    }

  # when user set globals, they would interfere with our calculation, so
  # disable them and later re-enable them
  no strict 'refs';
  my $abr = "$self\::accuracy"; my $ab = $$abr; $$abr = undef;
  my $pbr = "$self\::precision"; my $pb = $$pbr; $$pbr = undef;
  # we also need to disable any set A or P on $x (_find_round_parameters took
  # them already into account), since these would interfere, too
  delete $x->{_a}; delete $x->{_p};
  # need to disable $upgrade in BigInt, to avoid deep recursion
  local $Math::BigInt::upgrade = undef;	# should be really parent class vs MBI

  # remember sign and make $x positive, since -4 ** (1/2) => -2
  my $sign = 0; $sign = 1 if $x->{sign} eq '-'; $x->{sign} = '+';

  my $is_two = 0;
  if ($y->isa('Math::BigFloat'))
    {
    $is_two = ($y->{sign} eq '+' && $MBI->_is_two($y->{_m}) && $MBI->_is_zero($y->{_e}));
    }
  else
    {
    $is_two = ($y == 2);
    }

  # normal square root if $y == 2:
  if ($is_two)
    {
    $x->bsqrt($scale+4);
    }
  elsif ($y->is_one('-'))
    {
    # $x ** -1 => 1/$x
    my $u = $self->bone()->bdiv($x,$scale);
    # copy private parts over
    $x->{_m} = $u->{_m};
    $x->{_e} = $u->{_e};
    $x->{_es} = $u->{_es};
    }
  else
    {
    # calculate the broot() as integer result first, and if it fits, return
    # it rightaway (but only if $x and $y are integer):

    my $done = 0;				# not yet
    if ($y->is_int() && $x->is_int())
      {
      my $i = $MBI->_copy( $x->{_m} );
      $MBI->_lsft( $i, $x->{_e}, 10 ) unless $MBI->_is_zero($x->{_e});
      my $int = Math::BigInt->bzero();
      $int->{value} = $i;
      $int->broot($y->as_number());
      # if ($exact)
      if ($int->copy()->bpow($y) == $x)
        {
        # found result, return it
        $x->{_m} = $int->{value};
        $x->{_e} = $MBI->_zero();
        $x->{_es} = '+';
        $x->bnorm();
        $done = 1;
        }
      }
    if ($done == 0)
      {
      my $u = $self->bone()->bdiv($y,$scale+4);
      delete $u->{_a}; delete $u->{_p};         # otherwise it conflicts
      $x->bpow($u,$scale+4);                    # el cheapo
      }
    }
  $x->bneg() if $sign == 1;
  
  # shortcut to not run through _find_round_parameters again
  if (defined $params[0])
    {
    $x->bround($params[0],$params[2]);		# then round accordingly
    }
  else
    {
    $x->bfround($params[1],$params[2]);		# then round accordingly
    }
  if ($fallback)
    {
    # clear a/p after round, since user did not request it
    delete $x->{_a}; delete $x->{_p};
    }
  # restore globals
  $$abr = $ab; $$pbr = $pb;
  $x;
  }

sub bsqrt
  { 
  # calculate square root
  my ($self,$x,$a,$p,$r) = ref($_[0]) ? (ref($_[0]),@_) : objectify(1,@_);

  return $x if $x->modify('bsqrt');

  return $x->bnan() if $x->{sign} !~ /^[+]/;	# NaN, -inf or < 0
  return $x if $x->{sign} eq '+inf';		# sqrt(inf) == inf
  return $x->round($a,$p,$r) if $x->is_zero() || $x->is_one();

  # we need to limit the accuracy to protect against overflow
  my $fallback = 0;
  my (@params,$scale);
  ($x,@params) = $x->_find_round_parameters($a,$p,$r);

  return $x if $x->is_nan();		# error in _find_round_parameters?

  # no rounding at all, so must use fallback
  if (scalar @params == 0) 
    {
    # simulate old behaviour
    $params[0] = $self->div_scale();	# and round to it as accuracy
    $scale = $params[0]+4; 		# at least four more for proper round
    $params[2] = $r;			# round mode by caller or undef
    $fallback = 1;			# to clear a/p afterwards
    }
  else
    {
    # the 4 below is empirical, and there might be cases where it is not
    # enough...
    $scale = abs($params[0] || $params[1]) + 4; # take whatever is defined
    }

  # when user set globals, they would interfere with our calculation, so
  # disable them and later re-enable them
  no strict 'refs';
  my $abr = "$self\::accuracy"; my $ab = $$abr; $$abr = undef;
  my $pbr = "$self\::precision"; my $pb = $$pbr; $$pbr = undef;
  # we also need to disable any set A or P on $x (_find_round_parameters took
  # them already into account), since these would interfere, too
  delete $x->{_a}; delete $x->{_p};
  # need to disable $upgrade in BigInt, to avoid deep recursion
  local $Math::BigInt::upgrade = undef;	# should be really parent class vs MBI

  my $i = $MBI->_copy( $x->{_m} );
  $MBI->_lsft( $i, $x->{_e}, 10 ) unless $MBI->_is_zero($x->{_e});
  my $xas = Math::BigInt->bzero();
  $xas->{value} = $i;

  my $gs = $xas->copy()->bsqrt();	# some guess

  if (($x->{_es} ne '-')		# guess can't be accurate if there are
					# digits after the dot
   && ($xas->bacmp($gs * $gs) == 0))	# guess hit the nail on the head?
    {
    # exact result, copy result over to keep $x
    $x->{_m} = $gs->{value}; $x->{_e} = $MBI->_zero(); $x->{_es} = '+';
    $x->bnorm();
    # shortcut to not run through _find_round_parameters again
    if (defined $params[0])
      {
      $x->bround($params[0],$params[2]);	# then round accordingly
      }
    else
      {
      $x->bfround($params[1],$params[2]);	# then round accordingly
      }
    if ($fallback)
      {
      # clear a/p after round, since user did not request it
      delete $x->{_a}; delete $x->{_p};
      }
    # re-enable A and P, upgrade is taken care of by "local"
    ${"$self\::accuracy"} = $ab; ${"$self\::precision"} = $pb;
    return $x;
    }
 
  # sqrt(2) = 1.4 because sqrt(2*100) = 1.4*10; so we can increase the accuracy
  # of the result by multiplying the input by 100 and then divide the integer
  # result of sqrt(input) by 10. Rounding afterwards returns the real result.

  # The following steps will transform 123.456 (in $x) into 123456 (in $y1)
  my $y1 = $MBI->_copy($x->{_m});

  my $length = $MBI->_len($y1);
  
  # Now calculate how many digits the result of sqrt(y1) would have
  my $digits = int($length / 2);

  # But we need at least $scale digits, so calculate how many are missing
  my $shift = $scale - $digits;

  # This happens if the input had enough digits
  # (we take care of integer guesses above)
  $shift = 0 if $shift < 0; 

  # Multiply in steps of 100, by shifting left two times the "missing" digits
  my $s2 = $shift * 2;

  # We now make sure that $y1 has the same odd or even number of digits than
  # $x had. So when _e of $x is odd, we must shift $y1 by one digit left,
  # because we always must multiply by steps of 100 (sqrt(100) is 10) and not
  # steps of 10. The length of $x does not count, since an even or odd number
  # of digits before the dot is not changed by adding an even number of digits
  # after the dot (the result is still odd or even digits long).
  $s2++ if $MBI->_is_odd($x->{_e});

  $MBI->_lsft( $y1, $MBI->_new($s2), 10);

  # now take the square root and truncate to integer
  $y1 = $MBI->_sqrt($y1);

  # By "shifting" $y1 right (by creating a negative _e) we calculate the final
  # result, which is than later rounded to the desired scale.

  # calculate how many zeros $x had after the '.' (or before it, depending
  # on sign of $dat, the result should have half as many:
  my $dat = $MBI->_num($x->{_e});
  $dat = -$dat if $x->{_es} eq '-';
  $dat += $length;

  if ($dat > 0)
    {
    # no zeros after the dot (e.g. 1.23, 0.49 etc)
    # preserve half as many digits before the dot than the input had 
    # (but round this "up")
    $dat = int(($dat+1)/2);
    }
  else
    {
    $dat = int(($dat)/2);
    }
  $dat -= $MBI->_len($y1);
  if ($dat < 0)
    {
    $dat = abs($dat);
    $x->{_e} = $MBI->_new( $dat );
    $x->{_es} = '-';
    }
  else
    {    
    $x->{_e} = $MBI->_new( $dat );
    $x->{_es} = '+';
    }
  $x->{_m} = $y1;
  $x->bnorm();

  # shortcut to not run through _find_round_parameters again
  if (defined $params[0])
    {
    $x->bround($params[0],$params[2]);		# then round accordingly
    }
  else
    {
    $x->bfround($params[1],$params[2]);		# then round accordingly
    }
  if ($fallback)
    {
    # clear a/p after round, since user did not request it
    delete $x->{_a}; delete $x->{_p};
    }
  # restore globals
  $$abr = $ab; $$pbr = $pb;
  $x;
  }

sub bfac
  {
  # (BFLOAT or num_str, BFLOAT or num_str) return BFLOAT
  # compute factorial number, modifies first argument

  # set up parameters
  my ($self,$x,@r) = (ref($_[0]),@_);
  # objectify is costly, so avoid it
  ($self,$x,@r) = objectify(1,@_) if !ref($x);

  # inf => inf
  return $x if $x->modify('bfac') || $x->{sign} eq '+inf';	

  return $x->bnan() 
    if (($x->{sign} ne '+') ||		# inf, NaN, <0 etc => NaN
     ($x->{_es} ne '+'));		# digits after dot?

  # use BigInt's bfac() for faster calc
  if (! $MBI->_is_zero($x->{_e}))
    {
    $MBI->_lsft($x->{_m}, $x->{_e},10);	# change 12e1 to 120e0
    $x->{_e} = $MBI->_zero();		# normalize
    $x->{_es} = '+';
    }
  $MBI->_fac($x->{_m});			# calculate factorial
  $x->bnorm()->round(@r); 		# norm again and round result
  }

sub _pow
  {
  # Calculate a power where $y is a non-integer, like 2 ** 0.3
  my ($x,$y,@r) = @_;
  my $self = ref($x);

  # if $y == 0.5, it is sqrt($x)
  $HALF = $self->new($HALF) unless ref($HALF);
  return $x->bsqrt(@r,$y) if $y->bcmp($HALF) == 0;

  # Using:
  # a ** x == e ** (x * ln a)

  # u = y * ln x
  #                _                         _
  # Taylor:       |   u    u^2    u^3         |
  # x ** y  = 1 + |  --- + --- + ----- + ...  |
  #               |_  1    1*2   1*2*3       _|

  # we need to limit the accuracy to protect against overflow
  my $fallback = 0;
  my ($scale,@params);
  ($x,@params) = $x->_find_round_parameters(@r);
    
  return $x if $x->is_nan();		# error in _find_round_parameters?

  # no rounding at all, so must use fallback
  if (scalar @params == 0)
    {
    # simulate old behaviour
    $params[0] = $self->div_scale();	# and round to it as accuracy
    $params[1] = undef;			# disable P
    $scale = $params[0]+4; 		# at least four more for proper round
    $params[2] = $r[2];			# round mode by caller or undef
    $fallback = 1;			# to clear a/p afterwards
    }
  else
    {
    # the 4 below is empirical, and there might be cases where it is not
    # enough...
    $scale = abs($params[0] || $params[1]) + 4; # take whatever is defined
    }

  # when user set globals, they would interfere with our calculation, so
  # disable them and later re-enable them
  no strict 'refs';
  my $abr = "$self\::accuracy"; my $ab = $$abr; $$abr = undef;
  my $pbr = "$self\::precision"; my $pb = $$pbr; $$pbr = undef;
  # we also need to disable any set A or P on $x (_find_round_parameters took
  # them already into account), since these would interfere, too
  delete $x->{_a}; delete $x->{_p};
  # need to disable $upgrade in BigInt, to avoid deep recursion
  local $Math::BigInt::upgrade = undef;
 
  my ($limit,$v,$u,$below,$factor,$next,$over);

  $u = $x->copy()->blog(undef,$scale)->bmul($y);
  my $do_invert = ($u->{sign} eq '-');
  $u->bneg()  if $do_invert;
  $v = $self->bone();				# 1
  $factor = $self->new(2);			# 2
  $x->bone();					# first term: 1

  $below = $v->copy();
  $over = $u->copy();

  $limit = $self->new("1E-". ($scale-1));
  #my $steps = 0;
  while (3 < 5)
    {
    # we calculate the next term, and add it to the last
    # when the next term is below our limit, it won't affect the outcome
    # anymore, so we stop:
    $next = $over->copy()->bdiv($below,$scale);
    last if $next->bacmp($limit) <= 0;
    $x->badd($next);
    # calculate things for the next term
    $over *= $u; $below *= $factor; $factor->binc();

    last if $x->{sign} !~ /^[-+]$/;

    #$steps++;
    }

  if ($do_invert)
    {
    my $x_copy = $x->copy;
    $x->bone->bdiv($x_copy, $scale);
    }
  
  # shortcut to not run through _find_round_parameters again
  if (defined $params[0])
    {
    $x->bround($params[0],$params[2]);		# then round accordingly
    }
  else
    {
    $x->bfround($params[1],$params[2]);		# then round accordingly
    }
  if ($fallback)
    {
    # clear a/p after round, since user did not request it
    delete $x->{_a}; delete $x->{_p};
    }
  # restore globals
  $$abr = $ab; $$pbr = $pb;
  $x;
  }

sub bpow 
  {
  # (BFLOAT or num_str, BFLOAT or num_str) return BFLOAT
  # compute power of two numbers, second arg is used as integer
  # modifies first argument

  # set up parameters
  my ($self,$x,$y,$a,$p,$r) = (ref($_[0]),@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,$a,$p,$r) = objectify(2,@_);
    }

  return $x if $x->modify('bpow');

  return $x->bnan() if $x->{sign} eq $nan || $y->{sign} eq $nan;
  return $x if $x->{sign} =~ /^[+-]inf$/;
  
  # cache the result of is_zero
  my $y_is_zero = $y->is_zero();
  return $x->bone() if $y_is_zero;
  return $x         if $x->is_one() || $y->is_one();

  my $x_is_zero = $x->is_zero();
  return $x->_pow($y,$a,$p,$r) if !$x_is_zero && !$y->is_int();		# non-integer power

  my $y1 = $y->as_number()->{value};			# make MBI part

  # if ($x == -1)
  if ($x->{sign} eq '-' && $MBI->_is_one($x->{_m}) && $MBI->_is_zero($x->{_e}))
    {
    # if $x == -1 and odd/even y => +1/-1  because +-1 ^ (+-1) => +-1
    return $MBI->_is_odd($y1) ? $x : $x->babs(1);
    }
  if ($x_is_zero)
    {
    return $x if $y->{sign} eq '+'; 	# 0**y => 0 (if not y <= 0)
    # 0 ** -y => 1 / (0 ** y) => 1 / 0! (1 / 0 => +inf)
    return $x->binf();
    }

  my $new_sign = '+';
  $new_sign = $MBI->_is_odd($y1) ? '-' : '+' if $x->{sign} ne '+';

  # calculate $x->{_m} ** $y and $x->{_e} * $y separately (faster)
  $x->{_m} = $MBI->_pow( $x->{_m}, $y1);
  $x->{_e} = $MBI->_mul ($x->{_e}, $y1);

  $x->{sign} = $new_sign;
  $x->bnorm();
  if ($y->{sign} eq '-')
    {
    # modify $x in place!
    my $z = $x->copy(); $x->bone();
    return scalar $x->bdiv($z,$a,$p,$r);	# round in one go (might ignore y's A!)
    }
  $x->round($a,$p,$r,$y);
  }

sub bmodpow
  {
  # takes a very large number to a very large exponent in a given very
  # large modulus, quickly, thanks to binary exponentiation. Supports
  # negative exponents.
  my ($self,$num,$exp,$mod,@r) = objectify(3,@_);

  return $num if $num->modify('bmodpow');

  # check modulus for valid values
  return $num->bnan() if ($mod->{sign} ne '+'           # NaN, - , -inf, +inf
                       || $mod->is_zero());

  # check exponent for valid values
  if ($exp->{sign} =~ /\w/)
    {
    # i.e., if it's NaN, +inf, or -inf...
    return $num->bnan();
    }

  $num->bmodinv ($mod) if ($exp->{sign} eq '-');

  # check num for valid values (also NaN if there was no inverse but $exp < 0)
  return $num->bnan() if $num->{sign} !~ /^[+-]$/;

  # $mod is positive, sign on $exp is ignored, result also positive

  # XXX TODO: speed it up when all three numbers are integers
  $num->bpow($exp)->bmod($mod);
  }

###############################################################################
# trigonometric functions

# helper function for bpi() and batan2(), calculates arcus tanges (1/x)

sub _atan_inv
  {
  # return a/b so that a/b approximates atan(1/x) to at least limit digits
  my ($self, $x, $limit) = @_;

  # Taylor:       x^3   x^5   x^7   x^9
  #    atan = x - --- + --- - --- + --- - ...
  #                3     5     7     9 

  #               1      1         1        1
  #    atan 1/x = - - ------- + ------- - ------- + ...
  #               x   x^3 * 3   x^5 * 5   x^7 * 7 

  #               1      1         1            1
  #    atan 1/x = - - --------- + ---------- - ----------- + ... 
  #               5    3 * 125     5 * 3125     7 * 78125

  # Subtraction/addition of a rational:

  #  5    7    5*3 +- 7*4
  #  - +- -  = ----------
  #  4    3       4*3

  # Term:  N        N+1
  #
  #        a             1                  a * d * c +- b
  #        ----- +- ------------------  =  ----------------
  #        b           d * c                b * d * c

  #  since b1 = b0 * (d-2) * c

  #        a             1                  a * d +- b / c
  #        ----- +- ------------------  =  ----------------
  #        b           d * c                b * d 

  # and  d = d + 2
  # and  c = c * x * x

  #        u = d * c
  #        stop if length($u) > limit 
  #        a = a * u +- b
  #        b = b * u
  #        d = d + 2
  #        c = c * x * x
  #        sign = 1 - sign

  my $a = $MBI->_one();
  my $b = $MBI->_copy($x);
 
  my $x2  = $MBI->_mul( $MBI->_copy($x), $b);		# x2 = x * x
  my $d   = $MBI->_new( 3 );				# d = 3
  my $c   = $MBI->_mul( $MBI->_copy($x), $x2);		# c = x ^ 3
  my $two = $MBI->_new( 2 );

  # run the first step unconditionally
  my $u = $MBI->_mul( $MBI->_copy($d), $c);
  $a = $MBI->_mul($a, $u);
  $a = $MBI->_sub($a, $b);
  $b = $MBI->_mul($b, $u);
  $d = $MBI->_add($d, $two);
  $c = $MBI->_mul($c, $x2);

  # a is now a * (d-3) * c
  # b is now b * (d-2) * c

  # run the second step unconditionally
  $u = $MBI->_mul( $MBI->_copy($d), $c);
  $a = $MBI->_mul($a, $u);
  $a = $MBI->_add($a, $b);
  $b = $MBI->_mul($b, $u);
  $d = $MBI->_add($d, $two);
  $c = $MBI->_mul($c, $x2);

  # a is now a * (d-3) * (d-5) * c * c  
  # b is now b * (d-2) * (d-4) * c * c

  # so we can remove c * c from both a and b to shorten the numbers involved:
  $a = $MBI->_div($a, $x2);
  $b = $MBI->_div($b, $x2);
  $a = $MBI->_div($a, $x2);
  $b = $MBI->_div($b, $x2);

#  my $step = 0; 
  my $sign = 0;						# 0 => -, 1 => +
  while (3 < 5)
    {
#    $step++;
#    if (($i++ % 100) == 0)
#      {
#    print "a=",$MBI->_str($a),"\n";
#    print "b=",$MBI->_str($b),"\n";
#      }
#    print "d=",$MBI->_str($d),"\n";
#    print "x2=",$MBI->_str($x2),"\n";
#    print "c=",$MBI->_str($c),"\n";

    my $u = $MBI->_mul( $MBI->_copy($d), $c);
    # use _alen() for libs like GMP where _len() would be O(N^2)
    last if $MBI->_alen($u) > $limit;
    my ($bc,$r) = $MBI->_div( $MBI->_copy($b), $c);
    if ($MBI->_is_zero($r))
      {
      # b / c is an integer, so we can remove c from all terms
      # this happens almost every time:
      $a = $MBI->_mul($a, $d);
      $a = $MBI->_sub($a, $bc) if $sign == 0;
      $a = $MBI->_add($a, $bc) if $sign == 1;
      $b = $MBI->_mul($b, $d);
      }
    else
      {
      # b / c is not an integer, so we keep c in the terms
      # this happens very rarely, for instance for x = 5, this happens only
      # at the following steps:
      # 1, 5, 14, 32, 72, 157, 340, ...
      $a = $MBI->_mul($a, $u);
      $a = $MBI->_sub($a, $b) if $sign == 0;
      $a = $MBI->_add($a, $b) if $sign == 1;
      $b = $MBI->_mul($b, $u);
      }
    $d = $MBI->_add($d, $two);
    $c = $MBI->_mul($c, $x2);
    $sign = 1 - $sign;

    }

#  print "Took $step steps for ", $MBI->_str($x),"\n";
#  print "a=",$MBI->_str($a),"\n"; print "b=",$MBI->_str($b),"\n";
  # return a/b so that a/b approximates atan(1/x)
  ($a,$b);
  }

sub bpi {

    # Called as                 Argument list
    # ---------                 -------------
    # Math::BigFloat->bpi()     ("Math::BigFloat")
    # Math::BigFloat->bpi(10)   ("Math::BigFloat", 10)
    # $x->bpi()                 ($x)
    # $x->bpi(10)               ($x, 10)
    # Math::BigFloat::bpi()     ()
    # Math::BigFloat::bpi(10)   (10)
    #
    # In ambiguous cases, we favour the OO-style, so the following case
    #
    #   $n = Math::BigFloat->new("10");
    #   $x = Math::BigFloat->bpi($n);
    #
    # which gives an argument list with the single element $n, is resolved as
    #
    #   $n->bpi();

    my $self    = shift;
    my $selfref = ref $self;
    my $class   = $selfref || $self;

    my $accu;                      # accuracy (number of digits)
    my $prec;                      # precision
    my $rndm;                      # round mode

    # If bpi() is called as a function ...
    #
    # This cludge is necessary because we still support bpi() as a function. If
    # bpi() is called with either no argument or one argument, and that one
    # argument is either undefined or a scalar that looks like a number, then
    # we assume bpi() is called as a function.

    if (@_ == 0 &&
        (defined($self) && !ref($self) && $self =~ /^\s*[+-]?\d/i)
          ||
        !defined($self))
    {
        $accu = $self;
        $class = __PACKAGE__;
        $self = $class -> bzero();      # initialize
    }

    # ... or if bpi() is called as a method ...

    else {
        if ($selfref) {                 # bpi() called as instance method
            return $self if $self -> modify('bpi');
        } else {                        # bpi() called as class method
            $self = $class -> bzero();  # initialize
        }
        $accu = shift;
        $prec = shift;
        $rndm = shift;
    }

    my @r = ($accu, $prec, $rndm);

    # We need to limit the accuracy to protect against overflow.
    my $fallback = 0;
    my ($scale, @params);
    ($self, @params) = $self -> _find_round_parameters(@r);

    # Error in _find_round_parameters?
    #
    # We can't return here, because that will fail if $self was a NaN when
    # bpi() was invoked, and we want to assign pi to $x. It is probably not a
    # good idea that _find_round_parameters() signals invalid round parameters
    # by silently returning a NaN. Fixme!
    #return $self if $self && $self->is_nan();

    # No rounding at all, so must use fallback.
    if (scalar @params == 0) {
        # Simulate old behaviour
        $params[0] = $self -> div_scale();  # and round to it as accuracy
        $params[1] = undef;                 # disable P
        $params[2] = $r[2];                 # round mode by caller or undef
        $fallback = 1;                      # to clear a/p afterwards
    }

    # The accuracy, i.e., the number of digits. Pi has one digit before the
    # dot, so a precision of 4 digits is equivalent to an accuracy of 5 digits.

    my $n = $params[0] || 1 - $params[1];

    if ($n < 1000) {

        # after  (Hwang Chien-Lih) (1997)
        # pi/4 = 183 * atan(1/239) + 32 * atan(1/1023)  68 * atan(1/5832)
        #        + 12 * atan(1/110443) - 12 * atan(1/4841182) - 100 * atan(1/6826318)

        # Use a few more digits in the intermediate computations.

        my $nextra = $n < 800 ? 4 : 5;
        $n += $nextra;

        my ($a, $b) = $class->_atan_inv($MBI->_new(239), $n);
        my ($c, $d) = $class->_atan_inv($MBI->_new(1023), $n);
        my ($e, $f) = $class->_atan_inv($MBI->_new(5832), $n);
        my ($g, $h) = $class->_atan_inv($MBI->_new(110443), $n);
        my ($i, $j) = $class->_atan_inv($MBI->_new(4841182), $n);
        my ($k, $l) = $class->_atan_inv($MBI->_new(6826318), $n);

        $MBI->_mul($a, $MBI->_new(732));
        $MBI->_mul($c, $MBI->_new(128));
        $MBI->_mul($e, $MBI->_new(272));
        $MBI->_mul($g, $MBI->_new(48));
        $MBI->_mul($i, $MBI->_new(48));
        $MBI->_mul($k, $MBI->_new(400));

        my $x = $class->bone(); $x->{_m} = $a; my $x_d = $class->bone(); $x_d->{_m} = $b;
        my $y = $class->bone(); $y->{_m} = $c; my $y_d = $class->bone(); $y_d->{_m} = $d;
        my $z = $class->bone(); $z->{_m} = $e; my $z_d = $class->bone(); $z_d->{_m} = $f;
        my $u = $class->bone(); $u->{_m} = $g; my $u_d = $class->bone(); $u_d->{_m} = $h;
        my $v = $class->bone(); $v->{_m} = $i; my $v_d = $class->bone(); $v_d->{_m} = $j;
        my $w = $class->bone(); $w->{_m} = $k; my $w_d = $class->bone(); $w_d->{_m} = $l;
        $x->bdiv($x_d, $n);
        $y->bdiv($y_d, $n);
        $z->bdiv($z_d, $n);
        $u->bdiv($u_d, $n);
        $v->bdiv($v_d, $n);
        $w->bdiv($w_d, $n);

        delete $x->{_a}; delete $y->{_a}; delete $z->{_a};
        delete $u->{_a}; delete $v->{_a}; delete $w->{_a};
        $x->badd($y)->bsub($z)->badd($u)->bsub($v)->bsub($w);

        for my $key (qw/ sign _m _es _e _a _p /) {
            $self -> {$key} = $x -> {$key} if exists $x -> {$key};
        }

    } else {

        # For large accuracy, the arctan formulas become very inefficient with
        # Math::BigFloat. Switch to Brent-Salamin (aka AGM or Gauss-Legendre).

        # Use a few more digits in the intermediate computations.
        my $nextra = 8;

        $HALF = $class -> new($HALF) unless ref($HALF);
        my ($an, $bn, $tn, $pn) = ($class -> bone, $HALF -> copy -> bsqrt($n),
                                   $HALF -> copy -> bmul($HALF), $class -> bone);
        while ($pn < $n) {
            my $prev_an = $an -> copy;
            $an -> badd($bn) -> bmul($HALF, $n);
            $bn -> bmul($prev_an) -> bsqrt($n);
            $prev_an -> bsub($an);
            $tn -> bsub($pn * $prev_an * $prev_an);
            $pn -> badd($pn);
        }
        $an -> badd($bn);
        $an -> bmul($an, $n) -> bdiv(4 * $tn, $n);

        for my $key (qw/ sign _m _es _e _a _p /) {
            $self -> {$key} = $an -> {$key} if exists $an -> {$key};;
        }
    }

    $self -> round(@params);

    if ($fallback) {
        delete $self->{_a};
        delete $self->{_p};
    }

    return $self;
}

sub bcos
  {
  # Calculate a cosinus of x.
  my ($self,$x,@r) = ref($_[0]) ? (ref($_[0]),@_) : objectify(1,@_);

  # Taylor:      x^2   x^4   x^6   x^8
  #    cos = 1 - --- + --- - --- + --- ...
  #               2!    4!    6!    8!

  # we need to limit the accuracy to protect against overflow
  my $fallback = 0;
  my ($scale,@params);
  ($x,@params) = $x->_find_round_parameters(@r);
    
  #         constant object       or error in _find_round_parameters?
  return $x if $x->modify('bcos') || $x->is_nan();

  return $x->bone(@r) if $x->is_zero();

  # no rounding at all, so must use fallback
  if (scalar @params == 0)
    {
    # simulate old behaviour
    $params[0] = $self->div_scale();	# and round to it as accuracy
    $params[1] = undef;			# disable P
    $scale = $params[0]+4; 		# at least four more for proper round
    $params[2] = $r[2];			# round mode by caller or undef
    $fallback = 1;			# to clear a/p afterwards
    }
  else
    {
    # the 4 below is empirical, and there might be cases where it is not
    # enough...
    $scale = abs($params[0] || $params[1]) + 4; # take whatever is defined
    }

  # when user set globals, they would interfere with our calculation, so
  # disable them and later re-enable them
  no strict 'refs';
  my $abr = "$self\::accuracy"; my $ab = $$abr; $$abr = undef;
  my $pbr = "$self\::precision"; my $pb = $$pbr; $$pbr = undef;
  # we also need to disable any set A or P on $x (_find_round_parameters took
  # them already into account), since these would interfere, too
  delete $x->{_a}; delete $x->{_p};
  # need to disable $upgrade in BigInt, to avoid deep recursion
  local $Math::BigInt::upgrade = undef;
 
  my $last = 0;
  my $over = $x * $x;                   # X ^ 2
  my $x2 = $over->copy();               # X ^ 2; difference between terms
  my $sign = 1;                         # start with -=
  my $below = $self->new(2); my $factorial = $self->new(3);
  $x->bone(); delete $x->{_a}; delete $x->{_p};

  my $limit = $self->new("1E-". ($scale-1));
  #my $steps = 0;
  while (3 < 5)
    {
    # we calculate the next term, and add it to the last
    # when the next term is below our limit, it won't affect the outcome
    # anymore, so we stop:
    my $next = $over->copy()->bdiv($below,$scale);
    last if $next->bacmp($limit) <= 0;

    if ($sign == 0)
      {
      $x->badd($next);
      }
    else
      {
      $x->bsub($next);
      }
    $sign = 1-$sign;					# alternate
    # calculate things for the next term
    $over->bmul($x2);					# $x*$x
    $below->bmul($factorial); $factorial->binc();	# n*(n+1)
    $below->bmul($factorial); $factorial->binc();	# n*(n+1)
    }

  # shortcut to not run through _find_round_parameters again
  if (defined $params[0])
    {
    $x->bround($params[0],$params[2]);		# then round accordingly
    }
  else
    {
    $x->bfround($params[1],$params[2]);		# then round accordingly
    }
  if ($fallback)
    {
    # clear a/p after round, since user did not request it
    delete $x->{_a}; delete $x->{_p};
    }
  # restore globals
  $$abr = $ab; $$pbr = $pb;
  $x;
  }

sub bsin
  {
  # Calculate a sinus of x.
  my ($self,$x,@r) = ref($_[0]) ? (ref($_[0]),@_) : objectify(1,@_);

  # taylor:      x^3   x^5   x^7   x^9
  #    sin = x - --- + --- - --- + --- ...
  #               3!    5!    7!    9!

  # we need to limit the accuracy to protect against overflow
  my $fallback = 0;
  my ($scale,@params);
  ($x,@params) = $x->_find_round_parameters(@r);
    
  #         constant object       or error in _find_round_parameters?
  return $x if $x->modify('bsin') || $x->is_nan();

  return $x->bzero(@r) if $x->is_zero();

  # no rounding at all, so must use fallback
  if (scalar @params == 0)
    {
    # simulate old behaviour
    $params[0] = $self->div_scale();	# and round to it as accuracy
    $params[1] = undef;			# disable P
    $scale = $params[0]+4; 		# at least four more for proper round
    $params[2] = $r[2];			# round mode by caller or undef
    $fallback = 1;			# to clear a/p afterwards
    }
  else
    {
    # the 4 below is empirical, and there might be cases where it is not
    # enough...
    $scale = abs($params[0] || $params[1]) + 4; # take whatever is defined
    }

  # when user set globals, they would interfere with our calculation, so
  # disable them and later re-enable them
  no strict 'refs';
  my $abr = "$self\::accuracy"; my $ab = $$abr; $$abr = undef;
  my $pbr = "$self\::precision"; my $pb = $$pbr; $$pbr = undef;
  # we also need to disable any set A or P on $x (_find_round_parameters took
  # them already into account), since these would interfere, too
  delete $x->{_a}; delete $x->{_p};
  # need to disable $upgrade in BigInt, to avoid deep recursion
  local $Math::BigInt::upgrade = undef;
 
  my $last = 0;
  my $over = $x * $x;			# X ^ 2
  my $x2 = $over->copy();		# X ^ 2; difference between terms
  $over->bmul($x);			# X ^ 3 as starting value
  my $sign = 1;				# start with -=
  my $below = $self->new(6); my $factorial = $self->new(4);
  delete $x->{_a}; delete $x->{_p};

  my $limit = $self->new("1E-". ($scale-1));
  #my $steps = 0;
  while (3 < 5)
    {
    # we calculate the next term, and add it to the last
    # when the next term is below our limit, it won't affect the outcome
    # anymore, so we stop:
    my $next = $over->copy()->bdiv($below,$scale);
    last if $next->bacmp($limit) <= 0;

    if ($sign == 0)
      {
      $x->badd($next);
      }
    else
      {
      $x->bsub($next);
      }
    $sign = 1-$sign;					# alternate
    # calculate things for the next term
    $over->bmul($x2);					# $x*$x
    $below->bmul($factorial); $factorial->binc();	# n*(n+1)
    $below->bmul($factorial); $factorial->binc();	# n*(n+1)
    }

  # shortcut to not run through _find_round_parameters again
  if (defined $params[0])
    {
    $x->bround($params[0],$params[2]);		# then round accordingly
    }
  else
    {
    $x->bfround($params[1],$params[2]);		# then round accordingly
    }
  if ($fallback)
    {
    # clear a/p after round, since user did not request it
    delete $x->{_a}; delete $x->{_p};
    }
  # restore globals
  $$abr = $ab; $$pbr = $pb;
  $x;
  }

sub batan2 {
    # $y -> batan2($x) returns the arcus tangens of $y / $x.

    # Set up parameters.
    my ($self, $y, $x, @r) = (ref($_[0]), @_);

    # Objectify is costly, so avoid it if we can.
    if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1]))) {
        ($self, $y, $x, @r) = objectify(2, @_);
    }

    # Quick exit if $y is read-only.
    return $y if $y -> modify('batan2');

    # Handle all NaN cases.
    return $y -> bnan() if $x->{sign} eq $nan || $y->{sign} eq $nan;

    # We need to limit the accuracy to protect against overflow.
    my $fallback = 0;
    my ($scale, @params);
    ($y, @params) = $y -> _find_round_parameters(@r);

    # Error in _find_round_parameters?
    return $y if $y->is_nan();

    # No rounding at all, so must use fallback.
    if (scalar @params == 0) {
        # Simulate old behaviour
        $params[0] = $self -> div_scale();  # and round to it as accuracy
        $params[1] = undef;                 # disable P
        $scale = $params[0] + 4;            # at least four more for proper round
        $params[2] = $r[2];                 # round mode by caller or undef
        $fallback = 1;                      # to clear a/p afterwards
    } else {
        # The 4 below is empirical, and there might be cases where it is not
        # enough ...
        $scale = abs($params[0] || $params[1]) + 4; # take whatever is defined
    }

    if ($x -> is_inf("+")) {                            # x = inf
        if ($y -> is_inf("+")) {                        #    y = inf
            $y -> bpi($scale) -> bmul("0.25");          #       pi/4
        } elsif ($y -> is_inf("-")) {                   #    y = -inf
            $y -> bpi($scale) -> bmul("-0.25");         #       -pi/4
        } else {                                        #    -inf < y < inf
            return $y -> bzero(@r);                     #       0
        }
    }

    elsif ($x -> is_inf("-")) {                         # x = -inf
        if ($y -> is_inf("+")) {                        #    y = inf
            $y -> bpi($scale) -> bmul("0.75");          #       3/4 pi
        } elsif ($y -> is_inf("-")) {                   #    y = -inf
            $y -> bpi($scale) -> bmul("-0.75");         #       -3/4 pi
        } elsif ($y >= 0) {                             #    y >= 0
            $y -> bpi($scale);                          #       pi
        } else {                                        #    y < 0
            $y -> bpi($scale) -> bneg();                #       -pi
        }
    }

    elsif ($x > 0) {                                    # 0 < x < inf
        if ($y -> is_inf("+")) {                        #    y = inf
            $y -> bpi($scale) -> bmul("0.5");           #       pi/2
        } elsif ($y -> is_inf("-")) {                   #    y = -inf
            $y -> bpi($scale) -> bmul("-0.5");          #       -pi/2
        } else {                                        #   -inf < y < inf
            $y -> bdiv($x, $scale) -> batan($scale);    #       atan(y/x)
        }
    }

    elsif ($x < 0) {                                    # -inf < x < 0
        my $pi = $class -> bpi($scale);
        if ($y >= 0) {                                  #    y >= 0
            $y -> bdiv($x, $scale) -> batan()           #       atan(y/x) + pi
               -> badd($pi);
        } else {                                        #    y < 0
            $y -> bdiv($x, $scale) -> batan()           #       atan(y/x) - pi
               -> bsub($pi);
        }
    }

    else {                                              # x = 0
        if ($y > 0) {                                   #    y > 0
            $y -> bpi($scale) -> bmul("0.5");           #       pi/2
        } elsif ($y < 0) {                              #    y < 0
            $y -> bpi($scale) -> bmul("-0.5");          #       -pi/2
        } else {                                        #    y = 0
            return $y -> bzero(@r);                     #       0
        }
    }

    $y -> round(@r);

    if ($fallback) {
        delete $y->{_a};
        delete $y->{_p};
    }

    return $y;
}

sub batan {
    # Calculate a arcus tangens of x.

    my $self    = shift;
    my $selfref = ref $self;
    my $class   = $selfref || $self;

    my (@r) = @_;

    # taylor:       x^3   x^5   x^7   x^9
    #    atan = x - --- + --- - --- + --- ...
    #                3     5     7     9

    # We need to limit the accuracy to protect against overflow.

    my $fallback = 0;
    my ($scale, @params);
    ($self, @params) = $self->_find_round_parameters(@r);

    # Constant object or error in _find_round_parameters?

    return $self if $self->modify('batan') || $self->is_nan();

    if ($self->{sign} =~ /^[+-]inf\z/) {
        # +inf result is PI/2
        # -inf result is -PI/2
        # calculate PI/2
        my $pi = $class->bpi(@r);
        # modify $self in place
        $self->{_m} = $pi->{_m};
        $self->{_e} = $pi->{_e};
        $self->{_es} = $pi->{_es};
        # -y => -PI/2, +y => PI/2
        $self->{sign} = substr($self->{sign}, 0, 1);  # "+inf" => "+"
        $MBI->_div($self->{_m}, $MBI->_new(2));
        return $self;
    }

    return $self->bzero(@r) if $self->is_zero();

    # no rounding at all, so must use fallback
    if (scalar @params == 0) {
        # simulate old behaviour
        $params[0] = $class->div_scale();  # and round to it as accuracy
        $params[1] = undef;               # disable P
        $scale = $params[0]+4;            # at least four more for proper round
        $params[2] = $r[2];               # round mode by caller or undef
        $fallback = 1;                    # to clear a/p afterwards
    } else {
        # the 4 below is empirical, and there might be cases where it is not
        # enough...
        $scale = abs($params[0] || $params[1]) + 4; # take whatever is defined
    }

    # 1 or -1 => PI/4
    # inlined is_one() && is_one('-')
    if ($MBI->_is_one($self->{_m}) && $MBI->_is_zero($self->{_e})) {
        my $pi = $class->bpi($scale - 3);
        # modify $self in place
        $self->{_m} = $pi->{_m};
        $self->{_e} = $pi->{_e};
        $self->{_es} = $pi->{_es};
        # leave the sign of $self alone (+1 => +PI/4, -1 => -PI/4)
        $MBI->_div($self->{_m}, $MBI->_new(4));
        return $self;
    }

    # This series is only valid if -1 < x < 1, so for other x we need to
    # calculate PI/2 - atan(1/x):
    my $one = $MBI->_new(1);
    my $pi = undef;
    if ($self->bacmp($self->copy->bone) >= 0) {
        # calculate PI/2
        $pi = $class->bpi($scale - 3);
        $MBI->_div($pi->{_m}, $MBI->_new(2));
        # calculate 1/$self:
        my $self_copy = $self->copy();
        # modify $self in place
        $self->bone(); $self->bdiv($self_copy, $scale);
    }

    my $fmul = 1;
    foreach my $k (0 .. int($scale / 20)) {
        $fmul *= 2;
        $self->bdiv($self->copy->bmul($self)->binc->bsqrt($scale + 4)->binc, $scale + 4);
    }

    # When user set globals, they would interfere with our calculation, so
    # disable them and later re-enable them.
    no strict 'refs';
    my $abr = "$class\::accuracy";  my $ab = $$abr; $$abr = undef;
    my $pbr = "$class\::precision"; my $pb = $$pbr; $$pbr = undef;
    # We also need to disable any set A or P on $self (_find_round_parameters
    # took them already into account), since these would interfere, too
    delete $self->{_a}; delete $self->{_p};
    # Need to disable $upgrade in BigInt, to avoid deep recursion.
    local $Math::BigInt::upgrade = undef;

    my $last = 0;
    my $over = $self * $self;		# X ^ 2
    my $self2 = $over->copy();		# X ^ 2; difference between terms
    $over->bmul($self);			# X ^ 3 as starting value
    my $sign = 1;			# start with -=
    my $below = $class->new(3);
    my $two = $class->new(2);
    delete $self->{_a}; delete $self->{_p};

    my $limit = $class->new("1E-". ($scale-1));
    #my $steps = 0;
    while (1) {
        # We calculate the next term, and add it to the last. When the next
        # term is below our limit, it won't affect the outcome anymore, so we
        # stop:
        my $next = $over->copy()->bdiv($below, $scale);
        last if $next->bacmp($limit) <= 0;

        if ($sign == 0) {
            $self->badd($next);
        } else {
            $self->bsub($next);
        }
        $sign = 1-$sign;        # alternatex
        # calculate things for the next term
        $over->bmul($self2);    # $self*$self
        $below->badd($two);     # n += 2
    }
    $self->bmul($fmul);

    if (defined $pi) {
        my $self_copy = $self->copy();
        # modify $self in place
        $self->{_m} = $pi->{_m};
        $self->{_e} = $pi->{_e};
        $self->{_es} = $pi->{_es};
        # PI/2 - $self
        $self->bsub($self_copy);
    }

    # Shortcut to not run through _find_round_parameters again.
    if (defined $params[0]) {
        $self->bround($params[0], $params[2]); # then round accordingly
    } else {
        $self->bfround($params[1], $params[2]); # then round accordingly
    }
    if ($fallback) {
        # Clear a/p after round, since user did not request it.
        delete $self->{_a}; delete $self->{_p};
    }

    # restore globals
    $$abr = $ab; $$pbr = $pb;
    $self;
}

###############################################################################
# rounding functions

sub bfround
  {
  # precision: round to the $Nth digit left (+$n) or right (-$n) from the '.'
  # $n == 0 means round to integer
  # expects and returns normalized numbers!
  my $x = shift; my $self = ref($x) || $x; $x = $self->new(shift) if !ref($x);

  my ($scale,$mode) = $x->_scale_p(@_);
  return $x if !defined $scale || $x->modify('bfround'); # no-op

  # never round a 0, +-inf, NaN
  if ($x->is_zero())
    {
    $x->{_p} = $scale if !defined $x->{_p} || $x->{_p} < $scale; # -3 < -2
    return $x; 
    }
  return $x if $x->{sign} !~ /^[+-]$/;

  # don't round if x already has lower precision
  return $x if (defined $x->{_p} && $x->{_p} < 0 && $scale < $x->{_p});

  $x->{_p} = $scale;			# remember round in any case
  delete $x->{_a};			# and clear A
  if ($scale < 0)
    {
    # round right from the '.'

    return $x if $x->{_es} eq '+';		# e >= 0 => nothing to round

    $scale = -$scale;				# positive for simplicity
    my $len = $MBI->_len($x->{_m});		# length of mantissa

    # the following poses a restriction on _e, but if _e is bigger than a
    # scalar, you got other problems (memory etc) anyway
    my $dad = -(0+ ($x->{_es}.$MBI->_num($x->{_e})));	# digits after dot
    my $zad = 0;				# zeros after dot
    $zad = $dad - $len if (-$dad < -$len);	# for 0.00..00xxx style
   
    # print "scale $scale dad $dad zad $zad len $len\n";
    # number  bsstr   len zad dad	
    # 0.123   123e-3	3   0 3
    # 0.0123  123e-4	3   1 4
    # 0.001   1e-3      1   2 3
    # 1.23    123e-2	3   0 2
    # 1.2345  12345e-4	5   0 4

    # do not round after/right of the $dad
    return $x if $scale > $dad;			# 0.123, scale >= 3 => exit

    # round to zero if rounding inside the $zad, but not for last zero like:
    # 0.0065, scale -2, round last '0' with following '65' (scale == zad case)
    return $x->bzero() if $scale < $zad;
    if ($scale == $zad)			# for 0.006, scale -3 and trunc
      {
      $scale = -$len;
      }
    else
      {
      # adjust round-point to be inside mantissa
      if ($zad != 0)
        {
	$scale = $scale-$zad;
        }
      else
        {
        my $dbd = $len - $dad; $dbd = 0 if $dbd < 0;	# digits before dot
	$scale = $dbd+$scale;
        }
      }
    }
  else
    {
    # round left from the '.'

    # 123 => 100 means length(123) = 3 - $scale (2) => 1

    my $dbt = $MBI->_len($x->{_m}); 
    # digits before dot 
    my $dbd = $dbt + ($x->{_es} . $MBI->_num($x->{_e}));
    # should be the same, so treat it as this 
    $scale = 1 if $scale == 0; 
    # shortcut if already integer 
    return $x if $scale == 1 && $dbt <= $dbd; 
    # maximum digits before dot 
    ++$dbd;

    if ($scale > $dbd) 
       { 
       # not enough digits before dot, so round to zero 
       return $x->bzero; 
       }
    elsif ( $scale == $dbd )
       { 
       # maximum 
       $scale = -$dbt; 
       } 
    else
       { 
       $scale = $dbd - $scale; 
       }
    }
  # pass sign to bround for rounding modes '+inf' and '-inf'
  my $m = bless { sign => $x->{sign}, value => $x->{_m} }, 'Math::BigInt';
  $m->bround($scale,$mode);
  $x->{_m} = $m->{value};			# get our mantissa back
  $x->bnorm();
  }

sub bround
  {
  # accuracy: preserve $N digits, and overwrite the rest with 0's
  my $x = shift; my $self = ref($x) || $x; $x = $self->new(shift) if !ref($x);

  if (($_[0] || 0) < 0)
    {
    require Carp; Carp::croak ('bround() needs positive accuracy');
    }

  my ($scale,$mode) = $x->_scale_a(@_);
  return $x if !defined $scale || $x->modify('bround');	# no-op

  # scale is now either $x->{_a}, $accuracy, or the user parameter
  # test whether $x already has lower accuracy, do nothing in this case 
  # but do round if the accuracy is the same, since a math operation might
  # want to round a number with A=5 to 5 digits afterwards again
  return $x if defined $x->{_a} && $x->{_a} < $scale;

  # scale < 0 makes no sense
  # scale == 0 => keep all digits
  # never round a +-inf, NaN
  return $x if ($scale <= 0) || $x->{sign} !~ /^[+-]$/;

  # 1: never round a 0
  # 2: if we should keep more digits than the mantissa has, do nothing
  if ($x->is_zero() || $MBI->_len($x->{_m}) <= $scale)
    {
    $x->{_a} = $scale if !defined $x->{_a} || $x->{_a} > $scale;
    return $x; 
    }

  # pass sign to bround for '+inf' and '-inf' rounding modes
  my $m = bless { sign => $x->{sign}, value => $x->{_m} }, 'Math::BigInt';

  $m->bround($scale,$mode);		# round mantissa
  $x->{_m} = $m->{value};		# get our mantissa back
  $x->{_a} = $scale;			# remember rounding
  delete $x->{_p};			# and clear P
  $x->bnorm();				# del trailing zeros gen. by bround()
  }

sub bfloor
  {
  # round towards minus infinity
  my ($self,$x,$a,$p,$r) = ref($_[0]) ? (ref($_[0]),@_) : objectify(1,@_);

  return $x if $x->modify('bfloor');
   
  return $x if $x->{sign} !~ /^[+-]$/;	# nan, +inf, -inf

  # if $x has digits after dot
  if ($x->{_es} eq '-')
    {
    $x->{_m} = $MBI->_rsft($x->{_m},$x->{_e},10); # cut off digits after dot
    $x->{_e} = $MBI->_zero();			# trunc/norm	
    $x->{_es} = '+';				# abs e
    $MBI->_inc($x->{_m}) if $x->{sign} eq '-';	# increment if negative
    }
  $x->round($a,$p,$r);
  }

sub bceil
  {
  # round towards plus infinity
  my ($self,$x,$a,$p,$r) = ref($_[0]) ? (ref($_[0]),@_) : objectify(1,@_);

  return $x if $x->modify('bceil');
  return $x if $x->{sign} !~ /^[+-]$/;	# nan, +inf, -inf

  # if $x has digits after dot
  if ($x->{_es} eq '-')
    {
    $x->{_m} = $MBI->_rsft($x->{_m},$x->{_e},10); # cut off digits after dot
    $x->{_e} = $MBI->_zero();			# trunc/norm	
    $x->{_es} = '+';				# abs e
    if ($x->{sign} eq '+') {
        $MBI->_inc($x->{_m});                   # increment if positive
    } else {
        $x->{sign} = '+' if $MBI->_is_zero($x->{_m});   # avoid -0
    }
    }
  $x->round($a,$p,$r);
  }

sub bint
  {
  # round towards zero
  my ($self,$x,$a,$p,$r) = ref($_[0]) ? (ref($_[0]),@_) : objectify(1,@_);

  return $x if $x->modify('bint');
  return $x if $x->{sign} !~ /^[+-]$/;  # nan, +inf, -inf

  # if $x has digits after the decimal point
  if ($x->{_es} eq '-')
    {
    $x->{_m} = $MBI->_rsft($x->{_m},$x->{_e},10); # cut off digits after dot
    $x->{_e} = $MBI->_zero();                     # truncate/normalize
    $x->{_es} = '+';                              # abs e
    $x->{sign} = '+' if $MBI->_is_zero($x->{_m}); # avoid -0
    }
  $x->round($a,$p,$r);
  }

sub brsft
  {
  # shift right by $y (divide by power of $n)
  
  # set up parameters
  my ($self,$x,$y,$n,$a,$p,$r) = (ref($_[0]),@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,$n,$a,$p,$r) = objectify(2,@_);
    }

  return $x if $x->modify('brsft');
  return $x if $x->{sign} !~ /^[+-]$/;	# nan, +inf, -inf

  $n = 2 if !defined $n; $n = $self->new($n);

  # negative amount?
  return $x->blsft($y->copy()->babs(),$n) if $y->{sign} =~ /^-/;

  # the following call to bdiv() will return either quo or (quo,remainder):
  $x->bdiv($n->bpow($y),$a,$p,$r,$y);
  }

sub blsft
  {
  # shift left by $y (multiply by power of $n)
  
  # set up parameters
  my ($self,$x,$y,$n,$a,$p,$r) = (ref($_[0]),@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,$n,$a,$p,$r) = objectify(2,@_);
    }

  return $x if $x->modify('blsft');
  return $x if $x->{sign} !~ /^[+-]$/;	# nan, +inf, -inf

  $n = 2 if !defined $n; $n = $self->new($n);

  # negative amount?
  return $x->brsft($y->copy()->babs(),$n) if $y->{sign} =~ /^-/;

  $x->bmul($n->bpow($y),$a,$p,$r,$y);
  }

###############################################################################

sub DESTROY
  {
  # going through AUTOLOAD for every DESTROY is costly, avoid it by empty sub
  }

sub AUTOLOAD
  {
  # make fxxx and bxxx both work by selectively mapping fxxx() to MBF::bxxx()
  # or falling back to MBI::bxxx()
  my $name = $AUTOLOAD;

  $name =~ s/(.*):://;	# split package
  my $c = $1 || $class;
  no strict 'refs';
  $c->import() if $IMPORT == 0;
  if (!_method_alias($name))
    {
    if (!defined $name)
      {
      # delayed load of Carp and avoid recursion	
      require Carp;
      Carp::croak ("$c: Can't call a method without name");
      }
    if (!_method_hand_up($name))
      {
      # delayed load of Carp and avoid recursion	
      require Carp;
      Carp::croak ("Can't call $c\-\>$name, not a valid method");
      }
    # try one level up, but subst. bxxx() for fxxx() since MBI only got bxxx()
    $name =~ s/^f/b/;
    return &{"Math::BigInt"."::$name"}(@_);
    }
  my $bname = $name; $bname =~ s/^f/b/;
  $c .= "::$name";
  *{$c} = \&{$bname};
  &{$c};	# uses @_
  }

sub exponent
  {
  # return a copy of the exponent
  my ($self,$x) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@_);

  if ($x->{sign} !~ /^[+-]$/)
    {
    my $s = $x->{sign}; $s =~ s/^[+-]//;
    return Math::BigInt->new($s); 		# -inf, +inf => +inf
    }
  Math::BigInt->new( $x->{_es} . $MBI->_str($x->{_e}));
  }

sub mantissa
  {
  # return a copy of the mantissa
  my ($self,$x) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@_);
 
  if ($x->{sign} !~ /^[+-]$/)
    {
    my $s = $x->{sign}; $s =~ s/^[+]//;
    return Math::BigInt->new($s);		# -inf, +inf => +inf
    }
  my $m = Math::BigInt->new( $MBI->_str($x->{_m}));
  $m->bneg() if $x->{sign} eq '-';

  $m;
  }

sub parts
  {
  # return a copy of both the exponent and the mantissa
  my ($self,$x) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@_);

  if ($x->{sign} !~ /^[+-]$/)
    {
    my $s = $x->{sign}; $s =~ s/^[+]//; my $se = $s; $se =~ s/^[-]//;
    return ($self->new($s),$self->new($se)); # +inf => inf and -inf,+inf => inf
    }
  my $m = Math::BigInt->bzero();
  $m->{value} = $MBI->_copy($x->{_m});
  $m->bneg() if $x->{sign} eq '-';
  ($m, Math::BigInt->new( $x->{_es} . $MBI->_num($x->{_e}) ));
  }

##############################################################################
# private stuff (internal use only)

sub import
  {
  my $self = shift;
  my $l = scalar @_;
  my $lib = ''; my @a;
  my $lib_kind = 'try';
  $IMPORT=1;
  for ( my $i = 0; $i < $l ; $i++)
    {
    if ( $_[$i] eq ':constant' )
      {
      # This causes overlord er load to step in. 'binary' and 'integer'
      # are handled by BigInt.
      overload::constant float => sub { $self->new(shift); }; 
      }
    elsif ($_[$i] eq 'upgrade')
      {
      # this causes upgrading
      $upgrade = $_[$i+1];		# or undef to disable
      $i++;
      }
    elsif ($_[$i] eq 'downgrade')
      {
      # this causes downgrading
      $downgrade = $_[$i+1];		# or undef to disable
      $i++;
      }
    elsif ($_[$i] =~ /^(lib|try|only)\z/)
      {
      # alternative library
      $lib = $_[$i+1] || '';		# default Calc
      $lib_kind = $1;			# lib, try or only
      $i++;
      }
    elsif ($_[$i] eq 'with')
      {
      # alternative class for our private parts()
      # XXX: no longer supported
      # $MBI = $_[$i+1] || 'Math::BigInt';
      $i++;
      }
    else
      {
      push @a, $_[$i];
      }
    }

  $lib =~ tr/a-zA-Z0-9,://cd;		# restrict to sane characters
  # let use Math::BigInt lib => 'GMP'; use Math::BigFloat; still work
  my $mbilib = eval { Math::BigInt->config()->{lib} };
  if ((defined $mbilib) && ($MBI eq 'Math::BigInt::Calc'))
    {
    # MBI already loaded
    Math::BigInt->import( $lib_kind, "$lib,$mbilib", 'objectify');
    }
  else
    {
    # MBI not loaded, or with ne "Math::BigInt::Calc"
    $lib .= ",$mbilib" if defined $mbilib;
    $lib =~ s/^,//;				# don't leave empty 
    
    # replacement library can handle lib statement, but also could ignore it
    
    # Perl < 5.6.0 dies with "out of memory!" when eval() and ':constant' is
    # used in the same script, or eval inside import(). So we require MBI:
    require Math::BigInt;
    Math::BigInt->import( $lib_kind => $lib, 'objectify' );
    }
  if ($@)
    {
    require Carp; Carp::croak ("Couldn't load $lib: $! $@");
    }
  # find out which one was actually loaded
  $MBI = Math::BigInt->config()->{lib};

  # register us with MBI to get notified of future lib changes
  Math::BigInt::_register_callback( $self, sub { $MBI = $_[0]; } );

  $self->export_to_level(1,$self,@a);		# export wanted functions
  }

sub bnorm
  {
  # adjust m and e so that m is smallest possible
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);

  return $x if $x->{sign} !~ /^[+-]$/;		# inf, nan etc

  my $zeros = $MBI->_zeros($x->{_m});		# correct for trailing zeros
  if ($zeros != 0)
    {
    my $z = $MBI->_new($zeros);
    $x->{_m} = $MBI->_rsft ($x->{_m}, $z, 10);
    if ($x->{_es} eq '-')
      {
      if ($MBI->_acmp($x->{_e},$z) >= 0)
        {
        $x->{_e} = $MBI->_sub ($x->{_e}, $z);
        $x->{_es} = '+' if $MBI->_is_zero($x->{_e});
        }
      else
        {
        $x->{_e} = $MBI->_sub ( $MBI->_copy($z), $x->{_e});
        $x->{_es} = '+';
        }
      }
    else
      {
      $x->{_e} = $MBI->_add ($x->{_e}, $z);
      }
    }
  else
    {
    # $x can only be 0Ey if there are no trailing zeros ('0' has 0 trailing
    # zeros). So, for something like 0Ey, set y to 1, and -0 => +0
    $x->{sign} = '+', $x->{_es} = '+', $x->{_e} = $MBI->_one()
     if $MBI->_is_zero($x->{_m});
    }

  $x;					# MBI bnorm is no-op, so do not call it
  } 
 
##############################################################################

sub as_hex
  {
  # return number as hexadecimal string (only for integers defined)
  my ($self,$x) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@_);

  return $x->bstr() if $x->{sign} !~ /^[+-]$/;  # inf, nan etc
  return '0x0' if $x->is_zero();

  return $nan if $x->{_es} ne '+';		# how to do 1e-1 in hex!?

  my $z = $MBI->_copy($x->{_m});
  if (! $MBI->_is_zero($x->{_e}))		# > 0 
    {
    $MBI->_lsft( $z, $x->{_e},10);
    }
  $z = Math::BigInt->new( $x->{sign} . $MBI->_num($z));
  $z->as_hex();
  }

sub as_bin
  {
  # return number as binary digit string (only for integers defined)
  my ($self,$x) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@_);

  return $x->bstr() if $x->{sign} !~ /^[+-]$/;  # inf, nan etc
  return '0b0' if $x->is_zero();

  return $nan if $x->{_es} ne '+';		# how to do 1e-1 in hex!?

  my $z = $MBI->_copy($x->{_m});
  if (! $MBI->_is_zero($x->{_e}))		# > 0 
    {
    $MBI->_lsft( $z, $x->{_e},10);
    }
  $z = Math::BigInt->new( $x->{sign} . $MBI->_num($z));
  $z->as_bin();
  }

sub as_oct
  {
  # return number as octal digit string (only for integers defined)
  my ($self,$x) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@_);

  return $x->bstr() if $x->{sign} !~ /^[+-]$/;  # inf, nan etc
  return '0' if $x->is_zero();

  return $nan if $x->{_es} ne '+';		# how to do 1e-1 in hex!?

  my $z = $MBI->_copy($x->{_m});
  if (! $MBI->_is_zero($x->{_e}))		# > 0 
    {
    $MBI->_lsft( $z, $x->{_e},10);
    }
  $z = Math::BigInt->new( $x->{sign} . $MBI->_num($z));
  $z->as_oct();
  }

sub as_number
  {
  # return copy as a bigint representation of this BigFloat number
  my ($self,$x) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@_);

  return $x if $x->modify('as_number');

  if (!$x->isa('Math::BigFloat'))
    {
    # if the object can as_number(), use it
    return $x->as_number() if $x->can('as_number');
    # otherwise, get us a float and then a number
    $x = $x->can('as_float') ? $x->as_float() : $self->new(0+"$x");
    }

  return Math::BigInt->binf($x->sign()) if $x->is_inf();
  return Math::BigInt->bnan()           if $x->is_nan();

  my $z = $MBI->_copy($x->{_m});
  if ($x->{_es} eq '-')			# < 0
    {
    $MBI->_rsft( $z, $x->{_e},10);
    } 
  elsif (! $MBI->_is_zero($x->{_e}))	# > 0 
    {
    $MBI->_lsft( $z, $x->{_e},10);
    }
  $z = Math::BigInt->new( $x->{sign} . $MBI->_str($z));
  $z;
  }

sub length
  {
  my $x = shift;
  my $class = ref($x) || $x;
  $x = $class->new(shift) unless ref($x);

  return 1 if $MBI->_is_zero($x->{_m});

  my $len = $MBI->_len($x->{_m});
  $len += $MBI->_num($x->{_e}) if $x->{_es} eq '+';
  if (wantarray())
    {
    my $t = 0;
    $t = $MBI->_num($x->{_e}) if $x->{_es} eq '-';
    return ($len, $t);
    }
  $len;
  }

sub from_hex {
    my $self    = shift;
    my $selfref = ref $self;
    my $class   = $selfref || $self;

    my $str = shift;

    # If called as a class method, initialize a new object.

    $self = $class -> bzero() unless $selfref;

    if ($str =~ s/
                     ^

                     # sign
                     ( [+-]? )

                     # optional "hex marker"
                     (?: 0? x )?

                     # significand using the hex digits 0..9 and a..f
                     (
                         [0-9a-fA-F]+ (?: _ [0-9a-fA-F]+ )*
                         (?:
                             \.
                             (?: [0-9a-fA-F]+ (?: _ [0-9a-fA-F]+ )* )?
                         )?
                     |
                         \.
                         [0-9a-fA-F]+ (?: _ [0-9a-fA-F]+ )*
                     )

                     # exponent (power of 2) using decimal digits
                     (?:
                         [Pp]
                         ( [+-]? )
                         ( \d+ (?: _ \d+ )* )
                     )?

                     $
                 //x)
    {
        my $s_sign  = $1 || '+';
        my $s_value = $2;
        my $e_sign  = $3 || '+';
        my $e_value = $4 || '0';
        $s_value =~ tr/_//d;
        $e_value =~ tr/_//d;

        # The significand must be multiplied by 2 raised to this exponent.

        my $two_expon = $class -> new($e_value);
        $two_expon -> bneg() if $e_sign eq '-';

        # If there is a dot in the significand, remove it and adjust the
        # exponent according to the number of digits in the fraction part of
        # the significand. Since the digits in the significand are in base 16,
        # but the exponent is only in base 2, multiply the exponent adjustment
        # value by log(16) / log(2) = 4.

        my $idx = index($s_value, '.');
        if ($idx >= 0) {
            substr($s_value, $idx, 1) = '';
            $two_expon -= $class -> new(CORE::length($s_value))
                                 -> bsub($idx)
                                 -> bmul("4");
        }

        $self -> {sign} = $s_sign;
        $self -> {_m}   = $MBI -> _from_hex('0x' . $s_value);

        if ($two_expon > 0) {
            my $factor = $class -> new("2") -> bpow($two_expon);
            $self -> bmul($factor);
        } elsif ($two_expon < 0) {
            my $factor = $class -> new("0.5") -> bpow(-$two_expon);
            $self -> bmul($factor);
        }

        return $self;
    }

    return $self->bnan();
}

sub from_oct {
    my $self    = shift;
    my $selfref = ref $self;
    my $class   = $selfref || $self;

    my $str = shift;

    # If called as a class method, initialize a new object.

    $self = $class -> bzero() unless $selfref;

    if ($str =~ s/
                     ^

                     # sign
                     ( [+-]? )

                     # significand using the octal digits 0..7
                     (
                         [0-7]+ (?: _ [0-7]+ )*
                         (?:
                             \.
                             (?: [0-7]+ (?: _ [0-7]+ )* )?
                         )?
                     |
                         \.
                         [0-7]+ (?: _ [0-7]+ )*
                     )

                     # exponent (power of 2) using decimal digits
                     (?:
                         [Pp]
                         ( [+-]? )
                         ( \d+ (?: _ \d+ )* )
                     )?

                     $
                 //x)
    {
        my $s_sign  = $1 || '+';
        my $s_value = $2;
        my $e_sign  = $3 || '+';
        my $e_value = $4 || '0';
        $s_value =~ tr/_//d;
        $e_value =~ tr/_//d;

        # The significand must be multiplied by 2 raised to this exponent.

        my $two_expon = $class -> new($e_value);
        $two_expon -> bneg() if $e_sign eq '-';

        # If there is a dot in the significand, remove it and adjust the
        # exponent according to the number of digits in the fraction part of
        # the significand. Since the digits in the significand are in base 8,
        # but the exponent is only in base 2, multiply the exponent adjustment
        # value by log(8) / log(2) = 3.

        my $idx = index($s_value, '.');
        if ($idx >= 0) {
            substr($s_value, $idx, 1) = '';
            $two_expon -= $class -> new(CORE::length($s_value))
                                 -> bsub($idx)
                                 -> bmul("3");
        }

        $self -> {sign} = $s_sign;
        $self -> {_m}   = $MBI -> _from_oct($s_value);

        if ($two_expon > 0) {
            my $factor = $class -> new("2") -> bpow($two_expon);
            $self -> bmul($factor);
        } elsif ($two_expon < 0) {
            my $factor = $class -> new("0.5") -> bpow(-$two_expon);
            $self -> bmul($factor);
        }

        return $self;
    }

    return $self->bnan();
}

sub from_bin {
    my $self    = shift;
    my $selfref = ref $self;
    my $class   = $selfref || $self;

    my $str = shift;

    # If called as a class method, initialize a new object.

    $self = $class -> bzero() unless $selfref;

    if ($str =~ s/
                     ^

                     # sign
                     ( [+-]? )

                     # optional "bin marker"
                     (?: 0? b )?

                     # significand using the binary digits 0 and 1
                     (
                         [01]+ (?: _ [01]+ )*
                         (?:
                             \.
                             (?: [01]+ (?: _ [01]+ )* )?
                         )?
                     |
                         \.
                         [01]+ (?: _ [01]+ )*
                     )

                     # exponent (power of 2) using decimal digits
                     (?:
                         [Pp]
                         ( [+-]? )
                         ( \d+ (?: _ \d+ )* )
                     )?

                     $
                 //x)
    {
        my $s_sign  = $1 || '+';
        my $s_value = $2;
        my $e_sign  = $3 || '+';
        my $e_value = $4 || '0';
        $s_value =~ tr/_//d;
        $e_value =~ tr/_//d;

        # The significand must be multiplied by 2 raised to this exponent.

        my $two_expon = $class -> new($e_value);
        $two_expon -> bneg() if $e_sign eq '-';

        # If there is a dot in the significand, remove it and adjust the
        # exponent according to the number of digits in the fraction part of
        # the significand.

        my $idx = index($s_value, '.');
        if ($idx >= 0) {
            substr($s_value, $idx, 1) = '';
            $two_expon -= $class -> new(CORE::length($s_value))
                                 -> bsub($idx);
        }

        $self -> {sign} = $s_sign;
        $self -> {_m}   = $MBI -> _from_bin('0b' . $s_value);

        if ($two_expon > 0) {
            my $factor = $class -> new("2") -> bpow($two_expon);
            $self -> bmul($factor);
        } elsif ($two_expon < 0) {
            my $factor = $class -> new("0.5") -> bpow(-$two_expon);
            $self -> bmul($factor);
        }

        return $self;
    }

    return $self->bnan();
}

1;

__END__

=pod

=head1 NAME

Math::BigFloat - Arbitrary size floating point math package

=head1 SYNOPSIS

 use Math::BigFloat;

 # Number creation
 my $x = Math::BigFloat->new($str);	# defaults to 0
 my $y = $x->copy();			# make a true copy
 my $nan  = Math::BigFloat->bnan();	# create a NotANumber
 my $zero = Math::BigFloat->bzero();	# create a +0
 my $inf = Math::BigFloat->binf();	# create a +inf
 my $inf = Math::BigFloat->binf('-');	# create a -inf
 my $one = Math::BigFloat->bone();	# create a +1
 my $mone = Math::BigFloat->bone('-');	# create a -1
 my $x = Math::BigFloat->bone('-');	#

 my $x = Math::BigFloat->from_hex('0xc.afep+3');    # from hexadecimal
 my $x = Math::BigFloat->from_bin('0b1.1001p-4');   # from binary
 my $x = Math::BigFloat->from_oct('1.3267p-4');     # from octal

 my $pi = Math::BigFloat->bpi(100);	# PI to 100 digits

 # the following examples compute their result to 100 digits accuracy:
 my $cos  = Math::BigFloat->new(1)->bcos(100);	      # cosinus(1)
 my $sin  = Math::BigFloat->new(1)->bsin(100);	      # sinus(1)
 my $atan = Math::BigFloat->new(1)->batan(100);	      # arcus tangens(1)

 my $atan2 = Math::BigFloat->new(  1 )->batan2( 1 ,100); # batan(1)
 my $atan2 = Math::BigFloat->new(  1 )->batan2( 8 ,100); # batan(1/8)
 my $atan2 = Math::BigFloat->new( -2 )->batan2( 1 ,100); # batan(-2)

 # Testing
 $x->is_zero();		 # true if arg is +0
 $x->is_nan();		 # true if arg is NaN
 $x->is_one();		 # true if arg is +1
 $x->is_one('-');	 # true if arg is -1
 $x->is_odd();		 # true if odd, false for even
 $x->is_even();		 # true if even, false for odd
 $x->is_pos();		 # true if >= 0
 $x->is_neg();		 # true if <  0
 $x->is_inf(sign);	 # true if +inf, or -inf (default is '+')

 $x->bcmp($y);		 # compare numbers (undef,<0,=0,>0)
 $x->bacmp($y);		 # compare absolutely (undef,<0,=0,>0)
 $x->sign();		 # return the sign, either +,- or NaN
 $x->digit($n);		 # return the nth digit, counting from right
 $x->digit(-$n);	 # return the nth digit, counting from left 

 # The following all modify their first argument. If you want to pre-
 # serve $x, use $z = $x->copy()->bXXX($y); See under L</CAVEATS> for
 # necessary when mixing $a = $b assignments with non-overloaded math.

 # set 
 $x->bzero();		 # set $i to 0
 $x->bnan();		 # set $i to NaN
 $x->bone();		 # set $x to +1
 $x->bone('-');		 # set $x to -1
 $x->binf();		 # set $x to inf
 $x->binf('-');		 # set $x to -inf

 $x->bneg();		 # negation
 $x->babs();		 # absolute value
 $x->bnorm();		 # normalize (no-op)
 $x->bnot();		 # two's complement (bit wise not)
 $x->binc();		 # increment x by 1
 $x->bdec();		 # decrement x by 1

 $x->badd($y);		 # addition (add $y to $x)
 $x->bsub($y);		 # subtraction (subtract $y from $x)
 $x->bmul($y);		 # multiplication (multiply $x by $y)
 $x->bdiv($y);		 # divide, set $x to quotient
			 # return (quo,rem) or quo if scalar

 $x->bmod($y);		 # modulus ($x % $y)
 $x->bpow($y);		 # power of arguments ($x ** $y)
 $x->bmodpow($exp,$mod); # modular exponentiation (($num**$exp) % $mod))
 $x->blsft($y, $n);	 # left shift by $y places in base $n
 $x->brsft($y, $n);	 # right shift by $y places in base $n
			 # returns (quo,rem) or quo if in scalar context

 $x->blog();		 # logarithm of $x to base e (Euler's number)
 $x->blog($base);	 # logarithm of $x to base $base (f.i. 2)
 $x->bexp();		 # calculate e ** $x where e is Euler's number

 $x->band($y);		 # bit-wise and
 $x->bior($y);		 # bit-wise inclusive or
 $x->bxor($y);		 # bit-wise exclusive or
 $x->bnot();		 # bit-wise not (two's complement)

 $x->bsqrt();		 # calculate square-root
 $x->broot($y);		 # $y'th root of $x (e.g. $y == 3 => cubic root)
 $x->bfac();		 # factorial of $x (1*2*3*4*..$x)

 $x->bround($N); 	 # accuracy: preserve $N digits
 $x->bfround($N);	 # precision: round to the $Nth digit

 $x->bfloor();		 # return integer less or equal than $x
 $x->bceil();		 # return integer greater or equal than $x
 $x->bint();             # round towards zero

  # The following do not modify their arguments:

 bgcd(@values);		 # greatest common divisor
 blcm(@values);		 # lowest common multiplicator

 $x->bstr();		 # return string
 $x->bsstr();		 # return string in scientific notation

 $x->as_int();		 # return $x as BigInt 
 $x->exponent();	 # return exponent as BigInt
 $x->mantissa();	 # return mantissa as BigInt
 $x->parts();		 # return (mantissa,exponent) as BigInt

 $x->length();		 # number of digits (w/o sign and '.')
 ($l,$f) = $x->length(); # number of digits, and length of fraction

 $x->precision();	 # return P of $x (or global, if P of $x undef)
 $x->precision($n);	 # set P of $x to $n
 $x->accuracy();	 # return A of $x (or global, if A of $x undef)
 $x->accuracy($n);	 # set A $x to $n

 # these get/set the appropriate global value for all BigFloat objects
 Math::BigFloat->precision();	# Precision
 Math::BigFloat->accuracy();	# Accuracy
 Math::BigFloat->round_mode();	# rounding mode

=head1 DESCRIPTION

All operators (including basic math operations) are overloaded if you
declare your big floating point numbers as

  $i = Math::BigFloat -> new('12_3.456_789_123_456_789E-2');

Operations with overloaded operators preserve the arguments, which is
exactly what you expect.

=head2 Input

Input to these routines are either BigFloat objects, or strings of the
following four forms:

=over

=item *

C</^[+-]\d+$/>

=item *

C</^[+-]\d+\.\d*$/>

=item *

C</^[+-]\d+E[+-]?\d+$/>

=item *

C</^[+-]\d*\.\d+E[+-]?\d+$/>

=back

all with optional leading and trailing zeros and/or spaces. Additionally,
numbers are allowed to have an underscore between any two digits.

Empty strings as well as other illegal numbers results in 'NaN'.

bnorm() on a BigFloat object is now effectively a no-op, since the numbers 
are always stored in normalized form. On a string, it creates a BigFloat 
object.

=head2 Output

Output values are BigFloat objects (normalized), except for bstr() and bsstr().

The string output will always have leading and trailing zeros stripped and drop
a plus sign. C<bstr()> will give you always the form with a decimal point,
while C<bsstr()> (s for scientific) gives you the scientific notation.

	Input			bstr()		bsstr()
	'-0'			'0'		'0E1'
   	'  -123 123 123'	'-123123123'	'-123123123E0'
	'00.0123'		'0.0123'	'123E-4'
	'123.45E-2'		'1.2345'	'12345E-4'
	'10E+3'			'10000'		'1E4'

Some routines (C<is_odd()>, C<is_even()>, C<is_zero()>, C<is_one()>,
C<is_nan()>) return true or false, while others (C<bcmp()>, C<bacmp()>)
return either undef, <0, 0 or >0 and are suited for sort.

Actual math is done by using the class defined with C<< with => Class; >>
(which defaults to BigInts) to represent the mantissa and exponent.

The sign C</^[+-]$/> is stored separately. The string 'NaN' is used to 
represent the result when input arguments are not numbers, and 'inf' and
'-inf' are used to represent positive and negative infinity, respectively.

=head2 mantissa(), exponent() and parts()

mantissa() and exponent() return the said parts of the BigFloat
as BigInts such that:

	$m = $x->mantissa();
	$e = $x->exponent();
	$y = $m * ( 10 ** $e );
	print "ok\n" if $x == $y;

C<< ($m,$e) = $x->parts(); >> is just a shortcut giving you both of them.

Currently the mantissa is reduced as much as possible, favouring higher
exponents over lower ones (e.g. returning 1e7 instead of 10e6 or 10000000e0).
This might change in the future, so do not depend on it.

=head2 Accuracy vs. Precision

See also: L<Rounding|/Rounding>.

Math::BigFloat supports both precision (rounding to a certain place before or
after the dot) and accuracy (rounding to a certain number of digits). For a
full documentation, examples and tips on these topics please see the large
section about rounding in L<Math::BigInt>.

Since things like C<sqrt(2)> or C<1 / 3> must presented with a limited
accuracy lest a operation consumes all resources, each operation produces
no more than the requested number of digits.

If there is no global precision or accuracy set, B<and> the operation in
question was not called with a requested precision or accuracy, B<and> the
input $x has no accuracy or precision set, then a fallback parameter will
be used. For historical reasons, it is called C<div_scale> and can be accessed
via:

	$d = Math::BigFloat->div_scale();	# query
	Math::BigFloat->div_scale($n);		# set to $n digits

The default value for C<div_scale> is 40.

In case the result of one operation has more digits than specified,
it is rounded. The rounding mode taken is either the default mode, or the one
supplied to the operation after the I<scale>:

    $x = Math::BigFloat->new(2);
    Math::BigFloat->accuracy(5);	      # 5 digits max
    $y = $x->copy()->bdiv(3);		      # will give 0.66667
    $y = $x->copy()->bdiv(3,6);		      # will give 0.666667
    $y = $x->copy()->bdiv(3,6,undef,'odd');   # will give 0.666667
    Math::BigFloat->round_mode('zero');
    $y = $x->copy()->bdiv(3,6);		      # will also give 0.666667

Note that C<< Math::BigFloat->accuracy() >> and C<< Math::BigFloat->precision() >>
set the global variables, and thus B<any> newly created number will be subject
to the global rounding B<immediately>. This means that in the examples above, the
C<3> as argument to C<bdiv()> will also get an accuracy of B<5>.

It is less confusing to either calculate the result fully, and afterwards
round it explicitly, or use the additional parameters to the math
functions like so:

	use Math::BigFloat;
	$x = Math::BigFloat->new(2);
	$y = $x->copy()->bdiv(3);
	print $y->bround(5),"\n";		# will give 0.66667

	or

	use Math::BigFloat;
	$x = Math::BigFloat->new(2);
	$y = $x->copy()->bdiv(3,5);		# will give 0.66667
	print "$y\n";

=head2 Rounding

=over

=item bfround ( +$scale )

Rounds to the $scale'th place left from the '.', counting from the dot.
The first digit is numbered 1. 

=item bfround ( -$scale )

Rounds to the $scale'th place right from the '.', counting from the dot.

=item bfround ( 0 )

Rounds to an integer.

=item bround  ( +$scale )

Preserves accuracy to $scale digits from the left (aka significant digits)
and pads the rest with zeros. If the number is between 1 and -1, the
significant digits count from the first non-zero after the '.'

=item bround  ( -$scale ) and bround ( 0 )

These are effectively no-ops.

=back

All rounding functions take as a second parameter a rounding mode from one of
the following: 'even', 'odd', '+inf', '-inf', 'zero', 'trunc' or 'common'.

The default rounding mode is 'even'. By using
C<< Math::BigFloat->round_mode($round_mode); >> you can get and set the default
mode for subsequent rounding. The usage of C<$Math::BigFloat::$round_mode> is
no longer supported.
The second parameter to the round functions then overrides the default
temporarily. 

The C<as_number()> function returns a BigInt from a Math::BigFloat. It uses
'trunc' as rounding mode to make it equivalent to:

	$x = 2.5;
	$y = int($x) + 2;

You can override this by passing the desired rounding mode as parameter to
C<as_number()>:

	$x = Math::BigFloat->new(2.5);
	$y = $x->as_number('odd');	# $y = 3

=head1 METHODS

Math::BigFloat supports all methods that Math::BigInt supports, except it
calculates non-integer results when possible. Please see L<Math::BigInt>
for a full description of each method. Below are just the most important
differences:

=over

=item accuracy()

      $x->accuracy(5);           # local for $x
      CLASS->accuracy(5);        # global for all members of CLASS
                                 # Note: This also applies to new()!

      $A = $x->accuracy();       # read out accuracy that affects $x
      $A = CLASS->accuracy();    # read out global accuracy

Set or get the global or local accuracy, aka how many significant digits the
results have. If you set a global accuracy, then this also applies to new()!

Warning! The accuracy I<sticks>, e.g. once you created a number under the
influence of C<< CLASS->accuracy($A) >>, all results from math operations with
that number will also be rounded.

In most cases, you should probably round the results explicitly using one of
L<Math::BigInt/round()>, L<Math::BigInt/bround()> or L<Math::BigInt/bfround()> or by passing the desired accuracy
to the math operation as additional parameter:

        my $x = Math::BigInt->new(30000);
        my $y = Math::BigInt->new(7);
        print scalar $x->copy()->bdiv($y, 2);           # print 4300
        print scalar $x->copy()->bdiv($y)->bround(2);   # print 4300

=item precision()

      $x->precision(-2);      # local for $x, round at the second
                              # digit right of the dot
      $x->precision(2);       # ditto, round at the second digit
                              # left of the dot

      CLASS->precision(5);    # Global for all members of CLASS
                              # This also applies to new()!
      CLASS->precision(-5);   # ditto

      $P = CLASS->precision();  # read out global precision
      $P = $x->precision();     # read out precision that affects $x

Note: You probably want to use L</accuracy()> instead. With L</accuracy()> you
set the number of digits each result should have, with L</precision()> you
set the place where to round!

=item bdiv()

        $q = $x->bdiv($y);
        ($q, $r) = $x->bdiv($y);

In scalar context, divides $x by $y and returns the result to the given or
default accuracy/precision. In list context, does floored division
(F-division), returning an integer $q and a remainder $r so that $x = $q * $y +
$r. The remainer (modulo) is equal to what is returned by C<$x->bmod($y)>.

=item bmod()

	$x->bmod($y);

Returns $x modulo $y. When $x is finite, and $y is finite and non-zero, the
result is identical to the remainder after floored division (F-division). If,
in addition, both $x and $y are integers, the result is identical to the result
from Perl's % operator.

=item bexp()

	$x->bexp($accuracy);		# calculate e ** X

Calculates the expression C<e ** $x> where C<e> is Euler's number.

This method was added in v1.82 of Math::BigInt (April 2007).

=item bnok()

	$x->bnok($y);	# x over y (binomial coefficient n over k)

Calculates the binomial coefficient n over k, also called the "choose"
function. The result is equivalent to:

	( n )      n!
	| - |  = -------
	( k )    k!(n-k)!

This method was added in v1.84 of Math::BigInt (April 2007).

=item bpi()

	print Math::BigFloat->bpi(100), "\n";

Calculate PI to N digits (including the 3 before the dot). The result is
rounded according to the current rounding mode, which defaults to "even".

This method was added in v1.87 of Math::BigInt (June 2007).

=item bcos()

	my $x = Math::BigFloat->new(1);
	print $x->bcos(100), "\n";

Calculate the cosinus of $x, modifying $x in place.

This method was added in v1.87 of Math::BigInt (June 2007).

=item bsin()

	my $x = Math::BigFloat->new(1);
	print $x->bsin(100), "\n";

Calculate the sinus of $x, modifying $x in place.

This method was added in v1.87 of Math::BigInt (June 2007).

=item batan2()

	my $y = Math::BigFloat->new(2);
	my $x = Math::BigFloat->new(3);
	print $y->batan2($x), "\n";

Calculate the arcus tanges of C<$y> divided by C<$x>, modifying $y in place.
See also L</batan()>.

This method was added in v1.87 of Math::BigInt (June 2007).

=item batan()

	my $x = Math::BigFloat->new(1);
	print $x->batan(100), "\n";

Calculate the arcus tanges of $x, modifying $x in place. See also L</batan2()>.

This method was added in v1.87 of Math::BigInt (June 2007).

=item bmuladd()

	$x->bmuladd($y,$z);

Multiply $x by $y, and then add $z to the result.

This method was added in v1.87 of Math::BigInt (June 2007).

=item as_float()

This method is called when Math::BigFloat encounters an object it doesn't know
how to handle. For instance, assume $x is a Math::BigFloat, or subclass
thereof, and $y is defined, but not a Math::BigFloat, or subclass thereof. If
you do

    $x -> badd($y);

$y needs to be converted into an object that $x can deal with. This is done by
first checking if $y is something that $x might be upgraded to. If that is the
case, no further attempts are made. The next is to see if $y supports the
method C<as_float()>. The method C<as_float()> is expected to return either an
object that has the same class as $x, a subclass thereof, or a string that
C<ref($x)-E<gt>new()> can parse to create an object.

In Math::BigFloat, C<as_float()> has the same effect as C<copy()>.

=item from_hex()

    $x -> from_hex("0x1.921fb54442d18p+1");
    $x = Math::BigFloat -> from_hex("0x1.921fb54442d18p+1");

Interpret input as a hexadecimal string.A prefix ("0x", "x", ignoring case) is
optional. A single underscore character ("_") may be placed between any two
digits. If the input is invalid, a NaN is returned. The exponent is in base 2
using decimal digits.

If called as an instance method, the value is assigned to the invocand.

=item from_bin()

    $x -> from_bin("0b1.1001p-4");
    $x = Math::BigFloat -> from_bin("0b1.1001p-4");

Interpret input as a hexadecimal string. A prefix ("0b" or "b", ignoring case)
is optional. A single underscore character ("_") may be placed between any two
digits. If the input is invalid, a NaN is returned. The exponent is in base 2
using decimal digits.

If called as an instance method, the value is assigned to the invocand.

=item from_oct()

    $x -> from_oct("1.3267p-4");
    $x = Math::BigFloat -> from_oct("1.3267p-4");

Interpret input as an octal string. A single underscore character ("_") may be
placed between any two digits. If the input is invalid, a NaN is returned. The
exponent is in base 2 using decimal digits.

If called as an instance method, the value is assigned to the invocand.

=back

=head1 Autocreating constants

After C<use Math::BigFloat ':constant'> all the floating point constants
in the given scope are converted to C<Math::BigFloat>. This conversion
happens at compile time.

In particular

  perl -MMath::BigFloat=:constant -e 'print 2E-100,"\n"'

prints the value of C<2E-100>. Note that without conversion of 
constants the expression 2E-100 will be calculated as normal floating point 
number.

Please note that ':constant' does not affect integer constants, nor binary 
nor hexadecimal constants. Use L<bignum> or L<Math::BigInt> to get this to
work.

=head2 Math library

Math with the numbers is done (by default) by a module called
Math::BigInt::Calc. This is equivalent to saying:

	use Math::BigFloat lib => 'Calc';

You can change this by using:

	use Math::BigFloat lib => 'GMP';

B<Note>: General purpose packages should not be explicit about the library
to use; let the script author decide which is best.

Note: The keyword 'lib' will warn when the requested library could not be
loaded. To suppress the warning use 'try' instead:

	use Math::BigFloat try => 'GMP';

If your script works with huge numbers and Calc is too slow for them,
you can also for the loading of one of these libraries and if none
of them can be used, the code will die:

        use Math::BigFloat only => 'GMP,Pari';

The following would first try to find Math::BigInt::Foo, then
Math::BigInt::Bar, and when this also fails, revert to Math::BigInt::Calc:

	use Math::BigFloat lib => 'Foo,Math::BigInt::Bar';

See the respective low-level library documentation for further details.

Please note that Math::BigFloat does B<not> use the denoted library itself,
but it merely passes the lib argument to Math::BigInt. So, instead of the need
to do:

	use Math::BigInt lib => 'GMP';
	use Math::BigFloat;

you can roll it all into one line:

	use Math::BigFloat lib => 'GMP';

It is also possible to just require Math::BigFloat:

	require Math::BigFloat;

This will load the necessary things (like BigInt) when they are needed, and
automatically.

See L<Math::BigInt> for more details than you ever wanted to know about using
a different low-level library.

=head2 Using Math::BigInt::Lite

For backwards compatibility reasons it is still possible to
request a different storage class for use with Math::BigFloat:

        use Math::BigFloat with => 'Math::BigInt::Lite';

However, this request is ignored, as the current code now uses the low-level
math library for directly storing the number parts.

=head1 EXPORTS

C<Math::BigFloat> exports nothing by default, but can export the C<bpi()> method:

	use Math::BigFloat qw/bpi/;

	print bpi(10), "\n";

=head1 CAVEATS

Do not try to be clever to insert some operations in between switching
libraries:

    require Math::BigFloat;
    my $matter = Math::BigFloat->bone() + 4;	# load BigInt and Calc
    Math::BigFloat->import( lib => 'Pari' );	# load Pari, too
    my $anti_matter = Math::BigFloat->bone()+4;	# now use Pari

This will create objects with numbers stored in two different backend libraries,
and B<VERY BAD THINGS> will happen when you use these together:

	my $flash_and_bang = $matter + $anti_matter;	# Don't do this!

=over

=item stringify, bstr()

Both stringify and bstr() now drop the leading '+'. The old code would return
'+1.23', the new returns '1.23'. See the documentation in L<Math::BigInt> for
reasoning and details.

=item bdiv()

The following will probably not print what you expect:

	print $c->bdiv(123.456),"\n";

It prints both quotient and remainder since print works in list context. Also,
bdiv() will modify $c, so be careful. You probably want to use

    print $c / 123.456,"\n";
    # or if you want to modify $c:
    print scalar $c->bdiv(123.456),"\n";

instead.

=item brsft()

The following will probably not print what you expect:

	my $c = Math::BigFloat->new('3.14159');
        print $c->brsft(3,10),"\n";	# prints 0.00314153.1415

It prints both quotient and remainder, since print calls C<brsft()> in list
context. Also, C<< $c->brsft() >> will modify $c, so be careful.
You probably want to use

	print scalar $c->copy()->brsft(3,10),"\n";
	# or if you really want to modify $c
        print scalar $c->brsft(3,10),"\n";

instead.

=item Modifying and =

Beware of:

	$x = Math::BigFloat->new(5);
	$y = $x;

It will not do what you think, e.g. making a copy of $x. Instead it just makes
a second reference to the B<same> object and stores it in $y. Thus anything
that modifies $x will modify $y (except overloaded math operators), and vice
versa. See L<Math::BigInt> for details and how to avoid that.

=item bpow()

C<bpow()> now modifies the first argument, unlike the old code which left
it alone and only returned the result. This is to be consistent with
C<badd()> etc. The first will modify $x, the second one won't:

	print bpow($x,$i),"\n"; 	# modify $x
	print $x->bpow($i),"\n"; 	# ditto
	print $x ** $i,"\n";		# leave $x alone 

=item precision() vs. accuracy()

A common pitfall is to use L</precision()> when you want to round a result to
a certain number of digits:

    use Math::BigFloat;

    Math::BigFloat->precision(4);	    # does not do what you
					    # think it does
    my $x = Math::BigFloat->new(12345);	    # rounds $x to "12000"!
    print "$x\n";			    # print "12000"
    my $y = Math::BigFloat->new(3);	    # rounds $y to "0"!
    print "$y\n";			    # print "0"
    $z = $x / $y;			    # 12000 / 0 => NaN!
    print "$z\n";
    print $z->precision(),"\n";		    # 4

Replacing L</precision()> with L</accuracy()> is probably not what you want, either:

    use Math::BigFloat;

    Math::BigFloat->accuracy(4);	  # enables global rounding:
    my $x = Math::BigFloat->new(123456);  # rounded immediately
                                          #   to "12350"
    print "$x\n";			  # print "123500"
    my $y = Math::BigFloat->new(3);	  # rounded to "3
    print "$y\n";			  # print "3"
    print $z = $x->copy()->bdiv($y),"\n"; # 41170
    print $z->accuracy(),"\n";		  # 4

What you want to use instead is:

    use Math::BigFloat;

    my $x = Math::BigFloat->new(123456);    # no rounding
    print "$x\n";			    # print "123456"
    my $y = Math::BigFloat->new(3);	    # no rounding
    print "$y\n";			    # print "3"
    print $z = $x->copy()->bdiv($y,4),"\n"; # 41150
    print $z->accuracy(),"\n";		    # undef

In addition to computing what you expected, the last example also does B<not>
"taint" the result with an accuracy or precision setting, which would
influence any further operation.

=back

=head1 BUGS

Please report any bugs or feature requests to
C<bug-math-bigint at rt.cpan.org>, or through the web interface at
L<https://rt.cpan.org/Ticket/Create.html?Queue=Math-BigInt>
(requires login).
We will be notified, and then you'll automatically be notified of progress on
your bug as I make changes.

=head1 SUPPORT

You can find documentation for this module with the perldoc command.

    perldoc Math::BigFloat

You can also look for information at:

=over 4

=item * RT: CPAN's request tracker

L<https://rt.cpan.org/Public/Dist/Display.html?Name=Math-BigInt>

=item * AnnoCPAN: Annotated CPAN documentation

L<http://annocpan.org/dist/Math-BigInt>

=item * CPAN Ratings

L<http://cpanratings.perl.org/dist/Math-BigInt>

=item * Search CPAN

L<http://search.cpan.org/dist/Math-BigInt/>

=item * CPAN Testers Matrix

L<http://matrix.cpantesters.org/?dist=Math-BigInt>

=item * The Bignum mailing list

=over 4

=item * Post to mailing list

C<bignum at lists.scsys.co.uk>

=item * View mailing list

L<http://lists.scsys.co.uk/pipermail/bignum/>

=item * Subscribe/Unsubscribe

L<http://lists.scsys.co.uk/cgi-bin/mailman/listinfo/bignum>

=back

=back

=head1 LICENSE

This program is free software; you may redistribute it and/or modify it under
the same terms as Perl itself.

=head1 SEE ALSO

L<Math::BigFloat> and L<Math::BigInt> as well as the backends
L<Math::BigInt::FastCalc>, L<Math::BigInt::GMP>, and L<Math::BigInt::Pari>.

The pragmas L<bignum>, L<bigint> and L<bigrat> also might be of interest
because they solve the autoupgrading/downgrading issue, at least partly.

=head1 AUTHORS

=over 4

=item *

Mark Biggar, overloaded interface by Ilya Zakharevich, 1996-2001.

=item *

Completely rewritten by Tels L<http://bloodgate.com> in 2001-2008.

=item *

Florian Ragwitz L<flora@cpan.org>, 2010.

=item *

Peter John Acklam, L<pjacklam@online.no>, 2011-.

=back

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         package Math::BigInt;

#
# "Mike had an infinite amount to do and a negative amount of time in which
# to do it." - Before and After
#

# The following hash values are used:
#   value: unsigned int with actual value (as a Math::BigInt::Calc or similar)
#   sign : +,-,NaN,+inf,-inf
#   _a   : accuracy
#   _p   : precision
#   _f   : flags, used by MBF to flag parts of a float as untouchable

# Remember not to take shortcuts ala $xs = $x->{value}; $CALC->foo($xs); since
# underlying lib might change the reference!

use 5.006001;
use strict;
use warnings;

our $VERSION = '1.999715';
$VERSION = eval $VERSION;

our @ISA = qw(Exporter);
our @EXPORT_OK = qw(objectify bgcd blcm);

# _trap_inf and _trap_nan are internal and should never be accessed from the
# outside
our ($round_mode, $accuracy, $precision, $div_scale, $rnd_mode,
     $upgrade, $downgrade, $_trap_nan, $_trap_inf);

my $class = "Math::BigInt";

# Inside overload, the first arg is always an object. If the original code had
# it reversed (like $x = 2 * $y), then the third parameter is true.
# In some cases (like add, $x = $x + 2 is the same as $x = 2 + $x) this makes
# no difference, but in some cases it does.

# For overloaded ops with only one argument we simple use $_[0]->copy() to
# preserve the argument.

# Thus inheritance of overload operators becomes possible and transparent for
# our subclasses without the need to repeat the entire overload section there.

# We register ops that are not registerable yet, so suppress warnings
{ no warnings;
use overload
'='     =>      sub { $_[0]->copy(); },

# some shortcuts for speed (assumes that reversed order of arguments is routed
# to normal '+' and we thus can always modify first arg. If this is changed,
# this breaks and must be adjusted.)
'+='    =>      sub { $_[0]->badd($_[1]); },
'-='    =>      sub { $_[0]->bsub($_[1]); },
'*='    =>      sub { $_[0]->bmul($_[1]); },
'/='    =>      sub { scalar $_[0]->bdiv($_[1]); },
'%='    =>      sub { $_[0]->bmod($_[1]); },
'^='    =>      sub { $_[0]->bxor($_[1]); },
'&='    =>      sub { $_[0]->band($_[1]); },
'|='    =>      sub { $_[0]->bior($_[1]); },

'**='   =>      sub { $_[0]->bpow($_[1]); },
'<<='   =>      sub { $_[0]->blsft($_[1]); },
'>>='   =>      sub { $_[0]->brsft($_[1]); },

# not supported by Perl yet
'..'    =>      \&_pointpoint,

'<=>'   =>      sub { my $rc = $_[2] ?
                      ref($_[0])->bcmp($_[1],$_[0]) :
                      $_[0]->bcmp($_[1]);
                      $rc = 1 unless defined $rc;
                      $rc <=> 0;
                },
# we need '>=' to get things like "1 >= NaN" right:
'>='    =>      sub { my $rc = $_[2] ?
                      ref($_[0])->bcmp($_[1],$_[0]) :
                      $_[0]->bcmp($_[1]);
                      # if there was a NaN involved, return false
                      return '' unless defined $rc;
                      $rc >= 0;
                },
'cmp'   =>      sub {
         $_[2] ?
               "$_[1]" cmp $_[0]->bstr() :
               $_[0]->bstr() cmp "$_[1]" },

'cos'   =>      sub { $_[0]->copy->bcos(); },
'sin'   =>      sub { $_[0]->copy->bsin(); },
'atan2' =>      sub { $_[2] ?
                        ref($_[0])->new($_[1])->batan2($_[0]) :
                        $_[0]->copy()->batan2($_[1]) },

# are not yet overloadable
#'hex'  =>      sub { print "hex"; $_[0]; },
#'oct'  =>      sub { print "oct"; $_[0]; },

# log(N) is log(N, e), where e is Euler's number
'log'   =>      sub { $_[0]->copy()->blog(); },
'exp'   =>      sub { $_[0]->copy()->bexp($_[1]); },
'int'   =>      sub { $_[0]->copy(); },
'neg'   =>      sub { $_[0]->copy()->bneg(); },
'abs'   =>      sub { $_[0]->copy()->babs(); },
'sqrt'  =>      sub { $_[0]->copy()->bsqrt(); },
'~'     =>      sub { $_[0]->copy()->bnot(); },

# for subtract it's a bit tricky to not modify b: b-a => -a+b
'-'     =>      sub { my $c = $_[0]->copy; $_[2] ?
                        $c->bneg()->badd( $_[1]) :
                        $c->bsub( $_[1]) },
'+'     =>      sub { $_[0]->copy()->badd($_[1]); },
'*'     =>      sub { $_[0]->copy()->bmul($_[1]); },

'/'     =>      sub {
   $_[2] ? ref($_[0])->new($_[1])->bdiv($_[0]) : $_[0]->copy->bdiv($_[1]);
  },
'%'     =>      sub {
   $_[2] ? ref($_[0])->new($_[1])->bmod($_[0]) : $_[0]->copy->bmod($_[1]);
  },
'**'    =>      sub {
   $_[2] ? ref($_[0])->new($_[1])->bpow($_[0]) : $_[0]->copy->bpow($_[1]);
  },
'<<'    =>      sub {
   $_[2] ? ref($_[0])->new($_[1])->blsft($_[0]) : $_[0]->copy->blsft($_[1]);
  },
'>>'    =>      sub {
   $_[2] ? ref($_[0])->new($_[1])->brsft($_[0]) : $_[0]->copy->brsft($_[1]);
  },
'&'     =>      sub {
   $_[2] ? ref($_[0])->new($_[1])->band($_[0]) : $_[0]->copy->band($_[1]);
  },
'|'     =>      sub {
   $_[2] ? ref($_[0])->new($_[1])->bior($_[0]) : $_[0]->copy->bior($_[1]);
  },
'^'     =>      sub {
   $_[2] ? ref($_[0])->new($_[1])->bxor($_[0]) : $_[0]->copy->bxor($_[1]);
  },

# can modify arg of ++ and --, so avoid a copy() for speed, but don't
# use $_[0]->bone(), it would modify $_[0] to be 1!
'++'    =>      sub { $_[0]->binc() },
'--'    =>      sub { $_[0]->bdec() },

# if overloaded, O(1) instead of O(N) and twice as fast for small numbers
'bool'  =>      sub {
  # this kludge is needed for perl prior 5.6.0 since returning 0 here fails :-/
  # v5.6.1 dumps on this: return !$_[0]->is_zero() || undef;                :-(
  my $t = undef;
  $t = 1 if !$_[0]->is_zero();
  $t;
  },

# the original qw() does not work with the TIESCALAR below, why?
# Order of arguments insignificant
'""' => sub { $_[0]->bstr(); },
'0+' => sub { $_[0]->numify(); }
;
} # no warnings scope

##############################################################################
# global constants, flags and accessory

# These vars are public, but their direct usage is not recommended, use the
# accessor methods instead

$round_mode = 'even'; # one of 'even', 'odd', '+inf', '-inf', 'zero', 'trunc' or 'common'
$accuracy   = undef;
$precision  = undef;
$div_scale  = 40;

$upgrade = undef;                       # default is no upgrade
$downgrade = undef;                     # default is no downgrade

# These are internally, and not to be used from the outside at all

$_trap_nan = 0;                         # are NaNs ok? set w/ config()
$_trap_inf = 0;                         # are infs ok? set w/ config()
my $nan = 'NaN';                        # constants for easier life

my $CALC = 'Math::BigInt::Calc';        # module to do the low level math
                                        # default is Calc.pm
my $IMPORT = 0;                         # was import() called yet?
                                        # used to make require work
my %WARN;                               # warn only once for low-level libs
my %CAN;                                # cache for $CALC->can(...)
my %CALLBACKS;                          # callbacks to notify on lib loads
my $EMU_LIB = 'Math/BigInt/CalcEmu.pm'; # emulate low-level math

##############################################################################
# the old code had $rnd_mode, so we need to support it, too

$rnd_mode   = 'even';
sub TIESCALAR  { my ($class) = @_; bless \$round_mode, $class; }
sub FETCH      { return $round_mode; }
sub STORE      { $rnd_mode = $_[0]->round_mode($_[1]); }

BEGIN
  {
  # tie to enable $rnd_mode to work transparently
  tie $rnd_mode, 'Math::BigInt';

  # set up some handy alias names
  *as_int = \&as_number;
  *is_pos = \&is_positive;
  *is_neg = \&is_negative;
  }

##############################################################################

sub round_mode
  {
  no strict 'refs';
  # make Class->round_mode() work
  my $self = shift;
  my $class = ref($self) || $self || __PACKAGE__;
  if (defined $_[0])
    {
    my $m = shift;
    if ($m !~ /^(even|odd|\+inf|\-inf|zero|trunc|common)$/)
      {
      require Carp; Carp::croak ("Unknown round mode '$m'");
      }
    return ${"${class}::round_mode"} = $m;
    }
  ${"${class}::round_mode"};
  }

sub upgrade
  {
  no strict 'refs';
  # make Class->upgrade() work
  my $self = shift;
  my $class = ref($self) || $self || __PACKAGE__;
  # need to set new value?
  if (@_ > 0)
    {
    return ${"${class}::upgrade"} = $_[0];
    }
  ${"${class}::upgrade"};
  }

sub downgrade
  {
  no strict 'refs';
  # make Class->downgrade() work
  my $self = shift;
  my $class = ref($self) || $self || __PACKAGE__;
  # need to set new value?
  if (@_ > 0)
    {
    return ${"${class}::downgrade"} = $_[0];
    }
  ${"${class}::downgrade"};
  }

sub div_scale
  {
  no strict 'refs';
  # make Class->div_scale() work
  my $self = shift;
  my $class = ref($self) || $self || __PACKAGE__;
  if (defined $_[0])
    {
    if ($_[0] < 0)
      {
      require Carp; Carp::croak ('div_scale must be greater than zero');
      }
    ${"${class}::div_scale"} = $_[0];
    }
  ${"${class}::div_scale"};
  }

sub accuracy
  {
  # $x->accuracy($a);           ref($x) $a
  # $x->accuracy();             ref($x)
  # Class->accuracy();          class
  # Class->accuracy($a);        class $a

  my $x = shift;
  my $class = ref($x) || $x || __PACKAGE__;

  no strict 'refs';
  # need to set new value?
  if (@_ > 0)
    {
    my $a = shift;
    # convert objects to scalars to avoid deep recursion. If object doesn't
    # have numify(), then hopefully it will have overloading for int() and
    # boolean test without wandering into a deep recursion path...
    $a = $a->numify() if ref($a) && $a->can('numify');

    if (defined $a)
      {
      # also croak on non-numerical
      if (!$a || $a <= 0)
        {
        require Carp;
        Carp::croak ('Argument to accuracy must be greater than zero');
        }
      if (int($a) != $a)
        {
        require Carp;
        Carp::croak ('Argument to accuracy must be an integer');
        }
      }
    if (ref($x))
      {
      # $object->accuracy() or fallback to global
      $x->bround($a) if $a;             # not for undef, 0
      $x->{_a} = $a;                    # set/overwrite, even if not rounded
      delete $x->{_p};                  # clear P
      $a = ${"${class}::accuracy"} unless defined $a;   # proper return value
      }
    else
      {
      ${"${class}::accuracy"} = $a;     # set global A
      ${"${class}::precision"} = undef; # clear global P
      }
    return $a;                          # shortcut
    }

  my $a;
  # $object->accuracy() or fallback to global
  $a = $x->{_a} if ref($x);
  # but don't return global undef, when $x's accuracy is 0!
  $a = ${"${class}::accuracy"} if !defined $a;
  $a;
  }

sub precision
  {
  # $x->precision($p);          ref($x) $p
  # $x->precision();            ref($x)
  # Class->precision();         class
  # Class->precision($p);       class $p

  my $x = shift;
  my $class = ref($x) || $x || __PACKAGE__;

  no strict 'refs';
  if (@_ > 0)
    {
    my $p = shift;
    # convert objects to scalars to avoid deep recursion. If object doesn't
    # have numify(), then hopefully it will have overloading for int() and
    # boolean test without wandering into a deep recursion path...
    $p = $p->numify() if ref($p) && $p->can('numify');
    if ((defined $p) && (int($p) != $p))
      {
      require Carp; Carp::croak ('Argument to precision must be an integer');
      }
    if (ref($x))
      {
      # $object->precision() or fallback to global
      $x->bfround($p) if $p;            # not for undef, 0
      $x->{_p} = $p;                    # set/overwrite, even if not rounded
      delete $x->{_a};                  # clear A
      $p = ${"${class}::precision"} unless defined $p;  # proper return value
      }
    else
      {
      ${"${class}::precision"} = $p;    # set global P
      ${"${class}::accuracy"} = undef;  # clear global A
      }
    return $p;                          # shortcut
    }

  my $p;
  # $object->precision() or fallback to global
  $p = $x->{_p} if ref($x);
  # but don't return global undef, when $x's precision is 0!
  $p = ${"${class}::precision"} if !defined $p;
  $p;
  }

sub config
  {
  # return (or set) configuration data as hash ref
  my $class = shift || 'Math::BigInt';

  no strict 'refs';
  if (@_ > 1 || (@_ == 1 && (ref($_[0]) eq 'HASH')))
    {
    # try to set given options as arguments from hash

    my $args = $_[0];
    if (ref($args) ne 'HASH')
      {
      $args = { @_ };
      }
    # these values can be "set"
    my $set_args = {};
    foreach my $key (
     qw/trap_inf trap_nan
        upgrade downgrade precision accuracy round_mode div_scale/
     )
      {
      $set_args->{$key} = $args->{$key} if exists $args->{$key};
      delete $args->{$key};
      }
    if (keys %$args > 0)
      {
      require Carp;
      Carp::croak ("Illegal key(s) '",
       join("','",keys %$args),"' passed to $class\->config()");
      }
    foreach my $key (keys %$set_args)
      {
      if ($key =~ /^trap_(inf|nan)\z/)
        {
        ${"${class}::_trap_$1"} = ($set_args->{"trap_$1"} ? 1 : 0);
        next;
        }
      # use a call instead of just setting the $variable to check argument
      $class->$key($set_args->{$key});
      }
    }

  # now return actual configuration

  my $cfg = {
    lib => $CALC,
    lib_version => ${"${CALC}::VERSION"},
    class => $class,
    trap_nan => ${"${class}::_trap_nan"},
    trap_inf => ${"${class}::_trap_inf"},
    version => ${"${class}::VERSION"},
    };
  foreach my $key (qw/
     upgrade downgrade precision accuracy round_mode div_scale
     /)
    {
    $cfg->{$key} = ${"${class}::$key"};
    };
  if (@_ == 1 && (ref($_[0]) ne 'HASH'))
    {
    # calls of the style config('lib') return just this value
    return $cfg->{$_[0]};
    }
  $cfg;
  }

sub _scale_a
  {
  # select accuracy parameter based on precedence,
  # used by bround() and bfround(), may return undef for scale (means no op)
  my ($x,$scale,$mode) = @_;

  $scale = $x->{_a} unless defined $scale;

  no strict 'refs';
  my $class = ref($x);

  $scale = ${ $class . '::accuracy' } unless defined $scale;
  $mode = ${ $class . '::round_mode' } unless defined $mode;

  if (defined $scale)
    {
    $scale = $scale->can('numify') ? $scale->numify()
                                   : "$scale" if ref($scale);
    $scale = int($scale);
    }

  ($scale,$mode);
  }

sub _scale_p
  {
  # select precision parameter based on precedence,
  # used by bround() and bfround(), may return undef for scale (means no op)
  my ($x,$scale,$mode) = @_;

  $scale = $x->{_p} unless defined $scale;

  no strict 'refs';
  my $class = ref($x);

  $scale = ${ $class . '::precision' } unless defined $scale;
  $mode = ${ $class . '::round_mode' } unless defined $mode;

  if (defined $scale)
    {
    $scale = $scale->can('numify') ? $scale->numify()
                                   : "$scale" if ref($scale);
    $scale = int($scale);
    }

  ($scale,$mode);
  }

##############################################################################
# constructors

sub copy {
    my $self    = shift;
    my $selfref = ref $self;
    my $class   = $selfref || $self;

    # If called as a class method, the object to copy is the next argument.

    $self = shift() unless $selfref;

    my $copy = bless {}, $class;

    $copy->{sign}  = $self->{sign};
    $copy->{value} = $CALC->_copy($self->{value});
    $copy->{_a}    = $self->{_a} if exists $self->{_a};
    $copy->{_p}    = $self->{_p} if exists $self->{_p};

    return $copy;
}

sub new {
    # Create a new Math::BigInt object from a string or another Math::BigInt
    # object. See hash keys documented at top.

    # The argument could be an object, so avoid ||, && etc. on it. This would
    # cause costly overloaded code to be called. The only allowed ops are ref()
    # and defined.

    my $self    = shift;
    my $selfref = ref $self;
    my $class   = $selfref || $self;

    my ($wanted, $a, $p, $r) = @_;

    # If called as a class method, initialize a new object.

    $self = bless {}, $class unless $selfref;

    unless (defined $wanted) {
        require Carp;
        Carp::carp("Use of uninitialized value in new");
        return $self->bzero($a, $p, $r);
    }

    if (ref($wanted) && $wanted->isa($class)) {         # MBI or subclass
        # Using "$copy = $wanted -> copy()" here fails some tests. Fixme!
        my $copy = $class -> copy($wanted);
        if ($selfref) {
            %$self = %$copy;
        } else {
            $self = $copy;
        }
        return $self;
    }

    $class->import() if $IMPORT == 0;           # make require work

    # Shortcut for non-zero scalar integers with no non-zero exponent.

    if (!ref($wanted) &&
        $wanted =~ / ^
                     ([+-]?)            # optional sign
                     ([1-9][0-9]*)      # non-zero significand
                     (\.0*)?            # ... with optional zero fraction
                     ([Ee][+-]?0+)?     # optional zero exponent
                     \z
                   /x)
    {
        my $sgn = $1;
        my $abs = $2;
        $self->{sign} = $sgn || '+';
        $self->{value} = $CALC->_new($abs);

        no strict 'refs';
        if (defined($a) || defined($p)
            || defined(${"${class}::precision"})
            || defined(${"${class}::accuracy"}))
        {
            $self->round($a, $p, $r)
              unless @_ == 4 && !defined $a && !defined $p;
        }

        return $self;
    }

    # Handle Infs.

    if ($wanted =~ /^\s*([+-]?)inf(inity)?\s*\z/i) {
        my $sgn = $1 || '+';
        $self->{sign} = $sgn . 'inf';   # set a default sign for bstr()
        return $self->binf($sgn);
    }

    # Handle explicit NaNs (not the ones returned due to invalid input).

    if ($wanted =~ /^\s*([+-]?)nan\s*\z/i) {
        return $self->bnan();
    }

    if ($wanted =~ /^\s*[+-]?0[Xx]/) {
        return $class -> from_hex($wanted);
    }

    if ($wanted =~ /^\s*[+-]?0[Bb]/) {
        return $class -> from_bin($wanted);
    }

    # Split string into mantissa, exponent, integer, fraction, value, and sign.
    my ($mis, $miv, $mfv, $es, $ev) = _split($wanted);
    if (!ref $mis) {
        if ($_trap_nan) {
            require Carp; Carp::croak("$wanted is not a number in $class");
        }
        $self->{value} = $CALC->_zero();
        $self->{sign} = $nan;
        return $self;
    }

    if (!ref $miv) {
        # _from_hex or _from_bin
        $self->{value} = $mis->{value};
        $self->{sign} = $mis->{sign};
        return $self;   # throw away $mis
    }

    # Make integer from mantissa by adjusting exponent, then convert to a
    # Math::BigInt.
    $self->{sign} = $$mis;           # store sign
    $self->{value} = $CALC->_zero(); # for all the NaN cases
    my $e = int("$$es$$ev");         # exponent (avoid recursion)
    if ($e > 0) {
        my $diff = $e - CORE::length($$mfv);
        if ($diff < 0) {         # Not integer
            if ($_trap_nan) {
                require Carp; Carp::croak("$wanted not an integer in $class");
            }
            #print "NOI 1\n";
            return $upgrade->new($wanted, $a, $p, $r) if defined $upgrade;
            $self->{sign} = $nan;
        } else {                 # diff >= 0
            # adjust fraction and add it to value
            #print "diff > 0 $$miv\n";
            $$miv = $$miv . ($$mfv . '0' x $diff);
        }
    }

    else {
        if ($$mfv ne '') {       # e <= 0
            # fraction and negative/zero E => NOI
            if ($_trap_nan) {
                require Carp; Carp::croak("$wanted not an integer in $class");
            }
            #print "NOI 2 \$\$mfv '$$mfv'\n";
            return $upgrade->new($wanted, $a, $p, $r) if defined $upgrade;
            $self->{sign} = $nan;
        } elsif ($e < 0) {
            # xE-y, and empty mfv
            # Split the mantissa at the decimal point. E.g., if
            # $$miv = 12345 and $e = -2, then $frac = 45 and $$miv = 123.

            my $frac = substr($$miv, $e); # $frac is fraction part
            substr($$miv, $e) = "";       # $$miv is now integer part

            if ($frac =~ /[^0]/) {
                if ($_trap_nan) {
                    require Carp; Carp::croak("$wanted not an integer in $class");
                }
                #print "NOI 3\n";
                return $upgrade->new($wanted, $a, $p, $r) if defined $upgrade;
                $self->{sign} = $nan;
            }
        }
    }

    unless ($self->{sign} eq $nan) {
        $self->{sign} = '+' if $$miv eq '0';            # normalize -0 => +0
        $self->{value} = $CALC->_new($$miv) if $self->{sign} =~ /^[+-]$/;
    }

    # If any of the globals are set, use them to round, and store them inside
    # $self. Do not round for new($x, undef, undef) since that is used by MBF
    # to signal no rounding.

    $self->round($a, $p, $r) unless @_ == 4 && !defined $a && !defined $p;
    $self;
}

sub bnan
  {
  # create a bigint 'NaN', if given a BigInt, set it to 'NaN'
  my $self = shift;
  $self = $class if !defined $self;
  if (!ref($self))
    {
    my $c = $self; $self = {}; bless $self, $c;
    }
  no strict 'refs';
  if (${"${class}::_trap_nan"})
    {
    require Carp;
    Carp::croak ("Tried to set $self to NaN in $class\::bnan()");
    }
  $self->import() if $IMPORT == 0;              # make require work
  return if $self->modify('bnan');
  if ($self->can('_bnan'))
    {
    # use subclass to initialize
    $self->_bnan();
    }
  else
    {
    # otherwise do our own thing
    $self->{value} = $CALC->_zero();
    }
  $self->{sign} = $nan;
  delete $self->{_a}; delete $self->{_p};       # rounding NaN is silly
  $self;
  }

sub binf
  {
  # create a bigint '+-inf', if given a BigInt, set it to '+-inf'
  # the sign is either '+', or if given, used from there
  my $self = shift;
  my $sign = shift; $sign = '+' if !defined $sign || $sign !~ /^-(inf)?$/;
  $self = $class if !defined $self;
  if (!ref($self))
    {
    my $c = $self; $self = {}; bless $self, $c;
    }
  no strict 'refs';
  if (${"${class}::_trap_inf"})
    {
    require Carp;
    Carp::croak ("Tried to set $self to +-inf in $class\::binf()");
    }
  $self->import() if $IMPORT == 0;              # make require work
  return if $self->modify('binf');
  if ($self->can('_binf'))
    {
    # use subclass to initialize
    $self->_binf();
    }
  else
    {
    # otherwise do our own thing
    $self->{value} = $CALC->_zero();
    }
  $sign = $sign . 'inf' if $sign !~ /inf$/;     # - => -inf
  $self->{sign} = $sign;
  ($self->{_a},$self->{_p}) = @_;               # take over requested rounding
  $self;
  }

sub bzero
  {
  # create a bigint '+0', if given a BigInt, set it to 0
  my $self = shift;
  $self = __PACKAGE__ if !defined $self;

  if (!ref($self))
    {
    my $c = $self; $self = {}; bless $self, $c;
    }
  $self->import() if $IMPORT == 0;              # make require work
  return if $self->modify('bzero');

  if ($self->can('_bzero'))
    {
    # use subclass to initialize
    $self->_bzero();
    }
  else
    {
    # otherwise do our own thing
    $self->{value} = $CALC->_zero();
    }
  $self->{sign} = '+';
  if (@_ > 0)
    {
    if (@_ > 3)
      {
      # call like: $x->bzero($a,$p,$r,$y);
      ($self,$self->{_a},$self->{_p}) = $self->_find_round_parameters(@_);
      }
    else
      {
      $self->{_a} = $_[0]
       if ( (!defined $self->{_a}) || (defined $_[0] && $_[0] > $self->{_a}));
      $self->{_p} = $_[1]
       if ( (!defined $self->{_p}) || (defined $_[1] && $_[1] > $self->{_p}));
      }
    }
  $self;
  }

sub bone
  {
  # create a bigint '+1' (or -1 if given sign '-'),
  # if given a BigInt, set it to +1 or -1, respectively
  my $self = shift;
  my $sign = shift; $sign = '+' if !defined $sign || $sign ne '-';
  $self = $class if !defined $self;

  if (!ref($self))
    {
    my $c = $self; $self = {}; bless $self, $c;
    }
  $self->import() if $IMPORT == 0;              # make require work
  return if $self->modify('bone');

  if ($self->can('_bone'))
    {
    # use subclass to initialize
    $self->_bone();
    }
  else
    {
    # otherwise do our own thing
    $self->{value} = $CALC->_one();
    }
  $self->{sign} = $sign;
  if (@_ > 0)
    {
    if (@_ > 3)
      {
      # call like: $x->bone($sign,$a,$p,$r,$y);
      ($self,$self->{_a},$self->{_p}) = $self->_find_round_parameters(@_);
      }
    else
      {
      # call like: $x->bone($sign,$a,$p,$r);
      $self->{_a} = $_[0]
       if ( (!defined $self->{_a}) || (defined $_[0] && $_[0] > $self->{_a}));
      $self->{_p} = $_[1]
       if ( (!defined $self->{_p}) || (defined $_[1] && $_[1] > $self->{_p}));
      }
    }
  $self;
  }

##############################################################################
# string conversion

sub bsstr
  {
  # (ref to BFLOAT or num_str ) return num_str
  # Convert number from internal format to scientific string format.
  # internal format is always normalized (no leading zeros, "-0E0" => "+0E0")
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);

  if ($x->{sign} !~ /^[+-]$/)
    {
    return $x->{sign} unless $x->{sign} eq '+inf';      # -inf, NaN
    return 'inf';                                       # +inf
    }
  my ($m,$e) = $x->parts();
  #$m->bstr() . 'e+' . $e->bstr();      # e can only be positive in BigInt
  # 'e+' because E can only be positive in BigInt
  $m->bstr() . 'e+' . $CALC->_str($e->{value});
  }

sub bstr
  {
  # make a string from bigint object
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);

  if ($x->{sign} !~ /^[+-]$/)
    {
    return $x->{sign} unless $x->{sign} eq '+inf';      # -inf, NaN
    return 'inf';                                       # +inf
    }
  my $es = ''; $es = $x->{sign} if $x->{sign} eq '-';
  $es.$CALC->_str($x->{value});
  }

sub numify
  {
  # Make a Perl scalar number from a Math::BigInt object.
  my $x = shift; $x = $class->new($x) unless ref $x;

  if ($x -> is_nan()) {
      require Math::Complex;
      my $inf = Math::Complex::Inf();
      return $inf - $inf;
  }

  if ($x -> is_inf()) {
      require Math::Complex;
      my $inf = Math::Complex::Inf();
      return $x -> is_negative() ? -$inf : $inf;
  }

  my $num = 0 + $CALC->_num($x->{value});
  return $x->{sign} eq '-' ? -$num : $num;
  }

##############################################################################
# public stuff (usually prefixed with "b")

sub sign
  {
  # return the sign of the number: +/-/-inf/+inf/NaN
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);

  $x->{sign};
  }

sub _find_round_parameters {
    # After any operation or when calling round(), the result is rounded by
    # regarding the A & P from arguments, local parameters, or globals.

    # !!!!!!! If you change this, remember to change round(), too! !!!!!!!!!!

    # This procedure finds the round parameters, but it is for speed reasons
    # duplicated in round. Otherwise, it is tested by the testsuite and used
    # by bdiv().

    # returns ($self) or ($self,$a,$p,$r) - sets $self to NaN of both A and P
    # were requested/defined (locally or globally or both)

    my ($self, $a, $p, $r, @args) = @_;
    # $a accuracy, if given by caller
    # $p precision, if given by caller
    # $r round_mode, if given by caller
    # @args all 'other' arguments (0 for unary, 1 for binary ops)

    my $class = ref($self);       # find out class of argument(s)
    no strict 'refs';

    # convert to normal scalar for speed and correctness in inner parts
    $a = $a->can('numify') ? $a->numify() : "$a" if defined $a && ref($a);
    $p = $p->can('numify') ? $p->numify() : "$p" if defined $p && ref($p);

    # now pick $a or $p, but only if we have got "arguments"
    if (!defined $a) {
        foreach ($self, @args) {
            # take the defined one, or if both defined, the one that is smaller
            $a = $_->{_a} if (defined $_->{_a}) && (!defined $a || $_->{_a} < $a);
        }
    }
    if (!defined $p) {
        # even if $a is defined, take $p, to signal error for both defined
        foreach ($self, @args) {
            # take the defined one, or if both defined, the one that is bigger
            # -2 > -3, and 3 > 2
            $p = $_->{_p} if (defined $_->{_p}) && (!defined $p || $_->{_p} > $p);
        }
    }

    # if still none defined, use globals (#2)
    $a = ${"$class\::accuracy"}  unless defined $a;
    $p = ${"$class\::precision"} unless defined $p;

    # A == 0 is useless, so undef it to signal no rounding
    $a = undef if defined $a && $a == 0;

    # no rounding today?
    return ($self) unless defined $a || defined $p; # early out

    # set A and set P is an fatal error
    return ($self->bnan()) if defined $a && defined $p; # error

    $r = ${"$class\::round_mode"} unless defined $r;
    if ($r !~ /^(even|odd|[+-]inf|zero|trunc|common)$/) {
        require Carp; Carp::croak ("Unknown round mode '$r'");
    }

    $a = int($a) if defined $a;
    $p = int($p) if defined $p;

    ($self, $a, $p, $r);
}

sub round {
    # Round $self according to given parameters, or given second argument's
    # parameters or global defaults

    # for speed reasons, _find_round_parameters is embedded here:

    my ($self, $a, $p, $r, @args) = @_;
    # $a accuracy, if given by caller
    # $p precision, if given by caller
    # $r round_mode, if given by caller
    # @args all 'other' arguments (0 for unary, 1 for binary ops)

    my $class = ref($self);       # find out class of argument(s)
    no strict 'refs';

    # now pick $a or $p, but only if we have got "arguments"
    if (!defined $a) {
        foreach ($self, @args) {
            # take the defined one, or if both defined, the one that is smaller
            $a = $_->{_a} if (defined $_->{_a}) && (!defined $a || $_->{_a} < $a);
        }
    }
    if (!defined $p) {
        # even if $a is defined, take $p, to signal error for both defined
        foreach ($self, @args) {
            # take the defined one, or if both defined, the one that is bigger
            # -2 > -3, and 3 > 2
            $p = $_->{_p} if (defined $_->{_p}) && (!defined $p || $_->{_p} > $p);
        }
    }

    # if still none defined, use globals (#2)
    $a = ${"$class\::accuracy"}  unless defined $a;
    $p = ${"$class\::precision"} unless defined $p;

    # A == 0 is useless, so undef it to signal no rounding
    $a = undef if defined $a && $a == 0;

    # no rounding today?
    return $self unless defined $a || defined $p; # early out

    # set A and set P is an fatal error
    return $self->bnan() if defined $a && defined $p;

    $r = ${"$class\::round_mode"} unless defined $r;
    if ($r !~ /^(even|odd|[+-]inf|zero|trunc|common)$/) {
        require Carp; Carp::croak ("Unknown round mode '$r'");
    }

    # now round, by calling either bround or bfround:
    if (defined $a) {
        $self->bround(int($a), $r) if !defined $self->{_a} || $self->{_a} >= $a;
    } else {                  # both can't be undefined due to early out
        $self->bfround(int($p), $r) if !defined $self->{_p} || $self->{_p} <= $p;
    }

    # bround() or bfround() already called bnorm() if nec.
    $self;
}

sub bnorm
  {
  # (numstr or BINT) return BINT
  # Normalize number -- no-op here
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);
  $x;
  }

sub babs
  {
  # (BINT or num_str) return BINT
  # make number absolute, or return absolute BINT from string
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);

  return $x if $x->modify('babs');
  # post-normalized abs for internal use (does nothing for NaN)
  $x->{sign} =~ s/^-/+/;
  $x;
  }

sub bsgn {
    # Signum function.

    my $self = shift;

    return $self if $self->modify('bsgn');

    return $self -> bone("+") if $self -> is_pos();
    return $self -> bone("-") if $self -> is_neg();
    return $self;               # zero or NaN
}

sub bneg
  {
  # (BINT or num_str) return BINT
  # negate number or make a negated number from string
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);

  return $x if $x->modify('bneg');

  # for +0 do not negate (to have always normalized +0). Does nothing for 'NaN'
  $x->{sign} =~ tr/+-/-+/ unless ($x->{sign} eq '+' && $CALC->_is_zero($x->{value}));
  $x;
  }

sub bcmp
  {
  # Compares 2 values.  Returns one of undef, <0, =0, >0. (suitable for sort)
  # (BINT or num_str, BINT or num_str) return cond_code

  # set up parameters
  my ($self,$x,$y) = (ref($_[0]),@_);

  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y) = objectify(2,@_);
    }

  return $upgrade->bcmp($x,$y) if defined $upgrade &&
    ((!$x->isa($self)) || (!$y->isa($self)));

  if (($x->{sign} !~ /^[+-]$/) || ($y->{sign} !~ /^[+-]$/))
    {
    # handle +-inf and NaN
    return undef if (($x->{sign} eq $nan) || ($y->{sign} eq $nan));
    return 0 if $x->{sign} eq $y->{sign} && $x->{sign} =~ /^[+-]inf$/;
    return +1 if $x->{sign} eq '+inf';
    return -1 if $x->{sign} eq '-inf';
    return -1 if $y->{sign} eq '+inf';
    return +1;
    }
  # check sign for speed first
  return 1 if $x->{sign} eq '+' && $y->{sign} eq '-';   # does also 0 <=> -y
  return -1 if $x->{sign} eq '-' && $y->{sign} eq '+';  # does also -x <=> 0

  # have same sign, so compare absolute values.  Don't make tests for zero
  # here because it's actually slower than testing in Calc (especially w/ Pari
  # et al)

  # post-normalized compare for internal use (honors signs)
  if ($x->{sign} eq '+')
    {
    # $x and $y both > 0
    return $CALC->_acmp($x->{value},$y->{value});
    }

  # $x && $y both < 0
  $CALC->_acmp($y->{value},$x->{value});        # swapped acmp (lib returns 0,1,-1)
  }

sub bacmp
  {
  # Compares 2 values, ignoring their signs.
  # Returns one of undef, <0, =0, >0. (suitable for sort)
  # (BINT, BINT) return cond_code

  # set up parameters
  my ($self,$x,$y) = (ref($_[0]),@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y) = objectify(2,@_);
    }

  return $upgrade->bacmp($x,$y) if defined $upgrade &&
    ((!$x->isa($self)) || (!$y->isa($self)));

  if (($x->{sign} !~ /^[+-]$/) || ($y->{sign} !~ /^[+-]$/))
    {
    # handle +-inf and NaN
    return undef if (($x->{sign} eq $nan) || ($y->{sign} eq $nan));
    return 0 if $x->{sign} =~ /^[+-]inf$/ && $y->{sign} =~ /^[+-]inf$/;
    return 1 if $x->{sign} =~ /^[+-]inf$/ && $y->{sign} !~ /^[+-]inf$/;
    return -1;
    }
  $CALC->_acmp($x->{value},$y->{value});        # lib does only 0,1,-1
  }

sub badd
  {
  # add second arg (BINT or string) to first (BINT) (modifies first)
  # return result as BINT

  # set up parameters
  my ($self,$x,$y,@r) = (ref($_[0]),@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@r) = objectify(2,@_);
    }

  return $x if $x->modify('badd');
  return $upgrade->badd($upgrade->new($x),$upgrade->new($y),@r) if defined $upgrade &&
    ((!$x->isa($self)) || (!$y->isa($self)));

  $r[3] = $y;                           # no push!
  # inf and NaN handling
  if (($x->{sign} !~ /^[+-]$/) || ($y->{sign} !~ /^[+-]$/))
    {
    # NaN first
    return $x->bnan() if (($x->{sign} eq $nan) || ($y->{sign} eq $nan));
    # inf handling
    if (($x->{sign} =~ /^[+-]inf$/) && ($y->{sign} =~ /^[+-]inf$/))
      {
      # +inf++inf or -inf+-inf => same, rest is NaN
      return $x if $x->{sign} eq $y->{sign};
      return $x->bnan();
      }
    # +-inf + something => +inf
    # something +-inf => +-inf
    $x->{sign} = $y->{sign}, return $x if $y->{sign} =~ /^[+-]inf$/;
    return $x;
    }

  my ($sx, $sy) = ( $x->{sign}, $y->{sign} );           # get signs

  if ($sx eq $sy)
    {
    $x->{value} = $CALC->_add($x->{value},$y->{value}); # same sign, abs add
    }
  else
    {
    my $a = $CALC->_acmp ($y->{value},$x->{value});     # absolute compare
    if ($a > 0)
      {
      $x->{value} = $CALC->_sub($y->{value},$x->{value},1); # abs sub w/ swap
      $x->{sign} = $sy;
      }
    elsif ($a == 0)
      {
      # speedup, if equal, set result to 0
      $x->{value} = $CALC->_zero();
      $x->{sign} = '+';
      }
    else # a < 0
      {
      $x->{value} = $CALC->_sub($x->{value}, $y->{value}); # abs sub
      }
    }
  $x->round(@r);
  }

sub bsub
  {
  # (BINT or num_str, BINT or num_str) return BINT
  # subtract second arg from first, modify first

  # set up parameters
  my ($self,$x,$y,@r) = (ref($_[0]),@_);

  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@r) = objectify(2,@_);
    }

  return $x if $x->modify('bsub');

  return $upgrade->new($x)->bsub($upgrade->new($y),@r) if defined $upgrade &&
   ((!$x->isa($self)) || (!$y->isa($self)));

  return $x->round(@r) if $y->is_zero();

  # To correctly handle the lone special case $x->bsub($x), we note the sign
  # of $x, then flip the sign from $y, and if the sign of $x did change, too,
  # then we caught the special case:
  my $xsign = $x->{sign};
  $y->{sign} =~ tr/+\-/-+/;     # does nothing for NaN
  if ($xsign ne $x->{sign})
    {
    # special case of $x->bsub($x) results in 0
    return $x->bzero(@r) if $xsign =~ /^[+-]$/;
    return $x->bnan();          # NaN, -inf, +inf
    }
  $x->badd($y,@r);              # badd does not leave internal zeros
  $y->{sign} =~ tr/+\-/-+/;     # refix $y (does nothing for NaN)
  $x;                           # already rounded by badd() or no round nec.
  }

sub binc
  {
  # increment arg by one
  my ($self,$x,$a,$p,$r) = ref($_[0]) ? (ref($_[0]),@_) : objectify(1,@_);
  return $x if $x->modify('binc');

  if ($x->{sign} eq '+')
    {
    $x->{value} = $CALC->_inc($x->{value});
    return $x->round($a,$p,$r);
    }
  elsif ($x->{sign} eq '-')
    {
    $x->{value} = $CALC->_dec($x->{value});
    $x->{sign} = '+' if $CALC->_is_zero($x->{value}); # -1 +1 => -0 => +0
    return $x->round($a,$p,$r);
    }
  # inf, nan handling etc
  $x->badd($self->bone(),$a,$p,$r);             # badd does round
  }

sub bdec
  {
  # decrement arg by one
  my ($self,$x,@r) = ref($_[0]) ? (ref($_[0]),@_) : objectify(1,@_);
  return $x if $x->modify('bdec');

  if ($x->{sign} eq '-')
    {
    # x already < 0
    $x->{value} = $CALC->_inc($x->{value});
    }
  else
    {
    return $x->badd($self->bone('-'),@r)
        unless $x->{sign} eq '+'; # inf or NaN
    # >= 0
    if ($CALC->_is_zero($x->{value}))
      {
      # == 0
      $x->{value} = $CALC->_one(); $x->{sign} = '-';            # 0 => -1
      }
    else
      {
      # > 0
      $x->{value} = $CALC->_dec($x->{value});
      }
    }
  $x->round(@r);
  }

sub blog
  {
  # Return the logarithm of the operand. If a second operand is defined, that
  # value is used as the base, otherwise the base is assumed to be Euler's
  # constant.

  # Don't objectify the base, since an undefined base, as in $x->blog() or
  # $x->blog(undef) signals that the base is Euler's number.

  # set up parameters
  my ($self,$x,$base,@r) = (undef,@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1]))) {
      ($self,$x,$base,@r) = objectify(1,@_);
  }

  return $x if $x->modify('blog');

  # Handle all exception cases and all trivial cases. I have used Wolfram Alpha
  # (http://www.wolframalpha.com) as the reference for these cases.

  return $x -> bnan() if $x -> is_nan();

  if (defined $base) {
      $base = $self -> new($base) unless ref $base;
      if ($base -> is_nan() || $base -> is_one()) {
          return $x -> bnan();
      } elsif ($base -> is_inf() || $base -> is_zero()) {
          return $x -> bnan() if $x -> is_inf() || $x -> is_zero();
          return $x -> bzero();
      } elsif ($base -> is_negative()) {            # -inf < base < 0
          return $x -> bzero() if $x -> is_one();   #     x = 1
          return $x -> bone()  if $x == $base;      #     x = base
          return $x -> bnan();                      #     otherwise
      }
      return $x -> bone() if $x == $base;           # 0 < base && 0 < x < inf
  }

  # We now know that the base is either undefined or >= 2 and finite.

  return $x -> binf('+') if $x -> is_inf();         #   x = +/-inf
  return $x -> bnan()    if $x -> is_neg();         #   -inf < x < 0
  return $x -> bzero()   if $x -> is_one();         #   x = 1
  return $x -> binf('-') if $x -> is_zero();        #   x = 0

  # At this point we are done handling all exception cases and trivial cases.

  return $upgrade -> blog($upgrade -> new($x), $base, @r) if defined $upgrade;

  # fix for bug #24969:
  # the default base is e (Euler's number) which is not an integer
  if (!defined $base)
    {
    require Math::BigFloat;
    my $u = Math::BigFloat->blog(Math::BigFloat->new($x))->as_int();
    # modify $x in place
    $x->{value} = $u->{value};
    $x->{sign} = $u->{sign};
    return $x;
    }

  my ($rc,$exact) = $CALC->_log_int($x->{value},$base->{value});
  return $x->bnan() unless defined $rc;         # not possible to take log?
  $x->{value} = $rc;
  $x->round(@r);
  }

sub bnok
  {
  # Calculate n over k (binomial coefficient or "choose" function) as integer.
  # set up parameters
  my ($self,$x,$y,@r) = (ref($_[0]),@_);

  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@r) = objectify(2,@_);
    }

  return $x if $x->modify('bnok');
  return $x->bnan() if $x->{sign} eq 'NaN' || $y->{sign} eq 'NaN';
  return $x->binf() if $x->{sign} eq '+inf';

  # k > n or k < 0 => 0
  my $cmp = $x->bacmp($y);
  return $x->bzero() if $cmp < 0 || $y->{sign} =~ /^-/;
  # k == n => 1
  return $x->bone(@r) if $cmp == 0;

  if ($CALC->can('_nok'))
    {
    $x->{value} = $CALC->_nok($x->{value},$y->{value});
    }
  else
    {
    # ( 7 )       7!       1*2*3*4 * 5*6*7   5 * 6 * 7       6   7
    # ( - ) = --------- =  --------------- = --------- = 5 * - * -
    # ( 3 )   (7-3)! 3!    1*2*3*4 * 1*2*3   1 * 2 * 3       2   3

    if (!$y->is_zero())
      {
      my $z = $x - $y;
      $z->binc();
      my $r = $z->copy(); $z->binc();
      my $d = $self->new(2);
      while ($z->bacmp($x) <= 0)                # f <= x ?
        {
        $r->bmul($z); $r->bdiv($d);
        $z->binc(); $d->binc();
        }
      $x->{value} = $r->{value}; $x->{sign} = '+';
      }
    else { $x->bone(); }
    }
  $x->round(@r);
  }

sub bexp
  {
  # Calculate e ** $x (Euler's number to the power of X), truncated to
  # an integer value.
  my ($self,$x,@r) = ref($_[0]) ? (ref($_[0]),@_) : objectify(1,@_);
  return $x if $x->modify('bexp');

  # inf, -inf, NaN, <0 => NaN
  return $x->bnan() if $x->{sign} eq 'NaN';
  return $x->bone() if $x->is_zero();
  return $x if $x->{sign} eq '+inf';
  return $x->bzero() if $x->{sign} eq '-inf';

  my $u;
  {
    # run through Math::BigFloat unless told otherwise
    require Math::BigFloat unless defined $upgrade;
    local $upgrade = 'Math::BigFloat' unless defined $upgrade;
    # calculate result, truncate it to integer
    $u = $upgrade->bexp($upgrade->new($x),@r);
  }

  if (!defined $upgrade)
    {
    $u = $u->as_int();
    # modify $x in place
    $x->{value} = $u->{value};
    $x->round(@r);
    }
  else { $x = $u; }
  }

sub blcm
  {
  # (BINT or num_str, BINT or num_str) return BINT
  # does not modify arguments, but returns new object
  # Lowest Common Multiple

  my $y = shift; my ($x);
  if (ref($y))
    {
    $x = $y->copy();
    }
  else
    {
    $x = $class->new($y);
    }
  my $self = ref($x);
  while (@_)
    {
    my $y = shift; $y = $self->new($y) if !ref ($y);
    $x = __lcm($x,$y);
    }
  $x;
  }

sub bgcd
  {
  # (BINT or num_str, BINT or num_str) return BINT
  # does not modify arguments, but returns new object
  # GCD -- Euclid's algorithm, variant C (Knuth Vol 3, pg 341 ff)

  my $y = shift;
  $y = $class->new($y) if !ref($y);
  my $self = ref($y);
  my $x = $y->copy()->babs();                   # keep arguments
  return $x->bnan() if $x->{sign} !~ /^[+-]$/;  # x NaN?

  while (@_)
    {
    $y = shift; $y = $self->new($y) if !ref($y);
    return $x->bnan() if $y->{sign} !~ /^[+-]$/;        # y NaN?
    $x->{value} = $CALC->_gcd($x->{value},$y->{value});
    last if $CALC->_is_one($x->{value});
    }
  $x;
  }

sub bnot
  {
  # (num_str or BINT) return BINT
  # represent ~x as twos-complement number
  # we don't need $self, so undef instead of ref($_[0]) make it slightly faster
  my ($self,$x,$a,$p,$r) = ref($_[0]) ? (undef,@_) : objectify(1,@_);

  return $x if $x->modify('bnot');
  $x->binc()->bneg();                   # binc already does round
  }

##############################################################################
# is_foo test routines
# we don't need $self, so undef instead of ref($_[0]) make it slightly faster

sub is_zero
  {
  # return true if arg (BINT or num_str) is zero (array '+', '0')
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);

  return 0 if $x->{sign} !~ /^\+$/;                     # -, NaN & +-inf aren't
  $CALC->_is_zero($x->{value});
  }

sub is_nan
  {
  # return true if arg (BINT or num_str) is NaN
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);

  $x->{sign} eq $nan ? 1 : 0;
  }

sub is_inf
  {
  # return true if arg (BINT or num_str) is +-inf
  my ($self,$x,$sign) = ref($_[0]) ? (undef,@_) : objectify(1,@_);

  if (defined $sign)
    {
    $sign = '[+-]inf' if $sign eq '';   # +- doesn't matter, only that's inf
    $sign = "[$1]inf" if $sign =~ /^([+-])(inf)?$/;     # extract '+' or '-'
    return $x->{sign} =~ /^$sign$/ ? 1 : 0;
    }
  $x->{sign} =~ /^[+-]inf$/ ? 1 : 0;            # only +-inf is infinity
  }

sub is_one
  {
  # return true if arg (BINT or num_str) is +1, or -1 if sign is given
  my ($self,$x,$sign) = ref($_[0]) ? (undef,@_) : objectify(1,@_);

  $sign = '+' if !defined $sign || $sign ne '-';

  return 0 if $x->{sign} ne $sign;      # -1 != +1, NaN, +-inf aren't either
  $CALC->_is_one($x->{value});
  }

sub is_odd
  {
  # return true when arg (BINT or num_str) is odd, false for even
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);

  return 0 if $x->{sign} !~ /^[+-]$/;                   # NaN & +-inf aren't
  $CALC->_is_odd($x->{value});
  }

sub is_even
  {
  # return true when arg (BINT or num_str) is even, false for odd
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);

  return 0 if $x->{sign} !~ /^[+-]$/;                   # NaN & +-inf aren't
  $CALC->_is_even($x->{value});
  }

sub is_positive
  {
  # return true when arg (BINT or num_str) is positive (> 0)
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);

  return 1 if $x->{sign} eq '+inf';                     # +inf is positive

  # 0+ is neither positive nor negative
  ($x->{sign} eq '+' && !$x->is_zero()) ? 1 : 0;
  }

sub is_negative
  {
  # return true when arg (BINT or num_str) is negative (< 0)
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);

  $x->{sign} =~ /^-/ ? 1 : 0;           # -inf is negative, but NaN is not
  }

sub is_int
  {
  # return true when arg (BINT or num_str) is an integer
  # always true for BigInt, but different for BigFloats
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);

  $x->{sign} =~ /^[+-]$/ ? 1 : 0;               # inf/-inf/NaN aren't
  }

###############################################################################

sub bmul
  {
  # multiply the first number by the second number
  # (BINT or num_str, BINT or num_str) return BINT

  # set up parameters
  my ($self,$x,$y,@r) = (ref($_[0]),@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@r) = objectify(2,@_);
    }

  return $x if $x->modify('bmul');

  return $x->bnan() if (($x->{sign} eq $nan) || ($y->{sign} eq $nan));

  # inf handling
  if (($x->{sign} =~ /^[+-]inf$/) || ($y->{sign} =~ /^[+-]inf$/))
    {
    return $x->bnan() if $x->is_zero() || $y->is_zero();
    # result will always be +-inf:
    # +inf * +/+inf => +inf, -inf * -/-inf => +inf
    # +inf * -/-inf => -inf, -inf * +/+inf => -inf
    return $x->binf() if ($x->{sign} =~ /^\+/ && $y->{sign} =~ /^\+/);
    return $x->binf() if ($x->{sign} =~ /^-/ && $y->{sign} =~ /^-/);
    return $x->binf('-');
    }

  return $upgrade->bmul($x,$upgrade->new($y),@r)
   if defined $upgrade && !$y->isa($self);

  $r[3] = $y;                           # no push here

  $x->{sign} = $x->{sign} eq $y->{sign} ? '+' : '-'; # +1 * +1 or -1 * -1 => +

  $x->{value} = $CALC->_mul($x->{value},$y->{value});   # do actual math
  $x->{sign} = '+' if $CALC->_is_zero($x->{value});     # no -0

  $x->round(@r);
  }

sub bmuladd
  {
  # multiply two numbers and then add the third to the result
  # (BINT or num_str, BINT or num_str, BINT or num_str) return BINT

  # set up parameters
  my ($self,$x,$y,$z,@r) = objectify(3,@_);

  return $x if $x->modify('bmuladd');

  return $x->bnan() if  ($x->{sign} eq $nan) ||
                        ($y->{sign} eq $nan) ||
                        ($z->{sign} eq $nan);

  # inf handling of x and y
  if (($x->{sign} =~ /^[+-]inf$/) || ($y->{sign} =~ /^[+-]inf$/))
    {
    return $x->bnan() if $x->is_zero() || $y->is_zero();
    # result will always be +-inf:
    # +inf * +/+inf => +inf, -inf * -/-inf => +inf
    # +inf * -/-inf => -inf, -inf * +/+inf => -inf
    return $x->binf() if ($x->{sign} =~ /^\+/ && $y->{sign} =~ /^\+/);
    return $x->binf() if ($x->{sign} =~ /^-/ && $y->{sign} =~ /^-/);
    return $x->binf('-');
    }
  # inf handling x*y and z
  if (($z->{sign} =~ /^[+-]inf$/))
    {
    # something +-inf => +-inf
    $x->{sign} = $z->{sign}, return $x if $z->{sign} =~ /^[+-]inf$/;
    }

  return $upgrade->bmuladd($x,$upgrade->new($y),$upgrade->new($z),@r)
   if defined $upgrade && (!$y->isa($self) || !$z->isa($self) || !$x->isa($self));

  # TODO: what if $y and $z have A or P set?
  $r[3] = $z;                           # no push here

  $x->{sign} = $x->{sign} eq $y->{sign} ? '+' : '-'; # +1 * +1 or -1 * -1 => +

  $x->{value} = $CALC->_mul($x->{value},$y->{value});   # do actual math
  $x->{sign} = '+' if $CALC->_is_zero($x->{value});     # no -0

  my ($sx, $sz) = ( $x->{sign}, $z->{sign} );           # get signs

  if ($sx eq $sz)
    {
    $x->{value} = $CALC->_add($x->{value},$z->{value}); # same sign, abs add
    }
  else
    {
    my $a = $CALC->_acmp ($z->{value},$x->{value});     # absolute compare
    if ($a > 0)
      {
      $x->{value} = $CALC->_sub($z->{value},$x->{value},1); # abs sub w/ swap
      $x->{sign} = $sz;
      }
    elsif ($a == 0)
      {
      # speedup, if equal, set result to 0
      $x->{value} = $CALC->_zero();
      $x->{sign} = '+';
      }
    else # a < 0
      {
      $x->{value} = $CALC->_sub($x->{value}, $z->{value}); # abs sub
      }
    }
  $x->round(@r);
  }

sub bdiv
  {

    # This does floored division, where the quotient is floored toward negative
    # infinity and the remainder has the same sign as the divisor.

    # Set up parameters.
    my ($self,$x,$y,@r) = (ref($_[0]),@_);

    # objectify() is costly, so avoid it if we can.
    if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1]))) {
        ($self,$x,$y,@r) = objectify(2,@_);
    }

    return $x if $x->modify('bdiv');

    my $wantarray = wantarray;          # call only once

    # At least one argument is NaN. Return NaN for both quotient and the
    # modulo/remainder.

    if ($x -> is_nan() || $y -> is_nan()) {
        return $wantarray ? ($x -> bnan(), $self -> bnan()) : $x -> bnan();
    }

    # Divide by zero and modulo zero.
    #
    # Division: Use the common convention that x / 0 is inf with the same sign
    # as x, except when x = 0, where we return NaN. This is also what earlier
    # versions did.
    #
    # Modulo: In modular arithmetic, the congruence relation z = x (mod y)
    # means that there is some integer k such that z - x = k y. If y = 0, we
    # get z - x = 0 or z = x. This is also what earlier versions did, except
    # that 0 % 0 returned NaN.
    #
    #     inf / 0 =  inf                     inf % 0 =  inf
    #       5 / 0 =  inf                       5 % 0 =    5
    #       0 / 0 =  NaN                       0 % 0 =    0 (before: NaN)
    #      -5 / 0 = -inf                      -5 % 0 =   -5
    #    -inf / 0 = -inf                    -inf % 0 = -inf

    if ($y -> is_zero()) {
        my ($quo, $rem);
        if ($wantarray) {
                $rem = $x -> copy();
            }
        if ($x -> is_zero()) {
            $quo = $x -> bnan();
        } else {
            $quo = $x -> binf($x -> {sign});
        }
        return $wantarray ? ($quo, $rem) : $quo;
    }

    # Numerator (dividend) is +/-inf, and denominator is finite and non-zero.
    # The divide by zero cases are covered above. In all of the cases listed
    # below we return the same as core Perl.
    #
    #     inf / -inf =  NaN                  inf % -inf =  NaN
    #     inf /   -5 = -inf                  inf %   -5 =  NaN (before: 0)
    #     inf /    5 =  inf                  inf %    5 =  NaN (before: 0)
    #     inf /  inf =  NaN                  inf %  inf =  NaN
    #
    #    -inf / -inf =  NaN                 -inf % -inf =  NaN
    #    -inf /   -5 =  inf                 -inf %   -5 =  NaN (before: 0)
    #    -inf /    5 = -inf                 -inf %    5 =  NaN (before: 0)
    #    -inf /  inf =  NaN                 -inf %  inf =  NaN

    if ($x -> is_inf()) {
        my ($quo, $rem);
        $rem = $self -> bnan() if $wantarray;
        if ($y -> is_inf()) {
            $quo = $x -> bnan();
        } else {
            my $sign = $x -> bcmp(0) == $y -> bcmp(0) ? '+' : '-';
            $quo = $x -> binf($sign);
      }
        return $wantarray ? ($quo, $rem) : $quo;
    }

    # Denominator (divisor) is +/-inf. The cases when the numerator is +/-inf
    # are covered above. In the modulo cases (in the right column) we return
    # the same as core Perl, which does floored division, so for consistency we
    # also do floored division in the division cases (in the left column).
    #
    #      -5 /  inf =   -1 (before: 0)       -5 %  inf =  inf (before: -5)
    #       0 /  inf =    0                    0 %  inf =    0
    #       5 /  inf =    0                    5 %  inf =    5
    #
    #      -5 / -inf =    0                   -5 % -inf =   -5
    #       0 / -inf =    0                    0 % -inf =    0
    #       5 / -inf =   -1 (before: 0)        5 % -inf = -inf (before: 5)

    if ($y -> is_inf()) {
        my ($quo, $rem);
        if ($x -> is_zero() || $x -> bcmp(0) == $y -> bcmp(0)) {
            $rem = $x -> copy() if $wantarray;
            $quo = $x -> bzero();
        } else {
            $rem = $self -> binf($y -> {sign}) if $wantarray;
            $quo = $x -> bone('-');
        }
        return $wantarray ? ($quo, $rem) : $quo;
  }

  # At this point, both the numerator and denominator are finite numbers, and
  # the denominator (divisor) is non-zero.

  return $upgrade->bdiv($upgrade->new($x),$upgrade->new($y),@r)
   if defined $upgrade;

  $r[3] = $y;                                   # no push!

    # Inialize remainder.

    my $rem = $self->bzero();

    # Are both operands the same object, i.e., like $x -> bdiv($x)?
    # If so, flipping the sign of $y also flips the sign of $x.

    my $xsign = $x->{sign};
    my $ysign = $y->{sign};

    $y->{sign} =~ tr/+-/-+/;            # Flip the sign of $y, and see ...
    my $same = $xsign ne $x->{sign};    # ... if that changed the sign of $x.
    $y->{sign} = $ysign;                # Re-insert the original sign.

    if ($same) {
        $x -> bone();
    } else {
    ($x->{value},$rem->{value}) = $CALC->_div($x->{value},$y->{value});

        if ($CALC -> _is_zero($rem->{value})) {
            if ($xsign eq $ysign || $CALC -> _is_zero($x->{value})) {
                $x->{sign} = '+';
            } else {
                $x->{sign} = '-';
            }
        } else {
            if ($xsign eq $ysign) {
                $x->{sign} = '+';
            } else {
                if ($xsign eq '+') {
                    $x -> badd(1);
                } else {
                    $x -> bsub(1);
                }
                $x->{sign} = '-';
            }
        }
    }

    $x->round(@r);

    if ($wantarray) {
        unless ($CALC -> _is_zero($rem->{value})) {
            if ($xsign ne $ysign) {
                $rem = $y -> copy() -> babs() -> bsub($rem);
      }
            $rem->{sign} = $ysign;
      }
        $rem->{_a} = $x->{_a};
        $rem->{_p} = $x->{_p};
    $rem->round(@r);
    return ($x,$rem);
    }

    return $x;
  }

###############################################################################
# modulus functions

sub bmod
  {

    # This is the remainder after floored division, where the quotient is
    # floored toward negative infinity and the remainder has the same sign as
    # the divisor.

    # Set up parameters.
  my ($self,$x,$y,@r) = (ref($_[0]),@_);

  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@r) = objectify(2,@_);
    }

  return $x if $x->modify('bmod');
  $r[3] = $y;                                   # no push!

    # At least one argument is NaN.

    if ($x -> is_nan() || $y -> is_nan()) {
        return $x -> bnan();
    }

    # Modulo zero. See documentation for bdiv().

    if ($y -> is_zero()) {
            return $x;
        }

    # Numerator (dividend) is +/-inf.

    if ($x -> is_inf()) {
        return $x -> bnan();
    }

    # Denominator (divisor) is +/-inf.

    if ($y -> is_inf()) {
        if ($x -> is_zero() || $x -> bcmp(0) == $y -> bcmp(0)) {
            return $x;
        } else {
            return $x -> binf($y -> sign());
        }
    }

    # Calc new sign and in case $y == +/- 1, return $x.

  $x->{value} = $CALC->_mod($x->{value},$y->{value});
  if ($CALC -> _is_zero($x->{value}))
    {
        $x->{sign} = '+';       # do not leave -0
    }
  else
    {
    $x->{value} = $CALC->_sub($y->{value},$x->{value},1)        # $y-$x
      if ($x->{sign} ne $y->{sign});
    $x->{sign} = $y->{sign};
    }

  $x->round(@r);
  }

sub bmodinv
  {
  # Return modular multiplicative inverse:
  #
  #   z is the modular inverse of x (mod y) if and only if
  #
  #       x*z  1  (mod y)
  #
  # If the modulus y is larger than one, x and z are relative primes (i.e.,
  # their greatest common divisor is one).
  #
  # If no modular multiplicative inverse exists, NaN is returned.

  # set up parameters
  my ($self,$x,$y,@r) = (undef,@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@r) = objectify(2,@_);
    }

  return $x if $x->modify('bmodinv');

  # Return NaN if one or both arguments is +inf, -inf, or nan.

  return $x->bnan() if ($y->{sign} !~ /^[+-]$/ ||
                        $x->{sign} !~ /^[+-]$/);

  # Return NaN if $y is zero; 1 % 0 makes no sense.

  return $x->bnan() if $y->is_zero();

  # Return 0 in the trivial case. $x % 1 or $x % -1 is zero for all finite
  # integers $x.

  return $x->bzero() if ($y->is_one() ||
                         $y->is_one('-'));

  # Return NaN if $x = 0, or $x modulo $y is zero. The only valid case when
  # $x = 0 is when $y = 1 or $y = -1, but that was covered above.
  #
  # Note that computing $x modulo $y here affects the value we'll feed to
  # $CALC->_modinv() below when $x and $y have opposite signs. E.g., if $x =
  # 5 and $y = 7, those two values are fed to _modinv(), but if $x = -5 and
  # $y = 7, the values fed to _modinv() are $x = 2 (= -5 % 7) and $y = 7.
  # The value if $x is affected only when $x and $y have opposite signs.

  $x->bmod($y);
  return $x->bnan() if $x->is_zero();

  # Compute the modular multiplicative inverse of the absolute values. We'll
  # correct for the signs of $x and $y later. Return NaN if no GCD is found.

  ($x->{value}, $x->{sign}) = $CALC->_modinv($x->{value}, $y->{value});
  return $x->bnan() if !defined $x->{value};

  # Library inconsistency workaround: _modinv() in Math::BigInt::GMP versions
  # <= 1.32 return undef rather than a "+" for the sign.

  $x->{sign} = '+' unless defined $x->{sign};

  # When one or both arguments are negative, we have the following
  # relations.  If x and y are positive:
  #
  #   modinv(-x, -y) = -modinv(x, y)
  #   modinv(-x,  y) = y - modinv(x, y)  = -modinv(x, y) (mod y)
  #   modinv( x, -y) = modinv(x, y) - y  =  modinv(x, y) (mod -y)

  # We must swap the sign of the result if the original $x is negative.
  # However, we must compensate for ignoring the signs when computing the
  # inverse modulo. The net effect is that we must swap the sign of the
  # result if $y is negative.

  $x -> bneg() if $y->{sign} eq '-';

  # Compute $x modulo $y again after correcting the sign.

  $x -> bmod($y) if $x->{sign} ne $y->{sign};

  return $x;
  }

sub bmodpow
  {
  # Modular exponentiation. Raises a very large number to a very large exponent
  # in a given very large modulus quickly, thanks to binary exponentiation.
  # Supports negative exponents.
  my ($self,$num,$exp,$mod,@r) = objectify(3,@_);

  return $num if $num->modify('bmodpow');

  # When the exponent 'e' is negative, use the following relation, which is
  # based on finding the multiplicative inverse 'd' of 'b' modulo 'm':
  #
  #    b^(-e) (mod m) = d^e (mod m) where b*d = 1 (mod m)

  $num->bmodinv($mod) if ($exp->{sign} eq '-');

  # Check for valid input. All operands must be finite, and the modulus must be
  # non-zero.

  return $num->bnan() if ($num->{sign} =~ /NaN|inf/ ||  # NaN, -inf, +inf
                          $exp->{sign} =~ /NaN|inf/ ||  # NaN, -inf, +inf
                          $mod->{sign} =~ /NaN|inf/);   # NaN, -inf, +inf

  # Modulo zero. See documentation for Math::BigInt's bmod() method.

  if ($mod -> is_zero()) {
      if ($num -> is_zero()) {
          return $self -> bnan();
      } else {
          return $num -> copy();
      }
  }

  # Compute 'a (mod m)', ignoring the signs on 'a' and 'm'. If the resulting
  # value is zero, the output is also zero, regardless of the signs on 'a' and
  # 'm'.

  my $value = $CALC->_modpow($num->{value}, $exp->{value}, $mod->{value});
  my $sign  = '+';

  # If the resulting value is non-zero, we have four special cases, depending
  # on the signs on 'a' and 'm'.

  unless ($CALC->_is_zero($value)) {

      # There is a negative sign on 'a' (= $num**$exp) only if the number we
      # are exponentiating ($num) is negative and the exponent ($exp) is odd.

      if ($num->{sign} eq '-' && $exp->is_odd()) {

          # When both the number 'a' and the modulus 'm' have a negative sign,
          # use this relation:
          #
          #    -a (mod -m) = -(a (mod m))

          if ($mod->{sign} eq '-') {
              $sign = '-';
          }

          # When only the number 'a' has a negative sign, use this relation:
          #
          #    -a (mod m) = m - (a (mod m))

          else {
              # Use copy of $mod since _sub() modifies the first argument.
              my $mod = $CALC->_copy($mod->{value});
              $value = $CALC->_sub($mod, $value);
              $sign  = '+';
          }

      } else {

          # When only the modulus 'm' has a negative sign, use this relation:
          #
          #    a (mod -m) = (a (mod m)) - m
          #               = -(m - (a (mod m)))

          if ($mod->{sign} eq '-') {
              # Use copy of $mod since _sub() modifies the first argument.
              my $mod = $CALC->_copy($mod->{value});
              $value = $CALC->_sub($mod, $value);
              $sign  = '-';
          }

          # When neither the number 'a' nor the modulus 'm' have a negative
          # sign, directly return the already computed value.
          #
          #    (a (mod m))

      }

  }

  $num->{value} = $value;
  $num->{sign}  = $sign;

  return $num;
  }

###############################################################################

sub bfac
  {
  # (BINT or num_str, BINT or num_str) return BINT
  # compute factorial number from $x, modify $x in place
  my ($self,$x,@r) = ref($_[0]) ? (undef,@_) : objectify(1,@_);

  return $x if $x->modify('bfac') || $x->{sign} eq '+inf';      # inf => inf
  return $x->bnan() if $x->{sign} ne '+';                       # NaN, <0 etc => NaN

  $x->{value} = $CALC->_fac($x->{value});
  $x->round(@r);
  }

sub bpow
  {
  # (BINT or num_str, BINT or num_str) return BINT
  # compute power of two numbers -- stolen from Knuth Vol 2 pg 233
  # modifies first argument

  # set up parameters
  my ($self,$x,$y,@r) = (ref($_[0]),@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@r) = objectify(2,@_);
    }

  return $x if $x->modify('bpow');

  return $x->bnan() if $x->{sign} eq $nan || $y->{sign} eq $nan;

  # inf handling
  if (($x->{sign} =~ /^[+-]inf$/) || ($y->{sign} =~ /^[+-]inf$/))
    {
    if (($x->{sign} =~ /^[+-]inf$/) && ($y->{sign} =~ /^[+-]inf$/))
      {
      # +-inf ** +-inf
      return $x->bnan();
      }
    # +-inf ** Y
    if ($x->{sign} =~ /^[+-]inf/)
      {
      # +inf ** 0 => NaN
      return $x->bnan() if $y->is_zero();
      # -inf ** -1 => 1/inf => 0
      return $x->bzero() if $y->is_one('-') && $x->is_negative();

      # +inf ** Y => inf
      return $x if $x->{sign} eq '+inf';

      # -inf ** Y => -inf if Y is odd
      return $x if $y->is_odd();
      return $x->babs();
      }
    # X ** +-inf

    # 1 ** +inf => 1
    return $x if $x->is_one();

    # 0 ** inf => 0
    return $x if $x->is_zero() && $y->{sign} =~ /^[+]/;

    # 0 ** -inf => inf
    return $x->binf() if $x->is_zero();

    # -1 ** -inf => NaN
    return $x->bnan() if $x->is_one('-') && $y->{sign} =~ /^[-]/;

    # -X ** -inf => 0
    return $x->bzero() if $x->{sign} eq '-' && $y->{sign} =~ /^[-]/;

    # -1 ** inf => NaN
    return $x->bnan() if $x->{sign} eq '-';

    # X ** inf => inf
    return $x->binf() if $y->{sign} =~ /^[+]/;
    # X ** -inf => 0
    return $x->bzero();
    }

  return $upgrade->bpow($upgrade->new($x),$y,@r)
   if defined $upgrade && (!$y->isa($self) || $y->{sign} eq '-');

  $r[3] = $y;                                   # no push!

  # cases 0 ** Y, X ** 0, X ** 1, 1 ** Y are handled by Calc or Emu

  my $new_sign = '+';
  $new_sign = $y->is_odd() ? '-' : '+' if ($x->{sign} ne '+');

  # 0 ** -7 => ( 1 / (0 ** 7)) => 1 / 0 => +inf
  return $x->binf()
    if $y->{sign} eq '-' && $x->{sign} eq '+' && $CALC->_is_zero($x->{value});
  # 1 ** -y => 1 / (1 ** |y|)
  # so do test for negative $y after above's clause
  return $x->bnan() if $y->{sign} eq '-' && !$CALC->_is_one($x->{value});

  $x->{value} = $CALC->_pow($x->{value},$y->{value});
  $x->{sign} = $new_sign;
  $x->{sign} = '+' if $CALC->_is_zero($y->{value});
  $x->round(@r);
  }

sub blsft
  {
  # (BINT or num_str, BINT or num_str) return BINT
  # compute x << y, base n, y >= 0

  # set up parameters
  my ($self,$x,$y,$n,@r) = (ref($_[0]),@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,$n,@r) = objectify(2,@_);
    }

  return $x if $x->modify('blsft');
  return $x->bnan() if ($x->{sign} !~ /^[+-]$/ || $y->{sign} !~ /^[+-]$/);
  return $x->round(@r) if $y->is_zero();

  $n = 2 if !defined $n; return $x->bnan() if $n <= 0 || $y->{sign} eq '-';

  $x->{value} = $CALC->_lsft($x->{value},$y->{value},$n);
  $x->round(@r);
  }

sub brsft
  {
  # (BINT or num_str, BINT or num_str) return BINT
  # compute x >> y, base n, y >= 0

  # set up parameters
  my ($self,$x,$y,$n,@r) = (ref($_[0]),@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,$n,@r) = objectify(2,@_);
    }

  return $x if $x->modify('brsft');
  return $x->bnan() if ($x->{sign} !~ /^[+-]$/ || $y->{sign} !~ /^[+-]$/);
  return $x->round(@r) if $y->is_zero();
  return $x->bzero(@r) if $x->is_zero();                # 0 => 0

  $n = 2 if !defined $n; return $x->bnan() if $n <= 0 || $y->{sign} eq '-';

   # this only works for negative numbers when shifting in base 2
  if (($x->{sign} eq '-') && ($n == 2))
    {
    return $x->round(@r) if $x->is_one('-');    # -1 => -1
    if (!$y->is_one())
      {
      # although this is O(N*N) in calc (as_bin!) it is O(N) in Pari et al
      # but perhaps there is a better emulation for two's complement shift...
      # if $y != 1, we must simulate it by doing:
      # convert to bin, flip all bits, shift, and be done
      $x->binc();                       # -3 => -2
      my $bin = $x->as_bin();
      $bin =~ s/^-0b//;                 # strip '-0b' prefix
      $bin =~ tr/10/01/;                # flip bits
      # now shift
      if ($y >= CORE::length($bin))
        {
        $bin = '0';                     # shifting to far right creates -1
                                        # 0, because later increment makes
                                        # that 1, attached '-' makes it '-1'
                                        # because -1 >> x == -1 !
        }
      else
        {
        $bin =~ s/.{$y}$//;             # cut off at the right side
        $bin = '1' . $bin;              # extend left side by one dummy '1'
        $bin =~ tr/10/01/;              # flip bits back
        }
      my $res = $self->new('0b'.$bin);  # add prefix and convert back
      $res->binc();                     # remember to increment
      $x->{value} = $res->{value};      # take over value
      return $x->round(@r);             # we are done now, magic, isn't?
      }
    # x < 0, n == 2, y == 1
    $x->bdec();                         # n == 2, but $y == 1: this fixes it
    }

  $x->{value} = $CALC->_rsft($x->{value},$y->{value},$n);
  $x->round(@r);
  }

sub band
  {
  #(BINT or num_str, BINT or num_str) return BINT
  # compute x & y

  # set up parameters
  my ($self,$x,$y,@r) = (ref($_[0]),@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@r) = objectify(2,@_);
    }

  return $x if $x->modify('band');

  $r[3] = $y;                           # no push!

  return $x->bnan() if ($x->{sign} !~ /^[+-]$/ || $y->{sign} !~ /^[+-]$/);

  my $sx = $x->{sign} eq '+' ? 1 : -1;
  my $sy = $y->{sign} eq '+' ? 1 : -1;

  if ($sx == 1 && $sy == 1)
    {
    $x->{value} = $CALC->_and($x->{value},$y->{value});
    return $x->round(@r);
    }

  if ($CAN{signed_and})
    {
    $x->{value} = $CALC->_signed_and($x->{value},$y->{value},$sx,$sy);
    return $x->round(@r);
    }

  require $EMU_LIB;
  __emu_band($self,$x,$y,$sx,$sy,@r);
  }

sub bior
  {
  #(BINT or num_str, BINT or num_str) return BINT
  # compute x | y

  # set up parameters
  my ($self,$x,$y,@r) = (ref($_[0]),@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@r) = objectify(2,@_);
    }

  return $x if $x->modify('bior');
  $r[3] = $y;                           # no push!

  return $x->bnan() if ($x->{sign} !~ /^[+-]$/ || $y->{sign} !~ /^[+-]$/);

  my $sx = $x->{sign} eq '+' ? 1 : -1;
  my $sy = $y->{sign} eq '+' ? 1 : -1;

  # the sign of X follows the sign of X, e.g. sign of Y irrelevant for bior()

  # don't use lib for negative values
  if ($sx == 1 && $sy == 1)
    {
    $x->{value} = $CALC->_or($x->{value},$y->{value});
    return $x->round(@r);
    }

  # if lib can do negative values, let it handle this
  if ($CAN{signed_or})
    {
    $x->{value} = $CALC->_signed_or($x->{value},$y->{value},$sx,$sy);
    return $x->round(@r);
    }

  require $EMU_LIB;
  __emu_bior($self,$x,$y,$sx,$sy,@r);
  }

sub bxor
  {
  #(BINT or num_str, BINT or num_str) return BINT
  # compute x ^ y

  # set up parameters
  my ($self,$x,$y,@r) = (ref($_[0]),@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@r) = objectify(2,@_);
    }

  return $x if $x->modify('bxor');
  $r[3] = $y;                           # no push!

  return $x->bnan() if ($x->{sign} !~ /^[+-]$/ || $y->{sign} !~ /^[+-]$/);

  my $sx = $x->{sign} eq '+' ? 1 : -1;
  my $sy = $y->{sign} eq '+' ? 1 : -1;

  # don't use lib for negative values
  if ($sx == 1 && $sy == 1)
    {
    $x->{value} = $CALC->_xor($x->{value},$y->{value});
    return $x->round(@r);
    }

  # if lib can do negative values, let it handle this
  if ($CAN{signed_xor})
    {
    $x->{value} = $CALC->_signed_xor($x->{value},$y->{value},$sx,$sy);
    return $x->round(@r);
    }

  require $EMU_LIB;
  __emu_bxor($self,$x,$y,$sx,$sy,@r);
  }

sub length
  {
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);

  my $e = $CALC->_len($x->{value});
  wantarray ? ($e,0) : $e;
  }

sub digit
  {
  # return the nth decimal digit, negative values count backward, 0 is right
  my ($self,$x,$n) = ref($_[0]) ? (undef,@_) : objectify(1,@_);

  $n = $n->numify() if ref($n);
  $CALC->_digit($x->{value},$n||0);
  }

sub _trailing_zeros
  {
  # return the amount of trailing zeros in $x (as scalar)
  my $x = shift;
  $x = $class->new($x) unless ref $x;

  return 0 if $x->{sign} !~ /^[+-]$/;   # NaN, inf, -inf etc

  $CALC->_zeros($x->{value});           # must handle odd values, 0 etc
  }

sub bsqrt
  {
  # calculate square root of $x
  my ($self,$x,@r) = ref($_[0]) ? (undef,@_) : objectify(1,@_);

  return $x if $x->modify('bsqrt');

  return $x->bnan() if $x->{sign} !~ /^\+/;     # -x or -inf or NaN => NaN
  return $x if $x->{sign} eq '+inf';            # sqrt(+inf) == inf

  return $upgrade->bsqrt($x,@r) if defined $upgrade;

  $x->{value} = $CALC->_sqrt($x->{value});
  $x->round(@r);
  }

sub broot
  {
  # calculate $y'th root of $x

  # set up parameters
  my ($self,$x,$y,@r) = (ref($_[0]),@_);

  $y = $self->new(2) unless defined $y;

  # objectify is costly, so avoid it
  if ((!ref($x)) || (ref($x) ne ref($y)))
    {
    ($self,$x,$y,@r) = objectify(2,$self || $class,@_);
    }

  return $x if $x->modify('broot');

  # NaN handling: $x ** 1/0, x or y NaN, or y inf/-inf or y == 0
  return $x->bnan() if $x->{sign} !~ /^\+/ || $y->is_zero() ||
         $y->{sign} !~ /^\+$/;

  return $x->round(@r)
    if $x->is_zero() || $x->is_one() || $x->is_inf() || $y->is_one();

  return $upgrade->new($x)->broot($upgrade->new($y),@r) if defined $upgrade;

  $x->{value} = $CALC->_root($x->{value},$y->{value});
  $x->round(@r);
  }

sub exponent
  {
  # return a copy of the exponent (here always 0, NaN or 1 for $m == 0)
  my ($self,$x) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@_);

  if ($x->{sign} !~ /^[+-]$/)
    {
    my $s = $x->{sign}; $s =~ s/^[+-]//;  # NaN, -inf,+inf => NaN or inf
    return $self->new($s);
    }
  return $self->bzero() if $x->is_zero();

  # 12300 => 2 trailing zeros => exponent is 2
  $self->new( $CALC->_zeros($x->{value}) );
  }

sub mantissa
  {
  # return the mantissa (compatible to Math::BigFloat, e.g. reduced)
  my ($self,$x) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@_);

  if ($x->{sign} !~ /^[+-]$/)
    {
    # for NaN, +inf, -inf: keep the sign
    return $self->new($x->{sign});
    }
  my $m = $x->copy(); delete $m->{_p}; delete $m->{_a};

  # that's a bit inefficient:
  my $zeros = $CALC->_zeros($m->{value});
  $m->brsft($zeros,10) if $zeros != 0;
  $m;
  }

sub parts
  {
  # return a copy of both the exponent and the mantissa
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);

  ($x->mantissa(),$x->exponent());
  }

##############################################################################
# rounding functions

sub bfround
  {
  # precision: round to the $Nth digit left (+$n) or right (-$n) from the '.'
  # $n == 0 || $n == 1 => round to integer
  my $x = shift; my $self = ref($x) || $x; $x = $self->new($x) unless ref $x;

  my ($scale,$mode) = $x->_scale_p(@_);

  return $x if !defined $scale || $x->modify('bfround');        # no-op

  # no-op for BigInts if $n <= 0
  $x->bround( $x->length()-$scale, $mode) if $scale > 0;

  delete $x->{_a};      # delete to save memory
  $x->{_p} = $scale;    # store new _p
  $x;
  }

sub _scan_for_nonzero
  {
  # internal, used by bround() to scan for non-zeros after a '5'
  my ($x,$pad,$xs,$len) = @_;

  return 0 if $len == 1;                # "5" is trailed by invisible zeros
  my $follow = $pad - 1;
  return 0 if $follow > $len || $follow < 1;

  # use the string form to check whether only '0's follow or not
  substr ($xs,-$follow) =~ /[^0]/ ? 1 : 0;
  }

sub fround
  {
  # Exists to make life easier for switch between MBF and MBI (should we
  # autoload fxxx() like MBF does for bxxx()?)
  my $x = shift; $x = $class->new($x) unless ref $x;
  $x->bround(@_);
  }

sub bround
  {
  # accuracy: +$n preserve $n digits from left,
  #           -$n preserve $n digits from right (f.i. for 0.1234 style in MBF)
  # no-op for $n == 0
  # and overwrite the rest with 0's, return normalized number
  # do not return $x->bnorm(), but $x

  my $x = shift; $x = $class->new($x) unless ref $x;
  my ($scale,$mode) = $x->_scale_a(@_);
  return $x if !defined $scale || $x->modify('bround'); # no-op

  if ($x->is_zero() || $scale == 0)
    {
    $x->{_a} = $scale if !defined $x->{_a} || $x->{_a} > $scale; # 3 > 2
    return $x;
    }
  return $x if $x->{sign} !~ /^[+-]$/;          # inf, NaN

  # we have fewer digits than we want to scale to
  my $len = $x->length();
  # convert $scale to a scalar in case it is an object (put's a limit on the
  # number length, but this would already limited by memory constraints), makes
  # it faster
  $scale = $scale->numify() if ref ($scale);

  # scale < 0, but > -len (not >=!)
  if (($scale < 0 && $scale < -$len-1) || ($scale >= $len))
    {
    $x->{_a} = $scale if !defined $x->{_a} || $x->{_a} > $scale; # 3 > 2
    return $x;
    }

  # count of 0's to pad, from left (+) or right (-): 9 - +6 => 3, or |-6| => 6
  my ($pad,$digit_round,$digit_after);
  $pad = $len - $scale;
  $pad = abs($scale-1) if $scale < 0;

  # do not use digit(), it is very costly for binary => decimal
  # getting the entire string is also costly, but we need to do it only once
  my $xs = $CALC->_str($x->{value});
  my $pl = -$pad-1;

  # pad:   123: 0 => -1, at 1 => -2, at 2 => -3, at 3 => -4
  # pad+1: 123: 0 => 0,  at 1 => -1, at 2 => -2, at 3 => -3
  $digit_round = '0'; $digit_round = substr($xs,$pl,1) if $pad <= $len;
  $pl++; $pl ++ if $pad >= $len;
  $digit_after = '0'; $digit_after = substr($xs,$pl,1) if $pad > 0;

  # in case of 01234 we round down, for 6789 up, and only in case 5 we look
  # closer at the remaining digits of the original $x, remember decision
  my $round_up = 1;                                     # default round up
  $round_up -- if
    ($mode eq 'trunc')                          ||      # trunc by round down
    ($digit_after =~ /[01234]/)                 ||      # round down anyway,
                                                        # 6789 => round up
    ($digit_after eq '5')                       &&      # not 5000...0000
    ($x->_scan_for_nonzero($pad,$xs,$len) == 0)         &&
    (
     ($mode eq 'even') && ($digit_round =~ /[24680]/) ||
     ($mode eq 'odd')  && ($digit_round =~ /[13579]/) ||
     ($mode eq '+inf') && ($x->{sign} eq '-')   ||
     ($mode eq '-inf') && ($x->{sign} eq '+')   ||
     ($mode eq 'zero')          # round down if zero, sign adjusted below
    );
  my $put_back = 0;                                     # not yet modified

  if (($pad > 0) && ($pad <= $len))
    {
    substr($xs,-$pad,$pad) = '0' x $pad;                # replace with '00...'
    $put_back = 1;                                      # need to put back
    }
  elsif ($pad > $len)
    {
    $x->bzero();                                        # round to '0'
    }

  if ($round_up)                                        # what gave test above?
    {
    $put_back = 1;                                      # need to put back
    $pad = $len, $xs = '0' x $pad if $scale < 0;        # tlr: whack 0.51=>1.0

    # we modify directly the string variant instead of creating a number and
    # adding it, since that is faster (we already have the string)
    my $c = 0; $pad ++;                         # for $pad == $len case
    while ($pad <= $len)
      {
      $c = substr($xs,-$pad,1) + 1; $c = '0' if $c eq '10';
      substr($xs,-$pad,1) = $c; $pad++;
      last if $c != 0;                          # no overflow => early out
      }
    $xs = '1'.$xs if $c == 0;

    }
  $x->{value} = $CALC->_new($xs) if $put_back == 1;     # put back, if needed

  $x->{_a} = $scale if $scale >= 0;
  if ($scale < 0)
    {
    $x->{_a} = $len+$scale;
    $x->{_a} = 0 if $scale < -$len;
    }
  $x;
  }

sub bfloor
  {
  # round towards minus infinity; no-op since it's already integer
  my ($self,$x,@r) = ref($_[0]) ? (undef,@_) : objectify(1,@_);

  $x->round(@r);
  }

sub bceil
  {
  # round towards plus infinity; no-op since it's already int
  my ($self,$x,@r) = ref($_[0]) ? (undef,@_) : objectify(1,@_);

  $x->round(@r);
  }

sub bint {
    # round towards zero; no-op since it's already integer
    my ($self,$x,@r) = ref($_[0]) ? (undef,@_) : objectify(1,@_);

    $x->round(@r);
}

sub as_number
  {
  # An object might be asked to return itself as bigint on certain overloaded
  # operations. This does exactly this, so that sub classes can simple inherit
  # it or override with their own integer conversion routine.
  $_[0]->copy();
  }

sub as_hex
  {
  # return as hex string, with prefixed 0x
  my $x = shift; $x = $class->new($x) if !ref($x);

  return $x->bstr() if $x->{sign} !~ /^[+-]$/;  # inf, nan etc

  my $s = '';
  $s = $x->{sign} if $x->{sign} eq '-';
  $s . $CALC->_as_hex($x->{value});
  }

sub as_bin
  {
  # return as binary string, with prefixed 0b
  my $x = shift; $x = $class->new($x) if !ref($x);

  return $x->bstr() if $x->{sign} !~ /^[+-]$/;  # inf, nan etc

  my $s = ''; $s = $x->{sign} if $x->{sign} eq '-';
  return $s . $CALC->_as_bin($x->{value});
  }

sub as_oct
  {
  # return as octal string, with prefixed 0
  my $x = shift; $x = $class->new($x) if !ref($x);

  return $x->bstr() if $x->{sign} !~ /^[+-]$/;  # inf, nan etc

  my $oct = $CALC->_as_oct($x->{value});
  return $x->{sign} eq '-' ? "-$oct" : $oct;
  }

##############################################################################
# private stuff (internal use only)

sub objectify {
    # Convert strings and "foreign objects" to the objects we want.

    # The first argument, $count, is the number of following arguments that
    # objectify() looks at and converts to objects. The first is a classname.
    # If the given count is 0, all arguments will be used.

    # After the count is read, objectify obtains the name of the class to which
    # the following arguments are converted. If the second argument is a
    # reference, use the reference type as the class name. Otherwise, if it is
    # a string that looks like a class name, use that. Otherwise, use $class.

    # Caller:                        Gives us:
    #
    # $x->badd(1);                => ref x, scalar y
    # Class->badd(1,2);           => classname x (scalar), scalar x, scalar y
    # Class->badd(Class->(1),2);  => classname x (scalar), ref x, scalar y
    # Math::BigInt::badd(1,2);    => scalar x, scalar y

    # A shortcut for the common case $x->unary_op():

    return (ref($_[1]), $_[1]) if (@_ == 2) && ($_[0]||0 == 1) && ref($_[1]);

    # Check the context.

    unless (wantarray) {
        require Carp;
        Carp::croak ("${class}::objectify() needs list context");
    }

    # Get the number of arguments to objectify.

    my $count = shift;
    $count ||= @_;

    # Initialize the output array.

    my @a = @_;

    # If the first argument is a reference, use that reference type as our
    # class name. Otherwise, if the first argument looks like a class name,
    # then use that as our class name. Otherwise, use the default class name.

    {
        if (ref($a[0])) {               # reference?
            unshift @a, ref($a[0]);
            last;
        }
        if ($a[0] =~ /^[A-Z].*::/) {    # string with class name?
            last;
        }
        unshift @a, $class;             # default class name
    }

    no strict 'refs';

    # What we upgrade to, if anything.

    my $up = ${"$a[0]::upgrade"};

    # Disable downgrading, because Math::BigFloat -> foo('1.0','2.0') needs
    # floats.

    my $down;
    if (defined ${"$a[0]::downgrade"}) {
        $down = ${"$a[0]::downgrade"};
        ${"$a[0]::downgrade"} = undef;
    }

    for my $i (1 .. $count) {
        my $ref = ref $a[$i];

        # Perl scalars are fed to the appropriate constructor.

        unless ($ref) {
            $a[$i] = $a[0] -> new($a[$i]);
            next;
        }

        # If it is an object of the right class, all is fine.

        next if $ref -> isa($a[0]);

        # Upgrading is OK, so skip further tests if the argument is upgraded.

        if (defined $up && $ref -> isa($up)) {
            next;
        }

        # See if we can call one of the as_xxx() methods. We don't know whether
        # the as_xxx() method returns an object or a scalar, so re-check
        # afterwards.

        my $recheck = 0;

        if ($a[0] -> isa('Math::BigInt')) {
            if ($a[$i] -> can('as_int')) {
                $a[$i] = $a[$i] -> as_int();
                $recheck = 1;
            } elsif ($a[$i] -> can('as_number')) {
                $a[$i] = $a[$i] -> as_number();
                $recheck = 1;
            }
        }

        elsif ($a[0] -> isa('Math::BigFloat')) {
            if ($a[$i] -> can('as_float')) {
                $a[$i] = $a[$i] -> as_float();
                $recheck = $1;
            }
        }

        # If we called one of the as_xxx() methods, recheck.

        if ($recheck) {
            $ref = ref($a[$i]);

            # Perl scalars are fed to the appropriate constructor.

            unless ($ref) {
                $a[$i] = $a[0] -> new($a[$i]);
                next;
            }

            # If it is an object of the right class, all is fine.

            next if $ref -> isa($a[0]);
        }

        # Last resort.

        $a[$i] = $a[0] -> new($a[$i]);
    }

    # Reset the downgrading.

    ${"$a[0]::downgrade"} = $down;

    return @a;
}

sub _register_callback
  {
  my ($class,$callback) = @_;

  if (ref($callback) ne 'CODE')
    {
    require Carp;
    Carp::croak ("$callback is not a coderef");
    }
  $CALLBACKS{$class} = $callback;
  }

sub import
  {
  my $self = shift;

  $IMPORT++;                            # remember we did import()
  my @a; my $l = scalar @_;
  my $warn_or_die = 0;                  # 0 - no warn, 1 - warn, 2 - die
  for ( my $i = 0; $i < $l ; $i++ )
    {
    if ($_[$i] eq ':constant')
      {
      # this causes overlord er load to step in
      overload::constant
        integer => sub { $self->new(shift) },
        binary => sub { $self->new(shift) };
      }
    elsif ($_[$i] eq 'upgrade')
      {
      # this causes upgrading
      $upgrade = $_[$i+1];              # or undef to disable
      $i++;
      }
    elsif ($_[$i] =~ /^(lib|try|only)\z/)
      {
      # this causes a different low lib to take care...
      $CALC = $_[$i+1] || '';
      # lib => 1 (warn on fallback), try => 0 (no warn), only => 2 (die on fallback)
      $warn_or_die = 1 if $_[$i] eq 'lib';
      $warn_or_die = 2 if $_[$i] eq 'only';
      $i++;
      }
    else
      {
      push @a, $_[$i];
      }
    }
  # any non :constant stuff is handled by our parent, Exporter
  if (@a > 0)
    {
    require Exporter;

    $self->SUPER::import(@a);                   # need it for subclasses
    $self->export_to_level(1,$self,@a);         # need it for MBF
    }

  # try to load core math lib
  my @c = split /\s*,\s*/,$CALC;
  foreach (@c)
    {
    $_ =~ tr/a-zA-Z0-9://cd;                    # limit to sane characters
    }
  push @c, \'Calc'                              # if all fail, try these
    if $warn_or_die < 2;                        # but not for "only"
  $CALC = '';                                   # signal error
  foreach my $l (@c)
    {
    # fallback libraries are "marked" as \'string', extract string if nec.
    my $lib = $l; $lib = $$l if ref($l);

    next if ($lib || '') eq '';
    $lib = 'Math::BigInt::'.$lib if $lib !~ /^Math::BigInt/i;
    $lib =~ s/\.pm$//;
    if ($] < 5.006)
      {
      # Perl < 5.6.0 dies with "out of memory!" when eval("") and ':constant' is
      # used in the same script, or eval("") inside import().
      my @parts = split /::/, $lib;             # Math::BigInt => Math BigInt
      my $file = pop @parts; $file .= '.pm';    # BigInt => BigInt.pm
      require File::Spec;
      $file = File::Spec->catfile (@parts, $file);
      eval { require "$file"; $lib->import( @c ); }
      }
    else
      {
      eval "use $lib qw/@c/;";
      }
    if ($@ eq '')
      {
      my $ok = 1;
      # loaded it ok, see if the api_version() is high enough
      if ($lib->can('api_version') && $lib->api_version() >= 1.0)
        {
        $ok = 0;
        # api_version matches, check if it really provides anything we need
        for my $method (qw/
                one two ten
                str num
                add mul div sub dec inc
                acmp len digit is_one is_zero is_even is_odd
                is_two is_ten
                zeros new copy check
                from_hex from_oct from_bin as_hex as_bin as_oct
                rsft lsft xor and or
                mod sqrt root fac pow modinv modpow log_int gcd
         /)
          {
          if (!$lib->can("_$method"))
            {
            if (($WARN{$lib}||0) < 2)
              {
              require Carp;
              Carp::carp ("$lib is missing method '_$method'");
              $WARN{$lib} = 1;          # still warn about the lib
              }
            $ok++; last;
            }
          }
        }
      if ($ok == 0)
        {
        $CALC = $lib;
        if ($warn_or_die > 0 && ref($l))
          {
          require Carp;
          my $msg =
        "Math::BigInt: couldn't load specified math lib(s), fallback to $lib";
          Carp::carp ($msg) if $warn_or_die == 1;
          Carp::croak ($msg) if $warn_or_die == 2;
          }
        last;                   # found a usable one, break
        }
      else
        {
        if (($WARN{$lib}||0) < 2)
          {
          my $ver = eval "\$$lib\::VERSION" || 'unknown';
          require Carp;
          Carp::carp ("Cannot load outdated $lib v$ver, please upgrade");
          $WARN{$lib} = 2;              # never warn again
          }
        }
      }
    }
  if ($CALC eq '')
    {
    require Carp;
    if ($warn_or_die == 2)
      {
      Carp::croak(
          "Couldn't load specified math lib(s) and fallback disallowed");
      }
    else
      {
      Carp::croak(
          "Couldn't load any math lib(s), not even fallback to Calc.pm");
      }
    }

  # notify callbacks
  foreach my $class (keys %CALLBACKS)
    {
    &{$CALLBACKS{$class}}($CALC);
    }

  # Fill $CAN with the results of $CALC->can(...) for emulating lower math lib
  # functions

  %CAN = ();
  for my $method (qw/ signed_and signed_or signed_xor /)
    {
    $CAN{$method} = $CALC->can("_$method") ? 1 : 0;
    }

  # import done
  }

# Create a Math::BigInt from a hexadecimal string.

sub from_hex {
    my $self    = shift;
    my $selfref = ref $self;
    my $class   = $selfref || $self;

    my $str = shift;

    # If called as a class method, initialize a new object.

    $self = $class -> bzero() unless $selfref;

    if ($str =~ s/
                     ^
                     ( [+-]? )
                     (0?x)?
                     (
                         [0-9a-fA-F]*
                         ( _ [0-9a-fA-F]+ )*
                     )
                     $
                 //x)
    {
        # Get a "clean" version of the string, i.e., non-emtpy and with no
        # underscores or invalid characters.

        my $sign = $1;
        my $chrs = $3;
        $chrs =~ tr/_//d;
        $chrs = '0' unless CORE::length $chrs;

        # The library method requires a prefix.

        $self->{value} = $CALC->_from_hex('0x' . $chrs);

        # Place the sign.

        if ($sign eq '-' && ! $CALC->_is_zero($self->{value})) {
            $self->{sign} = '-';
        }

        return $self;
    }

    # CORE::hex() parses as much as it can, and ignores any trailing garbage.
    # For backwards compatibility, we return NaN.

    return $self->bnan();
}

# Create a Math::BigInt from an octal string.

sub from_oct {
    my $self    = shift;
    my $selfref = ref $self;
    my $class   = $selfref || $self;

    my $str = shift;

    # If called as a class method, initialize a new object.

    $self = $class -> bzero() unless $selfref;

    if ($str =~ s/
                     ^
                     ( [+-]? )
                     (
                         [0-7]*
                         ( _ [0-7]+ )*
                     )
                     $
                 //x)
    {
        # Get a "clean" version of the string, i.e., non-emtpy and with no
        # underscores or invalid characters.

        my $sign = $1;
        my $chrs = $2;
        $chrs =~ tr/_//d;
        $chrs = '0' unless CORE::length $chrs;

        # The library method requires a prefix.

        $self->{value} = $CALC->_from_oct('0' . $chrs);

        # Place the sign.

        if ($sign eq '-' && ! $CALC->_is_zero($self->{value})) {
            $self->{sign} = '-';
        }

        return $self;
    }

    # CORE::oct() parses as much as it can, and ignores any trailing garbage.
    # For backwards compatibility, we return NaN.

    return $self->bnan();
}

# Create a Math::BigInt from a binary string.

sub from_bin {
    my $self    = shift;
    my $selfref = ref $self;
    my $class   = $selfref || $self;

    my $str = shift;

    # If called as a class method, initialize a new object.

    $self = $class -> bzero() unless $selfref;

    if ($str =~ s/
                     ^
                     ( [+-]? )
                     (0?b)?
                     (
                         [01]*
                         ( _ [01]+ )*
                     )
                     $
                 //x)
    {
        # Get a "clean" version of the string, i.e., non-emtpy and with no
        # underscores or invalid characters.

        my $sign = $1;
        my $chrs = $3;
        $chrs =~ tr/_//d;
        $chrs = '0' unless CORE::length $chrs;

        # The library method requires a prefix.

        $self->{value} = $CALC->_from_bin('0b' . $chrs);

        # Place the sign.

        if ($sign eq '-' && ! $CALC->_is_zero($self->{value})) {
            $self->{sign} = '-';
        }

        return $self;
    }

    # For consistency with from_hex() and from_oct(), we return NaN when the
    # input is invalid.

    return $self->bnan();
}

sub _split_dec_string {
    my $str = shift;

    if ($str =~ s/
                     ^

                     # leading whitespace
                     ( \s* )

                     # optional sign
                     ( [+-]? )

                     # significand
                     (
                         \d+ (?: _ \d+ )*
                         (?:
                             \.
                             (?: \d+ (?: _ \d+ )* )?
                         )?
                     |
                         \.
                         \d+ (?: _ \d+ )*
                     )

                     # optional exponent
                     (?:
                         [Ee]
                         ( [+-]? )
                         ( \d+ (?: _ \d+ )* )
                     )?

                     # trailing stuff
                     ( \D .*? )?

                     \z
                 //x)
    {
        my $leading         = $1;
        my $significand_sgn = $2 || '+';
        my $significand_abs = $3;
        my $exponent_sgn    = $4 || '+';
        my $exponent_abs    = $5 || '0';
        my $trailing        = $6;

        # Remove underscores and leading zeros.

        $significand_abs =~ tr/_//d;
        $exponent_abs    =~ tr/_//d;

        $significand_abs =~ s/^0+(.)/$1/;
        $exponent_abs    =~ s/^0+(.)/$1/;

        # If the significand contains a dot, remove it and adjust the exponent
        # accordingly. E.g., "1234.56789e+3" -> "123456789e-2"

        my $idx = index $significand_abs, '.';
        if ($idx > -1) {
            $significand_abs =~ s/0+\z//;
            substr($significand_abs, $idx, 1) = '';
            my $exponent = $exponent_sgn . $exponent_abs;
            $exponent .= $idx - CORE::length($significand_abs);
            $exponent_abs = abs $exponent;
            $exponent_sgn = $exponent < 0 ? '-' : '+';
        }

        return($leading,
               $significand_sgn, $significand_abs,
               $exponent_sgn, $exponent_abs,
               $trailing);
    }

    return undef;
}

sub _split
  {
  # input: num_str; output: undef for invalid or
  # (\$mantissa_sign,\$mantissa_value,\$mantissa_fraction,
  # \$exp_sign,\$exp_value)
  # Internal, take apart a string and return the pieces.
  # Strip leading/trailing whitespace, leading zeros, underscore and reject
  # invalid input.
  my $x = shift;

  # strip white space at front, also extraneous leading zeros
  $x =~ s/^\s*([-]?)0*([0-9])/$1$2/g;   # will not strip '  .2'
  $x =~ s/^\s+//;                       # but this will
  $x =~ s/\s+$//g;                      # strip white space at end

  # shortcut, if nothing to split, return early
  if ($x =~ /^[+-]?[0-9]+\z/)
    {
    $x =~ s/^([+-])0*([0-9])/$2/; my $sign = $1 || '+';
    return (\$sign, \$x, \'', \'', \0);
    }

  # invalid starting char?
  return if $x !~ /^[+-]?(\.?[0-9]|0b[0-1]|0x[0-9a-fA-F])/;

  return Math::BigInt->from_hex($x) if $x =~ /^[+-]?0x/;        # hex string
  return Math::BigInt->from_bin($x) if $x =~ /^[+-]?0b/;        # binary string

  # strip underscores between digits
  $x =~ s/([0-9])_([0-9])/$1$2/g;
  $x =~ s/([0-9])_([0-9])/$1$2/g;               # do twice for 1_2_3

  # some possible inputs:
  # 2.1234 # 0.12        # 1          # 1E1 # 2.134E1 # 434E-10 # 1.02009E-2
  # .2     # 1_2_3.4_5_6 # 1.4E1_2_3  # 1e3 # +.2     # 0e999

  my ($m,$e,$last) = split /[Ee]/,$x;
  return if defined $last;              # last defined => 1e2E3 or others
  $e = '0' if !defined $e || $e eq "";

  # sign,value for exponent,mantint,mantfrac
  my ($es,$ev,$mis,$miv,$mfv);
  # valid exponent?
  if ($e =~ /^([+-]?)0*([0-9]+)$/)      # strip leading zeros
    {
    $es = $1; $ev = $2;
    # valid mantissa?
    return if $m eq '.' || $m eq '';
    my ($mi,$mf,$lastf) = split /\./,$m;
    return if defined $lastf;           # lastf defined => 1.2.3 or others
    $mi = '0' if !defined $mi;
    $mi .= '0' if $mi =~ /^[\-\+]?$/;
    $mf = '0' if !defined $mf || $mf eq '';
    if ($mi =~ /^([+-]?)0*([0-9]+)$/)           # strip leading zeros
      {
      $mis = $1||'+'; $miv = $2;
      return unless ($mf =~ /^([0-9]*?)0*$/);   # strip trailing zeros
      $mfv = $1;
      # handle the 0e999 case here
      $ev = 0 if $miv eq '0' && $mfv eq '';
      return (\$mis,\$miv,\$mfv,\$es,\$ev);
      }
    }
  return; # NaN, not a number
  }

##############################################################################
# internal calculation routines (others are in Math::BigInt::Calc etc)

sub __lcm
  {
  # (BINT or num_str, BINT or num_str) return BINT
  # does modify first argument
  # LCM

  my ($x,$ty) = @_;
  return $x->bnan() if ($x->{sign} eq $nan) || ($ty->{sign} eq $nan);
  my $method = ref($x) . '::bgcd';
  no strict 'refs';
  $x * $ty / &$method($x,$ty);
  }

###############################################################################
# trigonometric functions

sub bpi
  {
  # Calculate PI to N digits. Unless upgrading is in effect, returns the
  # result truncated to an integer, that is, always returns '3'.
  my ($self,$n) = @_;
  if (@_ == 1)
    {
    # called like Math::BigInt::bpi(10);
    $n = $self; $self = $class;
    }
  $self = ref($self) if ref($self);

  return $upgrade->new($n) if defined $upgrade;

  # hard-wired to "3"
  $self->new(3);
  }

sub bcos
  {
  # Calculate cosinus(x) to N digits. Unless upgrading is in effect, returns the
  # result truncated to an integer.
  my ($self,$x,@r) = ref($_[0]) ? (undef,@_) : objectify(1,@_);

  return $x if $x->modify('bcos');

  return $x->bnan() if $x->{sign} !~ /^[+-]\z/; # -inf +inf or NaN => NaN

  return $upgrade->new($x)->bcos(@r) if defined $upgrade;

  require Math::BigFloat;
  # calculate the result and truncate it to integer
  my $t = Math::BigFloat->new($x)->bcos(@r)->as_int();

  $x->bone() if $t->is_one();
  $x->bzero() if $t->is_zero();
  $x->round(@r);
  }

sub bsin
  {
  # Calculate sinus(x) to N digits. Unless upgrading is in effect, returns the
  # result truncated to an integer.
  my ($self,$x,@r) = ref($_[0]) ? (undef,@_) : objectify(1,@_);

  return $x if $x->modify('bsin');

  return $x->bnan() if $x->{sign} !~ /^[+-]\z/; # -inf +inf or NaN => NaN

  return $upgrade->new($x)->bsin(@r) if defined $upgrade;

  require Math::BigFloat;
  # calculate the result and truncate it to integer
  my $t = Math::BigFloat->new($x)->bsin(@r)->as_int();

  $x->bone() if $t->is_one();
  $x->bzero() if $t->is_zero();
  $x->round(@r);
  }

sub batan2
  {
  # calculate arcus tangens of ($y/$x)

  # set up parameters
  my ($self,$y,$x,@r) = (ref($_[0]),@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$y,$x,@r) = objectify(2,@_);
    }

  return $y if $y->modify('batan2');

  return $y->bnan() if ($y->{sign} eq $nan) || ($x->{sign} eq $nan);

  # Y    X
  # != 0 -inf result is +- pi
  if ($x->is_inf() || $y->is_inf())
    {
    # upgrade to BigFloat etc.
    return $upgrade->new($y)->batan2($upgrade->new($x),@r) if defined $upgrade;
    if ($y->is_inf())
      {
      if ($x->{sign} eq '-inf')
        {
        # calculate 3 pi/4 => 2.3.. => 2
        $y->bone( substr($y->{sign},0,1) );
        $y->bmul($self->new(2));
        }
      elsif ($x->{sign} eq '+inf')
        {
        # calculate pi/4 => 0.7 => 0
        $y->bzero();
        }
      else
        {
        # calculate pi/2 => 1.5 => 1
        $y->bone( substr($y->{sign},0,1) );
        }
      }
    else
      {
      if ($x->{sign} eq '+inf')
        {
        # calculate pi/4 => 0.7 => 0
        $y->bzero();
        }
      else
        {
        # PI => 3.1415.. => 3
        $y->bone( substr($y->{sign},0,1) );
        $y->bmul($self->new(3));
        }
      }
    return $y;
    }

  return $upgrade->new($y)->batan2($upgrade->new($x),@r) if defined $upgrade;

  require Math::BigFloat;
  my $r = Math::BigFloat->new($y)
                        ->batan2(Math::BigFloat->new($x),@r)
                        ->as_int();

  $x->{value} = $r->{value};
  $x->{sign} = $r->{sign};

  $x;
  }

sub batan
  {
  # Calculate arcus tangens of x to N digits. Unless upgrading is in effect, returns the
  # result truncated to an integer.
  my ($self,$x,@r) = ref($_[0]) ? (undef,@_) : objectify(1,@_);

  return $x if $x->modify('batan');

  return $x->bnan() if $x->{sign} !~ /^[+-]\z/; # -inf +inf or NaN => NaN

  return $upgrade->new($x)->batan(@r) if defined $upgrade;

  # calculate the result and truncate it to integer
  my $t = Math::BigFloat->new($x)->batan(@r);

  $x->{value} = $CALC->_new( $x->as_int()->bstr() );
  $x->round(@r);
  }

###############################################################################
# this method returns 0 if the object can be modified, or 1 if not.
# We use a fast constant sub() here, to avoid costly calls. Subclasses
# may override it with special code (f.i. Math::BigInt::Constant does so)

sub modify () { 0; }

1;
__END__

=pod

=head1 NAME

Math::BigInt - Arbitrary size integer/float math package

=head1 SYNOPSIS

  use Math::BigInt;

  # or make it faster with huge numbers: install (optional)
  # Math::BigInt::GMP and always use (it will fall back to
  # pure Perl if the GMP library is not installed):
  # (See also the L<MATH LIBRARY> section!)

  # will warn if Math::BigInt::GMP cannot be found
  use Math::BigInt lib => 'GMP';

  # to suppress the warning use this:
  # use Math::BigInt try => 'GMP';

  # dies if GMP cannot be loaded:
  # use Math::BigInt only => 'GMP';

  my $str = '1234567890';
  my @values = (64,74,18);
  my $n = 1; my $sign = '-';

  # Number creation
  my $x = Math::BigInt->new($str);      # defaults to 0
  my $y = $x->copy();                   # make a true copy
  my $nan  = Math::BigInt->bnan();      # create a NotANumber
  my $zero = Math::BigInt->bzero();     # create a +0
  my $inf = Math::BigInt->binf();       # create a +inf
  my $inf = Math::BigInt->binf('-');    # create a -inf
  my $one = Math::BigInt->bone();       # create a +1
  my $mone = Math::BigInt->bone('-');   # create a -1

  my $pi = Math::BigInt->bpi();         # returns '3'
                                        # see Math::BigFloat::bpi()

  $h = Math::BigInt->new('0x123');      # from hexadecimal
  $b = Math::BigInt->new('0b101');      # from binary
  $o = Math::BigInt->from_oct('0101');  # from octal
  $h = Math::BigInt->from_hex('cafe');  # from hexadecimal
  $b = Math::BigInt->from_bin('0101');  # from binary

  # Testing (don't modify their arguments)
  # (return true if the condition is met, otherwise false)

  $x->is_zero();        # if $x is +0
  $x->is_nan();         # if $x is NaN
  $x->is_one();         # if $x is +1
  $x->is_one('-');      # if $x is -1
  $x->is_odd();         # if $x is odd
  $x->is_even();        # if $x is even
  $x->is_pos();         # if $x > 0
  $x->is_neg();         # if $x < 0
  $x->is_inf($sign);    # if $x is +inf, or -inf (sign is default '+')
  $x->is_int();         # if $x is an integer (not a float)

  # comparing and digit/sign extraction
  $x->bcmp($y);         # compare numbers (undef,<0,=0,>0)
  $x->bacmp($y);        # compare absolutely (undef,<0,=0,>0)
  $x->sign();           # return the sign, either +,- or NaN
  $x->digit($n);        # return the nth digit, counting from right
  $x->digit(-$n);       # return the nth digit, counting from left

  # The following all modify their first argument. If you want to pre-
  # serve $x, use $z = $x->copy()->bXXX($y); See under L<CAVEATS> for
  # why this is necessary when mixing $a = $b assignments with non-over-
  # loaded math.

  $x->bzero();          # set $x to 0
  $x->bnan();           # set $x to NaN
  $x->bone();           # set $x to +1
  $x->bone('-');        # set $x to -1
  $x->binf();           # set $x to inf
  $x->binf('-');        # set $x to -inf

  $x->bneg();           # negation
  $x->babs();           # absolute value
  $x->bsgn();           # sign function (-1, 0, 1, or NaN)
  $x->bnorm();          # normalize (no-op in BigInt)
  $x->bnot();           # two's complement (bit wise not)
  $x->binc();           # increment $x by 1
  $x->bdec();           # decrement $x by 1

  $x->badd($y);         # addition (add $y to $x)
  $x->bsub($y);         # subtraction (subtract $y from $x)
  $x->bmul($y);         # multiplication (multiply $x by $y)
  $x->bdiv($y);         # divide, set $x to quotient
                        # return (quo,rem) or quo if scalar

  $x->bmuladd($y,$z);   # $x = $x * $y + $z

  $x->bmod($y);         # modulus (x % y)
  $x->bmodpow($y,$mod); # modular exponentiation (($x ** $y) % $mod)
  $x->bmodinv($mod);    # modular multiplicative inverse
  $x->bpow($y);         # power of arguments (x ** y)
  $x->blsft($y);        # left shift in base 2
  $x->brsft($y);        # right shift in base 2
                        # returns (quo,rem) or quo if in sca-
                        # lar context
  $x->blsft($y,$n);     # left shift by $y places in base $n
  $x->brsft($y,$n);     # right shift by $y places in base $n
                        # returns (quo,rem) or quo if in sca-
                        # lar context

  $x->band($y);         # bitwise and
  $x->bior($y);         # bitwise inclusive or
  $x->bxor($y);         # bitwise exclusive or
  $x->bnot();           # bitwise not (two's complement)

  $x->bsqrt();          # calculate square-root
  $x->broot($y);        # $y'th root of $x (e.g. $y == 3 => cubic root)
  $x->bfac();           # factorial of $x (1*2*3*4*..$x)

  $x->bnok($y);         # x over y (binomial coefficient n over k)

  $x->blog();           # logarithm of $x to base e (Euler's number)
  $x->blog($base);      # logarithm of $x to base $base (f.i. 2)
  $x->bexp();           # calculate e ** $x where e is Euler's number

  $x->round($A,$P,$mode);  # round to accuracy or precision using
                           # mode $mode
  $x->bround($n);          # accuracy: preserve $n digits
  $x->bfround($n);         # $n > 0: round $nth digits,
                           # $n < 0: round to the $nth digit after the
                           # dot, no-op for BigInts

  # The following do not modify their arguments in BigInt (are no-ops),
  # but do so in BigFloat:

  $x->bfloor();            # round towards minus infinity
  $x->bceil();             # round towards plus infinity
  $x->bint();              # round towards zero

  # The following do not modify their arguments:

  # greatest common divisor (no OO style)
  my $gcd = Math::BigInt::bgcd(@values);
  # lowest common multiple (no OO style)
  my $lcm = Math::BigInt::blcm(@values);

  $x->length();            # return number of digits in number
  ($xl,$f) = $x->length(); # length of number and length of fraction
                           # part, latter is always 0 digits long
                           # for BigInts

  $x->exponent();         # return exponent as BigInt
  $x->mantissa();         # return (signed) mantissa as BigInt
  $x->parts();            # return (mantissa,exponent) as BigInt
  $x->copy();             # make a true copy of $x (unlike $y = $x;)
  $x->as_int();           # return as BigInt (in BigInt: same as copy())
  $x->numify();           # return as scalar (might overflow!)

  # conversion to string (do not modify their argument)
  $x->bstr();         # normalized string (e.g. '3')
  $x->bsstr();        # norm. string in scientific notation (e.g. '3E0')
  $x->as_hex();       # as signed hexadecimal string with prefixed 0x
  $x->as_bin();       # as signed binary string with prefixed 0b
  $x->as_oct();       # as signed octal string with prefixed 0


  # precision and accuracy (see section about rounding for more)
  $x->precision();       # return P of $x (or global, if P of $x undef)
  $x->precision($n);     # set P of $x to $n
  $x->accuracy();        # return A of $x (or global, if A of $x undef)
  $x->accuracy($n);      # set A $x to $n

  # Global methods
  Math::BigInt->precision();   # get/set global P for all BigInt objects
  Math::BigInt->accuracy();    # get/set global A for all BigInt objects
  Math::BigInt->round_mode();  # get/set global round mode, one of
                               # 'even', 'odd', '+inf', '-inf', 'zero',
                               # 'trunc' or 'common'
  Math::BigInt->config();      # return hash containing configuration

=head1 DESCRIPTION

All operators (including basic math operations) are overloaded if you
declare your big integers as

  $i = Math::BigInt -> new('123_456_789_123_456_789');

Operations with overloaded operators preserve the arguments which is
exactly what you expect.

=head2 Input

Input values to these routines may be any string, that looks like a number
and results in an integer, including hexadecimal and binary numbers.

Scalars holding numbers may also be passed, but note that non-integer numbers
may already have lost precision due to the conversion to float. Quote
your input if you want BigInt to see all the digits:

        $x = Math::BigInt->new(12345678890123456789);   # bad
        $x = Math::BigInt->new('12345678901234567890'); # good

You can include one underscore between any two digits.

This means integer values like 1.01E2 or even 1000E-2 are also accepted.
Non-integer values result in NaN.

Hexadecimal (prefixed with "0x") and binary numbers (prefixed with "0b")
are accepted, too. Please note that octal numbers are not recognized
by new(), so the following will print "123":

        perl -MMath::BigInt -le 'print Math::BigInt->new("0123")'

To convert an octal number, use from_oct();

        perl -MMath::BigInt -le 'print Math::BigInt->from_oct("0123")'

Currently, Math::BigInt::new() defaults to 0, while Math::BigInt::new('')
results in 'NaN'. This might change in the future, so use always the following
explicit forms to get a zero or NaN:

        $zero = Math::BigInt->bzero();
        $nan = Math::BigInt->bnan();

C<bnorm()> on a BigInt object is now effectively a no-op, since the numbers
are always stored in normalized form. If passed a string, creates a BigInt
object from the input.

=head2 Output

Output values are BigInt objects (normalized), except for the methods which
return a string (see L</SYNOPSIS>).

Some routines (C<is_odd()>, C<is_even()>, C<is_zero()>, C<is_one()>,
C<is_nan()>, etc.) return true or false, while others (C<bcmp()>, C<bacmp()>)
return either undef (if NaN is involved), <0, 0 or >0 and are suited for sort.

=head1 METHODS

Each of the methods below (except config(), accuracy() and precision())
accepts three additional parameters. These arguments C<$A>, C<$P> and C<$R>
are C<accuracy>, C<precision> and C<round_mode>. Please see the section about
L</ACCURACY and PRECISION> for more information.

=over

=item config()

    use Data::Dumper;

    print Dumper ( Math::BigInt->config() );
    print Math::BigInt->config()->{lib},"\n";

Returns a hash containing the configuration, e.g. the version number, lib
loaded etc. The following hash keys are currently filled in with the
appropriate information.

    key           Description
                  Example
    ============================================================
    lib           Name of the low-level math library
                  Math::BigInt::Calc
    lib_version   Version of low-level math library (see 'lib')
                  0.30
    class         The class name of config() you just called
                  Math::BigInt
    upgrade       To which class math operations might be
                  upgraded Math::BigFloat
    downgrade     To which class math operations might be
                  downgraded undef
    precision     Global precision
                  undef
    accuracy      Global accuracy
                  undef
    round_mode    Global round mode
                  even
    version       version number of the class you used
                  1.61
    div_scale     Fallback accuracy for div
                  40
    trap_nan      If true, traps creation of NaN via croak()
                  1
    trap_inf      If true, traps creation of +inf/-inf via croak()
                  1

The following values can be set by passing C<config()> a reference to a hash:

        trap_inf trap_nan
        upgrade downgrade precision accuracy round_mode div_scale

Example:

        $new_cfg = Math::BigInt->config(
            { trap_inf => 1, precision => 5 }
        );

=item accuracy()

    $x->accuracy(5);         # local for $x
    CLASS->accuracy(5);      # global for all members of CLASS
                             # Note: This also applies to new()!

    $A = $x->accuracy();     # read out accuracy that affects $x
    $A = CLASS->accuracy();  # read out global accuracy

Set or get the global or local accuracy, aka how many significant digits the
results have. If you set a global accuracy, then this also applies to new()!

Warning! The accuracy I<sticks>, e.g. once you created a number under the
influence of C<< CLASS->accuracy($A) >>, all results from math operations with
that number will also be rounded.

In most cases, you should probably round the results explicitly using one of
L</round()>, L</bround()> or L</bfround()> or by passing the desired accuracy
to the math operation as additional parameter:

    my $x = Math::BigInt->new(30000);
    my $y = Math::BigInt->new(7);
    print scalar $x->copy()->bdiv($y, 2);               # print 4300
    print scalar $x->copy()->bdiv($y)->bround(2);       # print 4300

Please see the section about L</ACCURACY and PRECISION> for further details.

Value must be greater than zero. Pass an undef value to disable it:

    $x->accuracy(undef);
    Math::BigInt->accuracy(undef);

Returns the current accuracy. For C<< $x->accuracy() >> it will return either
the local accuracy, or if not defined, the global. This means the return value
represents the accuracy that will be in effect for $x:

    $y = Math::BigInt->new(1234567);       # unrounded
    print Math::BigInt->accuracy(4),"\n";  # set 4, print 4
    $x = Math::BigInt->new(123456);        # $x will be automatic-
                                           # ally rounded!
    print "$x $y\n";                       # '123500 1234567'
    print $x->accuracy(),"\n";             # will be 4
    print $y->accuracy(),"\n";             # also 4, since
                                           # global is 4
    print Math::BigInt->accuracy(5),"\n";  # set to 5, print 5
    print $x->accuracy(),"\n";             # still 4
    print $y->accuracy(),"\n";             # 5, since global is 5

Note: Works also for subclasses like Math::BigFloat. Each class has it's own
globals separated from Math::BigInt, but it is possible to subclass
Math::BigInt and make the globals of the subclass aliases to the ones from
Math::BigInt.

=item precision()

    $x->precision(-2);          # local for $x, round at the second
                                # digit right of the dot
    $x->precision(2);           # ditto, round at the second digit
                                # left of the dot

    CLASS->precision(5);        # Global for all members of CLASS
                                # This also applies to new()!
    CLASS->precision(-5);       # ditto

    $P = CLASS->precision();    # read out global precision
    $P = $x->precision();       # read out precision that affects $x

Note: You probably want to use L</accuracy()> instead. With L</accuracy()> you
set the number of digits each result should have, with L</precision()> you
set the place where to round!

C<precision()> sets or gets the global or local precision, aka at which digit
before or after the dot to round all results. A set global precision also
applies to all newly created numbers!

In Math::BigInt, passing a negative number precision has no effect since no
numbers have digits after the dot. In L<Math::BigFloat>, it will round all
results to P digits after the dot.

Please see the section about L</ACCURACY and PRECISION> for further details.

Pass an undef value to disable it:

    $x->precision(undef);
    Math::BigInt->precision(undef);

Returns the current precision. For C<< $x->precision() >> it will return either
the local precision of $x, or if not defined, the global. This means the return
value represents the prevision that will be in effect for $x:

    $y = Math::BigInt->new(1234567);        # unrounded
    print Math::BigInt->precision(4),"\n";  # set 4, print 4
    $x = Math::BigInt->new(123456);  # will be automatically rounded
    print $x;                               # print "120000"!

Note: Works also for subclasses like L<Math::BigFloat>. Each class has its
own globals separated from Math::BigInt, but it is possible to subclass
Math::BigInt and make the globals of the subclass aliases to the ones from
Math::BigInt.

=item brsft()

    $x->brsft($y,$n);

Shifts $x right by $y in base $n. Default is base 2, used are usually 10 and
2, but others work, too.

Right shifting usually amounts to dividing $x by $n ** $y and truncating the
result:


    $x = Math::BigInt->new(10);
    $x->brsft(1);                       # same as $x >> 1: 5
    $x = Math::BigInt->new(1234);
    $x->brsft(2,10);                    # result 12

There is one exception, and that is base 2 with negative $x:


    $x = Math::BigInt->new(-5);
    print $x->brsft(1);

This will print -3, not -2 (as it would if you divide -5 by 2 and truncate the
result).

=item new()

    $x = Math::BigInt->new($str,$A,$P,$R);

Creates a new BigInt object from a scalar or another BigInt object. The
input is accepted as decimal, hex (with leading '0x') or binary (with leading
'0b').

See L</Input> for more info on accepted input formats.

=item from_oct()

    $x = Math::BigInt->from_oct("0775");      # input is octal

Interpret the input as an octal string and return the corresponding value. A
"0" (zero) prefix is optional. A single underscore character may be placed
right after the prefix, if present, or between any two digits. If the input is
invalid, a NaN is returned.

=item from_hex()

    $x = Math::BigInt->from_hex("0xcafe");    # input is hexadecimal

Interpret input as a hexadecimal string. A "0x" or "x" prefix is optional. A
single underscore character may be placed right after the prefix, if present,
or between any two digits. If the input is invalid, a NaN is returned.

=item from_bin()

    $x = Math::BigInt->from_bin("0b10011");   # input is binary

Interpret the input as a binary string. A "0b" or "b" prefix is optional. A
single underscore character may be placed right after the prefix, if present,
or between any two digits. If the input is invalid, a NaN is returned.

=item bnan()

    $x = Math::BigInt->bnan();

Creates a new BigInt object representing NaN (Not A Number).
If used on an object, it will set it to NaN:

    $x->bnan();

=item bzero()

    $x = Math::BigInt->bzero();

Creates a new BigInt object representing zero.
If used on an object, it will set it to zero:

    $x->bzero();

=item binf()

    $x = Math::BigInt->binf($sign);

Creates a new BigInt object representing infinity. The optional argument is
either '-' or '+', indicating whether you want infinity or minus infinity.
If used on an object, it will set it to infinity:

    $x->binf();
    $x->binf('-');

=item bone()

    $x = Math::BigInt->binf($sign);

Creates a new BigInt object representing one. The optional argument is
either '-' or '+', indicating whether you want one or minus one.
If used on an object, it will set it to one:

    $x->bone();         # +1
    $x->bone('-');              # -1

=item is_one()/is_zero()/is_nan()/is_inf()

    $x->is_zero();              # true if arg is +0
    $x->is_nan();               # true if arg is NaN
    $x->is_one();               # true if arg is +1
    $x->is_one('-');            # true if arg is -1
    $x->is_inf();               # true if +inf
    $x->is_inf('-');            # true if -inf (sign is default '+')

These methods all test the BigInt for being one specific value and return
true or false depending on the input. These are faster than doing something
like:

    if ($x == 0)

=item is_pos()/is_neg()/is_positive()/is_negative()

    $x->is_pos();                       # true if > 0
    $x->is_neg();                       # true if < 0

The methods return true if the argument is positive or negative, respectively.
C<NaN> is neither positive nor negative, while C<+inf> counts as positive, and
C<-inf> is negative. A C<zero> is neither positive nor negative.

These methods are only testing the sign, and not the value.

C<is_positive()> and C<is_negative()> are aliases to C<is_pos()> and
C<is_neg()>, respectively. C<is_positive()> and C<is_negative()> were
introduced in v1.36, while C<is_pos()> and C<is_neg()> were only introduced
in v1.68.

=item is_odd()/is_even()/is_int()

    $x->is_odd();               # true if odd, false for even
    $x->is_even();              # true if even, false for odd
    $x->is_int();               # true if $x is an integer

The return true when the argument satisfies the condition. C<NaN>, C<+inf>,
C<-inf> are not integers and are neither odd nor even.

In BigInt, all numbers except C<NaN>, C<+inf> and C<-inf> are integers.

=item bcmp()

    $x->bcmp($y);

Compares $x with $y and takes the sign into account.
Returns -1, 0, 1 or undef.

=item bacmp()

    $x->bacmp($y);

Compares $x with $y while ignoring their sign. Returns -1, 0, 1 or undef.

=item sign()

    $x->sign();

Return the sign, of $x, meaning either C<+>, C<->, C<-inf>, C<+inf> or NaN.

If you want $x to have a certain sign, use one of the following methods:

    $x->babs();                 # '+'
    $x->babs()->bneg();         # '-'
    $x->bnan();                 # 'NaN'
    $x->binf();                 # '+inf'
    $x->binf('-');              # '-inf'

=item digit()

    $x->digit($n);       # return the nth digit, counting from right

If C<$n> is negative, returns the digit counting from left.

=item bneg()

    $x->bneg();

Negate the number, e.g. change the sign between '+' and '-', or between '+inf'
and '-inf', respectively. Does nothing for NaN or zero.

=item babs()

    $x->babs();

Set the number to its absolute value, e.g. change the sign from '-' to '+'
and from '-inf' to '+inf', respectively. Does nothing for NaN or positive
numbers.

=item bsgn()

    $x->bsgn();

Signum function. Set the number to -1, 0, or 1, depending on whether the
number is negative, zero, or positive, respectively. Does not modify NaNs.

=item bnorm()

    $x->bnorm();                        # normalize (no-op)

=item bnot()

    $x->bnot();

Two's complement (bitwise not). This is equivalent to

    $x->binc()->bneg();

but faster.

=item binc()

    $x->binc();                 # increment x by 1

=item bdec()

    $x->bdec();                 # decrement x by 1

=item badd()

    $x->badd($y);               # addition (add $y to $x)

=item bsub()

    $x->bsub($y);               # subtraction (subtract $y from $x)

=item bmul()

    $x->bmul($y);               # multiplication (multiply $x by $y)

=item bmuladd()

    $x->bmuladd($y,$z);

Multiply $x by $y, and then add $z to the result,

This method was added in v1.87 of Math::BigInt (June 2007).

=item bdiv()

    $x->bdiv($y);               # divide, set $x to quotient

Returns $x divided by $y. In list context, does floored division (F-division),
where the quotient is the greatest integer less than or equal to the quotient
of the two operands. Consequently, the remainder is either zero or has the same
sign as the second operand. In scalar context, only the quotient is returned.

=item bmod()

    $x->bmod($y);               # modulus (x % y)

Returns $x modulo $y. When $x is finite, and $y is finite and non-zero, the
result is identical to the remainder after floored division (F-division), i.e.,
identical to the result from Perl's % operator.

=item bmodinv()

    $x->bmodinv($mod);          # modular multiplicative inverse

Returns the multiplicative inverse of C<$x> modulo C<$mod>. If

    $y = $x -> copy() -> bmodinv($mod)

then C<$y> is the number closest to zero, and with the same sign as C<$mod>,
satisfying

    ($x * $y) % $mod = 1 % $mod

If C<$x> and C<$y> are non-zero, they must be relative primes, i.e.,
C<bgcd($y, $mod)==1>. 'C<NaN>' is returned when no modular multiplicative
inverse exists.

=item bmodpow()

    $num->bmodpow($exp,$mod);           # modular exponentiation
                                        # ($num**$exp % $mod)

Returns the value of C<$num> taken to the power C<$exp> in the modulus
C<$mod> using binary exponentiation.  C<bmodpow> is far superior to
writing

    $num ** $exp % $mod

because it is much faster - it reduces internal variables into
the modulus whenever possible, so it operates on smaller numbers.

C<bmodpow> also supports negative exponents.

    bmodpow($num, -1, $mod)

is exactly equivalent to

    bmodinv($num, $mod)

=item bpow()

    $x->bpow($y);                     # power of arguments (x ** y)

=item blog()

    $x->blog($base, $accuracy);   # logarithm of x to the base $base

If C<$base> is not defined, Euler's number (e) is used:

    print $x->blog(undef, 100);       # log(x) to 100 digits

=item bexp()

    $x->bexp($accuracy);              # calculate e ** X

Calculates the expression C<e ** $x> where C<e> is Euler's number.

This method was added in v1.82 of Math::BigInt (April 2007).

See also L</blog()>.

=item bnok()

    $x->bnok($y);         # x over y (binomial coefficient n over k)

Calculates the binomial coefficient n over k, also called the "choose"
function. The result is equivalent to:

        ( n )      n!
        | - |  = -------
        ( k )    k!(n-k)!

This method was added in v1.84 of Math::BigInt (April 2007).

=item bpi()

    print Math::BigInt->bpi(100), "\n";         # 3

Returns PI truncated to an integer, with the argument being ignored. This means
under BigInt this always returns C<3>.

If upgrading is in effect, returns PI, rounded to N digits with the
current rounding mode:

    use Math::BigFloat;
    use Math::BigInt upgrade => Math::BigFloat;
    print Math::BigInt->bpi(3), "\n";           # 3.14
    print Math::BigInt->bpi(100), "\n";         # 3.1415....

This method was added in v1.87 of Math::BigInt (June 2007).

=item bcos()

    my $x = Math::BigInt->new(1);
    print $x->bcos(100), "\n";

Calculate the cosinus of $x, modifying $x in place.

In BigInt, unless upgrading is in effect, the result is truncated to an
integer.

This method was added in v1.87 of Math::BigInt (June 2007).

=item bsin()

    my $x = Math::BigInt->new(1);
    print $x->bsin(100), "\n";

Calculate the sinus of $x, modifying $x in place.

In BigInt, unless upgrading is in effect, the result is truncated to an
integer.

This method was added in v1.87 of Math::BigInt (June 2007).

=item batan2()

    my $x = Math::BigInt->new(1);
    my $y = Math::BigInt->new(1);
    print $y->batan2($x), "\n";

Calculate the arcus tangens of C<$y> divided by C<$x>, modifying $y in place.

In BigInt, unless upgrading is in effect, the result is truncated to an
integer.

This method was added in v1.87 of Math::BigInt (June 2007).

=item batan()

    my $x = Math::BigFloat->new(0.5);
    print $x->batan(100), "\n";

Calculate the arcus tangens of $x, modifying $x in place.

In BigInt, unless upgrading is in effect, the result is truncated to an
integer.

This method was added in v1.87 of Math::BigInt (June 2007).

=item blsft()

    $x->blsft($y);              # left shift in base 2
    $x->blsft($y,$n);           # left shift, in base $n (like 10)

=item brsft()

    $x->brsft($y);              # right shift in base 2
    $x->brsft($y,$n);           # right shift, in base $n (like 10)

=item band()

    $x->band($y);               # bitwise and

=item bior()

    $x->bior($y);               # bitwise inclusive or

=item bxor()

    $x->bxor($y);               # bitwise exclusive or

=item bnot()

    $x->bnot();                 # bitwise not (two's complement)

=item bsqrt()

    $x->bsqrt();                # calculate square-root

=item broot()

    $x->broot($N);

Calculates the N'th root of C<$x>.

=item bfac()

    $x->bfac();                 # factorial of $x (1*2*3*4*..$x)

=item round()

    $x->round($A,$P,$round_mode);

Round $x to accuracy C<$A> or precision C<$P> using the round mode
C<$round_mode>.

=item bround()

    $x->bround($N);               # accuracy: preserve $N digits

=item bfround()

    $x->bfround($N);

If N is > 0, rounds to the Nth digit from the left. If N < 0, rounds to
the Nth digit after the dot. Since BigInts are integers, the case N < 0
is a no-op for them.

Examples:

        Input           N               Result
        ===================================================
        123456.123456   3               123500
        123456.123456   2               123450
        123456.123456   -2              123456.12
        123456.123456   -3              123456.123

=item bfloor()

    $x->bfloor();

Round $x towards minus infinity (i.e., set $x to the largest integer less than
or equal to $x). This is a no-op in BigInt, but changes $x in BigFloat, if $x
is not an integer.

=item bceil()

    $x->bceil();

Round $x towards plus infinity (i.e., set $x to the smallest integer greater
than or equal to $x). This is a no-op in BigInt, but changes $x in BigFloat, if
$x is not an integer.

=item bint()

    $x->bint();

Round $x towards zero. This is a no-op in BigInt, but changes $x in BigFloat,
if $x is not an integer.

=item bgcd()

    bgcd(@values);           # greatest common divisor (no OO style)

=item blcm()

    blcm(@values);           # lowest common multiple (no OO style)

=item length()

    $x->length();
    ($xl,$fl) = $x->length();

Returns the number of digits in the decimal representation of the number.
In list context, returns the length of the integer and fraction part. For
BigInt's, the length of the fraction part will always be 0.

=item exponent()

    $x->exponent();

Return the exponent of $x as BigInt.

=item mantissa()

    $x->mantissa();

Return the signed mantissa of $x as BigInt.

=item parts()

    $x->parts();        # return (mantissa,exponent) as BigInt

=item copy()

    $x->copy();         # make a true copy of $x (unlike $y = $x;)

=item as_int()

=item as_number()

These methods are called when Math::BigInt encounters an object it doesn't know
how to handle. For instance, assume $x is a Math::BigInt, or subclass thereof,
and $y is defined, but not a Math::BigInt, or subclass thereof. If you do

    $x -> badd($y);

$y needs to be converted into an object that $x can deal with. This is done by
first checking if $y is something that $x might be upgraded to. If that is the
case, no further attempts are made. The next is to see if $y supports the
method C<as_int()>. If it does, C<as_int()> is called, but if it doesn't, the
next thing is to see if $y supports the method C<as_number()>. If it does,
C<as_number()> is called. The method C<as_int()> (and C<as_number()>) is
expected to return either an object that has the same class as $x, a subclass
thereof, or a string that C<ref($x)-E<gt>new()> can parse to create an object.

C<as_number()> is an alias to C<as_int()>. C<as_number> was introduced in
v1.22, while C<as_int()> was introduced in v1.68.

In Math::BigInt, C<as_int()> has the same effect as C<copy()>.

=item bstr()

    $x->bstr();

Returns a normalized string representation of C<$x>.

=item bsstr()

    $x->bsstr();     # normalized string in scientific notation

=item as_hex()

    $x->as_hex();    # as signed hexadecimal string with prefixed 0x

=item as_bin()

    $x->as_bin();    # as signed binary string with prefixed 0b

=item as_oct()

    $x->as_oct();    # as signed octal string with prefixed 0

=item numify()

        print $x->numify();

This returns a normal Perl scalar from $x. It is used automatically
whenever a scalar is needed, for instance in array index operations.

This loses precision, to avoid this use L</as_int()> instead.

=item modify()

    $x->modify('bpowd');

This method returns 0 if the object can be modified with the given
operation, or 1 if not.

This is used for instance by L<Math::BigInt::Constant>.

=item upgrade()/downgrade()

Set/get the class for downgrade/upgrade operations. Thuis is used
for instance by L<bignum>. The defaults are '', thus the following
operation will create a BigInt, not a BigFloat:

        my $i = Math::BigInt->new(123);
        my $f = Math::BigFloat->new('123.1');

        print $i + $f,"\n";                     # print 246

=item div_scale()

Set/get the number of digits for the default precision in divide
operations.

=item round_mode()

Set/get the current round mode.

=back

=head1 ACCURACY and PRECISION

Since version v1.33, Math::BigInt and Math::BigFloat have full support for
accuracy and precision based rounding, both automatically after every
operation, as well as manually.

This section describes the accuracy/precision handling in Math::Big* as it
used to be and as it is now, complete with an explanation of all terms and
abbreviations.

Not yet implemented things (but with correct description) are marked with '!',
things that need to be answered are marked with '?'.

In the next paragraph follows a short description of terms used here (because
these may differ from terms used by others people or documentation).

During the rest of this document, the shortcuts A (for accuracy), P (for
precision), F (fallback) and R (rounding mode) will be used.

=head2 Precision P

A fixed number of digits before (positive) or after (negative)
the decimal point. For example, 123.45 has a precision of -2. 0 means an
integer like 123 (or 120). A precision of 2 means two digits to the left
of the decimal point are zero, so 123 with P = 1 becomes 120. Note that
numbers with zeros before the decimal point may have different precisions,
because 1200 can have p = 0, 1 or 2 (depending on what the initial value
was). It could also have p < 0, when the digits after the decimal point
are zero.

The string output (of floating point numbers) will be padded with zeros:

        Initial value   P       A       Result          String
        ------------------------------------------------------------
        1234.01         -3              1000            1000
        1234            -2              1200            1200
        1234.5          -1              1230            1230
        1234.001        1               1234            1234.0
        1234.01         0               1234            1234
        1234.01         2               1234.01         1234.01
        1234.01         5               1234.01         1234.01000

For BigInts, no padding occurs.

=head2 Accuracy A

Number of significant digits. Leading zeros are not counted. A
number may have an accuracy greater than the non-zero digits
when there are zeros in it or trailing zeros. For example, 123.456 has
A of 6, 10203 has 5, 123.0506 has 7, 123.450000 has 8 and 0.000123 has 3.

The string output (of floating point numbers) will be padded with zeros:

        Initial value   P       A       Result          String
        ------------------------------------------------------------
        1234.01                 3       1230            1230
        1234.01                 6       1234.01         1234.01
        1234.1                  8       1234.1          1234.1000

For BigInts, no padding occurs.

=head2 Fallback F

When both A and P are undefined, this is used as a fallback accuracy when
dividing numbers.

=head2 Rounding mode R

When rounding a number, different 'styles' or 'kinds'
of rounding are possible. (Note that random rounding, as in
Math::Round, is not implemented.)

=over

=item 'trunc'

truncation invariably removes all digits following the
rounding place, replacing them with zeros. Thus, 987.65 rounded
to tens (P=1) becomes 980, and rounded to the fourth sigdig
becomes 987.6 (A=4). 123.456 rounded to the second place after the
decimal point (P=-2) becomes 123.46.

All other implemented styles of rounding attempt to round to the
"nearest digit." If the digit D immediately to the right of the
rounding place (skipping the decimal point) is greater than 5, the
number is incremented at the rounding place (possibly causing a
cascade of incrementation): e.g. when rounding to units, 0.9 rounds
to 1, and -19.9 rounds to -20. If D < 5, the number is similarly
truncated at the rounding place: e.g. when rounding to units, 0.4
rounds to 0, and -19.4 rounds to -19.

However the results of other styles of rounding differ if the
digit immediately to the right of the rounding place (skipping the
decimal point) is 5 and if there are no digits, or no digits other
than 0, after that 5. In such cases:

=item 'even'

rounds the digit at the rounding place to 0, 2, 4, 6, or 8
if it is not already. E.g., when rounding to the first sigdig, 0.45
becomes 0.4, -0.55 becomes -0.6, but 0.4501 becomes 0.5.

=item 'odd'

rounds the digit at the rounding place to 1, 3, 5, 7, or 9 if
it is not already. E.g., when rounding to the first sigdig, 0.45
becomes 0.5, -0.55 becomes -0.5, but 0.5501 becomes 0.6.

=item '+inf'

round to plus infinity, i.e. always round up. E.g., when
rounding to the first sigdig, 0.45 becomes 0.5, -0.55 becomes -0.5,
and 0.4501 also becomes 0.5.

=item '-inf'

round to minus infinity, i.e. always round down. E.g., when
rounding to the first sigdig, 0.45 becomes 0.4, -0.55 becomes -0.6,
but 0.4501 becomes 0.5.

=item 'zero'

round to zero, i.e. positive numbers down, negative ones up.
E.g., when rounding to the first sigdig, 0.45 becomes 0.4, -0.55
becomes -0.5, but 0.4501 becomes 0.5.

=item 'common'

round up if the digit immediately to the right of the rounding place
is 5 or greater, otherwise round down. E.g., 0.15 becomes 0.2 and
0.149 becomes 0.1.

=back

The handling of A & P in MBI/MBF (the old core code shipped with Perl
versions <= 5.7.2) is like this:

=over

=item Precision

  * bfround($p) is able to round to $p number of digits after the decimal
    point
  * otherwise P is unused

=item Accuracy (significant digits)

  * bround($a) rounds to $a significant digits
  * only bdiv() and bsqrt() take A as (optional) parameter
    + other operations simply create the same number (bneg etc), or
      more (bmul) of digits
    + rounding/truncating is only done when explicitly calling one
      of bround or bfround, and never for BigInt (not implemented)
  * bsqrt() simply hands its accuracy argument over to bdiv.
  * the documentation and the comment in the code indicate two
    different ways on how bdiv() determines the maximum number
    of digits it should calculate, and the actual code does yet
    another thing
    POD:
      max($Math::BigFloat::div_scale,length(dividend)+length(divisor))
    Comment:
      result has at most max(scale, length(dividend), length(divisor)) digits
    Actual code:
      scale = max(scale, length(dividend)-1,length(divisor)-1);
      scale += length(divisor) - length(dividend);
    So for lx = 3, ly = 9, scale = 10, scale will actually be 16 (10
    So for lx = 3, ly = 9, scale = 10, scale will actually be 16
    (10+9-3). Actually, the 'difference' added to the scale is cal-
    culated from the number of "significant digits" in dividend and
    divisor, which is derived by looking at the length of the man-
    tissa. Which is wrong, since it includes the + sign (oops) and
    actually gets 2 for '+100' and 4 for '+101'. Oops again. Thus
    124/3 with div_scale=1 will get you '41.3' based on the strange
    assumption that 124 has 3 significant digits, while 120/7 will
    get you '17', not '17.1' since 120 is thought to have 2 signif-
    icant digits. The rounding after the division then uses the
    remainder and $y to determine whether it must round up or down.
 ?  I have no idea which is the right way. That's why I used a slightly more
 ?  simple scheme and tweaked the few failing testcases to match it.

=back

This is how it works now:

=over

=item Setting/Accessing

  * You can set the A global via Math::BigInt->accuracy() or
    Math::BigFloat->accuracy() or whatever class you are using.
  * You can also set P globally by using Math::SomeClass->precision()
    likewise.
  * Globals are classwide, and not inherited by subclasses.
  * to undefine A, use Math::SomeCLass->accuracy(undef);
  * to undefine P, use Math::SomeClass->precision(undef);
  * Setting Math::SomeClass->accuracy() clears automatically
    Math::SomeClass->precision(), and vice versa.
  * To be valid, A must be > 0, P can have any value.
  * If P is negative, this means round to the P'th place to the right of the
    decimal point; positive values mean to the left of the decimal point.
    P of 0 means round to integer.
  * to find out the current global A, use Math::SomeClass->accuracy()
  * to find out the current global P, use Math::SomeClass->precision()
  * use $x->accuracy() respective $x->precision() for the local
    setting of $x.
  * Please note that $x->accuracy() respective $x->precision()
    return eventually defined global A or P, when $x's A or P is not
    set.

=item Creating numbers

  * When you create a number, you can give the desired A or P via:
    $x = Math::BigInt->new($number,$A,$P);
  * Only one of A or P can be defined, otherwise the result is NaN
  * If no A or P is give ($x = Math::BigInt->new($number) form), then the
    globals (if set) will be used. Thus changing the global defaults later on
    will not change the A or P of previously created numbers (i.e., A and P of
    $x will be what was in effect when $x was created)
  * If given undef for A and P, NO rounding will occur, and the globals will
    NOT be used. This is used by subclasses to create numbers without
    suffering rounding in the parent. Thus a subclass is able to have its own
    globals enforced upon creation of a number by using
    $x = Math::BigInt->new($number,undef,undef):

        use Math::BigInt::SomeSubclass;
        use Math::BigInt;

        Math::BigInt->accuracy(2);
        Math::BigInt::SomeSubClass->accuracy(3);
        $x = Math::BigInt::SomeSubClass->new(1234);

    $x is now 1230, and not 1200. A subclass might choose to implement
    this otherwise, e.g. falling back to the parent's A and P.

=item Usage

  * If A or P are enabled/defined, they are used to round the result of each
    operation according to the rules below
  * Negative P is ignored in Math::BigInt, since BigInts never have digits
    after the decimal point
  * Math::BigFloat uses Math::BigInt internally, but setting A or P inside
    Math::BigInt as globals does not tamper with the parts of a BigFloat.
    A flag is used to mark all Math::BigFloat numbers as 'never round'.

=item Precedence

  * It only makes sense that a number has only one of A or P at a time.
    If you set either A or P on one object, or globally, the other one will
    be automatically cleared.
  * If two objects are involved in an operation, and one of them has A in
    effect, and the other P, this results in an error (NaN).
  * A takes precedence over P (Hint: A comes before P).
    If neither of them is defined, nothing is used, i.e. the result will have
    as many digits as it can (with an exception for bdiv/bsqrt) and will not
    be rounded.
  * There is another setting for bdiv() (and thus for bsqrt()). If neither of
    A or P is defined, bdiv() will use a fallback (F) of $div_scale digits.
    If either the dividend's or the divisor's mantissa has more digits than
    the value of F, the higher value will be used instead of F.
    This is to limit the digits (A) of the result (just consider what would
    happen with unlimited A and P in the case of 1/3 :-)
  * bdiv will calculate (at least) 4 more digits than required (determined by
    A, P or F), and, if F is not used, round the result
    (this will still fail in the case of a result like 0.12345000000001 with A
    or P of 5, but this can not be helped - or can it?)
  * Thus you can have the math done by on Math::Big* class in two modi:
    + never round (this is the default):
      This is done by setting A and P to undef. No math operation
      will round the result, with bdiv() and bsqrt() as exceptions to guard
      against overflows. You must explicitly call bround(), bfround() or
      round() (the latter with parameters).
      Note: Once you have rounded a number, the settings will 'stick' on it
      and 'infect' all other numbers engaged in math operations with it, since
      local settings have the highest precedence. So, to get SaferRound[tm],
      use a copy() before rounding like this:

        $x = Math::BigFloat->new(12.34);
        $y = Math::BigFloat->new(98.76);
        $z = $x * $y;                           # 1218.6984
        print $x->copy()->bround(3);            # 12.3 (but A is now 3!)
        $z = $x * $y;                           # still 1218.6984, without
                                                # copy would have been 1210!

    + round after each op:
      After each single operation (except for testing like is_zero()), the
      method round() is called and the result is rounded appropriately. By
      setting proper values for A and P, you can have all-the-same-A or
      all-the-same-P modes. For example, Math::Currency might set A to undef,
      and P to -2, globally.

 ?Maybe an extra option that forbids local A & P settings would be in order,
 ?so that intermediate rounding does not 'poison' further math?

=item Overriding globals

  * you will be able to give A, P and R as an argument to all the calculation
    routines; the second parameter is A, the third one is P, and the fourth is
    R (shift right by one for binary operations like badd). P is used only if
    the first parameter (A) is undefined. These three parameters override the
    globals in the order detailed as follows, i.e. the first defined value
    wins:
    (local: per object, global: global default, parameter: argument to sub)
      + parameter A
      + parameter P
      + local A (if defined on both of the operands: smaller one is taken)
      + local P (if defined on both of the operands: bigger one is taken)
      + global A
      + global P
      + global F
  * bsqrt() will hand its arguments to bdiv(), as it used to, only now for two
    arguments (A and P) instead of one

=item Local settings

  * You can set A or P locally by using $x->accuracy() or
    $x->precision()
    and thus force different A and P for different objects/numbers.
  * Setting A or P this way immediately rounds $x to the new value.
  * $x->accuracy() clears $x->precision(), and vice versa.

=item Rounding

  * the rounding routines will use the respective global or local settings.
    bround() is for accuracy rounding, while bfround() is for precision
  * the two rounding functions take as the second parameter one of the
    following rounding modes (R):
    'even', 'odd', '+inf', '-inf', 'zero', 'trunc', 'common'
  * you can set/get the global R by using Math::SomeClass->round_mode()
    or by setting $Math::SomeClass::round_mode
  * after each operation, $result->round() is called, and the result may
    eventually be rounded (that is, if A or P were set either locally,
    globally or as parameter to the operation)
  * to manually round a number, call $x->round($A,$P,$round_mode);
    this will round the number by using the appropriate rounding function
    and then normalize it.
  * rounding modifies the local settings of the number:

        $x = Math::BigFloat->new(123.456);
        $x->accuracy(5);
        $x->bround(4);

    Here 4 takes precedence over 5, so 123.5 is the result and $x->accuracy()
    will be 4 from now on.

=item Default values

  * R: 'even'
  * F: 40
  * A: undef
  * P: undef

=item Remarks

  * The defaults are set up so that the new code gives the same results as
    the old code (except in a few cases on bdiv):
    + Both A and P are undefined and thus will not be used for rounding
      after each operation.
    + round() is thus a no-op, unless given extra parameters A and P

=back

=head1 Infinity and Not a Number

While BigInt has extensive handling of inf and NaN, certain quirks remain.

=over

=item oct()/hex()

These perl routines currently (as of Perl v.5.8.6) cannot handle passed
inf.

        te@linux:~> perl -wle 'print 2 ** 3333'
        Inf
        te@linux:~> perl -wle 'print 2 ** 3333 == 2 ** 3333'
        1
        te@linux:~> perl -wle 'print oct(2 ** 3333)'
        0
        te@linux:~> perl -wle 'print hex(2 ** 3333)'
        Illegal hexadecimal digit 'I' ignored at -e line 1.
        0

The same problems occur if you pass them Math::BigInt->binf() objects. Since
overloading these routines is not possible, this cannot be fixed from BigInt.

=item ==, !=, <, >, <=, >= with NaNs

BigInt's bcmp() routine currently returns undef to signal that a NaN was
involved in a comparison. However, the overload code turns that into
either 1 or '' and thus operations like C<< NaN != NaN >> might return
wrong values.

=item log(-inf)

C<< log(-inf) >> is highly weird. Since log(-x)=pi*i+log(x), then
log(-inf)=pi*i+inf. However, since the imaginary part is finite, the real
infinity "overshadows" it, so the number might as well just be infinity.
However, the result is a complex number, and since BigInt/BigFloat can only
have real numbers as results, the result is NaN.

=item exp(), cos(), sin(), atan2()

These all might have problems handling infinity right.

=back

=head1 INTERNALS

The actual numbers are stored as unsigned big integers (with separate sign).

You should neither care about nor depend on the internal representation; it
might change without notice. Use B<ONLY> method calls like C<< $x->sign(); >>
instead relying on the internal representation.

=head2 MATH LIBRARY

Math with the numbers is done (by default) by a module called
C<Math::BigInt::Calc>. This is equivalent to saying:

        use Math::BigInt try => 'Calc';

You can change this backend library by using:

        use Math::BigInt try => 'GMP';

B<Note>: General purpose packages should not be explicit about the library
to use; let the script author decide which is best.

If your script works with huge numbers and Calc is too slow for them,
you can also for the loading of one of these libraries and if none
of them can be used, the code will die:

        use Math::BigInt only => 'GMP,Pari';

The following would first try to find Math::BigInt::Foo, then
Math::BigInt::Bar, and when this also fails, revert to Math::BigInt::Calc:

        use Math::BigInt try => 'Foo,Math::BigInt::Bar';

The library that is loaded last will be used. Note that this can be
overwritten at any time by loading a different library, and numbers
constructed with different libraries cannot be used in math operations
together.

=head3 What library to use?

B<Note>: General purpose packages should not be explicit about the library
to use; let the script author decide which is best.

L<Math::BigInt::GMP> and L<Math::BigInt::Pari> are in cases involving big
numbers much faster than Calc, however it is slower when dealing with very
small numbers (less than about 20 digits) and when converting very large
numbers to decimal (for instance for printing, rounding, calculating their
length in decimal etc).

So please select carefully what library you want to use.

Different low-level libraries use different formats to store the numbers.
However, you should B<NOT> depend on the number having a specific format
internally.

See the respective math library module documentation for further details.

=head2 SIGN

The sign is either '+', '-', 'NaN', '+inf' or '-inf'.

A sign of 'NaN' is used to represent the result when input arguments are not
numbers or as a result of 0/0. '+inf' and '-inf' represent plus respectively
minus infinity. You will get '+inf' when dividing a positive number by 0, and
'-inf' when dividing any negative number by 0.

=head2 mantissa(), exponent() and parts()

C<mantissa()> and C<exponent()> return the said parts of the BigInt such
that:

        $m = $x->mantissa();
        $e = $x->exponent();
        $y = $m * ( 10 ** $e );
        print "ok\n" if $x == $y;

C<< ($m,$e) = $x->parts() >> is just a shortcut that gives you both of them
in one go. Both the returned mantissa and exponent have a sign.

Currently, for BigInts C<$e> is always 0, except +inf and -inf, where it is
C<+inf>; and for NaN, where it is C<NaN>; and for C<$x == 0>, where it is C<1>
(to be compatible with Math::BigFloat's internal representation of a zero as
C<0E1>).

C<$m> is currently just a copy of the original number. The relation between
C<$e> and C<$m> will stay always the same, though their real values might
change.

=head1 EXAMPLES

  use Math::BigInt;

  sub bigint { Math::BigInt->new(shift); }

  $x = Math::BigInt->bstr("1234")       # string "1234"
  $x = "$x";                            # same as bstr()
  $x = Math::BigInt->bneg("1234");      # BigInt "-1234"
  $x = Math::BigInt->babs("-12345");    # BigInt "12345"
  $x = Math::BigInt->bnorm("-0.00");    # BigInt "0"
  $x = bigint(1) + bigint(2);           # BigInt "3"
  $x = bigint(1) + "2";                 # ditto (auto-BigIntify of "2")
  $x = bigint(1);                       # BigInt "1"
  $x = $x + 5 / 2;                      # BigInt "3"
  $x = $x ** 3;                         # BigInt "27"
  $x *= 2;                              # BigInt "54"
  $x = Math::BigInt->new(0);            # BigInt "0"
  $x--;                                 # BigInt "-1"
  $x = Math::BigInt->badd(4,5)          # BigInt "9"
  print $x->bsstr();                    # 9e+0

Examples for rounding:

  use Math::BigFloat;
  use Test::More;

  $x = Math::BigFloat->new(123.4567);
  $y = Math::BigFloat->new(123.456789);
  Math::BigFloat->accuracy(4);          # no more A than 4

  is ($x->copy()->bround(),123.4);      # even rounding
  print $x->copy()->bround(),"\n";      # 123.4
  Math::BigFloat->round_mode('odd');    # round to odd
  print $x->copy()->bround(),"\n";      # 123.5
  Math::BigFloat->accuracy(5);          # no more A than 5
  Math::BigFloat->round_mode('odd');    # round to odd
  print $x->copy()->bround(),"\n";      # 123.46
  $y = $x->copy()->bround(4),"\n";      # A = 4: 123.4
  print "$y, ",$y->accuracy(),"\n";     # 123.4, 4

  Math::BigFloat->accuracy(undef);      # A not important now
  Math::BigFloat->precision(2);         # P important
  print $x->copy()->bnorm(),"\n";       # 123.46
  print $x->copy()->bround(),"\n";      # 123.46

Examples for converting:

  my $x = Math::BigInt->new('0b1'.'01' x 123);
  print "bin: ",$x->as_bin()," hex:",$x->as_hex()," dec: ",$x,"\n";

=head1 Autocreating constants

After C<use Math::BigInt ':constant'> all the B<integer> decimal, hexadecimal
and binary constants in the given scope are converted to C<Math::BigInt>.
This conversion happens at compile time.

In particular,

  perl -MMath::BigInt=:constant -e 'print 2**100,"\n"'

prints the integer value of C<2**100>. Note that without conversion of
constants the expression 2**100 will be calculated as perl scalar.

Please note that strings and floating point constants are not affected,
so that

        use Math::BigInt qw/:constant/;

        $x = 1234567890123456789012345678901234567890
                + 123456789123456789;
        $y = '1234567890123456789012345678901234567890'
                + '123456789123456789';

do not work. You need an explicit Math::BigInt->new() around one of the
operands. You should also quote large constants to protect loss of precision:

        use Math::BigInt;

        $x = Math::BigInt->new('1234567889123456789123456789123456789');

Without the quotes Perl would convert the large number to a floating point
constant at compile time and then hand the result to BigInt, which results in
an truncated result or a NaN.

This also applies to integers that look like floating point constants:

        use Math::BigInt ':constant';

        print ref(123e2),"\n";
        print ref(123.2e2),"\n";

will print nothing but newlines. Use either L<bignum> or L<Math::BigFloat>
to get this to work.

=head1 PERFORMANCE

Using the form $x += $y; etc over $x = $x + $y is faster, since a copy of $x
must be made in the second case. For long numbers, the copy can eat up to 20%
of the work (in the case of addition/subtraction, less for
multiplication/division). If $y is very small compared to $x, the form
$x += $y is MUCH faster than $x = $x + $y since making the copy of $x takes
more time then the actual addition.

With a technique called copy-on-write, the cost of copying with overload could
be minimized or even completely avoided. A test implementation of COW did show
performance gains for overloaded math, but introduced a performance loss due
to a constant overhead for all other operations. So Math::BigInt does currently
not COW.

The rewritten version of this module (vs. v0.01) is slower on certain
operations, like C<new()>, C<bstr()> and C<numify()>. The reason are that it
does now more work and handles much more cases. The time spent in these
operations is usually gained in the other math operations so that code on
the average should get (much) faster. If they don't, please contact the author.

Some operations may be slower for small numbers, but are significantly faster
for big numbers. Other operations are now constant (O(1), like C<bneg()>,
C<babs()> etc), instead of O(N) and thus nearly always take much less time.
These optimizations were done on purpose.

If you find the Calc module to slow, try to install any of the replacement
modules and see if they help you.

=head2 Alternative math libraries

You can use an alternative library to drive Math::BigInt. See the section
L</MATH LIBRARY> for more information.

For more benchmark results see L<http://bloodgate.com/perl/benchmarks.html>.

=head1 SUBCLASSING

=head2 Subclassing Math::BigInt

The basic design of Math::BigInt allows simple subclasses with very little
work, as long as a few simple rules are followed:

=over

=item *

The public API must remain consistent, i.e. if a sub-class is overloading
addition, the sub-class must use the same name, in this case badd(). The
reason for this is that Math::BigInt is optimized to call the object methods
directly.

=item *

The private object hash keys like C<< $x->{sign} >> may not be changed, but
additional keys can be added, like C<< $x->{_custom} >>.

=item *

Accessor functions are available for all existing object hash keys and should
be used instead of directly accessing the internal hash keys. The reason for
this is that Math::BigInt itself has a pluggable interface which permits it
to support different storage methods.

=back

More complex sub-classes may have to replicate more of the logic internal of
Math::BigInt if they need to change more basic behaviors. A subclass that
needs to merely change the output only needs to overload C<bstr()>.

All other object methods and overloaded functions can be directly inherited
from the parent class.

At the very minimum, any subclass will need to provide its own C<new()> and can
store additional hash keys in the object. There are also some package globals
that must be defined, e.g.:

  # Globals
  $accuracy = undef;
  $precision = -2;       # round to 2 decimal places
  $round_mode = 'even';
  $div_scale = 40;

Additionally, you might want to provide the following two globals to allow
auto-upgrading and auto-downgrading to work correctly:

  $upgrade = undef;
  $downgrade = undef;

This allows Math::BigInt to correctly retrieve package globals from the
subclass, like C<$SubClass::precision>.  See t/Math/BigInt/Subclass.pm or
t/Math/BigFloat/SubClass.pm completely functional subclass examples.

Don't forget to

        use overload;

in your subclass to automatically inherit the overloading from the parent. If
you like, you can change part of the overloading, look at Math::String for an
example.

=head1 UPGRADING

When used like this:

        use Math::BigInt upgrade => 'Foo::Bar';

certain operations will 'upgrade' their calculation and thus the result to
the class Foo::Bar. Usually this is used in conjunction with Math::BigFloat:

        use Math::BigInt upgrade => 'Math::BigFloat';

As a shortcut, you can use the module L<bignum>:

        use bignum;

Also good for one-liners:

        perl -Mbignum -le 'print 2 ** 255'

This makes it possible to mix arguments of different classes (as in 2.5 + 2)
as well es preserve accuracy (as in sqrt(3)).

Beware: This feature is not fully implemented yet.

=head2 Auto-upgrade

The following methods upgrade themselves unconditionally; that is if upgrade
is in effect, they will always hand up their work:

=over

=item bsqrt()

=item div()

=item blog()

=item bexp()

=item bpi()

=item bcos()

=item bsin()

=item batan2()

=item batan()

=back

All other methods upgrade themselves only when one (or all) of their
arguments are of the class mentioned in $upgrade.

=head1 EXPORTS

C<Math::BigInt> exports nothing by default, but can export the following methods:

        bgcd
        blcm

=head1 CAVEATS

Some things might not work as you expect them. Below is documented what is
known to be troublesome:

=over

=item bstr(), bsstr() and 'cmp'

Both C<bstr()> and C<bsstr()> as well as automated stringify via overload now
drop the leading '+'. The old code would return '+3', the new returns '3'.
This is to be consistent with Perl and to make C<cmp> (especially with
overloading) to work as you expect. It also solves problems with C<Test.pm>
and L<Test::More>, which stringify arguments before comparing them.

Mark Biggar said, when asked about to drop the '+' altogether, or make only
C<cmp> work:

        I agree (with the first alternative), don't add the '+' on positive
        numbers.  It's not as important anymore with the new internal
        form for numbers.  It made doing things like abs and neg easier,
        but those have to be done differently now anyway.

So, the following examples will now work all as expected:

        use Test::More tests => 1;
        use Math::BigInt;

        my $x = Math::BigInt -> new(3*3);
        my $y = Math::BigInt -> new(3*3);

        is ($x,3*3, 'multiplication');
        print "$x eq 9" if $x eq $y;
        print "$x eq 9" if $x eq '9';
        print "$x eq 9" if $x eq 3*3;

Additionally, the following still works:

        print "$x == 9" if $x == $y;
        print "$x == 9" if $x == 9;
        print "$x == 9" if $x == 3*3;

There is now a C<bsstr()> method to get the string in scientific notation aka
C<1e+2> instead of C<100>. Be advised that overloaded 'eq' always uses bstr()
for comparison, but Perl will represent some numbers as 100 and others
as 1e+308. If in doubt, convert both arguments to Math::BigInt before
comparing them as strings:

        use Test::More tests => 3;
        use Math::BigInt;

        $x = Math::BigInt->new('1e56'); $y = 1e56;
        is ($x,$y);                     # will fail
        is ($x->bsstr(),$y);            # okay
        $y = Math::BigInt->new($y);
        is ($x,$y);                     # okay

Alternatively, simply use C<< <=> >> for comparisons, this will get it
always right. There is not yet a way to get a number automatically represented
as a string that matches exactly the way Perl represents it.

See also the section about L<Infinity and Not a Number> for problems in
comparing NaNs.

=item int()

C<int()> will return (at least for Perl v5.7.1 and up) another BigInt, not a
Perl scalar:

        $x = Math::BigInt->new(123);
        $y = int($x);                           # BigInt 123
        $x = Math::BigFloat->new(123.45);
        $y = int($x);                           # BigInt 123

In all Perl versions you can use C<as_number()> or C<as_int> for the same
effect:

        $x = Math::BigFloat->new(123.45);
        $y = $x->as_number();                   # BigInt 123
        $y = $x->as_int();                      # ditto

This also works for other subclasses, like Math::String.

If you want a real Perl scalar, use C<numify()>:

        $y = $x->numify();                      # 123 as scalar

This is seldom necessary, though, because this is done automatically, like
when you access an array:

        $z = $array[$x];                        # does work automatically

=item length()

The following will probably not do what you expect:

        $c = Math::BigInt->new(123);
        print $c->length(),"\n";                # prints 30

It prints both the number of digits in the number and in the fraction part
since print calls C<length()> in list context. Use something like:

        print scalar $c->length(),"\n";         # prints 3

=item bdiv()

The following will probably not do what you expect:

        print $c->bdiv(10000),"\n";

It prints both quotient and remainder since print calls C<bdiv()> in list
context. Also, C<bdiv()> will modify $c, so be careful. You probably want
to use

        print $c / 10000,"\n";

or, if you want to  modify $c instead,

        print scalar $c->bdiv(10000),"\n";

The quotient is always the greatest integer less than or equal to the
real-valued quotient of the two operands, and the remainder (when it is
non-zero) always has the same sign as the second operand; so, for
example,

          1 / 4  => ( 0, 1)
          1 / -4 => (-1,-3)
         -3 / 4  => (-1, 1)
         -3 / -4 => ( 0,-3)
        -11 / 2  => (-5,1)
         11 /-2  => (-5,-1)

As a consequence, the behavior of the operator % agrees with the
behavior of Perl's built-in % operator (as documented in the perlop
manpage), and the equation

        $x == ($x / $y) * $y + ($x % $y)

holds true for any $x and $y, which justifies calling the two return
values of bdiv() the quotient and remainder. The only exception to this rule
are when $y == 0 and $x is negative, then the remainder will also be
negative. See below under "infinity handling" for the reasoning behind this.

Perl's 'use integer;' changes the behaviour of % and / for scalars, but will
not change BigInt's way to do things. This is because under 'use integer' Perl
will do what the underlying C thinks is right and this is different for each
system. If you need BigInt's behaving exactly like Perl's 'use integer', bug
the author to implement it ;)

=item infinity handling

Here are some examples that explain the reasons why certain results occur while
handling infinity:

The following table shows the result of the division and the remainder, so that
the equation above holds true. Some "ordinary" cases are strewn in to show more
clearly the reasoning:

        A /  B  =   C,     R so that C *    B +    R =    A
     =========================================================
        5 /   8 =   0,     5         0 *    8 +    5 =    5
        0 /   8 =   0,     0         0 *    8 +    0 =    0
        0 / inf =   0,     0         0 *  inf +    0 =    0
        0 /-inf =   0,     0         0 * -inf +    0 =    0
        5 / inf =   0,     5         0 *  inf +    5 =    5
        5 /-inf =   0,     5         0 * -inf +    5 =    5
        -5/ inf =   0,    -5         0 *  inf +   -5 =   -5
        -5/-inf =   0,    -5         0 * -inf +   -5 =   -5
       inf/   5 =  inf,    0       inf *    5 +    0 =  inf
      -inf/   5 = -inf,    0      -inf *    5 +    0 = -inf
       inf/  -5 = -inf,    0      -inf *   -5 +    0 =  inf
      -inf/  -5 =  inf,    0       inf *   -5 +    0 = -inf
         5/   5 =    1,    0         1 *    5 +    0 =    5
        -5/  -5 =    1,    0         1 *   -5 +    0 =   -5
       inf/ inf =    1,    0         1 *  inf +    0 =  inf
      -inf/-inf =    1,    0         1 * -inf +    0 = -inf
       inf/-inf =   -1,    0        -1 * -inf +    0 =  inf
      -inf/ inf =   -1,    0         1 * -inf +    0 = -inf
         8/   0 =  inf,    8       inf *    0 +    8 =    8
       inf/   0 =  inf,  inf       inf *    0 +  inf =  inf
         0/   0 =  NaN

These cases below violate the "remainder has the sign of the second of the two
arguments", since they wouldn't match up otherwise.

        A /  B  =   C,     R so that C *    B +    R =    A
     ========================================================
      -inf/   0 = -inf, -inf      -inf *    0 +  inf = -inf
        -8/   0 = -inf,   -8      -inf *    0 +    8 = -8

=item Modifying and =

Beware of:

        $x = Math::BigFloat->new(5);
        $y = $x;

It will not do what you think, e.g. making a copy of $x. Instead it just makes
a second reference to the B<same> object and stores it in $y. Thus anything
that modifies $x (except overloaded operators) will modify $y, and vice versa.
Or in other words, C<=> is only safe if you modify your BigInts only via
overloaded math. As soon as you use a method call it breaks:

        $x->bmul(2);
        print "$x, $y\n";       # prints '10, 10'

If you want a true copy of $x, use:

        $y = $x->copy();

You can also chain the calls like this, this will make first a copy and then
multiply it by 2:

        $y = $x->copy()->bmul(2);

See also the documentation for overload.pm regarding C<=>.

=item bpow

C<bpow()> (and the rounding functions) now modifies the first argument and
returns it, unlike the old code which left it alone and only returned the
result. This is to be consistent with C<badd()> etc. The first three will
modify $x, the last one won't:

        print bpow($x,$i),"\n";         # modify $x
        print $x->bpow($i),"\n";        # ditto
        print $x **= $i,"\n";           # the same
        print $x ** $i,"\n";            # leave $x alone

The form C<$x **= $y> is faster than C<$x = $x ** $y;>, though.

=item Overloading -$x

The following:

        $x = -$x;

is slower than

        $x->bneg();

since overload calls C<sub($x,0,1);> instead of C<neg($x)>. The first variant
needs to preserve $x since it does not know that it later will get overwritten.
This makes a copy of $x and takes O(N), but $x->bneg() is O(1).

=item Mixing different object types

With overloaded operators, it is the first (dominating) operand that determines
which method is called. Here are some examples showing what actually gets
called in various cases.

        use Math::BigInt;
        use Math::BigFloat;

        $mbf  = Math::BigFloat->new(5);
        $mbi2 = Math::BigInt->new(5);
        $mbi  = Math::BigInt->new(2);
                                        # what actually gets called:
        $float = $mbf + $mbi;           # $mbf->badd($mbi)
        $float = $mbf / $mbi;           # $mbf->bdiv($mbi)
        $integer = $mbi + $mbf;         # $mbi->badd($mbf)
        $integer = $mbi2 / $mbi;        # $mbi2->bdiv($mbi)
        $integer = $mbi2 / $mbf;        # $mbi2->bdiv($mbf)

For instance, Math::BigInt->bdiv() will always return a Math::BigInt, regardless of
whether the second operant is a Math::BigFloat. To get a Math::BigFloat you
either need to call the operation manually, make sure each operand already is a
Math::BigFloat, or cast to that type via Math::BigFloat->new():

        $float = Math::BigFloat->new($mbi2) / $mbi;     # = 2.5

Beware of casting the entire expression, as this would cast the
result, at which point it is too late:

        $float = Math::BigFloat->new($mbi2 / $mbi);     # = 2

Beware also of the order of more complicated expressions like:

        $integer = ($mbi2 + $mbi) / $mbf;               # int / float => int
        $integer = $mbi2 / Math::BigFloat->new($mbi);   # ditto

If in doubt, break the expression into simpler terms, or cast all operands
to the desired resulting type.

Scalar values are a bit different, since:

        $float = 2 + $mbf;
        $float = $mbf + 2;

will both result in the proper type due to the way the overloaded math works.

This section also applies to other overloaded math packages, like Math::String.

One solution to you problem might be autoupgrading|upgrading. See the
pragmas L<bignum>, L<bigint> and L<bigrat> for an easy way to do this.

=item bsqrt()

C<bsqrt()> works only good if the result is a big integer, e.g. the square
root of 144 is 12, but from 12 the square root is 3, regardless of rounding
mode. The reason is that the result is always truncated to an integer.

If you want a better approximation of the square root, then use:

        $x = Math::BigFloat->new(12);
        Math::BigFloat->precision(0);
        Math::BigFloat->round_mode('even');
        print $x->copy->bsqrt(),"\n";           # 4

        Math::BigFloat->precision(2);
        print $x->bsqrt(),"\n";                 # 3.46
        print $x->bsqrt(3),"\n";                # 3.464

=item brsft()

For negative numbers in base see also L<brsft|/brsft()>.

=back

=head1 BUGS

Please report any bugs or feature requests to
C<bug-math-bigint at rt.cpan.org>, or through the web interface at
L<https://rt.cpan.org/Ticket/Create.html?Queue=Math-BigInt>
(requires login).
We will be notified, and then you'll automatically be notified of progress on
your bug as I make changes.

=head1 SUPPORT

You can find documentation for this module with the perldoc command.

    perldoc Math::BigInt

You can also look for information at:

=over 4

=item * RT: CPAN's request tracker

L<https://rt.cpan.org/Public/Dist/Display.html?Name=Math-BigInt>

=item * AnnoCPAN: Annotated CPAN documentation

L<http://annocpan.org/dist/Math-BigInt>

=item * CPAN Ratings

L<http://cpanratings.perl.org/dist/Math-BigInt>

=item * Search CPAN

L<http://search.cpan.org/dist/Math-BigInt/>

=item * CPAN Testers Matrix

L<http://matrix.cpantesters.org/?dist=Math-BigInt>

=item * The Bignum mailing list

=over 4

=item * Post to mailing list

C<bignum at lists.scsys.co.uk>

=item * View mailing list

L<http://lists.scsys.co.uk/pipermail/bignum/>

=item * Subscribe/Unsubscribe

L<http://lists.scsys.co.uk/cgi-bin/mailman/listinfo/bignum>

=back

=back

=head1 LICENSE

This program is free software; you may redistribute it and/or modify it under
the same terms as Perl itself.

=head1 SEE ALSO

L<Math::BigFloat> and L<Math::BigRat> as well as the backends
L<Math::BigInt::FastCalc>, L<Math::BigInt::GMP>, and L<Math::BigInt::Pari>.

The pragmas L<bignum>, L<bigint> and L<bigrat> also might be of interest
because they solve the autoupgrading/downgrading issue, at least partly.

=head1 AUTHORS

=over 4

=item *

Mark Biggar, overloaded interface by Ilya Zakharevich, 1996-2001.

=item *

Completely rewritten by Tels L<http://bloodgate.com>, 2001-2008.

=item *

Florian Ragwitz E<lt>flora@cpan.orgE<gt>, 2010.

=item *

Peter John Acklam E<lt>pjacklam@online.noE<gt>, 2011-.

=back

Many people contributed in one or more ways to the final beast, see the file
CREDITS for an (incomplete) list. If you miss your name, please drop me a
mail. Thank you!

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         #
# "Tax the rat farms." - Lord Vetinari
#

# The following hash values are used:
#   sign : +,-,NaN,+inf,-inf
#   _d   : denominator
#   _n   : numerator (value = _n/_d)
#   _a   : accuracy
#   _p   : precision
# You should not look at the innards of a BigRat - use the methods for this.

package Math::BigRat;

# anything older is untested, and unlikely to work
use 5.006;
use strict;
use warnings;

use Carp ();

use Math::BigFloat;

our ($VERSION, @ISA, $upgrade, $downgrade,
     $accuracy, $precision, $round_mode, $div_scale, $_trap_nan, $_trap_inf);

@ISA = qw(Math::BigFloat);

$VERSION = '0.260802';
$VERSION = eval $VERSION;

# Inherit overload from Math::BigFloat, but disable the bitwise ops that don't
# make much sense for rationals unless they're truncated or something first.

use overload
  map {
      my $op = $_;
      ($op => sub {
           Carp::croak("bitwise operation $op not supported in Math::BigRat");
       });
  } qw(& | ^ ~ << >> &= |= ^= <<= >>=);

BEGIN {
    *objectify = \&Math::BigInt::objectify;  # inherit this from BigInt
    *AUTOLOAD  = \&Math::BigFloat::AUTOLOAD; # can't inherit AUTOLOAD
    # We inherit these from BigFloat because currently it is not possible
    # that MBF has a different $MBI variable than we, because MBF also uses
    # Math::BigInt::config->('lib'); (there is always only one library loaded)
    *_e_add = \&Math::BigFloat::_e_add;
    *_e_sub = \&Math::BigFloat::_e_sub;
    *as_int = \&as_number;
    *is_pos = \&is_positive;
    *is_neg = \&is_negative;
}

##############################################################################
# Global constants and flags. Access these only via the accessor methods!

$accuracy = $precision = undef;
$round_mode = 'even';
$div_scale = 40;
$upgrade = undef;
$downgrade = undef;

# These are internally, and not to be used from the outside at all!

$_trap_nan = 0;                         # are NaNs ok? set w/ config()
$_trap_inf = 0;                         # are infs ok? set w/ config()

# the package we are using for our private parts, defaults to:
# Math::BigInt->config()->{lib}
my $MBI = 'Math::BigInt::Calc';

my $nan   = 'NaN';
my $class = 'Math::BigRat';

sub isa {
    return 0 if $_[1] =~ /^Math::Big(Int|Float)/; # we aren't
    UNIVERSAL::isa(@_);
}

##############################################################################

# If $x is a Math::BigRat object and $f is a Math::BigFloat object, then
#
#   $x -> _new_from_float($f)
#
# converts $x into a Math::BigRat with the value of $f.

sub _new_from_float
  {
  # turn a single float input into a rational number (like '0.1')
  my ($self,$f) = @_;

  return $self->bnan() if $f->is_nan();
  return $self->binf($f->{sign}) if $f->{sign} =~ /^[+-]inf$/;

  $self->{_n} = $MBI->_copy($f->{_m});	# mantissa
  $self->{_d} = $MBI->_one();
  $self->{sign} = $f->{sign} || '+';
  if ($f->{_es} eq '-')
    {
    # something like Math::BigRat->new('0.1');
    # 1 / 1 => 1/10
    $MBI->_lsft($self->{_d}, $f->{_e} ,10);
    }
  else
    {
    # something like Math::BigRat->new('10');
    # 1 / 1 => 10/1
    $MBI->_lsft($self->{_n}, $f->{_e} ,10) unless
      $MBI->_is_zero($f->{_e});
    }
  return $self -> bnorm();
  }

# If $x is a Math::BigRat object and $i is a Math::BigInt object, then
#
#   $x -> _new_from_int($i)
#
# converts $x into a Math::BigRat with the value of $i.

sub _new_from_int {
    my ($self, $i) = @_;

    return $self -> bnan()             if $i -> is_nan();
    return $self -> binf($i -> sign()) if $i -> is_inf();

    $self -> {_n}   = $MBI -> _copy($i -> {value});
    $self -> {_d}   = $MBI -> _one();
    $self -> {sign} = $i -> {sign};
    return $self;
}

sub new {
    my $self    = shift;
    my $selfref = ref $self;
    my $class   = $selfref || $self;

    # Get numerator and denominator.

    my ($n, $d) = @_;

    # If called as a class method, initialize a new object.

    $self = bless {}, $class unless $selfref;

    # Input like $class->new($n), where there is no denominator, and where $n
    # is a Math::BigInt or Math::BigFloat.

    if ((!defined $d) && (ref $n) && (!$n->isa('Math::BigRat'))) {
        if ($n->isa('Math::BigFloat')) {
            $self->_new_from_float($n);
        }
        elsif ($n->isa('Math::BigInt')) {
            # TODO: trap NaN, inf
            $self->{_n} = $MBI->_copy($n->{value}); # "mantissa" = N
            $self->{_d} = $MBI->_one();             # d => 1
            $self->{sign} = $n->{sign};
        }
        elsif ($n->isa('Math::BigInt::Lite')) {
            # TODO: trap NaN, inf
            $self->{sign} = '+';
            $self->{sign} = '-' if $$n < 0;
            $self->{_n} = $MBI->_new(abs($$n)); # "mantissa" = N
            $self->{_d} = $MBI->_one();         # d => 1
        }
        return $self->bnorm();  # normalize (120/100 => 6/5)
    }

    # Input like $class->new($n, $d) where $n and $d both are Math::BigInt
    # objects or Math::BigInt::Lite objects.
    if (ref($d) && ref($n)) {

        # do N first (for $self->{sign}):
        if ($n->isa('Math::BigInt')) {
            # TODO: trap NaN, inf
            $self->{_n} = $MBI->_copy($n->{value}); # "mantissa" = N
            $self->{sign} = $n->{sign};
        }
        elsif ($n->isa('Math::BigInt::Lite')) {
            # TODO: trap NaN, inf
            $self->{sign} = '+';
            $self->{sign} = '-' if $$n < 0;
            $self->{_n} = $MBI->_new(abs($$n)); # "mantissa" = $n
        }
        else {
            Carp::croak(ref($n) . " is not a recognized object format for"
                        . " Math::BigRat->new");
        }

        # now D:
        if ($d->isa('Math::BigInt')) {
            # TODO: trap NaN, inf
            $self->{_d} = $MBI->_copy($d->{value}); # "mantissa" = D
            # +/+ or -/- => +, +/- or -/+ => -
            $self->{sign} = $d->{sign} ne $self->{sign} ? '-' : '+';
        } elsif ($d->isa('Math::BigInt::Lite')) {
            # TODO: trap NaN, inf
            $self->{_d} = $MBI->_new(abs($$d)); # "mantissa" = D
            my $ds = '+';
            $ds = '-' if $$d < 0;
            # +/+ or -/- => +, +/- or -/+ => -
            $self->{sign} = $ds ne $self->{sign} ? '-' : '+';
        } else {
            Carp::croak(ref($d) . " is not a recognized object format for"
                        . " Math::BigRat->new");
        }

        return $self->bnorm();  # normalize (120/100 => 6/5)
    }

    return $n->copy() if ref $n; # already a BigRat

    if (!defined $n) {
        $self->{_n} = $MBI->_zero(); # undef => 0
        $self->{_d} = $MBI->_one();
        $self->{sign} = '+';
        return $self;
    }

    # string input with / delimiter
    if ($n =~ m|\s*/\s*|) {
        return $class->bnan() if $n =~ m|/.*/|; # 1/2/3 isn't valid
        return $class->bnan() if $n =~ m|/\s*$|; # 1/ isn't valid
        ($n, $d) = split (/\//, $n);
        # try as BigFloats first
        if (($n =~ /[\.eE]/) || ($d =~ /[\.eE]/)) {
            local $Math::BigFloat::accuracy = undef;
            local $Math::BigFloat::precision = undef;

            # one of them looks like a float
            my $nf = Math::BigFloat->new($n, undef, undef);
            $self->{sign} = '+';
            return $self->bnan() if $nf->is_nan();

            $self->{_n} = $MBI->_copy($nf->{_m}); # get mantissa

            # now correct $self->{_n} due to $n
            my $f = Math::BigFloat->new($d, undef, undef);
            return $self->bnan() if $f->is_nan();
            $self->{_d} = $MBI->_copy($f->{_m});

            # calculate the difference between nE and dE
            my $diff_e = $nf->exponent()->bsub($f->exponent);
            if ($diff_e->is_negative()) {
                # < 0: mul d with it
                $MBI->_lsft($self->{_d}, $MBI->_new($diff_e->babs()), 10);
            } elsif (!$diff_e->is_zero()) {
                # > 0: mul n with it
                $MBI->_lsft($self->{_n}, $MBI->_new($diff_e), 10);
            }
        } else {
            # both d and n look like (big)ints

            $self->{sign} = '+'; # no sign => '+'
            $self->{_n} = undef;
            $self->{_d} = undef;
            if ($n =~ /^([+-]?)0*([0-9]+)\z/) { # first part ok?
                $self->{sign} = $1 || '+'; # no sign => '+'
                $self->{_n} = $MBI->_new($2 || 0);
            }

            if ($d =~ /^([+-]?)0*([0-9]+)\z/) { # second part ok?
                $self->{sign} =~ tr/+-/-+/ if ($1 || '') eq '-'; # negate if second part neg.
                $self->{_d} = $MBI->_new($2 || 0);
            }

            if (!defined $self->{_n} || !defined $self->{_d}) {
                $d = Math::BigInt->new($d, undef, undef) unless ref $d;
                $n = Math::BigInt->new($n, undef, undef) unless ref $n;

                if ($n->{sign} =~ /^[+-]$/ && $d->{sign} =~ /^[+-]$/) {
                    # both parts are ok as integers (weird things like ' 1e0'
                    $self->{_n} = $MBI->_copy($n->{value});
                    $self->{_d} = $MBI->_copy($d->{value});
                    $self->{sign} = $n->{sign};
                    $self->{sign} =~ tr/+-/-+/ if $d->{sign} eq '-'; # -1/-2 => 1/2
                    return $self->bnorm();
                }

                $self->{sign} = '+'; # a default sign
                return $self->bnan() if $n->is_nan() || $d->is_nan();

                # handle inf cases:
                if ($n->is_inf() || $d->is_inf()) {
                    if ($n->is_inf()) {
                        return $self->bnan() if $d->is_inf(); # both are inf => NaN
                        my $s = '+'; # '+inf/+123' or '-inf/-123'
                        $s = '-' if substr($n->{sign}, 0, 1) ne $d->{sign};
                        # +-inf/123 => +-inf
                        return $self->binf($s);
                    }
                    # 123/inf => 0
                    return $self->bzero();
                }
            }
        }

        return $self->bnorm();
    }

    # simple string input
    if (($n =~ /[\.eE]/) && $n !~ /^0x/) {
        # looks like a float, quacks like a float, so probably is a float
        $self->{sign} = 'NaN';
        local $Math::BigFloat::accuracy = undef;
        local $Math::BigFloat::precision = undef;
        $self->_new_from_float(Math::BigFloat->new($n, undef, undef));
    } else {
        # for simple forms, use $MBI directly
        if ($n =~ /^([+-]?)0*([0-9]+)\z/) {
            $self->{sign} = $1 || '+';
            $self->{_n} = $MBI->_new($2 || 0);
            $self->{_d} = $MBI->_one();
        }
        elsif ($n =~ /^\s*([+-]?)inf(inity)?\s*\z/i) {
            my $sgn = $1 || '+';
            $self->{sign} = $sgn . 'inf';   # set a default sign for bstr()
            $self->binf($sgn);
        }

        else {
            my $n = Math::BigInt->new($n, undef, undef);
            $self->{_n} = $MBI->_copy($n->{value});
            $self->{_d} = $MBI->_one();
            $self->{sign} = $n->{sign};
            return $self->bnan() if $self->{sign} eq 'NaN';
        }
    }

    $self->bnorm();
}

sub copy {
    my $self    = shift;
    my $selfref = ref $self;
    my $class   = $selfref || $self;

    # If called as a class method, the object to copy is the next argument.

    $self = shift() unless $selfref;

    my $copy = bless {}, $class;

    $copy->{sign} = $self->{sign};
    $copy->{_d} = $MBI->_copy($self->{_d});
    $copy->{_n} = $MBI->_copy($self->{_n});
    $copy->{_a} = $self->{_a} if defined $self->{_a};
    $copy->{_p} = $self->{_p} if defined $self->{_p};

    $copy;
}

##############################################################################

sub config
  {
  # return (later set?) configuration data as hash ref
  my $class = shift || 'Math::BigRat';

  if (@_ == 1 && ref($_[0]) ne 'HASH')
    {
    my $cfg = $class->SUPER::config();
    return $cfg->{$_[0]};
    }

  my $cfg = $class->SUPER::config(@_);

  # now we need only to override the ones that are different from our parent
  $cfg->{class} = $class;
  $cfg->{with} = $MBI;
  $cfg;
  }

##############################################################################

sub bstr
  {
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);

  if ($x->{sign} !~ /^[+-]$/)		# inf, NaN etc
    {
    my $s = $x->{sign}; $s =~ s/^\+//; 	# +inf => inf
    return $s;
    }

  my $s = ''; $s = $x->{sign} if $x->{sign} ne '+';	# '+3/2' => '3/2'

  return $s . $MBI->_str($x->{_n}) if $MBI->_is_one($x->{_d});
  $s . $MBI->_str($x->{_n}) . '/' . $MBI->_str($x->{_d});
  }

sub bsstr
  {
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);

  if ($x->{sign} !~ /^[+-]$/)		# inf, NaN etc
    {
    my $s = $x->{sign}; $s =~ s/^\+//; 	# +inf => inf
    return $s;
    }

  my $s = ''; $s = $x->{sign} if $x->{sign} ne '+';	# +3 vs 3
  $s . $MBI->_str($x->{_n}) . '/' . $MBI->_str($x->{_d});
  }

sub bnorm
  {
  # reduce the number to the shortest form
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);

  # Both parts must be objects of whatever we are using today.
  if (my $c = $MBI->_check($x->{_n}))
    {
        Carp::croak("n did not pass the self-check ($c) in bnorm()");
    }
  if (my $c = $MBI->_check($x->{_d}))
    {
        Carp::croak("d did not pass the self-check ($c) in bnorm()");
    }

  # no normalize for NaN, inf etc.
  return $x if $x->{sign} !~ /^[+-]$/;

  # normalize zeros to 0/1
  if ($MBI->_is_zero($x->{_n}))
    {
    $x->{sign} = '+';					# never leave a -0
    $x->{_d} = $MBI->_one() unless $MBI->_is_one($x->{_d});
    return $x;
    }

  return $x if $MBI->_is_one($x->{_d});			# no need to reduce

  # reduce other numbers
  my $gcd = $MBI->_copy($x->{_n});
  $gcd = $MBI->_gcd($gcd,$x->{_d});

  if (!$MBI->_is_one($gcd))
    {
    $x->{_n} = $MBI->_div($x->{_n},$gcd);
    $x->{_d} = $MBI->_div($x->{_d},$gcd);
    }
  $x;
  }

##############################################################################
# sign manipulation

sub bneg
  {
  # (BRAT or num_str) return BRAT
  # negate number or make a negated number from string
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);

  return $x if $x->modify('bneg');

  # for +0 do not negate (to have always normalized +0). Does nothing for 'NaN'
  $x->{sign} =~ tr/+-/-+/
    unless ($x->{sign} eq '+' && $MBI->_is_zero($x->{_n}));
  $x;
  }

##############################################################################
# special values

sub _bnan
  {
  # used by parent class bnan() to initialize number to NaN
  my $self = shift;

  if ($_trap_nan)
    {
    my $class = ref($self);
    # "$self" below will stringify the object, this blows up if $self is a
    # partial object (happens under trap_nan), so fix it beforehand
    $self->{_d} = $MBI->_zero() unless defined $self->{_d};
    $self->{_n} = $MBI->_zero() unless defined $self->{_n};
    Carp::croak ("Tried to set $self to NaN in $class\::_bnan()");
    }
  $self->{_n} = $MBI->_zero();
  $self->{_d} = $MBI->_zero();
  }

sub _binf
  {
  # used by parent class bone() to initialize number to +inf/-inf
  my $self = shift;

  if ($_trap_inf)
    {
    my $class = ref($self);
    # "$self" below will stringify the object, this blows up if $self is a
    # partial object (happens under trap_nan), so fix it beforehand
    $self->{_d} = $MBI->_zero() unless defined $self->{_d};
    $self->{_n} = $MBI->_zero() unless defined $self->{_n};
    Carp::croak ("Tried to set $self to inf in $class\::_binf()");
    }
  $self->{_n} = $MBI->_zero();
  $self->{_d} = $MBI->_zero();
  }

sub _bone
  {
  # used by parent class bone() to initialize number to +1/-1
  my $self = shift;
  $self->{_n} = $MBI->_one();
  $self->{_d} = $MBI->_one();
  }

sub _bzero
  {
  # used by parent class bzero() to initialize number to 0
  my $self = shift;
  $self->{_n} = $MBI->_zero();
  $self->{_d} = $MBI->_one();
  }

##############################################################################
# mul/add/div etc

sub badd
  {
  # add two rational numbers

  # set up parameters
  my ($self,$x,$y,@r) = (ref($_[0]),@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@r) = objectify(2,@_);
    }

  # +inf + +inf => +inf,  -inf + -inf => -inf
  return $x->binf(substr($x->{sign},0,1))
    if $x->{sign} eq $y->{sign} && $x->{sign} =~ /^[+-]inf$/;

  # +inf + -inf or -inf + +inf => NaN
  return $x->bnan() if ($x->{sign} !~ /^[+-]$/ || $y->{sign} !~ /^[+-]$/);

  #  1   1    gcd(3,4) = 1    1*3 + 1*4    7
  #  - + -                  = --------- = --
  #  4   3                      4*3       12

  # we do not compute the gcd() here, but simple do:
  #  5   7    5*3 + 7*4   43
  #  - + -  = --------- = --
  #  4   3       4*3      12

  # and bnorm() will then take care of the rest

  # 5 * 3
  $x->{_n} = $MBI->_mul($x->{_n}, $y->{_d});

  # 7 * 4
  my $m = $MBI->_mul($MBI->_copy($y->{_n}), $x->{_d});

  # 5 * 3 + 7 * 4
  ($x->{_n}, $x->{sign}) = _e_add($x->{_n}, $m, $x->{sign}, $y->{sign});

  # 4 * 3
  $x->{_d} = $MBI->_mul($x->{_d}, $y->{_d});

  # normalize result, and possible round
  $x->bnorm()->round(@r);
  }

sub bsub
  {
  # subtract two rational numbers

  # set up parameters
  my ($self,$x,$y,@r) = (ref($_[0]),@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@r) = objectify(2,@_);
    }

  # flip sign of $x, call badd(), then flip sign of result
  $x->{sign} =~ tr/+-/-+/
    unless $x->{sign} eq '+' && $MBI->_is_zero($x->{_n});	# not -0
  $x->badd($y,@r);				# does norm and round
  $x->{sign} =~ tr/+-/-+/
    unless $x->{sign} eq '+' && $MBI->_is_zero($x->{_n});	# not -0
  $x;
  }

sub bmul
  {
  # multiply two rational numbers

  # set up parameters
  my ($self,$x,$y,@r) = (ref($_[0]),@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@r) = objectify(2,@_);
    }

  return $x->bnan() if ($x->{sign} eq 'NaN' || $y->{sign} eq 'NaN');

  # inf handling
  if (($x->{sign} =~ /^[+-]inf$/) || ($y->{sign} =~ /^[+-]inf$/))
    {
    return $x->bnan() if $x->is_zero() || $y->is_zero();
    # result will always be +-inf:
    # +inf * +/+inf => +inf, -inf * -/-inf => +inf
    # +inf * -/-inf => -inf, -inf * +/+inf => -inf
    return $x->binf() if ($x->{sign} =~ /^\+/ && $y->{sign} =~ /^\+/);
    return $x->binf() if ($x->{sign} =~ /^-/ && $y->{sign} =~ /^-/);
    return $x->binf('-');
    }

  # x== 0 # also: or y == 1 or y == -1
  return wantarray ? ($x,$self->bzero()) : $x if $x->is_zero();

  # XXX TODO:
  # According to Knuth, this can be optimized by doing gcd twice (for d and n)
  # and reducing in one step. This would save us the bnorm() at the end.

  #  1   2    1 * 2    2    1
  #  - * - =  -----  = -  = -
  #  4   3    4 * 3    12   6

  $x->{_n} = $MBI->_mul($x->{_n}, $y->{_n});
  $x->{_d} = $MBI->_mul($x->{_d}, $y->{_d});

  # compute new sign
  $x->{sign} = $x->{sign} eq $y->{sign} ? '+' : '-';

  $x->bnorm()->round(@r);
  }

sub bdiv
  {
  # (dividend: BRAT or num_str, divisor: BRAT or num_str) return
  # (BRAT,BRAT) (quo,rem) or BRAT (only rem)

  # set up parameters
  my ($self,$x,$y,@r) = (ref($_[0]),@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@r) = objectify(2,@_);
    }

  return $x if $x->modify('bdiv');

    my $wantarray = wantarray;          # call only once

    # At least one argument is NaN. This is handled the same way as in
    # Math::BigInt -> bdiv(). See the comments in the code implementing that
    # method.

    if ($x -> is_nan() || $y -> is_nan()) {
        return $wantarray ? ($x -> bnan(), $self -> bnan()) : $x -> bnan();
    }

    # Divide by zero and modulo zero. This is handled the same way as in
    # Math::BigInt -> bdiv(). See the comments in the code implementing that
    # method.

    if ($y -> is_zero()) {
        my ($quo, $rem);
        if ($wantarray) {
            $rem = $x -> copy();
        }
        if ($x -> is_zero()) {
            $quo = $x -> bnan();
        } else {
            $quo = $x -> binf($x -> {sign});
        }
        return $wantarray ? ($quo, $rem) : $quo;
    }

    # Numerator (dividend) is +/-inf. This is handled the same way as in
    # Math::BigInt -> bdiv(). See the comments in the code implementing that
    # method.

    if ($x -> is_inf()) {
        my ($quo, $rem);
        $rem = $self -> bnan() if $wantarray;
        if ($y -> is_inf()) {
            $quo = $x -> bnan();
        } else {
            my $sign = $x -> bcmp(0) == $y -> bcmp(0) ? '+' : '-';
            $quo = $x -> binf($sign);
        }
        return $wantarray ? ($quo, $rem) : $quo;
    }

  # Denominator (divisor) is +/-inf. This is handled the same way as in
  # Math::BigFloat -> bdiv(). See the comments in the code implementing that
  # method.

  if ($y -> is_inf()) {
      my ($quo, $rem);
      if ($wantarray) {
          if ($x -> is_zero() || $x -> bcmp(0) == $y -> bcmp(0)) {
              $rem = $x -> copy();
              $quo = $x -> bzero();
          } else {
              $rem = $self -> binf($y -> {sign});
              $quo = $x -> bone('-');
          }
          return ($quo, $rem);
      } else {
          if ($y -> is_inf()) {
              if ($x -> is_nan() || $x -> is_inf()) {
                  return $x -> bnan();
              } else {
                  return $x -> bzero();
              }
          }
      }
  }

  # At this point, both the numerator and denominator are finite numbers, and
  # the denominator (divisor) is non-zero.

  # x == 0?
  return wantarray ? ($x,$self->bzero()) : $x if $x->is_zero();

  # XXX TODO: list context, upgrade
  # According to Knuth, this can be optimized by doing gcd twice (for d and n)
  # and reducing in one step. This would save us the bnorm() at the end.

  # 1     1    1   3
  # -  /  - == - * -
  # 4     3    4   1

  $x->{_n} = $MBI->_mul($x->{_n}, $y->{_d});
  $x->{_d} = $MBI->_mul($x->{_d}, $y->{_n});

  # compute new sign
  $x->{sign} = $x->{sign} eq $y->{sign} ? '+' : '-';

  $x -> bnorm();
  if (wantarray) {
      my $rem = $x -> copy();
      $x -> bfloor();
      $x -> round(@r);
      $rem -> bsub($x -> copy()) -> bmul($y);
      return $x, $rem;
  } else {
      $x -> round(@r);
      return $x;
  }
  }

sub bmod
  {
  # compute "remainder" (in Perl way) of $x / $y

  # set up parameters
  my ($self,$x,$y,@r) = (ref($_[0]),@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@r) = objectify(2,@_);
    }

  return $x if $x->modify('bmod');

    # At least one argument is NaN. This is handled the same way as in
    # Math::BigInt -> bmod().

    if ($x -> is_nan() || $y -> is_nan()) {
        return $x -> bnan();
    }

    # Modulo zero. This is handled the same way as in Math::BigInt -> bmod().

    if ($y -> is_zero()) {
        return $x;
    }

    # Numerator (dividend) is +/-inf. This is handled the same way as in
    # Math::BigInt -> bmod().

    if ($x -> is_inf()) {
        return $x -> bnan();
    }

    # Denominator (divisor) is +/-inf. This is handled the same way as in
    # Math::BigInt -> bmod().

    if ($y -> is_inf()) {
        if ($x -> is_zero() || $x -> bcmp(0) == $y -> bcmp(0)) {
            return $x;
        } else {
            return $x -> binf($y -> sign());
        }
    }

  # At this point, both the numerator and denominator are finite numbers, and
  # the denominator (divisor) is non-zero.

  return $x if $x->is_zero();           # 0 / 7 = 0, mod 0

  # Compute $x - $y * floor($x/$y). This can probably be optimized by working
  # on a lower level.

  $x -> bsub($x -> copy() -> bdiv($y) -> bfloor() -> bmul($y));
  return $x -> round(@r);
  }

##############################################################################
# bdec/binc

sub bdec
  {
  # decrement value (subtract 1)
  my ($self,$x,@r) = ref($_[0]) ? (ref($_[0]),@_) : objectify(1,@_);

  return $x if $x->{sign} !~ /^[+-]$/;	# NaN, inf, -inf

  if ($x->{sign} eq '-')
    {
    $x->{_n} = $MBI->_add($x->{_n}, $x->{_d});		# -5/2 => -7/2
    }
  else
    {
    if ($MBI->_acmp($x->{_n},$x->{_d}) < 0)		# n < d?
      {
      # 1/3 -- => -2/3
      $x->{_n} = $MBI->_sub($MBI->_copy($x->{_d}), $x->{_n});
      $x->{sign} = '-';
      }
    else
      {
      $x->{_n} = $MBI->_sub($x->{_n}, $x->{_d}); 	# 5/2 => 3/2
      }
    }
  $x->bnorm()->round(@r);
  }

sub binc
  {
  # increment value (add 1)
  my ($self,$x,@r) = ref($_[0]) ? (ref($_[0]),@_) : objectify(1,@_);

  return $x if $x->{sign} !~ /^[+-]$/;	# NaN, inf, -inf

  if ($x->{sign} eq '-')
    {
    if ($MBI->_acmp($x->{_n},$x->{_d}) < 0)
      {
      # -1/3 ++ => 2/3 (overflow at 0)
      $x->{_n} = $MBI->_sub($MBI->_copy($x->{_d}), $x->{_n});
      $x->{sign} = '+';
      }
    else
      {
      $x->{_n} = $MBI->_sub($x->{_n}, $x->{_d}); 	# -5/2 => -3/2
      }
    }
  else
    {
    $x->{_n} = $MBI->_add($x->{_n},$x->{_d});		# 5/2 => 7/2
    }
  $x->bnorm()->round(@r);
  }

##############################################################################
# is_foo methods (the rest is inherited)

sub is_int
  {
  # return true if arg (BRAT or num_str) is an integer
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);

  return 1 if ($x->{sign} =~ /^[+-]$/) &&	# NaN and +-inf aren't
    $MBI->_is_one($x->{_d});			# x/y && y != 1 => no integer
  0;
  }

sub is_zero
  {
  # return true if arg (BRAT or num_str) is zero
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);

  return 1 if $x->{sign} eq '+' && $MBI->_is_zero($x->{_n});
  0;
  }

sub is_one
  {
  # return true if arg (BRAT or num_str) is +1 or -1 if signis given
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);

  my $sign = $_[2] || ''; $sign = '+' if $sign ne '-';
  return 1
   if ($x->{sign} eq $sign && $MBI->_is_one($x->{_n}) && $MBI->_is_one($x->{_d}));
  0;
  }

sub is_odd
  {
  # return true if arg (BFLOAT or num_str) is odd or false if even
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);

  return 1 if ($x->{sign} =~ /^[+-]$/) &&		# NaN & +-inf aren't
    ($MBI->_is_one($x->{_d}) && $MBI->_is_odd($x->{_n})); # x/2 is not, but 3/1
  0;
  }

sub is_even
  {
  # return true if arg (BINT or num_str) is even or false if odd
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);

  return 0 if $x->{sign} !~ /^[+-]$/;			# NaN & +-inf aren't
  return 1 if ($MBI->_is_one($x->{_d})			# x/3 is never
     && $MBI->_is_even($x->{_n}));			# but 4/1 is
  0;
  }

##############################################################################
# parts() and friends

sub numerator
  {
  my ($self,$x) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@_);

  # NaN, inf, -inf
  return Math::BigInt->new($x->{sign}) if ($x->{sign} !~ /^[+-]$/);

  my $n = Math::BigInt->new($MBI->_str($x->{_n})); $n->{sign} = $x->{sign};
  $n;
  }

sub denominator
  {
  my ($self,$x) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@_);

  # NaN
  return Math::BigInt->new($x->{sign}) if $x->{sign} eq 'NaN';
  # inf, -inf
  return Math::BigInt->bone() if $x->{sign} !~ /^[+-]$/;

  Math::BigInt->new($MBI->_str($x->{_d}));
  }

sub parts
  {
  my ($self,$x) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@_);

  my $c = 'Math::BigInt';

  return ($c->bnan(),$c->bnan()) if $x->{sign} eq 'NaN';
  return ($c->binf(),$c->binf()) if $x->{sign} eq '+inf';
  return ($c->binf('-'),$c->binf()) if $x->{sign} eq '-inf';

  my $n = $c->new($MBI->_str($x->{_n}));
  $n->{sign} = $x->{sign};
  my $d = $c->new($MBI->_str($x->{_d}));
  ($n,$d);
  }

sub length
  {
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);

  return $nan unless $x->is_int();
  $MBI->_len($x->{_n});				# length(-123/1) => length(123)
  }

sub digit
  {
  my ($self,$x,$n) = ref($_[0]) ? (undef,$_[0],$_[1]) : objectify(1,@_);

  return $nan unless $x->is_int();
  $MBI->_digit($x->{_n},$n || 0);		# digit(-123/1,2) => digit(123,2)
  }

##############################################################################
# special calc routines

sub bceil
  {
  my ($self,$x) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@_);

  return $x if $x->{sign} !~ /^[+-]$/ ||	# not for NaN, inf
            $MBI->_is_one($x->{_d});		# 22/1 => 22, 0/1 => 0

  $x->{_n} = $MBI->_div($x->{_n},$x->{_d});	# 22/7 => 3/1 w/ truncate
  $x->{_d} = $MBI->_one();			# d => 1
  $x->{_n} = $MBI->_inc($x->{_n})
    if $x->{sign} eq '+';			# +22/7 => 4/1
  $x->{sign} = '+' if $MBI->_is_zero($x->{_n});	# -0 => 0
  $x;
  }

sub bfloor
  {
  my ($self,$x) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@_);

  return $x if $x->{sign} !~ /^[+-]$/ ||	# not for NaN, inf
            $MBI->_is_one($x->{_d});		# 22/1 => 22, 0/1 => 0

  $x->{_n} = $MBI->_div($x->{_n},$x->{_d});	# 22/7 => 3/1 w/ truncate
  $x->{_d} = $MBI->_one();			# d => 1
  $x->{_n} = $MBI->_inc($x->{_n})
    if $x->{sign} eq '-';			# -22/7 => -4/1
  $x;
  }

sub bfac
  {
  my ($self,$x,@r) = ref($_[0]) ? (ref($_[0]),@_) : objectify(1,@_);

  # if $x is not an integer
  if (($x->{sign} ne '+') || (!$MBI->_is_one($x->{_d})))
    {
    return $x->bnan();
    }

  $x->{_n} = $MBI->_fac($x->{_n});
  # since _d is 1, we don't need to reduce/norm the result
  $x->round(@r);
  }

sub bpow
  {
  # power ($x ** $y)

  # set up parameters
  my ($self,$x,$y,@r) = (ref($_[0]),@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@r) = objectify(2,@_);
    }

  return $x if $x->{sign} =~ /^[+-]inf$/;       # -inf/+inf ** x
  return $x->bnan() if $x->{sign} eq $nan || $y->{sign} eq $nan;
  return $x->bone(@r) if $y->is_zero();
  return $x->round(@r) if $x->is_one() || $y->is_one();

  if ($x->{sign} eq '-' && $MBI->_is_one($x->{_n}) && $MBI->_is_one($x->{_d}))
    {
    # if $x == -1 and odd/even y => +1/-1
    return $y->is_odd() ? $x->round(@r) : $x->babs()->round(@r);
    # my Casio FX-5500L has a bug here: -1 ** 2 is -1, but -1 * -1 is 1;
    }
  # 1 ** -y => 1 / (1 ** |y|)
  # so do test for negative $y after above's clause

  return $x->round(@r) if $x->is_zero();  # 0**y => 0 (if not y <= 0)

  # shortcut if y == 1/N (is then sqrt() respective broot())
  if ($MBI->_is_one($y->{_n}))
    {
    return $x->bsqrt(@r) if $MBI->_is_two($y->{_d});	# 1/2 => sqrt
    return $x->broot($MBI->_str($y->{_d}),@r);		# 1/N => root(N)
    }

  # shortcut y/1 (and/or x/1)
  if ($MBI->_is_one($y->{_d}))
    {
    # shortcut for x/1 and y/1
    if ($MBI->_is_one($x->{_d}))
      {
      $x->{_n} = $MBI->_pow($x->{_n},$y->{_n});		# x/1 ** y/1 => (x ** y)/1
      if ($y->{sign} eq '-')
        {
        # 0.2 ** -3 => 1/(0.2 ** 3)
        ($x->{_n},$x->{_d}) = ($x->{_d},$x->{_n});	# swap
        }
      # correct sign; + ** + => +
      if ($x->{sign} eq '-')
        {
        # - * - => +, - * - * - => -
        $x->{sign} = '+' if $MBI->_is_even($y->{_n});
        }
      return $x->round(@r);
      }
    # x/z ** y/1
    $x->{_n} = $MBI->_pow($x->{_n},$y->{_n});		# 5/2 ** y/1 => 5 ** y / 2 ** y
    $x->{_d} = $MBI->_pow($x->{_d},$y->{_n});
    if ($y->{sign} eq '-')
      {
      # 0.2 ** -3 => 1/(0.2 ** 3)
      ($x->{_n},$x->{_d}) = ($x->{_d},$x->{_n});	# swap
      }
    # correct sign; + ** + => +
    if ($x->{sign} eq '-')
      {
      # - * - => +, - * - * - => -
      $x->{sign} = '+' if $MBI->_is_even($y->{_n});
      }
    return $x->round(@r);
    }

#  print STDERR "# $x $y\n";

  # otherwise:

  #      n/d     n  ______________
  # a/b       =  -\/  (a/b) ** d

  # (a/b) ** n == (a ** n) / (b ** n)
  $MBI->_pow($x->{_n}, $y->{_n});
  $MBI->_pow($x->{_d}, $y->{_n});

  return $x->broot($MBI->_str($y->{_d}),@r);		# n/d => root(n)
  }

sub blog
  {
  # Return the logarithm of the operand. If a second operand is defined, that
  # value is used as the base, otherwise the base is assumed to be Euler's
  # constant.

  # Don't objectify the base, since an undefined base, as in $x->blog() or
  # $x->blog(undef) signals that the base is Euler's number.

  # set up parameters
  my ($self,$x,$base,@r) = (ref($_[0]),@_);

  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$base,@r) = objectify(1,$class,@_);
    }

  return $x if $x->modify('blog');

  # Handle all exception cases and all trivial cases. I have used Wolfram Alpha
  # (http://www.wolframalpha.com) as the reference for these cases.

  return $x -> bnan() if $x -> is_nan();

  if (defined $base) {
      $base = $self -> new($base) unless ref $base;
      if ($base -> is_nan() || $base -> is_one()) {
          return $x -> bnan();
      } elsif ($base -> is_inf() || $base -> is_zero()) {
          return $x -> bnan() if $x -> is_inf() || $x -> is_zero();
          return $x -> bzero();
      } elsif ($base -> is_negative()) {            # -inf < base < 0
          return $x -> bzero() if $x -> is_one();   #     x = 1
          return $x -> bone()  if $x == $base;      #     x = base
          return $x -> bnan();                      #     otherwise
      }
      return $x -> bone() if $x == $base;           # 0 < base && 0 < x < inf
  }

  # We now know that the base is either undefined or positive and finite.

  if ($x -> is_inf()) {                 # x = +/-inf
      my $sign = defined $base && $base < 1 ? '-' : '+';
      return $x -> binf($sign);
  } elsif ($x -> is_neg()) {            # -inf < x < 0
      return $x -> bnan();
  } elsif ($x -> is_one()) {            # x = 1
      return $x -> bzero();
  } elsif ($x -> is_zero()) {           # x = 0
      my $sign = defined $base && $base < 1 ? '+' : '-';
      return $x -> binf($sign);
  }

  # At this point we are done handling all exception cases and trivial cases.

  # Do it with Math::BigFloats and convert back to Math::BigRat.
  $base = $base -> _as_float() if defined $base;
  $x -> _new_from_float($x -> _as_float() -> blog($base, @r));
  }

sub bexp
  {
  # set up parameters
  my ($self,$x,$y,@r) = (ref($_[0]),@_);

  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@r) = objectify(2,$class,@_);
    }

  return $x->binf(@r) if $x->{sign} eq '+inf';
  return $x->bzero(@r) if $x->{sign} eq '-inf';

  # we need to limit the accuracy to protect against overflow
  my $fallback = 0;
  my ($scale,@params);
  ($x,@params) = $x->_find_round_parameters(@r);

  # also takes care of the "error in _find_round_parameters?" case
  return $x if $x->{sign} eq 'NaN';

  # no rounding at all, so must use fallback
  if (scalar @params == 0)
    {
    # simulate old behaviour
    $params[0] = $self->div_scale();	# and round to it as accuracy
    $params[1] = undef;			# P = undef
    $scale = $params[0]+4;		# at least four more for proper round
    $params[2] = $r[2];			# round mode by caller or undef
    $fallback = 1;			# to clear a/p afterwards
    }
  else
    {
    # the 4 below is empirical, and there might be cases where it's not enough...
    $scale = abs($params[0] || $params[1]) + 4; # take whatever is defined
    }

  return $x->bone(@params) if $x->is_zero();

  # See the comments in Math::BigFloat on how this algorithm works.
  # Basically we calculate A and B (where B is faculty(N)) so that A/B = e

  my $x_org = $x->copy();
  if ($scale <= 75)
    {
    # set $x directly from a cached string form
    $x->{_n} =
        $MBI->_new("90933395208605785401971970164779391644753259799242");
    $x->{_d} =
        $MBI->_new("33452526613163807108170062053440751665152000000000");
    $x->{sign} = '+';
    }
  else
    {
    # compute A and B so that e = A / B.

    # After some terms we end up with this, so we use it as a starting point:
    my $A = $MBI->_new("90933395208605785401971970164779391644753259799242");
    my $F = $MBI->_new(42); my $step = 42;

    # Compute how many steps we need to take to get $A and $B sufficiently big
    my $steps = Math::BigFloat::_len_to_steps($scale - 4);
#    print STDERR "# Doing $steps steps for ", $scale-4, " digits\n";
    while ($step++ <= $steps)
      {
      # calculate $a * $f + 1
      $A = $MBI->_mul($A, $F);
      $A = $MBI->_inc($A);
      # increment f
      $F = $MBI->_inc($F);
      }
    # compute $B as factorial of $steps (this is faster than doing it manually)
    my $B = $MBI->_fac($MBI->_new($steps));

#  print "A ", $MBI->_str($A), "\nB ", $MBI->_str($B), "\n";

    $x->{_n} = $A;
    $x->{_d} = $B;
    $x->{sign} = '+';
    }

  # $x contains now an estimate of e, with some surplus digits, so we can round
  if (!$x_org->is_one())
    {
    # raise $x to the wanted power and round it in one step:
    $x->bpow($x_org, @params);
    }
  else
    {
    # else just round the already computed result
    delete $x->{_a}; delete $x->{_p};
    # shortcut to not run through _find_round_parameters again
    if (defined $params[0])
      {
      $x->bround($params[0],$params[2]);                # then round accordingly
      }
    else
      {
      $x->bfround($params[1],$params[2]);               # then round accordingly
      }
    }
  if ($fallback)
    {
    # clear a/p after round, since user did not request it
    delete $x->{_a}; delete $x->{_p};
    }

  $x;
  }

sub bnok
  {
  # set up parameters
  my ($self,$x,$y,@r) = (ref($_[0]),@_);

  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@r) = objectify(2,$class,@_);
    }

  # do it with floats
  $x->_new_from_float($x->_as_float()->bnok(Math::BigFloat->new("$y"),@r));
  }

sub _float_from_part
  {
  my $x = shift;

  my $f = Math::BigFloat->bzero();
  $f->{_m} = $MBI->_copy($x);
  $f->{_e} = $MBI->_zero();

  $f;
  }

sub _as_float
  {
  my $x = shift;

  local $Math::BigFloat::upgrade = undef;
  local $Math::BigFloat::accuracy = undef;
  local $Math::BigFloat::precision = undef;
  # 22/7 => 3.142857143..

  my $a = $x->accuracy() || 0;
  if ($a != 0 || !$MBI->_is_one($x->{_d}))
    {
    # n/d
    return scalar Math::BigFloat->new($x->{sign} . $MBI->_str($x->{_n}))->bdiv($MBI->_str($x->{_d}), $x->accuracy());
    }
  # just n
  Math::BigFloat->new($x->{sign} . $MBI->_str($x->{_n}));
  }

sub broot
  {
  # set up parameters
  my ($self,$x,$y,@r) = (ref($_[0]),@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@r) = objectify(2,@_);
    }

  if ($x->is_int() && $y->is_int())
    {
    return $self->new($x->as_number()->broot($y->as_number(),@r));
    }

  # do it with floats
  $x->_new_from_float($x->_as_float()->broot($y->_as_float(),@r))->bnorm()->bround(@r);
  }

sub bmodpow
  {
  # set up parameters
  my ($self,$x,$y,$m,@r) = (ref($_[0]),@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,$m,@r) = objectify(3,@_);
    }

  # $x or $y or $m are NaN or +-inf => NaN
  return $x->bnan()
   if $x->{sign} !~ /^[+-]$/ || $y->{sign} !~ /^[+-]$/ ||
   $m->{sign} !~ /^[+-]$/;

  if ($x->is_int() && $y->is_int() && $m->is_int())
    {
    return $self->new($x->as_number()->bmodpow($y->as_number(),$m,@r));
    }

  warn ("bmodpow() not fully implemented");
  $x->bnan();
  }

sub bmodinv
  {
  # set up parameters
  my ($self,$x,$y,@r) = (ref($_[0]),@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@r) = objectify(2,@_);
    }

  # $x or $y are NaN or +-inf => NaN
  return $x->bnan()
   if $x->{sign} !~ /^[+-]$/ || $y->{sign} !~ /^[+-]$/;

  if ($x->is_int() && $y->is_int())
    {
    return $self->new($x->as_number()->bmodinv($y->as_number(),@r));
    }

  warn ("bmodinv() not fully implemented");
  $x->bnan();
  }

sub bsqrt
  {
  my ($self,$x,@r) = ref($_[0]) ? (ref($_[0]),@_) : objectify(1,@_);

  return $x->bnan() if $x->{sign} !~ /^[+]/;    # NaN, -inf or < 0
  return $x if $x->{sign} eq '+inf';            # sqrt(inf) == inf
  return $x->round(@r) if $x->is_zero() || $x->is_one();

  local $Math::BigFloat::upgrade = undef;
  local $Math::BigFloat::downgrade = undef;
  local $Math::BigFloat::precision = undef;
  local $Math::BigFloat::accuracy = undef;
  local $Math::BigInt::upgrade = undef;
  local $Math::BigInt::precision = undef;
  local $Math::BigInt::accuracy = undef;

  $x->{_n} = _float_from_part($x->{_n})->bsqrt();
  $x->{_d} = _float_from_part($x->{_d})->bsqrt();

  # XXX TODO: we probably can optimize this:

  # if sqrt(D) was not integer
  if ($x->{_d}->{_es} ne '+')
    {
    $x->{_n}->blsft($x->{_d}->exponent()->babs(),10);	# 7.1/4.51 => 7.1/45.1
    $x->{_d} = $MBI->_copy($x->{_d}->{_m});		# 7.1/45.1 => 71/45.1
    }
  # if sqrt(N) was not integer
  if ($x->{_n}->{_es} ne '+')
    {
    $x->{_d}->blsft($x->{_n}->exponent()->babs(),10);	# 71/45.1 => 710/45.1
    $x->{_n} = $MBI->_copy($x->{_n}->{_m});		# 710/45.1 => 710/451
    }

  # convert parts to $MBI again
  $x->{_n} = $MBI->_lsft($MBI->_copy($x->{_n}->{_m}), $x->{_n}->{_e}, 10)
    if ref($x->{_n}) ne $MBI && ref($x->{_n}) ne 'ARRAY';
  $x->{_d} = $MBI->_lsft($MBI->_copy($x->{_d}->{_m}), $x->{_d}->{_e}, 10)
    if ref($x->{_d}) ne $MBI && ref($x->{_d}) ne 'ARRAY';

  $x->bnorm()->round(@r);
  }

sub blsft
  {
  my ($self,$x,$y,$b,@r) = objectify(3,@_);

  $b = 2 unless defined $b;
  $b = $self->new($b) unless ref ($b);
  $x->bmul($b->copy()->bpow($y), @r);
  $x;
  }

sub brsft
  {
  my ($self,$x,$y,$b,@r) = objectify(3,@_);

  $b = 2 unless defined $b;
  $b = $self->new($b) unless ref ($b);
  $x->bdiv($b->copy()->bpow($y), @r);
  $x;
  }

##############################################################################
# round

sub round
  {
  $_[0];
  }

sub bround
  {
  $_[0];
  }

sub bfround
  {
  $_[0];
  }

##############################################################################
# comparing

sub bcmp
  {
  # compare two signed numbers

  # set up parameters
  my ($self,$x,$y) = (ref($_[0]),@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y) = objectify(2,@_);
    }

  if (($x->{sign} !~ /^[+-]$/) || ($y->{sign} !~ /^[+-]$/))
    {
    # handle +-inf and NaN
    return undef if (($x->{sign} eq $nan) || ($y->{sign} eq $nan));
    return 0 if $x->{sign} eq $y->{sign} && $x->{sign} =~ /^[+-]inf$/;
    return +1 if $x->{sign} eq '+inf';
    return -1 if $x->{sign} eq '-inf';
    return -1 if $y->{sign} eq '+inf';
    return +1;
    }
  # check sign for speed first
  return 1 if $x->{sign} eq '+' && $y->{sign} eq '-';   # does also 0 <=> -y
  return -1 if $x->{sign} eq '-' && $y->{sign} eq '+';  # does also -x <=> 0

  # shortcut
  my $xz = $MBI->_is_zero($x->{_n});
  my $yz = $MBI->_is_zero($y->{_n});
  return 0 if $xz && $yz;                               # 0 <=> 0
  return -1 if $xz && $y->{sign} eq '+';                # 0 <=> +y
  return 1 if $yz && $x->{sign} eq '+';                 # +x <=> 0

  my $t = $MBI->_mul($MBI->_copy($x->{_n}), $y->{_d});
  my $u = $MBI->_mul($MBI->_copy($y->{_n}), $x->{_d});

  my $cmp = $MBI->_acmp($t,$u);				# signs are equal
  $cmp = -$cmp if $x->{sign} eq '-';			# both are '-' => reverse
  $cmp;
  }

sub bacmp
  {
  # compare two numbers (as unsigned)

  # set up parameters
  my ($self,$x,$y) = (ref($_[0]),@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y) = objectify(2,$class,@_);
    }

  if (($x->{sign} !~ /^[+-]$/) || ($y->{sign} !~ /^[+-]$/))
    {
    # handle +-inf and NaN
    return undef if (($x->{sign} eq $nan) || ($y->{sign} eq $nan));
    return 0 if $x->{sign} =~ /^[+-]inf$/ && $y->{sign} =~ /^[+-]inf$/;
    return 1 if $x->{sign} =~ /^[+-]inf$/ && $y->{sign} !~ /^[+-]inf$/;
    return -1;
    }

  my $t = $MBI->_mul($MBI->_copy($x->{_n}), $y->{_d});
  my $u = $MBI->_mul($MBI->_copy($y->{_n}), $x->{_d});
  $MBI->_acmp($t,$u);					# ignore signs
  }

##############################################################################
# output conversation

sub numify
  {
  # convert 17/8 => float (aka 2.125)
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);

  return $x->bstr() if $x->{sign} !~ /^[+-]$/;	# inf, NaN, etc

  # N/1 => N
  my $neg = ''; $neg = '-' if $x->{sign} eq '-';
  return $neg . $MBI->_num($x->{_n}) if $MBI->_is_one($x->{_d});

  $x->_as_float()->numify() + 0.0;
  }

sub as_number
  {
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);

  # NaN, inf etc
  return Math::BigInt->new($x->{sign}) if $x->{sign} !~ /^[+-]$/;

  my $u = Math::BigInt->bzero();
  $u->{value} = $MBI->_div($MBI->_copy($x->{_n}), $x->{_d});	# 22/7 => 3
  $u->bneg if $x->{sign} eq '-'; # no negative zero
  $u;
  }

sub as_float
  {
  # return N/D as Math::BigFloat

  # set up parameters
  my ($self,$x,@r) = (ref($_[0]),@_);
  # objectify is costly, so avoid it
  ($self,$x,@r) = objectify(1,$class,@_) unless ref $_[0];

  # NaN, inf etc
  return Math::BigFloat->new($x->{sign}) if $x->{sign} !~ /^[+-]$/;

  my $u = Math::BigFloat->bzero();
  $u->{sign} = $x->{sign};
  # n
  $u->{_m} = $MBI->_copy($x->{_n});
  $u->{_e} = $MBI->_zero();
  $u->bdiv($MBI->_str($x->{_d}), @r);
  # return $u
  $u;
  }

sub as_bin
  {
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);

  return $x unless $x->is_int();

  my $s = $x->{sign}; $s = '' if $s eq '+';
  $s . $MBI->_as_bin($x->{_n});
  }

sub as_hex
  {
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);

  return $x unless $x->is_int();

  my $s = $x->{sign}; $s = '' if $s eq '+';
  $s . $MBI->_as_hex($x->{_n});
  }

sub as_oct
  {
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);

  return $x unless $x->is_int();

  my $s = $x->{sign}; $s = '' if $s eq '+';
  $s . $MBI->_as_oct($x->{_n});
  }

##############################################################################

sub from_hex
  {
  my $class = shift;

  $class->new(@_);
  }

sub from_bin
  {
  my $class = shift;

  $class->new(@_);
  }

sub from_oct
  {
  my $class = shift;

  my @parts;
  for my $c (@_)
    {
    push @parts, Math::BigInt->from_oct($c);
    }
  $class->new (@parts);
  }

##############################################################################
# import

sub import
  {
  my $self = shift;
  my $l = scalar @_;
  my $lib = ''; my @a;
  my $try = 'try';

  for (my $i = 0; $i < $l ; $i++)
    {
    if ($_[$i] eq ':constant')
      {
      # this rest causes overlord er load to step in
      overload::constant float => sub { $self->new(shift); };
      }
#    elsif ($_[$i] eq 'upgrade')
#      {
#     # this causes upgrading
#      $upgrade = $_[$i+1];		# or undef to disable
#      $i++;
#      }
    elsif ($_[$i] eq 'downgrade')
      {
      # this causes downgrading
      $downgrade = $_[$i+1];		# or undef to disable
      $i++;
      }
    elsif ($_[$i] =~ /^(lib|try|only)\z/)
      {
      $lib = $_[$i+1] || '';		# default Calc
      $try = $1;			# lib, try or only
      $i++;
      }
    elsif ($_[$i] eq 'with')
      {
      # this argument is no longer used
      #$MBI = $_[$i+1] || 'Math::BigInt::Calc';	# default Math::BigInt::Calc
      $i++;
      }
    else
      {
      push @a, $_[$i];
      }
    }
  require Math::BigInt;

  # let use Math::BigInt lib => 'GMP'; use Math::BigRat; still have GMP
  if ($lib ne '')
    {
    my @c = split /\s*,\s*/, $lib;
    foreach (@c)
      {
      $_ =~ tr/a-zA-Z0-9://cd;                    # limit to sane characters
      }
    $lib = join(",", @c);
    }
  my @import = ('objectify');
  push @import, $try => $lib if $lib ne '';

  # MBI already loaded, so feed it our lib arguments
  Math::BigInt->import(@import);

  $MBI = Math::BigFloat->config()->{lib};

  # register us with MBI to get notified of future lib changes
  Math::BigInt::_register_callback($self, sub { $MBI = $_[0]; });

  # any non :constant stuff is handled by our parent, Exporter (loaded
  # by Math::BigFloat, even if @_ is empty, to give it a chance
  $self->SUPER::import(@a);             # for subclasses
  $self->export_to_level(1,$self,@a);   # need this, too
  }

1;

__END__

=pod

=head1 NAME

Math::BigRat - Arbitrary big rational numbers

=head1 SYNOPSIS

	use Math::BigRat;

	my $x = Math::BigRat->new('3/7'); $x += '5/9';

	print $x->bstr(),"\n";
	print $x ** 2,"\n";

	my $y = Math::BigRat->new('inf');
	print "$y ", ($y->is_inf ? 'is' : 'is not') , " infinity\n";

	my $z = Math::BigRat->new(144); $z->bsqrt();

=head1 DESCRIPTION

Math::BigRat complements Math::BigInt and Math::BigFloat by providing support
for arbitrary big rational numbers.

=head2 MATH LIBRARY

You can change the underlying module that does the low-level
math operations by using:

	use Math::BigRat try => 'GMP';

Note: This needs Math::BigInt::GMP installed.

The following would first try to find Math::BigInt::Foo, then
Math::BigInt::Bar, and when this also fails, revert to Math::BigInt::Calc:

	use Math::BigRat try => 'Foo,Math::BigInt::Bar';

If you want to get warned when the fallback occurs, replace "try" with
"lib":

	use Math::BigRat lib => 'Foo,Math::BigInt::Bar';

If you want the code to die instead, replace "try" with
"only":

	use Math::BigRat only => 'Foo,Math::BigInt::Bar';

=head1 METHODS

Any methods not listed here are derived from Math::BigFloat (or
Math::BigInt), so make sure you check these two modules for further
information.

=head2 new()

	$x = Math::BigRat->new('1/3');

Create a new Math::BigRat object. Input can come in various forms:

	$x = Math::BigRat->new(123);				# scalars
	$x = Math::BigRat->new('inf');				# infinity
	$x = Math::BigRat->new('123.3');			# float
	$x = Math::BigRat->new('1/3');				# simple string
	$x = Math::BigRat->new('1 / 3');			# spaced
	$x = Math::BigRat->new('1 / 0.1');			# w/ floats
	$x = Math::BigRat->new(Math::BigInt->new(3));		# BigInt
	$x = Math::BigRat->new(Math::BigFloat->new('3.1'));	# BigFloat
	$x = Math::BigRat->new(Math::BigInt::Lite->new('2'));	# BigLite

	# You can also give D and N as different objects:
	$x = Math::BigRat->new(
		Math::BigInt->new(-123),
		Math::BigInt->new(7),
		);			# => -123/7

=head2 numerator()

	$n = $x->numerator();

Returns a copy of the numerator (the part above the line) as signed BigInt.

=head2 denominator()

	$d = $x->denominator();

Returns a copy of the denominator (the part under the line) as positive BigInt.

=head2 parts()

	($n,$d) = $x->parts();

Return a list consisting of (signed) numerator and (unsigned) denominator as
BigInts.

=head2 numify()

	my $y = $x->numify();

Returns the object as a scalar. This will lose some data if the object
cannot be represented by a normal Perl scalar (integer or float), so
use L<as_int()|/as_int()E<sol>as_number()> or L</as_float()> instead.

This routine is automatically used whenever a scalar is required:

	my $x = Math::BigRat->new('3/1');
	@array = (0,1,2,3);
	$y = $array[$x];		# set $y to 3

=head2 as_int()/as_number()

	$x = Math::BigRat->new('13/7');
	print $x->as_int(),"\n";		# '1'

Returns a copy of the object as BigInt, truncated to an integer.

C<as_number()> is an alias for C<as_int()>.

=head2 as_float()

	$x = Math::BigRat->new('13/7');
	print $x->as_float(),"\n";		# '1'

	$x = Math::BigRat->new('2/3');
	print $x->as_float(5),"\n";		# '0.66667'

Returns a copy of the object as BigFloat, preserving the
accuracy as wanted, or the default of 40 digits.

This method was added in v0.22 of Math::BigRat (April 2008).

=head2 as_hex()

	$x = Math::BigRat->new('13');
	print $x->as_hex(),"\n";		# '0xd'

Returns the BigRat as hexadecimal string. Works only for integers.

=head2 as_bin()

	$x = Math::BigRat->new('13');
	print $x->as_bin(),"\n";		# '0x1101'

Returns the BigRat as binary string. Works only for integers.

=head2 as_oct()

	$x = Math::BigRat->new('13');
	print $x->as_oct(),"\n";		# '015'

Returns the BigRat as octal string. Works only for integers.

=head2 from_hex()/from_bin()/from_oct()

	my $h = Math::BigRat->from_hex('0x10');
	my $b = Math::BigRat->from_bin('0b10000000');
	my $o = Math::BigRat->from_oct('020');

Create a BigRat from an hexadecimal, binary or octal number
in string form.

=head2 length()

	$len = $x->length();

Return the length of $x in digits for integer values.

=head2 digit()

	print Math::BigRat->new('123/1')->digit(1);	# 1
	print Math::BigRat->new('123/1')->digit(-1);	# 3

Return the N'ths digit from X when X is an integer value.

=head2 bnorm()

	$x->bnorm();

Reduce the number to the shortest form. This routine is called
automatically whenever it is needed.

=head2 bfac()

	$x->bfac();

Calculates the factorial of $x. For instance:

	print Math::BigRat->new('3/1')->bfac(),"\n";	# 1*2*3
	print Math::BigRat->new('5/1')->bfac(),"\n";	# 1*2*3*4*5

Works currently only for integers.

=head2 bround()/round()/bfround()

Are not yet implemented.

=head2 bmod()

	$x->bmod($y);

Returns $x modulo $y. When $x is finite, and $y is finite and non-zero, the
result is identical to the remainder after floored division (F-division). If,
in addition, both $x and $y are integers, the result is identical to the result
from Perl's % operator.

=head2 bneg()

	$x->bneg();

Used to negate the object in-place.

=head2 is_one()

	print "$x is 1\n" if $x->is_one();

Return true if $x is exactly one, otherwise false.

=head2 is_zero()

	print "$x is 0\n" if $x->is_zero();

Return true if $x is exactly zero, otherwise false.

=head2 is_pos()/is_positive()

	print "$x is >= 0\n" if $x->is_positive();

Return true if $x is positive (greater than or equal to zero), otherwise
false. Please note that '+inf' is also positive, while 'NaN' and '-inf' aren't.

C<is_positive()> is an alias for C<is_pos()>.

=head2 is_neg()/is_negative()

	print "$x is < 0\n" if $x->is_negative();

Return true if $x is negative (smaller than zero), otherwise false. Please
note that '-inf' is also negative, while 'NaN' and '+inf' aren't.

C<is_negative()> is an alias for C<is_neg()>.

=head2 is_int()

	print "$x is an integer\n" if $x->is_int();

Return true if $x has a denominator of 1 (e.g. no fraction parts), otherwise
false. Please note that '-inf', 'inf' and 'NaN' aren't integer.

=head2 is_odd()

	print "$x is odd\n" if $x->is_odd();

Return true if $x is odd, otherwise false.

=head2 is_even()

	print "$x is even\n" if $x->is_even();

Return true if $x is even, otherwise false.

=head2 bceil()

	$x->bceil();

Set $x to the next bigger integer value (e.g. truncate the number to integer
and then increment it by one).

=head2 bfloor()

	$x->bfloor();

Truncate $x to an integer value.

=head2 bsqrt()

	$x->bsqrt();

Calculate the square root of $x.

=head2 broot()

	$x->broot($n);

Calculate the N'th root of $x.

=head2 badd()

        $x->badd($y);

Adds $y to $x and returns the result.

=head2 bmul()

        $x->bmul($y);

Multiplies $y to $x and returns the result.

=head2 bsub()

        $x->bsub($y);

Subtracts $y from $x and returns the result.

=head2 bdiv()

        $q = $x->bdiv($y);
        ($q, $r) = $x->bdiv($y);

In scalar context, divides $x by $y and returns the result. In list context,
does floored division (F-division), returning an integer $q and a remainder $r
so that $x = $q * $y + $r. The remainer (modulo) is equal to what is returned
by C<$x->bmod($y)>.

=head2 bdec()

        $x->bdec();

Decrements $x by 1 and returns the result.

=head2 binc()

        $x->binc();

Increments $x by 1 and returns the result.

=head2 copy()

	my $z = $x->copy();

Makes a deep copy of the object.

Please see the documentation in L<Math::BigInt> for further details.

=head2 bstr()/bsstr()

	my $x = Math::BigInt->new('8/4');
	print $x->bstr(),"\n";			# prints 1/2
	print $x->bsstr(),"\n";			# prints 1/2

Return a string representing this object.

=head2 bacmp()/bcmp()

Used to compare numbers.

Please see the documentation in L<Math::BigInt> for further details.

=head2 blsft()/brsft()

Used to shift numbers left/right.

Please see the documentation in L<Math::BigInt> for further details.

=head2 bpow()

	$x->bpow($y);

Compute $x ** $y.

Please see the documentation in L<Math::BigInt> for further details.

=head2 bexp()

	$x->bexp($accuracy);		# calculate e ** X

Calculates two integers A and B so that A/B is equal to C<e ** $x>, where C<e> is
Euler's number.

This method was added in v0.20 of Math::BigRat (May 2007).

See also C<blog()>.

=head2 bnok()

	$x->bnok($y);		   # x over y (binomial coefficient n over k)

Calculates the binomial coefficient n over k, also called the "choose"
function. The result is equivalent to:

	( n )      n!
	| - |  = -------
	( k )    k!(n-k)!

This method was added in v0.20 of Math::BigRat (May 2007).

=head2 config()

        use Data::Dumper;

        print Dumper ( Math::BigRat->config() );
        print Math::BigRat->config()->{lib},"\n";

Returns a hash containing the configuration, e.g. the version number, lib
loaded etc. The following hash keys are currently filled in with the
appropriate information.

        key             RO/RW   Description
                                Example
        ============================================================
        lib             RO      Name of the Math library
                                Math::BigInt::Calc
        lib_version     RO      Version of 'lib'
                                0.30
        class           RO      The class of config you just called
                                Math::BigRat
        version         RO      version number of the class you used
                                0.10
        upgrade         RW      To which class numbers are upgraded
                                undef
        downgrade       RW      To which class numbers are downgraded
                                undef
        precision       RW      Global precision
                                undef
        accuracy        RW      Global accuracy
                                undef
        round_mode      RW      Global round mode
                                even
        div_scale       RW      Fallback accuracy for div
                                40
        trap_nan        RW      Trap creation of NaN (undef = no)
                                undef
        trap_inf        RW      Trap creation of +inf/-inf (undef = no)
                                undef

By passing a reference to a hash you may set the configuration values. This
works only for values that a marked with a C<RW> above, anything else is
read-only.

=head2 objectify()

This is an internal routine that turns scalars into objects.

=head1 BUGS

Please report any bugs or feature requests to
C<bug-math-bigrat at rt.cpan.org>, or through the web interface at
L<https://rt.cpan.org/Ticket/Create.html?Queue=Math-BigRat>
(requires login).
We will be notified, and then you'll automatically be notified of progress on
your bug as I make changes.

=head1 SUPPORT

You can find documentation for this module with the perldoc command.

    perldoc Math::BigRat

You can also look for information at:

=over 4

=item * RT: CPAN's request tracker

L<https://rt.cpan.org/Public/Dist/Display.html?Name=Math-BigRat>

=item * AnnoCPAN: Annotated CPAN documentation

L<http://annocpan.org/dist/Math-BigRat>

=item * CPAN Ratings

L<http://cpanratings.perl.org/dist/Math-BigRat>

=item * Search CPAN

L<http://search.cpan.org/dist/Math-BigRat/>

=item * CPAN Testers Matrix

L<http://matrix.cpantesters.org/?dist=Math-BigRat>

=item * The Bignum mailing list

=over 4

=item * Post to mailing list

C<bignum at lists.scsys.co.uk>

=item * View mailing list

L<http://lists.scsys.co.uk/pipermail/bignum/>

=item * Subscribe/Unsubscribe

L<http://lists.scsys.co.uk/cgi-bin/mailman/listinfo/bignum>

=back

=back

=head1 LICENSE

This program is free software; you may redistribute it and/or modify it under
the same terms as Perl itself.

=head1 SEE ALSO

L<bigrat>, L<Math::BigFloat> and L<Math::BigInt> as well as the backends
L<Math::BigInt::FastCalc>, L<Math::BigInt::GMP>, and L<Math::BigInt::Pari>.

=head1 AUTHORS

(C) by Tels L<http://bloodgate.com/> 2001 - 2009.

Currently maintained by Peter John Acklam <pjacklam@online.no>.

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       #
# Complex numbers and associated mathematical functions
# -- Raphael Manfredi	Since Sep 1996
# -- Jarkko Hietaniemi	Since Mar 1997
# -- Daniel S. Lewart	Since Sep 1997
#

package Math::Complex;

{ use 5.006; }
use strict;

our $VERSION = 1.59;

use Config;

our($Inf, $ExpInf);
BEGIN {
    my %DBL_MAX =
	(
	  4  => '1.70141183460469229e+38',
	  8  => '1.7976931348623157e+308',
	 # AFAICT the 10, 12, and 16-byte long doubles
	 # all have the same maximum.
	 10 => '1.1897314953572317650857593266280070162E+4932',
	 12 => '1.1897314953572317650857593266280070162E+4932',
	 16 => '1.1897314953572317650857593266280070162E+4932',
	);
    my $nvsize = $Config{nvsize} ||
	        ($Config{uselongdouble} && $Config{longdblsize}) ||
                 $Config{doublesize};
    die "Math::Complex: Could not figure out nvsize\n"
	unless defined $nvsize;
    die "Math::Complex: Cannot not figure out max nv (nvsize = $nvsize)\n"
	unless defined $DBL_MAX{$nvsize};
    my $DBL_MAX = eval $DBL_MAX{$nvsize};
    die "Math::Complex: Could not figure out max nv (nvsize = $nvsize)\n"
	unless defined $DBL_MAX;
    my $BIGGER_THAN_THIS = 1e30;  # Must find something bigger than this.
    if ($^O eq 'unicosmk') {
	$Inf = $DBL_MAX;
    } else {
	local $SIG{FPE} = { };
        local $!;
	# We do want an arithmetic overflow, Inf INF inf Infinity.
	for my $t (
	    'exp(99999)',  # Enough even with 128-bit long doubles.
	    'inf',
	    'Inf',
	    'INF',
	    'infinity',
	    'Infinity',
	    'INFINITY',
	    '1e99999',
	    ) {
	    local $^W = 0;
	    my $i = eval "$t+1.0";
	    if (defined $i && $i > $BIGGER_THAN_THIS) {
		$Inf = $i;
		last;
	    }
	}
	$Inf = $DBL_MAX unless defined $Inf;  # Oh well, close enough.
	die "Math::Complex: Could not get Infinity"
	    unless $Inf > $BIGGER_THAN_THIS;
	$ExpInf = exp(99999);
    }
    # print "# On this machine, Inf = '$Inf'\n";
}

use Scalar::Util qw(set_prototype);

use warnings;
no warnings 'syntax';  # To avoid the (_) warnings.

BEGIN {
    # For certain functions that we override, in 5.10 or better
    # we can set a smarter prototype that will handle the lexical $_
    # (also a 5.10+ feature).
    if ($] >= 5.010000) {
        set_prototype \&abs, '_';
        set_prototype \&cos, '_';
        set_prototype \&exp, '_';
        set_prototype \&log, '_';
        set_prototype \&sin, '_';
        set_prototype \&sqrt, '_';
    }
}

my $i;
my %LOGN;

# Regular expression for floating point numbers.
# These days we could use Scalar::Util::lln(), I guess.
my $gre = qr'\s*([\+\-]?(?:(?:(?:\d+(?:_\d+)*(?:\.\d*(?:_\d+)*)?|\.\d+(?:_\d+)*)(?:[eE][\+\-]?\d+(?:_\d+)*)?))|inf)'i;

require Exporter;

our @ISA = qw(Exporter);

my @trig = qw(
	      pi
	      tan
	      csc cosec sec cot cotan
	      asin acos atan
	      acsc acosec asec acot acotan
	      sinh cosh tanh
	      csch cosech sech coth cotanh
	      asinh acosh atanh
	      acsch acosech asech acoth acotanh
	     );

our @EXPORT = (qw(
	     i Re Im rho theta arg
	     sqrt log ln
	     log10 logn cbrt root
	     cplx cplxe
	     atan2
	     ),
	   @trig);

my @pi = qw(pi pi2 pi4 pip2 pip4 Inf);

our @EXPORT_OK = @pi;

our %EXPORT_TAGS = (
    'trig' => [@trig],
    'pi' => [@pi],
);

use overload
	'='	=> \&_copy,
	'+='	=> \&_plus,
	'+'	=> \&_plus,
	'-='	=> \&_minus,
	'-'	=> \&_minus,
	'*='	=> \&_multiply,
	'*'	=> \&_multiply,
	'/='	=> \&_divide,
	'/'	=> \&_divide,
	'**='	=> \&_power,
	'**'	=> \&_power,
	'=='	=> \&_numeq,
	'<=>'	=> \&_spaceship,
	'neg'	=> \&_negate,
	'~'	=> \&_conjugate,
	'abs'	=> \&abs,
	'sqrt'	=> \&sqrt,
	'exp'	=> \&exp,
	'log'	=> \&log,
	'sin'	=> \&sin,
	'cos'	=> \&cos,
	'atan2'	=> \&atan2,
        '""'    => \&_stringify;

#
# Package "privates"
#

my %DISPLAY_FORMAT = ('style' => 'cartesian',
		      'polar_pretty_print' => 1);
my $eps            = 1e-14;		# Epsilon

#
# Object attributes (internal):
#	cartesian	[real, imaginary] -- cartesian form
#	polar		[rho, theta] -- polar form
#	c_dirty		cartesian form not up-to-date
#	p_dirty		polar form not up-to-date
#	display		display format (package's global when not set)
#

# Die on bad *make() arguments.

sub _cannot_make {
    die "@{[(caller(1))[3]]}: Cannot take $_[0] of '$_[1]'.\n";
}

sub _make {
    my $arg = shift;
    my ($p, $q);

    if ($arg =~ /^$gre$/) {
	($p, $q) = ($1, 0);
    } elsif ($arg =~ /^(?:$gre)?$gre\s*i\s*$/) {
	($p, $q) = ($1 || 0, $2);
    } elsif ($arg =~ /^\s*\(\s*$gre\s*(?:,\s*$gre\s*)?\)\s*$/) {
	($p, $q) = ($1, $2 || 0);
    }

    if (defined $p) {
	$p =~ s/^\+//;
	$p =~ s/^(-?)inf$/"${1}9**9**9"/e;
	$q =~ s/^\+//;
	$q =~ s/^(-?)inf$/"${1}9**9**9"/e;
    }

    return ($p, $q);
}

sub _emake {
    my $arg = shift;
    my ($p, $q);

    if ($arg =~ /^\s*\[\s*$gre\s*(?:,\s*$gre\s*)?\]\s*$/) {
	($p, $q) = ($1, $2 || 0);
    } elsif ($arg =~ m!^\s*\[\s*$gre\s*(?:,\s*([-+]?\d*\s*)?pi(?:/\s*(\d+))?\s*)?\]\s*$!) {
	($p, $q) = ($1, ($2 eq '-' ? -1 : ($2 || 1)) * pi() / ($3 || 1));
    } elsif ($arg =~ /^\s*\[\s*$gre\s*\]\s*$/) {
	($p, $q) = ($1, 0);
    } elsif ($arg =~ /^\s*$gre\s*$/) {
	($p, $q) = ($1, 0);
    }

    if (defined $p) {
	$p =~ s/^\+//;
	$q =~ s/^\+//;
	$p =~ s/^(-?)inf$/"${1}9**9**9"/e;
	$q =~ s/^(-?)inf$/"${1}9**9**9"/e;
    }

    return ($p, $q);
}

sub _copy {
    my $self = shift;
    my $clone = {%$self};
    if ($self->{'cartesian'}) {
	$clone->{'cartesian'} = [@{$self->{'cartesian'}}];
    }
    if ($self->{'polar'}) {
	$clone->{'polar'} = [@{$self->{'polar'}}];
    }
    bless $clone,__PACKAGE__;
    return $clone;
}

#
# ->make
#
# Create a new complex number (cartesian form)
#
sub make {
    my $self = bless {}, shift;
    my ($re, $im);
    if (@_ == 0) {
	($re, $im) = (0, 0);
    } elsif (@_ == 1) {
	return (ref $self)->emake($_[0])
	    if ($_[0] =~ /^\s*\[/);
	($re, $im) = _make($_[0]);
    } elsif (@_ == 2) {
	($re, $im) = @_;
    }
    if (defined $re) {
	_cannot_make("real part",      $re) unless $re =~ /^$gre$/;
    }
    $im ||= 0;
    _cannot_make("imaginary part", $im) unless $im =~ /^$gre$/;
    $self->_set_cartesian([$re, $im ]);
    $self->display_format('cartesian');

    return $self;
}

#
# ->emake
#
# Create a new complex number (exponential form)
#
sub emake {
    my $self = bless {}, shift;
    my ($rho, $theta);
    if (@_ == 0) {
	($rho, $theta) = (0, 0);
    } elsif (@_ == 1) {
	return (ref $self)->make($_[0])
	    if ($_[0] =~ /^\s*\(/ || $_[0] =~ /i\s*$/);
	($rho, $theta) = _emake($_[0]);
    } elsif (@_ == 2) {
	($rho, $theta) = @_;
    }
    if (defined $rho && defined $theta) {
	if ($rho < 0) {
	    $rho   = -$rho;
	    $theta = ($theta <= 0) ? $theta + pi() : $theta - pi();
	}
    }
    if (defined $rho) {
	_cannot_make("rho",   $rho)   unless $rho   =~ /^$gre$/;
    }
    $theta ||= 0;
    _cannot_make("theta", $theta) unless $theta =~ /^$gre$/;
    $self->_set_polar([$rho, $theta]);
    $self->display_format('polar');

    return $self;
}

sub new { &make }		# For backward compatibility only.

#
# cplx
#
# Creates a complex number from a (re, im) tuple.
# This avoids the burden of writing Math::Complex->make(re, im).
#
sub cplx {
	return __PACKAGE__->make(@_);
}

#
# cplxe
#
# Creates a complex number from a (rho, theta) tuple.
# This avoids the burden of writing Math::Complex->emake(rho, theta).
#
sub cplxe {
	return __PACKAGE__->emake(@_);
}

#
# pi
#
# The number defined as pi = 180 degrees
#
sub pi () { 4 * CORE::atan2(1, 1) }

#
# pi2
#
# The full circle
#
sub pi2 () { 2 * pi }

#
# pi4
#
# The full circle twice.
#
sub pi4 () { 4 * pi }

#
# pip2
#
# The quarter circle
#
sub pip2 () { pi / 2 }

#
# pip4
#
# The eighth circle.
#
sub pip4 () { pi / 4 }

#
# _uplog10
#
# Used in log10().
#
sub _uplog10 () { 1 / CORE::log(10) }

#
# i
#
# The number defined as i*i = -1;
#
sub i () {
        return $i if ($i);
	$i = bless {};
	$i->{'cartesian'} = [0, 1];
	$i->{'polar'}     = [1, pip2];
	$i->{c_dirty} = 0;
	$i->{p_dirty} = 0;
	return $i;
}

#
# _ip2
#
# Half of i.
#
sub _ip2 () { i / 2 }

#
# Attribute access/set routines
#

sub _cartesian {$_[0]->{c_dirty} ?
		   $_[0]->_update_cartesian : $_[0]->{'cartesian'}}
sub _polar     {$_[0]->{p_dirty} ?
		   $_[0]->_update_polar : $_[0]->{'polar'}}

sub _set_cartesian { $_[0]->{p_dirty}++; $_[0]->{c_dirty} = 0;
		     $_[0]->{'cartesian'} = $_[1] }
sub _set_polar     { $_[0]->{c_dirty}++; $_[0]->{p_dirty} = 0;
		     $_[0]->{'polar'} = $_[1] }

#
# ->_update_cartesian
#
# Recompute and return the cartesian form, given accurate polar form.
#
sub _update_cartesian {
	my $self = shift;
	my ($r, $t) = @{$self->{'polar'}};
	$self->{c_dirty} = 0;
	return $self->{'cartesian'} = [$r * CORE::cos($t), $r * CORE::sin($t)];
}

#
#
# ->_update_polar
#
# Recompute and return the polar form, given accurate cartesian form.
#
sub _update_polar {
	my $self = shift;
	my ($x, $y) = @{$self->{'cartesian'}};
	$self->{p_dirty} = 0;
	return $self->{'polar'} = [0, 0] if $x == 0 && $y == 0;
	return $self->{'polar'} = [CORE::sqrt($x*$x + $y*$y),
				   CORE::atan2($y, $x)];
}

#
# (_plus)
#
# Computes z1+z2.
#
sub _plus {
	my ($z1, $z2, $regular) = @_;
	my ($re1, $im1) = @{$z1->_cartesian};
	$z2 = cplx($z2) unless ref $z2;
	my ($re2, $im2) = ref $z2 ? @{$z2->_cartesian} : ($z2, 0);
	unless (defined $regular) {
		$z1->_set_cartesian([$re1 + $re2, $im1 + $im2]);
		return $z1;
	}
	return (ref $z1)->make($re1 + $re2, $im1 + $im2);
}

#
# (_minus)
#
# Computes z1-z2.
#
sub _minus {
	my ($z1, $z2, $inverted) = @_;
	my ($re1, $im1) = @{$z1->_cartesian};
	$z2 = cplx($z2) unless ref $z2;
	my ($re2, $im2) = @{$z2->_cartesian};
	unless (defined $inverted) {
		$z1->_set_cartesian([$re1 - $re2, $im1 - $im2]);
		return $z1;
	}
	return $inverted ?
		(ref $z1)->make($re2 - $re1, $im2 - $im1) :
		(ref $z1)->make($re1 - $re2, $im1 - $im2);

}

#
# (_multiply)
#
# Computes z1*z2.
#
sub _multiply {
        my ($z1, $z2, $regular) = @_;
	if ($z1->{p_dirty} == 0 and ref $z2 and $z2->{p_dirty} == 0) {
	    # if both polar better use polar to avoid rounding errors
	    my ($r1, $t1) = @{$z1->_polar};
	    my ($r2, $t2) = @{$z2->_polar};
	    my $t = $t1 + $t2;
	    if    ($t >   pi()) { $t -= pi2 }
	    elsif ($t <= -pi()) { $t += pi2 }
	    unless (defined $regular) {
		$z1->_set_polar([$r1 * $r2, $t]);
		return $z1;
	    }
	    return (ref $z1)->emake($r1 * $r2, $t);
	} else {
	    my ($x1, $y1) = @{$z1->_cartesian};
	    if (ref $z2) {
		my ($x2, $y2) = @{$z2->_cartesian};
		return (ref $z1)->make($x1*$x2-$y1*$y2, $x1*$y2+$y1*$x2);
	    } else {
		return (ref $z1)->make($x1*$z2, $y1*$z2);
	    }
	}
}

#
# _divbyzero
#
# Die on division by zero.
#
sub _divbyzero {
    my $mess = "$_[0]: Division by zero.\n";

    if (defined $_[1]) {
	$mess .= "(Because in the definition of $_[0], the divisor ";
	$mess .= "$_[1] " unless ("$_[1]" eq '0');
	$mess .= "is 0)\n";
    }

    my @up = caller(1);

    $mess .= "Died at $up[1] line $up[2].\n";

    die $mess;
}

#
# (_divide)
#
# Computes z1/z2.
#
sub _divide {
	my ($z1, $z2, $inverted) = @_;
	if ($z1->{p_dirty} == 0 and ref $z2 and $z2->{p_dirty} == 0) {
	    # if both polar better use polar to avoid rounding errors
	    my ($r1, $t1) = @{$z1->_polar};
	    my ($r2, $t2) = @{$z2->_polar};
	    my $t;
	    if ($inverted) {
		_divbyzero "$z2/0" if ($r1 == 0);
		$t = $t2 - $t1;
		if    ($t >   pi()) { $t -= pi2 }
		elsif ($t <= -pi()) { $t += pi2 }
		return (ref $z1)->emake($r2 / $r1, $t);
	    } else {
		_divbyzero "$z1/0" if ($r2 == 0);
		$t = $t1 - $t2;
		if    ($t >   pi()) { $t -= pi2 }
		elsif ($t <= -pi()) { $t += pi2 }
		return (ref $z1)->emake($r1 / $r2, $t);
	    }
	} else {
	    my ($d, $x2, $y2);
	    if ($inverted) {
		($x2, $y2) = @{$z1->_cartesian};
		$d = $x2*$x2 + $y2*$y2;
		_divbyzero "$z2/0" if $d == 0;
		return (ref $z1)->make(($x2*$z2)/$d, -($y2*$z2)/$d);
	    } else {
		my ($x1, $y1) = @{$z1->_cartesian};
		if (ref $z2) {
		    ($x2, $y2) = @{$z2->_cartesian};
		    $d = $x2*$x2 + $y2*$y2;
		    _divbyzero "$z1/0" if $d == 0;
		    my $u = ($x1*$x2 + $y1*$y2)/$d;
		    my $v = ($y1*$x2 - $x1*$y2)/$d;
		    return (ref $z1)->make($u, $v);
		} else {
		    _divbyzero "$z1/0" if $z2 == 0;
		    return (ref $z1)->make($x1/$z2, $y1/$z2);
		}
	    }
	}
}

#
# (_power)
#
# Computes z1**z2 = exp(z2 * log z1)).
#
sub _power {
	my ($z1, $z2, $inverted) = @_;
	if ($inverted) {
	    return 1 if $z1 == 0 || $z2 == 1;
	    return 0 if $z2 == 0 && Re($z1) > 0;
	} else {
	    return 1 if $z2 == 0 || $z1 == 1;
	    return 0 if $z1 == 0 && Re($z2) > 0;
	}
	my $w = $inverted ? &exp($z1 * &log($z2))
	                  : &exp($z2 * &log($z1));
	# If both arguments cartesian, return cartesian, else polar.
	return $z1->{c_dirty} == 0 &&
	       (not ref $z2 or $z2->{c_dirty} == 0) ?
	       cplx(@{$w->_cartesian}) : $w;
}

#
# (_spaceship)
#
# Computes z1 <=> z2.
# Sorts on the real part first, then on the imaginary part. Thus 2-4i < 3+8i.
#
sub _spaceship {
	my ($z1, $z2, $inverted) = @_;
	my ($re1, $im1) = ref $z1 ? @{$z1->_cartesian} : ($z1, 0);
	my ($re2, $im2) = ref $z2 ? @{$z2->_cartesian} : ($z2, 0);
	my $sgn = $inverted ? -1 : 1;
	return $sgn * ($re1 <=> $re2) if $re1 != $re2;
	return $sgn * ($im1 <=> $im2);
}

#
# (_numeq)
#
# Computes z1 == z2.
#
# (Required in addition to _spaceship() because of NaNs.)
sub _numeq {
	my ($z1, $z2, $inverted) = @_;
	my ($re1, $im1) = ref $z1 ? @{$z1->_cartesian} : ($z1, 0);
	my ($re2, $im2) = ref $z2 ? @{$z2->_cartesian} : ($z2, 0);
	return $re1 == $re2 && $im1 == $im2 ? 1 : 0;
}

#
# (_negate)
#
# Computes -z.
#
sub _negate {
	my ($z) = @_;
	if ($z->{c_dirty}) {
		my ($r, $t) = @{$z->_polar};
		$t = ($t <= 0) ? $t + pi : $t - pi;
		return (ref $z)->emake($r, $t);
	}
	my ($re, $im) = @{$z->_cartesian};
	return (ref $z)->make(-$re, -$im);
}

#
# (_conjugate)
#
# Compute complex's _conjugate.
#
sub _conjugate {
	my ($z) = @_;
	if ($z->{c_dirty}) {
		my ($r, $t) = @{$z->_polar};
		return (ref $z)->emake($r, -$t);
	}
	my ($re, $im) = @{$z->_cartesian};
	return (ref $z)->make($re, -$im);
}

#
# (abs)
#
# Compute or set complex's norm (rho).
#
sub abs {
	my ($z, $rho) = @_ ? @_ : $_;
	unless (ref $z) {
	    if (@_ == 2) {
		$_[0] = $_[1];
	    } else {
		return CORE::abs($z);
	    }
	}
	if (defined $rho) {
	    $z->{'polar'} = [ $rho, ${$z->_polar}[1] ];
	    $z->{p_dirty} = 0;
	    $z->{c_dirty} = 1;
	    return $rho;
	} else {
	    return ${$z->_polar}[0];
	}
}

sub _theta {
    my $theta = $_[0];

    if    ($$theta >   pi()) { $$theta -= pi2 }
    elsif ($$theta <= -pi()) { $$theta += pi2 }
}

#
# arg
#
# Compute or set complex's argument (theta).
#
sub arg {
	my ($z, $theta) = @_;
	return $z unless ref $z;
	if (defined $theta) {
	    _theta(\$theta);
	    $z->{'polar'} = [ ${$z->_polar}[0], $theta ];
	    $z->{p_dirty} = 0;
	    $z->{c_dirty} = 1;
	} else {
	    $theta = ${$z->_polar}[1];
	    _theta(\$theta);
	}
	return $theta;
}

#
# (sqrt)
#
# Compute sqrt(z).
#
# It is quite tempting to use wantarray here so that in list context
# sqrt() would return the two solutions.  This, however, would
# break things like
#
#	print "sqrt(z) = ", sqrt($z), "\n";
#
# The two values would be printed side by side without no intervening
# whitespace, quite confusing.
# Therefore if you want the two solutions use the root().
#
sub sqrt {
	my ($z) = @_ ? $_[0] : $_;
	my ($re, $im) = ref $z ? @{$z->_cartesian} : ($z, 0);
	return $re < 0 ? cplx(0, CORE::sqrt(-$re)) : CORE::sqrt($re)
	    if $im == 0;
	my ($r, $t) = @{$z->_polar};
	return (ref $z)->emake(CORE::sqrt($r), $t/2);
}

#
# cbrt
#
# Compute cbrt(z) (cubic root).
#
# Why are we not returning three values?  The same answer as for sqrt().
#
sub cbrt {
	my ($z) = @_;
	return $z < 0 ?
	    -CORE::exp(CORE::log(-$z)/3) :
		($z > 0 ? CORE::exp(CORE::log($z)/3): 0)
	    unless ref $z;
	my ($r, $t) = @{$z->_polar};
	return 0 if $r == 0;
	return (ref $z)->emake(CORE::exp(CORE::log($r)/3), $t/3);
}

#
# _rootbad
#
# Die on bad root.
#
sub _rootbad {
    my $mess = "Root '$_[0]' illegal, root rank must be positive integer.\n";

    my @up = caller(1);

    $mess .= "Died at $up[1] line $up[2].\n";

    die $mess;
}

#
# root
#
# Computes all nth root for z, returning an array whose size is n.
# `n' must be a positive integer.
#
# The roots are given by (for k = 0..n-1):
#
# z^(1/n) = r^(1/n) (cos ((t+2 k pi)/n) + i sin ((t+2 k pi)/n))
#
sub root {
	my ($z, $n, $k) = @_;
	_rootbad($n) if ($n < 1 or int($n) != $n);
	my ($r, $t) = ref $z ?
	    @{$z->_polar} : (CORE::abs($z), $z >= 0 ? 0 : pi);
	my $theta_inc = pi2 / $n;
	my $rho = $r ** (1/$n);
	my $cartesian = ref $z && $z->{c_dirty} == 0;
	if (@_ == 2) {
	    my @root;
	    for (my $i = 0, my $theta = $t / $n;
		 $i < $n;
		 $i++, $theta += $theta_inc) {
		my $w = cplxe($rho, $theta);
		# Yes, $cartesian is loop invariant.
		push @root, $cartesian ? cplx(@{$w->_cartesian}) : $w;
	    }
	    return @root;
	} elsif (@_ == 3) {
	    my $w = cplxe($rho, $t / $n + $k * $theta_inc);
	    return $cartesian ? cplx(@{$w->_cartesian}) : $w;
	}
}

#
# Re
#
# Return or set Re(z).
#
sub Re {
	my ($z, $Re) = @_;
	return $z unless ref $z;
	if (defined $Re) {
	    $z->{'cartesian'} = [ $Re, ${$z->_cartesian}[1] ];
	    $z->{c_dirty} = 0;
	    $z->{p_dirty} = 1;
	} else {
	    return ${$z->_cartesian}[0];
	}
}

#
# Im
#
# Return or set Im(z).
#
sub Im {
	my ($z, $Im) = @_;
	return 0 unless ref $z;
	if (defined $Im) {
	    $z->{'cartesian'} = [ ${$z->_cartesian}[0], $Im ];
	    $z->{c_dirty} = 0;
	    $z->{p_dirty} = 1;
	} else {
	    return ${$z->_cartesian}[1];
	}
}

#
# rho
#
# Return or set rho(w).
#
sub rho {
    Math::Complex::abs(@_);
}

#
# theta
#
# Return or set theta(w).
#
sub theta {
    Math::Complex::arg(@_);
}

#
# (exp)
#
# Computes exp(z).
#
sub exp {
    my ($z) = @_ ? @_ : $_;
    return CORE::exp($z) unless ref $z;
    my ($x, $y) = @{$z->_cartesian};
    return (ref $z)->emake(CORE::exp($x), $y);
}

#
# _logofzero
#
# Die on logarithm of zero.
#
sub _logofzero {
    my $mess = "$_[0]: Logarithm of zero.\n";

    if (defined $_[1]) {
	$mess .= "(Because in the definition of $_[0], the argument ";
	$mess .= "$_[1] " unless ($_[1] eq '0');
	$mess .= "is 0)\n";
    }

    my @up = caller(1);

    $mess .= "Died at $up[1] line $up[2].\n";

    die $mess;
}

#
# (log)
#
# Compute log(z).
#
sub log {
	my ($z) = @_ ? @_ : $_;
	unless (ref $z) {
	    _logofzero("log") if $z == 0;
	    return $z > 0 ? CORE::log($z) : cplx(CORE::log(-$z), pi);
	}
	my ($r, $t) = @{$z->_polar};
	_logofzero("log") if $r == 0;
	if    ($t >   pi()) { $t -= pi2 }
	elsif ($t <= -pi()) { $t += pi2 }
	return (ref $z)->make(CORE::log($r), $t);
}

#
# ln
#
# Alias for log().
#
sub ln { Math::Complex::log(@_) }

#
# log10
#
# Compute log10(z).
#

sub log10 {
	return Math::Complex::log($_[0]) * _uplog10;
}

#
# logn
#
# Compute logn(z,n) = log(z) / log(n)
#
sub logn {
	my ($z, $n) = @_;
	$z = cplx($z, 0) unless ref $z;
	my $logn = $LOGN{$n};
	$logn = $LOGN{$n} = CORE::log($n) unless defined $logn;	# Cache log(n)
	return &log($z) / $logn;
}

#
# (cos)
#
# Compute cos(z) = (exp(iz) + exp(-iz))/2.
#
sub cos {
	my ($z) = @_ ? @_ : $_;
	return CORE::cos($z) unless ref $z;
	my ($x, $y) = @{$z->_cartesian};
	my $ey = CORE::exp($y);
	my $sx = CORE::sin($x);
	my $cx = CORE::cos($x);
	my $ey_1 = $ey ? 1 / $ey : Inf();
	return (ref $z)->make($cx * ($ey + $ey_1)/2,
			      $sx * ($ey_1 - $ey)/2);
}

#
# (sin)
#
# Compute sin(z) = (exp(iz) - exp(-iz))/2.
#
sub sin {
	my ($z) = @_ ? @_ : $_;
	return CORE::sin($z) unless ref $z;
	my ($x, $y) = @{$z->_cartesian};
	my $ey = CORE::exp($y);
	my $sx = CORE::sin($x);
	my $cx = CORE::cos($x);
	my $ey_1 = $ey ? 1 / $ey : Inf();
	return (ref $z)->make($sx * ($ey + $ey_1)/2,
			      $cx * ($ey - $ey_1)/2);
}

#
# tan
#
# Compute tan(z) = sin(z) / cos(z).
#
sub tan {
	my ($z) = @_;
	my $cz = &cos($z);
	_divbyzero "tan($z)", "cos($z)" if $cz == 0;
	return &sin($z) / $cz;
}

#
# sec
#
# Computes the secant sec(z) = 1 / cos(z).
#
sub sec {
	my ($z) = @_;
	my $cz = &cos($z);
	_divbyzero "sec($z)", "cos($z)" if ($cz == 0);
	return 1 / $cz;
}

#
# csc
#
# Computes the cosecant csc(z) = 1 / sin(z).
#
sub csc {
	my ($z) = @_;
	my $sz = &sin($z);
	_divbyzero "csc($z)", "sin($z)" if ($sz == 0);
	return 1 / $sz;
}

#
# cosec
#
# Alias for csc().
#
sub cosec { Math::Complex::csc(@_) }

#
# cot
#
# Computes cot(z) = cos(z) / sin(z).
#
sub cot {
	my ($z) = @_;
	my $sz = &sin($z);
	_divbyzero "cot($z)", "sin($z)" if ($sz == 0);
	return &cos($z) / $sz;
}

#
# cotan
#
# Alias for cot().
#
sub cotan { Math::Complex::cot(@_) }

#
# acos
#
# Computes the arc cosine acos(z) = -i log(z + sqrt(z*z-1)).
#
sub acos {
	my $z = $_[0];
	return CORE::atan2(CORE::sqrt(1-$z*$z), $z)
	    if (! ref $z) && CORE::abs($z) <= 1;
	$z = cplx($z, 0) unless ref $z;
	my ($x, $y) = @{$z->_cartesian};
	return 0 if $x == 1 && $y == 0;
	my $t1 = CORE::sqrt(($x+1)*($x+1) + $y*$y);
	my $t2 = CORE::sqrt(($x-1)*($x-1) + $y*$y);
	my $alpha = ($t1 + $t2)/2;
	my $beta  = ($t1 - $t2)/2;
	$alpha = 1 if $alpha < 1;
	if    ($beta >  1) { $beta =  1 }
	elsif ($beta < -1) { $beta = -1 }
	my $u = CORE::atan2(CORE::sqrt(1-$beta*$beta), $beta);
	my $v = CORE::log($alpha + CORE::sqrt($alpha*$alpha-1));
	$v = -$v if $y > 0 || ($y == 0 && $x < -1);
	return (ref $z)->make($u, $v);
}

#
# asin
#
# Computes the arc sine asin(z) = -i log(iz + sqrt(1-z*z)).
#
sub asin {
	my $z = $_[0];
	return CORE::atan2($z, CORE::sqrt(1-$z*$z))
	    if (! ref $z) && CORE::abs($z) <= 1;
	$z = cplx($z, 0) unless ref $z;
	my ($x, $y) = @{$z->_cartesian};
	return 0 if $x == 0 && $y == 0;
	my $t1 = CORE::sqrt(($x+1)*($x+1) + $y*$y);
	my $t2 = CORE::sqrt(($x-1)*($x-1) + $y*$y);
	my $alpha = ($t1 + $t2)/2;
	my $beta  = ($t1 - $t2)/2;
	$alpha = 1 if $alpha < 1;
	if    ($beta >  1) { $beta =  1 }
	elsif ($beta < -1) { $beta = -1 }
	my $u =  CORE::atan2($beta, CORE::sqrt(1-$beta*$beta));
	my $v = -CORE::log($alpha + CORE::sqrt($alpha*$alpha-1));
	$v = -$v if $y > 0 || ($y == 0 && $x < -1);
	return (ref $z)->make($u, $v);
}

#
# atan
#
# Computes the arc tangent atan(z) = i/2 log((i+z) / (i-z)).
#
sub atan {
	my ($z) = @_;
	return CORE::atan2($z, 1) unless ref $z;
	my ($x, $y) = ref $z ? @{$z->_cartesian} : ($z, 0);
	return 0 if $x == 0 && $y == 0;
	_divbyzero "atan(i)"  if ( $z == i);
	_logofzero "atan(-i)" if (-$z == i); # -i is a bad file test...
	my $log = &log((i + $z) / (i - $z));
	return _ip2 * $log;
}

#
# asec
#
# Computes the arc secant asec(z) = acos(1 / z).
#
sub asec {
	my ($z) = @_;
	_divbyzero "asec($z)", $z if ($z == 0);
	return acos(1 / $z);
}

#
# acsc
#
# Computes the arc cosecant acsc(z) = asin(1 / z).
#
sub acsc {
	my ($z) = @_;
	_divbyzero "acsc($z)", $z if ($z == 0);
	return asin(1 / $z);
}

#
# acosec
#
# Alias for acsc().
#
sub acosec { Math::Complex::acsc(@_) }

#
# acot
#
# Computes the arc cotangent acot(z) = atan(1 / z)
#
sub acot {
	my ($z) = @_;
	_divbyzero "acot(0)"  if $z == 0;
	return ($z >= 0) ? CORE::atan2(1, $z) : CORE::atan2(-1, -$z)
	    unless ref $z;
	_divbyzero "acot(i)"  if ($z - i == 0);
	_logofzero "acot(-i)" if ($z + i == 0);
	return atan(1 / $z);
}

#
# acotan
#
# Alias for acot().
#
sub acotan { Math::Complex::acot(@_) }

#
# cosh
#
# Computes the hyperbolic cosine cosh(z) = (exp(z) + exp(-z))/2.
#
sub cosh {
	my ($z) = @_;
	my $ex;
	unless (ref $z) {
	    $ex = CORE::exp($z);
            return $ex ? ($ex == $ExpInf ? Inf() : ($ex + 1/$ex)/2) : Inf();
	}
	my ($x, $y) = @{$z->_cartesian};
	$ex = CORE::exp($x);
	my $ex_1 = $ex ? 1 / $ex : Inf();
	return (ref $z)->make(CORE::cos($y) * ($ex + $ex_1)/2,
			      CORE::sin($y) * ($ex - $ex_1)/2);
}

#
# sinh
#
# Computes the hyperbolic sine sinh(z) = (exp(z) - exp(-z))/2.
#
sub sinh {
	my ($z) = @_;
	my $ex;
	unless (ref $z) {
	    return 0 if $z == 0;
	    $ex = CORE::exp($z);
            return $ex ? ($ex == $ExpInf ? Inf() : ($ex - 1/$ex)/2) : -Inf();
	}
	my ($x, $y) = @{$z->_cartesian};
	my $cy = CORE::cos($y);
	my $sy = CORE::sin($y);
	$ex = CORE::exp($x);
	my $ex_1 = $ex ? 1 / $ex : Inf();
	return (ref $z)->make(CORE::cos($y) * ($ex - $ex_1)/2,
			      CORE::sin($y) * ($ex + $ex_1)/2);
}

#
# tanh
#
# Computes the hyperbolic tangent tanh(z) = sinh(z) / cosh(z).
#
sub tanh {
	my ($z) = @_;
	my $cz = cosh($z);
	_divbyzero "tanh($z)", "cosh($z)" if ($cz == 0);
	my $sz = sinh($z);
	return  1 if $cz ==  $sz;
	return -1 if $cz == -$sz;
	return $sz / $cz;
}

#
# sech
#
# Computes the hyperbolic secant sech(z) = 1 / cosh(z).
#
sub sech {
	my ($z) = @_;
	my $cz = cosh($z);
	_divbyzero "sech($z)", "cosh($z)" if ($cz == 0);
	return 1 / $cz;
}

#
# csch
#
# Computes the hyperbolic cosecant csch(z) = 1 / sinh(z).
#
sub csch {
	my ($z) = @_;
	my $sz = sinh($z);
	_divbyzero "csch($z)", "sinh($z)" if ($sz == 0);
	return 1 / $sz;
}

#
# cosech
#
# Alias for csch().
#
sub cosech { Math::Complex::csch(@_) }

#
# coth
#
# Computes the hyperbolic cotangent coth(z) = cosh(z) / sinh(z).
#
sub coth {
	my ($z) = @_;
	my $sz = sinh($z);
	_divbyzero "coth($z)", "sinh($z)" if $sz == 0;
	my $cz = cosh($z);
	return  1 if $cz ==  $sz;
	return -1 if $cz == -$sz;
	return $cz / $sz;
}

#
# cotanh
#
# Alias for coth().
#
sub cotanh { Math::Complex::coth(@_) }

#
# acosh
#
# Computes the area/inverse hyperbolic cosine acosh(z) = log(z + sqrt(z*z-1)).
#
sub acosh {
	my ($z) = @_;
	unless (ref $z) {
	    $z = cplx($z, 0);
	}
	my ($re, $im) = @{$z->_cartesian};
	if ($im == 0) {
	    return CORE::log($re + CORE::sqrt($re*$re - 1))
		if $re >= 1;
	    return cplx(0, CORE::atan2(CORE::sqrt(1 - $re*$re), $re))
		if CORE::abs($re) < 1;
	}
	my $t = &sqrt($z * $z - 1) + $z;
	# Try Taylor if looking bad (this usually means that
	# $z was large negative, therefore the sqrt is really
	# close to abs(z), summing that with z...)
	$t = 1/(2 * $z) - 1/(8 * $z**3) + 1/(16 * $z**5) - 5/(128 * $z**7)
	    if $t == 0;
	my $u = &log($t);
	$u->Im(-$u->Im) if $re < 0 && $im == 0;
	return $re < 0 ? -$u : $u;
}

#
# asinh
#
# Computes the area/inverse hyperbolic sine asinh(z) = log(z + sqrt(z*z+1))
#
sub asinh {
	my ($z) = @_;
	unless (ref $z) {
	    my $t = $z + CORE::sqrt($z*$z + 1);
	    return CORE::log($t) if $t;
	}
	my $t = &sqrt($z * $z + 1) + $z;
	# Try Taylor if looking bad (this usually means that
	# $z was large negative, therefore the sqrt is really
	# close to abs(z), summing that with z...)
	$t = 1/(2 * $z) - 1/(8 * $z**3) + 1/(16 * $z**5) - 5/(128 * $z**7)
	    if $t == 0;
	return &log($t);
}

#
# atanh
#
# Computes the area/inverse hyperbolic tangent atanh(z) = 1/2 log((1+z) / (1-z)).
#
sub atanh {
	my ($z) = @_;
	unless (ref $z) {
	    return CORE::log((1 + $z)/(1 - $z))/2 if CORE::abs($z) < 1;
	    $z = cplx($z, 0);
	}
	_divbyzero 'atanh(1)',  "1 - $z" if (1 - $z == 0);
	_logofzero 'atanh(-1)'           if (1 + $z == 0);
	return 0.5 * &log((1 + $z) / (1 - $z));
}

#
# asech
#
# Computes the area/inverse hyperbolic secant asech(z) = acosh(1 / z).
#
sub asech {
	my ($z) = @_;
	_divbyzero 'asech(0)', "$z" if ($z == 0);
	return acosh(1 / $z);
}

#
# acsch
#
# Computes the area/inverse hyperbolic cosecant acsch(z) = asinh(1 / z).
#
sub acsch {
	my ($z) = @_;
	_divbyzero 'acsch(0)', $z if ($z == 0);
	return asinh(1 / $z);
}

#
# acosech
#
# Alias for acosh().
#
sub acosech { Math::Complex::acsch(@_) }

#
# acoth
#
# Computes the area/inverse hyperbolic cotangent acoth(z) = 1/2 log((1+z) / (z-1)).
#
sub acoth {
	my ($z) = @_;
	_divbyzero 'acoth(0)'            if ($z == 0);
	unless (ref $z) {
	    return CORE::log(($z + 1)/($z - 1))/2 if CORE::abs($z) > 1;
	    $z = cplx($z, 0);
	}
	_divbyzero 'acoth(1)',  "$z - 1" if ($z - 1 == 0);
	_logofzero 'acoth(-1)', "1 + $z" if (1 + $z == 0);
	return &log((1 + $z) / ($z - 1)) / 2;
}

#
# acotanh
#
# Alias for acot().
#
sub acotanh { Math::Complex::acoth(@_) }

#
# (atan2)
#
# Compute atan(z1/z2), minding the right quadrant.
#
sub atan2 {
	my ($z1, $z2, $inverted) = @_;
	my ($re1, $im1, $re2, $im2);
	if ($inverted) {
	    ($re1, $im1) = ref $z2 ? @{$z2->_cartesian} : ($z2, 0);
	    ($re2, $im2) = ref $z1 ? @{$z1->_cartesian} : ($z1, 0);
	} else {
	    ($re1, $im1) = ref $z1 ? @{$z1->_cartesian} : ($z1, 0);
	    ($re2, $im2) = ref $z2 ? @{$z2->_cartesian} : ($z2, 0);
	}
	if ($im1 || $im2) {
	    # In MATLAB the imaginary parts are ignored.
	    # warn "atan2: Imaginary parts ignored";
	    # http://documents.wolfram.com/mathematica/functions/ArcTan
	    # NOTE: Mathematica ArcTan[x,y] while atan2(y,x)
	    my $s = $z1 * $z1 + $z2 * $z2;
	    _divbyzero("atan2") if $s == 0;
	    my $i = &i;
	    my $r = $z2 + $z1 * $i;
	    return -$i * &log($r / &sqrt( $s ));
	}
	return CORE::atan2($re1, $re2);
}

#
# display_format
# ->display_format
#
# Set (get if no argument) the display format for all complex numbers that
# don't happen to have overridden it via ->display_format
#
# When called as an object method, this actually sets the display format for
# the current object.
#
# Valid object formats are 'c' and 'p' for cartesian and polar. The first
# letter is used actually, so the type can be fully spelled out for clarity.
#
sub display_format {
	my $self  = shift;
	my %display_format = %DISPLAY_FORMAT;

	if (ref $self) {			# Called as an object method
	    if (exists $self->{display_format}) {
		my %obj = %{$self->{display_format}};
		@display_format{keys %obj} = values %obj;
	    }
	}
	if (@_ == 1) {
	    $display_format{style} = shift;
	} else {
	    my %new = @_;
	    @display_format{keys %new} = values %new;
	}

	if (ref $self) { # Called as an object method
	    $self->{display_format} = { %display_format };
	    return
		wantarray ?
		    %{$self->{display_format}} :
		    $self->{display_format}->{style};
	}

        # Called as a class method
	%DISPLAY_FORMAT = %display_format;
	return
	    wantarray ?
		%DISPLAY_FORMAT :
		    $DISPLAY_FORMAT{style};
}

#
# (_stringify)
#
# Show nicely formatted complex number under its cartesian or polar form,
# depending on the current display format:
#
# . If a specific display format has been recorded for this object, use it.
# . Otherwise, use the generic current default for all complex numbers,
#   which is a package global variable.
#
sub _stringify {
	my ($z) = shift;

	my $style = $z->display_format;

	$style = $DISPLAY_FORMAT{style} unless defined $style;

	return $z->_stringify_polar if $style =~ /^p/i;
	return $z->_stringify_cartesian;
}

#
# ->_stringify_cartesian
#
# Stringify as a cartesian representation 'a+bi'.
#
sub _stringify_cartesian {
	my $z  = shift;
	my ($x, $y) = @{$z->_cartesian};
	my ($re, $im);

	my %format = $z->display_format;
	my $format = $format{format};

	if ($x) {
	    if ($x =~ /^NaN[QS]?$/i) {
		$re = $x;
	    } else {
		if ($x =~ /^-?\Q$Inf\E$/oi) {
		    $re = $x;
		} else {
		    $re = defined $format ? sprintf($format, $x) : $x;
		}
	    }
	} else {
	    undef $re;
	}

	if ($y) {
	    if ($y =~ /^(NaN[QS]?)$/i) {
		$im = $y;
	    } else {
		if ($y =~ /^-?\Q$Inf\E$/oi) {
		    $im = $y;
		} else {
		    $im =
			defined $format ?
			    sprintf($format, $y) :
			    ($y == 1 ? "" : ($y == -1 ? "-" : $y));
		}
	    }
	    $im .= "i";
	} else {
	    undef $im;
	}

	my $str = $re;

	if (defined $im) {
	    if ($y < 0) {
		$str .= $im;
	    } elsif ($y > 0 || $im =~ /^NaN[QS]?i$/i)  {
		$str .= "+" if defined $re;
		$str .= $im;
	    }
	} elsif (!defined $re) {
	    $str = "0";
	}

	return $str;
}


#
# ->_stringify_polar
#
# Stringify as a polar representation '[r,t]'.
#
sub _stringify_polar {
	my $z  = shift;
	my ($r, $t) = @{$z->_polar};
	my $theta;

	my %format = $z->display_format;
	my $format = $format{format};

	if ($t =~ /^NaN[QS]?$/i || $t =~ /^-?\Q$Inf\E$/oi) {
	    $theta = $t; 
	} elsif ($t == pi) {
	    $theta = "pi";
	} elsif ($r == 0 || $t == 0) {
	    $theta = defined $format ? sprintf($format, $t) : $t;
	}

	return "[$r,$theta]" if defined $theta;

	#
	# Try to identify pi/n and friends.
	#

	$t -= int(CORE::abs($t) / pi2) * pi2;

	if ($format{polar_pretty_print} && $t) {
	    my ($a, $b);
	    for $a (2..9) {
		$b = $t * $a / pi;
		if ($b =~ /^-?\d+$/) {
		    $b = $b < 0 ? "-" : "" if CORE::abs($b) == 1;
		    $theta = "${b}pi/$a";
		    last;
		}
	    }
	}

        if (defined $format) {
	    $r     = sprintf($format, $r);
	    $theta = sprintf($format, $t) unless defined $theta;
	} else {
	    $theta = $t unless defined $theta;
	}

	return "[$r,$theta]";
}

sub Inf {
    return $Inf;
}

1;
__END__

=pod

=head1 NAME

Math::Complex - complex numbers and associated mathematical functions

=head1 SYNOPSIS

	use Math::Complex;

	$z = Math::Complex->make(5, 6);
	$t = 4 - 3*i + $z;
	$j = cplxe(1, 2*pi/3);

=head1 DESCRIPTION

This package lets you create and manipulate complex numbers. By default,
I<Perl> limits itself to real numbers, but an extra C<use> statement brings
full complex support, along with a full set of mathematical functions
typically associated with and/or extended to complex numbers.

If you wonder what complex numbers are, they were invented to be able to solve
the following equation:

	x*x = -1

and by definition, the solution is noted I<i> (engineers use I<j> instead since
I<i> usually denotes an intensity, but the name does not matter). The number
I<i> is a pure I<imaginary> number.

The arithmetics with pure imaginary numbers works just like you would expect
it with real numbers... you just have to remember that

	i*i = -1

so you have:

	5i + 7i = i * (5 + 7) = 12i
	4i - 3i = i * (4 - 3) = i
	4i * 2i = -8
	6i / 2i = 3
	1 / i = -i

Complex numbers are numbers that have both a real part and an imaginary
part, and are usually noted:

	a + bi

where C<a> is the I<real> part and C<b> is the I<imaginary> part. The
arithmetic with complex numbers is straightforward. You have to
keep track of the real and the imaginary parts, but otherwise the
rules used for real numbers just apply:

	(4 + 3i) + (5 - 2i) = (4 + 5) + i(3 - 2) = 9 + i
	(2 + i) * (4 - i) = 2*4 + 4i -2i -i*i = 8 + 2i + 1 = 9 + 2i

A graphical representation of complex numbers is possible in a plane
(also called the I<complex plane>, but it's really a 2D plane).
The number

	z = a + bi

is the point whose coordinates are (a, b). Actually, it would
be the vector originating from (0, 0) to (a, b). It follows that the addition
of two complex numbers is a vectorial addition.

Since there is a bijection between a point in the 2D plane and a complex
number (i.e. the mapping is unique and reciprocal), a complex number
can also be uniquely identified with polar coordinates:

	[rho, theta]

where C<rho> is the distance to the origin, and C<theta> the angle between
the vector and the I<x> axis. There is a notation for this using the
exponential form, which is:

	rho * exp(i * theta)

where I<i> is the famous imaginary number introduced above. Conversion
between this form and the cartesian form C<a + bi> is immediate:

	a = rho * cos(theta)
	b = rho * sin(theta)

which is also expressed by this formula:

	z = rho * exp(i * theta) = rho * (cos theta + i * sin theta)

In other words, it's the projection of the vector onto the I<x> and I<y>
axes. Mathematicians call I<rho> the I<norm> or I<modulus> and I<theta>
the I<argument> of the complex number. The I<norm> of C<z> is
marked here as C<abs(z)>.

The polar notation (also known as the trigonometric representation) is
much more handy for performing multiplications and divisions of
complex numbers, whilst the cartesian notation is better suited for
additions and subtractions. Real numbers are on the I<x> axis, and
therefore I<y> or I<theta> is zero or I<pi>.

All the common operations that can be performed on a real number have
been defined to work on complex numbers as well, and are merely
I<extensions> of the operations defined on real numbers. This means
they keep their natural meaning when there is no imaginary part, provided
the number is within their definition set.

For instance, the C<sqrt> routine which computes the square root of
its argument is only defined for non-negative real numbers and yields a
non-negative real number (it is an application from B<R+> to B<R+>).
If we allow it to return a complex number, then it can be extended to
negative real numbers to become an application from B<R> to B<C> (the
set of complex numbers):

	sqrt(x) = x >= 0 ? sqrt(x) : sqrt(-x)*i

It can also be extended to be an application from B<C> to B<C>,
whilst its restriction to B<R> behaves as defined above by using
the following definition:

	sqrt(z = [r,t]) = sqrt(r) * exp(i * t/2)

Indeed, a negative real number can be noted C<[x,pi]> (the modulus
I<x> is always non-negative, so C<[x,pi]> is really C<-x>, a negative
number) and the above definition states that

	sqrt([x,pi]) = sqrt(x) * exp(i*pi/2) = [sqrt(x),pi/2] = sqrt(x)*i

which is exactly what we had defined for negative real numbers above.
The C<sqrt> returns only one of the solutions: if you want the both,
use the C<root> function.

All the common mathematical functions defined on real numbers that
are extended to complex numbers share that same property of working
I<as usual> when the imaginary part is zero (otherwise, it would not
be called an extension, would it?).

A I<new> operation possible on a complex number that is
the identity for real numbers is called the I<conjugate>, and is noted
with a horizontal bar above the number, or C<~z> here.

	 z = a + bi
	~z = a - bi

Simple... Now look:

	z * ~z = (a + bi) * (a - bi) = a*a + b*b

We saw that the norm of C<z> was noted C<abs(z)> and was defined as the
distance to the origin, also known as:

	rho = abs(z) = sqrt(a*a + b*b)

so

	z * ~z = abs(z) ** 2

If z is a pure real number (i.e. C<b == 0>), then the above yields:

	a * a = abs(a) ** 2

which is true (C<abs> has the regular meaning for real number, i.e. stands
for the absolute value). This example explains why the norm of C<z> is
noted C<abs(z)>: it extends the C<abs> function to complex numbers, yet
is the regular C<abs> we know when the complex number actually has no
imaginary part... This justifies I<a posteriori> our use of the C<abs>
notation for the norm.

=head1 OPERATIONS

Given the following notations:

	z1 = a + bi = r1 * exp(i * t1)
	z2 = c + di = r2 * exp(i * t2)
	z = <any complex or real number>

the following (overloaded) operations are supported on complex numbers:

	z1 + z2 = (a + c) + i(b + d)
	z1 - z2 = (a - c) + i(b - d)
	z1 * z2 = (r1 * r2) * exp(i * (t1 + t2))
	z1 / z2 = (r1 / r2) * exp(i * (t1 - t2))
	z1 ** z2 = exp(z2 * log z1)
	~z = a - bi
	abs(z) = r1 = sqrt(a*a + b*b)
	sqrt(z) = sqrt(r1) * exp(i * t/2)
	exp(z) = exp(a) * exp(i * b)
	log(z) = log(r1) + i*t
	sin(z) = 1/2i (exp(i * z1) - exp(-i * z))
	cos(z) = 1/2 (exp(i * z1) + exp(-i * z))
	atan2(y, x) = atan(y / x) # Minding the right quadrant, note the order.

The definition used for complex arguments of atan2() is

       -i log((x + iy)/sqrt(x*x+y*y))

Note that atan2(0, 0) is not well-defined.

The following extra operations are supported on both real and complex
numbers:

	Re(z) = a
	Im(z) = b
	arg(z) = t
	abs(z) = r

	cbrt(z) = z ** (1/3)
	log10(z) = log(z) / log(10)
	logn(z, n) = log(z) / log(n)

	tan(z) = sin(z) / cos(z)

	csc(z) = 1 / sin(z)
	sec(z) = 1 / cos(z)
	cot(z) = 1 / tan(z)

	asin(z) = -i * log(i*z + sqrt(1-z*z))
	acos(z) = -i * log(z + i*sqrt(1-z*z))
	atan(z) = i/2 * log((i+z) / (i-z))

	acsc(z) = asin(1 / z)
	asec(z) = acos(1 / z)
	acot(z) = atan(1 / z) = -i/2 * log((i+z) / (z-i))

	sinh(z) = 1/2 (exp(z) - exp(-z))
	cosh(z) = 1/2 (exp(z) + exp(-z))
	tanh(z) = sinh(z) / cosh(z) = (exp(z) - exp(-z)) / (exp(z) + exp(-z))

	csch(z) = 1 / sinh(z)
	sech(z) = 1 / cosh(z)
	coth(z) = 1 / tanh(z)

	asinh(z) = log(z + sqrt(z*z+1))
	acosh(z) = log(z + sqrt(z*z-1))
	atanh(z) = 1/2 * log((1+z) / (1-z))

	acsch(z) = asinh(1 / z)
	asech(z) = acosh(1 / z)
	acoth(z) = atanh(1 / z) = 1/2 * log((1+z) / (z-1))

I<arg>, I<abs>, I<log>, I<csc>, I<cot>, I<acsc>, I<acot>, I<csch>,
I<coth>, I<acosech>, I<acotanh>, have aliases I<rho>, I<theta>, I<ln>,
I<cosec>, I<cotan>, I<acosec>, I<acotan>, I<cosech>, I<cotanh>,
I<acosech>, I<acotanh>, respectively.  C<Re>, C<Im>, C<arg>, C<abs>,
C<rho>, and C<theta> can be used also as mutators.  The C<cbrt>
returns only one of the solutions: if you want all three, use the
C<root> function.

The I<root> function is available to compute all the I<n>
roots of some complex, where I<n> is a strictly positive integer.
There are exactly I<n> such roots, returned as a list. Getting the
number mathematicians call C<j> such that:

	1 + j + j*j = 0;

is a simple matter of writing:

	$j = ((root(1, 3))[1];

The I<k>th root for C<z = [r,t]> is given by:

	(root(z, n))[k] = r**(1/n) * exp(i * (t + 2*k*pi)/n)

You can return the I<k>th root directly by C<root(z, n, k)>,
indexing starting from I<zero> and ending at I<n - 1>.

The I<spaceship> numeric comparison operator, E<lt>=E<gt>, is also
defined. In order to ensure its restriction to real numbers is conform
to what you would expect, the comparison is run on the real part of
the complex number first, and imaginary parts are compared only when
the real parts match.

=head1 CREATION

To create a complex number, use either:

	$z = Math::Complex->make(3, 4);
	$z = cplx(3, 4);

if you know the cartesian form of the number, or

	$z = 3 + 4*i;

if you like. To create a number using the polar form, use either:

	$z = Math::Complex->emake(5, pi/3);
	$x = cplxe(5, pi/3);

instead. The first argument is the modulus, the second is the angle
(in radians, the full circle is 2*pi).  (Mnemonic: C<e> is used as a
notation for complex numbers in the polar form).

It is possible to write:

	$x = cplxe(-3, pi/4);

but that will be silently converted into C<[3,-3pi/4]>, since the
modulus must be non-negative (it represents the distance to the origin
in the complex plane).

It is also possible to have a complex number as either argument of the
C<make>, C<emake>, C<cplx>, and C<cplxe>: the appropriate component of
the argument will be used.

	$z1 = cplx(-2,  1);
	$z2 = cplx($z1, 4);

The C<new>, C<make>, C<emake>, C<cplx>, and C<cplxe> will also
understand a single (string) argument of the forms

    	2-3i
    	-3i
	[2,3]
	[2,-3pi/4]
	[2]

in which case the appropriate cartesian and exponential components
will be parsed from the string and used to create new complex numbers.
The imaginary component and the theta, respectively, will default to zero.

The C<new>, C<make>, C<emake>, C<cplx>, and C<cplxe> will also
understand the case of no arguments: this means plain zero or (0, 0).

=head1 DISPLAYING

When printed, a complex number is usually shown under its cartesian
style I<a+bi>, but there are legitimate cases where the polar style
I<[r,t]> is more appropriate.  The process of converting the complex
number into a string that can be displayed is known as I<stringification>.

By calling the class method C<Math::Complex::display_format> and
supplying either C<"polar"> or C<"cartesian"> as an argument, you
override the default display style, which is C<"cartesian">. Not
supplying any argument returns the current settings.

This default can be overridden on a per-number basis by calling the
C<display_format> method instead. As before, not supplying any argument
returns the current display style for this number. Otherwise whatever you
specify will be the new display style for I<this> particular number.

For instance:

	use Math::Complex;

	Math::Complex::display_format('polar');
	$j = (root(1, 3))[1];
	print "j = $j\n";		# Prints "j = [1,2pi/3]"
	$j->display_format('cartesian');
	print "j = $j\n";		# Prints "j = -0.5+0.866025403784439i"

The polar style attempts to emphasize arguments like I<k*pi/n>
(where I<n> is a positive integer and I<k> an integer within [-9, +9]),
this is called I<polar pretty-printing>.

For the reverse of stringifying, see the C<make> and C<emake>.

=head2 CHANGED IN PERL 5.6

The C<display_format> class method and the corresponding
C<display_format> object method can now be called using
a parameter hash instead of just a one parameter.

The old display format style, which can have values C<"cartesian"> or
C<"polar">, can be changed using the C<"style"> parameter.

	$j->display_format(style => "polar");

The one parameter calling convention also still works.

	$j->display_format("polar");

There are two new display parameters.

The first one is C<"format">, which is a sprintf()-style format string
to be used for both numeric parts of the complex number(s).  The is
somewhat system-dependent but most often it corresponds to C<"%.15g">.
You can revert to the default by setting the C<format> to C<undef>.

	# the $j from the above example

	$j->display_format('format' => '%.5f');
	print "j = $j\n";		# Prints "j = -0.50000+0.86603i"
	$j->display_format('format' => undef);
	print "j = $j\n";		# Prints "j = -0.5+0.86603i"

Notice that this affects also the return values of the
C<display_format> methods: in list context the whole parameter hash
will be returned, as opposed to only the style parameter value.
This is a potential incompatibility with earlier versions if you
have been calling the C<display_format> method in list context.

The second new display parameter is C<"polar_pretty_print">, which can
be set to true or false, the default being true.  See the previous
section for what this means.

=head1 USAGE

Thanks to overloading, the handling of arithmetics with complex numbers
is simple and almost transparent.

Here are some examples:

	use Math::Complex;

	$j = cplxe(1, 2*pi/3);	# $j ** 3 == 1
	print "j = $j, j**3 = ", $j ** 3, "\n";
	print "1 + j + j**2 = ", 1 + $j + $j**2, "\n";

	$z = -16 + 0*i;			# Force it to be a complex
	print "sqrt($z) = ", sqrt($z), "\n";

	$k = exp(i * 2*pi/3);
	print "$j - $k = ", $j - $k, "\n";

	$z->Re(3);			# Re, Im, arg, abs,
	$j->arg(2);			# (the last two aka rho, theta)
					# can be used also as mutators.

=head1 CONSTANTS

=head2 PI

The constant C<pi> and some handy multiples of it (pi2, pi4,
and pip2 (pi/2) and pip4 (pi/4)) are also available if separately
exported:

    use Math::Complex ':pi'; 
    $third_of_circle = pi2 / 3;

=head2 Inf

The floating point infinity can be exported as a subroutine Inf():

    use Math::Complex qw(Inf sinh);
    my $AlsoInf = Inf() + 42;
    my $AnotherInf = sinh(1e42);
    print "$AlsoInf is $AnotherInf\n" if $AlsoInf == $AnotherInf;

Note that the stringified form of infinity varies between platforms:
it can be for example any of

   inf
   infinity
   INF
   1.#INF

or it can be something else. 

Also note that in some platforms trying to use the infinity in
arithmetic operations may result in Perl crashing because using
an infinity causes SIGFPE or its moral equivalent to be sent.
The way to ignore this is

  local $SIG{FPE} = sub { };

=head1 ERRORS DUE TO DIVISION BY ZERO OR LOGARITHM OF ZERO

The division (/) and the following functions

	log	ln	log10	logn
	tan	sec	csc	cot
	atan	asec	acsc	acot
	tanh	sech	csch	coth
	atanh	asech	acsch	acoth

cannot be computed for all arguments because that would mean dividing
by zero or taking logarithm of zero. These situations cause fatal
runtime errors looking like this

	cot(0): Division by zero.
	(Because in the definition of cot(0), the divisor sin(0) is 0)
	Died at ...

or

	atanh(-1): Logarithm of zero.
	Died at...

For the C<csc>, C<cot>, C<asec>, C<acsc>, C<acot>, C<csch>, C<coth>,
C<asech>, C<acsch>, the argument cannot be C<0> (zero).  For the
logarithmic functions and the C<atanh>, C<acoth>, the argument cannot
be C<1> (one).  For the C<atanh>, C<acoth>, the argument cannot be
C<-1> (minus one).  For the C<atan>, C<acot>, the argument cannot be
C<i> (the imaginary unit).  For the C<atan>, C<acoth>, the argument
cannot be C<-i> (the negative imaginary unit).  For the C<tan>,
C<sec>, C<tanh>, the argument cannot be I<pi/2 + k * pi>, where I<k>
is any integer.  atan2(0, 0) is undefined, and if the complex arguments
are used for atan2(), a division by zero will happen if z1**2+z2**2 == 0.

Note that because we are operating on approximations of real numbers,
these errors can happen when merely `too close' to the singularities
listed above.

=head1 ERRORS DUE TO INDIGESTIBLE ARGUMENTS

The C<make> and C<emake> accept both real and complex arguments.
When they cannot recognize the arguments they will die with error
messages like the following

    Math::Complex::make: Cannot take real part of ...
    Math::Complex::make: Cannot take real part of ...
    Math::Complex::emake: Cannot take rho of ...
    Math::Complex::emake: Cannot take theta of ...

=head1 BUGS

Saying C<use Math::Complex;> exports many mathematical routines in the
caller environment and even overrides some (C<sqrt>, C<log>, C<atan2>).
This is construed as a feature by the Authors, actually... ;-)

All routines expect to be given real or complex numbers. Don't attempt to
use BigFloat, since Perl has currently no rule to disambiguate a '+'
operation (for instance) between two overloaded entities.

In Cray UNICOS there is some strange numerical instability that results
in root(), cos(), sin(), cosh(), sinh(), losing accuracy fast.  Beware.
The bug may be in UNICOS math libs, in UNICOS C compiler, in Math::Complex.
Whatever it is, it does not manifest itself anywhere else where Perl runs.

=head1 SEE ALSO

L<Math::Trig>

=head1 AUTHORS

Daniel S. Lewart <F<lewart!at!uiuc.edu>>,
Jarkko Hietaniemi <F<jhi!at!iki.fi>>,
Raphael Manfredi <F<Raphael_Manfredi!at!pobox.com>>,
Zefram <zefram@fysh.org>

=head1 LICENSE

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself. 

=cut

1;

# eof
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 #
# Trigonometric functions, mostly inherited from Math::Complex.
# -- Jarkko Hietaniemi, since April 1997
# -- Raphael Manfredi, September 1996 (indirectly: because of Math::Complex)
#

package Math::Trig;

{ use 5.006; }
use strict;

use Math::Complex 1.59;
use Math::Complex qw(:trig :pi);
require Exporter;

our @ISA = qw(Exporter);

our $VERSION = 1.23;

my @angcnv = qw(rad2deg rad2grad
		deg2rad deg2grad
		grad2rad grad2deg);

my @areal = qw(asin_real acos_real);

our @EXPORT = (@{$Math::Complex::EXPORT_TAGS{'trig'}},
	   @angcnv, @areal);

my @rdlcnv = qw(cartesian_to_cylindrical
		cartesian_to_spherical
		cylindrical_to_cartesian
		cylindrical_to_spherical
		spherical_to_cartesian
		spherical_to_cylindrical);

my @greatcircle = qw(
		     great_circle_distance
		     great_circle_direction
		     great_circle_bearing
		     great_circle_waypoint
		     great_circle_midpoint
		     great_circle_destination
		    );

my @pi = qw(pi pi2 pi4 pip2 pip4);

our @EXPORT_OK = (@rdlcnv, @greatcircle, @pi, 'Inf');

# See e.g. the following pages:
# http://www.movable-type.co.uk/scripts/LatLong.html
# http://williams.best.vwh.net/avform.htm

our %EXPORT_TAGS = ('radial' => [ @rdlcnv ],
	        'great_circle' => [ @greatcircle ],
	        'pi'     => [ @pi ]);

sub _DR  () { pi2/360 }
sub _RD  () { 360/pi2 }
sub _DG  () { 400/360 }
sub _GD  () { 360/400 }
sub _RG  () { 400/pi2 }
sub _GR  () { pi2/400 }

#
# Truncating remainder.
#

sub _remt ($$) {
    # Oh yes, POSIX::fmod() would be faster. Possibly. If it is available.
    $_[0] - $_[1] * int($_[0] / $_[1]);
}

#
# Angle conversions.
#

sub rad2rad($)     { _remt($_[0], pi2) }

sub deg2deg($)     { _remt($_[0], 360) }

sub grad2grad($)   { _remt($_[0], 400) }

sub rad2deg ($;$)  { my $d = _RD * $_[0]; $_[1] ? $d : deg2deg($d) }

sub deg2rad ($;$)  { my $d = _DR * $_[0]; $_[1] ? $d : rad2rad($d) }

sub grad2deg ($;$) { my $d = _GD * $_[0]; $_[1] ? $d : deg2deg($d) }

sub deg2grad ($;$) { my $d = _DG * $_[0]; $_[1] ? $d : grad2grad($d) }

sub rad2grad ($;$) { my $d = _RG * $_[0]; $_[1] ? $d : grad2grad($d) }

sub grad2rad ($;$) { my $d = _GR * $_[0]; $_[1] ? $d : rad2rad($d) }

#
# acos and asin functions which always return a real number
#

sub acos_real {
    return 0  if $_[0] >=  1;
    return pi if $_[0] <= -1;
    return acos($_[0]);
}

sub asin_real {
    return  &pip2 if $_[0] >=  1;
    return -&pip2 if $_[0] <= -1;
    return asin($_[0]);
}

sub cartesian_to_spherical {
    my ( $x, $y, $z ) = @_;

    my $rho = sqrt( $x * $x + $y * $y + $z * $z );

    return ( $rho,
             atan2( $y, $x ),
             $rho ? acos_real( $z / $rho ) : 0 );
}

sub spherical_to_cartesian {
    my ( $rho, $theta, $phi ) = @_;

    return ( $rho * cos( $theta ) * sin( $phi ),
             $rho * sin( $theta ) * sin( $phi ),
             $rho * cos( $phi   ) );
}

sub spherical_to_cylindrical {
    my ( $x, $y, $z ) = spherical_to_cartesian( @_ );

    return ( sqrt( $x * $x + $y * $y ), $_[1], $z );
}

sub cartesian_to_cylindrical {
    my ( $x, $y, $z ) = @_;

    return ( sqrt( $x * $x + $y * $y ), atan2( $y, $x ), $z );
}

sub cylindrical_to_cartesian {
    my ( $rho, $theta, $z ) = @_;

    return ( $rho * cos( $theta ), $rho * sin( $theta ), $z );
}

sub cylindrical_to_spherical {
    return ( cartesian_to_spherical( cylindrical_to_cartesian( @_ ) ) );
}

sub great_circle_distance {
    my ( $theta0, $phi0, $theta1, $phi1, $rho ) = @_;

    $rho = 1 unless defined $rho; # Default to the unit sphere.

    my $lat0 = pip2 - $phi0;
    my $lat1 = pip2 - $phi1;

    return $rho *
	acos_real( cos( $lat0 ) * cos( $lat1 ) * cos( $theta0 - $theta1 ) +
		   sin( $lat0 ) * sin( $lat1 ) );
}

sub great_circle_direction {
    my ( $theta0, $phi0, $theta1, $phi1 ) = @_;

    my $lat0 = pip2 - $phi0;
    my $lat1 = pip2 - $phi1;

    return rad2rad(pi2 -
	atan2(sin($theta0-$theta1) * cos($lat1),
		cos($lat0) * sin($lat1) -
		    sin($lat0) * cos($lat1) * cos($theta0-$theta1)));
}

*great_circle_bearing         = \&great_circle_direction;

sub great_circle_waypoint {
    my ( $theta0, $phi0, $theta1, $phi1, $point ) = @_;

    $point = 0.5 unless defined $point;

    my $d = great_circle_distance( $theta0, $phi0, $theta1, $phi1 );

    return undef if $d == pi;

    my $sd = sin($d);

    return ($theta0, $phi0) if $sd == 0;

    my $A = sin((1 - $point) * $d) / $sd;
    my $B = sin(     $point  * $d) / $sd;

    my $lat0 = pip2 - $phi0;
    my $lat1 = pip2 - $phi1;

    my $x = $A * cos($lat0) * cos($theta0) + $B * cos($lat1) * cos($theta1);
    my $y = $A * cos($lat0) * sin($theta0) + $B * cos($lat1) * sin($theta1);
    my $z = $A * sin($lat0)                + $B * sin($lat1);

    my $theta = atan2($y, $x);
    my $phi   = acos_real($z);

    return ($theta, $phi);
}

sub great_circle_midpoint {
    great_circle_waypoint(@_[0..3], 0.5);
}

sub great_circle_destination {
    my ( $theta0, $phi0, $dir0, $dst ) = @_;

    my $lat0 = pip2 - $phi0;

    my $phi1   = asin_real(sin($lat0)*cos($dst) +
			   cos($lat0)*sin($dst)*cos($dir0));

    my $theta1 = $theta0 + atan2(sin($dir0)*sin($dst)*cos($lat0),
				 cos($dst)-sin($lat0)*sin($phi1));

    my $dir1 = great_circle_bearing($theta1, $phi1, $theta0, $phi0) + pi;

    $dir1 -= pi2 if $dir1 > pi2;

    return ($theta1, $phi1, $dir1);
}

1;

__END__
=pod

=head1 NAME

Math::Trig - trigonometric functions

=head1 SYNOPSIS

    use Math::Trig;

    $x = tan(0.9);
    $y = acos(3.7);
    $z = asin(2.4);

    $halfpi = pi/2;

    $rad = deg2rad(120);

    # Import constants pi2, pip2, pip4 (2*pi, pi/2, pi/4).
    use Math::Trig ':pi';

    # Import the conversions between cartesian/spherical/cylindrical.
    use Math::Trig ':radial';

        # Import the great circle formulas.
    use Math::Trig ':great_circle';

=head1 DESCRIPTION

C<Math::Trig> defines many trigonometric functions not defined by the
core Perl which defines only the C<sin()> and C<cos()>.  The constant
B<pi> is also defined as are a few convenience functions for angle
conversions, and I<great circle formulas> for spherical movement.

=head1 ANGLES

All angles are defined in radians, except where otherwise specified
(for example in the deg/rad conversion functions).

=head1 TRIGONOMETRIC FUNCTIONS

The tangent

=over 4

=item B<tan>

=back

The cofunctions of the sine, cosine, and tangent (cosec/csc and cotan/cot
are aliases)

B<csc>, B<cosec>, B<sec>, B<sec>, B<cot>, B<cotan>

The arcus (also known as the inverse) functions of the sine, cosine,
and tangent

B<asin>, B<acos>, B<atan>

The principal value of the arc tangent of y/x

B<atan2>(y, x)

The arcus cofunctions of the sine, cosine, and tangent (acosec/acsc
and acotan/acot are aliases).  Note that atan2(0, 0) is not well-defined.

B<acsc>, B<acosec>, B<asec>, B<acot>, B<acotan>

The hyperbolic sine, cosine, and tangent

B<sinh>, B<cosh>, B<tanh>

The cofunctions of the hyperbolic sine, cosine, and tangent (cosech/csch
and cotanh/coth are aliases)

B<csch>, B<cosech>, B<sech>, B<coth>, B<cotanh>

The area (also known as the inverse) functions of the hyperbolic
sine, cosine, and tangent

B<asinh>, B<acosh>, B<atanh>

The area cofunctions of the hyperbolic sine, cosine, and tangent
(acsch/acosech and acoth/acotanh are aliases)

B<acsch>, B<acosech>, B<asech>, B<acoth>, B<acotanh>

The trigonometric constant B<pi> and some of handy multiples
of it are also defined.

B<pi, pi2, pi4, pip2, pip4>

=head2 ERRORS DUE TO DIVISION BY ZERO

The following functions

    acoth
    acsc
    acsch
    asec
    asech
    atanh
    cot
    coth
    csc
    csch
    sec
    sech
    tan
    tanh

cannot be computed for all arguments because that would mean dividing
by zero or taking logarithm of zero. These situations cause fatal
runtime errors looking like this

    cot(0): Division by zero.
    (Because in the definition of cot(0), the divisor sin(0) is 0)
    Died at ...

or

    atanh(-1): Logarithm of zero.
    Died at...

For the C<csc>, C<cot>, C<asec>, C<acsc>, C<acot>, C<csch>, C<coth>,
C<asech>, C<acsch>, the argument cannot be C<0> (zero).  For the
C<atanh>, C<acoth>, the argument cannot be C<1> (one).  For the
C<atanh>, C<acoth>, the argument cannot be C<-1> (minus one).  For the
C<tan>, C<sec>, C<tanh>, C<sech>, the argument cannot be I<pi/2 + k *
pi>, where I<k> is any integer.

Note that atan2(0, 0) is not well-defined.

=head2 SIMPLE (REAL) ARGUMENTS, COMPLEX RESULTS

Please note that some of the trigonometric functions can break out
from the B<real axis> into the B<complex plane>. For example
C<asin(2)> has no definition for plain real numbers but it has
definition for complex numbers.

In Perl terms this means that supplying the usual Perl numbers (also
known as scalars, please see L<perldata>) as input for the
trigonometric functions might produce as output results that no more
are simple real numbers: instead they are complex numbers.

The C<Math::Trig> handles this by using the C<Math::Complex> package
which knows how to handle complex numbers, please see L<Math::Complex>
for more information. In practice you need not to worry about getting
complex numbers as results because the C<Math::Complex> takes care of
details like for example how to display complex numbers. For example:

    print asin(2), "\n";

should produce something like this (take or leave few last decimals):

    1.5707963267949-1.31695789692482i

That is, a complex number with the real part of approximately C<1.571>
and the imaginary part of approximately C<-1.317>.

=head1 PLANE ANGLE CONVERSIONS

(Plane, 2-dimensional) angles may be converted with the following functions.

=over

=item deg2rad

    $radians  = deg2rad($degrees);

=item grad2rad

    $radians  = grad2rad($gradians);

=item rad2deg

    $degrees  = rad2deg($radians);

=item grad2deg

    $degrees  = grad2deg($gradians);

=item deg2grad

    $gradians = deg2grad($degrees);

=item rad2grad

    $gradians = rad2grad($radians);

=back

The full circle is 2 I<pi> radians or I<360> degrees or I<400> gradians.
The result is by default wrapped to be inside the [0, {2pi,360,400}[ circle.
If you don't want this, supply a true second argument:

    $zillions_of_radians  = deg2rad($zillions_of_degrees, 1);
    $negative_degrees     = rad2deg($negative_radians, 1);

You can also do the wrapping explicitly by rad2rad(), deg2deg(), and
grad2grad().

=over 4

=item rad2rad

    $radians_wrapped_by_2pi = rad2rad($radians);

=item deg2deg

    $degrees_wrapped_by_360 = deg2deg($degrees);

=item grad2grad

    $gradians_wrapped_by_400 = grad2grad($gradians);

=back

=head1 RADIAL COORDINATE CONVERSIONS

B<Radial coordinate systems> are the B<spherical> and the B<cylindrical>
systems, explained shortly in more detail.

You can import radial coordinate conversion functions by using the
C<:radial> tag:

    use Math::Trig ':radial';

    ($rho, $theta, $z)     = cartesian_to_cylindrical($x, $y, $z);
    ($rho, $theta, $phi)   = cartesian_to_spherical($x, $y, $z);
    ($x, $y, $z)           = cylindrical_to_cartesian($rho, $theta, $z);
    ($rho_s, $theta, $phi) = cylindrical_to_spherical($rho_c, $theta, $z);
    ($x, $y, $z)           = spherical_to_cartesian($rho, $theta, $phi);
    ($rho_c, $theta, $z)   = spherical_to_cylindrical($rho_s, $theta, $phi);

B<All angles are in radians>.

=head2 COORDINATE SYSTEMS

B<Cartesian> coordinates are the usual rectangular I<(x, y, z)>-coordinates.

Spherical coordinates, I<(rho, theta, pi)>, are three-dimensional
coordinates which define a point in three-dimensional space.  They are
based on a sphere surface.  The radius of the sphere is B<rho>, also
known as the I<radial> coordinate.  The angle in the I<xy>-plane
(around the I<z>-axis) is B<theta>, also known as the I<azimuthal>
coordinate.  The angle from the I<z>-axis is B<phi>, also known as the
I<polar> coordinate.  The North Pole is therefore I<0, 0, rho>, and
the Gulf of Guinea (think of the missing big chunk of Africa) I<0,
pi/2, rho>.  In geographical terms I<phi> is latitude (northward
positive, southward negative) and I<theta> is longitude (eastward
positive, westward negative).

B<BEWARE>: some texts define I<theta> and I<phi> the other way round,
some texts define the I<phi> to start from the horizontal plane, some
texts use I<r> in place of I<rho>.

Cylindrical coordinates, I<(rho, theta, z)>, are three-dimensional
coordinates which define a point in three-dimensional space.  They are
based on a cylinder surface.  The radius of the cylinder is B<rho>,
also known as the I<radial> coordinate.  The angle in the I<xy>-plane
(around the I<z>-axis) is B<theta>, also known as the I<azimuthal>
coordinate.  The third coordinate is the I<z>, pointing up from the
B<theta>-plane.

=head2 3-D ANGLE CONVERSIONS

Conversions to and from spherical and cylindrical coordinates are
available.  Please notice that the conversions are not necessarily
reversible because of the equalities like I<pi> angles being equal to
I<-pi> angles.

=over 4

=item cartesian_to_cylindrical

    ($rho, $theta, $z) = cartesian_to_cylindrical($x, $y, $z);

=item cartesian_to_spherical

    ($rho, $theta, $phi) = cartesian_to_spherical($x, $y, $z);

=item cylindrical_to_cartesian

    ($x, $y, $z) = cylindrical_to_cartesian($rho, $theta, $z);

=item cylindrical_to_spherical

    ($rho_s, $theta, $phi) = cylindrical_to_spherical($rho_c, $theta, $z);

Notice that when C<$z> is not 0 C<$rho_s> is not equal to C<$rho_c>.

=item spherical_to_cartesian

    ($x, $y, $z) = spherical_to_cartesian($rho, $theta, $phi);

=item spherical_to_cylindrical

    ($rho_c, $theta, $z) = spherical_to_cylindrical($rho_s, $theta, $phi);

Notice that when C<$z> is not 0 C<$rho_c> is not equal to C<$rho_s>.

=back

=head1 GREAT CIRCLE DISTANCES AND DIRECTIONS

A great circle is section of a circle that contains the circle
diameter: the shortest distance between two (non-antipodal) points on
the spherical surface goes along the great circle connecting those two
points.

=head2 great_circle_distance

You can compute spherical distances, called B<great circle distances>,
by importing the great_circle_distance() function:

  use Math::Trig 'great_circle_distance';

  $distance = great_circle_distance($theta0, $phi0, $theta1, $phi1, [, $rho]);

The I<great circle distance> is the shortest distance between two
points on a sphere.  The distance is in C<$rho> units.  The C<$rho> is
optional, it defaults to 1 (the unit sphere), therefore the distance
defaults to radians.

If you think geographically the I<theta> are longitudes: zero at the
Greenwhich meridian, eastward positive, westward negative -- and the
I<phi> are latitudes: zero at the North Pole, northward positive,
southward negative.  B<NOTE>: this formula thinks in mathematics, not
geographically: the I<phi> zero is at the North Pole, not at the
Equator on the west coast of Africa (Bay of Guinea).  You need to
subtract your geographical coordinates from I<pi/2> (also known as 90
degrees).

  $distance = great_circle_distance($lon0, pi/2 - $lat0,
                                    $lon1, pi/2 - $lat1, $rho);

=head2 great_circle_direction

The direction you must follow the great circle (also known as I<bearing>)
can be computed by the great_circle_direction() function:

  use Math::Trig 'great_circle_direction';

  $direction = great_circle_direction($theta0, $phi0, $theta1, $phi1);

=head2 great_circle_bearing

Alias 'great_circle_bearing' for 'great_circle_direction' is also available.

  use Math::Trig 'great_circle_bearing';

  $direction = great_circle_bearing($theta0, $phi0, $theta1, $phi1);

The result of great_circle_direction is in radians, zero indicating
straight north, pi or -pi straight south, pi/2 straight west, and
-pi/2 straight east.

=head2 great_circle_destination

You can inversely compute the destination if you know the
starting point, direction, and distance:

  use Math::Trig 'great_circle_destination';

  # $diro is the original direction,
  # for example from great_circle_bearing().
  # $distance is the angular distance in radians,
  # for example from great_circle_distance().
  # $thetad and $phid are the destination coordinates,
  # $dird is the final direction at the destination.

  ($thetad, $phid, $dird) =
    great_circle_destination($theta, $phi, $diro, $distance);

or the midpoint if you know the end points:

=head2 great_circle_midpoint

  use Math::Trig 'great_circle_midpoint';

  ($thetam, $phim) =
    great_circle_midpoint($theta0, $phi0, $theta1, $phi1);

The great_circle_midpoint() is just a special case (with $way = 0.5) of

=head2 great_circle_waypoint

  use Math::Trig 'great_circle_waypoint';

  ($thetai, $phii) =
    great_circle_waypoint($theta0, $phi0, $theta1, $phi1, $way);

Where the $way is a value from zero ($theta0, $phi0) to one ($theta1,
$phi1).  Note that antipodal points (where their distance is I<pi>
radians) do not have waypoints between them (they would have an an
"equator" between them), and therefore C<undef> is returned for
antipodal points.  If the points are the same and the distance
therefore zero and all waypoints therefore identical, the first point
(either point) is returned.

The thetas, phis, direction, and distance in the above are all in radians.

You can import all the great circle formulas by

  use Math::Trig ':great_circle';

Notice that the resulting directions might be somewhat surprising if
you are looking at a flat worldmap: in such map projections the great
circles quite often do not look like the shortest routes --  but for
example the shortest possible routes from Europe or North America to
Asia do often cross the polar regions.  (The common Mercator projection
does B<not> show great circles as straight lines: straight lines in the
Mercator projection are lines of constant bearing.)

=head1 EXAMPLES

To calculate the distance between London (51.3N 0.5W) and Tokyo
(35.7N 139.8E) in kilometers:

    use Math::Trig qw(great_circle_distance deg2rad);

    # Notice the 90 - latitude: phi zero is at the North Pole.
    sub NESW { deg2rad($_[0]), deg2rad(90 - $_[1]) }
    my @L = NESW( -0.5, 51.3);
    my @T = NESW(139.8, 35.7);
    my $km = great_circle_distance(@L, @T, 6378); # About 9600 km.

The direction you would have to go from London to Tokyo (in radians,
straight north being zero, straight east being pi/2).

    use Math::Trig qw(great_circle_direction);

    my $rad = great_circle_direction(@L, @T); # About 0.547 or 0.174 pi.

The midpoint between London and Tokyo being

    use Math::Trig qw(great_circle_midpoint);

    my @M = great_circle_midpoint(@L, @T);

or about 69 N 89 E, in the frozen wastes of Siberia.

B<NOTE>: you B<cannot> get from A to B like this:

   Dist = great_circle_distance(A, B)
   Dir  = great_circle_direction(A, B)
   C    = great_circle_destination(A, Dist, Dir)

and expect C to be B, because the bearing constantly changes when
going from A to B (except in some special case like the meridians or
the circles of latitudes) and in great_circle_destination() one gives
a B<constant> bearing to follow.

=head2 CAVEAT FOR GREAT CIRCLE FORMULAS

The answers may be off by few percentages because of the irregular
(slightly aspherical) form of the Earth.  The errors are at worst
about 0.55%, but generally below 0.3%.

=head2 Real-valued asin and acos

For small inputs asin() and acos() may return complex numbers even
when real numbers would be enough and correct, this happens because of
floating-point inaccuracies.  You can see these inaccuracies for
example by trying theses:

  print cos(1e-6)**2+sin(1e-6)**2 - 1,"\n";
  printf "%.20f", cos(1e-6)**2+sin(1e-6)**2,"\n";

which will print something like this

  -1.11022302462516e-16
  0.99999999999999988898

even though the expected results are of course exactly zero and one.
The formulas used to compute asin() and acos() are quite sensitive to
this, and therefore they might accidentally slip into the complex
plane even when they should not.  To counter this there are two
interfaces that are guaranteed to return a real-valued output.

=over 4

=item asin_real

    use Math::Trig qw(asin_real);

    $real_angle = asin_real($input_sin);

Return a real-valued arcus sine if the input is between [-1, 1],
B<inclusive> the endpoints.  For inputs greater than one, pi/2
is returned.  For inputs less than minus one, -pi/2 is returned.

=item acos_real

    use Math::Trig qw(acos_real);

    $real_angle = acos_real($input_cos);

Return a real-valued arcus cosine if the input is between [-1, 1],
B<inclusive> the endpoints.  For inputs greater than one, zero
is returned.  For inputs less than minus one, pi is returned.

=back

=head1 BUGS

Saying C<use Math::Trig;> exports many mathematical routines in the
caller environment and even overrides some (C<sin>, C<cos>).  This is
construed as a feature by the Authors, actually... ;-)

The code is not optimized for speed, especially because we use
C<Math::Complex> and thus go quite near complex numbers while doing
the computations even when the arguments are not. This, however,
cannot be completely avoided if we want things like C<asin(2)> to give
an answer instead of giving a fatal runtime error.

Do not attempt navigation using these formulas.

=head1 SEE ALSO

L<Math::Complex>

=head1 AUTHORS

Jarkko Hietaniemi <F<jhi!at!iki.fi>>,
Raphael Manfredi <F<Raphael_Manfredi!at!pobox.com>>,
Zefram <zefram@fysh.org>

=head1 LICENSE

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself. 

=cut

# eof
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        package Math::BigInt::Calc;

use 5.006001;
use strict;
use warnings;

our $VERSION = '1.999715';
$VERSION = eval $VERSION;

# Package to store unsigned big integers in decimal and do math with them

# Internally the numbers are stored in an array with at least 1 element, no
# leading zero parts (except the first) and in base 1eX where X is determined
# automatically at loading time to be the maximum possible value

# todo:
# - fully remove funky $# stuff in div() (maybe - that code scares me...)

# USE_MUL: due to problems on certain os (os390, posix-bc) "* 1e-5" is used
# instead of "/ 1e5" at some places, (marked with USE_MUL). Other platforms
# BS2000, some Crays need USE_DIV instead.
# The BEGIN block is used to determine which of the two variants gives the
# correct result.

# Beware of things like:
# $i = $i * $y + $car; $car = int($i / $BASE); $i = $i % $BASE;
# This works on x86, but fails on ARM (SA1100, iPAQ) due to who knows what
# reasons. So, use this instead (slower, but correct):
# $i = $i * $y + $car; $car = int($i / $BASE); $i -= $BASE * $car;

##############################################################################
# global constants, flags and accessory

# announce that we are compatible with MBI v1.83 and up
sub api_version () { 2; }
 
# constants for easier life
my ($BASE,$BASE_LEN,$RBASE,$MAX_VAL);
my ($AND_BITS,$XOR_BITS,$OR_BITS);
my ($AND_MASK,$XOR_MASK,$OR_MASK);

sub _base_len 
  {
  # Set/get the BASE_LEN and assorted other, connected values.
  # Used only by the testsuite, the set variant is used only by the BEGIN
  # block below:
  shift;

  my ($b, $int) = @_;
  if (defined $b)
    {
    # avoid redefinitions
    undef &_mul;
    undef &_div;

    if ($] >= 5.008 && $int && $b > 7)
      {
      $BASE_LEN = $b;
      *_mul = \&_mul_use_div_64;
      *_div = \&_div_use_div_64;
      $BASE = int("1e".$BASE_LEN);
      $MAX_VAL = $BASE-1;
      return $BASE_LEN unless wantarray;
      return ($BASE_LEN, $BASE, $AND_BITS, $XOR_BITS, $OR_BITS, $BASE_LEN, $MAX_VAL,);
      }

    # find whether we can use mul or div in mul()/div()
    $BASE_LEN = $b+1;
    my $caught = 0;
    while (--$BASE_LEN > 5)
      {
      $BASE = int("1e".$BASE_LEN);
      $RBASE = abs('1e-'.$BASE_LEN);			# see USE_MUL
      $caught = 0;
      $caught += 1 if (int($BASE * $RBASE) != 1);	# should be 1
      $caught += 2 if (int($BASE / $BASE) != 1);	# should be 1
      last if $caught != 3;
      }
    $BASE = int("1e".$BASE_LEN);
    $RBASE = abs('1e-'.$BASE_LEN);			# see USE_MUL
    $MAX_VAL = $BASE-1;
   
    # ($caught & 1) != 0 => cannot use MUL
    # ($caught & 2) != 0 => cannot use DIV
    if ($caught == 2)				# 2
      {
      # must USE_MUL since we cannot use DIV
      *_mul = \&_mul_use_mul;
      *_div = \&_div_use_mul;
      }
    else					# 0 or 1
      {
      # can USE_DIV instead
      *_mul = \&_mul_use_div;
      *_div = \&_div_use_div;
      }
    }
  return $BASE_LEN unless wantarray;
  return ($BASE_LEN, $BASE, $AND_BITS, $XOR_BITS, $OR_BITS, $BASE_LEN, $MAX_VAL);
  }

sub _new {
    # Given a string representing an integer, returns a reference to an array
    # of integers, where each integer represents a chunk of the original input
    # integer. Assumes normalized value as input.

    my ($proto, $str) = @_;

    my $input_len = length($str) - 1;

    # Shortcut for small numbers.
    return [ int($str) ] if $input_len < $BASE_LEN;

    my $format = "a" . (($input_len % $BASE_LEN) + 1);
    $format .= $] < 5.008 ? "a$BASE_LEN" x int($input_len / $BASE_LEN)
                          : "(a$BASE_LEN)*";

    [ reverse(map { 0 + $_ } unpack($format, $str)) ];
}

BEGIN
  {
  # from Daniel Pfeiffer: determine largest group of digits that is precisely
  # multipliable with itself plus carry
  # Test now changed to expect the proper pattern, not a result off by 1 or 2
  my ($e, $num) = 3;	# lowest value we will use is 3+1-1 = 3
  do {
      $num = '9' x ++$e;
      $num *= $num + 1;
  } while $num =~ /9{$e}0{$e}/;		# must be a certain pattern
  $e--; 				# last test failed, so retract one step
  # the limits below brush the problems with the test above under the rug:
  # the test should be able to find the proper $e automatically
  $e = 5 if $^O =~ /^uts/;	# UTS get's some special treatment
  $e = 5 if $^O =~ /^unicos/;	# unicos is also problematic (6 seems to work
				# there, but we play safe)

  my $int = 0;
  if ($e > 7)
    {
    use integer;
    my $e1 = 7;
    $num = 7;
    do 
      {
      $num = ('9' x ++$e1) + 0;
      $num *= $num + 1;
      } while ("$num" =~ /9{$e1}0{$e1}/);	# must be a certain pattern
    $e1--; 					# last test failed, so retract one step
    if ($e1 > 7)
      { 
      $int = 1; $e = $e1; 
      }
    }
 
  __PACKAGE__->_base_len($e,$int);	# set and store

  use integer;
  # find out how many bits _and, _or and _xor can take (old default = 16)
  # I don't think anybody has yet 128 bit scalars, so let's play safe.
  local $^W = 0;	# don't warn about 'nonportable number'
  $AND_BITS = 15; $XOR_BITS = 15; $OR_BITS = 15;

  # find max bits, we will not go higher than numberofbits that fit into $BASE
  # to make _and etc simpler (and faster for smaller, slower for large numbers)
  my $max = 16;
  while (2 ** $max < $BASE) { $max++; }
  {
    no integer;
    $max = 16 if $] < 5.006;	# older Perls might not take >16 too well
  }
  my ($x,$y,$z);
  do {
    $AND_BITS++;
    $x = CORE::oct('0b' . '1' x $AND_BITS); $y = $x & $x;
    $z = (2 ** $AND_BITS) - 1;
    } while ($AND_BITS < $max && $x == $z && $y == $x);
  $AND_BITS --;						# retreat one step
  do {
    $XOR_BITS++;
    $x = CORE::oct('0b' . '1' x $XOR_BITS); $y = $x ^ 0;
    $z = (2 ** $XOR_BITS) - 1;
    } while ($XOR_BITS < $max && $x == $z && $y == $x);
  $XOR_BITS --;						# retreat one step
  do {
    $OR_BITS++;
    $x = CORE::oct('0b' . '1' x $OR_BITS); $y = $x | $x;
    $z = (2 ** $OR_BITS) - 1;
    } while ($OR_BITS < $max && $x == $z && $y == $x);
  $OR_BITS --;						# retreat one step
  
  $AND_MASK = __PACKAGE__->_new( ( 2 ** $AND_BITS ));
  $XOR_MASK = __PACKAGE__->_new( ( 2 ** $XOR_BITS ));
  $OR_MASK = __PACKAGE__->_new( ( 2 ** $OR_BITS ));

  # We can compute the approximate length no faster than the real length:
  *_alen = \&_len;
  }

###############################################################################

sub _zero
  {
  # create a zero
  [ 0 ];
  }

sub _one
  {
  # create a one
  [ 1 ];
  }

sub _two
  {
  # create a two (used internally for shifting)
  [ 2 ];
  }

sub _ten
  {
  # create a 10 (used internally for shifting)
  [ 10 ];
  }

sub _1ex
  {
  # create a 1Ex
  my $rem = $_[1] % $BASE_LEN;		# remainder
  my $parts = $_[1] / $BASE_LEN;	# parts

  # 000000, 000000, 100 
  [ (0) x $parts, '1' . ('0' x $rem) ];
  }

sub _copy
  {
  # make a true copy
  [ @{$_[1]} ];
  }

# catch and throw away
sub import { }

##############################################################################
# convert back to string and number

sub _str {
    # Convert number from internal base 1eN format to string format. Internal
    # format is always normalized, i.e., no leading zeros.

    my $ary = $_[1];
    my $idx = $#$ary;             # index of last element

    if ($idx < 0) {               # should not happen
        require Carp;
        Carp::croak("$_[1] has no elements");
    }

    # Handle first one differently, since it should not have any leading zeros.
    my $ret = int($ary->[$idx]);
    if ($idx > 0) {
        $idx--;
        # Interestingly, the pre-padd method uses more time
        # the old grep variant takes longer (14 vs. 10 sec)
        my $z = '0' x ($BASE_LEN - 1);
        while ($idx >= 0) {
            $ret .= substr($z . $ary->[$idx], -$BASE_LEN);
            $idx--;
        }
    }
    $ret;
}

sub _num
  {
    # Make a Perl scalar number (int/float) from a BigInt object.
    my $x = $_[1];

    return 0 + $x->[0] if scalar @$x == 1;      # below $BASE

    # Start with the most significant element and work towards the least
    # significant element. Avoid multiplying "inf" (which happens if the number
    # overflows) with "0" (if there are zero elements in $x) since this gives
    # "nan" which propagates to the output.

    my $num = 0;
    for (my $i = $#$x ; $i >= 0 ; --$i) {
        $num *= $BASE;
        $num += $x -> [$i];
    }
    return $num;
  }

##############################################################################
# actual math code

sub _add {
    # (ref to int_num_array, ref to int_num_array)
    #
    # Routine to add two base 1eX numbers stolen from Knuth Vol 2 Algorithm A
    # pg 231. There are separate routines to add and sub as per Knuth pg 233.
    # This routine modifies array x, but not y.

    my ($c, $x, $y) = @_;

    return $x if @$y == 1 && $y->[0] == 0;      # $x + 0 => $x
    if (@$x == 1 && $x->[0] == 0) {             # 0 + $y => $y->copy
        # Twice as slow as $x = [ @$y ], but necessary to modify $x in-place.
        @$x = @$y;
        return $x;
    }

    # For each in Y, add Y to X and carry. If after that, something is left in
    # X, foreach in X add carry to X and then return X, carry. Trades one
    # "$j++" for having to shift arrays.
    my $i;
    my $car = 0;
    my $j = 0;
    for $i (@$y) {
        $x->[$j] -= $BASE if $car = (($x->[$j] += $i + $car) >= $BASE) ? 1 : 0;
        $j++;
    }
    while ($car != 0) {
        $x->[$j] -= $BASE if $car = (($x->[$j] += $car) >= $BASE) ? 1 : 0;
        $j++;
    }
    $x;
}

sub _inc {
    # (ref to int_num_array, ref to int_num_array)
    # Add 1 to $x, modify $x in place
    my ($c, $x) = @_;

    for my $i (@$x) {
        return $x if ($i += 1) < $BASE;		# early out
        $i = 0;					# overflow, next
    }
    push @$x, 1 if $x->[-1] == 0;		# last overflowed, so extend
    $x;
}

sub _dec {
    # (ref to int_num_array, ref to int_num_array)
    # Sub 1 from $x, modify $x in place
    my ($c, $x) = @_;

    my $MAX = $BASE - 1;			# since MAX_VAL based on BASE
    for my $i (@$x) {
        last if ($i -= 1) >= 0;			# early out
        $i = $MAX;				# underflow, next
    }
    pop @$x if $x->[-1] == 0 && @$x > 1;	# last underflowed (but leave 0)
    $x;
}

sub _sub {
    # (ref to int_num_array, ref to int_num_array, swap)
    #
    # Subtract base 1eX numbers -- stolen from Knuth Vol 2 pg 232, $x > $y
    # subtract Y from X by modifying x in place
    my ($c, $sx, $sy, $s) = @_;

    my $car = 0;
    my $i;
    my $j = 0;
    if (!$s) {
        for $i (@$sx) {
            last unless defined $sy->[$j] || $car;
            $i += $BASE if $car = (($i -= ($sy->[$j] || 0) + $car) < 0);
            $j++;
        }
        # might leave leading zeros, so fix that
        return __strip_zeros($sx);
    }
    for $i (@$sx) {
        # We can't do an early out if $x < $y, since we need to copy the high
        # chunks from $y. Found by Bob Mathews.
        #last unless defined $sy->[$j] || $car;
        $sy->[$j] += $BASE
          if $car = ($sy->[$j] = $i - ($sy->[$j] || 0) - $car) < 0;
        $j++;
    }
    # might leave leading zeros, so fix that
    __strip_zeros($sy);
}

sub _mul_use_mul
  {
  # (ref to int_num_array, ref to int_num_array)
  # multiply two numbers in internal representation
  # modifies first arg, second need not be different from first
  my ($c,$xv,$yv) = @_;

  if (@$yv == 1)
    {
    # shortcut for two very short numbers (improved by Nathan Zook)
    # works also if xv and yv are the same reference, and handles also $x == 0
    if (@$xv == 1)
      {
      if (($xv->[0] *= $yv->[0]) >= $BASE)
         {
         $xv->[0] = $xv->[0] - ($xv->[1] = int($xv->[0] * $RBASE)) * $BASE;
         };
      return $xv;
      }
    # $x * 0 => 0
    if ($yv->[0] == 0)
      {
      @$xv = (0);
      return $xv;
      }
    # multiply a large number a by a single element one, so speed up
    my $y = $yv->[0]; my $car = 0;
    foreach my $i (@$xv)
      {
      $i = $i * $y + $car; $car = int($i * $RBASE); $i -= $car * $BASE;
      }
    push @$xv, $car if $car != 0;
    return $xv;
    }
  # shortcut for result $x == 0 => result = 0
  return $xv if ( ((@$xv == 1) && ($xv->[0] == 0)) ); 

  # since multiplying $x with $x fails, make copy in this case
  $yv = [@$xv] if $xv == $yv;	# same references?

  my @prod = (); my ($prod,$car,$cty,$xi,$yi);

  for $xi (@$xv)
    {
    $car = 0; $cty = 0;

    # slow variant
#    for $yi (@$yv)
#      {
#      $prod = $xi * $yi + ($prod[$cty] || 0) + $car;
#      $prod[$cty++] =
#       $prod - ($car = int($prod * RBASE)) * $BASE;  # see USE_MUL
#      }
#    $prod[$cty] += $car if $car; # need really to check for 0?
#    $xi = shift @prod;

    # faster variant
    # looping through this if $xi == 0 is silly - so optimize it away!
    $xi = (shift @prod || 0), next if $xi == 0;
    for $yi (@$yv)
      {
      $prod = $xi * $yi + ($prod[$cty] || 0) + $car;
##     this is actually a tad slower
##        $prod = $prod[$cty]; $prod += ($car + $xi * $yi);	# no ||0 here
      $prod[$cty++] =
       $prod - ($car = int($prod * $RBASE)) * $BASE;  # see USE_MUL
      }
    $prod[$cty] += $car if $car; # need really to check for 0?
    $xi = shift @prod || 0;	# || 0 makes v5.005_3 happy
    }
  push @$xv, @prod;
  # can't have leading zeros
#  __strip_zeros($xv);
  $xv;
  }                                                                             

sub _mul_use_div_64
  {
  # (ref to int_num_array, ref to int_num_array)
  # multiply two numbers in internal representation
  # modifies first arg, second need not be different from first
  # works for 64 bit integer with "use integer"
  my ($c,$xv,$yv) = @_;

  use integer;
  if (@$yv == 1)
    {
    # shortcut for two small numbers, also handles $x == 0
    if (@$xv == 1)
      {
      # shortcut for two very short numbers (improved by Nathan Zook)
      # works also if xv and yv are the same reference, and handles also $x == 0
      if (($xv->[0] *= $yv->[0]) >= $BASE)
          {
          $xv->[0] =
              $xv->[0] - ($xv->[1] = $xv->[0] / $BASE) * $BASE;
          };
      return $xv;
      }
    # $x * 0 => 0
    if ($yv->[0] == 0)
      {
      @$xv = (0);
      return $xv;
      }
    # multiply a large number a by a single element one, so speed up
    my $y = $yv->[0]; my $car = 0;
    foreach my $i (@$xv)
      {
      #$i = $i * $y + $car; $car = $i / $BASE; $i -= $car * $BASE;
      $i = $i * $y + $car; $i -= ($car = $i / $BASE) * $BASE;
      }
    push @$xv, $car if $car != 0;
    return $xv;
    }
  # shortcut for result $x == 0 => result = 0
  return $xv if ( ((@$xv == 1) && ($xv->[0] == 0)) ); 

  # since multiplying $x with $x fails, make copy in this case
  $yv = [@$xv] if $xv == $yv;	# same references?

  my @prod = (); my ($prod,$car,$cty,$xi,$yi);
  for $xi (@$xv)
    {
    $car = 0; $cty = 0;
    # looping through this if $xi == 0 is silly - so optimize it away!
    $xi = (shift @prod || 0), next if $xi == 0;
    for $yi (@$yv)
      {
      $prod = $xi * $yi + ($prod[$cty] || 0) + $car;
      $prod[$cty++] = $prod - ($car = $prod / $BASE) * $BASE;
      }
    $prod[$cty] += $car if $car; # need really to check for 0?
    $xi = shift @prod || 0;	# || 0 makes v5.005_3 happy
    }
  push @$xv, @prod;
  $xv;
  }                                                                             

sub _mul_use_div
  {
  # (ref to int_num_array, ref to int_num_array)
  # multiply two numbers in internal representation
  # modifies first arg, second need not be different from first
  my ($c,$xv,$yv) = @_;

  if (@$yv == 1)
    {
    # shortcut for two small numbers, also handles $x == 0
    if (@$xv == 1)
      {
      # shortcut for two very short numbers (improved by Nathan Zook)
      # works also if xv and yv are the same reference, and handles also $x == 0
      if (($xv->[0] *= $yv->[0]) >= $BASE)
          {
          $xv->[0] =
              $xv->[0] - ($xv->[1] = int($xv->[0] / $BASE)) * $BASE;
          };
      return $xv;
      }
    # $x * 0 => 0
    if ($yv->[0] == 0)
      {
      @$xv = (0);
      return $xv;
      }
    # multiply a large number a by a single element one, so speed up
    my $y = $yv->[0]; my $car = 0;
    foreach my $i (@$xv)
      {
      $i = $i * $y + $car; $car = int($i / $BASE); $i -= $car * $BASE;
      # This (together with use integer;) does not work on 32-bit Perls
      #$i = $i * $y + $car; $i -= ($car = $i / $BASE) * $BASE;
      }
    push @$xv, $car if $car != 0;
    return $xv;
    }
  # shortcut for result $x == 0 => result = 0
  return $xv if ( ((@$xv == 1) && ($xv->[0] == 0)) ); 

  # since multiplying $x with $x fails, make copy in this case
  $yv = [@$xv] if $xv == $yv;	# same references?

  my @prod = (); my ($prod,$car,$cty,$xi,$yi);
  for $xi (@$xv)
    {
    $car = 0; $cty = 0;
    # looping through this if $xi == 0 is silly - so optimize it away!
    $xi = (shift @prod || 0), next if $xi == 0;
    for $yi (@$yv)
      {
      $prod = $xi * $yi + ($prod[$cty] || 0) + $car;
      $prod[$cty++] = $prod - ($car = int($prod / $BASE)) * $BASE;
      }
    $prod[$cty] += $car if $car; # need really to check for 0?
    $xi = shift @prod || 0;	# || 0 makes v5.005_3 happy
    }
  push @$xv, @prod;
  # can't have leading zeros
#  __strip_zeros($xv);
  $xv;
  }                                                                             

sub _div_use_mul
  {
  # ref to array, ref to array, modify first array and return remainder if 
  # in list context

  # see comments in _div_use_div() for more explanations

  my ($c,$x,$yorg) = @_;
  
  # the general div algorithm here is about O(N*N) and thus quite slow, so
  # we first check for some special cases and use shortcuts to handle them.

  # This works, because we store the numbers in a chunked format where each
  # element contains 5..7 digits (depending on system).

  # if both numbers have only one element:
  if (@$x == 1 && @$yorg == 1)
    {
    # shortcut, $yorg and $x are two small numbers
    if (wantarray)
      {
      my $r = [ $x->[0] % $yorg->[0] ];
      $x->[0] = int($x->[0] / $yorg->[0]);
      return ($x,$r); 
      }
    else
      {
      $x->[0] = int($x->[0] / $yorg->[0]);
      return $x; 
      }
    }

  # if x has more than one, but y has only one element:
  if (@$yorg == 1)
    {
    my $rem;
    $rem = _mod($c,[ @$x ],$yorg) if wantarray;

    # shortcut, $y is < $BASE
    my $j = scalar @$x; my $r = 0; 
    my $y = $yorg->[0]; my $b;
    while ($j-- > 0)
      {
      $b = $r * $BASE + $x->[$j];
      $x->[$j] = int($b/$y);
      $r = $b % $y;
      }
    pop @$x if @$x > 1 && $x->[-1] == 0;	# splice up a leading zero 
    return ($x,$rem) if wantarray;
    return $x;
    }

  # now x and y have more than one element

  # check whether y has more elements than x, if yet, the result will be 0
  if (@$yorg > @$x)
    {
    my $rem;
    $rem = [@$x] if wantarray;                  # make copy
    splice (@$x,1);                             # keep ref to original array
    $x->[0] = 0;                                # set to 0
    return ($x,$rem) if wantarray;              # including remainder?
    return $x;					# only x, which is [0] now
    }
  # check whether the numbers have the same number of elements, in that case
  # the result will fit into one element and can be computed efficiently
  if (@$yorg == @$x)
    {
    my $rem;
    # if $yorg has more digits than $x (it's leading element is longer than
    # the one from $x), the result will also be 0:
    if (length(int($yorg->[-1])) > length(int($x->[-1])))
      {
      $rem = [@$x] if wantarray;		# make copy
      splice (@$x,1);				# keep ref to org array
      $x->[0] = 0;				# set to 0
      return ($x,$rem) if wantarray;		# including remainder?
      return $x;
      }
    # now calculate $x / $yorg
    if (length(int($yorg->[-1])) == length(int($x->[-1])))
      {
      # same length, so make full compare

      my $a = 0; my $j = scalar @$x - 1;
      # manual way (abort if unequal, good for early ne)
      while ($j >= 0)
        {
        last if ($a = $x->[$j] - $yorg->[$j]); $j--;
        }
      # $a contains the result of the compare between X and Y
      # a < 0: x < y, a == 0: x == y, a > 0: x > y
      if ($a <= 0)
        {
        $rem = [ 0 ];                   # a = 0 => x == y => rem 0
        $rem = [@$x] if $a != 0;        # a < 0 => x < y => rem = x
        splice(@$x,1);                  # keep single element
        $x->[0] = 0;                    # if $a < 0
        $x->[0] = 1 if $a == 0;         # $x == $y
        return ($x,$rem) if wantarray;
        return $x;
        }
      # $x >= $y, so proceed normally
      }
    }

  # all other cases:

  my $y = [ @$yorg ];				# always make copy to preserve

  my ($car,$bar,$prd,$dd,$xi,$yi,@q,$v2,$v1,@d,$tmp,$q,$u2,$u1,$u0);

  $car = $bar = $prd = 0;
  if (($dd = int($BASE/($y->[-1]+1))) != 1) 
    {
    for $xi (@$x) 
      {
      $xi = $xi * $dd + $car;
      $xi -= ($car = int($xi * $RBASE)) * $BASE;	# see USE_MUL
      }
    push(@$x, $car); $car = 0;
    for $yi (@$y) 
      {
      $yi = $yi * $dd + $car;
      $yi -= ($car = int($yi * $RBASE)) * $BASE;	# see USE_MUL
      }
    }
  else 
    {
    push(@$x, 0);
    }
  @q = (); ($v2,$v1) = @$y[-2,-1];
  $v2 = 0 unless $v2;
  while ($#$x > $#$y) 
    {
    ($u2,$u1,$u0) = @$x[-3..-1];
    $u2 = 0 unless $u2;
    #warn "oups v1 is 0, u0: $u0 $y->[-2] $y->[-1] l ",scalar @$y,"\n"
    # if $v1 == 0;
    $q = (($u0 == $v1) ? $MAX_VAL : int(($u0*$BASE+$u1)/$v1));
    --$q while ($v2*$q > ($u0*$BASE+$u1-$q*$v1)*$BASE+$u2);
    if ($q)
      {
      ($car, $bar) = (0,0);
      for ($yi = 0, $xi = $#$x-$#$y-1; $yi <= $#$y; ++$yi,++$xi) 
        {
        $prd = $q * $y->[$yi] + $car;
        $prd -= ($car = int($prd * $RBASE)) * $BASE;	# see USE_MUL
	$x->[$xi] += $BASE if ($bar = (($x->[$xi] -= $prd + $bar) < 0));
	}
      if ($x->[-1] < $car + $bar) 
        {
        $car = 0; --$q;
	for ($yi = 0, $xi = $#$x-$#$y-1; $yi <= $#$y; ++$yi,++$xi) 
          {
	  $x->[$xi] -= $BASE
	   if ($car = (($x->[$xi] += $y->[$yi] + $car) >= $BASE));
	  }
	}   
      }
    pop(@$x);
    unshift(@q, $q);
    }
  if (wantarray) 
    {
    @d = ();
    if ($dd != 1)  
      {
      $car = 0; 
      for $xi (reverse @$x) 
        {
        $prd = $car * $BASE + $xi;
        $car = $prd - ($tmp = int($prd / $dd)) * $dd; # see USE_MUL
        unshift(@d, $tmp);
        }
      }
    else 
      {
      @d = @$x;
      }
    @$x = @q;
    my $d = \@d; 
    __strip_zeros($x);
    __strip_zeros($d);
    return ($x,$d);
    }
  @$x = @q;
  __strip_zeros($x);
  $x;
  }

sub _div_use_div_64
  {
  # ref to array, ref to array, modify first array and return remainder if 
  # in list context
  # This version works on 64 bit integers
  my ($c,$x,$yorg) = @_;

  use integer;
  # the general div algorithm here is about O(N*N) and thus quite slow, so
  # we first check for some special cases and use shortcuts to handle them.

  # This works, because we store the numbers in a chunked format where each
  # element contains 5..7 digits (depending on system).

  # if both numbers have only one element:
  if (@$x == 1 && @$yorg == 1)
    {
    # shortcut, $yorg and $x are two small numbers
    if (wantarray)
      {
      my $r = [ $x->[0] % $yorg->[0] ];
      $x->[0] = int($x->[0] / $yorg->[0]);
      return ($x,$r); 
      }
    else
      {
      $x->[0] = int($x->[0] / $yorg->[0]);
      return $x; 
      }
    }
  # if x has more than one, but y has only one element:
  if (@$yorg == 1)
    {
    my $rem;
    $rem = _mod($c,[ @$x ],$yorg) if wantarray;

    # shortcut, $y is < $BASE
    my $j = scalar @$x; my $r = 0; 
    my $y = $yorg->[0]; my $b;
    while ($j-- > 0)
      {
      $b = $r * $BASE + $x->[$j];
      $x->[$j] = int($b/$y);
      $r = $b % $y;
      }
    pop @$x if @$x > 1 && $x->[-1] == 0;	# splice up a leading zero 
    return ($x,$rem) if wantarray;
    return $x;
    }
  # now x and y have more than one element

  # check whether y has more elements than x, if yet, the result will be 0
  if (@$yorg > @$x)
    {
    my $rem;
    $rem = [@$x] if wantarray;			# make copy
    splice (@$x,1);				# keep ref to original array
    $x->[0] = 0;				# set to 0
    return ($x,$rem) if wantarray;		# including remainder?
    return $x;					# only x, which is [0] now
    }
  # check whether the numbers have the same number of elements, in that case
  # the result will fit into one element and can be computed efficiently
  if (@$yorg == @$x)
    {
    my $rem;
    # if $yorg has more digits than $x (it's leading element is longer than
    # the one from $x), the result will also be 0:
    if (length(int($yorg->[-1])) > length(int($x->[-1])))
      {
      $rem = [@$x] if wantarray;		# make copy
      splice (@$x,1);				# keep ref to org array
      $x->[0] = 0;				# set to 0
      return ($x,$rem) if wantarray;		# including remainder?
      return $x;
      }
    # now calculate $x / $yorg

    if (length(int($yorg->[-1])) == length(int($x->[-1])))
      {
      # same length, so make full compare

      my $a = 0; my $j = scalar @$x - 1;
      # manual way (abort if unequal, good for early ne)
      while ($j >= 0)
        {
        last if ($a = $x->[$j] - $yorg->[$j]); $j--;
        }
      # $a contains the result of the compare between X and Y
      # a < 0: x < y, a == 0: x == y, a > 0: x > y
      if ($a <= 0)
        {
        $rem = [ 0 ];			# a = 0 => x == y => rem 0
        $rem = [@$x] if $a != 0;	# a < 0 => x < y => rem = x
        splice(@$x,1);			# keep single element
        $x->[0] = 0;			# if $a < 0
        $x->[0] = 1 if $a == 0; 	# $x == $y
        return ($x,$rem) if wantarray;	# including remainder?
        return $x;
        }
      # $x >= $y, so proceed normally

      }
    }

  # all other cases:

  my $y = [ @$yorg ];				# always make copy to preserve
 
  my ($car,$bar,$prd,$dd,$xi,$yi,@q,$v2,$v1,@d,$tmp,$q,$u2,$u1,$u0);

  $car = $bar = $prd = 0;
  if (($dd = int($BASE/($y->[-1]+1))) != 1) 
    {
    for $xi (@$x) 
      {
      $xi = $xi * $dd + $car;
      $xi -= ($car = int($xi / $BASE)) * $BASE;
      }
    push(@$x, $car); $car = 0;
    for $yi (@$y) 
      {
      $yi = $yi * $dd + $car;
      $yi -= ($car = int($yi / $BASE)) * $BASE;
      }
    }
  else 
    {
    push(@$x, 0);
    }

  # @q will accumulate the final result, $q contains the current computed
  # part of the final result

  @q = (); ($v2,$v1) = @$y[-2,-1];
  $v2 = 0 unless $v2;
  while ($#$x > $#$y) 
    {
    ($u2,$u1,$u0) = @$x[-3..-1];
    $u2 = 0 unless $u2;
    #warn "oups v1 is 0, u0: $u0 $y->[-2] $y->[-1] l ",scalar @$y,"\n"
    # if $v1 == 0;
    $q = (($u0 == $v1) ? $MAX_VAL : int(($u0*$BASE+$u1)/$v1));
    --$q while ($v2*$q > ($u0*$BASE+$u1-$q*$v1)*$BASE+$u2);
    if ($q)
      {
      ($car, $bar) = (0,0);
      for ($yi = 0, $xi = $#$x-$#$y-1; $yi <= $#$y; ++$yi,++$xi) 
        {
        $prd = $q * $y->[$yi] + $car;
        $prd -= ($car = int($prd / $BASE)) * $BASE;
	$x->[$xi] += $BASE if ($bar = (($x->[$xi] -= $prd + $bar) < 0));
	}
      if ($x->[-1] < $car + $bar) 
        {
        $car = 0; --$q;
	for ($yi = 0, $xi = $#$x-$#$y-1; $yi <= $#$y; ++$yi,++$xi) 
          {
	  $x->[$xi] -= $BASE
	   if ($car = (($x->[$xi] += $y->[$yi] + $car) >= $BASE));
	  }
	}   
      }
    pop(@$x); unshift(@q, $q);
    }
  if (wantarray) 
    {
    @d = ();
    if ($dd != 1)  
      {
      $car = 0; 
      for $xi (reverse @$x) 
        {
        $prd = $car * $BASE + $xi;
        $car = $prd - ($tmp = int($prd / $dd)) * $dd;
        unshift(@d, $tmp);
        }
      }
    else 
      {
      @d = @$x;
      }
    @$x = @q;
    my $d = \@d; 
    __strip_zeros($x);
    __strip_zeros($d);
    return ($x,$d);
    }
  @$x = @q;
  __strip_zeros($x);
  $x;
  }

sub _div_use_div
  {
  # ref to array, ref to array, modify first array and return remainder if 
  # in list context
  my ($c,$x,$yorg) = @_;

  # the general div algorithm here is about O(N*N) and thus quite slow, so
  # we first check for some special cases and use shortcuts to handle them.

  # This works, because we store the numbers in a chunked format where each
  # element contains 5..7 digits (depending on system).

  # if both numbers have only one element:
  if (@$x == 1 && @$yorg == 1)
    {
    # shortcut, $yorg and $x are two small numbers
    if (wantarray)
      {
      my $r = [ $x->[0] % $yorg->[0] ];
      $x->[0] = int($x->[0] / $yorg->[0]);
      return ($x,$r); 
      }
    else
      {
      $x->[0] = int($x->[0] / $yorg->[0]);
      return $x; 
      }
    }
  # if x has more than one, but y has only one element:
  if (@$yorg == 1)
    {
    my $rem;
    $rem = _mod($c,[ @$x ],$yorg) if wantarray;

    # shortcut, $y is < $BASE
    my $j = scalar @$x; my $r = 0; 
    my $y = $yorg->[0]; my $b;
    while ($j-- > 0)
      {
      $b = $r * $BASE + $x->[$j];
      $x->[$j] = int($b/$y);
      $r = $b % $y;
      }
    pop @$x if @$x > 1 && $x->[-1] == 0;	# splice up a leading zero 
    return ($x,$rem) if wantarray;
    return $x;
    }
  # now x and y have more than one element

  # check whether y has more elements than x, if yet, the result will be 0
  if (@$yorg > @$x)
    {
    my $rem;
    $rem = [@$x] if wantarray;			# make copy
    splice (@$x,1);				# keep ref to original array
    $x->[0] = 0;				# set to 0
    return ($x,$rem) if wantarray;		# including remainder?
    return $x;					# only x, which is [0] now
    }
  # check whether the numbers have the same number of elements, in that case
  # the result will fit into one element and can be computed efficiently
  if (@$yorg == @$x)
    {
    my $rem;
    # if $yorg has more digits than $x (it's leading element is longer than
    # the one from $x), the result will also be 0:
    if (length(int($yorg->[-1])) > length(int($x->[-1])))
      {
      $rem = [@$x] if wantarray;		# make copy
      splice (@$x,1);				# keep ref to org array
      $x->[0] = 0;				# set to 0
      return ($x,$rem) if wantarray;		# including remainder?
      return $x;
      }
    # now calculate $x / $yorg

    if (length(int($yorg->[-1])) == length(int($x->[-1])))
      {
      # same length, so make full compare

      my $a = 0; my $j = scalar @$x - 1;
      # manual way (abort if unequal, good for early ne)
      while ($j >= 0)
        {
        last if ($a = $x->[$j] - $yorg->[$j]); $j--;
        }
      # $a contains the result of the compare between X and Y
      # a < 0: x < y, a == 0: x == y, a > 0: x > y
      if ($a <= 0)
        {
        $rem = [ 0 ];			# a = 0 => x == y => rem 0
        $rem = [@$x] if $a != 0;	# a < 0 => x < y => rem = x
        splice(@$x,1);			# keep single element
        $x->[0] = 0;			# if $a < 0
        $x->[0] = 1 if $a == 0; 	# $x == $y
        return ($x,$rem) if wantarray;	# including remainder?
        return $x;
        }
      # $x >= $y, so proceed normally

      }
    }

  # all other cases:

  my $y = [ @$yorg ];				# always make copy to preserve
 
  my ($car,$bar,$prd,$dd,$xi,$yi,@q,$v2,$v1,@d,$tmp,$q,$u2,$u1,$u0);

  $car = $bar = $prd = 0;
  if (($dd = int($BASE/($y->[-1]+1))) != 1) 
    {
    for $xi (@$x) 
      {
      $xi = $xi * $dd + $car;
      $xi -= ($car = int($xi / $BASE)) * $BASE;
      }
    push(@$x, $car); $car = 0;
    for $yi (@$y) 
      {
      $yi = $yi * $dd + $car;
      $yi -= ($car = int($yi / $BASE)) * $BASE;
      }
    }
  else 
    {
    push(@$x, 0);
    }

  # @q will accumulate the final result, $q contains the current computed
  # part of the final result

  @q = (); ($v2,$v1) = @$y[-2,-1];
  $v2 = 0 unless $v2;
  while ($#$x > $#$y) 
    {
    ($u2,$u1,$u0) = @$x[-3..-1];
    $u2 = 0 unless $u2;
    #warn "oups v1 is 0, u0: $u0 $y->[-2] $y->[-1] l ",scalar @$y,"\n"
    # if $v1 == 0;
    $q = (($u0 == $v1) ? $MAX_VAL : int(($u0*$BASE+$u1)/$v1));
    --$q while ($v2*$q > ($u0*$BASE+$u1-$q*$v1)*$BASE+$u2);
    if ($q)
      {
      ($car, $bar) = (0,0);
      for ($yi = 0, $xi = $#$x-$#$y-1; $yi <= $#$y; ++$yi,++$xi) 
        {
        $prd = $q * $y->[$yi] + $car;
        $prd -= ($car = int($prd / $BASE)) * $BASE;
	$x->[$xi] += $BASE if ($bar = (($x->[$xi] -= $prd + $bar) < 0));
	}
      if ($x->[-1] < $car + $bar) 
        {
        $car = 0; --$q;
	for ($yi = 0, $xi = $#$x-$#$y-1; $yi <= $#$y; ++$yi,++$xi) 
          {
	  $x->[$xi] -= $BASE
	   if ($car = (($x->[$xi] += $y->[$yi] + $car) >= $BASE));
	  }
	}   
      }
    pop(@$x); unshift(@q, $q);
    }
  if (wantarray) 
    {
    @d = ();
    if ($dd != 1)  
      {
      $car = 0; 
      for $xi (reverse @$x) 
        {
        $prd = $car * $BASE + $xi;
        $car = $prd - ($tmp = int($prd / $dd)) * $dd;
        unshift(@d, $tmp);
        }
      }
    else 
      {
      @d = @$x;
      }
    @$x = @q;
    my $d = \@d; 
    __strip_zeros($x);
    __strip_zeros($d);
    return ($x,$d);
    }
  @$x = @q;
  __strip_zeros($x);
  $x;
  }

##############################################################################
# testing

sub _acmp {
    # Internal absolute post-normalized compare (ignore signs)
    # ref to array, ref to array, return <0, 0, >0
    # Arrays must have at least one entry; this is not checked for.
    my ($c, $cx, $cy) = @_;

    # shortcut for short numbers
    return (($cx->[0] <=> $cy->[0]) <=> 0)
      if @$cx == @$cy && @$cx == 1;

    # fast comp based on number of array elements (aka pseudo-length)
    my $lxy = (@$cx - @$cy)
      # or length of first element if same number of elements (aka difference 0)
      ||
        # need int() here because sometimes the last element is '00018' vs '18'
        (length(int($cx->[-1])) - length(int($cy->[-1])));

    return -1 if $lxy < 0;      # already differs, ret
    return  1 if $lxy > 0;      # ditto

    # manual way (abort if unequal, good for early ne)
    my $a;
    my $j = @$cx;
    while (--$j >= 0) {
        last if $a = $cx->[$j] - $cy->[$j];
    }
    $a <=> 0;
}

sub _len {
    # compute number of digits in base 10

    # int() because add/sub sometimes leaves strings (like '00005') instead of
    # '5' in this place, thus causing length() to report wrong length
    my $cx = $_[1];

    (@$cx - 1) * $BASE_LEN + length(int($cx->[-1]));
}

sub _digit {
    # Return the nth digit. Zero is rightmost, so _digit(123,0) gives 3.
    # Negative values count from the left, so _digit(123, -1) gives 1.
    my ($c, $x, $n) = @_;

    my $len = _len('', $x);

    $n += $len if $n < 0;               # -1 last, -2 second-to-last
    return "0" if $n < 0 || $n >= $len; # return 0 for digits out of range

    my $elem = int($n / $BASE_LEN);     # which array element
    my $digit = $n % $BASE_LEN;         # which digit in this element
    substr("$x->[$elem]", -$digit - 1, 1);
}

sub _zeros {
    # Return number of trailing zeros in decimal.
    # Check each array element for having 0 at end as long as elem == 0
    # Upon finding a elem != 0, stop.

    my $x = $_[1];

    return 0 if @$x == 1 && $x->[0] == 0;

    my $zeros = 0;
    my $elem;
    foreach my $e (@$x) {
        if ($e != 0) {
            $elem = "$e";               # preserve x
            $elem =~ s/.*?(0*$)/$1/;    # strip anything not zero
            $zeros *= $BASE_LEN;        # elems * 5
            $zeros += length($elem);    # count trailing zeros
            last;                       # early out
        }
        $zeros ++;                      # real else branch: 50% slower!
    }
    $zeros;
}

##############################################################################
# _is_* routines

sub _is_zero {
    # return true if arg is zero 
    @{$_[1]} == 1 && $_[1]->[0] == 0 ? 1 : 0;
}

sub _is_even {
    # return true if arg is even
    $_[1]->[0] & 1 ? 0 : 1;
}

sub _is_odd {
    # return true if arg is odd
    $_[1]->[0] & 1 ? 1 : 0;
}

sub _is_one {
    # return true if arg is one
    @{$_[1]} == 1 && $_[1]->[0] == 1 ? 1 : 0;
}

sub _is_two {
    # return true if arg is two 
    @{$_[1]} == 1 && $_[1]->[0] == 2 ? 1 : 0;
}

sub _is_ten {
    # return true if arg is ten 
    @{$_[1]} == 1 && $_[1]->[0] == 10 ? 1 : 0;
}

sub __strip_zeros {
    # Internal normalization function that strips leading zeros from the array.
    # Args: ref to array
    my $s = shift;

    my $cnt = @$s;              # get count of parts
    my $i = $cnt - 1;
    push @$s, 0 if $i < 0;	# div might return empty results, so fix it

    return $s if @$s == 1;	# early out

    #print "strip: cnt $cnt i $i\n";
    # '0', '3', '4', '0', '0',
    #  0    1    2    3    4
    # cnt = 5, i = 4
    # i = 4
    # i = 3
    # => fcnt = cnt - i (5-2 => 3, cnt => 5-1 = 4, throw away from 4th pos)
    # >= 1: skip first part (this can be zero)
    while ($i > 0) {
        last if $s->[$i] != 0;
        $i--;
    }
    $i++;
    splice @$s, $i if $i < $cnt;        # $i cant be 0
    $s;
}

###############################################################################
# check routine to test internal state for corruptions

sub _check {
    # used by the test suite
    my $x = $_[1];

    return "$x is not a reference" if !ref($x);

    # are all parts are valid?
    my $i = 0;
    my $j = @$x;
    my ($e, $try);
    while ($i < $j) {
        $e = $x->[$i]; $e = 'undef' unless defined $e;
        $try = '=~ /^[\+]?[0-9]+\$/; '."($x, $e)";
        last if $e !~ /^[+]?[0-9]+$/;
        $try = '=~ /^[\+]?[0-9]+\$/; '."($x, $e) (stringify)";
        last if "$e" !~ /^[+]?[0-9]+$/;
        $try = '=~ /^[\+]?[0-9]+\$/; '."($x, $e) (cat-stringify)";
        last if '' . "$e" !~ /^[+]?[0-9]+$/;
        $try = ' < 0 || >= $BASE; '."($x, $e)";
        last if $e <0 || $e >= $BASE;
        # This test is disabled, since new/bnorm and certain ops (like early out
        # in add/sub) are allowed/expected to leave '00000' in some elements.
        #$try = '=~ /^00+/; '."($x, $e)";
        #last if $e =~ /^00+/;
        $i++;
    }
    return "Illegal part '$e' at pos $i (tested: $try)" if $i < $j;
    0;
}

###############################################################################

sub _mod {
    # if possible, use mod shortcut
    my ($c, $x, $yo) = @_;

    # slow way since $y too big
    if (@$yo > 1) {
        my ($xo, $rem) = _div($c, $x, $yo);
        @$x = @$rem;
        return $x;
    }

    my $y = $yo->[0];

    # if both are single element arrays
    if (scalar @$x == 1) {
        $x->[0] %= $y;
        return $x;
    }

    # if @$x has more than one element, but @$y is a single element
    my $b = $BASE % $y;
    if ($b == 0) {
        # when BASE % Y == 0 then (B * BASE) % Y == 0
        # (B * BASE) % $y + A % Y => A % Y
        # so need to consider only last element: O(1)
        $x->[0] %= $y;
    } elsif ($b == 1) {
        # else need to go through all elements in @$x: O(N), but loop is a bit
        # simplified
        my $r = 0;
        foreach (@$x) {
            $r = ($r + $_) % $y;        # not much faster, but heh...
            #$r += $_ % $y; $r %= $y;
        }
        $r = 0 if $r == $y;
        $x->[0] = $r;
    } else {
        # else need to go through all elements in @$x: O(N)
        my $r = 0;
        my $bm = 1;
        foreach (@$x) {
            $r = ($_ * $bm + $r) % $y;
            $bm = ($bm * $b) % $y;

            #$r += ($_ % $y) * $bm;
            #$bm *= $b;
            #$bm %= $y;
            #$r %= $y;
        }
        $r = 0 if $r == $y;
        $x->[0] = $r;
    }
    @$x = $x->[0];		# keep one element of @$x
    return $x;
}

##############################################################################
# shifts

sub _rsft {
    my ($c, $x, $y, $n) = @_;

    if ($n != 10) {
        $n = _new($c, $n);
        return _div($c, $x, _pow($c, $n, $y));
    }

    # shortcut (faster) for shifting by 10)
    # multiples of $BASE_LEN
    my $dst = 0;                                            # destination
    my $src = _num($c, $y);                                 # as normal int
    my $xlen = (@$x - 1) * $BASE_LEN + length(int($x->[-1]));
    if ($src >= $xlen or ($src == $xlen and !defined $x->[1])) {
        # 12345 67890 shifted right by more than 10 digits => 0
        splice(@$x, 1);                 # leave only one element
        $x->[0] = 0;                    # set to zero
        return $x;
    }
    my $rem = $src % $BASE_LEN;         # remainder to shift
    $src = int($src / $BASE_LEN);       # source
    if ($rem == 0) {
        splice(@$x, 0, $src);           # even faster, 38.4 => 39.3
    } else {
        my $len = @$x - $src;           # elems to go
        my $vd;
        my $z = '0' x $BASE_LEN;
        $x->[@$x] = 0;                  # avoid || 0 test inside loop
        while ($dst < $len) {
            $vd = $z . $x->[$src];
            $vd = substr($vd, -$BASE_LEN, $BASE_LEN - $rem);
            $src++;
            $vd = substr($z . $x->[$src], -$rem, $rem) . $vd;
            $vd = substr($vd, -$BASE_LEN, $BASE_LEN) if length($vd) > $BASE_LEN;
            $x->[$dst] = int($vd);
            $dst++;
        }
        splice(@$x, $dst) if $dst > 0;          # kill left-over array elems
        pop @$x if $x->[-1] == 0 && @$x > 1;    # kill last element if 0
    }                                           # else rem == 0
    $x;
}

sub _lsft {
    my ($c, $x, $y, $n) = @_;

    if ($n != 10) {
        $n = _new($c, $n);
        return _mul($c, $x, _pow($c, $n, $y));
    }

    # shortcut (faster) for shifting by 10) since we are in base 10eX
    # multiples of $BASE_LEN:
    my $src = @$x;                              # source
    my $len = _num($c, $y);		        # shift-len as normal int
    my $rem = $len % $BASE_LEN;	        	# remainder to shift
    my $dst = $src + int($len / $BASE_LEN);     # destination
    my $vd;                                     # further speedup
    $x->[$src] = 0;                             # avoid first ||0 for speed
    my $z = '0' x $BASE_LEN;
    while ($src >= 0) {
        $vd = $x->[$src];
        $vd = $z . $vd;
        $vd = substr($vd, -$BASE_LEN + $rem, $BASE_LEN - $rem);
        $vd .= $src > 0 ? substr($z . $x->[$src - 1], -$BASE_LEN, $rem)
                        : '0' x $rem;
        $vd = substr($vd, -$BASE_LEN, $BASE_LEN) if length($vd) > $BASE_LEN;
        $x->[$dst] = int($vd);
        $dst--;
        $src--;
    }
    # set lowest parts to 0
    while ($dst >= 0) {
        $x->[$dst--] = 0;
    }
    # fix spurious last zero element
    splice @$x, -1 if $x->[-1] == 0;
    $x;
}

sub _pow {
    # power of $x to $y
    # ref to array, ref to array, return ref to array
    my ($c, $cx, $cy) = @_;

    if (@$cy == 1 && $cy->[0] == 0) {
        splice(@$cx, 1);
        $cx->[0] = 1;                   # y == 0 => x => 1
        return $cx;
    }

    if ((@$cx == 1 && $cx->[0] == 1) ||     #    x == 1
        (@$cy == 1 && $cy->[0] == 1))       # or y == 1
    {
        return $cx;
    }

    if (@$cx == 1 && $cx->[0] == 0) {
        splice (@$cx, 1);
        $cx->[0] = 0;                   # 0 ** y => 0 (if not y <= 0)
        return $cx;
    }

    my $pow2 = _one();

    my $y_bin = _as_bin($c, $cy);
    $y_bin =~ s/^0b//;
    my $len = length($y_bin);
    while (--$len > 0) {
        _mul($c, $pow2, $cx) if substr($y_bin, $len, 1) eq '1'; # is odd?
        _mul($c, $cx, $cx);
    }

    _mul($c, $cx, $pow2);
    $cx;
}

sub _nok {
    # Return binomial coefficient (n over k).
    # Given refs to arrays, return ref to array.
    # First input argument is modified.

    my ($c, $n, $k) = @_;

    # If k > n/2, or, equivalently, 2*k > n, compute nok(n, k) as
    # nok(n, n-k), to minimize the number if iterations in the loop.

    {
        my $twok = _mul($c, _two($c), _copy($c, $k));   # 2 * k
        if (_acmp($c, $twok, $n) > 0) {                 # if 2*k > n
            $k = _sub($c, _copy($c, $n), $k);           # k = n - k
        }
    }

    # Example:
    #
    # / 7 \       7!       1*2*3*4 * 5*6*7   5 * 6 * 7       6   7
    # |   | = --------- =  --------------- = --------- = 5 * - * -
    # \ 3 /   (7-3)! 3!    1*2*3*4 * 1*2*3   1 * 2 * 3       2   3

    if (_is_zero($c, $k)) {
        @$n = 1;
    }

    else {

        # Make a copy of the original n, since we'll be modifying n in-place.

        my $n_orig = _copy($c, $n);

        # n = 5, f = 6, d = 2 (cf. example above)

        _sub($c, $n, $k);
        _inc($c, $n);

        my $f = _copy($c, $n);
        _inc($c, $f);

        my $d = _two($c);

        # while f <= n (the original n, that is) ...

        while (_acmp($c, $f, $n_orig) <= 0) {

            # n = (n * f / d) == 5 * 6 / 2 (cf. example above)

            _mul($c, $n, $f);
            _div($c, $n, $d);

            # f = 7, d = 3 (cf. example above)

            _inc($c, $f);
            _inc($c, $d);
        }

    }

    return $n;
}

my @factorials = (
  1,
  1,
  2,
  2*3,
  2*3*4,
  2*3*4*5,
  2*3*4*5*6,
  2*3*4*5*6*7,
);

sub _fac
  {
  # factorial of $x
  # ref to array, return ref to array
  my ($c,$cx) = @_;

  if ((@$cx == 1) && ($cx->[0] <= 7))
    {
    $cx->[0] = $factorials[$cx->[0]];		# 0 => 1, 1 => 1, 2 => 2 etc.
    return $cx;
    }

  if ((@$cx == 1) && 		# we do this only if $x >= 12 and $x <= 7000
      ($cx->[0] >= 12 && $cx->[0] < 7000))
    {

  # Calculate (k-j) * (k-j+1) ... k .. (k+j-1) * (k + j)
  # See http://blogten.blogspot.com/2007/01/calculating-n.html
  # The above series can be expressed as factors:
  #   k * k - (j - i) * 2
  # We cache k*k, and calculate (j * j) as the sum of the first j odd integers

  # This will not work when N exceeds the storage of a Perl scalar, however,
  # in this case the algorithm would be way to slow to terminate, anyway.

  # As soon as the last element of $cx is 0, we split it up and remember
  # how many zeors we got so far. The reason is that n! will accumulate
  # zeros at the end rather fast.
  my $zero_elements = 0;

  # If n is even, set n = n -1
  my $k = _num($c,$cx); my $even = 1;
  if (($k & 1) == 0)
    {
    $even = $k; $k --;
    }
  # set k to the center point
  $k = ($k + 1) / 2;
#  print "k $k even: $even\n";
  # now calculate k * k
  my $k2 = $k * $k;
  my $odd = 1; my $sum = 1;
  my $i = $k - 1;
  # keep reference to x
  my $new_x = _new($c, $k * $even);
  @$cx = @$new_x;
  if ($cx->[0] == 0)
    {
    $zero_elements ++; shift @$cx;
    }
#  print STDERR "x = ", _str($c,$cx),"\n";
  my $BASE2 = int(sqrt($BASE))-1;
  my $j = 1; 
  while ($j <= $i)
    {
    my $m = ($k2 - $sum); $odd += 2; $sum += $odd; $j++;
    while ($j <= $i && ($m < $BASE2) && (($k2 - $sum) < $BASE2))
      {
      $m *= ($k2 - $sum);
      $odd += 2; $sum += $odd; $j++;
#      print STDERR "\n k2 $k2 m $m sum $sum odd $odd\n"; sleep(1);
      }
    if ($m < $BASE)
      {
      _mul($c,$cx,[$m]);
      }
    else
      {
      _mul($c,$cx,$c->_new($m));
      }
    if ($cx->[0] == 0)
      {
      $zero_elements ++; shift @$cx;
      }
#    print STDERR "Calculate $k2 - $sum = $m (x = ", _str($c,$cx),")\n";
    }
  # multiply in the zeros again
  unshift @$cx, (0) x $zero_elements; 
  return $cx;
  }

  # go forward until $base is exceeded
  # limit is either $x steps (steps == 100 means a result always too high) or
  # $base.
  my $steps = 100; $steps = $cx->[0] if @$cx == 1;
  my $r = 2; my $cf = 3; my $step = 2; my $last = $r;
  while ($r*$cf < $BASE && $step < $steps)
    {
    $last = $r; $r *= $cf++; $step++;
    }
  if ((@$cx == 1) && $step == $cx->[0])
    {
    # completely done, so keep reference to $x and return
    $cx->[0] = $r;
    return $cx;
    }
  
  # now we must do the left over steps
  my $n;					# steps still to do
  if (scalar @$cx == 1)
    {
    $n = $cx->[0];
    }
  else
    {
    $n = _copy($c,$cx);
    }

  # Set $cx to the last result below $BASE (but keep ref to $x)
  $cx->[0] = $last; splice (@$cx,1);
  # As soon as the last element of $cx is 0, we split it up and remember
  # how many zeors we got so far. The reason is that n! will accumulate
  # zeros at the end rather fast.
  my $zero_elements = 0;

  # do left-over steps fit into a scalar?
  if (ref $n eq 'ARRAY')
    {
    # No, so use slower inc() & cmp()
    # ($n is at least $BASE here)
    my $base_2 = int(sqrt($BASE)) - 1;
    #print STDERR "base_2: $base_2\n"; 
    while ($step < $base_2)
      {
      if ($cx->[0] == 0)
        {
        $zero_elements ++; shift @$cx;
        }
      my $b = $step * ($step + 1); $step += 2;
      _mul($c,$cx,[$b]);
      }
    $step = [$step];
    while (_acmp($c,$step,$n) <= 0)
      {
      if ($cx->[0] == 0)
        {
        $zero_elements ++; shift @$cx;
        }
      _mul($c,$cx,$step); _inc($c,$step);
      }
    }
  else
    {
    # Yes, so we can speed it up slightly
  
#    print "# left over steps $n\n";

    my $base_4 = int(sqrt(sqrt($BASE))) - 2;
    #print STDERR "base_4: $base_4\n";
    my $n4 = $n - 4; 
    while ($step < $n4 && $step < $base_4)
      {
      if ($cx->[0] == 0)
        {
        $zero_elements ++; shift @$cx;
        }
      my $b = $step * ($step + 1); $step += 2; $b *= $step * ($step + 1); $step += 2;
      _mul($c,$cx,[$b]);
      }
    my $base_2 = int(sqrt($BASE)) - 1;
    my $n2 = $n - 2; 
    #print STDERR "base_2: $base_2\n"; 
    while ($step < $n2 && $step < $base_2)
      {
      if ($cx->[0] == 0)
        {
        $zero_elements ++; shift @$cx;
        }
      my $b = $step * ($step + 1); $step += 2;
      _mul($c,$cx,[$b]);
      }
    # do what's left over
    while ($step <= $n)
      {
      _mul($c,$cx,[$step]); $step++;
      if ($cx->[0] == 0)
        {
        $zero_elements ++; shift @$cx;
        }
      }
    }
  # multiply in the zeros again
  unshift @$cx, (0) x $zero_elements;
  $cx;			# return result
  }

#############################################################################

sub _log_int
  {
  # calculate integer log of $x to base $base
  # ref to array, ref to array - return ref to array
  my ($c,$x,$base) = @_;

  # X == 0 => NaN
  return if (scalar @$x == 1 && $x->[0] == 0);
  # BASE 0 or 1 => NaN
  return if (scalar @$base == 1 && $base->[0] < 2);
  my $cmp = _acmp($c,$x,$base); # X == BASE => 1
  if ($cmp == 0)
    {
    splice (@$x,1); $x->[0] = 1;
    return ($x,1)
    }
  # X < BASE
  if ($cmp < 0)
    {
    splice (@$x,1); $x->[0] = 0;
    return ($x,undef);
    }

  my $x_org = _copy($c,$x);		# preserve x
  splice(@$x,1); $x->[0] = 1;		# keep ref to $x

  # Compute a guess for the result based on:
  # $guess = int ( length_in_base_10(X) / ( log(base) / log(10) ) )
  my $len = _len($c,$x_org);
  my $log = log($base->[-1]) / log(10);

  # for each additional element in $base, we add $BASE_LEN to the result,
  # based on the observation that log($BASE,10) is BASE_LEN and
  # log(x*y) == log(x) + log(y):
  $log += ((scalar @$base)-1) * $BASE_LEN;

  # calculate now a guess based on the values obtained above:
  my $res = int($len / $log);

  $x->[0] = $res;
  my $trial = _pow ($c, _copy($c, $base), $x);
  my $a = _acmp($c,$trial,$x_org);

#  print STDERR "# trial ", _str($c,$x)," was: $a (0 = exact, -1 too small, +1 too big)\n";

  # found an exact result?
  return ($x,1) if $a == 0;

  if ($a > 0)
    {
    # or too big
    _div($c,$trial,$base); _dec($c, $x);
    while (($a = _acmp($c,$trial,$x_org)) > 0)
      {
#      print STDERR "# big _log_int at ", _str($c,$x), "\n"; 
      _div($c,$trial,$base); _dec($c, $x);
      }
    # result is now exact (a == 0), or too small (a < 0)
    return ($x, $a == 0 ? 1 : 0);
    }

  # else: result was to small
  _mul($c,$trial,$base);

  # did we now get the right result?
  $a = _acmp($c,$trial,$x_org);

  if ($a == 0)				# yes, exactly
    {
    _inc($c, $x);
    return ($x,1); 
    }
  return ($x,0) if $a > 0;  

  # Result still too small (we should come here only if the estimate above
  # was very off base):
 
  # Now let the normal trial run obtain the real result
  # Simple loop that increments $x by 2 in each step, possible overstepping
  # the real result

  my $base_mul = _mul($c, _copy($c,$base), $base);	# $base * $base

  while (($a = _acmp($c,$trial,$x_org)) < 0)
    {
#    print STDERR "# small _log_int at ", _str($c,$x), "\n"; 
    _mul($c,$trial,$base_mul); _add($c, $x, [2]);
    }

  my $exact = 1;
  if ($a > 0)
    {
    # overstepped the result
    _dec($c, $x);
    _div($c,$trial,$base);
    $a = _acmp($c,$trial,$x_org);
    if ($a > 0)
      {
      _dec($c, $x);
      }
    $exact = 0 if $a != 0;		# a = -1 => not exact result, a = 0 => exact
    }
  
  ($x,$exact);				# return result
  }

# for debugging:
  use constant DEBUG => 0;
  my $steps = 0;
  sub steps { $steps };

sub _sqrt
  {
  # square-root of $x in place
  # Compute a guess of the result (by rule of thumb), then improve it via
  # Newton's method.
  my ($c,$x) = @_;

  if (scalar @$x == 1)
    {
    # fits into one Perl scalar, so result can be computed directly
    $x->[0] = int(sqrt($x->[0]));
    return $x;
    } 
  my $y = _copy($c,$x);
  # hopefully _len/2 is < $BASE, the -1 is to always undershot the guess
  # since our guess will "grow"
  my $l = int((_len($c,$x)-1) / 2);	

  my $lastelem = $x->[-1];					# for guess
  my $elems = scalar @$x - 1;
  # not enough digits, but could have more?
  if ((length($lastelem) <= 3) && ($elems > 1))
    {
    # right-align with zero pad
    my $len = length($lastelem) & 1;
    print "$lastelem => " if DEBUG;
    $lastelem .= substr($x->[-2] . '0' x $BASE_LEN,0,$BASE_LEN);
    # former odd => make odd again, or former even to even again
    $lastelem = $lastelem / 10 if (length($lastelem) & 1) != $len;
    print "$lastelem\n" if DEBUG;
    }

  # construct $x (instead of _lsft($c,$x,$l,10)
  my $r = $l % $BASE_LEN;	# 10000 00000 00000 00000 ($BASE_LEN=5)
  $l = int($l / $BASE_LEN);
  print "l =  $l " if DEBUG;

  splice @$x,$l;		# keep ref($x), but modify it

  # we make the first part of the guess not '1000...0' but int(sqrt($lastelem))
  # that gives us:
  # 14400 00000 => sqrt(14400) => guess first digits to be 120
  # 144000 000000 => sqrt(144000) => guess 379

  print "$lastelem (elems $elems) => " if DEBUG;
  $lastelem = $lastelem / 10 if ($elems & 1 == 1);		# odd or even?
  my $g = sqrt($lastelem); $g =~ s/\.//;			# 2.345 => 2345
  $r -= 1 if $elems & 1 == 0;					# 70 => 7

  # padd with zeros if result is too short
  $x->[$l--] = int(substr($g . '0' x $r,0,$r+1));
  print "now ",$x->[-1] if DEBUG;
  print " would have been ", int('1' . '0' x $r),"\n" if DEBUG;

  # If @$x > 1, we could compute the second elem of the guess, too, to create
  # an even better guess. Not implemented yet. Does it improve performance?
  $x->[$l--] = 0 while ($l >= 0);	# all other digits of guess are zero

  print "start x= ",_str($c,$x),"\n" if DEBUG;
  my $two = _two();
  my $last = _zero();
  my $lastlast = _zero();
  $steps = 0 if DEBUG;
  while (_acmp($c,$last,$x) != 0 && _acmp($c,$lastlast,$x) != 0)
    {
    $steps++ if DEBUG;
    $lastlast = _copy($c,$last);
    $last = _copy($c,$x);
    _add($c,$x, _div($c,_copy($c,$y),$x));
    _div($c,$x, $two );
    print " x= ",_str($c,$x),"\n" if DEBUG;
    }
  print "\nsteps in sqrt: $steps, " if DEBUG;
  _dec($c,$x) if _acmp($c,$y,_mul($c,_copy($c,$x),$x)) < 0;	# overshot? 
  print " final ",$x->[-1],"\n" if DEBUG;
  $x;
  }

sub _root
  {
  # take n'th root of $x in place (n >= 3)
  my ($c,$x,$n) = @_;
 
  if (scalar @$x == 1)
    {
    if (scalar @$n > 1)
      {
      # result will always be smaller than 2 so trunc to 1 at once
      $x->[0] = 1;
      }
    else
      {
      # fits into one Perl scalar, so result can be computed directly
      # cannot use int() here, because it rounds wrongly (try 
      # (81 ** 3) ** (1/3) to see what I mean)
      #$x->[0] = int( $x->[0] ** (1 / $n->[0]) );
      # round to 8 digits, then truncate result to integer
      $x->[0] = int ( sprintf ("%.8f", $x->[0] ** (1 / $n->[0]) ) );
      }
    return $x;
    } 

  # we know now that X is more than one element long

  # if $n is a power of two, we can repeatedly take sqrt($X) and find the
  # proper result, because sqrt(sqrt($x)) == root($x,4)
  my $b = _as_bin($c,$n);
  if ($b =~ /0b1(0+)$/)
    {
    my $count = CORE::length($1);	# 0b100 => len('00') => 2
    my $cnt = $count;			# counter for loop
    unshift (@$x, 0);			# add one element, together with one
					# more below in the loop this makes 2
    while ($cnt-- > 0)
      {
      # 'inflate' $X by adding one element, basically computing
      # $x * $BASE * $BASE. This gives us more $BASE_LEN digits for result
      # since len(sqrt($X)) approx == len($x) / 2.
      unshift (@$x, 0);
      # calculate sqrt($x), $x is now one element to big, again. In the next
      # round we make that two, again.
      _sqrt($c,$x);
      }
    # $x is now one element to big, so truncate result by removing it
    splice (@$x,0,1);
    } 
  else
    {
    # trial computation by starting with 2,4,8,16 etc until we overstep
    my $step;
    my $trial = _two();

    # while still to do more than X steps
    do
      {
      $step = _two();
      while (_acmp($c, _pow($c, _copy($c, $trial), $n), $x) < 0)
        {
        _mul ($c, $step, [2]);
        _add ($c, $trial, $step);
        }

      # hit exactly?
      if (_acmp($c, _pow($c, _copy($c, $trial), $n), $x) == 0)
        {
        @$x = @$trial;			# make copy while preserving ref to $x
        return $x;
        }
      # overstepped, so go back on step
      _sub($c, $trial, $step);
      } while (scalar @$step > 1 || $step->[0] > 128);

    # reset step to 2
    $step = _two();
    # add two, because $trial cannot be exactly the result (otherwise we would
    # already have found it)
    _add($c, $trial, $step);
 
    # and now add more and more (2,4,6,8,10 etc)
    while (_acmp($c, _pow($c, _copy($c, $trial), $n), $x) < 0)
      {
      _add ($c, $trial, $step);
      }

    # hit not exactly? (overstepped)
    if (_acmp($c, _pow($c, _copy($c, $trial), $n), $x) > 0)
      {
      _dec($c,$trial);
      }

    # hit not exactly? (overstepped)
    # 80 too small, 81 slightly too big, 82 too big
    if (_acmp($c, _pow($c, _copy($c, $trial), $n), $x) > 0)
      {
      _dec ($c, $trial); 
      }

    @$x = @$trial;			# make copy while preserving ref to $x
    return $x;
    }
  $x; 
  }

##############################################################################
# binary stuff

sub _and
  {
  my ($c,$x,$y) = @_;

  # the shortcut makes equal, large numbers _really_ fast, and makes only a
  # very small performance drop for small numbers (e.g. something with less
  # than 32 bit) Since we optimize for large numbers, this is enabled.
  return $x if _acmp($c,$x,$y) == 0;		# shortcut
  
  my $m = _one(); my ($xr,$yr);
  my $mask = $AND_MASK;

  my $x1 = $x;
  my $y1 = _copy($c,$y);			# make copy
  $x = _zero();
  my ($b,$xrr,$yrr);
  use integer;
  while (!_is_zero($c,$x1) && !_is_zero($c,$y1))
    {
    ($x1, $xr) = _div($c,$x1,$mask);
    ($y1, $yr) = _div($c,$y1,$mask);

    # make ints() from $xr, $yr
    # this is when the AND_BITS are greater than $BASE and is slower for
    # small (<256 bits) numbers, but faster for large numbers. Disabled
    # due to KISS principle

#    $b = 1; $xrr = 0; foreach (@$xr) { $xrr += $_ * $b; $b *= $BASE; }
#    $b = 1; $yrr = 0; foreach (@$yr) { $yrr += $_ * $b; $b *= $BASE; }
#    _add($c,$x, _mul($c, _new( $c, ($xrr & $yrr) ), $m) );
    
    # 0+ due to '&' doesn't work in strings
    _add($c,$x, _mul($c, [ 0+$xr->[0] & 0+$yr->[0] ], $m) );
    _mul($c,$m,$mask);
    }
  $x;
  }

sub _xor
  {
  my ($c,$x,$y) = @_;

  return _zero() if _acmp($c,$x,$y) == 0;	# shortcut (see -and)

  my $m = _one(); my ($xr,$yr);
  my $mask = $XOR_MASK;

  my $x1 = $x;
  my $y1 = _copy($c,$y);			# make copy
  $x = _zero();
  my ($b,$xrr,$yrr);
  use integer;
  while (!_is_zero($c,$x1) && !_is_zero($c,$y1))
    {
    ($x1, $xr) = _div($c,$x1,$mask);
    ($y1, $yr) = _div($c,$y1,$mask);
    # make ints() from $xr, $yr (see _and())
    #$b = 1; $xrr = 0; foreach (@$xr) { $xrr += $_ * $b; $b *= $BASE; }
    #$b = 1; $yrr = 0; foreach (@$yr) { $yrr += $_ * $b; $b *= $BASE; }
    #_add($c,$x, _mul($c, _new( $c, ($xrr ^ $yrr) ), $m) );

    # 0+ due to '^' doesn't work in strings
    _add($c,$x, _mul($c, [ 0+$xr->[0] ^ 0+$yr->[0] ], $m) );
    _mul($c,$m,$mask);
    }
  # the loop stops when the shorter of the two numbers is exhausted
  # the remainder of the longer one will survive bit-by-bit, so we simple
  # multiply-add it in
  _add($c,$x, _mul($c, $x1, $m) ) if !_is_zero($c,$x1);
  _add($c,$x, _mul($c, $y1, $m) ) if !_is_zero($c,$y1);
  
  $x;
  }

sub _or
  {
  my ($c,$x,$y) = @_;

  return $x if _acmp($c,$x,$y) == 0;		# shortcut (see _and)

  my $m = _one(); my ($xr,$yr);
  my $mask = $OR_MASK;

  my $x1 = $x;
  my $y1 = _copy($c,$y);			# make copy
  $x = _zero();
  my ($b,$xrr,$yrr);
  use integer;
  while (!_is_zero($c,$x1) && !_is_zero($c,$y1))
    {
    ($x1, $xr) = _div($c,$x1,$mask);
    ($y1, $yr) = _div($c,$y1,$mask);
    # make ints() from $xr, $yr (see _and())
#    $b = 1; $xrr = 0; foreach (@$xr) { $xrr += $_ * $b; $b *= $BASE; }
#    $b = 1; $yrr = 0; foreach (@$yr) { $yrr += $_ * $b; $b *= $BASE; }
#    _add($c,$x, _mul($c, _new( $c, ($xrr | $yrr) ), $m) );
    
    # 0+ due to '|' doesn't work in strings
    _add($c,$x, _mul($c, [ 0+$xr->[0] | 0+$yr->[0] ], $m) );
    _mul($c,$m,$mask);
    }
  # the loop stops when the shorter of the two numbers is exhausted
  # the remainder of the longer one will survive bit-by-bit, so we simple
  # multiply-add it in
  _add($c,$x, _mul($c, $x1, $m) ) if !_is_zero($c,$x1);
  _add($c,$x, _mul($c, $y1, $m) ) if !_is_zero($c,$y1);
  
  $x;
  }

sub _as_hex
  {
  # convert a decimal number to hex (ref to array, return ref to string)
  my ($c,$x) = @_;

  # fits into one element (handle also 0x0 case)
  return sprintf("0x%x",$x->[0]) if @$x == 1;

  my $x1 = _copy($c,$x);

  my $es = '';
  my ($xr, $h, $x10000);
  if ($] >= 5.006)
    {
    $x10000 = [ 0x10000 ]; $h = 'h4';
    }
  else
    {
    $x10000 = [ 0x1000 ]; $h = 'h3';
    }
  while (@$x1 != 1 || $x1->[0] != 0)		# _is_zero()
    {
    ($x1, $xr) = _div($c,$x1,$x10000);
    $es .= unpack($h,pack('V',$xr->[0]));
    }
  $es = reverse $es;
  $es =~ s/^[0]+//;   # strip leading zeros
  '0x' . $es;					# return result prepended with 0x
  }

sub _as_bin
  {
  # convert a decimal number to bin (ref to array, return ref to string)
  my ($c,$x) = @_;

  # fits into one element (and Perl recent enough), handle also 0b0 case
  # handle zero case for older Perls
  if ($] <= 5.005 && @$x == 1 && $x->[0] == 0)
    {
    my $t = '0b0'; return $t;
    }
  if (@$x == 1 && $] >= 5.006)
    {
    my $t = sprintf("0b%b",$x->[0]);
    return $t;
    }
  my $x1 = _copy($c,$x);

  my $es = '';
  my ($xr, $b, $x10000);
  if ($] >= 5.006)
    {
    $x10000 = [ 0x10000 ]; $b = 'b16';
    }
  else
    {
    $x10000 = [ 0x1000 ]; $b = 'b12';
    }
  while (!(@$x1 == 1 && $x1->[0] == 0))		# _is_zero()
    {
    ($x1, $xr) = _div($c,$x1,$x10000);
    $es .= unpack($b,pack('v',$xr->[0]));
    }
  $es = reverse $es;
  $es =~ s/^[0]+//;   # strip leading zeros
  '0b' . $es;					# return result prepended with 0b
  }

sub _as_oct
  {
  # convert a decimal number to octal (ref to array, return ref to string)
  my ($c,$x) = @_;

  # fits into one element (handle also 0 case)
  return sprintf("0%o",$x->[0]) if @$x == 1;

  my $x1 = _copy($c,$x);

  my $es = '';
  my $xr;
  my $x1000 = [ 0100000 ];
  while (@$x1 != 1 || $x1->[0] != 0)		# _is_zero()
    {
    ($x1, $xr) = _div($c,$x1,$x1000);
    $es .= reverse sprintf("%05o", $xr->[0]);
    }
  $es = reverse $es;
  $es =~ s/^0+//;   # strip leading zeros
  '0' . $es;					# return result prepended with 0
  }

sub _from_oct
  {
  # convert a octal number to decimal (string, return ref to array)
  my ($c,$os) = @_;

  # for older Perls, play safe
  my $m = [ 0100000 ];
  my $d = 5;					# 5 digits at a time

  my $mul = _one();
  my $x = _zero();

  my $len = int( (length($os)-1)/$d );		# $d digit parts, w/o the '0'
  my $val; my $i = -$d;
  while ($len >= 0)
    {
    $val = substr($os,$i,$d);			# get oct digits
    $val = CORE::oct($val);
    $i -= $d; $len --;
    my $adder = [ $val ];
    _add ($c, $x, _mul ($c, $adder, $mul ) ) if $val != 0;
    _mul ($c, $mul, $m ) if $len >= 0; 		# skip last mul
    }
  $x;
  }

sub _from_hex
  {
  # convert a hex number to decimal (string, return ref to array)
  my ($c,$hs) = @_;

  my $m = _new($c, 0x10000000);			# 28 bit at a time (<32 bit!)
  my $d = 7;					# 7 digits at a time
  if ($] <= 5.006)
    {
    # for older Perls, play safe
    $m = [ 0x10000 ];				# 16 bit at a time (<32 bit!)
    $d = 4;					# 4 digits at a time
    }

  my $mul = _one();
  my $x = _zero();

  my $len = int( (length($hs)-2)/$d );		# $d digit parts, w/o the '0x'
  my $val; my $i = -$d;
  while ($len >= 0)
    {
    $val = substr($hs,$i,$d);			# get hex digits
    $val =~ s/^0x// if $len == 0;		# for last part only because
    $val = CORE::hex($val);			# hex does not like wrong chars
    $i -= $d; $len --;
    my $adder = [ $val ];
    # if the resulting number was to big to fit into one element, create a
    # two-element version (bug found by Mark Lakata - Thanx!)
    if (CORE::length($val) > $BASE_LEN)
      {
      $adder = _new($c,$val);
      }
    _add ($c, $x, _mul ($c, $adder, $mul ) ) if $val != 0;
    _mul ($c, $mul, $m ) if $len >= 0; 		# skip last mul
    }
  $x;
  }

sub _from_bin
  {
  # convert a hex number to decimal (string, return ref to array)
  my ($c,$bs) = @_;

  # instead of converting X (8) bit at a time, it is faster to "convert" the
  # number to hex, and then call _from_hex.

  my $hs = $bs;
  $hs =~ s/^[+-]?0b//;					# remove sign and 0b
  my $l = length($hs);					# bits
  $hs = '0' x (8-($l % 8)) . $hs if ($l % 8) != 0;	# padd left side w/ 0
  my $h = '0x' . unpack('H*', pack ('B*', $hs));	# repack as hex
  
  $c->_from_hex($h);
  }

##############################################################################
# special modulus functions

sub _modinv
  {
  # modular multiplicative inverse
  my ($c,$x,$y) = @_;

  # modulo zero
  if (_is_zero($c, $y)) {
      return (undef, undef);
  }

  # modulo one
  if (_is_one($c, $y)) {
      return (_zero($c), '+');
  }

  my $u = _zero($c);
  my $v = _one($c);
  my $a = _copy($c,$y);
  my $b = _copy($c,$x);

  # Euclid's Algorithm for bgcd(), only that we calc bgcd() ($a) and the result
  # ($u) at the same time. See comments in BigInt for why this works.
  my $q;
  my $sign = 1;
  {
      ($a, $q, $b) = ($b, _div($c, $a, $b));        # step 1
      last if _is_zero($c, $b);

      my $t = _add($c,                              # step 2:
                   _mul($c, _copy($c, $v), $q) ,    #  t =   v * q
                   $u );                            #      + u
      $u = $v;                                      #  u = v
      $v = $t;                                      #  v = t
      $sign = -$sign;
      redo;
  }

  # if the gcd is not 1, then return NaN
  return (undef, undef) unless _is_one($c, $a);

  ($v, $sign == 1 ? '+' : '-');
  }

sub _modpow
  {
  # modulus of power ($x ** $y) % $z
  my ($c,$num,$exp,$mod) = @_;

  # a^b (mod 1) = 0 for all a and b
  if (_is_one($c,$mod))
    {
        @$num = 0;
        return $num;
    }

  # 0^a (mod m) = 0 if m != 0, a != 0
  # 0^0 (mod m) = 1 if m != 0
  if (_is_zero($c, $num)) {
      if (_is_zero($c, $exp)) {
          @$num = 1;
      } else {
          @$num = 0;
      }
      return $num;
  }

#  $num = _mod($c,$num,$mod);	# this does not make it faster

  my $acc = _copy($c,$num); my $t = _one();

  my $expbin = _as_bin($c,$exp); $expbin =~ s/^0b//;
  my $len = length($expbin);
  while (--$len >= 0)
    {
    if ( substr($expbin,$len,1) eq '1')			# is_odd
      {
      _mul($c,$t,$acc);
      $t = _mod($c,$t,$mod);
      }
    _mul($c,$acc,$acc);
    $acc = _mod($c,$acc,$mod);
    }
  @$num = @$t;
  $num;
  }

sub _gcd {
    # Greatest common divisor.

    my ($c, $x, $y) = @_;

    # gcd(0,0) = 0
    # gcd(0,a) = a, if a != 0

    if (@$x == 1 && $x->[0] == 0) {
        if (@$y == 1 && $y->[0] == 0) {
            @$x = 0;
        } else {
            @$x = @$y;
        }
        return $x;
    }

    # Until $y is zero ...

    until (@$y == 1 && $y->[0] == 0) {

        # Compute remainder.

        _mod($c, $x, $y);

        # Swap $x and $y.

        my $tmp = [ @$x ];
        @$x = @$y;
        $y = $tmp;      # no deref here; that would modify input $y
    }

    return $x;
}

##############################################################################
##############################################################################

1;
__END__

=pod

=head1 NAME

Math::BigInt::Calc - Pure Perl module to support Math::BigInt

=head1 SYNOPSIS

This library provides support for big integer calculations. It is not
intended to be used by other modules. Other modules which support the same
API (see below) can also be used to support Math::BigInt, like
Math::BigInt::GMP and Math::BigInt::Pari.

=head1 DESCRIPTION

In this library, the numbers are represented in base B = 10**N, where N is
the largest possible value that does not cause overflow in the intermediate
computations. The base B elements are stored in an array, with the least
significant element stored in array element zero. There are no leading zero
elements, except a single zero element when the number is zero.

For instance, if B = 10000, the number 1234567890 is represented internally
as [3456, 7890, 12].

=head1 THE Math::BigInt API

In order to allow for multiple big integer libraries, Math::BigInt was
rewritten to use a plug-in library for core math routines. Any module which
conforms to the API can be used by Math::BigInt by using this in your program:

	use Math::BigInt lib => 'libname';

'libname' is either the long name, like 'Math::BigInt::Pari', or only the short
version, like 'Pari'.

=head2 General Notes

A library only needs to deal with unsigned big integers. Testing of input
parameter validity is done by the caller, so there is no need to worry about
underflow (e.g., in C<_sub()> and C<_dec()>) nor about division by zero (e.g.,
in C<_div()>) or similar cases.

For some methods, the first parameter can be modified. That includes the
possibility that you return a reference to a completely different object
instead. Although keeping the reference and just changing its contents is
preferred over creating and returning a different reference.

Return values are always objects, strings, Perl scalars, or true/false for
comparison routines.

=head2 API version 1

The following methods must be defined in order to support the use by
Math::BigInt v1.70 or later.

=head3 API version

=over 4

=item I<api_version()>

Return API version as a Perl scalar, 1 for Math::BigInt v1.70, 2 for
Math::BigInt v1.83.

=back

=head3 Constructors

=over 4

=item I<_new(STR)>

Convert a string representing an unsigned decimal number to an object
representing the same number. The input is normalize, i.e., it matches
C<^(0|[1-9]\d*)$>.

=item I<_zero()>

Return an object representing the number zero.

=item I<_one()>

Return an object representing the number one.

=item I<_two()>

Return an object representing the number two.

=item I<_ten()>

Return an object representing the number ten.

=item I<_from_bin(STR)>

Return an object given a string representing a binary number. The input has a
'0b' prefix and matches the regular expression C<^0[bB](0|1[01]*)$>.

=item I<_from_oct(STR)>

Return an object given a string representing an octal number. The input has a
'0' prefix and matches the regular expression C<^0[1-7]*$>.

=item I<_from_hex(STR)>

Return an object given a string representing a hexadecimal number. The input
has a '0x' prefix and matches the regular expression
C<^0x(0|[1-9a-fA-F][\da-fA-F]*)$>.

=back

=head3 Mathematical functions

Each of these methods may modify the first input argument, except I<_bgcd()>,
which shall not modify any input argument, and I<_sub()> which may modify the
second input argument.

=over 4

=item I<_add(OBJ1, OBJ2)>

Returns the result of adding OBJ2 to OBJ1.

=item I<_mul(OBJ1, OBJ2)>

Returns the result of multiplying OBJ2 and OBJ1.

=item I<_div(OBJ1, OBJ2)>

Returns the result of dividing OBJ1 by OBJ2 and truncating the result to an
integer.

=item I<_sub(OBJ1, OBJ2, FLAG)>

=item I<_sub(OBJ1, OBJ2)>

Returns the result of subtracting OBJ2 by OBJ1. If C<flag> is false or omitted,
OBJ1 might be modified. If C<flag> is true, OBJ2 might be modified.

=item I<_dec(OBJ)>

Decrement OBJ by one.

=item I<_inc(OBJ)>

Increment OBJ by one.

=item I<_mod(OBJ1, OBJ2)>

Return OBJ1 modulo OBJ2, i.e., the remainder after dividing OBJ1 by OBJ2.

=item I<_sqrt(OBJ)>

Return the square root of the object, truncated to integer.

=item I<_root(OBJ, N)>

Return Nth root of the object, truncated to int. N is E<gt>= 3.

=item I<_fac(OBJ)>

Return factorial of object (1*2*3*4*...).

=item I<_pow(OBJ1, OBJ2)>

Return OBJ1 to the power of OBJ2. By convention, 0**0 = 1.

=item I<_modinv(OBJ1, OBJ2)>

Return modular multiplicative inverse, i.e., return OBJ3 so that

    (OBJ3 * OBJ1) % OBJ2 = 1 % OBJ2

The result is returned as two arguments. If the modular multiplicative
inverse does not exist, both arguments are undefined. Otherwise, the
arguments are a number (object) and its sign ("+" or "-").

The output value, with its sign, must either be a positive value in the
range 1,2,...,OBJ2-1 or the same value subtracted OBJ2. For instance, if the
input arguments are objects representing the numbers 7 and 5, the method
must either return an object representing the number 3 and a "+" sign, since
(3*7) % 5 = 1 % 5, or an object representing the number 2 and "-" sign,
since (-2*7) % 5 = 1 % 5.

=item I<_modpow(OBJ1, OBJ2, OBJ3)>

Return modular exponentiation, (OBJ1 ** OBJ2) % OBJ3.

=item I<_rsft(OBJ, N, B)>

Shift object N digits right in base B and return the resulting object. This is
equivalent to performing integer division by B**N and discarding the remainder,
except that it might be much faster, depending on how the number is represented
internally.

For instance, if the object $obj represents the hexadecimal number 0xabcde,
then C<_rsft($obj, 2, 16)> returns an object representing the number 0xabc. The
"remainer", 0xde, is discarded and not returned.

=item I<_lsft(OBJ, N, B)>

Shift the object N digits left in base B. This is equivalent to multiplying by
B**N, except that it might be much faster, depending on how the number is
represented internally.

=item I<_log_int(OBJ, B)>

Return integer log of OBJ to base BASE. This method has two output arguments,
the OBJECT and a STATUS. The STATUS is Perl scalar; it is 1 if OBJ is the exact
result, 0 if the result was truncted to give OBJ, and undef if it is unknown
whether OBJ is the exact result.

=item I<_gcd(OBJ1, OBJ2)>

Return the greatest common divisor of OBJ1 and OBJ2.

=back

=head3 Bitwise operators

Each of these methods may modify the first input argument.

=over 4

=item I<_and(OBJ1, OBJ2)>

Return bitwise and. If necessary, the smallest number is padded with leading
zeros.

=item I<_or(OBJ1, OBJ2)>

Return bitwise or. If necessary, the smallest number is padded with leading
zeros.

=item I<_xor(OBJ1, OBJ2)>

Return bitwise exclusive or. If necessary, the smallest number is padded
with leading zeros.

=back

=head3 Boolean operators

=over 4

=item I<_is_zero(OBJ)>

Returns a true value if OBJ is zero, and false value otherwise.

=item I<_is_one(OBJ)>

Returns a true value if OBJ is one, and false value otherwise.

=item I<_is_two(OBJ)>

Returns a true value if OBJ is two, and false value otherwise.

=item I<_is_ten(OBJ)>

Returns a true value if OBJ is ten, and false value otherwise.

=item I<_is_even(OBJ)>

Return a true value if OBJ is an even integer, and a false value otherwise.

=item I<_is_odd(OBJ)>

Return a true value if OBJ is an even integer, and a false value otherwise.

=item I<_acmp(OBJ1, OBJ2)>

Compare OBJ1 and OBJ2 and return -1, 0, or 1, if OBJ1 is less than, equal
to, or larger than OBJ2, respectively.

=back

=head3 String conversion

=over 4

=item I<_str(OBJ)>

Return a string representing the object. The returned string should have no
leading zeros, i.e., it should match C<^(0|[1-9]\d*)$>.

=item I<_as_bin(OBJ)>

Return the binary string representation of the number. The string must have a
'0b' prefix.

=item I<_as_oct(OBJ)>

Return the octal string representation of the number. The string must have
a '0x' prefix.

Note: This method was required from Math::BigInt version 1.78, but the required
API version number was not incremented, so there are older libraries that
support API version 1, but do not support C<_as_oct()>.

=item I<_as_hex(OBJ)>

Return the hexadecimal string representation of the number. The string must
have a '0x' prefix.

=back

=head3 Numeric conversion

=over 4

=item I<_num(OBJ)>

Given an object, return a Perl scalar number (int/float) representing this
number.

=back

=head3 Miscellaneous

=over 4

=item I<_copy(OBJ)>

Return a true copy of the object.

=item I<_len(OBJ)>

Returns the number of the decimal digits in the number. The output is a
Perl scalar.

=item I<_zeros(OBJ)>

Return the number of trailing decimal zeros. The output is a Perl scalar.

=item I<_digit(OBJ, N)>

Return the Nth digit as a Perl scalar. N is a Perl scalar, where zero refers to
the rightmost (least significant) digit, and negative values count from the
left (most significant digit). If $obj represents the number 123, then
I<_digit($obj, 0)> is 3 and I<_digit(123, -1)> is 1.

=item I<_check(OBJ)>

Return a true value if the object is OK, and a false value otherwise. This is a
check routine to test the internal state of the object for corruption.

=back

=head2 API version 2

The following methods are required for an API version of 2 or greater.

=head3 Constructors

=over 4

=item I<_1ex(N)>

Return an object representing the number 10**N where N E<gt>= 0 is a Perl
scalar.

=back

=head3 Mathematical functions

=over 4

=item I<_nok(OBJ1, OBJ2)>

Return the binomial coefficient OBJ1 over OBJ1.

=back

=head3 Miscellaneous

=over 4

=item I<_alen(OBJ)>

Return the approximate number of decimal digits of the object. The
output is one Perl scalar. This estimate must be greater than or equal
to what C<_len()> returns.

=back

=head2 API optional methods

The following methods are optional, and can be defined if the underlying lib
has a fast way to do them. If undefined, Math::BigInt will use pure Perl (hence
slow) fallback routines to emulate these:

=head3 Signed bitwise operators.

Each of these methods may modify the first input argument.

=over 4

=item I<_signed_or(OBJ1, OBJ2, SIGN1, SIGN2)>

Return the signed bitwise or.

=item I<_signed_and(OBJ1, OBJ2, SIGN1, SIGN2)>

Return the signed bitwise and.

=item I<_signed_xor(OBJ1, OBJ2, SIGN1, SIGN2)>

Return the signed bitwise exclusive or.

=back

=head1 WRAP YOUR OWN

If you want to port your own favourite c-lib for big numbers to the
Math::BigInt interface, you can take any of the already existing modules as
a rough guideline. You should really wrap up the latest BigInt and BigFloat
testsuites with your module, and replace in them any of the following:

	use Math::BigInt;

by this:

	use Math::BigInt lib => 'yourlib';

This way you ensure that your library really works 100% within Math::BigInt.

=head1 BUGS

Please report any bugs or feature requests to
C<bug-math-bigint at rt.cpan.org>, or through the web interface at
L<https://rt.cpan.org/Ticket/Create.html?Queue=Math-BigInt>
(requires login).
We will be notified, and then you'll automatically be notified of progress on
your bug as I make changes.

=head1 SUPPORT

You can find documentation for this module with the perldoc command.

    perldoc Math::BigInt::Calc

You can also look for information at:

=over 4

=item * RT: CPAN's request tracker

L<https://rt.cpan.org/Public/Dist/Display.html?Name=Math-BigInt>

=item * AnnoCPAN: Annotated CPAN documentation

L<http://annocpan.org/dist/Math-BigInt>

=item * CPAN Ratings

L<http://cpanratings.perl.org/dist/Math-BigInt>

=item * Search CPAN

L<http://search.cpan.org/dist/Math-BigInt/>

=item * CPAN Testers Matrix

L<http://matrix.cpantesters.org/?dist=Math-BigInt>

=item * The Bignum mailing list

=over 4

=item * Post to mailing list

C<bignum at lists.scsys.co.uk>

=item * View mailing list

L<http://lists.scsys.co.uk/pipermail/bignum/>

=item * Subscribe/Unsubscribe

L<http://lists.scsys.co.uk/cgi-bin/mailman/listinfo/bignum>

=back

=back

=head1 LICENSE

This program is free software; you may redistribute it and/or modify it under
the same terms as Perl itself. 

=head1 AUTHORS

=over 4

=item *

Original math code by Mark Biggar, rewritten by Tels L<http://bloodgate.com/>
in late 2000.

=item *

Separated from BigInt and shaped API with the help of John Peacock.

=item *

Fixed, speed-up, streamlined and enhanced by Tels 2001 - 2007.

=item *

API documentation corrected and extended by Peter John Acklam,
E<lt>pjacklam@online.noE<gt>

=back

=head1 SEE ALSO

L<Math::BigInt>, L<Math::BigFloat>,
L<Math::BigInt::GMP>, L<Math::BigInt::FastCalc> and L<Math::BigInt::Pari>.

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         package Math::BigInt::CalcEmu;

use 5.006001;
use strict;
use warnings;

our $VERSION = '1.999715';
$VERSION = eval $VERSION;

package Math::BigInt;

# See SYNOPSIS below.

my $CALC_EMU;

BEGIN
  {
  $CALC_EMU = Math::BigInt->config()->{'lib'};
  # register us with MBI to get notified of future lib changes
  Math::BigInt::_register_callback( __PACKAGE__, sub { $CALC_EMU = $_[0]; } );
  }

sub __emu_band
  {
  my ($self,$x,$y,$sx,$sy,@r) = @_;

  return $x->bzero(@r) if $y->is_zero() || $x->is_zero();
  
  my $sign = 0;					# sign of result
  $sign = 1 if $sx == -1 && $sy == -1;

  my ($bx,$by);

  if ($sx == -1)				# if x is negative
    {
    # two's complement: inc and flip all "bits" in $bx
    $bx = $x->binc()->as_hex();			# -1 => 0, -2 => 1, -3 => 2 etc
    $bx =~ s/-?0x//;
    $bx =~ tr/0123456789abcdef/\x0f\x0e\x0d\x0c\x0b\x0a\x09\x08\x07\x06\x05\x04\x03\x02\x01\x00/;
    }
  else
    {
    $bx = $x->as_hex();				# get binary representation
    $bx =~ s/-?0x//;
    $bx =~ tr/fedcba9876543210/\x0f\x0e\x0d\x0c\x0b\x0a\x09\x08\x07\x06\x05\x04\x03\x02\x01\x00/;
    }
  if ($sy == -1)				# if y is negative
    {
    # two's complement: inc and flip all "bits" in $by
    $by = $y->copy()->binc()->as_hex();		# -1 => 0, -2 => 1, -3 => 2 etc
    $by =~ s/-?0x//;
    $by =~ tr/0123456789abcdef/\x0f\x0e\x0d\x0c\x0b\x0a\x09\x08\x07\x06\x05\x04\x03\x02\x01\x00/;
    }
  else
    {
    $by = $y->as_hex();				# get binary representation
    $by =~ s/-?0x//;
    $by =~ tr/fedcba9876543210/\x0f\x0e\x0d\x0c\x0b\x0a\x09\x08\x07\x06\x05\x04\x03\x02\x01\x00/;
    }
  # now we have bit-strings from X and Y, reverse them for padding
  $bx = reverse $bx;
  $by = reverse $by;

  # padd the shorter string
  my $xx = "\x00"; $xx = "\x0f" if $sx == -1;
  my $yy = "\x00"; $yy = "\x0f" if $sy == -1;
  my $diff = CORE::length($bx) - CORE::length($by);
  if ($diff > 0)
    {
    # if $yy eq "\x00", we can cut $bx, otherwise we need to padd $by
    $by .= $yy x $diff;
    }
  elsif ($diff < 0)
    {
    # if $xx eq "\x00", we can cut $by, otherwise we need to padd $bx
    $bx .= $xx x abs($diff);
    }
  
  # and the strings together
  my $r = $bx & $by;

  # and reverse the result again
  $bx = reverse $r;

  # One of $x or $y was negative, so need to flip bits in the result.
  # In both cases (one or two of them negative, or both positive) we need
  # to get the characters back.
  if ($sign == 1)
    {
    $bx =~ tr/\x0f\x0e\x0d\x0c\x0b\x0a\x09\x08\x07\x06\x05\x04\x03\x02\x01\x00/0123456789abcdef/;
    }
  else
    {
    $bx =~ tr/\x0f\x0e\x0d\x0c\x0b\x0a\x09\x08\x07\x06\x05\x04\x03\x02\x01\x00/fedcba9876543210/;
    }

  # leading zeros will be stripped by _from_hex()
  $bx = '0x' . $bx;
  $x->{value} = $CALC_EMU->_from_hex( $bx );

  # calculate sign of result
  $x->{sign} = '+';
  $x->{sign} = '-' if $sign == 1 && !$x->is_zero();

  $x->bdec() if $sign == 1;

  $x->round(@r);
  }

sub __emu_bior
  {
  my ($self,$x,$y,$sx,$sy,@r) = @_;

  return $x->round(@r) if $y->is_zero();

  my $sign = 0;					# sign of result
  $sign = 1 if ($sx == -1) || ($sy == -1);

  my ($bx,$by);

  if ($sx == -1)				# if x is negative
    {
    # two's complement: inc and flip all "bits" in $bx
    $bx = $x->binc()->as_hex();			# -1 => 0, -2 => 1, -3 => 2 etc
    $bx =~ s/-?0x//;
    $bx =~ tr/0123456789abcdef/\x0f\x0e\x0d\x0c\x0b\x0a\x09\x08\x07\x06\x05\x04\x03\x02\x01\x00/;
    }
  else
    {
    $bx = $x->as_hex();				# get binary representation
    $bx =~ s/-?0x//;
    $bx =~ tr/fedcba9876543210/\x0f\x0e\x0d\x0c\x0b\x0a\x09\x08\x07\x06\x05\x04\x03\x02\x01\x00/;
    }
  if ($sy == -1)				# if y is negative
    {
    # two's complement: inc and flip all "bits" in $by
    $by = $y->copy()->binc()->as_hex();		# -1 => 0, -2 => 1, -3 => 2 etc
    $by =~ s/-?0x//;
    $by =~ tr/0123456789abcdef/\x0f\x0e\x0d\x0c\x0b\x0a\x09\x08\x07\x06\x05\x04\x03\x02\x01\x00/;
    }
  else
    {
    $by = $y->as_hex();				# get binary representation
    $by =~ s/-?0x//;
    $by =~ tr/fedcba9876543210/\x0f\x0e\x0d\x0c\x0b\x0a\x09\x08\x07\x06\x05\x04\x03\x02\x01\x00/;
    }
  # now we have bit-strings from X and Y, reverse them for padding
  $bx = reverse $bx;
  $by = reverse $by;

  # padd the shorter string
  my $xx = "\x00"; $xx = "\x0f" if $sx == -1;
  my $yy = "\x00"; $yy = "\x0f" if $sy == -1;
  my $diff = CORE::length($bx) - CORE::length($by);
  if ($diff > 0)
    {
    $by .= $yy x $diff;
    }
  elsif ($diff < 0)
    {
    $bx .= $xx x abs($diff);
    }

  # or the strings together
  my $r = $bx | $by;

  # and reverse the result again
  $bx = reverse $r;

  # one of $x or $y was negative, so need to flip bits in the result
  # in both cases (one or two of them negative, or both positive) we need
  # to get the characters back.
  if ($sign == 1)
    {
    $bx =~ tr/\x0f\x0e\x0d\x0c\x0b\x0a\x09\x08\x07\x06\x05\x04\x03\x02\x01\x00/0123456789abcdef/;
    }
  else
    {
    $bx =~ tr/\x0f\x0e\x0d\x0c\x0b\x0a\x09\x08\x07\x06\x05\x04\x03\x02\x01\x00/fedcba9876543210/;
    }

  # leading zeros will be stripped by _from_hex()
  $bx = '0x' . $bx;
  $x->{value} = $CALC_EMU->_from_hex( $bx );

  # calculate sign of result
  $x->{sign} = '+';
  $x->{sign} = '-' if $sign == 1 && !$x->is_zero();

  # if one of X or Y was negative, we need to decrement result
  $x->bdec() if $sign == 1;

  $x->round(@r);
  }

sub __emu_bxor
  {
  my ($self,$x,$y,$sx,$sy,@r) = @_;

  return $x->round(@r) if $y->is_zero();

  my $sign = 0;					# sign of result
  $sign = 1 if $x->{sign} ne $y->{sign};

  my ($bx,$by);

  if ($sx == -1)				# if x is negative
    {
    # two's complement: inc and flip all "bits" in $bx
    $bx = $x->binc()->as_hex();			# -1 => 0, -2 => 1, -3 => 2 etc
    $bx =~ s/-?0x//;
    $bx =~ tr/0123456789abcdef/\x0f\x0e\x0d\x0c\x0b\x0a\x09\x08\x07\x06\x05\x04\x03\x02\x01\x00/;
    }
  else
    {
    $bx = $x->as_hex();				# get binary representation
    $bx =~ s/-?0x//;
    $bx =~ tr/fedcba9876543210/\x0f\x0e\x0d\x0c\x0b\x0a\x09\x08\x07\x06\x05\x04\x03\x02\x01\x00/;
    }
  if ($sy == -1)				# if y is negative
    {
    # two's complement: inc and flip all "bits" in $by
    $by = $y->copy()->binc()->as_hex();		# -1 => 0, -2 => 1, -3 => 2 etc
    $by =~ s/-?0x//;
    $by =~ tr/0123456789abcdef/\x0f\x0e\x0d\x0c\x0b\x0a\x09\x08\x07\x06\x05\x04\x03\x02\x01\x00/;
    }
  else
    {
    $by = $y->as_hex();				# get binary representation
    $by =~ s/-?0x//;
    $by =~ tr/fedcba9876543210/\x0f\x0e\x0d\x0c\x0b\x0a\x09\x08\x07\x06\x05\x04\x03\x02\x01\x00/;
    }
  # now we have bit-strings from X and Y, reverse them for padding
  $bx = reverse $bx;
  $by = reverse $by;

  # padd the shorter string
  my $xx = "\x00"; $xx = "\x0f" if $sx == -1;
  my $yy = "\x00"; $yy = "\x0f" if $sy == -1;
  my $diff = CORE::length($bx) - CORE::length($by);
  if ($diff > 0)
    {
    $by .= $yy x $diff;
    }
  elsif ($diff < 0)
    {
    $bx .= $xx x abs($diff);
    }

  # xor the strings together
  my $r = $bx ^ $by;

  # and reverse the result again
  $bx = reverse $r;

  # one of $x or $y was negative, so need to flip bits in the result
  # in both cases (one or two of them negative, or both positive) we need
  # to get the characters back.
  if ($sign == 1)
    {
    $bx =~ tr/\x0f\x0e\x0d\x0c\x0b\x0a\x09\x08\x07\x06\x05\x04\x03\x02\x01\x00/0123456789abcdef/;
    }
  else
    {
    $bx =~ tr/\x0f\x0e\x0d\x0c\x0b\x0a\x09\x08\x07\x06\x05\x04\x03\x02\x01\x00/fedcba9876543210/;
    }

  # leading zeros will be stripped by _from_hex()
  $bx = '0x' . $bx;
  $x->{value} = $CALC_EMU->_from_hex( $bx );

  # calculate sign of result
  $x->{sign} = '+';
  $x->{sign} = '-' if $sx != $sy && !$x->is_zero();

  $x->bdec() if $sign == 1;

  $x->round(@r);
  }

##############################################################################
##############################################################################

1;

__END__

=pod

=head1 NAME

Math::BigInt::CalcEmu - Emulate low-level math with BigInt code

=head1 SYNOPSIS

	use Math::BigInt::CalcEmu;

=head1 DESCRIPTION

Contains routines that emulate low-level math functions in BigInt, e.g.
optional routines the low-level math package does not provide on its own.

Will be loaded on demand and called automatically by BigInt.

Stuff here is really low-priority to optimize, since it is far better to
implement the operation in the low-level math library directly, possible even
using a call to the native lib.

=head1 METHODS

=over

=item __emu_bxor

=item __emu_band

=item __emu_bior

=back

=head1 BUGS

Please report any bugs or feature requests to
C<bug-math-bigint at rt.cpan.org>, or through the web interface at
L<https://rt.cpan.org/Ticket/Create.html?Queue=Math-BigInt>
(requires login).
We will be notified, and then you'll automatically be notified of progress on
your bug as I make changes.

=head1 SUPPORT

You can find documentation for this module with the perldoc command.

    perldoc Math::BigInt::CalcEmu

You can also look for information at:

=over 4

=item * RT: CPAN's request tracker

L<https://rt.cpan.org/Public/Dist/Display.html?Name=Math-BigInt>

=item * AnnoCPAN: Annotated CPAN documentation

L<http://annocpan.org/dist/Math-BigInt>

=item * CPAN Ratings

L<http://cpanratings.perl.org/dist/Math-BigInt>

=item * Search CPAN

L<http://search.cpan.org/dist/Math-BigInt/>

=item * CPAN Testers Matrix

L<http://matrix.cpantesters.org/?dist=Math-BigInt>

=item * The Bignum mailing list

=over 4

=item * Post to mailing list

C<bignum at lists.scsys.co.uk>

=item * View mailing list

L<http://lists.scsys.co.uk/pipermail/bignum/>

=item * Subscribe/Unsubscribe

L<http://lists.scsys.co.uk/cgi-bin/mailman/listinfo/bignum>

=back

=back

=head1 LICENSE

This program is free software; you may redistribute it and/or modify it under
the same terms as Perl itself. 

=head1 AUTHORS

(c) Tels http://bloodgate.com 2003, 2004 - based on BigInt code by
Tels from 2001-2003.

=head1 SEE ALSO

L<Math::BigInt>, L<Math::BigFloat>,
L<Math::BigInt::GMP> and L<Math::BigInt::Pari>.

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      #!perl

package Math::BigInt::Trace;

require 5.006;
use strict;
use warnings;

use Exporter;
use Math::BigInt;

our ($PACKAGE, @EXPORT_OK, $accuracy, $precision, $round_mode, $div_scale);

our @ISA = qw(Exporter Math::BigInt);

our $VERSION = '0.42_01';

use overload;                   # inherit overload from BigInt

# Globals
$accuracy = $precision = undef;
$round_mode = 'even';
$div_scale = 40;

sub new {
    my $proto = shift;
    my $class = ref($proto) || $proto;

    my $value = shift;
    my $a = $accuracy;
    $a = $_[0] if defined $_[0];
    my $p = $precision;
    $p = $_[1] if defined $_[1];
    my $self = Math::BigInt->new($value, $a, $p, $round_mode);
    bless $self, $class;
    print "MBI new '$value' => '$self' (", ref($self), ")";
    return $self;
}

sub import {
    print "MBI import ", join(' ', @_);
    my $self = shift;
    Math::BigInt::import($self, @_);            # need it for subclasses
#    $self->export_to_level(1, $self, @_);       # need this ?
    @_ = ();
}

1;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
package Memoize::Expire;
# require 5.00556;
use Carp;
$DEBUG = 0;
$VERSION = '1.03';

# This package will implement expiration by prepending a fixed-length header
# to the font of the cached data.  The format of the header will be:
# (4-byte number of last-access-time)  (For LRU when I implement it)
# (4-byte expiration time: unsigned seconds-since-unix-epoch)
# (2-byte number-of-uses-before-expire)

sub _header_fmt () { "N N n" }
sub _header_size () { length(_header_fmt) }

# Usage:  memoize func 
#         TIE => [Memoize::Expire, LIFETIME => sec, NUM_USES => n,
#                 TIE => [...] ]

BEGIN {
  eval {require Time::HiRes};
  unless ($@) {
    Time::HiRes->import('time');
  }
}

sub TIEHASH {
  my ($package, %args) = @_;
  my %cache;
  if ($args{TIE}) {
    my ($module, @opts) = @{$args{TIE}};
    my $modulefile = $module . '.pm';
    $modulefile =~ s{::}{/}g;
    eval { require $modulefile };
    if ($@) {
      croak "Memoize::Expire: Couldn't load hash tie module `$module': $@; aborting";
    }
    my $rc = (tie %cache => $module, @opts);
    unless ($rc) {
      croak "Memoize::Expire: Couldn't tie hash to `$module': $@; aborting";
    }
  }
  $args{LIFETIME} ||= 0;
  $args{NUM_USES} ||= 0;
  $args{C} = \%cache;
  bless \%args => $package;
}

sub STORE {
  $DEBUG and print STDERR " >> Store $_[1] $_[2]\n";
  my ($self, $key, $value) = @_;
  my $expire_time = $self->{LIFETIME} > 0 ? $self->{LIFETIME} + time : 0;
  # The call that results in a value to store into the cache is the
  # first of the NUM_USES allowed calls.
  my $header = _make_header(time, $expire_time, $self->{NUM_USES}-1);
  $self->{C}{$key} = $header . $value;
  $value;
}

sub FETCH {
  $DEBUG and print STDERR " >> Fetch cached value for $_[1]\n";
  my ($data, $last_access, $expire_time, $num_uses_left) = _get_item($_[0]{C}{$_[1]});
  $DEBUG and print STDERR " >>   (ttl: ", ($expire_time-time()), ", nuses: $num_uses_left)\n";
  $num_uses_left--;
  $last_access = time;
  _set_header(@_, $data, $last_access, $expire_time, $num_uses_left);
  $data;
}

sub EXISTS {
  $DEBUG and print STDERR " >> Exists $_[1]\n";
  unless (exists $_[0]{C}{$_[1]}) {
    $DEBUG and print STDERR "    Not in underlying hash at all.\n";
    return 0;
  }
  my $item = $_[0]{C}{$_[1]};
  my ($last_access, $expire_time, $num_uses_left) = _get_header($item);
  my $ttl = $expire_time - time;
  if ($DEBUG) {
    $_[0]{LIFETIME} and print STDERR "    Time to live for this item: $ttl\n";
    $_[0]{NUM_USES} and print STDERR "    Uses remaining: $num_uses_left\n";
  }
  if (   (! $_[0]{LIFETIME} || $expire_time > time)
      && (! $_[0]{NUM_USES} || $num_uses_left > 0 )) {
	    $DEBUG and print STDERR "    (Still good)\n";
    return 1;
  } else {
    $DEBUG and print STDERR "    (Expired)\n";
    return 0;
  }
}

# Arguments: last access time, expire time, number of uses remaining
sub _make_header {
  pack "N N n", @_;
}

sub _strip_header {
  substr($_[0], 10);
}

# Arguments: last access time, expire time, number of uses remaining
sub _set_header {
  my ($self, $key, $data, @header) = @_;
  $self->{C}{$key} = _make_header(@header) . $data;
}

sub _get_item {
  my $data = substr($_[0], 10);
  my @header = unpack "N N n", substr($_[0], 0, 10);
#  print STDERR " >> _get_item: $data => $data @header\n";
  ($data, @header);
}

# Return last access time, expire time, number of uses remaining
sub _get_header  {
  unpack "N N n", substr($_[0], 0, 10);
}

1;

=head1 NAME 

Memoize::Expire - Plug-in module for automatic expiration of memoized values

=head1 SYNOPSIS

  use Memoize;
  use Memoize::Expire;
  tie my %cache => 'Memoize::Expire',
	  	     LIFETIME => $lifetime,    # In seconds
		     NUM_USES => $n_uses;

  memoize 'function', SCALAR_CACHE => [HASH => \%cache ];

=head1 DESCRIPTION

Memoize::Expire is a plug-in module for Memoize.  It allows the cached
values for memoized functions to expire automatically.  This manual
assumes you are already familiar with the Memoize module.  If not, you
should study that manual carefully first, paying particular attention
to the HASH feature.

Memoize::Expire is a layer of software that you can insert in between
Memoize itself and whatever underlying package implements the cache.
The layer presents a hash variable whose values expire whenever they
get too old, have been used too often, or both. You tell C<Memoize> to
use this forgetful hash as its cache instead of the default, which is
an ordinary hash.

To specify a real-time timeout, supply the C<LIFETIME> option with a
numeric value.  Cached data will expire after this many seconds, and
will be looked up afresh when it expires.  When a data item is looked
up afresh, its lifetime is reset.

If you specify C<NUM_USES> with an argument of I<n>, then each cached
data item will be discarded and looked up afresh after the I<n>th time
you access it.  When a data item is looked up afresh, its number of
uses is reset.

If you specify both arguments, data will be discarded from the cache
when either expiration condition holds.

Memoize::Expire uses a real hash internally to store the cached data.
You can use the C<HASH> option to Memoize::Expire to supply a tied
hash in place of the ordinary hash that Memoize::Expire will normally
use.  You can use this feature to add Memoize::Expire as a layer in
between a persistent disk hash and Memoize.  If you do this, you get a
persistent disk cache whose entries expire automatically.  For
example:

  #   Memoize
  #      |
  #   Memoize::Expire  enforces data expiration policy
  #      |
  #   DB_File  implements persistence of data in a disk file
  #      |
  #   Disk file

  use Memoize;
  use Memoize::Expire;
  use DB_File;

  # Set up persistence
  tie my %disk_cache => 'DB_File', $filename, O_CREAT|O_RDWR, 0666];

  # Set up expiration policy, supplying persistent hash as a target
  tie my %cache => 'Memoize::Expire', 
	  	     LIFETIME => $lifetime,    # In seconds
		     NUM_USES => $n_uses,
                     HASH => \%disk_cache; 

  # Set up memoization, supplying expiring persistent hash for cache
  memoize 'function', SCALAR_CACHE => [ HASH => \%cache ];

=head1 INTERFACE

There is nothing special about Memoize::Expire.  It is just an
example.  If you don't like the policy that it implements, you are
free to write your own expiration policy module that implements
whatever policy you desire.  Here is how to do that.  Let us suppose
that your module will be named MyExpirePolicy.

Short summary: You need to create a package that defines four methods:

=over 4

=item 
TIEHASH

Construct and return cache object.

=item 
EXISTS

Given a function argument, is the corresponding function value in the
cache, and if so, is it fresh enough to use?

=item
FETCH

Given a function argument, look up the corresponding function value in
the cache and return it.

=item 
STORE

Given a function argument and the corresponding function value, store
them into the cache.

=item
CLEAR

(Optional.)  Flush the cache completely.

=back

The user who wants the memoization cache to be expired according to
your policy will say so by writing

  tie my %cache => 'MyExpirePolicy', args...;
  memoize 'function', SCALAR_CACHE => [HASH => \%cache];

This will invoke C<< MyExpirePolicy->TIEHASH(args) >>.
MyExpirePolicy::TIEHASH should do whatever is appropriate to set up
the cache, and it should return the cache object to the caller.

For example, MyExpirePolicy::TIEHASH might create an object that
contains a regular Perl hash (which it will to store the cached
values) and some extra information about the arguments and how old the
data is and things like that.  Let us call this object `C'.

When Memoize needs to check to see if an entry is in the cache
already, it will invoke C<< C->EXISTS(key) >>.  C<key> is the normalized
function argument.  MyExpirePolicy::EXISTS should return 0 if the key
is not in the cache, or if it has expired, and 1 if an unexpired value
is in the cache.  It should I<not> return C<undef>, because there is a
bug in some versions of Perl that will cause a spurious FETCH if the
EXISTS method returns C<undef>.

If your EXISTS function returns true, Memoize will try to fetch the
cached value by invoking C<< C->FETCH(key) >>.  MyExpirePolicy::FETCH should
return the cached value.  Otherwise, Memoize will call the memoized
function to compute the appropriate value, and will store it into the
cache by calling C<< C->STORE(key, value) >>.

Here is a very brief example of a policy module that expires each
cache item after ten seconds.

	package Memoize::TenSecondExpire;

	sub TIEHASH {
	  my ($package, %args) = @_;
          my $cache = $args{HASH} || {};
	  bless $cache => $package;
	}

	sub EXISTS {
	  my ($cache, $key) = @_;
	  if (exists $cache->{$key} && 
              $cache->{$key}{EXPIRE_TIME} > time) {
	    return 1
	  } else {
	    return 0;  # Do NOT return `undef' here.
	  }
	}

	sub FETCH {
	  my ($cache, $key) = @_;
	  return $cache->{$key}{VALUE};
	}

	sub STORE {
	  my ($cache, $key, $newvalue) = @_;
	  $cache->{$key}{VALUE} = $newvalue;
	  $cache->{$key}{EXPIRE_TIME} = time + 10;
	}

To use this expiration policy, the user would say

	use Memoize;
        tie my %cache10sec => 'Memoize::TenSecondExpire';
	memoize 'function', SCALAR_CACHE => [HASH => \%cache10sec];

Memoize would then call C<function> whenever a cached value was
entirely absent or was older than ten seconds.

You should always support a C<HASH> argument to C<TIEHASH> that ties
the underlying cache so that the user can specify that the cache is
also persistent or that it has some other interesting semantics.  The
example above demonstrates how to do this, as does C<Memoize::Expire>.

Another sample module, L<Memoize::Saves>, is available in a separate
distribution on CPAN.  It implements a policy that allows you to
specify that certain function values would always be looked up afresh.
See the documentation for details.

=head1 ALTERNATIVES

Brent Powers has a C<Memoize::ExpireLRU> module that was designed to
work with Memoize and provides expiration of least-recently-used data.
The cache is held at a fixed number of entries, and when new data
comes in, the least-recently used data is expired.  See
L<http://search.cpan.org/search?mode=module&query=ExpireLRU>.

Joshua Chamas's Tie::Cache module may be useful as an expiration
manager.  (If you try this, let me know how it works out.)

If you develop any useful expiration managers that you think should be
distributed with Memoize, please let me know.

=head1 CAVEATS

This module is experimental, and may contain bugs.  Please report bugs
to the address below.

Number-of-uses is stored as a 16-bit unsigned integer, so can't exceed
65535.

Because of clock granularity, expiration times may occur up to one
second sooner than you expect.  For example, suppose you store a value
with a lifetime of ten seconds, and you store it at 12:00:00.998 on a
certain day.  Memoize will look at the clock and see 12:00:00.  Then
9.01 seconds later, at 12:00:10.008 you try to read it back.  Memoize
will look at the clock and see 12:00:10 and conclude that the value
has expired.  This will probably not occur if you have
C<Time::HiRes> installed.

=head1 AUTHOR

Mark-Jason Dominus (mjd-perl-memoize+@plover.com)

Mike Cariaso provided valuable insight into the best way to solve this
problem.

=head1 SEE ALSO

perl(1)

The Memoize man page.

http://www.plover.com/~mjd/perl/Memoize/  (for news and updates)

I maintain a mailing list on which I occasionally announce new
versions of Memoize.  The list is for announcements only, not
discussion.  To join, send an empty message to
mjd-perl-memoize-request@Plover.com.

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        package Memoize::ExpireTest;

=head1 NAME

Memoize::ExpireTest - test for Memoize expiration semantics

=head1 DESCRIPTION

This module is just for testing expiration semantics.  It's not a very
good example of how to write an expiration module.

If you are looking for an example, I recommend that you look at the
simple example in the Memoize::Expire documentation, or at the code
for Memoize::Expire itself.

If you have questions, I will be happy to answer them if you send them
to mjd-perl-memoize+@plover.com.

=cut

$VERSION = '1.03';
my %cache;

sub TIEHASH {	
  my ($pack) = @_;
  bless \%cache => $pack;
}

sub EXISTS {
  my ($cache, $key) = @_;
  exists $cache->{$key} ? 1 : 0;
}

sub FETCH {
  my ($cache, $key) = @_;
  $cache->{$key};
}

sub STORE {
  my ($cache, $key, $val) = @_;
  $cache->{$key} = $val;
}

sub expire {
  my ($key) = @_;
  delete $cache{$key};
}

1;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             package Memoize::NDBM_File;

=head1 NAME

Memoize::NDBM_File - glue to provide EXISTS for NDBM_File for Storable use

=head1 DESCRIPTION

See L<Memoize>.

=cut

use NDBM_File;
@ISA = qw(NDBM_File);
$VERSION = '1.03';

$Verbose = 0;

sub AUTOLOAD {
  warn "Nonexistent function $AUTOLOAD invoked in Memoize::NDBM_File\n";
}

sub import {
  warn "Importing Memoize::NDBM_File\n" if $Verbose;
}


my %keylist;

# This is so ridiculous...
sub _backhash {
  my $self = shift;
  my %fakehash;
  my $k; 
  for ($k = $self->FIRSTKEY(); defined $k; $k = $self->NEXTKEY($k)) {
    $fakehash{$k} = undef;
  }
  $keylist{$self} = \%fakehash;
}

sub EXISTS {
  warn "Memoize::NDBM_File EXISTS (@_)\n" if $Verbose;
  my $self = shift;
  _backhash($self)  unless exists $keylist{$self};
  my $r = exists $keylist{$self}{$_[0]};
  warn "Memoize::NDBM_File EXISTS (@_) ==> $r\n" if $Verbose;
  $r;
}

sub DEFINED {
  warn "Memoize::NDBM_File DEFINED (@_)\n" if $Verbose;
  my $self = shift;
  _backhash($self)  unless exists $keylist{$self};
  defined $keylist{$self}{$_[0]};
}

sub DESTROY {
  warn "Memoize::NDBM_File DESTROY (@_)\n" if $Verbose;
  my $self = shift;
  delete $keylist{$self};   # So much for reference counting...
  $self->SUPER::DESTROY(@_);
}

# Maybe establish the keylist at TIEHASH time instead?

sub STORE {
  warn "Memoize::NDBM_File STORE (@_)\n" if $VERBOSE;
  my $self = shift;
  $keylist{$self}{$_[0]} = undef;
  $self->SUPER::STORE(@_);
}



# Inherit FETCH and TIEHASH

1;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                package Memoize::SDBM_File;

=head1 NAME

Memoize::SDBM_File - glue to provide EXISTS for SDBM_File for Storable use

=head1 DESCRIPTION

See L<Memoize>.

=cut

use SDBM_File;
@ISA = qw(SDBM_File);
$VERSION = '1.03';

$Verbose = 0;

sub AUTOLOAD {
  warn "Nonexistent function $AUTOLOAD invoked in Memoize::SDBM_File\n";
}

sub import {
  warn "Importing Memoize::SDBM_File\n" if $Verbose;
}


my %keylist;

# This is so ridiculous...
sub _backhash {
  my $self = shift;
  my %fakehash;
  my $k; 
  for ($k = $self->FIRSTKEY(); defined $k; $k = $self->NEXTKEY($k)) {
    $fakehash{$k} = undef;
  }
  $keylist{$self} = \%fakehash;
}

sub EXISTS {
  warn "Memoize::SDBM_File EXISTS (@_)\n" if $Verbose;
  my $self = shift;
  _backhash($self)  unless exists $keylist{$self};
  my $r = exists $keylist{$self}{$_[0]};
  warn "Memoize::SDBM_File EXISTS (@_) ==> $r\n" if $Verbose;
  $r;
}

sub DEFINED {
  warn "Memoize::SDBM_File DEFINED (@_)\n" if $Verbose;
  my $self = shift;
  _backhash($self)  unless exists $keylist{$self};
  defined $keylist{$self}{$_[0]};
}

sub DESTROY {
  warn "Memoize::SDBM_File DESTROY (@_)\n" if $Verbose;
  my $self = shift;
  delete $keylist{$self};   # So much for reference counting...
  $self->SUPER::DESTROY(@_);
}

# Maybe establish the keylist at TIEHASH time instead?

sub STORE {
  warn "Memoize::SDBM_File STORE (@_)\n" if $VERBOSE;
  my $self = shift;
  $keylist{$self}{$_[0]} = undef;
  $self->SUPER::STORE(@_);
}

# Inherit FETCH and TIEHASH

1;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  package Memoize::Storable;

=head1 NAME

Memoize::Storable - store Memoized data in Storable database

=head1 DESCRIPTION

See L<Memoize>.

=cut

use Storable ();
$VERSION = '1.03';
$Verbose = 0;

sub TIEHASH {
  require Carp if $Verbose;
  my $package = shift;
  my $filename = shift;
  my $truehash = (-e $filename) ? Storable::retrieve($filename) : {};
  my %options;
  print STDERR "Memoize::Storable::TIEHASH($filename, @_)\n" if $Verbose;
  @options{@_} = ();
  my $self = 
    {FILENAME => $filename, 
     H => $truehash, 
     OPTIONS => \%options
    };
  bless $self => $package;
}

sub STORE {
  require Carp if $Verbose;
  my $self = shift;
  print STDERR "Memoize::Storable::STORE(@_)\n" if $Verbose;
  $self->{H}{$_[0]} = $_[1];
}

sub FETCH {
  require Carp if $Verbose;
  my $self = shift;
  print STDERR "Memoize::Storable::FETCH(@_)\n" if $Verbose;
  $self->{H}{$_[0]};
}

sub EXISTS {
  require Carp if $Verbose;
  my $self = shift;
  print STDERR "Memoize::Storable::EXISTS(@_)\n" if $Verbose;
  exists $self->{H}{$_[0]};
}

sub DESTROY {
  require Carp if $Verbose;
  my $self= shift;
  print STDERR "Memoize::Storable::DESTROY(@_)\n" if $Verbose;
  if (exists $self->{OPTIONS}{'nstore'}) {
    Storable::nstore($self->{H}, $self->{FILENAME});
  } else {
    Storable::store($self->{H}, $self->{FILENAME});
  }
}

sub FIRSTKEY {
  'Fake hash from Memoize::Storable';
}

sub NEXTKEY {
  undef;
}
1;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    package Module::CoreList;
use strict;
use vars qw/$VERSION %released %version %families %upstream
	    %bug_tracker %deprecated %delta/;
use Module::CoreList::TieHashDelta;
use version;
$VERSION = '5.20170114_24';

sub _released_order {   # Sort helper, to make '?' sort after everything else
    (substr($released{$a}, 0, 1) eq "?")
    ? ((substr($released{$b}, 0, 1) eq "?")
        ? 0
        : 1)
    : ((substr($released{$b}, 0, 1) eq "?")
        ? -1
        : $released{$a} cmp $released{$b} )
}

my $dumpinc = 0;
sub import {
    my $self = shift;
    my $what = shift || '';
    if ($what eq 'dumpinc') {
        $dumpinc = 1;
    }
}

END {
    print "---INC---\n", join "\n" => keys %INC
      if $dumpinc;
}


sub first_release_raw {
    my $module = shift;
    $module = shift if eval { $module->isa(__PACKAGE__) }
      and scalar @_ and $_[0] =~ m#\A[a-zA-Z_][0-9a-zA-Z_]*(?:(::|')[0-9a-zA-Z_]+)*\z#;
    my $version = shift;

    my @perls = $version
        ? grep { defined $version{$_}{ $module } &&
                        $version{$_}{ $module } ge $version } keys %version
        : grep { exists $version{$_}{ $module }             } keys %version;

    return @perls;
}

sub first_release_by_date {
    my @perls = &first_release_raw;
    return unless @perls;
    return (sort _released_order @perls)[0];
}

sub first_release {
    my @perls = &first_release_raw;
    return unless @perls;
    return (sort { $a cmp $b } @perls)[0];
}

sub find_modules {
    my $regex = shift;
    $regex = shift if eval { $regex->isa(__PACKAGE__) };
    my @perls = @_;
    @perls = keys %version unless @perls;

    my %mods;
    foreach (@perls) {
        while (my ($k, $v) = each %{$version{$_}}) {
            $mods{$k}++ if $k =~ $regex;
        }
    }
    return sort keys %mods
}

sub find_version {
    my $v = shift;
    if ($v->isa(__PACKAGE__)) {
        $v = shift;
        return if not defined $v;
    }
    return $version{$v} if defined $version{$v};
    return;
}

sub is_deprecated {
    my $module = shift;
    $module = shift if eval { $module->isa(__PACKAGE__) }
      and scalar @_ and $_[0] =~ m#\A[a-zA-Z_][0-9a-zA-Z_]*(?:(::|')[0-9a-zA-Z_]+)*\z#;
    my $perl_version = shift;
    $perl_version ||= $];
    return unless $module && exists $deprecated{$perl_version}{$module};
    return $deprecated{$perl_version}{$module};
}

sub deprecated_in {
    my $module = shift;
    $module = shift if eval { $module->isa(__PACKAGE__) }
      and scalar @_ and $_[0] =~ m#\A[a-zA-Z_][0-9a-zA-Z_]*(?:(::|')[0-9a-zA-Z_]+)*\z#;
    return unless $module;
    my @perls = grep { exists $deprecated{$_}{$module} } keys %deprecated;
    return unless @perls;
    require List::Util;
    return List::Util::minstr(@perls);
}

sub removed_from {
  my @perls = &removed_raw;
  return shift @perls;
}

sub removed_from_by_date {
  my @perls = sort _released_order &removed_raw;
  return shift @perls;
}

sub removed_raw {
  my $mod = shift;
  $mod = shift if eval { $mod->isa(__PACKAGE__) }
      and scalar @_ and $_[0] =~ m#\A[a-zA-Z_][0-9a-zA-Z_]*(?:(::|')[0-9a-zA-Z_]+)*\z#;
  return unless my @perls = sort { $a cmp $b } first_release_raw($mod);
  my $last = pop @perls;
  my @removed = grep { $_ > $last } sort { $a cmp $b } keys %version;
  return @removed;
}

sub changes_between {
  my $left_ver = shift;
  $left_ver = shift if eval { $left_ver->isa(__PACKAGE__) };
  my $right_ver = shift;

  my $left  = $version{ $left_ver };
  my $right = $version{ $right_ver };

  my %uniq = (%$left, %$right);

  my %changes;
  for my $lib (keys %uniq) {
      my $lhs = exists $left->{ $lib }
              ? (defined $left->{ $lib } ? $left->{ $lib } : '(undef)')
              : '(absent)';
      my $rhs = exists $right->{ $lib }
              ? (defined $right->{ $lib } ? $right->{ $lib } : '(undef)')
              : '(absent)';

      next if $lhs eq $rhs;

      my $change = {
        (exists $left->{$lib}  ? (left  => $left->{$lib})  : ()),
        (exists $right->{$lib} ? (right => $right->{$lib}) : ()),
      };

      $changes{$lib} = $change;
  }

  return %changes;
}

# When things escaped.
# NB. If you put version numbers with trailing zeroes here, you
# should also add an alias for the numerical ($]) version; see
# just before the __END__ of this module.
%released = (
    5.000    => '1994-10-17',
    5.001    => '1995-03-14',
    5.002    => '1996-02-29',
    5.00307  => '1996-10-10',
    5.004    => '1997-05-15',
    5.005    => '1998-07-22',
    5.00503  => '1999-03-28',
    5.00405  => '1999-04-29',
    5.006    => '2000-03-22',
    5.006001 => '2001-04-08',
    5.007003 => '2002-03-05',
    5.008    => '2002-07-19',
    5.008001 => '2003-09-25',
    5.009    => '2003-10-27',
    5.008002 => '2003-11-05',
    5.006002 => '2003-11-15',
    5.008003 => '2004-01-14',
    5.00504  => '2004-02-23',
    5.009001 => '2004-03-16',
    5.008004 => '2004-04-21',
    5.008005 => '2004-07-19',
    5.008006 => '2004-11-27',
    5.009002 => '2005-04-01',
    5.008007 => '2005-05-30',
    5.009003 => '2006-01-28',
    5.008008 => '2006-01-31',
    5.009004 => '2006-08-15',
    5.009005 => '2007-07-07',
    5.010000 => '2007-12-18',
    5.008009 => '2008-12-14',
    5.010001 => '2009-08-22',
    5.011000 => '2009-10-02',
    5.011001 => '2009-10-20',
    5.011002 => '2009-11-20',
    5.011003 => '2009-12-20',
    5.011004 => '2010-01-20',
    5.011005 => '2010-02-20',
    5.012000 => '2010-04-12',
    5.013000 => '2010-04-20',
    5.012001 => '2010-05-16',
    5.013001 => '2010-05-20',
    5.013002 => '2010-06-22',
    5.013003 => '2010-07-20',
    5.013004 => '2010-08-20',
    5.012002 => '2010-09-06',
    5.013005 => '2010-09-19',
    5.013006 => '2010-10-20',
    5.013007 => '2010-11-20',
    5.013008 => '2010-12-20',
    5.012003 => '2011-01-21',
    5.013009 => '2011-01-20',
    5.013010 => '2011-02-20',
    5.013011 => '2011-03-20',
    5.014000 => '2011-05-14',
    5.012004 => '2011-06-20',
    5.012005 => '2012-11-10',
    5.014001 => '2011-06-16',
    5.015000 => '2011-06-20',
    5.015001 => '2011-07-20',
    5.015002 => '2011-08-20',
    5.014002 => '2011-09-26',
    5.015003 => '2011-09-20',
    5.015004 => '2011-10-20',
    5.015005 => '2011-11-20',
    5.015006 => '2011-12-20',
    5.015007 => '2012-01-20',
    5.015008 => '2012-02-20',
    5.015009 => '2012-03-20',
    5.016000 => '2012-05-20',
    5.016001 => '2012-08-08',
    5.016002 => '2012-11-01',
    5.017000 => '2012-05-26',
    5.017001 => '2012-06-20',
    5.017002 => '2012-07-20',
    5.017003 => '2012-08-20',
    5.017004 => '2012-09-20',
    5.014003 => '2012-10-12',
    5.017005 => '2012-10-20',
    5.017006 => '2012-11-20',
    5.017007 => '2012-12-18',
    5.017008 => '2013-01-20',
    5.017009 => '2013-02-20',
    5.014004 => '2013-03-10',
    5.016003 => '2013-03-11',
    5.017010 => '2013-03-21',
    5.017011 => '2013-04-20',
    5.018000 => '2013-05-18',
    5.019000 => '2013-05-20',
    5.019001 => '2013-06-21',
    5.019002 => '2013-07-22',
    5.018001 => '2013-08-12',
    5.019003 => '2013-08-20',
    5.019004 => '2013-09-20',
    5.019005 => '2013-10-20',
    5.019006 => '2013-11-20',
    5.019007 => '2013-12-20',
    5.018002 => '2014-01-06',
    5.018003 => '2014-10-01',
    5.018004 => '2014-10-01',
    5.019008 => '2014-01-20',
    5.019009 => '2014-02-20',
    5.01901  => '2014-03-20',
    5.019011 => '2014-04-20',
    5.020000 => '2014-05-27',
    5.021000 => '2014-05-27',
    5.021001 => '2014-06-20',
    5.021002 => '2014-07-20',
    5.021003 => '2014-08-20',
    5.020001 => '2014-09-14',
    5.021004 => '2014-09-20',
    5.021005 => '2014-10-20',
    5.021006 => '2014-11-20',
    5.021007 => '2014-12-20',
    5.021008 => '2015-01-20',
    5.020002 => '2015-02-14',
    5.021009 => '2015-02-21',
    5.021010 => '2015-03-20',
    5.021011 => '2015-04-20',
    5.022000 => '2015-06-01',
    5.023000 => '2015-06-20',
    5.023001 => '2015-07-20',
    5.023002 => '2015-08-20',
    5.020003 => '2015-09-12',
    5.023003 => '2015-09-20',
    5.023004 => '2015-10-20',
    5.023005 => '2015-11-20',
    5.022001 => '2015-12-13',
    5.023006 => '2015-12-21',
    5.023007 => '2016-01-20',
    5.023008 => '2016-02-20',
    5.023009 => '2016-03-20',
    5.022002 => '2016-04-29',
    5.024000 => '2016-05-09',
    5.025000 => '2016-05-09',
    5.025001 => '2016-05-20',
    5.025002 => '2016-06-20',
    5.025003 => '2016-07-20',
    5.025004 => '2016-08-20',
    5.025005 => '2016-09-20',
    5.025006 => '2016-10-20',
    5.025007 => '2016-11-20',
    5.025008 => '2016-12-20',
    5.024001 => '2017-01-14',
  );

for my $version ( sort { $a <=> $b } keys %released ) {
    my $family = int ($version * 1000) / 1000;
    push @{ $families{ $family }} , $version;
}

%delta = (
    5 => {
        changed => {
            'AnyDBM_File'           => undef,
            'AutoLoader'            => undef,
            'AutoSplit'             => undef,
            'Benchmark'             => undef,
            'Carp'                  => undef,
            'Cwd'                   => undef,
            'DB_File'               => undef,
            'DynaLoader'            => undef,
            'English'               => undef,
            'Env'                   => undef,
            'Exporter'              => undef,
            'ExtUtils::MakeMaker'   => undef,
            'Fcntl'                 => undef,
            'File::Basename'        => undef,
            'File::CheckTree'       => undef,
            'File::Find'            => undef,
            'FileHandle'            => undef,
            'GDBM_File'             => undef,
            'Getopt::Long'          => undef,
            'Getopt::Std'           => undef,
            'I18N::Collate'         => undef,
            'IPC::Open2'            => undef,
            'IPC::Open3'            => undef,
            'Math::BigFloat'        => undef,
            'Math::BigInt'          => undef,
            'Math::Complex'         => undef,
            'NDBM_File'             => undef,
            'Net::Ping'             => undef,
            'ODBM_File'             => undef,
            'POSIX'                 => undef,
            'SDBM_File'             => undef,
            'Search::Dict'          => undef,
            'Shell'                 => undef,
            'Socket'                => undef,
            'Sys::Hostname'         => undef,
            'Sys::Syslog'           => undef,
            'Term::Cap'             => undef,
            'Term::Complete'        => undef,
            'Test::Harness'         => undef,
            'Text::Abbrev'          => undef,
            'Text::ParseWords'      => undef,
            'Text::Soundex'         => undef,
            'Text::Tabs'            => undef,
            'TieHash'               => undef,
            'Time::Local'           => undef,
            'integer'               => undef,
            'less'                  => undef,
            'sigtrap'               => undef,
            'strict'                => undef,
            'subs'                  => undef,
        },
        removed => {
        }
    },
    5.001 => {
        delta_from => 5,
        changed => {
            'ExtUtils::Liblist'     => undef,
            'ExtUtils::Manifest'    => undef,
            'ExtUtils::Mkbootstrap' => undef,
            'File::Path'            => undef,
            'SubstrHash'            => undef,
            'lib'                   => undef,
        },
        removed => {
        }
    },
    5.002 => {
        delta_from => 5.001,
        changed => {
            'DB_File'               => '1.01',
            'Devel::SelfStubber'    => '1.01',
            'DirHandle'             => undef,
            'DynaLoader'            => '1.00',
            'ExtUtils::Install'     => undef,
            'ExtUtils::MM_OS2'      => undef,
            'ExtUtils::MM_Unix'     => undef,
            'ExtUtils::MM_VMS'      => undef,
            'ExtUtils::MakeMaker'   => '5.21',
            'ExtUtils::Manifest'    => '1.22',
            'ExtUtils::Mksymlists'  => '1.00',
            'Fcntl'                 => '1.00',
            'File::Copy'            => '1.5',
            'File::Path'            => '1.01',
            'FileCache'             => undef,
            'FileHandle'            => '1.00',
            'GDBM_File'             => '1.00',
            'Getopt::Long'          => '2.01',
            'NDBM_File'             => '1.00',
            'Net::Ping'             => '1',
            'ODBM_File'             => '1.00',
            'POSIX'                 => '1.00',
            'Pod::Functions'        => undef,
            'Pod::Text'             => undef,
            'SDBM_File'             => '1.00',
            'Safe'                  => '1.00',
            'SelectSaver'           => undef,
            'SelfLoader'            => '1.06',
            'Socket'                => '1.5',
            'Symbol'                => undef,
            'Term::ReadLine'        => undef,
            'Test::Harness'         => '1.07',
            'Text::Wrap'            => undef,
            'Tie::Hash'             => undef,
            'Tie::Scalar'           => undef,
            'Tie::SubstrHash'       => undef,
            'diagnostics'           => undef,
            'overload'              => undef,
            'vars'                  => undef,
        },
        removed => {
            'SubstrHash'            => 1,
            'TieHash'               => 1,
        }
    },
    5.00307 => {
        delta_from => 5.002,
        changed => {
            'Config'                => undef,
            'DB_File'               => '1.03',
            'ExtUtils::Embed'       => '1.18',
            'ExtUtils::Install'     => '1.15',
            'ExtUtils::Liblist'     => '1.20',
            'ExtUtils::MM_Unix'     => '1.107',
            'ExtUtils::MakeMaker'   => '5.38',
            'ExtUtils::Manifest'    => '1.27',
            'ExtUtils::Mkbootstrap' => '1.13',
            'ExtUtils::Mksymlists'  => '1.12',
            'ExtUtils::testlib'     => '1.11',
            'Fatal'                 => undef,
            'File::Basename'        => '2.4',
            'FindBin'               => '1.04',
            'Getopt::Long'          => '2.04',
            'IO'                    => undef,
            'IO::File'              => '1.05',
            'IO::Handle'            => '1.12',
            'IO::Pipe'              => '1.07',
            'IO::Seekable'          => '1.05',
            'IO::Select'            => '1.09',
            'IO::Socket'            => '1.13',
            'Net::Ping'             => '1.01',
            'OS2::ExtAttr'          => '0.01',
            'OS2::PrfDB'            => '0.02',
            'OS2::Process'          => undef,
            'OS2::REXX'             => undef,
            'Opcode'                => '1.01',
            'Safe'                  => '2.06',
            'Test::Harness'         => '1.13',
            'Text::Tabs'            => '96.051501',
            'Text::Wrap'            => '96.041801',
            'UNIVERSAL'             => undef,
            'VMS::Filespec'         => undef,
            'VMS::Stdio'            => '2.0',
            'ops'                   => undef,
            'sigtrap'               => '1.01',
        },
        removed => {
        }
    },
    5.004 => {
        delta_from => 5.00307,
        changed => {
            'Bundle::CPAN'          => '0.02',
            'CGI'                   => '2.36',
            'CGI::Apache'           => '1.01',
            'CGI::Carp'             => '1.06',
            'CGI::Fast'             => '1.00a',
            'CGI::Push'             => '1.00',
            'CGI::Switch'           => '0.05',
            'CPAN'                  => '1.2401',
            'CPAN::FirstTime'       => '1.18',
            'CPAN::Nox'             => undef,
            'Class::Struct'         => undef,
            'Cwd'                   => '2.00',
            'DB_File'               => '1.14',
            'DynaLoader'            => '1.02',
            'ExtUtils::Command'     => '1.00',
            'ExtUtils::Embed'       => '1.2501',
            'ExtUtils::Install'     => '1.16',
            'ExtUtils::Liblist'     => '1.2201',
            'ExtUtils::MM_Unix'     => '1.114',
            'ExtUtils::MM_Win32'    => undef,
            'ExtUtils::MakeMaker'   => '5.4002',
            'ExtUtils::Manifest'    => '1.33',
            'ExtUtils::Mksymlists'  => '1.13',
            'ExtUtils::XSSymSet'    => '1.0',
            'Fcntl'                 => '1.03',
            'File::Basename'        => '2.5',
            'File::Compare'         => '1.1001',
            'File::Copy'            => '2.02',
            'File::Path'            => '1.04',
            'File::stat'            => undef,
            'FileHandle'            => '2.00',
            'Getopt::Long'          => '2.10',
            'IO::File'              => '1.0602',
            'IO::Handle'            => '1.1504',
            'IO::Pipe'              => '1.0901',
            'IO::Seekable'          => '1.06',
            'IO::Select'            => '1.10',
            'IO::Socket'            => '1.1602',
            'IPC::Open2'            => '1.01',
            'IPC::Open3'            => '1.0101',
            'Math::Complex'         => '1.01',
            'Math::Trig'            => '1',
            'Net::Ping'             => '2.02',
            'Net::hostent'          => undef,
            'Net::netent'           => undef,
            'Net::protoent'         => undef,
            'Net::servent'          => undef,
            'Opcode'                => '1.04',
            'POSIX'                 => '1.02',
            'Pod::Html'             => undef,
            'Pod::Text'             => '1.0203',
            'SelfLoader'            => '1.07',
            'Socket'                => '1.6',
            'Symbol'                => '1.02',
            'Test::Harness'         => '1.1502',
            'Text::Tabs'            => '96.121201',
            'Text::Wrap'            => '97.011701',
            'Tie::RefHash'          => undef,
            'Time::gmtime'          => '1.01',
            'Time::localtime'       => '1.01',
            'Time::tm'              => undef,
            'User::grent'           => undef,
            'User::pwent'           => undef,
            'VMS::DCLsym'           => '1.01',
            'VMS::Stdio'            => '2.02',
            'autouse'               => '1.01',
            'blib'                  => undef,
            'constant'              => '1.00',
            'locale'                => undef,
            'sigtrap'               => '1.02',
            'vmsish'                => undef,
        },
        removed => {
            'Fatal'                 => 1,
        }
    },
    5.00405 => {
        delta_from => 5.004,
        changed => {
            'AutoLoader'            => '5.56',
            'AutoSplit'             => '1.0303',
            'Bundle::CPAN'          => '0.03',
            'CGI'                   => '2.42',
            'CGI::Apache'           => '1.1',
            'CGI::Carp'             => '1.10',
            'CGI::Cookie'           => '1.06',
            'CGI::Push'             => '1.01',
            'CGI::Switch'           => '0.06',
            'CPAN'                  => '1.40',
            'CPAN::FirstTime'       => '1.30',
            'Cwd'                   => '2.01',
            'DB_File'               => '1.15',
            'DynaLoader'            => '1.03',
            'ExtUtils::Command'     => '1.01',
            'ExtUtils::Embed'       => '1.2505',
            'ExtUtils::Install'     => '1.28',
            'ExtUtils::Liblist'     => '1.25',
            'ExtUtils::MM_Unix'     => '1.118',
            'ExtUtils::MakeMaker'   => '5.42',
            'ExtUtils::Mkbootstrap' => '1.14',
            'ExtUtils::Mksymlists'  => '1.16',
            'File::Basename'        => '2.6',
            'File::DosGlob'         => undef,
            'File::Path'            => '1.0402',
            'File::Spec'            => '0.6',
            'File::Spec::Mac'       => '1.0',
            'File::Spec::OS2'       => undef,
            'File::Spec::Unix'      => undef,
            'File::Spec::VMS'       => undef,
            'File::Spec::Win32'     => undef,
            'FindBin'               => '1.41',
            'Getopt::Long'          => '2.19',
            'IO::File'              => '1.06021',
            'IO::Socket'            => '1.1603',
            'IPC::Open3'            => '1.0103',
            'Math::Complex'         => '1.25',
            'NDBM_File'             => '1.01',
            'Pod::Html'             => '1.0101',
            'Pod::Text'             => '1.0204',
            'SelfLoader'            => '1.08',
            'Socket'                => '1.7',
            'Test'                  => '1.04',
            'Test::Harness'         => '1.1602',
            'Text::ParseWords'      => '3.1001',
            'Text::Wrap'            => '98.112902',
            'Tie::Handle'           => undef,
            'attrs'                 => '0.1',
            'base'                  => undef,
            'blib'                  => '1.00',
            're'                    => undef,
            'strict'                => '1.01',
        },
        removed => {
        }
    },
    5.005 => {
        delta_from => 5.00405,
        changed => {
            'AutoLoader'            => undef,
            'AutoSplit'             => '1.0302',
            'B'                     => undef,
            'B::Asmdata'            => undef,
            'B::Assembler'          => undef,
            'B::Bblock'             => undef,
            'B::Bytecode'           => undef,
            'B::C'                  => undef,
            'B::CC'                 => undef,
            'B::Debug'              => undef,
            'B::Deparse'            => '0.56',
            'B::Disassembler'       => undef,
            'B::Lint'               => undef,
            'B::Showlex'            => undef,
            'B::Stackobj'           => undef,
            'B::Terse'              => undef,
            'B::Xref'               => undef,
            'CGI::Carp'             => '1.101',
            'CPAN'                  => '1.3901',
            'CPAN::FirstTime'       => '1.29',
            'DB_File'               => '1.60',
            'Data::Dumper'          => '2.09',
            'Errno'                 => '1.09',
            'ExtUtils::Installed'   => '0.02',
            'ExtUtils::MM_Unix'     => '1.12601',
            'ExtUtils::MakeMaker'   => '5.4301',
            'ExtUtils::Mkbootstrap' => '1.13',
            'ExtUtils::Mksymlists'  => '1.17',
            'ExtUtils::Packlist'    => '0.03',
            'Fatal'                 => '1.02',
            'File::Path'            => '1.0401',
            'Getopt::Long'          => '2.17',
            'IO::Handle'            => '1.1505',
            'IPC::Msg'              => '1.00',
            'IPC::Open3'            => '1.0102',
            'IPC::Semaphore'        => '1.00',
            'IPC::SysV'             => '1.03',
            'O'                     => undef,
            'OS2::Process'          => '0.2',
            'Pod::Html'             => '1.01',
            'Pod::Text'             => '1.0203',
            'Text::ParseWords'      => '3.1',
            'Text::Wrap'            => '97.02',
            'Thread'                => '1.0',
            'Thread::Queue'         => undef,
            'Thread::Semaphore'     => undef,
            'Thread::Signal'        => undef,
            'Thread::Specific'      => undef,
            'Tie::Array'            => '1.00',
            'VMS::Stdio'            => '2.1',
            'attrs'                 => '1.0',
            'fields'                => '0.02',
            're'                    => '0.02',
        },
        removed => {
            'Bundle::CPAN'          => 1,
        }
    },
    5.00503 => {
        delta_from => 5.005,
        changed => {
            'AutoSplit'             => '1.0303',
            'CGI'                   => '2.46',
            'CGI::Carp'             => '1.13',
            'CGI::Fast'             => '1.01',
            'CPAN'                  => '1.48',
            'CPAN::FirstTime'       => '1.36',
            'CPAN::Nox'             => '1.00',
            'DB_File'               => '1.65',
            'Data::Dumper'          => '2.101',
            'Dumpvalue'             => undef,
            'Errno'                 => '1.111',
            'ExtUtils::Install'     => '1.28',
            'ExtUtils::Liblist'     => '1.25',
            'ExtUtils::MM_Unix'     => '1.12602',
            'ExtUtils::MakeMaker'   => '5.4302',
            'ExtUtils::Manifest'    => '1.33',
            'ExtUtils::Mkbootstrap' => '1.14',
            'ExtUtils::Mksymlists'  => '1.17',
            'ExtUtils::testlib'     => '1.11',
            'FindBin'               => '1.42',
            'Getopt::Long'          => '2.19',
            'Getopt::Std'           => '1.01',
            'IO::Pipe'              => '1.0902',
            'IPC::Open3'            => '1.0103',
            'Math::Complex'         => '1.26',
            'Test'                  => '1.122',
            'Text::Wrap'            => '98.112902',
        },
        removed => {
        }
    },
    5.00504 => {
        delta_from => 5.00503,
        changed => {
            'CPAN::FirstTime'       => '1.36',
            'DB_File'               => '1.807',
            'ExtUtils::Install'     => '1.28',
            'ExtUtils::Liblist'     => '1.25',
            'ExtUtils::MM_Unix'     => '1.12602',
            'ExtUtils::Manifest'    => '1.33',
            'ExtUtils::Miniperl'    => undef,
            'ExtUtils::Mkbootstrap' => '1.14',
            'ExtUtils::Mksymlists'  => '1.17',
            'ExtUtils::testlib'     => '1.11',
            'File::Compare'         => '1.1002',
            'File::Spec'            => '0.8',
            'File::Spec::Functions' => undef,
            'File::Spec::Mac'       => undef,
            'Getopt::Long'          => '2.20',
            'Pod::Html'             => '1.02',
        },
        removed => {
        }
    },
    5.006 => {
        delta_from => 5.00504,
        changed => {
            'AutoLoader'            => '5.57',
            'AutoSplit'             => '1.0305',
            'B::Deparse'            => '0.59',
            'B::Stash'              => undef,
            'Benchmark'             => '1',
            'ByteLoader'            => '0.03',
            'CGI'                   => '2.56',
            'CGI::Apache'           => undef,
            'CGI::Carp'             => '1.14',
            'CGI::Cookie'           => '1.12',
            'CGI::Fast'             => '1.02',
            'CGI::Pretty'           => '1.03',
            'CGI::Switch'           => undef,
            'CPAN'                  => '1.52',
            'CPAN::FirstTime'       => '1.38',
            'Carp::Heavy'           => undef,
            'Class::Struct'         => '0.58',
            'Cwd'                   => '2.02',
            'DB'                    => '1.0',
            'DB_File'               => '1.72',
            'Devel::DProf'          => '20000000.00_00',
            'Devel::Peek'           => '1.00_01',
            'DynaLoader'            => '1.04',
            'Exporter'              => '5.562',
            'Exporter::Heavy'       => undef,
            'ExtUtils::MM_Cygwin'   => undef,
            'ExtUtils::MM_Unix'     => '1.12603',
            'ExtUtils::MakeMaker'   => '5.45',
            'File::Copy'            => '2.03',
            'File::Glob'            => '0.991',
            'File::Path'            => '1.0403',
            'GDBM_File'             => '1.03',
            'Getopt::Long'          => '2.23',
            'Getopt::Std'           => '1.02',
            'IO'                    => '1.20',
            'IO::Dir'               => '1.03',
            'IO::File'              => '1.08',
            'IO::Handle'            => '1.21',
            'IO::Pipe'              => '1.121',
            'IO::Poll'              => '0.01',
            'IO::Seekable'          => '1.08',
            'IO::Select'            => '1.14',
            'IO::Socket'            => '1.26',
            'IO::Socket::INET'      => '1.25',
            'IO::Socket::UNIX'      => '1.20',
            'JNI'                   => '0.01',
            'JPL::AutoLoader'       => undef,
            'JPL::Class'            => undef,
            'JPL::Compile'          => undef,
            'NDBM_File'             => '1.03',
            'ODBM_File'             => '1.02',
            'OS2::DLL'              => undef,
            'POSIX'                 => '1.03',
            'Pod::Checker'          => '1.098',
            'Pod::Find'             => '0.12',
            'Pod::Html'             => '1.03',
            'Pod::InputObjects'     => '1.12',
            'Pod::Man'              => '1.02',
            'Pod::ParseUtils'       => '0.2',
            'Pod::Parser'           => '1.12',
            'Pod::Plainer'          => '0.01',
            'Pod::Select'           => '1.12',
            'Pod::Text'             => '2.03',
            'Pod::Text::Color'      => '0.05',
            'Pod::Text::Termcap'    => '0.04',
            'Pod::Usage'            => '1.12',
            'SDBM_File'             => '1.02',
            'SelfLoader'            => '1.0901',
            'Shell'                 => '0.2',
            'Socket'                => '1.72',
            'Sys::Hostname'         => '1.1',
            'Sys::Syslog'           => '0.01',
            'Term::ANSIColor'       => '1.01',
            'Test'                  => '1.13',
            'Test::Harness'         => '1.1604',
            'Text::ParseWords'      => '3.2',
            'Text::Soundex'         => '1.0',
            'Text::Tabs'            => '98.112801',
            'Tie::Array'            => '1.01',
            'Tie::Handle'           => '1.0',
            'VMS::Stdio'            => '2.2',
            'XSLoader'              => '0.01',
            'attributes'            => '0.03',
            'autouse'               => '1.02',
            'base'                  => '1.01',
            'bytes'                 => undef,
            'charnames'             => undef,
            'constant'              => '1.02',
            'diagnostics'           => '1.0',
            'fields'                => '1.01',
            'filetest'              => undef,
            'lib'                   => '0.5564',
            'open'                  => undef,
            'utf8'                  => undef,
            'warnings'              => undef,
            'warnings::register'    => undef,
        },
        removed => {
        }
    },
    5.006001 => {
        delta_from => 5.006,
        changed => {
            'AutoLoader'            => '5.58',
            'B::Assembler'          => '0.02',
            'B::Concise'            => '0.51',
            'B::Deparse'            => '0.6',
            'ByteLoader'            => '0.04',
            'CGI'                   => '2.752',
            'CGI::Carp'             => '1.20',
            'CGI::Cookie'           => '1.18',
            'CGI::Pretty'           => '1.05',
            'CGI::Push'             => '1.04',
            'CGI::Util'             => '1.1',
            'CPAN'                  => '1.59_54',
            'CPAN::FirstTime'       => '1.53',
            'Class::Struct'         => '0.59',
            'Cwd'                   => '2.04',
            'DB_File'               => '1.75',
            'Data::Dumper'          => '2.102',
            'ExtUtils::Install'     => '1.28',
            'ExtUtils::Liblist'     => '1.26',
            'ExtUtils::MM_Unix'     => '1.12603',
            'ExtUtils::Manifest'    => '1.33',
            'ExtUtils::Mkbootstrap' => '1.14',
            'ExtUtils::Mksymlists'  => '1.17',
            'ExtUtils::testlib'     => '1.11',
            'File::Path'            => '1.0404',
            'File::Spec'            => '0.82',
            'File::Spec::Epoc'      => undef,
            'File::Spec::Functions' => '1.1',
            'File::Spec::Mac'       => '1.2',
            'File::Spec::OS2'       => '1.1',
            'File::Spec::Unix'      => '1.2',
            'File::Spec::VMS'       => '1.1',
            'File::Spec::Win32'     => '1.2',
            'File::Temp'            => '0.12',
            'GDBM_File'             => '1.05',
            'Getopt::Long'          => '2.25',
            'IO::Poll'              => '0.05',
            'JNI'                   => '0.1',
            'Math::BigFloat'        => '0.02',
            'Math::BigInt'          => '0.01',
            'Math::Complex'         => '1.31',
            'NDBM_File'             => '1.04',
            'ODBM_File'             => '1.03',
            'OS2::REXX'             => '1.00',
            'Pod::Checker'          => '1.2',
            'Pod::Find'             => '0.21',
            'Pod::InputObjects'     => '1.13',
            'Pod::LaTeX'            => '0.53',
            'Pod::Man'              => '1.15',
            'Pod::ParseUtils'       => '0.22',
            'Pod::Parser'           => '1.13',
            'Pod::Select'           => '1.13',
            'Pod::Text'             => '2.08',
            'Pod::Text::Color'      => '0.06',
            'Pod::Text::Overstrike' => '1.01',
            'Pod::Text::Termcap'    => '1',
            'Pod::Usage'            => '1.14',
            'SDBM_File'             => '1.03',
            'SelfLoader'            => '1.0902',
            'Shell'                 => '0.3',
            'Term::ANSIColor'       => '1.03',
            'Test'                  => '1.15',
            'Text::Wrap'            => '2001.0131',
            'Tie::Handle'           => '4.0',
            'Tie::RefHash'          => '1.3',
        },
        removed => {
        }
    },
    5.006002 => {
        delta_from => 5.006001,
        changed => {
            'CPAN::FirstTime'       => '1.53',
            'DB_File'               => '1.806',
            'Data::Dumper'          => '2.121',
            'ExtUtils::Command'     => '1.05',
            'ExtUtils::Command::MM' => '0.03',
            'ExtUtils::Install'     => '1.32',
            'ExtUtils::Installed'   => '0.08',
            'ExtUtils::Liblist'     => '1.01',
            'ExtUtils::Liblist::Kid'=> '1.3',
            'ExtUtils::MM'          => '0.04',
            'ExtUtils::MM_Any'      => '0.07',
            'ExtUtils::MM_BeOS'     => '1.04',
            'ExtUtils::MM_Cygwin'   => '1.06',
            'ExtUtils::MM_DOS'      => '0.02',
            'ExtUtils::MM_MacOS'    => '1.07',
            'ExtUtils::MM_NW5'      => '2.06',
            'ExtUtils::MM_OS2'      => '1.04',
            'ExtUtils::MM_UWIN'     => '0.02',
            'ExtUtils::MM_Unix'     => '1.42',
            'ExtUtils::MM_VMS'      => '5.70',
            'ExtUtils::MM_Win32'    => '1.09',
            'ExtUtils::MM_Win95'    => '0.03',
            'ExtUtils::MY'          => '0.01',
            'ExtUtils::MakeMaker'   => '6.17',
            'ExtUtils::MakeMaker::bytes'=> '0.01',
            'ExtUtils::MakeMaker::vmsish'=> '0.01',
            'ExtUtils::Manifest'    => '1.42',
            'ExtUtils::Mkbootstrap' => '1.15',
            'ExtUtils::Mksymlists'  => '1.19',
            'ExtUtils::Packlist'    => '0.04',
            'ExtUtils::testlib'     => '1.15',
            'File::Spec'            => '0.86',
            'File::Spec::Cygwin'    => '1.1',
            'File::Spec::Epoc'      => '1.1',
            'File::Spec::Functions' => '1.3',
            'File::Spec::Mac'       => '1.4',
            'File::Spec::OS2'       => '1.2',
            'File::Spec::Unix'      => '1.5',
            'File::Spec::VMS'       => '1.4',
            'File::Spec::Win32'     => '1.4',
            'File::Temp'            => '0.14',
            'Safe'                  => '2.10',
            'Test'                  => '1.24',
            'Test::Builder'         => '0.17',
            'Test::Harness'         => '2.30',
            'Test::Harness::Assert' => '0.01',
            'Test::Harness::Iterator'=> '0.01',
            'Test::Harness::Straps' => '0.15',
            'Test::More'            => '0.47',
            'Test::Simple'          => '0.47',
            'Unicode'               => '3.0.1',
            'if'                    => '0.03',
            'ops'                   => '1.00',
        },
        removed => {
        }
    },
    5.007003 => {
        delta_from => 5.006001,
        changed => {
            'AnyDBM_File'           => '1.00',
            'Attribute::Handlers'   => '0.76',
            'AutoLoader'            => '5.59',
            'AutoSplit'             => '1.0307',
            'B'                     => '1.00',
            'B::Asmdata'            => '1.00',
            'B::Assembler'          => '0.04',
            'B::Bblock'             => '1.00',
            'B::Bytecode'           => '1.00',
            'B::C'                  => '1.01',
            'B::CC'                 => '1.00',
            'B::Concise'            => '0.52',
            'B::Debug'              => '1.00',
            'B::Deparse'            => '0.63',
            'B::Disassembler'       => '1.01',
            'B::Lint'               => '1.00',
            'B::Showlex'            => '1.00',
            'B::Stackobj'           => '1.00',
            'B::Stash'              => '1.00',
            'B::Terse'              => '1.00',
            'B::Xref'               => '1.00',
            'Benchmark'             => '1.04',
            'CGI'                   => '2.80',
            'CGI::Apache'           => '1.00',
            'CGI::Carp'             => '1.22',
            'CGI::Cookie'           => '1.20',
            'CGI::Fast'             => '1.04',
            'CGI::Pretty'           => '1.05_00',
            'CGI::Switch'           => '1.00',
            'CGI::Util'             => '1.3',
            'CPAN'                  => '1.59_56',
            'CPAN::FirstTime'       => '1.54',
            'CPAN::Nox'             => '1.00_01',
            'Carp'                  => '1.01',
            'Carp::Heavy'           => '1.01',
            'Class::ISA'            => '0.32',
            'Class::Struct'         => '0.61',
            'Cwd'                   => '2.06',
            'DB_File'               => '1.804',
            'Data::Dumper'          => '2.12',
            'Devel::DProf'          => '20000000.00_01',
            'Devel::PPPort'         => '2.0002',
            'Devel::Peek'           => '1.00_03',
            'Devel::SelfStubber'    => '1.03',
            'Digest'                => '1.00',
            'Digest::MD5'           => '2.16',
            'DirHandle'             => '1.00',
            'Dumpvalue'             => '1.10',
            'Encode'                => '0.40',
            'Encode::CN'            => '0.02',
            'Encode::CN::HZ'        => undef,
            'Encode::Encoding'      => '0.02',
            'Encode::Internal'      => '0.30',
            'Encode::JP'            => '0.02',
            'Encode::JP::Constants' => '1.02',
            'Encode::JP::H2Z'       => '0.77',
            'Encode::JP::ISO_2022_JP'=> undef,
            'Encode::JP::JIS'       => undef,
            'Encode::JP::Tr'        => '0.77',
            'Encode::KR'            => '0.02',
            'Encode::TW'            => '0.02',
            'Encode::Tcl'           => '1.01',
            'Encode::Tcl::Escape'   => '1.01',
            'Encode::Tcl::Extended' => '1.01',
            'Encode::Tcl::HanZi'    => '1.01',
            'Encode::Tcl::Table'    => '1.01',
            'Encode::Unicode'       => '0.30',
            'Encode::XS'            => '0.40',
            'Encode::iso10646_1'    => '0.30',
            'Encode::usc2_le'       => '0.30',
            'Encode::utf8'          => '0.30',
            'English'               => '1.00',
            'Env'                   => '1.00',
            'Exporter'              => '5.566',
            'Exporter::Heavy'       => '5.562',
            'ExtUtils::Command'     => '1.02',
            'ExtUtils::Constant'    => '0.11',
            'ExtUtils::Embed'       => '1.250601',
            'ExtUtils::Install'     => '1.29',
            'ExtUtils::Installed'   => '0.04',
            'ExtUtils::Liblist'     => '1.2701',
            'ExtUtils::MM_BeOS'     => '1.00',
            'ExtUtils::MM_Cygwin'   => '1.00',
            'ExtUtils::MM_OS2'      => '1.00',
            'ExtUtils::MM_Unix'     => '1.12607',
            'ExtUtils::MM_VMS'      => '5.56',
            'ExtUtils::MM_Win32'    => '1.00_02',
            'ExtUtils::MakeMaker'   => '5.48_03',
            'ExtUtils::Manifest'    => '1.35',
            'ExtUtils::Mkbootstrap' => '1.1401',
            'ExtUtils::Mksymlists'  => '1.18',
            'ExtUtils::Packlist'    => '0.04',
            'ExtUtils::testlib'     => '1.1201',
            'Fatal'                 => '1.03',
            'Fcntl'                 => '1.04',
            'File::Basename'        => '2.71',
            'File::CheckTree'       => '4.1',
            'File::Compare'         => '1.1003',
            'File::Copy'            => '2.05',
            'File::DosGlob'         => '1.00',
            'File::Find'            => '1.04',
            'File::Glob'            => '1.01',
            'File::Path'            => '1.05',
            'File::Spec'            => '0.83',
            'File::Spec::Cygwin'    => '1.0',
            'File::Spec::Epoc'      => '1.00',
            'File::Spec::Functions' => '1.2',
            'File::Spec::Mac'       => '1.3',
            'File::Spec::Unix'      => '1.4',
            'File::Spec::VMS'       => '1.2',
            'File::Spec::Win32'     => '1.3',
            'File::Temp'            => '0.13',
            'File::stat'            => '1.00',
            'FileCache'             => '1.00',
            'FileHandle'            => '2.01',
            'Filter::Simple'        => '0.77',
            'Filter::Util::Call'    => '1.06',
            'FindBin'               => '1.43',
            'GDBM_File'             => '1.06',
            'Getopt::Long'          => '2.28',
            'Getopt::Std'           => '1.03',
            'I18N::Collate'         => '1.00',
            'I18N::LangTags'        => '0.27',
            'I18N::LangTags::List'  => '0.25',
            'I18N::Langinfo'        => '0.01',
            'IO::Dir'               => '1.03_00',
            'IO::File'              => '1.09',
            'IO::Handle'            => '1.21_00',
            'IO::Pipe'              => '1.122',
            'IO::Poll'              => '0.06',
            'IO::Seekable'          => '1.08_00',
            'IO::Select'            => '1.15',
            'IO::Socket'            => '1.27',
            'IO::Socket::INET'      => '1.26',
            'IO::Socket::UNIX'      => '1.20_00',
            'IPC::Msg'              => '1.00_00',
            'IPC::Open3'            => '1.0104',
            'IPC::Semaphore'        => '1.00_00',
            'IPC::SysV'             => '1.03_00',
            'List::Util'            => '1.06_00',
            'Locale::Constants'     => '2.01',
            'Locale::Country'       => '2.01',
            'Locale::Currency'      => '2.01',
            'Locale::Language'      => '2.01',
            'Locale::Maketext'      => '1.03',
            'Locale::Script'        => '2.01',
            'MIME::Base64'          => '2.12',
            'MIME::QuotedPrint'     => '2.03',
            'Math::BigFloat'        => '1.30',
            'Math::BigInt'          => '1.54',
            'Math::BigInt::Calc'    => '0.25',
            'Math::Complex'         => '1.34',
            'Math::Trig'            => '1.01',
            'Memoize'               => '0.66',
            'Memoize::AnyDBM_File'  => '0.65',
            'Memoize::Expire'       => '0.66',
            'Memoize::ExpireFile'   => '0.65',
            'Memoize::ExpireTest'   => '0.65',
            'Memoize::NDBM_File'    => '0.65',
            'Memoize::SDBM_File'    => '0.65',
            'Memoize::Storable'     => '0.65',
            'NEXT'                  => '0.50',
            'Net::Cmd'              => '2.21',
            'Net::Config'           => '1.10',
            'Net::Domain'           => '2.17',
            'Net::FTP'              => '2.64',
            'Net::FTP::A'           => '1.15',
            'Net::FTP::E'           => '0.01',
            'Net::FTP::I'           => '1.12',
            'Net::FTP::L'           => '0.01',
            'Net::FTP::dataconn'    => '0.10',
            'Net::NNTP'             => '2.21',
            'Net::Netrc'            => '2.12',
            'Net::POP3'             => '2.23',
            'Net::Ping'             => '2.12',
            'Net::SMTP'             => '2.21',
            'Net::Time'             => '2.09',
            'Net::hostent'          => '1.00',
            'Net::netent'           => '1.00',
            'Net::protoent'         => '1.00',
            'Net::servent'          => '1.00',
            'O'                     => '1.00',
            'OS2::DLL'              => '1.00',
            'OS2::Process'          => '1.0',
            'OS2::REXX'             => '1.01',
            'Opcode'                => '1.05',
            'POSIX'                 => '1.05',
            'PerlIO'                => '1.00',
            'PerlIO::Scalar'        => '0.01',
            'PerlIO::Via'           => '0.01',
            'Pod::Checker'          => '1.3',
            'Pod::Find'             => '0.22',
            'Pod::Functions'        => '1.01',
            'Pod::Html'             => '1.04',
            'Pod::LaTeX'            => '0.54',
            'Pod::Man'              => '1.32',
            'Pod::ParseLink'        => '1.05',
            'Pod::Text'             => '2.18',
            'Pod::Text::Color'      => '1.03',
            'Pod::Text::Overstrike' => '1.08',
            'Pod::Text::Termcap'    => '1.09',
            'Safe'                  => '2.07',
            'Scalar::Util'          => '1.06_00',
            'Search::Dict'          => '1.02',
            'SelectSaver'           => '1.00',
            'SelfLoader'            => '1.0903',
            'Shell'                 => '0.4',
            'Socket'                => '1.75',
            'Storable'              => '1.015',
            'Switch'                => '2.06',
            'Symbol'                => '1.04',
            'Sys::Syslog'           => '0.02',
            'Term::ANSIColor'       => '1.04',
            'Term::Cap'             => '1.07',
            'Term::Complete'        => '1.4',
            'Term::ReadLine'        => '1.00',
            'Test'                  => '1.18',
            'Test::Builder'         => '0.11',
            'Test::Harness'         => '2.01',
            'Test::Harness::Assert' => '0.01',
            'Test::Harness::Iterator'=> '0.01',
            'Test::Harness::Straps' => '0.08',
            'Test::More'            => '0.41',
            'Test::Simple'          => '0.41',
            'Text::Abbrev'          => '1.00',
            'Text::Balanced'        => '1.89',
            'Text::ParseWords'      => '3.21',
            'Text::Soundex'         => '1.01',
            'Text::Wrap'            => '2001.0929',
            'Thread'                => '2.00',
            'Thread::Queue'         => '1.00',
            'Thread::Semaphore'     => '1.00',
            'Thread::Signal'        => '1.00',
            'Thread::Specific'      => '1.00',
            'Tie::Array'            => '1.02',
            'Tie::File'             => '0.17',
            'Tie::Handle'           => '4.1',
            'Tie::Hash'             => '1.00',
            'Tie::Memoize'          => '1.0',
            'Tie::RefHash'          => '1.3_00',
            'Tie::Scalar'           => '1.00',
            'Tie::SubstrHash'       => '1.00',
            'Time::HiRes'           => '1.20_00',
            'Time::Local'           => '1.04',
            'Time::gmtime'          => '1.02',
            'Time::localtime'       => '1.02',
            'Time::tm'              => '1.00',
            'UNIVERSAL'             => '1.00',
            'Unicode::Collate'      => '0.10',
            'Unicode::Normalize'    => '0.14',
            'Unicode::UCD'          => '0.2',
            'User::grent'           => '1.00',
            'User::pwent'           => '1.00',
            'VMS::DCLsym'           => '1.02',
            'VMS::Filespec'         => '1.1',
            'VMS::Stdio'            => '2.3',
            'XS::Typemap'           => '0.01',
            'attributes'            => '0.04_01',
            'attrs'                 => '1.01',
            'autouse'               => '1.03',
            'base'                  => '1.02',
            'blib'                  => '1.01',
            'bytes'                 => '1.00',
            'charnames'             => '1.01',
            'constant'              => '1.04',
            'diagnostics'           => '1.1',
            'encoding'              => '1.00',
            'fields'                => '1.02',
            'filetest'              => '1.00',
            'if'                    => '0.01',
            'integer'               => '1.00',
            'less'                  => '0.01',
            'locale'                => '1.00',
            'open'                  => '1.01',
            'ops'                   => '1.00',
            'overload'              => '1.00',
            're'                    => '0.03',
            'sort'                  => '1.00',
            'strict'                => '1.02',
            'subs'                  => '1.00',
            'threads'               => '0.05',
            'threads::shared'       => '0.90',
            'utf8'                  => '1.00',
            'vars'                  => '1.01',
            'vmsish'                => '1.00',
            'warnings'              => '1.00',
            'warnings::register'    => '1.00',
        },
        removed => {
        }
    },
    5.008 => {
        delta_from => 5.007003,
        changed => {
            'Attribute::Handlers'   => '0.77',
            'B'                     => '1.01',
            'B::Lint'               => '1.01',
            'B::Xref'               => '1.01',
            'CGI'                   => '2.81',
            'CGI::Carp'             => '1.23',
            'CPAN'                  => '1.61',
            'CPAN::FirstTime'       => '1.56',
            'CPAN::Nox'             => '1.02',
            'Digest::MD5'           => '2.20',
            'Dumpvalue'             => '1.11',
            'Encode'                => '1.75',
            'Encode::Alias'         => '1.32',
            'Encode::Byte'          => '1.22',
            'Encode::CJKConstants'  => '1.00',
            'Encode::CN'            => '1.24',
            'Encode::CN::HZ'        => '1.04',
            'Encode::Config'        => '1.06',
            'Encode::EBCDIC'        => '1.21',
            'Encode::Encoder'       => '0.05',
            'Encode::Encoding'      => '1.30',
            'Encode::Guess'         => '1.06',
            'Encode::JP'            => '1.25',
            'Encode::JP::H2Z'       => '1.02',
            'Encode::JP::JIS7'      => '1.08',
            'Encode::KR'            => '1.22',
            'Encode::KR::2022_KR'   => '1.05',
            'Encode::MIME::Header'  => '1.05',
            'Encode::Symbol'        => '1.22',
            'Encode::TW'            => '1.26',
            'Encode::Unicode'       => '1.37',
            'Exporter::Heavy'       => '5.566',
            'ExtUtils::Command'     => '1.04',
            'ExtUtils::Command::MM' => '0.01',
            'ExtUtils::Constant'    => '0.12',
            'ExtUtils::Installed'   => '0.06',
            'ExtUtils::Liblist'     => '1.00',
            'ExtUtils::Liblist::Kid'=> '1.29',
            'ExtUtils::MM'          => '0.04',
            'ExtUtils::MM_Any'      => '0.04',
            'ExtUtils::MM_BeOS'     => '1.03',
            'ExtUtils::MM_Cygwin'   => '1.04',
            'ExtUtils::MM_DOS'      => '0.01',
            'ExtUtils::MM_MacOS'    => '1.03',
            'ExtUtils::MM_NW5'      => '2.05',
            'ExtUtils::MM_OS2'      => '1.03',
            'ExtUtils::MM_UWIN'     => '0.01',
            'ExtUtils::MM_Unix'     => '1.33',
            'ExtUtils::MM_VMS'      => '5.65',
            'ExtUtils::MM_Win32'    => '1.05',
            'ExtUtils::MM_Win95'    => '0.02',
            'ExtUtils::MY'          => '0.01',
            'ExtUtils::MakeMaker'   => '6.03',
            'ExtUtils::Manifest'    => '1.38',
            'ExtUtils::Mkbootstrap' => '1.15',
            'ExtUtils::Mksymlists'  => '1.19',
            'ExtUtils::testlib'     => '1.15',
            'File::CheckTree'       => '4.2',
            'FileCache'             => '1.021',
            'Filter::Simple'        => '0.78',
            'Getopt::Long'          => '2.32',
            'Hash::Util'            => '0.04',
            'List::Util'            => '1.07_00',
            'Locale::Country'       => '2.04',
            'Math::BigFloat'        => '1.35',
            'Math::BigFloat::Trace' => '0.01',
            'Math::BigInt'          => '1.60',
            'Math::BigInt::Calc'    => '0.30',
            'Math::BigInt::Trace'   => '0.01',
            'Math::BigRat'          => '0.07',
            'Memoize'               => '1.01',
            'Memoize::Expire'       => '1.00',
            'Memoize::ExpireFile'   => '1.01',
            'Net::FTP'              => '2.65',
            'Net::FTP::dataconn'    => '0.11',
            'Net::Ping'             => '2.19',
            'Net::SMTP'             => '2.24',
            'PerlIO'                => '1.01',
            'PerlIO::encoding'      => '0.06',
            'PerlIO::scalar'        => '0.01',
            'PerlIO::via'           => '0.01',
            'PerlIO::via::QuotedPrint'=> '0.04',
            'Pod::Man'              => '1.33',
            'Pod::Text'             => '2.19',
            'Scalar::Util'          => '1.07_00',
            'Storable'              => '2.04',
            'Switch'                => '2.09',
            'Sys::Syslog'           => '0.03',
            'Test'                  => '1.20',
            'Test::Builder'         => '0.15',
            'Test::Harness'         => '2.26',
            'Test::Harness::Straps' => '0.14',
            'Test::More'            => '0.45',
            'Test::Simple'          => '0.45',
            'Thread::Queue'         => '2.00',
            'Thread::Semaphore'     => '2.00',
            'Tie::File'             => '0.93',
            'Tie::RefHash'          => '1.30',
            'Unicode'               => '3.2.0',
            'Unicode::Collate'      => '0.12',
            'Unicode::Normalize'    => '0.17',
            'XS::APItest'           => '0.01',
            'attributes'            => '0.05',
            'base'                  => '1.03',
            'bigint'                => '0.02',
            'bignum'                => '0.11',
            'bigrat'                => '0.04',
            'blib'                  => '1.02',
            'encoding'              => '1.35',
            'sort'                  => '1.01',
            'threads'               => '0.99',
        },
        removed => {
            'Encode::Internal'      => 1,
            'Encode::JP::Constants' => 1,
            'Encode::JP::ISO_2022_JP'=> 1,
            'Encode::JP::JIS'       => 1,
            'Encode::JP::Tr'        => 1,
            'Encode::Tcl'           => 1,
            'Encode::Tcl::Escape'   => 1,
            'Encode::Tcl::Extended' => 1,
            'Encode::Tcl::HanZi'    => 1,
            'Encode::Tcl::Table'    => 1,
            'Encode::XS'            => 1,
            'Encode::iso10646_1'    => 1,
            'Encode::usc2_le'       => 1,
            'Encode::utf8'          => 1,
            'PerlIO::Scalar'        => 1,
            'PerlIO::Via'           => 1,
        }
    },
    5.008001 => {
        delta_from => 5.008,
        changed => {
            'Attribute::Handlers'   => '0.78',
            'AutoLoader'            => '5.60',
            'AutoSplit'             => '1.04',
            'B'                     => '1.02',
            'B::Asmdata'            => '1.01',
            'B::Assembler'          => '0.06',
            'B::Bblock'             => '1.02',
            'B::Bytecode'           => '1.01',
            'B::C'                  => '1.02',
            'B::Concise'            => '0.56',
            'B::Debug'              => '1.01',
            'B::Deparse'            => '0.64',
            'B::Disassembler'       => '1.03',
            'B::Lint'               => '1.02',
            'B::Terse'              => '1.02',
            'Benchmark'             => '1.051',
            'ByteLoader'            => '0.05',
            'CGI'                   => '3.00',
            'CGI::Carp'             => '1.26',
            'CGI::Cookie'           => '1.24',
            'CGI::Fast'             => '1.041',
            'CGI::Pretty'           => '1.07_00',
            'CGI::Util'             => '1.31',
            'CPAN'                  => '1.76_01',
            'CPAN::FirstTime'       => '1.60',
            'CPAN::Nox'             => '1.03',
            'Class::Struct'         => '0.63',
            'Cwd'                   => '2.08',
            'DB_File'               => '1.806',
            'Data::Dumper'          => '2.121',
            'Devel::DProf'          => '20030813.00',
            'Devel::PPPort'         => '2.007',
            'Devel::Peek'           => '1.01',
            'Digest'                => '1.02',
            'Digest::MD5'           => '2.27',
            'Encode'                => '1.9801',
            'Encode::Alias'         => '1.38',
            'Encode::Byte'          => '1.23',
            'Encode::CJKConstants'  => '1.02',
            'Encode::CN::HZ'        => '1.05',
            'Encode::Config'        => '1.07',
            'Encode::Encoder'       => '0.07',
            'Encode::Encoding'      => '1.33',
            'Encode::Guess'         => '1.09',
            'Encode::JP::JIS7'      => '1.12',
            'Encode::KR'            => '1.23',
            'Encode::KR::2022_KR'   => '1.06',
            'Encode::MIME::Header'  => '1.09',
            'Encode::Unicode'       => '1.40',
            'Encode::Unicode::UTF7' => '0.02',
            'English'               => '1.01',
            'Errno'                 => '1.09_00',
            'Exporter'              => '5.567',
            'Exporter::Heavy'       => '5.567',
            'ExtUtils::Command'     => '1.05',
            'ExtUtils::Command::MM' => '0.03',
            'ExtUtils::Constant'    => '0.14',
            'ExtUtils::Install'     => '1.32',
            'ExtUtils::Installed'   => '0.08',
            'ExtUtils::Liblist'     => '1.01',
            'ExtUtils::Liblist::Kid'=> '1.3',
            'ExtUtils::MM_Any'      => '0.07',
            'ExtUtils::MM_BeOS'     => '1.04',
            'ExtUtils::MM_Cygwin'   => '1.06',
            'ExtUtils::MM_DOS'      => '0.02',
            'ExtUtils::MM_MacOS'    => '1.07',
            'ExtUtils::MM_NW5'      => '2.06',
            'ExtUtils::MM_OS2'      => '1.04',
            'ExtUtils::MM_UWIN'     => '0.02',
            'ExtUtils::MM_Unix'     => '1.42',
            'ExtUtils::MM_VMS'      => '5.70',
            'ExtUtils::MM_Win32'    => '1.09',
            'ExtUtils::MM_Win95'    => '0.03',
            'ExtUtils::MakeMaker'   => '6.17',
            'ExtUtils::MakeMaker::bytes'=> '0.01',
            'ExtUtils::MakeMaker::vmsish'=> '0.01',
            'ExtUtils::Manifest'    => '1.42',
            'Fcntl'                 => '1.05',
            'File::Basename'        => '2.72',
            'File::Copy'            => '2.06',
            'File::Find'            => '1.05',
            'File::Glob'            => '1.02',
            'File::Path'            => '1.06',
            'File::Spec'            => '0.86',
            'File::Spec::Cygwin'    => '1.1',
            'File::Spec::Epoc'      => '1.1',
            'File::Spec::Functions' => '1.3',
            'File::Spec::Mac'       => '1.4',
            'File::Spec::OS2'       => '1.2',
            'File::Spec::Unix'      => '1.5',
            'File::Spec::VMS'       => '1.4',
            'File::Spec::Win32'     => '1.4',
            'File::Temp'            => '0.14',
            'FileCache'             => '1.03',
            'Filter::Util::Call'    => '1.0601',
            'GDBM_File'             => '1.07',
            'Getopt::Long'          => '2.34',
            'Getopt::Std'           => '1.04',
            'Hash::Util'            => '0.05',
            'I18N::LangTags'        => '0.28',
            'I18N::LangTags::List'  => '0.26',
            'I18N::Langinfo'        => '0.02',
            'IO'                    => '1.21',
            'IO::Dir'               => '1.04',
            'IO::File'              => '1.10',
            'IO::Handle'            => '1.23',
            'IO::Seekable'          => '1.09',
            'IO::Select'            => '1.16',
            'IO::Socket'            => '1.28',
            'IO::Socket::INET'      => '1.27',
            'IO::Socket::UNIX'      => '1.21',
            'IPC::Msg'              => '1.02',
            'IPC::Open3'            => '1.0105',
            'IPC::Semaphore'        => '1.02',
            'IPC::SysV'             => '1.04',
            'JNI'                   => '0.2',
            'List::Util'            => '1.13',
            'Locale::Country'       => '2.61',
            'Locale::Currency'      => '2.21',
            'Locale::Language'      => '2.21',
            'Locale::Maketext'      => '1.06',
            'Locale::Maketext::Guts'=> undef,
            'Locale::Maketext::GutsLoader'=> undef,
            'Locale::Script'        => '2.21',
            'MIME::Base64'          => '2.20',
            'MIME::QuotedPrint'     => '2.20',
            'Math::BigFloat'        => '1.40',
            'Math::BigInt'          => '1.66',
            'Math::BigInt::Calc'    => '0.36',
            'Math::BigInt::Scalar'  => '0.11',
            'Math::BigRat'          => '0.10',
            'Math::Trig'            => '1.02',
            'NDBM_File'             => '1.05',
            'NEXT'                  => '0.60',
            'Net::Cmd'              => '2.24',
            'Net::Domain'           => '2.18',
            'Net::FTP'              => '2.71',
            'Net::FTP::A'           => '1.16',
            'Net::NNTP'             => '2.22',
            'Net::POP3'             => '2.24',
            'Net::Ping'             => '2.31',
            'Net::SMTP'             => '2.26',
            'Net::hostent'          => '1.01',
            'Net::servent'          => '1.01',
            'ODBM_File'             => '1.04',
            'OS2::DLL'              => '1.01',
            'OS2::ExtAttr'          => '0.02',
            'OS2::PrfDB'            => '0.03',
            'OS2::Process'          => '1.01',
            'OS2::REXX'             => '1.02',
            'POSIX'                 => '1.06',
            'PerlIO'                => '1.02',
            'PerlIO::encoding'      => '0.07',
            'PerlIO::scalar'        => '0.02',
            'PerlIO::via'           => '0.02',
            'PerlIO::via::QuotedPrint'=> '0.05',
            'Pod::Checker'          => '1.41',
            'Pod::Find'             => '0.24',
            'Pod::Functions'        => '1.02',
            'Pod::Html'             => '1.0501',
            'Pod::InputObjects'     => '1.14',
            'Pod::LaTeX'            => '0.55',
            'Pod::Man'              => '1.37',
            'Pod::ParseLink'        => '1.06',
            'Pod::ParseUtils'       => '0.3',
            'Pod::Perldoc'          => '3.10',
            'Pod::Perldoc::BaseTo'  => undef,
            'Pod::Perldoc::GetOptsOO'=> undef,
            'Pod::Perldoc::ToChecker'=> undef,
            'Pod::Perldoc::ToMan'   => undef,
            'Pod::Perldoc::ToNroff' => undef,
            'Pod::Perldoc::ToPod'   => undef,
            'Pod::Perldoc::ToRtf'   => undef,
            'Pod::Perldoc::ToText'  => undef,
            'Pod::Perldoc::ToTk'    => undef,
            'Pod::Perldoc::ToXml'   => undef,
            'Pod::PlainText'        => '2.01',
            'Pod::Text'             => '2.21',
            'Pod::Text::Color'      => '1.04',
            'Pod::Text::Overstrike' => '1.1',
            'Pod::Text::Termcap'    => '1.11',
            'Pod::Usage'            => '1.16',
            'SDBM_File'             => '1.04',
            'Safe'                  => '2.10',
            'Scalar::Util'          => '1.13',
            'SelfLoader'            => '1.0904',
            'Shell'                 => '0.5',
            'Socket'                => '1.76',
            'Storable'              => '2.08',
            'Switch'                => '2.10',
            'Symbol'                => '1.05',
            'Sys::Hostname'         => '1.11',
            'Sys::Syslog'           => '0.04',
            'Term::ANSIColor'       => '1.07',
            'Term::Cap'             => '1.08',
            'Term::Complete'        => '1.401',
            'Term::ReadLine'        => '1.01',
            'Test'                  => '1.24',
            'Test::Builder'         => '0.17',
            'Test::Harness'         => '2.30',
            'Test::Harness::Straps' => '0.15',
            'Test::More'            => '0.47',
            'Test::Simple'          => '0.47',
            'Text::Abbrev'          => '1.01',
            'Text::Balanced'        => '1.95',
            'Text::Wrap'            => '2001.09291',
            'Thread::Semaphore'     => '2.01',
            'Tie::Array'            => '1.03',
            'Tie::File'             => '0.97',
            'Tie::RefHash'          => '1.31',
            'Time::HiRes'           => '1.51',
            'Time::Local'           => '1.07',
            'UNIVERSAL'             => '1.01',
            'Unicode'               => '4.0.0',
            'Unicode::Collate'      => '0.28',
            'Unicode::Normalize'    => '0.23',
            'Unicode::UCD'          => '0.21',
            'VMS::Filespec'         => '1.11',
            'XS::APItest'           => '0.02',
            'XSLoader'              => '0.02',
            'attributes'            => '0.06',
            'base'                  => '2.03',
            'bigint'                => '0.04',
            'bignum'                => '0.14',
            'bigrat'                => '0.06',
            'bytes'                 => '1.01',
            'charnames'             => '1.02',
            'diagnostics'           => '1.11',
            'encoding'              => '1.47',
            'fields'                => '2.03',
            'filetest'              => '1.01',
            'if'                    => '0.03',
            'lib'                   => '0.5565',
            'open'                  => '1.02',
            'overload'              => '1.01',
            're'                    => '0.04',
            'sort'                  => '1.02',
            'strict'                => '1.03',
            'threads'               => '1.00',
            'threads::shared'       => '0.91',
            'utf8'                  => '1.02',
            'vmsish'                => '1.01',
            'warnings'              => '1.03',
        },
        removed => {
        }
    },
    5.008002 => {
        delta_from => 5.008001,
        changed => {
            'DB_File'               => '1.807',
            'Devel::PPPort'         => '2.009',
            'Digest::MD5'           => '2.30',
            'I18N::LangTags'        => '0.29',
            'I18N::LangTags::List'  => '0.29',
            'MIME::Base64'          => '2.21',
            'MIME::QuotedPrint'     => '2.21',
            'Net::Domain'           => '2.19',
            'Net::FTP'              => '2.72',
            'Pod::Perldoc'          => '3.11',
            'Time::HiRes'           => '1.52',
            'Unicode::Collate'      => '0.30',
            'Unicode::Normalize'    => '0.25',
        },
        removed => {
        }
    },
    5.008003 => {
        delta_from => 5.008002,
        changed => {
            'Benchmark'             => '1.052',
            'CGI'                   => '3.01',
            'CGI::Carp'             => '1.27',
            'CGI::Fast'             => '1.05',
            'CGI::Pretty'           => '1.08',
            'CGI::Util'             => '1.4',
            'Cwd'                   => '2.12',
            'DB_File'               => '1.808',
            'Devel::PPPort'         => '2.011',
            'Digest'                => '1.05',
            'Digest::MD5'           => '2.33',
            'Digest::base'          => '1.00',
            'Encode'                => '1.99',
            'Exporter'              => '5.57',
            'File::CheckTree'       => '4.3',
            'File::Copy'            => '2.07',
            'File::Find'            => '1.06',
            'File::Spec'            => '0.87',
            'FindBin'               => '1.44',
            'Getopt::Std'           => '1.05',
            'Math::BigFloat'        => '1.42',
            'Math::BigInt'          => '1.68',
            'Math::BigInt::Calc'    => '0.38',
            'Math::BigInt::CalcEmu' => '0.02',
            'OS2::DLL'              => '1.02',
            'POSIX'                 => '1.07',
            'PerlIO'                => '1.03',
            'PerlIO::via::QuotedPrint'=> '0.06',
            'Pod::Html'             => '1.0502',
            'Pod::Parser'           => '1.14',
            'Pod::Perldoc'          => '3.12',
            'Pod::PlainText'        => '2.02',
            'Storable'              => '2.09',
            'Test::Harness'         => '2.40',
            'Test::Harness::Assert' => '0.02',
            'Test::Harness::Iterator'=> '0.02',
            'Test::Harness::Straps' => '0.19',
            'Tie::Hash'             => '1.01',
            'Unicode::Collate'      => '0.33',
            'Unicode::Normalize'    => '0.28',
            'XS::APItest'           => '0.03',
            'base'                  => '2.04',
            'diagnostics'           => '1.12',
            'encoding'              => '1.48',
            'threads'               => '1.01',
            'threads::shared'       => '0.92',
        },
        removed => {
            'Math::BigInt::Scalar'  => 1,
        }
    },
    5.008004 => {
        delta_from => 5.008003,
        changed => {
            'Attribute::Handlers'   => '0.78_01',
            'B::Assembler'          => '0.07',
            'B::Concise'            => '0.60',
            'B::Deparse'            => '0.66',
            'Benchmark'             => '1.06',
            'CGI'                   => '3.04',
            'Carp'                  => '1.02',
            'Cwd'                   => '2.17',
            'DBM_Filter'            => '0.01',
            'DBM_Filter::compress'  => '0.01',
            'DBM_Filter::encode'    => '0.01',
            'DBM_Filter::int32'     => '0.01',
            'DBM_Filter::null'      => '0.01',
            'DBM_Filter::utf8'      => '0.01',
            'Digest'                => '1.06',
            'DynaLoader'            => '1.05',
            'Encode'                => '1.99_01',
            'Encode::CN::HZ'        => '1.0501',
            'Exporter'              => '5.58',
            'Exporter::Heavy'       => '5.57',
            'ExtUtils::Liblist::Kid'=> '1.3001',
            'ExtUtils::MM_NW5'      => '2.07_02',
            'ExtUtils::MM_Win95'    => '0.0301',
            'File::Find'            => '1.07',
            'IO::Handle'            => '1.24',
            'IO::Pipe'              => '1.123',
            'IPC::Open3'            => '1.0106',
            'Locale::Maketext'      => '1.08',
            'MIME::Base64'          => '3.01',
            'MIME::QuotedPrint'     => '3.01',
            'Math::BigFloat'        => '1.44',
            'Math::BigInt'          => '1.70',
            'Math::BigInt::Calc'    => '0.40',
            'Math::BigInt::CalcEmu' => '0.04',
            'Math::BigRat'          => '0.12',
            'ODBM_File'             => '1.05',
            'POSIX'                 => '1.08',
            'Shell'                 => '0.5.2',
            'Socket'                => '1.77',
            'Storable'              => '2.12',
            'Sys::Syslog'           => '0.05',
            'Term::ANSIColor'       => '1.08',
            'Time::HiRes'           => '1.59',
            'Unicode'               => '4.0.1',
            'Unicode::UCD'          => '0.22',
            'Win32'                 => '0.23',
            'base'                  => '2.05',
            'bigint'                => '0.05',
            'bignum'                => '0.15',
            'charnames'             => '1.03',
            'open'                  => '1.03',
            'threads'               => '1.03',
            'utf8'                  => '1.03',
        },
        removed => {
        }
    },
    5.008005 => {
        delta_from => 5.008004,
        changed => {
            'B::Concise'            => '0.61',
            'B::Deparse'            => '0.67',
            'CGI'                   => '3.05',
            'CGI::Carp'             => '1.28',
            'CGI::Util'             => '1.5',
            'Carp'                  => '1.03',
            'Carp::Heavy'           => '1.03',
            'Cwd'                   => '2.19',
            'DB_File'               => '1.809',
            'Digest'                => '1.08',
            'Encode'                => '2.01',
            'Encode::Alias'         => '2.00',
            'Encode::Byte'          => '2.00',
            'Encode::CJKConstants'  => '2.00',
            'Encode::CN'            => '2.00',
            'Encode::CN::HZ'        => '2.01',
            'Encode::Config'        => '2.00',
            'Encode::EBCDIC'        => '2.00',
            'Encode::Encoder'       => '2.00',
            'Encode::Encoding'      => '2.00',
            'Encode::Guess'         => '2.00',
            'Encode::JP'            => '2.00',
            'Encode::JP::H2Z'       => '2.00',
            'Encode::JP::JIS7'      => '2.00',
            'Encode::KR'            => '2.00',
            'Encode::KR::2022_KR'   => '2.00',
            'Encode::MIME::Header'  => '2.00',
            'Encode::Symbol'        => '2.00',
            'Encode::TW'            => '2.00',
            'Encode::Unicode'       => '2.00',
            'Encode::Unicode::UTF7' => '2.01',
            'File::Basename'        => '2.73',
            'File::Copy'            => '2.08',
            'File::Glob'            => '1.03',
            'FileCache'             => '1.04_01',
            'I18N::LangTags'        => '0.33',
            'I18N::LangTags::Detect'=> '1.03',
            'List::Util'            => '1.14',
            'Locale::Constants'     => '2.07',
            'Locale::Country'       => '2.07',
            'Locale::Currency'      => '2.07',
            'Locale::Language'      => '2.07',
            'Locale::Maketext'      => '1.09',
            'Locale::Script'        => '2.07',
            'Net::Cmd'              => '2.26',
            'Net::FTP'              => '2.75',
            'Net::NNTP'             => '2.23',
            'Net::POP3'             => '2.28',
            'Net::SMTP'             => '2.29',
            'Net::Time'             => '2.10',
            'Pod::Checker'          => '1.42',
            'Pod::Find'             => '0.2401',
            'Pod::LaTeX'            => '0.56',
            'Pod::ParseUtils'       => '1.2',
            'Pod::Perldoc'          => '3.13',
            'Safe'                  => '2.11',
            'Scalar::Util'          => '1.14',
            'Shell'                 => '0.6',
            'Storable'              => '2.13',
            'Term::Cap'             => '1.09',
            'Test'                  => '1.25',
            'Test::Harness'         => '2.42',
            'Text::ParseWords'      => '3.22',
            'Text::Wrap'            => '2001.09292',
            'Time::Local'           => '1.10',
            'Unicode::Collate'      => '0.40',
            'Unicode::Normalize'    => '0.30',
            'XS::APItest'           => '0.04',
            'autouse'               => '1.04',
            'base'                  => '2.06',
            'charnames'             => '1.04',
            'diagnostics'           => '1.13',
            'encoding'              => '2.00',
            'threads'               => '1.05',
            'utf8'                  => '1.04',
        },
        removed => {
        }
    },
    5.008006 => {
        delta_from => 5.008005,
        changed => {
            'B'                     => '1.07',
            'B::C'                  => '1.04',
            'B::Concise'            => '0.64',
            'B::Debug'              => '1.02',
            'B::Deparse'            => '0.69',
            'B::Lint'               => '1.03',
            'B::Showlex'            => '1.02',
            'Cwd'                   => '3.01',
            'DB_File'               => '1.810',
            'Data::Dumper'          => '2.121_02',
            'Devel::PPPort'         => '3.03',
            'Devel::Peek'           => '1.02',
            'Encode'                => '2.08',
            'Encode::Alias'         => '2.02',
            'Encode::Encoding'      => '2.02',
            'Encode::JP'            => '2.01',
            'Encode::Unicode'       => '2.02',
            'Exporter::Heavy'       => '5.58',
            'ExtUtils::Constant'    => '0.1401',
            'File::Spec'            => '3.01',
            'File::Spec::Win32'     => '1.5',
            'I18N::LangTags'        => '0.35',
            'I18N::LangTags::List'  => '0.35',
            'MIME::Base64'          => '3.05',
            'MIME::QuotedPrint'     => '3.03',
            'Math::BigFloat'        => '1.47',
            'Math::BigInt'          => '1.73',
            'Math::BigInt::Calc'    => '0.43',
            'Math::BigRat'          => '0.13',
            'Text::ParseWords'      => '3.23',
            'Time::HiRes'           => '1.65',
            'XS::APItest'           => '0.05',
            'diagnostics'           => '1.14',
            'encoding'              => '2.01',
            'open'                  => '1.04',
            'overload'              => '1.02',
        },
        removed => {
        }
    },
    5.008007 => {
        delta_from => 5.008006,
        changed => {
            'B'                     => '1.09',
            'B::Concise'            => '0.65',
            'B::Deparse'            => '0.7',
            'B::Disassembler'       => '1.04',
            'B::Terse'              => '1.03',
            'Benchmark'             => '1.07',
            'CGI'                   => '3.10',
            'CGI::Carp'             => '1.29',
            'CGI::Cookie'           => '1.25',
            'Carp'                  => '1.04',
            'Carp::Heavy'           => '1.04',
            'Class::ISA'            => '0.33',
            'Cwd'                   => '3.05',
            'DB_File'               => '1.811',
            'Data::Dumper'          => '2.121_04',
            'Devel::DProf'          => '20050310.00',
            'Devel::PPPort'         => '3.06',
            'Digest'                => '1.10',
            'Digest::file'          => '0.01',
            'Encode'                => '2.10',
            'Encode::Alias'         => '2.03',
            'Errno'                 => '1.09_01',
            'ExtUtils::Constant'    => '0.16',
            'ExtUtils::Constant::Base'=> '0.01',
            'ExtUtils::Constant::Utils'=> '0.01',
            'ExtUtils::Constant::XS'=> '0.01',
            'File::Find'            => '1.09',
            'File::Glob'            => '1.04',
            'File::Path'            => '1.07',
            'File::Spec'            => '3.05',
            'File::Temp'            => '0.16',
            'FileCache'             => '1.05',
            'IO::File'              => '1.11',
            'IO::Socket::INET'      => '1.28',
            'Math::BigFloat'        => '1.51',
            'Math::BigInt'          => '1.77',
            'Math::BigInt::Calc'    => '0.47',
            'Math::BigInt::CalcEmu' => '0.05',
            'Math::BigRat'          => '0.15',
            'Pod::Find'             => '1.3',
            'Pod::Html'             => '1.0503',
            'Pod::InputObjects'     => '1.3',
            'Pod::LaTeX'            => '0.58',
            'Pod::ParseUtils'       => '1.3',
            'Pod::Parser'           => '1.3',
            'Pod::Perldoc'          => '3.14',
            'Pod::Select'           => '1.3',
            'Pod::Usage'            => '1.3',
            'SelectSaver'           => '1.01',
            'Symbol'                => '1.06',
            'Sys::Syslog'           => '0.06',
            'Term::ANSIColor'       => '1.09',
            'Term::Complete'        => '1.402',
            'Test::Builder'         => '0.22',
            'Test::Harness'         => '2.48',
            'Test::Harness::Point'  => '0.01',
            'Test::Harness::Straps' => '0.23',
            'Test::More'            => '0.54',
            'Test::Simple'          => '0.54',
            'Text::ParseWords'      => '3.24',
            'Text::Wrap'            => '2001.09293',
            'Tie::RefHash'          => '1.32',
            'Time::HiRes'           => '1.66',
            'Time::Local'           => '1.11',
            'Unicode'               => '4.1.0',
            'Unicode::Normalize'    => '0.32',
            'Unicode::UCD'          => '0.23',
            'Win32'                 => '0.24',
            'XS::APItest'           => '0.06',
            'base'                  => '2.07',
            'bigint'                => '0.07',
            'bignum'                => '0.17',
            'bigrat'                => '0.08',
            'bytes'                 => '1.02',
            'constant'              => '1.05',
            'overload'              => '1.03',
            'threads::shared'       => '0.93',
            'utf8'                  => '1.05',
        },
        removed => {
            'JNI'                   => 1,
            'JPL::AutoLoader'       => 1,
            'JPL::Class'            => 1,
            'JPL::Compile'          => 1,
        }
    },
    5.008008 => {
        delta_from => 5.008007,
        changed => {
            'Attribute::Handlers'   => '0.78_02',
            'B'                     => '1.09_01',
            'B::Bblock'             => '1.02_01',
            'B::Bytecode'           => '1.01_01',
            'B::C'                  => '1.04_01',
            'B::CC'                 => '1.00_01',
            'B::Concise'            => '0.66',
            'B::Debug'              => '1.02_01',
            'B::Deparse'            => '0.71',
            'B::Disassembler'       => '1.05',
            'B::Terse'              => '1.03_01',
            'ByteLoader'            => '0.06',
            'CGI'                   => '3.15',
            'CGI::Cookie'           => '1.26',
            'CPAN'                  => '1.76_02',
            'Cwd'                   => '3.12',
            'DB'                    => '1.01',
            'DB_File'               => '1.814',
            'Data::Dumper'          => '2.121_08',
            'Devel::DProf'          => '20050603.00',
            'Devel::PPPort'         => '3.06_01',
            'Devel::Peek'           => '1.03',
            'Digest'                => '1.14',
            'Digest::MD5'           => '2.36',
            'Digest::file'          => '1.00',
            'Dumpvalue'             => '1.12',
            'Encode'                => '2.12',
            'Encode::Alias'         => '2.04',
            'Encode::Config'        => '2.01',
            'Encode::MIME::Header'  => '2.01',
            'Encode::MIME::Header::ISO_2022_JP'=> '1.01',
            'English'               => '1.02',
            'ExtUtils::Command'     => '1.09',
            'ExtUtils::Command::MM' => '0.05',
            'ExtUtils::Constant'    => '0.17',
            'ExtUtils::Embed'       => '1.26',
            'ExtUtils::Install'     => '1.33',
            'ExtUtils::Liblist::Kid'=> '1.3',
            'ExtUtils::MM'          => '0.05',
            'ExtUtils::MM_AIX'      => '0.03',
            'ExtUtils::MM_Any'      => '0.13',
            'ExtUtils::MM_BeOS'     => '1.05',
            'ExtUtils::MM_Cygwin'   => '1.08',
            'ExtUtils::MM_MacOS'    => '1.08',
            'ExtUtils::MM_NW5'      => '2.08',
            'ExtUtils::MM_OS2'      => '1.05',
            'ExtUtils::MM_QNX'      => '0.02',
            'ExtUtils::MM_Unix'     => '1.50',
            'ExtUtils::MM_VMS'      => '5.73',
            'ExtUtils::MM_VOS'      => '0.02',
            'ExtUtils::MM_Win32'    => '1.12',
            'ExtUtils::MM_Win95'    => '0.04',
            'ExtUtils::MakeMaker'   => '6.30',
            'ExtUtils::MakeMaker::Config'=> '0.02',
            'ExtUtils::Manifest'    => '1.46',
            'File::Basename'        => '2.74',
            'File::Copy'            => '2.09',
            'File::Find'            => '1.10',
            'File::Glob'            => '1.05',
            'File::Path'            => '1.08',
            'File::Spec'            => '3.12',
            'File::Spec::Win32'     => '1.6',
            'FileCache'             => '1.06',
            'Filter::Simple'        => '0.82',
            'FindBin'               => '1.47',
            'GDBM_File'             => '1.08',
            'Getopt::Long'          => '2.35',
            'IO'                    => '1.22',
            'IO::Dir'               => '1.05',
            'IO::File'              => '1.13',
            'IO::Handle'            => '1.25',
            'IO::Pipe'              => '1.13',
            'IO::Poll'              => '0.07',
            'IO::Seekable'          => '1.10',
            'IO::Select'            => '1.17',
            'IO::Socket'            => '1.29',
            'IO::Socket::INET'      => '1.29',
            'IO::Socket::UNIX'      => '1.22',
            'IPC::Open2'            => '1.02',
            'IPC::Open3'            => '1.02',
            'List::Util'            => '1.18',
            'MIME::Base64'          => '3.07',
            'MIME::QuotedPrint'     => '3.07',
            'Math::Complex'         => '1.35',
            'Math::Trig'            => '1.03',
            'NDBM_File'             => '1.06',
            'ODBM_File'             => '1.06',
            'OS2::PrfDB'            => '0.04',
            'OS2::Process'          => '1.02',
            'OS2::REXX'             => '1.03',
            'Opcode'                => '1.06',
            'POSIX'                 => '1.09',
            'PerlIO'                => '1.04',
            'PerlIO::encoding'      => '0.09',
            'PerlIO::scalar'        => '0.04',
            'PerlIO::via'           => '0.03',
            'Pod::Checker'          => '1.43',
            'Pod::Find'             => '1.34',
            'Pod::Functions'        => '1.03',
            'Pod::Html'             => '1.0504',
            'Pod::ParseUtils'       => '1.33',
            'Pod::Parser'           => '1.32',
            'Pod::Usage'            => '1.33',
            'SDBM_File'             => '1.05',
            'Safe'                  => '2.12',
            'Scalar::Util'          => '1.18',
            'Socket'                => '1.78',
            'Storable'              => '2.15',
            'Switch'                => '2.10_01',
            'Sys::Syslog'           => '0.13',
            'Term::ANSIColor'       => '1.10',
            'Term::ReadLine'        => '1.02',
            'Test::Builder'         => '0.32',
            'Test::Builder::Module' => '0.02',
            'Test::Builder::Tester' => '1.02',
            'Test::Builder::Tester::Color'=> undef,
            'Test::Harness'         => '2.56',
            'Test::Harness::Straps' => '0.26',
            'Test::More'            => '0.62',
            'Test::Simple'          => '0.62',
            'Text::Tabs'            => '2005.0824',
            'Text::Wrap'            => '2005.082401',
            'Tie::Hash'             => '1.02',
            'Time::HiRes'           => '1.86',
            'Unicode::Collate'      => '0.52',
            'Unicode::UCD'          => '0.24',
            'User::grent'           => '1.01',
            'Win32'                 => '0.2601',
            'XS::APItest'           => '0.08',
            'XS::Typemap'           => '0.02',
            'XSLoader'              => '0.06',
            'attrs'                 => '1.02',
            'autouse'               => '1.05',
            'blib'                  => '1.03',
            'charnames'             => '1.05',
            'diagnostics'           => '1.15',
            'encoding'              => '2.02',
            'if'                    => '0.05',
            'open'                  => '1.05',
            'ops'                   => '1.01',
            'overload'              => '1.04',
            're'                    => '0.05',
            'threads'               => '1.07',
            'threads::shared'       => '0.94',
            'utf8'                  => '1.06',
            'vmsish'                => '1.02',
            'warnings'              => '1.05',
            'warnings::register'    => '1.01',
        },
        removed => {
        }
    },
    5.008009 => {
        delta_from => 5.008008,
        changed => {
            'Attribute::Handlers'   => '0.78_03',
            'AutoLoader'            => '5.67',
            'AutoSplit'             => '1.06',
            'B'                     => '1.19',
            'B::Asmdata'            => '1.02',
            'B::Assembler'          => '0.08',
            'B::C'                  => '1.05',
            'B::Concise'            => '0.76',
            'B::Debug'              => '1.05',
            'B::Deparse'            => '0.87',
            'B::Lint'               => '1.11',
            'B::Lint::Debug'        => undef,
            'B::Terse'              => '1.05',
            'Benchmark'             => '1.1',
            'CGI'                   => '3.42',
            'CGI::Carp'             => '1.30_01',
            'CGI::Cookie'           => '1.29',
            'CGI::Fast'             => '1.07',
            'CGI::Util'             => '1.5_01',
            'CPAN'                  => '1.9301',
            'CPAN::Debug'           => '5.5',
            'CPAN::DeferedCode'     => '5.50',
            'CPAN::Distroprefs'     => '6',
            'CPAN::FirstTime'       => '5.5_01',
            'CPAN::HandleConfig'    => '5.5',
            'CPAN::Kwalify'         => '5.50',
            'CPAN::Nox'             => '5.50',
            'CPAN::Queue'           => '5.5',
            'CPAN::Tarzip'          => '5.5',
            'CPAN::Version'         => '5.5',
            'Carp'                  => '1.10',
            'Carp::Heavy'           => '1.10',
            'Cwd'                   => '3.29',
            'DBM_Filter'            => '0.02',
            'DBM_Filter::compress'  => '0.02',
            'DBM_Filter::encode'    => '0.02',
            'DBM_Filter::int32'     => '0.02',
            'DBM_Filter::null'      => '0.02',
            'DBM_Filter::utf8'      => '0.02',
            'DB_File'               => '1.817',
            'Data::Dumper'          => '2.121_17',
            'Devel::DProf'          => '20080331.00',
            'Devel::InnerPackage'   => '0.3',
            'Devel::PPPort'         => '3.14',
            'Devel::Peek'           => '1.04',
            'Digest'                => '1.15',
            'Digest::MD5'           => '2.37',
            'DirHandle'             => '1.02',
            'DynaLoader'            => '1.09',
            'Encode'                => '2.26',
            'Encode::Alias'         => '2.10',
            'Encode::Byte'          => '2.03',
            'Encode::CJKConstants'  => '2.02',
            'Encode::CN'            => '2.02',
            'Encode::CN::HZ'        => '2.05',
            'Encode::Config'        => '2.05',
            'Encode::EBCDIC'        => '2.02',
            'Encode::Encoder'       => '2.01',
            'Encode::Encoding'      => '2.05',
            'Encode::GSM0338'       => '2.01',
            'Encode::Guess'         => '2.02',
            'Encode::JP'            => '2.03',
            'Encode::JP::H2Z'       => '2.02',
            'Encode::JP::JIS7'      => '2.04',
            'Encode::KR'            => '2.02',
            'Encode::KR::2022_KR'   => '2.02',
            'Encode::MIME::Header'  => '2.05',
            'Encode::MIME::Header::ISO_2022_JP'=> '1.03',
            'Encode::MIME::Name'    => '1.01',
            'Encode::Symbol'        => '2.02',
            'Encode::TW'            => '2.02',
            'Encode::Unicode'       => '2.05',
            'Encode::Unicode::UTF7' => '2.04',
            'English'               => '1.03',
            'Errno'                 => '1.10',
            'Exporter'              => '5.63',
            'Exporter::Heavy'       => '5.63',
            'ExtUtils::Command'     => '1.15',
            'ExtUtils::Command::MM' => '6.48',
            'ExtUtils::Constant'    => '0.21',
            'ExtUtils::Constant::Base'=> '0.04',
            'ExtUtils::Constant::ProxySubs'=> '0.06',
            'ExtUtils::Constant::Utils'=> '0.02',
            'ExtUtils::Constant::XS'=> '0.02',
            'ExtUtils::Embed'       => '1.28',
            'ExtUtils::Install'     => '1.50_01',
            'ExtUtils::Installed'   => '1.43',
            'ExtUtils::Liblist'     => '6.48',
            'ExtUtils::Liblist::Kid'=> '6.48',
            'ExtUtils::MM'          => '6.48',
            'ExtUtils::MM_AIX'      => '6.48',
            'ExtUtils::MM_Any'      => '6.48',
            'ExtUtils::MM_BeOS'     => '6.48',
            'ExtUtils::MM_Cygwin'   => '6.48',
            'ExtUtils::MM_DOS'      => '6.48',
            'ExtUtils::MM_Darwin'   => '6.48',
            'ExtUtils::MM_MacOS'    => '6.48',
            'ExtUtils::MM_NW5'      => '6.48',
            'ExtUtils::MM_OS2'      => '6.48',
            'ExtUtils::MM_QNX'      => '6.48',
            'ExtUtils::MM_UWIN'     => '6.48',
            'ExtUtils::MM_Unix'     => '6.48',
            'ExtUtils::MM_VMS'      => '6.48',
            'ExtUtils::MM_VOS'      => '6.48',
            'ExtUtils::MM_Win32'    => '6.48',
            'ExtUtils::MM_Win95'    => '6.48',
            'ExtUtils::MY'          => '6.48',
            'ExtUtils::MakeMaker'   => '6.48',
            'ExtUtils::MakeMaker::Config'=> '6.48',
            'ExtUtils::MakeMaker::bytes'=> '6.48',
            'ExtUtils::MakeMaker::vmsish'=> '6.48',
            'ExtUtils::Manifest'    => '1.55',
            'ExtUtils::Mkbootstrap' => '6.48',
            'ExtUtils::Mksymlists'  => '6.48',
            'ExtUtils::Packlist'    => '1.43',
            'ExtUtils::ParseXS'     => '2.19',
            'ExtUtils::XSSymSet'    => '1.1',
            'ExtUtils::testlib'     => '6.48',
            'Fatal'                 => '1.06',
            'Fcntl'                 => '1.06',
            'File::Basename'        => '2.77',
            'File::CheckTree'       => '4.4',
            'File::Compare'         => '1.1005',
            'File::Copy'            => '2.13',
            'File::DosGlob'         => '1.01',
            'File::Find'            => '1.13',
            'File::Glob'            => '1.06',
            'File::Path'            => '2.07_02',
            'File::Spec'            => '3.29',
            'File::Spec::Cygwin'    => '3.29',
            'File::Spec::Epoc'      => '3.29',
            'File::Spec::Functions' => '3.29',
            'File::Spec::Mac'       => '3.29',
            'File::Spec::OS2'       => '3.29',
            'File::Spec::Unix'      => '3.29',
            'File::Spec::VMS'       => '3.29',
            'File::Spec::Win32'     => '3.29',
            'File::Temp'            => '0.20',
            'File::stat'            => '1.01',
            'FileCache'             => '1.07',
            'Filter::Simple'        => '0.83',
            'Filter::Util::Call'    => '1.07',
            'FindBin'               => '1.49',
            'GDBM_File'             => '1.09',
            'Getopt::Long'          => '2.37',
            'Getopt::Std'           => '1.06',
            'Hash::Util'            => '0.06',
            'IO'                    => '1.23',
            'IO::Dir'               => '1.06',
            'IO::File'              => '1.14',
            'IO::Handle'            => '1.27',
            'IO::Socket'            => '1.30',
            'IO::Socket::INET'      => '1.31',
            'IO::Socket::UNIX'      => '1.23',
            'IPC::Msg'              => '2.00',
            'IPC::Open2'            => '1.03',
            'IPC::Open3'            => '1.03',
            'IPC::Semaphore'        => '2.00',
            'IPC::SharedMem'        => '2.00',
            'IPC::SysV'             => '2.00',
            'List::Util'            => '1.19',
            'Locale::Maketext'      => '1.13',
            'Locale::Maketext::Guts'=> '1.13',
            'Locale::Maketext::GutsLoader'=> '1.13',
            'Math::BigFloat'        => '1.60',
            'Math::BigInt'          => '1.89',
            'Math::BigInt::Calc'    => '0.52',
            'Math::BigRat'          => '0.22',
            'Math::Complex'         => '1.54',
            'Math::Trig'            => '1.18',
            'Module::CoreList'      => '2.17',
            'Module::Pluggable'     => '3.8',
            'Module::Pluggable::Object'=> '3.6',
            'NDBM_File'             => '1.07',
            'NEXT'                  => '0.61',
            'Net::Cmd'              => '2.29',
            'Net::Config'           => '1.11',
            'Net::Domain'           => '2.20',
            'Net::FTP'              => '2.77',
            'Net::FTP::A'           => '1.18',
            'Net::NNTP'             => '2.24',
            'Net::POP3'             => '2.29',
            'Net::Ping'             => '2.35',
            'Net::SMTP'             => '2.31',
            'O'                     => '1.01',
            'ODBM_File'             => '1.07',
            'OS2::DLL'              => '1.03',
            'OS2::Process'          => '1.03',
            'Opcode'                => '1.0601',
            'POSIX'                 => '1.15',
            'PerlIO'                => '1.05',
            'PerlIO::encoding'      => '0.11',
            'PerlIO::scalar'        => '0.06',
            'PerlIO::via'           => '0.05',
            'Pod::Html'             => '1.09',
            'Pod::ParseUtils'       => '1.35',
            'Pod::Parser'           => '1.35',
            'Pod::Select'           => '1.35',
            'Pod::Usage'            => '1.35',
            'SDBM_File'             => '1.06',
            'Safe'                  => '2.16',
            'Scalar::Util'          => '1.19',
            'SelfLoader'            => '1.17',
            'Shell'                 => '0.72',
            'Socket'                => '1.81',
            'Storable'              => '2.19',
            'Switch'                => '2.13',
            'Sys::Syslog'           => '0.27',
            'Sys::Syslog::win32::Win32'=> undef,
            'Term::ANSIColor'       => '1.12',
            'Term::Cap'             => '1.12',
            'Term::ReadLine'        => '1.03',
            'Test::Builder'         => '0.80',
            'Test::Builder::Module' => '0.80',
            'Test::Builder::Tester' => '1.13',
            'Test::Harness'         => '2.64',
            'Test::Harness::Results'=> '0.01_01',
            'Test::Harness::Straps' => '0.26_01',
            'Test::Harness::Util'   => '0.01',
            'Test::More'            => '0.80',
            'Test::Simple'          => '0.80',
            'Text::Balanced'        => '1.98',
            'Text::ParseWords'      => '3.27',
            'Text::Soundex'         => '3.03',
            'Text::Tabs'            => '2007.1117',
            'Text::Wrap'            => '2006.1117',
            'Thread'                => '2.01',
            'Thread::Queue'         => '2.11',
            'Thread::Semaphore'     => '2.09',
            'Tie::Handle'           => '4.2',
            'Tie::Hash'             => '1.03',
            'Tie::Memoize'          => '1.1',
            'Tie::RefHash'          => '1.38',
            'Tie::Scalar'           => '1.01',
            'Tie::StdHandle'        => '4.2',
            'Time::HiRes'           => '1.9715',
            'Time::Local'           => '1.1901',
            'Time::gmtime'          => '1.03',
            'Unicode'               => '5.1.0',
            'Unicode::Normalize'    => '1.02',
            'Unicode::UCD'          => '0.25',
            'VMS::DCLsym'           => '1.03',
            'VMS::Stdio'            => '2.4',
            'Win32'                 => '0.38',
            'Win32API::File'        => '0.1001_01',
            'Win32API::File::ExtUtils::Myconst2perl'=> '1',
            'Win32CORE'             => '0.02',
            'XS::APItest'           => '0.15',
            'XS::Typemap'           => '0.03',
            'XSLoader'              => '0.10',
            'attributes'            => '0.09',
            'autouse'               => '1.06',
            'base'                  => '2.13',
            'bigint'                => '0.23',
            'bignum'                => '0.23',
            'bigrat'                => '0.23',
            'blib'                  => '1.04',
            'charnames'             => '1.06',
            'constant'              => '1.17',
            'diagnostics'           => '1.16',
            'encoding'              => '2.6_01',
            'fields'                => '2.12',
            'filetest'              => '1.02',
            'lib'                   => '0.61',
            'open'                  => '1.06',
            'ops'                   => '1.02',
            'overload'              => '1.06',
            're'                    => '0.0601',
            'sigtrap'               => '1.04',
            'threads'               => '1.71',
            'threads::shared'       => '1.27',
            'utf8'                  => '1.07',
            'warnings'              => '1.05_01',
        },
        removed => {
        }
    },
    5.009 => {
        delta_from => 5.008002,
        changed => {
            'B'                     => '1.03',
            'B::C'                  => '1.03',
            'B::Concise'            => '0.57',
            'B::Deparse'            => '0.65',
            'DB_File'               => '1.806',
            'Devel::PPPort'         => '2.008',
            'English'               => '1.02',
            'Fatal'                 => '1.04',
            'OS2::DLL'              => '1.02',
            'Opcode'                => '1.06',
            'Time::HiRes'           => '1.51',
            'Unicode::Collate'      => '0.28',
            'Unicode::Normalize'    => '0.23',
            'XSLoader'              => '0.03',
            'assertions'            => '0.01',
            'assertions::activate'  => '0.01',
            'overload'              => '1.02',
            'version'               => '0.29',
        },
        removed => {
        }
    },
    5.009001 => {
        delta_from => 5.008004,
        changed => {
            'B'                     => '1.05',
            'B::Assembler'          => '0.06',
            'B::C'                  => '1.04',
            'B::Concise'            => '0.59',
            'B::Debug'              => '1.02',
            'B::Deparse'            => '0.65',
            'DB_File'               => '1.808_01',
            'Devel::PPPort'         => '2.011_01',
            'Digest'                => '1.05',
            'DynaLoader'            => '1.04',
            'English'               => '1.02',
            'Exporter::Heavy'       => '5.567',
            'ExtUtils::Command'     => '1.07',
            'ExtUtils::Liblist::Kid'=> '1.3',
            'ExtUtils::MM_Any'      => '0.0901',
            'ExtUtils::MM_Cygwin'   => '1.07',
            'ExtUtils::MM_NW5'      => '2.07_01',
            'ExtUtils::MM_Unix'     => '1.45_01',
            'ExtUtils::MM_VMS'      => '5.71_01',
            'ExtUtils::MM_Win32'    => '1.10_01',
            'ExtUtils::MM_Win95'    => '0.03',
            'ExtUtils::MakeMaker'   => '6.21_02',
            'ExtUtils::Manifest'    => '1.43',
            'Fatal'                 => '1.04',
            'Getopt::Long'          => '2.3401',
            'IO::Handle'            => '1.23',
            'IO::Pipe'              => '1.122',
            'IPC::Open3'            => '1.0105',
            'MIME::Base64'          => '3.00_01',
            'MIME::QuotedPrint'     => '3.00',
            'Memoize'               => '1.01_01',
            'ODBM_File'             => '1.04',
            'Opcode'                => '1.06',
            'POSIX'                 => '1.07',
            'Storable'              => '2.11',
            'Time::HiRes'           => '1.56',
            'Time::Local'           => '1.07_94',
            'UNIVERSAL'             => '1.02',
            'Unicode'               => '4.0.0',
            'Unicode::UCD'          => '0.21',
            'XSLoader'              => '0.03',
            'assertions'            => '0.01',
            'assertions::activate'  => '0.01',
            'base'                  => '2.04',
            'if'                    => '0.0401',
            'open'                  => '1.02',
            'overload'              => '1.02',
            'threads'               => '1.02',
            'utf8'                  => '1.02',
            'version'               => '0.36',
        },
        removed => {
        }
    },
    5.009002 => {
        delta_from => 5.008007,
        changed => {
            'B'                     => '1.07',
            'B::Concise'            => '0.64',
            'B::Deparse'            => '0.69',
            'B::Disassembler'       => '1.03',
            'B::Terse'              => '1.02',
            'CGI'                   => '3.07',
            'Config::Extensions'    => '0.01',
            'Devel::DProf'          => '20030813.00',
            'DynaLoader'            => '1.07',
            'Encode'                => '2.09',
            'Encode::Alias'         => '2.02',
            'English'               => '1.03',
            'Exporter'              => '5.59',
            'Exporter::Heavy'       => '5.59',
            'ExtUtils::Command'     => '1.07',
            'ExtUtils::Command::MM' => '0.03_01',
            'ExtUtils::Embed'       => '1.26',
            'ExtUtils::Liblist::Kid'=> '1.3',
            'ExtUtils::MM_Any'      => '0.10',
            'ExtUtils::MM_Cygwin'   => '1.07',
            'ExtUtils::MM_MacOS'    => '1.08',
            'ExtUtils::MM_NW5'      => '2.07',
            'ExtUtils::MM_Unix'     => '1.46_01',
            'ExtUtils::MM_VMS'      => '5.71',
            'ExtUtils::MM_Win32'    => '1.10',
            'ExtUtils::MM_Win95'    => '0.03',
            'ExtUtils::MakeMaker'   => '6.25',
            'ExtUtils::Manifest'    => '1.44',
            'Fatal'                 => '1.04',
            'File::Path'            => '1.06',
            'FileCache'             => '1.04_01',
            'Getopt::Long'          => '2.3401',
            'IO::File'              => '1.10',
            'IO::Socket::INET'      => '1.27',
            'Math::BigFloat'        => '1.49',
            'Math::BigInt'          => '1.75',
            'Math::BigInt::Calc'    => '0.45',
            'Math::BigRat'          => '0.14',
            'Memoize'               => '1.01_01',
            'Module::CoreList'      => '1.99',
            'NEXT'                  => '0.60_01',
            'Opcode'                => '1.06',
            'Pod::Html'             => '1.0502',
            'Scalar::Util'          => '1.14_1',
            'Storable'              => '2.14',
            'Symbol'                => '1.05',
            'Test::Harness'         => '2.46',
            'Test::Harness::Straps' => '0.20_01',
            'Text::Balanced'        => '1.95_01',
            'Text::Wrap'            => '2001.09292',
            'UNIVERSAL'             => '1.02',
            'Unicode'               => '4.0.1',
            'Unicode::Normalize'    => '0.30',
            'Unicode::UCD'          => '0.22',
            'Win32'                 => '0.23',
            'XS::APItest'           => '0.05',
            'XSLoader'              => '0.03',
            'assertions'            => '0.01',
            'assertions::activate'  => '0.01',
            'base'                  => '2.06',
            'bigint'                => '0.06',
            'bignum'                => '0.16',
            'bigrat'                => '0.07',
            'bytes'                 => '1.01',
            'encoding::warnings'    => '0.05',
            'if'                    => '0.0401',
            're'                    => '0.05',
            'threads::shared'       => '0.92',
            'utf8'                  => '1.04',
            'version'               => '0.42',
            'warnings'              => '1.04',
        },
        removed => {
            'Test::Harness::Point'  => 1,
        }
    },
    5.009003 => {
        delta_from => 5.008008,
        changed => {
            'Archive::Tar'          => '1.26_01',
            'Archive::Tar::Constant'=> '0.02',
            'Archive::Tar::File'    => '0.02',
            'AutoSplit'             => '1.04_01',
            'B'                     => '1.10',
            'B::Bblock'             => '1.02',
            'B::Bytecode'           => '1.01',
            'B::C'                  => '1.04',
            'B::CC'                 => '1.00',
            'B::Concise'            => '0.67',
            'B::Debug'              => '1.02',
            'B::Deparse'            => '0.73',
            'B::Lint'               => '1.04',
            'B::Terse'              => '1.03',
            'CGI'                   => '3.15_01',
            'CPAN'                  => '1.83_58',
            'CPAN::Debug'           => '4.44',
            'CPAN::FirstTime'       => '4.50',
            'CPAN::HandleConfig'    => '4.31',
            'CPAN::Nox'             => '2.31',
            'CPAN::Tarzip'          => '3.36',
            'CPAN::Version'         => '2.55',
            'Carp'                  => '1.05',
            'Carp::Heavy'           => '1.05',
            'Compress::Zlib'        => '2.000_07',
            'Compress::Zlib::Common'=> '2.000_07',
            'Compress::Zlib::Compress::Gzip::Constants'=> '2.000_07',
            'Compress::Zlib::Compress::Zip::Constants'=> '1.00',
            'Compress::Zlib::CompressPlugin::Deflate'=> '2.000_05',
            'Compress::Zlib::CompressPlugin::Identity'=> '2.000_05',
            'Compress::Zlib::File::GlobMapper'=> '0.000_02',
            'Compress::Zlib::FileConstants'=> '2.000_07',
            'Compress::Zlib::IO::Compress::Base'=> '2.000_05',
            'Compress::Zlib::IO::Compress::Deflate'=> '2.000_07',
            'Compress::Zlib::IO::Compress::Gzip'=> '2.000_07',
            'Compress::Zlib::IO::Compress::RawDeflate'=> '2.000_07',
            'Compress::Zlib::IO::Compress::Zip'=> '2.000_04',
            'Compress::Zlib::IO::Uncompress::AnyInflate'=> '2.000_07',
            'Compress::Zlib::IO::Uncompress::AnyUncompress'=> '2.000_05',
            'Compress::Zlib::IO::Uncompress::Base'=> '2.000_05',
            'Compress::Zlib::IO::Uncompress::Gunzip'=> '2.000_07',
            'Compress::Zlib::IO::Uncompress::Inflate'=> '2.000_07',
            'Compress::Zlib::IO::Uncompress::RawInflate'=> '2.000_07',
            'Compress::Zlib::IO::Uncompress::Unzip'=> '2.000_05',
            'Compress::Zlib::ParseParameters'=> '2.000_07',
            'Compress::Zlib::UncompressPlugin::Identity'=> '2.000_05',
            'Compress::Zlib::UncompressPlugin::Inflate'=> '2.000_05',
            'Config::Extensions'    => '0.01',
            'Cwd'                   => '3.15',
            'Devel::PPPort'         => '3.08',
            'Digest::SHA'           => '5.32',
            'DirHandle'             => '1.01',
            'DynaLoader'            => '1.07',
            'Encode'                => '2.14',
            'Encode::CN::HZ'        => '2.02',
            'Encode::MIME::Header'  => '2.02',
            'English'               => '1.04',
            'Exporter'              => '5.59',
            'Exporter::Heavy'       => '5.59',
            'ExtUtils::CBuilder'    => '0.15',
            'ExtUtils::CBuilder::Base'=> '0.12',
            'ExtUtils::CBuilder::Platform::Unix'=> '0.12',
            'ExtUtils::CBuilder::Platform::VMS'=> '0.12',
            'ExtUtils::CBuilder::Platform::Windows'=> '0.12',
            'ExtUtils::CBuilder::Platform::aix'=> '0.12',
            'ExtUtils::CBuilder::Platform::cygwin'=> '0.12',
            'ExtUtils::CBuilder::Platform::darwin'=> '0.12',
            'ExtUtils::CBuilder::Platform::dec_osf'=> '0.01',
            'ExtUtils::CBuilder::Platform::os2'=> '0.13',
            'ExtUtils::Command::MM' => '0.05_01',
            'ExtUtils::Constant'    => '0.2',
            'ExtUtils::Constant::Base'=> '0.02',
            'ExtUtils::Constant::ProxySubs'=> '0.01',
            'ExtUtils::Constant::XS'=> '0.02',
            'ExtUtils::MM_Any'      => '0.13_01',
            'ExtUtils::MM_Unix'     => '1.50_01',
            'ExtUtils::MakeMaker'   => '6.30_01',
            'ExtUtils::ParseXS'     => '2.15_02',
            'Fatal'                 => '1.04',
            'File::Compare'         => '1.1005',
            'File::Spec'            => '3.15',
            'File::Temp'            => '0.16_01',
            'IO::File'              => '1.13_01',
            'IO::Handle'            => '1.26',
            'IO::Socket'            => '1.29_01',
            'IO::Socket::INET'      => '1.29_02',
            'IO::Socket::UNIX'      => '1.22_01',
            'IO::Zlib'              => '1.04_02',
            'Locale::Maketext'      => '1.10_01',
            'Math::BigInt::FastCalc'=> '0.10',
            'Memoize'               => '1.01_01',
            'Module::CoreList'      => '2.02',
            'Moped::Msg'            => '0.01',
            'NEXT'                  => '0.60_01',
            'Net::Cmd'              => '2.26_01',
            'Net::Domain'           => '2.19_01',
            'Net::Ping'             => '2.31_04',
            'Opcode'                => '1.08',
            'POSIX'                 => '1.10',
            'Pod::Escapes'          => '1.04',
            'Pod::Man'              => '2.04',
            'Pod::Perldoc'          => '3.14_01',
            'Pod::Simple'           => '3.04',
            'Pod::Simple::BlackBox' => undef,
            'Pod::Simple::Checker'  => '2.02',
            'Pod::Simple::Debug'    => undef,
            'Pod::Simple::DumpAsText'=> '2.02',
            'Pod::Simple::DumpAsXML'=> '2.02',
            'Pod::Simple::HTML'     => '3.03',
            'Pod::Simple::HTMLBatch'=> '3.02',
            'Pod::Simple::HTMLLegacy'=> '5.01',
            'Pod::Simple::LinkSection'=> undef,
            'Pod::Simple::Methody'  => '2.02',
            'Pod::Simple::Progress' => '1.01',
            'Pod::Simple::PullParser'=> '2.02',
            'Pod::Simple::PullParserEndToken'=> undef,
            'Pod::Simple::PullParserStartToken'=> undef,
            'Pod::Simple::PullParserTextToken'=> undef,
            'Pod::Simple::PullParserToken'=> '2.02',
            'Pod::Simple::RTF'      => '2.02',
            'Pod::Simple::Search'   => '3.04',
            'Pod::Simple::SimpleTree'=> '2.02',
            'Pod::Simple::Text'     => '2.02',
            'Pod::Simple::TextContent'=> '2.02',
            'Pod::Simple::TiedOutFH'=> undef,
            'Pod::Simple::Transcode'=> undef,
            'Pod::Simple::TranscodeDumb'=> '2.02',
            'Pod::Simple::TranscodeSmart'=> undef,
            'Pod::Simple::XMLOutStream'=> '2.02',
            'Pod::Text'             => '3.01',
            'Pod::Text::Color'      => '2.01',
            'Pod::Text::Overstrike' => '2',
            'Pod::Text::Termcap'    => '2.01',
            'Pod::Usage'            => '1.33_01',
            'SelfLoader'            => '1.0905',
            'Storable'              => '2.15_02',
            'Test::Builder::Module' => '0.03',
            'Text::Balanced'        => '1.95_01',
            'Tie::File'             => '0.97_01',
            'UNIVERSAL'             => '1.03',
            'XS::APItest'           => '0.09',
            'assertions'            => '0.02',
            'assertions::activate'  => '0.02',
            'assertions::compat'    => undef,
            'constant'              => '1.07',
            'encoding::warnings'    => '0.05',
            'feature'               => '1.00',
            're'                    => '0.06',
            'sort'                  => '2.00',
            'version'               => '0.53',
        },
        removed => {
        }
    },
    5.009004 => {
        delta_from => 5.009003,
        changed => {
            'Archive::Tar'          => '1.30_01',
            'AutoLoader'            => '5.61',
            'B'                     => '1.11',
            'B::Bytecode'           => '1.02',
            'B::C'                  => '1.05',
            'B::Concise'            => '0.69',
            'B::Deparse'            => '0.76',
            'B::Lint'               => '1.08',
            'Benchmark'             => '1.08',
            'CGI'                   => '3.20',
            'CGI::Cookie'           => '1.27',
            'CGI::Fast'             => '1.07',
            'CPAN'                  => '1.87_55',
            'CPAN::Debug'           => '5.400561',
            'CPAN::FirstTime'       => '5.400742',
            'CPAN::HandleConfig'    => '5.400740',
            'CPAN::Nox'             => '5.400561',
            'CPAN::Tarzip'          => '5.400714',
            'CPAN::Version'         => '5.400561',
            'Compress::Raw::Zlib'   => '2.000_13',
            'Compress::Zlib'        => '2.000_13',
            'Cwd'                   => '3.19',
            'Devel::PPPort'         => '3.10',
            'Digest'                => '1.15',
            'Digest::SHA'           => '5.43',
            'Encode'                => '2.18_01',
            'Encode::Alias'         => '2.06',
            'Encode::Byte'          => '2.02',
            'Encode::CJKConstants'  => '2.02',
            'Encode::CN'            => '2.02',
            'Encode::CN::HZ'        => '2.04',
            'Encode::Config'        => '2.03',
            'Encode::EBCDIC'        => '2.02',
            'Encode::Encoder'       => '2.01',
            'Encode::Encoding'      => '2.04',
            'Encode::Guess'         => '2.02',
            'Encode::JP'            => '2.03',
            'Encode::JP::H2Z'       => '2.02',
            'Encode::JP::JIS7'      => '2.02',
            'Encode::KR'            => '2.02',
            'Encode::KR::2022_KR'   => '2.02',
            'Encode::MIME::Header'  => '2.04',
            'Encode::MIME::Header::ISO_2022_JP'=> '1.03',
            'Encode::Symbol'        => '2.02',
            'Encode::TW'            => '2.02',
            'Encode::Unicode'       => '2.03',
            'Encode::Unicode::UTF7' => '2.04',
            'ExtUtils::CBuilder'    => '0.18',
            'ExtUtils::CBuilder::Platform::Windows'=> '0.12_01',
            'ExtUtils::Constant::Base'=> '0.03',
            'ExtUtils::Constant::ProxySubs'=> '0.03',
            'ExtUtils::Install'     => '1.41',
            'ExtUtils::Installed'   => '1.41',
            'ExtUtils::MM_Any'      => '0.13_02',
            'ExtUtils::MM_NW5'      => '2.08_01',
            'ExtUtils::MM_Unix'     => '1.5003',
            'ExtUtils::MM_VMS'      => '5.73_03',
            'ExtUtils::MM_Win32'    => '1.12_02',
            'ExtUtils::MM_Win95'    => '0.04_01',
            'ExtUtils::MakeMaker'   => '6.30_02',
            'ExtUtils::Manifest'    => '1.46_01',
            'ExtUtils::Mkbootstrap' => '1.15_01',
            'ExtUtils::Mksymlists'  => '1.19_01',
            'ExtUtils::Packlist'    => '1.41',
            'File::Basename'        => '2.75',
            'File::Find'            => '1.11',
            'File::GlobMapper'      => '0.000_02',
            'File::Spec'            => '3.19',
            'FileCache'             => '1.07',
            'Getopt::Long'          => '2.3501',
            'Hash::Util'            => '0.07',
            'Hash::Util::FieldHash' => '0.01',
            'IO'                    => '1.23_01',
            'IO::Compress::Adapter::Deflate'=> '2.000_13',
            'IO::Compress::Adapter::Identity'=> '2.000_13',
            'IO::Compress::Base'    => '2.000_13',
            'IO::Compress::Base::Common'=> '2.000_13',
            'IO::Compress::Deflate' => '2.000_13',
            'IO::Compress::Gzip'    => '2.000_13',
            'IO::Compress::Gzip::Constants'=> '2.000_13',
            'IO::Compress::RawDeflate'=> '2.000_13',
            'IO::Compress::Zip'     => '2.000_13',
            'IO::Compress::Zip::Constants'=> '2.000_13',
            'IO::Compress::Zlib::Constants'=> '2.000_13',
            'IO::Compress::Zlib::Extra'=> '2.000_13',
            'IO::Dir'               => '1.06',
            'IO::File'              => '1.14',
            'IO::Handle'            => '1.27',
            'IO::Socket'            => '1.30_01',
            'IO::Socket::INET'      => '1.31',
            'IO::Socket::UNIX'      => '1.23',
            'IO::Uncompress::Adapter::Identity'=> '2.000_13',
            'IO::Uncompress::Adapter::Inflate'=> '2.000_13',
            'IO::Uncompress::AnyInflate'=> '2.000_13',
            'IO::Uncompress::AnyUncompress'=> '2.000_13',
            'IO::Uncompress::Base'  => '2.000_13',
            'IO::Uncompress::Gunzip'=> '2.000_13',
            'IO::Uncompress::Inflate'=> '2.000_13',
            'IO::Uncompress::RawInflate'=> '2.000_13',
            'IO::Uncompress::Unzip' => '2.000_13',
            'MIME::Base64'          => '3.07_01',
            'Math::Complex'         => '1.36',
            'Math::Trig'            => '1.04',
            'Module::Build'         => '0.2805',
            'Module::Build::Base'   => undef,
            'Module::Build::Compat' => '0.03',
            'Module::Build::ConfigData'=> undef,
            'Module::Build::Cookbook'=> undef,
            'Module::Build::ModuleInfo'=> undef,
            'Module::Build::Notes'  => undef,
            'Module::Build::PPMMaker'=> undef,
            'Module::Build::Platform::Amiga'=> undef,
            'Module::Build::Platform::Default'=> undef,
            'Module::Build::Platform::EBCDIC'=> undef,
            'Module::Build::Platform::MPEiX'=> undef,
            'Module::Build::Platform::MacOS'=> undef,
            'Module::Build::Platform::RiscOS'=> undef,
            'Module::Build::Platform::Unix'=> undef,
            'Module::Build::Platform::VMS'=> undef,
            'Module::Build::Platform::VOS'=> undef,
            'Module::Build::Platform::Windows'=> undef,
            'Module::Build::Platform::aix'=> undef,
            'Module::Build::Platform::cygwin'=> undef,
            'Module::Build::Platform::darwin'=> undef,
            'Module::Build::Platform::os2'=> undef,
            'Module::Build::PodParser'=> undef,
            'Module::Build::Version'=> '0',
            'Module::Build::YAML'   => '0.50',
            'Module::CoreList'      => '2.08',
            'Module::Load'          => '0.10',
            'Module::Loaded'        => '0.01',
            'Package::Constants'    => '0.01',
            'Pod::Html'             => '1.07',
            'Pod::Man'              => '2.09',
            'Pod::Text'             => '3.07',
            'Pod::Text::Color'      => '2.03',
            'Pod::Text::Termcap'    => '2.03',
            'SDBM_File'             => '1.06',
            'Shell'                 => '0.7',
            'Sys::Syslog'           => '0.17',
            'Term::ANSIColor'       => '1.11',
            'Test::Builder'         => '0.33',
            'Test::Builder::Tester' => '1.04',
            'Test::Harness'         => '2.62',
            'Test::Harness::Util'   => '0.01',
            'Test::More'            => '0.64',
            'Test::Simple'          => '0.64',
            'Text::Balanced'        => '1.98_01',
            'Text::ParseWords'      => '3.25',
            'Text::Tabs'            => '2007.071101',
            'Text::Wrap'            => '2006.0711',
            'Tie::RefHash'          => '1.34_01',
            'Time::HiRes'           => '1.87',
            'Time::Local'           => '1.13',
            'Time::gmtime'          => '1.03',
            'UNIVERSAL'             => '1.04',
            'Unicode::Normalize'    => '1.01',
            'Win32API::File'        => '0.1001',
            'Win32API::File::ExtUtils::Myconst2perl'=> '1',
            'assertions'            => '0.03',
            'assertions::compat'    => '0.02',
            'autouse'               => '1.06',
            'diagnostics'           => '1.16',
            'encoding'              => '2.04',
            'encoding::warnings'    => '0.10',
            'feature'               => '1.01',
            're'                    => '0.0601',
            'threads'               => '1.38',
            'threads::shared'       => '0.94_01',
            'version'               => '0.67',
        },
        removed => {
            'Compress::Zlib::Common'=> 1,
            'Compress::Zlib::Compress::Gzip::Constants'=> 1,
            'Compress::Zlib::Compress::Zip::Constants'=> 1,
            'Compress::Zlib::CompressPlugin::Deflate'=> 1,
            'Compress::Zlib::CompressPlugin::Identity'=> 1,
            'Compress::Zlib::File::GlobMapper'=> 1,
            'Compress::Zlib::FileConstants'=> 1,
            'Compress::Zlib::IO::Compress::Base'=> 1,
            'Compress::Zlib::IO::Compress::Deflate'=> 1,
            'Compress::Zlib::IO::Compress::Gzip'=> 1,
            'Compress::Zlib::IO::Compress::RawDeflate'=> 1,
            'Compress::Zlib::IO::Compress::Zip'=> 1,
            'Compress::Zlib::IO::Uncompress::AnyInflate'=> 1,
            'Compress::Zlib::IO::Uncompress::AnyUncompress'=> 1,
            'Compress::Zlib::IO::Uncompress::Base'=> 1,
            'Compress::Zlib::IO::Uncompress::Gunzip'=> 1,
            'Compress::Zlib::IO::Uncompress::Inflate'=> 1,
            'Compress::Zlib::IO::Uncompress::RawInflate'=> 1,
            'Compress::Zlib::IO::Uncompress::Unzip'=> 1,
            'Compress::Zlib::ParseParameters'=> 1,
            'Compress::Zlib::UncompressPlugin::Identity'=> 1,
            'Compress::Zlib::UncompressPlugin::Inflate'=> 1,
        }
    },
    5.009005 => {
        delta_from => 5.009004,
        changed => {
            'Archive::Extract'      => '0.22_01',
            'Archive::Tar'          => '1.32',
            'Attribute::Handlers'   => '0.78_06',
            'AutoLoader'            => '5.63',
            'AutoSplit'             => '1.05',
            'B'                     => '1.16',
            'B::Concise'            => '0.72',
            'B::Debug'              => '1.05',
            'B::Deparse'            => '0.82',
            'B::Lint'               => '1.09',
            'B::Terse'              => '1.05',
            'Benchmark'             => '1.1',
            'CGI'                   => '3.29',
            'CGI::Cookie'           => '1.28',
            'CGI::Util'             => '1.5_01',
            'CPAN'                  => '1.9102',
            'CPAN::Debug'           => '5.400955',
            'CPAN::FirstTime'       => '5.401669',
            'CPAN::HandleConfig'    => '5.401744',
            'CPAN::Kwalify'         => '5.401418',
            'CPAN::Nox'             => '5.400844',
            'CPAN::Queue'           => '5.401704',
            'CPAN::Tarzip'          => '5.401717',
            'CPAN::Version'         => '5.401387',
            'CPANPLUS'              => '0.81_01',
            'CPANPLUS::Backend'     => undef,
            'CPANPLUS::Backend::RV' => undef,
            'CPANPLUS::Config'      => undef,
            'CPANPLUS::Configure'   => undef,
            'CPANPLUS::Configure::Setup'=> undef,
            'CPANPLUS::Dist'        => undef,
            'CPANPLUS::Dist::Base'  => '0.01',
            'CPANPLUS::Dist::Build' => '0.06_01',
            'CPANPLUS::Dist::Build::Constants'=> '0.01',
            'CPANPLUS::Dist::MM'    => undef,
            'CPANPLUS::Dist::Sample'=> undef,
            'CPANPLUS::Error'       => undef,
            'CPANPLUS::Internals'   => '0.81_01',
            'CPANPLUS::Internals::Constants'=> '0.01',
            'CPANPLUS::Internals::Constants::Report'=> '0.01',
            'CPANPLUS::Internals::Extract'=> undef,
            'CPANPLUS::Internals::Fetch'=> undef,
            'CPANPLUS::Internals::Report'=> undef,
            'CPANPLUS::Internals::Search'=> undef,
            'CPANPLUS::Internals::Source'=> undef,
            'CPANPLUS::Internals::Utils'=> undef,
            'CPANPLUS::Internals::Utils::Autoflush'=> undef,
            'CPANPLUS::Module'      => undef,
            'CPANPLUS::Module::Author'=> undef,
            'CPANPLUS::Module::Author::Fake'=> undef,
            'CPANPLUS::Module::Checksums'=> undef,
            'CPANPLUS::Module::Fake'=> undef,
            'CPANPLUS::Module::Signature'=> undef,
            'CPANPLUS::Selfupdate'  => undef,
            'CPANPLUS::Shell'       => undef,
            'CPANPLUS::Shell::Classic'=> '0.0562',
            'CPANPLUS::Shell::Default'=> '0.81_01',
            'CPANPLUS::Shell::Default::Plugins::Remote'=> undef,
            'CPANPLUS::Shell::Default::Plugins::Source'=> undef,
            'CPANPLUS::inc'         => undef,
            'Carp'                  => '1.07',
            'Carp::Heavy'           => '1.07',
            'Compress::Raw::Zlib'   => '2.005',
            'Compress::Zlib'        => '2.005',
            'Cwd'                   => '3.25',
            'DBM_Filter'            => '0.02',
            'DB_File'               => '1.815',
            'Data::Dumper'          => '2.121_13',
            'Devel::InnerPackage'   => '0.3',
            'Devel::PPPort'         => '3.11_01',
            'Digest::MD5'           => '2.36_01',
            'Digest::SHA'           => '5.44',
            'DynaLoader'            => '1.08',
            'Encode'                => '2.23',
            'Encode::Alias'         => '2.07',
            'Encode::Byte'          => '2.03',
            'Encode::Config'        => '2.04',
            'Encode::Encoding'      => '2.05',
            'Encode::GSM0338'       => '2.00',
            'Encode::JP::JIS7'      => '2.03',
            'Encode::MIME::Header'  => '2.05',
            'Encode::MIME::Name'    => '1.01',
            'Encode::Unicode'       => '2.05',
            'Errno'                 => '1.10',
            'Exporter'              => '5.60',
            'Exporter::Heavy'       => '5.60',
            'ExtUtils::CBuilder'    => '0.19',
            'ExtUtils::CBuilder::Platform::Windows'=> '0.13',
            'ExtUtils::Command'     => '1.13',
            'ExtUtils::Command::MM' => '0.07',
            'ExtUtils::Constant::Base'=> '0.04',
            'ExtUtils::Install'     => '1.41_01',
            'ExtUtils::Liblist'     => '1.03',
            'ExtUtils::Liblist::Kid'=> '1.33',
            'ExtUtils::MM'          => '0.07',
            'ExtUtils::MM_AIX'      => '0.05',
            'ExtUtils::MM_Any'      => '0.15',
            'ExtUtils::MM_BeOS'     => '1.07',
            'ExtUtils::MM_Cygwin'   => '1.1',
            'ExtUtils::MM_DOS'      => '0.04',
            'ExtUtils::MM_MacOS'    => '1.1',
            'ExtUtils::MM_NW5'      => '2.1',
            'ExtUtils::MM_OS2'      => '1.07',
            'ExtUtils::MM_QNX'      => '0.04',
            'ExtUtils::MM_UWIN'     => '0.04',
            'ExtUtils::MM_Unix'     => '1.54_01',
            'ExtUtils::MM_VMS'      => '5.76',
            'ExtUtils::MM_VOS'      => '0.04',
            'ExtUtils::MM_Win32'    => '1.15',
            'ExtUtils::MM_Win95'    => '0.06',
            'ExtUtils::MY'          => '0.03',
            'ExtUtils::MakeMaker'   => '6.36',
            'ExtUtils::MakeMaker::Config'=> '0.04',
            'ExtUtils::MakeMaker::bytes'=> '0.03',
            'ExtUtils::MakeMaker::vmsish'=> '0.03',
            'ExtUtils::Manifest'    => '1.51_01',
            'ExtUtils::Mkbootstrap' => '1.17',
            'ExtUtils::Mksymlists'  => '1.21',
            'ExtUtils::ParseXS'     => '2.18',
            'ExtUtils::XSSymSet'    => '1.1',
            'ExtUtils::testlib'     => '1.17',
            'Fatal'                 => '1.05',
            'Fcntl'                 => '1.06',
            'File::Basename'        => '2.76',
            'File::Copy'            => '2.10',
            'File::Fetch'           => '0.10',
            'File::Glob'            => '1.06',
            'File::Path'            => '2.01',
            'File::Spec'            => '3.25',
            'File::Spec::Cygwin'    => '1.1_01',
            'File::Spec::VMS'       => '1.4_01',
            'File::Temp'            => '0.18',
            'Filter::Util::Call'    => '1.0602',
            'FindBin'               => '1.49',
            'Getopt::Long'          => '2.36',
            'Hash::Util::FieldHash' => '1.01',
            'IO::Compress::Adapter::Deflate'=> '2.005',
            'IO::Compress::Adapter::Identity'=> '2.005',
            'IO::Compress::Base'    => '2.005',
            'IO::Compress::Base::Common'=> '2.005',
            'IO::Compress::Deflate' => '2.005',
            'IO::Compress::Gzip'    => '2.005',
            'IO::Compress::Gzip::Constants'=> '2.005',
            'IO::Compress::RawDeflate'=> '2.005',
            'IO::Compress::Zip'     => '2.005',
            'IO::Compress::Zip::Constants'=> '2.005',
            'IO::Compress::Zlib::Constants'=> '2.005',
            'IO::Compress::Zlib::Extra'=> '2.005',
            'IO::Uncompress::Adapter::Identity'=> '2.005',
            'IO::Uncompress::Adapter::Inflate'=> '2.005',
            'IO::Uncompress::AnyInflate'=> '2.005',
            'IO::Uncompress::AnyUncompress'=> '2.005',
            'IO::Uncompress::Base'  => '2.005',
            'IO::Uncompress::Gunzip'=> '2.005',
            'IO::Uncompress::Inflate'=> '2.005',
            'IO::Uncompress::RawInflate'=> '2.005',
            'IO::Uncompress::Unzip' => '2.005',
            'IO::Zlib'              => '1.05_01',
            'IPC::Cmd'              => '0.36_01',
            'List::Util'            => '1.19',
            'Locale::Maketext::Simple'=> '0.18',
            'Log::Message'          => '0.01',
            'Log::Message::Config'  => '0.01',
            'Log::Message::Handlers'=> undef,
            'Log::Message::Item'    => undef,
            'Log::Message::Simple'  => '0.0201',
            'Math::BigFloat'        => '1.58',
            'Math::BigInt'          => '1.87',
            'Math::BigInt::Calc'    => '0.51',
            'Math::BigInt::FastCalc'=> '0.15_01',
            'Math::BigRat'          => '0.19',
            'Math::Complex'         => '1.37',
            'Memoize'               => '1.01_02',
            'Module::Build'         => '0.2808',
            'Module::Build::Config' => undef,
            'Module::Build::Version'=> '0.7203',
            'Module::CoreList'      => '2.12',
            'Module::Load::Conditional'=> '0.16',
            'Module::Pluggable'     => '3.6',
            'Module::Pluggable::Object'=> '3.6',
            'NDBM_File'             => '1.07',
            'Net::Cmd'              => '2.28',
            'Net::Config'           => '1.11',
            'Net::Domain'           => '2.20',
            'Net::FTP'              => '2.77',
            'Net::FTP::A'           => '1.18',
            'Net::NNTP'             => '2.24',
            'Net::POP3'             => '2.29',
            'Net::SMTP'             => '2.31',
            'ODBM_File'             => '1.07',
            'OS2::DLL'              => '1.03',
            'Object::Accessor'      => '0.32',
            'Opcode'                => '1.09',
            'POSIX'                 => '1.13',
            'Params::Check'         => '0.26',
            'PerlIO::encoding'      => '0.10',
            'PerlIO::scalar'        => '0.05',
            'PerlIO::via'           => '0.04',
            'Pod::Html'             => '1.08',
            'Pod::Man'              => '2.12',
            'Pod::ParseUtils'       => '1.35',
            'Pod::Parser'           => '1.35',
            'Pod::Select'           => '1.35',
            'Pod::Simple'           => '3.05',
            'Pod::Text'             => '3.08',
            'Pod::Usage'            => '1.35',
            'Scalar::Util'          => '1.19',
            'SelfLoader'            => '1.11',
            'Shell'                 => '0.72_01',
            'Socket'                => '1.79',
            'Storable'              => '2.16',
            'Switch'                => '2.13',
            'Sys::Syslog'           => '0.18_01',
            'Term::ANSIColor'       => '1.12',
            'Term::UI'              => '0.14_01',
            'Term::UI::History'     => undef,
            'Test::Builder'         => '0.70',
            'Test::Builder::Module' => '0.68',
            'Test::Builder::Tester' => '1.07',
            'Test::Harness'         => '2.64',
            'Test::Harness::Results'=> '0.01',
            'Test::More'            => '0.70',
            'Test::Simple'          => '0.70',
            'Text::Balanced'        => '2.0.0',
            'Text::Soundex'         => '3.02',
            'Text::Tabs'            => '2007.1117',
            'Text::Wrap'            => '2006.1117',
            'Thread'                => '3.02',
            'Tie::File'             => '0.97_02',
            'Tie::Hash::NamedCapture'=> '0.06',
            'Tie::Memoize'          => '1.1',
            'Tie::RefHash'          => '1.37',
            'Time::HiRes'           => '1.9707',
            'Time::Local'           => '1.17',
            'Time::Piece'           => '1.11_02',
            'Time::Seconds'         => undef,
            'Unicode'               => '5.0.0',
            'Unicode::Normalize'    => '1.02',
            'Unicode::UCD'          => '0.25',
            'VMS::DCLsym'           => '1.03',
            'Win32'                 => '0.30',
            'Win32API::File'        => '0.1001_01',
            'Win32CORE'             => '0.02',
            'XS::APItest'           => '0.12',
            'XSLoader'              => '0.08',
            'attributes'            => '0.08',
            'base'                  => '2.12',
            'bigint'                => '0.22',
            'bignum'                => '0.22',
            'bigrat'                => '0.22',
            'bytes'                 => '1.03',
            'charnames'             => '1.06',
            'constant'              => '1.10',
            'diagnostics'           => '1.17',
            'encoding'              => '2.06',
            'encoding::warnings'    => '0.11',
            'feature'               => '1.10',
            'fields'                => '2.12',
            'less'                  => '0.02',
            'mro'                   => '1.00',
            'overload'              => '1.06',
            're'                    => '0.08',
            'sigtrap'               => '1.04',
            'sort'                  => '2.01',
            'strict'                => '1.04',
            'threads'               => '1.63',
            'threads::shared'       => '1.12',
            'utf8'                  => '1.07',
            'version'               => '0.7203',
            'warnings'              => '1.06',
        },
        removed => {
            'B::Asmdata'            => 1,
            'B::Assembler'          => 1,
            'B::Bblock'             => 1,
            'B::Bytecode'           => 1,
            'B::C'                  => 1,
            'B::CC'                 => 1,
            'B::Disassembler'       => 1,
            'B::Stackobj'           => 1,
            'B::Stash'              => 1,
            'ByteLoader'            => 1,
            'Thread::Signal'        => 1,
            'Thread::Specific'      => 1,
            'assertions'            => 1,
            'assertions::activate'  => 1,
            'assertions::compat'    => 1,
        }
    },
    5.01 => {
        delta_from => 5.009005,
        changed => {
            'Archive::Extract'      => '0.24',
            'Archive::Tar'          => '1.38',
            'Attribute::Handlers'   => '0.79',
            'B'                     => '1.17',
            'B::Concise'            => '0.74',
            'B::Deparse'            => '0.83',
            'CPAN'                  => '1.9205',
            'CPAN::API::HOWTO'      => undef,
            'CPAN::Debug'           => '5.402212',
            'CPAN::DeferedCode'     => '5.50',
            'CPAN::FirstTime'       => '5.402229',
            'CPAN::HandleConfig'    => '5.402212',
            'CPAN::Nox'             => '5.402411',
            'CPAN::Queue'           => '5.402212',
            'CPAN::Tarzip'          => '5.402213',
            'CPAN::Version'         => '5.5',
            'CPANPLUS'              => '0.84',
            'CPANPLUS::Dist::Build' => '0.06_02',
            'CPANPLUS::Internals'   => '0.84',
            'CPANPLUS::Shell::Default'=> '0.84',
            'CPANPLUS::Shell::Default::Plugins::CustomSource'=> undef,
            'Carp'                  => '1.08',
            'Carp::Heavy'           => '1.08',
            'Compress::Raw::Zlib'   => '2.008',
            'Compress::Zlib'        => '2.008',
            'Cwd'                   => '3.2501',
            'DB_File'               => '1.816_1',
            'Data::Dumper'          => '2.121_14',
            'Devel::PPPort'         => '3.13',
            'Digest::SHA'           => '5.45',
            'Exporter'              => '5.62',
            'Exporter::Heavy'       => '5.62',
            'ExtUtils::CBuilder'    => '0.21',
            'ExtUtils::CBuilder::Base'=> '0.21',
            'ExtUtils::CBuilder::Platform::Unix'=> '0.21',
            'ExtUtils::CBuilder::Platform::VMS'=> '0.22',
            'ExtUtils::CBuilder::Platform::Windows'=> '0.21',
            'ExtUtils::CBuilder::Platform::aix'=> '0.21',
            'ExtUtils::CBuilder::Platform::cygwin'=> '0.21',
            'ExtUtils::CBuilder::Platform::darwin'=> '0.21',
            'ExtUtils::CBuilder::Platform::dec_osf'=> '0.21',
            'ExtUtils::CBuilder::Platform::os2'=> '0.21',
            'ExtUtils::Command::MM' => '6.42',
            'ExtUtils::Constant::ProxySubs'=> '0.05',
            'ExtUtils::Embed'       => '1.27',
            'ExtUtils::Install'     => '1.44',
            'ExtUtils::Installed'   => '1.43',
            'ExtUtils::Liblist'     => '6.42',
            'ExtUtils::Liblist::Kid'=> '6.42',
            'ExtUtils::MM'          => '6.42',
            'ExtUtils::MM_AIX'      => '6.42',
            'ExtUtils::MM_Any'      => '6.42',
            'ExtUtils::MM_BeOS'     => '6.42',
            'ExtUtils::MM_Cygwin'   => '6.42',
            'ExtUtils::MM_DOS'      => '6.42',
            'ExtUtils::MM_MacOS'    => '6.42',
            'ExtUtils::MM_NW5'      => '6.42',
            'ExtUtils::MM_OS2'      => '6.42',
            'ExtUtils::MM_QNX'      => '6.42',
            'ExtUtils::MM_UWIN'     => '6.42',
            'ExtUtils::MM_Unix'     => '6.42',
            'ExtUtils::MM_VMS'      => '6.42',
            'ExtUtils::MM_VOS'      => '6.42',
            'ExtUtils::MM_Win32'    => '6.42',
            'ExtUtils::MM_Win95'    => '6.42',
            'ExtUtils::MY'          => '6.42',
            'ExtUtils::MakeMaker'   => '6.42',
            'ExtUtils::MakeMaker::Config'=> '6.42',
            'ExtUtils::MakeMaker::bytes'=> '6.42',
            'ExtUtils::MakeMaker::vmsish'=> '6.42',
            'ExtUtils::Mkbootstrap' => '6.42',
            'ExtUtils::Mksymlists'  => '6.42',
            'ExtUtils::Packlist'    => '1.43',
            'ExtUtils::ParseXS'     => '2.18_02',
            'ExtUtils::testlib'     => '6.42',
            'File::Copy'            => '2.11',
            'File::Fetch'           => '0.14',
            'File::Find'            => '1.12',
            'File::Path'            => '2.04',
            'File::Spec'            => '3.2501',
            'File::Spec::Cygwin'    => '3.2501',
            'File::Spec::Epoc'      => '3.2501',
            'File::Spec::Functions' => '3.2501',
            'File::Spec::Mac'       => '3.2501',
            'File::Spec::OS2'       => '3.2501',
            'File::Spec::Unix'      => '3.2501',
            'File::Spec::VMS'       => '3.2501',
            'File::Spec::Win32'     => '3.2501',
            'Filter::Util::Call'    => '1.07',
            'Getopt::Long'          => '2.37',
            'Hash::Util::FieldHash' => '1.03',
            'IO::Compress::Adapter::Deflate'=> '2.008',
            'IO::Compress::Adapter::Identity'=> '2.008',
            'IO::Compress::Base'    => '2.008',
            'IO::Compress::Base::Common'=> '2.008',
            'IO::Compress::Deflate' => '2.008',
            'IO::Compress::Gzip'    => '2.008',
            'IO::Compress::Gzip::Constants'=> '2.008',
            'IO::Compress::RawDeflate'=> '2.008',
            'IO::Compress::Zip'     => '2.008',
            'IO::Compress::Zip::Constants'=> '2.008',
            'IO::Compress::Zlib::Constants'=> '2.008',
            'IO::Compress::Zlib::Extra'=> '2.008',
            'IO::Uncompress::Adapter::Identity'=> '2.008',
            'IO::Uncompress::Adapter::Inflate'=> '2.008',
            'IO::Uncompress::AnyInflate'=> '2.008',
            'IO::Uncompress::AnyUncompress'=> '2.008',
            'IO::Uncompress::Base'  => '2.008',
            'IO::Uncompress::Gunzip'=> '2.008',
            'IO::Uncompress::Inflate'=> '2.008',
            'IO::Uncompress::RawInflate'=> '2.008',
            'IO::Uncompress::Unzip' => '2.008',
            'IO::Zlib'              => '1.07',
            'IPC::Cmd'              => '0.40_1',
            'IPC::SysV'             => '1.05',
            'Locale::Maketext'      => '1.12',
            'Log::Message::Simple'  => '0.04',
            'Math::BigFloat'        => '1.59',
            'Math::BigInt'          => '1.88',
            'Math::BigInt::Calc'    => '0.52',
            'Math::BigInt::FastCalc'=> '0.16',
            'Math::BigRat'          => '0.21',
            'Module::Build'         => '0.2808_01',
            'Module::Build::Base'   => '0.2808_01',
            'Module::Build::Compat' => '0.2808_01',
            'Module::Build::Config' => '0.2808_01',
            'Module::Build::Dumper' => undef,
            'Module::Build::ModuleInfo'=> '0.2808_01',
            'Module::Build::Notes'  => '0.2808_01',
            'Module::Build::PPMMaker'=> '0.2808_01',
            'Module::Build::Platform::Amiga'=> '0.2808_01',
            'Module::Build::Platform::Default'=> '0.2808_01',
            'Module::Build::Platform::EBCDIC'=> '0.2808_01',
            'Module::Build::Platform::MPEiX'=> '0.2808_01',
            'Module::Build::Platform::MacOS'=> '0.2808_01',
            'Module::Build::Platform::RiscOS'=> '0.2808_01',
            'Module::Build::Platform::Unix'=> '0.2808_01',
            'Module::Build::Platform::VMS'=> '0.2808_01',
            'Module::Build::Platform::VOS'=> '0.2808_01',
            'Module::Build::Platform::Windows'=> '0.2808_01',
            'Module::Build::Platform::aix'=> '0.2808_01',
            'Module::Build::Platform::cygwin'=> '0.2808_01',
            'Module::Build::Platform::darwin'=> '0.2808_01',
            'Module::Build::Platform::os2'=> '0.2808_01',
            'Module::Build::PodParser'=> '0.2808_01',
            'Module::CoreList'      => '2.13',
            'Module::Load'          => '0.12',
            'Module::Load::Conditional'=> '0.22',
            'Net::Cmd'              => '2.29',
            'Net::Ping'             => '2.33',
            'Opcode'                => '1.11',
            'Pod::Checker'          => '1.43_01',
            'Pod::Man'              => '2.16',
            'Pod::Perldoc'          => '3.14_02',
            'Socket'                => '1.80',
            'Storable'              => '2.18',
            'Sys::Syslog'           => '0.22',
            'Sys::Syslog::win32::Win32'=> undef,
            'Term::Cap'             => '1.12',
            'Term::ReadLine'        => '1.03',
            'Term::UI'              => '0.18',
            'Test::Builder'         => '0.72',
            'Test::Builder::Module' => '0.72',
            'Test::Builder::Tester' => '1.09',
            'Test::Harness::Straps' => '0.26_01',
            'Test::More'            => '0.72',
            'Test::Simple'          => '0.72',
            'Text::ParseWords'      => '3.26',
            'Text::Soundex'         => '3.03',
            'Tie::StdHandle'        => undef,
            'Time::HiRes'           => '1.9711',
            'Time::Local'           => '1.18',
            'Time::Piece'           => '1.12',
            'VMS::Filespec'         => '1.12',
            'Win32'                 => '0.34',
            'base'                  => '2.13',
            'constant'              => '1.13',
            'feature'               => '1.11',
            'fields'                => '2.13',
            'filetest'              => '1.02',
            'open'                  => '1.06',
            'threads'               => '1.67',
            'threads::shared'       => '1.14',
            'version'               => '0.74',
        },
        removed => {
        }
    },
    5.010001 => {
        delta_from => 5.01,
        changed => {
            'App::Prove'            => '3.17',
            'App::Prove::State'     => '3.17',
            'App::Prove::State::Result'=> '3.17',
            'App::Prove::State::Result::Test'=> '3.17',
            'Archive::Extract'      => '0.34',
            'Archive::Tar'          => '1.52',
            'Attribute::Handlers'   => '0.85',
            'AutoLoader'            => '5.68',
            'AutoSplit'             => '1.06',
            'B'                     => '1.22',
            'B::Concise'            => '0.76',
            'B::Debug'              => '1.11',
            'B::Deparse'            => '0.89',
            'B::Lint'               => '1.11',
            'B::Lint::Debug'        => undef,
            'B::Xref'               => '1.02',
            'Benchmark'             => '1.11',
            'CGI'                   => '3.43',
            'CGI::Carp'             => '1.30_01',
            'CGI::Cookie'           => '1.29',
            'CPAN'                  => '1.9402',
            'CPAN::Author'          => '5.5',
            'CPAN::Bundle'          => '5.5',
            'CPAN::CacheMgr'        => '5.5',
            'CPAN::Complete'        => '5.5',
            'CPAN::Debug'           => '5.5',
            'CPAN::DeferredCode'    => '5.50',
            'CPAN::Distribution'    => '1.93',
            'CPAN::Distroprefs'     => '6',
            'CPAN::Distrostatus'    => '5.5',
            'CPAN::Exception::RecursiveDependency'=> '5.5',
            'CPAN::Exception::blocked_urllist'=> '1.0',
            'CPAN::Exception::yaml_not_installed'=> '5.5',
            'CPAN::FTP'             => '5.5001',
            'CPAN::FTP::netrc'      => '1.00',
            'CPAN::FirstTime'       => '5.53',
            'CPAN::HandleConfig'    => '5.5',
            'CPAN::Index'           => '1.93',
            'CPAN::InfoObj'         => '5.5',
            'CPAN::Kwalify'         => '5.50',
            'CPAN::LWP::UserAgent'  => '1.00',
            'CPAN::Module'          => '5.5',
            'CPAN::Nox'             => '5.50',
            'CPAN::Prompt'          => '5.5',
            'CPAN::Queue'           => '5.5',
            'CPAN::Shell'           => '5.5',
            'CPAN::Tarzip'          => '5.501',
            'CPAN::URL'             => '5.5',
            'CPANPLUS'              => '0.88',
            'CPANPLUS::Dist::Autobundle'=> undef,
            'CPANPLUS::Dist::Base'  => undef,
            'CPANPLUS::Dist::Build' => '0.36',
            'CPANPLUS::Dist::Build::Constants'=> '0.36',
            'CPANPLUS::Internals'   => '0.88',
            'CPANPLUS::Internals::Constants'=> undef,
            'CPANPLUS::Internals::Constants::Report'=> undef,
            'CPANPLUS::Internals::Source::Memory'=> undef,
            'CPANPLUS::Internals::Source::SQLite'=> undef,
            'CPANPLUS::Internals::Source::SQLite::Tie'=> undef,
            'CPANPLUS::Shell::Default'=> '0.88',
            'Carp'                  => '1.11',
            'Carp::Heavy'           => '1.11',
            'Compress::Raw::Bzip2'  => '2.020',
            'Compress::Raw::Zlib'   => '2.020',
            'Compress::Zlib'        => '2.020',
            'Cwd'                   => '3.30',
            'DB'                    => '1.02',
            'DBM_Filter::compress'  => '0.02',
            'DBM_Filter::encode'    => '0.02',
            'DBM_Filter::int32'     => '0.02',
            'DBM_Filter::null'      => '0.02',
            'DBM_Filter::utf8'      => '0.02',
            'DB_File'               => '1.820',
            'Data::Dumper'          => '2.124',
            'Devel::DProf'          => '20080331.00',
            'Devel::PPPort'         => '3.19',
            'Devel::Peek'           => '1.04',
            'Digest'                => '1.16',
            'Digest::MD5'           => '2.39',
            'Digest::SHA'           => '5.47',
            'Digest::base'          => '1.16',
            'Digest::file'          => '1.16',
            'DirHandle'             => '1.03',
            'Dumpvalue'             => '1.13',
            'DynaLoader'            => '1.10',
            'Encode'                => '2.35',
            'Encode::Alias'         => '2.12',
            'Encode::CN::HZ'        => '2.05',
            'Encode::Config'        => '2.05',
            'Encode::GSM0338'       => '2.01',
            'Encode::Guess'         => '2.03',
            'Encode::JP::JIS7'      => '2.04',
            'Encode::MIME::Header'  => '2.11',
            'Encode::Unicode'       => '2.06',
            'Errno'                 => '1.11',
            'Exporter'              => '5.63',
            'Exporter::Heavy'       => '5.63',
            'ExtUtils::CBuilder'    => '0.2602',
            'ExtUtils::CBuilder::Base'=> '0.2602',
            'ExtUtils::CBuilder::Platform::Unix'=> '0.2602',
            'ExtUtils::CBuilder::Platform::VMS'=> '0.2602',
            'ExtUtils::CBuilder::Platform::Windows'=> '0.2602',
            'ExtUtils::CBuilder::Platform::aix'=> '0.2602',
            'ExtUtils::CBuilder::Platform::cygwin'=> '0.2602',
            'ExtUtils::CBuilder::Platform::darwin'=> '0.2602',
            'ExtUtils::CBuilder::Platform::dec_osf'=> '0.2602',
            'ExtUtils::CBuilder::Platform::os2'=> '0.2602',
            'ExtUtils::Command'     => '1.16',
            'ExtUtils::Command::MM' => '6.55_02',
            'ExtUtils::Constant'    => '0.22',
            'ExtUtils::Constant::ProxySubs'=> '0.06',
            'ExtUtils::Constant::Utils'=> '0.02',
            'ExtUtils::Constant::XS'=> '0.03',
            'ExtUtils::Embed'       => '1.28',
            'ExtUtils::Install'     => '1.54',
            'ExtUtils::Installed'   => '1.999_001',
            'ExtUtils::Liblist'     => '6.55_02',
            'ExtUtils::Liblist::Kid'=> '6.5502',
            'ExtUtils::MM'          => '6.55_02',
            'ExtUtils::MM_AIX'      => '6.55_02',
            'ExtUtils::MM_Any'      => '6.55_02',
            'ExtUtils::MM_BeOS'     => '6.55_02',
            'ExtUtils::MM_Cygwin'   => '6.55_02',
            'ExtUtils::MM_DOS'      => '6.5502',
            'ExtUtils::MM_Darwin'   => '6.55_02',
            'ExtUtils::MM_MacOS'    => '6.5502',
            'ExtUtils::MM_NW5'      => '6.55_02',
            'ExtUtils::MM_OS2'      => '6.55_02',
            'ExtUtils::MM_QNX'      => '6.55_02',
            'ExtUtils::MM_UWIN'     => '6.5502',
            'ExtUtils::MM_Unix'     => '6.55_02',
            'ExtUtils::MM_VMS'      => '6.55_02',
            'ExtUtils::MM_VOS'      => '6.55_02',
            'ExtUtils::MM_Win32'    => '6.55_02',
            'ExtUtils::MM_Win95'    => '6.55_02',
            'ExtUtils::MY'          => '6.5502',
            'ExtUtils::MakeMaker'   => '6.55_02',
            'ExtUtils::MakeMaker::Config'=> '6.55_02',
            'ExtUtils::Manifest'    => '1.56',
            'ExtUtils::Mkbootstrap' => '6.55_02',
            'ExtUtils::Mksymlists'  => '6.55_02',
            'ExtUtils::ParseXS'     => '2.2002',
            'ExtUtils::testlib'     => '6.5502',
            'Fatal'                 => '2.06_01',
            'File::Basename'        => '2.77',
            'File::CheckTree'       => '4.4',
            'File::Compare'         => '1.1006',
            'File::Copy'            => '2.14',
            'File::DosGlob'         => '1.01',
            'File::Fetch'           => '0.20',
            'File::Find'            => '1.14',
            'File::GlobMapper'      => '1.000',
            'File::Path'            => '2.07_03',
            'File::Spec'            => '3.30',
            'File::Spec::Cygwin'    => '3.30',
            'File::Spec::Epoc'      => '3.30',
            'File::Spec::Functions' => '3.30',
            'File::Spec::Mac'       => '3.30',
            'File::Spec::OS2'       => '3.30',
            'File::Spec::Unix'      => '3.30',
            'File::Spec::VMS'       => '3.30',
            'File::Spec::Win32'     => '3.30',
            'File::Temp'            => '0.22',
            'File::stat'            => '1.01',
            'FileCache'             => '1.08',
            'FileHandle'            => '2.02',
            'Filter::Simple'        => '0.84',
            'Filter::Util::Call'    => '1.08',
            'FindBin'               => '1.50',
            'GDBM_File'             => '1.09',
            'Getopt::Long'          => '2.38',
            'Getopt::Std'           => '1.06',
            'Hash::Util::FieldHash' => '1.04',
            'I18N::Collate'         => '1.01',
            'IO'                    => '1.25',
            'IO::Compress::Adapter::Bzip2'=> '2.020',
            'IO::Compress::Adapter::Deflate'=> '2.020',
            'IO::Compress::Adapter::Identity'=> '2.020',
            'IO::Compress::Base'    => '2.020',
            'IO::Compress::Base::Common'=> '2.020',
            'IO::Compress::Bzip2'   => '2.020',
            'IO::Compress::Deflate' => '2.020',
            'IO::Compress::Gzip'    => '2.020',
            'IO::Compress::Gzip::Constants'=> '2.020',
            'IO::Compress::RawDeflate'=> '2.020',
            'IO::Compress::Zip'     => '2.020',
            'IO::Compress::Zip::Constants'=> '2.020',
            'IO::Compress::Zlib::Constants'=> '2.020',
            'IO::Compress::Zlib::Extra'=> '2.020',
            'IO::Dir'               => '1.07',
            'IO::Handle'            => '1.28',
            'IO::Socket'            => '1.31',
            'IO::Uncompress::Adapter::Bunzip2'=> '2.020',
            'IO::Uncompress::Adapter::Identity'=> '2.020',
            'IO::Uncompress::Adapter::Inflate'=> '2.020',
            'IO::Uncompress::AnyInflate'=> '2.020',
            'IO::Uncompress::AnyUncompress'=> '2.020',
            'IO::Uncompress::Base'  => '2.020',
            'IO::Uncompress::Bunzip2'=> '2.020',
            'IO::Uncompress::Gunzip'=> '2.020',
            'IO::Uncompress::Inflate'=> '2.020',
            'IO::Uncompress::RawInflate'=> '2.020',
            'IO::Uncompress::Unzip' => '2.020',
            'IO::Zlib'              => '1.09',
            'IPC::Cmd'              => '0.46',
            'IPC::Msg'              => '2.01',
            'IPC::Open2'            => '1.03',
            'IPC::Open3'            => '1.04',
            'IPC::Semaphore'        => '2.01',
            'IPC::SharedMem'        => '2.01',
            'IPC::SysV'             => '2.01',
            'List::Util'            => '1.21',
            'List::Util::PP'        => '1.21',
            'List::Util::XS'        => '1.21',
            'Locale::Maketext'      => '1.13',
            'Locale::Maketext::Guts'=> '1.13',
            'Locale::Maketext::GutsLoader'=> '1.13',
            'Log::Message'          => '0.02',
            'MIME::Base64'          => '3.08',
            'MIME::QuotedPrint'     => '3.08',
            'Math::BigFloat'        => '1.60',
            'Math::BigInt'          => '1.89',
            'Math::BigInt::FastCalc'=> '0.19',
            'Math::BigRat'          => '0.22',
            'Math::Complex'         => '1.56',
            'Math::Trig'            => '1.2',
            'Memoize'               => '1.01_03',
            'Module::Build'         => '0.340201',
            'Module::Build::Base'   => '0.340201',
            'Module::Build::Compat' => '0.340201',
            'Module::Build::Config' => '0.340201',
            'Module::Build::Cookbook'=> '0.340201',
            'Module::Build::Dumper' => '0.340201',
            'Module::Build::ModuleInfo'=> '0.340201',
            'Module::Build::Notes'  => '0.340201',
            'Module::Build::PPMMaker'=> '0.340201',
            'Module::Build::Platform::Amiga'=> '0.340201',
            'Module::Build::Platform::Default'=> '0.340201',
            'Module::Build::Platform::EBCDIC'=> '0.340201',
            'Module::Build::Platform::MPEiX'=> '0.340201',
            'Module::Build::Platform::MacOS'=> '0.340201',
            'Module::Build::Platform::RiscOS'=> '0.340201',
            'Module::Build::Platform::Unix'=> '0.340201',
            'Module::Build::Platform::VMS'=> '0.340201',
            'Module::Build::Platform::VOS'=> '0.340201',
            'Module::Build::Platform::Windows'=> '0.340201',
            'Module::Build::Platform::aix'=> '0.340201',
            'Module::Build::Platform::cygwin'=> '0.340201',
            'Module::Build::Platform::darwin'=> '0.340201',
            'Module::Build::Platform::os2'=> '0.340201',
            'Module::Build::PodParser'=> '0.340201',
            'Module::Build::Version'=> '0.77',
            'Module::CoreList'      => '2.18',
            'Module::Load'          => '0.16',
            'Module::Load::Conditional'=> '0.30',
            'Module::Loaded'        => '0.02',
            'Module::Pluggable'     => '3.9',
            'Module::Pluggable::Object'=> '3.9',
            'NDBM_File'             => '1.08',
            'NEXT'                  => '0.64',
            'Net::Ping'             => '2.36',
            'O'                     => '1.01',
            'OS2::Process'          => '1.03',
            'OS2::REXX'             => '1.04',
            'Object::Accessor'      => '0.34',
            'POSIX'                 => '1.17',
            'Package::Constants'    => '0.02',
            'Parse::CPAN::Meta'     => '1.39',
            'PerlIO'                => '1.06',
            'PerlIO::encoding'      => '0.11',
            'PerlIO::scalar'        => '0.07',
            'PerlIO::via'           => '0.07',
            'Pod::Checker'          => '1.45',
            'Pod::Find'             => '1.35',
            'Pod::Html'             => '1.09',
            'Pod::InputObjects'     => '1.31',
            'Pod::Man'              => '2.22',
            'Pod::ParseLink'        => '1.09',
            'Pod::ParseUtils'       => '1.36',
            'Pod::Parser'           => '1.37',
            'Pod::Perldoc'          => '3.14_04',
            'Pod::PlainText'        => '2.04',
            'Pod::Select'           => '1.36',
            'Pod::Simple'           => '3.07',
            'Pod::Simple::XHTML'    => '3.04',
            'Pod::Text'             => '3.13',
            'Pod::Text::Color'      => '2.05',
            'Pod::Text::Overstrike' => '2.03',
            'Pod::Text::Termcap'    => '2.05',
            'Pod::Usage'            => '1.36',
            'Safe'                  => '2.18',
            'Scalar::Util'          => '1.21',
            'Scalar::Util::PP'      => '1.21',
            'SelectSaver'           => '1.02',
            'SelfLoader'            => '1.17',
            'Socket'                => '1.82',
            'Storable'              => '2.20',
            'Switch'                => '2.14',
            'Symbol'                => '1.07',
            'Sys::Syslog'           => '0.27',
            'TAP::Base'             => '3.17',
            'TAP::Formatter::Base'  => '3.17',
            'TAP::Formatter::Color' => '3.17',
            'TAP::Formatter::Console'=> '3.17',
            'TAP::Formatter::Console::ParallelSession'=> '3.17',
            'TAP::Formatter::Console::Session'=> '3.17',
            'TAP::Formatter::File'  => '3.17',
            'TAP::Formatter::File::Session'=> '3.17',
            'TAP::Formatter::Session'=> '3.17',
            'TAP::Harness'          => '3.17',
            'TAP::Object'           => '3.17',
            'TAP::Parser'           => '3.17',
            'TAP::Parser::Aggregator'=> '3.17',
            'TAP::Parser::Grammar'  => '3.17',
            'TAP::Parser::Iterator' => '3.17',
            'TAP::Parser::Iterator::Array'=> '3.17',
            'TAP::Parser::Iterator::Process'=> '3.17',
            'TAP::Parser::Iterator::Stream'=> '3.17',
            'TAP::Parser::IteratorFactory'=> '3.17',
            'TAP::Parser::Multiplexer'=> '3.17',
            'TAP::Parser::Result'   => '3.17',
            'TAP::Parser::Result::Bailout'=> '3.17',
            'TAP::Parser::Result::Comment'=> '3.17',
            'TAP::Parser::Result::Plan'=> '3.17',
            'TAP::Parser::Result::Pragma'=> '3.17',
            'TAP::Parser::Result::Test'=> '3.17',
            'TAP::Parser::Result::Unknown'=> '3.17',
            'TAP::Parser::Result::Version'=> '3.17',
            'TAP::Parser::Result::YAML'=> '3.17',
            'TAP::Parser::ResultFactory'=> '3.17',
            'TAP::Parser::Scheduler'=> '3.17',
            'TAP::Parser::Scheduler::Job'=> '3.17',
            'TAP::Parser::Scheduler::Spinner'=> '3.17',
            'TAP::Parser::Source'   => '3.17',
            'TAP::Parser::Source::Perl'=> '3.17',
            'TAP::Parser::Utils'    => '3.17',
            'TAP::Parser::YAMLish::Reader'=> '3.17',
            'TAP::Parser::YAMLish::Writer'=> '3.17',
            'Term::ANSIColor'       => '2.00',
            'Term::ReadLine'        => '1.04',
            'Term::UI'              => '0.20',
            'Test'                  => '1.25_02',
            'Test::Builder'         => '0.92',
            'Test::Builder::Module' => '0.92',
            'Test::Builder::Tester' => '1.18',
            'Test::Builder::Tester::Color'=> '1.18',
            'Test::Harness'         => '3.17',
            'Test::More'            => '0.92',
            'Test::Simple'          => '0.92',
            'Text::ParseWords'      => '3.27',
            'Text::Tabs'            => '2009.0305',
            'Text::Wrap'            => '2009.0305',
            'Thread::Queue'         => '2.11',
            'Thread::Semaphore'     => '2.09',
            'Tie::Handle'           => '4.2',
            'Tie::Hash'             => '1.03',
            'Tie::RefHash'          => '1.38',
            'Tie::Scalar'           => '1.01',
            'Tie::StdHandle'        => '4.2',
            'Time::HiRes'           => '1.9719',
            'Time::Local'           => '1.1901',
            'Time::Piece'           => '1.15',
            'UNIVERSAL'             => '1.05',
            'Unicode'               => '5.1.0',
            'Unicode::Normalize'    => '1.03',
            'Unicode::UCD'          => '0.27',
            'VMS::Stdio'            => '2.4',
            'Win32'                 => '0.39',
            'Win32API::File'        => '0.1101',
            'XS::APItest'           => '0.15',
            'XS::Typemap'           => '0.03',
            'XSLoader'              => '0.10',
            'attributes'            => '0.09',
            'attrs'                 => '1.03',
            'autodie'               => '2.06_01',
            'autodie::exception'    => '2.06_01',
            'autodie::exception::system'=> '2.06_01',
            'autodie::hints'        => '2.06_01',
            'base'                  => '2.14',
            'bigint'                => '0.23',
            'bignum'                => '0.23',
            'bigrat'                => '0.23',
            'blib'                  => '1.04',
            'charnames'             => '1.07',
            'constant'              => '1.17',
            'encoding'              => '2.6_01',
            'feature'               => '1.13',
            'fields'                => '2.14',
            'lib'                   => '0.62',
            'mro'                   => '1.01',
            'open'                  => '1.07',
            'ops'                   => '1.02',
            'overload'              => '1.07',
            'overload::numbers'     => undef,
            'overloading'           => '0.01',
            'parent'                => '0.221',
            're'                    => '0.09',
            'threads'               => '1.72',
            'threads::shared'       => '1.29',
            'version'               => '0.77',
        },
        removed => {
            'CPAN::API::HOWTO'      => 1,
            'CPAN::DeferedCode'     => 1,
            'CPANPLUS::inc'         => 1,
            'ExtUtils::MakeMaker::bytes'=> 1,
            'ExtUtils::MakeMaker::vmsish'=> 1,
            'Test::Harness::Assert' => 1,
            'Test::Harness::Iterator'=> 1,
            'Test::Harness::Point'  => 1,
            'Test::Harness::Results'=> 1,
            'Test::Harness::Straps' => 1,
            'Test::Harness::Util'   => 1,
        }
    },
    5.011 => {
        delta_from => 5.010001,
        changed => {
            'Archive::Tar'          => '1.54',
            'Attribute::Handlers'   => '0.87',
            'AutoLoader'            => '5.70',
            'B::Deparse'            => '0.91',
            'B::Lint'               => '1.11_01',
            'B::Lint::Debug'        => '0.01',
            'CGI'                   => '3.45',
            'CGI::Apache'           => '1.01',
            'CGI::Carp'             => '3.45',
            'CGI::Pretty'           => '3.44',
            'CGI::Switch'           => '1.01',
            'CGI::Util'             => '3.45',
            'CPAN'                  => '1.94_51',
            'CPAN::Distribution'    => '1.94',
            'CPAN::FTP'             => '5.5002',
            'CPAN::Index'           => '1.94',
            'CPAN::LWP::UserAgent'  => '1.94',
            'CPANPLUS::Dist::Build' => '0.40',
            'CPANPLUS::Dist::Build::Constants'=> '0.40',
            'Carp'                  => '1.12',
            'Carp::Heavy'           => '1.12',
            'Class::ISA'            => '0.36',
            'Compress::Raw::Bzip2'  => '2.021',
            'Compress::Raw::Zlib'   => '2.021',
            'Compress::Zlib'        => '2.021',
            'Cwd'                   => '3.3002',
            'Data::Dumper'          => '2.125',
            'Encode'                => '2.37',
            'Exporter'              => '5.64',
            'Exporter::Heavy'       => '5.64',
            'ExtUtils::ParseXS'     => '2.200403',
            'File::Basename'        => '2.78',
            'File::Copy'            => '2.16',
            'File::stat'            => '1.02',
            'IO'                    => '1.25_01',
            'IO::Compress::Adapter::Bzip2'=> '2.021',
            'IO::Compress::Adapter::Deflate'=> '2.021',
            'IO::Compress::Adapter::Identity'=> '2.021',
            'IO::Compress::Base'    => '2.021',
            'IO::Compress::Base::Common'=> '2.021',
            'IO::Compress::Bzip2'   => '2.021',
            'IO::Compress::Deflate' => '2.021',
            'IO::Compress::Gzip'    => '2.021',
            'IO::Compress::Gzip::Constants'=> '2.021',
            'IO::Compress::RawDeflate'=> '2.021',
            'IO::Compress::Zip'     => '2.021',
            'IO::Compress::Zip::Constants'=> '2.021',
            'IO::Compress::Zlib::Constants'=> '2.021',
            'IO::Compress::Zlib::Extra'=> '2.021',
            'IO::Uncompress::Adapter::Bunzip2'=> '2.021',
            'IO::Uncompress::Adapter::Identity'=> '2.021',
            'IO::Uncompress::Adapter::Inflate'=> '2.021',
            'IO::Uncompress::AnyInflate'=> '2.021',
            'IO::Uncompress::AnyUncompress'=> '2.021',
            'IO::Uncompress::Base'  => '2.021',
            'IO::Uncompress::Bunzip2'=> '2.021',
            'IO::Uncompress::Gunzip'=> '2.021',
            'IO::Uncompress::Inflate'=> '2.021',
            'IO::Uncompress::RawInflate'=> '2.021',
            'IO::Uncompress::Unzip' => '2.021',
            'IO::Zlib'              => '1.10',
            'IPC::Cmd'              => '0.50',
            'IPC::Open3'            => '1.05',
            'Locale::Maketext::Simple'=> '0.21',
            'Log::Message::Simple'  => '0.06',
            'Math::BigInt'          => '1.89_01',
            'Math::BigRat'          => '0.24',
            'Module::Build'         => '0.35',
            'Module::Build::Base'   => '0.35',
            'Module::Build::Compat' => '0.35',
            'Module::Build::Config' => '0.35',
            'Module::Build::Cookbook'=> '0.35',
            'Module::Build::Dumper' => '0.35',
            'Module::Build::ModuleInfo'=> '0.35',
            'Module::Build::Notes'  => '0.35',
            'Module::Build::PPMMaker'=> '0.35',
            'Module::Build::Platform::Amiga'=> '0.35',
            'Module::Build::Platform::Default'=> '0.35',
            'Module::Build::Platform::EBCDIC'=> '0.35',
            'Module::Build::Platform::MPEiX'=> '0.35',
            'Module::Build::Platform::MacOS'=> '0.35',
            'Module::Build::Platform::RiscOS'=> '0.35',
            'Module::Build::Platform::Unix'=> '0.35',
            'Module::Build::Platform::VMS'=> '0.35',
            'Module::Build::Platform::VOS'=> '0.35',
            'Module::Build::Platform::Windows'=> '0.35',
            'Module::Build::Platform::aix'=> '0.35',
            'Module::Build::Platform::cygwin'=> '0.35',
            'Module::Build::Platform::darwin'=> '0.35',
            'Module::Build::Platform::os2'=> '0.35',
            'Module::Build::PodParser'=> '0.35',
            'Module::CoreList'      => '2.19',
            'Module::Loaded'        => '0.06',
            'Opcode'                => '1.13',
            'PerlIO::via'           => '0.08',
            'Pod::Perldoc'          => '3.15_01',
            'Pod::Plainer'          => '1.01',
            'Safe'                  => '2.19',
            'Socket'                => '1.84',
            'Switch'                => '2.14_01',
            'Term::ANSIColor'       => '2.02',
            'Term::ReadLine'        => '1.05',
            'Text::Balanced'        => '2.02',
            'Text::Soundex'         => '3.03_01',
            'Time::Local'           => '1.1901_01',
            'Unicode::Collate'      => '0.52_01',
            'attributes'            => '0.12',
            'constant'              => '1.19',
            'deprecate'             => '0.01',
            'overload'              => '1.08',
            'parent'                => '0.223',
            're'                    => '0.10',
            'threads'               => '1.74',
            'threads::shared'       => '1.31',
            'warnings'              => '1.07',
        },
        removed => {
            'attrs'                 => 1,
        }
    },
    5.011001 => {
        delta_from => 5.011,
        changed => {
            'B'                     => '1.23',
            'B::Concise'            => '0.77',
            'B::Deparse'            => '0.92',
            'CGI'                   => '3.48',
            'CGI::Pretty'           => '3.46',
            'CGI::Util'             => '3.48',
            'CPANPLUS'              => '0.89_03',
            'CPANPLUS::Internals'   => '0.89_03',
            'CPANPLUS::Shell::Default'=> '0.89_03',
            'Carp'                  => '1.13',
            'Carp::Heavy'           => '1.13',
            'ExtUtils::CBuilder'    => '0.260301',
            'ExtUtils::CBuilder::Base'=> '0.260301',
            'ExtUtils::CBuilder::Platform::Unix'=> '0.260301',
            'ExtUtils::CBuilder::Platform::VMS'=> '0.260301',
            'ExtUtils::CBuilder::Platform::Windows'=> '0.260301',
            'ExtUtils::CBuilder::Platform::aix'=> '0.260301',
            'ExtUtils::CBuilder::Platform::cygwin'=> '0.260301',
            'ExtUtils::CBuilder::Platform::darwin'=> '0.260301',
            'ExtUtils::CBuilder::Platform::dec_osf'=> '0.260301',
            'ExtUtils::CBuilder::Platform::os2'=> '0.260301',
            'ExtUtils::Install'     => '1.55',
            'ExtUtils::Manifest'    => '1.57',
            'ExtUtils::Packlist'    => '1.44',
            'ExtUtils::ParseXS'     => '2.21',
            'File::Glob'            => '1.07',
            'File::Path'            => '2.08',
            'IO'                    => '1.25_02',
            'Module::CoreList'      => '2.21',
            'OS2::DLL'              => '1.04',
            'OS2::Process'          => '1.04',
            'Object::Accessor'      => '0.36',
            'Opcode'                => '1.15',
            'POSIX'                 => '1.18',
            'Parse::CPAN::Meta'     => '1.40',
            'PerlIO::via'           => '0.09',
            'Pod::Simple'           => '3.08',
            'Socket'                => '1.85',
            'Storable'              => '2.22',
            'Switch'                => '2.15',
            'Test::Builder'         => '0.94',
            'Test::Builder::Module' => '0.94',
            'Test::More'            => '0.94',
            'Test::Simple'          => '0.94',
            'XS::APItest'           => '0.16',
            'mro'                   => '1.02',
            'overload'              => '1.09',
            'threads::shared'       => '1.32',
        },
        removed => {
        }
    },
    5.011002 => {
        delta_from => 5.011001,
        changed => {
            'B::Concise'            => '0.78',
            'B::Deparse'            => '0.93',
            'CPANPLUS'              => '0.89_09',
            'CPANPLUS::Dist::Build' => '0.44',
            'CPANPLUS::Dist::Build::Constants'=> '0.44',
            'CPANPLUS::Internals'   => '0.89_09',
            'CPANPLUS::Shell::Default'=> '0.89_09',
            'Carp'                  => '1.14',
            'Carp::Heavy'           => '1.14',
            'Compress::Zlib'        => '2.022',
            'DBM_Filter'            => '0.03',
            'Encode'                => '2.38',
            'Encode::Byte'          => '2.04',
            'Encode::CN'            => '2.03',
            'Encode::JP'            => '2.04',
            'Encode::KR'            => '2.03',
            'Encode::TW'            => '2.03',
            'Encode::Unicode'       => '2.07',
            'Env'                   => '1.01',
            'Exporter'              => '5.64_01',
            'Exporter::Heavy'       => '5.64_01',
            'ExtUtils::CBuilder'    => '0.27',
            'ExtUtils::CBuilder::Base'=> '0.27',
            'ExtUtils::CBuilder::Platform::Unix'=> '0.27',
            'ExtUtils::CBuilder::Platform::VMS'=> '0.27',
            'ExtUtils::CBuilder::Platform::Windows'=> '0.27',
            'ExtUtils::CBuilder::Platform::Windows::BCC'=> '0.27',
            'ExtUtils::CBuilder::Platform::Windows::GCC'=> '0.27',
            'ExtUtils::CBuilder::Platform::Windows::MSVC'=> '0.27',
            'ExtUtils::CBuilder::Platform::aix'=> '0.27',
            'ExtUtils::CBuilder::Platform::cygwin'=> '0.27',
            'ExtUtils::CBuilder::Platform::darwin'=> '0.27',
            'ExtUtils::CBuilder::Platform::dec_osf'=> '0.27',
            'ExtUtils::CBuilder::Platform::os2'=> '0.27',
            'File::Fetch'           => '0.22',
            'I18N::LangTags::Detect'=> '1.04',
            'I18N::Langinfo'        => '0.03',
            'IO::Compress::Adapter::Bzip2'=> '2.022',
            'IO::Compress::Adapter::Deflate'=> '2.022',
            'IO::Compress::Adapter::Identity'=> '2.022',
            'IO::Compress::Base'    => '2.022',
            'IO::Compress::Base::Common'=> '2.022',
            'IO::Compress::Bzip2'   => '2.022',
            'IO::Compress::Deflate' => '2.022',
            'IO::Compress::Gzip'    => '2.022',
            'IO::Compress::Gzip::Constants'=> '2.022',
            'IO::Compress::RawDeflate'=> '2.022',
            'IO::Compress::Zip'     => '2.022',
            'IO::Compress::Zip::Constants'=> '2.022',
            'IO::Compress::Zlib::Constants'=> '2.022',
            'IO::Compress::Zlib::Extra'=> '2.022',
            'IO::Uncompress::Adapter::Bunzip2'=> '2.022',
            'IO::Uncompress::Adapter::Identity'=> '2.022',
            'IO::Uncompress::Adapter::Inflate'=> '2.022',
            'IO::Uncompress::AnyInflate'=> '2.022',
            'IO::Uncompress::AnyUncompress'=> '2.022',
            'IO::Uncompress::Base'  => '2.022',
            'IO::Uncompress::Bunzip2'=> '2.022',
            'IO::Uncompress::Gunzip'=> '2.022',
            'IO::Uncompress::Inflate'=> '2.022',
            'IO::Uncompress::RawInflate'=> '2.022',
            'IO::Uncompress::Unzip' => '2.022',
            'IPC::Cmd'              => '0.54',
            'List::Util'            => '1.22',
            'List::Util::PP'        => '1.22',
            'List::Util::XS'        => '1.22',
            'Locale::Maketext'      => '1.14',
            'Module::Build'         => '0.35_09',
            'Module::Build::Base'   => '0.35_09',
            'Module::Build::Compat' => '0.35_09',
            'Module::Build::Config' => '0.35_09',
            'Module::Build::Cookbook'=> '0.35_09',
            'Module::Build::Dumper' => '0.35_09',
            'Module::Build::ModuleInfo'=> '0.35_09',
            'Module::Build::Notes'  => '0.35_09',
            'Module::Build::PPMMaker'=> '0.35_09',
            'Module::Build::Platform::Amiga'=> '0.35_09',
            'Module::Build::Platform::Default'=> '0.35_09',
            'Module::Build::Platform::EBCDIC'=> '0.35_09',
            'Module::Build::Platform::MPEiX'=> '0.35_09',
            'Module::Build::Platform::MacOS'=> '0.35_09',
            'Module::Build::Platform::RiscOS'=> '0.35_09',
            'Module::Build::Platform::Unix'=> '0.35_09',
            'Module::Build::Platform::VMS'=> '0.35_09',
            'Module::Build::Platform::VOS'=> '0.35_09',
            'Module::Build::Platform::Windows'=> '0.35_09',
            'Module::Build::Platform::aix'=> '0.35_09',
            'Module::Build::Platform::cygwin'=> '0.35_09',
            'Module::Build::Platform::darwin'=> '0.35_09',
            'Module::Build::Platform::os2'=> '0.35_09',
            'Module::Build::PodParser'=> '0.35_09',
            'Module::Build::YAML'   => '1.40',
            'Module::CoreList'      => '2.23',
            'Module::Load::Conditional'=> '0.34',
            'Pod::Simple'           => '3.10',
            'Pod::Simple::XHTML'    => '3.10',
            'Scalar::Util'          => '1.22',
            'Scalar::Util::PP'      => '1.22',
            'Switch'                => '2.16',
            'XS::APItest'           => '0.17',
            'XS::APItest::KeywordRPN'=> '0.003',
            'base'                  => '2.15',
            'diagnostics'           => '1.18',
            'fields'                => '2.15',
            'inc::latest'           => '0.35_09',
            'legacy'                => '1.00',
            'overload'              => '1.10',
        },
        removed => {
        }
    },
    5.011003 => {
        delta_from => 5.011002,
        changed => {
            'App::Cpan'             => '1.570001',
            'Archive::Extract'      => '0.36',
            'CPAN'                  => '1.94_5301',
            'CPAN::FTP'             => '5.5004',
            'CPAN::FirstTime'       => '5.530001',
            'CPAN::Mirrors'         => '1.770001',
            'CPANPLUS'              => '0.90',
            'CPANPLUS::Internals'   => '0.90',
            'CPANPLUS::Shell::Default'=> '0.90',
            'Cwd'                   => '3.31',
            'Encode'                => '2.39',
            'ExtUtils::Command::MM' => '6.56',
            'ExtUtils::Liblist'     => '6.56',
            'ExtUtils::Liblist::Kid'=> '6.56',
            'ExtUtils::MM'          => '6.56',
            'ExtUtils::MM_AIX'      => '6.56',
            'ExtUtils::MM_Any'      => '6.56',
            'ExtUtils::MM_BeOS'     => '6.56',
            'ExtUtils::MM_Cygwin'   => '6.56',
            'ExtUtils::MM_DOS'      => '6.56',
            'ExtUtils::MM_Darwin'   => '6.56',
            'ExtUtils::MM_MacOS'    => '6.56',
            'ExtUtils::MM_NW5'      => '6.56',
            'ExtUtils::MM_OS2'      => '6.56',
            'ExtUtils::MM_QNX'      => '6.56',
            'ExtUtils::MM_UWIN'     => '6.56',
            'ExtUtils::MM_Unix'     => '6.56',
            'ExtUtils::MM_VMS'      => '6.56',
            'ExtUtils::MM_VOS'      => '6.56',
            'ExtUtils::MM_Win32'    => '6.56',
            'ExtUtils::MM_Win95'    => '6.56',
            'ExtUtils::MY'          => '6.56',
            'ExtUtils::MakeMaker'   => '6.56',
            'ExtUtils::MakeMaker::Config'=> '6.56',
            'ExtUtils::Mkbootstrap' => '6.56',
            'ExtUtils::Mksymlists'  => '6.56',
            'ExtUtils::testlib'     => '6.56',
            'File::Find'            => '1.15',
            'File::Path'            => '2.08_01',
            'File::Spec'            => '3.31',
            'Module::Build'         => '0.36',
            'Module::Build::Base'   => '0.36',
            'Module::Build::Compat' => '0.36',
            'Module::Build::Config' => '0.36',
            'Module::Build::Cookbook'=> '0.36',
            'Module::Build::Dumper' => '0.36',
            'Module::Build::ModuleInfo'=> '0.36',
            'Module::Build::Notes'  => '0.36',
            'Module::Build::PPMMaker'=> '0.36',
            'Module::Build::Platform::Amiga'=> '0.36',
            'Module::Build::Platform::Default'=> '0.36',
            'Module::Build::Platform::EBCDIC'=> '0.36',
            'Module::Build::Platform::MPEiX'=> '0.36',
            'Module::Build::Platform::MacOS'=> '0.36',
            'Module::Build::Platform::RiscOS'=> '0.36',
            'Module::Build::Platform::Unix'=> '0.36',
            'Module::Build::Platform::VMS'=> '0.36',
            'Module::Build::Platform::VOS'=> '0.36',
            'Module::Build::Platform::Windows'=> '0.36',
            'Module::Build::Platform::aix'=> '0.36',
            'Module::Build::Platform::cygwin'=> '0.36',
            'Module::Build::Platform::darwin'=> '0.36',
            'Module::Build::Platform::os2'=> '0.36',
            'Module::Build::PodParser'=> '0.36',
            'Module::CoreList'      => '2.24',
            'POSIX'                 => '1.19',
            'Pod::Simple'           => '3.13',
            'Pod::Simple::BlackBox' => '3.13',
            'Pod::Simple::Checker'  => '3.13',
            'Pod::Simple::Debug'    => '3.13',
            'Pod::Simple::DumpAsText'=> '3.13',
            'Pod::Simple::DumpAsXML'=> '3.13',
            'Pod::Simple::HTML'     => '3.13',
            'Pod::Simple::HTMLBatch'=> '3.13',
            'Pod::Simple::LinkSection'=> '3.13',
            'Pod::Simple::Methody'  => '3.13',
            'Pod::Simple::Progress' => '3.13',
            'Pod::Simple::PullParser'=> '3.13',
            'Pod::Simple::PullParserEndToken'=> '3.13',
            'Pod::Simple::PullParserStartToken'=> '3.13',
            'Pod::Simple::PullParserTextToken'=> '3.13',
            'Pod::Simple::PullParserToken'=> '3.13',
            'Pod::Simple::RTF'      => '3.13',
            'Pod::Simple::Search'   => '3.13',
            'Pod::Simple::SimpleTree'=> '3.13',
            'Pod::Simple::Text'     => '3.13',
            'Pod::Simple::TextContent'=> '3.13',
            'Pod::Simple::TiedOutFH'=> '3.13',
            'Pod::Simple::Transcode'=> '3.13',
            'Pod::Simple::TranscodeDumb'=> '3.13',
            'Pod::Simple::TranscodeSmart'=> '3.13',
            'Pod::Simple::XHTML'    => '3.13',
            'Pod::Simple::XMLOutStream'=> '3.13',
            'Safe'                  => '2.20',
            'Unicode'               => '5.2.0',
            'constant'              => '1.20',
            'diagnostics'           => '1.19',
            'feature'               => '1.14',
            'inc::latest'           => '0.36',
            'threads'               => '1.75',
            'warnings'              => '1.08',
        },
        removed => {
            'legacy'                => 1,
        }
    },
    5.011004 => {
        delta_from => 5.011003,
        changed => {
            'App::Cpan'             => '1.5701',
            'Archive::Extract'      => '0.38',
            'B::Deparse'            => '0.94',
            'CPAN'                  => '1.94_54',
            'CPAN::FirstTime'       => '5.53',
            'CPAN::Mirrors'         => '1.77',
            'Carp'                  => '1.15',
            'Carp::Heavy'           => '1.15',
            'Compress::Raw::Bzip2'  => '2.024',
            'Compress::Raw::Zlib'   => '2.024',
            'Compress::Zlib'        => '2.024',
            'File::Copy'            => '2.17',
            'File::Fetch'           => '0.24',
            'GDBM_File'             => '1.10',
            'IO::Compress::Adapter::Bzip2'=> '2.024',
            'IO::Compress::Adapter::Deflate'=> '2.024',
            'IO::Compress::Adapter::Identity'=> '2.024',
            'IO::Compress::Base'    => '2.024',
            'IO::Compress::Base::Common'=> '2.024',
            'IO::Compress::Bzip2'   => '2.024',
            'IO::Compress::Deflate' => '2.024',
            'IO::Compress::Gzip'    => '2.024',
            'IO::Compress::Gzip::Constants'=> '2.024',
            'IO::Compress::RawDeflate'=> '2.024',
            'IO::Compress::Zip'     => '2.024',
            'IO::Compress::Zip::Constants'=> '2.024',
            'IO::Compress::Zlib::Constants'=> '2.024',
            'IO::Compress::Zlib::Extra'=> '2.024',
            'IO::Uncompress::Adapter::Bunzip2'=> '2.024',
            'IO::Uncompress::Adapter::Identity'=> '2.024',
            'IO::Uncompress::Adapter::Inflate'=> '2.024',
            'IO::Uncompress::AnyInflate'=> '2.024',
            'IO::Uncompress::AnyUncompress'=> '2.024',
            'IO::Uncompress::Base'  => '2.024',
            'IO::Uncompress::Bunzip2'=> '2.024',
            'IO::Uncompress::Gunzip'=> '2.024',
            'IO::Uncompress::Inflate'=> '2.024',
            'IO::Uncompress::RawInflate'=> '2.024',
            'IO::Uncompress::Unzip' => '2.024',
            'Module::Build'         => '0.3603',
            'Module::Build::Base'   => '0.3603',
            'Module::Build::Compat' => '0.3603',
            'Module::Build::Config' => '0.3603',
            'Module::Build::Cookbook'=> '0.3603',
            'Module::Build::Dumper' => '0.3603',
            'Module::Build::ModuleInfo'=> '0.3603',
            'Module::Build::Notes'  => '0.3603',
            'Module::Build::PPMMaker'=> '0.3603',
            'Module::Build::Platform::Amiga'=> '0.3603',
            'Module::Build::Platform::Default'=> '0.3603',
            'Module::Build::Platform::EBCDIC'=> '0.3603',
            'Module::Build::Platform::MPEiX'=> '0.3603',
            'Module::Build::Platform::MacOS'=> '0.3603',
            'Module::Build::Platform::RiscOS'=> '0.3603',
            'Module::Build::Platform::Unix'=> '0.3603',
            'Module::Build::Platform::VMS'=> '0.3603',
            'Module::Build::Platform::VOS'=> '0.3603',
            'Module::Build::Platform::Windows'=> '0.3603',
            'Module::Build::Platform::aix'=> '0.3603',
            'Module::Build::Platform::cygwin'=> '0.3603',
            'Module::Build::Platform::darwin'=> '0.3603',
            'Module::Build::Platform::os2'=> '0.3603',
            'Module::Build::PodParser'=> '0.3603',
            'Module::CoreList'      => '2.25',
            'PerlIO::encoding'      => '0.12',
            'Safe'                  => '2.21',
            'UNIVERSAL'             => '1.06',
            'feature'               => '1.15',
            'inc::latest'           => '0.3603',
            'less'                  => '0.03',
            're'                    => '0.11',
            'version'               => '0.81',
            'warnings'              => '1.09',
        },
        removed => {
        }
    },
    5.011005 => {
        delta_from => 5.011004,
        changed => {
            'B::Debug'              => '1.12',
            'CPAN'                  => '1.94_56',
            'CPAN::Debug'           => '5.5001',
            'CPAN::Distribution'    => '1.9456',
            'CPAN::FirstTime'       => '5.5301',
            'CPAN::HandleConfig'    => '5.5001',
            'CPAN::Shell'           => '5.5001',
            'CPAN::Tarzip'          => '5.5011',
            'CPANPLUS::Dist::Build' => '0.46',
            'CPANPLUS::Dist::Build::Constants'=> '0.46',
            'Module::CoreList'      => '2.26',
            'Pod::Man'              => '2.23',
            'Pod::ParseLink'        => '1.10',
            'Pod::Perldoc'          => '3.15_02',
            'Pod::Plainer'          => '1.02',
            'Pod::Text'             => '3.14',
            'Pod::Text::Color'      => '2.06',
            'Pod::Text::Overstrike' => '2.04',
            'Pod::Text::Termcap'    => '2.06',
            'Safe'                  => '2.22',
            'Socket'                => '1.86',
            'version'               => '0.82',
        },
        removed => {
        }
    },
    5.012 => {
        delta_from => 5.011005,
        changed => {
            'B::Deparse'            => '0.96',
            'CPAN::Distribution'    => '1.9456_01',
            'Module::CoreList'      => '2.29',
            'Safe'                  => '2.25',
            'Socket'                => '1.87',
            'Tie::Scalar'           => '1.02',
            'Time::Piece'           => '1.15_01',
            'bytes'                 => '1.04',
            'feature'               => '1.16',
            'utf8'                  => '1.08',
        },
        removed => {
        }
    },
    5.012001 => {
        delta_from => 5.012,
        changed => {
            'B::Deparse'            => '0.97',
            'CGI'                   => '3.49',
            'CGI::Fast'             => '1.08',
            'Carp'                  => '1.16',
            'Carp::Heavy'           => '1.16',
            'File::Copy'            => '2.18',
            'Module::CoreList'      => '2.32',
            'Pod::Functions'        => '1.04',
            'Pod::Simple'           => '3.14',
            'Pod::Simple::BlackBox' => '3.14',
            'Pod::Simple::Checker'  => '3.14',
            'Pod::Simple::Debug'    => '3.14',
            'Pod::Simple::DumpAsText'=> '3.14',
            'Pod::Simple::DumpAsXML'=> '3.14',
            'Pod::Simple::HTML'     => '3.14',
            'Pod::Simple::HTMLBatch'=> '3.14',
            'Pod::Simple::LinkSection'=> '3.14',
            'Pod::Simple::Methody'  => '3.14',
            'Pod::Simple::Progress' => '3.14',
            'Pod::Simple::PullParser'=> '3.14',
            'Pod::Simple::PullParserEndToken'=> '3.14',
            'Pod::Simple::PullParserStartToken'=> '3.14',
            'Pod::Simple::PullParserTextToken'=> '3.14',
            'Pod::Simple::PullParserToken'=> '3.14',
            'Pod::Simple::RTF'      => '3.14',
            'Pod::Simple::Search'   => '3.14',
            'Pod::Simple::SimpleTree'=> '3.14',
            'Pod::Simple::Text'     => '3.14',
            'Pod::Simple::TextContent'=> '3.14',
            'Pod::Simple::TiedOutFH'=> '3.14',
            'Pod::Simple::Transcode'=> '3.14',
            'Pod::Simple::TranscodeDumb'=> '3.14',
            'Pod::Simple::TranscodeSmart'=> '3.14',
            'Pod::Simple::XHTML'    => '3.14',
            'Pod::Simple::XMLOutStream'=> '3.14',
            'Safe'                  => '2.27',
        },
        removed => {
        }
    },
    5.012002 => {
        delta_from => 5.012001,
        changed => {
            'Carp'                  => '1.17',
            'Carp::Heavy'           => '1.17',
            'File::Spec'            => '3.31_01',
            'Module::CoreList'      => '2.38',
            'Module::Load::Conditional'=> '0.38',
            'PerlIO::scalar'        => '0.08',
        },
        removed => {
        }
    },
    5.012003 => {
        delta_from => 5.012002,
        changed => {
            'B::Deparse'            => '0.9701',
            'Module::Build::Platform::cygwin'=> '0.360301',
            'Module::CoreList'      => '2.43',
            'Socket'                => '1.87_01',
        },
        removed => {
        }
    },
    5.012004 => {
        delta_from => 5.012003,
        changed => {
            'Module::CoreList'      => '2.50',
        },
        removed => {
        }
    },
    5.012005 => {
        delta_from => 5.012004,
        changed => {
            'B::Concise'            => '0.78_01',
            'Encode'                => '2.39_01',
            'File::Glob'            => '1.07_01',
            'Module::CoreList'      => '2.50_02',
            'Unicode::UCD'          => '0.29',
            'charnames'             => '1.07_01',
        },
        removed => {
        }
    },
    5.013 => {
        delta_from => 5.012,
        changed => {
            'CGI'                   => '3.49',
            'CGI::Fast'             => '1.08',
            'Data::Dumper'          => '2.126',
            'ExtUtils::MM_Unix'     => '6.5601',
            'ExtUtils::MakeMaker'   => '6.5601',
            'File::Copy'            => '2.18',
            'IPC::Open3'            => '1.06',
            'MIME::Base64'          => '3.09',
            'MIME::QuotedPrint'     => '3.09',
            'Module::CoreList'      => '2.31',
            'Pod::Functions'        => '1.04',
            'XS::APItest'           => '0.18',
            'XS::APItest::KeywordRPN'=> '0.004',
            'feature'               => '1.17',
            'threads'               => '1.77_01',
            'threads::shared'       => '1.33',
        },
        removed => {
        }
    },
    5.013001 => {
        delta_from => 5.012001,
        changed => {
            'Data::Dumper'          => '2.126',
            'Dumpvalue'             => '1.14',
            'Errno'                 => '1.12',
            'ExtUtils::MM_Unix'     => '6.5601',
            'ExtUtils::MakeMaker'   => '6.5601',
            'ExtUtils::ParseXS'     => '2.2205',
            'File::Find'            => '1.16',
            'IPC::Cmd'              => '0.58',
            'IPC::Open3'            => '1.06',
            'List::Util'            => '1.23',
            'List::Util::PP'        => '1.23',
            'List::Util::XS'        => '1.23',
            'Locale::Codes'         => '3.12',
            'Locale::Codes::Country'=> '3.12',
            'Locale::Codes::Currency'=> '3.12',
            'Locale::Codes::Language'=> '3.12',
            'Locale::Codes::Script' => '3.12',
            'Locale::Constants'     => '3.12',
            'Locale::Country'       => '3.12',
            'Locale::Currency'      => '3.12',
            'Locale::Language'      => '3.12',
            'Locale::Script'        => '3.12',
            'MIME::Base64'          => '3.09',
            'MIME::QuotedPrint'     => '3.09',
            'Module::Build::Platform::cygwin'=> '0.360301',
            'Module::CoreList'      => '2.34',
            'Module::Load::Conditional'=> '0.38',
            'PerlIO::scalar'        => '0.08',
            'Scalar::Util'          => '1.23',
            'Scalar::Util::PP'      => '1.23',
            'Socket'                => '1.88',
            'Term::ReadLine'        => '1.06',
            'Unicode::UCD'          => '0.28',
            'XS::APItest'           => '0.19',
            'XS::APItest::KeywordRPN'=> '0.004',
            'charnames'             => '1.08',
            'feature'               => '1.17',
            'threads'               => '1.77_01',
            'threads::shared'       => '1.33',
        },
        removed => {
            'Class::ISA'            => 1,
            'Pod::Plainer'          => 1,
            'Switch'                => 1,
        }
    },
    5.013002 => {
        delta_from => 5.013001,
        changed => {
            'B::Concise'            => '0.79',
            'B::Deparse'            => '0.98',
            'CPAN'                  => '1.94_57',
            'CPAN::Distribution'    => '1.9600',
            'Exporter'              => '5.64_02',
            'Exporter::Heavy'       => '5.64_02',
            'File::Copy'            => '2.19',
            'Hash::Util'            => '0.08',
            'IO::Socket'            => '1.32',
            'Locale::Codes'         => '3.13',
            'Locale::Codes::Country'=> '3.13',
            'Locale::Codes::Currency'=> '3.13',
            'Locale::Codes::Language'=> '3.13',
            'Locale::Codes::Script' => '3.13',
            'Locale::Constants'     => '3.13',
            'Locale::Country'       => '3.13',
            'Locale::Currency'      => '3.13',
            'Locale::Language'      => '3.13',
            'Locale::Script'        => '3.13',
            'Search::Dict'          => '1.03',
            'Socket'                => '1.89',
            'Thread::Semaphore'     => '2.11',
            'UNIVERSAL'             => '1.07',
            'VMS::DCLsym'           => '1.04',
            'mro'                   => '1.03',
            'threads'               => '1.77_02',
            'threads::shared'       => '1.33_01',
        },
        removed => {
        }
    },
    5.013003 => {
        delta_from => 5.013002,
        changed => {
            'App::Prove'            => '3.21',
            'App::Prove::State'     => '3.21',
            'App::Prove::State::Result'=> '3.21',
            'App::Prove::State::Result::Test'=> '3.21',
            'Archive::Extract'      => '0.42',
            'Archive::Tar'          => '1.64',
            'Archive::Tar::Constant'=> '1.64',
            'Archive::Tar::File'    => '1.64',
            'Attribute::Handlers'   => '0.88',
            'CPANPLUS'              => '0.9007',
            'CPANPLUS::Internals'   => '0.9007',
            'CPANPLUS::Shell::Default'=> '0.9007',
            'Compress::Raw::Bzip2'  => '2.027',
            'Compress::Raw::Zlib'   => '2.027_01',
            'Compress::Zlib'        => '2.027',
            'DB'                    => '1.03',
            'Digest::MD5'           => '2.40',
            'Digest::SHA'           => '5.48',
            'Exporter'              => '5.64_03',
            'Exporter::Heavy'       => '5.64_03',
            'ExtUtils::CBuilder'    => '0.2703',
            'ExtUtils::CBuilder::Base'=> '0.2703_01',
            'ExtUtils::CBuilder::Platform::Unix'=> '0.2703',
            'ExtUtils::CBuilder::Platform::VMS'=> '0.2703',
            'ExtUtils::CBuilder::Platform::Windows'=> '0.2703',
            'ExtUtils::CBuilder::Platform::Windows::BCC'=> '0.2703',
            'ExtUtils::CBuilder::Platform::Windows::GCC'=> '0.2703',
            'ExtUtils::CBuilder::Platform::Windows::MSVC'=> '0.2703',
            'ExtUtils::CBuilder::Platform::aix'=> '0.2703',
            'ExtUtils::CBuilder::Platform::cygwin'=> '0.2703',
            'ExtUtils::CBuilder::Platform::darwin'=> '0.2703',
            'ExtUtils::CBuilder::Platform::dec_osf'=> '0.2703',
            'ExtUtils::CBuilder::Platform::os2'=> '0.2703',
            'ExtUtils::Manifest'    => '1.58',
            'ExtUtils::ParseXS'     => '2.2206',
            'Fatal'                 => '2.10',
            'File::Basename'        => '2.79',
            'File::Copy'            => '2.20',
            'File::DosGlob'         => '1.02',
            'File::Find'            => '1.17',
            'File::Glob'            => '1.08',
            'File::stat'            => '1.03',
            'I18N::LangTags'        => '0.35_01',
            'I18N::LangTags::List'  => '0.35_01',
            'IO::Compress::Adapter::Bzip2'=> '2.027',
            'IO::Compress::Adapter::Deflate'=> '2.027',
            'IO::Compress::Adapter::Identity'=> '2.027',
            'IO::Compress::Base'    => '2.027',
            'IO::Compress::Base::Common'=> '2.027',
            'IO::Compress::Bzip2'   => '2.027',
            'IO::Compress::Deflate' => '2.027',
            'IO::Compress::Gzip'    => '2.027',
            'IO::Compress::Gzip::Constants'=> '2.027',
            'IO::Compress::RawDeflate'=> '2.027',
            'IO::Compress::Zip'     => '2.027',
            'IO::Compress::Zip::Constants'=> '2.027',
            'IO::Compress::Zlib::Constants'=> '2.027',
            'IO::Compress::Zlib::Extra'=> '2.027',
            'IO::Uncompress::Adapter::Bunzip2'=> '2.027',
            'IO::Uncompress::Adapter::Identity'=> '2.027',
            'IO::Uncompress::Adapter::Inflate'=> '2.027',
            'IO::Uncompress::AnyInflate'=> '2.027',
            'IO::Uncompress::AnyUncompress'=> '2.027',
            'IO::Uncompress::Base'  => '2.027',
            'IO::Uncompress::Bunzip2'=> '2.027',
            'IO::Uncompress::Gunzip'=> '2.027',
            'IO::Uncompress::Inflate'=> '2.027',
            'IO::Uncompress::RawInflate'=> '2.027',
            'IO::Uncompress::Unzip' => '2.027',
            'IPC::Cmd'              => '0.60',
            'IPC::Msg'              => '2.03',
            'IPC::Semaphore'        => '2.03',
            'IPC::SharedMem'        => '2.03',
            'IPC::SysV'             => '2.03',
            'Locale::Maketext'      => '1.15',
            'Locale::Maketext::Guts'=> undef,
            'Locale::Maketext::GutsLoader'=> undef,
            'Module::Build'         => '0.3607',
            'Module::Build::Base'   => '0.3607',
            'Module::Build::Compat' => '0.3607',
            'Module::Build::Config' => '0.3607',
            'Module::Build::Cookbook'=> '0.3607',
            'Module::Build::Dumper' => '0.3607',
            'Module::Build::ModuleInfo'=> '0.3607',
            'Module::Build::Notes'  => '0.3607',
            'Module::Build::PPMMaker'=> '0.3607',
            'Module::Build::Platform::Amiga'=> '0.3607',
            'Module::Build::Platform::Default'=> '0.3607',
            'Module::Build::Platform::EBCDIC'=> '0.3607',
            'Module::Build::Platform::MPEiX'=> '0.3607',
            'Module::Build::Platform::MacOS'=> '0.3607',
            'Module::Build::Platform::RiscOS'=> '0.3607',
            'Module::Build::Platform::Unix'=> '0.3607',
            'Module::Build::Platform::VMS'=> '0.3607',
            'Module::Build::Platform::VOS'=> '0.3607',
            'Module::Build::Platform::Windows'=> '0.3607',
            'Module::Build::Platform::aix'=> '0.3607',
            'Module::Build::Platform::cygwin'=> '0.3607',
            'Module::Build::Platform::darwin'=> '0.3607',
            'Module::Build::Platform::os2'=> '0.3607',
            'Module::Build::PodParser'=> '0.3607',
            'Module::CoreList'      => '2.36',
            'Module::Load'          => '0.18',
            'TAP::Base'             => '3.21',
            'TAP::Formatter::Base'  => '3.21',
            'TAP::Formatter::Color' => '3.21',
            'TAP::Formatter::Console'=> '3.21',
            'TAP::Formatter::Console::ParallelSession'=> '3.21',
            'TAP::Formatter::Console::Session'=> '3.21',
            'TAP::Formatter::File'  => '3.21',
            'TAP::Formatter::File::Session'=> '3.21',
            'TAP::Formatter::Session'=> '3.21',
            'TAP::Harness'          => '3.21',
            'TAP::Object'           => '3.21',
            'TAP::Parser'           => '3.21',
            'TAP::Parser::Aggregator'=> '3.21',
            'TAP::Parser::Grammar'  => '3.21',
            'TAP::Parser::Iterator' => '3.21',
            'TAP::Parser::Iterator::Array'=> '3.21',
            'TAP::Parser::Iterator::Process'=> '3.21',
            'TAP::Parser::Iterator::Stream'=> '3.21',
            'TAP::Parser::IteratorFactory'=> '3.21',
            'TAP::Parser::Multiplexer'=> '3.21',
            'TAP::Parser::Result'   => '3.21',
            'TAP::Parser::Result::Bailout'=> '3.21',
            'TAP::Parser::Result::Comment'=> '3.21',
            'TAP::Parser::Result::Plan'=> '3.21',
            'TAP::Parser::Result::Pragma'=> '3.21',
            'TAP::Parser::Result::Test'=> '3.21',
            'TAP::Parser::Result::Unknown'=> '3.21',
            'TAP::Parser::Result::Version'=> '3.21',
            'TAP::Parser::Result::YAML'=> '3.21',
            'TAP::Parser::ResultFactory'=> '3.21',
            'TAP::Parser::Scheduler'=> '3.21',
            'TAP::Parser::Scheduler::Job'=> '3.21',
            'TAP::Parser::Scheduler::Spinner'=> '3.21',
            'TAP::Parser::Source'   => '3.21',
            'TAP::Parser::SourceHandler'=> '3.21',
            'TAP::Parser::SourceHandler::Executable'=> '3.21',
            'TAP::Parser::SourceHandler::File'=> '3.21',
            'TAP::Parser::SourceHandler::Handle'=> '3.21',
            'TAP::Parser::SourceHandler::Perl'=> '3.21',
            'TAP::Parser::SourceHandler::RawTAP'=> '3.21',
            'TAP::Parser::SourceHandler::pgTAP'=> '3.21',
            'TAP::Parser::Utils'    => '3.21',
            'TAP::Parser::YAMLish::Reader'=> '3.21',
            'TAP::Parser::YAMLish::Writer'=> '3.21',
            'Term::ANSIColor'       => '3.00',
            'Term::ReadLine'        => '1.07',
            'Test::Harness'         => '3.21',
            'Tie::Array'            => '1.04',
            'Time::HiRes'           => '1.9721',
            'Time::Piece'           => '1.20_01',
            'Unicode::Collate'      => '0.53',
            'Unicode::Normalize'    => '1.06',
            'Unicode::UCD'          => '0.29',
            'autodie'               => '2.10',
            'autodie::exception'    => '2.10',
            'autodie::exception::system'=> '2.10',
            'autodie::hints'        => '2.10',
            'blib'                  => '1.05',
            'charnames'             => '1.11',
            'diagnostics'           => '1.20',
            'inc::latest'           => '0.3607',
            'lib'                   => '0.63',
            're'                    => '0.12',
            'threads'               => '1.77_03',
            'threads::shared'       => '1.33_02',
            'vars'                  => '1.02',
            'warnings'              => '1.10',
        },
        removed => {
            'TAP::Parser::Source::Perl'=> 1,
        }
    },
    5.013004 => {
        delta_from => 5.013003,
        changed => {
            'App::Prove'            => '3.22',
            'App::Prove::State'     => '3.22',
            'App::Prove::State::Result'=> '3.22',
            'App::Prove::State::Result::Test'=> '3.22',
            'Archive::Tar'          => '1.68',
            'Archive::Tar::Constant'=> '1.68',
            'Archive::Tar::File'    => '1.68',
            'B::Lint'               => '1.12',
            'B::Lint::Debug'        => '1.12',
            'Carp'                  => '1.18',
            'Carp::Heavy'           => '1.18',
            'Compress::Raw::Bzip2'  => '2.030',
            'Compress::Raw::Zlib'   => '2.030',
            'Compress::Zlib'        => '2.030',
            'ExtUtils::ParseXS'     => '2.2207',
            'File::Spec'            => '3.31_01',
            'I18N::Langinfo'        => '0.04',
            'IO::Compress::Adapter::Bzip2'=> '2.030',
            'IO::Compress::Adapter::Deflate'=> '2.030',
            'IO::Compress::Adapter::Identity'=> '2.030',
            'IO::Compress::Base'    => '2.030',
            'IO::Compress::Base::Common'=> '2.030',
            'IO::Compress::Bzip2'   => '2.030',
            'IO::Compress::Deflate' => '2.030',
            'IO::Compress::Gzip'    => '2.030',
            'IO::Compress::Gzip::Constants'=> '2.030',
            'IO::Compress::RawDeflate'=> '2.030',
            'IO::Compress::Zip'     => '2.030',
            'IO::Compress::Zip::Constants'=> '2.030',
            'IO::Compress::Zlib::Constants'=> '2.030',
            'IO::Compress::Zlib::Extra'=> '2.030',
            'IO::Uncompress::Adapter::Bunzip2'=> '2.030',
            'IO::Uncompress::Adapter::Identity'=> '2.030',
            'IO::Uncompress::Adapter::Inflate'=> '2.030',
            'IO::Uncompress::AnyInflate'=> '2.030',
            'IO::Uncompress::AnyUncompress'=> '2.030',
            'IO::Uncompress::Base'  => '2.030',
            'IO::Uncompress::Bunzip2'=> '2.030',
            'IO::Uncompress::Gunzip'=> '2.030',
            'IO::Uncompress::Inflate'=> '2.030',
            'IO::Uncompress::RawInflate'=> '2.030',
            'IO::Uncompress::Unzip' => '2.030',
            'Module::CoreList'      => '2.37',
            'TAP::Base'             => '3.22',
            'TAP::Formatter::Base'  => '3.22',
            'TAP::Formatter::Color' => '3.22',
            'TAP::Formatter::Console'=> '3.22',
            'TAP::Formatter::Console::ParallelSession'=> '3.22',
            'TAP::Formatter::Console::Session'=> '3.22',
            'TAP::Formatter::File'  => '3.22',
            'TAP::Formatter::File::Session'=> '3.22',
            'TAP::Formatter::Session'=> '3.22',
            'TAP::Harness'          => '3.22',
            'TAP::Object'           => '3.22',
            'TAP::Parser'           => '3.22',
            'TAP::Parser::Aggregator'=> '3.22',
            'TAP::Parser::Grammar'  => '3.22',
            'TAP::Parser::Iterator' => '3.22',
            'TAP::Parser::Iterator::Array'=> '3.22',
            'TAP::Parser::Iterator::Process'=> '3.22',
            'TAP::Parser::Iterator::Stream'=> '3.22',
            'TAP::Parser::IteratorFactory'=> '3.22',
            'TAP::Parser::Multiplexer'=> '3.22',
            'TAP::Parser::Result'   => '3.22',
            'TAP::Parser::Result::Bailout'=> '3.22',
            'TAP::Parser::Result::Comment'=> '3.22',
            'TAP::Parser::Result::Plan'=> '3.22',
            'TAP::Parser::Result::Pragma'=> '3.22',
            'TAP::Parser::Result::Test'=> '3.22',
            'TAP::Parser::Result::Unknown'=> '3.22',
            'TAP::Parser::Result::Version'=> '3.22',
            'TAP::Parser::Result::YAML'=> '3.22',
            'TAP::Parser::ResultFactory'=> '3.22',
            'TAP::Parser::Scheduler'=> '3.22',
            'TAP::Parser::Scheduler::Job'=> '3.22',
            'TAP::Parser::Scheduler::Spinner'=> '3.22',
            'TAP::Parser::Source'   => '3.22',
            'TAP::Parser::SourceHandler'=> '3.22',
            'TAP::Parser::SourceHandler::Executable'=> '3.22',
            'TAP::Parser::SourceHandler::File'=> '3.22',
            'TAP::Parser::SourceHandler::Handle'=> '3.22',
            'TAP::Parser::SourceHandler::Perl'=> '3.22',
            'TAP::Parser::SourceHandler::RawTAP'=> '3.22',
            'TAP::Parser::Utils'    => '3.22',
            'TAP::Parser::YAMLish::Reader'=> '3.22',
            'TAP::Parser::YAMLish::Writer'=> '3.22',
            'Test::Builder'         => '0.96',
            'Test::Builder::Module' => '0.96',
            'Test::Builder::Tester' => '1.20',
            'Test::Builder::Tester::Color'=> '1.20',
            'Test::Harness'         => '3.22',
            'Test::More'            => '0.96',
            'Test::Simple'          => '0.96',
            'Unicode::Collate'      => '0.56',
            'Unicode::Collate::Locale'=> '0.56',
            'XS::APItest'           => '0.20',
            'charnames'             => '1.15',
            'feature'               => '1.18',
        },
        removed => {
            'TAP::Parser::SourceHandler::pgTAP'=> 1,
        }
    },
    5.013005 => {
        delta_from => 5.013004,
        changed => {
            'B::Debug'              => '1.16',
            'CPANPLUS::Dist::Build' => '0.48',
            'CPANPLUS::Dist::Build::Constants'=> '0.48',
            'Data::Dumper'          => '2.128',
            'Encode'                => '2.40',
            'Encode::Guess'         => '2.04',
            'Encode::MIME::Header'  => '2.12',
            'Encode::Unicode::UTF7' => '2.05',
            'Errno'                 => '1.13',
            'ExtUtils::Command::MM' => '6.57_05',
            'ExtUtils::Liblist'     => '6.57_05',
            'ExtUtils::Liblist::Kid'=> '6.5705',
            'ExtUtils::MM'          => '6.57_05',
            'ExtUtils::MM_AIX'      => '6.57_05',
            'ExtUtils::MM_Any'      => '6.57_05',
            'ExtUtils::MM_BeOS'     => '6.57_05',
            'ExtUtils::MM_Cygwin'   => '6.57_05',
            'ExtUtils::MM_DOS'      => '6.5705',
            'ExtUtils::MM_Darwin'   => '6.57_05',
            'ExtUtils::MM_MacOS'    => '6.5705',
            'ExtUtils::MM_NW5'      => '6.57_05',
            'ExtUtils::MM_OS2'      => '6.57_05',
            'ExtUtils::MM_QNX'      => '6.57_05',
            'ExtUtils::MM_UWIN'     => '6.5705',
            'ExtUtils::MM_Unix'     => '6.57_05',
            'ExtUtils::MM_VMS'      => '6.57_05',
            'ExtUtils::MM_VOS'      => '6.57_05',
            'ExtUtils::MM_Win32'    => '6.57_05',
            'ExtUtils::MM_Win95'    => '6.57_05',
            'ExtUtils::MY'          => '6.5705',
            'ExtUtils::MakeMaker'   => '6.57_05',
            'ExtUtils::MakeMaker::Config'=> '6.57_05',
            'ExtUtils::MakeMaker::YAML'=> '1.44',
            'ExtUtils::Mkbootstrap' => '6.57_05',
            'ExtUtils::Mksymlists'  => '6.57_05',
            'ExtUtils::testlib'     => '6.5705',
            'Filter::Simple'        => '0.85',
            'Hash::Util'            => '0.09',
            'Math::BigFloat'        => '1.62',
            'Math::BigInt'          => '1.95',
            'Math::BigInt::Calc'    => '0.54',
            'Math::BigInt::CalcEmu' => '0.06',
            'Math::BigInt::FastCalc'=> '0.22',
            'Math::BigRat'          => '0.26',
            'Module::CoreList'      => '2.39',
            'POSIX'                 => '1.20',
            'PerlIO::scalar'        => '0.09',
            'Safe'                  => '2.28',
            'Test::Builder'         => '0.97_01',
            'Test::Builder::Module' => '0.97_01',
            'Test::Builder::Tester' => '1.21_01',
            'Test::Builder::Tester::Color'=> '1.21_01',
            'Test::More'            => '0.97_01',
            'Test::Simple'          => '0.97_01',
            'Tie::Hash'             => '1.04',
            'Unicode::Collate'      => '0.59',
            'Unicode::Collate::Locale'=> '0.59',
            'XS::APItest'           => '0.21',
            'XS::APItest::KeywordRPN'=> '0.005',
            'XSLoader'              => '0.11',
            'bigint'                => '0.25',
            'bignum'                => '0.25',
            'bigrat'                => '0.25',
            'blib'                  => '1.06',
            'open'                  => '1.08',
            'threads::shared'       => '1.33_03',
            'warnings'              => '1.11',
            'warnings::register'    => '1.02',
        },
        removed => {
        }
    },
    5.013006 => {
        delta_from => 5.013005,
        changed => {
            'Archive::Extract'      => '0.44',
            'B'                     => '1.24',
            'B::Deparse'            => '0.99',
            'CPAN'                  => '1.94_61',
            'CPAN::FTP'             => '5.5005',
            'CPAN::Queue'           => '5.5001',
            'CPAN::Version'         => '5.5001',
            'Carp'                  => '1.19',
            'Carp::Heavy'           => '1.19',
            'Compress::Raw::Bzip2'  => '2.031',
            'Cwd'                   => '3.34',
            'Data::Dumper'          => '2.129',
            'Devel::Peek'           => '1.05',
            'Digest::MD5'           => '2.51',
            'ExtUtils::Constant::Base'=> '0.05',
            'ExtUtils::Constant::ProxySubs'=> '0.07',
            'ExtUtils::Embed'       => '1.29',
            'ExtUtils::XSSymSet'    => '1.2',
            'Fcntl'                 => '1.09',
            'File::DosGlob'         => '1.03',
            'File::Find'            => '1.18',
            'File::Glob'            => '1.09',
            'File::Spec'            => '3.33',
            'File::Spec::Cygwin'    => '3.33',
            'File::Spec::Epoc'      => '3.33',
            'File::Spec::Functions' => '3.33',
            'File::Spec::Mac'       => '3.33',
            'File::Spec::OS2'       => '3.33',
            'File::Spec::Unix'      => '3.33',
            'File::Spec::VMS'       => '3.33',
            'File::Spec::Win32'     => '3.33',
            'GDBM_File'             => '1.11',
            'Hash::Util::FieldHash' => '1.05',
            'I18N::Langinfo'        => '0.06',
            'IPC::Cmd'              => '0.64',
            'IPC::Open3'            => '1.07',
            'Locale::Codes'         => '3.14',
            'Locale::Codes::Country'=> '3.14',
            'Locale::Codes::Currency'=> '3.14',
            'Locale::Codes::Language'=> '3.14',
            'Locale::Codes::Script' => '3.14',
            'Locale::Constants'     => '3.14',
            'Locale::Country'       => '3.14',
            'Locale::Currency'      => '3.14',
            'Locale::Language'      => '3.14',
            'Locale::Maketext'      => '1.16',
            'Locale::Script'        => '3.14',
            'Math::BigFloat'        => '1.63',
            'Math::BigInt'          => '1.97',
            'Math::BigInt::Calc'    => '0.55',
            'Math::BigInt::CalcEmu' => '0.07',
            'Module::CoreList'      => '2.40',
            'NDBM_File'             => '1.09',
            'NEXT'                  => '0.65',
            'ODBM_File'             => '1.08',
            'Opcode'                => '1.16',
            'POSIX'                 => '1.21',
            'PerlIO::encoding'      => '0.13',
            'PerlIO::scalar'        => '0.10',
            'PerlIO::via'           => '0.10',
            'Pod::Man'              => '2.25',
            'Pod::Text'             => '3.15',
            'SDBM_File'             => '1.07',
            'Socket'                => '1.90',
            'Sys::Hostname'         => '1.13',
            'Tie::Hash::NamedCapture'=> '0.07',
            'Unicode::Collate'      => '0.63',
            'Unicode::Collate::Locale'=> '0.63',
            'Unicode::Normalize'    => '1.07',
            'XS::APItest'           => '0.23',
            'XSLoader'              => '0.13',
            'attributes'            => '0.13',
            'charnames'             => '1.16',
            'if'                    => '0.06',
            'mro'                   => '1.04',
            'overload'              => '1.11',
            're'                    => '0.13',
            'sigtrap'               => '1.05',
            'threads'               => '1.81_01',
            'threads::shared'       => '1.34',
        },
        removed => {
            'XS::APItest::KeywordRPN'=> 1,
        }
    },
    5.013007 => {
        delta_from => 5.013006,
        changed => {
            'Archive::Extract'      => '0.46',
            'Archive::Tar'          => '1.72',
            'Archive::Tar::Constant'=> '1.72',
            'Archive::Tar::File'    => '1.72',
            'AutoLoader'            => '5.71',
            'B'                     => '1.26',
            'B::Concise'            => '0.81',
            'B::Deparse'            => '1.01',
            'CGI'                   => '3.50',
            'CPAN'                  => '1.94_62',
            'CPANPLUS'              => '0.9010',
            'CPANPLUS::Dist::Build' => '0.50',
            'CPANPLUS::Dist::Build::Constants'=> '0.50',
            'CPANPLUS::Internals'   => '0.9010',
            'CPANPLUS::Shell::Default'=> '0.9010',
            'Data::Dumper'          => '2.130_01',
            'DynaLoader'            => '1.11',
            'ExtUtils::Constant'    => '0.23',
            'ExtUtils::Constant::ProxySubs'=> '0.08',
            'Fcntl'                 => '1.10',
            'File::Fetch'           => '0.28',
            'File::Glob'            => '1.10',
            'File::stat'            => '1.04',
            'GDBM_File'             => '1.12',
            'Hash::Util'            => '0.10',
            'Hash::Util::FieldHash' => '1.06',
            'I18N::Langinfo'        => '0.07',
            'Locale::Maketext'      => '1.17',
            'Locale::Maketext::Guts'=> '1.17',
            'Locale::Maketext::GutsLoader'=> '1.17',
            'MIME::Base64'          => '3.10',
            'MIME::QuotedPrint'     => '3.10',
            'Math::BigFloat'        => '1.99_01',
            'Math::BigInt'          => '1.99_01',
            'Math::BigInt::Calc'    => '1.99_01',
            'Math::BigInt::CalcEmu' => '1.99_01',
            'Math::BigInt::FastCalc'=> '0.24_01',
            'Math::BigRat'          => '0.26_01',
            'Module::CoreList'      => '2.41',
            'NDBM_File'             => '1.10',
            'ODBM_File'             => '1.09',
            'Opcode'                => '1.17',
            'POSIX'                 => '1.22',
            'Pod::Simple'           => '3.15',
            'Pod::Simple::BlackBox' => '3.15',
            'Pod::Simple::Checker'  => '3.15',
            'Pod::Simple::Debug'    => '3.15',
            'Pod::Simple::DumpAsText'=> '3.15',
            'Pod::Simple::DumpAsXML'=> '3.15',
            'Pod::Simple::HTML'     => '3.15',
            'Pod::Simple::HTMLBatch'=> '3.15',
            'Pod::Simple::LinkSection'=> '3.15',
            'Pod::Simple::Methody'  => '3.15',
            'Pod::Simple::Progress' => '3.15',
            'Pod::Simple::PullParser'=> '3.15',
            'Pod::Simple::PullParserEndToken'=> '3.15',
            'Pod::Simple::PullParserStartToken'=> '3.15',
            'Pod::Simple::PullParserTextToken'=> '3.15',
            'Pod::Simple::PullParserToken'=> '3.15',
            'Pod::Simple::RTF'      => '3.15',
            'Pod::Simple::Search'   => '3.15',
            'Pod::Simple::SimpleTree'=> '3.15',
            'Pod::Simple::Text'     => '3.15',
            'Pod::Simple::TextContent'=> '3.15',
            'Pod::Simple::TiedOutFH'=> '3.15',
            'Pod::Simple::Transcode'=> '3.15',
            'Pod::Simple::TranscodeDumb'=> '3.15',
            'Pod::Simple::TranscodeSmart'=> '3.15',
            'Pod::Simple::XHTML'    => '3.15',
            'Pod::Simple::XMLOutStream'=> '3.15',
            'SDBM_File'             => '1.08',
            'Safe'                  => '2.29',
            'SelfLoader'            => '1.18',
            'Socket'                => '1.91',
            'Storable'              => '2.24',
            'Sys::Hostname'         => '1.14',
            'Unicode'               => '6.0.0',
            'Unicode::Collate'      => '0.67',
            'Unicode::Collate::CJK::Big5'=> '0.65',
            'Unicode::Collate::CJK::GB2312'=> '0.65',
            'Unicode::Collate::CJK::JISX0208'=> '0.64',
            'Unicode::Collate::CJK::Korean'=> '0.66',
            'Unicode::Collate::CJK::Pinyin'=> '0.65',
            'Unicode::Collate::CJK::Stroke'=> '0.65',
            'Unicode::Collate::Locale'=> '0.67',
            'XS::APItest'           => '0.26',
            'XS::Typemap'           => '0.04',
            'charnames'             => '1.17',
            'mro'                   => '1.05',
            'parent'                => '0.224',
            're'                    => '0.14',
            'threads'               => '1.81_02',
        },
        removed => {
        }
    },
    5.013008 => {
        delta_from => 5.013007,
        changed => {
            'Archive::Tar'          => '1.74',
            'Archive::Tar::Constant'=> '1.74',
            'Archive::Tar::File'    => '1.74',
            'B'                     => '1.27',
            'B::Concise'            => '0.82',
            'B::Deparse'            => '1.02',
            'Carp::Heavy'           => '1.17',
            'Cwd'                   => '3.35',
            'Data::Dumper'          => '2.130_02',
            'Devel::Peek'           => '1.06',
            'Devel::SelfStubber'    => '1.05',
            'Digest::SHA'           => '5.50',
            'Dumpvalue'             => '1.15',
            'DynaLoader'            => '1.12',
            'Env'                   => '1.02',
            'Exporter::Heavy'       => '5.64_01',
            'ExtUtils::CBuilder'    => '0.280201',
            'ExtUtils::CBuilder::Base'=> '0.280201',
            'ExtUtils::CBuilder::Platform::Unix'=> '0.280201',
            'ExtUtils::CBuilder::Platform::VMS'=> '0.280201',
            'ExtUtils::CBuilder::Platform::Windows'=> '0.280201',
            'ExtUtils::CBuilder::Platform::Windows::BCC'=> '0.280201',
            'ExtUtils::CBuilder::Platform::Windows::GCC'=> '0.280201',
            'ExtUtils::CBuilder::Platform::Windows::MSVC'=> '0.280201',
            'ExtUtils::CBuilder::Platform::aix'=> '0.280201',
            'ExtUtils::CBuilder::Platform::cygwin'=> '0.280201',
            'ExtUtils::CBuilder::Platform::darwin'=> '0.280201',
            'ExtUtils::CBuilder::Platform::dec_osf'=> '0.280201',
            'ExtUtils::CBuilder::Platform::os2'=> '0.280201',
            'ExtUtils::Constant::Utils'=> '0.03',
            'ExtUtils::Embed'       => '1.30',
            'ExtUtils::ParseXS'     => '2.2208',
            'Fatal'                 => '2.1001',
            'Fcntl'                 => '1.11',
            'File::CheckTree'       => '4.41',
            'File::Glob'            => '1.11',
            'GDBM_File'             => '1.13',
            'Hash::Util::FieldHash' => '1.07',
            'I18N::Collate'         => '1.02',
            'IO'                    => '1.25_03',
            'IPC::Cmd'              => '0.66',
            'IPC::Open3'            => '1.08',
            'Locale::Codes'         => '3.15',
            'Locale::Codes::Country'=> '3.15',
            'Locale::Codes::Currency'=> '3.15',
            'Locale::Codes::Language'=> '3.15',
            'Locale::Codes::Script' => '3.15',
            'Locale::Constants'     => '3.15',
            'Locale::Country'       => '3.15',
            'Locale::Currency'      => '3.15',
            'Locale::Language'      => '3.15',
            'Locale::Script'        => '3.15',
            'MIME::Base64'          => '3.13',
            'MIME::QuotedPrint'     => '3.13',
            'Math::BigFloat'        => '1.99_02',
            'Math::BigInt'          => '1.99_02',
            'Math::BigInt::Calc'    => '1.99_02',
            'Math::BigInt::CalcEmu' => '1.99_02',
            'Memoize'               => '1.02',
            'Memoize::AnyDBM_File'  => '1.02',
            'Memoize::Expire'       => '1.02',
            'Memoize::ExpireFile'   => '1.02',
            'Memoize::ExpireTest'   => '1.02',
            'Memoize::NDBM_File'    => '1.02',
            'Memoize::SDBM_File'    => '1.02',
            'Memoize::Storable'     => '1.02',
            'Module::CoreList'      => '2.43',
            'NDBM_File'             => '1.11',
            'Net::Ping'             => '2.37',
            'ODBM_File'             => '1.10',
            'Opcode'                => '1.18',
            'POSIX'                 => '1.23',
            'PerlIO::encoding'      => '0.14',
            'PerlIO::scalar'        => '0.11',
            'PerlIO::via'           => '0.11',
            'SDBM_File'             => '1.09',
            'Socket'                => '1.92',
            'Storable'              => '2.25',
            'Time::HiRes'           => '1.9721_01',
            'Unicode::Collate'      => '0.6801',
            'Unicode::Collate::Locale'=> '0.68',
            'Unicode::Normalize'    => '1.08',
            'Unicode::UCD'          => '0.30',
            'Win32'                 => '0.41',
            'XS::APItest'           => '0.27',
            'autodie'               => '2.1001',
            'autodie::exception'    => '2.1001',
            'autodie::exception::system'=> '2.1001',
            'autodie::hints'        => '2.1001',
            'feature'               => '1.19',
            'if'                    => '0.0601',
            'mro'                   => '1.06',
            'overload'              => '1.12',
            're'                    => '0.15',
            'threads'               => '1.81_03',
            'threads::shared'       => '1.35',
            'version'               => '0.86',
        },
        removed => {
        }
    },
    5.013009 => {
        delta_from => 5.013008,
        changed => {
            'Archive::Extract'      => '0.48',
            'Archive::Tar'          => '1.76',
            'Archive::Tar::Constant'=> '1.76',
            'Archive::Tar::File'    => '1.76',
            'B::Concise'            => '0.83',
            'B::Deparse'            => '1.03',
            'B::Lint'               => '1.13',
            'Benchmark'             => '1.12',
            'CGI'                   => '3.51',
            'CGI::Carp'             => '3.51',
            'CGI::Cookie'           => '1.30',
            'CGI::Push'             => '1.05',
            'CGI::Util'             => '3.51',
            'CPAN'                  => '1.94_63',
            'CPAN::HTTP::Client'    => '1.94',
            'CPAN::HTTP::Credentials'=> '1.94',
            'CPAN::Meta::YAML'      => '0.003',
            'CPANPLUS'              => '0.9011',
            'CPANPLUS::Dist::Build' => '0.52',
            'CPANPLUS::Dist::Build::Constants'=> '0.52',
            'CPANPLUS::Internals'   => '0.9011',
            'CPANPLUS::Shell::Default'=> '0.9011',
            'Carp::Heavy'           => '1.19',
            'Compress::Raw::Bzip2'  => '2.033',
            'Compress::Raw::Zlib'   => '2.033',
            'Compress::Zlib'        => '2.033',
            'Cwd'                   => '3.36',
            'DBM_Filter'            => '0.04',
            'DB_File'               => '1.821',
            'Devel::Peek'           => '1.07',
            'DirHandle'             => '1.04',
            'Dumpvalue'             => '1.16',
            'Encode'                => '2.42',
            'Encode::Alias'         => '2.13',
            'Encode::MIME::Header'  => '2.13',
            'Exporter::Heavy'       => '5.64_03',
            'ExtUtils::Install'     => '1.56',
            'ExtUtils::ParseXS'     => '2.2209',
            'File::Basename'        => '2.80',
            'File::Copy'            => '2.21',
            'File::DosGlob'         => '1.04',
            'File::Fetch'           => '0.32',
            'File::Find'            => '1.19',
            'File::Spec::Mac'       => '3.34',
            'File::Spec::VMS'       => '3.34',
            'File::stat'            => '1.05',
            'HTTP::Tiny'            => '0.009',
            'Hash::Util::FieldHash' => '1.08',
            'IO::Compress::Adapter::Bzip2'=> '2.033',
            'IO::Compress::Adapter::Deflate'=> '2.033',
            'IO::Compress::Adapter::Identity'=> '2.033',
            'IO::Compress::Base'    => '2.033',
            'IO::Compress::Base::Common'=> '2.033',
            'IO::Compress::Bzip2'   => '2.033',
            'IO::Compress::Deflate' => '2.033',
            'IO::Compress::Gzip'    => '2.033',
            'IO::Compress::Gzip::Constants'=> '2.033',
            'IO::Compress::RawDeflate'=> '2.033',
            'IO::Compress::Zip'     => '2.033',
            'IO::Compress::Zip::Constants'=> '2.033',
            'IO::Compress::Zlib::Constants'=> '2.033',
            'IO::Compress::Zlib::Extra'=> '2.033',
            'IO::Handle'            => '1.29',
            'IO::Uncompress::Adapter::Bunzip2'=> '2.033',
            'IO::Uncompress::Adapter::Identity'=> '2.033',
            'IO::Uncompress::Adapter::Inflate'=> '2.033',
            'IO::Uncompress::AnyInflate'=> '2.033',
            'IO::Uncompress::AnyUncompress'=> '2.033',
            'IO::Uncompress::Base'  => '2.033',
            'IO::Uncompress::Bunzip2'=> '2.033',
            'IO::Uncompress::Gunzip'=> '2.033',
            'IO::Uncompress::Inflate'=> '2.033',
            'IO::Uncompress::RawInflate'=> '2.033',
            'IO::Uncompress::Unzip' => '2.033',
            'IPC::Cmd'              => '0.68',
            'IPC::Open3'            => '1.09',
            'JSON::PP'              => '2.27103',
            'JSON::PP::Boolean'     => undef,
            'Locale::Maketext'      => '1.18',
            'Log::Message'          => '0.04',
            'Log::Message::Config'  => '0.04',
            'Log::Message::Handlers'=> '0.04',
            'Log::Message::Item'    => '0.04',
            'Log::Message::Simple'  => '0.08',
            'Math::BigFloat'        => '1.99_03',
            'Math::BigInt'          => '1.99_03',
            'Math::BigInt::Calc'    => '1.99_03',
            'Math::BigInt::FastCalc'=> '0.24_02',
            'Math::BigRat'          => '0.26_02',
            'Module::CoreList'      => '2.42_01',
            'Module::Load::Conditional'=> '0.40',
            'Module::Metadata'      => '1.000003',
            'Net::Ping'             => '2.38',
            'OS2::Process'          => '1.05',
            'Object::Accessor'      => '0.38',
            'POSIX'                 => '1.24',
            'Params::Check'         => '0.28',
            'Perl::OSType'          => '1.002',
            'Pod::LaTeX'            => '0.59',
            'Pod::Perldoc'          => '3.15_03',
            'Socket'                => '1.93',
            'Storable'              => '2.26',
            'Sys::Hostname'         => '1.15',
            'Term::UI'              => '0.24',
            'Thread::Queue'         => '2.12',
            'Thread::Semaphore'     => '2.12',
            'Time::Local'           => '1.2000',
            'UNIVERSAL'             => '1.08',
            'Unicode::Normalize'    => '1.10',
            'Win32'                 => '0.44',
            'bigint'                => '0.26',
            'bignum'                => '0.26',
            'bigrat'                => '0.26',
            'charnames'             => '1.18',
            'diagnostics'           => '1.21',
            're'                    => '0.16',
            'threads'               => '1.83',
            'threads::shared'       => '1.36',
            'version'               => '0.88',
        },
        removed => {
        }
    },
    5.01301 => {
        delta_from => 5.013009,
        changed => {
            'Attribute::Handlers'   => '0.89',
            'B'                     => '1.28',
            'B::Showlex'            => '1.03',
            'CGI'                   => '3.52',
            'CPAN'                  => '1.94_65',
            'CPAN::Distribution'    => '1.9601',
            'CPAN::FTP::netrc'      => '1.01',
            'CPAN::FirstTime'       => '5.5303',
            'CPAN::HandleConfig'    => '5.5003',
            'CPAN::Meta'            => '2.110440',
            'CPAN::Meta::Converter' => '2.110440',
            'CPAN::Meta::Feature'   => '2.110440',
            'CPAN::Meta::History'   => '2.110440',
            'CPAN::Meta::Prereqs'   => '2.110440',
            'CPAN::Meta::Spec'      => '2.110440',
            'CPAN::Meta::Validator' => '2.110440',
            'CPAN::Shell'           => '5.5002',
            'CPANPLUS'              => '0.9101',
            'CPANPLUS::Internals'   => '0.9101',
            'CPANPLUS::Shell::Default'=> '0.9101',
            'Carp'                  => '1.20',
            'Carp::Heavy'           => '1.20',
            'Cwd'                   => '3.37',
            'Devel::DProf'          => '20110217.00',
            'DynaLoader'            => '1.13',
            'ExtUtils::CBuilder'    => '0.280202',
            'ExtUtils::CBuilder::Base'=> '0.280202',
            'ExtUtils::CBuilder::Platform::Unix'=> '0.280202',
            'ExtUtils::CBuilder::Platform::VMS'=> '0.280202',
            'ExtUtils::CBuilder::Platform::Windows'=> '0.280202',
            'ExtUtils::CBuilder::Platform::Windows::BCC'=> '0.280202',
            'ExtUtils::CBuilder::Platform::Windows::GCC'=> '0.280202',
            'ExtUtils::CBuilder::Platform::Windows::MSVC'=> '0.280202',
            'ExtUtils::CBuilder::Platform::aix'=> '0.280202',
            'ExtUtils::CBuilder::Platform::cygwin'=> '0.280202',
            'ExtUtils::CBuilder::Platform::darwin'=> '0.280202',
            'ExtUtils::CBuilder::Platform::dec_osf'=> '0.280202',
            'ExtUtils::CBuilder::Platform::os2'=> '0.280202',
            'File::Copy'            => '2.22',
            'Filter::Simple'        => '0.86',
            'HTTP::Tiny'            => '0.010',
            'I18N::LangTags::Detect'=> '1.05',
            'IO::Select'            => '1.18',
            'IPC::Cmd'              => '0.70',
            'Locale::Maketext'      => '1.19',
            'Math::BigFloat'        => '1.992',
            'Math::BigInt'          => '1.992',
            'Math::BigInt::Calc'    => '1.992',
            'Math::BigInt::CalcEmu' => '1.992',
            'Module::Build'         => '0.37_05',
            'Module::Build::Base'   => '0.37_05',
            'Module::Build::Compat' => '0.37_05',
            'Module::Build::Config' => '0.37_05',
            'Module::Build::Cookbook'=> '0.37_05',
            'Module::Build::Dumper' => '0.37_05',
            'Module::Build::ModuleInfo'=> '0.37_05',
            'Module::Build::Notes'  => '0.37_05',
            'Module::Build::PPMMaker'=> '0.37_05',
            'Module::Build::Platform::Amiga'=> '0.37_05',
            'Module::Build::Platform::Default'=> '0.37_05',
            'Module::Build::Platform::EBCDIC'=> '0.37_05',
            'Module::Build::Platform::MPEiX'=> '0.37_05',
            'Module::Build::Platform::MacOS'=> '0.37_05',
            'Module::Build::Platform::RiscOS'=> '0.37_05',
            'Module::Build::Platform::Unix'=> '0.37_05',
            'Module::Build::Platform::VMS'=> '0.37_05',
            'Module::Build::Platform::VOS'=> '0.37_05',
            'Module::Build::Platform::Windows'=> '0.37_05',
            'Module::Build::Platform::aix'=> '0.37_05',
            'Module::Build::Platform::cygwin'=> '0.37_05',
            'Module::Build::Platform::darwin'=> '0.37_05',
            'Module::Build::Platform::os2'=> '0.37_05',
            'Module::Build::PodParser'=> '0.37_05',
            'Module::Build::Version'=> '0.87',
            'Module::Build::YAML'   => '1.41',
            'Module::CoreList'      => '2.45',
            'Module::Load::Conditional'=> '0.44',
            'Module::Metadata'      => '1.000004',
            'OS2::Process'          => '1.06',
            'Parse::CPAN::Meta'     => '1.4401',
            'Pod::Html'             => '1.1',
            'Socket'                => '1.94',
            'Term::UI'              => '0.26',
            'Unicode::Collate'      => '0.72',
            'Unicode::Collate::Locale'=> '0.71',
            'Unicode::UCD'          => '0.31',
            'VMS::DCLsym'           => '1.05',
            'Version::Requirements' => '0.101020',
            'bigrat'                => '0.27',
            'deprecate'             => '0.02',
            'diagnostics'           => '1.22',
            'inc::latest'           => '0.37_05',
            'overload'              => '1.13',
            're'                    => '0.17',
            'utf8'                  => '1.09',
            'warnings'              => '1.12',
        },
        removed => {
        }
    },
    5.013011 => {
        delta_from => 5.01301,
        changed => {
            'App::Prove'            => '3.23',
            'App::Prove::State'     => '3.23',
            'App::Prove::State::Result'=> '3.23',
            'App::Prove::State::Result::Test'=> '3.23',
            'B'                     => '1.29',
            'CPAN'                  => '1.9600',
            'CPAN::Author'          => '5.5001',
            'CPAN::CacheMgr'        => '5.5001',
            'CPAN::Distribution'    => '1.9602',
            'CPAN::Exception::blocked_urllist'=> '1.001',
            'CPAN::HTTP::Client'    => '1.9600',
            'CPAN::HTTP::Credentials'=> '1.9600',
            'CPAN::Index'           => '1.9600',
            'CPAN::LWP::UserAgent'  => '1.9600',
            'CPAN::Mirrors'         => '1.9600',
            'CPAN::Module'          => '5.5001',
            'CPANPLUS'              => '0.9103',
            'CPANPLUS::Dist::Build' => '0.54',
            'CPANPLUS::Dist::Build::Constants'=> '0.54',
            'CPANPLUS::Internals'   => '0.9103',
            'CPANPLUS::Shell::Default'=> '0.9103',
            'Cwd'                   => '3.36',
            'Devel::DProf'          => '20110228.00',
            'Digest::SHA'           => '5.61',
            'ExtUtils::Command'     => '1.17',
            'File::Basename'        => '2.81',
            'File::Copy'            => '2.21',
            'File::Glob'            => '1.12',
            'GDBM_File'             => '1.14',
            'HTTP::Tiny'            => '0.011',
            'Hash::Util'            => '0.11',
            'Hash::Util::FieldHash' => '1.09',
            'I18N::Langinfo'        => '0.08',
            'IO'                    => '1.25_04',
            'IO::Dir'               => '1.08',
            'IO::File'              => '1.15',
            'IO::Handle'            => '1.30',
            'IO::Pipe'              => '1.14',
            'IO::Poll'              => '0.08',
            'IO::Select'            => '1.20',
            'JSON::PP'              => '2.27105',
            'Locale::Codes'         => '3.16',
            'Locale::Codes::Country'=> '3.16',
            'Locale::Codes::Currency'=> '3.16',
            'Locale::Codes::Language'=> '3.16',
            'Locale::Codes::Script' => '3.16',
            'Locale::Constants'     => '3.16',
            'Locale::Country'       => '3.16',
            'Locale::Currency'      => '3.16',
            'Locale::Language'      => '3.16',
            'Locale::Script'        => '3.16',
            'Math::BigFloat'        => '1.993',
            'Math::BigInt'          => '1.994',
            'Math::BigInt::Calc'    => '1.993',
            'Math::BigInt::CalcEmu' => '1.993',
            'Math::BigInt::FastCalc'=> '0.28',
            'Module::Build'         => '0.3800',
            'Module::Build::Base'   => '0.3800',
            'Module::Build::Compat' => '0.3800',
            'Module::Build::Config' => '0.3800',
            'Module::Build::Cookbook'=> '0.3800',
            'Module::Build::Dumper' => '0.3800',
            'Module::Build::ModuleInfo'=> '0.3800',
            'Module::Build::Notes'  => '0.3800',
            'Module::Build::PPMMaker'=> '0.3800',
            'Module::Build::Platform::Amiga'=> '0.3800',
            'Module::Build::Platform::Default'=> '0.3800',
            'Module::Build::Platform::EBCDIC'=> '0.3800',
            'Module::Build::Platform::MPEiX'=> '0.3800',
            'Module::Build::Platform::MacOS'=> '0.3800',
            'Module::Build::Platform::RiscOS'=> '0.3800',
            'Module::Build::Platform::Unix'=> '0.3800',
            'Module::Build::Platform::VMS'=> '0.3800',
            'Module::Build::Platform::VOS'=> '0.3800',
            'Module::Build::Platform::Windows'=> '0.3800',
            'Module::Build::Platform::aix'=> '0.3800',
            'Module::Build::Platform::cygwin'=> '0.3800',
            'Module::Build::Platform::darwin'=> '0.3800',
            'Module::Build::Platform::os2'=> '0.3800',
            'Module::Build::PodParser'=> '0.3800',
            'Module::CoreList'      => '2.46',
            'NDBM_File'             => '1.12',
            'Pod::Simple'           => '3.16',
            'Pod::Simple::BlackBox' => '3.16',
            'Pod::Simple::Checker'  => '3.16',
            'Pod::Simple::Debug'    => '3.16',
            'Pod::Simple::DumpAsText'=> '3.16',
            'Pod::Simple::DumpAsXML'=> '3.16',
            'Pod::Simple::HTML'     => '3.16',
            'Pod::Simple::HTMLBatch'=> '3.16',
            'Pod::Simple::LinkSection'=> '3.16',
            'Pod::Simple::Methody'  => '3.16',
            'Pod::Simple::Progress' => '3.16',
            'Pod::Simple::PullParser'=> '3.16',
            'Pod::Simple::PullParserEndToken'=> '3.16',
            'Pod::Simple::PullParserStartToken'=> '3.16',
            'Pod::Simple::PullParserTextToken'=> '3.16',
            'Pod::Simple::PullParserToken'=> '3.16',
            'Pod::Simple::RTF'      => '3.16',
            'Pod::Simple::Search'   => '3.16',
            'Pod::Simple::SimpleTree'=> '3.16',
            'Pod::Simple::Text'     => '3.16',
            'Pod::Simple::TextContent'=> '3.16',
            'Pod::Simple::TiedOutFH'=> '3.16',
            'Pod::Simple::Transcode'=> '3.16',
            'Pod::Simple::TranscodeDumb'=> '3.16',
            'Pod::Simple::TranscodeSmart'=> '3.16',
            'Pod::Simple::XHTML'    => '3.16',
            'Pod::Simple::XMLOutStream'=> '3.16',
            'Storable'              => '2.27',
            'Sys::Hostname'         => '1.16',
            'TAP::Base'             => '3.23',
            'TAP::Formatter::Base'  => '3.23',
            'TAP::Formatter::Color' => '3.23',
            'TAP::Formatter::Console'=> '3.23',
            'TAP::Formatter::Console::ParallelSession'=> '3.23',
            'TAP::Formatter::Console::Session'=> '3.23',
            'TAP::Formatter::File'  => '3.23',
            'TAP::Formatter::File::Session'=> '3.23',
            'TAP::Formatter::Session'=> '3.23',
            'TAP::Harness'          => '3.23',
            'TAP::Object'           => '3.23',
            'TAP::Parser'           => '3.23',
            'TAP::Parser::Aggregator'=> '3.23',
            'TAP::Parser::Grammar'  => '3.23',
            'TAP::Parser::Iterator' => '3.23',
            'TAP::Parser::Iterator::Array'=> '3.23',
            'TAP::Parser::Iterator::Process'=> '3.23',
            'TAP::Parser::Iterator::Stream'=> '3.23',
            'TAP::Parser::IteratorFactory'=> '3.23',
            'TAP::Parser::Multiplexer'=> '3.23',
            'TAP::Parser::Result'   => '3.23',
            'TAP::Parser::Result::Bailout'=> '3.23',
            'TAP::Parser::Result::Comment'=> '3.23',
            'TAP::Parser::Result::Plan'=> '3.23',
            'TAP::Parser::Result::Pragma'=> '3.23',
            'TAP::Parser::Result::Test'=> '3.23',
            'TAP::Parser::Result::Unknown'=> '3.23',
            'TAP::Parser::Result::Version'=> '3.23',
            'TAP::Parser::Result::YAML'=> '3.23',
            'TAP::Parser::ResultFactory'=> '3.23',
            'TAP::Parser::Scheduler'=> '3.23',
            'TAP::Parser::Scheduler::Job'=> '3.23',
            'TAP::Parser::Scheduler::Spinner'=> '3.23',
            'TAP::Parser::Source'   => '3.23',
            'TAP::Parser::SourceHandler'=> '3.23',
            'TAP::Parser::SourceHandler::Executable'=> '3.23',
            'TAP::Parser::SourceHandler::File'=> '3.23',
            'TAP::Parser::SourceHandler::Handle'=> '3.23',
            'TAP::Parser::SourceHandler::Perl'=> '3.23',
            'TAP::Parser::SourceHandler::RawTAP'=> '3.23',
            'TAP::Parser::Utils'    => '3.23',
            'TAP::Parser::YAMLish::Reader'=> '3.23',
            'TAP::Parser::YAMLish::Writer'=> '3.23',
            'Test::Builder'         => '0.98',
            'Test::Builder::Module' => '0.98',
            'Test::Builder::Tester' => '1.22',
            'Test::Builder::Tester::Color'=> '1.22',
            'Test::Harness'         => '3.23',
            'Test::More'            => '0.98',
            'Test::Simple'          => '0.98',
            'Tie::Hash::NamedCapture'=> '0.08',
            'Tie::RefHash'          => '1.39',
            'Unicode::Collate'      => '0.73',
            'Unicode::Collate::Locale'=> '0.73',
            'Unicode::UCD'          => '0.32',
            'XS::Typemap'           => '0.05',
            'attributes'            => '0.14',
            'base'                  => '2.16',
            'inc::latest'           => '0.3800',
            'mro'                   => '1.07',
            'parent'                => '0.225',
        },
        removed => {
        }
    },
    5.014 => {
        delta_from => 5.013011,
        changed => {
            'ExtUtils::CBuilder'    => '0.280203',
            'ExtUtils::CBuilder::Base'=> '0.280203',
            'ExtUtils::CBuilder::Platform::Unix'=> '0.280203',
            'ExtUtils::CBuilder::Platform::VMS'=> '0.280203',
            'ExtUtils::CBuilder::Platform::Windows'=> '0.280203',
            'ExtUtils::CBuilder::Platform::Windows::BCC'=> '0.280203',
            'ExtUtils::CBuilder::Platform::Windows::GCC'=> '0.280203',
            'ExtUtils::CBuilder::Platform::Windows::MSVC'=> '0.280203',
            'ExtUtils::CBuilder::Platform::aix'=> '0.280203',
            'ExtUtils::CBuilder::Platform::cygwin'=> '0.280203',
            'ExtUtils::CBuilder::Platform::darwin'=> '0.280203',
            'ExtUtils::CBuilder::Platform::dec_osf'=> '0.280203',
            'ExtUtils::CBuilder::Platform::os2'=> '0.280203',
            'ExtUtils::ParseXS'     => '2.2210',
            'File::Basename'        => '2.82',
            'HTTP::Tiny'            => '0.012',
            'IO::Handle'            => '1.31',
            'Module::CoreList'      => '2.49',
            'PerlIO'                => '1.07',
            'Pod::Html'             => '1.11',
            'XS::APItest'           => '0.28',
            'bigint'                => '0.27',
            'bignum'                => '0.27',
            'bigrat'                => '0.28',
            'constant'              => '1.21',
            'feature'               => '1.20',
            're'                    => '0.18',
            'threads::shared'       => '1.37',
        },
        removed => {
        }
    },
    5.014001 => {
        delta_from => 5.014,
        changed => {
            'B::Deparse'            => '1.04',
            'Module::CoreList'      => '2.49_01',
            'Pod::Perldoc'          => '3.15_04',
        },
        removed => {
        }
    },
    5.014002 => {
        delta_from => 5.014001,
        changed => {
            'CPAN'                  => '1.9600_01',
            'CPAN::Distribution'    => '1.9602_01',
            'Devel::DProf::dprof::V'=> undef,
            'Encode'                => '2.42_01',
            'File::Glob'            => '1.13',
            'Module::CoreList'      => '2.49_02',
            'PerlIO::scalar'        => '0.11_01',
            'Time::Piece::Seconds'  => undef,
        },
        removed => {
        }
    },
    5.014003 => {
        delta_from => 5.014002,
        changed => {
            'Digest'                => '1.16_01',
            'IPC::Open3'            => '1.09_01',
            'Module::CoreList'      => '2.49_04',
        },
        removed => {
        }
    },
    5.014004 => {
        delta_from => 5.014003,
        changed => {
            'Encode'                => '2.42_02',
            'IPC::Open3'            => '1.0901',
            'Module::CoreList'      => '2.49_06',
        },
        removed => {
        }
    },
    5.015 => {
        delta_from => 5.014001,
        changed => {
            'Archive::Extract'      => '0.52',
            'Attribute::Handlers'   => '0.91',
            'B'                     => '1.30',
            'B::Concise'            => '0.84',
            'B::Deparse'            => '1.05',
            'Benchmark'             => '1.13',
            'CGI'                   => '3.54',
            'CGI::Util'             => '3.53',
            'CPAN::Meta'            => '2.110930',
            'CPAN::Meta::Converter' => '2.110930',
            'CPAN::Meta::Feature'   => '2.110930',
            'CPAN::Meta::History'   => '2.110930',
            'CPAN::Meta::Prereqs'   => '2.110930',
            'CPAN::Meta::Spec'      => '2.110930',
            'CPAN::Meta::Validator' => '2.110930',
            'CPANPLUS'              => '0.9105',
            'CPANPLUS::Dist::Build' => '0.56',
            'CPANPLUS::Dist::Build::Constants'=> '0.56',
            'CPANPLUS::Internals'   => '0.9105',
            'CPANPLUS::Shell::Default'=> '0.9105',
            'Compress::Raw::Bzip2'  => '2.035',
            'Compress::Raw::Zlib'   => '2.035',
            'Compress::Zlib'        => '2.035',
            'DB_File'               => '1.822',
            'Data::Dumper'          => '2.131',
            'Devel::Peek'           => '1.08',
            'Digest::SHA'           => '5.62',
            'Encode'                => '2.43',
            'Encode::Alias'         => '2.14',
            'ExtUtils::CBuilder'    => '0.280204',
            'ExtUtils::CBuilder::Base'=> '0.280204',
            'Fatal'                 => '2.10',
            'File::Spec::Win32'     => '3.34',
            'Filter::Simple'        => '0.87',
            'Filter::Util::Call'    => '1.39',
            'FindBin'               => '1.51',
            'Hash::Util::FieldHash' => '1.10',
            'I18N::LangTags'        => '0.36',
            'IO::Compress::Adapter::Bzip2'=> '2.035',
            'IO::Compress::Adapter::Deflate'=> '2.035',
            'IO::Compress::Adapter::Identity'=> '2.035',
            'IO::Compress::Base'    => '2.035',
            'IO::Compress::Base::Common'=> '2.035',
            'IO::Compress::Bzip2'   => '2.035',
            'IO::Compress::Deflate' => '2.035',
            'IO::Compress::Gzip'    => '2.035',
            'IO::Compress::Gzip::Constants'=> '2.035',
            'IO::Compress::RawDeflate'=> '2.035',
            'IO::Compress::Zip'     => '2.035',
            'IO::Compress::Zip::Constants'=> '2.035',
            'IO::Compress::Zlib::Constants'=> '2.035',
            'IO::Compress::Zlib::Extra'=> '2.035',
            'IO::Uncompress::Adapter::Bunzip2'=> '2.035',
            'IO::Uncompress::Adapter::Identity'=> '2.035',
            'IO::Uncompress::Adapter::Inflate'=> '2.035',
            'IO::Uncompress::AnyInflate'=> '2.035',
            'IO::Uncompress::AnyUncompress'=> '2.035',
            'IO::Uncompress::Base'  => '2.035',
            'IO::Uncompress::Bunzip2'=> '2.035',
            'IO::Uncompress::Gunzip'=> '2.035',
            'IO::Uncompress::Inflate'=> '2.035',
            'IO::Uncompress::RawInflate'=> '2.035',
            'IO::Uncompress::Unzip' => '2.035',
            'IPC::Open2'            => '1.04',
            'IPC::Open3'            => '1.11',
            'JSON::PP'              => '2.27200',
            'Math::BigFloat'        => '1.994',
            'Math::BigInt'          => '1.995',
            'Math::Complex'         => '1.57',
            'Math::Trig'            => '1.21',
            'Module::CoreList'      => '2.51',
            'ODBM_File'             => '1.11',
            'Object::Accessor'      => '0.42',
            'Opcode'                => '1.19',
            'PerlIO::encoding'      => '0.15',
            'PerlIO::scalar'        => '0.12',
            'Pod::Perldoc'          => '3.15_05',
            'Storable'              => '2.28',
            'Sys::Syslog'           => '0.29',
            'Time::HiRes'           => '1.9722',
            'Unicode::Collate'      => '0.76',
            'Unicode::Collate::CJK::Pinyin'=> '0.76',
            'Unicode::Collate::CJK::Stroke'=> '0.76',
            'Unicode::Collate::Locale'=> '0.76',
            'Unicode::Normalize'    => '1.12',
            'XS::APItest'           => '0.29',
            'XSLoader'              => '0.15',
            'autodie'               => '2.10',
            'autodie::exception'    => '2.10',
            'autodie::exception::system'=> '2.10',
            'autodie::hints'        => '2.10',
            'base'                  => '2.17',
            'charnames'             => '1.22',
            'constant'              => '1.22',
            'feature'               => '1.21',
            'mro'                   => '1.08',
            'overload'              => '1.14',
            'threads::shared'       => '1.38',
            'vmsish'                => '1.03',
        },
        removed => {
            'Devel::DProf'          => 1,
            'Shell'                 => 1,
        }
    },
    5.015001 => {
        delta_from => 5.015,
        changed => {
            'B::Deparse'            => '1.06',
            'CGI'                   => '3.55',
            'CPAN::Meta'            => '2.110930001',
            'CPAN::Meta::Converter' => '2.110930001',
            'CPANPLUS'              => '0.9108',
            'CPANPLUS::Internals'   => '0.9108',
            'CPANPLUS::Shell::Default'=> '0.9108',
            'Carp'                  => '1.21',
            'Carp::Heavy'           => '1.21',
            'Compress::Raw::Bzip2'  => '2.037',
            'Compress::Raw::Zlib'   => '2.037',
            'Compress::Zlib'        => '2.037',
            'Cwd'                   => '3.37',
            'Env'                   => '1.03',
            'ExtUtils::Command::MM' => '6.58',
            'ExtUtils::Liblist'     => '6.58',
            'ExtUtils::Liblist::Kid'=> '6.58',
            'ExtUtils::MM'          => '6.58',
            'ExtUtils::MM_AIX'      => '6.58',
            'ExtUtils::MM_Any'      => '6.58',
            'ExtUtils::MM_BeOS'     => '6.58',
            'ExtUtils::MM_Cygwin'   => '6.58',
            'ExtUtils::MM_DOS'      => '6.58',
            'ExtUtils::MM_Darwin'   => '6.58',
            'ExtUtils::MM_MacOS'    => '6.58',
            'ExtUtils::MM_NW5'      => '6.58',
            'ExtUtils::MM_OS2'      => '6.58',
            'ExtUtils::MM_QNX'      => '6.58',
            'ExtUtils::MM_UWIN'     => '6.58',
            'ExtUtils::MM_Unix'     => '6.58',
            'ExtUtils::MM_VMS'      => '6.58',
            'ExtUtils::MM_VOS'      => '6.58',
            'ExtUtils::MM_Win32'    => '6.58',
            'ExtUtils::MM_Win95'    => '6.58',
            'ExtUtils::MY'          => '6.58',
            'ExtUtils::MakeMaker'   => '6.58',
            'ExtUtils::MakeMaker::Config'=> '6.58',
            'ExtUtils::Mkbootstrap' => '6.58',
            'ExtUtils::Mksymlists'  => '6.58',
            'ExtUtils::ParseXS'     => '3.00_01',
            'ExtUtils::ParseXS::Constants'=> undef,
            'ExtUtils::ParseXS::CountLines'=> undef,
            'ExtUtils::ParseXS::Utilities'=> undef,
            'ExtUtils::Typemaps'    => '1.00',
            'ExtUtils::Typemaps::InputMap'=> undef,
            'ExtUtils::Typemaps::OutputMap'=> undef,
            'ExtUtils::Typemaps::Type'=> '0.05',
            'ExtUtils::testlib'     => '6.58',
            'File::Basename'        => '2.83',
            'File::Find'            => '1.20',
            'HTTP::Tiny'            => '0.013',
            'I18N::Langinfo'        => '0.08_02',
            'IO::Compress::Adapter::Bzip2'=> '2.037',
            'IO::Compress::Adapter::Deflate'=> '2.037',
            'IO::Compress::Adapter::Identity'=> '2.037',
            'IO::Compress::Base'    => '2.037',
            'IO::Compress::Base::Common'=> '2.037',
            'IO::Compress::Bzip2'   => '2.037',
            'IO::Compress::Deflate' => '2.037',
            'IO::Compress::Gzip'    => '2.037',
            'IO::Compress::Gzip::Constants'=> '2.037',
            'IO::Compress::RawDeflate'=> '2.037',
            'IO::Compress::Zip'     => '2.037',
            'IO::Compress::Zip::Constants'=> '2.037',
            'IO::Compress::Zlib::Constants'=> '2.037',
            'IO::Compress::Zlib::Extra'=> '2.037',
            'IO::Uncompress::Adapter::Bunzip2'=> '2.037',
            'IO::Uncompress::Adapter::Identity'=> '2.037',
            'IO::Uncompress::Adapter::Inflate'=> '2.037',
            'IO::Uncompress::AnyInflate'=> '2.037',
            'IO::Uncompress::AnyUncompress'=> '2.037',
            'IO::Uncompress::Base'  => '2.037',
            'IO::Uncompress::Bunzip2'=> '2.037',
            'IO::Uncompress::Gunzip'=> '2.037',
            'IO::Uncompress::Inflate'=> '2.037',
            'IO::Uncompress::RawInflate'=> '2.037',
            'IO::Uncompress::Unzip' => '2.037',
            'IPC::Cmd'              => '0.72',
            'Locale::Codes'         => '3.17',
            'Locale::Codes::Constants'=> '3.17',
            'Locale::Codes::Country'=> '3.17',
            'Locale::Codes::Country_Codes'=> '3.17',
            'Locale::Codes::Currency'=> '3.17',
            'Locale::Codes::Currency_Codes'=> '3.17',
            'Locale::Codes::LangExt'=> '3.17',
            'Locale::Codes::LangExt_Codes'=> '3.17',
            'Locale::Codes::LangVar'=> '3.17',
            'Locale::Codes::LangVar_Codes'=> '3.17',
            'Locale::Codes::Language'=> '3.17',
            'Locale::Codes::Language_Codes'=> '3.17',
            'Locale::Codes::Script' => '3.17',
            'Locale::Codes::Script_Codes'=> '3.17',
            'Locale::Country'       => '3.17',
            'Locale::Currency'      => '3.17',
            'Locale::Language'      => '3.17',
            'Locale::Script'        => '3.17',
            'Math::BigFloat::Trace' => '0.28',
            'Math::BigInt::FastCalc'=> '0.29',
            'Math::BigInt::Trace'   => '0.28',
            'Math::BigRat'          => '0.2602',
            'Math::Complex'         => '1.58',
            'Math::Trig'            => '1.22',
            'Module::CoreList'      => '2.54',
            'OS2::Process'          => '1.07',
            'Pod::Perldoc'          => '3.15_06',
            'Pod::Simple'           => '3.18',
            'Pod::Simple::BlackBox' => '3.18',
            'Pod::Simple::Checker'  => '3.18',
            'Pod::Simple::Debug'    => '3.18',
            'Pod::Simple::DumpAsText'=> '3.18',
            'Pod::Simple::DumpAsXML'=> '3.18',
            'Pod::Simple::HTML'     => '3.18',
            'Pod::Simple::HTMLBatch'=> '3.18',
            'Pod::Simple::LinkSection'=> '3.18',
            'Pod::Simple::Methody'  => '3.18',
            'Pod::Simple::Progress' => '3.18',
            'Pod::Simple::PullParser'=> '3.18',
            'Pod::Simple::PullParserEndToken'=> '3.18',
            'Pod::Simple::PullParserStartToken'=> '3.18',
            'Pod::Simple::PullParserTextToken'=> '3.18',
            'Pod::Simple::PullParserToken'=> '3.18',
            'Pod::Simple::RTF'      => '3.18',
            'Pod::Simple::Search'   => '3.18',
            'Pod::Simple::SimpleTree'=> '3.18',
            'Pod::Simple::Text'     => '3.18',
            'Pod::Simple::TextContent'=> '3.18',
            'Pod::Simple::TiedOutFH'=> '3.18',
            'Pod::Simple::Transcode'=> '3.18',
            'Pod::Simple::TranscodeDumb'=> '3.18',
            'Pod::Simple::TranscodeSmart'=> '3.18',
            'Pod::Simple::XHTML'    => '3.18',
            'Pod::Simple::XMLOutStream'=> '3.18',
            'Storable'              => '2.31',
            'Sys::Syslog::Win32'    => undef,
            'Time::HiRes'           => '1.9724',
            'Unicode::Collate'      => '0.77',
            'Unicode::UCD'          => '0.33',
            'Win32API::File'        => '0.1200',
            'XS::APItest'           => '0.30',
            'attributes'            => '0.15',
            'bigint'                => '0.28',
            'bignum'                => '0.28',
            'charnames'             => '1.23',
            'diagnostics'           => '1.23',
            'feature'               => '1.22',
            'overload'              => '1.15',
            'perlfaq'               => '5.015000',
            'threads'               => '1.84',
            'version'               => '0.93',
        },
        removed => {
            'ExtUtils::MakeMaker::YAML'=> 1,
            'Locale::Constants'     => 1,
            'Sys::Syslog::win32::Win32'=> 1,
        }
    },
    5.015002 => {
        delta_from => 5.015001,
        changed => {
            'Attribute::Handlers'   => '0.92',
            'B'                     => '1.31',
            'B::Concise'            => '0.85',
            'B::Deparse'            => '1.07',
            'B::Terse'              => '1.06',
            'B::Xref'               => '1.03',
            'CPAN'                  => '1.9800',
            'CPAN::Exception::yaml_process_error'=> '5.5',
            'CPAN::Meta'            => '2.112150',
            'CPAN::Meta::Converter' => '2.112150',
            'CPAN::Meta::Feature'   => '2.112150',
            'CPAN::Meta::History'   => '2.112150',
            'CPAN::Meta::Prereqs'   => '2.112150',
            'CPAN::Meta::Spec'      => '2.112150',
            'CPAN::Meta::Validator' => '2.112150',
            'CPANPLUS'              => '0.9109',
            'CPANPLUS::Internals'   => '0.9109',
            'CPANPLUS::Shell::Default'=> '0.9109',
            'DB_File'               => '1.824',
            'Data::Dumper'          => '2.132',
            'Encode'                => '2.44',
            'Encode::Alias'         => '2.15',
            'Encode::Encoder'       => '2.02',
            'Encode::Guess'         => '2.05',
            'ExtUtils::Command::MM' => '6.59',
            'ExtUtils::Install'     => '1.57',
            'ExtUtils::Installed'   => '1.999002',
            'ExtUtils::Liblist'     => '6.59',
            'ExtUtils::Liblist::Kid'=> '6.59',
            'ExtUtils::MM'          => '6.59',
            'ExtUtils::MM_AIX'      => '6.59',
            'ExtUtils::MM_Any'      => '6.59',
            'ExtUtils::MM_BeOS'     => '6.59',
            'ExtUtils::MM_Cygwin'   => '6.59',
            'ExtUtils::MM_DOS'      => '6.59',
            'ExtUtils::MM_Darwin'   => '6.59',
            'ExtUtils::MM_MacOS'    => '6.59',
            'ExtUtils::MM_NW5'      => '6.59',
            'ExtUtils::MM_OS2'      => '6.59',
            'ExtUtils::MM_QNX'      => '6.59',
            'ExtUtils::MM_UWIN'     => '6.59',
            'ExtUtils::MM_Unix'     => '6.59',
            'ExtUtils::MM_VMS'      => '6.59',
            'ExtUtils::MM_VOS'      => '6.59',
            'ExtUtils::MM_Win32'    => '6.59',
            'ExtUtils::MM_Win95'    => '6.59',
            'ExtUtils::MY'          => '6.59',
            'ExtUtils::MakeMaker'   => '6.59',
            'ExtUtils::MakeMaker::Config'=> '6.59',
            'ExtUtils::Manifest'    => '1.60',
            'ExtUtils::Mkbootstrap' => '6.59',
            'ExtUtils::Mksymlists'  => '6.59',
            'ExtUtils::ParseXS'     => '3.03_01',
            'ExtUtils::Typemaps'    => '1.01',
            'ExtUtils::testlib'     => '6.59',
            'File::Spec'            => '3.34',
            'File::Spec::Mac'       => '3.35',
            'File::Spec::Unix'      => '3.34',
            'File::Spec::VMS'       => '3.35',
            'File::Spec::Win32'     => '3.35',
            'I18N::LangTags'        => '0.37',
            'IO'                    => '1.25_05',
            'IO::Handle'            => '1.32',
            'IO::Socket'            => '1.33',
            'IO::Socket::INET'      => '1.32',
            'IPC::Open3'            => '1.12',
            'Math::BigFloat'        => '1.995',
            'Math::BigFloat::Trace' => '0.29',
            'Math::BigInt'          => '1.996',
            'Math::BigInt::Trace'   => '0.29',
            'Module::Build'         => '0.39_01',
            'Module::Build::Base'   => '0.39_01',
            'Module::Build::Compat' => '0.39_01',
            'Module::Build::Config' => '0.39_01',
            'Module::Build::Cookbook'=> '0.39_01',
            'Module::Build::Dumper' => '0.39_01',
            'Module::Build::ModuleInfo'=> '0.39_01',
            'Module::Build::Notes'  => '0.39_01',
            'Module::Build::PPMMaker'=> '0.39_01',
            'Module::Build::Platform::Amiga'=> '0.39_01',
            'Module::Build::Platform::Default'=> '0.39_01',
            'Module::Build::Platform::EBCDIC'=> '0.39_01',
            'Module::Build::Platform::MPEiX'=> '0.39_01',
            'Module::Build::Platform::MacOS'=> '0.39_01',
            'Module::Build::Platform::RiscOS'=> '0.39_01',
            'Module::Build::Platform::Unix'=> '0.39_01',
            'Module::Build::Platform::VMS'=> '0.39_01',
            'Module::Build::Platform::VOS'=> '0.39_01',
            'Module::Build::Platform::Windows'=> '0.39_01',
            'Module::Build::Platform::aix'=> '0.39_01',
            'Module::Build::Platform::cygwin'=> '0.39_01',
            'Module::Build::Platform::darwin'=> '0.39_01',
            'Module::Build::Platform::os2'=> '0.39_01',
            'Module::Build::PodParser'=> '0.39_01',
            'Module::CoreList'      => '2.55',
            'Module::Load'          => '0.20',
            'Module::Metadata'      => '1.000005_01',
            'Opcode'                => '1.20',
            'Params::Check'         => '0.32',
            'PerlIO::via'           => '0.12',
            'Term::ANSIColor'       => '3.01',
            'Unicode::Collate'      => '0.78',
            'Unicode::Normalize'    => '1.13',
            'Unicode::UCD'          => '0.34',
            'bigint'                => '0.29',
            'bignum'                => '0.29',
            'bigrat'                => '0.29',
            'diagnostics'           => '1.24',
            'fields'                => '2.16',
            'inc::latest'           => '0.39_01',
        },
        removed => {
        }
    },
    5.015003 => {
        delta_from => 5.015002,
        changed => {
            'AnyDBM_File'           => '1.01',
            'Archive::Extract'      => '0.56',
            'Archive::Tar'          => '1.78',
            'Archive::Tar::Constant'=> '1.78',
            'Archive::Tar::File'    => '1.78',
            'Attribute::Handlers'   => '0.93',
            'B'                     => '1.32',
            'B::Concise'            => '0.86',
            'B::Deparse'            => '1.08',
            'CPAN::Meta'            => '2.112621',
            'CPAN::Meta::Converter' => '2.112621',
            'CPAN::Meta::Feature'   => '2.112621',
            'CPAN::Meta::History'   => '2.112621',
            'CPAN::Meta::Prereqs'   => '2.112621',
            'CPAN::Meta::Spec'      => '2.112621',
            'CPAN::Meta::Validator' => '2.112621',
            'CPAN::Meta::YAML'      => '0.004',
            'CPANPLUS'              => '0.9111',
            'CPANPLUS::Dist::Build' => '0.58',
            'CPANPLUS::Dist::Build::Constants'=> '0.58',
            'CPANPLUS::Internals'   => '0.9111',
            'CPANPLUS::Shell::Default'=> '0.9111',
            'Carp'                  => '1.23',
            'Carp::Heavy'           => '1.23',
            'Data::Dumper'          => '2.134',
            'Devel::PPPort'         => '3.20',
            'Errno'                 => '1.14',
            'Exporter'              => '5.65',
            'Exporter::Heavy'       => '5.65',
            'ExtUtils::ParseXS'     => '3.04_04',
            'ExtUtils::ParseXS::Constants'=> '3.04_04',
            'ExtUtils::ParseXS::CountLines'=> '3.04_04',
            'ExtUtils::ParseXS::Utilities'=> '3.04_04',
            'ExtUtils::Typemaps'    => '1.02',
            'File::Glob'            => '1.13',
            'Filter::Simple'        => '0.88',
            'IO'                    => '1.25_06',
            'IO::Handle'            => '1.33',
            'Locale::Codes'         => '3.18',
            'Locale::Codes::Constants'=> '3.18',
            'Locale::Codes::Country'=> '3.18',
            'Locale::Codes::Country_Codes'=> '3.18',
            'Locale::Codes::Currency'=> '3.18',
            'Locale::Codes::Currency_Codes'=> '3.18',
            'Locale::Codes::LangExt'=> '3.18',
            'Locale::Codes::LangExt_Codes'=> '3.18',
            'Locale::Codes::LangVar'=> '3.18',
            'Locale::Codes::LangVar_Codes'=> '3.18',
            'Locale::Codes::Language'=> '3.18',
            'Locale::Codes::Language_Codes'=> '3.18',
            'Locale::Codes::Script' => '3.18',
            'Locale::Codes::Script_Codes'=> '3.18',
            'Locale::Country'       => '3.18',
            'Locale::Currency'      => '3.18',
            'Locale::Language'      => '3.18',
            'Locale::Script'        => '3.18',
            'Math::BigFloat'        => '1.997',
            'Math::BigInt'          => '1.997',
            'Math::BigInt::Calc'    => '1.997',
            'Math::BigInt::CalcEmu' => '1.997',
            'Math::BigInt::FastCalc'=> '0.30',
            'Math::BigRat'          => '0.2603',
            'Module::CoreList'      => '2.56',
            'Module::Load::Conditional'=> '0.46',
            'Module::Metadata'      => '1.000007',
            'ODBM_File'             => '1.12',
            'POSIX'                 => '1.26',
            'Pod::Perldoc'          => '3.15_07',
            'Pod::Simple'           => '3.19',
            'Pod::Simple::BlackBox' => '3.19',
            'Pod::Simple::Checker'  => '3.19',
            'Pod::Simple::Debug'    => '3.19',
            'Pod::Simple::DumpAsText'=> '3.19',
            'Pod::Simple::DumpAsXML'=> '3.19',
            'Pod::Simple::HTML'     => '3.19',
            'Pod::Simple::HTMLBatch'=> '3.19',
            'Pod::Simple::LinkSection'=> '3.19',
            'Pod::Simple::Methody'  => '3.19',
            'Pod::Simple::Progress' => '3.19',
            'Pod::Simple::PullParser'=> '3.19',
            'Pod::Simple::PullParserEndToken'=> '3.19',
            'Pod::Simple::PullParserStartToken'=> '3.19',
            'Pod::Simple::PullParserTextToken'=> '3.19',
            'Pod::Simple::PullParserToken'=> '3.19',
            'Pod::Simple::RTF'      => '3.19',
            'Pod::Simple::Search'   => '3.19',
            'Pod::Simple::SimpleTree'=> '3.19',
            'Pod::Simple::Text'     => '3.19',
            'Pod::Simple::TextContent'=> '3.19',
            'Pod::Simple::TiedOutFH'=> '3.19',
            'Pod::Simple::Transcode'=> '3.19',
            'Pod::Simple::TranscodeDumb'=> '3.19',
            'Pod::Simple::TranscodeSmart'=> '3.19',
            'Pod::Simple::XHTML'    => '3.19',
            'Pod::Simple::XMLOutStream'=> '3.19',
            'Search::Dict'          => '1.04',
            'Socket'                => '1.94_01',
            'Storable'              => '2.32',
            'Text::Abbrev'          => '1.02',
            'Tie::Array'            => '1.05',
            'UNIVERSAL'             => '1.09',
            'Unicode::UCD'          => '0.35',
            'XS::APItest'           => '0.31',
            'XSLoader'              => '0.16',
            'attributes'            => '0.16',
            'diagnostics'           => '1.25',
            'open'                  => '1.09',
            'perlfaq'               => '5.0150034',
            'threads'               => '1.85',
            'threads::shared'       => '1.40',
        },
        removed => {
        }
    },
    5.015004 => {
        delta_from => 5.015003,
        changed => {
            'Archive::Tar'          => '1.80',
            'Archive::Tar::Constant'=> '1.80',
            'Archive::Tar::File'    => '1.80',
            'Digest'                => '1.17',
            'DynaLoader'            => '1.14',
            'ExtUtils::Command::MM' => '6.61_01',
            'ExtUtils::Liblist'     => '6.61_01',
            'ExtUtils::Liblist::Kid'=> '6.61_01',
            'ExtUtils::MM'          => '6.61_01',
            'ExtUtils::MM_AIX'      => '6.61_01',
            'ExtUtils::MM_Any'      => '6.61_01',
            'ExtUtils::MM_BeOS'     => '6.61_01',
            'ExtUtils::MM_Cygwin'   => '6.61_01',
            'ExtUtils::MM_DOS'      => '6.61_01',
            'ExtUtils::MM_Darwin'   => '6.61_01',
            'ExtUtils::MM_MacOS'    => '6.61_01',
            'ExtUtils::MM_NW5'      => '6.61_01',
            'ExtUtils::MM_OS2'      => '6.61_01',
            'ExtUtils::MM_QNX'      => '6.61_01',
            'ExtUtils::MM_UWIN'     => '6.61_01',
            'ExtUtils::MM_Unix'     => '6.61_01',
            'ExtUtils::MM_VMS'      => '6.61_01',
            'ExtUtils::MM_VOS'      => '6.61_01',
            'ExtUtils::MM_Win32'    => '6.61_01',
            'ExtUtils::MM_Win95'    => '6.61_01',
            'ExtUtils::MY'          => '6.61_01',
            'ExtUtils::MakeMaker'   => '6.61_01',
            'ExtUtils::MakeMaker::Config'=> '6.61_01',
            'ExtUtils::Mkbootstrap' => '6.61_01',
            'ExtUtils::Mksymlists'  => '6.61_01',
            'ExtUtils::ParseXS'     => '3.05',
            'ExtUtils::ParseXS::Constants'=> '3.05',
            'ExtUtils::ParseXS::CountLines'=> '3.05',
            'ExtUtils::ParseXS::Utilities'=> '3.05',
            'ExtUtils::testlib'     => '6.61_01',
            'File::DosGlob'         => '1.05',
            'Module::CoreList'      => '2.57',
            'Module::Load'          => '0.22',
            'Unicode::Collate'      => '0.80',
            'Unicode::Collate::Locale'=> '0.80',
            'Unicode::UCD'          => '0.36',
            'XS::APItest'           => '0.32',
            'XS::Typemap'           => '0.07',
            'attributes'            => '0.17',
            'base'                  => '2.18',
            'constant'              => '1.23',
            'mro'                   => '1.09',
            'open'                  => '1.10',
            'perlfaq'               => '5.0150035',
        },
        removed => {
        }
    },
    5.015005 => {
        delta_from => 5.015004,
        changed => {
            'Archive::Extract'      => '0.58',
            'B::Concise'            => '0.87',
            'B::Deparse'            => '1.09',
            'CGI'                   => '3.58',
            'CGI::Fast'             => '1.09',
            'CPANPLUS'              => '0.9112',
            'CPANPLUS::Dist::Build' => '0.60',
            'CPANPLUS::Dist::Build::Constants'=> '0.60',
            'CPANPLUS::Internals'   => '0.9112',
            'CPANPLUS::Shell::Default'=> '0.9112',
            'Compress::Raw::Bzip2'  => '2.042',
            'Compress::Raw::Zlib'   => '2.042',
            'Compress::Zlib'        => '2.042',
            'Digest::SHA'           => '5.63',
            'Errno'                 => '1.15',
            'ExtUtils::Command::MM' => '6.63_02',
            'ExtUtils::Liblist'     => '6.63_02',
            'ExtUtils::Liblist::Kid'=> '6.63_02',
            'ExtUtils::MM'          => '6.63_02',
            'ExtUtils::MM_AIX'      => '6.63_02',
            'ExtUtils::MM_Any'      => '6.63_02',
            'ExtUtils::MM_BeOS'     => '6.63_02',
            'ExtUtils::MM_Cygwin'   => '6.63_02',
            'ExtUtils::MM_DOS'      => '6.63_02',
            'ExtUtils::MM_Darwin'   => '6.63_02',
            'ExtUtils::MM_MacOS'    => '6.63_02',
            'ExtUtils::MM_NW5'      => '6.63_02',
            'ExtUtils::MM_OS2'      => '6.63_02',
            'ExtUtils::MM_QNX'      => '6.63_02',
            'ExtUtils::MM_UWIN'     => '6.63_02',
            'ExtUtils::MM_Unix'     => '6.63_02',
            'ExtUtils::MM_VMS'      => '6.63_02',
            'ExtUtils::MM_VOS'      => '6.63_02',
            'ExtUtils::MM_Win32'    => '6.63_02',
            'ExtUtils::MM_Win95'    => '6.63_02',
            'ExtUtils::MY'          => '6.63_02',
            'ExtUtils::MakeMaker'   => '6.63_02',
            'ExtUtils::MakeMaker::Config'=> '6.63_02',
            'ExtUtils::Mkbootstrap' => '6.63_02',
            'ExtUtils::Mksymlists'  => '6.63_02',
            'ExtUtils::testlib'     => '6.63_02',
            'File::DosGlob'         => '1.06',
            'File::Glob'            => '1.14',
            'HTTP::Tiny'            => '0.016',
            'IO::Compress::Adapter::Bzip2'=> '2.042',
            'IO::Compress::Adapter::Deflate'=> '2.042',
            'IO::Compress::Adapter::Identity'=> '2.042',
            'IO::Compress::Base'    => '2.042',
            'IO::Compress::Base::Common'=> '2.042',
            'IO::Compress::Bzip2'   => '2.042',
            'IO::Compress::Deflate' => '2.042',
            'IO::Compress::Gzip'    => '2.042',
            'IO::Compress::Gzip::Constants'=> '2.042',
            'IO::Compress::RawDeflate'=> '2.042',
            'IO::Compress::Zip'     => '2.042',
            'IO::Compress::Zip::Constants'=> '2.042',
            'IO::Compress::Zlib::Constants'=> '2.042',
            'IO::Compress::Zlib::Extra'=> '2.042',
            'IO::Uncompress::Adapter::Bunzip2'=> '2.042',
            'IO::Uncompress::Adapter::Identity'=> '2.042',
            'IO::Uncompress::Adapter::Inflate'=> '2.042',
            'IO::Uncompress::AnyInflate'=> '2.042',
            'IO::Uncompress::AnyUncompress'=> '2.042',
            'IO::Uncompress::Base'  => '2.042',
            'IO::Uncompress::Bunzip2'=> '2.042',
            'IO::Uncompress::Gunzip'=> '2.042',
            'IO::Uncompress::Inflate'=> '2.042',
            'IO::Uncompress::RawInflate'=> '2.042',
            'IO::Uncompress::Unzip' => '2.042',
            'Locale::Maketext'      => '1.20',
            'Locale::Maketext::Guts'=> '1.20',
            'Locale::Maketext::GutsLoader'=> '1.20',
            'Module::CoreList'      => '2.58',
            'Opcode'                => '1.21',
            'Socket'                => '1.94_02',
            'Storable'              => '2.33',
            'UNIVERSAL'             => '1.10',
            'Unicode::Collate'      => '0.85',
            'Unicode::Collate::CJK::Pinyin'=> '0.85',
            'Unicode::Collate::CJK::Stroke'=> '0.85',
            'Unicode::Collate::Locale'=> '0.85',
            'Unicode::UCD'          => '0.37',
            'XS::APItest'           => '0.33',
            'arybase'               => '0.01',
            'charnames'             => '1.24',
            'feature'               => '1.23',
            'perlfaq'               => '5.0150036',
            'strict'                => '1.05',
            'unicore::Name'         => undef,
        },
        removed => {
        }
    },
    5.015006 => {
        delta_from => 5.015005,
        changed => {
            'Archive::Tar'          => '1.82',
            'Archive::Tar::Constant'=> '1.82',
            'Archive::Tar::File'    => '1.82',
            'AutoLoader'            => '5.72',
            'B::Concise'            => '0.88',
            'B::Debug'              => '1.17',
            'B::Deparse'            => '1.10',
            'CPAN::Meta::YAML'      => '0.005',
            'CPANPLUS'              => '0.9113',
            'CPANPLUS::Internals'   => '0.9113',
            'CPANPLUS::Shell::Default'=> '0.9113',
            'Carp'                  => '1.24',
            'Compress::Raw::Bzip2'  => '2.045',
            'Compress::Raw::Zlib'   => '2.045',
            'Compress::Zlib'        => '2.045',
            'Cwd'                   => '3.38',
            'DB'                    => '1.04',
            'Data::Dumper'          => '2.135_01',
            'Digest::SHA'           => '5.70',
            'Dumpvalue'             => '1.17',
            'Exporter'              => '5.66',
            'Exporter::Heavy'       => '5.66',
            'ExtUtils::CBuilder'    => '0.280205',
            'ExtUtils::CBuilder::Platform::os2'=> '0.280204',
            'ExtUtils::Packlist'    => '1.45',
            'ExtUtils::ParseXS'     => '3.08',
            'ExtUtils::ParseXS::Constants'=> '3.08',
            'ExtUtils::ParseXS::CountLines'=> '3.08',
            'ExtUtils::ParseXS::Utilities'=> '3.08',
            'File::Basename'        => '2.84',
            'File::Glob'            => '1.15',
            'File::Spec::Unix'      => '3.35',
            'Getopt::Std'           => '1.07',
            'I18N::LangTags'        => '0.38',
            'IO::Compress::Adapter::Bzip2'=> '2.045',
            'IO::Compress::Adapter::Deflate'=> '2.045',
            'IO::Compress::Adapter::Identity'=> '2.045',
            'IO::Compress::Base'    => '2.046',
            'IO::Compress::Base::Common'=> '2.045',
            'IO::Compress::Bzip2'   => '2.045',
            'IO::Compress::Deflate' => '2.045',
            'IO::Compress::Gzip'    => '2.045',
            'IO::Compress::Gzip::Constants'=> '2.045',
            'IO::Compress::RawDeflate'=> '2.045',
            'IO::Compress::Zip'     => '2.046',
            'IO::Compress::Zip::Constants'=> '2.045',
            'IO::Compress::Zlib::Constants'=> '2.045',
            'IO::Compress::Zlib::Extra'=> '2.045',
            'IO::Dir'               => '1.09',
            'IO::File'              => '1.16',
            'IO::Uncompress::Adapter::Bunzip2'=> '2.045',
            'IO::Uncompress::Adapter::Identity'=> '2.045',
            'IO::Uncompress::Adapter::Inflate'=> '2.045',
            'IO::Uncompress::AnyInflate'=> '2.045',
            'IO::Uncompress::AnyUncompress'=> '2.045',
            'IO::Uncompress::Base'  => '2.046',
            'IO::Uncompress::Bunzip2'=> '2.045',
            'IO::Uncompress::Gunzip'=> '2.045',
            'IO::Uncompress::Inflate'=> '2.045',
            'IO::Uncompress::RawInflate'=> '2.045',
            'IO::Uncompress::Unzip' => '2.046',
            'Locale::Codes'         => '3.20',
            'Locale::Codes::Constants'=> '3.20',
            'Locale::Codes::Country'=> '3.20',
            'Locale::Codes::Country_Codes'=> '3.20',
            'Locale::Codes::Country_Retired'=> '3.20',
            'Locale::Codes::Currency'=> '3.20',
            'Locale::Codes::Currency_Codes'=> '3.20',
            'Locale::Codes::Currency_Retired'=> '3.20',
            'Locale::Codes::LangExt'=> '3.20',
            'Locale::Codes::LangExt_Codes'=> '3.20',
            'Locale::Codes::LangExt_Retired'=> '3.20',
            'Locale::Codes::LangFam'=> '3.20',
            'Locale::Codes::LangFam_Codes'=> '3.20',
            'Locale::Codes::LangFam_Retired'=> '3.20',
            'Locale::Codes::LangVar'=> '3.20',
            'Locale::Codes::LangVar_Codes'=> '3.20',
            'Locale::Codes::LangVar_Retired'=> '3.20',
            'Locale::Codes::Language'=> '3.20',
            'Locale::Codes::Language_Codes'=> '3.20',
            'Locale::Codes::Language_Retired'=> '3.20',
            'Locale::Codes::Script' => '3.20',
            'Locale::Codes::Script_Codes'=> '3.20',
            'Locale::Codes::Script_Retired'=> '3.20',
            'Locale::Country'       => '3.20',
            'Locale::Currency'      => '3.20',
            'Locale::Language'      => '3.20',
            'Locale::Maketext'      => '1.21',
            'Locale::Script'        => '3.20',
            'Module::CoreList'      => '2.59',
            'Module::Loaded'        => '0.08',
            'Opcode'                => '1.22',
            'POSIX'                 => '1.27',
            'Pod::Html'             => '1.12',
            'Pod::LaTeX'            => '0.60',
            'Pod::Perldoc'          => '3.15_08',
            'Safe'                  => '2.30',
            'SelfLoader'            => '1.20',
            'Socket'                => '1.97',
            'Storable'              => '2.34',
            'UNIVERSAL'             => '1.11',
            'Unicode::Collate'      => '0.87',
            'Unicode::Collate::Locale'=> '0.87',
            'XS::APItest'           => '0.34',
            'arybase'               => '0.02',
            'charnames'             => '1.27',
            'diagnostics'           => '1.26',
            'feature'               => '1.24',
            'if'                    => '0.0602',
            'overload'              => '1.16',
            'sigtrap'               => '1.06',
            'strict'                => '1.06',
            'threads'               => '1.86',
            'version'               => '0.96',
        },
        removed => {
        }
    },
    5.015007 => {
        delta_from => 5.015006,
        changed => {
            'B'                     => '1.33',
            'B::Deparse'            => '1.11',
            'CGI'                   => '3.59',
            'CPAN::Meta'            => '2.113640',
            'CPAN::Meta::Converter' => '2.113640',
            'CPAN::Meta::Feature'   => '2.113640',
            'CPAN::Meta::History'   => '2.113640',
            'CPAN::Meta::Prereqs'   => '2.113640',
            'CPAN::Meta::Requirements'=> '2.113640',
            'CPAN::Meta::Spec'      => '2.113640',
            'CPAN::Meta::Validator' => '2.113640',
            'CPANPLUS'              => '0.9116',
            'CPANPLUS::Internals'   => '0.9116',
            'CPANPLUS::Shell::Default'=> '0.9116',
            'Cwd'                   => '3.39_01',
            'Data::Dumper'          => '2.135_03',
            'Devel::InnerPackage'   => '0.4',
            'ExtUtils::CBuilder::Base'=> '0.280205',
            'ExtUtils::CBuilder::Platform::Unix'=> '0.280205',
            'ExtUtils::CBuilder::Platform::VMS'=> '0.280205',
            'ExtUtils::CBuilder::Platform::Windows'=> '0.280205',
            'ExtUtils::CBuilder::Platform::Windows::BCC'=> '0.280205',
            'ExtUtils::CBuilder::Platform::Windows::GCC'=> '0.280205',
            'ExtUtils::CBuilder::Platform::Windows::MSVC'=> '0.280205',
            'ExtUtils::CBuilder::Platform::aix'=> '0.280205',
            'ExtUtils::CBuilder::Platform::cygwin'=> '0.280205',
            'ExtUtils::CBuilder::Platform::darwin'=> '0.280205',
            'ExtUtils::CBuilder::Platform::dec_osf'=> '0.280205',
            'ExtUtils::CBuilder::Platform::os2'=> '0.280205',
            'ExtUtils::Manifest'    => '1.61',
            'ExtUtils::Packlist'    => '1.46',
            'ExtUtils::ParseXS'     => '3.12',
            'ExtUtils::ParseXS::Constants'=> '3.12',
            'ExtUtils::ParseXS::CountLines'=> '3.12',
            'ExtUtils::ParseXS::Utilities'=> '3.12',
            'ExtUtils::Typemaps'    => '1.03',
            'ExtUtils::Typemaps::Cmd'=> undef,
            'ExtUtils::Typemaps::Type'=> '0.06',
            'File::Glob'            => '1.16',
            'File::Spec'            => '3.39_01',
            'File::Spec::Cygwin'    => '3.39_01',
            'File::Spec::Epoc'      => '3.39_01',
            'File::Spec::Functions' => '3.39_01',
            'File::Spec::Mac'       => '3.39_01',
            'File::Spec::OS2'       => '3.39_01',
            'File::Spec::Unix'      => '3.39_01',
            'File::Spec::VMS'       => '3.39_01',
            'File::Spec::Win32'     => '3.39_01',
            'IO::Dir'               => '1.10',
            'IO::Pipe'              => '1.15',
            'IO::Poll'              => '0.09',
            'IO::Select'            => '1.21',
            'IO::Socket'            => '1.34',
            'IO::Socket::INET'      => '1.33',
            'IO::Socket::UNIX'      => '1.24',
            'Locale::Maketext'      => '1.22',
            'Math::BigInt'          => '1.998',
            'Module::CoreList'      => '2.60',
            'Module::Pluggable'     => '4.0',
            'POSIX'                 => '1.28',
            'PerlIO::scalar'        => '0.13',
            'Pod::Html'             => '1.13',
            'Pod::Perldoc'          => '3.15_15',
            'Pod::Perldoc::BaseTo'  => '3.15_15',
            'Pod::Perldoc::GetOptsOO'=> '3.15_15',
            'Pod::Perldoc::ToANSI'  => '3.15_15',
            'Pod::Perldoc::ToChecker'=> '3.15_15',
            'Pod::Perldoc::ToMan'   => '3.15_15',
            'Pod::Perldoc::ToNroff' => '3.15_15',
            'Pod::Perldoc::ToPod'   => '3.15_15',
            'Pod::Perldoc::ToRtf'   => '3.15_15',
            'Pod::Perldoc::ToTerm'  => '3.15_15',
            'Pod::Perldoc::ToText'  => '3.15_15',
            'Pod::Perldoc::ToTk'    => '3.15_15',
            'Pod::Perldoc::ToXml'   => '3.15_15',
            'Term::UI'              => '0.30',
            'Tie::File'             => '0.98',
            'Unicode::UCD'          => '0.39',
            'Version::Requirements' => '0.101021',
            'XS::APItest'           => '0.35',
            '_charnames'            => '1.28',
            'arybase'               => '0.03',
            'autouse'               => '1.07',
            'charnames'             => '1.28',
            'diagnostics'           => '1.27',
            'feature'               => '1.25',
            'overload'              => '1.17',
            'overloading'           => '0.02',
            'perlfaq'               => '5.0150038',
        },
        removed => {
        }
    },
    5.015008 => {
        delta_from => 5.015007,
        changed => {
            'B'                     => '1.34',
            'B::Deparse'            => '1.12',
            'CPAN::Meta'            => '2.120351',
            'CPAN::Meta::Converter' => '2.120351',
            'CPAN::Meta::Feature'   => '2.120351',
            'CPAN::Meta::History'   => '2.120351',
            'CPAN::Meta::Prereqs'   => '2.120351',
            'CPAN::Meta::Requirements'=> '2.120351',
            'CPAN::Meta::Spec'      => '2.120351',
            'CPAN::Meta::Validator' => '2.120351',
            'CPAN::Meta::YAML'      => '0.007',
            'CPANPLUS'              => '0.9118',
            'CPANPLUS::Dist::Build' => '0.62',
            'CPANPLUS::Dist::Build::Constants'=> '0.62',
            'CPANPLUS::Internals'   => '0.9118',
            'CPANPLUS::Shell::Default'=> '0.9118',
            'Carp'                  => '1.25',
            'Carp::Heavy'           => '1.25',
            'Compress::Raw::Bzip2'  => '2.048',
            'Compress::Raw::Zlib'   => '2.048',
            'Compress::Zlib'        => '2.048',
            'Cwd'                   => '3.39_02',
            'DB_File'               => '1.826',
            'Data::Dumper'          => '2.135_05',
            'English'               => '1.05',
            'ExtUtils::Install'     => '1.58',
            'ExtUtils::ParseXS'     => '3.16',
            'ExtUtils::ParseXS::Constants'=> '3.16',
            'ExtUtils::ParseXS::CountLines'=> '3.16',
            'ExtUtils::ParseXS::Utilities'=> '3.16',
            'ExtUtils::Typemaps'    => '3.16',
            'ExtUtils::Typemaps::Cmd'=> '3.16',
            'ExtUtils::Typemaps::InputMap'=> '3.16',
            'ExtUtils::Typemaps::OutputMap'=> '3.16',
            'ExtUtils::Typemaps::Type'=> '3.16',
            'File::Copy'            => '2.23',
            'File::Glob'            => '1.17',
            'File::Spec'            => '3.39_02',
            'File::Spec::Cygwin'    => '3.39_02',
            'File::Spec::Epoc'      => '3.39_02',
            'File::Spec::Functions' => '3.39_02',
            'File::Spec::Mac'       => '3.39_02',
            'File::Spec::OS2'       => '3.39_02',
            'File::Spec::Unix'      => '3.39_02',
            'File::Spec::VMS'       => '3.39_02',
            'File::Spec::Win32'     => '3.39_02',
            'Filter::Util::Call'    => '1.40',
            'IO::Compress::Adapter::Bzip2'=> '2.048',
            'IO::Compress::Adapter::Deflate'=> '2.048',
            'IO::Compress::Adapter::Identity'=> '2.048',
            'IO::Compress::Base'    => '2.048',
            'IO::Compress::Base::Common'=> '2.048',
            'IO::Compress::Bzip2'   => '2.048',
            'IO::Compress::Deflate' => '2.048',
            'IO::Compress::Gzip'    => '2.048',
            'IO::Compress::Gzip::Constants'=> '2.048',
            'IO::Compress::RawDeflate'=> '2.048',
            'IO::Compress::Zip'     => '2.048',
            'IO::Compress::Zip::Constants'=> '2.048',
            'IO::Compress::Zlib::Constants'=> '2.048',
            'IO::Compress::Zlib::Extra'=> '2.048',
            'IO::Uncompress::Adapter::Bunzip2'=> '2.048',
            'IO::Uncompress::Adapter::Identity'=> '2.048',
            'IO::Uncompress::Adapter::Inflate'=> '2.048',
            'IO::Uncompress::AnyInflate'=> '2.048',
            'IO::Uncompress::AnyUncompress'=> '2.048',
            'IO::Uncompress::Base'  => '2.048',
            'IO::Uncompress::Bunzip2'=> '2.048',
            'IO::Uncompress::Gunzip'=> '2.048',
            'IO::Uncompress::Inflate'=> '2.048',
            'IO::Uncompress::RawInflate'=> '2.048',
            'IO::Uncompress::Unzip' => '2.048',
            'IPC::Cmd'              => '0.76',
            'Math::Complex'         => '1.59',
            'Math::Trig'            => '1.23',
            'Module::Metadata'      => '1.000009',
            'Opcode'                => '1.23',
            'POSIX'                 => '1.30',
            'Parse::CPAN::Meta'     => '1.4402',
            'PerlIO::mmap'          => '0.010',
            'Pod::Checker'          => '1.51',
            'Pod::Find'             => '1.51',
            'Pod::Functions'        => '1.05',
            'Pod::Html'             => '1.14',
            'Pod::InputObjects'     => '1.51',
            'Pod::ParseUtils'       => '1.51',
            'Pod::Parser'           => '1.51',
            'Pod::PlainText'        => '2.05',
            'Pod::Select'           => '1.51',
            'Pod::Usage'            => '1.51',
            'Safe'                  => '2.31',
            'Socket'                => '1.98',
            'Term::Cap'             => '1.13',
            'Term::ReadLine'        => '1.08',
            'Time::HiRes'           => '1.9725',
            'Unicode'               => '6.1.0',
            'Unicode::UCD'          => '0.41',
            'Version::Requirements' => '0.101022',
            'XS::APItest'           => '0.36',
            'XS::Typemap'           => '0.08',
            '_charnames'            => '1.29',
            'arybase'               => '0.04',
            'charnames'             => '1.29',
            'diagnostics'           => '1.28',
            'feature'               => '1.26',
            'locale'                => '1.01',
            'overload'              => '1.18',
            'perlfaq'               => '5.0150039',
            're'                    => '0.19',
            'subs'                  => '1.01',
            'warnings'              => '1.13',
        },
        removed => {
        }
    },
    5.015009 => {
        delta_from => 5.015008,
        changed => {
            'B::Deparse'            => '1.13',
            'B::Lint'               => '1.14',
            'B::Lint::Debug'        => '1.14',
            'CPAN::Meta'            => '2.120630',
            'CPAN::Meta::Converter' => '2.120630',
            'CPAN::Meta::Feature'   => '2.120630',
            'CPAN::Meta::History'   => '2.120630',
            'CPAN::Meta::Prereqs'   => '2.120630',
            'CPAN::Meta::Requirements'=> '2.120630',
            'CPAN::Meta::Spec'      => '2.120630',
            'CPAN::Meta::Validator' => '2.120630',
            'CPANPLUS'              => '0.9121',
            'CPANPLUS::Internals'   => '0.9121',
            'CPANPLUS::Shell::Default'=> '0.9121',
            'Data::Dumper'          => '2.135_06',
            'Digest::SHA'           => '5.71',
            'ExtUtils::CBuilder'    => '0.280206',
            'ExtUtils::CBuilder::Base'=> '0.280206',
            'ExtUtils::CBuilder::Platform::Unix'=> '0.280206',
            'ExtUtils::CBuilder::Platform::VMS'=> '0.280206',
            'ExtUtils::CBuilder::Platform::Windows'=> '0.280206',
            'ExtUtils::CBuilder::Platform::Windows::BCC'=> '0.280206',
            'ExtUtils::CBuilder::Platform::Windows::GCC'=> '0.280206',
            'ExtUtils::CBuilder::Platform::Windows::MSVC'=> '0.280206',
            'ExtUtils::CBuilder::Platform::aix'=> '0.280206',
            'ExtUtils::CBuilder::Platform::cygwin'=> '0.280206',
            'ExtUtils::CBuilder::Platform::darwin'=> '0.280206',
            'ExtUtils::CBuilder::Platform::dec_osf'=> '0.280206',
            'ExtUtils::CBuilder::Platform::os2'=> '0.280206',
            'HTTP::Tiny'            => '0.017',
            'Locale::Codes'         => '3.21',
            'Locale::Codes::Constants'=> '3.21',
            'Locale::Codes::Country'=> '3.21',
            'Locale::Codes::Country_Codes'=> '3.21',
            'Locale::Codes::Country_Retired'=> '3.21',
            'Locale::Codes::Currency'=> '3.21',
            'Locale::Codes::Currency_Codes'=> '3.21',
            'Locale::Codes::Currency_Retired'=> '3.21',
            'Locale::Codes::LangExt'=> '3.21',
            'Locale::Codes::LangExt_Codes'=> '3.21',
            'Locale::Codes::LangExt_Retired'=> '3.21',
            'Locale::Codes::LangFam'=> '3.21',
            'Locale::Codes::LangFam_Codes'=> '3.21',
            'Locale::Codes::LangFam_Retired'=> '3.21',
            'Locale::Codes::LangVar'=> '3.21',
            'Locale::Codes::LangVar_Codes'=> '3.21',
            'Locale::Codes::LangVar_Retired'=> '3.21',
            'Locale::Codes::Language'=> '3.21',
            'Locale::Codes::Language_Codes'=> '3.21',
            'Locale::Codes::Language_Retired'=> '3.21',
            'Locale::Codes::Script' => '3.21',
            'Locale::Codes::Script_Codes'=> '3.21',
            'Locale::Codes::Script_Retired'=> '3.21',
            'Locale::Country'       => '3.21',
            'Locale::Currency'      => '3.21',
            'Locale::Language'      => '3.21',
            'Locale::Script'        => '3.21',
            'Module::CoreList'      => '2.65',
            'Pod::Html'             => '1.1501',
            'Pod::Perldoc'          => '3.17',
            'Pod::Perldoc::BaseTo'  => '3.17',
            'Pod::Perldoc::GetOptsOO'=> '3.17',
            'Pod::Perldoc::ToANSI'  => '3.17',
            'Pod::Perldoc::ToChecker'=> '3.17',
            'Pod::Perldoc::ToMan'   => '3.17',
            'Pod::Perldoc::ToNroff' => '3.17',
            'Pod::Perldoc::ToPod'   => '3.17',
            'Pod::Perldoc::ToRtf'   => '3.17',
            'Pod::Perldoc::ToTerm'  => '3.17',
            'Pod::Perldoc::ToText'  => '3.17',
            'Pod::Perldoc::ToTk'    => '3.17',
            'Pod::Perldoc::ToXml'   => '3.17',
            'Pod::Simple'           => '3.20',
            'Pod::Simple::BlackBox' => '3.20',
            'Pod::Simple::Checker'  => '3.20',
            'Pod::Simple::Debug'    => '3.20',
            'Pod::Simple::DumpAsText'=> '3.20',
            'Pod::Simple::DumpAsXML'=> '3.20',
            'Pod::Simple::HTML'     => '3.20',
            'Pod::Simple::HTMLBatch'=> '3.20',
            'Pod::Simple::LinkSection'=> '3.20',
            'Pod::Simple::Methody'  => '3.20',
            'Pod::Simple::Progress' => '3.20',
            'Pod::Simple::PullParser'=> '3.20',
            'Pod::Simple::PullParserEndToken'=> '3.20',
            'Pod::Simple::PullParserStartToken'=> '3.20',
            'Pod::Simple::PullParserTextToken'=> '3.20',
            'Pod::Simple::PullParserToken'=> '3.20',
            'Pod::Simple::RTF'      => '3.20',
            'Pod::Simple::Search'   => '3.20',
            'Pod::Simple::SimpleTree'=> '3.20',
            'Pod::Simple::Text'     => '3.20',
            'Pod::Simple::TextContent'=> '3.20',
            'Pod::Simple::TiedOutFH'=> '3.20',
            'Pod::Simple::Transcode'=> '3.20',
            'Pod::Simple::TranscodeDumb'=> '3.20',
            'Pod::Simple::TranscodeSmart'=> '3.20',
            'Pod::Simple::XHTML'    => '3.20',
            'Pod::Simple::XMLOutStream'=> '3.20',
            'Socket'                => '2.000',
            'Term::ReadLine'        => '1.09',
            'Unicode::Collate'      => '0.89',
            'Unicode::Collate::CJK::Korean'=> '0.88',
            'Unicode::Collate::Locale'=> '0.89',
            'Unicode::Normalize'    => '1.14',
            'Unicode::UCD'          => '0.42',
            'XS::APItest'           => '0.37',
            'arybase'               => '0.05',
            'attributes'            => '0.18',
            'charnames'             => '1.30',
            'feature'               => '1.27',
        },
        removed => {
        }
    },
    5.016 => {
        delta_from => 5.015009,
        changed => {
            'B::Concise'            => '0.89',
            'B::Deparse'            => '1.14',
            'Carp'                  => '1.26',
            'Carp::Heavy'           => '1.26',
            'IO::Socket'            => '1.35',
            'Module::CoreList'      => '2.66',
            'PerlIO::scalar'        => '0.14',
            'Pod::Html'             => '1.1502',
            'Safe'                  => '2.31_01',
            'Socket'                => '2.001',
            'Unicode::UCD'          => '0.43',
            'XS::APItest'           => '0.38',
            '_charnames'            => '1.31',
            'attributes'            => '0.19',
            'strict'                => '1.07',
            'version'               => '0.99',
        },
        removed => {
        }
    },
    5.016001 => {
        delta_from => 5.016,
        changed => {
            'B'                     => '1.35',
            'B::Deparse'            => '1.14_01',
            'List::Util'            => '1.25',
            'List::Util::PP'        => '1.25',
            'List::Util::XS'        => '1.25',
            'Module::CoreList'      => '2.70',
            'PerlIO::scalar'        => '0.14_01',
            'Scalar::Util'          => '1.25',
            'Scalar::Util::PP'      => '1.25',
            're'                    => '0.19_01',
        },
        removed => {
        }
    },
    5.016002 => {
        delta_from => 5.016001,
        changed => {
            'Module::CoreList'      => '2.76',
        },
        removed => {
        }
    },
    5.016003 => {
        delta_from => 5.016002,
        changed => {
            'Encode'                => '2.44_01',
            'Module::CoreList'      => '2.76_02',
            'XS::APItest'           => '0.39',
        },
        removed => {
        }
    },
    5.017 => {
        delta_from => 5.016,
        changed => {
            'B'                     => '1.35',
            'B::Concise'            => '0.90',
            'ExtUtils::ParseXS'     => '3.17',
            'ExtUtils::ParseXS::Utilities'=> '3.17',
            'File::DosGlob'         => '1.07',
            'File::Find'            => '1.21',
            'File::stat'            => '1.06',
            'Hash::Util'            => '0.12',
            'IO::Socket'            => '1.34',
            'Module::CoreList'      => '2.67',
            'Pod::Functions'        => '1.06',
            'Storable'              => '2.35',
            'XS::APItest'           => '0.39',
            'diagnostics'           => '1.29',
            'feature'               => '1.28',
            'overload'              => '1.19',
            'utf8'                  => '1.10',
        },
        removed => {
            'Version::Requirements' => 1,
        }
    },
    5.017001 => {
        delta_from => 5.017,
        changed => {
            'App::Prove'            => '3.25',
            'App::Prove::State'     => '3.25',
            'App::Prove::State::Result'=> '3.25',
            'App::Prove::State::Result::Test'=> '3.25',
            'Archive::Extract'      => '0.60',
            'Archive::Tar'          => '1.88',
            'Archive::Tar::Constant'=> '1.88',
            'Archive::Tar::File'    => '1.88',
            'B'                     => '1.36',
            'B::Deparse'            => '1.15',
            'CPAN::Meta'            => '2.120921',
            'CPAN::Meta::Converter' => '2.120921',
            'CPAN::Meta::Feature'   => '2.120921',
            'CPAN::Meta::History'   => '2.120921',
            'CPAN::Meta::Prereqs'   => '2.120921',
            'CPAN::Meta::Requirements'=> '2.122',
            'CPAN::Meta::Spec'      => '2.120921',
            'CPAN::Meta::Validator' => '2.120921',
            'CPAN::Meta::YAML'      => '0.008',
            'CPANPLUS'              => '0.9130',
            'CPANPLUS::Config::HomeEnv'=> '0.04',
            'CPANPLUS::Internals'   => '0.9130',
            'CPANPLUS::Shell::Default'=> '0.9130',
            'Class::Struct'         => '0.64',
            'Compress::Raw::Bzip2'  => '2.052',
            'Compress::Raw::Zlib'   => '2.054',
            'Compress::Zlib'        => '2.052',
            'Digest::MD5'           => '2.52',
            'DynaLoader'            => '1.15',
            'ExtUtils::CBuilder'    => '0.280208',
            'ExtUtils::CBuilder::Base'=> '0.280208',
            'ExtUtils::CBuilder::Platform::Unix'=> '0.280208',
            'ExtUtils::CBuilder::Platform::VMS'=> '0.280208',
            'ExtUtils::CBuilder::Platform::Windows'=> '0.280208',
            'ExtUtils::CBuilder::Platform::Windows::BCC'=> '0.280208',
            'ExtUtils::CBuilder::Platform::Windows::GCC'=> '0.280208',
            'ExtUtils::CBuilder::Platform::Windows::MSVC'=> '0.280208',
            'ExtUtils::CBuilder::Platform::aix'=> '0.280208',
            'ExtUtils::CBuilder::Platform::cygwin'=> '0.280208',
            'ExtUtils::CBuilder::Platform::darwin'=> '0.280208',
            'ExtUtils::CBuilder::Platform::dec_osf'=> '0.280208',
            'ExtUtils::CBuilder::Platform::os2'=> '0.280208',
            'Fatal'                 => '2.11',
            'File::DosGlob'         => '1.08',
            'File::Fetch'           => '0.34',
            'File::Spec::Unix'      => '3.39_03',
            'Filter::Util::Call'    => '1.45',
            'HTTP::Tiny'            => '0.022',
            'IO'                    => '1.25_07',
            'IO::Compress::Adapter::Bzip2'=> '2.052',
            'IO::Compress::Adapter::Deflate'=> '2.052',
            'IO::Compress::Adapter::Identity'=> '2.052',
            'IO::Compress::Base'    => '2.052',
            'IO::Compress::Base::Common'=> '2.052',
            'IO::Compress::Bzip2'   => '2.052',
            'IO::Compress::Deflate' => '2.052',
            'IO::Compress::Gzip'    => '2.052',
            'IO::Compress::Gzip::Constants'=> '2.052',
            'IO::Compress::RawDeflate'=> '2.052',
            'IO::Compress::Zip'     => '2.052',
            'IO::Compress::Zip::Constants'=> '2.052',
            'IO::Compress::Zlib::Constants'=> '2.052',
            'IO::Compress::Zlib::Extra'=> '2.052',
            'IO::Uncompress::Adapter::Bunzip2'=> '2.052',
            'IO::Uncompress::Adapter::Identity'=> '2.052',
            'IO::Uncompress::Adapter::Inflate'=> '2.052',
            'IO::Uncompress::AnyInflate'=> '2.052',
            'IO::Uncompress::AnyUncompress'=> '2.052',
            'IO::Uncompress::Base'  => '2.052',
            'IO::Uncompress::Bunzip2'=> '2.052',
            'IO::Uncompress::Gunzip'=> '2.052',
            'IO::Uncompress::Inflate'=> '2.052',
            'IO::Uncompress::RawInflate'=> '2.052',
            'IO::Uncompress::Unzip' => '2.052',
            'IPC::Cmd'              => '0.78',
            'List::Util'            => '1.25',
            'List::Util::XS'        => '1.25',
            'Locale::Codes'         => '3.22',
            'Locale::Codes::Constants'=> '3.22',
            'Locale::Codes::Country'=> '3.22',
            'Locale::Codes::Country_Codes'=> '3.22',
            'Locale::Codes::Country_Retired'=> '3.22',
            'Locale::Codes::Currency'=> '3.22',
            'Locale::Codes::Currency_Codes'=> '3.22',
            'Locale::Codes::Currency_Retired'=> '3.22',
            'Locale::Codes::LangExt'=> '3.22',
            'Locale::Codes::LangExt_Codes'=> '3.22',
            'Locale::Codes::LangExt_Retired'=> '3.22',
            'Locale::Codes::LangFam'=> '3.22',
            'Locale::Codes::LangFam_Codes'=> '3.22',
            'Locale::Codes::LangFam_Retired'=> '3.22',
            'Locale::Codes::LangVar'=> '3.22',
            'Locale::Codes::LangVar_Codes'=> '3.22',
            'Locale::Codes::LangVar_Retired'=> '3.22',
            'Locale::Codes::Language'=> '3.22',
            'Locale::Codes::Language_Codes'=> '3.22',
            'Locale::Codes::Language_Retired'=> '3.22',
            'Locale::Codes::Script' => '3.22',
            'Locale::Codes::Script_Codes'=> '3.22',
            'Locale::Codes::Script_Retired'=> '3.22',
            'Locale::Country'       => '3.22',
            'Locale::Currency'      => '3.22',
            'Locale::Language'      => '3.22',
            'Locale::Script'        => '3.22',
            'Memoize'               => '1.03',
            'Memoize::AnyDBM_File'  => '1.03',
            'Memoize::Expire'       => '1.03',
            'Memoize::ExpireFile'   => '1.03',
            'Memoize::ExpireTest'   => '1.03',
            'Memoize::NDBM_File'    => '1.03',
            'Memoize::SDBM_File'    => '1.03',
            'Memoize::Storable'     => '1.03',
            'Module::Build'         => '0.40',
            'Module::Build::Base'   => '0.40',
            'Module::Build::Compat' => '0.40',
            'Module::Build::Config' => '0.40',
            'Module::Build::Cookbook'=> '0.40',
            'Module::Build::Dumper' => '0.40',
            'Module::Build::ModuleInfo'=> '0.40',
            'Module::Build::Notes'  => '0.40',
            'Module::Build::PPMMaker'=> '0.40',
            'Module::Build::Platform::Amiga'=> '0.40',
            'Module::Build::Platform::Default'=> '0.40',
            'Module::Build::Platform::EBCDIC'=> '0.40',
            'Module::Build::Platform::MPEiX'=> '0.40',
            'Module::Build::Platform::MacOS'=> '0.40',
            'Module::Build::Platform::RiscOS'=> '0.40',
            'Module::Build::Platform::Unix'=> '0.40',
            'Module::Build::Platform::VMS'=> '0.40',
            'Module::Build::Platform::VOS'=> '0.40',
            'Module::Build::Platform::Windows'=> '0.40',
            'Module::Build::Platform::aix'=> '0.40',
            'Module::Build::Platform::cygwin'=> '0.40',
            'Module::Build::Platform::darwin'=> '0.40',
            'Module::Build::Platform::os2'=> '0.40',
            'Module::Build::PodParser'=> '0.40',
            'Module::CoreList'      => '2.68',
            'Module::Load::Conditional'=> '0.50',
            'Object::Accessor'      => '0.44',
            'POSIX'                 => '1.31',
            'Params::Check'         => '0.36',
            'Parse::CPAN::Meta'     => '1.4404',
            'PerlIO::mmap'          => '0.011',
            'PerlIO::via::QuotedPrint'=> '0.07',
            'Pod::Html'             => '1.16',
            'Pod::Man'              => '2.26',
            'Pod::Text'             => '3.16',
            'Safe'                  => '2.33_01',
            'Scalar::Util'          => '1.25',
            'Search::Dict'          => '1.07',
            'Storable'              => '2.36',
            'TAP::Base'             => '3.25',
            'TAP::Formatter::Base'  => '3.25',
            'TAP::Formatter::Color' => '3.25',
            'TAP::Formatter::Console'=> '3.25',
            'TAP::Formatter::Console::ParallelSession'=> '3.25',
            'TAP::Formatter::Console::Session'=> '3.25',
            'TAP::Formatter::File'  => '3.25',
            'TAP::Formatter::File::Session'=> '3.25',
            'TAP::Formatter::Session'=> '3.25',
            'TAP::Harness'          => '3.25',
            'TAP::Object'           => '3.25',
            'TAP::Parser'           => '3.25',
            'TAP::Parser::Aggregator'=> '3.25',
            'TAP::Parser::Grammar'  => '3.25',
            'TAP::Parser::Iterator' => '3.25',
            'TAP::Parser::Iterator::Array'=> '3.25',
            'TAP::Parser::Iterator::Process'=> '3.25',
            'TAP::Parser::Iterator::Stream'=> '3.25',
            'TAP::Parser::IteratorFactory'=> '3.25',
            'TAP::Parser::Multiplexer'=> '3.25',
            'TAP::Parser::Result'   => '3.25',
            'TAP::Parser::Result::Bailout'=> '3.25',
            'TAP::Parser::Result::Comment'=> '3.25',
            'TAP::Parser::Result::Plan'=> '3.25',
            'TAP::Parser::Result::Pragma'=> '3.25',
            'TAP::Parser::Result::Test'=> '3.25',
            'TAP::Parser::Result::Unknown'=> '3.25',
            'TAP::Parser::Result::Version'=> '3.25',
            'TAP::Parser::Result::YAML'=> '3.25',
            'TAP::Parser::ResultFactory'=> '3.25',
            'TAP::Parser::Scheduler'=> '3.25',
            'TAP::Parser::Scheduler::Job'=> '3.25',
            'TAP::Parser::Scheduler::Spinner'=> '3.25',
            'TAP::Parser::Source'   => '3.25',
            'TAP::Parser::SourceHandler'=> '3.25',
            'TAP::Parser::SourceHandler::Executable'=> '3.25',
            'TAP::Parser::SourceHandler::File'=> '3.25',
            'TAP::Parser::SourceHandler::Handle'=> '3.25',
            'TAP::Parser::SourceHandler::Perl'=> '3.25',
            'TAP::Parser::SourceHandler::RawTAP'=> '3.25',
            'TAP::Parser::Utils'    => '3.25',
            'TAP::Parser::YAMLish::Reader'=> '3.25',
            'TAP::Parser::YAMLish::Writer'=> '3.25',
            'Term::ANSIColor'       => '3.02',
            'Test::Harness'         => '3.25',
            'Unicode'               => '6.2.0',
            'Unicode::UCD'          => '0.44',
            'XS::APItest'           => '0.40',
            '_charnames'            => '1.32',
            'attributes'            => '0.2',
            'autodie'               => '2.11',
            'autodie::exception'    => '2.11',
            'autodie::exception::system'=> '2.11',
            'autodie::hints'        => '2.11',
            'bigint'                => '0.30',
            'charnames'             => '1.32',
            'feature'               => '1.29',
            'inc::latest'           => '0.40',
            'perlfaq'               => '5.0150040',
            're'                    => '0.20',
        },
        removed => {
            'List::Util::PP'        => 1,
            'Scalar::Util::PP'      => 1,
        }
    },
    5.017002 => {
        delta_from => 5.017001,
        changed => {
            'App::Prove'            => '3.25_01',
            'App::Prove::State'     => '3.25_01',
            'App::Prove::State::Result'=> '3.25_01',
            'App::Prove::State::Result::Test'=> '3.25_01',
            'B::Concise'            => '0.91',
            'Compress::Raw::Bzip2'  => '2.05201',
            'Compress::Raw::Zlib'   => '2.05401',
            'Exporter'              => '5.67',
            'Exporter::Heavy'       => '5.67',
            'Fatal'                 => '2.12',
            'File::Fetch'           => '0.36',
            'File::stat'            => '1.07',
            'IO'                    => '1.25_08',
            'IO::Socket'            => '1.35',
            'Module::CoreList'      => '2.69',
            'PerlIO::scalar'        => '0.15',
            'Socket'                => '2.002',
            'Storable'              => '2.37',
            'TAP::Base'             => '3.25_01',
            'TAP::Formatter::Base'  => '3.25_01',
            'TAP::Formatter::Color' => '3.25_01',
            'TAP::Formatter::Console'=> '3.25_01',
            'TAP::Formatter::Console::ParallelSession'=> '3.25_01',
            'TAP::Formatter::Console::Session'=> '3.25_01',
            'TAP::Formatter::File'  => '3.25_01',
            'TAP::Formatter::File::Session'=> '3.25_01',
            'TAP::Formatter::Session'=> '3.25_01',
            'TAP::Harness'          => '3.25_01',
            'TAP::Object'           => '3.25_01',
            'TAP::Parser'           => '3.25_01',
            'TAP::Parser::Aggregator'=> '3.25_01',
            'TAP::Parser::Grammar'  => '3.25_01',
            'TAP::Parser::Iterator' => '3.25_01',
            'TAP::Parser::Iterator::Array'=> '3.25_01',
            'TAP::Parser::Iterator::Process'=> '3.25_01',
            'TAP::Parser::Iterator::Stream'=> '3.25_01',
            'TAP::Parser::IteratorFactory'=> '3.25_01',
            'TAP::Parser::Multiplexer'=> '3.25_01',
            'TAP::Parser::Result'   => '3.25_01',
            'TAP::Parser::Result::Bailout'=> '3.25_01',
            'TAP::Parser::Result::Comment'=> '3.25_01',
            'TAP::Parser::Result::Plan'=> '3.25_01',
            'TAP::Parser::Result::Pragma'=> '3.25_01',
            'TAP::Parser::Result::Test'=> '3.25_01',
            'TAP::Parser::Result::Unknown'=> '3.25_01',
            'TAP::Parser::Result::Version'=> '3.25_01',
            'TAP::Parser::Result::YAML'=> '3.25_01',
            'TAP::Parser::ResultFactory'=> '3.25_01',
            'TAP::Parser::Scheduler'=> '3.25_01',
            'TAP::Parser::Scheduler::Job'=> '3.25_01',
            'TAP::Parser::Scheduler::Spinner'=> '3.25_01',
            'TAP::Parser::Source'   => '3.25_01',
            'TAP::Parser::SourceHandler'=> '3.25_01',
            'TAP::Parser::SourceHandler::Executable'=> '3.25_01',
            'TAP::Parser::SourceHandler::File'=> '3.25_01',
            'TAP::Parser::SourceHandler::Handle'=> '3.25_01',
            'TAP::Parser::SourceHandler::Perl'=> '3.25_01',
            'TAP::Parser::SourceHandler::RawTAP'=> '3.25_01',
            'TAP::Parser::Utils'    => '3.25_01',
            'TAP::Parser::YAMLish::Reader'=> '3.25_01',
            'TAP::Parser::YAMLish::Writer'=> '3.25_01',
            'Test::Harness'         => '3.25_01',
            'Tie::StdHandle'        => '4.3',
            'XS::APItest'           => '0.41',
            'autodie'               => '2.12',
            'autodie::exception'    => '2.12',
            'autodie::exception::system'=> '2.12',
            'autodie::hints'        => '2.12',
            'diagnostics'           => '1.30',
            'overload'              => '1.20',
            're'                    => '0.21',
            'vars'                  => '1.03',
        },
        removed => {
        }
    },
    5.017003 => {
        delta_from => 5.017002,
        changed => {
            'B'                     => '1.37',
            'B::Concise'            => '0.92',
            'B::Debug'              => '1.18',
            'B::Deparse'            => '1.16',
            'CGI'                   => '3.60',
            'Compress::Raw::Bzip2'  => '2.055',
            'Compress::Raw::Zlib'   => '2.056',
            'Compress::Zlib'        => '2.055',
            'Data::Dumper'          => '2.135_07',
            'Devel::Peek'           => '1.09',
            'Encode'                => '2.47',
            'Encode::Alias'         => '2.16',
            'Encode::GSM0338'       => '2.02',
            'Encode::Unicode::UTF7' => '2.06',
            'IO::Compress::Adapter::Bzip2'=> '2.055',
            'IO::Compress::Adapter::Deflate'=> '2.055',
            'IO::Compress::Adapter::Identity'=> '2.055',
            'IO::Compress::Base'    => '2.055',
            'IO::Compress::Base::Common'=> '2.055',
            'IO::Compress::Bzip2'   => '2.055',
            'IO::Compress::Deflate' => '2.055',
            'IO::Compress::Gzip'    => '2.055',
            'IO::Compress::Gzip::Constants'=> '2.055',
            'IO::Compress::RawDeflate'=> '2.055',
            'IO::Compress::Zip'     => '2.055',
            'IO::Compress::Zip::Constants'=> '2.055',
            'IO::Compress::Zlib::Constants'=> '2.055',
            'IO::Compress::Zlib::Extra'=> '2.055',
            'IO::Uncompress::Adapter::Bunzip2'=> '2.055',
            'IO::Uncompress::Adapter::Identity'=> '2.055',
            'IO::Uncompress::Adapter::Inflate'=> '2.055',
            'IO::Uncompress::AnyInflate'=> '2.055',
            'IO::Uncompress::AnyUncompress'=> '2.055',
            'IO::Uncompress::Base'  => '2.055',
            'IO::Uncompress::Bunzip2'=> '2.055',
            'IO::Uncompress::Gunzip'=> '2.055',
            'IO::Uncompress::Inflate'=> '2.055',
            'IO::Uncompress::RawInflate'=> '2.055',
            'IO::Uncompress::Unzip' => '2.055',
            'Module::Build'         => '0.4003',
            'Module::Build::Base'   => '0.4003',
            'Module::Build::Compat' => '0.4003',
            'Module::Build::Config' => '0.4003',
            'Module::Build::Cookbook'=> '0.4003',
            'Module::Build::Dumper' => '0.4003',
            'Module::Build::ModuleInfo'=> '0.4003',
            'Module::Build::Notes'  => '0.4003',
            'Module::Build::PPMMaker'=> '0.4003',
            'Module::Build::Platform::Amiga'=> '0.4003',
            'Module::Build::Platform::Default'=> '0.4003',
            'Module::Build::Platform::EBCDIC'=> '0.4003',
            'Module::Build::Platform::MPEiX'=> '0.4003',
            'Module::Build::Platform::MacOS'=> '0.4003',
            'Module::Build::Platform::RiscOS'=> '0.4003',
            'Module::Build::Platform::Unix'=> '0.4003',
            'Module::Build::Platform::VMS'=> '0.4003',
            'Module::Build::Platform::VOS'=> '0.4003',
            'Module::Build::Platform::Windows'=> '0.4003',
            'Module::Build::Platform::aix'=> '0.4003',
            'Module::Build::Platform::cygwin'=> '0.4003',
            'Module::Build::Platform::darwin'=> '0.4003',
            'Module::Build::Platform::os2'=> '0.4003',
            'Module::Build::PodParser'=> '0.4003',
            'Module::CoreList'      => '2.71',
            'Module::CoreList::TieHashDelta'=> '2.71',
            'Module::Load::Conditional'=> '0.54',
            'Module::Metadata'      => '1.000011',
            'Module::Pluggable'     => '4.3',
            'Module::Pluggable::Object'=> '4.3',
            'Pod::Simple'           => '3.23',
            'Pod::Simple::BlackBox' => '3.23',
            'Pod::Simple::Checker'  => '3.23',
            'Pod::Simple::Debug'    => '3.23',
            'Pod::Simple::DumpAsText'=> '3.23',
            'Pod::Simple::DumpAsXML'=> '3.23',
            'Pod::Simple::HTML'     => '3.23',
            'Pod::Simple::HTMLBatch'=> '3.23',
            'Pod::Simple::LinkSection'=> '3.23',
            'Pod::Simple::Methody'  => '3.23',
            'Pod::Simple::Progress' => '3.23',
            'Pod::Simple::PullParser'=> '3.23',
            'Pod::Simple::PullParserEndToken'=> '3.23',
            'Pod::Simple::PullParserStartToken'=> '3.23',
            'Pod::Simple::PullParserTextToken'=> '3.23',
            'Pod::Simple::PullParserToken'=> '3.23',
            'Pod::Simple::RTF'      => '3.23',
            'Pod::Simple::Search'   => '3.23',
            'Pod::Simple::SimpleTree'=> '3.23',
            'Pod::Simple::Text'     => '3.23',
            'Pod::Simple::TextContent'=> '3.23',
            'Pod::Simple::TiedOutFH'=> '3.23',
            'Pod::Simple::Transcode'=> '3.23',
            'Pod::Simple::TranscodeDumb'=> '3.23',
            'Pod::Simple::TranscodeSmart'=> '3.23',
            'Pod::Simple::XHTML'    => '3.23',
            'Pod::Simple::XMLOutStream'=> '3.23',
            'Socket'                => '2.004',
            'Storable'              => '2.38',
            'Sys::Syslog'           => '0.31',
            'Term::ReadLine'        => '1.10',
            'Text::Tabs'            => '2012.0818',
            'Text::Wrap'            => '2012.0818',
            'Time::Local'           => '1.2300',
            'Unicode::UCD'          => '0.45',
            'Win32'                 => '0.45',
            'Win32CORE'             => '0.03',
            'XS::APItest'           => '0.42',
            'inc::latest'           => '0.4003',
            'perlfaq'               => '5.0150041',
            're'                    => '0.22',
        },
        removed => {
        }
    },
    5.017004 => {
        delta_from => 5.017003,
        changed => {
            'Archive::Tar'          => '1.90',
            'Archive::Tar::Constant'=> '1.90',
            'Archive::Tar::File'    => '1.90',
            'B'                     => '1.38',
            'B::Concise'            => '0.93',
            'B::Deparse'            => '1.17',
            'B::Xref'               => '1.04',
            'CPANPLUS'              => '0.9131',
            'CPANPLUS::Internals'   => '0.9131',
            'CPANPLUS::Shell::Default'=> '0.9131',
            'DB_File'               => '1.827',
            'Devel::Peek'           => '1.10',
            'DynaLoader'            => '1.16',
            'Errno'                 => '1.16',
            'ExtUtils::ParseXS'     => '3.18',
            'ExtUtils::ParseXS::Constants'=> '3.18',
            'ExtUtils::ParseXS::CountLines'=> '3.18',
            'ExtUtils::ParseXS::Utilities'=> '3.18',
            'File::Copy'            => '2.24',
            'File::Find'            => '1.22',
            'IPC::Open3'            => '1.13',
            'Locale::Codes'         => '3.23',
            'Locale::Codes::Constants'=> '3.23',
            'Locale::Codes::Country'=> '3.23',
            'Locale::Codes::Country_Codes'=> '3.23',
            'Locale::Codes::Country_Retired'=> '3.23',
            'Locale::Codes::Currency'=> '3.23',
            'Locale::Codes::Currency_Codes'=> '3.23',
            'Locale::Codes::Currency_Retired'=> '3.23',
            'Locale::Codes::LangExt'=> '3.23',
            'Locale::Codes::LangExt_Codes'=> '3.23',
            'Locale::Codes::LangExt_Retired'=> '3.23',
            'Locale::Codes::LangFam'=> '3.23',
            'Locale::Codes::LangFam_Codes'=> '3.23',
            'Locale::Codes::LangFam_Retired'=> '3.23',
            'Locale::Codes::LangVar'=> '3.23',
            'Locale::Codes::LangVar_Codes'=> '3.23',
            'Locale::Codes::LangVar_Retired'=> '3.23',
            'Locale::Codes::Language'=> '3.23',
            'Locale::Codes::Language_Codes'=> '3.23',
            'Locale::Codes::Language_Retired'=> '3.23',
            'Locale::Codes::Script' => '3.23',
            'Locale::Codes::Script_Codes'=> '3.23',
            'Locale::Codes::Script_Retired'=> '3.23',
            'Locale::Country'       => '3.23',
            'Locale::Currency'      => '3.23',
            'Locale::Language'      => '3.23',
            'Locale::Script'        => '3.23',
            'Math::BigFloat::Trace' => '0.30',
            'Math::BigInt::Trace'   => '0.30',
            'Module::CoreList'      => '2.73',
            'Module::CoreList::TieHashDelta'=> '2.73',
            'Opcode'                => '1.24',
            'Socket'                => '2.006',
            'Storable'              => '2.39',
            'Sys::Syslog'           => '0.32',
            'Unicode::UCD'          => '0.46',
            'XS::APItest'           => '0.43',
            'bignum'                => '0.30',
            'bigrat'                => '0.30',
            'constant'              => '1.24',
            'feature'               => '1.30',
            'threads::shared'       => '1.41',
            'version'               => '0.9901',
            'warnings'              => '1.14',
        },
        removed => {
        }
    },
    5.017005 => {
        delta_from => 5.017004,
        changed => {
            'AutoLoader'            => '5.73',
            'B'                     => '1.39',
            'B::Deparse'            => '1.18',
            'CPANPLUS'              => '0.9133',
            'CPANPLUS::Internals'   => '0.9133',
            'CPANPLUS::Shell::Default'=> '0.9133',
            'Carp'                  => '1.27',
            'Carp::Heavy'           => '1.27',
            'Data::Dumper'          => '2.136',
            'Digest::SHA'           => '5.72',
            'ExtUtils::CBuilder'    => '0.280209',
            'ExtUtils::CBuilder::Base'=> '0.280209',
            'ExtUtils::CBuilder::Platform::Unix'=> '0.280209',
            'ExtUtils::CBuilder::Platform::VMS'=> '0.280209',
            'ExtUtils::CBuilder::Platform::Windows'=> '0.280209',
            'ExtUtils::CBuilder::Platform::Windows::BCC'=> '0.280209',
            'ExtUtils::CBuilder::Platform::Windows::GCC'=> '0.280209',
            'ExtUtils::CBuilder::Platform::Windows::MSVC'=> '0.280209',
            'ExtUtils::CBuilder::Platform::aix'=> '0.280209',
            'ExtUtils::CBuilder::Platform::cygwin'=> '0.280209',
            'ExtUtils::CBuilder::Platform::darwin'=> '0.280209',
            'ExtUtils::CBuilder::Platform::dec_osf'=> '0.280209',
            'ExtUtils::CBuilder::Platform::os2'=> '0.280209',
            'File::Copy'            => '2.25',
            'File::Glob'            => '1.18',
            'HTTP::Tiny'            => '0.024',
            'Module::CoreList'      => '2.75',
            'Module::CoreList::TieHashDelta'=> '2.75',
            'PerlIO::encoding'      => '0.16',
            'Unicode::Collate'      => '0.90',
            'Unicode::Collate::Locale'=> '0.90',
            'Unicode::Normalize'    => '1.15',
            'Win32CORE'             => '0.04',
            'XS::APItest'           => '0.44',
            'attributes'            => '0.21',
            'bigint'                => '0.31',
            'bignum'                => '0.31',
            'bigrat'                => '0.31',
            'feature'               => '1.31',
            'threads::shared'       => '1.42',
            'warnings'              => '1.15',
        },
        removed => {
        }
    },
    5.017006 => {
        delta_from => 5.017005,
        changed => {
            'B'                     => '1.40',
            'B::Concise'            => '0.94',
            'B::Deparse'            => '1.19',
            'B::Xref'               => '1.05',
            'CGI'                   => '3.63',
            'CGI::Util'             => '3.62',
            'CPAN'                  => '1.99_51',
            'CPANPLUS::Dist::Build' => '0.64',
            'CPANPLUS::Dist::Build::Constants'=> '0.64',
            'Carp'                  => '1.28',
            'Carp::Heavy'           => '1.28',
            'Compress::Raw::Bzip2'  => '2.058',
            'Compress::Raw::Zlib'   => '2.058',
            'Compress::Zlib'        => '2.058',
            'Data::Dumper'          => '2.137',
            'Digest::