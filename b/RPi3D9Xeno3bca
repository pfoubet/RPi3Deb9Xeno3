 _is_id = False

    _child_node_types = (Node.TEXT_NODE, Node.ENTITY_REFERENCE_NODE)

    def __init__(self, qName, namespaceURI=EMPTY_NAMESPACE, localName=None,
                 prefix=None):
        self.ownerElement = None
        self._name = qName
        self.namespaceURI = namespaceURI
        self._prefix = prefix
        self.childNodes = NodeList()

        # Add the single child node that represents the value of the attr
        self.childNodes.append(Text())

        # nodeValue and value are set elsewhere

    def _get_localName(self):
        try:
            return self._localName
        except AttributeError:
            return self.nodeName.split(":", 1)[-1]

    def _get_specified(self):
        return self.specified

    def _get_name(self):
        return self._name

    def _set_name(self, value):
        self._name = value
        if self.ownerElement is not None:
            _clear_id_cache(self.ownerElement)

    nodeName = name = property(_get_name, _set_name)

    def _get_value(self):
        return self._value

    def _set_value(self, value):
        self._value = value
        self.childNodes[0].data = value
        if self.ownerElement is not None:
            _clear_id_cache(self.ownerElement)
        self.childNodes[0].data = value

    nodeValue = value = property(_get_value, _set_value)

    def _get_prefix(self):
        return self._prefix

    def _set_prefix(self, prefix):
        nsuri = self.namespaceURI
        if prefix == "xmlns":
            if nsuri and nsuri != XMLNS_NAMESPACE:
                raise xml.dom.NamespaceErr(
                    "illegal use of 'xmlns' prefix for the wrong namespace")
        self._prefix = prefix
        if prefix is None:
            newName = self.localName
        else:
            newName = "%s:%s" % (prefix, self.localName)
        if self.ownerElement:
            _clear_id_cache(self.ownerElement)
        self.name = newName

    prefix = property(_get_prefix, _set_prefix)

    def unlink(self):
        # This implementation does not call the base implementation
        # since most of that is not needed, and the expense of the
        # method call is not warranted.  We duplicate the removal of
        # children, but that's all we needed from the base class.
        elem = self.ownerElement
        if elem is not None:
            del elem._attrs[self.nodeName]
            del elem._attrsNS[(self.namespaceURI, self.localName)]
            if self._is_id:
                self._is_id = False
                elem._magic_id_nodes -= 1
                self.ownerDocument._magic_id_count -= 1
        for child in self.childNodes:
            child.unlink()
        del self.childNodes[:]

    def _get_isId(self):
        if self._is_id:
            return True
        doc = self.ownerDocument
        elem = self.ownerElement
        if doc is None or elem is None:
            return False

        info = doc._get_elem_info(elem)
        if info is None:
            return False
        if self.namespaceURI:
            return info.isIdNS(self.namespaceURI, self.localName)
        else:
            return info.isId(self.nodeName)

    def _get_schemaType(self):
        doc = self.ownerDocument
        elem = self.ownerElement
        if doc is None or elem is None:
            return _no_type

        info = doc._get_elem_info(elem)
        if info is None:
            return _no_type
        if self.namespaceURI:
            return info.getAttributeTypeNS(self.namespaceURI, self.localName)
        else:
            return info.getAttributeType(self.nodeName)

defproperty(Attr, "isId",       doc="True if this attribute is an ID.")
defproperty(Attr, "localName",  doc="Namespace-local name of this attribute.")
defproperty(Attr, "schemaType", doc="Schema type for this attribute.")


class NamedNodeMap(object):
    """The attribute list is a transient interface to the underlying
    dictionaries.  Mutations here will change the underlying element's
    dictionary.

    Ordering is imposed artificially and does not reflect the order of
    attributes as found in an input document.
    """

    __slots__ = ('_attrs', '_attrsNS', '_ownerElement')

    def __init__(self, attrs, attrsNS, ownerElement):
        self._attrs = attrs
        self._attrsNS = attrsNS
        self._ownerElement = ownerElement

    def _get_length(self):
        return len(self._attrs)

    def item(self, index):
        try:
            return self[list(self._attrs.keys())[index]]
        except IndexError:
            return None

    def items(self):
        L = []
        for node in self._attrs.values():
            L.append((node.nodeName, node.value))
        return L

    def itemsNS(self):
        L = []
        for node in self._attrs.values():
            L.append(((node.namespaceURI, node.localName), node.value))
        return L

    def __contains__(self, key):
        if isinstance(key, str):
            return key in self._attrs
        else:
            return key in self._attrsNS

    def keys(self):
        return self._attrs.keys()

    def keysNS(self):
        return self._attrsNS.keys()

    def values(self):
        return self._attrs.values()

    def get(self, name, value=None):
        return self._attrs.get(name, value)

    __len__ = _get_length

    def _cmp(self, other):
        if self._attrs is getattr(other, "_attrs", None):
            return 0
        else:
            return (id(self) > id(other)) - (id(self) < id(other))

    def __eq__(self, other):
        return self._cmp(other) == 0

    def __ge__(self, other):
        return self._cmp(other) >= 0

    def __gt__(self, other):
        return self._cmp(other) > 0

    def __le__(self, other):
        return self._cmp(other) <= 0

    def __lt__(self, other):
        return self._cmp(other) < 0

    def __getitem__(self, attname_or_tuple):
        if isinstance(attname_or_tuple, tuple):
            return self._attrsNS[attname_or_tuple]
        else:
            return self._attrs[attname_or_tuple]

    # same as set
    def __setitem__(self, attname, value):
        if isinstance(value, str):
            try:
                node = self._attrs[attname]
            except KeyError:
                node = Attr(attname)
                node.ownerDocument = self._ownerElement.ownerDocument
                self.setNamedItem(node)
            node.value = value
        else:
            if not isinstance(value, Attr):
                raise TypeError("value must be a string or Attr object")
            node = value
            self.setNamedItem(node)

    def getNamedItem(self, name):
        try:
            return self._attrs[name]
        except KeyError:
            return None

    def getNamedItemNS(self, namespaceURI, localName):
        try:
            return self._attrsNS[(namespaceURI, localName)]
        except KeyError:
            return None

    def removeNamedItem(self, name):
        n = self.getNamedItem(name)
        if n is not None:
            _clear_id_cache(self._ownerElement)
            del self._attrs[n.nodeName]
            del self._attrsNS[(n.namespaceURI, n.localName)]
            if hasattr(n, 'ownerElement'):
                n.ownerElement = None
            return n
        else:
            raise xml.dom.NotFoundErr()

    def removeNamedItemNS(self, namespaceURI, localName):
        n = self.getNamedItemNS(namespaceURI, localName)
        if n is not None:
            _clear_id_cache(self._ownerElement)
            del self._attrsNS[(n.namespaceURI, n.localName)]
            del self._attrs[n.nodeName]
            if hasattr(n, 'ownerElement'):
                n.ownerElement = None
            return n
        else:
            raise xml.dom.NotFoundErr()

    def setNamedItem(self, node):
        if not isinstance(node, Attr):
            raise xml.dom.HierarchyRequestErr(
                "%s cannot be child of %s" % (repr(node), repr(self)))
        old = self._attrs.get(node.name)
        if old:
            old.unlink()
        self._attrs[node.name] = node
        self._attrsNS[(node.namespaceURI, node.localName)] = node
        node.ownerElement = self._ownerElement
        _clear_id_cache(node.ownerElement)
        return old

    def setNamedItemNS(self, node):
        return self.setNamedItem(node)

    def __delitem__(self, attname_or_tuple):
        node = self[attname_or_tuple]
        _clear_id_cache(node.ownerElement)
        node.unlink()

    def __getstate__(self):
        return self._attrs, self._attrsNS, self._ownerElement

    def __setstate__(self, state):
        self._attrs, self._attrsNS, self._ownerElement = state

defproperty(NamedNodeMap, "length",
            doc="Number of nodes in the NamedNodeMap.")

AttributeList = NamedNodeMap


class TypeInfo(object):
    __slots__ = 'namespace', 'name'

    def __init__(self, namespace, name):
        self.namespace = namespace
        self.name = name

    def __repr__(self):
        if self.namespace:
            return "<%s %r (from %r)>" % (self.__class__.__name__, self.name,
                                          self.namespace)
        else:
            return "<%s %r>" % (self.__class__.__name__, self.name)

    def _get_name(self):
        return self.name

    def _get_namespace(self):
        return self.namespace

_no_type = TypeInfo(None, None)

class Element(Node):
    __slots__=('ownerDocument', 'parentNode', 'tagName', 'nodeName', 'prefix',
               'namespaceURI', '_localName', 'childNodes', '_attrs', '_attrsNS',
               'nextSibling', 'previousSibling')
    nodeType = Node.ELEMENT_NODE
    nodeValue = None
    schemaType = _no_type

    _magic_id_nodes = 0

    _child_node_types = (Node.ELEMENT_NODE,
                         Node.PROCESSING_INSTRUCTION_NODE,
                         Node.COMMENT_NODE,
                         Node.TEXT_NODE,
                         Node.CDATA_SECTION_NODE,
                         Node.ENTITY_REFERENCE_NODE)

    def __init__(self, tagName, namespaceURI=EMPTY_NAMESPACE, prefix=None,
                 localName=None):
        self.parentNode = None
        self.tagName = self.nodeName = tagName
        self.prefix = prefix
        self.namespaceURI = namespaceURI
        self.childNodes = NodeList()
        self.nextSibling = self.previousSibling = None

        # Attribute dictionaries are lazily created
        # attributes are double-indexed:
        #    tagName -> Attribute
        #    URI,localName -> Attribute
        # in the future: consider lazy generation
        # of attribute objects this is too tricky
        # for now because of headaches with
        # namespaces.
        self._attrs = None
        self._attrsNS = None

    def _ensure_attributes(self):
        if self._attrs is None:
            self._attrs = {}
            self._attrsNS = {}

    def _get_localName(self):
        try:
            return self._localName
        except AttributeError:
            return self.tagName.split(":", 1)[-1]

    def _get_tagName(self):
        return self.tagName

    def unlink(self):
        if self._attrs is not None:
            for attr in list(self._attrs.values()):
                attr.unlink()
        self._attrs = None
        self._attrsNS = None
        Node.unlink(self)

    def getAttribute(self, attname):
        if self._attrs is None:
            return ""
        try:
            return self._attrs[attname].value
        except KeyError:
            return ""

    def getAttributeNS(self, namespaceURI, localName):
        if self._attrsNS is None:
            return ""
        try:
            return self._attrsNS[(namespaceURI, localName)].value
        except KeyError:
            return ""

    def setAttribute(self, attname, value):
        attr = self.getAttributeNode(attname)
        if attr is None:
            attr = Attr(attname)
            attr.value = value # also sets nodeValue
            attr.ownerDocument = self.ownerDocument
            self.setAttributeNode(attr)
        elif value != attr.value:
            attr.value = value
            if attr.isId:
                _clear_id_cache(self)

    def setAttributeNS(self, namespaceURI, qualifiedName, value):
        prefix, localname = _nssplit(qualifiedName)
        attr = self.getAttributeNodeNS(namespaceURI, localname)
        if attr is None:
            attr = Attr(qualifiedName, namespaceURI, localname, prefix)
            attr.value = value
            attr.ownerDocument = self.ownerDocument
            self.setAttributeNode(attr)
        else:
            if value != attr.value:
                attr.value = value
                if attr.isId:
                    _clear_id_cache(self)
            if attr.prefix != prefix:
                attr.prefix = prefix
                attr.nodeName = qualifiedName

    def getAttributeNode(self, attrname):
        if self._attrs is None:
            return None
        return self._attrs.get(attrname)

    def getAttributeNodeNS(self, namespaceURI, localName):
        if self._attrsNS is None:
            return None
        return self._attrsNS.get((namespaceURI, localName))

    def setAttributeNode(self, attr):
        if attr.ownerElement not in (None, self):
            raise xml.dom.InuseAttributeErr("attribute node already owned")
        self._ensure_attributes()
        old1 = self._attrs.get(attr.name, None)
        if old1 is not None:
            self.removeAttributeNode(old1)
        old2 = self._attrsNS.get((attr.namespaceURI, attr.localName), None)
        if old2 is not None and old2 is not old1:
            self.removeAttributeNode(old2)
        _set_attribute_node(self, attr)

        if old1 is not attr:
            # It might have already been part of this node, in which case
            # it doesn't represent a change, and should not be returned.
            return old1
        if old2 is not attr:
            return old2

    setAttributeNodeNS = setAttributeNode

    def removeAttribute(self, name):
        if self._attrsNS is None:
            raise xml.dom.NotFoundErr()
        try:
            attr = self._attrs[name]
        except KeyError:
            raise xml.dom.NotFoundErr()
        self.removeAttributeNode(attr)

    def removeAttributeNS(self, namespaceURI, localName):
        if self._attrsNS is None:
            raise xml.dom.NotFoundErr()
        try:
            attr = self._attrsNS[(namespaceURI, localName)]
        except KeyError:
            raise xml.dom.NotFoundErr()
        self.removeAttributeNode(attr)

    def removeAttributeNode(self, node):
        if node is None:
            raise xml.dom.NotFoundErr()
        try:
            self._attrs[node.name]
        except KeyError:
            raise xml.dom.NotFoundErr()
        _clear_id_cache(self)
        node.unlink()
        # Restore this since the node is still useful and otherwise
        # unlinked
        node.ownerDocument = self.ownerDocument

    removeAttributeNodeNS = removeAttributeNode

    def hasAttribute(self, name):
        if self._attrs is None:
            return False
        return name in self._attrs

    def hasAttributeNS(self, namespaceURI, localName):
        if self._attrsNS is None:
            return False
        return (namespaceURI, localName) in self._attrsNS

    def getElementsByTagName(self, name):
        return _get_elements_by_tagName_helper(self, name, NodeList())

    def getElementsByTagNameNS(self, namespaceURI, localName):
        return _get_elements_by_tagName_ns_helper(
            self, namespaceURI, localName, NodeList())

    def __repr__(self):
        return "<DOM Element: %s at %#x>" % (self.tagName, id(self))

    def writexml(self, writer, indent="", addindent="", newl=""):
        # indent = current indentation
        # addindent = indentation to add to higher levels
        # newl = newline string
        writer.write(indent+"<" + self.tagName)

        attrs = self._get_attributes()
        a_names = sorted(attrs.keys())

        for a_name in a_names:
            writer.write(" %s=\"" % a_name)
            _write_data(writer, attrs[a_name].value)
            writer.write("\"")
        if self.childNodes:
            writer.write(">")
            if (len(self.childNodes) == 1 and
                self.childNodes[0].nodeType == Node.TEXT_NODE):
                self.childNodes[0].writexml(writer, '', '', '')
            else:
                writer.write(newl)
                for node in self.childNodes:
                    node.writexml(writer, indent+addindent, addindent, newl)
                writer.write(indent)
            writer.write("</%s>%s" % (self.tagName, newl))
        else:
            writer.write("/>%s"%(newl))

    def _get_attributes(self):
        self._ensure_attributes()
        return NamedNodeMap(self._attrs, self._attrsNS, self)

    def hasAttributes(self):
        if self._attrs:
            return True
        else:
            return False

    # DOM Level 3 attributes, based on the 22 Oct 2002 draft

    def setIdAttribute(self, name):
        idAttr = self.getAttributeNode(name)
        self.setIdAttributeNode(idAttr)

    def setIdAttributeNS(self, namespaceURI, localName):
        idAttr = self.getAttributeNodeNS(namespaceURI, localName)
        self.setIdAttributeNode(idAttr)

    def setIdAttributeNode(self, idAttr):
        if idAttr is None or not self.isSameNode(idAttr.ownerElement):
            raise xml.dom.NotFoundErr()
        if _get_containing_entref(self) is not None:
            raise xml.dom.NoModificationAllowedErr()
        if not idAttr._is_id:
            idAttr._is_id = True
            self._magic_id_nodes += 1
            self.ownerDocument._magic_id_count += 1
            _clear_id_cache(self)

defproperty(Element, "attributes",
            doc="NamedNodeMap of attributes on the element.")
defproperty(Element, "localName",
            doc="Namespace-local name of this element.")


def _set_attribute_node(element, attr):
    _clear_id_cache(element)
    element._ensure_attributes()
    element._attrs[attr.name] = attr
    element._attrsNS[(attr.namespaceURI, attr.localName)] = attr

    # This creates a circular reference, but Element.unlink()
    # breaks the cycle since the references to the attribute
    # dictionaries are tossed.
    attr.ownerElement = element

class Childless:
    """Mixin that makes childless-ness easy to implement and avoids
    the complexity of the Node methods that deal with children.
    """
    __slots__ = ()

    attributes = None
    childNodes = EmptyNodeList()
    firstChild = None
    lastChild = None

    def _get_firstChild(self):
        return None

    def _get_lastChild(self):
        return None

    def appendChild(self, node):
        raise xml.dom.HierarchyRequestErr(
            self.nodeName + " nodes cannot have children")

    def hasChildNodes(self):
        return False

    def insertBefore(self, newChild, refChild):
        raise xml.dom.HierarchyRequestErr(
            self.nodeName + " nodes do not have children")

    def removeChild(self, oldChild):
        raise xml.dom.NotFoundErr(
            self.nodeName + " nodes do not have children")

    def normalize(self):
        # For childless nodes, normalize() has nothing to do.
        pass

    def replaceChild(self, newChild, oldChild):
        raise xml.dom.HierarchyRequestErr(
            self.nodeName + " nodes do not have children")


class ProcessingInstruction(Childless, Node):
    nodeType = Node.PROCESSING_INSTRUCTION_NODE
    __slots__ = ('target', 'data')

    def __init__(self, target, data):
        self.target = target
        self.data = data

    # nodeValue is an alias for data
    def _get_nodeValue(self):
        return self.data
    def _set_nodeValue(self, value):
        self.data = value
    nodeValue = property(_get_nodeValue, _set_nodeValue)

    # nodeName is an alias for target
    def _get_nodeName(self):
        return self.target
    def _set_nodeName(self, value):
        self.target = value
    nodeName = property(_get_nodeName, _set_nodeName)

    def writexml(self, writer, indent="", addindent="", newl=""):
        writer.write("%s<?%s %s?>%s" % (indent,self.target, self.data, newl))


class CharacterData(Childless, Node):
    __slots__=('_data', 'ownerDocument','parentNode', 'previousSibling', 'nextSibling')

    def __init__(self):
        self.ownerDocument = self.parentNode = None
        self.previousSibling = self.nextSibling = None
        self._data = ''
        Node.__init__(self)

    def _get_length(self):
        return len(self.data)
    __len__ = _get_length

    def _get_data(self):
        return self._data
    def _set_data(self, data):
        self._data = data

    data = nodeValue = property(_get_data, _set_data)

    def __repr__(self):
        data = self.data
        if len(data) > 10:
            dotdotdot = "..."
        else:
            dotdotdot = ""
        return '<DOM %s node "%r%s">' % (
            self.__class__.__name__, data[0:10], dotdotdot)

    def substringData(self, offset, count):
        if offset < 0:
            raise xml.dom.IndexSizeErr("offset cannot be negative")
        if offset >= len(self.data):
            raise xml.dom.IndexSizeErr("offset cannot be beyond end of data")
        if count < 0:
            raise xml.dom.IndexSizeErr("count cannot be negative")
        return self.data[offset:offset+count]

    def appendData(self, arg):
        self.data = self.data + arg

    def insertData(self, offset, arg):
        if offset < 0:
            raise xml.dom.IndexSizeErr("offset cannot be negative")
        if offset >= len(self.data):
            raise xml.dom.IndexSizeErr("offset cannot be beyond end of data")
        if arg:
            self.data = "%s%s%s" % (
                self.data[:offset], arg, self.data[offset:])

    def deleteData(self, offset, count):
        if offset < 0:
            raise xml.dom.IndexSizeErr("offset cannot be negative")
        if offset >= len(self.data):
            raise xml.dom.IndexSizeErr("offset cannot be beyond end of data")
        if count < 0:
            raise xml.dom.IndexSizeErr("count cannot be negative")
        if count:
            self.data = self.data[:offset] + self.data[offset+count:]

    def replaceData(self, offset, count, arg):
        if offset < 0:
            raise xml.dom.IndexSizeErr("offset cannot be negative")
        if offset >= len(self.data):
            raise xml.dom.IndexSizeErr("offset cannot be beyond end of data")
        if count < 0:
            raise xml.dom.IndexSizeErr("count cannot be negative")
        if count:
            self.data = "%s%s%s" % (
                self.data[:offset], arg, self.data[offset+count:])

defproperty(CharacterData, "length", doc="Length of the string data.")


class Text(CharacterData):
    __slots__ = ()

    nodeType = Node.TEXT_NODE
    nodeName = "#text"
    attributes = None

    def splitText(self, offset):
        if offset < 0 or offset > len(self.data):
            raise xml.dom.IndexSizeErr("illegal offset value")
        newText = self.__class__()
        newText.data = self.data[offset:]
        newText.ownerDocument = self.ownerDocument
        next = self.nextSibling
        if self.parentNode and self in self.parentNode.childNodes:
            if next is None:
                self.parentNode.appendChild(newText)
            else:
                self.parentNode.insertBefore(newText, next)
        self.data = self.data[:offset]
        return newText

    def writexml(self, writer, indent="", addindent="", newl=""):
        _write_data(writer, "%s%s%s" % (indent, self.data, newl))

    # DOM Level 3 (WD 9 April 2002)

    def _get_wholeText(self):
        L = [self.data]
        n = self.previousSibling
        while n is not None:
            if n.nodeType in (Node.TEXT_NODE, Node.CDATA_SECTION_NODE):
                L.insert(0, n.data)
                n = n.previousSibling
            else:
                break
        n = self.nextSibling
        while n is not None:
            if n.nodeType in (Node.TEXT_NODE, Node.CDATA_SECTION_NODE):
                L.append(n.data)
                n = n.nextSibling
            else:
                break
        return ''.join(L)

    def replaceWholeText(self, content):
        # XXX This needs to be seriously changed if minidom ever
        # supports EntityReference nodes.
        parent = self.parentNode
        n = self.previousSibling
        while n is not None:
            if n.nodeType in (Node.TEXT_NODE, Node.CDATA_SECTION_NODE):
                next = n.previousSibling
                parent.removeChild(n)
                n = next
            else:
                break
        n = self.nextSibling
        if not content:
            parent.removeChild(self)
        while n is not None:
            if n.nodeType in (Node.TEXT_NODE, Node.CDATA_SECTION_NODE):
                next = n.nextSibling
                parent.removeChild(n)
                n = next
            else:
                break
        if content:
            self.data = content
            return self
        else:
            return None

    def _get_isWhitespaceInElementContent(self):
        if self.data.strip():
            return False
        elem = _get_containing_element(self)
        if elem is None:
            return False
        info = self.ownerDocument._get_elem_info(elem)
        if info is None:
            return False
        else:
            return info.isElementContent()

defproperty(Text, "isWhitespaceInElementContent",
            doc="True iff this text node contains only whitespace"
                " and is in element content.")
defproperty(Text, "wholeText",
            doc="The text of all logically-adjacent text nodes.")


def _get_containing_element(node):
    c = node.parentNode
    while c is not None:
        if c.nodeType == Node.ELEMENT_NODE:
            return c
        c = c.parentNode
    return None

def _get_containing_entref(node):
    c = node.parentNode
    while c is not None:
        if c.nodeType == Node.ENTITY_REFERENCE_NODE:
            return c
        c = c.parentNode
    return None


class Comment(CharacterData):
    nodeType = Node.COMMENT_NODE
    nodeName = "#comment"

    def __init__(self, data):
        CharacterData.__init__(self)
        self._data = data

    def writexml(self, writer, indent="", addindent="", newl=""):
        if "--" in self.data:
            raise ValueError("'--' is not allowed in a comment node")
        writer.write("%s<!--%s-->%s" % (indent, self.data, newl))


class CDATASection(Text):
    __slots__ = ()

    nodeType = Node.CDATA_SECTION_NODE
    nodeName = "#cdata-section"

    def writexml(self, writer, indent="", addindent="", newl=""):
        if self.data.find("]]>") >= 0:
            raise ValueError("']]>' not allowed in a CDATA section")
        writer.write("<![CDATA[%s]]>" % self.data)


class ReadOnlySequentialNamedNodeMap(object):
    __slots__ = '_seq',

    def __init__(self, seq=()):
        # seq should be a list or tuple
        self._seq = seq

    def __len__(self):
        return len(self._seq)

    def _get_length(self):
        return len(self._seq)

    def getNamedItem(self, name):
        for n in self._seq:
            if n.nodeName == name:
                return n

    def getNamedItemNS(self, namespaceURI, localName):
        for n in self._seq:
            if n.namespaceURI == namespaceURI and n.localName == localName:
                return n

    def __getitem__(self, name_or_tuple):
        if isinstance(name_or_tuple, tuple):
            node = self.getNamedItemNS(*name_or_tuple)
        else:
            node = self.getNamedItem(name_or_tuple)
        if node is None:
            raise KeyError(name_or_tuple)
        return node

    def item(self, index):
        if index < 0:
            return None
        try:
            return self._seq[index]
        except IndexError:
            return None

    def removeNamedItem(self, name):
        raise xml.dom.NoModificationAllowedErr(
            "NamedNodeMap instance is read-only")

    def removeNamedItemNS(self, namespaceURI, localName):
        raise xml.dom.NoModificationAllowedErr(
            "NamedNodeMap instance is read-only")

    def setNamedItem(self, node):
        raise xml.dom.NoModificationAllowedErr(
            "NamedNodeMap instance is read-only")

    def setNamedItemNS(self, node):
        raise xml.dom.NoModificationAllowedErr(
            "NamedNodeMap instance is read-only")

    def __getstate__(self):
        return [self._seq]

    def __setstate__(self, state):
        self._seq = state[0]

defproperty(ReadOnlySequentialNamedNodeMap, "length",
            doc="Number of entries in the NamedNodeMap.")


class Identified:
    """Mix-in class that supports the publicId and systemId attributes."""

    __slots__ = 'publicId', 'systemId'

    def _identified_mixin_init(self, publicId, systemId):
        self.publicId = publicId
        self.systemId = systemId

    def _get_publicId(self):
        return self.publicId

    def _get_systemId(self):
        return self.systemId

class DocumentType(Identified, Childless, Node):
    nodeType = Node.DOCUMENT_TYPE_NODE
    nodeValue = None
    name = None
    publicId = None
    systemId = None
    internalSubset = None

    def __init__(self, qualifiedName):
        self.entities = ReadOnlySequentialNamedNodeMap()
        self.notations = ReadOnlySequentialNamedNodeMap()
        if qualifiedName:
            prefix, localname = _nssplit(qualifiedName)
            self.name = localname
        self.nodeName = self.name

    def _get_internalSubset(self):
        return self.internalSubset

    def cloneNode(self, deep):
        if self.ownerDocument is None:
            # it's ok
            clone = DocumentType(None)
            clone.name = self.name
            clone.nodeName = self.name
            operation = xml.dom.UserDataHandler.NODE_CLONED
            if deep:
                clone.entities._seq = []
                clone.notations._seq = []
                for n in self.notations._seq:
                    notation = Notation(n.nodeName, n.publicId, n.systemId)
                    clone.notations._seq.append(notation)
                    n._call_user_data_handler(operation, n, notation)
                for e in self.entities._seq:
                    entity = Entity(e.nodeName, e.publicId, e.systemId,
                                    e.notationName)
                    entity.actualEncoding = e.actualEncoding
                    entity.encoding = e.encoding
                    entity.version = e.version
                    clone.entities._seq.append(entity)
                    e._call_user_data_handler(operation, n, entity)
            self._call_user_data_handler(operation, self, clone)
            return clone
        else:
            return None

    def writexml(self, writer, indent="", addindent="", newl=""):
        writer.write("<!DOCTYPE ")
        writer.write(self.name)
        if self.publicId:
            writer.write("%s  PUBLIC '%s'%s  '%s'"
                         % (newl, self.publicId, newl, self.systemId))
        elif self.systemId:
            writer.write("%s  SYSTEM '%s'" % (newl, self.systemId))
        if self.internalSubset is not None:
            writer.write(" [")
            writer.write(self.internalSubset)
            writer.write("]")
        writer.write(">"+newl)

class Entity(Identified, Node):
    attributes = None
    nodeType = Node.ENTITY_NODE
    nodeValue = None

    actualEncoding = None
    encoding = None
    version = None

    def __init__(self, name, publicId, systemId, notation):
        self.nodeName = name
        self.notationName = notation
        self.childNodes = NodeList()
        self._identified_mixin_init(publicId, systemId)

    def _get_actualEncoding(self):
        return self.actualEncoding

    def _get_encoding(self):
        return self.encoding

    def _get_version(self):
        return self.version

    def appendChild(self, newChild):
        raise xml.dom.HierarchyRequestErr(
            "cannot append children to an entity node")

    def insertBefore(self, newChild, refChild):
        raise xml.dom.HierarchyRequestErr(
            "cannot insert children below an entity node")

    def removeChild(self, oldChild):
        raise xml.dom.HierarchyRequestErr(
            "cannot remove children from an entity node")

    def replaceChild(self, newChild, oldChild):
        raise xml.dom.HierarchyRequestErr(
            "cannot replace children of an entity node")

class Notation(Identified, Childless, Node):
    nodeType = Node.NOTATION_NODE
    nodeValue = None

    def __init__(self, name, publicId, systemId):
        self.nodeName = name
        self._identified_mixin_init(publicId, systemId)


class DOMImplementation(DOMImplementationLS):
    _features = [("core", "1.0"),
                 ("core", "2.0"),
                 ("core", None),
                 ("xml", "1.0"),
                 ("xml", "2.0"),
                 ("xml", None),
                 ("ls-load", "3.0"),
                 ("ls-load", None),
                 ]

    def hasFeature(self, feature, version):
        if version == "":
            version = None
        return (feature.lower(), version) in self._features

    def createDocument(self, namespaceURI, qualifiedName, doctype):
        if doctype and doctype.parentNode is not None:
            raise xml.dom.WrongDocumentErr(
                "doctype object owned by another DOM tree")
        doc = self._create_document()

        add_root_element = not (namespaceURI is None
                                and qualifiedName is None
                                and doctype is None)

        if not qualifiedName and add_root_element:
            # The spec is unclear what to raise here; SyntaxErr
            # would be the other obvious candidate. Since Xerces raises
            # InvalidCharacterErr, and since SyntaxErr is not listed
            # for createDocument, that seems to be the better choice.
            # XXX: need to check for illegal characters here and in
            # createElement.

            # DOM Level III clears this up when talking about the return value
            # of this function.  If namespaceURI, qName and DocType are
            # Null the document is returned without a document element
            # Otherwise if doctype or namespaceURI are not None
            # Then we go back to the above problem
            raise xml.dom.InvalidCharacterErr("Element with no name")

        if add_root_element:
            prefix, localname = _nssplit(qualifiedName)
            if prefix == "xml" \
               and namespaceURI != "http://www.w3.org/XML/1998/namespace":
                raise xml.dom.NamespaceErr("illegal use of 'xml' prefix")
            if prefix and not namespaceURI:
                raise xml.dom.NamespaceErr(
                    "illegal use of prefix without namespaces")
            element = doc.createElementNS(namespaceURI, qualifiedName)
            if doctype:
                doc.appendChild(doctype)
            doc.appendChild(element)

        if doctype:
            doctype.parentNode = doctype.ownerDocument = doc

        doc.doctype = doctype
        doc.implementation = self
        return doc

    def createDocumentType(self, qualifiedName, publicId, systemId):
        doctype = DocumentType(qualifiedName)
        doctype.publicId = publicId
        doctype.systemId = systemId
        return doctype

    # DOM Level 3 (WD 9 April 2002)

    def getInterface(self, feature):
        if self.hasFeature(feature, None):
            return self
        else:
            return None

    # internal
    def _create_document(self):
        return Document()

class ElementInfo(object):
    """Object that represents content-model information for an element.

    This implementation is not expected to be used in practice; DOM
    builders should provide implementations which do the right thing
    using information available to it.

    """

    __slots__ = 'tagName',

    def __init__(self, name):
        self.tagName = name

    def getAttributeType(self, aname):
        return _no_type

    def getAttributeTypeNS(self, namespaceURI, localName):
        return _no_type

    def isElementContent(self):
        return False

    def isEmpty(self):
        """Returns true iff this element is declared to have an EMPTY
        content model."""
        return False

    def isId(self, aname):
        """Returns true iff the named attribute is a DTD-style ID."""
        return False

    def isIdNS(self, namespaceURI, localName):
        """Returns true iff the identified attribute is a DTD-style ID."""
        return False

    def __getstate__(self):
        return self.tagName

    def __setstate__(self, state):
        self.tagName = state

def _clear_id_cache(node):
    if node.nodeType == Node.DOCUMENT_NODE:
        node._id_cache.clear()
        node._id_search_stack = None
    elif _in_document(node):
        node.ownerDocument._id_cache.clear()
        node.ownerDocument._id_search_stack= None

class Document(Node, DocumentLS):
    __slots__ = ('_elem_info', 'doctype',
                 '_id_search_stack', 'childNodes', '_id_cache')
    _child_node_types = (Node.ELEMENT_NODE, Node.PROCESSING_INSTRUCTION_NODE,
                         Node.COMMENT_NODE, Node.DOCUMENT_TYPE_NODE)

    implementation = DOMImplementation()
    nodeType = Node.DOCUMENT_NODE
    nodeName = "#document"
    nodeValue = None
    attributes = None
    parentNode = None
    previousSibling = nextSibling = None


    # Document attributes from Level 3 (WD 9 April 2002)

    actualEncoding = None
    encoding = None
    standalone = None
    version = None
    strictErrorChecking = False
    errorHandler = None
    documentURI = None

    _magic_id_count = 0

    def __init__(self):
        self.doctype = None
        self.childNodes = NodeList()
        # mapping of (namespaceURI, localName) -> ElementInfo
        #        and tagName -> ElementInfo
        self._elem_info = {}
        self._id_cache = {}
        self._id_search_stack = None

    def _get_elem_info(self, element):
        if element.namespaceURI:
            key = element.namespaceURI, element.localName
        else:
            key = element.tagName
        return self._elem_info.get(key)

    def _get_actualEncoding(self):
        return self.actualEncoding

    def _get_doctype(self):
        return self.doctype

    def _get_documentURI(self):
        return self.documentURI

    def _get_encoding(self):
        return self.encoding

    def _get_errorHandler(self):
        return self.errorHandler

    def _get_standalone(self):
        return self.standalone

    def _get_strictErrorChecking(self):
        return self.strictErrorChecking

    def _get_version(self):
        return self.version

    def appendChild(self, node):
        if node.nodeType not in self._child_node_types:
            raise xml.dom.HierarchyRequestErr(
                "%s cannot be child of %s" % (repr(node), repr(self)))
        if node.parentNode is not None:
            # This needs to be done before the next test since this
            # may *be* the document element, in which case it should
            # end up re-ordered to the end.
            node.parentNode.removeChild(node)

        if node.nodeType == Node.ELEMENT_NODE \
           and self._get_documentElement():
            raise xml.dom.HierarchyRequestErr(
                "two document elements disallowed")
        return Node.appendChild(self, node)

    def removeChild(self, oldChild):
        try:
            self.childNodes.remove(oldChild)
        except ValueError:
            raise xml.dom.NotFoundErr()
        oldChild.nextSibling = oldChild.previousSibling = None
        oldChild.parentNode = None
        if self.documentElement is oldChild:
            self.documentElement = None

        return oldChild

    def _get_documentElement(self):
        for node in self.childNodes:
            if node.nodeType == Node.ELEMENT_NODE:
                return node

    def unlink(self):
        if self.doctype is not None:
            self.doctype.unlink()
            self.doctype = None
        Node.unlink(self)

    def cloneNode(self, deep):
        if not deep:
            return None
        clone = self.implementation.createDocument(None, None, None)
        clone.encoding = self.encoding
        clone.standalone = self.standalone
        clone.version = self.version
        for n in self.childNodes:
            childclone = _clone_node(n, deep, clone)
            assert childclone.ownerDocument.isSameNode(clone)
            clone.childNodes.append(childclone)
            if childclone.nodeType == Node.DOCUMENT_NODE:
                assert clone.documentElement is None
            elif childclone.nodeType == Node.DOCUMENT_TYPE_NODE:
                assert clone.doctype is None
                clone.doctype = childclone
            childclone.parentNode = clone
        self._call_user_data_handler(xml.dom.UserDataHandler.NODE_CLONED,
                                     self, clone)
        return clone

    def createDocumentFragment(self):
        d = DocumentFragment()
        d.ownerDocument = self
        return d

    def createElement(self, tagName):
        e = Element(tagName)
        e.ownerDocument = self
        return e

    def createTextNode(self, data):
        if not isinstance(data, str):
            raise TypeError("node contents must be a string")
        t = Text()
        t.data = data
        t.ownerDocument = self
        return t

    def createCDATASection(self, data):
        if not isinstance(data, str):
            raise TypeError("node contents must be a string")
        c = CDATASection()
        c.data = data
        c.ownerDocument = self
        return c

    def createComment(self, data):
        c = Comment(data)
        c.ownerDocument = self
        return c

    def createProcessingInstruction(self, target, data):
        p = ProcessingInstruction(target, data)
        p.ownerDocument = self
        return p

    def createAttribute(self, qName):
        a = Attr(qName)
        a.ownerDocument = self
        a.value = ""
        return a

    def createElementNS(self, namespaceURI, qualifiedName):
        prefix, localName = _nssplit(qualifiedName)
        e = Element(qualifiedName, namespaceURI, prefix)
        e.ownerDocument = self
        return e

    def createAttributeNS(self, namespaceURI, qualifiedName):
        prefix, localName = _nssplit(qualifiedName)
        a = Attr(qualifiedName, namespaceURI, localName, prefix)
        a.ownerDocument = self
        a.value = ""
        return a

    # A couple of implementation-specific helpers to create node types
    # not supported by the W3C DOM specs:

    def _create_entity(self, name, publicId, systemId, notationName):
        e = Entity(name, publicId, systemId, notationName)
        e.ownerDocument = self
        return e

    def _create_notation(self, name, publicId, systemId):
        n = Notation(name, publicId, systemId)
        n.ownerDocument = self
        return n

    def getElementById(self, id):
        if id in self._id_cache:
            return self._id_cache[id]
        if not (self._elem_info or self._magic_id_count):
            return None

        stack = self._id_search_stack
        if stack is None:
            # we never searched before, or the cache has been cleared
            stack = [self.documentElement]
            self._id_search_stack = stack
        elif not stack:
            # Previous search was completed and cache is still valid;
            # no matching node.
            return None

        result = None
        while stack:
            node = stack.pop()
            # add child elements to stack for continued searching
            stack.extend([child for child in node.childNodes
                          if child.nodeType in _nodeTypes_with_children])
            # check this node
            info = self._get_elem_info(node)
            if info:
                # We have to process all ID attributes before
                # returning in order to get all the attributes set to
                # be IDs using Element.setIdAttribute*().
                for attr in node.attributes.values():
                    if attr.namespaceURI:
                        if info.isIdNS(attr.namespaceURI, attr.localName):
                            self._id_cache[attr.value] = node
                            if attr.value == id:
                                result = node
                            elif not node._magic_id_nodes:
                                break
                    elif info.isId(attr.name):
                        self._id_cache[attr.value] = node
                        if attr.value == id:
                            result = node
                        elif not node._magic_id_nodes:
                            break
                    elif attr._is_id:
                        self._id_cache[attr.value] = node
                        if attr.value == id:
                            result = node
                        elif node._magic_id_nodes == 1:
                            break
            elif node._magic_id_nodes:
                for attr in node.attributes.values():
                    if attr._is_id:
                        self._id_cache[attr.value] = node
                        if attr.value == id:
                            result = node
            if result is not None:
                break
        return result

    def getElementsByTagName(self, name):
        return _get_elements_by_tagName_helper(self, name, NodeList())

    def getElementsByTagNameNS(self, namespaceURI, localName):
        return _get_elements_by_tagName_ns_helper(
            self, namespaceURI, localName, NodeList())

    def isSupported(self, feature, version):
        return self.implementation.hasFeature(feature, version)

    def importNode(self, node, deep):
        if node.nodeType == Node.DOCUMENT_NODE:
            raise xml.dom.NotSupportedErr("cannot import document nodes")
        elif node.nodeType == Node.DOCUMENT_TYPE_NODE:
            raise xml.dom.NotSupportedErr("cannot import document type nodes")
        return _clone_node(node, deep, self)

    def writexml(self, writer, indent="", addindent="", newl="", encoding=None):
        if encoding is None:
            writer.write('<?xml version="1.0" ?>'+newl)
        else:
            writer.write('<?xml version="1.0" encoding="%s"?>%s' % (
                encoding, newl))
        for node in self.childNodes:
            node.writexml(writer, indent, addindent, newl)

    # DOM Level 3 (WD 9 April 2002)

    def renameNode(self, n, namespaceURI, name):
        if n.ownerDocument is not self:
            raise xml.dom.WrongDocumentErr(
                "cannot rename nodes from other documents;\n"
                "expected %s,\nfound %s" % (self, n.ownerDocument))
        if n.nodeType not in (Node.ELEMENT_NODE, Node.ATTRIBUTE_NODE):
            raise xml.dom.NotSupportedErr(
                "renameNode() only applies to element and attribute nodes")
        if namespaceURI != EMPTY_NAMESPACE:
            if ':' in name:
                prefix, localName = name.split(':', 1)
                if (  prefix == "xmlns"
                      and namespaceURI != xml.dom.XMLNS_NAMESPACE):
                    raise xml.dom.NamespaceErr(
                        "illegal use of 'xmlns' prefix")
            else:
                if (  name == "xmlns"
                      and namespaceURI != xml.dom.XMLNS_NAMESPACE
                      and n.nodeType == Node.ATTRIBUTE_NODE):
                    raise xml.dom.NamespaceErr(
                        "illegal use of the 'xmlns' attribute")
                prefix = None
                localName = name
        else:
            prefix = None
            localName = None
        if n.nodeType == Node.ATTRIBUTE_NODE:
            element = n.ownerElement
            if element is not None:
                is_id = n._is_id
                element.removeAttributeNode(n)
        else:
            element = None
        n.prefix = prefix
        n._localName = localName
        n.namespaceURI = namespaceURI
        n.nodeName = name
        if n.nodeType == Node.ELEMENT_NODE:
            n.tagName = name
        else:
            # attribute node
            n.name = name
            if element is not None:
                element.setAttributeNode(n)
                if is_id:
                    element.setIdAttributeNode(n)
        # It's not clear from a semantic perspective whether we should
        # call the user data handlers for the NODE_RENAMED event since
        # we're re-using the existing node.  The draft spec has been
        # interpreted as meaning "no, don't call the handler unless a
        # new node is created."
        return n

defproperty(Document, "documentElement",
            doc="Top-level element of this document.")


def _clone_node(node, deep, newOwnerDocument):
    """
    Clone a node and give it the new owner document.
    Called by Node.cloneNode and Document.importNode
    """
    if node.ownerDocument.isSameNode(newOwnerDocument):
        operation = xml.dom.UserDataHandler.NODE_CLONED
    else:
        operation = xml.dom.UserDataHandler.NODE_IMPORTED
    if node.nodeType == Node.ELEMENT_NODE:
        clone = newOwnerDocument.createElementNS(node.namespaceURI,
                                                 node.nodeName)
        for attr in node.attributes.values():
            clone.setAttributeNS(attr.namespaceURI, attr.nodeName, attr.value)
            a = clone.getAttributeNodeNS(attr.namespaceURI, attr.localName)
            a.specified = attr.specified

        if deep:
            for child in node.childNodes:
                c = _clone_node(child, deep, newOwnerDocument)
                clone.appendChild(c)

    elif node.nodeType == Node.DOCUMENT_FRAGMENT_NODE:
        clone = newOwnerDocument.createDocumentFragment()
        if deep:
            for child in node.childNodes:
                c = _clone_node(child, deep, newOwnerDocument)
                clone.appendChild(c)

    elif node.nodeType == Node.TEXT_NODE:
        clone = newOwnerDocument.createTextNode(node.data)
    elif node.nodeType == Node.CDATA_SECTION_NODE:
        clone = newOwnerDocument.createCDATASection(node.data)
    elif node.nodeType == Node.PROCESSING_INSTRUCTION_NODE:
        clone = newOwnerDocument.createProcessingInstruction(node.target,
                                                             node.data)
    elif node.nodeType == Node.COMMENT_NODE:
        clone = newOwnerDocument.createComment(node.data)
    elif node.nodeType == Node.ATTRIBUTE_NODE:
        clone = newOwnerDocument.createAttributeNS(node.namespaceURI,
                                                   node.nodeName)
        clone.specified = True
        clone.value = node.value
    elif node.nodeType == Node.DOCUMENT_TYPE_NODE:
        assert node.ownerDocument is not newOwnerDocument
        operation = xml.dom.UserDataHandler.NODE_IMPORTED
        clone = newOwnerDocument.implementation.createDocumentType(
            node.name, node.publicId, node.systemId)
        clone.ownerDocument = newOwnerDocument
        if deep:
            clone.entities._seq = []
            clone.notations._seq = []
            for n in node.notations._seq:
                notation = Notation(n.nodeName, n.publicId, n.systemId)
                notation.ownerDocument = newOwnerDocument
                clone.notations._seq.append(notation)
                if hasattr(n, '_call_user_data_handler'):
                    n._call_user_data_handler(operation, n, notation)
            for e in node.entities._seq:
                entity = Entity(e.nodeName, e.publicId, e.systemId,
                                e.notationName)
                entity.actualEncoding = e.actualEncoding
                entity.encoding = e.encoding
                entity.version = e.version
                entity.ownerDocument = newOwnerDocument
                clone.entities._seq.append(entity)
                if hasattr(e, '_call_user_data_handler'):
                    e._call_user_data_handler(operation, n, entity)
    else:
        # Note the cloning of Document and DocumentType nodes is
        # implementation specific.  minidom handles those cases
        # directly in the cloneNode() methods.
        raise xml.dom.NotSupportedErr("Cannot clone node %s" % repr(node))

    # Check for _call_user_data_handler() since this could conceivably
    # used with other DOM implementations (one of the FourThought
    # DOMs, perhaps?).
    if hasattr(node, '_call_user_data_handler'):
        node._call_user_data_handler(operation, node, clone)
    return clone


def _nssplit(qualifiedName):
    fields = qualifiedName.split(':', 1)
    if len(fields) == 2:
        return fields
    else:
        return (None, fields[0])


def _do_pulldom_parse(func, args, kwargs):
    events = func(*args, **kwargs)
    toktype, rootNode = events.getEvent()
    events.expandNode(rootNode)
    events.clear()
    return rootNode

def parse(file, parser=None, bufsize=None):
    """Parse a file into a DOM by filename or file object."""
    if parser is None and not bufsize:
        from xml.dom import expatbuilder
        return expatbuilder.parse(file)
    else:
        from xml.dom import pulldom
        return _do_pulldom_parse(pulldom.parse, (file,),
            {'parser': parser, 'bufsize': bufsize})

def parseString(string, parser=None):
    """Parse a file into a DOM from a string."""
    if parser is None:
        from xml.dom import expatbuilder
        return expatbuilder.parseString(string)
    else:
        from xml.dom import pulldom
        return _do_pulldom_parse(pulldom.parseString, (string,),
                                 {'parser': parser})

def getDOMImplementation(features=None):
    if features:
        if isinstance(features, str):
            features = domreg._parse_feature_string(features)
        for f, v in features:
            if not Document.implementation.hasFeature(f, v):
                return None
    return Document.implementation
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             import xml.sax
import xml.sax.handler

START_ELEMENT = "START_ELEMENT"
END_ELEMENT = "END_ELEMENT"
COMMENT = "COMMENT"
START_DOCUMENT = "START_DOCUMENT"
END_DOCUMENT = "END_DOCUMENT"
PROCESSING_INSTRUCTION = "PROCESSING_INSTRUCTION"
IGNORABLE_WHITESPACE = "IGNORABLE_WHITESPACE"
CHARACTERS = "CHARACTERS"

class PullDOM(xml.sax.ContentHandler):
    _locator = None
    document = None

    def __init__(self, documentFactory=None):
        from xml.dom import XML_NAMESPACE
        self.documentFactory = documentFactory
        self.firstEvent = [None, None]
        self.lastEvent = self.firstEvent
        self.elementStack = []
        self.push = self.elementStack.append
        try:
            self.pop = self.elementStack.pop
        except AttributeError:
            # use class' pop instead
            pass
        self._ns_contexts = [{XML_NAMESPACE:'xml'}] # contains uri -> prefix dicts
        self._current_context = self._ns_contexts[-1]
        self.pending_events = []

    def pop(self):
        result = self.elementStack[-1]
        del self.elementStack[-1]
        return result

    def setDocumentLocator(self, locator):
        self._locator = locator

    def startPrefixMapping(self, prefix, uri):
        if not hasattr(self, '_xmlns_attrs'):
            self._xmlns_attrs = []
        self._xmlns_attrs.append((prefix or 'xmlns', uri))
        self._ns_contexts.append(self._current_context.copy())
        self._current_context[uri] = prefix or None

    def endPrefixMapping(self, prefix):
        self._current_context = self._ns_contexts.pop()

    def startElementNS(self, name, tagName , attrs):
        # Retrieve xml namespace declaration attributes.
        xmlns_uri = 'http://www.w3.org/2000/xmlns/'
        xmlns_attrs = getattr(self, '_xmlns_attrs', None)
        if xmlns_attrs is not None:
            for aname, value in xmlns_attrs:
                attrs._attrs[(xmlns_uri, aname)] = value
            self._xmlns_attrs = []
        uri, localname = name
        if uri:
            # When using namespaces, the reader may or may not
            # provide us with the original name. If not, create
            # *a* valid tagName from the current context.
            if tagName is None:
                prefix = self._current_context[uri]
                if prefix:
                    tagName = prefix + ":" + localname
                else:
                    tagName = localname
            if self.document:
                node = self.document.createElementNS(uri, tagName)
            else:
                node = self.buildDocument(uri, tagName)
        else:
            # When the tagname is not prefixed, it just appears as
            # localname
            if self.document:
                node = self.document.createElement(localname)
            else:
                node = self.buildDocument(None, localname)

        for aname,value in attrs.items():
            a_uri, a_localname = aname
            if a_uri == xmlns_uri:
                if a_localname == 'xmlns':
                    qname = a_localname
                else:
                    qname = 'xmlns:' + a_localname
                attr = self.document.createAttributeNS(a_uri, qname)
                node.setAttributeNodeNS(attr)
            elif a_uri:
                prefix = self._current_context[a_uri]
                if prefix:
                    qname = prefix + ":" + a_localname
                else:
                    qname = a_localname
                attr = self.document.createAttributeNS(a_uri, qname)
                node.setAttributeNodeNS(attr)
            else:
                attr = self.document.createAttribute(a_localname)
                node.setAttributeNode(attr)
            attr.value = value

        self.lastEvent[1] = [(START_ELEMENT, node), None]
        self.lastEvent = self.lastEvent[1]
        self.push(node)

    def endElementNS(self, name, tagName):
        self.lastEvent[1] = [(END_ELEMENT, self.pop()), None]
        self.lastEvent = self.lastEvent[1]

    def startElement(self, name, attrs):
        if self.document:
            node = self.document.createElement(name)
        else:
            node = self.buildDocument(None, name)

        for aname,value in attrs.items():
            attr = self.document.createAttribute(aname)
            attr.value = value
            node.setAttributeNode(attr)

        self.lastEvent[1] = [(START_ELEMENT, node), None]
        self.lastEvent = self.lastEvent[1]
        self.push(node)

    def endElement(self, name):
        self.lastEvent[1] = [(END_ELEMENT, self.pop()), None]
        self.lastEvent = self.lastEvent[1]

    def comment(self, s):
        if self.document:
            node = self.document.createComment(s)
            self.lastEvent[1] = [(COMMENT, node), None]
            self.lastEvent = self.lastEvent[1]
        else:
            event = [(COMMENT, s), None]
            self.pending_events.append(event)

    def processingInstruction(self, target, data):
        if self.document:
            node = self.document.createProcessingInstruction(target, data)
            self.lastEvent[1] = [(PROCESSING_INSTRUCTION, node), None]
            self.lastEvent = self.lastEvent[1]
        else:
            event = [(PROCESSING_INSTRUCTION, target, data), None]
            self.pending_events.append(event)

    def ignorableWhitespace(self, chars):
        node = self.document.createTextNode(chars)
        self.lastEvent[1] = [(IGNORABLE_WHITESPACE, node), None]
        self.lastEvent = self.lastEvent[1]

    def characters(self, chars):
        node = self.document.createTextNode(chars)
        self.lastEvent[1] = [(CHARACTERS, node), None]
        self.lastEvent = self.lastEvent[1]

    def startDocument(self):
        if self.documentFactory is None:
            import xml.dom.minidom
            self.documentFactory = xml.dom.minidom.Document.implementation

    def buildDocument(self, uri, tagname):
        # Can't do that in startDocument, since we need the tagname
        # XXX: obtain DocumentType
        node = self.documentFactory.createDocument(uri, tagname, None)
        self.document = node
        self.lastEvent[1] = [(START_DOCUMENT, node), None]
        self.lastEvent = self.lastEvent[1]
        self.push(node)
        # Put everything we have seen so far into the document
        for e in self.pending_events:
            if e[0][0] == PROCESSING_INSTRUCTION:
                _,target,data = e[0]
                n = self.document.createProcessingInstruction(target, data)
                e[0] = (PROCESSING_INSTRUCTION, n)
            elif e[0][0] == COMMENT:
                n = self.document.createComment(e[0][1])
                e[0] = (COMMENT, n)
            else:
                raise AssertionError("Unknown pending event ",e[0][0])
            self.lastEvent[1] = e
            self.lastEvent = e
        self.pending_events = None
        return node.firstChild

    def endDocument(self):
        self.lastEvent[1] = [(END_DOCUMENT, self.document), None]
        self.pop()

    def clear(self):
        "clear(): Explicitly release parsing structures"
        self.document = None

class ErrorHandler:
    def warning(self, exception):
        print(exception)
    def error(self, exception):
        raise exception
    def fatalError(self, exception):
        raise exception

class DOMEventStream:
    def __init__(self, stream, parser, bufsize):
        self.stream = stream
        self.parser = parser
        self.bufsize = bufsize
        if not hasattr(self.parser, 'feed'):
            self.getEvent = self._slurp
        self.reset()

    def reset(self):
        self.pulldom = PullDOM()
        # This content handler relies on namespace support
        self.parser.setFeature(xml.sax.handler.feature_namespaces, 1)
        self.parser.setContentHandler(self.pulldom)

    def __getitem__(self, pos):
        rc = self.getEvent()
        if rc:
            return rc
        raise IndexError

    def __next__(self):
        rc = self.getEvent()
        if rc:
            return rc
        raise StopIteration

    def __iter__(self):
        return self

    def expandNode(self, node):
        event = self.getEvent()
        parents = [node]
        while event:
            token, cur_node = event
            if cur_node is node:
                return
            if token != END_ELEMENT:
                parents[-1].appendChild(cur_node)
            if token == START_ELEMENT:
                parents.append(cur_node)
            elif token == END_ELEMENT:
                del parents[-1]
            event = self.getEvent()

    def getEvent(self):
        # use IncrementalParser interface, so we get the desired
        # pull effect
        if not self.pulldom.firstEvent[1]:
            self.pulldom.lastEvent = self.pulldom.firstEvent
        while not self.pulldom.firstEvent[1]:
            buf = self.stream.read(self.bufsize)
            if not buf:
                self.parser.close()
                return None
            self.parser.feed(buf)
        rc = self.pulldom.firstEvent[1][0]
        self.pulldom.firstEvent[1] = self.pulldom.firstEvent[1][1]
        return rc

    def _slurp(self):
        """ Fallback replacement for getEvent() using the
            standard SAX2 interface, which means we slurp the
            SAX events into memory (no performance gain, but
            we are compatible to all SAX parsers).
        """
        self.parser.parse(self.stream)
        self.getEvent = self._emit
        return self._emit()

    def _emit(self):
        """ Fallback replacement for getEvent() that emits
            the events that _slurp() read previously.
        """
        rc = self.pulldom.firstEvent[1][0]
        self.pulldom.firstEvent[1] = self.pulldom.firstEvent[1][1]
        return rc

    def clear(self):
        """clear(): Explicitly release parsing objects"""
        self.pulldom.clear()
        del self.pulldom
        self.parser = None
        self.stream = None

class SAX2DOM(PullDOM):

    def startElementNS(self, name, tagName , attrs):
        PullDOM.startElementNS(self, name, tagName, attrs)
        curNode = self.elementStack[-1]
        parentNode = self.elementStack[-2]
        parentNode.appendChild(curNode)

    def startElement(self, name, attrs):
        PullDOM.startElement(self, name, attrs)
        curNode = self.elementStack[-1]
        parentNode = self.elementStack[-2]
        parentNode.appendChild(curNode)

    def processingInstruction(self, target, data):
        PullDOM.processingInstruction(self, target, data)
        node = self.lastEvent[0][1]
        parentNode = self.elementStack[-1]
        parentNode.appendChild(node)

    def ignorableWhitespace(self, chars):
        PullDOM.ignorableWhitespace(self, chars)
        node = self.lastEvent[0][1]
        parentNode = self.elementStack[-1]
        parentNode.appendChild(node)

    def characters(self, chars):
        PullDOM.characters(self, chars)
        node = self.lastEvent[0][1]
        parentNode = self.elementStack[-1]
        parentNode.appendChild(node)


default_bufsize = (2 ** 14) - 20

def parse(stream_or_string, parser=None, bufsize=None):
    if bufsize is None:
        bufsize = default_bufsize
    if isinstance(stream_or_string, str):
        stream = open(stream_or_string, 'rb')
    else:
        stream = stream_or_string
    if not parser:
        parser = xml.sax.make_parser()
    return DOMEventStream(stream, parser, bufsize)

def parseString(string, parser=None):
    from io import StringIO

    bufsize = len(string)
    buf = StringIO(string)
    if not parser:
        parser = xml.sax.make_parser()
    return DOMEventStream(buf, parser, bufsize)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
[                 @   s   Gd  d   d  Z  d S)c               @   s   e  Z d  Z d Z d Z d Z d Z d Z d Z d Z	 d Z
 d Z d Z d	 Z d
 Z d Z d Z d Z d Z d Z d d   Z d S)
NodeFilterzL
    This is the DOM2 NodeFilter interface. It contains only constants.
             l                 @         i   i   i   c             C   s
   t   d  S)N)NotImplementedError)selfZnode r   (/usr/lib/python3.5/xml/dom/NodeFilter.py
acceptNode   s    zNodeFilter.acceptNodeN)__name__
__module____qualname____doc__ZFILTER_ACCEPTZFILTER_REJECTZFILTER_SKIPZSHOW_ALLZSHOW_ELEMENTZSHOW_ATTRIBUTEZ	SHOW_TEXTZSHOW_CDATA_SECTIONZSHOW_ENTITY_REFERENCEZSHOW_ENTITYZSHOW_PROCESSING_INSTRUCTIONZSHOW_COMMENTZSHOW_DOCUMENTZSHOW_DOCUMENT_TYPEZSHOW_DOCUMENT_FRAGMENTZSHOW_NOTATIONr   r   r   r   r   r      s$   r   N)r   r   r   r   r   <module>   s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            
[                 @   s:  d  Z  Gd d   d  Z d Z d Z d Z d Z d Z d Z d	 Z d
 Z	 d Z
 d Z d Z d Z d Z d Z d Z d Z Gd d   d e  Z Gd d   d e  Z Gd d   d e  Z Gd d   d e  Z Gd d   d e  Z Gd d   d e  Z Gd d    d  e  Z Gd! d"   d" e  Z Gd# d$   d$ e  Z Gd% d&   d& e  Z Gd' d(   d( e  Z Gd) d*   d* e  Z Gd+ d,   d, e  Z Gd- d.   d. e  Z  Gd/ d0   d0 e  Z! Gd1 d2   d2 e  Z" Gd3 d4   d4 e  Z# Gd5 d6   d6  Z$ d7 Z% d8 Z& d9 Z' d: Z( d: Z) d d; l* m+ Z+ m, Z, d: S)<a  W3C Document Object Model implementation for Python.

The Python mapping of the Document Object Model is documented in the
Python Library Reference in the section on the xml.dom package.

This package contains the following modules:

minidom -- A simple implementation of the Level 1 DOM with namespace
           support added (based on the Level 2 specification) and other
           minor Level 2 functionality.

pulldom -- DOM builder supporting on-demand tree-building for selected
           subtrees of the document.

c               @   sd   e  Z d  Z d Z f  Z d Z d Z d Z d Z d Z	 d Z
 d Z d	 Z d
 Z d Z d Z d Z d S)Nodez$Class giving the NodeType constants.                        	   
         N)__name__
__module____qualname____doc__	__slots__ZELEMENT_NODEZATTRIBUTE_NODEZ	TEXT_NODEZCDATA_SECTION_NODEZENTITY_REFERENCE_NODEZENTITY_NODEZPROCESSING_INSTRUCTION_NODEZCOMMENT_NODEZDOCUMENT_NODEZDOCUMENT_TYPE_NODEZDOCUMENT_FRAGMENT_NODEZNOTATION_NODE r   r   &/usr/lib/python3.5/xml/dom/__init__.pyr      s   	r   r   r   r   r   r   r   r   r	   r
   r   r   r               c               @   s.   e  Z d  Z d Z d d   Z d d   Z d S)DOMExceptionzmAbstract base class for DOM exceptions.
    Exceptions with specific codes are specializations of this class.c             O   s2   |  j  t k r t d   t j |  | |  d  S)Nz0DOMException should not be instantiated directly)	__class__r   RuntimeError	Exception__init__)selfargskwr   r   r   r   B   s    	zDOMException.__init__c             C   s   |  j  S)N)code)r   r   r   r   	_get_codeH   s    zDOMException._get_codeN)r   r   r   r   r   r"   r   r   r   r   r   >   s   r   c               @   s   e  Z d  Z e Z d S)IndexSizeErrN)r   r   r   INDEX_SIZE_ERRr!   r   r   r   r   r#   L   s   r#   c               @   s   e  Z d  Z e Z d S)DomstringSizeErrN)r   r   r   DOMSTRING_SIZE_ERRr!   r   r   r   r   r%   O   s   r%   c               @   s   e  Z d  Z e Z d S)HierarchyRequestErrN)r   r   r   HIERARCHY_REQUEST_ERRr!   r   r   r   r   r'   R   s   r'   c               @   s   e  Z d  Z e Z d S)WrongDocumentErrN)r   r   r   WRONG_DOCUMENT_ERRr!   r   r   r   r   r)   U   s   r)   c               @   s   e  Z d  Z e Z d S)InvalidCharacterErrN)r   r   r   INVALID_CHARACTER_ERRr!   r   r   r   r   r+   X   s   r+   c               @   s   e  Z d  Z e Z d S)NoDataAllowedErrN)r   r   r   NO_DATA_ALLOWED_ERRr!   r   r   r   r   r-   [   s   r-   c               @   s   e  Z d  Z e Z d S)NoModificationAllowedErrN)r   r   r   NO_MODIFICATION_ALLOWED_ERRr!   r   r   r   r   r/   ^   s   r/   c               @   s   e  Z d  Z e Z d S)NotFoundErrN)r   r   r   NOT_FOUND_ERRr!   r   r   r   r   r1   a   s   r1   c               @   s   e  Z d  Z e Z d S)NotSupportedErrN)r   r   r   NOT_SUPPORTED_ERRr!   r   r   r   r   r3   d   s   r3   c               @   s   e  Z d  Z e Z d S)InuseAttributeErrN)r   r   r   INUSE_ATTRIBUTE_ERRr!   r   r   r   r   r5   g   s   r5   c               @   s   e  Z d  Z e Z d S)InvalidStateErrN)r   r   r   INVALID_STATE_ERRr!   r   r   r   r   r7   j   s   r7   c               @   s   e  Z d  Z e Z d S)	SyntaxErrN)r   r   r   
SYNTAX_ERRr!   r   r   r   r   r9   m   s   r9   c               @   s   e  Z d  Z e Z d S)InvalidModificationErrN)r   r   r   INVALID_MODIFICATION_ERRr!   r   r   r   r   r;   p   s   r;   c               @   s   e  Z d  Z e Z d S)NamespaceErrN)r   r   r   NAMESPACE_ERRr!   r   r   r   r   r=   s   s   r=   c               @   s   e  Z d  Z e Z d S)InvalidAccessErrN)r   r   r   INVALID_ACCESS_ERRr!   r   r   r   r   r?   v   s   r?   c               @   s   e  Z d  Z e Z d S)ValidationErrN)r   r   r   VALIDATION_ERRr!   r   r   r   r   rA   y   s   rA   c               @   s.   e  Z d  Z d Z d Z d Z d Z d Z d S)UserDataHandlerzBClass giving the operation constants for UserDataHandler.handle().r   r   r   r   N)r   r   r   r   ZNODE_CLONEDZNODE_IMPORTEDZNODE_DELETEDZNODE_RENAMEDr   r   r   r   rC   |   s
   rC   z$http://www.w3.org/XML/1998/namespacezhttp://www.w3.org/2000/xmlns/zhttp://www.w3.org/1999/xhtmlN)getDOMImplementationregisterDOMImplementation)-r   r   r$   r&   r(   r*   r,   r.   r0   r2   r4   r6   r8   r:   r<   r>   r@   rB   r   r   r#   r%   r'   r)   r+   r-   r/   r1   r3   r5   r7   r9   r;   r=   r?   rA   rC   ZXML_NAMESPACEZXMLNS_NAMESPACEZXHTML_NAMESPACEZEMPTY_NAMESPACEZEMPTY_PREFIXZdomregrD   rE   r   r   r   r   <module>   sR   
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                """Implementation of the DOM Level 3 'LS-Load' feature."""

import copy
import warnings
import xml.dom

from xml.dom.NodeFilter import NodeFilter


__all__ = ["DOMBuilder", "DOMEntityResolver", "DOMInputSource"]


class Options:
    """Features object that has variables set for each DOMBuilder feature.

    The DOMBuilder class uses an instance of this class to pass settings to
    the ExpatBuilder class.
    """

    # Note that the DOMBuilder class in LoadSave constrains which of these
    # values can be set using the DOM Level 3 LoadSave feature.

    namespaces = 1
    namespace_declarations = True
    validation = False
    external_parameter_entities = True
    external_general_entities = True
    external_dtd_subset = True
    validate_if_schema = False
    validate = False
    datatype_normalization = False
    create_entity_ref_nodes = True
    entities = True
    whitespace_in_element_content = True
    cdata_sections = True
    comments = True
    charset_overrides_xml_encoding = True
    infoset = False
    supported_mediatypes_only = False

    errorHandler = None
    filter = None


class DOMBuilder:
    entityResolver = None
    errorHandler = None
    filter = None

    ACTION_REPLACE = 1
    ACTION_APPEND_AS_CHILDREN = 2
    ACTION_INSERT_AFTER = 3
    ACTION_INSERT_BEFORE = 4

    _legal_actions = (ACTION_REPLACE, ACTION_APPEND_AS_CHILDREN,
                      ACTION_INSERT_AFTER, ACTION_INSERT_BEFORE)

    def __init__(self):
        self._options = Options()

    def _get_entityResolver(self):
        return self.entityResolver
    def _set_entityResolver(self, entityResolver):
        self.entityResolver = entityResolver

    def _get_errorHandler(self):
        return self.errorHandler
    def _set_errorHandler(self, errorHandler):
        self.errorHandler = errorHandler

    def _get_filter(self):
        return self.filter
    def _set_filter(self, filter):
        self.filter = filter

    def setFeature(self, name, state):
        if self.supportsFeature(name):
            state = state and 1 or 0
            try:
                settings = self._settings[(_name_xform(name), state)]
            except KeyError:
                raise xml.dom.NotSupportedErr(
                    "unsupported feature: %r" % (name,))
            else:
                for name, value in settings:
                    setattr(self._options, name, value)
        else:
            raise xml.dom.NotFoundErr("unknown feature: " + repr(name))

    def supportsFeature(self, name):
        return hasattr(self._options, _name_xform(name))

    def canSetFeature(self, name, state):
        key = (_name_xform(name), state and 1 or 0)
        return key in self._settings

    # This dictionary maps from (feature,value) to a list of
    # (option,value) pairs that should be set on the Options object.
    # If a (feature,value) setting is not in this dictionary, it is
    # not supported by the DOMBuilder.
    #
    _settings = {
        ("namespace_declarations", 0): [
            ("namespace_declarations", 0)],
        ("namespace_declarations", 1): [
            ("namespace_declarations", 1)],
        ("validation", 0): [
            ("validation", 0)],
        ("external_general_entities", 0): [
            ("external_general_entities", 0)],
        ("external_general_entities", 1): [
            ("external_general_entities", 1)],
        ("external_parameter_entities", 0): [
            ("external_parameter_entities", 0)],
        ("external_parameter_entities", 1): [
            ("external_parameter_entities", 1)],
        ("validate_if_schema", 0): [
            ("validate_if_schema", 0)],
        ("create_entity_ref_nodes", 0): [
            ("create_entity_ref_nodes", 0)],
        ("create_entity_ref_nodes", 1): [
            ("create_entity_ref_nodes", 1)],
        ("entities", 0): [
            ("create_entity_ref_nodes", 0),
            ("entities", 0)],
        ("entities", 1): [
            ("entities", 1)],
        ("whitespace_in_element_content", 0): [
            ("whitespace_in_element_content", 0)],
        ("whitespace_in_element_content", 1): [
            ("whitespace_in_element_content", 1)],
        ("cdata_sections", 0): [
            ("cdata_sections", 0)],
        ("cdata_sections", 1): [
            ("cdata_sections", 1)],
        ("comments", 0): [
            ("comments", 0)],
        ("comments", 1): [
            ("comments", 1)],
        ("charset_overrides_xml_encoding", 0): [
            ("charset_overrides_xml_encoding", 0)],
        ("charset_overrides_xml_encoding", 1): [
            ("charset_overrides_xml_encoding", 1)],
        ("infoset", 0): [],
        ("infoset", 1): [
            ("namespace_declarations", 0),
            ("validate_if_schema", 0),
            ("create_entity_ref_nodes", 0),
            ("entities", 0),
            ("cdata_sections", 0),
            ("datatype_normalization", 1),
            ("whitespace_in_element_content", 1),
            ("comments", 1),
            ("charset_overrides_xml_encoding", 1)],
        ("supported_mediatypes_only", 0): [
            ("supported_mediatypes_only", 0)],
        ("namespaces", 0): [
            ("namespaces", 0)],
        ("namespaces", 1): [
            ("namespaces", 1)],
    }

    def getFeature(self, name):
        xname = _name_xform(name)
        try:
            return getattr(self._options, xname)
        except AttributeError:
            if name == "infoset":
                options = self._options
                return (options.datatype_normalization
                        and options.whitespace_in_element_content
                        and options.comments
                        and options.charset_overrides_xml_encoding
                        and not (options.namespace_declarations
                                 or options.validate_if_schema
                                 or options.create_entity_ref_nodes
                                 or options.entities
                                 or options.cdata_sections))
            raise xml.dom.NotFoundErr("feature %s not known" % repr(name))

    def parseURI(self, uri):
        if self.entityResolver:
            input = self.entityResolver.resolveEntity(None, uri)
        else:
            input = DOMEntityResolver().resolveEntity(None, uri)
        return self.parse(input)

    def parse(self, input):
        options = copy.copy(self._options)
        options.filter = self.filter
        options.errorHandler = self.errorHandler
        fp = input.byteStream
        if fp is None and options.systemId:
            import urllib.request
            fp = urllib.request.urlopen(input.systemId)
        return self._parse_bytestream(fp, options)

    def parseWithContext(self, input, cnode, action):
        if action not in self._legal_actions:
            raise ValueError("not a legal action")
        raise NotImplementedError("Haven't written this yet...")

    def _parse_bytestream(self, stream, options):
        import xml.dom.expatbuilder
        builder = xml.dom.expatbuilder.makeBuilder(options)
        return builder.parseFile(stream)


def _name_xform(name):
    return name.lower().replace('-', '_')


class DOMEntityResolver(object):
    __slots__ = '_opener',

    def resolveEntity(self, publicId, systemId):
        assert systemId is not None
        source = DOMInputSource()
        source.publicId = publicId
        source.systemId = systemId
        source.byteStream = self._get_opener().open(systemId)

        # determine the encoding if the transport provided it
        source.encoding = self._guess_media_encoding(source)

        # determine the base URI is we can
        import posixpath, urllib.parse
        parts = urllib.parse.urlparse(systemId)
        scheme, netloc, path, params, query, fragment = parts
        # XXX should we check the scheme here as well?
        if path and not path.endswith("/"):
            path = posixpath.dirname(path) + "/"
            parts = scheme, netloc, path, params, query, fragment
            source.baseURI = urllib.parse.urlunparse(parts)

        return source

    def _get_opener(self):
        try:
            return self._opener
        except AttributeError:
            self._opener = self._create_opener()
            return self._opener

    def _create_opener(self):
        import urllib.request
        return urllib.request.build_opener()

    def _guess_media_encoding(self, source):
        info = source.byteStream.info()
        if "Content-Type" in info:
            for param in info.getplist():
                if param.startswith("charset="):
                    return param.split("=", 1)[1].lower()


class DOMInputSource(object):
    __slots__ = ('byteStream', 'characterStream', 'stringData',
                 'encoding', 'publicId', 'systemId', 'baseURI')

    def __init__(self):
        self.byteStream = None
        self.characterStream = None
        self.stringData = None
        self.encoding = None
        self.publicId = None
        self.systemId = None
        self.baseURI = None

    def _get_byteStream(self):
        return self.byteStream
    def _set_byteStream(self, byteStream):
        self.byteStream = byteStream

    def _get_characterStream(self):
        return self.characterStream
    def _set_characterStream(self, characterStream):
        self.characterStream = characterStream

    def _get_stringData(self):
        return self.stringData
    def _set_stringData(self, data):
        self.stringData = data

    def _get_encoding(self):
        return self.encoding
    def _set_encoding(self, encoding):
        self.encoding = encoding

    def _get_publicId(self):
        return self.publicId
    def _set_publicId(self, publicId):
        self.publicId = publicId

    def _get_systemId(self):
        return self.systemId
    def _set_systemId(self, systemId):
        self.systemId = systemId

    def _get_baseURI(self):
        return self.baseURI
    def _set_baseURI(self, uri):
        self.baseURI = uri


class DOMBuilderFilter:
    """Element filter which can be used to tailor construction of
    a DOM instance.
    """

    # There's really no need for this class; concrete implementations
    # should just implement the endElement() and startElement()
    # methods as appropriate.  Using this makes it easy to only
    # implement one of them.

    FILTER_ACCEPT = 1
    FILTER_REJECT = 2
    FILTER_SKIP = 3
    FILTER_INTERRUPT = 4

    whatToShow = NodeFilter.SHOW_ALL

    def _get_whatToShow(self):
        return self.whatToShow

    def acceptNode(self, element):
        return self.FILTER_ACCEPT

    def startContainer(self, element):
        return self.FILTER_ACCEPT

del NodeFilter


class _AsyncDeprecatedProperty:
    def warn(self, cls):
        clsname = cls.__name__
        warnings.warn(
            "{cls}.async is deprecated; use {cls}.async_".format(cls=clsname),
            DeprecationWarning)

    def __get__(self, instance, cls):
        self.warn(cls)
        if instance is not None:
            return instance.async_
        return False

    def __set__(self, instance, value):
        self.warn(type(instance))
        setattr(instance, 'async_', value)


class DocumentLS:
    """Mixin to create documents that conform to the load/save spec."""

    async = _AsyncDeprecatedProperty()
    async_ = False

    def _get_async(self):
        return False

    def _set_async(self, async):
        if async:
            raise xml.dom.NotSupportedErr(
                "asynchronous document loading is not supported")

    def abort(self):
        # What does it mean to "clear" a document?  Does the
        # documentElement disappear?
        raise NotImplementedError(
            "haven't figured out what this means yet")

    def load(self, uri):
        raise NotImplementedError("haven't written this yet")

    def loadXML(self, source):
        raise NotImplementedError("haven't written this yet")

    def saveXML(self, snode):
        if snode is None:
            snode = self
        elif snode.ownerDocument is not self:
            raise xml.dom.WrongDocumentErr()
        return snode.toxml()


del _AsyncDeprecatedProperty


class DOMImplementationLS:
    MODE_SYNCHRONOUS = 1
    MODE_ASYNCHRONOUS = 2

    def createDOMBuilder(self, mode, schemaType):
        if schemaType is not None:
            raise xml.dom.NotSupportedErr(
                "schemaType not yet supported")
        if mode == self.MODE_SYNCHRONOUS:
            return DOMBuilder()
        if mode == self.MODE_ASYNCHRONOUS:
            raise xml.dom.NotSupportedErr(
                "asynchronous builders are not supported")
        raise ValueError("unknown value for mode")

    def createDOMWriter(self):
        raise NotImplementedError(
            "the writer interface hasn't been written yet!")

    def createDOMInputSource(self):
        return DOMInputSource()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
[J                 @   sX   d  Z  d d d d i Z i  Z d d   Z d d   Z d	 f  d
 d  Z d d   Z d	 S)zRegistration facilities for DOM. This module should not be used
directly. Instead, the functions getDOMImplementation and
registerDOMImplementation should be imported from xml.dom.Zminidomzxml.dom.minidomZ4DOMzxml.dom.DOMImplementationc             C   s   | t  |  <d S)aI  registerDOMImplementation(name, factory)

    Register the factory function with the name. The factory function
    should return an object which implements the DOMImplementation
    interface. The factory function can either return the same object,
    or a new one (e.g. if that implementation supports some
    customization).N)
registered)namefactory r   $/usr/lib/python3.5/xml/dom/domreg.pyregisterDOMImplementation   s    	r   c             C   s1   x* | D]" \ } } |  j  | |  s d Sq Wd S)zF_good_enough(dom, features) -> Return 1 if the dom offers the features       )Z
hasFeature)domfeaturesfvr   r   r   _good_enough   s    r   Nc             C   s0  d d l  } d } t j |   } | rI t | i  i  d g  } | j   S|  rZ t |    Sd | j k r} t d | j d  St | t  r t	 |  } x0 t j
   D]" } |   } t | |  r | Sq WxR t j   D]D } y t d |  } Wn t k
 rw Yn Xt | |  r | Sq Wt d   d S)aS  getDOMImplementation(name = None, features = ()) -> DOM implementation.

    Return a suitable DOM implementation. The name is either
    well-known, the module name of a DOM implementation, or None. If
    it is not None, imports the corresponding module and returns
    DOMImplementation object if the import succeeds.

    If name is not given, consider the available implementations to
    find one with the required feature set. If no implementation can
    be found, raise an ImportError. The features list must be a sequence
    of (feature, version) pairs which are passed to hasFeature.r   NgetDOMImplementationZ
PYTHON_DOMr   z$no suitable DOM implementation found)oswell_known_implementationsget
__import__r   r   environ
isinstancestr_parse_feature_stringvaluesr   keys	ExceptionImportError)r   r
   r   Zcreatormodr	   r   r   r   r   %   s0    
	r   c             C   s   g  } |  j    } d } t |  } x | | k  r | | } | d d k r` t d | f   | d } d  } | | k  r | | } | d d k r | d } | } | j | | f  q' Wt |  S)Nr   
0123456789zbad feature name: %rr   )splitlen
ValueErrorappendtuple)sr
   partsiZlengthZfeatureversionr   r   r   r   r   P   s"    



r   )__doc__r   r   r   r   r   r   r   r   r   r   <module>   s   +                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   
['                 @   si   d  Z  d d d d g Z d d l Z e f Z Gd d   d e  Z Gd d   d e  Z	 d	 d   Z
 d S)
zPython version compatibility support for minidom.

This module contains internal implementation details and
should not be imported; use xml.dom.minidom instead.
NodeListEmptyNodeListStringTypesdefproperty    Nc               @   s[   e  Z d  Z f  Z d d   Z d d   Z d d   Z e e e d d Z d	 d
   Z	 d S)r   c             C   s.   d | k o t  |   k  n r* |  | Sd  S)Nr   )len)selfindex r	   (/usr/lib/python3.5/xml/dom/minicompat.pyitem5   s    "zNodeList.itemc             C   s
   t  |   S)N)r   )r   r	   r	   r
   _get_length9   s    zNodeList._get_lengthc             C   s   t  j j d   d  S)Nz.attempt to modify read-only attribute 'length')xmldomNoModificationAllowedErr)r   valuer	   r	   r
   _set_length<   s    	zNodeList._set_lengthdocz$The number of nodes in the NodeList.c             C   s&   | d  k r g  } | |  d  d   <d  S)Nr	   )r   stater	   r	   r
   __setstate__D   s    zNodeList.__setstate__N)
__name__
__module____qualname__	__slots__r   r   r   propertylengthr   r	   r	   r	   r
   r   2   s   	c               @   sg   e  Z d  Z f  Z d d   Z d d   Z d d   Z d d   Z d	 d
   Z e	 e e d d Z
 d S)r   c             C   s   t    } | j |  | S)N)r   extend)r   otherNLr	   r	   r
   __add__M   s    	zEmptyNodeList.__add__c             C   s   t    } | j |  | S)N)r   r   )r   r   r   r	   r	   r
   __radd__R   s    	zEmptyNodeList.__radd__c             C   s   d  S)Nr	   )r   r   r	   r	   r
   r   W   s    zEmptyNodeList.itemc             C   s   d S)Nr   r	   )r   r	   r	   r
   r   Z   s    zEmptyNodeList._get_lengthc             C   s   t  j j d   d  S)Nz.attempt to modify read-only attribute 'length')r   r   r   )r   r   r	   r	   r
   r   ]   s    	zEmptyNodeList._set_lengthr   z$The number of nodes in the NodeList.N)r   r   r   r   r   r   r   r   r   r   r   r	   r	   r	   r
   r   J   s   c             C   so   t  |  d |  } | d d  } t |  d |  sF t d |   t | | d | } t |  | |  d  S)NZ_get_c             S   s    t  j j d t |    d  S)Nz&attempt to modify read-only attribute )r   r   r   repr)r   r   namer	   r	   r
   setg   s    	zdefproperty.<locals>.setZ_set_zexpected not to find _set_r   )getattrhasattrAssertionErrorr   setattr)klassr!   r   getr"   Zpropr	   r	   r
   r   e   s    )__doc____all__Zxml.domr   strr   listr   tupler   r   r	   r	   r	   r
   <module>   s   &	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
[-                 @   s   d  d l  Z d  d l Z d Z d Z d Z d Z d Z d Z d Z	 d	 Z
 Gd
 d   d e j j  Z Gd d   d  Z Gd d   d  Z Gd d   d e  Z d Z d d d d  Z d d d  Z d S)    NSTART_ELEMENTEND_ELEMENTCOMMENTSTART_DOCUMENTEND_DOCUMENTPROCESSING_INSTRUCTIONIGNORABLE_WHITESPACE
CHARACTERSc               @   s   e  Z d  Z d Z d Z d d d  Z d d   Z d d   Z d d	   Z d
 d   Z	 d d   Z
 d d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d  d!   Z d" d#   Z d S)$PullDOMNc             C   s   d d l  m } | |  _ d  d  g |  _ |  j |  _ g  |  _ |  j j |  _ y |  j j |  _ Wn t	 k
 rs Yn X| d i g |  _
 |  j
 d |  _ g  |  _ d  S)Nr   )XML_NAMESPACExml   )Zxml.domr   documentFactory
firstEvent	lastEventelementStackappendpushpopAttributeError_ns_contexts_current_contextpending_events)selfr   r    r   %/usr/lib/python3.5/xml/dom/pulldom.py__init__   s    		zPullDOM.__init__c             C   s   |  j  d } |  j  d =| S)Nr   r   r   )r   )r   resultr   r   r   r   !   s    
zPullDOM.popc             C   s   | |  _  d  S)N)_locator)r   Zlocatorr   r   r   setDocumentLocator&   s    zPullDOM.setDocumentLocatorc             C   sd   t  |  d  s g  |  _ |  j j | p* d | f  |  j j |  j j    | pV d  |  j | <d  S)N_xmlns_attrsxmlns)hasattrr!   r   r   r   copy)r   prefixurir   r   r   startPrefixMapping)   s
    	zPullDOM.startPrefixMappingc             C   s   |  j  j   |  _ d  S)N)r   r   r   )r   r%   r   r   r   endPrefixMapping0   s    zPullDOM.endPrefixMappingc             C   s5  d } t  |  d d   } | d  k	 rW x' | D] \ } } | | j | | f <q+ Wg  |  _ | \ } }	 | r | d  k r |  j | }
 |
 r |
 d |	 } n |	 } |  j r |  j j | |  } q|  j | |  } n0 |  j r |  j j |	  } n |  j d  |	  } x | j   D] \ } } | \ } } | | k rz| d k rK| } n
 d | } |  j j	 | |  } | j
 |  nt | r|  j | }
 |
 r|
 d | } n | } |  j j	 | |  } | j
 |  n |  j j |  } | j |  | | _ qWt | f d  g |  j d <|  j d |  _ |  j |  d  S)Nzhttp://www.w3.org/2000/xmlns/r!   :r"   zxmlns:r   )getattrZ_attrsr!   r   documentZcreateElementNSbuildDocumentcreateElementitemsZcreateAttributeNSZsetAttributeNodeNScreateAttributesetAttributeNodevaluer   r   r   )r   nametagNameattrsZ	xmlns_uriZxmlns_attrsanamer1   r&   Z	localnamer%   nodeZa_uriZa_localnameZqnameattrr   r   r   startElementNS3   sP    				
zPullDOM.startElementNSc             C   s3   t  |  j   f d  g |  j d <|  j d |  _ d  S)Nr   )r   r   r   )r   r2   r3   r   r   r   endElementNSl   s    zPullDOM.endElementNSc             C   s   |  j  r |  j  j |  } n |  j d  |  } xB | j   D]4 \ } } |  j  j |  } | | _ | j |  q= Wt | f d  g |  j d <|  j d |  _ |  j	 |  d  S)Nr   )
r+   r-   r,   r.   r/   r1   r0   r   r   r   )r   r2   r4   r6   r5   r1   r7   r   r   r   startElementp   s    		zPullDOM.startElementc             C   s3   t  |  j   f d  g |  j d <|  j d |  _ d  S)Nr   )r   r   r   )r   r2   r   r   r   
endElement   s    zPullDOM.endElementc             C   sm   |  j  rG |  j  j |  } t | f d  g |  j d <|  j d |  _ n" t | f d  g } |  j j |  d  S)Nr   )r+   createCommentr   r   r   r   )r   sr6   eventr   r   r   comment   s    	zPullDOM.commentc             C   ss   |  j  rJ |  j  j | |  } t | f d  g |  j d <|  j d |  _ n% t | | f d  g } |  j j |  d  S)Nr   )r+   createProcessingInstructionr   r   r   r   )r   targetdatar6   r>   r   r   r   processingInstruction   s    	zPullDOM.processingInstructionc             C   s?   |  j  j |  } t | f d  g |  j d <|  j d |  _ d  S)Nr   )r+   createTextNoder   r   )r   charsr6   r   r   r   ignorableWhitespace   s    zPullDOM.ignorableWhitespacec             C   s?   |  j  j |  } t | f d  g |  j d <|  j d |  _ d  S)Nr   )r+   rD   r	   r   )r   rE   r6   r   r   r   
characters   s    zPullDOM.charactersc             C   s4   |  j  d  k r0 d d  l } | j j j j |  _  d  S)Nr   )r   Zxml.dom.minidomZdomZminidomZDocumentimplementation)r   r   r   r   r   startDocument   s    zPullDOM.startDocumentc       	      C   s8  |  j  j | | d   } | |  _ t | f d  g |  j d <|  j d |  _ |  j |  x |  j D] } | d d t k r | d \ } } } |  j j | |  } t | f | d <nX | d d t	 k r |  j j
 | d d  } t	 | f | d <n t d | d d   | |  j d <| |  _ qa Wd  |  _ | j S)Nr   r   zUnknown pending event )r   ZcreateDocumentr+   r   r   r   r   r   r@   r   r<   AssertionErrorZ
firstChild)	r   r&   Ztagnamer6   e_rA   rB   nr   r   r   r,      s$    		zPullDOM.buildDocumentc             C   s*   t  |  j f d  g |  j d <|  j   d  S)Nr   )r   r+   r   r   )r   r   r   r   endDocument   s    zPullDOM.endDocumentc             C   s   d |  _  d S)z.clear(): Explicitly release parsing structuresN)r+   )r   r   r   r   clear   s    zPullDOM.clear)__name__
__module____qualname__r   r+   r   r   r    r'   r(   r8   r9   r:   r;   r?   rC   rF   rG   rI   r,   rN   rO   r   r   r   r   r
      s&   9		r
   c               @   s4   e  Z d  Z d d   Z d d   Z d d   Z d S)ErrorHandlerc             C   s   t  |  d  S)N)print)r   	exceptionr   r   r   warning   s    zErrorHandler.warningc             C   s
   |  d  S)Nr   )r   rU   r   r   r   error   s    zErrorHandler.errorc             C   s
   |  d  S)Nr   )r   rU   r   r   r   
fatalError   s    zErrorHandler.fatalErrorN)rP   rQ   rR   rV   rW   rX   r   r   r   r   rS      s   rS   c               @   s   e  Z d  Z d d   Z d d   Z d d   Z d d   Z d	 d
   Z d d   Z d d   Z	 d d   Z
 d d   Z d d   Z d S)DOMEventStreamc             C   sG   | |  _  | |  _ | |  _ t |  j d  s9 |  j |  _ |  j   d  S)Nfeed)streamparserbufsizer#   _slurpgetEventreset)r   r[   r\   r]   r   r   r   r      s    			zDOMEventStream.__init__c             C   s?   t    |  _ |  j j t j j j d  |  j j |  j  d  S)Nr   )	r
   pulldomr\   Z
setFeaturer   saxZhandlerZfeature_namespacesZsetContentHandler)r   r   r   r   r`      s    zDOMEventStream.resetc             C   s    |  j    } | r | St  d  S)N)r_   
IndexError)r   posrcr   r   r   __getitem__   s    zDOMEventStream.__getitem__c             C   s    |  j    } | r | St  d  S)N)r_   StopIteration)r   re   r   r   r   __next__   s    zDOMEventStream.__next__c             C   s   |  S)Nr   )r   r   r   r   __iter__   s    zDOMEventStream.__iter__c             C   s   |  j    } | g } x~ | r | \ } } | | k r: d  S| t k rW | d j |  | t k rs | j |  n | t k r | d =|  j    } q Wd  S)Nr   r   r   )r_   r   appendChildr   r   )r   r6   r>   parentstokenZcur_noder   r   r   
expandNode   s    		zDOMEventStream.expandNodec             C   s   |  j  j d s" |  j  j |  j  _ xP |  j  j d st |  j j |  j  } | sa |  j j   d  S|  j j |  q% W|  j  j d d } |  j  j d d |  j  j d <| S)Nr   r   )	ra   r   r   r[   readr]   r\   closerZ   )r   bufre   r   r   r   r_      s    zDOMEventStream.getEventc             C   s)   |  j  j |  j  |  j |  _ |  j   S)z Fallback replacement for getEvent() using the
            standard SAX2 interface, which means we slurp the
            SAX events into memory (no performance gain, but
            we are compatible to all SAX parsers).
        )r\   parser[   _emitr_   )r   r   r   r   r^     s    zDOMEventStream._slurpc             C   s6   |  j  j d d } |  j  j d d |  j  j d <| S)zn Fallback replacement for getEvent() that emits
            the events that _slurp() read previously.
        r   r   )ra   r   )r   re   r   r   r   rr     s    zDOMEventStream._emitc             C   s)   |  j  j   |  `  d |  _ d |  _ d S)z+clear(): Explicitly release parsing objectsN)ra   rO   r\   r[   )r   r   r   r   rO     s    	zDOMEventStream.clearN)rP   rQ   rR   r   r`   rf   rh   ri   rm   r_   r^   rr   rO   r   r   r   r   rY      s   
rY   c               @   sL   e  Z d  Z d d   Z d d   Z d d   Z d d   Z d	 d
   Z d S)SAX2DOMc             C   sA   t  j |  | | |  |  j d } |  j d } | j |  d  S)Nr      r   )r
   r8   r   rj   )r   r2   r3   r4   curNode
parentNoder   r   r   r8   #  s    zSAX2DOM.startElementNSc             C   s>   t  j |  | |  |  j d } |  j d } | j |  d  S)Nr   rt   r   ru   )r
   r:   r   rj   )r   r2   r4   rv   rw   r   r   r   r:   )  s    zSAX2DOM.startElementc             C   sB   t  j |  | |  |  j d d } |  j d } | j |  d  S)Nr   r   r   )r
   rC   r   r   rj   )r   rA   rB   r6   rw   r   r   r   rC   /  s    zSAX2DOM.processingInstructionc             C   s?   t  j |  |  |  j d d } |  j d } | j |  d  S)Nr   r   r   )r
   rF   r   r   rj   )r   rE   r6   rw   r   r   r   rF   5  s    zSAX2DOM.ignorableWhitespacec             C   s?   t  j |  |  |  j d d } |  j d } | j |  d  S)Nr   r   r   )r
   rG   r   r   rj   )r   rE   r6   rw   r   r   r   rG   ;  s    zSAX2DOM.charactersN)rP   rQ   rR   r8   r:   rC   rF   rG   r   r   r   r   rs   !  s
   rs   rt         c             C   s^   | d  k r t  } t |  t  r3 t |  d  } n |  } | sN t j j   } t | | |  S)Nrb)default_bufsize
isinstancestropenr   rb   make_parserrY   )Zstream_or_stringr\   r]   r[   r   r   r   rq   D  s    rq   c             C   sM   d d l  m } t |   } | |   } | s= t j j   } t | | |  S)Nr   )StringIO)ior   lenr   rb   r   rY   )stringr\   r   r]   rp   r   r   r   parseStringO  s    r   i @  i?  )Zxml.saxr   Zxml.sax.handlerr   r   r   r   r   r   r   r	   rb   ZContentHandlerr
   rS   rY   rs   r{   rq   r   r   r   r   r   <module>   s    U!                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  # $Id: __init__.py 3375 2008-02-13 08:05:08Z fredrik $
# elementtree package

# --------------------------------------------------------------------
# The ElementTree toolkit is
#
# Copyright (c) 1999-2008 by Fredrik Lundh
#
# By obtaining, using, and/or copying this software and/or its
# associated documentation, you agree that you have read, understood,
# and will comply with the following terms and conditions:
#
# Permission to use, copy, modify, and distribute this software and
# its associated documentation for any purpose and without fee is
# hereby granted, provided that the above copyright notice appears in
# all copies, and that both that copyright notice and this permission
# notice appear in supporting documentation, and that the name of
# Secret Labs AB or the author not be used in advertising or publicity
# pertaining to distribution of the software without specific, written
# prior permission.
#
# SECRET LABS AB AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD
# TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANT-
# ABILITY AND FITNESS.  IN NO EVENT SHALL SECRET LABS AB OR THE AUTHOR
# BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY
# DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
# OF THIS SOFTWARE.
# --------------------------------------------------------------------

# Licensed to PSF under a Contributor Agreement.
# See http://www.python.org/psf/license for licensing details.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            #
# ElementTree
# $Id: ElementInclude.py 3375 2008-02-13 08:05:08Z fredrik $
#
# limited xinclude support for element trees
#
# history:
# 2003-08-15 fl   created
# 2003-11-14 fl   fixed default loader
#
# Copyright (c) 2003-2004 by Fredrik Lundh.  All rights reserved.
#
# fredrik@pythonware.com
# http://www.pythonware.com
#
# --------------------------------------------------------------------
# The ElementTree toolkit is
#
# Copyright (c) 1999-2008 by Fredrik Lundh
#
# By obtaining, using, and/or copying this software and/or its
# associated documentation, you agree that you have read, understood,
# and will comply with the following terms and conditions:
#
# Permission to use, copy, modify, and distribute this software and
# its associated documentation for any purpose and without fee is
# hereby granted, provided that the above copyright notice appears in
# all copies, and that both that copyright notice and this permission
# notice appear in supporting documentation, and that the name of
# Secret Labs AB or the author not be used in advertising or publicity
# pertaining to distribution of the software without specific, written
# prior permission.
#
# SECRET LABS AB AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD
# TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANT-
# ABILITY AND FITNESS.  IN NO EVENT SHALL SECRET LABS AB OR THE AUTHOR
# BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY
# DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
# OF THIS SOFTWARE.
# --------------------------------------------------------------------

# Licensed to PSF under a Contributor Agreement.
# See http://www.python.org/psf/license for licensing details.

##
# Limited XInclude support for the ElementTree package.
##

import copy
from . import ElementTree

XINCLUDE = "{http://www.w3.org/2001/XInclude}"

XINCLUDE_INCLUDE = XINCLUDE + "include"
XINCLUDE_FALLBACK = XINCLUDE + "fallback"

##
# Fatal include error.

class FatalIncludeError(SyntaxError):
    pass

##
# Default loader.  This loader reads an included resource from disk.
#
# @param href Resource reference.
# @param parse Parse mode.  Either "xml" or "text".
# @param encoding Optional text encoding (UTF-8 by default for "text").
# @return The expanded resource.  If the parse mode is "xml", this
#    is an ElementTree instance.  If the parse mode is "text", this
#    is a Unicode string.  If the loader fails, it can return None
#    or raise an OSError exception.
# @throws OSError If the loader fails to load the resource.

def default_loader(href, parse, encoding=None):
    if parse == "xml":
        with open(href, 'rb') as file:
            data = ElementTree.parse(file).getroot()
    else:
        if not encoding:
            encoding = 'UTF-8'
        with open(href, 'r', encoding=encoding) as file:
            data = file.read()
    return data

##
# Expand XInclude directives.
#
# @param elem Root element.
# @param loader Optional resource loader.  If omitted, it defaults
#     to {@link default_loader}.  If given, it should be a callable
#     that implements the same interface as <b>default_loader</b>.
# @throws FatalIncludeError If the function fails to include a given
#     resource, or if the tree contains malformed XInclude elements.
# @throws OSError If the function fails to load a given resource.

def include(elem, loader=None):
    if loader is None:
        loader = default_loader
    # look for xinclude elements
    i = 0
    while i < len(elem):
        e = elem[i]
        if e.tag == XINCLUDE_INCLUDE:
            # process xinclude directive
            href = e.get("href")
            parse = e.get("parse", "xml")
            if parse == "xml":
                node = loader(href, parse)
                if node is None:
                    raise FatalIncludeError(
                        "cannot load %r as %r" % (href, parse)
                        )
                node = copy.copy(node)
                if e.tail:
                    node.tail = (node.tail or "") + e.tail
                elem[i] = node
            elif parse == "text":
                text = loader(href, parse, e.get("encoding"))
                if text is None:
                    raise FatalIncludeError(
                        "cannot load %r as %r" % (href, parse)
                        )
                if i:
                    node = elem[i-1]
                    node.tail = (node.tail or "") + text + (e.tail or "")
                else:
                    elem.text = (elem.text or "") + text + (e.tail or "")
                del elem[i]
                continue
            else:
                raise FatalIncludeError(
                    "unknown parse type in xi:include tag (%r)" % parse
                )
        elif e.tag == XINCLUDE_FALLBACK:
            raise FatalIncludeError(
                "xi:fallback tag must be child of xi:include (%r)" % e.tag
                )
        else:
            include(e, loader)
        i = i + 1
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
[                 @   s  d  Z  d d l m Z m Z m Z d d l m Z m Z m Z d d l m	 Z	 d d l
 m Z m Z d d l m Z e j Z e j Z e j Z e j j Z e j j Z e j j Z e j j Z e j   Z d e j d d	  d
 e j d d  d e j d d  d e j d d  d e j d d  d e j d d  d e j d d  d e j d d  d e j d d  i	 Z Gd d   d e  Z d d   Z d d   Z Gd  d!   d!  Z e e e f Z  Gd" d#   d# e  Z! Gd$ d%   d% e  Z" Gd& d'   d' e"  Z# Gd( d)   d) e"  Z$ d* Z% d+ e% Z& Gd, d-   d- e  Z' Gd. d/   d/  Z( Gd0 d1   d1 e( e  Z) Gd2 d3   d3 e( e'  Z* Gd4 d5   d5 e+  Z, Gd6 d7   d7 e  Z- d8 d9 d:  Z. d8 d; d<  Z/ d8 d= d>  Z0 d8 d? d@  Z1 dA dB   Z2 d S)CzFacility to use the Expat parser to load a minidom instance
from a string or file.

This avoids all the overhead of SAX and pulldom to gain performance.
    )
xmlbuilderminidomNode)EMPTY_NAMESPACEEMPTY_PREFIXXMLNS_NAMESPACE)expat)_append_child_set_attribute_node)
NodeFilterZCDATANZcdataENUMZenumerationZENTITYentityZENTITIESentitiesIDidZIDREFZidrefZIDREFSZidrefsZNMTOKENZnmtokenZNMTOKENSZnmtokensc               @   s   e  Z d  Z d Z d d d  Z d d   Z d	 d
   Z d d   Z d d   Z d d   Z	 d d   Z
 d d   Z d d   Z d S)ElementInfo
_attr_info_modeltagNameNc             C   s   | |  _  g  |  _ | |  _ d  S)N)r   r   r   )selfr   model r   */usr/lib/python3.5/xml/dom/expatbuilder.py__init__?   s    		zElementInfo.__init__c             C   s   |  j  |  j |  j f S)N)r   r   r   )r   r   r   r   __getstate__D   s    zElementInfo.__getstate__c             C   s   | \ |  _  |  _ |  _ d  S)N)r   r   r   )r   stater   r   r   __setstate__G   s    zElementInfo.__setstate__c             C   sY   xO |  j  D]D } | d | k r
 | d } | d d k rB t d St | d Sq
 Wt j S)N      r   (r   r    )r   _typeinfo_mapr   _no_type)r   anameinfotr   r   r   getAttributeTypeJ   s    
zElementInfo.getAttributeTypec             C   s   t  j S)N)r   r"   )r   namespaceURI	localNamer   r   r   getAttributeTypeNST   s    zElementInfo.getAttributeTypeNSc             C   s:   |  j  r2 |  j  d } | t j j t j j f k Sd Sd  S)Nr   F)r   r   r   ZXML_CTYPE_ANYZXML_CTYPE_MIXED)r   typer   r   r   isElementContentW   s
    	zElementInfo.isElementContentc             C   s(   |  j  r  |  j  d t j j k Sd Sd  S)Nr   F)r   r   r   ZXML_CTYPE_EMPTY)r   r   r   r   isEmpty_   s    	zElementInfo.isEmptyc             C   s6   x/ |  j  D]$ } | d | k r
 | d d k Sq
 Wd S)Nr   r   r   Fr    )r   )r   r#   r$   r   r   r   isIde   s    zElementInfo.isIdc             C   s   |  j  | | f  S)N)r-   )r   ZeuriZenameZaurir#   r   r   r   isIdNSk   s    zElementInfo.isIdNS)r   r   r   )__name__
__module____qualname__	__slots__r   r   r   r&   r)   r+   r,   r-   r.   r   r   r   r   r   <   s   
r   c             C   s   |  j  | |  S)N)_intern_setdefault)buildersr   r   r   _interno   s    r6   c             C   s   d | k s t   | j d  } |  j } t |  d k r | \ } } } | | |  } d | | f } | | |  } | | |  } nJ t |  d k r | \ } } t } | | |  } } n t d |   | | |  | | | f S)N    z%s:%sr   z4Unsupported syntax: spaces in URIs not supported: %r)AssertionErrorsplitr3   lenr   
ValueError)r4   namepartsinternuri	localnameprefixqnamer   r   r   _parse_ns_namer   s    	rD   c               @   si  e  Z d  Z d Z d d d  Z d d   Z d d   Z d	 d
   Z d d   Z d d   Z	 d d   Z
 d d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d d    Z d! d"   Z d# d$   Z d% d&   Z d' d(   Z d) d*   Z d+ d,   Z d- d.   Z d/ d0   Z d1 d2   Z d3 d4   Z d5 d6   Z d7 d8   Z d9 d:   Z d S);ExpatBuilderzPDocument builder that uses Expat to build a ParsedXML.DOM document
    instance.Nc             C   st   | d  k r t  j   } | |  _ |  j j d  k	 rK t |  j j  |  _ n d  |  _ t |  _ d  |  _ |  j	   d  S)N)
r   ZOptions_optionsfilterFilterVisibilityController_filterr   _finish_start_element_parserreset)r   optionsr   r   r   r      s    				zExpatBuilder.__init__c             C   s
   t  j   S)zCreate a new parser object.)r   ParserCreate)r   r   r   r   createParser   s    zExpatBuilder.createParserc             C   se   |  j  s^ |  j   |  _  |  j  j j |  _ d |  j  _ d |  j  _ d |  j  _ |  j |  j   |  j  S)z7Return the parser object, creating a new one if needed.T)	rK   rO   r?   
setdefaultr3   Zbuffer_textZordered_attributesZspecified_attributesinstall)r   r   r   r   	getParser   s    	zExpatBuilder.getParserc             C   s@   t  j t d d  |  _ |  j |  _ |  j j |  _ d |  _ d S)z6Free all data structures used during DOM construction.NF)theDOMImplementationZcreateDocumentr   documentcurNode
_elem_info_cdata)r   r   r   r   rL      s
    zExpatBuilder.resetc             C   s   |  j  | _ |  j | _ |  j | _ |  j | _ |  j j	 rH |  j
 | _ |  j | _ |  j j rl |  j | _ |  j j r |  j | _ |  j | _ |  j | _ n |  j | _ |  j | _ |  j | _ |  j | _ |  j | _  d S)z>Install the callbacks needed to build the DOM into the parser.N)!start_doctype_decl_handlerStartDoctypeDeclHandlerfirst_element_handlerStartElementHandlerend_element_handlerEndElementHandler
pi_handlerProcessingInstructionHandlerrF   r   entity_decl_handlerEntityDeclHandlernotation_decl_handlerNotationDeclHandlercommentscomment_handlerCommentHandlerZcdata_sectionsstart_cdata_section_handlerStartCdataSectionHandlerend_cdata_section_handlerEndCdataSectionHandlercharacter_data_handler_cdataCharacterDataHandlercharacter_data_handlerexternal_entity_ref_handlerExternalEntityRefHandlerxml_decl_handlerZXmlDeclHandlerelement_decl_handlerZElementDeclHandlerattlist_decl_handlerZAttlistDeclHandler)r   parserr   r   r   rQ      s$    zExpatBuilder.installc             C   s   |  j    } d } yf xO | j d  } | s. P| j | d  | r] |  j j r] |  j |  d } q W| j d d  Wn t k
 r Yn X|  j } |  j   d |  _ | S)	zIParse a document from a file object, returning the document
        node.T   i   r   F Ni @  )	rR   readParserT   documentElement_setup_subsetParseEscaperL   rK   )r   filers   Zfirst_bufferbufferdocr   r   r   	parseFile   s$    
	
	zExpatBuilder.parseFilec             C   sb   |  j    } y! | j | d  |  j |  Wn t k
 rA Yn X|  j } |  j   d |  _ | S)z<Parse a document from a string, returning the document node.TN)rR   rw   ry   rz   rT   rL   rK   )r   stringrs   r}   r   r   r   parseString   s    	
	zExpatBuilder.parseStringc             C   sA   |  j  j r= t   } | j |  | j   } | |  j  j _ d S)z/Load the internal subset if there might be one.N)rT   doctypeInternalSubsetExtractorr   	getSubsetinternalSubset)r   r|   Z	extractorsubsetr   r   r   ry      s
    	zExpatBuilder._setup_subsetc             C   s   |  j  j j | | |  } |  j  | _ t |  j  |  | |  j  _ |  j r |  j j |  t k r d  |  j  _ |  j  j	 d =d  } d  |  j
 _ d  |  j
 _ | r | d  k	 r g  | j _ g  | j _ d  |  j
 _ d  |  j
 _ |  j |  j
 _ d  S)Nr   )rT   implementationZcreateDocumentTypeownerDocumentr	   r   rI   
acceptNodeFILTER_REJECT
childNodesrK   ra   rc   r   _seq	notationsrf   r_   end_doctype_decl_handlerEndDoctypeDeclHandler)r   ZdoctypeNamesystemIdpublicIdhas_internal_subsetr   r   r   r   rX      s$    !z'ExpatBuilder.start_doctype_decl_handlerc             C   sI   |  j  j r |  j |  j _ |  j |  j _ |  j p9 |  j sE t	 |  _
 d  S)N)rF   rd   re   rK   rf   r^   r_   rV   rI   r   _finish_end_element)r   r   r   r   r     s
    z%ExpatBuilder.end_doctype_decl_handlerc             C   sZ   |  j  j | |  } t |  j |  |  j rV |  j j |  t k rV |  j j |  d  S)N)rT   ZcreateProcessingInstructionr	   rU   rI   r   r   removeChild)r   targetdatanoder   r   r   r^     s    !zExpatBuilder.pi_handlerc             C   s   |  j  j } |  j rd |  j rF | d j t k rF | d j |  d  S|  j j |  } d |  _ n^ | r | d j t	 k r | d } | j
 | } | | _
 d  St j   } | | _
 |  j | _ t |  j  |  d  S)Nr   Tr   r   r   r   )rU   r   rW   _cdata_continuenodeTypeCDATA_SECTION_NODEZ
appendDatarT   ZcreateCDATASection	TEXT_NODEr   r   Textr   r	   )r   r   r   r   valuer   r   r   rk     s"    		
		z)ExpatBuilder.character_data_handler_cdatac             C   s   |  j  j } | rC | d j t k rC | d } | j | | _ d  St j   } | j | | _ |  j | _ t	 |  j  |  d  S)Nr   r   r   )
rU   r   r   r   r   r   r   rT   r   r	   )r   r   r   r   r   r   r   rm   &  s    
z#ExpatBuilder.character_data_handlerc       
      C   s   | r
 d  S|  j  j s d  S|  j j | | | |  } | d  k	 rc |  j j |  }	 | j j |	  |  j j j j j |  |  j	 r |  j	 j
 |  t k r |  j j j j d =d  S)Nr   r   )rF   r   rT   Z_create_entityZcreateTextNoder   appendr   r   rI   r   r   )
r   Z
entityNameZis_parameter_entityr   baser   r   notationNamer   childr   r   r   r`   1  s    !z ExpatBuilder.entity_decl_handlerc             C   si   |  j  j | | |  } |  j  j j j j |  |  j re |  j j |  t k re |  j  j j j d =d  S)Nr   r   )	rT   Z_create_notationr   r   r   r   rI   r   FILTER_ACCEPT)r   r   r   r   r   r   r   r   r   rb   C  s    !z"ExpatBuilder.notation_decl_handlerc             C   sW   |  j  j |  } t |  j |  |  j rS |  j j |  t k rS |  j j |  d  S)N)rT   ZcreateCommentr	   rU   rI   r   r   r   )r   r   r   r   r   r   re   I  s    !zExpatBuilder.comment_handlerc             C   s   d |  _  d |  _ d  S)NTF)rW   r   )r   r   r   r   rg   O  s    	z(ExpatBuilder.start_cdata_section_handlerc             C   s   d |  _  d |  _ d  S)NF)rW   r   )r   r   r   r   ri   S  s    	z&ExpatBuilder.end_cdata_section_handlerc             C   s   d S)Nr   r   )r   contextr   r   r   r   r   r   rn   W  s    z(ExpatBuilder.external_entity_ref_handlerc             C   sH   |  j  d  k r" |  j r" t |  _ |  j |  j   _ |  j | |  d  S)N)rI   rV   r   r   start_element_handlerrR   r[   )r   r=   
attributesr   r   r   rZ   Z  s    	z"ExpatBuilder.first_element_handlerc             C   s   |  j  j |  } t |  j |  | |  _ | r xl t d t |  d  D]R } t j | | t d  t	  } | | d } | | _
 |  j  | _ t | |  qJ W| |  j  j k	 r |  j |  d  S)Nr   r   r   )rT   ZcreateElementr	   rU   ranger;   r   Attrr   r   r   r   r
   rx   rJ   )r   r=   r   r   iar   r   r   r   r   `  s    		z"ExpatBuilder.start_element_handlerc             C   s   |  j  r | |  j j k r d  S|  j  j |  } | t k rJ t |   n | t k rc t |   n d  S| j |  _	 | j j
 |  | j   d  S)N)rI   rT   rx   startContainerr   RejecterFILTER_SKIPSkipper
parentNoderU   r   unlink)r   r   Zfiltr   r   r   rJ   q  s    	z"ExpatBuilder._finish_start_elementc             C   s&   |  j  } | j |  _  |  j |  d  S)N)rU   r   r   )r   r=   rU   r   r   r   r\     s    	z ExpatBuilder.end_element_handlerc             C   s   |  j  j | j  } | r+ |  j | |  |  j r| | |  j j k rJ d  S|  j j |  t k r| |  j	 j
 |  | j   d  S)N)rV   getr   _handle_white_text_nodesrI   rT   rx   r   r   rU   r   r   )r   rU   r$   r   r   r   r     s    	z ExpatBuilder._finish_end_elementc             C   s   |  j  j s | j   r d  Sg  } x= | j D]2 } | j t k r- | j j   r- | j |  q- Wx | D] } | j	 |  qj Wd  S)N)
rF   Zwhitespace_in_element_contentr+   r   r   r   r   stripr   r   )r   r   r$   Lr   r   r   r   r     s    z%ExpatBuilder._handle_white_text_nodesc             C   sY   |  j  j |  } | d  k r7 t | |  |  j  | <n | j d  k sL t  | | _ d  S)N)rV   r   r   r   r9   )r   r=   r   r$   r   r   r   rq     s
    z!ExpatBuilder.element_decl_handlerc          	   C   sc   |  j  j |  } | d  k r7 t |  } | |  j  | <| j j d  | d  d  | d | | g  d  S)Nr   )rV   r   r   r   r   )r   elemr=   r*   defaultZrequiredr$   r   r   r   rr     s    	z!ExpatBuilder.attlist_decl_handlerc             C   sI   | |  j  _ | |  j  _ | d k rE | r9 d |  j  _ n d |  j  _ d  S)Nr   TF)rT   versionencoding
standalone)r   r   r   r   r   r   r   rp     s    zExpatBuilder.xml_decl_handler) r/   r0   r1   __doc__r   rO   rR   rL   rQ   r~   r   ry   rX   r   r^   rk   rm   r`   rb   re   rg   ri   rn   rZ   r   rJ   r\   r   r   rq   rr   rp   r   r   r   r   rE      s:   rE   c               @   s   e  Z d  Z d Z d
 Z d d   Z d d   Z d d   Z e j	 e
 j e j e
 j e j e
 j e j e
 j e j e
 j e j e
 j e j e
 j e j e
 j e j e
 j e j e
 j e j e
 j e j  e
 j! i Z" d	 S)rH   zoWrapper around a DOMBuilderFilter which implements the checks
    to make the whatToShow filter attribute work.rG   c             C   s   | |  _  d  S)N)rG   )r   rG   r   r   r   r     s    z#FilterVisibilityController.__init__c             C   sr   |  j  | j } |  j j | @rj |  j j |  } | t k rD t  | t k rf t d t	 |    | St
 Sd  S)Nz)startContainer() returned illegal value: )_nodetype_maskr   rG   
whatToShowr   FILTER_INTERRUPTrz   _ALLOWED_FILTER_RETURNSr<   reprr   )r   r   maskvalr   r   r   r     s    z)FilterVisibilityController.startContainerc             C   s   |  j  | j } |  j j | @r |  j j |  } | t k rD t  | t k r | j } x( | j	 d  d   D] } | j
 |  qm Wt S| t k r t d t |    | St Sd  S)Nz%acceptNode() returned illegal value: )r   r   rG   r   r   r   rz   r   r   r   ZappendChildr   r   r<   r   r   )r   r   r   r   parentr   r   r   r   r     s    	z%FilterVisibilityController.acceptNodeN)rG   )#r/   r0   r1   r   r2   r   r   r   r   ZELEMENT_NODEr   ZSHOW_ELEMENTZATTRIBUTE_NODEZSHOW_ATTRIBUTEr   Z	SHOW_TEXTr   ZSHOW_CDATA_SECTIONZENTITY_REFERENCE_NODEZSHOW_ENTITY_REFERENCEZENTITY_NODEZSHOW_ENTITYZPROCESSING_INSTRUCTION_NODEZSHOW_PROCESSING_INSTRUCTIONZCOMMENT_NODEZSHOW_COMMENTDOCUMENT_NODEZSHOW_DOCUMENTZDOCUMENT_TYPE_NODEZSHOW_DOCUMENT_TYPEZDOCUMENT_FRAGMENT_NODEZSHOW_DOCUMENT_FRAGMENTZNOTATION_NODEZSHOW_NOTATIONr   r   r   r   r   rH     s"   rH   c               @   s"   e  Z d  Z d Z d d   Z d S)	FilterCrutch_builder_level
_old_start_old_endc             C   sO   d |  _  | |  _ | j } | j |  _ | j |  _ |  j | _ |  j | _ d  S)Nr   )	r   r   rK   r[   r   r]   r   r   r\   )r   r4   rs   r   r   r   r     s    			zFilterCrutch.__init__N)r   r   r   r   )r/   r0   r1   r2   r   r   r   r   r   r     s   r   c               @   s:   e  Z d  Z f  Z d d   Z d d   Z d d   Z d S)r   c             C   s>   t  j |  |  | j } x d D] } t | | d   q  Wd  S)Nr_   rf   rl   rh   rj   ro   )r_   rf   rl   rh   rj   ro   )r   r   rK   setattr)r   r4   rs   r=   r   r   r   r     s    	    
zRejecter.__init__c             G   s   |  j  d |  _  d  S)Nr   )r   )r   argsr   r   r   r     s    zRejecter.start_element_handlerc             G   sZ   |  j  d k rF |  j j } |  j j |  |  j | _ |  j | _ n |  j  d |  _  d  S)Nr   r   )r   r   rK   rQ   r   r[   r   r]   )r   r   rs   r   r   r   r\      s    zRejecter.end_element_handlerN)r/   r0   r1   r2   r   r   r\   r   r   r   r   r     s   r   c               @   s.   e  Z d  Z f  Z d d   Z d d   Z d S)r   c             G   s?   |  j  j } |  j |   |  j  j | k	 r; |  j d |  _ d  S)Nr   )r   rU   r   r   )r   r   r   r   r   r   r   -  s    zSkipper.start_element_handlerc             G   s`   |  j  d k r? |  j |  j j _ |  j |  j j _ d  |  _ n |  j  d |  _  |  j |   d  S)Nr   r   )r   r   r   rK   r[   r   r]   )r   r   r   r   r   r\   3  s    zSkipper.end_element_handlerN)r/   r0   r1   r2   r   r\   r   r   r   r   r   *  s   r   z8http://xml.python.org/entities/fragment-builder/internalz<!DOCTYPE wrapper
  %%s [
  <!ENTITY fragment-builder-internal
    SYSTEM "%s">
%%s
]>
<wrapper %%s
>&fragment-builder-internal;</wrapper>c               @   sm   e  Z d  Z d Z d d d  Z d d   Z d d   Z d	 d
   Z d d   Z d d   Z	 d d   Z
 d S)FragmentBuilderzBuilder which constructs document fragments given XML source
    text and a context node.

    The context node is expected to provide information about the
    namespace declarations which are in scope at the start of the
    fragment.
    Nc             C   sM   | j  t k r$ | |  _ | |  _ n | j |  _ | |  _ t j |  |  d  S)N)r   r   originalDocumentr   r   rE   r   )r   r   rM   r   r   r   r   [  s    		zFragmentBuilder.__init__c             C   s   t  j |   d  |  _ d  S)N)rE   rL   fragment)r   r   r   r   rL   d  s    zFragmentBuilder.resetc             C   s   |  j  | j    S)zRParse a document fragment from a file object, returning the
        fragment node.)r   rv   )r   r{   r   r   r   r~   h  s    zFragmentBuilder.parseFilec       	   	   C   s   | |  _  |  j   } |  j j } d } | r} | j p? |  j   } | j rd d | j | j f } q | j r d | j } n d } |  j   } t	 | | | f } y | j
 | d  Wn |  j     Yn X|  j } |  j   | S)zMParse a document fragment from a string, returning the
        fragment node.ru   zPUBLIC "%s" "%s"zSYSTEM "%s"r   )_sourcerR   r   r   r   _getDeclarationsr   r   _getNSattrs_FRAGMENT_BUILDER_TEMPLATErw   rL   r   )	r   r   rs   r   Zidentr   ZnsattrsrT   r   r   r   r   r   m  s,    			
	
zFragmentBuilder.parseStringc             C   s{  |  j  j j } d } | rwx t | j j  D]s } | j j |  } | rV | d } d | | j f } | j r d | | j | j	 f } q. d | | j	 f } q. Wx t | j
 j  D] } | j
 j |  } | r | d } d | | j f } | j rd | | j | j	 f } n5 | j	 r7d | | j	 f } n d	 | | j j f } | j rid
 | | j f } | d } q W| S)zRe-create the internal subset from the DocumentType node.

        This is only needed if we don't already have the
        internalSubset as a string.
        ru   z
  z%s<!NOTATION %sz!%s PUBLIC "%s"
             "%s">z%s SYSTEM "%s">z%s<!ENTITY %sz %s PUBLIC "%s"
             "%s"z%s SYSTEM "%s"z%s "%s"z%s NOTATION %s>)r   r   r   r   r   ZlengthitemnodeNamer   r   r   Z
firstChildr   r   )r   r   r5   r   Znotationr   r   r   r   r     s6    
	
			z FragmentBuilder._getDeclarationsc             C   s   d S)Nru   r   )r   r   r   r   r     s    zFragmentBuilder._getNSattrsc             C   s   | t  k r |  j } |  j } |  j j |  } |  j |  _ |  j j   |  _ |  j |  _ z | j |  j	 d  Wd  | |  _ | |  _ d  |  _	 Xd St
 j |  | | | |  Sd  S)Nr   r   )$_FRAGMENT_BUILDER_INTERNAL_SYSTEM_IDrT   rU   rK   ZExternalEntityParserCreater   ZcreateDocumentFragmentr   rw   r   rE   rn   )r   r   r   r   r   Zold_documentZold_cur_noders   r   r   r   rn     s    				
z+FragmentBuilder.external_entity_ref_handler)r/   r0   r1   r   r   rL   r~   r   r   r   rn   r   r   r   r   r   R  s   	$r   c               @   s^   e  Z d  Z d Z d d   Z d d   Z d d   Z d d	   Z d
 d   Z d d   Z	 d S)
Namespacesz7Mix-in class for builders; adds support for namespaces.c             C   s   g  |  _  d  S)N)_ns_ordered_prefixes)r   r   r   r   _initNamespaces  s    zNamespaces._initNamespacesc             C   s   t  j d d  } d | _ | S)z'Create a new namespace-handling parser.Znamespace_separatorr7   T)r   rN   Znamespace_prefixes)r   rs   r   r   r   rO     s    	zNamespaces.createParserc             C   s,   t  j |  |  |  j j r( |  j | _ d S)z.Insert the namespace-handlers onto the parser.N)rE   rQ   rF   Znamespace_declarationsstart_namespace_decl_handlerZStartNamespaceDeclHandler)r   rs   r   r   r   rQ     s    zNamespaces.installc             C   s   |  j  j | | f  d S)z/Push this namespace declaration on our storage.N)r   r   )r   rB   r@   r   r   r   r     s    z'Namespaces.start_namespace_decl_handlerc             C   s'  d | k r* t  |  |  \ } } } } n t } | } d  } t } t j | | | |  } |  j | _ t |  j |  | |  _ |  j	 rx |  j	 D]t \ } } | r t j
 t |  d |  t | d  } n t j
 d t d t  } | | _ |  j | _ t | |  q W|  j	 d  d   =| r#| j   | j }	 | j }
 x t d t |  d  D] } | | } | | d } d | k rt  |  |  \ } } } } t j
 | | | |  } | |	 | <| |
 | | f <n2 t j
 | t | t  } | |	 | <| |
 t | f <|  j | _ | | _ | | _ qUWd  S)Nr7   zxmlns:xmlnsr   r   r   )rD   r   r   r   ZElementrT   r   r	   rU   r   r   r6   r   r   r
   Z_ensure_attributes_attrs_attrsNSr   r;   ZownerElement)r   r=   r   r@   rA   rB   rC   r   r   r   r   r   r#   r   r   r   r   r     sP    			
		


	z Namespaces.start_element_handlerc             C   s   |  j  } d | k rl t |  |  \ } } } } | j | k r] | j | k r] | j | k s t d   n6 | j | k s t d   | j t k s t d   | j |  _  |  j	 |  d  S)Nr7   z$element stack messed up! (namespace)z&element stack messed up - bad nodeNamez*element stack messed up - bad namespaceURI)
rU   rD   r'   r(   rB   r9   r   r   r   r   )r   r=   rU   r@   rA   rB   rC   r   r   r   r\     s    			zNamespaces.end_element_handlerN)
r/   r0   r1   r   r   rO   rQ   r   r   r\   r   r   r   r   r     s   5r   c               @   s"   e  Z d  Z d Z d d   Z d S)ExpatBuilderNSz*Document builder that supports namespaces.c             C   s   t  j |   |  j   d  S)N)rE   rL   r   )r   r   r   r   rL   )  s    zExpatBuilderNS.resetN)r/   r0   r1   r   rL   r   r   r   r   r   &  s   r   c               @   s.   e  Z d  Z d Z d d   Z d d   Z d S)FragmentBuilderNSz*Fragment builder that supports namespaces.c             C   s   t  j |   |  j   d  S)N)r   rL   r   )r   r   r   r   rL   1  s    zFragmentBuilderNS.resetc             C   s   d } |  j  } g  } x | r t | d  r x~ | j j   D]m \ } } | | k rX q= | j |  | rx d | } n d } | r d | | | f } q= d | | f } q= W| j } q W| S)zNReturn string of namespace attributes from this element and
        ancestors.ru   _ns_prefix_urizxmlns:r   z%s
    %s='%s'z %s='%s')r   hasattrr   itemsr   r   )r   attrsr   r   rB   r@   Zdeclnamer   r   r   r   5  s"    		zFragmentBuilderNS._getNSattrsN)r/   r0   r1   r   rL   r   r   r   r   r   r   .  s   r   c               @   s   e  Z d  Z d Z d S)rz   zEException raised to short-circuit parsing in InternalSubsetExtractor.N)r/   r0   r1   r   r   r   r   r   rz   S  s   rz   c               @   sp   e  Z d  Z d Z d Z d d   Z d d   Z d d   Z d	 d
   Z d d   Z	 d d   Z
 d d   Z d S)r   zBXML processor which can rip out the internal document type subset.Nc             C   s   |  j  S)z'Return the internal subset as a string.)r   )r   r   r   r   r   \  s    z!InternalSubsetExtractor.getSubsetc             C   s-   y t  j |  |  Wn t k
 r( Yn Xd  S)N)rE   r~   rz   )r   r{   r   r   r   r~   `  s    z!InternalSubsetExtractor.parseFilec             C   s-   y t  j |  |  Wn t k
 r( Yn Xd  S)N)rE   r   rz   )r   r   r   r   r   r   f  s    z#InternalSubsetExtractor.parseStringc             C   s   |  j  | _ |  j | _ d  S)N)rX   rY   r   r[   )r   rs   r   r   r   rQ   l  s    zInternalSubsetExtractor.installc             C   sF   | r9 |  j    } g  |  _ |  j j | _ |  j | _ n	 t    d  S)N)rR   r   r   ZDefaultHandlerr   r   rz   )r   r=   r   r   r   rs   r   r   r   rX   p  s    	z2InternalSubsetExtractor.start_doctype_decl_handlerc             C   s@   d j  |  j  j d d  j d d  } | |  _ t    d  S)Nru   z

)joinr   replacerz   )r   r5   r   r   r   r   z  s    *	z0InternalSubsetExtractor.end_doctype_decl_handlerc             C   s   t     d  S)N)rz   )r   r=   r   r   r   r   r     s    z-InternalSubsetExtractor.start_element_handler)r/   r0   r1   r   r   r   r~   r   rQ   rX   r   r   r   r   r   r   r   W  s   
r   Tc          	   C   sh   | r t    } n	 t   } t |  t  rU t |  d   } | j |  } Wd QRXn | j |   } | S)z{Parse a document, returning the resulting Document node.

    'file' may be either a file name or an open file object.
    rbN)r   rE   
isinstancestropenr~   )r{   
namespacesr4   fpresultr   r   r   parse  s    	r   c             C   s(   | r t    } n	 t   } | j |   S)zOParse a document from a string, returning the resulting
    Document node.
    )r   rE   r   )r   r   r4   r   r   r   r     s    	r   c          	   C   sn   | r t  |  } n t |  } t |  t  r[ t |  d   } | j |  } Wd QRXn | j |   } | S)zParse a fragment of a document, given the context from which it
    was originally extracted.  context should be the parent of the
    node(s) which are in the fragment.

    'file' may be either a file name or an open file object.
    r   N)r   r   r   r   r   r~   )r{   r   r   r4   r   r   r   r   r   parseFragment  s    r   c             C   s.   | r t  |  } n t |  } | j |   S)zParse a fragment of a document from a string, given the context
    from which it was originally extracted.  context should be the
    parent of the node(s) which are in the fragment.
    )r   r   r   )r   r   r   r4   r   r   r   parseFragmentString  s    r   c             C   s!   |  j  r t |   St |   Sd S)z,Create a builder based on an Options object.N)r   r   rE   )rM   r   r   r   makeBuilder  s    	
r   )3r   Zxml.domr   r   r   r   r   r   Zxml.parsersr   Zxml.dom.minidomr	   r
   Zxml.dom.NodeFilterr   r   r   r   ZDOMBuilderFilterr   r   r   r   ZgetDOMImplementationrS   ZTypeInfor!   objectr   r6   rD   rE   r   rH   r   r   r   r   r   r   r   r   r   	Exceptionrz   r   r   r   r   r   r   r   r   r   r   <module>   s\   			3 B:u_%,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
[                @   s1  d  Z  d d l Z d d l Z d d l m Z m Z m Z m Z d d l Td d l	 m
 Z
 m Z e j j j e j j j f Z Gd d   d e j j  Z e e d d	 d
 e e d d	 d e e d d	 d d d   Z d d   Z d d   Z d d   Z d d   Z Gd d   d e  Z Gd d   d e  Z e e d d	 d e e d d	 d e e d  d	 d! Gd" d#   d# e  Z e e d$ d	 d% e Z Gd& d'   d' e  Z e d d  Z Gd( d)   d) e  Z e e d* d	 d+ e e d d	 d, d- d.   Z Gd/ d0   d0  Z  Gd1 d2   d2 e  e  Z! Gd3 d4   d4 e  e  Z" e e" d$ d	 d5 Gd6 d7   d7 e"  Z# e e# d8 d	 d9 e e# d: d	 d; d< d=   Z$ d> d?   Z% Gd@ dA   dA e"  Z& GdB dC   dC e#  Z' GdD dE   dE e  Z( e e( d$ d	 dF GdG dH   dH  Z) GdI dJ   dJ e) e  e  Z* GdK dL   dL e) e  Z+ GdM dN   dN e) e  e  Z, GdO dP   dP e
  Z- GdQ dR   dR e  Z. dS dT   Z/ GdU dV   dV e e  Z0 e e0 dW d	 dX dY dZ   Z1 d[ d\   Z2 d] d^   Z3 d d d_ d`  Z4 d da db  Z5 d dc dd  Z6 d S)eac  Simple implementation of the Level 1 DOM.

Namespaces and other minor Level 2 features are also supported.

parse("foo.xml")

parseString("<foo><bar/></foo>")

Todo:
=====
 * convenience methods for getting elements and text.
 * more testing
 * bring some of the writer and linearizer code into conformance with this
        interface
 * SAX 2 namespaces
    N)EMPTY_NAMESPACEEMPTY_PREFIXXMLNS_NAMESPACEdomreg)*)DOMImplementationLS
DocumentLSc               @   sT  e  Z d  Z d Z d Z d Z d Z d Z e Z	 d d   Z
 d d d  Z d d d d d	  Z d
 d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d  d!   Z d" d#   Z d$ d%   Z d& d'   Z d( d)   Z d* d+   Z d, d-   Z d. d/   Z d0 d1   Z  d S)2NodeNc             C   s   d S)NT )selfr
   r
   %/usr/lib/python3.5/xml/dom/minidom.py__bool__+   s    zNode.__bool__c             C   s   |  j  d d |  S)N )toprettyxml)r   encodingr
   r
   r   toxml.   s    z
Node.toxml	
c             C   s   | d  k r t  j   } n' t  j t  j   d | d d d d } |  j t j k rp |  j | d | | |  n |  j | d | |  | d  k r | j   S| j	   j   Sd  S)Nr   errorsxmlcharrefreplacenewliner   r   )
ioStringIOTextIOWrapperBytesIOnodeTyper	   DOCUMENT_NODEwritexmlgetvaluedetach)r   indentnewlr   writerr
   r
   r   r   1   s    	
zNode.toprettyxmlc             C   s   t  |  j  S)N)bool
childNodes)r   r
   r
   r   hasChildNodesC   s    zNode.hasChildNodesc             C   s   |  j  S)N)r$   )r   r
   r
   r   _get_childNodesF   s    zNode._get_childNodesc             C   s   |  j  r |  j  d Sd  S)Nr   )r$   )r   r
   r
   r   _get_firstChildI   s    	zNode._get_firstChildc             C   s   |  j  r |  j  d Sd  S)N   )r$   )r   r
   r
   r   _get_lastChildM   s    	zNode._get_lastChildc             C   so  | j  |  j k r@ x' t | j  D] } |  j | |  q" W| S| j  |  j k rz t j j d t	 |  t	 |   f   | j
 d  k	 r | j
 j |  | d  k r |  j |  n y |  j j |  } Wn! t k
 r t j j    Yn X| j  t k rt |   |  j j | |  | | _ | | _ | rY|  j | d } | | _ | | _ n	 d  | _ |  | _
 | S)Nz%s cannot be child of %sr(   )r   DOCUMENT_FRAGMENT_NODEtupler$   insertBefore_child_node_typesxmldomHierarchyRequestErrrepr
parentNoderemoveChildappendChildindex
ValueErrorNotFoundErr_nodeTypes_with_children_clear_id_cacheinsertnextSiblingpreviousSibling)r   newChildrefChildcr6   noder
   r
   r   r-   Q   s6    	
					zNode.insertBeforec             C   s   | j  |  j k r= x$ t | j  D] } |  j |  q" W| S| j  |  j k rz t j j d t	 |  t	 |   f   n | j  t
 k r t |   | j d  k	 r | j j |  t |  |  d  | _ | S)Nz%s cannot be child of %s)r   r+   r,   r$   r5   r.   r/   r0   r1   r2   r9   r:   r3   r4   _append_childr<   )r   rA   r@   r
   r
   r   r5   q   s    	"
	zNode.appendChildc             C   sz  | j  |  j k r8 | j } |  j |  |  j | |  S| j  |  j k rr t j j d t	 |  t	 |   f   | | k r d  S| j
 d  k	 r | j
 j |  y |  j j |  } Wn! t k
 r t j j    Yn X| |  j | <|  | _
 d  | _
 | j  t k s| j  t k r"t |   | j | _ | j | _ d  | _ d  | _ | j ra| | j _ | j rv| | j _ | S)Nz%s cannot be child of %s)r   r+   r<   r4   r-   r.   r/   r0   r1   r2   r3   r$   r6   r7   r8   r9   r:   r=   )r   r>   oldChildr?   r6   r
   r
   r   replaceChild   s<    				
				zNode.replaceChildc             C   s   y |  j  j |  Wn! t k
 r7 t j j    Yn X| j d  k	 rV | j | j _ | j d  k	 rt | j | j _ d  | _ | _ | j t	 k r t
 |   d  | _ | S)N)r$   remover7   r/   r0   r8   r<   r=   r   r9   r:   r3   )r   rC   r
   r
   r   r4      s    
	zNode.removeChildc             C   s'  g  } x|  j  D] } | j t j k r | j sl | rG | j | d _ | j r_ | j | j _ | j   q| r | d j | j k r | d } | j | j | _ | j | _ | j r | | j _ | j   q| j |  q | j |  | j t j	 k r | j
   q W| |  j  d  d   <d  S)Nr(   r)   r)   r)   )r$   r   r	   	TEXT_NODEdatar<   r=   unlinkappendELEMENT_NODE	normalize)r   LchildrA   r
   r
   r   rK      s*    		
	zNode.normalizec             C   s   t  |  | |  j p |   S)N)_clone_nodeownerDocument)r   deepr
   r
   r   	cloneNode   s    zNode.cloneNodec             C   s   |  j  j j | |  S)N)rO   implementation
hasFeature)r   featureversionr
   r
   r   isSupported   s    zNode.isSupportedc             C   s   d  S)Nr
   )r   r
   r
   r   _get_localName   s    zNode._get_localNamec             C   s
   |  | k S)Nr
   )r   otherr
   r
   r   
isSameNode   s    zNode.isSameNodec             C   s   |  j  | d   r |  Sd  Sd  S)N)rV   )r   rT   r
   r
   r   getInterface   s    zNode.getInterfacec             C   s6   y |  j  | d SWn t t f k
 r1 d  SYn Xd  S)Nr   )
_user_dataAttributeErrorKeyError)r   keyr
   r
   r   getUserData   s    zNode.getUserDatac             C   s   d  } y |  j  } Wn! t k
 r6 i  } | |  _  Yn X| | k rQ | | d } | d  k ry d  } | d  k	 r | | =n | | f | | <| S)Nr   )r[   r\   )r   r^   rG   handlerolddr
   r
   r   setUserData   s    
zNode.setUserDatac             C   sd   t  |  d  r` xN t |  j j    D]7 \ } \ } } | d  k	 r% | j | | | | |  q% Wd  S)Nr[   )hasattrlistr[   itemsZhandle)r   	operationsrcZdstr^   rG   r`   r
   r
   r   _call_user_data_handler   s    (zNode._call_user_data_handlerc             C   sY   d  |  _  |  _ |  j rC x |  j D] } | j   q# Wt   |  _ d  |  _ d  |  _ d  S)N)r3   rO   r$   rH   NodeListr=   r<   )r   rM   r
   r
   r   rH     s    		zNode.unlinkc             C   s   |  S)Nr
   )r   r
   r
   r   	__enter__  s    zNode.__enter__c             C   s   |  j    d  S)N)rH   )r   ZetZevtbr
   r
   r   __exit__  s    zNode.__exit__)!__name__
__module____qualname__namespaceURIr3   rO   r<   r=   r   prefixr   r   r   r%   r&   r'   r*   r-   r5   rD   r4   rK   rQ   rV   rW   rY   rZ   r_   rc   ri   rH   rk   rm   r
   r
   r
   r   r	   "   s:     
r	   
firstChilddoczFirst child node, or None.	lastChildzLast child node, or None.	localNamez"Namespace-local name of this node.c             C   sE   |  j  } | r+ | d } | | _ | | _ | j |  |  | _ d  S)Nr(   r)   )r$   r=   r<   rI   r3   )r   rA   r$   Zlastr
   r
   r   rB     s    	
		rB   c             C   s6   x/ |  d  k	 r1 |  j  t j k r% d S|  j }  q Wd S)NTF)r   r	   r   r3   )rA   r
   r
   r   _in_document&  s
    rw   c             C   sM   | rI | j  d d  j  d d  j  d d  j  d d  } |  j |  d	 S)
zWrites datachars to writer.&z&amp;<z&lt;"z&quot;>z&gt;N)replacewrite)r"   rG   r
   r
   r   _write_data.  s    r~   c             C   sb   x[ |  j  D]P } | j t j k rJ | d k s= | j | k rJ | j |  t | | |  q
 W| S)Nr   )r$   r   r	   rJ   tagNamerI   _get_elements_by_tagName_helper)parentnamercrA   r
   r
   r   r   5  s    r   c             C   s   xy |  j  D]n } | j t j k r
 | d k s= | j | k re | d k sX | j | k re | j |  t | | | |  q
 W| S)Nr   )r$   r   r	   rJ   rv   rq   rI   "_get_elements_by_tagName_ns_helper)r   ZnsURIrv   r   rA   r
   r
   r   r   =  s    r   c               @   sm   e  Z d  Z e j Z d Z d Z d Z d Z	 e j
 e j e j e j e j e j e j f Z d d   Z d S)DocumentFragmentz#document-fragmentNc             C   s   t    |  _ d  S)N)rj   r$   )r   r
   r
   r   __init__T  s    zDocumentFragment.__init__)rn   ro   rp   r	   r+   r   nodeName	nodeValue
attributesr3   rJ   rF   CDATA_SECTION_NODEENTITY_REFERENCE_NODEPROCESSING_INSTRUCTION_NODECOMMENT_NODENOTATION_NODEr.   r   r
   r
   r
   r   r   F  s   	r   c               @   s  e  Z d  Z d# Z e j Z d	 Z d
 Z d
 Z	 e j
 e j f Z e d	 d	 d d  Z d d   Z d d   Z d d   Z d d   Z e e e  Z Z d d   Z d d   Z e e e  Z Z d d   Z d d   Z e e e  Z d d   Z d d    Z d! d"   Z d	 S)$Attr_name_valuerq   _prefixr$   
_localNamerO   ownerElementNFc             C   sG   d  |  _  | |  _ | |  _ | |  _ t   |  _ |  j j t    d  S)N)r   r   rq   r   rj   r$   rI   Text)r   qNamerq   rv   rr   r
   r
   r   r   b  s    				zAttr.__init__c             C   s;   y |  j  SWn) t k
 r6 |  j j d d  d SYn Xd  S)N:r(   r)   )r   r\   r   split)r   r
   r
   r   rW   o  s    zAttr._get_localNamec             C   s   |  j  S)N)	specified)r   r
   r
   r   _get_specifiedu  s    zAttr._get_specifiedc             C   s   |  j  S)N)r   )r   r
   r
   r   	_get_namex  s    zAttr._get_namec             C   s)   | |  _  |  j d  k	 r% t |  j  d  S)N)r   r   r:   )r   valuer
   r
   r   	_set_name{  s    	zAttr._set_namec             C   s   |  j  S)N)r   )r   r
   r
   r   
_get_value  s    zAttr._get_valuec             C   sI   | |  _  | |  j d _ |  j d  k	 r5 t |  j  | |  j d _ d  S)Nr   )r   r$   rG   r   r:   )r   r   r
   r
   r   
_set_value  s
    	zAttr._set_valuec             C   s   |  j  S)N)r   )r   r
   r
   r   _get_prefix  s    zAttr._get_prefixc             C   s   |  j  } | d k r9 | r9 | t k r9 t j j d   | |  _ | d  k rZ |  j } n d | |  j f } |  j r t |  j  | |  _	 d  S)Nxmlnsz5illegal use of 'xmlns' prefix for the wrong namespacez%s:%s)
rq   r   r/   r0   NamespaceErrr   rv   r   r:   r   )r   rr   ZnsuriZnewNamer
   r
   r   _set_prefix  s    					zAttr._set_prefixc             C   s   |  j  } | d  k	 rk | j |  j =| j |  j |  j f =|  j rk d |  _ | j d 8_ |  j j	 d 8_	 x |  j
 D] } | j   qu W|  j
 d  d   =d  S)NFr(   )r   _attrsr   _attrsNSrq   rv   _is_id_magic_id_nodesrO   _magic_id_countr$   rH   )r   elemrM   r
   r
   r   rH     s    			zAttr.unlinkc             C   s   |  j  r d S|  j } |  j } | d  k s7 | d  k r; d S| j |  } | d  k rZ d S|  j ry | j |  j |  j  S| j |  j  Sd  S)NTF)	r   rO   r   _get_elem_inforq   isIdNSrv   isIdr   )r   rt   r   infor
   r
   r   	_get_isId  s    				zAttr._get_isIdc             C   s   |  j  } |  j } | d  k s* | d  k r. t S| j |  } | d  k rM t S|  j rl | j |  j |  j  S| j |  j  Sd  S)N)	rO   r   _no_typer   rq   getAttributeTypeNSrv   getAttributeTyper   )r   rt   r   r   r
   r
   r   _get_schemaType  s    			zAttr._get_schemaType)r   r   rq   r   r$   r   rO   r   ) rn   ro   rp   	__slots__r	   ATTRIBUTE_NODEr   r   r   r   rF   r   r.   r   r   rW   r   r   r   propertyr   r   r   r   r   r   r   r   rr   rH   r   r   r
   r
   r
   r   r   X  s.    	r   r   z True if this attribute is an ID.z'Namespace-local name of this attribute.
schemaTypezSchema type for this attribute.c               @   si  e  Z d  Z d Z d< Z d d   Z d d   Z d	 d
   Z d d   Z d d   Z	 d d   Z
 d d   Z d d   Z d d   Z d d d  Z e Z d d   Z d d   Z d d   Z d  d!   Z d" d#   Z d$ d%   Z d& d'   Z d( d)   Z d* d+   Z d, d-   Z d. d/   Z d0 d1   Z d2 d3   Z d4 d5   Z d6 d7   Z d8 d9   Z d: d;   Z  d S)=NamedNodeMapa  The attribute list is a transient interface to the underlying
    dictionaries.  Mutations here will change the underlying element's
    dictionary.

    Ordering is imposed artificially and does not reflect the order of
    attributes as found in an input document.
    r   r   _ownerElementc             C   s   | |  _  | |  _ | |  _ d  S)N)r   r   r   )r   attrsZattrsNSr   r
   r
   r   r     s    		zNamedNodeMap.__init__c             C   s   t  |  j  S)N)lenr   )r   r
   r
   r   _get_length  s    zNamedNodeMap._get_lengthc             C   s<   y |  t  |  j j    | SWn t k
 r7 d  SYn Xd  S)N)re   r   keys
IndexError)r   r6   r
   r
   r   item  s    zNamedNodeMap.itemc             C   s=   g  } x0 |  j  j   D] } | j | j | j f  q W| S)N)r   valuesrI   r   r   )r   rL   rA   r
   r
   r   rf     s    zNamedNodeMap.itemsc             C   sF   g  } x9 |  j  j   D]( } | j | j | j f | j f  q W| S)N)r   r   rI   rq   rv   r   )r   rL   rA   r
   r
   r   itemsNS  s    &zNamedNodeMap.itemsNSc             C   s-   t  | t  r | |  j k S| |  j k Sd  S)N)
isinstancestrr   r   )r   r^   r
   r
   r   __contains__  s    zNamedNodeMap.__contains__c             C   s   |  j  j   S)N)r   r   )r   r
   r
   r   r     s    zNamedNodeMap.keysc             C   s   |  j  j   S)N)r   r   )r   r
   r
   r   keysNS  s    zNamedNodeMap.keysNSc             C   s   |  j  j   S)N)r   r   )r   r
   r
   r   r     s    zNamedNodeMap.valuesNc             C   s   |  j  j | |  S)N)r   get)r   r   r   r
   r
   r   r   
  s    zNamedNodeMap.getc             C   sO   |  j  t | d d   k r d St |   t |  k t |   t |  k  Sd  S)Nr   r   )r   getattrid)r   rX   r
   r
   r   _cmp  s    zNamedNodeMap._cmpc             C   s   |  j  |  d k S)Nr   )r   )r   rX   r
   r
   r   __eq__  s    zNamedNodeMap.__eq__c             C   s   |  j  |  d k S)Nr   )r   )r   rX   r
   r
   r   __ge__  s    zNamedNodeMap.__ge__c             C   s   |  j  |  d k S)Nr   )r   )r   rX   r
   r
   r   __gt__  s    zNamedNodeMap.__gt__c             C   s   |  j  |  d k S)Nr   )r   )r   rX   r
   r
   r   __le__  s    zNamedNodeMap.__le__c             C   s   |  j  |  d k  S)Nr   )r   )r   rX   r
   r
   r   __lt__!  s    zNamedNodeMap.__lt__c             C   s)   t  | t  r |  j | S|  j | Sd  S)N)r   r,   r   r   )r   attname_or_tupler
   r
   r   __getitem__$  s    zNamedNodeMap.__getitem__c             C   s   t  | t  ri y |  j | } Wn: t k
 r\ t |  } |  j j | _ |  j |  Yn X| | _ n. t  | t  s t	 d   | } |  j |  d  S)Nz%value must be a string or Attr object)
r   r   r   r]   r   r   rO   setNamedItemr   	TypeError)r   attnamer   rA   r
   r
   r   __setitem__+  s    zNamedNodeMap.__setitem__c             C   s,   y |  j  | SWn t k
 r' d  SYn Xd  S)N)r   r]   )r   r   r
   r
   r   getNamedItem:  s    zNamedNodeMap.getNamedItemc             C   s2   y |  j  | | f SWn t k
 r- d  SYn Xd  S)N)r   r]   )r   rq   rv   r
   r
   r   getNamedItemNS@  s    zNamedNodeMap.getNamedItemNSc             C   sz   |  j  |  } | d  k	 rg t |  j  |  j | j =|  j | j | j f =t | d  rc d  | _	 | St
 j j    d  S)Nr   )r   r:   r   r   r   r   rq   rv   rd   r   r/   r0   r8   )r   r   nr
   r
   r   removeNamedItemF  s    	zNamedNodeMap.removeNamedItemc             C   s}   |  j  | |  } | d  k	 rj t |  j  |  j | j | j f =|  j | j =t | d  rf d  | _	 | St
 j j    d  S)Nr   )r   r:   r   r   rq   rv   r   r   rd   r   r/   r0   r8   )r   rq   rv   r   r
   r
   r   removeNamedItemNSR  s    	zNamedNodeMap.removeNamedItemNSc             C   s   t  | t  s7 t j j d t |  t |   f   |  j j | j  } | r\ | j	   | |  j | j <| |  j
 | j | j f <|  j | _ t | j  | S)Nz%s cannot be child of %s)r   r   r/   r0   r1   r2   r   r   r   rH   r   rq   rv   r   r   r:   )r   rA   ra   r
   r
   r   r   ^  s    	
zNamedNodeMap.setNamedItemc             C   s   |  j  |  S)N)r   )r   rA   r
   r
   r   setNamedItemNSk  s    zNamedNodeMap.setNamedItemNSc             C   s%   |  | } t  | j  | j   d  S)N)r:   r   rH   )r   r   rA   r
   r
   r   __delitem__n  s    
zNamedNodeMap.__delitem__c             C   s   |  j  |  j |  j f S)N)r   r   r   )r   r
   r
   r   __getstate__s  s    zNamedNodeMap.__getstate__c             C   s   | \ |  _  |  _ |  _ d  S)N)r   r   r   )r   stater
   r
   r   __setstate__v  s    zNamedNodeMap.__setstate__)r   r   r   )!rn   ro   rp   __doc__r   r   r   r   rf   r   r   r   r   r   r   __len__r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r
   r
   r
   r   r     s<   r   Zlengthz$Number of nodes in the NamedNodeMap.c               @   sF   e  Z d  Z d Z d d   Z d d   Z d d   Z d	 d
   Z d S)TypeInfo	namespacer   c             C   s   | |  _  | |  _ d  S)N)r   r   )r   r   r   r
   r
   r   r     s    	zTypeInfo.__init__c             C   sA   |  j  r& d |  j j |  j |  j  f Sd |  j j |  j f Sd  S)Nz<%s %r (from %r)>z<%s %r>)r   	__class__rn   r   )r   r
   r
   r   __repr__  s    	zTypeInfo.__repr__c             C   s   |  j  S)N)r   )r   r
   r
   r   r     s    zTypeInfo._get_namec             C   s   |  j  S)N)r   )r   r
   r
   r   _get_namespace  s    zTypeInfo._get_namespaceN)r   r   )rn   ro   rp   r   r   r   r   r   r
   r
   r
   r   r     s
   r   c               @   s  e  Z d  Z dD Z e j Z d Z e Z	 d Z
 e j e j e j e j e j e j f Z e d d d d  Z d d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d d    Z d! d"   Z d# d$   Z d% d&   Z e Z d' d(   Z d) d*   Z  d+ d,   Z! e! Z" d- d.   Z# d/ d0   Z$ d1 d2   Z% d3 d4   Z& d5 d6   Z' d7 d7 d7 d8 d9  Z( d: d;   Z) d< d=   Z* d> d?   Z+ d@ dA   Z, dB dC   Z- d S)EElementrO   r3   r   r   rr   rq   r   r$   r   r   r<   r=   Nr   c             C   s]   d  |  _  | |  _ |  _ | |  _ | |  _ t   |  _ d  |  _ |  _ d  |  _	 d  |  _
 d  S)N)r3   r   r   rr   rq   rj   r$   r<   r=   r   r   )r   r   rq   rr   rv   r
   r
   r   r     s    			
	zElement.__init__c             C   s%   |  j  d  k r! i  |  _  i  |  _ d  S)N)r   r   )r   r
   r
   r   _ensure_attributes  s    	zElement._ensure_attributesc             C   s;   y |  j  SWn) t k
 r6 |  j j d d  d SYn Xd  S)Nr   r(   r)   )r   r\   r   r   )r   r
   r
   r   rW     s    zElement._get_localNamec             C   s   |  j  S)N)r   )r   r
   r
   r   _get_tagName  s    zElement._get_tagNamec             C   s\   |  j  d  k	 r9 x' t |  j  j    D] } | j   q% Wd  |  _  d  |  _ t j |   d  S)N)r   re   r   rH   r   r	   )r   attrr
   r
   r   rH     s    		zElement.unlinkc             C   sB   |  j  d  k r d Sy |  j  | j SWn t k
 r= d SYn Xd  S)Nr   )r   r   r]   )r   r   r
   r
   r   getAttribute  s    zElement.getAttributec             C   sH   |  j  d  k r d Sy |  j  | | f j SWn t k
 rC d SYn Xd  S)Nr   )r   r   r]   )r   rq   rv   r
   r
   r   getAttributeNS  s    zElement.getAttributeNSc             C   s{   |  j  |  } | d  k rL t |  } | | _ |  j | _ |  j |  n+ | | j k rw | | _ | j rw t |   d  S)N)getAttributeNoder   r   rO   setAttributeNoder   r:   )r   r   r   r   r
   r
   r   setAttribute  s    			zElement.setAttributec             C   s   t  |  \ } } |  j | |  } | d  k rj t | | | |  } | | _ |  j | _ |  j |  nL | | j k r | | _ | j r t |   | j | k r | | _ | | _	 d  S)N)
_nssplitgetAttributeNodeNSr   r   rO   r   r   r:   rr   r   )r   rq   qualifiedNamer   rr   	localnamer   r
   r
   r   setAttributeNS  s    			
	zElement.setAttributeNSc             C   s#   |  j  d  k r d  S|  j  j |  S)N)r   r   )r   Zattrnamer
   r
   r   r     s    zElement.getAttributeNodec             C   s)   |  j  d  k r d  S|  j  j | | f  S)N)r   r   )r   rq   rv   r
   r
   r   r     s    zElement.getAttributeNodeNSc             C   s   | j  d  |  f k r' t j j d   |  j   |  j j | j d   } | d  k	 rb |  j |  |  j	 j | j
 | j f d   } | d  k	 r | | k	 r |  j |  t |  |  | | k	 r | S| | k	 r | Sd  S)Nzattribute node already owned)r   r/   r0   ZInuseAttributeErrr   r   r   r   removeAttributeNoder   rq   rv   _set_attribute_node)r   r   Zold1Zold2r
   r
   r   r     s    
!zElement.setAttributeNodec             C   sd   |  j  d  k r t j j    y |  j | } Wn! t k
 rR t j j    Yn X|  j |  d  S)N)r   r/   r0   r8   r   r]   r   )r   r   r   r
   r
   r   removeAttribute  s    zElement.removeAttributec             C   sj   |  j  d  k r t j j    y |  j  | | f } Wn! t k
 rX t j j    Yn X|  j |  d  S)N)r   r/   r0   r8   r]   r   )r   rq   rv   r   r
   r
   r   removeAttributeNS%  s    zElement.removeAttributeNSc             C   su   | d  k r t  j j    y |  j | j Wn! t k
 rP t  j j    Yn Xt |   | j   |  j | _ d  S)N)	r/   r0   r8   r   r   r]   r:   rH   rO   )r   rA   r
   r
   r   r   .  s    

zElement.removeAttributeNodec             C   s    |  j  d  k r d S| |  j  k S)NF)r   )r   r   r
   r
   r   hasAttribute=  s    zElement.hasAttributec             C   s&   |  j  d  k r d S| | f |  j  k S)NF)r   )r   rq   rv   r
   r
   r   hasAttributeNSB  s    zElement.hasAttributeNSc             C   s   t  |  | t    S)N)r   rj   )r   r   r
   r
   r   getElementsByTagNameG  s    zElement.getElementsByTagNamec             C   s   t  |  | | t    S)N)r   rj   )r   rq   rv   r
   r
   r   getElementsByTagNameNSJ  s    zElement.getElementsByTagNameNSc             C   s   d |  j  t |   f S)Nz<DOM Element: %s at %#x>)r   r   )r   r
   r
   r   r   N  s    zElement.__repr__r   c       	      C   sW  | j  | d |  j  |  j   } t | j    } x@ | D]8 } | j  d |  t | | | j  | j  d  q= W|  j rB| j  d  t |  j  d k r |  j d j	 t
 j k r |  j d j | d d d  nH | j  |  x+ |  j D]  } | j | | | | |  q W| j  |  | j  d |  j | f  n | j  d	 |  d  S)
Nry   z %s="rz   r{   r(   r   r   z</%s>%sz/>%s)r}   r   _get_attributessortedr   r~   r   r$   r   r   r	   rF   r   )	r   r"   r    	addindentr!   r   Za_namesZa_namerA   r
   r
   r   r   Q  s$    	 zElement.writexmlc             C   s    |  j    t |  j |  j |   S)N)r   r   r   r   )r   r
   r
   r   r   l  s    
zElement._get_attributesc             C   s   |  j  r d Sd Sd  S)NTF)r   )r   r
   r
   r   hasAttributesp  s    	zElement.hasAttributesc             C   s    |  j  |  } |  j |  d  S)N)r   setIdAttributeNode)r   r   idAttrr
   r
   r   setIdAttributex  s    zElement.setIdAttributec             C   s#   |  j  | |  } |  j |  d  S)N)r   r   )r   rq   rv   r   r
   r
   r   setIdAttributeNS|  s    zElement.setIdAttributeNSc             C   s   | d  k s |  j  | j  r. t j j    t |   d  k	 rO t j j    | j s d | _ |  j d 7_ |  j	 j
 d 7_
 t |   d  S)NTr(   )rY   r   r/   r0   r8   _get_containing_entrefNoModificationAllowedErrr   r   rO   r   r:   )r   r   r
   r
   r   r     s    		zElement.setIdAttributeNode)rO   r3   r   r   rr   rq   r   r$   r   r   r<   r=   ).rn   ro   rp   r   r	   rJ   r   r   r   r   r   r   r   rF   r   r   r.   r   r   r   rW   r   rH   r   r   r   r   r   r   r   ZsetAttributeNodeNSr   r   r   ZremoveAttributeNodeNSr   r   r   r   r   r   r   r   r  r  r   r
   r
   r
   r   r     sT     			r   r   z*NamedNodeMap of attributes on the element.z%Namespace-local name of this element.c             C   sJ   t  |   |  j   | |  j | j <| |  j | j | j f <|  | _ d  S)N)r:   r   r   r   r   rq   rv   r   )elementr   r
   r
   r   r     s
    

r   c               @   s   e  Z d  Z d Z f  Z d Z e   Z d Z d Z	 d d   Z
 d d   Z d d   Z d	 d
   Z d d   Z d d   Z d d   Z d d   Z d S)	ChildlesszMixin that makes childless-ness easy to implement and avoids
    the complexity of the Node methods that deal with children.
    Nc             C   s   d  S)Nr
   )r   r
   r
   r   r'     s    zChildless._get_firstChildc             C   s   d  S)Nr
   )r   r
   r
   r   r*     s    zChildless._get_lastChildc             C   s   t  j j |  j d   d  S)Nz nodes cannot have children)r/   r0   r1   r   )r   rA   r
   r
   r   r5     s    	zChildless.appendChildc             C   s   d S)NFr
   )r   r
   r
   r   r%     s    zChildless.hasChildNodesc             C   s   t  j j |  j d   d  S)Nz nodes do not have children)r/   r0   r1   r   )r   r>   r?   r
   r
   r   r-     s    	zChildless.insertBeforec             C   s   t  j j |  j d   d  S)Nz nodes do not have children)r/   r0   r8   r   )r   rC   r
   r
   r   r4     s    	zChildless.removeChildc             C   s   d  S)Nr
   )r   r
   r
   r   rK     s    zChildless.normalizec             C   s   t  j j |  j d   d  S)Nz nodes do not have children)r/   r0   r1   r   )r   r>   rC   r
   r
   r   rD     s    	zChildless.replaceChild)rn   ro   rp   r   r   r   ZEmptyNodeListr$   rs   ru   r'   r*   r5   r%   r-   r4   rK   rD   r
   r
   r
   r   r    s   	r  c               @   s   e  Z d  Z e j Z d Z d d   Z d d   Z d d   Z	 e
 e e	  Z d	 d
   Z d d   Z e
 e e  Z d d d d d  Z d S)ProcessingInstructiontargetrG   c             C   s   | |  _  | |  _ d  S)N)r  rG   )r   r  rG   r
   r
   r   r     s    	zProcessingInstruction.__init__c             C   s   |  j  S)N)rG   )r   r
   r
   r   _get_nodeValue  s    z$ProcessingInstruction._get_nodeValuec             C   s   | |  _  d  S)N)rG   )r   r   r
   r
   r   _set_nodeValue  s    z$ProcessingInstruction._set_nodeValuec             C   s   |  j  S)N)r  )r   r
   r
   r   _get_nodeName  s    z#ProcessingInstruction._get_nodeNamec             C   s   | |  _  d  S)N)r  )r   r   r
   r
   r   _set_nodeName  s    z#ProcessingInstruction._set_nodeNamer   c             C   s'   | j  d | |  j |  j | f  d  S)Nz%s<?%s %s?>%s)r}   r  rG   )r   r"   r    r   r!   r
   r
   r   r     s    zProcessingInstruction.writexmlN)r  rG   )rn   ro   rp   r	   r   r   r   r   r	  r
  r   r   r  r  r   r   r
   r
   r
   r   r    s   	r  c               @   s   e  Z d  Z d Z d d   Z d d	   Z e Z d
 d   Z d d   Z e	 e e  Z
 Z d d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d S)CharacterData_datarO   r3   r=   r<   c             C   s:   d  |  _  |  _ d  |  _ |  _ d |  _ t j |   d  S)Nr   )rO   r3   r=   r<   r  r	   r   )r   r
   r
   r   r     s    	zCharacterData.__init__c             C   s   t  |  j  S)N)r   rG   )r   r
   r
   r   r     s    zCharacterData._get_lengthc             C   s   |  j  S)N)r  )r   r
   r
   r   	_get_data  s    zCharacterData._get_datac             C   s   | |  _  d  S)N)r  )r   rG   r
   r
   r   	_set_data  s    zCharacterData._set_datac             C   sK   |  j  } t |  d k r$ d } n d } d |  j j | d d  | f S)N
   z...r   z<DOM %s node "%r%s">r   )rG   r   r   rn   )r   rG   Z	dotdotdotr
   r
   r   r     s    		zCharacterData.__repr__c             C   sx   | d k  r t  j j d   | t |  j  k rE t  j j d   | d k  rc t  j j d   |  j | | |  S)Nr   zoffset cannot be negativez#offset cannot be beyond end of datazcount cannot be negative)r/   r0   IndexSizeErrr   rG   )r   offsetcountr
   r
   r   substringData  s    zCharacterData.substringDatac             C   s   |  j  | |  _  d  S)N)rG   )r   argr
   r
   r   
appendData  s    zCharacterData.appendDatac             C   s   | d k  r t  j j d   | t |  j  k rE t  j j d   | r{ d |  j d  |  | |  j | d   f |  _ d  S)Nr   zoffset cannot be negativez#offset cannot be beyond end of dataz%s%s%s)r/   r0   r  r   rG   )r   r  r  r
   r
   r   
insertData  s    zCharacterData.insertDatac             C   s   | d k  r t  j j d   | t |  j  k rE t  j j d   | d k  rc t  j j d   | r |  j d  |  |  j | | d   |  _ d  S)Nr   zoffset cannot be negativez#offset cannot be beyond end of datazcount cannot be negative)r/   r0   r  r   rG   )r   r  r  r
   r
   r   
deleteData  s    zCharacterData.deleteDatac             C   s   | d k  r t  j j d   | t |  j  k rE t  j j d   | d k  rc t  j j d   | r d |  j d  |  | |  j | | d   f |  _ d  S)Nr   zoffset cannot be negativez#offset cannot be beyond end of datazcount cannot be negativez%s%s%s)r/   r0   r  r   rG   )r   r  r  r  r
   r
   r   replaceData  s    zCharacterData.replaceDataN)r  rO   r3   r=   r<   )rn   ro   rp   r   r   r   r   r  r  r   rG   r   r   r  r  r  r  r  r
   r
   r
   r   r    s   			
r  zLength of the string data.c               @   sp   e  Z d  Z f  Z e j Z d Z d Z d d   Z	 d d d d d  Z
 d d	   Z d
 d   Z d d   Z d S)r   z#textNc             C   s   | d k  s! | t  |  j  k r3 t j j d   |  j   } |  j | d   | _ |  j | _ |  j } |  j r |  |  j j	 k r | d  k r |  j j
 |  n |  j j | |  |  j d  |  |  _ | S)Nr   zillegal offset value)r   rG   r/   r0   r  r   rO   r<   r3   r$   r5   r-   )r   r  ZnewTextnextr
   r
   r   	splitText0  s    !	zText.splitTextr   c             C   s!   t  | d | |  j | f  d  S)Nz%s%s%s)r~   rG   )r   r"   r    r   r!   r
   r
   r   r   ?  s    zText.writexmlc             C   s   |  j  g } |  j } xK | d  k	 rb | j t j t j f k r^ | j d | j   | j } q Pq W|  j } xH | d  k	 r | j t j t j f k r | j | j   | j } qo Pqo Wd j	 |  S)Nr   r   )
rG   r=   r   r	   rF   r   r;   r<   rI   join)r   rL   r   r
   r
   r   _get_wholeTextD  s    		zText._get_wholeTextc             C   s   |  j  } |  j } xK | d  k	 r_ | j t j t j f k r[ | j } | j |  | } q Pq W|  j } | s| | j |   xK | d  k	 r | j t j t j f k r | j } | j |  | } q Pq W| r | |  _ |  Sd  Sd  S)N)	r3   r=   r   r	   rF   r   r4   r<   rG   )r   Zcontentr   r   r  r
   r
   r   replaceWholeTextV  s*    								zText.replaceWholeTextc             C   s_   |  j  j   r d St |   } | d  k r/ d S|  j j |  } | d  k rQ d S| j   Sd  S)NF)rG   strip_get_containing_elementrO   r   isElementContent)r   r   r   r
   r
   r   !_get_isWhitespaceInElementContentr  s    z&Text._get_isWhitespaceInElementContent)rn   ro   rp   r   r	   rF   r   r   r   r  r   r  r  r#  r
   r
   r
   r   r   )  s   	r   ZisWhitespaceInElementContentzKTrue iff this text node contains only whitespace and is in element content.Z	wholeTextz.The text of all logically-adjacent text nodes.c             C   s?   |  j  } x/ | d  k	 r: | j t j k r. | S| j  } q Wd  S)N)r3   r   r	   rJ   )rA   r@   r
   r
   r   r!    s    	r!  c             C   s?   |  j  } x/ | d  k	 r: | j t j k r. | S| j  } q Wd  S)N)r3   r   r	   r   )rA   r@   r
   r
   r   r    s    	r  c               @   s@   e  Z d  Z e j Z d Z d d   Z d d d d d  Z d S)Commentz#commentc             C   s   t  j |   | |  _ d  S)N)r  r   r  )r   rG   r
   r
   r   r     s    zComment.__init__r   c             C   s<   d |  j  k r t d   | j d | |  j  | f  d  S)Nz--z%'--' is not allowed in a comment nodez%s<!--%s-->%s)rG   r7   r}   )r   r"   r    r   r!   r
   r
   r   r     s    zComment.writexmlN)	rn   ro   rp   r	   r   r   r   r   r   r
   r
   r
   r   r$    s   	r$  c               @   s:   e  Z d  Z f  Z e j Z d Z d d d d d  Z d S)CDATASectionz#cdata-sectionr   c             C   s<   |  j  j d  d k r$ t d   | j d |  j   d  S)Nz]]>r   z$']]>' not allowed in a CDATA sectionz<![CDATA[%s]]>)rG   findr7   r}   )r   r"   r    r   r!   r
   r
   r   r     s    zCDATASection.writexmlN)	rn   ro   rp   r   r	   r   r   r   r   r
   r
   r
   r   r%    s   	r%  c               @   s   e  Z d  Z d Z f  d d  Z d d   Z d d   Z d d	   Z d
 d   Z d d   Z	 d d   Z
 d d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d S)ReadOnlySequentialNamedNodeMap_seqc             C   s   | |  _  d  S)N)r(  )r   seqr
   r
   r   r     s    z'ReadOnlySequentialNamedNodeMap.__init__c             C   s   t  |  j  S)N)r   r(  )r   r
   r
   r   r     s    z&ReadOnlySequentialNamedNodeMap.__len__c             C   s   t  |  j  S)N)r   r(  )r   r
   r
   r   r     s    z*ReadOnlySequentialNamedNodeMap._get_lengthc             C   s+   x$ |  j  D] } | j | k r
 | Sq
 Wd  S)N)r(  r   )r   r   r   r
   r
   r   r     s    z+ReadOnlySequentialNamedNodeMap.getNamedItemc             C   s:   x3 |  j  D]( } | j | k r
 | j | k r
 | Sq
 Wd  S)N)r(  rq   rv   )r   rq   rv   r   r
   r
   r   r     s    z-ReadOnlySequentialNamedNodeMap.getNamedItemNSc             C   sL   t  | t  r! |  j |   } n |  j |  } | d  k rH t |   | S)N)r   r,   r   r   r]   )r   Zname_or_tuplerA   r
   r
   r   r     s    z*ReadOnlySequentialNamedNodeMap.__getitem__c             C   s<   | d k  r d  Sy |  j  | SWn t k
 r7 d  SYn Xd  S)Nr   )r(  r   )r   r6   r
   r
   r   r     s    z#ReadOnlySequentialNamedNodeMap.itemc             C   s   t  j j d   d  S)Nz"NamedNodeMap instance is read-only)r/   r0   r  )r   r   r
   r
   r   r     s    	z.ReadOnlySequentialNamedNodeMap.removeNamedItemc             C   s   t  j j d   d  S)Nz"NamedNodeMap instance is read-only)r/   r0   r  )r   rq   rv   r
   r
   r   r     s    	z0ReadOnlySequentialNamedNodeMap.removeNamedItemNSc             C   s   t  j j d   d  S)Nz"NamedNodeMap instance is read-only)r/   r0   r  )r   rA   r
   r
   r   r     s    	z+ReadOnlySequentialNamedNodeMap.setNamedItemc             C   s   t  j j d   d  S)Nz"NamedNodeMap instance is read-only)r/   r0   r  )r   rA   r
   r
   r   r     s    	z-ReadOnlySequentialNamedNodeMap.setNamedItemNSc             C   s
   |  j  g S)N)r(  )r   r
   r
   r   r     s    z+ReadOnlySequentialNamedNodeMap.__getstate__c             C   s   | d |  _  d  S)Nr   )r(  )r   r   r
   r
   r   r     s    z+ReadOnlySequentialNamedNodeMap.__setstate__N)r(  )rn   ro   rp   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r
   r
   r
   r   r'    s   	r'  z&Number of entries in the NamedNodeMap.c               @   s@   e  Z d  Z d Z d Z d d   Z d d   Z d d	   Z d
 S)
Identifiedz@Mix-in class that supports the publicId and systemId attributes.publicIdsystemIdc             C   s   | |  _  | |  _ d  S)N)r+  r,  )r   r+  r,  r
   r
   r   _identified_mixin_init  s    	z!Identified._identified_mixin_initc             C   s   |  j  S)N)r+  )r   r
   r
   r   _get_publicId  s    zIdentified._get_publicIdc             C   s   |  j  S)N)r,  )r   r
   r
   r   _get_systemId  s    zIdentified._get_systemIdN)r+  r,  )rn   ro   rp   r   r   r-  r.  r/  r
   r
   r
   r   r*    s
   r*  c               @   sp   e  Z d  Z e j Z d Z d Z d Z d Z	 d Z
 d d   Z d d   Z d d   Z d d d d	 d
  Z d S)DocumentTypeNc             C   sI   t    |  _ t    |  _ | r9 t |  \ } } | |  _ |  j |  _ d  S)N)r'  entities	notationsr   r   r   )r   r   rr   r   r
   r
   r   r   	  s    	zDocumentType.__init__c             C   s   |  j  S)N)internalSubset)r   r
   r
   r   _get_internalSubset  s    z DocumentType._get_internalSubsetc             C   sY  |  j  d  k rQt d   } |  j | _ |  j | _ t j j j } | r:g  | j _	 g  | j
 _	 xU |  j
 j	 D]G } t | j | j | j  } | j
 j	 j |  | j | | |  qm Wx |  j j	 D]q } t | j | j | j | j  } | j | _ | j | _ | j | _ | j j	 j |  | j | | |  q W|  j | |  |  | Sd  Sd  S)N)rO   r0  r   r   r/   r0   UserDataHandlerNODE_CLONEDr1  r(  r2  Notationr+  r,  rI   ri   EntitynotationNameactualEncodingr   rU   )r   rP   clonerg   r   notationeentityr
   r
   r   rQ     s.    zDocumentType.cloneNoder   c             C   s   | j  d  | j  |  j  |  j rL | j  d | |  j | |  j f  n# |  j ro | j  d | |  j f  |  j d  k	 r | j  d  | j  |  j  | j  d  | j  d |  d  S)Nz
<!DOCTYPE z%s  PUBLIC '%s'%s  '%s'z%s  SYSTEM '%s'z []r{   )r}   r   r+  r,  r3  )r   r"   r    r   r!   r
   r
   r   r   /  s    			zDocumentType.writexml)rn   ro   rp   r	   DOCUMENT_TYPE_NODEr   r   r   r+  r,  r3  r   r4  rQ   r   r
   r
   r
   r   r0    s   	r0  c               @   s   e  Z d  Z d Z e j Z d Z d Z d Z	 d Z
 d d   Z d d   Z d d   Z d d	   Z d
 d   Z d d   Z d d   Z d d   Z d S)r8  Nc             C   s2   | |  _  | |  _ t   |  _ |  j | |  d  S)N)r   r9  rj   r$   r-  )r   r   r+  r,  r<  r
   r
   r   r   F  s    		zEntity.__init__c             C   s   |  j  S)N)r:  )r   r
   r
   r   _get_actualEncodingL  s    zEntity._get_actualEncodingc             C   s   |  j  S)N)r   )r   r
   r
   r   _get_encodingO  s    zEntity._get_encodingc             C   s   |  j  S)N)rU   )r   r
   r
   r   _get_versionR  s    zEntity._get_versionc             C   s   t  j j d   d  S)Nz(cannot append children to an entity node)r/   r0   r1   )r   r>   r
   r
   r   r5   U  s    	zEntity.appendChildc             C   s   t  j j d   d  S)Nz+cannot insert children below an entity node)r/   r0   r1   )r   r>   r?   r
   r
   r   r-   Y  s    	zEntity.insertBeforec             C   s   t  j j d   d  S)Nz*cannot remove children from an entity node)r/   r0   r1   )r   rC   r
   r
   r   r4   ]  s    	zEntity.removeChildc             C   s   t  j j d   d  S)Nz)cannot replace children of an entity node)r/   r0   r1   )r   r>   rC   r
   r
   r   rD   a  s    	zEntity.replaceChild)rn   ro   rp   r   r	   ZENTITY_NODEr   r   r:  r   rU   r   rA  rB  rC  r5   r-   r4   rD   r
   r
   r
   r   r8  =  s   	r8  c               @   s+   e  Z d  Z e j Z d Z d d   Z d S)r7  Nc             C   s   | |  _  |  j | |  d  S)N)r   r-  )r   r   r+  r,  r
   r
   r   r   i  s    	zNotation.__init__)rn   ro   rp   r	   r   r   r   r   r
   r
   r
   r   r7  e  s   	r7  c            	   @   sj   e  Z d  Z d d d d d d d d g Z d d	   Z d
 d   Z d d   Z d d   Z d d   Z d S)DOMImplementationcore1.02.0Nr/   ls-load3.0c             C   s+   | d k r d  } | j    | f |  j k S)Nr   )lower	_features)r   rT   rU   r
   r
   r   rS   y  s    zDOMImplementation.hasFeaturec       	      C   s6  | r' | j  d  k	 r' t j j d   |  j   } | d  k oT | d  k oT | d  k } | rw | rw t j j d   | r
t |  \ } } | d k r | d k r t j j d   | r | r t j j d   | j | |  } | r | j	 |  | j	 |  | r | | _  | _
 | | _ |  | _ | S)Nz(doctype object owned by another DOM treezElement with no namer/   z$http://www.w3.org/XML/1998/namespacezillegal use of 'xml' prefixz(illegal use of prefix without namespaces)r3   r/   r0   WrongDocumentErr_create_documentZInvalidCharacterErrr   r   createElementNSr5   rO   doctyperR   )	r   rq   r   rO  rt   Zadd_root_elementrr   r   r  r
   r
   r   createDocument~  s4    						z DOMImplementation.createDocumentc             C   s"   t  |  } | | _ | | _ | S)N)r0  r+  r,  )r   r   r+  r,  rO  r
   r
   r   createDocumentType  s    		z$DOMImplementation.createDocumentTypec             C   s   |  j  | d   r |  Sd  Sd  S)N)rS   )r   rT   r
   r
   r   rZ     s    zDOMImplementation.getInterfacec             C   s   t    S)N)Document)r   r
   r
   r   rM    s    z"DOMImplementation._create_document)rE  rF  )rE  rG  )rE  N)r/   rF  )r/   rG  )r/   N)rH  rI  )rH  N)	rn   ro   rp   rK  rS   rP  rQ  rZ   rM  r
   r
   r
   r   rD  n  s   	-rD  c               @   s   e  Z d  Z d Z d Z d d   Z d d   Z d d   Z d	 d
   Z d d   Z	 d d   Z
 d d   Z d d   Z d d   Z d S)ElementInfozObject that represents content-model information for an element.

    This implementation is not expected to be used in practice; DOM
    builders should provide implementations which do the right thing
    using information available to it.

    r   c             C   s   | |  _  d  S)N)r   )r   r   r
   r
   r   r     s    zElementInfo.__init__c             C   s   t  S)N)r   )r   anamer
   r
   r   r     s    zElementInfo.getAttributeTypec             C   s   t  S)N)r   )r   rq   rv   r
   r
   r   r     s    zElementInfo.getAttributeTypeNSc             C   s   d S)NFr
   )r   r
   r
   r   r"    s    zElementInfo.isElementContentc             C   s   d S)zQReturns true iff this element is declared to have an EMPTY
        content model.Fr
   )r   r
   r
   r   isEmpty  s    zElementInfo.isEmptyc             C   s   d S)z7Returns true iff the named attribute is a DTD-style ID.Fr
   )r   rT  r
   r
   r   r     s    zElementInfo.isIdc             C   s   d S)z<Returns true iff the identified attribute is a DTD-style ID.Fr
   )r   rq   rv   r
   r
   r   r     s    zElementInfo.isIdNSc             C   s   |  j  S)N)r   )r   r
   r
   r   r     s    zElementInfo.__getstate__c             C   s   | |  _  d  S)N)r   )r   r   r
   r
   r   r     s    zElementInfo.__setstate__N)r   )rn   ro   rp   r   r   r   r   r   r"  rU  r   r   r   r   r
   r
   r
   r   rS    s   rS  c             C   sW   |  j  t j k r+ |  j j   d  |  _ n( t |   rS |  j j j   d  |  j _ d  S)N)r   r	   r   	_id_cacheclear_id_search_stackrw   rO   )rA   r
   r
   r   r:     s    r:   c               @   s0  e  Z d  Z dM Z e j e j e j e j f Z	 e
   Z e j Z d Z d Z d Z d Z d Z Z d Z d Z d Z d Z d Z d Z d Z d	 Z d
 d   Z d d   Z d d   Z d d   Z d d   Z  d d   Z! d d   Z" d d   Z# d d   Z$ d d   Z% d d   Z& d  d!   Z' d" d#   Z( d$ d%   Z) d& d'   Z* d( d)   Z+ d* d+   Z, d, d-   Z- d. d/   Z. d0 d1   Z/ d2 d3   Z0 d4 d5   Z1 d6 d7   Z2 d8 d9   Z3 d: d;   Z4 d< d=   Z5 d> d?   Z6 d@ dA   Z7 dB dC   Z8 dD dE   Z9 dF dG   Z: dH dH dH d dI dJ  Z; dK dL   Z< d S)NrR  
_elem_inforO  rX  r$   rV  z	#documentNFr   c             C   s4   d  |  _  t   |  _ i  |  _ i  |  _ d  |  _ d  S)N)rO  rj   r$   rY  rV  rX  )r   r
   r
   r   r   
  s
    			zDocument.__init__c             C   s7   | j  r | j  | j f } n	 | j } |  j j |  S)N)rq   rv   r   rY  r   )r   r  r^   r
   r
   r   r     s    		zDocument._get_elem_infoc             C   s   |  j  S)N)r:  )r   r
   r
   r   rA    s    zDocument._get_actualEncodingc             C   s   |  j  S)N)rO  )r   r
   r
   r   _get_doctype  s    zDocument._get_doctypec             C   s   |  j  S)N)documentURI)r   r
   r
   r   _get_documentURI   s    zDocument._get_documentURIc             C   s   |  j  S)N)r   )r   r
   r
   r   rB  #  s    zDocument._get_encodingc             C   s   |  j  S)N)errorHandler)r   r
   r
   r   _get_errorHandler&  s    zDocument._get_errorHandlerc             C   s   |  j  S)N)
standalone)r   r
   r
   r   _get_standalone)  s    zDocument._get_standalonec             C   s   |  j  S)N)strictErrorChecking)r   r
   r
   r   _get_strictErrorChecking,  s    z!Document._get_strictErrorCheckingc             C   s   |  j  S)N)rU   )r   r
   r
   r   rC  /  s    zDocument._get_versionc             C   s   | j  |  j k r: t j j d t |  t |   f   | j d  k	 rY | j j |  | j  t j	 k r |  j
   r t j j d   t j |  |  S)Nz%s cannot be child of %sz two document elements disallowed)r   r.   r/   r0   r1   r2   r3   r4   r	   rJ   _get_documentElementr5   )r   rA   r
   r
   r   r5   2  s    			zDocument.appendChildc             C   sm   y |  j  j |  Wn! t k
 r7 t j j    Yn Xd  | _ | _ d  | _ |  j	 | k ri d  |  _	 | S)N)
r$   rE   r7   r/   r0   r8   r<   r=   r3   documentElement)r   rC   r
   r
   r   r4   B  s    		zDocument.removeChildc             C   s.   x' |  j  D] } | j t j k r
 | Sq
 Wd  S)N)r$   r   r	   rJ   )r   rA   r
   r
   r   rc  N  s    zDocument._get_documentElementc             C   s6   |  j  d  k	 r% |  j  j   d  |  _  t j |   d  S)N)rO  rH   r	   )r   r
   r
   r   rH   S  s    	zDocument.unlinkc             C   s  | s
 d  S|  j  j d  d  d   } |  j | _ |  j | _ |  j | _ x |  j D] } t | | |  } | j j |  s t	  | j j
 |  | j t j k r | j d  k s t	  n0 | j t j k r | j d  k s t	  | | _ | | _ qP W|  j t j j j |  |  | S)N)rR   rP  r   r_  rU   r$   rN   rO   rY   AssertionErrorrI   r   r	   r   rd  r@  rO  r3   ri   r/   r0   r5  r6  )r   rP   r;  r   Z
childcloner
   r
   r   rQ   Y  s&    	
zDocument.cloneNodec             C   s   t    } |  | _ | S)N)r   rO   )r   rb   r
   r
   r   createDocumentFragmentn  s    		zDocument.createDocumentFragmentc             C   s   t  |  } |  | _ | S)N)r   rO   )r   r   r=  r
   r
   r   createElements  s    	zDocument.createElementc             C   s:   t  | t  s t d   t   } | | _ |  | _ | S)Nznode contents must be a string)r   r   r   r   rG   rO   )r   rG   tr
   r
   r   createTextNodex  s    			zDocument.createTextNodec             C   s:   t  | t  s t d   t   } | | _ |  | _ | S)Nznode contents must be a string)r   r   r   r%  rG   rO   )r   rG   r@   r
   r
   r   createCDATASection  s    			zDocument.createCDATASectionc             C   s   t  |  } |  | _ | S)N)r$  rO   )r   rG   r@   r
   r
   r   createComment  s    	zDocument.createCommentc             C   s   t  | |  } |  | _ | S)N)r  rO   )r   r  rG   pr
   r
   r   createProcessingInstruction  s    	z$Document.createProcessingInstructionc             C   s"   t  |  } |  | _ d | _ | S)Nr   )r   rO   r   )r   r   ar
   r
   r   createAttribute  s    		zDocument.createAttributec             C   s1   t  |  \ } } t | | |  } |  | _ | S)N)r   r   rO   )r   rq   r   rr   rv   r=  r
   r
   r   rN    s    	zDocument.createElementNSc             C   s=   t  |  \ } } t | | | |  } |  | _ d | _ | S)Nr   )r   r   rO   r   )r   rq   r   rr   rv   rn  r
   r
   r   createAttributeNS  s
    		zDocument.createAttributeNSc             C   s"   t  | | | |  } |  | _ | S)N)r8  rO   )r   r   r+  r,  r9  r=  r
   r
   r   _create_entity  s    	zDocument._create_entityc             C   s   t  | | |  } |  | _ | S)N)r7  rO   )r   r   r+  r,  r   r
   r
   r   _create_notation  s    	zDocument._create_notationc             C   s  | |  j  k r |  j  | S|  j p) |  j s0 d  S|  j } | d  k r] |  j g } | |  _ n
 | sg d  Sd  } x| r| j   } | j d d   | j D  |  j |  } | rxI| j	 j
   D] } | j r | j | j | j  r| |  j  | j <| j | k r| } q| j sPq | j | j  rg| |  j  | j <| j | k rZ| } q| j sPq | j r | |  j  | j <| j | k r| } q | j d k r Pq WnQ | j r xE | j	 j
   D]4 } | j r| |  j  | j <| j | k r| } qW| d  k	 rp Pqp W| S)Nc             S   s%   g  |  ] } | j  t k r |  q Sr
   )r   r9   ).0rM   r
   r
   r   
<listcomp>  s   	 z+Document.getElementById.<locals>.<listcomp>r(   )rV  rY  r   rX  rd  popextendr$   r   r   r   rq   r   rv   r   r   r   r   r   )r   r   stackresultrA   r   r   r
   r
   r   getElementById  sZ    											
zDocument.getElementByIdc             C   s   t  |  | t    S)N)r   rj   )r   r   r
   r
   r   r     s    zDocument.getElementsByTagNamec             C   s   t  |  | | t    S)N)r   rj   )r   rq   rv   r
   r
   r   r     s    zDocument.getElementsByTagNameNSc             C   s   |  j  j | |  S)N)rR   rS   )r   rT   rU   r
   r
   r   rV     s    zDocument.isSupportedc             C   s[   | j  t j k r' t j j d   n$ | j  t j k rK t j j d   t | | |   S)Nzcannot import document nodesz!cannot import document type nodes)r   r	   r   r/   r0   NotSupportedErrr@  rN   )r   rA   rP   r
   r
   r   
importNode  s
    zDocument.importNoder   c             C   se   | d  k r  | j  d |  n | j  d | | f  x' |  j D] } | j | | | |  qA Wd  S)Nz<?xml version="1.0" ?>z%<?xml version="1.0" encoding="%s"?>%s)r}   r$   r   )r   r"   r    r   r!   r   rA   r
   r
   r   r     s    	zDocument.writexmlc             C   s  | j  |  k	 r. t j j d |  | j  f   | j t j t j f k r[ t j j d   | t	 k rd | k r | j
 d d  \ } } | d k r| t j j k rt j j d   q| d k r | t j j k r | j t j k r t j j d   d  } | } n d  } d  } | j t j k r[| j } | d  k	 ra| j } | j |  n d  } | | _ | | _ | | _ | | _ | j t j k r| | _ n5 | | _ | d  k	 r| j |  | r| j |  | S)Nz?cannot rename nodes from other documents;
expected %s,
found %sz8renameNode() only applies to element and attribute nodesr   r(   r   zillegal use of 'xmlns' prefixz$illegal use of the 'xmlns' attribute)rO   r/   r0   rL  r   r	   rJ   r   rz  r   r   r   r   r   r   r   rr   r   rq   r   r   r   r   r   )r   r   rq   r   rr   rv   r  Zis_idr
   r
   r   
renameNode  sR    														zDocument.renameNode)rY  rO  rX  r$   rV  )=rn   ro   rp   r   r	   rJ   r   r   r@  r.   rD  rR   r   r   r   r   r   r3   r=   r<   r:  r   r_  rU   ra  r]  r[  r   r   r   rA  rZ  r\  rB  r^  r`  rb  rC  r5   r4   rc  rH   rQ   rf  rg  ri  rj  rk  rm  ro  rN  rp  rq  rr  ry  r   r   rV   r{  r   r|  r
   r
   r
   r   rR    sh    		
	
:rR  rd  z#Top-level element of this document.c             C   s  |  j  j |  r$ t j j j } n t j j j } |  j t j	 k r | j
 |  j |  j  } xW |  j j   D]F } | j | j | j | j  | j | j | j  } | j | _ qm W| rx|  j D]% } t | | |  } | j |  q Wn|  j t j k rM| j   } | rx|  j D]% } t | | |  } | j |  q!Wn|  j t j k rt| j |  j  } nd|  j t j k r| j |  j  } n=|  j t j k r| j |  j  |  j  } n|  j t j! k r| j" |  j  } n|  j t j# k r1| j$ |  j |  j  } d | _ |  j | _ n|  j t j% k r|  j  | k	 sXt&  t j j j } | j' j( |  j) |  j* |  j+  } | | _  | rg  | j, _- g  | j. _- xm |  j. j- D]_ }	 t/ |	 j |	 j* |	 j+  }
 | |
 _  | j. j- j0 |
  t1 |	 d  r|	 j2 | |	 |
  qWx |  j, j- D] } t3 | j | j* | j+ | j4  } | j5 | _5 | j6 | _6 | j7 | _7 | | _  | j, j- j0 |  t1 | d  r,| j2 | |	 |  q,Wn t j j8 d t9 |     t1 |  d  r|  j2 | |  |  | S)zo
    Clone a node and give it the new owner document.
    Called by Node.cloneNode and Document.importNode
    Tri   zCannot clone node %s):rO   rY   r/   r0   r5  r6  ZNODE_IMPORTEDr   r	   rJ   rN  rq   r   r   r   r   r   r   rv   r   r$   rN   r5   r+   rf  rF   ri  rG   r   rj  r   rm  r  r   rk  r   rp  r@  re  rR   rQ  r   r+  r,  r1  r(  r2  r7  rI   rd   ri   r8  r9  r:  r   rU   rz  r2   )rA   rP   ZnewOwnerDocumentrg   r;  r   rn  rM   r@   r   r<  r=  r>  r
   r
   r   rN   A  s~    					rN   c             C   s:   |  j  d d  } t |  d k r( | Sd  | d f Sd  S)Nr   r(      r   )r   r   )r   Zfieldsr
   r
   r   r     s    r   c             C   s<   |  | |   } | j    \ } } | j |  | j   | S)N)ZgetEventZ
expandNoderW  )funcargskwargsZeventsZtoktypeZrootNoder
   r
   r   _do_pulldom_parse  s
    
r  c             C   sf   | d k r0 | r0 d d l  m } | j |   Sd d l  m } t | j |  f d | d | i  Sd S)z3Parse a file into a DOM by filename or file object.Nr   )expatbuilder)pulldomparserbufsize)xml.domr  parser  r  )filer  r  r  r  r
   r
   r   r    s    r  c             C   sY   | d k r) d d l  m } | j |   Sd d l  m } t | j |  f d | i  Sd S)z&Parse a file into a DOM from a string.Nr   )r  )r  r  )r  r  parseStringr  r  )stringr  r  r  r
   r
   r   r    s    r  c             C   s[   |  rT t  |  t  r$ t j |   }  x- |  D]% \ } } t j j | |  s+ d  Sq+ Wt j S)N)r   r   r   Z_parse_feature_stringrR  rR   rS   )Zfeaturesfvr
   r
   r   getDOMImplementation  s    r  )7r   r   r  r/   r   r   r   r   Zxml.dom.minicompatZxml.dom.xmlbuilderr   r   r0   r	   rJ   r   r9   ZdefpropertyrB   rw   r~   r   r   r   r   objectr   ZAttributeListr   r   r   r   r  r  r  r   r!  r  r$  r%  r'  r*  r0  r8  r7  rD  rS  r:   rR  rN   r   r  r  r  r  r
   r
   r
   r   <module>   s   "

	y)GU	><(	O* OR

                                                                                                                                                                                                                                                                                                                                    # Deprecated alias for xml.etree.ElementTree

from xml.etree.ElementTree import *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
[2                 @   s   d  Z  d d l Z d d l Z d d l Z d d l m Z d d d g Z Gd d   d  Z Gd	 d   d  Z	 d
 d   Z
 Gd d   d e  Z Gd d   d e  Z Gd d   d  Z [ Gd d   d  Z Gd d   d  Z [ Gd d   d  Z d S)z4Implementation of the DOM Level 3 'LS-Load' feature.    N)
NodeFilter
DOMBuilderDOMEntityResolverDOMInputSourcec               @   s   e  Z d  Z d Z d Z d Z d Z d Z d Z d Z	 d Z
 d Z d Z d Z d Z d Z d Z d Z d Z d Z d Z d Z d Z d S)OptionszFeatures object that has variables set for each DOMBuilder feature.

    The DOMBuilder class uses an instance of this class to pass settings to
    the ExpatBuilder class.
       TFN)__name__
__module____qualname____doc__
namespacesnamespace_declarations
validationexternal_parameter_entitiesexternal_general_entitiesZexternal_dtd_subsetvalidate_if_schemaZvalidatedatatype_normalizationcreate_entity_ref_nodesentitieswhitespace_in_element_contentcdata_sectionscommentscharset_overrides_xml_encodinginfosetsupported_mediatypes_onlyerrorHandlerfilter r   r   (/usr/lib/python3.5/xml/dom/xmlbuilder.pyr      s(   r   c            5   @   s  e  Z d  Z d Z d Z d Z d Z d Z d Z d Z	 e e e e	 f Z
 d d   Z d d	   Z d
 d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d4 d5 g d6 d7 g d8 d9 g d: d; g d< d= g d> d? g d@ dA g dB dC g dD dE g dF dG g dH dI dJ g dK dL g dM dN g dO dP g dQ dR g dS dT g dU dV g dW dX g dY dZ g d[ d\ g d] g  d^ d_ d` da db dc dd de df dg g	 dh di g dj dk g dl dm g i Z d* d+   Z d, d-   Z d. d/   Z d0 d1   Z d2 d3   Z d S)nr   Nr            c             C   s   t    |  _ d  S)N)r   _options)selfr   r   r   __init__:   s    zDOMBuilder.__init__c             C   s   |  j  S)N)entityResolver)r#   r   r   r   _get_entityResolver=   s    zDOMBuilder._get_entityResolverc             C   s   | |  _  d  S)N)r%   )r#   r%   r   r   r   _set_entityResolver?   s    zDOMBuilder._set_entityResolverc             C   s   |  j  S)N)r   )r#   r   r   r   _get_errorHandlerB   s    zDOMBuilder._get_errorHandlerc             C   s   | |  _  d  S)N)r   )r#   r   r   r   r   _set_errorHandlerD   s    zDOMBuilder._set_errorHandlerc             C   s   |  j  S)N)r   )r#   r   r   r   _get_filterG   s    zDOMBuilder._get_filterc             C   s   | |  _  d  S)N)r   )r#   r   r   r   r   _set_filterI   s    zDOMBuilder._set_filterc             C   s   |  j  |  r | r d p d } y |  j t |  | f } Wn+ t k
 rk t j j d | f   Yq XxF | D] \ } } t |  j | |  qs Wn t j j	 d t
 |    d  S)Nr   r   zunsupported feature: %rzunknown feature: )supportsFeature	_settings_name_xformKeyErrorxmldomNotSupportedErrsetattrr"   NotFoundErrrepr)r#   namestateZsettingsvaluer   r   r   
setFeatureL   s    	zDOMBuilder.setFeaturec             C   s   t  |  j t |   S)N)hasattrr"   r.   )r#   r6   r   r   r   r,   Z   s    zDOMBuilder.supportsFeaturec             C   s+   t  |  | r d p d f } | |  j k S)Nr   r   )r.   r-   )r#   r6   r7   keyr   r   r   canSetFeature]   s    zDOMBuilder.canSetFeaturer   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   c             C   s   t  |  } y t |  j |  SWn t k
 r | d k r |  j } | j o | j o | j o | j o | j p | j	 p | j
 p | j p | j St j j d t |    Yn Xd  S)Nr   zfeature %s not known)r.   getattrr"   AttributeErrorr   r   r   r   r   r   r   r   r   r0   r1   r4   r5   )r#   r6   Zxnameoptionsr   r   r   
getFeature   s     									zDOMBuilder.getFeaturec             C   sC   |  j  r! |  j  j d  |  } n t   j d  |  } |  j |  S)N)r%   resolveEntityr   parse)r#   uriinputr   r   r   parseURI   s    	zDOMBuilder.parseURIc             C   sy   t  j  |  j  } |  j | _ |  j | _ | j } | d  k ri | j ri d d  l } | j j | j  } |  j	 | |  S)Nr   )
copyr"   r   r   
byteStreamsystemIdurllib.requestrequestZurlopen_parse_bytestream)r#   rD   r?   fpurllibr   r   r   rB      s    	zDOMBuilder.parsec             C   s+   | |  j  k r t d   t d   d  S)Nznot a legal actionzHaven't written this yet...)_legal_actions
ValueErrorNotImplementedError)r#   rD   Zcnodeactionr   r   r   parseWithContext   s    zDOMBuilder.parseWithContextc             C   s.   d d  l  } | j j j |  } | j |  S)Nr   )Zxml.dom.expatbuilderr1   ZexpatbuilderZmakeBuilderZ	parseFile)r#   streamr?   r0   Zbuilderr   r   r   rK      s    zDOMBuilder._parse_bytestream)r   r   )r   r   )r   r   )r   r   )r   r   )r   r   )r   r   )r   r   )r   r   )r   r   )r   r   )r   r   )r   r   )r   r   )r   r   )r   r   )r   r   )r   r   )r   r   )r   r   )r   r   )r   r   )r   r   )r   r   )r   r   )r   r   )r   r   )r   r   )r   r   )r   r   )r   r   )r   r   )r   r   )r   r   )r   r   )r   r   )r   r   )r   r   )r   r   )r   r   )r   r   )r   r   )r   r   )r   r   )r   r   )r   r   )r   r   )r   r   )r   r   )r   r   )r   r   )r   r   )r   r   )r   r   )r   r   )r   r   )r   r   )r   r   )r   r	   r
   r%   r   r   ZACTION_REPLACEZACTION_APPEND_AS_CHILDRENZACTION_INSERT_AFTERZACTION_INSERT_BEFORErN   r$   r&   r'   r(   r)   r*   r+   r9   r,   r<   r-   r@   rE   rB   rR   rK   r   r   r   r   r   -   s   

c             C   s   |  j    j d d  S)N-_)lowerreplace)r6   r   r   r   r.      s    r.   c               @   sF   e  Z d  Z d Z d d   Z d d   Z d d   Z d d	   Z d
 S)r   _openerc             C   s   | d  k	 s t   t   } | | _ | | _ |  j   j |  | _ |  j |  | _ d d  l	 } d d  l
 } | j j |  } | \ } } }	 }
 } } |	 r |	 j d  r | j |	  d }	 | | |	 |
 | | f } | j j |  | _ | S)Nr   /)AssertionErrorr   publicIdrH   _get_openeropenrG   _guess_media_encodingencoding	posixpathZurllib.parserB   ZurlparseendswithdirnameZ
urlunparsebaseURI)r#   r[   rH   sourcer`   rM   partsZschemeZnetlocpathZparamsZqueryZfragmentr   r   r   rA      s    			zDOMEntityResolver.resolveEntityc             C   s:   y |  j  SWn( t k
 r5 |  j   |  _  |  j  SYn Xd  S)N)rX   r>   _create_opener)r#   r   r   r   r\      s
    zDOMEntityResolver._get_openerc             C   s   d d  l  } | j j   S)Nr   )rI   rJ   Zbuild_opener)r#   rM   r   r   r   rg      s    z DOMEntityResolver._create_openerc             C   s_   | j  j   } d | k r[ x= | j   D]/ } | j d  r( | j d d  d j   Sq( Wd  S)NzContent-Typezcharset==r   )rG   infoZgetplist
startswithsplitrV   )r#   rd   ri   Zparamr   r   r   r^      s
    z'DOMEntityResolver._guess_media_encodingN)rX   )r   r	   r
   	__slots__rA   r\   rg   r^   r   r   r   r   r      s
   c               @   s   e  Z d  Z d' Z d d	   Z d
 d   Z d d   Z d d   Z d d   Z d d   Z	 d d   Z
 d d   Z d d   Z d d   Z d d   Z d d   Z d  d!   Z d" d#   Z d$ d%   Z d& S)(r   rG   characterStream
stringDatar_   r[   rH   rc   c             C   sC   d  |  _  d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  S)N)rG   rm   rn   r_   r[   rH   rc   )r#   r   r   r   r$     s    						zDOMInputSource.__init__c             C   s   |  j  S)N)rG   )r#   r   r   r   _get_byteStream  s    zDOMInputSource._get_byteStreamc             C   s   | |  _  d  S)N)rG   )r#   rG   r   r   r   _set_byteStream  s    zDOMInputSource._set_byteStreamc             C   s   |  j  S)N)rm   )r#   r   r   r   _get_characterStream  s    z#DOMInputSource._get_characterStreamc             C   s   | |  _  d  S)N)rm   )r#   rm   r   r   r   _set_characterStream  s    z#DOMInputSource._set_characterStreamc             C   s   |  j  S)N)rn   )r#   r   r   r   _get_stringData  s    zDOMInputSource._get_stringDatac             C   s   | |  _  d  S)N)rn   )r#   datar   r   r   _set_stringData  s    zDOMInputSource._set_stringDatac             C   s   |  j  S)N)r_   )r#   r   r   r   _get_encoding  s    zDOMInputSource._get_encodingc             C   s   | |  _  d  S)N)r_   )r#   r_   r   r   r   _set_encoding  s    zDOMInputSource._set_encodingc             C   s   |  j  S)N)r[   )r#   r   r   r   _get_publicId"  s    zDOMInputSource._get_publicIdc             C   s   | |  _  d  S)N)r[   )r#   r[   r   r   r   _set_publicId$  s    zDOMInputSource._set_publicIdc             C   s   |  j  S)N)rH   )r#   r   r   r   _get_systemId'  s    zDOMInputSource._get_systemIdc             C   s   | |  _  d  S)N)rH   )r#   rH   r   r   r   _set_systemId)  s    zDOMInputSource._set_systemIdc             C   s   |  j  S)N)rc   )r#   r   r   r   _get_baseURI,  s    zDOMInputSource._get_baseURIc             C   s   | |  _  d  S)N)rc   )r#   rC   r   r   r   _set_baseURI.  s    zDOMInputSource._set_baseURIN)rG   rm   rn   r_   r[   rH   rc   )r   r	   r
   rl   r$   ro   rp   rq   rr   rs   ru   rv   rw   rx   ry   rz   r{   r|   r}   r   r   r   r   r     s"    	c               @   s[   e  Z d  Z d Z d Z d Z d Z d Z e j	 Z
 d d   Z d d	   Z d
 d   Z d S)DOMBuilderFilterzSElement filter which can be used to tailor construction of
    a DOM instance.
    r   r   r    r!   c             C   s   |  j  S)N)
whatToShow)r#   r   r   r   _get_whatToShowC  s    z DOMBuilderFilter._get_whatToShowc             C   s   |  j  S)N)FILTER_ACCEPT)r#   elementr   r   r   
acceptNodeF  s    zDOMBuilderFilter.acceptNodec             C   s   |  j  S)N)r   )r#   r   r   r   r   startContainerI  s    zDOMBuilderFilter.startContainerN)r   r	   r
   r   r   ZFILTER_REJECTZFILTER_SKIPZFILTER_INTERRUPTr   ZSHOW_ALLr   r   r   r   r   r   r   r   r~   2  s   	r~   c               @   s4   e  Z d  Z d d   Z d d   Z d d   Z d S)_AsyncDeprecatedPropertyc             C   s)   | j  } t j d j d |  t  d  S)Nz+{cls}.async is deprecated; use {cls}.async_cls)r   warningswarnformatDeprecationWarning)r#   r   Zclsnamer   r   r   r   P  s    	z_AsyncDeprecatedProperty.warnc             C   s$   |  j  |  | d  k	 r  | j Sd S)NF)r   async_)r#   instancer   r   r   r   __get__V  s    z _AsyncDeprecatedProperty.__get__c             C   s'   |  j  t |   t | d |  d  S)Nr   )r   typer3   )r#   r   r8   r   r   r   __set__\  s    z _AsyncDeprecatedProperty.__set__N)r   r	   r
   r   r   r   r   r   r   r   r   O  s   r   c               @   sm   e  Z d  Z d Z e   Z d Z d d   Z d d   Z d d   Z	 d	 d
   Z
 d d   Z d d   Z d S)
DocumentLSz=Mixin to create documents that conform to the load/save spec.Fc             C   s   d S)NFr   )r#   r   r   r   
_get_asyncg  s    zDocumentLS._get_asyncc             C   s   | r t  j j d   d  S)Nz.asynchronous document loading is not supported)r0   r1   r2   )r#   asyncr   r   r   
_set_asyncj  s    	zDocumentLS._set_asyncc             C   s   t  d   d  S)Nz'haven't figured out what this means yet)rP   )r#   r   r   r   aborto  s    zDocumentLS.abortc             C   s   t  d   d  S)Nzhaven't written this yet)rP   )r#   rC   r   r   r   loadu  s    zDocumentLS.loadc             C   s   t  d   d  S)Nzhaven't written this yet)rP   )r#   rd   r   r   r   loadXMLx  s    zDocumentLS.loadXMLc             C   s=   | d  k r |  } n | j  |  k	 r3 t j j    | j   S)N)ZownerDocumentr0   r1   ZWrongDocumentErrZtoxml)r#   Zsnoder   r   r   saveXML{  s
    	zDocumentLS.saveXMLN)r   r	   r
   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   a  s   	r   c               @   s@   e  Z d  Z d Z d Z d d   Z d d   Z d d   Z d	 S)
DOMImplementationLSr   r   c             C   se   | d  k	 r t  j j d   | |  j k r4 t   S| |  j k rU t  j j d   t d   d  S)NzschemaType not yet supportedz'asynchronous builders are not supportedzunknown value for mode)r0   r1   r2   MODE_SYNCHRONOUSr   MODE_ASYNCHRONOUSrO   )r#   modeZ
schemaTyper   r   r   createDOMBuilder  s    				z$DOMImplementationLS.createDOMBuilderc             C   s   t  d   d  S)Nz-the writer interface hasn't been written yet!)rP   )r#   r   r   r   createDOMWriter  s    z#DOMImplementationLS.createDOMWriterc             C   s   t    S)N)r   )r#   r   r   r   createDOMInputSource  s    z(DOMImplementationLS.createDOMInputSourceN)r   r	   r
   r   r   r   r   r   r   r   r   r   r     s
   r   )r   rF   r   Zxml.domr0   Zxml.dom.NodeFilterr   __all__r   r   r.   objectr   r   r~   r   r   r   r   r   r   r   <module>   s     ,1"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         #
# ElementTree
# $Id: ElementPath.py 3375 2008-02-13 08:05:08Z fredrik $
#
# limited xpath support for element trees
#
# history:
# 2003-05-23 fl   created
# 2003-05-28 fl   added support for // etc
# 2003-08-27 fl   fixed parsing of periods in element names
# 2007-09-10 fl   new selection engine
# 2007-09-12 fl   fixed parent selector
# 2007-09-13 fl   added iterfind; changed findall to return a list
# 2007-11-30 fl   added namespaces support
# 2009-10-30 fl   added child element value filter
#
# Copyright (c) 2003-2009 by Fredrik Lundh.  All rights reserved.
#
# fredrik@pythonware.com
# http://www.pythonware.com
#
# --------------------------------------------------------------------
# The ElementTree toolkit is
#
# Copyright (c) 1999-2009 by Fredrik Lundh
#
# By obtaining, using, and/or copying this software and/or its
# associated documentation, you agree that you have read, understood,
# and will comply with the following terms and conditions:
#
# Permission to use, copy, modify, and distribute this software and
# its associated documentation for any purpose and without fee is
# hereby granted, provided that the above copyright notice appears in
# all copies, and that both that copyright notice and this permission
# notice appear in supporting documentation, and that the name of
# Secret Labs AB or the author not be used in advertising or publicity
# pertaining to distribution of the software without specific, written
# prior permission.
#
# SECRET LABS AB AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD
# TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANT-
# ABILITY AND FITNESS.  IN NO EVENT SHALL SECRET LABS AB OR THE AUTHOR
# BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY
# DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
# OF THIS SOFTWARE.
# --------------------------------------------------------------------

# Licensed to PSF under a Contributor Agreement.
# See http://www.python.org/psf/license for licensing details.

##
# Implementation module for XPath support.  There's usually no reason
# to import this module directly; the <b>ElementTree</b> does this for
# you, if needed.
##

import re

xpath_tokenizer_re = re.compile(
    "("
    "'[^']*'|\"[^\"]*\"|"
    "::|"
    "//?|"
    "\.\.|"
    "\(\)|"
    "[/.*:\[\]\(\)@=])|"
    "((?:\{[^}]+\})?[^/\[\]\(\)@=\s]+)|"
    "\s+"
    )

def xpath_tokenizer(pattern, namespaces=None):
    for token in xpath_tokenizer_re.findall(pattern):
        tag = token[1]
        if tag and tag[0] != "{" and ":" in tag:
            try:
                prefix, uri = tag.split(":", 1)
                if not namespaces:
                    raise KeyError
                yield token[0], "{%s}%s" % (namespaces[prefix], uri)
            except KeyError:
                raise SyntaxError("prefix %r not found in prefix map" % prefix)
        else:
            yield token

def get_parent_map(context):
    parent_map = context.parent_map
    if parent_map is None:
        context.parent_map = parent_map = {}
        for p in context.root.iter():
            for e in p:
                parent_map[e] = p
    return parent_map

def prepare_child(next, token):
    tag = token[1]
    def select(context, result):
        for elem in result:
            for e in elem:
                if e.tag == tag:
                    yield e
    return select

def prepare_star(next, token):
    def select(context, result):
        for elem in result:
            yield from elem
    return select

def prepare_self(next, token):
    def select(context, result):
        yield from result
    return select

def prepare_descendant(next, token):
    try:
        token = next()
    except StopIteration:
        return
    if token[0] == "*":
        tag = "*"
    elif not token[0]:
        tag = token[1]
    else:
        raise SyntaxError("invalid descendant")
    def select(context, result):
        for elem in result:
            for e in elem.iter(tag):
                if e is not elem:
                    yield e
    return select

def prepare_parent(next, token):
    def select(context, result):
        # FIXME: raise error if .. is applied at toplevel?
        parent_map = get_parent_map(context)
        result_map = {}
        for elem in result:
            if elem in parent_map:
                parent = parent_map[elem]
                if parent not in result_map:
                    result_map[parent] = None
                    yield parent
    return select

def prepare_predicate(next, token):
    # FIXME: replace with real parser!!! refs:
    # http://effbot.org/zone/simple-iterator-parser.htm
    # http://javascript.crockford.com/tdop/tdop.html
    signature = []
    predicate = []
    while 1:
        try:
            token = next()
        except StopIteration:
            return
        if token[0] == "]":
            break
        if token[0] and token[0][:1] in "'\"":
            token = "'", token[0][1:-1]
        signature.append(token[0] or "-")
        predicate.append(token[1])
    signature = "".join(signature)
    # use signature to determine predicate type
    if signature == "@-":
        # [@attribute] predicate
        key = predicate[1]
        def select(context, result):
            for elem in result:
                if elem.get(key) is not None:
                    yield elem
        return select
    if signature == "@-='":
        # [@attribute='value']
        key = predicate[1]
        value = predicate[-1]
        def select(context, result):
            for elem in result:
                if elem.get(key) == value:
                    yield elem
        return select
    if signature == "-" and not re.match("\-?\d+$", predicate[0]):
        # [tag]
        tag = predicate[0]
        def select(context, result):
            for elem in result:
                if elem.find(tag) is not None:
                    yield elem
        return select
    if signature == "-='" and not re.match("\-?\d+$", predicate[0]):
        # [tag='value']
        tag = predicate[0]
        value = predicate[-1]
        def select(context, result):
            for elem in result:
                for e in elem.findall(tag):
                    if "".join(e.itertext()) == value:
                        yield elem
                        break
        return select
    if signature == "-" or signature == "-()" or signature == "-()-":
        # [index] or [last()] or [last()-index]
        if signature == "-":
            # [index]
            index = int(predicate[0]) - 1
            if index < 0:
                raise SyntaxError("XPath position >= 1 expected")
        else:
            if predicate[0] != "last":
                raise SyntaxError("unsupported function")
            if signature == "-()-":
                try:
                    index = int(predicate[2]) - 1
                except ValueError:
                    raise SyntaxError("unsupported expression")
                if index > -2:
                    raise SyntaxError("XPath offset from last() must be negative")
            else:
                index = -1
        def select(context, result):
            parent_map = get_parent_map(context)
            for elem in result:
                try:
                    parent = parent_map[elem]
                    # FIXME: what if the selector is "*" ?
                    elems = list(parent.findall(elem.tag))
                    if elems[index] is elem:
                        yield elem
                except (IndexError, KeyError):
                    pass
        return select
    raise SyntaxError("invalid predicate")

ops = {
    "": prepare_child,
    "*": prepare_star,
    ".": prepare_self,
    "..": prepare_parent,
    "//": prepare_descendant,
    "[": prepare_predicate,
    }

_cache = {}

class _SelectorContext:
    parent_map = None
    def __init__(self, root):
        self.root = root

# --------------------------------------------------------------------

##
# Generate all matching objects.

def iterfind(elem, path, namespaces=None):
    # compile selector pattern
    cache_key = (path, None if namespaces is None
                            else tuple(sorted(namespaces.items())))
    if path[-1:] == "/":
        path = path + "*" # implicit all (FIXME: keep this?)
    try:
        selector = _cache[cache_key]
    except KeyError:
        if len(_cache) > 100:
            _cache.clear()
        if path[:1] == "/":
            raise SyntaxError("cannot use absolute path on element")
        next = iter(xpath_tokenizer(path, namespaces)).__next__
        try:
            token = next()
        except StopIteration:
            return
        selector = []
        while 1:
            try:
                selector.append(ops[token[0]](next, token))
            except StopIteration:
                raise SyntaxError("invalid path")
            try:
                token = next()
                if token[0] == "/":
                    token = next()
            except StopIteration:
                break
        _cache[cache_key] = selector
    # execute selector pattern
    result = [elem]
    context = _SelectorContext(elem)
    for select in selector:
        result = select(context, result)
    return result

##
# Find first matching object.

def find(elem, path, namespaces=None):
    return next(iterfind(elem, path, namespaces), None)

##
# Find all matching objects.

def findall(elem, path, namespaces=None):
    return list(iterfind(elem, path, namespaces))

##
# Find text for first matching object.

def findtext(elem, path, default=None, namespaces=None):
    try:
        elem = next(iterfind(elem, path, namespaces))
        return elem.text or ""
    except StopIteration:
        return default
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            """Lightweight XML support for Python.

 XML is an inherently hierarchical data format, and the most natural way to
 represent it is with a tree.  This module has two classes for this purpose:

    1. ElementTree represents the whole XML document as a tree and

    2. Element represents a single node in this tree.

 Interactions with the whole document (reading and writing to/from files) are
 usually done on the ElementTree level.  Interactions with a single XML element
 and its sub-elements are done on the Element level.

 Element is a flexible container object designed to store hierarchical data
 structures in memory. It can be described as a cross between a list and a
 dictionary.  Each Element has a number of properties associated with it:

    'tag' - a string containing the element's name.

    'attributes' - a Python dictionary storing the element's attributes.

    'text' - a string containing the element's text content.

    'tail' - an optional string containing text after the element's end tag.

    And a number of child elements stored in a Python sequence.

 To create an element instance, use the Element constructor,
 or the SubElement factory function.

 You can also use the ElementTree class to wrap an element structure
 and convert it to and from XML.

"""

#---------------------------------------------------------------------
# Licensed to PSF under a Contributor Agreement.
# See http://www.python.org/psf/license for licensing details.
#
# ElementTree
# Copyright (c) 1999-2008 by Fredrik Lundh.  All rights reserved.
#
# fredrik@pythonware.com
# http://www.pythonware.com
# --------------------------------------------------------------------
# The ElementTree toolkit is
#
# Copyright (c) 1999-2008 by Fredrik Lundh
#
# By obtaining, using, and/or copying this software and/or its
# associated documentation, you agree that you have read, understood,
# and will comply with the following terms and conditions:
#
# Permission to use, copy, modify, and distribute this software and
# its associated documentation for any purpose and without fee is
# hereby granted, provided that the above copyright notice appears in
# all copies, and that both that copyright notice and this permission
# notice appear in supporting documentation, and that the name of
# Secret Labs AB or the author not be used in advertising or publicity
# pertaining to distribution of the software without specific, written
# prior permission.
#
# SECRET LABS AB AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD
# TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANT-
# ABILITY AND FITNESS.  IN NO EVENT SHALL SECRET LABS AB OR THE AUTHOR
# BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY
# DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
# OF THIS SOFTWARE.
# --------------------------------------------------------------------

__all__ = [
    # public symbols
    "Comment",
    "dump",
    "Element", "ElementTree",
    "fromstring", "fromstringlist",
    "iselement", "iterparse",
    "parse", "ParseError",
    "PI", "ProcessingInstruction",
    "QName",
    "SubElement",
    "tostring", "tostringlist",
    "TreeBuilder",
    "VERSION",
    "XML", "XMLID",
    "XMLParser",
    "register_namespace",
    ]

VERSION = "1.3.0"

import sys
import re
import warnings
import io
import contextlib

from . import ElementPath


class ParseError(SyntaxError):
    """An error when parsing an XML document.

    In addition to its exception value, a ParseError contains
    two extra attributes:
        'code'     - the specific exception code
        'position' - the line and column of the error

    """
    pass

# --------------------------------------------------------------------


def iselement(element):
    """Return True if *element* appears to be an Element."""
    return hasattr(element, 'tag')


class Element:
    """An XML element.

    This class is the reference implementation of the Element interface.

    An element's length is its number of subelements.  That means if you
    want to check if an element is truly empty, you should check BOTH
    its length AND its text attribute.

    The element tag, attribute names, and attribute values can be either
    bytes or strings.

    *tag* is the element name.  *attrib* is an optional dictionary containing
    element attributes. *extra* are additional element attributes given as
    keyword arguments.

    Example form:
        <tag attrib>text<child/>...</tag>tail

    """

    tag = None
    """The element's name."""

    attrib = None
    """Dictionary of the element's attributes."""

    text = None
    """
    Text before first subelement. This is either a string or the value None.
    Note that if there is no text, this attribute may be either
    None or the empty string, depending on the parser.

    """

    tail = None
    """
    Text after this element's end tag, but before the next sibling element's
    start tag.  This is either a string or the value None.  Note that if there
    was no text, this attribute may be either None or an empty string,
    depending on the parser.

    """

    def __init__(self, tag, attrib={}, **extra):
        if not isinstance(attrib, dict):
            raise TypeError("attrib must be dict, not %s" % (
                attrib.__class__.__name__,))
        attrib = attrib.copy()
        attrib.update(extra)
        self.tag = tag
        self.attrib = attrib
        self._children = []

    def __repr__(self):
        return "<%s %r at %#x>" % (self.__class__.__name__, self.tag, id(self))

    def makeelement(self, tag, attrib):
        """Create a new element with the same type.

        *tag* is a string containing the element name.
        *attrib* is a dictionary containing the element attributes.

        Do not call this method, use the SubElement factory function instead.

        """
        return self.__class__(tag, attrib)

    def copy(self):
        """Return copy of current element.

        This creates a shallow copy. Subelements will be shared with the
        original tree.

        """
        elem = self.makeelement(self.tag, self.attrib)
        elem.text = self.text
        elem.tail = self.tail
        elem[:] = self
        return elem

    def __len__(self):
        return len(self._children)

    def __bool__(self):
        warnings.warn(
            "The behavior of this method will change in future versions.  "
            "Use specific 'len(elem)' or 'elem is not None' test instead.",
            FutureWarning, stacklevel=2
            )
        return len(self._children) != 0 # emulate old behaviour, for now

    def __getitem__(self, index):
        return self._children[index]

    def __setitem__(self, index, element):
        # if isinstance(index, slice):
        #     for elt in element:
        #         assert iselement(elt)
        # else:
        #     assert iselement(element)
        self._children[index] = element

    def __delitem__(self, index):
        del self._children[index]

    def append(self, subelement):
        """Add *subelement* to the end of this element.

        The new element will appear in document order after the last existing
        subelement (or directly after the text, if it's the first subelement),
        but before the end tag for this element.

        """
        self._assert_is_element(subelement)
        self._children.append(subelement)

    def extend(self, elements):
        """Append subelements from a sequence.

        *elements* is a sequence with zero or more elements.

        """
        for element in elements:
            self._assert_is_element(element)
        self._children.extend(elements)

    def insert(self, index, subelement):
        """Insert *subelement* at position *index*."""
        self._assert_is_element(subelement)
        self._children.insert(index, subelement)

    def _assert_is_element(self, e):
        # Need to refer to the actual Python implementation, not the
        # shadowing C implementation.
        if not isinstance(e, _Element_Py):
            raise TypeError('expected an Element, not %s' % type(e).__name__)

    def remove(self, subelement):
        """Remove matching subelement.

        Unlike the find methods, this method compares elements based on
        identity, NOT ON tag value or contents.  To remove subelements by
        other means, the easiest way is to use a list comprehension to
        select what elements to keep, and then use slice assignment to update
        the parent element.

        ValueError is raised if a matching element could not be found.

        """
        # assert iselement(element)
        self._children.remove(subelement)

    def getchildren(self):
        """(Deprecated) Return all subelements.

        Elements are returned in document order.

        """
        warnings.warn(
            "This method will be removed in future versions.  "
            "Use 'list(elem)' or iteration over elem instead.",
            DeprecationWarning, stacklevel=2
            )
        return self._children

    def find(self, path, namespaces=None):
        """Find first matching element by tag name or path.

        *path* is a string having either an element tag or an XPath,
        *namespaces* is an optional mapping from namespace prefix to full name.

        Return the first matching element, or None if no element was found.

        """
        return ElementPath.find(self, path, namespaces)

    def findtext(self, path, default=None, namespaces=None):
        """Find text for first matching element by tag name or path.

        *path* is a string having either an element tag or an XPath,
        *default* is the value to return if the element was not found,
        *namespaces* is an optional mapping from namespace prefix to full name.

        Return text content of first matching element, or default value if
        none was found.  Note that if an element is found having no text
        content, the empty string is returned.

        """
        return ElementPath.findtext(self, path, default, namespaces)

    def findall(self, path, namespaces=None):
        """Find all matching subelements by tag name or path.

        *path* is a string having either an element tag or an XPath,
        *namespaces* is an optional mapping from namespace prefix to full name.

        Returns list containing all matching elements in document order.

        """
        return ElementPath.findall(self, path, namespaces)

    def iterfind(self, path, namespaces=None):
        """Find all matching subelements by tag name or path.

        *path* is a string having either an element tag or an XPath,
        *namespaces* is an optional mapping from namespace prefix to full name.

        Return an iterable yielding all matching elements in document order.

        """
        return ElementPath.iterfind(self, path, namespaces)

    def clear(self):
        """Reset element.

        This function removes all subelements, clears all attributes, and sets
        the text and tail attributes to None.

        """
        self.attrib.clear()
        self._children = []
        self.text = self.tail = None

    def get(self, key, default=None):
        """Get element attribute.

        Equivalent to attrib.get, but some implementations may handle this a
        bit more efficiently.  *key* is what attribute to look for, and
        *default* is what to return if the attribute was not found.

        Returns a string containing the attribute value, or the default if
        attribute was not found.

        """
        return self.attrib.get(key, default)

    def set(self, key, value):
        """Set element attribute.

        Equivalent to attrib[key] = value, but some implementations may handle
        this a bit more efficiently.  *key* is what attribute to set, and
        *value* is the attribute value to set it to.

        """
        self.attrib[key] = value

    def keys(self):
        """Get list of attribute names.

        Names are returned in an arbitrary order, just like an ordinary
        Python dict.  Equivalent to attrib.keys()

        """
        return self.attrib.keys()

    def items(self):
        """Get element attributes as a sequence.

        The attributes are returned in arbitrary order.  Equivalent to
        attrib.items().

        Return a list of (name, value) tuples.

        """
        return self.attrib.items()

    def iter(self, tag=None):
        """Create tree iterator.

        The iterator loops over the element and all subelements in document
        order, returning all elements with a matching tag.

        If the tree structure is modified during iteration, new or removed
        elements may or may not be included.  To get a stable set, use the
        list() function on the iterator, and loop over the resulting list.

        *tag* is what tags to look for (default is to return all elements)

        Return an iterator containing all the matching elements.

        """
        if tag == "*":
            tag = None
        if tag is None or self.tag == tag:
            yield self
        for e in self._children:
            yield from e.iter(tag)

    # compatibility
    def getiterator(self, tag=None):
        # Change for a DeprecationWarning in 1.4
        warnings.warn(
            "This method will be removed in future versions.  "
            "Use 'elem.iter()' or 'list(elem.iter())' instead.",
            PendingDeprecationWarning, stacklevel=2
        )
        return list(self.iter(tag))

    def itertext(self):
        """Create text iterator.

        The iterator loops over the element and all subelements in document
        order, returning all inner text.

        """
        tag = self.tag
        if not isinstance(tag, str) and tag is not None:
            return
        t = self.text
        if t:
            yield t
        for e in self:
            yield from e.itertext()
            t = e.tail
            if t:
                yield t


def SubElement(parent, tag, attrib={}, **extra):
    """Subelement factory which creates an element instance, and appends it
    to an existing parent.

    The element tag, attribute names, and attribute values can be either
    bytes or Unicode strings.

    *parent* is the parent element, *tag* is the subelements name, *attrib* is
    an optional directory containing element attributes, *extra* are
    additional attributes given as keyword arguments.

    """
    attrib = attrib.copy()
    attrib.update(extra)
    element = parent.makeelement(tag, attrib)
    parent.append(element)
    return element


def Comment(text=None):
    """Comment element factory.

    This function creates a special element which the standard serializer
    serializes as an XML comment.

    *text* is a string containing the comment string.

    """
    element = Element(Comment)
    element.text = text
    return element


def ProcessingInstruction(target, text=None):
    """Processing Instruction element factory.

    This function creates a special element which the standard serializer
    serializes as an XML comment.

    *target* is a string containing the processing instruction, *text* is a
    string containing the processing instruction contents, if any.

    """
    element = Element(ProcessingInstruction)
    element.text = target
    if text:
        element.text = element.text + " " + text
    return element

PI = ProcessingInstruction


class QName:
    """Qualified name wrapper.

    This class can be used to wrap a QName attribute value in order to get
    proper namespace handing on output.

    *text_or_uri* is a string containing the QName value either in the form
    {uri}local, or if the tag argument is given, the URI part of a QName.

    *tag* is an optional argument which if given, will make the first
    argument (text_or_uri) be interpreted as a URI, and this argument (tag)
    be interpreted as a local name.

    """
    def __init__(self, text_or_uri, tag=None):
        if tag:
            text_or_uri = "{%s}%s" % (text_or_uri, tag)
        self.text = text_or_uri
    def __str__(self):
        return self.text
    def __repr__(self):
        return '<%s %r>' % (self.__class__.__name__, self.text)
    def __hash__(self):
        return hash(self.text)
    def __le__(self, other):
        if isinstance(other, QName):
            return self.text <= other.text
        return self.text <= other
    def __lt__(self, other):
        if isinstance(other, QName):
            return self.text < other.text
        return self.text < other
    def __ge__(self, other):
        if isinstance(other, QName):
            return self.text >= other.text
        return self.text >= other
    def __gt__(self, other):
        if isinstance(other, QName):
            return self.text > other.text
        return self.text > other
    def __eq__(self, other):
        if isinstance(other, QName):
            return self.text == other.text
        return self.text == other

# --------------------------------------------------------------------


class ElementTree:
    """An XML element hierarchy.

    This class also provides support for serialization to and from
    standard XML.

    *element* is an optional root element node,
    *file* is an optional file handle or file name of an XML file whose
    contents will be used to initialize the tree with.

    """
    def __init__(self, element=None, file=None):
        # assert element is None or iselement(element)
        self._root = element # first node
        if file:
            self.parse(file)

    def getroot(self):
        """Return root element of this tree."""
        return self._root

    def _setroot(self, element):
        """Replace root element of this tree.

        This will discard the current contents of the tree and replace it
        with the given element.  Use with care!

        """
        # assert iselement(element)
        self._root = element

    def parse(self, source, parser=None):
        """Load external XML document into element tree.

        *source* is a file name or file object, *parser* is an optional parser
        instance that defaults to XMLParser.

        ParseError is raised if the parser fails to parse the document.

        Returns the root element of the given source document.

        """
        close_source = False
        if not hasattr(source, "read"):
            source = open(source, "rb")
            close_source = True
        try:
            if parser is None:
                # If no parser was specified, create a default XMLParser
                parser = XMLParser()
                if hasattr(parser, '_parse_whole'):
                    # The default XMLParser, when it comes from an accelerator,
                    # can define an internal _parse_whole API for efficiency.
                    # It can be used to parse the whole source without feeding
                    # it with chunks.
                    self._root = parser._parse_whole(source)
                    return self._root
            while True:
                data = source.read(65536)
                if not data:
                    break
                parser.feed(data)
            self._root = parser.close()
            return self._root
        finally:
            if close_source:
                source.close()

    def iter(self, tag=None):
        """Create and return tree iterator for the root element.

        The iterator loops over all elements in this tree, in document order.

        *tag* is a string with the tag name to iterate over
        (default is to return all elements).

        """
        # assert self._root is not None
        return self._root.iter(tag)

    # compatibility
    def getiterator(self, tag=None):
        # Change for a DeprecationWarning in 1.4
        warnings.warn(
            "This method will be removed in future versions.  "
            "Use 'tree.iter()' or 'list(tree.iter())' instead.",
            PendingDeprecationWarning, stacklevel=2
        )
        return list(self.iter(tag))

    def find(self, path, namespaces=None):
        """Find first matching element by tag name or path.

        Same as getroot().find(path), which is Element.find()

        *path* is a string having either an element tag or an XPath,
        *namespaces* is an optional mapping from namespace prefix to full name.

        Return the first matching element, or None if no element was found.

        """
        # assert self._root is not None
        if path[:1] == "/":
            path = "." + path
            warnings.warn(
                "This search is broken in 1.3 and earlier, and will be "
                "fixed in a future version.  If you rely on the current "
                "behaviour, change it to %r" % path,
                FutureWarning, stacklevel=2
                )
        return self._root.find(path, namespaces)

    def findtext(self, path, default=None, namespaces=None):
        """Find first matching element by tag name or path.

        Same as getroot().findtext(path),  which is Element.findtext()

        *path* is a string having either an element tag or an XPath,
        *namespaces* is an optional mapping from namespace prefix to full name.

        Return the first matching element, or None if no element was found.

        """
        # assert self._root is not None
        if path[:1] == "/":
            path = "." + path
            warnings.warn(
                "This search is broken in 1.3 and earlier, and will be "
                "fixed in a future version.  If you rely on the current "
                "behaviour, change it to %r" % path,
                FutureWarning, stacklevel=2
                )
        return self._root.findtext(path, default, namespaces)

    def findall(self, path, namespaces=None):
        """Find all matching subelements by tag name or path.

        Same as getroot().findall(path), which is Element.findall().

        *path* is a string having either an element tag or an XPath,
        *namespaces* is an optional mapping from namespace prefix to full name.

        Return list containing all matching elements in document order.

        """
        # assert self._root is not None
        if path[:1] == "/":
            path = "." + path
            warnings.warn(
                "This search is broken in 1.3 and earlier, and will be "
                "fixed in a future version.  If you rely on the current "
                "behaviour, change it to %r" % path,
                FutureWarning, stacklevel=2
                )
        return self._root.findall(path, namespaces)

    def iterfind(self, path, namespaces=None):
        """Find all matching subelements by tag name or path.

        Same as getroot().iterfind(path), which is element.iterfind()

        *path* is a string having either an element tag or an XPath,
        *namespaces* is an optional mapping from namespace prefix to full name.

        Return an iterable yielding all matching elements in document order.

        """
        # assert self._root is not None
        if path[:1] == "/":
            path = "." + path
            warnings.warn(
                "This search is broken in 1.3 and earlier, and will be "
                "fixed in a future version.  If you rely on the current "
                "behaviour, change it to %r" % path,
                FutureWarning, stacklevel=2
                )
        return self._root.iterfind(path, namespaces)

    def write(self, file_or_filename,
              encoding=None,
              xml_declaration=None,
              default_namespace=None,
              method=None, *,
              short_empty_elements=True):
        """Write element tree to a file as XML.

        Arguments:
          *file_or_filename* -- file name or a file object opened for writing

          *encoding* -- the output encoding (default: US-ASCII)

          *xml_declaration* -- bool indicating if an XML declaration should be
                               added to the output. If None, an XML declaration
                               is added if encoding IS NOT either of:
                               US-ASCII, UTF-8, or Unicode

          *default_namespace* -- sets the default XML namespace (for "xmlns")

          *method* -- either "xml" (default), "html, "text", or "c14n"

          *short_empty_elements* -- controls the formatting of elements
                                    that contain no content. If True (default)
                                    they are emitted as a single self-closed
                                    tag, otherwise they are emitted as a pair
                                    of start/end tags

        """
        if not method:
            method = "xml"
        elif method not in _serialize:
            raise ValueError("unknown method %r" % method)
        if not encoding:
            if method == "c14n":
                encoding = "utf-8"
            else:
                encoding = "us-ascii"
        enc_lower = encoding.lower()
        with _get_writer(file_or_filename, enc_lower) as write:
            if method == "xml" and (xml_declaration or
                    (xml_declaration is None and
                     enc_lower not in ("utf-8", "us-ascii", "unicode"))):
                declared_encoding = encoding
                if enc_lower == "unicode":
                    # Retrieve the default encoding for the xml declaration
                    import locale
                    declared_encoding = locale.getpreferredencoding()
                write("<?xml version='1.0' encoding='%s'?>\n" % (
                    declared_encoding,))
            if method == "text":
                _serialize_text(write, self._root)
            else:
                qnames, namespaces = _namespaces(self._root, default_namespace)
                serialize = _serialize[method]
                serialize(write, self._root, qnames, namespaces,
                          short_empty_elements=short_empty_elements)

    def write_c14n(self, file):
        # lxml.etree compatibility.  use output method instead
        return self.write(file, method="c14n")

# --------------------------------------------------------------------
# serialization support

@contextlib.contextmanager
def _get_writer(file_or_filename, encoding):
    # returns text write method and release all resources after using
    try:
        write = file_or_filename.write
    except AttributeError:
        # file_or_filename is a file name
        if encoding == "unicode":
            file = open(file_or_filename, "w")
        else:
            file = open(file_or_filename, "w", encoding=encoding,
                        errors="xmlcharrefreplace")
        with file:
            yield file.write
    else:
        # file_or_filename is a file-like object
        # encoding determines if it is a text or binary writer
        if encoding == "unicode":
            # use a text writer as is
            yield write
        else:
            # wrap a binary writer with TextIOWrapper
            with contextlib.ExitStack() as stack:
                if isinstance(file_or_filename, io.BufferedIOBase):
                    file = file_or_filename
                elif isinstance(file_or_filename, io.RawIOBase):
                    file = io.BufferedWriter(file_or_filename)
                    # Keep the original file open when the BufferedWriter is
                    # destroyed
                    stack.callback(file.detach)
                else:
                    # This is to handle passed objects that aren't in the
                    # IOBase hierarchy, but just have a write method
                    file = io.BufferedIOBase()
                    file.writable = lambda: True
                    file.write = write
                    try:
                        # TextIOWrapper uses this methods to determine
                        # if BOM (for UTF-16, etc) should be added
                        file.seekable = file_or_filename.seekable
                        file.tell = file_or_filename.tell
                    except AttributeError:
                        pass
                file = io.TextIOWrapper(file,
                                        encoding=encoding,
                                        errors="xmlcharrefreplace",
                                        newline="\n")
                # Keep the original file open when the TextIOWrapper is
                # destroyed
                stack.callback(file.detach)
                yield file.write

def _namespaces(elem, default_namespace=None):
    # identify namespaces used in this tree

    # maps qnames to *encoded* prefix:local names
    qnames = {None: None}

    # maps uri:s to prefixes
    namespaces = {}
    if default_namespace:
        namespaces[default_namespace] = ""

    def add_qname(qname):
        # calculate serialized qname representation
        try:
            if qname[:1] == "{":
                uri, tag = qname[1:].rsplit("}", 1)
                prefix = namespaces.get(uri)
                if prefix is None:
                    prefix = _namespace_map.get(uri)
                    if prefix is None:
                        prefix = "ns%d" % len(namespaces)
                    if prefix != "xml":
                        namespaces[uri] = prefix
                if prefix:
                    qnames[qname] = "%s:%s" % (prefix, tag)
                else:
                    qnames[qname] = tag # default element
            else:
                if default_namespace:
                    # FIXME: can this be handled in XML 1.0?
                    raise ValueError(
                        "cannot use non-qualified names with "
                        "default_namespace option"
                        )
                qnames[qname] = qname
        except TypeError:
            _raise_serialization_error(qname)

    # populate qname and namespaces table
    for elem in elem.iter():
        tag = elem.tag
        if isinstance(tag, QName):
            if tag.text not in qnames:
                add_qname(tag.text)
        elif isinstance(tag, str):
            if tag not in qnames:
                add_qname(tag)
        elif tag is not None and tag is not Comment and tag is not PI:
            _raise_serialization_error(tag)
        for key, value in elem.items():
            if isinstance(key, QName):
                key = key.text
            if key not in qnames:
                add_qname(key)
            if isinstance(value, QName) and value.text not in qnames:
                add_qname(value.text)
        text = elem.text
        if isinstance(text, QName) and text.text not in qnames:
            add_qname(text.text)
    return qnames, namespaces

def _serialize_xml(write, elem, qnames, namespaces,
                   short_empty_elements, **kwargs):
    tag = elem.tag
    text = elem.text
    if tag is Comment:
        write("<!--%s-->" % text)
    elif tag is ProcessingInstruction:
        write("<?%s?>" % text)
    else:
        tag = qnames[tag]
        if tag is None:
            if text:
                write(_escape_cdata(text))
            for e in elem:
                _serialize_xml(write, e, qnames, None,
                               short_empty_elements=short_empty_elements)
        else:
            write("<" + tag)
            items = list(elem.items())
            if items or namespaces:
                if namespaces:
                    for v, k in sorted(namespaces.items(),
                                       key=lambda x: x[1]):  # sort on prefix
                        if k:
                            k = ":" + k
                        write(" xmlns%s=\"%s\"" % (
                            k,
                            _escape_attrib(v)
                            ))
                for k, v in sorted(items):  # lexical order
                    if isinstance(k, QName):
                        k = k.text
                    if isinstance(v, QName):
                        v = qnames[v.text]
                    else:
                        v = _escape_attrib(v)
                    write(" %s=\"%s\"" % (qnames[k], v))
            if text or len(elem) or not short_empty_elements:
                write(">")
                if text:
                    write(_escape_cdata(text))
                for e in elem:
                    _serialize_xml(write, e, qnames, None,
                                   short_empty_elements=short_empty_elements)
                write("</" + tag + ">")
            else:
                write(" />")
    if elem.tail:
        write(_escape_cdata(elem.tail))

HTML_EMPTY = ("area", "base", "basefont", "br", "col", "frame", "hr",
              "img", "input", "isindex", "link", "meta", "param")

try:
    HTML_EMPTY = set(HTML_EMPTY)
except NameError:
    pass

def _serialize_html(write, elem, qnames, namespaces, **kwargs):
    tag = elem.tag
    text = elem.text
    if tag is Comment:
        write("<!--%s-->" % _escape_cdata(text))
    elif tag is ProcessingInstruction:
        write("<?%s?>" % _escape_cdata(text))
    else:
        tag = qnames[tag]
        if tag is None:
            if text:
                write(_escape_cdata(text))
            for e in elem:
                _serialize_html(write, e, qnames, None)
        else:
            write("<" + tag)
            items = list(elem.items())
            if items or namespaces:
                if namespaces:
                    for v, k in sorted(namespaces.items(),
                                       key=lambda x: x[1]):  # sort on prefix
                        if k:
                            k = ":" + k
                        write(" xmlns%s=\"%s\"" % (
                            k,
                            _escape_attrib(v)
                            ))
                for k, v in sorted(items):  # lexical order
                    if isinstance(k, QName):
                        k = k.text
                    if isinstance(v, QName):
                        v = qnames[v.text]
                    else:
                        v = _escape_attrib_html(v)
                    # FIXME: handle boolean attributes
                    write(" %s=\"%s\"" % (qnames[k], v))
            write(">")
            ltag = tag.lower()
            if text:
                if ltag == "script" or ltag == "style":
                    write(text)
                else:
                    write(_escape_cdata(text))
            for e in elem:
                _serialize_html(write, e, qnames, None)
            if ltag not in HTML_EMPTY:
                write("</" + tag + ">")
    if elem.tail:
        write(_escape_cdata(elem.tail))

def _serialize_text(write, elem):
    for part in elem.itertext():
        write(part)
    if elem.tail:
        write(elem.tail)

_serialize = {
    "xml": _serialize_xml,
    "html": _serialize_html,
    "text": _serialize_text,
# this optional method is imported at the end of the module
#   "c14n": _serialize_c14n,
}


def register_namespace(prefix, uri):
    """Register a namespace prefix.

    The registry is global, and any existing mapping for either the
    given prefix or the namespace URI will be removed.

    *prefix* is the namespace prefix, *uri* is a namespace uri. Tags and
    attributes in this namespace will be serialized with prefix if possible.

    ValueError is raised if prefix is reserved or is invalid.

    """
    if re.match("ns\d+$", prefix):
        raise ValueError("Prefix format reserved for internal use")
    for k, v in list(_namespace_map.items()):
        if k == uri or v == prefix:
            del _namespace_map[k]
    _namespace_map[uri] = prefix

_namespace_map = {
    # "well-known" namespace prefixes
    "http://www.w3.org/XML/1998/namespace": "xml",
    "http://www.w3.org/1999/xhtml": "html",
    "http://www.w3.org/1999/02/22-rdf-syntax-ns#": "rdf",
    "http://schemas.xmlsoap.org/wsdl/": "wsdl",
    # xml schema
    "http://www.w3.org/2001/XMLSchema": "xs",
    "http://www.w3.org/2001/XMLSchema-instance": "xsi",
    # dublin core
    "http://purl.org/dc/elements/1.1/": "dc",
}
# For tests and troubleshooting
register_namespace._namespace_map = _namespace_map

def _raise_serialization_error(text):
    raise TypeError(
        "cannot serialize %r (type %s)" % (text, type(text).__name__)
        )

def _escape_cdata(text):
    # escape character data
    try:
        # it's worth avoiding do-nothing calls for strings that are
        # shorter than 500 character, or so.  assume that's, by far,
        # the most common case in most applications.
        if "&" in text:
            text = text.replace("&", "&amp;")
        if "<" in text:
            text = text.replace("<", "&lt;")
        if ">" in text:
            text = text.replace(">", "&gt;")
        return text
    except (TypeError, AttributeError):
        _raise_serialization_error(text)

def _escape_attrib(text):
    # escape attribute value
    try:
        if "&" in text:
            text = text.replace("&", "&amp;")
        if "<" in text:
            text = text.replace("<", "&lt;")
        if ">" in text:
            text = text.replace(">", "&gt;")
        if "\"" in text:
            text = text.replace("\"", "&quot;")
        # The following business with carriage returns is to satisfy
        # Section 2.11 of the XML specification, stating that 
        # CR or CR LN should be replaced with just LN
        # http://www.w3.org/TR/REC-xml/#sec-line-ends
        if "\r\n" in text:
            text = text.replace("\r\n", "\n")
        if "\r" in text:
            text = text.replace("\r", "\n")
        #The following four lines are issue 17582
        if "\n" in text:
            text = text.replace("\n", "&#10;")
        if "\t" in text:
            text = text.replace("\t", "&#09;")
        return text
    except (TypeError, AttributeError):
        _raise_serialization_error(text)

def _escape_attrib_html(text):
    # escape attribute value
    try:
        if "&" in text:
            text = text.replace("&", "&amp;")
        if ">" in text:
            text = text.replace(">", "&gt;")
        if "\"" in text:
            text = text.replace("\"", "&quot;")
        return text
    except (TypeError, AttributeError):
        _raise_serialization_error(text)

# --------------------------------------------------------------------

def tostring(element, encoding=None, method=None, *,
             short_empty_elements=True):
    """Generate string representation of XML element.

    All subelements are included.  If encoding is "unicode", a string
    is returned. Otherwise a bytestring is returned.

    *element* is an Element instance, *encoding* is an optional output
    encoding defaulting to US-ASCII, *method* is an optional output which can
    be one of "xml" (default), "html", "text" or "c14n".

    Returns an (optionally) encoded string containing the XML data.

    """
    stream = io.StringIO() if encoding == 'unicode' else io.BytesIO()
    ElementTree(element).write(stream, encoding, method=method,
                               short_empty_elements=short_empty_elements)
    return stream.getvalue()

class _ListDataStream(io.BufferedIOBase):
    """An auxiliary stream accumulating into a list reference."""
    def __init__(self, lst):
        self.lst = lst

    def writable(self):
        return True

    def seekable(self):
        return True

    def write(self, b):
        self.lst.append(b)

    def tell(self):
        return len(self.lst)

def tostringlist(element, encoding=None, method=None, *,
                 short_empty_elements=True):
    lst = []
    stream = _ListDataStream(lst)
    ElementTree(element).write(stream, encoding, method=method,
                               short_empty_elements=short_empty_elements)
    return lst


def dump(elem):
    """Write element tree or element structure to sys.stdout.

    This function should be used for debugging only.

    *elem* is either an ElementTree, or a single Element.  The exact output
    format is implementation dependent.  In this version, it's written as an
    ordinary XML file.

    """
    # debugging
    if not isinstance(elem, ElementTree):
        elem = ElementTree(elem)
    elem.write(sys.stdout, encoding="unicode")
    tail = elem.getroot().tail
    if not tail or tail[-1] != "\n":
        sys.stdout.write("\n")

# --------------------------------------------------------------------
# parsing


def parse(source, parser=None):
    """Parse XML document into element tree.

    *source* is a filename or file object containing XML data,
    *parser* is an optional parser instance defaulting to XMLParser.

    Return an ElementTree instance.

    """
    tree = ElementTree()
    tree.parse(source, parser)
    return tree


def iterparse(source, events=None, parser=None):
    """Incrementally parse XML document into ElementTree.

    This class also reports what's going on to the user based on the
    *events* it is initialized with.  The supported events are the strings
    "start", "end", "start-ns" and "end-ns" (the "ns" events are used to get
    detailed namespace information).  If *events* is omitted, only
    "end" events are reported.

    *source* is a filename or file object containing XML data, *events* is
    a list of events to report back, *parser* is an optional parser instance.

    Returns an iterator providing (event, elem) pairs.

    """
    close_source = False
    if not hasattr(source, "read"):
        source = open(source, "rb")
        close_source = True
    try:
        return _IterParseIterator(source, events, parser, close_source)
    except:
        if close_source:
            source.close()
        raise


class XMLPullParser:

    def __init__(self, events=None, *, _parser=None):
        # The _parser argument is for internal use only and must not be relied
        # upon in user code. It will be removed in a future release.
        # See http://bugs.python.org/issue17741 for more details.

        # _elementtree.c expects a list, not a deque
        self._events_queue = []
        self._index = 0
        self._parser = _parser or XMLParser(target=TreeBuilder())
        # wire up the parser for event reporting
        if events is None:
            events = ("end",)
        self._parser._setevents(self._events_queue, events)

    def feed(self, data):
        """Feed encoded data to parser."""
        if self._parser is None:
            raise ValueError("feed() called after end of stream")
        if data:
            try:
                self._parser.feed(data)
            except SyntaxError as exc:
                self._events_queue.append(exc)

    def _close_and_return_root(self):
        # iterparse needs this to set its root attribute properly :(
        root = self._parser.close()
        self._parser = None
        return root

    def close(self):
        """Finish feeding data to parser.

        Unlike XMLParser, does not return the root element. Use
        read_events() to consume elements from XMLPullParser.
        """
        self._close_and_return_root()

    def read_events(self):
        """Return an iterator over currently available (event, elem) pairs.

        Events are consumed from the internal event queue as they are
        retrieved from the iterator.
        """
        events = self._events_queue
        while True:
            index = self._index
            try:
                event = events[self._index]
                # Avoid retaining references to past events
                events[self._index] = None
            except IndexError:
                break
            index += 1
            # Compact the list in a O(1) amortized fashion
            # As noted above, _elementree.c needs a list, not a deque
            if index * 2 >= len(events):
                events[:index] = []
                self._index = 0
            else:
                self._index = index
            if isinstance(event, Exception):
                raise event
            else:
                yield event


class _IterParseIterator:

    def __init__(self, source, events, parser, close_source=False):
        # Use the internal, undocumented _parser argument for now; When the
        # parser argument of iterparse is removed, this can be killed.
        self._parser = XMLPullParser(events=events, _parser=parser)
        self._file = source
        self._close_file = close_source
        self.root = self._root = None

    def __next__(self):
        try:
            while 1:
                for event in self._parser.read_events():
                    return event
                if self._parser._parser is None:
                    break
                # load event buffer
                data = self._file.read(16 * 1024)
                if data:
                    self._parser.feed(data)
                else:
                    self._root = self._parser._close_and_return_root()
            self.root = self._root
        except:
            if self._close_file:
                self._file.close()
            raise
        if self._close_file:
            self._file.close()
        raise StopIteration

    def __iter__(self):
        return self


def XML(text, parser=None):
    """Parse XML document from string constant.

    This function can be used to embed "XML Literals" in Python code.

    *text* is a string containing XML data, *parser* is an
    optional parser instance, defaulting to the standard XMLParser.

    Returns an Element instance.

    """
    if not parser:
        parser = XMLParser(target=TreeBuilder())
    parser.feed(text)
    return parser.close()


def XMLID(text, parser=None):
    """Parse XML document from string constant for its IDs.

    *text* is a string containing XML data, *parser* is an
    optional parser instance, defaulting to the standard XMLParser.

    Returns an (Element, dict) tuple, in which the
    dict maps element id:s to elements.

    """
    if not parser:
        parser = XMLParser(target=TreeBuilder())
    parser.feed(text)
    tree = parser.close()
    ids = {}
    for elem in tree.iter():
        id = elem.get("id")
        if id:
            ids[id] = elem
    return tree, ids

# Parse XML document from string constant.  Alias for XML().
fromstring = XML

def fromstringlist(sequence, parser=None):
    """Parse XML document from sequence of string fragments.

    *sequence* is a list of other sequence, *parser* is an optional parser
    instance, defaulting to the standard XMLParser.

    Returns an Element instance.

    """
    if not parser:
        parser = XMLParser(target=TreeBuilder())
    for text in sequence:
        parser.feed(text)
    return parser.close()

# --------------------------------------------------------------------


class TreeBuilder:
    """Generic element structure builder.

    This builder converts a sequence of start, data, and end method
    calls to a well-formed element structure.

    You can use this class to build an element structure using a custom XML
    parser, or a parser for some other XML-like format.

    *element_factory* is an optional element factory which is called
    to create new Element instances, as necessary.

    """
    def __init__(self, element_factory=None):
        self._data = [] # data collector
        self._elem = [] # element stack
        self._last = None # last element
        self._tail = None # true if we're after an end tag
        if element_factory is None:
            element_factory = Element
        self._factory = element_factory

    def close(self):
        """Flush builder buffers and return toplevel document Element."""
        assert len(self._elem) == 0, "missing end tags"
        assert self._last is not None, "missing toplevel element"
        return self._last

    def _flush(self):
        if self._data:
            if self._last is not None:
                text = "".join(self._data)
                if self._tail:
                    assert self._last.tail is None, "internal error (tail)"
                    self._last.tail = text
                else:
                    assert self._last.text is None, "internal error (text)"
                    self._last.text = text
            self._data = []

    def data(self, data):
        """Add text to current element."""
        self._data.append(data)

    def start(self, tag, attrs):
        """Open new element and return it.

        *tag* is the element name, *attrs* is a dict containing element
        attributes.

        """
        self._flush()
        self._last = elem = self._factory(tag, attrs)
        if self._elem:
            self._elem[-1].append(elem)
        self._elem.append(elem)
        self._tail = 0
        return elem

    def end(self, tag):
        """Close and return current Element.

        *tag* is the element name.

        """
        self._flush()
        self._last = self._elem.pop()
        assert self._last.tag == tag,\
               "end tag mismatch (expected %s, got %s)" % (
                   self._last.tag, tag)
        self._tail = 1
        return self._last


# also see ElementTree and TreeBuilder
class XMLParser:
    """Element structure builder for XML source data based on the expat parser.

    *html* are predefined HTML entities (deprecated and not supported),
    *target* is an optional target object which defaults to an instance of the
    standard TreeBuilder class, *encoding* is an optional encoding string
    which if given, overrides the encoding specified in the XML file:
    http://www.iana.org/assignments/character-sets

    """

    def __init__(self, html=0, target=None, encoding=None):
        try:
            from xml.parsers import expat
        except ImportError:
            try:
                import pyexpat as expat
            except ImportError:
                raise ImportError(
                    "No module named expat; use SimpleXMLTreeBuilder instead"
                    )
        parser = expat.ParserCreate(encoding, "}")
        if target is None:
            target = TreeBuilder()
        # underscored names are provided for compatibility only
        self.parser = self._parser = parser
        self.target = self._target = target
        self._error = expat.error
        self._names = {} # name memo cache
        # main callbacks
        parser.DefaultHandlerExpand = self._default
        if hasattr(target, 'start'):
            parser.StartElementHandler = self._start
        if hasattr(target, 'end'):
            parser.EndElementHandler = self._end
        if hasattr(target, 'data'):
            parser.CharacterDataHandler = target.data
        # miscellaneous callbacks
        if hasattr(target, 'comment'):
            parser.CommentHandler = target.comment
        if hasattr(target, 'pi'):
            parser.ProcessingInstructionHandler = target.pi
        # Configure pyexpat: buffering, new-style attribute handling.
        parser.buffer_text = 1
        parser.ordered_attributes = 1
        parser.specified_attributes = 1
        self._doctype = None
        self.entity = {}
        try:
            self.version = "Expat %d.%d.%d" % expat.version_info
        except AttributeError:
            pass # unknown

    def _setevents(self, events_queue, events_to_report):
        # Internal API for XMLPullParser
        # events_to_report: a list of events to report during parsing (same as
        # the *events* of XMLPullParser's constructor.
        # events_queue: a list of actual parsing events that will be populated
        # by the underlying parser.
        #
        parser = self._parser
        append = events_queue.append
        for event_name in events_to_report:
            if event_name == "start":
                parser.ordered_attributes = 1
                parser.specified_attributes = 1
                def handler(tag, attrib_in, event=event_name, append=append,
                            start=self._start):
                    append((event, start(tag, attrib_in)))
                parser.StartElementHandler = handler
            elif event_name == "end":
                def handler(tag, event=event_name, append=append,
                            end=self._end):
                    append((event, end(tag)))
                parser.EndElementHandler = handler
            elif event_name == "start-ns":
                def handler(prefix, uri, event=event_name, append=append):
                    append((event, (prefix or "", uri or "")))
                parser.StartNamespaceDeclHandler = handler
            elif event_name == "end-ns":
                def handler(prefix, event=event_name, append=append):
                    append((event, None))
                parser.EndNamespaceDeclHandler = handler
            else:
                raise ValueError("unknown event %r" % event_name)

    def _raiseerror(self, value):
        err = ParseError(value)
        err.code = value.code
        err.position = value.lineno, value.offset
        raise err

    def _fixname(self, key):
        # expand qname, and convert name string to ascii, if possible
        try:
            name = self._names[key]
        except KeyError:
            name = key
            if "}" in name:
                name = "{" + name
            self._names[key] = name
        return name

    def _start(self, tag, attr_list):
        # Handler for expat's StartElementHandler. Since ordered_attributes
        # is set, the attributes are reported as a list of alternating
        # attribute name,value.
        fixname = self._fixname
        tag = fixname(tag)
        attrib = {}
        if attr_list:
            for i in range(0, len(attr_list), 2):
                attrib[fixname(attr_list[i])] = attr_list[i+1]
        return self.target.start(tag, attrib)

    def _end(self, tag):
        return self.target.end(self._fixname(tag))

    def _default(self, text):
        prefix = text[:1]
        if prefix == "&":
            # deal with undefined entities
            try:
                data_handler = self.target.data
            except AttributeError:
                return
            try:
                data_handler(self.entity[text[1:-1]])
            except KeyError:
                from xml.parsers import expat
                err = expat.error(
                    "undefined entity %s: line %d, column %d" %
                    (text, self.parser.ErrorLineNumber,
                    self.parser.ErrorColumnNumber)
                    )
                err.code = 11 # XML_ERROR_UNDEFINED_ENTITY
                err.lineno = self.parser.ErrorLineNumber
                err.offset = self.parser.ErrorColumnNumber
                raise err
        elif prefix == "<" and text[:9] == "<!DOCTYPE":
            self._doctype = [] # inside a doctype declaration
        elif self._doctype is not None:
            # parse doctype contents
            if prefix == ">":
                self._doctype = None
                return
            text = text.strip()
            if not text:
                return
            self._doctype.append(text)
            n = len(self._doctype)
            if n > 2:
                type = self._doctype[1]
                if type == "PUBLIC" and n == 4:
                    name, type, pubid, system = self._doctype
                    if pubid:
                        pubid = pubid[1:-1]
                elif type == "SYSTEM" and n == 3:
                    name, type, system = self._doctype
                    pubid = None
                else:
                    return
                if hasattr(self.target, "doctype"):
                    self.target.doctype(name, pubid, system[1:-1])
                elif self.doctype != self._XMLParser__doctype:
                    # warn about deprecated call
                    self._XMLParser__doctype(name, pubid, system[1:-1])
                    self.doctype(name, pubid, system[1:-1])
                self._doctype = None

    def doctype(self, name, pubid, system):
        """(Deprecated)  Handle doctype declaration

        *name* is the Doctype name, *pubid* is the public identifier,
        and *system* is the system identifier.

        """
        warnings.warn(
            "This method of XMLParser is deprecated.  Define doctype() "
            "method on the TreeBuilder target.",
            DeprecationWarning,
            )

    # sentinel, if doctype is redefined in a subclass
    __doctype = doctype

    def feed(self, data):
        """Feed encoded data to parser."""
        try:
            self.parser.Parse(data, 0)
        except self._error as v:
            self._raiseerror(v)

    def close(self):
        """Finish feeding data to parser and return element structure."""
        try:
            self.parser.Parse("", 1) # end of data
        except self._error as v:
            self._raiseerror(v)
        try:
            close_handler = self.target.close
        except AttributeError:
            pass
        else:
            return close_handler()
        finally:
            # get rid of circular references
            del self.parser, self._parser
            del self.target, self._target


# Import the C accelerators
try:
    # Element is going to be shadowed by the C implementation. We need to keep
    # the Python version of it accessible for some "creative" by external code
    # (see tests)
    _Element_Py = Element

    # Element, SubElement, ParseError, TreeBuilder, XMLParser
    from _elementtree import *
except ImportError:
    pass
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   
[                 @   sn   d  d l  Z  d d l m Z d Z e d Z e d Z Gd d   d e  Z d d	 d
  Z d d d  Z	 d S)    N   )ElementTreez!{http://www.w3.org/2001/XInclude}includeZfallbackc               @   s   e  Z d  Z d S)FatalIncludeErrorN)__name__
__module____qualname__ r	   r	   ./usr/lib/python3.5/xml/etree/ElementInclude.pyr   >   s   r   c          	   C   sx   | d k r= t  |  d   } t j |  j   } Wd  QRXn7 | sI d } t  |  d d |  } | j   } Wd  QRX| S)NxmlrbzUTF-8rencoding)openr   parseZgetrootread)hrefr   r   filedatar	   r	   r
   default_loaderM   s    r   c             C   s  | d  k r t  } d } x| t |   k  r|  | } | j t k r| j d  } | j d d  } | d k r | | |  } | d  k r t d | | f   t j |  } | j r | j p d | j | _ | |  | <q| d k r| | | | j d   } | d  k r+t d | | f   | re|  | d	 } | j pKd | | j p[d | _ n# |  j pqd | | j pd |  _ |  | =q qt d
 |   n2 | j t	 k rt d | j   n t
 | |  | d	 } q Wd  S)Nr   r   r   r   zcannot load %r as %r textr   r   z)unknown parse type in xi:include tag (%r)z0xi:fallback tag must be child of xi:include (%r))r   lentagXINCLUDE_INCLUDEgetr   copytailr   XINCLUDE_FALLBACKr   )elemloaderier   r   Znoder   r	   r	   r
   r   c   sF    
	&#)
r   r   r   ZXINCLUDEr   r   SyntaxErrorr   r   r   r	   r	   r	   r
   <module>3   s   

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
[D                 @   s   d  S)N r   r   r   (/usr/lib/python3.5/xml/etree/__init__.py<module>   s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         
[&                 @   s  d  d l  Z  e  j d  Z d d d  Z d d   Z d d   Z d	 d
   Z d d   Z d d   Z d d   Z	 d d   Z
 d e d e d e d e	 d e d e
 i Z i  Z Gd d   d  Z d d d  Z d d d  Z d d d   Z d d d! d"  Z d S)#    NzY('[^']*'|"[^"]*"|::|//?|\.\.|\(\)|[/.*:\[\]\(\)@=])|((?:\{[^}]+\})?[^/\[\]\(\)@=\s]+)|\s+c             c   s   x t  j |   D] } | d } | r | d d k r d | k r yE | j d d  \ } } | si t  | d d | | | f f VWq t k
 r t d |   Yq Xq | Vq Wd  S)N   r   {:z{%s}%sz!prefix %r not found in prefix map)xpath_tokenizer_refindallsplitKeyErrorSyntaxError)pattern
namespacestokentagprefixZuri r   +/usr/lib/python3.5/xml/etree/ElementPath.pyxpath_tokenizerI   s    
"!r   c             C   s[   |  j  } | d  k rW i  |  _  } x2 |  j j   D]! } x | D] } | | | <q? Wq2 W| S)N)
parent_maprootiter)contextr   per   r   r   get_parent_mapW   s    	r   c                s    | d     f d d   } | S)Nr   c             3   s:   x3 | D]+ } x" | D] } | j    k r | Vq Wq Wd  S)N)r   )r   resultelemr   )r   r   r   selectb   s    zprepare_child.<locals>.selectr   )nextr   r   r   )r   r   prepare_child`   s    
r   c             C   s   d d   } | S)Nc             s   s   x | D] } | Ed  Hq Wd  S)Nr   )r   r   r   r   r   r   r   j   s    zprepare_star.<locals>.selectr   )r   r   r   r   r   r   prepare_stari   s    r   c             C   s   d d   } | S)Nc             s   s   | Ed  Hd  S)Nr   )r   r   r   r   r   r   p   s    zprepare_self.<locals>.selectr   )r   r   r   r   r   r   prepare_selfo   s    r   c                sx   y |    } Wn t  k
 r% d  SYn X| d d k r? d   n# | d sV | d   n t d     f d d   } | S)Nr   *r   zinvalid descendantc             3   s@   x9 | D]1 } x( | j     D] } | | k	 r | Vq Wq Wd  S)N)r   )r   r   r   r   )r   r   r   r      s    z"prepare_descendant.<locals>.select)StopIterationr	   )r   r   r   r   )r   r   prepare_descendantt   s    		
r"   c             C   s   d d   } | S)Nc             s   sX   t  |   } i  } x? | D]7 } | | k r | | } | | k r d  | | <| Vq Wd  S)N)r   )r   r   r   Z
result_mapr   parentr   r   r   r      s    

zprepare_parent.<locals>.selectr   )r   r   r   r   r   r   prepare_parent   s    
r$   c                s  g  } g  } x y |    } Wn t  k
 r4 d  SYn X| d d k rF P| d r | d d  d  d k r d | d d d  f } | j | d p d  | j | d  q Wd j |  } | d k r | d   f d	 d
   } | S| d k r$| d  | d    f d d
   } | S| d k rgt j d | d  rg| d   f d d
   } | S| d k rt j d | d  r| d  | d    f d d
   } | S| d k s| d k s| d k r| d k rt | d  d     d k  rt d   n | d d k r2t d   | d k ry t | d  d   Wn t k
 rvt d   Yn X  d k rt d   n d     f d d
   } | St d   d  S) Nr   ]r   z'"'- z@-c             3   s/   x( | D]  } | j     d  k	 r | Vq Wd  S)N)get)r   r   r   )keyr   r   r      s    z!prepare_predicate.<locals>.selectz@-='c             3   s/   x( | D]  } | j      k r | Vq Wd  S)N)r)   )r   r   r   )r*   valuer   r   r      s    z\-?\d+$c             3   s/   x( | D]  } | j     d  k	 r | Vq Wd  S)N)find)r   r   r   )r   r   r   r      s    z-='c             3   sP   xI | D]A } x8 | j     D]' } d j | j     k r | VPq Wq Wd  S)Nr(   )r   joinZitertext)r   r   r   r   )r   r+   r   r   r      s
    z-()z-()-zXPath position >= 1 expectedZlastzunsupported function   zunsupported expressionz)XPath offset from last() must be negativec             3   sw   t  |   } xd | D]\ } y; | | } t | j | j   } |   | k rS | VWq t t f k
 rn Yq Xq Wd  S)N)r   listr   r   
IndexErrorr   )r   r   r   r   r#   Zelems)indexr   r   r      s    
	zinvalid predicater2   r2   r2   )r!   appendr-   rematchintr	   
ValueError)r   r   Z	signatureZ	predicater   r   )r1   r*   r   r+   r   prepare_predicate   sd    	$


#
#

$r9   r(   r    .z..z//[c               @   s"   e  Z d  Z d Z d d   Z d S)_SelectorContextNc             C   s   | |  _  d  S)N)r   )selfr   r   r   r   __init__   s    z_SelectorContext.__init__)__name__
__module____qualname__r   r>   r   r   r   r   r<      s   r<   c       
   !   C   s  | | d  k r d  n t  t | j     f } | d d   d k rP | d } y t | } Wn$t k
 rt t  d k r t j   | d  d  d k r t d   t t	 | |   j
 } y |   } Wn t k
 r d  SYn Xg  } x y" | j t | d | |   Wn t k
 r5t d   Yn Xy& |   } | d d k r[|   } Wq t k
 rqPYq Xq W| t | <Yn X|  g } t |   } x | D] }	 |	 | |  } qW| S)	Nr   /r    d   z#cannot use absolute path on elementr   zinvalid pathr2   )tuplesorteditems_cacher   lenclearr	   r   r   __next__r!   r4   opsr<   )
r   pathr   Z	cache_keyZselectorr   r   r   r   r   r   r   r   iterfind   sD    

	"	
	rM   c             C   s   t  t |  | |  d   S)N)r   rM   )r   rL   r   r   r   r   r,   )  s    r,   c             C   s   t  t |  | |   S)N)r/   rM   )r   rL   r   r   r   r   r   /  s    r   c             C   sF   y) t  t |  | |   }  |  j p' d SWn t k
 rA | SYn Xd  S)Nr(   )r   rM   textr!   )r   rL   defaultr   r   r   r   findtext5  s
    rP   )r5   compiler   r   r   r   r   r   r"   r$   r9   rK   rG   r<   rM   r,   r   rP   r   r   r   r   <module>;   s,   			Y
)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
[                 @   sw  d  Z  d d d d d d d d d	 d
 d d d d d d d d d d d d g Z d Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l m	 Z	 Gd d
   d
 e
  Z d d   Z Gd d   d  Z i  d d  Z d d  d  Z d d! d  Z e Z Gd" d   d  Z Gd# d   d  Z e j d$ d%    Z d d& d'  Z d( d)   Z d* d+ d, d- d. d/ d0 d1 d2 d3 d4 d5 d6 f Z y e e  Z Wn e k
 rYn Xd7 d8   Z d9 d:   Z d; e d< e d= e i Z d> d   Z d? d; d@ d< dA dB dC dD dE dF dG dH dI dJ i Z e e _ dK dL   Z  dM dN   Z! dO dP   Z" dQ dR   Z# d d dS dT dU d Z$ GdV dW   dW e j%  Z& d d dS dT dX d Z' dY d   Z( d dZ d	  Z) d d d[ d  Z* Gd\ d]   d]  Z+ Gd^ d_   d_  Z, d d` d  Z- d da d  Z. e- Z/ d db d  Z0 Gdc d   d  Z1 Gdd d   d  Z2 y e Z3 d de l4 TWn e5 k
 rrYn Xd S)fa  Lightweight XML support for Python.

 XML is an inherently hierarchical data format, and the most natural way to
 represent it is with a tree.  This module has two classes for this purpose:

    1. ElementTree represents the whole XML document as a tree and

    2. Element represents a single node in this tree.

 Interactions with the whole document (reading and writing to/from files) are
 usually done on the ElementTree level.  Interactions with a single XML element
 and its sub-elements are done on the Element level.

 Element is a flexible container object designed to store hierarchical data
 structures in memory. It can be described as a cross between a list and a
 dictionary.  Each Element has a number of properties associated with it:

    'tag' - a string containing the element's name.

    'attributes' - a Python dictionary storing the element's attributes.

    'text' - a string containing the element's text content.

    'tail' - an optional string containing text after the element's end tag.

    And a number of child elements stored in a Python sequence.

 To create an element instance, use the Element constructor,
 or the SubElement factory function.

 You can also use the ElementTree class to wrap an element structure
 and convert it to and from XML.

CommentdumpElementElementTree
fromstringfromstringlist	iselement	iterparseparse
ParseErrorPIProcessingInstructionQName
SubElementtostringtostringlistTreeBuilderVERSIONXMLXMLID	XMLParserregister_namespacez1.3.0    N   )ElementPathc               @   s   e  Z d  Z d Z d S)r
   zAn error when parsing an XML document.

    In addition to its exception value, a ParseError contains
    two extra attributes:
        'code'     - the specific exception code
        'position' - the line and column of the error

    N)__name__
__module____qualname____doc__ r   r   +/usr/lib/python3.5/xml/etree/ElementTree.pyr
   g   s   c             C   s   t  |  d  S)z2Return True if *element* appears to be an Element.tag)hasattr)elementr   r   r   r   u   s    c               @   s  e  Z d  Z d Z d Z d Z d Z d Z i  d d  Z d d   Z	 d d   Z
 d	 d
   Z d d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d d    Z d d! d"  Z d d d# d$  Z d d% d&  Z d d' d(  Z d) d*   Z d d+ d,  Z d- d.   Z d/ d0   Z d1 d2   Z d d3 d4  Z  d d5 d6  Z! d7 d8   Z" d S)9r   ah  An XML element.

    This class is the reference implementation of the Element interface.

    An element's length is its number of subelements.  That means if you
    want to check if an element is truly empty, you should check BOTH
    its length AND its text attribute.

    The element tag, attribute names, and attribute values can be either
    bytes or strings.

    *tag* is the element name.  *attrib* is an optional dictionary containing
    element attributes. *extra* are additional element attributes given as
    keyword arguments.

    Example form:
        <tag attrib>text<child/>...</tag>tail

    Nc             K   s`   t  | t  s( t d | j j f   | j   } | j |  | |  _ | |  _ g  |  _	 d  S)Nzattrib must be dict, not %s)

isinstancedict	TypeError	__class__r   copyupdater    attrib	_children)selfr    r)   extrar   r   r   __init__   s    		zElement.__init__c             C   s    d |  j  j |  j t |   f S)Nz<%s %r at %#x>)r&   r   r    id)r+   r   r   r   __repr__   s    zElement.__repr__c             C   s   |  j  | |  S)zCreate a new element with the same type.

        *tag* is a string containing the element name.
        *attrib* is a dictionary containing the element attributes.

        Do not call this method, use the SubElement factory function instead.

        )r&   )r+   r    r)   r   r   r   makeelement   s    	zElement.makeelementc             C   sD   |  j  |  j |  j  } |  j | _ |  j | _ |  | d d  <| S)zReturn copy of current element.

        This creates a shallow copy. Subelements will be shared with the
        original tree.

        N)r0   r    r)   texttail)r+   elemr   r   r   r'      s
    zElement.copyc             C   s   t  |  j  S)N)lenr*   )r+   r   r   r   __len__   s    zElement.__len__c             C   s)   t  j d t d d t |  j  d k S)NzyThe behavior of this method will change in future versions.  Use specific 'len(elem)' or 'elem is not None' test instead.
stacklevel   r   )warningswarnFutureWarningr4   r*   )r+   r   r   r   __bool__   s    zElement.__bool__c             C   s   |  j  | S)N)r*   )r+   indexr   r   r   __getitem__   s    zElement.__getitem__c             C   s   | |  j  | <d  S)N)r*   )r+   r<   r"   r   r   r   __setitem__   s    zElement.__setitem__c             C   s   |  j  | =d  S)N)r*   )r+   r<   r   r   r   __delitem__   s    zElement.__delitem__c             C   s!   |  j  |  |  j j |  d S)a  Add *subelement* to the end of this element.

        The new element will appear in document order after the last existing
        subelement (or directly after the text, if it's the first subelement),
        but before the end tag for this element.

        N)_assert_is_elementr*   append)r+   
subelementr   r   r   rA      s    zElement.appendc             C   s2   x | D] } |  j  |  q W|  j j |  d S)zkAppend subelements from a sequence.

        *elements* is a sequence with zero or more elements.

        N)r@   r*   extend)r+   elementsr"   r   r   r   rC      s    zElement.extendc             C   s$   |  j  |  |  j j | |  d S)z(Insert *subelement* at position *index*.N)r@   r*   insert)r+   r<   rB   r   r   r   rE      s    zElement.insertc             C   s,   t  | t  s( t d t |  j   d  S)Nzexpected an Element, not %s)r#   _Element_Pyr%   typer   )r+   er   r   r   r@      s    zElement._assert_is_elementc             C   s   |  j  j |  d S)a  Remove matching subelement.

        Unlike the find methods, this method compares elements based on
        identity, NOT ON tag value or contents.  To remove subelements by
        other means, the easiest way is to use a list comprehension to
        select what elements to keep, and then use slice assignment to update
        the parent element.

        ValueError is raised if a matching element could not be found.

        N)r*   remove)r+   rB   r   r   r   rI     s    zElement.removec             C   s   t  j d t d d |  j S)z`(Deprecated) Return all subelements.

        Elements are returned in document order.

        zaThis method will be removed in future versions.  Use 'list(elem)' or iteration over elem instead.r6   r7   )r8   r9   DeprecationWarningr*   )r+   r   r   r   getchildren  s    zElement.getchildrenc             C   s   t  j |  | |  S)a  Find first matching element by tag name or path.

        *path* is a string having either an element tag or an XPath,
        *namespaces* is an optional mapping from namespace prefix to full name.

        Return the first matching element, or None if no element was found.

        )r   find)r+   path
namespacesr   r   r   rL      s    	zElement.findc             C   s   t  j |  | | |  S)a  Find text for first matching element by tag name or path.

        *path* is a string having either an element tag or an XPath,
        *default* is the value to return if the element was not found,
        *namespaces* is an optional mapping from namespace prefix to full name.

        Return text content of first matching element, or default value if
        none was found.  Note that if an element is found having no text
        content, the empty string is returned.

        )r   findtext)r+   rM   defaultrN   r   r   r   rO   +  s    zElement.findtextc             C   s   t  j |  | |  S)a  Find all matching subelements by tag name or path.

        *path* is a string having either an element tag or an XPath,
        *namespaces* is an optional mapping from namespace prefix to full name.

        Returns list containing all matching elements in document order.

        )r   findall)r+   rM   rN   r   r   r   rQ   9  s    	zElement.findallc             C   s   t  j |  | |  S)a   Find all matching subelements by tag name or path.

        *path* is a string having either an element tag or an XPath,
        *namespaces* is an optional mapping from namespace prefix to full name.

        Return an iterable yielding all matching elements in document order.

        )r   iterfind)r+   rM   rN   r   r   r   rR   D  s    	zElement.iterfindc             C   s*   |  j  j   g  |  _ d |  _ |  _ d S)zReset element.

        This function removes all subelements, clears all attributes, and sets
        the text and tail attributes to None.

        N)r)   clearr*   r1   r2   )r+   r   r   r   rS   O  s    	zElement.clearc             C   s   |  j  j | |  S)ag  Get element attribute.

        Equivalent to attrib.get, but some implementations may handle this a
        bit more efficiently.  *key* is what attribute to look for, and
        *default* is what to return if the attribute was not found.

        Returns a string containing the attribute value, or the default if
        attribute was not found.

        )r)   get)r+   keyrP   r   r   r   rT   Z  s    zElement.getc             C   s   | |  j  | <d S)zSet element attribute.

        Equivalent to attrib[key] = value, but some implementations may handle
        this a bit more efficiently.  *key* is what attribute to set, and
        *value* is the attribute value to set it to.

        N)r)   )r+   rU   valuer   r   r   setg  s    zElement.setc             C   s   |  j  j   S)zGet list of attribute names.

        Names are returned in an arbitrary order, just like an ordinary
        Python dict.  Equivalent to attrib.keys()

        )r)   keys)r+   r   r   r   rX   q  s    zElement.keysc             C   s   |  j  j   S)zGet element attributes as a sequence.

        The attributes are returned in arbitrary order.  Equivalent to
        attrib.items().

        Return a list of (name, value) tuples.

        )r)   items)r+   r   r   r   rY   z  s    	zElement.itemsc             c   s\   | d k r d } | d k s- |  j  | k r2 |  Vx# |  j D] } | j |  Ed Hq< Wd S)a  Create tree iterator.

        The iterator loops over the element and all subelements in document
        order, returning all elements with a matching tag.

        If the tree structure is modified during iteration, new or removed
        elements may or may not be included.  To get a stable set, use the
        list() function on the iterator, and loop over the resulting list.

        *tag* is what tags to look for (default is to return all elements)

        Return an iterator containing all the matching elements.

        *N)r    r*   iter)r+   r    rH   r   r   r   r[     s    zElement.iterc             C   s)   t  j d t d d t |  j |   S)NzbThis method will be removed in future versions.  Use 'elem.iter()' or 'list(elem.iter())' instead.r6   r7   )r8   r9   PendingDeprecationWarninglistr[   )r+   r    r   r   r   getiterator  s    zElement.getiteratorc             c   su   |  j  } t | t  r) | d k	 r) d S|  j } | r= | Vx1 |  D]) } | j   Ed H| j } | rD | VqD Wd S)zCreate text iterator.

        The iterator loops over the element and all subelements in document
        order, returning all inner text.

        N)r    r#   strr1   itertextr2   )r+   r    trH   r   r   r   r`     s    			zElement.itertext)#r   r   r   r   r    r)   r1   r2   r-   r/   r0   r'   r5   r;   r=   r>   r?   rA   rC   rE   r@   rI   rK   rL   rO   rQ   rR   rS   rT   rW   rX   rY   r[   r^   r`   r   r   r   r   r   z   s@   	


		c             K   s<   | j    } | j |  |  j | |  } |  j |  | S)a  Subelement factory which creates an element instance, and appends it
    to an existing parent.

    The element tag, attribute names, and attribute values can be either
    bytes or Unicode strings.

    *parent* is the parent element, *tag* is the subelements name, *attrib* is
    an optional directory containing element attributes, *extra* are
    additional attributes given as keyword arguments.

    )r'   r(   r0   rA   )parentr    r)   r,   r"   r   r   r   r     s
    c             C   s   t  t  } |  | _ | S)zComment element factory.

    This function creates a special element which the standard serializer
    serializes as an XML comment.

    *text* is a string containing the comment string.

    )r   r   r1   )r1   r"   r   r   r   r     s    		c             C   s3   t  t  } |  | _ | r/ | j d | | _ | S)a*  Processing Instruction element factory.

    This function creates a special element which the standard serializer
    serializes as an XML comment.

    *target* is a string containing the processing instruction, *text* is a
    string containing the processing instruction contents, if any.

     )r   r   r1   )targetr1   r"   r   r   r   r     s
    
	c               @   s   e  Z d  Z d Z d d d  Z d d   Z d d   Z d	 d
   Z d d   Z d d   Z	 d d   Z
 d d   Z d d   Z d S)r   a  Qualified name wrapper.

    This class can be used to wrap a QName attribute value in order to get
    proper namespace handing on output.

    *text_or_uri* is a string containing the QName value either in the form
    {uri}local, or if the tag argument is given, the URI part of a QName.

    *tag* is an optional argument which if given, will make the first
    argument (text_or_uri) be interpreted as a URI, and this argument (tag)
    be interpreted as a local name.

    Nc             C   s#   | r d | | f } | |  _  d  S)Nz{%s}%s)r1   )r+   Ztext_or_urir    r   r   r   r-     s    zQName.__init__c             C   s   |  j  S)N)r1   )r+   r   r   r   __str__  s    zQName.__str__c             C   s   d |  j  j |  j f S)Nz<%s %r>)r&   r   r1   )r+   r   r   r   r/     s    zQName.__repr__c             C   s   t  |  j  S)N)hashr1   )r+   r   r   r   __hash__  s    zQName.__hash__c             C   s,   t  | t  r |  j | j k S|  j | k S)N)r#   r   r1   )r+   otherr   r   r   __le__  s    zQName.__le__c             C   s,   t  | t  r |  j | j k  S|  j | k  S)N)r#   r   r1   )r+   rh   r   r   r   __lt__	  s    zQName.__lt__c             C   s,   t  | t  r |  j | j k S|  j | k S)N)r#   r   r1   )r+   rh   r   r   r   __ge__  s    zQName.__ge__c             C   s,   t  | t  r |  j | j k S|  j | k S)N)r#   r   r1   )r+   rh   r   r   r   __gt__  s    zQName.__gt__c             C   s,   t  | t  r |  j | j k S|  j | k S)N)r#   r   r1   )r+   rh   r   r   r   __eq__  s    zQName.__eq__)r   r   r   r   r-   re   r/   rg   ri   rj   rk   rl   rm   r   r   r   r   r     s   c               @   s   e  Z d  Z d Z d d d d  Z d d   Z d d   Z d d	 d
  Z d d d  Z d d d  Z	 d d d  Z
 d d d d  Z d d d  Z d d d  Z d d d d d d d d Z d d   Z d S)r   a%  An XML element hierarchy.

    This class also provides support for serialization to and from
    standard XML.

    *element* is an optional root element node,
    *file* is an optional file handle or file name of an XML file whose
    contents will be used to initialize the tree with.

    Nc             C   s    | |  _  | r |  j |  d  S)N)_rootr	   )r+   r"   filer   r   r   r-   (  s    	zElementTree.__init__c             C   s   |  j  S)z!Return root element of this tree.)rn   )r+   r   r   r   getroot.  s    zElementTree.getrootc             C   s   | |  _  d S)zReplace root element of this tree.

        This will discard the current contents of the tree and replace it
        with the given element.  Use with care!

        N)rn   )r+   r"   r   r   r   _setroot2  s    zElementTree._setrootc          
   C   s   d } t  | d  s* t | d  } d } z | d k rj t   } t  | d  rj | j |  |  _ |  j Sx' | j d  } | s P| j |  qm W| j   |  _ |  j SWd | r | j   Xd S)a=  Load external XML document into element tree.

        *source* is a file name or file object, *parser* is an optional parser
        instance that defaults to XMLParser.

        ParseError is raised if the parser fails to parse the document.

        Returns the root element of the given source document.

        FreadrbTN_parse_wholei   )r!   openr   rt   rn   rr   feedclose)r+   sourceparserclose_sourcedatar   r   r   r	   <  s&    	zElementTree.parsec             C   s   |  j  j |  S)zCreate and return tree iterator for the root element.

        The iterator loops over all elements in this tree, in document order.

        *tag* is a string with the tag name to iterate over
        (default is to return all elements).

        )rn   r[   )r+   r    r   r   r   r[   a  s    
zElementTree.iterc             C   s)   t  j d t d d t |  j |   S)NzbThis method will be removed in future versions.  Use 'tree.iter()' or 'list(tree.iter())' instead.r6   r7   )r8   r9   r\   r]   r[   )r+   r    r   r   r   r^   n  s    zElementTree.getiteratorc             C   sM   | d d  d k r: d | } t  j d | t d d |  j j | |  S)a\  Find first matching element by tag name or path.

        Same as getroot().find(path), which is Element.find()

        *path* is a string having either an element tag or an XPath,
        *namespaces* is an optional mapping from namespace prefix to full name.

        Return the first matching element, or None if no element was found.

        Nr   /.zThis search is broken in 1.3 and earlier, and will be fixed in a future version.  If you rely on the current behaviour, change it to %rr6   r7   )r8   r9   r:   rn   rL   )r+   rM   rN   r   r   r   rL   w  s    
zElementTree.findc             C   sP   | d d  d k r: d | } t  j d | t d d |  j j | | |  S)ae  Find first matching element by tag name or path.

        Same as getroot().findtext(path),  which is Element.findtext()

        *path* is a string having either an element tag or an XPath,
        *namespaces* is an optional mapping from namespace prefix to full name.

        Return the first matching element, or None if no element was found.

        Nr   r|   r}   zThis search is broken in 1.3 and earlier, and will be fixed in a future version.  If you rely on the current behaviour, change it to %rr6   r7   )r8   r9   r:   rn   rO   )r+   rM   rP   rN   r   r   r   rO     s    
zElementTree.findtextc             C   sM   | d d  d k r: d | } t  j d | t d d |  j j | |  S)aa  Find all matching subelements by tag name or path.

        Same as getroot().findall(path), which is Element.findall().

        *path* is a string having either an element tag or an XPath,
        *namespaces* is an optional mapping from namespace prefix to full name.

        Return list containing all matching elements in document order.

        Nr   r|   r}   zThis search is broken in 1.3 and earlier, and will be fixed in a future version.  If you rely on the current behaviour, change it to %rr6   r7   )r8   r9   r:   rn   rQ   )r+   rM   rN   r   r   r   rQ     s    
zElementTree.findallc             C   sM   | d d  d k r: d | } t  j d | t d d |  j j | |  S)ag  Find all matching subelements by tag name or path.

        Same as getroot().iterfind(path), which is element.iterfind()

        *path* is a string having either an element tag or an XPath,
        *namespaces* is an optional mapping from namespace prefix to full name.

        Return an iterable yielding all matching elements in document order.

        Nr   r|   r}   zThis search is broken in 1.3 and earlier, and will be fixed in a future version.  If you rely on the current behaviour, change it to %rr6   r7   )r8   r9   r:   rn   rR   )r+   rM   rN   r   r   r   rR     s    
zElementTree.iterfindshort_empty_elementsTc            C   s7  | s d } n | t  k r+ t d |   | sL | d k rF d } n d } | j   } t | |   } | d k r | s | d k r | d k r | }	 | d k r d d l }
 |
 j   }	 | d	 |	 f  | d
 k r t | |  j  n> t |  j |  \ } } t  | } | | |  j | | d | Wd QRXd S)a  Write element tree to a file as XML.

        Arguments:
          *file_or_filename* -- file name or a file object opened for writing

          *encoding* -- the output encoding (default: US-ASCII)

          *xml_declaration* -- bool indicating if an XML declaration should be
                               added to the output. If None, an XML declaration
                               is added if encoding IS NOT either of:
                               US-ASCII, UTF-8, or Unicode

          *default_namespace* -- sets the default XML namespace (for "xmlns")

          *method* -- either "xml" (default), "html, "text", or "c14n"

          *short_empty_elements* -- controls the formatting of elements
                                    that contain no content. If True (default)
                                    they are emitted as a single self-closed
                                    tag, otherwise they are emitted as a pair
                                    of start/end tags

        xmlzunknown method %rc14nutf-8us-asciiNunicoder   z$<?xml version='1.0' encoding='%s'?>
r1   r~   )r   r   r   )	
_serialize
ValueErrorlower_get_writerlocalegetpreferredencoding_serialize_textrn   _namespaces)r+   file_or_filenameencodingZxml_declarationdefault_namespacemethodr~   Z	enc_lowerwriteZdeclared_encodingr   qnamesrN   Z	serializer   r   r   r     s2    		
zElementTree.writec             C   s   |  j  | d d S)Nr   r   )r   )r+   ro   r   r   r   
write_c14n	  s    zElementTree.write_c14n)r   r   r   r   r-   rp   rq   r	   r[   r^   rL   rO   rQ   rR   r   r   r   r   r   r   r     s"   

%	5c             c   s|  y |  j  } Wna t k
 rp | d k r; t |  d  } n t |  d d | d d } |  | j  VWd  QRXYnX| d k r | Vn t j    } t |  t j  r |  } n t |  t j  r t j	 |   } | j
 | j  nU t j   } d d   | _ | | _  y |  j | _ |  j | _ Wn t k
 r7Yn Xt j | d | d d d d	 } | j
 | j  | j  VWd  QRXd  S)
Nr   wr   errorsxmlcharrefreplacec               S   s   d S)NTr   r   r   r   r   <lambda>2  s    z_get_writer.<locals>.<lambda>newline
)r   AttributeErrorru   
contextlib	ExitStackr#   ioBufferedIOBase	RawIOBaseBufferedWritercallbackdetachwritableseekabletellTextIOWrapper)r   r   r   ro   stackr   r   r   r     s>    				r   c                s  d  d  i  i     r" d    <    f d d   } xK|  j    D]=}  |  j } t | t  r | j  k r | | j  nV t | t  r |  k r | |  n. | d  k	 r | t k	 r | t k	 r t |  xs |  j	   D]e \ } } t | t  r| j } |  k r!| |  t | t  r | j  k r | | j  q W|  j } t | t  rG | j  k rG | | j  qG W  f S)N c                s  y |  d  d  d k r |  d d   j  d d  \ } }  j |  } | d  k r t j |  } | d  k r d t   } | d k r |  | <| r d | | f  |  <q |  |  <n   r t d   |   |  <Wn t k
 r t |   Yn Xd  S)Nr   {}zns%dr   z%s:%sz<cannot use non-qualified names with default_namespace option)rsplitrT   _namespace_mapr4   r   r%   _raise_serialization_error)Zqnameurir    prefix)r   rN   r   r   r   	add_qnameO  s&    "
	z_namespaces.<locals>.add_qname)
r[   r    r#   r   r1   r_   r   r   r   rY   )r3   r   r   r    rU   rV   r1   r   )r   rN   r   r   r   D  s4    
	$
	
	r   c             K   sJ  | j  } | j } | t k r/ |  d |  n| t k rL |  d |  n| | } | d  k r | rx |  t |   x| D] } t |  | | d  d | q Wn|  d |  t | j    }	 |	 s | r| r0xV t | j   d d d   D]6 \ }
 } | rd | } |  d	 | t	 |
  f  q Wxu t |	  D]g \ } }
 t
 | t  ra| j } t
 |
 t  r| |
 j }
 n t	 |
  }
 |  d
 | | |
 f  q=W| st |  s| r |  d  | r|  t |   x' | D] } t |  | | d  d | qW|  d | d  n
 |  d  | j rF|  t | j   d  S)Nz	<!--%s-->z<?%s?>r~   <rU   c             S   s   |  d S)Nr   r   )xr   r   r   r     s    z _serialize_xml.<locals>.<lambda>:z xmlns%s="%s"z %s="%s">z</z />)r    r1   r   r   _escape_cdata_serialize_xmlr]   rY   sorted_escape_attribr#   r   r4   r2   )r   r3   r   rN   r~   kwargsr    r1   rH   rY   vkr   r   r   r     sT    		

	

	r   ZareabaseZbasefontZbrcolframeZhrZimginputZisindexlinkmetaZparamc             K   sa  | j  } | j } | t k r5 |  d t |   n| t k rX |  d t |   n| | } | d  k r | r |  t |   x| D] } t |  | | d   q Wn|  d |  t | j    } | s | r| r6xV t | j   d d d   D]6 \ }	 }
 |
 rd |
 }
 |  d |
 t	 |	  f  q Wxu t |  D]g \ }
 }	 t
 |
 t  rg|
 j }
 t
 |	 t  r| |	 j }	 n t |	  }	 |  d	 | |
 |	 f  qCW|  d
  | j   } | r| d k s| d k r|  |  n |  t |   x! | D] } t |  | | d   qW| t k rA|  d | d
  | j r]|  t | j   d  S)Nz	<!--%s-->z<?%s?>r   rU   c             S   s   |  d S)Nr   r   )r   r   r   r   r     s    z!_serialize_html.<locals>.<lambda>r   z xmlns%s="%s"z %s="%s"r   ZscriptZstylez</)r    r1   r   r   r   _serialize_htmlr]   rY   r   r   r#   r   _escape_attrib_htmlr   
HTML_EMPTYr2   )r   r3   r   rN   r   r    r1   rH   rY   r   r   Zltagr   r   r   r     sT    		

	
	r   c             C   s;   x | j    D] } |  |  q W| j r7 |  | j  d  S)N)r`   r2   )r   r3   partr   r   r   r     s    	r   r   htmlr1   c             C   sn   t  j d |   r t d   x? t t j    D]+ \ } } | | k sU | |  k r1 t | =q1 W|  t | <d S)at  Register a namespace prefix.

    The registry is global, and any existing mapping for either the
    given prefix or the namespace URI will be removed.

    *prefix* is the namespace prefix, *uri* is a namespace uri. Tags and
    attributes in this namespace will be serialized with prefix if possible.

    ValueError is raised if prefix is reserved or is invalid.

    zns\d+$z'Prefix format reserved for internal useN)rematchr   r]   r   rY   )r   r   r   r   r   r   r   r     s    z$http://www.w3.org/XML/1998/namespacezhttp://www.w3.org/1999/xhtmlz+http://www.w3.org/1999/02/22-rdf-syntax-ns#Zrdfz http://schemas.xmlsoap.org/wsdl/Zwsdlz http://www.w3.org/2001/XMLSchemaZxsz)http://www.w3.org/2001/XMLSchema-instanceZxsiz http://purl.org/dc/elements/1.1/Zdcc             C   s#   t  d |  t |   j f   d  S)Nzcannot serialize %r (type %s))r%   rG   r   )r1   r   r   r   r     s    r   c             C   s   yb d |  k r! |  j  d d  }  d |  k r? |  j  d d  }  d |  k r] |  j  d d  }  |  SWn" t t f k
 r t |   Yn Xd  S)N&z&amp;r   z&lt;r   z&gt;)replacer%   r   r   )r1   r   r   r   r   #  s    r   c             C   s!  y d |  k r! |  j  d d  }  d |  k r? |  j  d d  }  d |  k r] |  j  d d  }  d |  k r{ |  j  d d  }  d	 |  k r |  j  d	 d
  }  d |  k r |  j  d d
  }  d
 |  k r |  j  d
 d  }  d |  k r |  j  d d  }  |  SWn" t t f k
 rt |   Yn Xd  S)Nr   z&amp;r   z&lt;r   z&gt;"z&quot;z
r   z&#10;	z&#09;)r   r%   r   r   )r1   r   r   r   r   3  s(    r   c             C   s   yb d |  k r! |  j  d d  }  d |  k r? |  j  d d  }  d |  k r] |  j  d d  }  |  SWn" t t f k
 r t |   Yn Xd  S)Nr   z&amp;r   z&gt;r   z&quot;)r   r%   r   r   )r1   r   r   r   r   O  s    r   r~   Tc            C   sP   | d k r t  j   n	 t  j   } t |   j | | d | d | | j   S)a  Generate string representation of XML element.

    All subelements are included.  If encoding is "unicode", a string
    is returned. Otherwise a bytestring is returned.

    *element* is an Element instance, *encoding* is an optional output
    encoding defaulting to US-ASCII, *method* is an optional output which can
    be one of "xml" (default), "html", "text" or "c14n".

    Returns an (optionally) encoded string containing the XML data.

    r   r   r~   )r   StringIOBytesIOr   r   getvalue)r"   r   r   r~   streamr   r   r   r   ^  s    $c               @   sR   e  Z d  Z d Z d d   Z d d   Z d d   Z d d	   Z d
 d   Z d S)_ListDataStreamz7An auxiliary stream accumulating into a list reference.c             C   s   | |  _  d  S)N)lst)r+   r   r   r   r   r-   s  s    z_ListDataStream.__init__c             C   s   d S)NTr   )r+   r   r   r   r   v  s    z_ListDataStream.writablec             C   s   d S)NTr   )r+   r   r   r   r   y  s    z_ListDataStream.seekablec             C   s   |  j  j |  d  S)N)r   rA   )r+   br   r   r   r   |  s    z_ListDataStream.writec             C   s   t  |  j  S)N)r4   r   )r+   r   r   r   r     s    z_ListDataStream.tellN)	r   r   r   r   r-   r   r   r   r   r   r   r   r   r   q  s   r   c            C   s8   g  } t  |  } t |   j | | d | d | | S)Nr   r~   )r   r   r   )r"   r   r   r~   r   r   r   r   r   r     s
    c             C   sk   t  |  t  s t |   }  |  j t j d d |  j   j } | sW | d d k rg t j j d  d S)a#  Write element tree or element structure to sys.stdout.

    This function should be used for debugging only.

    *elem* is either an ElementTree, or a single Element.  The exact output
    format is implementation dependent.  In this version, it's written as an
    ordinary XML file.

    r   r   r   r   N)r#   r   r   sysstdoutrp   r2   )r3   r2   r   r   r   r     s    c             C   s   t    } | j |  |  | S)zParse XML document into element tree.

    *source* is a filename or file object containing XML data,
    *parser* is an optional parser instance defaulting to XMLParser.

    Return an ElementTree instance.

    )r   r	   )rx   ry   treer   r   r   r	     s    		c             C   sc   d } t  |  d  s* t |  d  }  d } y t |  | | |  SWn | rW |  j     Yn Xd S)aJ  Incrementally parse XML document into ElementTree.

    This class also reports what's going on to the user based on the
    *events* it is initialized with.  The supported events are the strings
    "start", "end", "start-ns" and "end-ns" (the "ns" events are used to get
    detailed namespace information).  If *events* is omitted, only
    "end" events are reported.

    *source* is a filename or file object containing XML data, *events* is
    a list of events to report back, *parser* is an optional parser instance.

    Returns an iterator providing (event, elem) pairs.

    Frr   rs   TN)r!   ru   _IterParseIteratorrw   )rx   eventsry   rz   r   r   r   r     s    
c               @   sU   e  Z d  Z d d d d d Z d d   Z d d   Z d	 d
   Z d d   Z d S)XMLPullParserN_parserc            C   sY   g  |  _  d |  _ | p' t d t    |  _ | d  k r? d } |  j j |  j  |  d  S)Nr   rd   end)r   )_events_queue_indexr   r   r   
_setevents)r+   r   r   r   r   r   r-     s    		zXMLPullParser.__init__c             C   sq   |  j  d k r t d   | rm y |  j  j |  Wn5 t k
 rl } z |  j j |  WYd d } ~ Xn Xd S)zFeed encoded data to parser.Nz!feed() called after end of stream)r   r   rv   SyntaxErrorr   rA   )r+   r{   excr   r   r   rv     s    zXMLPullParser.feedc             C   s   |  j  j   } d  |  _  | S)N)r   rw   )r+   rootr   r   r   _close_and_return_root  s    	z$XMLPullParser._close_and_return_rootc             C   s   |  j    d S)zFinish feeding data to parser.

        Unlike XMLParser, does not return the root element. Use
        read_events() to consume elements from XMLPullParser.
        N)r   )r+   r   r   r   rw     s    zXMLPullParser.closec             c   s   |  j  } x |  j } y | |  j } d | |  j <Wn t k
 rH PYn X| d 7} | d t |  k r g  | d |  <d |  _ n	 | |  _ t | t  r |  q | Vq Wd S)zReturn an iterator over currently available (event, elem) pairs.

        Events are consumed from the internal event queue as they are
        retrieved from the iterator.
        Nr   r7   r   )r   r   
IndexErrorr4   r#   	Exception)r+   r   r<   eventr   r   r   read_events  s     		
		zXMLPullParser.read_events)r   r   r   r-   rv   r   rw   r   r   r   r   r   r     s
   
r   c               @   s7   e  Z d  Z d d d  Z d d   Z d d   Z d S)	r   Fc             C   s>   t  d | d |  |  _ | |  _ | |  _ d  |  _ |  _ d  S)Nr   r   )r   r   _file_close_filer   rn   )r+   rx   r   ry   rz   r   r   r   r-     s    		z_IterParseIterator.__init__c          	   C   s   y xo x |  j  j   D] } | SW|  j  j  d  k r4 P|  j j d  } | r_ |  j  j |  q |  j  j   |  _ q W|  j |  _ Wn! |  j r |  j j	     Yn X|  j r |  j j	   t
  d  S)N   i   i @  )r   r   r   rr   rv   r   rn   r   r   rw   StopIteration)r+   r   r{   r   r   r   __next__  s$    		z_IterParseIterator.__next__c             C   s   |  S)Nr   )r+   r   r   r   __iter__/  s    z_IterParseIterator.__iter__N)r   r   r   r-   r   r   r   r   r   r   r     s   r   c             C   s/   | s t  d t    } | j |   | j   S)a  Parse XML document from string constant.

    This function can be used to embed "XML Literals" in Python code.

    *text* is a string containing XML data, *parser* is an
    optional parser instance, defaulting to the standard XMLParser.

    Returns an Element instance.

    rd   )r   r   rv   rw   )r1   ry   r   r   r   r   3  s    c             C   sw   | s t  d t    } | j |   | j   } i  } x3 | j   D]% } | j d  } | rD | | | <qD W| | f S)a  Parse XML document from string constant for its IDs.

    *text* is a string containing XML data, *parser* is an
    optional parser instance, defaulting to the standard XMLParser.

    Returns an (Element, dict) tuple, in which the
    dict maps element id:s to elements.

    rd   r.   )r   r   rv   rw   r[   rT   )r1   ry   r   Zidsr3   r.   r   r   r   r   D  s    
c             C   s@   | s t  d t    } x |  D] } | j |  q W| j   S)zParse XML document from sequence of string fragments.

    *sequence* is a list of other sequence, *parser* is an optional parser
    instance, defaulting to the standard XMLParser.

    Returns an Element instance.

    rd   )r   r   rv   rw   )Zsequencery   r1   r   r   r   r   \  s
    	c               @   sa   e  Z d  Z d Z d d d  Z d d   Z d d   Z d	 d
   Z d d   Z d d   Z	 d S)r   a  Generic element structure builder.

    This builder converts a sequence of start, data, and end method
    calls to a well-formed element structure.

    You can use this class to build an element structure using a custom XML
    parser, or a parser for some other XML-like format.

    *element_factory* is an optional element factory which is called
    to create new Element instances, as necessary.

    Nc             C   sC   g  |  _  g  |  _ d  |  _ d  |  _ | d  k r6 t } | |  _ d  S)N)_data_elem_last_tailr   _factory)r+   Zelement_factoryr   r   r   r-   {  s    				zTreeBuilder.__init__c             C   sC   t  |  j  d k s! t d   |  j d k	 s< t d   |  j S)z;Flush builder buffers and return toplevel document Element.r   zmissing end tagsNzmissing toplevel element)r4   r   AssertionErrorr   )r+   r   r   r   rw     s    !zTreeBuilder.closec             C   s   |  j  r |  j d  k	 r d j |  j   } |  j r` |  j j d  k sQ t d   | |  j _ n* |  j j d  k s~ t d   | |  j _ g  |  _  d  S)Nr   zinternal error (tail)zinternal error (text))r   r   joinr   r2   r   r1   )r+   r1   r   r   r   _flush  s    		zTreeBuilder._flushc             C   s   |  j  j |  d S)zAdd text to current element.N)r   rA   )r+   r{   r   r   r   r{     s    zTreeBuilder.datac             C   s]   |  j    |  j | |  |  _ } |  j r@ |  j d j |  |  j j |  d |  _ | S)zOpen new element and return it.

        *tag* is the element name, *attrs* is a dict containing element
        attributes.

        r   r   r   )r   r   r   r   rA   r   )r+   r    Zattrsr3   r   r   r   start  s    
		zTreeBuilder.startc             C   sZ   |  j    |  j j   |  _ |  j j | k sJ t d |  j j | f   d |  _ |  j S)zOClose and return current Element.

        *tag* is the element name.

        z&end tag mismatch (expected %s, got %s)r   )r   r   popr   r    r   r   )r+   r    r   r   r   r     s    
	zTreeBuilder.end)
r   r   r   r   r-   rw   r   r{   r   r   r   r   r   r   r   n  s   	c               @   s   e  Z d  Z d Z d d d d d  Z d d   Z d d	   Z d
 d   Z d d   Z d d   Z	 d d   Z
 d d   Z e Z d d   Z d d   Z d S)r   a  Element structure builder for XML source data based on the expat parser.

    *html* are predefined HTML entities (deprecated and not supported),
    *target* is an optional target object which defaults to an instance of the
    standard TreeBuilder class, *encoding* is an optional encoding string
    which if given, overrides the encoding specified in the XML file:
    http://www.iana.org/assignments/character-sets

    r   Nc             C   s  y d d l  m } WnC t k
 rY y d d  l } Wn t k
 rT t d   Yn XYn X| j | d  } | d  k r t   } | |  _ |  _ | |  _ |  _	 | j
 |  _ i  |  _ |  j | _ t | d  r |  j | _ t | d  r |  j | _ t | d  r| j | _ t | d  r.| j | _ t | d	  rI| j | _ d
 | _ d
 | _ d
 | _ d  |  _ i  |  _ y d | j |  _  Wn t! k
 rYn Xd  S)Nr   )expatz7No module named expat; use SimpleXMLTreeBuilder insteadr   r   r   r{   commentpir   zExpat %d.%d.%d)"xml.parsersr   ImportErrorZpyexpatZParserCreater   ry   r   rd   _targeterror_error_names_defaultZDefaultHandlerExpandr!   _startStartElementHandler_endEndElementHandlerr{   ZCharacterDataHandlerr   ZCommentHandlerr   ZProcessingInstructionHandlerZbuffer_textordered_attributesspecified_attributes_doctypeentityversion_infoversionr   )r+   r   rd   r   r   ry   r   r   r   r-     sF    							zXMLParser.__init__c             C   s   |  j  } | j } x | D] } | d k ra d | _ d | _ | | |  j d d  } | | _ q | d k r | | |  j d d  } | | _ q | d k r | | d d  } | | _ q | d	 k r | | d
 d  } | | _	 q t
 d |   q Wd  S)Nr   r   c             S   s   | | | |  |  f  d  S)Nr   )r    Z	attrib_inr   rA   r   r   r   r   handler  s    z%XMLParser._setevents.<locals>.handlerr   c             S   s   | | | |   f  d  S)Nr   )r    r   rA   r   r   r   r   r     s    zstart-nsc             S   s&   | | |  p d | p d f f  d  S)Nr   r   )r   r   r   rA   r   r   r   r    s    zend-nsc             S   s   | | d  f  d  S)Nr   )r   r   rA   r   r   r   r  	  s    zunknown event %r)r   rA   r  r  r  r  r  r  ZStartNamespaceDeclHandlerZEndNamespaceDeclHandlerr   )r+   Zevents_queueZevents_to_reportry   rA   Z
event_namer  r   r   r   r     s(    				zXMLParser._seteventsc             C   s7   t  |  } | j | _ | j | j f | _ |  d  S)N)r
   codelinenooffsetZposition)r+   rV   errr   r   r   _raiseerror  s    zXMLParser._raiseerrorc             C   sS   y |  j  | } Wn; t k
 rN | } d | k r= d | } | |  j  | <Yn X| S)Nr   r   )r   KeyError)r+   rU   namer   r   r   _fixname  s    
zXMLParser._fixnamec             C   ss   |  j  } | |  } i  } | r` x< t d t |  d  D]" } | | d | | | |  <q: W|  j j | |  S)Nr   r7   r   )r  ranger4   rd   r   )r+   r    Z	attr_listZfixnamer)   ir   r   r   r     s    	 zXMLParser._startc             C   s   |  j  j |  j |   S)N)rd   r   r  )r+   r    r   r   r   r  ,  s    zXMLParser._endc             C   s  | d  d  } | d k r y |  j  j } Wn t k
 rD d  SYn Xy | |  j | d d   Wqt k
 r d d l m } | j d | |  j j	 |  j j
 f  } d | _ |  j j	 | _ |  j j
 | _ |  YqXn| d k r| d  d  d	 k rg  |  _ n}|  j d  k	 r| d
 k r7d  |  _ d  S| j   } | sMd  S|  j j |  t |  j  } | d k r|  j d } | d k r| d k r|  j \ } } }	 }
 |	 r|	 d d  }	 n7 | d k r| d k r|  j \ } } }
 d  }	 n d  St |  j  d  r7|  j  j | |	 |
 d d   nL |  j |  j k r|  j | |	 |
 d d   |  j | |	 |
 d d   d  |  _ d  S)Nr   r   r   )r   z'undefined entity %s: line %d, column %d   r   	   z	<!DOCTYPEr   r7   ZPUBLIC   ZSYSTEM   doctyper   r   r   r   r   )rd   r{   r   r	  r  r   r   r   ry   ZErrorLineNumberZErrorColumnNumberr  r  r  r  striprA   r4   r!   r  _XMLParser__doctype)r+   r1   r   Zdata_handlerr   r  nrG   r  pubidsystemr   r   r   r  /  sZ    		"		#zXMLParser._defaultc             C   s   t  j d t  d S)z(Deprecated)  Handle doctype declaration

        *name* is the Doctype name, *pubid* is the public identifier,
        and *system* is the system identifier.

        z[This method of XMLParser is deprecated.  Define doctype() method on the TreeBuilder target.N)r8   r9   rJ   )r+   r  r  r   r   r   r   r  c  s    zXMLParser.doctypec             C   sS   y |  j  j | d  Wn5 |  j k
 rN } z |  j |  WYd d } ~ Xn Xd S)zFeed encoded data to parser.r   N)ry   Parser   r  )r+   r{   r   r   r   r   rv   s  s    zXMLParser.feedc             C   s   y |  j  j d d  Wn5 |  j k
 rN } z |  j |  WYd d } ~ Xn Xz0 y |  j j } Wn t k
 rv Yn X|   SWd |  `  |  ` |  ` |  ` Xd S)z;Finish feeding data to parser and return element structure.r   r   N)	ry   r!  r   r  rd   rw   r   r   r   )r+   r   Zclose_handlerr   r   r   rw   z  s     zXMLParser.close)r   r   r   r   r-   r   r  r  r  r  r  r  r  rv   rw   r   r   r   r   r     s   	*!4)rZ   )6r   __all__r   r   r   r8   r   r   r   r   r   r
   r   r   r   r   r   r   r   r   contextmanagerr   r   r   r   rW   	NameErrorr   r   r   r   r   r   r   r   r   r   r   r   r   r   r	   r   r   r   r   r   r   r   r   r   rF   Z_elementtreer   r   r   r   r   <module>"   s   )	 @04=22			E$K                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
[R                  @   s   d  d l  Td S)    )*N)Zxml.etree.ElementTree r   r   ,/usr/lib/python3.5/xml/etree/cElementTree.py<module>   s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             """Python interfaces to XML parsers.

This package contains one module:

expat -- Python wrapper for James Clark's Expat parser, with namespace
         support.

"""
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         """Interface to the Expat non-validating XML parser."""
import sys

from pyexpat import *

# provide pyexpat submodules as xml.parsers.expat submodules
sys.modules['xml.parsers.expat.model'] = model
sys.modules['xml.parsers.expat.errors'] = errors
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
[                  @   s
   d  Z  d S)zPython interfaces to XML parsers.

This package contains one module:

expat -- Python wrapper for James Clark's Expat parser, with namespace
         support.

N)__doc__ r   r   */usr/lib/python3.5/xml/parsers/__init__.py<module>   s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         
[                  @   s:   d  Z  d d l Z d d l Te e j d <e e j d <d S)z1Interface to the Expat non-validating XML parser.    N)*zxml.parsers.expat.modelzxml.parsers.expat.errors)__doc__sysZpyexpatZmodelmoduleserrors r   r   '/usr/lib/python3.5/xml/parsers/expat.py<module>   s   
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            """Simple API for XML (SAX) implementation for Python.

This module provides an implementation of the SAX 2 interface;
information about the Java version of the interface can be found at
http://www.megginson.com/SAX/.  The Python version of the interface is
documented at <...>.

This package contains the following modules:

handler -- Base classes and constants which define the SAX 2 API for
           the 'client-side' of SAX for Python.

saxutils -- Implementation of the convenience classes commonly used to
            work with SAX.

xmlreader -- Base classes and constants which define the SAX 2 API for
             the parsers used with SAX for Python.

expatreader -- Driver that allows use of the Expat parser with SAX.
"""

from .xmlreader import InputSource
from .handler import ContentHandler, ErrorHandler
from ._exceptions import SAXException, SAXNotRecognizedException, \
                        SAXParseException, SAXNotSupportedException, \
                        SAXReaderNotAvailable


def parse(source, handler, errorHandler=ErrorHandler()):
    parser = make_parser()
    parser.setContentHandler(handler)
    parser.setErrorHandler(errorHandler)
    parser.parse(source)

def parseString(string, handler, errorHandler=ErrorHandler()):
    import io
    if errorHandler is None:
        errorHandler = ErrorHandler()
    parser = make_parser()
    parser.setContentHandler(handler)
    parser.setErrorHandler(errorHandler)

    inpsrc = InputSource()
    if isinstance(string, str):
        inpsrc.setCharacterStream(io.StringIO(string))
    else:
        inpsrc.setByteStream(io.BytesIO(string))
    parser.parse(inpsrc)

# this is the parser list used by the make_parser function if no
# alternatives are given as parameters to the function

default_parser_list = ["xml.sax.expatreader"]

# tell modulefinder that importing sax potentially imports expatreader
_false = 0
if _false:
    import xml.sax.expatreader

import os, sys
if "PY_SAX_PARSER" in os.environ:
    default_parser_list = os.environ["PY_SAX_PARSER"].split(",")
del os

_key = "python.xml.sax.parser"
if sys.platform[:4] == "java" and sys.registry.containsKey(_key):
    default_parser_list = sys.registry.getProperty(_key).split(",")


def make_parser(parser_list = []):
    """Creates and returns a SAX parser.

    Creates the first parser it is able to instantiate of the ones
    given in the list created by doing parser_list +
    default_parser_list.  The lists must contain the names of Python
    modules containing both a SAX parser and a create_parser function."""

    for parser_name in parser_list + default_parser_list:
        try:
            return _create_parser(parser_name)
        except ImportError as e:
            import sys
            if parser_name in sys.modules:
                # The parser module was found, but importing it
                # failed unexpectedly, pass this exception through
                raise
        except SAXReaderNotAvailable:
            # The parser module detected that it won't work properly,
            # so try the next one
            pass

    raise SAXReaderNotAvailable("No parsers found", None)

# --- Internal utility methods used by make_parser

if sys.platform[ : 4] == "java":
    def _create_parser(parser_name):
        from org.python.core import imp
        drv_module = imp.importName(parser_name, 0, globals())
        return drv_module.create_parser()

else:
    def _create_parser(parser_name):
        drv_module = __import__(parser_name,{},{},['create_parser'])
        return drv_module.create_parser()

del sys
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       """Different kinds of SAX Exceptions"""
import sys
if sys.platform[:4] == "java":
    from java.lang import Exception
del sys

# ===== SAXEXCEPTION =====

class SAXException(Exception):
    """Encapsulate an XML error or warning. This class can contain
    basic error or warning information from either the XML parser or
    the application: you can subclass it to provide additional
    functionality, or to add localization. Note that although you will
    receive a SAXException as the argument to the handlers in the
    ErrorHandler interface, you are not actually required to raise
    the exception; instead, you can simply read the information in
    it."""

    def __init__(self, msg, exception=None):
        """Creates an exception. The message is required, but the exception
        is optional."""
        self._msg = msg
        self._exception = exception
        Exception.__init__(self, msg)

    def getMessage(self):
        "Return a message for this exception."
        return self._msg

    def getException(self):
        "Return the embedded exception, or None if there was none."
        return self._exception

    def __str__(self):
        "Create a string representation of the exception."
        return self._msg

    def __getitem__(self, ix):
        """Avoids weird error messages if someone does exception[ix] by
        mistake, since Exception has __getitem__ defined."""
        raise AttributeError("__getitem__")


# ===== SAXPARSEEXCEPTION =====

class SAXParseException(SAXException):
    """Encapsulate an XML parse error or warning.

    This exception will include information for locating the error in
    the original XML document. Note that although the application will
    receive a SAXParseException as the argument to the handlers in the
    ErrorHandler interface, the application is not actually required
    to raise the exception; instead, it can simply read the
    information in it and take a different action.

    Since this exception is a subclass of SAXException, it inherits
    the ability to wrap another exception."""

    def __init__(self, msg, exception, locator):
        "Creates the exception. The exception parameter is allowed to be None."
        SAXException.__init__(self, msg, exception)
        self._locator = locator

        # We need to cache this stuff at construction time.
        # If this exception is raised, the objects through which we must
        # traverse to get this information may be deleted by the time
        # it gets caught.
        self._systemId = self._locator.getSystemId()
        self._colnum = self._locator.getColumnNumber()
        self._linenum = self._locator.getLineNumber()

    def getColumnNumber(self):
        """The column number of the end of the text where the exception
        occurred."""
        return self._colnum

    def getLineNumber(self):
        "The line number of the end of the text where the exception occurred."
        return self._linenum

    def getPublicId(self):
        "Get the public identifier of the entity where the exception occurred."
        return self._locator.getPublicId()

    def getSystemId(self):
        "Get the system identifier of the entity where the exception occurred."
        return self._systemId

    def __str__(self):
        "Create a string representation of the exception."
        sysid = self.getSystemId()
        if sysid is None:
            sysid = "<unknown>"
        linenum = self.getLineNumber()
        if linenum is None:
            linenum = "?"
        colnum = self.getColumnNumber()
        if colnum is None:
            colnum = "?"
        return "%s:%s:%s: %s" % (sysid, linenum, colnum, self._msg)


# ===== SAXNOTRECOGNIZEDEXCEPTION =====

class SAXNotRecognizedException(SAXException):
    """Exception class for an unrecognized identifier.

    An XMLReader will raise this exception when it is confronted with an
    unrecognized feature or property. SAX applications and extensions may
    use this class for similar purposes."""


# ===== SAXNOTSUPPORTEDEXCEPTION =====

class SAXNotSupportedException(SAXException):
    """Exception class for an unsupported operation.

    An XMLReader will raise this exception when a service it cannot
    perform is requested (specifically setting a state or value). SAX
    applications and extensions may use this class for similar
    purposes."""

# ===== SAXNOTSUPPORTEDEXCEPTION =====

class SAXReaderNotAvailable(SAXNotSupportedException):
    """Exception class for a missing driver.

    An XMLReader module (driver) should raise this exception when it
    is first imported, e.g. when a support module cannot be imported.
    It also may be raised during parsing, e.g. if executing an external
    program is not permitted."""
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
[                 @   s   d  Z  d d l Z e j d d  d k r; d d l m Z [ Gd d   d e  Z Gd d	   d	 e  Z Gd
 d   d e  Z Gd d   d e  Z Gd d   d e  Z	 d S)z!Different kinds of SAX Exceptions    N   Zjava)	Exceptionc               @   sU   e  Z d  Z d Z d d d  Z d d   Z d d   Z d	 d
   Z d d   Z d S)SAXExceptiona  Encapsulate an XML error or warning. This class can contain
    basic error or warning information from either the XML parser or
    the application: you can subclass it to provide additional
    functionality, or to add localization. Note that although you will
    receive a SAXException as the argument to the handlers in the
    ErrorHandler interface, you are not actually required to raise
    the exception; instead, you can simply read the information in
    it.Nc             C   s&   | |  _  | |  _ t j |  |  d S)zUCreates an exception. The message is required, but the exception
        is optional.N)_msg
_exceptionr   __init__)selfmsg	exception r   )/usr/lib/python3.5/xml/sax/_exceptions.pyr      s    		zSAXException.__init__c             C   s   |  j  S)z$Return a message for this exception.)r   )r   r   r   r   
getMessage   s    zSAXException.getMessagec             C   s   |  j  S)z9Return the embedded exception, or None if there was none.)r   )r   r   r   r   getException   s    zSAXException.getExceptionc             C   s   |  j  S)z0Create a string representation of the exception.)r   )r   r   r   r   __str__"   s    zSAXException.__str__c             C   s   t  d   d S)zvAvoids weird error messages if someone does exception[ix] by
        mistake, since Exception has __getitem__ defined.__getitem__N)AttributeError)r   Zixr   r   r   r   &   s    zSAXException.__getitem__)	__name__
__module____qualname____doc__r   r   r   r   r   r   r   r   r   r   	   s   r   c               @   s^   e  Z d  Z d Z d d   Z d d   Z d d   Z d d	   Z d
 d   Z d d   Z	 d S)SAXParseExceptiona#  Encapsulate an XML parse error or warning.

    This exception will include information for locating the error in
    the original XML document. Note that although the application will
    receive a SAXParseException as the argument to the handlers in the
    ErrorHandler interface, the application is not actually required
    to raise the exception; instead, it can simply read the
    information in it and take a different action.

    Since this exception is a subclass of SAXException, it inherits
    the ability to wrap another exception.c             C   sV   t  j |  | |  | |  _ |  j j   |  _ |  j j   |  _ |  j j   |  _ d S)zECreates the exception. The exception parameter is allowed to be None.N)	r   r   _locatorgetSystemId	_systemIdgetColumnNumber_colnumgetLineNumber_linenum)r   r	   r
   Zlocatorr   r   r   r   ;   s
    	zSAXParseException.__init__c             C   s   |  j  S)zNThe column number of the end of the text where the exception
        occurred.)r   )r   r   r   r   r   H   s    z!SAXParseException.getColumnNumberc             C   s   |  j  S)zDThe line number of the end of the text where the exception occurred.)r   )r   r   r   r   r   M   s    zSAXParseException.getLineNumberc             C   s   |  j  j   S)zEGet the public identifier of the entity where the exception occurred.)r   getPublicId)r   r   r   r   r   Q   s    zSAXParseException.getPublicIdc             C   s   |  j  S)zEGet the system identifier of the entity where the exception occurred.)r   )r   r   r   r   r   U   s    zSAXParseException.getSystemIdc             C   sq   |  j    } | d k r d } |  j   } | d k r< d } |  j   } | d k rZ d } d | | | |  j f S)z0Create a string representation of the exception.Nz	<unknown>?z%s:%s:%s: %s)r   r   r   r   )r   ZsysidZlinenumZcolnumr   r   r   r   Y   s    zSAXParseException.__str__N)
r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   .   s   r   c               @   s   e  Z d  Z d Z d S)SAXNotRecognizedExceptionzException class for an unrecognized identifier.

    An XMLReader will raise this exception when it is confronted with an
    unrecognized feature or property. SAX applications and extensions may
    use this class for similar purposes.N)r   r   r   r   r   r   r   r   r    i   s   r    c               @   s   e  Z d  Z d Z d S)SAXNotSupportedExceptiona  Exception class for an unsupported operation.

    An XMLReader will raise this exception when a service it cannot
    perform is requested (specifically setting a state or value). SAX
    applications and extensions may use this class for similar
    purposes.N)r   r   r   r   r   r   r   r   r!   s   s   r!   c               @   s   e  Z d  Z d Z d S)SAXReaderNotAvailablea  Exception class for a missing driver.

    An XMLReader module (driver) should raise this exception when it
    is first imported, e.g. when a support module cannot be imported.
    It also may be raised during parsing, e.g. if executing an external
    program is not permitted.N)r   r   r   r   r   r   r   r   r"   }   s   r"   )
r   sysplatformZ	java.langr   r   r   r    r!   r"   r   r   r   r   <module>   s   %;

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           """
SAX driver for the pyexpat C module.  This driver works with
pyexpat.__version__ == '2.22'.
"""

version = "0.20"

from xml.sax._exceptions import *
from xml.sax.handler import feature_validation, feature_namespaces
from xml.sax.handler import feature_namespace_prefixes
from xml.sax.handler import feature_external_ges, feature_external_pes
from xml.sax.handler import feature_string_interning
from xml.sax.handler import property_xml_string, property_interning_dict

# xml.parsers.expat does not raise ImportError in Jython
import sys
if sys.platform[:4] == "java":
    raise SAXReaderNotAvailable("expat not available in Java", None)
del sys

try:
    from xml.parsers import expat
except ImportError:
    raise SAXReaderNotAvailable("expat not supported", None)
else:
    if not hasattr(expat, "ParserCreate"):
        raise SAXReaderNotAvailable("expat not supported", None)
from xml.sax import xmlreader, saxutils, handler

AttributesImpl = xmlreader.AttributesImpl
AttributesNSImpl = xmlreader.AttributesNSImpl

# If we're using a sufficiently recent version of Python, we can use
# weak references to avoid cycles between the parser and content
# handler, otherwise we'll just have to pretend.
try:
    import _weakref
except ImportError:
    def _mkproxy(o):
        return o
else:
    import weakref
    _mkproxy = weakref.proxy
    del weakref, _weakref

class _ClosedParser:
    pass

# --- ExpatLocator

class ExpatLocator(xmlreader.Locator):
    """Locator for use with the ExpatParser class.

    This uses a weak reference to the parser object to avoid creating
    a circular reference between the parser and the content handler.
    """
    def __init__(self, parser):
        self._ref = _mkproxy(parser)

    def getColumnNumber(self):
        parser = self._ref
        if parser._parser is None:
            return None
        return parser._parser.ErrorColumnNumber

    def getLineNumber(self):
        parser = self._ref
        if parser._parser is None:
            return 1
        return parser._parser.ErrorLineNumber

    def getPublicId(self):
        parser = self._ref
        if parser is None:
            return None
        return parser._source.getPublicId()

    def getSystemId(self):
        parser = self._ref
        if parser is None:
            return None
        return parser._source.getSystemId()


# --- ExpatParser

class ExpatParser(xmlreader.IncrementalParser, xmlreader.Locator):
    """SAX driver for the pyexpat C module."""

    def __init__(self, namespaceHandling=0, bufsize=2**16-20):
        xmlreader.IncrementalParser.__init__(self, bufsize)
        self._source = xmlreader.InputSource()
        self._parser = None
        self._namespaces = namespaceHandling
        self._lex_handler_prop = None
        self._parsing = 0
        self._entity_stack = []
        self._external_ges = 1
        self._interning = None

    # XMLReader methods

    def parse(self, source):
        "Parse an XML document from a URL or an InputSource."
        source = saxutils.prepare_input_source(source)

        self._source = source
        self.reset()
        self._cont_handler.setDocumentLocator(ExpatLocator(self))
        xmlreader.IncrementalParser.parse(self, source)

    def prepareParser(self, source):
        if source.getSystemId() is not None:
            self._parser.SetBase(source.getSystemId())

    # Redefined setContentHandler to allow changing handlers during parsing

    def setContentHandler(self, handler):
        xmlreader.IncrementalParser.setContentHandler(self, handler)
        if self._parsing:
            self._reset_cont_handler()

    def getFeature(self, name):
        if name == feature_namespaces:
            return self._namespaces
        elif name == feature_string_interning:
            return self._interning is not None
        elif name in (feature_validation, feature_external_pes,
                      feature_namespace_prefixes):
            return 0
        elif name == feature_external_ges:
            return self._external_ges
        raise SAXNotRecognizedException("Feature '%s' not recognized" % name)

    def setFeature(self, name, state):
        if self._parsing:
            raise SAXNotSupportedException("Cannot set features while parsing")

        if name == feature_namespaces:
            self._namespaces = state
        elif name == feature_external_ges:
            self._external_ges = state
        elif name == feature_string_interning:
            if state:
                if self._interning is None:
                    self._interning = {}
            else:
                self._interning = None
        elif name == feature_validation:
            if state:
                raise SAXNotSupportedException(
                    "expat does not support validation")
        elif name == feature_external_pes:
            if state:
                raise SAXNotSupportedException(
                    "expat does not read external parameter entities")
        elif name == feature_namespace_prefixes:
            if state:
                raise SAXNotSupportedException(
                    "expat does not report namespace prefixes")
        else:
            raise SAXNotRecognizedException(
                "Feature '%s' not recognized" % name)

    def getProperty(self, name):
        if name == handler.property_lexical_handler:
            return self._lex_handler_prop
        elif name == property_interning_dict:
            return self._interning
        elif name == property_xml_string:
            if self._parser:
                if hasattr(self._parser, "GetInputContext"):
                    return self._parser.GetInputContext()
                else:
                    raise SAXNotRecognizedException(
                        "This version of expat does not support getting"
                        " the XML string")
            else:
                raise SAXNotSupportedException(
                    "XML string cannot be returned when not parsing")
        raise SAXNotRecognizedException("Property '%s' not recognized" % name)

    def setProperty(self, name, value):
        if name == handler.property_lexical_handler:
            self._lex_handler_prop = value
            if self._parsing:
                self._reset_lex_handler_prop()
        elif name == property_interning_dict:
            self._interning = value
        elif name == property_xml_string:
            raise SAXNotSupportedException("Property '%s' cannot be set" %
                                           name)
        else:
            raise SAXNotRecognizedException("Property '%s' not recognized" %
                                            name)

    # IncrementalParser methods

    def feed(self, data, isFinal = 0):
        if not self._parsing:
            self.reset()
            self._parsing = 1
            self._cont_handler.startDocument()

        try:
            # The isFinal parameter is internal to the expat reader.
            # If it is set to true, expat will check validity of the entire
            # document. When feeding chunks, they are not normally final -
            # except when invoked from close.
            self._parser.Parse(data, isFinal)
        except expat.error as e:
            exc = SAXParseException(expat.ErrorString(e.code), e, self)
            # FIXME: when to invoke error()?
            self._err_handler.fatalError(exc)

    def close(self):
        if (self._entity_stack or self._parser is None or
            isinstance(self._parser, _ClosedParser)):
            # If we are completing an external entity, do nothing here
            return
        try:
            self.feed("", isFinal = 1)
            self._cont_handler.endDocument()
            self._parsing = 0
            # break cycle created by expat handlers pointing to our methods
            self._parser = None
        finally:
            self._parsing = 0
            if self._parser is not None:
                # Keep ErrorColumnNumber and ErrorLineNumber after closing.
                parser = _ClosedParser()
                parser.ErrorColumnNumber = self._parser.ErrorColumnNumber
                parser.ErrorLineNumber = self._parser.ErrorLineNumber
                self._parser = parser
            try:
                file = self._source.getCharacterStream()
                if file is not None:
                    file.close()
            finally:
                file = self._source.getByteStream()
                if file is not None:
                    file.close()

    def _reset_cont_handler(self):
        self._parser.ProcessingInstructionHandler = \
                                    self._cont_handler.processingInstruction
        self._parser.CharacterDataHandler = self._cont_handler.characters

    def _reset_lex_handler_prop(self):
        lex = self._lex_handler_prop
        parser = self._parser
        if lex is None:
            parser.CommentHandler = None
            parser.StartCdataSectionHandler = None
            parser.EndCdataSectionHandler = None
            parser.StartDoctypeDeclHandler = None
            parser.EndDoctypeDeclHandler = None
        else:
            parser.CommentHandler = lex.comment
            parser.StartCdataSectionHandler = lex.startCDATA
            parser.EndCdataSectionHandler = lex.endCDATA
            parser.StartDoctypeDeclHandler = self.start_doctype_decl
            parser.EndDoctypeDeclHandler = lex.endDTD

    def reset(self):
        if self._namespaces:
            self._parser = expat.ParserCreate(self._source.getEncoding(), " ",
                                              intern=self._interning)
            self._parser.namespace_prefixes = 1
            self._parser.StartElementHandler = self.start_element_ns
            self._parser.EndElementHandler = self.end_element_ns
        else:
            self._parser = expat.ParserCreate(self._source.getEncoding(),
                                              intern = self._interning)
            self._parser.StartElementHandler = self.start_element
            self._parser.EndElementHandler = self.end_element

        self._reset_cont_handler()
        self._parser.UnparsedEntityDeclHandler = self.unparsed_entity_decl
        self._parser.NotationDeclHandler = self.notation_decl
        self._parser.StartNamespaceDeclHandler = self.start_namespace_decl
        self._parser.EndNamespaceDeclHandler = self.end_namespace_decl

        self._decl_handler_prop = None
        if self._lex_handler_prop:
            self._reset_lex_handler_prop()
#         self._parser.DefaultHandler =
#         self._parser.DefaultHandlerExpand =
#         self._parser.NotStandaloneHandler =
        self._parser.ExternalEntityRefHandler = self.external_entity_ref
        try:
            self._parser.SkippedEntityHandler = self.skipped_entity_handler
        except AttributeError:
            # This pyexpat does not support SkippedEntity
            pass
        self._parser.SetParamEntityParsing(
            expat.XML_PARAM_ENTITY_PARSING_UNLESS_STANDALONE)

        self._parsing = 0
        self._entity_stack = []

    # Locator methods

    def getColumnNumber(self):
        if self._parser is None:
            return None
        return self._parser.ErrorColumnNumber

    def getLineNumber(self):
        if self._parser is None:
            return 1
        return self._parser.ErrorLineNumber

    def getPublicId(self):
        return self._source.getPublicId()

    def getSystemId(self):
        return self._source.getSystemId()

    # event handlers
    def start_element(self, name, attrs):
        self._cont_handler.startElement(name, AttributesImpl(attrs))

    def end_element(self, name):
        self._cont_handler.endElement(name)

    def start_element_ns(self, name, attrs):
        pair = name.split()
        if len(pair) == 1:
            # no namespace
            pair = (None, name)
        elif len(pair) == 3:
            pair = pair[0], pair[1]
        else:
            # default namespace
            pair = tuple(pair)

        newattrs = {}
        qnames = {}
        for (aname, value) in attrs.items():
            parts = aname.split()
            length = len(parts)
            if length == 1:
                # no namespace
                qname = aname
                apair = (None, aname)
            elif length == 3:
                qname = "%s:%s" % (parts[2], parts[1])
                apair = parts[0], parts[1]
            else:
                # default namespace
                qname = parts[1]
                apair = tuple(parts)

            newattrs[apair] = value
            qnames[apair] = qname

        self._cont_handler.startElementNS(pair, None,
                                          AttributesNSImpl(newattrs, qnames))

    def end_element_ns(self, name):
        pair = name.split()
        if len(pair) == 1:
            pair = (None, name)
        elif len(pair) == 3:
            pair = pair[0], pair[1]
        else:
            pair = tuple(pair)

        self._cont_handler.endElementNS(pair, None)

    # this is not used (call directly to ContentHandler)
    def processing_instruction(self, target, data):
        self._cont_handler.processingInstruction(target, data)

    # this is not used (call directly to ContentHandler)
    def character_data(self, data):
        self._cont_handler.characters(data)

    def start_namespace_decl(self, prefix, uri):
        self._cont_handler.startPrefixMapping(prefix, uri)

    def end_namespace_decl(self, prefix):
        self._cont_handler.endPrefixMapping(prefix)

    def start_doctype_decl(self, name, sysid, pubid, has_internal_subset):
        self._lex_handler_prop.startDTD(name, pubid, sysid)

    def unparsed_entity_decl(self, name, base, sysid, pubid, notation_name):
        self._dtd_handler.unparsedEntityDecl(name, pubid, sysid, notation_name)

    def notation_decl(self, name, base, sysid, pubid):
        self._dtd_handler.notationDecl(name, pubid, sysid)

    def external_entity_ref(self, context, base, sysid, pubid):
        if not self._external_ges:
            return 1

        source = self._ent_handler.resolveEntity(pubid, sysid)
        source = saxutils.prepare_input_source(source,
                                               self._source.getSystemId() or
                                               "")

        self._entity_stack.append((self._parser, self._source))
        self._parser = self._parser.ExternalEntityParserCreate(context)
        self._source = source

        try:
            xmlreader.IncrementalParser.parse(self, source)
        except:
            return 0  # FIXME: save error info here?

        (self._parser, self._source) = self._entity_stack[-1]
        del self._entity_stack[-1]
        return 1

    def skipped_entity_handler(self, name, is_pe):
        if is_pe:
            # The SAX spec requires to report skipped PEs with a '%'
            name = '%'+name
        self._cont_handler.skippedEntity(name)

# ---

def create_parser(*args, **kwargs):
    return ExpatParser(*args, **kwargs)

# ---

if __name__ == "__main__":
    import xml.sax.saxutils
    p = create_parser()
    p.setContentHandler(xml.sax.saxutils.XMLGenerator())
    p.setErrorHandler(xml.sax.ErrorHandler())
    p.parse("http://www.ibiblio.org/xml/examples/shakespeare/hamlet.xml")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      """
This module contains the core classes of version 2.0 of SAX for Python.
This file provides only default classes with absolutely minimum
functionality, from which drivers and applications can be subclassed.

Many of these classes are empty and are included only as documentation
of the interfaces.

$Id$
"""

version = '2.0beta'

#============================================================================
#
# HANDLER INTERFACES
#
#============================================================================

# ===== ERRORHANDLER =====

class ErrorHandler:
    """Basic interface for SAX error handlers.

    If you create an object that implements this interface, then
    register the object with your XMLReader, the parser will call the
    methods in your object to report all warnings and errors. There
    are three levels of errors available: warnings, (possibly)
    recoverable errors, and unrecoverable errors. All methods take a
    SAXParseException as the only parameter."""

    def error(self, exception):
        "Handle a recoverable error."
        raise exception

    def fatalError(self, exception):
        "Handle a non-recoverable error."
        raise exception

    def warning(self, exception):
        "Handle a warning."
        print(exception)


# ===== CONTENTHANDLER =====

class ContentHandler:
    """Interface for receiving logical document content events.

    This is the main callback interface in SAX, and the one most
    important to applications. The order of events in this interface
    mirrors the order of the information in the document."""

    def __init__(self):
        self._locator = None

    def setDocumentLocator(self, locator):
        """Called by the parser to give the application a locator for
        locating the origin of document events.

        SAX parsers are strongly encouraged (though not absolutely
        required) to supply a locator: if it does so, it must supply
        the locator to the application by invoking this method before
        invoking any of the other methods in the DocumentHandler
        interface.

        The locator allows the application to determine the end
        position of any document-related event, even if the parser is
        not reporting an error. Typically, the application will use
        this information for reporting its own errors (such as
        character content that does not match an application's
        business rules). The information returned by the locator is
        probably not sufficient for use with a search engine.

        Note that the locator will return correct information only
        during the invocation of the events in this interface. The
        application should not attempt to use it at any other time."""
        self._locator = locator

    def startDocument(self):
        """Receive notification of the beginning of a document.

        The SAX parser will invoke this method only once, before any
        other methods in this interface or in DTDHandler (except for
        setDocumentLocator)."""

    def endDocument(self):
        """Receive notification of the end of a document.

        The SAX parser will invoke this method only once, and it will
        be the last method invoked during the parse. The parser shall
        not invoke this method until it has either abandoned parsing
        (because of an unrecoverable error) or reached the end of
        input."""

    def startPrefixMapping(self, prefix, uri):
        """Begin the scope of a prefix-URI Namespace mapping.

        The information from this event is not necessary for normal
        Namespace processing: the SAX XML reader will automatically
        replace prefixes for element and attribute names when the
        http://xml.org/sax/features/namespaces feature is true (the
        default).

        There are cases, however, when applications need to use
        prefixes in character data or in attribute values, where they
        cannot safely be expanded automatically; the
        start/endPrefixMapping event supplies the information to the
        application to expand prefixes in those contexts itself, if
        necessary.

        Note that start/endPrefixMapping events are not guaranteed to
        be properly nested relative to each-other: all
        startPrefixMapping events will occur before the corresponding
        startElement event, and all endPrefixMapping events will occur
        after the corresponding endElement event, but their order is
        not guaranteed."""

    def endPrefixMapping(self, prefix):
        """End the scope of a prefix-URI mapping.

        See startPrefixMapping for details. This event will always
        occur after the corresponding endElement event, but the order
        of endPrefixMapping events is not otherwise guaranteed."""

    def startElement(self, name, attrs):
        """Signals the start of an element in non-namespace mode.

        The name parameter contains the raw XML 1.0 name of the
        element type as a string and the attrs parameter holds an
        instance of the Attributes class containing the attributes of
        the element."""

    def endElement(self, name):
        """Signals the end of an element in non-namespace mode.

        The name parameter contains the name of the element type, just
        as with the startElement event."""

    def startElementNS(self, name, qname, attrs):
        """Signals the start of an element in namespace mode.

        The name parameter contains the name of the element type as a
        (uri, localname) tuple, the qname parameter the raw XML 1.0
        name used in the source document, and the attrs parameter
        holds an instance of the Attributes class containing the
        attributes of the element.

        The uri part of the name tuple is None for elements which have
        no namespace."""

    def endElementNS(self, name, qname):
        """Signals the end of an element in namespace mode.

        The name parameter contains the name of the element type, just
        as with the startElementNS event."""

    def characters(self, content):
        """Receive notification of character data.

        The Parser will call this method to report each chunk of
        character data. SAX parsers may return all contiguous
        character data in a single chunk, or they may split it into
        several chunks; however, all of the characters in any single
        event must come from the same external entity so that the
        Locator provides useful information."""

    def ignorableWhitespace(self, whitespace):
        """Receive notification of ignorable whitespace in element content.

        Validating Parsers must use this method to report each chunk
        of ignorable whitespace (see the W3C XML 1.0 recommendation,
        section 2.10): non-validating parsers may also use this method
        if they are capable of parsing and using content models.

        SAX parsers may return all contiguous whitespace in a single
        chunk, or they may split it into several chunks; however, all
        of the characters in any single event must come from the same
        external entity, so that the Locator provides useful
        information."""

    def processingInstruction(self, target, data):
        """Receive notification of a processing instruction.

        The Parser will invoke this method once for each processing
        instruction found: note that processing instructions may occur
        before or after the main document element.

        A SAX parser should never report an XML declaration (XML 1.0,
        section 2.8) or a text declaration (XML 1.0, section 4.3.1)
        using this method."""

    def skippedEntity(self, name):
        """Receive notification of a skipped entity.

        The Parser will invoke this method once for each entity
        skipped. Non-validating processors may skip entities if they
        have not seen the declarations (because, for example, the
        entity was declared in an external DTD subset). All processors
        may skip external entities, depending on the values of the
        http://xml.org/sax/features/external-general-entities and the
        http://xml.org/sax/features/external-parameter-entities
        properties."""


# ===== DTDHandler =====

class DTDHandler:
    """Handle DTD events.

    This interface specifies only those DTD events required for basic
    parsing (unparsed entities and attributes)."""

    def notationDecl(self, name, publicId, systemId):
        "Handle a notation declaration event."

    def unparsedEntityDecl(self, name, publicId, systemId, ndata):
        "Handle an unparsed entity declaration event."


# ===== ENTITYRESOLVER =====

class EntityResolver:
    """Basic interface for resolving entities. If you create an object
    implementing this interface, then register the object with your
    Parser, the parser will call the method in your object to
    resolve all external entities. Note that DefaultHandler implements
    this interface with the default behaviour."""

    def resolveEntity(self, publicId, systemId):
        """Resolve the system identifier of an entity and return either
        the system identifier to read from as a string, or an InputSource
        to read from."""
        return systemId


#============================================================================
#
# CORE FEATURES
#
#============================================================================

feature_namespaces = "http://xml.org/sax/features/namespaces"
# true: Perform Namespace processing (default).
# false: Optionally do not perform Namespace processing
#        (implies namespace-prefixes).
# access: (parsing) read-only; (not parsing) read/write

feature_namespace_prefixes = "http://xml.org/sax/features/namespace-prefixes"
# true: Report the original prefixed names and attributes used for Namespace
#       declarations.
# false: Do not report attributes used for Namespace declarations, and
#        optionally do not report original prefixed names (default).
# access: (parsing) read-only; (not parsing) read/write

feature_string_interning = "http://xml.org/sax/features/string-interning"
# true: All element names, prefixes, attribute names, Namespace URIs, and
#       local names are interned using the built-in intern function.
# false: Names are not necessarily interned, although they may be (default).
# access: (parsing) read-only; (not parsing) read/write

feature_validation = "http://xml.org/sax/features/validation"
# true: Report all validation errors (implies external-general-entities and
#       external-parameter-entities).
# false: Do not report validation errors.
# access: (parsing) read-only; (not parsing) read/write

feature_external_ges = "http://xml.org/sax/features/external-general-entities"
# true: Include all external general (text) entities.
# false: Do not include external general entities.
# access: (parsing) read-only; (not parsing) read/write

feature_external_pes = "http://xml.org/sax/features/external-parameter-entities"
# true: Include all external parameter entities, including the external
#       DTD subset.
# false: Do not include any external parameter entities, even the external
#        DTD subset.
# access: (parsing) read-only; (not parsing) read/write

all_features = [feature_namespaces,
                feature_namespace_prefixes,
                feature_string_interning,
                feature_validation,
                feature_external_ges,
                feature_external_pes]


#============================================================================
#
# CORE PROPERTIES
#
#============================================================================

property_lexical_handler = "http://xml.org/sax/properties/lexical-handler"
# data type: xml.sax.sax2lib.LexicalHandler
# description: An optional extension handler for lexical events like comments.
# access: read/write

property_declaration_handler = "http://xml.org/sax/properties/declaration-handler"
# data type: xml.sax.sax2lib.DeclHandler
# description: An optional extension handler for DTD-related events other
#              than notations and unparsed entities.
# access: read/write

property_dom_node = "http://xml.org/sax/properties/dom-node"
# data type: org.w3c.dom.Node
# description: When parsing, the current DOM node being visited if this is
#              a DOM iterator; when not parsing, the root DOM node for
#              iteration.
# access: (parsing) read-only; (not parsing) read/write

property_xml_string = "http://xml.org/sax/properties/xml-string"
# data type: String
# description: The literal string of characters that was the source for
#              the current event.
# access: read-only

property_encoding = "http://www.python.org/sax/properties/encoding"
# data type: String
# description: The name of the encoding to assume for input data.
# access: write: set the encoding, e.g. established by a higher-level
#                protocol. May change during parsing (e.g. after
#                processing a META tag)
#         read:  return the current encoding (possibly established through
#                auto-detection.
# initial value: UTF-8
#

property_interning_dict = "http://www.python.org/sax/properties/interning-dict"
# data type: Dictionary
# description: The dictionary used to intern common strings in the document
# access: write: Request that the parser uses a specific dictionary, to
#                allow interning across different documents
#         read:  return the current interning dictionary, or None
#

all_properties = [property_lexical_handler,
                  property_dom_node,
                  property_declaration_handler,
                  property_xml_string,
                  property_encoding,
                  property_interning_dict]
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              """\
A library of useful helper classes to the SAX classes, for the
convenience of application and driver writers.
"""

import os, urllib.parse, urllib.request
import io
import codecs
from . import handler
from . import xmlreader

def __dict_replace(s, d):
    """Replace substrings of a string using a dictionary."""
    for key, value in d.items():
        s = s.replace(key, value)
    return s

def escape(data, entities={}):
    """Escape &, <, and > in a string of data.

    You can escape other strings of data by passing a dictionary as
    the optional entities parameter.  The keys and values must all be
    strings; each key will be replaced with its corresponding value.
    """

    # must do ampersand first
    data = data.replace("&", "&amp;")
    data = data.replace(">", "&gt;")
    data = data.replace("<", "&lt;")
    if entities:
        data = __dict_replace(data, entities)
    return data

def unescape(data, entities={}):
    """Unescape &amp;, &lt;, and &gt; in a string of data.

    You can unescape other strings of data by passing a dictionary as
    the optional entities parameter.  The keys and values must all be
    strings; each key will be replaced with its corresponding value.
    """
    data = data.replace("&lt;", "<")
    data = data.replace("&gt;", ">")
    if entities:
        data = __dict_replace(data, entities)
    # must do ampersand last
    return data.replace("&amp;", "&")

def quoteattr(data, entities={}):
    """Escape and quote an attribute value.

    Escape &, <, and > in a string of data, then quote it for use as
    an attribute value.  The \" character will be escaped as well, if
    necessary.

    You can escape other strings of data by passing a dictionary as
    the optional entities parameter.  The keys and values must all be
    strings; each key will be replaced with its corresponding value.
    """
    entities = entities.copy()
    entities.update({'\n': '&#10;', '\r': '&#13;', '\t':'&#9;'})
    data = escape(data, entities)
    if '"' in data:
        if "'" in data:
            data = '"%s"' % data.replace('"', "&quot;")
        else:
            data = "'%s'" % data
    else:
        data = '"%s"' % data
    return data


def _gettextwriter(out, encoding):
    if out is None:
        import sys
        return sys.stdout

    if isinstance(out, io.TextIOBase):
        # use a text writer as is
        return out

    if isinstance(out, (codecs.StreamWriter, codecs.StreamReaderWriter)):
        # use a codecs stream writer as is
        return out

    # wrap a binary writer with TextIOWrapper
    if isinstance(out, io.RawIOBase):
        # Keep the original file open when the TextIOWrapper is
        # destroyed
        class _wrapper:
            __class__ = out.__class__
            def __getattr__(self, name):
                return getattr(out, name)
        buffer = _wrapper()
        buffer.close = lambda: None
    else:
        # This is to handle passed objects that aren't in the
        # IOBase hierarchy, but just have a write method
        buffer = io.BufferedIOBase()
        buffer.writable = lambda: True
        buffer.write = out.write
        try:
            # TextIOWrapper uses this methods to determine
            # if BOM (for UTF-16, etc) should be added
            buffer.seekable = out.seekable
            buffer.tell = out.tell
        except AttributeError:
            pass
    return io.TextIOWrapper(buffer, encoding=encoding,
                            errors='xmlcharrefreplace',
                            newline='\n',
                            write_through=True)

class XMLGenerator(handler.ContentHandler):

    def __init__(self, out=None, encoding="iso-8859-1", short_empty_elements=False):
        handler.ContentHandler.__init__(self)
        out = _gettextwriter(out, encoding)
        self._write = out.write
        self._flush = out.flush
        self._ns_contexts = [{}] # contains uri -> prefix dicts
        self._current_context = self._ns_contexts[-1]
        self._undeclared_ns_maps = []
        self._encoding = encoding
        self._short_empty_elements = short_empty_elements
        self._pending_start_element = False

    def _qname(self, name):
        """Builds a qualified name from a (ns_url, localname) pair"""
        if name[0]:
            # Per http://www.w3.org/XML/1998/namespace, The 'xml' prefix is
            # bound by definition to http://www.w3.org/XML/1998/namespace.  It
            # does not need to be declared and will not usually be found in
            # self._current_context.
            if 'http://www.w3.org/XML/1998/namespace' == name[0]:
                return 'xml:' + name[1]
            # The name is in a non-empty namespace
            prefix = self._current_context[name[0]]
            if prefix:
                # If it is not the default namespace, prepend the prefix
                return prefix + ":" + name[1]
        # Return the unqualified name
        return name[1]

    def _finish_pending_start_element(self,endElement=False):
        if self._pending_start_element:
            self._write('>')
            self._pending_start_element = False

    # ContentHandler methods

    def startDocument(self):
        self._write('<?xml version="1.0" encoding="%s"?>\n' %
                        self._encoding)

    def endDocument(self):
        self._flush()

    def startPrefixMapping(self, prefix, uri):
        self._ns_contexts.append(self._current_context.copy())
        self._current_context[uri] = prefix
        self._undeclared_ns_maps.append((prefix, uri))

    def endPrefixMapping(self, prefix):
        self._current_context = self._ns_contexts[-1]
        del self._ns_contexts[-1]

    def startElement(self, name, attrs):
        self._finish_pending_start_element()
        self._write('<' + name)
        for (name, value) in attrs.items():
            self._write(' %s=%s' % (name, quoteattr(value)))
        if self._short_empty_elements:
            self._pending_start_element = True
        else:
            self._write(">")

    def endElement(self, name):
        if self._pending_start_element:
            self._write('/>')
            self._pending_start_element = False
        else:
            self._write('</%s>' % name)

    def startElementNS(self, name, qname, attrs):
        self._finish_pending_start_element()
        self._write('<' + self._qname(name))

        for prefix, uri in self._undeclared_ns_maps:
            if prefix:
                self._write(' xmlns:%s="%s"' % (prefix, uri))
            else:
                self._write(' xmlns="%s"' % uri)
        self._undeclared_ns_maps = []

        for (name, value) in attrs.items():
            self._write(' %s=%s' % (self._qname(name), quoteattr(value)))
        if self._short_empty_elements:
            self._pending_start_element = True
        else:
            self._write(">")

    def endElementNS(self, name, qname):
        if self._pending_start_element:
            self._write('/>')
            self._pending_start_element = False
        else:
            self._write('</%s>' % self._qname(name))

    def characters(self, content):
        if content:
            self._finish_pending_start_element()
            if not isinstance(content, str):
                content = str(content, self._encoding)
            self._write(escape(content))

    def ignorableWhitespace(self, content):
        if content:
            self._finish_pending_start_element()
            if not isinstance(content, str):
                content = str(content, self._encoding)
            self._write(content)

    def processingInstruction(self, target, data):
        self._finish_pending_start_element()
        self._write('<?%s %s?>' % (target, data))


class XMLFilterBase(xmlreader.XMLReader):
    """This class is designed to sit between an XMLReader and the
    client application's event handlers.  By default, it does nothing
    but pass requests up to the reader and events on to the handlers
    unmodified, but subclasses can override specific methods to modify
    the event stream or the configuration requests as they pass
    through."""

    def __init__(self, parent = None):
        xmlreader.XMLReader.__init__(self)
        self._parent = parent

    # ErrorHandler methods

    def error(self, exception):
        self._err_handler.error(exception)

    def fatalError(self, exception):
        self._err_handler.fatalError(exception)

    def warning(self, exception):
        self._err_handler.warning(exception)

    # ContentHandler methods

    def setDocumentLocator(self, locator):
        self._cont_handler.setDocumentLocator(locator)

    def startDocument(self):
        self._cont_handler.startDocument()

    def endDocument(self):
        self._cont_handler.endDocument()

    def startPrefixMapping(self, prefix, uri):
        self._cont_handler.startPrefixMapping(prefix, uri)

    def endPrefixMapping(self, prefix):
        self._cont_handler.endPrefixMapping(prefix)

    def startElement(self, name, attrs):
        self._cont_handler.startElement(name, attrs)

    def endElement(self, name):
        self._cont_handler.endElement(name)

    def startElementNS(self, name, qname, attrs):
        self._cont_handler.startElementNS(name, qname, attrs)

    def endElementNS(self, name, qname):
        self._cont_handler.endElementNS(name, qname)

    def characters(self, content):
        self._cont_handler.characters(content)

    def ignorableWhitespace(self, chars):
        self._cont_handler.ignorableWhitespace(chars)

    def processingInstruction(self, target, data):
        self._cont_handler.processingInstruction(target, data)

    def skippedEntity(self, name):
        self._cont_handler.skippedEntity(name)

    # DTDHandler methods

    def notationDecl(self, name, publicId, systemId):
        self._dtd_handler.notationDecl(name, publicId, systemId)

    def unparsedEntityDecl(self, name, publicId, systemId, ndata):
        self._dtd_handler.unparsedEntityDecl(name, publicId, systemId, ndata)

    # EntityResolver methods

    def resolveEntity(self, publicId, systemId):
        return self._ent_handler.resolveEntity(publicId, systemId)

    # XMLReader methods

    def parse(self, source):
        self._parent.setContentHandler(self)
        self._parent.setErrorHandler(self)
        self._parent.setEntityResolver(self)
        self._parent.setDTDHandler(self)
        self._parent.parse(source)

    def setLocale(self, locale):
        self._parent.setLocale(locale)

    def getFeature(self, name):
        return self._parent.getFeature(name)

    def setFeature(self, name, state):
        self._parent.setFeature(name, state)

    def getProperty(self, name):
        return self._parent.getProperty(name)

    def setProperty(self, name, value):
        self._parent.setProperty(name, value)

    # XMLFilter methods

    def getParent(self):
        return self._parent

    def setParent(self, parent):
        self._parent = parent

# --- Utility functions

def prepare_input_source(source, base=""):
    """This function takes an InputSource and an optional base URL and
    returns a fully resolved InputSource object ready for reading."""

    if isinstance(source, str):
        source = xmlreader.InputSource(source)
    elif hasattr(source, "read"):
        f = source
        source = xmlreader.InputSource()
        if isinstance(f.read(0), str):
            source.setCharacterStream(f)
        else:
            source.setByteStream(f)
        if hasattr(f, "name") and isinstance(f.name, str):
            source.setSystemId(f.name)

    if source.getCharacterStream() is None and source.getByteStream() is None:
        sysid = source.getSystemId()
        basehead = os.path.dirname(os.path.normpath(base))
        sysidfilename = os.path.join(basehead, sysid)
        if os.path.isfile(sysidfilename):
            source.setSystemId(sysidfilename)
            f = open(sysidfilename, "rb")
        else:
            source.setSystemId(urllib.parse.urljoin(base, sysid))
            f = urllib.request.urlopen(source.getSystemId())

        source.setByteStream(f)

    return source
                                                                                   
[	                 @   so  d  Z  d d l m Z d d l m Z m Z d d l m Z m Z m	 Z	 m
 Z
 m Z e   d d  Z e   d d  Z d	 g Z d
 Z e r d
 d l Z d
 d l Z d
 d l Z d e j k r e j d j d  Z [ d Z e j d d  d k r%e j j e  r%e j j e  j d  Z g  d d  Z e j d d  d k r\d d   Z n d d   Z [ d S)a  Simple API for XML (SAX) implementation for Python.

This module provides an implementation of the SAX 2 interface;
information about the Java version of the interface can be found at
http://www.megginson.com/SAX/.  The Python version of the interface is
documented at <...>.

This package contains the following modules:

handler -- Base classes and constants which define the SAX 2 API for
           the 'client-side' of SAX for Python.

saxutils -- Implementation of the convenience classes commonly used to
            work with SAX.

xmlreader -- Base classes and constants which define the SAX 2 API for
             the parsers used with SAX for Python.

expatreader -- Driver that allows use of the Expat parser with SAX.
   )InputSource)ContentHandlerErrorHandler)SAXExceptionSAXNotRecognizedExceptionSAXParseExceptionSAXNotSupportedExceptionSAXReaderNotAvailablec             C   s4   t    } | j |  | j |  | j |   d  S)N)make_parsersetContentHandlersetErrorHandlerparse)sourcehandlererrorHandlerparser r   &/usr/lib/python3.5/xml/sax/__init__.pyr      s    	r   c             C   s   d d  l  } | d  k r! t   } t   } | j |  | j |  t   } t |  t  ru | j | j	 |    n | j
 | j |    | j |  d  S)N    )ior   r
   r   r   r   
isinstancestrZsetCharacterStreamStringIOZsetByteStreamBytesIOr   )stringr   r   r   r   Zinpsrcr   r   r   parseString#   s    			r   zxml.sax.expatreaderr   NZPY_SAX_PARSER,zpython.xml.sax.parser   Zjavac             C   s   xw |  t  D]k } y t |  SWq t k
 rd } z# d d l } | | j k rR   WYd d } ~ Xq t k
 ru Yq Xq Wt d d   d S)a&  Creates and returns a SAX parser.

    Creates the first parser it is able to instantiate of the ones
    given in the list created by doing parser_list +
    default_parser_list.  The lists must contain the names of Python
    modules containing both a SAX parser and a create_parser function.r   NzNo parsers found)default_parser_list_create_parserImportErrorsysmodulesr	   )Zparser_listparser_nameer!   r   r   r   r
   F   s    	r
   c             C   s2   d d l  m } | j |  d t    } | j   S)Nr   )imp)Zorg.python.corer%   Z
importNameglobalscreate_parser)r#   r%   
drv_moduler   r   r   r   a   s    r   c             C   s"   t  |  i  i  d g  } | j   S)Nr'   )
__import__r'   )r#   r(   r   r   r   r   g   s    )__doc__Z	xmlreaderr   r   r   r   _exceptionsr   r   r   r   r	   r   r   r   _falseZxml.sax.expatreaderZxmlosr!   environsplitZ_keyplatformregistryZcontainsKeyZgetPropertyr
   r   r   r   r   r   <module>   s*   (	+                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         """An XML Reader is the SAX 2 name for an XML parser. XML Parsers
should be based on this code. """

from . import handler

from ._exceptions import SAXNotSupportedException, SAXNotRecognizedException


# ===== XMLREADER =====

class XMLReader:
    """Interface for reading an XML document using callbacks.

    XMLReader is the interface that an XML parser's SAX2 driver must
    implement. This interface allows an application to set and query
    features and properties in the parser, to register event handlers
    for document processing, and to initiate a document parse.

    All SAX interfaces are assumed to be synchronous: the parse
    methods must not return until parsing is complete, and readers
    must wait for an event-handler callback to return before reporting
    the next event."""

    def __init__(self):
        self._cont_handler = handler.ContentHandler()
        self._dtd_handler = handler.DTDHandler()
        self._ent_handler = handler.EntityResolver()
        self._err_handler = handler.ErrorHandler()

    def parse(self, source):
        "Parse an XML document from a system identifier or an InputSource."
        raise NotImplementedError("This method must be implemented!")

    def getContentHandler(self):
        "Returns the current ContentHandler."
        return self._cont_handler

    def setContentHandler(self, handler):
        "Registers a new object to receive document content events."
        self._cont_handler = handler

    def getDTDHandler(self):
        "Returns the current DTD handler."
        return self._dtd_handler

    def setDTDHandler(self, handler):
        "Register an object to receive basic DTD-related events."
        self._dtd_handler = handler

    def getEntityResolver(self):
        "Returns the current EntityResolver."
        return self._ent_handler

    def setEntityResolver(self, resolver):
        "Register an object to resolve external entities."
        self._ent_handler = resolver

    def getErrorHandler(self):
        "Returns the current ErrorHandler."
        return self._err_handler

    def setErrorHandler(self, handler):
        "Register an object to receive error-message events."
        self._err_handler = handler

    def setLocale(self, locale):
        """Allow an application to set the locale for errors and warnings.

        SAX parsers are not required to provide localization for errors
        and warnings; if they cannot support the requested locale,
        however, they must raise a SAX exception. Applications may
        request a locale change in the middle of a parse."""
        raise SAXNotSupportedException("Locale support not implemented")

    def getFeature(self, name):
        "Looks up and returns the state of a SAX2 feature."
        raise SAXNotRecognizedException("Feature '%s' not recognized" % name)

    def setFeature(self, name, state):
        "Sets the state of a SAX2 feature."
        raise SAXNotRecognizedException("Feature '%s' not recognized" % name)

    def getProperty(self, name):
        "Looks up and returns the value of a SAX2 property."
        raise SAXNotRecognizedException("Property '%s' not recognized" % name)

    def setProperty(self, name, value):
        "Sets the value of a SAX2 property."
        raise SAXNotRecognizedException("Property '%s' not recognized" % name)

class IncrementalParser(XMLReader):
    """This interface adds three extra methods to the XMLReader
    interface that allow XML parsers to support incremental
    parsing. Support for this interface is optional, since not all
    underlying XML parsers support this functionality.

    When the parser is instantiated it is ready to begin accepting
    data from the feed method immediately. After parsing has been
    finished with a call to close the reset method must be called to
    make the parser ready to accept new data, either from feed or
    using the parse method.

    Note that these methods must _not_ be called during parsing, that
    is, after parse has been called and before it returns.

    By default, the class also implements the parse method of the XMLReader
    interface using the feed, close and reset methods of the
    IncrementalParser interface as a convenience to SAX 2.0 driver
    writers."""

    def __init__(self, bufsize=2**16):
        self._bufsize = bufsize
        XMLReader.__init__(self)

    def parse(self, source):
        from . import saxutils
        source = saxutils.prepare_input_source(source)

        self.prepareParser(source)
        file = source.getCharacterStream()
        if file is None:
            file = source.getByteStream()
        buffer = file.read(self._bufsize)
        while buffer:
            self.feed(buffer)
            buffer = file.read(self._bufsize)
        self.close()

    def feed(self, data):
        """This method gives the raw XML data in the data parameter to
        the parser and makes it parse the data, emitting the
        corresponding events. It is allowed for XML constructs to be
        split across several calls to feed.

        feed may raise SAXException."""
        raise NotImplementedError("This method must be implemented!")

    def prepareParser(self, source):
        """This method is called by the parse implementation to allow
        the SAX 2.0 driver to prepare itself for parsing."""
        raise NotImplementedError("prepareParser must be overridden!")

    def close(self):
        """This method is called when the entire XML document has been
        passed to the parser through the feed method, to notify the
        parser that there are no more data. This allows the parser to
        do the final checks on the document and empty the internal
        data buffer.

        The parser will not be ready to parse another document until
        the reset method has been called.

        close may raise SAXException."""
        raise NotImplementedError("This method must be implemented!")

    def reset(self):
        """This method is called after close has been called to reset
        the parser so that it is ready to parse new documents. The
        results of calling parse or feed after close without calling
        reset are undefined."""
        raise NotImplementedError("This method must be implemented!")

# ===== LOCATOR =====

class Locator:
    """Interface for associating a SAX event with a document
    location. A locator object will return valid results only during
    calls to DocumentHandler methods; at any other time, the
    results are unpredictable."""

    def getColumnNumber(self):
        "Return the column number where the current event ends."
        return -1

    def getLineNumber(self):
        "Return the line number where the current event ends."
        return -1

    def getPublicId(self):
        "Return the public identifier for the current event."
        return None

    def getSystemId(self):
        "Return the system identifier for the current event."
        return None

# ===== INPUTSOURCE =====

class InputSource:
    """Encapsulation of the information needed by the XMLReader to
    read entities.

    This class may include information about the public identifier,
    system identifier, byte stream (possibly with character encoding
    information) and/or the character stream of an entity.

    Applications will create objects of this class for use in the
    XMLReader.parse method and for returning from
    EntityResolver.resolveEntity.

    An InputSource belongs to the application, the XMLReader is not
    allowed to modify InputSource objects passed to it from the
    application, although it may make copies and modify those."""

    def __init__(self, system_id = None):
        self.__system_id = system_id
        self.__public_id = None
        self.__encoding  = None
        self.__bytefile  = None
        self.__charfile  = None

    def setPublicId(self, public_id):
        "Sets the public identifier of this InputSource."
        self.__public_id = public_id

    def getPublicId(self):
        "Returns the public identifier of this InputSource."
        return self.__public_id

    def setSystemId(self, system_id):
        "Sets the system identifier of this InputSource."
        self.__system_id = system_id

    def getSystemId(self):
        "Returns the system identifier of this InputSource."
        return self.__system_id

    def setEncoding(self, encoding):
        """Sets the character encoding of this InputSource.

        The encoding must be a string acceptable for an XML encoding
        declaration (see section 4.3.3 of the XML recommendation).

        The encoding attribute of the InputSource is ignored if the
        InputSource also contains a character stream."""
        self.__encoding = encoding

    def getEncoding(self):
        "Get the character encoding of this InputSource."
        return self.__encoding

    def setByteStream(self, bytefile):
        """Set the byte stream (a Python file-like object which does
        not perform byte-to-character conversion) for this input
        source.

        The SAX parser will ignore this if there is also a character
        stream specified, but it will use a byte stream in preference
        to opening a URI connection itself.

        If the application knows the character encoding of the byte
        stream, it should set it with the setEncoding method."""
        self.__bytefile = bytefile

    def getByteStream(self):
        """Get the byte stream for this input source.

        The getEncoding method will return the character encoding for
        this byte stream, or None if unknown."""
        return self.__bytefile

    def setCharacterStream(self, charfile):
        """Set the character stream for this input source. (The stream
        must be a Python 2.0 Unicode-wrapped file-like that performs
        conversion to Unicode strings.)

        If there is a character stream specified, the SAX parser will
        ignore any byte stream and will not attempt to open a URI
        connection to the system identifier."""
        self.__charfile = charfile

    def getCharacterStream(self):
        "Get the character stream for this input source."
        return self.__charfile

# ===== ATTRIBUTESIMPL =====

class AttributesImpl:

    def __init__(self, attrs):
        """Non-NS-aware implementation.

        attrs should be of the form {name : value}."""
        self._attrs = attrs

    def getLength(self):
        return len(self._attrs)

    def getType(self, name):
        return "CDATA"

    def getValue(self, name):
        return self._attrs[name]

    def getValueByQName(self, name):
        return self._attrs[name]

    def getNameByQName(self, name):
        if name not in self._attrs:
            raise KeyError(name)
        return name

    def getQNameByName(self, name):
        if name not in self._attrs:
            raise KeyError(name)
        return name

    def getNames(self):
        return list(self._attrs.keys())

    def getQNames(self):
        return list(self._attrs.keys())

    def __len__(self):
        return len(self._attrs)

    def __getitem__(self, name):
        return self._attrs[name]

    def keys(self):
        return list(self._attrs.keys())

    def __contains__(self, name):
        return name in self._attrs

    def get(self, name, alternative=None):
        return self._attrs.get(name, alternative)

    def copy(self):
        return self.__class__(self._attrs)

    def items(self):
        return list(self._attrs.items())

    def values(self):
        return list(self._attrs.values())

# ===== ATTRIBUTESNSIMPL =====

class AttributesNSImpl(AttributesImpl):

    def __init__(self, attrs, qnames):
        """NS-aware implementation.

        attrs should be of the form {(ns_uri, lname): value, ...}.
        qnames of the form {(ns_uri, lname): qname, ...}."""
        self._attrs = attrs
        self._qnames = qnames

    def getValueByQName(self, name):
        for (nsname, qname) in self._qnames.items():
            if qname == name:
                return self._attrs[nsname]

        raise KeyError(name)

    def getNameByQName(self, name):
        for (nsname, qname) in self._qnames.items():
            if qname == name:
                return nsname

        raise KeyError(name)

    def getQNameByName(self, name):
        return self._qnames[name]

    def getQNames(self):
        return list(self._qnames.values())

    def copy(self):
        return self.__class__(self._attrs, self._qnames)


def _test():
    XMLReader()
    IncrementalParser()
    Locator()

if __name__ == "__main__":
    _test()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
[<                 @   s8  d  Z  d Z d d l Td d l m Z m Z d d l m Z d d l m Z m Z d d l m	 Z	 d d l m
 Z
 m Z d d	 l Z e j d	 d
  d k r e d d	   [ y d d l m Z Wn! e k
 r e d d	   Yn  Xe e d  re d d	   d d l m Z m Z m Z e j Z e j Z y d d	 l Z Wn e k
 rdd d   Z Yn Xd d	 l Z e j Z [ [ Gd d   d  Z Gd d   d e j  Z Gd d   d e j  e j  Z! d d   Z" e# d k r4d d	 l$ Z% e"   Z& e& j' e% j( j j)    e& j* e% j( j+    e& j, d  d	 S)z]
SAX driver for the pyexpat C module.  This driver works with
pyexpat.__version__ == '2.22'.
z0.20    )*)feature_validationfeature_namespaces)feature_namespace_prefixes)feature_external_gesfeature_external_pes)feature_string_interning)property_xml_stringproperty_interning_dictN   Zjavazexpat not available in Java)expatzexpat not supportedParserCreate)	xmlreadersaxutilshandlerc             C   s   |  S)N )or   r   )/usr/lib/python3.5/xml/sax/expatreader.py_mkproxy'   s    r   c               @   s   e  Z d  Z d S)_ClosedParserN)__name__
__module____qualname__r   r   r   r   r   .   s   r   c               @   sR   e  Z d  Z d Z d d   Z d d   Z d d   Z d d	   Z d
 d   Z d S)ExpatLocatorzLocator for use with the ExpatParser class.

    This uses a weak reference to the parser object to avoid creating
    a circular reference between the parser and the content handler.
    c             C   s   t  |  |  _ d  S)N)r   _ref)selfparserr   r   r   __init__9   s    zExpatLocator.__init__c             C   s&   |  j  } | j d  k r d  S| j j S)N)r   _parserErrorColumnNumber)r   r   r   r   r   getColumnNumber<   s    	zExpatLocator.getColumnNumberc             C   s&   |  j  } | j d  k r d S| j j S)N   )r   r   ErrorLineNumber)r   r   r   r   r   getLineNumberB   s    	zExpatLocator.getLineNumberc             C   s&   |  j  } | d  k r d  S| j j   S)N)r   _sourcegetPublicId)r   r   r   r   r   r%   H   s    	zExpatLocator.getPublicIdc             C   s&   |  j  } | d  k r d  S| j j   S)N)r   r$   getSystemId)r   r   r   r   r   r&   N   s    	zExpatLocator.getSystemIdN)	r   r   r   __doc__r   r    r#   r%   r&   r   r   r   r   r   3   s   r   c               @   s  e  Z d  Z d Z d dD d d  Z d d	   Z d
 d   Z d d   Z d d   Z d d   Z	 d d   Z
 d d   Z d d d  Z d d   Z d d   Z d d   Z d d   Z d  d!   Z d" d#   Z d$ d%   Z d& d'   Z d( d)   Z d* d+   Z d, d-   Z d. d/   Z d0 d1   Z d2 d3   Z d4 d5   Z d6 d7   Z d8 d9   Z d: d;   Z d< d=   Z d> d?   Z  d@ dA   Z! dB S)EExpatParserz$SAX driver for the pyexpat C module.r            c             C   se   t  j j |  |  t  j   |  _ d  |  _ | |  _ d  |  _ d |  _ g  |  _	 d |  _
 d  |  _ d  S)Nr   r!   )r   IncrementalParserr   ZInputSourcer$   r   _namespaces_lex_handler_prop_parsing_entity_stack_external_ges
_interning)r   ZnamespaceHandlingbufsizer   r   r   r   Z   s    						zExpatParser.__init__c             C   sO   t  j |  } | |  _ |  j   |  j j t |    t j j	 |  |  d S)z3Parse an XML document from a URL or an InputSource.N)
r   prepare_input_sourcer$   reset_cont_handlerZsetDocumentLocatorr   r   r,   parse)r   sourcer   r   r   r7   g   s
    	
zExpatParser.parsec             C   s,   | j    d  k	 r( |  j j | j     d  S)N)r&   r   ZSetBase)r   r8   r   r   r   prepareParserp   s    zExpatParser.prepareParserc             C   s*   t  j j |  |  |  j r& |  j   d  S)N)r   r,   setContentHandlerr/   _reset_cont_handler)r   r   r   r   r   r:   v   s    	zExpatParser.setContentHandlerc             C   sl   | t  k r |  j S| t k r, |  j d  k	 S| t t t f k rE d S| t k rX |  j St	 d |   d  S)Nr   zFeature '%s' not recognized)
r   r-   r   r2   r   r   r   r   r1   SAXNotRecognizedException)r   namer   r   r   
getFeature{   s    	zExpatParser.getFeaturec             C   s   |  j  r t d   | t k r- | |  _ n | t k rE | |  _ n | t k r~ | rr |  j d  k r{ i  |  _ q d  |  _ ns | t k r | r t d   nR | t	 k r | r t d   n1 | t
 k r | r t d   n t d |   d  S)Nz!Cannot set features while parsingz!expat does not support validationz/expat does not read external parameter entitiesz(expat does not report namespace prefixeszFeature '%s' not recognized)r/   SAXNotSupportedExceptionr   r-   r   r1   r   r2   r   r   r   r<   )r   r=   stater   r   r   
setFeature   s2    	zExpatParser.setFeaturec             C   s   | t  j k r |  j S| t k r) |  j S| t k rx |  j rl t |  j d  r] |  j j   St	 d   n t
 d   t	 d |   d  S)NGetInputContextz=This version of expat does not support getting the XML stringz.XML string cannot be returned when not parsingzProperty '%s' not recognized)r   property_lexical_handlerr.   r
   r2   r	   r   hasattrrB   r<   r?   )r   r=   r   r   r   getProperty   s    		zExpatParser.getPropertyc             C   sy   | t  j k r. | |  _ |  j ru |  j   nG | t k rF | |  _ n/ | t k re t d |   n t	 d |   d  S)NzProperty '%s' cannot be setzProperty '%s' not recognized)
r   rC   r.   r/   _reset_lex_handler_propr
   r2   r	   r?   r<   )r   r=   valuer   r   r   setProperty   s    		zExpatParser.setPropertyc             C   s   |  j  s) |  j   d |  _  |  j j   y |  j j | |  WnV t j k
 r } z3 t t j	 | j
  | |   } |  j j |  WYd  d  } ~ Xn Xd  S)Nr!   )r/   r5   r6   ZstartDocumentr   ZParser   errorZSAXParseExceptionZErrorStringcodeZ_err_handlerZ
fatalError)r   dataisFinaleexcr   r   r   feed   s    	
	zExpatParser.feedc             C   s  |  j  s* |  j d  k s* t |  j t  r. d  Sz6 |  j d d d |  j j   d |  _ d  |  _ Wd  d |  _ |  j d  k	 r t   } |  j j | _ |  j j	 | _	 | |  _ z) |  j
 j   } | d  k	 r | j   Wd  |  j
 j   } | d  k	 r | j   XXd  S)N rL   r!   r   )r0   r   
isinstancer   rO   r6   ZendDocumentr/   r   r"   r$   ZgetCharacterStreamcloseZgetByteStream)r   r   filer   r   r   rR      s*    				zExpatParser.closec             C   s(   |  j  j |  j _ |  j  j |  j _ d  S)N)r6   processingInstructionr   ZProcessingInstructionHandler
charactersZCharacterDataHandler)r   r   r   r   r;      s    zExpatParser._reset_cont_handlerc             C   s   |  j  } |  j } | d  k rN d  | _ d  | _ d  | _ d  | _ d  | _ n< | j | _ | j | _ | j	 | _ |  j
 | _ | j | _ d  S)N)r.   r   ZCommentHandlerZStartCdataSectionHandlerZEndCdataSectionHandlerZStartDoctypeDeclHandlerZEndDoctypeDeclHandlerZcommentZ
startCDATAZendCDATAstart_doctype_declZendDTD)r   Zlexr   r   r   r   rF      s    						z#ExpatParser._reset_lex_handler_propc             C   sa  |  j  r] t j |  j j   d d |  j |  _ d |  j _ |  j |  j _	 |  j
 |  j _ nB t j |  j j   d |  j |  _ |  j |  j _	 |  j |  j _ |  j   |  j |  j _ |  j |  j _ |  j |  j _ |  j |  j _ d  |  _ |  j r|  j   |  j |  j _ y |  j |  j _ Wn t k
 r7Yn X|  j j t j   d |  _! g  |  _" d  S)N internr!   r   )#r-   r   r   r$   ZgetEncodingr2   r   Znamespace_prefixesstart_element_nsZStartElementHandlerend_element_nsZEndElementHandlerstart_elementend_elementr;   unparsed_entity_declZUnparsedEntityDeclHandlernotation_declZNotationDeclHandlerstart_namespace_declZStartNamespaceDeclHandlerend_namespace_declZEndNamespaceDeclHandlerZ_decl_handler_propr.   rF   external_entity_refZExternalEntityRefHandlerskipped_entity_handlerZSkippedEntityHandlerAttributeErrorZSetParamEntityParsingZ*XML_PARAM_ENTITY_PARSING_UNLESS_STANDALONEr/   r0   )r   r   r   r   r5   	  s6    	
		
	
	zExpatParser.resetc             C   s   |  j  d  k r d  S|  j  j S)N)r   r   )r   r   r   r   r    0  s    zExpatParser.getColumnNumberc             C   s   |  j  d  k r d S|  j  j S)Nr!   )r   r"   )r   r   r   r   r#   5  s    zExpatParser.getLineNumberc             C   s   |  j  j   S)N)r$   r%   )r   r   r   r   r%   :  s    zExpatParser.getPublicIdc             C   s   |  j  j   S)N)r$   r&   )r   r   r   r   r&   =  s    zExpatParser.getSystemIdc             C   s   |  j  j | t |   d  S)N)r6   ZstartElementAttributesImpl)r   r=   attrsr   r   r   r[   A  s    zExpatParser.start_elementc             C   s   |  j  j |  d  S)N)r6   Z
endElement)r   r=   r   r   r   r\   D  s    zExpatParser.end_elementc             C   sL  | j    } t |  d k r- d  | f } n5 t |  d k rV | d | d f } n t |  } i  } i  } x | j   D] \ } } | j    } t |  }	 |	 d k r | }
 d  | f } nQ |	 d k r d | d | d f }
 | d | d f } n | d }
 t |  } | | | <|
 | | <q{ W|  j j | d  t | |   d  S)Nr!      r   z%s:%sr)   )splitlentupleitemsr6   ZstartElementNSAttributesNSImpl)r   r=   re   pairZnewattrsZqnamesZanamerG   partsZlengthZqnameZapairr   r   r   rY   G  s.    

zExpatParser.start_element_nsc             C   sy   | j    } t |  d k r- d  | f } n5 t |  d k rV | d | d f } n t |  } |  j j | d   d  S)Nr!   rf   r   )rg   rh   ri   r6   ZendElementNS)r   r=   rl   r   r   r   rZ   i  s    zExpatParser.end_element_nsc             C   s   |  j  j | |  d  S)N)r6   rT   )r   targetrK   r   r   r   processing_instructionu  s    z"ExpatParser.processing_instructionc             C   s   |  j  j |  d  S)N)r6   rU   )r   rK   r   r   r   character_datay  s    zExpatParser.character_datac             C   s   |  j  j | |  d  S)N)r6   ZstartPrefixMapping)r   prefixZurir   r   r   r_   |  s    z ExpatParser.start_namespace_declc             C   s   |  j  j |  d  S)N)r6   ZendPrefixMapping)r   rq   r   r   r   r`     s    zExpatParser.end_namespace_declc             C   s   |  j  j | | |  d  S)N)r.   ZstartDTD)r   r=   sysidpubidZhas_internal_subsetr   r   r   rV     s    zExpatParser.start_doctype_declc             C   s   |  j  j | | | |  d  S)N)_dtd_handlerZunparsedEntityDecl)r   r=   baserr   rs   Znotation_namer   r   r   r]     s    z ExpatParser.unparsed_entity_declc             C   s   |  j  j | | |  d  S)N)rt   ZnotationDecl)r   r=   ru   rr   rs   r   r   r   r^     s    zExpatParser.notation_declc          	   C   s   |  j  s d S|  j j | |  } t j | |  j j   p= d  } |  j j |  j	 |  j f  |  j	 j
 |  |  _	 | |  _ y t j j |  |  Wn d SYn X|  j d \ |  _	 |  _ |  j d =d S)Nr!   rP   r   rv   )r1   Z_ent_handlerZresolveEntityr   r4   r$   r&   r0   appendr   ZExternalEntityParserCreater   r,   r7   )r   contextru   rr   rs   r8   r   r   r   ra     s     					
zExpatParser.external_entity_refc             C   s$   | r d | } |  j  j |  d  S)N%)r6   ZskippedEntity)r   r=   Zis_per   r   r   rb     s    
z"ExpatParser.skipped_entity_handlerNi   i  )"r   r   r   r'   r   r7   r9   r:   r>   rA   rE   rH   rO   rR   r;   rF   r5   r    r#   r%   r&   r[   r\   rY   rZ   ro   rp   r_   r`   rV   r]   r^   ra   rb   r   r   r   r   r(   W   s>   	'"r(   c              O   s   t  |  |   S)N)r(   )argskwargsr   r   r   create_parser  s    r|   __main__z:http://www.ibiblio.org/xml/examples/shakespeare/hamlet.xml)-r'   versionZxml.sax._exceptionsZxml.sax.handlerr   r   r   r   r   r   r	   r
   sysplatformZSAXReaderNotAvailableZxml.parsersr   ImportErrorrD   Zxml.saxr   r   r   rd   rk   _weakrefr   weakrefproxyr   ZLocatorr   r,   r(   r|   r   Zxml.sax.saxutilsZxmlpr:   ZsaxZXMLGeneratorZsetErrorHandlerZErrorHandlerr7   r   r   r   r   <module>   sL   
			$ S	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   
[b6                 @   s   d  Z  d Z Gd d   d  Z Gd d   d  Z Gd d   d  Z Gd d	   d	  Z d
 Z d Z d Z d Z	 d Z
 d Z e e e e	 e
 e g Z d Z d Z d Z d Z d Z d Z e e e e e e g Z d S)a0  
This module contains the core classes of version 2.0 of SAX for Python.
This file provides only default classes with absolutely minimum
functionality, from which drivers and applications can be subclassed.

Many of these classes are empty and are included only as documentation
of the interfaces.

$Id$
z2.0betac               @   s:   e  Z d  Z d Z d d   Z d d   Z d d   Z d S)	ErrorHandlera  Basic interface for SAX error handlers.

    If you create an object that implements this interface, then
    register the object with your XMLReader, the parser will call the
    methods in your object to report all warnings and errors. There
    are three levels of errors available: warnings, (possibly)
    recoverable errors, and unrecoverable errors. All methods take a
    SAXParseException as the only parameter.c             C   s
   |  d S)zHandle a recoverable error.N )self	exceptionr   r   %/usr/lib/python3.5/xml/sax/handler.pyerror    s    zErrorHandler.errorc             C   s
   |  d S)zHandle a non-recoverable error.Nr   )r   r   r   r   r   
fatalError$   s    zErrorHandler.fatalErrorc             C   s   t  |  d S)zHandle a warning.N)print)r   r   r   r   r   warning(   s    zErrorHandler.warningN)__name__
__module____qualname____doc__r   r   r	   r   r   r   r   r      s   r   c               @   s   e  Z d  Z d Z d d   Z d d   Z d d   Z d d	   Z d
 d   Z d d   Z	 d d   Z
 d d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d S)ContentHandlerzInterface for receiving logical document content events.

    This is the main callback interface in SAX, and the one most
    important to applications. The order of events in this interface
    mirrors the order of the information in the document.c             C   s   d  |  _  d  S)N)_locator)r   r   r   r   __init__6   s    zContentHandler.__init__c             C   s   | |  _  d S)a#  Called by the parser to give the application a locator for
        locating the origin of document events.

        SAX parsers are strongly encouraged (though not absolutely
        required) to supply a locator: if it does so, it must supply
        the locator to the application by invoking this method before
        invoking any of the other methods in the DocumentHandler
        interface.

        The locator allows the application to determine the end
        position of any document-related event, even if the parser is
        not reporting an error. Typically, the application will use
        this information for reporting its own errors (such as
        character content that does not match an application's
        business rules). The information returned by the locator is
        probably not sufficient for use with a search engine.

        Note that the locator will return correct information only
        during the invocation of the events in this interface. The
        application should not attempt to use it at any other time.N)r   )r   Zlocatorr   r   r   setDocumentLocator9   s    z!ContentHandler.setDocumentLocatorc             C   s   d S)zReceive notification of the beginning of a document.

        The SAX parser will invoke this method only once, before any
        other methods in this interface or in DTDHandler (except for
        setDocumentLocator).Nr   )r   r   r   r   startDocumentP   s    zContentHandler.startDocumentc             C   s   d S)aQ  Receive notification of the end of a document.

        The SAX parser will invoke this method only once, and it will
        be the last method invoked during the parse. The parser shall
        not invoke this method until it has either abandoned parsing
        (because of an unrecoverable error) or reached the end of
        input.Nr   )r   r   r   r   endDocumentW   s    zContentHandler.endDocumentc             C   s   d S)a  Begin the scope of a prefix-URI Namespace mapping.

        The information from this event is not necessary for normal
        Namespace processing: the SAX XML reader will automatically
        replace prefixes for element and attribute names when the
        http://xml.org/sax/features/namespaces feature is true (the
        default).

        There are cases, however, when applications need to use
        prefixes in character data or in attribute values, where they
        cannot safely be expanded automatically; the
        start/endPrefixMapping event supplies the information to the
        application to expand prefixes in those contexts itself, if
        necessary.

        Note that start/endPrefixMapping events are not guaranteed to
        be properly nested relative to each-other: all
        startPrefixMapping events will occur before the corresponding
        startElement event, and all endPrefixMapping events will occur
        after the corresponding endElement event, but their order is
        not guaranteed.Nr   )r   prefixZurir   r   r   startPrefixMapping`   s    z!ContentHandler.startPrefixMappingc             C   s   d S)zEnd the scope of a prefix-URI mapping.

        See startPrefixMapping for details. This event will always
        occur after the corresponding endElement event, but the order
        of endPrefixMapping events is not otherwise guaranteed.Nr   )r   r   r   r   r   endPrefixMappingw   s    zContentHandler.endPrefixMappingc             C   s   d S)a  Signals the start of an element in non-namespace mode.

        The name parameter contains the raw XML 1.0 name of the
        element type as a string and the attrs parameter holds an
        instance of the Attributes class containing the attributes of
        the element.Nr   )r   nameattrsr   r   r   startElement~   s    zContentHandler.startElementc             C   s   d S)zSignals the end of an element in non-namespace mode.

        The name parameter contains the name of the element type, just
        as with the startElement event.Nr   )r   r   r   r   r   
endElement   s    zContentHandler.endElementc             C   s   d S)a  Signals the start of an element in namespace mode.

        The name parameter contains the name of the element type as a
        (uri, localname) tuple, the qname parameter the raw XML 1.0
        name used in the source document, and the attrs parameter
        holds an instance of the Attributes class containing the
        attributes of the element.

        The uri part of the name tuple is None for elements which have
        no namespace.Nr   )r   r   qnamer   r   r   r   startElementNS   s    zContentHandler.startElementNSc             C   s   d S)zSignals the end of an element in namespace mode.

        The name parameter contains the name of the element type, just
        as with the startElementNS event.Nr   )r   r   r   r   r   r   endElementNS   s    zContentHandler.endElementNSc             C   s   d S)a  Receive notification of character data.

        The Parser will call this method to report each chunk of
        character data. SAX parsers may return all contiguous
        character data in a single chunk, or they may split it into
        several chunks; however, all of the characters in any single
        event must come from the same external entity so that the
        Locator provides useful information.Nr   )r   Zcontentr   r   r   
characters   s    zContentHandler.charactersc             C   s   d S)aw  Receive notification of ignorable whitespace in element content.

        Validating Parsers must use this method to report each chunk
        of ignorable whitespace (see the W3C XML 1.0 recommendation,
        section 2.10): non-validating parsers may also use this method
        if they are capable of parsing and using content models.

        SAX parsers may return all contiguous whitespace in a single
        chunk, or they may split it into several chunks; however, all
        of the characters in any single event must come from the same
        external entity, so that the Locator provides useful
        information.Nr   )r   Z
whitespacer   r   r   ignorableWhitespace   s    z"ContentHandler.ignorableWhitespacec             C   s   d S)a  Receive notification of a processing instruction.

        The Parser will invoke this method once for each processing
        instruction found: note that processing instructions may occur
        before or after the main document element.

        A SAX parser should never report an XML declaration (XML 1.0,
        section 2.8) or a text declaration (XML 1.0, section 4.3.1)
        using this method.Nr   )r   targetdatar   r   r   processingInstruction   s    z$ContentHandler.processingInstructionc             C   s   d S)a  Receive notification of a skipped entity.

        The Parser will invoke this method once for each entity
        skipped. Non-validating processors may skip entities if they
        have not seen the declarations (because, for example, the
        entity was declared in an external DTD subset). All processors
        may skip external entities, depending on the values of the
        http://xml.org/sax/features/external-general-entities and the
        http://xml.org/sax/features/external-parameter-entities
        properties.Nr   )r   r   r   r   r   skippedEntity   s    zContentHandler.skippedEntityN)r
   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r"   r#   r   r   r   r   r   /   s   	
r   c               @   s.   e  Z d  Z d Z d d   Z d d   Z d S)
DTDHandlerzHandle DTD events.

    This interface specifies only those DTD events required for basic
    parsing (unparsed entities and attributes).c             C   s   d S)z$Handle a notation declaration event.Nr   )r   r   publicIdsystemIdr   r   r   notationDecl   s    zDTDHandler.notationDeclc             C   s   d S)z,Handle an unparsed entity declaration event.Nr   )r   r   r%   r&   Zndatar   r   r   unparsedEntityDecl   s    zDTDHandler.unparsedEntityDeclN)r
   r   r   r   r'   r(   r   r   r   r   r$      s   r$   c               @   s"   e  Z d  Z d Z d d   Z d S)EntityResolvera7  Basic interface for resolving entities. If you create an object
    implementing this interface, then register the object with your
    Parser, the parser will call the method in your object to
    resolve all external entities. Note that DefaultHandler implements
    this interface with the default behaviour.c             C   s   | S)zResolve the system identifier of an entity and return either
        the system identifier to read from as a string, or an InputSource
        to read from.r   )r   r%   r&   r   r   r   resolveEntity   s    zEntityResolver.resolveEntityN)r
   r   r   r   r*   r   r   r   r   r)      s   r)   z&http://xml.org/sax/features/namespacesz.http://xml.org/sax/features/namespace-prefixesz,http://xml.org/sax/features/string-interningz&http://xml.org/sax/features/validationz5http://xml.org/sax/features/external-general-entitiesz7http://xml.org/sax/features/external-parameter-entitiesz-http://xml.org/sax/properties/lexical-handlerz1http://xml.org/sax/properties/declaration-handlerz&http://xml.org/sax/properties/dom-nodez(http://xml.org/sax/properties/xml-stringz-http://www.python.org/sax/properties/encodingz3http://www.python.org/sax/properties/interning-dictN)r   versionr   r   r$   r)   Zfeature_namespacesZfeature_namespace_prefixesZfeature_string_interningZfeature_validationZfeature_external_gesZfeature_external_pesZall_featuresZproperty_lexical_handlerZproperty_declaration_handlerZproperty_dom_nodeZproperty_xml_stringZproperty_encodingZproperty_interning_dictZall_propertiesr   r   r   r   <module>
   s:   
		                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
[/                 @   s   d  Z  d d l Z d d l Z d d l Z d d l Z d d l Z d d l m Z d d l m	 Z	 d d   Z
 i  d d	  Z i  d
 d  Z i  d d  Z d d   Z Gd d   d e j  Z Gd d   d e	 j  Z d d d  Z d S)znA library of useful helper classes to the SAX classes, for the
convenience of application and driver writers.
    N   )handler)	xmlreaderc             C   s3   x, | j    D] \ } } |  j | |  }  q W|  S)z2Replace substrings of a string using a dictionary.)itemsreplace)sdkeyvalue r   &/usr/lib/python3.5/xml/sax/saxutils.py__dict_replace   s    r   c             C   sO   |  j  d d  }  |  j  d d  }  |  j  d d  }  | rK t |  |  }  |  S)zEscape &, <, and > in a string of data.

    You can escape other strings of data by passing a dictionary as
    the optional entities parameter.  The keys and values must all be
    strings; each key will be replaced with its corresponding value.
    &z&amp;>z&gt;<z&lt;)r   r   )dataentitiesr   r   r   escape   s    	r   c             C   sI   |  j  d d  }  |  j  d d  }  | r9 t |  |  }  |  j  d d  S)a
  Unescape &amp;, &lt;, and &gt; in a string of data.

    You can unescape other strings of data by passing a dictionary as
    the optional entities parameter.  The keys and values must all be
    strings; each key will be replaced with its corresponding value.
    z&lt;r   z&gt;r   z&amp;r   )r   r   )r   r   r   r   r   unescape"   s
    r   c             C   s   | j    } | j d d d d d d i  t |  |  }  d |  k rx d |  k rk d	 |  j d d
  }  q d |  }  n
 d	 |  }  |  S)a  Escape and quote an attribute value.

    Escape &, <, and > in a string of data, then quote it for use as
    an attribute value.  The " character will be escaped as well, if
    necessary.

    You can escape other strings of data by passing a dictionary as
    the optional entities parameter.  The keys and values must all be
    strings; each key will be replaced with its corresponding value.
    
z&#10;z&#13;	z&#9;"'z"%s"z&quot;z'%s')copyupdater   r   )r   r   r   r   r   	quoteattr0   s    
r   c                s    d  k r d d  l  } | j St   t j  r5   St   t j t j f  rT   St   t j  r G  f d d   d  } |   } d d   | _	 nX t j
   } d d   | _   j | _ y   j | _   j | _ Wn t k
 r Yn Xt j | d | d d	 d
 d d d S)Nr   c                   s+   e  Z d  Z   j Z   f d d   Z d S)z _gettextwriter.<locals>._wrapperc                s   t    |  S)N)getattr)selfname)outr   r   __getattr__[   s    z,_gettextwriter.<locals>._wrapper.__getattr__N)__name__
__module____qualname__	__class__r!   r   )r    r   r   _wrapperY   s   	r&   c               S   s   d  S)Nr   r   r   r   r   <lambda>^   s    z _gettextwriter.<locals>.<lambda>c               S   s   d S)NTr   r   r   r   r   r'   c   s    encodingerrorsxmlcharrefreplacenewliner   Zwrite_throughT)sysstdout
isinstanceio
TextIOBasecodecsStreamWriterStreamReaderWriter	RawIOBasecloseBufferedIOBasewritablewriteseekabletellAttributeErrorTextIOWrapper)r    r(   r,   r&   bufferr   )r    r   _gettextwriterH   s.    	r>   c               @   s   e  Z d  Z d d d d d  Z d d   Z d d d	  Z d
 d   Z d d   Z d d   Z d d   Z	 d d   Z
 d d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d S) XMLGeneratorNz
iso-8859-1Fc             C   s{   t  j j |   t | |  } | j |  _ | j |  _ i  g |  _ |  j d |  _	 g  |  _
 | |  _ | |  _ d |  _ d  S)Nr   F)r   ContentHandler__init__r>   r8   _writeflush_flush_ns_contexts_current_context_undeclared_ns_maps	_encoding_short_empty_elements_pending_start_element)r   r    r(   Zshort_empty_elementsr   r   r   rB   s   s    			zXMLGenerator.__init__c             C   sU   | d rM d | d k r& d | d S|  j  | d } | rM | d | d S| d S)z7Builds a qualified name from a (ns_url, localname) pairr   z$http://www.w3.org/XML/1998/namespacezxml:r   :)rG   )r   r   prefixr   r   r   _qname   s    
zXMLGenerator._qnamec             C   s#   |  j  r |  j d  d |  _  d  S)Nr   F)rK   rC   )r   
endElementr   r   r   _finish_pending_start_element   s    	z*XMLGenerator._finish_pending_start_elementc             C   s   |  j  d |  j  d  S)Nz$<?xml version="1.0" encoding="%s"?>
)rC   rI   )r   r   r   r   startDocument   s    	zXMLGenerator.startDocumentc             C   s   |  j    d  S)N)rE   )r   r   r   r   endDocument   s    zXMLGenerator.endDocumentc             C   s@   |  j  j |  j j    | |  j | <|  j j | | f  d  S)N)rF   appendrG   r   rH   )r   rM   urir   r   r   startPrefixMapping   s    zXMLGenerator.startPrefixMappingc             C   s   |  j  d |  _ |  j  d =d  S)Nr   r@   r@   )rF   rG   )r   rM   r   r   r   endPrefixMapping   s    zXMLGenerator.endPrefixMappingc             C   s{   |  j    |  j d |  x7 | j   D]) \ } } |  j d | t |  f  q( W|  j rj d |  _ n |  j d  d  S)Nr   z %s=%sTr   )rP   rC   r   r   rJ   rK   )r   r   attrsr
   r   r   r   startElement   s    
!	zXMLGenerator.startElementc             C   s7   |  j  r" |  j d  d |  _  n |  j d |  d  S)Nz/>Fz</%s>)rK   rC   )r   r   r   r   r   rO      s    	zXMLGenerator.endElementc             C   s   |  j    |  j d |  j |   xH |  j D]= \ } } | rZ |  j d | | f  q. |  j d |  q. Wg  |  _ x@ | j   D]2 \ } } |  j d |  j |  t |  f  q W|  j r d |  _ n |  j d  d  S)Nr   z xmlns:%s="%s"z xmlns="%s"z %s=%sTr   )rP   rC   rN   rH   r   r   rJ   rK   )r   r   qnamerW   rM   rT   r
   r   r   r   startElementNS   s    
	*	zXMLGenerator.startElementNSc             C   s@   |  j  r" |  j d  d |  _  n |  j d |  j |   d  S)Nz/>Fz</%s>)rK   rC   rN   )r   r   rY   r   r   r   endElementNS   s    	zXMLGenerator.endElementNSc             C   sH   | rD |  j    t | t  s1 t | |  j  } |  j t |   d  S)N)rP   r.   strrI   rC   r   )r   contentr   r   r   
characters   s
    
zXMLGenerator.charactersc             C   sB   | r> |  j    t | t  s1 t | |  j  } |  j |  d  S)N)rP   r.   r\   rI   rC   )r   r]   r   r   r   ignorableWhitespace   s
    
z XMLGenerator.ignorableWhitespacec             C   s%   |  j    |  j d | | f  d  S)Nz	<?%s %s?>)rP   rC   )r   targetr   r   r   r   processingInstruction   s    
z"XMLGenerator.processingInstruction)r"   r#   r$   rB   rN   rP   rQ   rR   rU   rV   rX   rO   rZ   r[   r^   r_   ra   r   r   r   r   r?   q   s   
r?   c               @   si  e  Z d  Z d Z d d d  Z d d   Z d d   Z d	 d
   Z d d   Z d d   Z	 d d   Z
 d d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d d    Z d! d"   Z d# d$   Z d% d&   Z d' d(   Z d) d*   Z d+ d,   Z d- d.   Z d/ d0   Z d1 d2   Z d3 d4   Z d5 d6   Z d7 d8   Z d9 d:   Z d S);XMLFilterBaseaY  This class is designed to sit between an XMLReader and the
    client application's event handlers.  By default, it does nothing
    but pass requests up to the reader and events on to the handlers
    unmodified, but subclasses can override specific methods to modify
    the event stream or the configuration requests as they pass
    through.Nc             C   s   t  j j |   | |  _ d  S)N)r   	XMLReaderrB   _parent)r   parentr   r   r   rB      s    zXMLFilterBase.__init__c             C   s   |  j  j |  d  S)N)_err_handlererror)r   	exceptionr   r   r   rg      s    zXMLFilterBase.errorc             C   s   |  j  j |  d  S)N)rf   
fatalError)r   rh   r   r   r   ri      s    zXMLFilterBase.fatalErrorc             C   s   |  j  j |  d  S)N)rf   warning)r   rh   r   r   r   rj      s    zXMLFilterBase.warningc             C   s   |  j  j |  d  S)N)_cont_handlersetDocumentLocator)r   Zlocatorr   r   r   rl      s    z XMLFilterBase.setDocumentLocatorc             C   s   |  j  j   d  S)N)rk   rQ   )r   r   r   r   rQ      s    zXMLFilterBase.startDocumentc             C   s   |  j  j   d  S)N)rk   rR   )r   r   r   r   rR     s    zXMLFilterBase.endDocumentc             C   s   |  j  j | |  d  S)N)rk   rU   )r   rM   rT   r   r   r   rU     s    z XMLFilterBase.startPrefixMappingc             C   s   |  j  j |  d  S)N)rk   rV   )r   rM   r   r   r   rV   	  s    zXMLFilterBase.endPrefixMappingc             C   s   |  j  j | |  d  S)N)rk   rX   )r   r   rW   r   r   r   rX     s    zXMLFilterBase.startElementc             C   s   |  j  j |  d  S)N)rk   rO   )r   r   r   r   r   rO     s    zXMLFilterBase.endElementc             C   s   |  j  j | | |  d  S)N)rk   rZ   )r   r   rY   rW   r   r   r   rZ     s    zXMLFilterBase.startElementNSc             C   s   |  j  j | |  d  S)N)rk   r[   )r   r   rY   r   r   r   r[     s    zXMLFilterBase.endElementNSc             C   s   |  j  j |  d  S)N)rk   r^   )r   r]   r   r   r   r^     s    zXMLFilterBase.charactersc             C   s   |  j  j |  d  S)N)rk   r_   )r   charsr   r   r   r_     s    z!XMLFilterBase.ignorableWhitespacec             C   s   |  j  j | |  d  S)N)rk   ra   )r   r`   r   r   r   r   ra     s    z#XMLFilterBase.processingInstructionc             C   s   |  j  j |  d  S)N)rk   skippedEntity)r   r   r   r   r   rn   !  s    zXMLFilterBase.skippedEntityc             C   s   |  j  j | | |  d  S)N)_dtd_handlernotationDecl)r   r   publicIdsystemIdr   r   r   rp   &  s    zXMLFilterBase.notationDeclc             C   s   |  j  j | | | |  d  S)N)ro   unparsedEntityDecl)r   r   rq   rr   Zndatar   r   r   rs   )  s    z XMLFilterBase.unparsedEntityDeclc             C   s   |  j  j | |  S)N)Z_ent_handlerresolveEntity)r   rq   rr   r   r   r   rt   .  s    zXMLFilterBase.resolveEntityc             C   sT   |  j  j |   |  j  j |   |  j  j |   |  j  j |   |  j  j |  d  S)N)rd   ZsetContentHandlerZsetErrorHandlerZsetEntityResolverZsetDTDHandlerparse)r   sourcer   r   r   ru   3  s
    zXMLFilterBase.parsec             C   s   |  j  j |  d  S)N)rd   	setLocale)r   Zlocaler   r   r   rw   :  s    zXMLFilterBase.setLocalec             C   s   |  j  j |  S)N)rd   
getFeature)r   r   r   r   r   rx   =  s    zXMLFilterBase.getFeaturec             C   s   |  j  j | |  d  S)N)rd   
setFeature)r   r   stater   r   r   ry   @  s    zXMLFilterBase.setFeaturec             C   s   |  j  j |  S)N)rd   getProperty)r   r   r   r   r   r{   C  s    zXMLFilterBase.getPropertyc             C   s   |  j  j | |  d  S)N)rd   setProperty)r   r   r
   r   r   r   r|   F  s    zXMLFilterBase.setPropertyc             C   s   |  j  S)N)rd   )r   r   r   r   	getParentK  s    zXMLFilterBase.getParentc             C   s   | |  _  d  S)N)rd   )r   re   r   r   r   	setParentN  s    zXMLFilterBase.setParent) r"   r#   r$   __doc__rB   rg   ri   rj   rl   rQ   rR   rU   rV   rX   rO   rZ   r[   r^   r_   ra   rn   rp   rs   rt   ru   rw   rx   ry   r{   r|   r}   r~   r   r   r   r   rb      s:   rb    c             C   s  t  |  t  r! t j |   }  n t |  d  r |  } t j   }  t  | j d  t  rj |  j |  n |  j |  t | d  r t  | j t  r |  j	 | j  |  j
   d k r}|  j   d k r}|  j   } t j j t j j |   } t j j | |  } t j j |  r<|  j	 |  t | d  } n4 |  j	 t j j | |   t j j |  j    } |  j |  |  S)zThis function takes an InputSource and an optional base URL and
    returns a fully resolved InputSource object ready for reading.readr   r   Nrb)r.   r\   r   ZInputSourcehasattrr   ZsetCharacterStreamZsetByteStreamr   ZsetSystemIdZgetCharacterStreamZgetByteStreamZgetSystemIdospathdirnamenormpathjoinisfileopenurllibru   ZurljoinZrequestZurlopen)rv   basefZsysidZbaseheadZsysidfilenamer   r   r   prepare_input_sourceS  s*    !$r   )r   r   Zurllib.parser   Zurllib.requestr/   r1   r   r   r   r   r   r   r   r>   rA   r?   rc   rb   r   r   r   r   r   <module>   s   $)so                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         
[1                 @   s   d  Z  d d l m Z d d l m Z m Z Gd d   d  Z Gd d   d e  Z Gd d	   d	  Z Gd
 d   d  Z	 Gd d   d  Z
 Gd d   d e
  Z d d   Z e d k r e   d S)z]An XML Reader is the SAX 2 name for an XML parser. XML Parsers
should be based on this code.    )handler)SAXNotSupportedExceptionSAXNotRecognizedExceptionc               @   s   e  Z d  Z d Z d d   Z d d   Z d d   Z d d	   Z d
 d   Z d d   Z	 d d   Z
 d d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d  S)!	XMLReadera%  Interface for reading an XML document using callbacks.

    XMLReader is the interface that an XML parser's SAX2 driver must
    implement. This interface allows an application to set and query
    features and properties in the parser, to register event handlers
    for document processing, and to initiate a document parse.

    All SAX interfaces are assumed to be synchronous: the parse
    methods must not return until parsing is complete, and readers
    must wait for an event-handler callback to return before reporting
    the next event.c             C   s@   t  j   |  _ t  j   |  _ t  j   |  _ t  j   |  _ d  S)N)	r   ZContentHandler_cont_handlerZ
DTDHandler_dtd_handlerZEntityResolver_ent_handlerZErrorHandler_err_handler)self r   '/usr/lib/python3.5/xml/sax/xmlreader.py__init__   s    zXMLReader.__init__c             C   s   t  d   d S)zAParse an XML document from a system identifier or an InputSource.z This method must be implemented!N)NotImplementedError)r
   sourcer   r   r   parse   s    zXMLReader.parsec             C   s   |  j  S)z#Returns the current ContentHandler.)r   )r
   r   r   r   getContentHandler"   s    zXMLReader.getContentHandlerc             C   s   | |  _  d S)z:Registers a new object to receive document content events.N)r   )r
   r   r   r   r   setContentHandler&   s    zXMLReader.setContentHandlerc             C   s   |  j  S)z Returns the current DTD handler.)r   )r
   r   r   r   getDTDHandler*   s    zXMLReader.getDTDHandlerc             C   s   | |  _  d S)z7Register an object to receive basic DTD-related events.N)r   )r
   r   r   r   r   setDTDHandler.   s    zXMLReader.setDTDHandlerc             C   s   |  j  S)z#Returns the current EntityResolver.)r   )r
   r   r   r   getEntityResolver2   s    zXMLReader.getEntityResolverc             C   s   | |  _  d S)z0Register an object to resolve external entities.N)r   )r
   Zresolverr   r   r   setEntityResolver6   s    zXMLReader.setEntityResolverc             C   s   |  j  S)z!Returns the current ErrorHandler.)r	   )r
   r   r   r   getErrorHandler:   s    zXMLReader.getErrorHandlerc             C   s   | |  _  d S)z3Register an object to receive error-message events.N)r	   )r
   r   r   r   r   setErrorHandler>   s    zXMLReader.setErrorHandlerc             C   s   t  d   d S)aH  Allow an application to set the locale for errors and warnings.

        SAX parsers are not required to provide localization for errors
        and warnings; if they cannot support the requested locale,
        however, they must raise a SAX exception. Applications may
        request a locale change in the middle of a parse.zLocale support not implementedN)r   )r
   Zlocaler   r   r   	setLocaleB   s    zXMLReader.setLocalec             C   s   t  d |   d S)z1Looks up and returns the state of a SAX2 feature.zFeature '%s' not recognizedN)r   )r
   namer   r   r   
getFeatureK   s    zXMLReader.getFeaturec             C   s   t  d |   d S)z!Sets the state of a SAX2 feature.zFeature '%s' not recognizedN)r   )r
   r   stater   r   r   
setFeatureO   s    zXMLReader.setFeaturec             C   s   t  d |   d S)z2Looks up and returns the value of a SAX2 property.zProperty '%s' not recognizedN)r   )r
   r   r   r   r   getPropertyS   s    zXMLReader.getPropertyc             C   s   t  d |   d S)z"Sets the value of a SAX2 property.zProperty '%s' not recognizedN)r   )r
   r   valuer   r   r   setPropertyW   s    zXMLReader.setPropertyN)__name__
__module____qualname____doc__r   r   r   r   r   r   r   r   r   r   r   r   r   r   r    r   r   r   r   r      s    	r   c               @   sa   e  Z d  Z d Z d d d  Z d d   Z d d	   Z d
 d   Z d d   Z d d   Z	 d S)IncrementalParseras  This interface adds three extra methods to the XMLReader
    interface that allow XML parsers to support incremental
    parsing. Support for this interface is optional, since not all
    underlying XML parsers support this functionality.

    When the parser is instantiated it is ready to begin accepting
    data from the feed method immediately. After parsing has been
    finished with a call to close the reset method must be called to
    make the parser ready to accept new data, either from feed or
    using the parse method.

    Note that these methods must _not_ be called during parsing, that
    is, after parse has been called and before it returns.

    By default, the class also implements the parse method of the XMLReader
    interface using the feed, close and reset methods of the
    IncrementalParser interface as a convenience to SAX 2.0 driver
    writers.      c             C   s   | |  _  t j |   d  S)N)_bufsizer   r   )r
   bufsizer   r   r   r   o   s    	zIncrementalParser.__init__c             C   s   d d l  m } | j |  } |  j |  | j   } | d  k rP | j   } | j |  j  } x) | r |  j |  | j |  j  } qe W|  j	   d  S)Nr   )saxutils)
 r*   Zprepare_input_sourceprepareParsergetCharacterStreamgetByteStreamreadr(   feedclose)r
   r   r*   filebufferr   r   r   r   s   s    	zIncrementalParser.parsec             C   s   t  d   d S)a  This method gives the raw XML data in the data parameter to
        the parser and makes it parse the data, emitting the
        corresponding events. It is allowed for XML constructs to be
        split across several calls to feed.

        feed may raise SAXException.z This method must be implemented!N)r   )r
   datar   r   r   r0      s    zIncrementalParser.feedc             C   s   t  d   d S)ztThis method is called by the parse implementation to allow
        the SAX 2.0 driver to prepare itself for parsing.z!prepareParser must be overridden!N)r   )r
   r   r   r   r   r,      s    zIncrementalParser.prepareParserc             C   s   t  d   d S)a  This method is called when the entire XML document has been
        passed to the parser through the feed method, to notify the
        parser that there are no more data. This allows the parser to
        do the final checks on the document and empty the internal
        data buffer.

        The parser will not be ready to parse another document until
        the reset method has been called.

        close may raise SAXException.z This method must be implemented!N)r   )r
   r   r   r   r1      s    zIncrementalParser.closec             C   s   t  d   d S)zThis method is called after close has been called to reset
        the parser so that it is ready to parse new documents. The
        results of calling parse or feed after close without calling
        reset are undefined.z This method must be implemented!N)r   )r
   r   r   r   reset   s    zIncrementalParser.resetNi   )
r!   r"   r#   r$   r   r   r0   r,   r1   r5   r   r   r   r   r%   [   s   	r%   c               @   sF   e  Z d  Z d Z d d   Z d d   Z d d   Z d d	   Z d
 S)LocatorzInterface for associating a SAX event with a document
    location. A locator object will return valid results only during
    calls to DocumentHandler methods; at any other time, the
    results are unpredictable.c             C   s   d S)z6Return the column number where the current event ends.r   r   )r
   r   r   r   getColumnNumber   s    zLocator.getColumnNumberc             C   s   d S)z4Return the line number where the current event ends.r   r7   r   )r
   r   r   r   getLineNumber   s    zLocator.getLineNumberc             C   s   d S)z3Return the public identifier for the current event.Nr   )r
   r   r   r   getPublicId   s    zLocator.getPublicIdc             C   s   d S)z3Return the system identifier for the current event.Nr   )r
   r   r   r   getSystemId   s    zLocator.getSystemIdN)r!   r"   r#   r$   r8   r9   r:   r;   r   r   r   r   r6      s
   r6   c               @   s   e  Z d  Z d Z d d d  Z d d   Z d d   Z d	 d
   Z d d   Z d d   Z	 d d   Z
 d d   Z d d   Z d d   Z d d   Z d S)InputSourcean  Encapsulation of the information needed by the XMLReader to
    read entities.

    This class may include information about the public identifier,
    system identifier, byte stream (possibly with character encoding
    information) and/or the character stream of an entity.

    Applications will create objects of this class for use in the
    XMLReader.parse method and for returning from
    EntityResolver.resolveEntity.

    An InputSource belongs to the application, the XMLReader is not
    allowed to modify InputSource objects passed to it from the
    application, although it may make copies and modify those.Nc             C   s1   | |  _  d  |  _ d  |  _ d  |  _ d  |  _ d  S)N)_InputSource__system_id_InputSource__public_id_InputSource__encoding_InputSource__bytefile_InputSource__charfile)r
   	system_idr   r   r   r      s
    				zInputSource.__init__c             C   s   | |  _  d S)z/Sets the public identifier of this InputSource.N)r>   )r
   Z	public_idr   r   r   setPublicId   s    zInputSource.setPublicIdc             C   s   |  j  S)z2Returns the public identifier of this InputSource.)r>   )r
   r   r   r   r:      s    zInputSource.getPublicIdc             C   s   | |  _  d S)z/Sets the system identifier of this InputSource.N)r=   )r
   rB   r   r   r   setSystemId   s    zInputSource.setSystemIdc             C   s   |  j  S)z2Returns the system identifier of this InputSource.)r=   )r
   r   r   r   r;      s    zInputSource.getSystemIdc             C   s   | |  _  d S)a4  Sets the character encoding of this InputSource.

        The encoding must be a string acceptable for an XML encoding
        declaration (see section 4.3.3 of the XML recommendation).

        The encoding attribute of the InputSource is ignored if the
        InputSource also contains a character stream.N)r?   )r
   encodingr   r   r   setEncoding   s    zInputSource.setEncodingc             C   s   |  j  S)z/Get the character encoding of this InputSource.)r?   )r
   r   r   r   getEncoding   s    zInputSource.getEncodingc             C   s   | |  _  d S)a  Set the byte stream (a Python file-like object which does
        not perform byte-to-character conversion) for this input
        source.

        The SAX parser will ignore this if there is also a character
        stream specified, but it will use a byte stream in preference
        to opening a URI connection itself.

        If the application knows the character encoding of the byte
        stream, it should set it with the setEncoding method.N)r@   )r
   Zbytefiler   r   r   setByteStream   s    zInputSource.setByteStreamc             C   s   |  j  S)zGet the byte stream for this input source.

        The getEncoding method will return the character encoding for
        this byte stream, or None if unknown.)r@   )r
   r   r   r   r.      s    zInputSource.getByteStreamc             C   s   | |  _  d S)a^  Set the character stream for this input source. (The stream
        must be a Python 2.0 Unicode-wrapped file-like that performs
        conversion to Unicode strings.)

        If there is a character stream specified, the SAX parser will
        ignore any byte stream and will not attempt to open a URI
        connection to the system identifier.N)rA   )r
   Zcharfiler   r   r   setCharacterStream  s    zInputSource.setCharacterStreamc             C   s   |  j  S)z/Get the character stream for this input source.)rA   )r
   r   r   r   r-     s    zInputSource.getCharacterStream)r!   r"   r#   r$   r   rC   r:   rD   r;   rF   rG   rH   r.   rI   r-   r   r   r   r   r<      s   

r<   c               @   s   e  Z d  Z d d   Z d d   Z d d   Z d d   Z d	 d
   Z d d   Z d d   Z	 d d   Z
 d d   Z d d   Z d d   Z d d   Z d d   Z d d d  Z d d   Z d  d!   Z d" d#   Z d S)$AttributesImplc             C   s   | |  _  d S)zQNon-NS-aware implementation.

        attrs should be of the form {name : value}.N)_attrs)r
   attrsr   r   r   r     s    zAttributesImpl.__init__c             C   s   t  |  j  S)N)lenrK   )r
   r   r   r   	getLength  s    zAttributesImpl.getLengthc             C   s   d S)NZCDATAr   )r
   r   r   r   r   getType!  s    zAttributesImpl.getTypec             C   s   |  j  | S)N)rK   )r
   r   r   r   r   getValue$  s    zAttributesImpl.getValuec             C   s   |  j  | S)N)rK   )r
   r   r   r   r   getValueByQName'  s    zAttributesImpl.getValueByQNamec             C   s   | |  j  k r t |   | S)N)rK   KeyError)r
   r   r   r   r   getNameByQName*  s    zAttributesImpl.getNameByQNamec             C   s   | |  j  k r t |   | S)N)rK   rR   )r
   r   r   r   r   getQNameByName/  s    zAttributesImpl.getQNameByNamec             C   s   t  |  j j    S)N)listrK   keys)r
   r   r   r   getNames4  s    zAttributesImpl.getNamesc             C   s   t  |  j j    S)N)rU   rK   rV   )r
   r   r   r   	getQNames7  s    zAttributesImpl.getQNamesc             C   s   t  |  j  S)N)rM   rK   )r
   r   r   r   __len__:  s    zAttributesImpl.__len__c             C   s   |  j  | S)N)rK   )r
   r   r   r   r   __getitem__=  s    zAttributesImpl.__getitem__c             C   s   t  |  j j    S)N)rU   rK   rV   )r
   r   r   r   rV   @  s    zAttributesImpl.keysc             C   s   | |  j  k S)N)rK   )r
   r   r   r   r   __contains__C  s    zAttributesImpl.__contains__Nc             C   s   |  j  j | |  S)N)rK   get)r
   r   Zalternativer   r   r   r\   F  s    zAttributesImpl.getc             C   s   |  j  |  j  S)N)	__class__rK   )r
   r   r   r   copyI  s    zAttributesImpl.copyc             C   s   t  |  j j    S)N)rU   rK   items)r
   r   r   r   r_   L  s    zAttributesImpl.itemsc             C   s   t  |  j j    S)N)rU   rK   values)r
   r   r   r   r`   O  s    zAttributesImpl.values)r!   r"   r#   r   rN   rO   rP   rQ   rS   rT   rW   rX   rY   rZ   rV   r[   r\   r^   r_   r`   r   r   r   r   rJ     s"   rJ   c               @   sX   e  Z d  Z d d   Z d d   Z d d   Z d d   Z d	 d
   Z d d   Z d S)AttributesNSImplc             C   s   | |  _  | |  _ d S)zNS-aware implementation.

        attrs should be of the form {(ns_uri, lname): value, ...}.
        qnames of the form {(ns_uri, lname): qname, ...}.N)rK   _qnames)r
   rL   Zqnamesr   r   r   r   V  s    	zAttributesNSImpl.__init__c             C   sG   x4 |  j  j   D]# \ } } | | k r |  j | Sq Wt |   d  S)N)rb   r_   rK   rR   )r
   r   nsnameqnamer   r   r   rQ   ^  s    z AttributesNSImpl.getValueByQNamec             C   s@   x- |  j  j   D] \ } } | | k r | Sq Wt |   d  S)N)rb   r_   rR   )r
   r   rc   rd   r   r   r   rS   e  s    zAttributesNSImpl.getNameByQNamec             C   s   |  j  | S)N)rb   )r
   r   r   r   r   rT   l  s    zAttributesNSImpl.getQNameByNamec             C   s   t  |  j j    S)N)rU   rb   r`   )r
   r   r   r   rX   o  s    zAttributesNSImpl.getQNamesc             C   s   |  j  |  j |  j  S)N)r]   rK   rb   )r
   r   r   r   r^   r  s    zAttributesNSImpl.copyN)	r!   r"   r#   r   rQ   rS   rT   rX   r^   r   r   r   r   ra   T  s   ra   c               C   s   t    t   t   d  S)N)r   r%   r6   r   r   r   r   _testv  s    re   __main__N)r$   r+   r   _exceptionsr   r   r   r%   r6   r<   rJ   ra   re   r!   r   r   r   r   <module>   s   PJY>"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     # This directory is a Python package.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          #
# XML-RPC CLIENT LIBRARY
# $Id$
#
# an XML-RPC client interface for Python.
#
# the marshalling and response parser code can also be used to
# implement XML-RPC servers.
#
# Notes:
# this version is designed to work with Python 2.1 or newer.
#
# History:
# 1999-01-14 fl  Created
# 1999-01-15 fl  Changed dateTime to use localtime
# 1999-01-16 fl  Added Binary/base64 element, default to RPC2 service
# 1999-01-19 fl  Fixed array data element (from Skip Montanaro)
# 1999-01-21 fl  Fixed dateTime constructor, etc.
# 1999-02-02 fl  Added fault handling, handle empty sequences, etc.
# 1999-02-10 fl  Fixed problem with empty responses (from Skip Montanaro)
# 1999-06-20 fl  Speed improvements, pluggable parsers/transports (0.9.8)
# 2000-11-28 fl  Changed boolean to check the truth value of its argument
# 2001-02-24 fl  Added encoding/Unicode/SafeTransport patches
# 2001-02-26 fl  Added compare support to wrappers (0.9.9/1.0b1)
# 2001-03-28 fl  Make sure response tuple is a singleton
# 2001-03-29 fl  Don't require empty params element (from Nicholas Riley)
# 2001-06-10 fl  Folded in _xmlrpclib accelerator support (1.0b2)
# 2001-08-20 fl  Base xmlrpclib.Error on built-in Exception (from Paul Prescod)
# 2001-09-03 fl  Allow Transport subclass to override getparser
# 2001-09-10 fl  Lazy import of urllib, cgi, xmllib (20x import speedup)
# 2001-10-01 fl  Remove containers from memo cache when done with them
# 2001-10-01 fl  Use faster escape method (80% dumps speedup)
# 2001-10-02 fl  More dumps microtuning
# 2001-10-04 fl  Make sure import expat gets a parser (from Guido van Rossum)
# 2001-10-10 sm  Allow long ints to be passed as ints if they don't overflow
# 2001-10-17 sm  Test for int and long overflow (allows use on 64-bit systems)
# 2001-11-12 fl  Use repr() to marshal doubles (from Paul Felix)
# 2002-03-17 fl  Avoid buffered read when possible (from James Rucker)
# 2002-04-07 fl  Added pythondoc comments
# 2002-04-16 fl  Added __str__ methods to datetime/binary wrappers
# 2002-05-15 fl  Added error constants (from Andrew Kuchling)
# 2002-06-27 fl  Merged with Python CVS version
# 2002-10-22 fl  Added basic authentication (based on code from Phillip Eby)
# 2003-01-22 sm  Add support for the bool type
# 2003-02-27 gvr Remove apply calls
# 2003-04-24 sm  Use cStringIO if available
# 2003-04-25 ak  Add support for nil
# 2003-06-15 gn  Add support for time.struct_time
# 2003-07-12 gp  Correct marshalling of Faults
# 2003-10-31 mvl Add multicall support
# 2004-08-20 mvl Bump minimum supported Python version to 2.1
# 2014-12-02 ch/doko  Add workaround for gzip bomb vulnerability
#
# Copyright (c) 1999-2002 by Secret Labs AB.
# Copyright (c) 1999-2002 by Fredrik Lundh.
#
# info@pythonware.com
# http://www.pythonware.com
#
# --------------------------------------------------------------------
# The XML-RPC client interface is
#
# Copyright (c) 1999-2002 by Secret Labs AB
# Copyright (c) 1999-2002 by Fredrik Lundh
#
# By obtaining, using, and/or copying this software and/or its
# associated documentation, you agree that you have read, understood,
# and will comply with the following terms and conditions:
#
# Permission to use, copy, modify, and distribute this software and
# its associated documentation for any purpose and without fee is
# hereby granted, provided that the above copyright notice appears in
# all copies, and that both that copyright notice and this permission
# notice appear in supporting documentation, and that the name of
# Secret Labs AB or the author not be used in advertising or publicity
# pertaining to distribution of the software without specific, written
# prior permission.
#
# SECRET LABS AB AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD
# TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANT-
# ABILITY AND FITNESS.  IN NO EVENT SHALL SECRET LABS AB OR THE AUTHOR
# BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY
# DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
# OF THIS SOFTWARE.
# --------------------------------------------------------------------

"""
An XML-RPC client interface for Python.

The marshalling and response parser code can also be used to
implement XML-RPC servers.

Exported exceptions:

  Error          Base class for client errors
  ProtocolError  Indicates an HTTP protocol error
  ResponseError  Indicates a broken response package
  Fault          Indicates an XML-RPC fault package

Exported classes:

  ServerProxy    Represents a logical connection to an XML-RPC server

  MultiCall      Executor of boxcared xmlrpc requests
  DateTime       dateTime wrapper for an ISO 8601 string or time tuple or
                 localtime integer value to generate a "dateTime.iso8601"
                 XML-RPC value
  Binary         binary data wrapper

  Marshaller     Generate an XML-RPC params chunk from a Python data structure
  Unmarshaller   Unmarshal an XML-RPC response from incoming XML event message
  Transport      Handles an HTTP transaction to an XML-RPC server
  SafeTransport  Handles an HTTPS transaction to an XML-RPC server

Exported constants:

  (none)

Exported functions:

  getparser      Create instance of the fastest available parser & attach
                 to an unmarshalling object
  dumps          Convert an argument tuple or a Fault instance to an XML-RPC
                 request (or response, if the methodresponse option is used).
  loads          Convert an XML-RPC packet to unmarshalled data plus a method
                 name (None if not present).
"""

import base64
import sys
import time
from datetime import datetime
import http.client
import urllib.parse
from xml.parsers import expat
import errno
from io import BytesIO
try:
    import gzip
except ImportError:
    gzip = None #python can be built without zlib/gzip support

# --------------------------------------------------------------------
# Internal stuff

def escape(s):
    s = s.replace("&", "&amp;")
    s = s.replace("<", "&lt;")
    return s.replace(">", "&gt;",)

# used in User-Agent header sent
__version__ = sys.version[:3]

# xmlrpc integer limits
MAXINT =  2**31-1
MININT = -2**31

# --------------------------------------------------------------------
# Error constants (from Dan Libby's specification at
# http://xmlrpc-epi.sourceforge.net/specs/rfc.fault_codes.php)

# Ranges of errors
PARSE_ERROR       = -32700
SERVER_ERROR      = -32600
APPLICATION_ERROR = -32500
SYSTEM_ERROR      = -32400
TRANSPORT_ERROR   = -32300

# Specific errors
NOT_WELLFORMED_ERROR  = -32700
UNSUPPORTED_ENCODING  = -32701
INVALID_ENCODING_CHAR = -32702
INVALID_XMLRPC        = -32600
METHOD_NOT_FOUND      = -32601
INVALID_METHOD_PARAMS = -32602
INTERNAL_ERROR        = -32603

# --------------------------------------------------------------------
# Exceptions

##
# Base class for all kinds of client-side errors.

class Error(Exception):
    """Base class for client errors."""
    def __str__(self):
        return repr(self)

##
# Indicates an HTTP-level protocol error.  This is raised by the HTTP
# transport layer, if the server returns an error code other than 200
# (OK).
#
# @param url The target URL.
# @param errcode The HTTP error code.
# @param errmsg The HTTP error message.
# @param headers The HTTP header dictionary.

class ProtocolError(Error):
    """Indicates an HTTP protocol error."""
    def __init__(self, url, errcode, errmsg, headers):
        Error.__init__(self)
        self.url = url
        self.errcode = errcode
        self.errmsg = errmsg
        self.headers = headers
    def __repr__(self):
        return (
            "<%s for %s: %s %s>" %
            (self.__class__.__name__, self.url, self.errcode, self.errmsg)
            )

##
# Indicates a broken XML-RPC response package.  This exception is
# raised by the unmarshalling layer, if the XML-RPC response is
# malformed.

class ResponseError(Error):
    """Indicates a broken response package."""
    pass

##
# Indicates an XML-RPC fault response package.  This exception is
# raised by the unmarshalling layer, if the XML-RPC response contains
# a fault string.  This exception can also be used as a class, to
# generate a fault XML-RPC message.
#
# @param faultCode The XML-RPC fault code.
# @param faultString The XML-RPC fault string.

class Fault(Error):
    """Indicates an XML-RPC fault package."""
    def __init__(self, faultCode, faultString, **extra):
        Error.__init__(self)
        self.faultCode = faultCode
        self.faultString = faultString
    def __repr__(self):
        return "<%s %s: %r>" % (self.__class__.__name__,
                                self.faultCode, self.faultString)

# --------------------------------------------------------------------
# Special values

##
# Backwards compatibility

boolean = Boolean = bool

##
# Wrapper for XML-RPC DateTime values.  This converts a time value to
# the format used by XML-RPC.
# <p>
# The value can be given as a datetime object, as a string in the
# format "yyyymmddThh:mm:ss", as a 9-item time tuple (as returned by
# time.localtime()), or an integer value (as returned by time.time()).
# The wrapper uses time.localtime() to convert an integer to a time
# tuple.
#
# @param value The time, given as a datetime object, an ISO 8601 string,
#              a time tuple, or an integer time value.


# Issue #13305: different format codes across platforms
_day0 = datetime(1, 1, 1)
if _day0.strftime('%Y') == '0001':      # Mac OS X
    def _iso8601_format(value):
        return value.strftime("%Y%m%dT%H:%M:%S")
elif _day0.strftime('%4Y') == '0001':   # Linux
    def _iso8601_format(value):
        return value.strftime("%4Y%m%dT%H:%M:%S")
else:
    def _iso8601_format(value):
        return value.strftime("%Y%m%dT%H:%M:%S").zfill(17)
del _day0


def _strftime(value):
    if isinstance(value, datetime):
        return _iso8601_format(value)

    if not isinstance(value, (tuple, time.struct_time)):
        if value == 0:
            value = time.time()
        value = time.localtime(value)

    return "%04d%02d%02dT%02d:%02d:%02d" % value[:6]

class DateTime:
    """DateTime wrapper for an ISO 8601 string or time tuple or
    localtime integer value to generate 'dateTime.iso8601' XML-RPC
    value.
    """

    def __init__(self, value=0):
        if isinstance(value, str):
            self.value = value
        else:
            self.value = _strftime(value)

    def make_comparable(self, other):
        if isinstance(other, DateTime):
            s = self.value
            o = other.value
        elif isinstance(other, datetime):
            s = self.value
            o = _iso8601_format(other)
        elif isinstance(other, str):
            s = self.value
            o = other
        elif hasattr(other, "timetuple"):
            s = self.timetuple()
            o = other.timetuple()
        else:
            otype = (hasattr(other, "__class__")
                     and other.__class__.__name__
                     or type(other))
            raise TypeError("Can't compare %s and %s" %
                            (self.__class__.__name__, otype))
        return s, o

    def __lt__(self, other):
        s, o = self.make_comparable(other)
        return s < o

    def __le__(self, other):
        s, o = self.make_comparable(other)
        return s <= o

    def __gt__(self, other):
        s, o = self.make_comparable(other)
        return s > o

    def __ge__(self, other):
        s, o = self.make_comparable(other)
        return s >= o

    def __eq__(self, other):
        s, o = self.make_comparable(other)
        return s == o

    def timetuple(self):
        return time.strptime(self.value, "%Y%m%dT%H:%M:%S")

    ##
    # Get date/time value.
    #
    # @return Date/time value, as an ISO 8601 string.

    def __str__(self):
        return self.value

    def __repr__(self):
        return "<%s %r at %#x>" % (self.__class__.__name__, self.value, id(self))

    def decode(self, data):
        self.value = str(data).strip()

    def encode(self, out):
        out.write("<value><dateTime.iso8601>")
        out.write(self.value)
        out.write("</dateTime.iso8601></value>\n")

def _datetime(data):
    # decode xml element contents into a DateTime structure.
    value = DateTime()
    value.decode(data)
    return value

def _datetime_type(data):
    return datetime.strptime(data, "%Y%m%dT%H:%M:%S")

##
# Wrapper for binary data.  This can be used to transport any kind
# of binary data over XML-RPC, using BASE64 encoding.
#
# @param data An 8-bit string containing arbitrary data.

class Binary:
    """Wrapper for binary data."""

    def __init__(self, data=None):
        if data is None:
            data = b""
        else:
            if not isinstance(data, (bytes, bytearray)):
                raise TypeError("expected bytes or bytearray, not %s" %
                                data.__class__.__name__)
            data = bytes(data)  # Make a copy of the bytes!
        self.data = data

    ##
    # Get buffer contents.
    #
    # @return Buffer contents, as an 8-bit string.

    def __str__(self):
        return str(self.data, "latin-1")  # XXX encoding?!

    def __eq__(self, other):
        if isinstance(other, Binary):
            other = other.data
        return self.data == other

    def decode(self, data):
        self.data = base64.decodebytes(data)

    def encode(self, out):
        out.write("<value><base64>\n")
        encoded = base64.encodebytes(self.data)
        out.write(encoded.decode('ascii'))
        out.write("</base64></value>\n")

def _binary(data):
    # decode xml element contents into a Binary structure
    value = Binary()
    value.decode(data)
    return value

WRAPPERS = (DateTime, Binary)

# --------------------------------------------------------------------
# XML parsers

class ExpatParser:
    # fast expat parser for Python 2.0 and later.
    def __init__(self, target):
        self._parser = parser = expat.ParserCreate(None, None)
        self._target = target
        parser.StartElementHandler = target.start
        parser.EndElementHandler = target.end
        parser.CharacterDataHandler = target.data
        encoding = None
        target.xml(encoding, None)

    def feed(self, data):
        self._parser.Parse(data, 0)

    def close(self):
        try:
            parser = self._parser
        except AttributeError:
            pass
        else:
            del self._target, self._parser # get rid of circular references
            parser.Parse(b"", True) # end of data

# --------------------------------------------------------------------
# XML-RPC marshalling and unmarshalling code

##
# XML-RPC marshaller.
#
# @param encoding Default encoding for 8-bit strings.  The default
#     value is None (interpreted as UTF-8).
# @see dumps

class Marshaller:
    """Generate an XML-RPC params chunk from a Python data structure.

    Create a Marshaller instance for each set of parameters, and use
    the "dumps" method to convert your data (represented as a tuple)
    to an XML-RPC params chunk.  To write a fault response, pass a
    Fault instance instead.  You may prefer to use the "dumps" module
    function for this purpose.
    """

    # by the way, if you don't understand what's going on in here,
    # that's perfectly ok.

    def __init__(self, encoding=None, allow_none=False):
        self.memo = {}
        self.data = None
        self.encoding = encoding
        self.allow_none = allow_none

    dispatch = {}

    def dumps(self, values):
        out = []
        write = out.append
        dump = self.__dump
        if isinstance(values, Fault):
            # fault instance
            write("<fault>\n")
            dump({'faultCode': values.faultCode,
                  'faultString': values.faultString},
                 write)
            write("</fault>\n")
        else:
            # parameter block
            # FIXME: the xml-rpc specification allows us to leave out
            # the entire <params> block if there are no parameters.
            # however, changing this may break older code (including
            # old versions of xmlrpclib.py), so this is better left as
            # is for now.  See @XMLRPC3 for more information. /F
            write("<params>\n")
            for v in values:
                write("<param>\n")
                dump(v, write)
                write("</param>\n")
            write("</params>\n")
        result = "".join(out)
        return result

    def __dump(self, value, write):
        try:
            f = self.dispatch[type(value)]
        except KeyError:
            # check if this object can be marshalled as a structure
            if not hasattr(value, '__dict__'):
                raise TypeError("cannot marshal %s objects" % type(value))
            # check if this class is a sub-class of a basic type,
            # because we don't know how to marshal these types
            # (e.g. a string sub-class)
            for type_ in type(value).__mro__:
                if type_ in self.dispatch.keys():
                    raise TypeError("cannot marshal %s objects" % type(value))
            # XXX(twouters): using "_arbitrary_instance" as key as a quick-fix
            # for the p3yk merge, this should probably be fixed more neatly.
            f = self.dispatch["_arbitrary_instance"]
        f(self, value, write)

    def dump_nil (self, value, write):
        if not self.allow_none:
            raise TypeError("cannot marshal None unless allow_none is enabled")
        write("<value><nil/></value>")
    dispatch[type(None)] = dump_nil

    def dump_bool(self, value, write):
        write("<value><boolean>")
        write(value and "1" or "0")
        write("</boolean></value>\n")
    dispatch[bool] = dump_bool

    def dump_long(self, value, write):
        if value > MAXINT or value < MININT:
            raise OverflowError("int exceeds XML-RPC limits")
        write("<value><int>")
        write(str(int(value)))
        write("</int></value>\n")
    dispatch[int] = dump_long

    # backward compatible
    dump_int = dump_long

    def dump_double(self, value, write):
        write("<value><double>")
        write(repr(value))
        write("</double></value>\n")
    dispatch[float] = dump_double

    def dump_unicode(self, value, write, escape=escape):
        write("<value><string>")
        write(escape(value))
        write("</string></value>\n")
    dispatch[str] = dump_unicode

    def dump_bytes(self, value, write):
        write("<value><base64>\n")
        encoded = base64.encodebytes(value)
        write(encoded.decode('ascii'))
        write("</base64></value>\n")
    dispatch[bytes] = dump_bytes
    dispatch[bytearray] = dump_bytes

    def dump_array(self, value, write):
        i = id(value)
        if i in self.memo:
            raise TypeError("cannot marshal recursive sequences")
        self.memo[i] = None
        dump = self.__dump
        write("<value><array><data>\n")
        for v in value:
            dump(v, write)
        write("</data></array></value>\n")
        del self.memo[i]
    dispatch[tuple] = dump_array
    dispatch[list] = dump_array

    def dump_struct(self, value, write, escape=escape):
        i = id(value)
        if i in self.memo:
            raise TypeError("cannot marshal recursive dictionaries")
        self.memo[i] = None
        dump = self.__dump
        write("<value><struct>\n")
        for k, v in value.items():
            write("<member>\n")
            if not isinstance(k, str):
                raise TypeError("dictionary key must be string")
            write("<name>%s</name>\n" % escape(k))
            dump(v, write)
            write("</member>\n")
        write("</struct></value>\n")
        del self.memo[i]
    dispatch[dict] = dump_struct

    def dump_datetime(self, value, write):
        write("<value><dateTime.iso8601>")
        write(_strftime(value))
        write("</dateTime.iso8601></value>\n")
    dispatch[datetime] = dump_datetime

    def dump_instance(self, value, write):
        # check for special wrappers
        if value.__class__ in WRAPPERS:
            self.write = write
            value.encode(self)
            del self.write
        else:
            # store instance attributes as a struct (really?)
            self.dump_struct(value.__dict__, write)
    dispatch[DateTime] = dump_instance
    dispatch[Binary] = dump_instance
    # XXX(twouters): using "_arbitrary_instance" as key as a quick-fix
    # for the p3yk merge, this should probably be fixed more neatly.
    dispatch["_arbitrary_instance"] = dump_instance

##
# XML-RPC unmarshaller.
#
# @see loads

class Unmarshaller:
    """Unmarshal an XML-RPC response, based on incoming XML event
    messages (start, data, end).  Call close() to get the resulting
    data structure.

    Note that this reader is fairly tolerant, and gladly accepts bogus
    XML-RPC data without complaining (but not bogus XML).
    """

    # and again, if you don't understand what's going on in here,
    # that's perfectly ok.

    def __init__(self, use_datetime=False, use_builtin_types=False):
        self._type = None
        self._stack = []
        self._marks = []
        self._data = []
        self._value = False
        self._methodname = None
        self._encoding = "utf-8"
        self.append = self._stack.append
        self._use_datetime = use_builtin_types or use_datetime
        self._use_bytes = use_builtin_types

    def close(self):
        # return response tuple and target method
        if self._type is None or self._marks:
            raise ResponseError()
        if self._type == "fault":
            raise Fault(**self._stack[0])
        return tuple(self._stack)

    def getmethodname(self):
        return self._methodname

    #
    # event handlers

    def xml(self, encoding, standalone):
        self._encoding = encoding
        # FIXME: assert standalone == 1 ???

    def start(self, tag, attrs):
        # prepare to handle this element
        if tag == "array" or tag == "struct":
            self._marks.append(len(self._stack))
        self._data = []
        if self._value and tag not in self.dispatch:
            raise ResponseError("unknown tag %r" % tag)
        self._value = (tag == "value")

    def data(self, text):
        self._data.append(text)

    def end(self, tag):
        # call the appropriate end tag handler
        try:
            f = self.dispatch[tag]
        except KeyError:
            pass # unknown tag ?
        else:
            return f(self, "".join(self._data))

    #
    # accelerator support

    def end_dispatch(self, tag, data):
        # dispatch data
        try:
            f = self.dispatch[tag]
        except KeyError:
            pass # unknown tag ?
        else:
            return f(self, data)

    #
    # element decoders

    dispatch = {}

    def end_nil (self, data):
        self.append(None)
        self._value = 0
    dispatch["nil"] = end_nil

    def end_boolean(self, data):
        if data == "0":
            self.append(False)
        elif data == "1":
            self.append(True)
        else:
            raise TypeError("bad boolean value")
        self._value = 0
    dispatch["boolean"] = end_boolean

    def end_int(self, data):
        self.append(int(data))
        self._value = 0
    dispatch["i4"] = end_int
    dispatch["i8"] = end_int
    dispatch["int"] = end_int

    def end_double(self, data):
        self.append(float(data))
        self._value = 0
    dispatch["double"] = end_double

    def end_string(self, data):
        if self._encoding:
            data = data.decode(self._encoding)
        self.append(data)
        self._value = 0
    dispatch["string"] = end_string
    dispatch["name"] = end_string # struct keys are always strings

    def end_array(self, data):
        mark = self._marks.pop()
        # map arrays to Python lists
        self._stack[mark:] = [self._stack[mark:]]
        self._value = 0
    dispatch["array"] = end_array

    def end_struct(self, data):
        mark = self._marks.pop()
        # map structs to Python dictionaries
        dict = {}
        items = self._stack[mark:]
        for i in range(0, len(items), 2):
            dict[items[i]] = items[i+1]
        self._stack[mark:] = [dict]
        self._value = 0
    dispatch["struct"] = end_struct

    def end_base64(self, data):
        value = Binary()
        value.decode(data.encode("ascii"))
        if self._use_bytes:
            value = value.data
        self.append(value)
        self._value = 0
    dispatch["base64"] = end_base64

    def end_dateTime(self, data):
        value = DateTime()
        value.decode(data)
        if self._use_datetime:
            value = _datetime_type(data)
        self.append(value)
    dispatch["dateTime.iso8601"] = end_dateTime

    def end_value(self, data):
        # if we stumble upon a value element with no internal
        # elements, treat it as a string element
        if self._value:
            self.end_string(data)
    dispatch["value"] = end_value

    def end_params(self, data):
        self._type = "params"
    dispatch["params"] = end_params

    def end_fault(self, data):
        self._type = "fault"
    dispatch["fault"] = end_fault

    def end_methodName(self, data):
        if self._encoding:
            data = data.decode(self._encoding)
        self._methodname = data
        self._type = "methodName" # no params
    dispatch["methodName"] = end_methodName

## Multicall support
#

class _MultiCallMethod:
    # some lesser magic to store calls made to a MultiCall object
    # for batch execution
    def __init__(self, call_list, name):
        self.__call_list = call_list
        self.__name = name
    def __getattr__(self, name):
        return _MultiCallMethod(self.__call_list, "%s.%s" % (self.__name, name))
    def __call__(self, *args):
        self.__call_list.append((self.__name, args))

class MultiCallIterator:
    """Iterates over the results of a multicall. Exceptions are
    raised in response to xmlrpc faults."""

    def __init__(self, results):
        self.results = results

    def __getitem__(self, i):
        item = self.results[i]
        if type(item) == type({}):
            raise Fault(item['faultCode'], item['faultString'])
        elif type(item) == type([]):
            return item[0]
        else:
            raise ValueError("unexpected type in multicall result")

class MultiCall:
    """server -> an object used to boxcar method calls

    server should be a ServerProxy object.

    Methods can be added to the MultiCall using normal
    method call syntax e.g.:

    multicall = MultiCall(server_proxy)
    multicall.add(2,3)
    multicall.get_address("Guido")

    To execute the multicall, call the MultiCall object e.g.:

    add_result, address = multicall()
    """

    def __init__(self, server):
        self.__server = server
        self.__call_list = []

    def __repr__(self):
        return "<%s at %#x>" % (self.__class__.__name__, id(self))

    __str__ = __repr__

    def __getattr__(self, name):
        return _MultiCallMethod(self.__call_list, name)

    def __call__(self):
        marshalled_list = []
        for name, args in self.__call_list:
            marshalled_list.append({'methodName' : name, 'params' : args})

        return MultiCallIterator(self.__server.system.multicall(marshalled_list))

# --------------------------------------------------------------------
# convenience functions

FastMarshaller = FastParser = FastUnmarshaller = None

##
# Create a parser object, and connect it to an unmarshalling instance.
# This function picks the fastest available XML parser.
#
# return A (parser, unmarshaller) tuple.

def getparser(use_datetime=False, use_builtin_types=False):
    """getparser() -> parser, unmarshaller

    Create an instance of the fastest available parser, and attach it
    to an unmarshalling object.  Return both objects.
    """
    if FastParser and FastUnmarshaller:
        if use_builtin_types:
            mkdatetime = _datetime_type
            mkbytes = base64.decodebytes
        elif use_datetime:
            mkdatetime = _datetime_type
            mkbytes = _binary
        else:
            mkdatetime = _datetime
            mkbytes = _binary
        target = FastUnmarshaller(True, False, mkbytes, mkdatetime, Fault)
        parser = FastParser(target)
    else:
        target = Unmarshaller(use_datetime=use_datetime, use_builtin_types=use_builtin_types)
        if FastParser:
            parser = FastParser(target)
        else:
            parser = ExpatParser(target)
    return parser, target

##
# Convert a Python tuple or a Fault instance to an XML-RPC packet.
#
# @def dumps(params, **options)
# @param params A tuple or Fault instance.
# @keyparam methodname If given, create a methodCall request for
#     this method name.
# @keyparam methodresponse If given, create a methodResponse packet.
#     If used with a tuple, the tuple must be a singleton (that is,
#     it must contain exactly one element).
# @keyparam encoding The packet encoding.
# @return A string containing marshalled data.

def dumps(params, methodname=None, methodresponse=None, encoding=None,
          allow_none=False):
    """data [,options] -> marshalled data

    Convert an argument tuple or a Fault instance to an XML-RPC
    request (or response, if the methodresponse option is used).

    In addition to the data object, the following options can be given
    as keyword arguments:

        methodname: the method name for a methodCall packet

        methodresponse: true to create a methodResponse packet.
        If this option is used with a tuple, the tuple must be
        a singleton (i.e. it can contain only one element).

        encoding: the packet encoding (default is UTF-8)

    All byte strings in the data structure are assumed to use the
    packet encoding.  Unicode strings are automatically converted,
    where necessary.
    """

    assert isinstance(params, (tuple, Fault)), "argument must be tuple or Fault instance"
    if isinstance(params, Fault):
        methodresponse = 1
    elif methodresponse and isinstance(params, tuple):
        assert len(params) == 1, "response tuple must be a singleton"

    if not encoding:
        encoding = "utf-8"

    if FastMarshaller:
        m = FastMarshaller(encoding)
    else:
        m = Marshaller(encoding, allow_none)

    data = m.dumps(params)

    if encoding != "utf-8":
        xmlheader = "<?xml version='1.0' encoding='%s'?>\n" % str(encoding)
    else:
        xmlheader = "<?xml version='1.0'?>\n" # utf-8 is default

    # standard XML-RPC wrappings
    if methodname:
        # a method call
        data = (
            xmlheader,
            "<methodCall>\n"
            "<methodName>", methodname, "</methodName>\n",
            data,
            "</methodCall>\n"
            )
    elif methodresponse:
        # a method response, or a fault structure
        data = (
            xmlheader,
            "<methodResponse>\n",
            data,
            "</methodResponse>\n"
            )
    else:
        return data # return as is
    return "".join(data)

##
# Convert an XML-RPC packet to a Python object.  If the XML-RPC packet
# represents a fault condition, this function raises a Fault exception.
#
# @param data An XML-RPC packet, given as an 8-bit string.
# @return A tuple containing the unpacked data, and the method name
#     (None if not present).
# @see Fault

def loads(data, use_datetime=False, use_builtin_types=False):
    """data -> unmarshalled data, method name

    Convert an XML-RPC packet to unmarshalled data plus a method
    name (None if not present).

    If the XML-RPC packet represents a fault condition, this function
    raises a Fault exception.
    """
    p, u = getparser(use_datetime=use_datetime, use_builtin_types=use_builtin_types)
    p.feed(data)
    p.close()
    return u.close(), u.getmethodname()

##
# Encode a string using the gzip content encoding such as specified by the
# Content-Encoding: gzip
# in the HTTP header, as described in RFC 1952
#
# @param data the unencoded data
# @return the encoded data

def gzip_encode(data):
    """data -> gzip encoded data

    Encode data using the gzip content encoding as described in RFC 1952
    """
    if not gzip:
        raise NotImplementedError
    f = BytesIO()
    with gzip.GzipFile(mode="wb", fileobj=f, compresslevel=1) as gzf:
        gzf.write(data)
    return f.getvalue()

##
# Decode a string using the gzip content encoding such as specified by the
# Content-Encoding: gzip
# in the HTTP header, as described in RFC 1952
#
# @param data The encoded data
# @keyparam max_decode Maximum bytes to decode (20MB default), use negative
#    values for unlimited decoding
# @return the unencoded data
# @raises ValueError if data is not correctly coded.
# @raises ValueError if max gzipped payload length exceeded

def gzip_decode(data, max_decode=20971520):
    """gzip encoded data -> unencoded data

    Decode data using the gzip content encoding as described in RFC 1952
    """
    if not gzip:
        raise NotImplementedError
    with gzip.GzipFile(mode="rb", fileobj=BytesIO(data)) as gzf:
        try:
            if max_decode < 0: # no limit
                decoded = gzf.read()
            else:
                decoded = gzf.read(max_decode + 1)
        except OSError:
            raise ValueError("invalid data")
    if max_decode >= 0 and len(decoded) > max_decode:
        raise ValueError("max gzipped payload length exceeded")
    return decoded

##
# Return a decoded file-like object for the gzip encoding
# as described in RFC 1952.
#
# @param response A stream supporting a read() method
# @return a file-like object that the decoded data can be read() from

class GzipDecodedResponse(gzip.GzipFile if gzip else object):
    """a file-like object to decode a response encoded with the gzip
    method, as described in RFC 1952.
    """
    def __init__(self, response):
        #response doesn't support tell() and read(), required by
        #GzipFile
        if not gzip:
            raise NotImplementedError
        self.io = BytesIO(response.read())
        gzip.GzipFile.__init__(self, mode="rb", fileobj=self.io)

    def close(self):
        try:
            gzip.GzipFile.close(self)
        finally:
            self.io.close()


# --------------------------------------------------------------------
# request dispatcher

class _Method:
    # some magic to bind an XML-RPC method to an RPC server.
    # supports "nested" methods (e.g. examples.getStateName)
    def __init__(self, send, name):
        self.__send = send
        self.__name = name
    def __getattr__(self, name):
        return _Method(self.__send, "%s.%s" % (self.__name, name))
    def __call__(self, *args):
        return self.__send(self.__name, args)

##
# Standard transport class for XML-RPC over HTTP.
# <p>
# You can create custom transports by subclassing this method, and
# overriding selected methods.

class Transport:
    """Handles an HTTP transaction to an XML-RPC server."""

    # client identifier (may be overridden)
    user_agent = "Python-xmlrpc/%s" % __version__

    #if true, we'll request gzip encoding
    accept_gzip_encoding = True

    # if positive, encode request using gzip if it exceeds this threshold
    # note that many server will get confused, so only use it if you know
    # that they can decode such a request
    encode_threshold = None #None = don't encode

    def __init__(self, use_datetime=False, use_builtin_types=False):
        self._use_datetime = use_datetime
        self._use_builtin_types = use_builtin_types
        self._connection = (None, None)
        self._extra_headers = []

    ##
    # Send a complete request, and parse the response.
    # Retry request if a cached connection has disconnected.
    #
    # @param host Target host.
    # @param handler Target PRC handler.
    # @param request_body XML-RPC request body.
    # @param verbose Debugging flag.
    # @return Parsed response.

    def request(self, host, handler, request_body, verbose=False):
        #retry request once if cached connection has gone cold
        for i in (0, 1):
            try:
                return self.single_request(host, handler, request_body, verbose)
            except http.client.RemoteDisconnected:
                if i:
                    raise
            except OSError as e:
                if i or e.errno not in (errno.ECONNRESET, errno.ECONNABORTED,
                                        errno.EPIPE):
                    raise

    def single_request(self, host, handler, request_body, verbose=False):
        # issue XML-RPC request
        try:
            http_conn = self.send_request(host, handler, request_body, verbose)
            resp = http_conn.getresponse()
            if resp.status == 200:
                self.verbose = verbose
                return self.parse_response(resp)

        except Fault:
            raise
        except Exception:
            #All unexpected errors leave connection in
            # a strange state, so we clear it.
            self.close()
            raise

        #We got an error response.
        #Discard any response data and raise exception
        if resp.getheader("content-length", ""):
            resp.read()
        raise ProtocolError(
            host + handler,
            resp.status, resp.reason,
            dict(resp.getheaders())
            )


    ##
    # Create parser.
    #
    # @return A 2-tuple containing a parser and an unmarshaller.

    def getparser(self):
        # get parser and unmarshaller
        return getparser(use_datetime=self._use_datetime,
                         use_builtin_types=self._use_builtin_types)

    ##
    # Get authorization info from host parameter
    # Host may be a string, or a (host, x509-dict) tuple; if a string,
    # it is checked for a "user:pw@host" format, and a "Basic
    # Authentication" header is added if appropriate.
    #
    # @param host Host descriptor (URL or (URL, x509 info) tuple).
    # @return A 3-tuple containing (actual host, extra headers,
    #     x509 info).  The header and x509 fields may be None.

    def get_host_info(self, host):

        x509 = {}
        if isinstance(host, tuple):
            host, x509 = host

        auth, host = urllib.parse.splituser(host)

        if auth:
            auth = urllib.parse.unquote_to_bytes(auth)
            auth = base64.encodebytes(auth).decode("utf-8")
            auth = "".join(auth.split()) # get rid of whitespace
            extra_headers = [
                ("Authorization", "Basic " + auth)
                ]
        else:
            extra_headers = []

        return host, extra_headers, x509

    ##
    # Connect to server.
    #
    # @param host Target host.
    # @return An HTTPConnection object

    def make_connection(self, host):
        #return an existing connection if possible.  This allows
        #HTTP/1.1 keep-alive.
        if self._connection and host == self._connection[0]:
            return self._connection[1]
        # create a HTTP connection object from a host descriptor
        chost, self._extra_headers, x509 = self.get_host_info(host)
        self._connection = host, http.client.HTTPConnection(chost)
        return self._connection[1]

    ##
    # Clear any cached connection object.
    # Used in the event of socket errors.
    #
    def close(self):
        host, connection = self._connection
        if connection:
            self._connection = (None, None)
            connection.close()

    ##
    # Send HTTP request.
    #
    # @param host Host descriptor (URL or (URL, x509 info) tuple).
    # @param handler Targer RPC handler (a path relative to host)
    # @param request_body The XML-RPC request body
    # @param debug Enable debugging if debug is true.
    # @return An HTTPConnection.

    def send_request(self, host, handler, request_body, debug):
        connection = self.make_connection(host)
        headers = self._extra_headers[:]
        if debug:
            connection.set_debuglevel(1)
        if self.accept_gzip_encoding and gzip:
            connection.putrequest("POST", handler, skip_accept_encoding=True)
            headers.append(("Accept-Encoding", "gzip"))
        else:
            connection.putrequest("POST", handler)
        headers.append(("Content-Type", "text/xml"))
        headers.append(("User-Agent", self.user_agent))
        self.send_headers(connection, headers)
        self.send_content(connection, request_body)
        return connection

    ##
    # Send request headers.
    # This function provides a useful hook for subclassing
    #
    # @param connection httpConnection.
    # @param headers list of key,value pairs for HTTP headers

    def send_headers(self, connection, headers):
        for key, val in headers:
            connection.putheader(key, val)

    ##
    # Send request body.
    # This function provides a useful hook for subclassing
    #
    # @param connection httpConnection.
    # @param request_body XML-RPC request body.

    def send_content(self, connection, request_body):
        #optionally encode the request
        if (self.encode_threshold is not None and
            self.encode_threshold < len(request_body) and
            gzip):
            connection.putheader("Content-Encoding", "gzip")
            request_body = gzip_encode(request_body)

        connection.putheader("Content-Length", str(len(request_body)))
        connection.endheaders(request_body)

    ##
    # Parse response.
    #
    # @param file Stream.
    # @return Response tuple and target method.

    def parse_response(self, response):
        # read response data from httpresponse, and parse it
        # Check for new http response object, otherwise it is a file object.
        if hasattr(response, 'getheader'):
            if response.getheader("Content-Encoding", "") == "gzip":
                stream = GzipDecodedResponse(response)
            else:
                stream = response
        else:
            stream = response

        p, u = self.getparser()

        while 1:
            data = stream.read(1024)
            if not data:
                break
            if self.verbose:
                print("body:", repr(data))
            p.feed(data)

        if stream is not response:
            stream.close()
        p.close()

        return u.close()

##
# Standard transport class for XML-RPC over HTTPS.

class SafeTransport(Transport):
    """Handles an HTTPS transaction to an XML-RPC server."""

    def __init__(self, use_datetime=False, use_builtin_types=False, *,
                 context=None):
        super().__init__(use_datetime=use_datetime, use_builtin_types=use_builtin_types)
        self.context = context

    # FIXME: mostly untested

    def make_connection(self, host):
        if self._connection and host == self._connection[0]:
            return self._connection[1]

        if not hasattr(http.client, "HTTPSConnection"):
            raise NotImplementedError(
            "your version of http.client doesn't support HTTPS")
        # create a HTTPS connection object from a host descriptor
        # host may be a string, or a (host, x509-dict) tuple
        chost, self._extra_headers, x509 = self.get_host_info(host)
        self._connection = host, http.client.HTTPSConnection(chost,
            None, context=self.context, **(x509 or {}))
        return self._connection[1]

##
# Standard server proxy.  This class establishes a virtual connection
# to an XML-RPC server.
# <p>
# This class is available as ServerProxy and Server.  New code should
# use ServerProxy, to avoid confusion.
#
# @def ServerProxy(uri, **options)
# @param uri The connection point on the server.
# @keyparam transport A transport factory, compatible with the
#    standard transport class.
# @keyparam encoding The default encoding used for 8-bit strings
#    (default is UTF-8).
# @keyparam verbose Use a true value to enable debugging output.
#    (printed to standard output).
# @see Transport

class ServerProxy:
    """uri [,options] -> a logical connection to an XML-RPC server

    uri is the connection point on the server, given as
    scheme://host/target.

    The standard implementation always supports the "http" scheme.  If
    SSL socket support is available (Python 2.0), it also supports
    "https".

    If the target part and the slash preceding it are both omitted,
    "/RPC2" is assumed.

    The following options can be given as keyword arguments:

        transport: a transport factory
        encoding: the request encoding (default is UTF-8)

    All 8-bit strings passed to the server proxy are assumed to use
    the given encoding.
    """

    def __init__(self, uri, transport=None, encoding=None, verbose=False,
                 allow_none=False, use_datetime=False, use_builtin_types=False,
                 *, context=None):
        # establish a "logical" server connection

        # get the url
        type, uri = urllib.parse.splittype(uri)
        if type not in ("http", "https"):
            raise OSError("unsupported XML-RPC protocol")
        self.__host, self.__handler = urllib.parse.splithost(uri)
        if not self.__handler:
            self.__handler = "/RPC2"

        if transport is None:
            if type == "https":
                handler = SafeTransport
                extra_kwargs = {"context": context}
            else:
                handler = Transport
                extra_kwargs = {}
            transport = handler(use_datetime=use_datetime,
                                use_builtin_types=use_builtin_types,
                                **extra_kwargs)
        self.__transport = transport

        self.__encoding = encoding or 'utf-8'
        self.__verbose = verbose
        self.__allow_none = allow_none

    def __close(self):
        self.__transport.close()

    def __request(self, methodname, params):
        # call a method on the remote server

        request = dumps(params, methodname, encoding=self.__encoding,
                        allow_none=self.__allow_none).encode(self.__encoding, 'xmlcharrefreplace')

        response = self.__transport.request(
            self.__host,
            self.__handler,
            request,
            verbose=self.__verbose
            )

        if len(response) == 1:
            response = response[0]

        return response

    def __repr__(self):
        return (
            "<%s for %s%s>" %
            (self.__class__.__name__, self.__host, self.__handler)
            )

    __str__ = __repr__

    def __getattr__(self, name):
        # magic method dispatcher
        return _Method(self.__request, name)

    # note: to call a remote object with a non-standard name, use
    # result getattr(server, "strange-python-name")(args)

    def __call__(self, attr):
        """A workaround to get special attributes on the ServerProxy
           without interfering with the magic __getattr__
        """
        if attr == "close":
            return self.__close
        elif attr == "transport":
            return self.__transport
        raise AttributeError("Attribute %r not found" % (attr,))

    def __enter__(self):
        return self

    def __exit__(self, *args):
        self.__close()

# compatibility

Server = ServerProxy

# --------------------------------------------------------------------
# test code

if __name__ == "__main__":

    # simple test program (from the XML-RPC specification)

    # local server, available from Lib/xmlrpc/server.py
    server = ServerProxy("http://localhost:8000")

    try:
        print(server.currentTime.getCurrentTime())
    except Error as v:
        print("ERROR", v)

    multi = MultiCall(server)
    multi.getData()
    multi.pow(2,9)
    multi.add(1,2)
    try:
        for response in multi():
            print(response)
    except Error as v:
        print("ERROR", v)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      r"""XML-RPC Servers.

This module can be used to create simple XML-RPC servers
by creating a server and either installing functions, a
class instance, or by extending the SimpleXMLRPCServer
class.

It can also be used to handle XML-RPC requests in a CGI
environment using CGIXMLRPCRequestHandler.

The Doc* classes can be used to create XML-RPC servers that
serve pydoc-style documentation in response to HTTP
GET requests. This documentation is dynamically generated
based on the functions and methods registered with the
server.

A list of possible usage patterns follows:

1. Install functions:

server = SimpleXMLRPCServer(("localhost", 8000))
server.register_function(pow)
server.register_function(lambda x,y: x+y, 'add')
server.serve_forever()

2. Install an instance:

class MyFuncs:
    def __init__(self):
        # make all of the sys functions available through sys.func_name
        import sys
        self.sys = sys
    def _listMethods(self):
        # implement this method so that system.listMethods
        # knows to advertise the sys methods
        return list_public_methods(self) + \
                ['sys.' + method for method in list_public_methods(self.sys)]
    def pow(self, x, y): return pow(x, y)
    def add(self, x, y) : return x + y

server = SimpleXMLRPCServer(("localhost", 8000))
server.register_introspection_functions()
server.register_instance(MyFuncs())
server.serve_forever()

3. Install an instance with custom dispatch method:

class Math:
    def _listMethods(self):
        # this method must be present for system.listMethods
        # to work
        return ['add', 'pow']
    def _methodHelp(self, method):
        # this method must be present for system.methodHelp
        # to work
        if method == 'add':
            return "add(2,3) => 5"
        elif method == 'pow':
            return "pow(x, y[, z]) => number"
        else:
            # By convention, return empty
            # string if no help is available
            return ""
    def _dispatch(self, method, params):
        if method == 'pow':
            return pow(*params)
        elif method == 'add':
            return params[0] + params[1]
        else:
            raise ValueError('bad method')

server = SimpleXMLRPCServer(("localhost", 8000))
server.register_introspection_functions()
server.register_instance(Math())
server.serve_forever()

4. Subclass SimpleXMLRPCServer:

class MathServer(SimpleXMLRPCServer):
    def _dispatch(self, method, params):
        try:
            # We are forcing the 'export_' prefix on methods that are
            # callable through XML-RPC to prevent potential security
            # problems
            func = getattr(self, 'export_' + method)
        except AttributeError:
            raise Exception('method "%s" is not supported' % method)
        else:
            return func(*params)

    def export_add(self, x, y):
        return x + y

server = MathServer(("localhost", 8000))
server.serve_forever()

5. CGI script:

server = CGIXMLRPCRequestHandler()
server.register_function(pow)
server.handle_request()
"""

# Written by Brian Quinlan (brian@sweetapp.com).
# Based on code written by Fredrik Lundh.

from xmlrpc.client import Fault, dumps, loads, gzip_encode, gzip_decode
from http.server import BaseHTTPRequestHandler
import http.server
import socketserver
import sys
import os
import re
import pydoc
import inspect
import traceback
try:
    import fcntl
except ImportError:
    fcntl = None

def resolve_dotted_attribute(obj, attr, allow_dotted_names=True):
    """resolve_dotted_attribute(a, 'b.c.d') => a.b.c.d

    Resolves a dotted attribute name to an object.  Raises
    an AttributeError if any attribute in the chain starts with a '_'.

    If the optional allow_dotted_names argument is false, dots are not
    supported and this function operates similar to getattr(obj, attr).
    """

    if allow_dotted_names:
        attrs = attr.split('.')
    else:
        attrs = [attr]

    for i in attrs:
        if i.startswith('_'):
            raise AttributeError(
                'attempt to access private attribute "%s"' % i
                )
        else:
            obj = getattr(obj,i)
    return obj

def list_public_methods(obj):
    """Returns a list of attribute strings, found in the specified
    object, which represent callable attributes"""

    return [member for member in dir(obj)
                if not member.startswith('_') and
                    callable(getattr(obj, member))]

class SimpleXMLRPCDispatcher:
    """Mix-in class that dispatches XML-RPC requests.

    This class is used to register XML-RPC method handlers
    and then to dispatch them. This class doesn't need to be
    instanced directly when used by SimpleXMLRPCServer but it
    can be instanced when used by the MultiPathXMLRPCServer
    """

    def __init__(self, allow_none=False, encoding=None,
                 use_builtin_types=False):
        self.funcs = {}
        self.instance = None
        self.allow_none = allow_none
        self.encoding = encoding or 'utf-8'
        self.use_builtin_types = use_builtin_types

    def register_instance(self, instance, allow_dotted_names=False):
        """Registers an instance to respond to XML-RPC requests.

        Only one instance can be installed at a time.

        If the registered instance has a _dispatch method then that
        method will be called with the name of the XML-RPC method and
        its parameters as a tuple
        e.g. instance._dispatch('add',(2,3))

        If the registered instance does not have a _dispatch method
        then the instance will be searched to find a matching method
        and, if found, will be called. Methods beginning with an '_'
        are considered private and will not be called by
        SimpleXMLRPCServer.

        If a registered function matches an XML-RPC request, then it
        will be called instead of the registered instance.

        If the optional allow_dotted_names argument is true and the
        instance does not have a _dispatch method, method names
        containing dots are supported and resolved, as long as none of
        the name segments start with an '_'.

            *** SECURITY WARNING: ***

            Enabling the allow_dotted_names options allows intruders
            to access your module's global variables and may allow
            intruders to execute arbitrary code on your machine.  Only
            use this option on a secure, closed network.

        """

        self.instance = instance
        self.allow_dotted_names = allow_dotted_names

    def register_function(self, function, name=None):
        """Registers a function to respond to XML-RPC requests.

        The optional name argument can be used to set a Unicode name
        for the function.
        """

        if name is None:
            name = function.__name__
        self.funcs[name] = function

    def register_introspection_functions(self):
        """Registers the XML-RPC introspection methods in the system
        namespace.

        see http://xmlrpc.usefulinc.com/doc/reserved.html
        """

        self.funcs.update({'system.listMethods' : self.system_listMethods,
                      'system.methodSignature' : self.system_methodSignature,
                      'system.methodHelp' : self.system_methodHelp})

    def register_multicall_functions(self):
        """Registers the XML-RPC multicall method in the system
        namespace.

        see http://www.xmlrpc.com/discuss/msgReader$1208"""

        self.funcs.update({'system.multicall' : self.system_multicall})

    def _marshaled_dispatch(self, data, dispatch_method = None, path = None):
        """Dispatches an XML-RPC method from marshalled (XML) data.

        XML-RPC methods are dispatched from the marshalled (XML) data
        using the _dispatch method and the result is returned as
        marshalled data. For backwards compatibility, a dispatch
        function can be provided as an argument (see comment in
        SimpleXMLRPCRequestHandler.do_POST) but overriding the
        existing method through subclassing is the preferred means
        of changing method dispatch behavior.
        """

        try:
            params, method = loads(data, use_builtin_types=self.use_builtin_types)

            # generate response
            if dispatch_method is not None:
                response = dispatch_method(method, params)
            else:
                response = self._dispatch(method, params)
            # wrap response in a singleton tuple
            response = (response,)
            response = dumps(response, methodresponse=1,
                             allow_none=self.allow_none, encoding=self.encoding)
        except Fault as fault:
            response = dumps(fault, allow_none=self.allow_none,
                             encoding=self.encoding)
        except:
            # report exception back to server
            exc_type, exc_value, exc_tb = sys.exc_info()
            response = dumps(
                Fault(1, "%s:%s" % (exc_type, exc_value)),
                encoding=self.encoding, allow_none=self.allow_none,
                )

        return response.encode(self.encoding, 'xmlcharrefreplace')

    def system_listMethods(self):
        """system.listMethods() => ['add', 'subtract', 'multiple']

        Returns a list of the methods supported by the server."""

        methods = set(self.funcs.keys())
        if self.instance is not None:
            # Instance can implement _listMethod to return a list of
            # methods
            if hasattr(self.instance, '_listMethods'):
                methods |= set(self.instance._listMethods())
            # if the instance has a _dispatch method then we
            # don't have enough information to provide a list
            # of methods
            elif not hasattr(self.instance, '_dispatch'):
                methods |= set(list_public_methods(self.instance))
        return sorted(methods)

    def system_methodSignature(self, method_name):
        """system.methodSignature('add') => [double, int, int]

        Returns a list describing the signature of the method. In the
        above example, the add method takes two integers as arguments
        and returns a double result.

        This server does NOT support system.methodSignature."""

        # See http://xmlrpc.usefulinc.com/doc/sysmethodsig.html

        return 'signatures not supported'

    def system_methodHelp(self, method_name):
        """system.methodHelp('add') => "Adds two integers together"

        Returns a string containing documentation for the specified method."""

        method = None
        if method_name in self.funcs:
            method = self.funcs[method_name]
        elif self.instance is not None:
            # Instance can implement _methodHelp to return help for a method
            if hasattr(self.instance, '_methodHelp'):
                return self.instance._methodHelp(method_name)
            # if the instance has a _dispatch method then we
            # don't have enough information to provide help
            elif not hasattr(self.instance, '_dispatch'):
                try:
                    method = resolve_dotted_attribute(
                                self.instance,
                                method_name,
                                self.allow_dotted_names
                                )
                except AttributeError:
                    pass

        # Note that we aren't checking that the method actually
        # be a callable object of some kind
        if method is None:
            return ""
        else:
            return pydoc.getdoc(method)

    def system_multicall(self, call_list):
        """system.multicall([{'methodName': 'add', 'params': [2, 2]}, ...]) => \
[[4], ...]

        Allows the caller to package multiple XML-RPC calls into a single
        request.

        See http://www.xmlrpc.com/discuss/msgReader$1208
        """

        results = []
        for call in call_list:
            method_name = call['methodName']
            params = call['params']

            try:
                # XXX A marshalling error in any response will fail the entire
                # multicall. If someone cares they should fix this.
                results.append([self._dispatch(method_name, params)])
            except Fault as fault:
                results.append(
                    {'faultCode' : fault.faultCode,
                     'faultString' : fault.faultString}
                    )
            except:
                exc_type, exc_value, exc_tb = sys.exc_info()
                results.append(
                    {'faultCode' : 1,
                     'faultString' : "%s:%s" % (exc_type, exc_value)}
                    )
        return results

    def _dispatch(self, method, params):
        """Dispatches the XML-RPC method.

        XML-RPC calls are forwarded to a registered function that
        matches the called XML-RPC method name. If no such function
        exists then the call is forwarded to the registered instance,
        if available.

        If the registered instance has a _dispatch method then that
        method will be called with the name of the XML-RPC method and
        its parameters as a tuple
        e.g. instance._dispatch('add',(2,3))

        If the registered instance does not have a _dispatch method
        then the instance will be searched to find a matching method
        and, if found, will be called.

        Methods beginning with an '_' are considered private and will
        not be called.
        """

        func = None
        try:
            # check to see if a matching function has been registered
            func = self.funcs[method]
        except KeyError:
            if self.instance is not None:
                # check for a _dispatch method
                if hasattr(self.instance, '_dispatch'):
                    return self.instance._dispatch(method, params)
                else:
                    # call instance method directly
                    try:
                        func = resolve_dotted_attribute(
                            self.instance,
                            method,
                            self.allow_dotted_names
                            )
                    except AttributeError:
                        pass

        if func is not None:
            return func(*params)
        else:
            raise Exception('method "%s" is not supported' % method)

class SimpleXMLRPCRequestHandler(BaseHTTPRequestHandler):
    """Simple XML-RPC request handler class.

    Handles all HTTP POST requests and attempts to decode them as
    XML-RPC requests.
    """

    # Class attribute listing the accessible path components;
    # paths not on this list will result in a 404 error.
    rpc_paths = ('/', '/RPC2')

    #if not None, encode responses larger than this, if possible
    encode_threshold = 1400 #a common MTU

    #Override form StreamRequestHandler: full buffering of output
    #and no Nagle.
    wbufsize = -1
    disable_nagle_algorithm = True

    # a re to match a gzip Accept-Encoding
    aepattern = re.compile(r"""
                            \s* ([^\s;]+) \s*            #content-coding
                            (;\s* q \s*=\s* ([0-9\.]+))? #q
                            """, re.VERBOSE | re.IGNORECASE)

    def accept_encodings(self):
        r = {}
        ae = self.headers.get("Accept-Encoding", "")
        for e in ae.split(","):
            match = self.aepattern.match(e)
            if match:
                v = match.group(3)
                v = float(v) if v else 1.0
                r[match.group(1)] = v
        return r

    def is_rpc_path_valid(self):
        if self.rpc_paths:
            return self.path in self.rpc_paths
        else:
            # If .rpc_paths is empty, just assume all paths are legal
            return True

    def do_POST(self):
        """Handles the HTTP POST request.

        Attempts to interpret all HTTP POST requests as XML-RPC calls,
        which are forwarded to the server's _dispatch method for handling.
        """

        # Check that the path is legal
        if not self.is_rpc_path_valid():
            self.report_404()
            return

        try:
            # Get arguments by reading body of request.
            # We read this in chunks to avoid straining
            # socket.read(); around the 10 or 15Mb mark, some platforms
            # begin to have problems (bug #792570).
            max_chunk_size = 10*1024*1024
            size_remaining = int(self.headers["content-length"])
            L = []
            while size_remaining:
                chunk_size = min(size_remaining, max_chunk_size)
                chunk = self.rfile.read(chunk_size)
                if not chunk:
                    break
                L.append(chunk)
                size_remaining -= len(L[-1])
            data = b''.join(L)

            data = self.decode_request_content(data)
            if data is None:
                return #response has been sent

            # In previous versions of SimpleXMLRPCServer, _dispatch
            # could be overridden in this class, instead of in
            # SimpleXMLRPCDispatcher. To maintain backwards compatibility,
            # check to see if a subclass implements _dispatch and dispatch
            # using that method if present.
            response = self.server._marshaled_dispatch(
                    data, getattr(self, '_dispatch', None), self.path
                )
        except Exception as e: # This should only happen if the module is buggy
            # internal error, report as HTTP server error
            self.send_response(500)

            # Send information about the exception if requested
            if hasattr(self.server, '_send_traceback_header') and \
                    self.server._send_traceback_header:
                self.send_header("X-exception", str(e))
                trace = traceback.format_exc()
                trace = str(trace.encode('ASCII', 'backslashreplace'), 'ASCII')
                self.send_header("X-traceback", trace)

            self.send_header("Content-length", "0")
            self.end_headers()
        else:
            self.send_response(200)
            self.send_header("Content-type", "text/xml")
            if self.encode_threshold is not None:
                if len(response) > self.encode_threshold:
                    q = self.accept_encodings().get("gzip", 0)
                    if q:
                        try:
                            response = gzip_encode(response)
                            self.send_header("Content-Encoding", "gzip")
                        except NotImplementedError:
                            pass
            self.send_header("Content-length", str(len(response)))
            self.end_headers()
            self.wfile.write(response)

    def decode_request_content(self, data):
        #support gzip encoding of request
        encoding = self.headers.get("content-encoding", "identity").lower()
        if encoding == "identity":
            return data
        if encoding == "gzip":
            try:
                return gzip_decode(data)
            except NotImplementedError:
                self.send_response(501, "encoding %r not supported" % encoding)
            except ValueError:
                self.send_response(400, "error decoding gzip content")
        else:
            self.send_response(501, "encoding %r not supported" % encoding)
        self.send_header("Content-length", "0")
        self.end_headers()

    def report_404 (self):
            # Report a 404 error
        self.send_response(404)
        response = b'No such page'
        self.send_header("Content-type", "text/plain")
        self.send_header("Content-length", str(len(response)))
        self.end_headers()
        self.wfile.write(response)

    def log_request(self, code='-', size='-'):
        """Selectively log an accepted request."""

        if self.server.logRequests:
            BaseHTTPRequestHandler.log_request(self, code, size)

class SimpleXMLRPCServer(socketserver.TCPServer,
                         SimpleXMLRPCDispatcher):
    """Simple XML-RPC server.

    Simple XML-RPC server that allows functions and a single instance
    to be installed to handle requests. The default implementation
    attempts to dispatch XML-RPC calls to the functions or instance
    installed in the server. Override the _dispatch method inherited
    from SimpleXMLRPCDispatcher to change this behavior.
    """

    allow_reuse_address = True

    # Warning: this is for debugging purposes only! Never set this to True in
    # production code, as will be sending out sensitive information (exception
    # and stack trace details) when exceptions are raised inside
    # SimpleXMLRPCRequestHandler.do_POST
    _send_traceback_header = False

    def __init__(self, addr, requestHandler=SimpleXMLRPCRequestHandler,
                 logRequests=True, allow_none=False, encoding=None,
                 bind_and_activate=True, use_builtin_types=False):
        self.logRequests = logRequests

        SimpleXMLRPCDispatcher.__init__(self, allow_none, encoding, use_builtin_types)
        socketserver.TCPServer.__init__(self, addr, requestHandler, bind_and_activate)


class MultiPathXMLRPCServer(SimpleXMLRPCServer):
    """Multipath XML-RPC Server
    This specialization of SimpleXMLRPCServer allows the user to create
    multiple Dispatcher instances and assign them to different
    HTTP request paths.  This makes it possible to run two or more
    'virtual XML-RPC servers' at the same port.
    Make sure that the requestHandler accepts the paths in question.
    """
    def __init__(self, addr, requestHandler=SimpleXMLRPCRequestHandler,
                 logRequests=True, allow_none=False, encoding=None,
                 bind_and_activate=True, use_builtin_types=False):

        SimpleXMLRPCServer.__init__(self, addr, requestHandler, logRequests, allow_none,
                                    encoding, bind_and_activate, use_builtin_types)
        self.dispatchers = {}
        self.allow_none = allow_none
        self.encoding = encoding or 'utf-8'

    def add_dispatcher(self, path, dispatcher):
        self.dispatchers[path] = dispatcher
        return dispatcher

    def get_dispatcher(self, path):
        return self.dispatchers[path]

    def _marshaled_dispatch(self, data, dispatch_method = None, path = None):
        try:
            response = self.dispatchers[path]._marshaled_dispatch(
               data, dispatch_method, path)
        except:
            # report low level exception back to server
            # (each dispatcher should have handled their own
            # exceptions)
            exc_type, exc_value = sys.exc_info()[:2]
            response = dumps(
                Fault(1, "%s:%s" % (exc_type, exc_value)),
                encoding=self.encoding, allow_none=self.allow_none)
            response = response.encode(self.encoding, 'xmlcharrefreplace')
        return response

class CGIXMLRPCRequestHandler(SimpleXMLRPCDispatcher):
    """Simple handler for XML-RPC data passed through CGI."""

    def __init__(self, allow_none=False, encoding=None, use_builtin_types=False):
        SimpleXMLRPCDispatcher.__init__(self, allow_none, encoding, use_builtin_types)

    def handle_xmlrpc(self, request_text):
        """Handle a single XML-RPC request"""

        response = self._marshaled_dispatch(request_text)

        print('Content-Type: text/xml')
        print('Content-Length: %d' % len(response))
        print()
        sys.stdout.flush()
        sys.stdout.buffer.write(response)
        sys.stdout.buffer.flush()

    def handle_get(self):
        """Handle a single HTTP GET request.

        Default implementation indicates an error because
        XML-RPC uses the POST method.
        """

        code = 400
        message, explain = BaseHTTPRequestHandler.responses[code]

        response = http.server.DEFAULT_ERROR_MESSAGE % \
            {
             'code' : code,
             'message' : message,
             'explain' : explain
            }
        response = response.encode('utf-8')
        print('Status: %d %s' % (code, message))
        print('Content-Type: %s' % http.server.DEFAULT_ERROR_CONTENT_TYPE)
        print('Content-Length: %d' % len(response))
        print()
        sys.stdout.flush()
        sys.stdout.buffer.write(response)
        sys.stdout.buffer.flush()

    def handle_request(self, request_text=None):
        """Handle a single XML-RPC request passed through a CGI post method.

        If no XML data is given then it is read from stdin. The resulting
        XML-RPC response is printed to stdout along with the correct HTTP
        headers.
        """

        if request_text is None and \
            os.environ.get('REQUEST_METHOD', None) == 'GET':
            self.handle_get()
        else:
            # POST data is normally available through stdin
            try:
                length = int(os.environ.get('CONTENT_LENGTH', None))
            except (ValueError, TypeError):
                length = -1
            if request_text is None:
                request_text = sys.stdin.read(length)

            self.handle_xmlrpc(request_text)


# -----------------------------------------------------------------------------
# Self documenting XML-RPC Server.

class ServerHTMLDoc(pydoc.HTMLDoc):
    """Class used to generate pydoc HTML document for a server"""

    def markup(self, text, escape=None, funcs={}, classes={}, methods={}):
        """Mark up some plain text, given a context of symbols to look for.
        Each context dictionary maps object names to anchor names."""
        escape = escape or self.escape
        results = []
        here = 0

        # XXX Note that this regular expression does not allow for the
        # hyperlinking of arbitrary strings being used as method
        # names. Only methods with names consisting of word characters
        # and '.'s are hyperlinked.
        pattern = re.compile(r'\b((http|ftp)://\S+[\w/]|'
                                r'RFC[- ]?(\d+)|'
                                r'PEP[- ]?(\d+)|'
                                r'(self\.)?((?:\w|\.)+))\b')
        while 1:
            match = pattern.search(text, here)
            if not match: break
            start, end = match.span()
            results.append(escape(text[here:start]))

            all, scheme, rfc, pep, selfdot, name = match.groups()
            if scheme:
                url = escape(all).replace('"', '&quot;')
                results.append('<a href="%s">%s</a>' % (url, url))
            elif rfc:
                url = 'http://www.rfc-editor.org/rfc/rfc%d.txt' % int(rfc)
                results.append('<a href="%s">%s</a>' % (url, escape(all)))
            elif pep:
                url = 'http://www.python.org/dev/peps/pep-%04d/' % int(pep)
                results.append('<a href="%s">%s</a>' % (url, escape(all)))
            elif text[end:end+1] == '(':
                results.append(self.namelink(name, methods, funcs, classes))
            elif selfdot:
                results.append('self.<strong>%s</strong>' % name)
            else:
                results.append(self.namelink(name, classes))
            here = end
        results.append(escape(text[here:]))
        return ''.join(results)

    def docroutine(self, object, name, mod=None,
                   funcs={}, classes={}, methods={}, cl=None):
        """Produce HTML documentation for a function or method object."""

        anchor = (cl and cl.__name__ or '') + '-' + name
        note = ''

        title = '<a name="%s"><strong>%s</strong></a>' % (
            self.escape(anchor), self.escape(name))

        if inspect.ismethod(object):
            args = inspect.getfullargspec(object)
            # exclude the argument bound to the instance, it will be
            # confusing to the non-Python user
            argspec = inspect.formatargspec (
                    args.args[1:],
                    args.varargs,
                    args.varkw,
                    args.defaults,
                    annotations=args.annotations,
                    formatvalue=self.formatvalue
                )
        elif inspect.isfunction(object):
            args = inspect.getfullargspec(object)
            argspec = inspect.formatargspec(
                args.args, args.varargs, args.varkw, args.defaults,
                annotations=args.annotations,
                formatvalue=self.formatvalue)
        else:
            argspec = '(...)'

        if isinstance(object, tuple):
            argspec = object[0] or argspec
            docstring = object[1] or ""
        else:
            docstring = pydoc.getdoc(object)

        decl = title + argspec + (note and self.grey(
               '<font face="helvetica, arial">%s</font>' % note))

        doc = self.markup(
            docstring, self.preformat, funcs, classes, methods)
        doc = doc and '<dd><tt>%s</tt></dd>' % doc
        return '<dl><dt>%s</dt>%s</dl>\n' % (decl, doc)

    def docserver(self, server_name, package_documentation, methods):
        """Produce HTML documentation for an XML-RPC server."""

        fdict = {}
        for key, value in methods.items():
            fdict[key] = '#-' + key
            fdict[value] = fdict[key]

        server_name = self.escape(server_name)
        head = '<big><big><strong>%s</strong></big></big>' % server_name
        result = self.heading(head, '#ffffff', '#7799ee')

        doc = self.markup(package_documentation, self.preformat, fdict)
        doc = doc and '<tt>%s</tt>' % doc
        result = result + '<p>%s</p>\n' % doc

        contents = []
        method_items = sorted(methods.items())
        for key, value in method_items:
            contents.append(self.docroutine(value, key, funcs=fdict))
        result = result + self.bigsection(
            'Methods', '#ffffff', '#eeaa77', ''.join(contents))

        return result

class XMLRPCDocGenerator:
    """Generates documentation for an XML-RPC server.

    This class is designed as mix-in and should not
    be constructed directly.
    """

    def __init__(self):
        # setup variables used for HTML documentation
        self.server_name = 'XML-RPC Server Documentation'
        self.server_documentation = \
            "This server exports the following methods through the XML-RPC "\
            "protocol."
        self.server_title = 'XML-RPC Server Documentation'

    def set_server_title(self, server_title):
        """Set the HTML title of the generated server documentation"""

        self.server_title = server_title

    def set_server_name(self, server_name):
        """Set the name of the generated HTML server documentation"""

        self.server_name = server_name

    def set_server_documentation(self, server_documentation):
        """Set the documentation string for the entire server."""

        self.server_documentation = server_documentation

    def generate_html_documentation(self):
        """generate_html_documentation() => html documentation for the server

        Generates HTML documentation for the server using introspection for
        installed functions and instances that do not implement the
        _dispatch method. Alternatively, instances can choose to implement
        the _get_method_argstring(method_name) method to provide the
        argument string used in the documentation and the
        _methodHelp(method_name) method to provide the help text used
        in the documentation."""

        methods = {}

        for method_name in self.system_listMethods():
            if method_name in self.funcs:
                method = self.funcs[method_name]
            elif self.instance is not None:
                method_info = [None, None] # argspec, documentation
                if hasattr(self.instance, '_get_method_argstring'):
                    method_info[0] = self.instance._get_method_argstring(method_name)
                if hasattr(self.instance, '_methodHelp'):
                    method_info[1] = self.instance._methodHelp(method_name)

                method_info = tuple(method_info)
                if method_info != (None, None):
                    method = method_info
                elif not hasattr(self.instance, '_dispatch'):
                    try:
                        method = resolve_dotted_attribute(
                                    self.instance,
                                    method_name
                                    )
                    except AttributeError:
                        method = method_info
                else:
                    method = method_info
            else:
                assert 0, "Could not find method in self.functions and no "\
                          "instance installed"

            methods[method_name] = method

        documenter = ServerHTMLDoc()
        documentation = documenter.docserver(
                                self.server_name,
                                self.server_documentation,
                                methods
                            )

        return documenter.page(self.server_title, documentation)

class DocXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
    """XML-RPC and documentation request handler class.

    Handles all HTTP POST requests and attempts to decode them as
    XML-RPC requests.

    Handles all HTTP GET requests and interprets them as requests
    for documentation.
    """

    def do_GET(self):
        """Handles the HTTP GET request.

        Interpret all HTTP GET requests as requests for server
        documentation.
        """
        # Check that the path is legal
        if not self.is_rpc_path_valid():
            self.report_404()
            return

        response = self.server.generate_html_documentation().encode('utf-8')
        self.send_response(200)
        self.send_header("Content-type", "text/html")
        self.send_header("Content-length", str(len(response)))
        self.end_headers()
        self.wfile.write(response)

class DocXMLRPCServer(  SimpleXMLRPCServer,
                        XMLRPCDocGenerator):
    """XML-RPC and HTML documentation server.

    Adds the ability to serve server documentation to the capabilities
    of SimpleXMLRPCServer.
    """

    def __init__(self, addr, requestHandler=DocXMLRPCRequestHandler,
                 logRequests=True, allow_none=False, encoding=None,
                 bind_and_activate=True, use_builtin_types=False):
        SimpleXMLRPCServer.__init__(self, addr, requestHandler, logRequests,
                                    allow_none, encoding, bind_and_activate,
                                    use_builtin_types)
        XMLRPCDocGenerator.__init__(self)

class DocCGIXMLRPCRequestHandler(   CGIXMLRPCRequestHandler,
                                    XMLRPCDocGenerator):
    """Handler for XML-RPC data and documentation requests passed through
    CGI"""

    def handle_get(self):
        """Handles the HTTP GET request.

        Interpret all HTTP GET requests as requests for server
        documentation.
        """

        response = self.generate_html_documentation().encode('utf-8')

        print('Content-Type: text/html')
        print('Content-Length: %d' % len(response))
        print()
        sys.stdout.flush()
        sys.stdout.buffer.write(response)
        sys.stdout.buffer.flush()

    def __init__(self):
        CGIXMLRPCRequestHandler.__init__(self)
        XMLRPCDocGenerator.__init__(self)


if __name__ == '__main__':
    import datetime

    class ExampleService:
        def getData(self):
            return '42'

        class currentTime:
            @staticmethod
            def getCurrentTime():
                return datetime.datetime.now()

    server = SimpleXMLRPCServer(("localhost", 8000))
    server.register_function(pow)
    server.register_function(lambda x,y: x+y, 'add')
    server.register_instance(ExampleService(), allow_dotted_names=True)
    server.register_multicall_functions()
    print('Serving XML-RPC on localhost port 8000')
    print('It is advisable to run this example server within a secure, closed network.')
    try:
        server.serve_forever()
    except KeyboardInterrupt:
        print("\nKeyboard interrupt received, exiting.")
        server.server_close()
        sys.exit(0)
                                                                                                                                                                                                                                
[&                  @   s   d  S)N r   r   r   %/usr/lib/python3.5/xmlrpc/__init__.py<module>   s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            
[              &   @   s  d  Z  d d l Z d d l Z d d l Z d d l m Z d d l Z d d l Z d d l	 m
 Z
 d d l Z d d l m Z y d d l Z Wn e k
 r d Z Yn Xd d   Z e j d d  Z dX Z dZ Z d[ Z d\ Z d] Z d^ Z d_ Z d` Z da Z db Z dc Z dd Z de Z df Z  Gd d   d e!  Z" Gd d   d e"  Z# Gd d   d e"  Z$ Gd d   d e"  Z% e& Z' Z( e d d d  Z) e) j* d  d k rd  d!   Z+ n0 e) j* d"  d k rd# d!   Z+ n d$ d!   Z+ [) d% d&   Z, Gd' d(   d(  Z- d) d*   Z. d+ d,   Z/ Gd- d.   d.  Z0 d/ d0   Z1 e- e0 f Z2 Gd1 d2   d2  Z3 Gd3 d4   d4  Z4 Gd5 d6   d6  Z5 Gd7 d8   d8  Z6 Gd9 d:   d:  Z7 Gd; d<   d<  Z8 d Z9 Z: Z; d= d= d> d?  Z< d d d d= d@ dA  Z= d= d= dB dC  Z> dD dE   Z? dF dG dH  Z@ GdI dJ   dJ e r<e jA n eB  ZC GdK dL   dL  ZD GdM dN   dN  ZE GdO dP   dP eE  ZF GdQ dR   dR  ZG eG ZH eI dS k reG dT  ZJ y eK eJ jL jM    Wn2 e" k
 rZN z eK dU eN  WYd d ZN [N Xn Xe8 eJ  ZO eO jP   eO jQ d	 dV  eO jR d d	  y" x eO   D] ZS eK eS  qAWWn2 e" k
 rZN z eK dU eN  WYd d ZN [N Xn Xd S)ga  
An XML-RPC client interface for Python.

The marshalling and response parser code can also be used to
implement XML-RPC servers.

Exported exceptions:

  Error          Base class for client errors
  ProtocolError  Indicates an HTTP protocol error
  ResponseError  Indicates a broken response package
  Fault          Indicates an XML-RPC fault package

Exported classes:

  ServerProxy    Represents a logical connection to an XML-RPC server

  MultiCall      Executor of boxcared xmlrpc requests
  DateTime       dateTime wrapper for an ISO 8601 string or time tuple or
                 localtime integer value to generate a "dateTime.iso8601"
                 XML-RPC value
  Binary         binary data wrapper

  Marshaller     Generate an XML-RPC params chunk from a Python data structure
  Unmarshaller   Unmarshal an XML-RPC response from incoming XML event message
  Transport      Handles an HTTP transaction to an XML-RPC server
  SafeTransport  Handles an HTTPS transaction to an XML-RPC server

Exported constants:

  (none)

Exported functions:

  getparser      Create instance of the fastest available parser & attach
                 to an unmarshalling object
  dumps          Convert an argument tuple or a Fault instance to an XML-RPC
                 request (or response, if the methodresponse option is used).
  loads          Convert an XML-RPC packet to unmarshalled data plus a method
                 name (None if not present).
    N)datetime)expat)BytesIOc             C   s4   |  j  d d  }  |  j  d d  }  |  j  d d  S)N&z&amp;<z&lt;>z&gt;)replace)s r
   #/usr/lib/python3.5/xmlrpc/client.pyescape   s    r               i  iX  i~  i~  i,~  i  i  iY  iZ  i[  c               @   s"   e  Z d  Z d Z d d   Z d S)ErrorzBase class for client errors.c             C   s
   t  |   S)N)repr)selfr
   r
   r   __str__   s    zError.__str__N)__name__
__module____qualname____doc__r   r
   r
   r
   r   r      s   r   c               @   s.   e  Z d  Z d Z d d   Z d d   Z d S)ProtocolErrorz!Indicates an HTTP protocol error.c             C   s5   t  j |   | |  _ | |  _ | |  _ | |  _ d  S)N)r   __init__urlerrcodeerrmsgheaders)r   r   r   r   r   r
   r
   r   r      s
    			zProtocolError.__init__c             C   s#   d |  j  j |  j |  j |  j f S)Nz<%s for %s: %s %s>)	__class__r   r   r   r   )r   r
   r
   r   __repr__   s    zProtocolError.__repr__N)r   r   r   r   r   r    r
   r
   r
   r   r      s   r   c               @   s   e  Z d  Z d Z d S)ResponseErrorz$Indicates a broken response package.N)r   r   r   r   r
   r
   r
   r   r!      s   r!   c               @   s.   e  Z d  Z d Z d d   Z d d   Z d S)Faultz#Indicates an XML-RPC fault package.c             K   s#   t  j |   | |  _ | |  _ d  S)N)r   r   	faultCodefaultString)r   r#   r$   Zextrar
   r
   r   r      s    	zFault.__init__c             C   s   d |  j  j |  j |  j f S)Nz<%s %s: %r>)r   r   r#   r$   )r   r
   r
   r   r       s    zFault.__repr__N)r   r   r   r   r   r    r
   r
   r
   r   r"      s   r"   z%YZ0001c             C   s   |  j  d  S)Nz%Y%m%dT%H:%M:%S)strftime)valuer
   r
   r   _iso8601_format  s    r'   z%4Yc             C   s   |  j  d  S)Nz%4Y%m%dT%H:%M:%S)r%   )r&   r
   r
   r   r'     s    c             C   s   |  j  d  j d  S)Nz%Y%m%dT%H:%M:%S   )r%   zfill)r&   r
   r
   r   r'     s    c             C   sj   t  |  t  r t |   St  |  t t j f  sX |  d k rI t j   }  t j |   }  d |  d  d  S)Nr   z%04d%02d%02dT%02d:%02d:%02d   )
isinstancer   r'   tupletimeZstruct_timeZ	localtime)r&   r
   r
   r   	_strftime  s    
r.   c               @   s   e  Z d  Z d Z d d d  Z d d   Z d d   Z d	 d
   Z d d   Z d d   Z	 d d   Z
 d d   Z d d   Z d d   Z d d   Z d d   Z d S)DateTimezDateTime wrapper for an ISO 8601 string or time tuple or
    localtime integer value to generate 'dateTime.iso8601' XML-RPC
    value.
    r   c             C   s.   t  | t  r | |  _ n t |  |  _ d  S)N)r+   strr&   r.   )r   r&   r
   r
   r   r   (  s    zDateTime.__init__c             C   s   t  | t  r$ |  j } | j } n t  | t  rK |  j } t |  } n t  | t  rl |  j } | } nm t | d  r |  j   } | j   } nC t | d  r | j j	 p t
 |  } t d |  j j	 | f   | | f S)N	timetupler   zCan't compare %s and %s)r+   r/   r&   r   r'   r0   hasattrr1   r   r   type	TypeError)r   otherr	   oZotyper
   r
   r   make_comparable.  s$    				zDateTime.make_comparablec             C   s   |  j  |  \ } } | | k  S)N)r7   )r   r5   r	   r6   r
   r
   r   __lt__C  s    zDateTime.__lt__c             C   s   |  j  |  \ } } | | k S)N)r7   )r   r5   r	   r6   r
   r
   r   __le__G  s    zDateTime.__le__c             C   s   |  j  |  \ } } | | k S)N)r7   )r   r5   r	   r6   r
   r
   r   __gt__K  s    zDateTime.__gt__c             C   s   |  j  |  \ } } | | k S)N)r7   )r   r5   r	   r6   r
   r
   r   __ge__O  s    zDateTime.__ge__c             C   s   |  j  |  \ } } | | k S)N)r7   )r   r5   r	   r6   r
   r
   r   __eq__S  s    zDateTime.__eq__c             C   s   t  j |  j d  S)Nz%Y%m%dT%H:%M:%S)r-   strptimer&   )r   r
   r
   r   r1   W  s    zDateTime.timetuplec             C   s   |  j  S)N)r&   )r   r
   r
   r   r   _  s    zDateTime.__str__c             C   s    d |  j  j |  j t |   f S)Nz<%s %r at %#x>)r   r   r&   id)r   r
   r
   r   r    b  s    zDateTime.__repr__c             C   s   t  |  j   |  _ d  S)N)r0   stripr&   )r   datar
   r
   r   decodee  s    zDateTime.decodec             C   s.   | j  d  | j  |  j  | j  d  d  S)Nz<value><dateTime.iso8601>z</dateTime.iso8601></value>
)writer&   )r   outr
   r
   r   encodeh  s    zDateTime.encodeN)r   r   r   r   r   r7   r8   r9   r:   r;   r<   r1   r   r    rA   rD   r
   r
   r
   r   r/   "  s   r/   c             C   s   t    } | j |   | S)N)r/   rA   )r@   r&   r
   r
   r   	_datetimem  s    	rE   c             C   s   t  j |  d  S)Nz%Y%m%dT%H:%M:%S)r   r=   )r@   r
   r
   r   _datetime_types  s    rF   c               @   sU   e  Z d  Z d Z d d d  Z d d   Z d d   Z d	 d
   Z d d   Z d S)BinaryzWrapper for binary data.Nc             C   sY   | d  k r d } n7 t  | t t f  s@ t d | j j   t |  } | |  _ d  S)N    z#expected bytes or bytearray, not %s)r+   bytes	bytearrayr4   r   r   r@   )r   r@   r
   r
   r   r     s    	zBinary.__init__c             C   s   t  |  j d  S)Nzlatin-1)r0   r@   )r   r
   r
   r   r     s    zBinary.__str__c             C   s%   t  | t  r | j } |  j | k S)N)r+   rG   r@   )r   r5   r
   r
   r   r<     s    	zBinary.__eq__c             C   s   t  j |  |  _ d  S)N)base64decodebytesr@   )r   r@   r
   r
   r   rA     s    zBinary.decodec             C   sF   | j  d  t j |  j  } | j  | j d   | j  d  d  S)Nz<value><base64>
asciiz</base64></value>
)rB   rK   encodebytesr@   rA   )r   rC   encodedr
   r
   r   rD     s    zBinary.encode)	r   r   r   r   r   r   r<   rA   rD   r
   r
   r
   r   rG   |  s   rG   c             C   s   t    } | j |   | S)N)rG   rA   )r@   r&   r
   r
   r   _binary  s    	rP   c               @   s4   e  Z d  Z d d   Z d d   Z d d   Z d S)ExpatParserc             C   s`   t  j d  d   |  _ } | |  _ | j | _ | j | _ | j | _	 d  } | j
 | d   d  S)N)r   ZParserCreate_parser_targetstartZStartElementHandlerendZEndElementHandlerr@   ZCharacterDataHandlerxml)r   targetparserencodingr
   r
   r   r     s    	zExpatParser.__init__c             C   s   |  j  j | d  d  S)Nr   )rR   Parse)r   r@   r
   r
   r   feed  s    zExpatParser.feedc             C   sB   y |  j  } Wn t k
 r! Yn X|  ` |  `  | j d d  d  S)NrH   T)rR   AttributeErrorrS   rZ   )r   rX   r
   r
   r   close  s    zExpatParser.closeN)r   r   r   r   r[   r]   r
   r
   r
   r   rQ     s   	rQ   c               @   s\  e  Z d  Z d Z d d d d  Z i  Z d d   Z d d	   Z d
 d   Z e e e	 d  <d d   Z
 e
 e e <d d   Z e e e <e Z d d   Z e e e <e d d  Z e e e <d d   Z e e e <e e e <d d   Z e e e <e e e <e d d  Z e e e <d d   Z e e e <d d   Z e e e <e e e  <e e d <d S)
Marshallerav  Generate an XML-RPC params chunk from a Python data structure.

    Create a Marshaller instance for each set of parameters, and use
    the "dumps" method to convert your data (represented as a tuple)
    to an XML-RPC params chunk.  To write a fault response, pass a
    Fault instance instead.  You may prefer to use the "dumps" module
    function for this purpose.
    NFc             C   s(   i  |  _  d  |  _ | |  _ | |  _ d  S)N)memor@   rY   
allow_none)r   rY   r`   r
   r
   r   r     s    			zMarshaller.__init__c             C   s   g  } | j  } |  j } t | t  r] | d  | d | j d | j i |  | d  nF | d  x/ | D]' } | d  | | |  | d  qn W| d  d	 j |  } | S)
Nz<fault>
r#   r$   z	</fault>
z	<params>
z<param>
z	</param>
z
</params>
 )append_Marshaller__dumpr+   r"   r#   r$   join)r   valuesrC   rB   dumpvresultr
   r
   r   dumps  s"    		



zMarshaller.dumpsc             C   s   y |  j  t |  } Wn t k
 r t | d  sL t d t |    xB t |  j D]1 } | |  j  j   k r\ t d t |    q\ W|  j  d } Yn X| |  | |  d  S)N__dict__zcannot marshal %s objects_arbitrary_instance)dispatchr3   KeyErrorr2   r4   __mro__keys)r   r&   rB   fZtype_r
   r
   r   Z__dump  s    zMarshaller.__dumpc             C   s#   |  j  s t d   | d  d  S)Nz0cannot marshal None unless allow_none is enabledz<value><nil/></value>)r`   r4   )r   r&   rB   r
   r
   r   dump_nil  s    	zMarshaller.dump_nilc             C   s.   | d  | | r d p d  | d  d  S)Nz<value><boolean>10z</boolean></value>
r
   )r   r&   rB   r
   r
   r   	dump_bool  s    
zMarshaller.dump_boolc             C   sR   | t  k s | t k  r$ t d   | d  | t t |    | d  d  S)Nzint exceeds XML-RPC limitsz<value><int>z</int></value>
)MAXINTMININTOverflowErrorr0   int)r   r&   rB   r
   r
   r   	dump_long  s
    
zMarshaller.dump_longc             C   s(   | d  | t  |   | d  d  S)Nz<value><double>z</double></value>
)r   )r   r&   rB   r
   r
   r   dump_double$  s    
zMarshaller.dump_doublec             C   s(   | d  | | |   | d  d  S)Nz<value><string>z</string></value>
r
   )r   r&   rB   r   r
   r
   r   dump_unicode*  s    
zMarshaller.dump_unicodec             C   s:   | d  t  j |  } | | j d   | d  d  S)Nz<value><base64>
rM   z</base64></value>
)rK   rN   rA   )r   r&   rB   rO   r
   r
   r   
dump_bytes0  s    
zMarshaller.dump_bytesc             C   s}   t  |  } | |  j k r' t d   d  |  j | <|  j } | d  x | D] } | | |  qN W| d  |  j | =d  S)Nz"cannot marshal recursive sequencesz<value><array><data>
z</data></array></value>
)r>   r_   r4   rc   )r   r&   rB   irf   rg   r
   r
   r   
dump_array8  s    	

zMarshaller.dump_arrayc             C   s   t  |  } | |  j k r' t d   d  |  j | <|  j } | d  xj | j   D]\ \ } } | d  t | t  s t d   | d | |   | | |  | d  qT W| d  |  j | =d  S)Nz%cannot marshal recursive dictionariesz<value><struct>
z	<member>
zdictionary key must be stringz<name>%s</name>
z
</member>
z</struct></value>
)r>   r_   r4   rc   itemsr+   r0   )r   r&   rB   r   r}   rf   krg   r
   r
   r   dump_structF  s    	


zMarshaller.dump_structc             C   s(   | d  | t  |   | d  d  S)Nz<value><dateTime.iso8601>z</dateTime.iso8601></value>
)r.   )r   r&   rB   r
   r
   r   dump_datetimeX  s    
zMarshaller.dump_datetimec             C   sE   | j  t k r. | |  _ | j |   |  ` n |  j | j |  d  S)N)r   WRAPPERSrB   rD   r   rj   )r   r&   rB   r
   r
   r   dump_instance^  s
    		zMarshaller.dump_instancerk   )!r   r   r   r   r   rl   ri   rc   rq   r3   rt   boolry   rx   Zdump_intrz   floatr   r{   r0   r|   rI   rJ   r~   r,   listr   dictr   r   r   r/   rG   r
   r
   r
   r   r^     s<   









	

r^   c               @   s  e  Z d  Z d Z d d d d  Z d d   Z d d   Z d	 d
   Z d d   Z d d   Z	 d d   Z
 d d   Z i  Z d d   Z e e d <d d   Z e e d <d d   Z e e d <e e d <e e d <d d   Z e e d  <d! d"   Z e e d# <e e d$ <d% d&   Z e e d' <d( d)   Z e e d* <d+ d,   Z e e d- <d. d/   Z e e d0 <d1 d2   Z e e d3 <d4 d5   Z e e d6 <d7 d8   Z e e d9 <d: d;   Z e e d< <d= S)>Unmarshallera  Unmarshal an XML-RPC response, based on incoming XML event
    messages (start, data, end).  Call close() to get the resulting
    data structure.

    Note that this reader is fairly tolerant, and gladly accepts bogus
    XML-RPC data without complaining (but not bogus XML).
    Fc             C   sj   d  |  _  g  |  _ g  |  _ g  |  _ d |  _ d  |  _ d |  _ |  j j |  _ | pW | |  _ | |  _	 d  S)NFzutf-8)
_type_stack_marks_data_value_methodname	_encodingrb   _use_datetime
_use_bytes)r   use_datetimeuse_builtin_typesr
   r
   r   r   ~  s    							zUnmarshaller.__init__c             C   sP   |  j  d  k s |  j r! t    |  j  d k rC t |  j d    t |  j  S)Nfaultr   )r   r   r!   r"   r   r,   )r   r
   r
   r   r]     s
    	zUnmarshaller.closec             C   s   |  j  S)N)r   )r   r
   r
   r   getmethodname  s    zUnmarshaller.getmethodnamec             C   s   | |  _  d  S)N)r   )r   rY   Z
standaloner
   r
   r   rV     s    zUnmarshaller.xmlc             C   su   | d k s | d k r1 |  j  j t |  j   g  |  _ |  j rb | |  j k rb t d |   | d k |  _ d  S)Narraystructzunknown tag %rr&   )r   rb   lenr   r   r   rl   r!   )r   tagZattrsr
   r
   r   rT     s    	zUnmarshaller.startc             C   s   |  j  j |  d  S)N)r   rb   )r   textr
   r
   r   r@     s    zUnmarshaller.datac             C   sC   y |  j  | } Wn t k
 r% Yn X| |  d j |  j   Sd  S)Nra   )rl   rm   rd   r   )r   r   rp   r
   r
   r   rU     s
    zUnmarshaller.endc             C   s7   y |  j  | } Wn t k
 r% Yn X| |  |  Sd  S)N)rl   rm   )r   r   r@   rp   r
   r
   r   end_dispatch  s
    zUnmarshaller.end_dispatchc             C   s   |  j  d   d |  _ d  S)Nr   )rb   r   )r   r@   r
   r
   r   end_nil  s    zUnmarshaller.end_nilZnilc             C   sQ   | d k r |  j  d  n( | d k r8 |  j  d  n t d   d |  _ d  S)Nrs   Frr   Tzbad boolean valuer   )rb   r4   r   )r   r@   r
   r
   r   end_boolean  s    zUnmarshaller.end_booleanbooleanc             C   s    |  j  t |   d |  _ d  S)Nr   )rb   rx   r   )r   r@   r
   r
   r   end_int  s    zUnmarshaller.end_intZi4Zi8rx   c             C   s    |  j  t |   d |  _ d  S)Nr   )rb   r   r   )r   r@   r
   r
   r   
end_double  s    zUnmarshaller.end_doubleZdoublec             C   s5   |  j  r | j |  j   } |  j |  d |  _ d  S)Nr   )r   rA   rb   r   )r   r@   r
   r
   r   
end_string  s    	zUnmarshaller.end_stringstringnamec             C   s?   |  j  j   } |  j | d   g |  j | d   <d |  _ d  S)Nr   )r   popr   r   )r   r@   markr
   r
   r   	end_array  s    #zUnmarshaller.end_arrayr   c             C   s   |  j  j   } i  } |  j | d   } x6 t d t |  d  D] } | | d | | | <qA W| g |  j | d   <d |  _ d  S)Nr   r   r   )r   r   r   ranger   r   )r   r@   r   r   r   r}   r
   r
   r   
end_struct  s    zUnmarshaller.end_structr   c             C   sK   t    } | j | j d   |  j r1 | j } |  j |  d |  _ d  S)NrM   r   )rG   rA   rD   r   r@   rb   r   )r   r@   r&   r
   r
   r   
end_base64  s    			zUnmarshaller.end_base64rK   c             C   s<   t    } | j |  |  j r+ t |  } |  j |  d  S)N)r/   rA   r   rF   rb   )r   r@   r&   r
   r
   r   end_dateTime   s
    		zUnmarshaller.end_dateTimezdateTime.iso8601c             C   s   |  j  r |  j |  d  S)N)r   r   )r   r@   r
   r
   r   	end_value  s    	zUnmarshaller.end_valuer&   c             C   s   d |  _  d  S)Nparams)r   )r   r@   r
   r
   r   
end_params  s    zUnmarshaller.end_paramsr   c             C   s   d |  _  d  S)Nr   )r   )r   r@   r
   r
   r   	end_fault  s    zUnmarshaller.end_faultr   c             C   s1   |  j  r | j |  j   } | |  _ d |  _ d  S)N
methodName)r   rA   r   r   )r   r@   r
   r
   r   end_methodName  s    		zUnmarshaller.end_methodNamer   N)r   r   r   r   r   r]   r   rV   rT   r@   rU   r   rl   r   r   r   r   r   r   r   r   r   r   r   r   r   r
   r
   r
   r   r   r  sN   	








	





r   c               @   s4   e  Z d  Z d d   Z d d   Z d d   Z d S)_MultiCallMethodc             C   s   | |  _  | |  _ d  S)N)_MultiCallMethod__call_list_MultiCallMethod__name)r   Z	call_listr   r
   r
   r   r   $  s    	z_MultiCallMethod.__init__c             C   s   t  |  j d |  j | f  S)Nz%s.%s)r   r   r   )r   r   r
   r
   r   __getattr__'  s    z_MultiCallMethod.__getattr__c             G   s   |  j  j |  j | f  d  S)N)r   rb   r   )r   argsr
   r
   r   __call__)  s    z_MultiCallMethod.__call__N)r   r   r   r   r   r   r
   r
   r
   r   r   !  s   r   c               @   s.   e  Z d  Z d Z d d   Z d d   Z d S)MultiCallIteratorzaIterates over the results of a multicall. Exceptions are
    raised in response to xmlrpc faults.c             C   s   | |  _  d  S)N)results)r   r   r
   r
   r   r   0  s    zMultiCallIterator.__init__c             C   so   |  j  | } t |  t i   k r? t | d | d   n, t |  t g   k r_ | d St d   d  S)Nr#   r$   r   z#unexpected type in multicall result)r   r3   r"   
ValueError)r   r}   itemr
   r
   r   __getitem__3  s    zMultiCallIterator.__getitem__N)r   r   r   r   r   r   r
   r
   r
   r   r   ,  s   r   c               @   sL   e  Z d  Z d Z d d   Z d d   Z e Z d d   Z d d	   Z d
 S)	MultiCalla~  server -> an object used to boxcar method calls

    server should be a ServerProxy object.

    Methods can be added to the MultiCall using normal
    method call syntax e.g.:

    multicall = MultiCall(server_proxy)
    multicall.add(2,3)
    multicall.get_address("Guido")

    To execute the multicall, call the MultiCall object e.g.:

    add_result, address = multicall()
    c             C   s   | |  _  g  |  _ d  S)N)_MultiCall__server_MultiCall__call_list)r   serverr
   r
   r   r   M  s    	zMultiCall.__init__c             C   s   d |  j  j t |   f S)Nz<%s at %#x>)r   r   r>   )r   r
   r
   r   r    Q  s    zMultiCall.__repr__c             C   s   t  |  j |  S)N)r   r   )r   r   r
   r
   r   r   V  s    zMultiCall.__getattr__c             C   sR   g  } x0 |  j  D]% \ } } | j d | d | i  q Wt |  j j j |   S)Nr   r   )r   rb   r   r   systemZ	multicall)r   Zmarshalled_listr   r   r
   r
   r   r   Y  s    zMultiCall.__call__N)	r   r   r   r   r   r    r   r   r   r
   r
   r
   r   r   <  s   r   Fc             C   s   t  rl t rl | r$ t } t j } n! |  r9 t } t } n t } t } t d d | | t  } t  |  } n6 t d |  d |  } t  r t  |  } n t	 |  } | | f S)zgetparser() -> parser, unmarshaller

    Create an instance of the fastest available parser, and attach it
    to an unmarshalling object.  Return both objects.
    TFr   r   )

FastParserFastUnmarshallerrF   rK   rL   rP   rE   r"   r   rQ   )r   r   Z
mkdatetimeZmkbytesrW   rX   r
   r
   r   	getparserk  s     	r   c             C   s  t  |  t t f  s! t d   t  |  t  r9 d } n3 | rl t  |  t  rl t |   d k sl t d   | sx d } t r t |  } n t | |  } | j |   } | d k r d t |  } n d } | r | d | d | d	 f } n | r| d
 | d f } n | Sd j	 |  S)a  data [,options] -> marshalled data

    Convert an argument tuple or a Fault instance to an XML-RPC
    request (or response, if the methodresponse option is used).

    In addition to the data object, the following options can be given
    as keyword arguments:

        methodname: the method name for a methodCall packet

        methodresponse: true to create a methodResponse packet.
        If this option is used with a tuple, the tuple must be
        a singleton (i.e. it can contain only one element).

        encoding: the packet encoding (default is UTF-8)

    All byte strings in the data structure are assumed to use the
    packet encoding.  Unicode strings are automatically converted,
    where necessary.
    z(argument must be tuple or Fault instancer   z"response tuple must be a singletonzutf-8z$<?xml version='1.0' encoding='%s'?>
z<?xml version='1.0'?>
z<methodCall>
<methodName>z</methodName>
z</methodCall>
z<methodResponse>
z</methodResponse>
ra   )
r+   r,   r"   AssertionErrorr   FastMarshallerr^   ri   r0   rd   )r   
methodnameZmethodresponserY   r`   mr@   Z	xmlheaderr
   r
   r   ri     s6    !	ri   c             C   sH   t  d | d |  \ } } | j |   | j   | j   | j   f S)zdata -> unmarshalled data, method name

    Convert an XML-RPC packet to unmarshalled data plus a method
    name (None if not present).

    If the XML-RPC packet represents a fault condition, this function
    raises a Fault exception.
    r   r   )r   r[   r]   r   )r@   r   r   pur
   r
   r   loads  s    	
r   c          	   C   sT   t  s t  t   } t  j d d d | d d   } | j |   Wd QRX| j   S)zhdata -> gzip encoded data

    Encode data using the gzip content encoding as described in RFC 1952
    modewbfileobjZcompresslevelr   N)gzipNotImplementedErrorr   GzipFilerB   getvalue)r@   rp   gzfr
   r
   r   gzip_encode  s    	!r   i  @c             C   s   t  s t  t  j d d d t |    Z } y2 | d k  rK | j   } n | j | d  } Wn t k
 r t d   Yn XWd QRX| d k r t |  | k r t d   | S)	zrgzip encoded data -> unencoded data

    Decode data using the gzip content encoding as described in RFC 1952
    r   rbr   r   r   zinvalid dataNz#max gzipped payload length exceeded)r   r   r   r   readOSErrorr   r   )r@   Z
max_decoder   Zdecodedr
   r
   r   gzip_decode  s    !r   c               @   s.   e  Z d  Z d Z d d   Z d d   Z d S)GzipDecodedResponsezha file-like object to decode a response encoded with the gzip
    method, as described in RFC 1952.
    c             C   sD   t  s t  t | j    |  _ t  j j |  d d d |  j d  S)Nr   r   r   )r   r   r   r   ior   r   )r   responser
   r
   r   r   )  s    zGzipDecodedResponse.__init__c          
   C   s)   z t  j j |   Wd  |  j j   Xd  S)N)r   r   r]   r   )r   r
   r
   r   r]   1  s    zGzipDecodedResponse.closeN)r   r   r   r   r   r]   r
   r
   r
   r   r   %  s   r   c               @   s4   e  Z d  Z d d   Z d d   Z d d   Z d S)_Methodc             C   s   | |  _  | |  _ d  S)N)_Method__send_Method__name)r   sendr   r
   r
   r   r   >  s    	z_Method.__init__c             C   s   t  |  j d |  j | f  S)Nz%s.%s)r   r   r   )r   r   r
   r
   r   r   A  s    z_Method.__getattr__c             G   s   |  j  |  j |  S)N)r   r   )r   r   r
   r
   r   r   C  s    z_Method.__call__N)r   r   r   r   r   r   r
   r
   r
   r   r   ;  s   r   c               @   s   e  Z d  Z d Z d e Z d Z d Z d d d d  Z d d d	  Z	 d d
 d  Z
 d d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d S)	Transportz1Handles an HTTP transaction to an XML-RPC server.zPython-xmlrpc/%sTNFc             C   s(   | |  _  | |  _ d |  _ g  |  _ d  S)N)NN)r   _use_builtin_types_connection_extra_headers)r   r   r   r
   r
   r   r   Z  s    			zTransport.__init__c             C   s   x d D] } y |  j  | | | |  SWq t j j k
 rJ | rF   Yq t k
 r } z/ | s | j t j t j t j f k r   WYd  d  } ~ Xq Xq Wd  S)Nr   r   )r   r   )	single_requesthttpclientZRemoteDisconnectedr   errnoZ
ECONNRESETZECONNABORTEDZEPIPE)r   hosthandlerrequest_bodyverboser}   er
   r
   r   requestj  s    zTransport.requestc             C   s   yM |  j  | | | |  } | j   } | j d k rL | |  _ |  j |  SWn3 t k
 rd   Yn t k
 r |  j     Yn X| j d d  r | j	   t
 | | | j | j t | j      d  S)N   zcontent-lengthra   )send_requestZgetresponseZstatusr   parse_responser"   	Exceptionr]   	getheaderr   r   reasonr   Z
getheaders)r   r   r   r   r   Z	http_connZrespr
   r
   r   r   w  s"    	

zTransport.single_requestc             C   s   t  d |  j d |  j  S)Nr   r   )r   r   r   )r   r
   r
   r   r     s    zTransport.getparserc             C   s   i  } t  | t  r! | \ } } t j j |  \ } } | r t j j |  } t j |  j d  } d j	 | j
    } d d | f g } n g  } | | | f S)Nzutf-8ra   ZAuthorizationzBasic )r+   r,   urllibparseZ	splituserZunquote_to_bytesrK   rN   rA   rd   split)r   r   x509ZauthZextra_headersr
   r
   r   get_host_info  s    zTransport.get_host_infoc             C   sh   |  j  r' | |  j  d k r' |  j  d S|  j |  \ } |  _ } | t j j |  f |  _  |  j  d S)Nr   r   )r   r   r   r   r   ZHTTPConnection)r   r   chostr   r
   r
   r   make_connection  s
    zTransport.make_connectionc             C   s,   |  j  \ } } | r( d |  _  | j   d  S)N)NN)r   r]   )r   r   
connectionr
   r
   r   r]     s    	zTransport.closec             C   s   |  j  |  } |  j d  d   } | r5 | j d  |  j rj t rj | j d | d d | j d
  n | j d |  | j d  | j d	 |  j f  |  j | |  |  j	 | |  | S)Nr   ZPOSTZskip_accept_encodingTAccept-Encodingr   Content-Typetext/xmlz
User-Agent)r   r   )r   r   )
r   r   Zset_debuglevelaccept_gzip_encodingr   Z
putrequestrb   
user_agentsend_headerssend_content)r   r   r   r   debugr   r   r
   r
   r   r     s    zTransport.send_requestc             C   s+   x$ | D] \ } } | j  | |  q Wd  S)N)	putheader)r   r   r   keyvalr
   r
   r   r    s    zTransport.send_headersc             C   ss   |  j  d  k	 rF |  j  t |  k  rF t rF | j d d  t |  } | j d t t |    | j |  d  S)NzContent-Encodingr   zContent-Length)encode_thresholdr   r   r  r   r0   Z
endheaders)r   r   r   r
   r
   r   r     s    zTransport.send_contentc             C   s   t  | d  r? | j d d  d k r6 t |  } qE | } n | } |  j   \ } } xC | j d  } | sp P|  j r t d t |   | j |  qZ W| | k	 r | j	   | j	   | j	   S)Nr   zContent-Encodingra   r   i   zbody:)
r2   r   r   r   r   r   printr   r[   r]   )r   r   streamr   r   r@   r
   r
   r   r     s"    		

zTransport.parse_response)r   r   r   r   __version__r   r   r  r   r   r   r   r   r   r]   r   r  r  r   r
   r
   r
   r   r   L  s   
!r   c                   s@   e  Z d  Z d Z d d d d   f d d Z d d   Z   S)	SafeTransportz2Handles an HTTPS transaction to an XML-RPC server.FcontextNc               s&   t    j d | d |  | |  _ d  S)Nr   r   )superr   r  )r   r   r   r  )r   r
   r   r   2  s    zSafeTransport.__init__c             C   s   |  j  r' | |  j  d k r' |  j  d St t j d  sE t d   |  j |  \ } |  _ } | t j j | d  d |  j | p i  f |  _  |  j  d S)Nr   r   HTTPSConnectionz1your version of http.client doesn't support HTTPSr  )	r   r2   r   r   r   r   r   r  r  )r   r   r   r   r
   r
   r   r   9  s    	!zSafeTransport.make_connection)r   r   r   r   r   r   r
   r
   )r   r   r  /  s   	r  c            
   @   s   e  Z d  Z d Z d d d d d d d d d d Z d d   Z d	 d
   Z d d   Z e Z d d   Z	 d d   Z
 d d   Z d d   Z d S)ServerProxya  uri [,options] -> a logical connection to an XML-RPC server

    uri is the connection point on the server, given as
    scheme://host/target.

    The standard implementation always supports the "http" scheme.  If
    SSL socket support is available (Python 2.0), it also supports
    "https".

    If the target part and the slash preceding it are both omitted,
    "/RPC2" is assumed.

    The following options can be given as keyword arguments:

        transport: a transport factory
        encoding: the request encoding (default is UTF-8)

    All 8-bit strings passed to the server proxy are assumed to use
    the given encoding.
    NFr  c            C   s   t  j j |  \ }	 } |	 d	 k r0 t d   t  j j |  \ |  _ |  _ |  j s` d |  _ | d  k r |	 d k r t }
 d | i } n t }
 i  } |
 d | d | |  } | |  _	 | p d |  _
 | |  _ | |  _ d  S)
Nr   httpszunsupported XML-RPC protocolz/RPC2r  r   r   zutf-8)r   r  )r   r   Z	splittyper   Z	splithost_ServerProxy__host_ServerProxy__handlerr  r   _ServerProxy__transport_ServerProxy__encoding_ServerProxy__verbose_ServerProxy__allow_none)r   Zuri	transportrY   r   r`   r   r   r  r3   r   Zextra_kwargsr
   r
   r   r   n  s&    					zServerProxy.__init__c             C   s   |  j  j   d  S)N)r  r]   )r   r
   r
   r   Z__close  s    zServerProxy.__closec             C   sw   t  | | d |  j d |  j j |  j d  } |  j j |  j |  j | d |  j } t	 |  d k rs | d } | S)NrY   r`   xmlcharrefreplacer   r   r   )
ri   r  r  rD   r  r   r  r  r  r   )r   r   r   r   r   r
   r
   r   Z	__request  s    	
zServerProxy.__requestc             C   s   d |  j  j |  j |  j f S)Nz<%s for %s%s>)r   r   r  r  )r   r
   r
   r   r      s    zServerProxy.__repr__c             C   s   t  |  j |  S)N)r   _ServerProxy__request)r   r   r
   r
   r   r     s    zServerProxy.__getattr__c             C   s=   | d k r |  j  S| d k r& |  j St d | f   d S)z|A workaround to get special attributes on the ServerProxy
           without interfering with the magic __getattr__
        r]   r  zAttribute %r not foundN)_ServerProxy__closer  r\   )r   attrr
   r
   r   r     s
    zServerProxy.__call__c             C   s   |  S)Nr
   )r   r
   r
   r   	__enter__  s    zServerProxy.__enter__c             G   s   |  j    d  S)N)r  )r   r   r
   r
   r   __exit__  s    zServerProxy.__exit__)r   r   r   r   r   r  r  r    r   r   r   r  r  r
   r
   r
   r   r  X  s   	
r  __main__zhttp://localhost:8000ZERROR	   l        il        i   iDiiipiiDiCiBiiii)Tr   rK   sysr-   r   Zhttp.clientr   Zurllib.parser   Zxml.parsersr   r   r   r   r   ImportErrorr   versionr
  ru   rv   ZPARSE_ERRORZSERVER_ERRORZAPPLICATION_ERRORZSYSTEM_ERRORZTRANSPORT_ERRORZNOT_WELLFORMED_ERRORZUNSUPPORTED_ENCODINGZINVALID_ENCODING_CHARZINVALID_XMLRPCZMETHOD_NOT_FOUNDZINVALID_METHOD_PARAMSZINTERNAL_ERRORr   r   r   r!   r"   r   r   ZBooleanZ_day0r%   r'   r.   r/   rE   rF   rG   rP   r   rQ   r^   r   r   r   r   r   r   r   r   ri   r   r   r   r   objectr   r   r   r  r  ZServerr   r   r  ZcurrentTimeZgetCurrentTimerg   ZmultiZgetDatapowaddr   r
   r
   r
   r   <module>   s   
K	#!''	J%)i 
                                                                            Metadata-Version: 1.0
Name: python-apt
Version: 1.1.0.b5
Summary: Python bindings for APT
Home-page: UNKNOWN
Author: APT Development Team
Author-email: deity@lists.debian.org
License: GNU GPL
Description: UNKNOWN
Platform: posix
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           # Copyright:
#   Moshe Zadka (c) 2002
#   Canonical Ltd. (c) 2005 (DebconfCommunicator)
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 
# THIS SOFTWARE IS PROVIDED BY AUTHORS AND CONTRIBUTORS ``AS IS'' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.

from __future__ import print_function

import sys, os
import errno
import re
import subprocess
import fcntl

class DebconfError(Exception):
    pass

LOW, MEDIUM, HIGH, CRITICAL = 'low', 'medium', 'high', 'critical'

class Debconf:

    def __init__(self, title=None, read=None, write=None):
        for command in ('capb set reset title input beginblock endblock go get'
                        ' register unregister subst fset fget previous_module'
                        ' visible purge metaget exist version settitle'
                        ' info progress data').split():
            self.setCommand(command)
        self.read = read or sys.stdin
        self.write = write or sys.stdout
        sys.stdout = sys.stderr
        self.setUp(title)

    def setUp(self, title):
        self.version = self.version(2)
        if self.version[:2] != '2.':
            raise DebconfError(256, "wrong version: %s" % self.version)
        self.capabilities = self.capb().split()
        if title:
            self.title(title)

    def setCommand(self, command):
        setattr(self, command,
               lambda *args, **kw: self.command(command, *args, **kw))

    def command(self, command, *params):
        command = command.upper()
        self.write.write("%s %s\n" % (command, ' '.join(map(str, params))))
        self.write.flush()

        while True:
            try:
                resp = self.read.readline().rstrip('\n')
                break
            except IOError as e:
                if e.errno == errno.EINTR:
                    continue
                else:
                    raise

        if ' ' in resp:
            status, data = resp.split(' ', 1)
        else:
            status, data = resp, ''
        status = int(status)
        if status == 0:
            return data
        elif status == 1:   # unescaped data
            unescaped = ''
            for chunk in re.split(r'(\\.)', data):
                if chunk.startswith('\\') and len(chunk) == 2:
                    if chunk[1] == 'n':
                        unescaped += '\n'
                    else:
                        unescaped += chunk[1]
                else:
                    unescaped += chunk
            return unescaped
        else:
            raise DebconfError(status, data)

    def stop(self):
        self.write.write('STOP\n')
        self.write.flush()

    def forceInput(self, priority, question):
        try:
            self.input(priority, question)
            return 1
        except DebconfError as e:
            if e.args[0] != 30:
                raise
        return 0

    def getBoolean(self, question):
        result = self.get(question)
        return result == 'true'

    def getString(self, question):
        return self.get(question)


class DebconfCommunicator(Debconf, object):
    def __init__(self, owner, title=None, cloexec=False):
        args = ['debconf-communicate', '-fnoninteractive', owner]
        self.dccomm = subprocess.Popen(
            args, stdin=subprocess.PIPE, stdout=subprocess.PIPE,
            close_fds=True, universal_newlines=True)
        super(DebconfCommunicator, self).__init__(title=title,
                                                  read=self.dccomm.stdout,
                                                  write=self.dccomm.stdin)
        if cloexec:
            fcntl.fcntl(self.read.fileno(), fcntl.F_SETFD, fcntl.FD_CLOEXEC)
            fcntl.fcntl(self.write.fileno(), fcntl.F_SETFD, fcntl.FD_CLOEXEC)

    def shutdown(self):
        if self.dccomm is not None:
            self.dccomm.stdin.close()
            self.dccomm.stdout.close()
            self.dccomm.wait()
            self.dccomm = None

    # Don't rely on this; call .shutdown() explicitly.
    def __del__(self):
        try:
            self.shutdown()
        except AttributeError:
            pass


if ('DEBCONF_USE_CDEBCONF' in os.environ and
    os.environ['DEBCONF_USE_CDEBCONF'] != ''):
    _frontEndProgram = '/usr/lib/cdebconf/debconf'
else:
    _frontEndProgram = '/usr/share/debconf/frontend'

def runFrontEnd():
    if 'DEBIAN_HAS_FRONTEND' not in os.environ:
        os.environ['PERL_DL_NONLAZY']='1'
        os.execv(_frontEndProgram, [_frontEndProgram, sys.executable]+sys.argv)


if __name__ == '__main__':
    runFrontEnd()
    db = Debconf()
    db.forceInput(CRITICAL, 'bsdmainutils/calendar_lib_is_not_empty')
    db.go()
    less = db.getBoolean('less/add_mime_handler')
    aptlc = db.getString('apt-listchanges/email-address')
    db.stop()
    print(db.version)
    print(db.capabilities)
    print(less)
    print(aptlc)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             #!/usr/bin/env python
# -*- coding: utf-8 -*-
# auth - authentication key management
#
#  Copyright (c) 2004 Canonical
#  Copyright (c) 2012 Sebastian Heinlein
#
#  Author: Michael Vogt <mvo@debian.org>
#          Sebastian Heinlein <devel@glatzor.de>
#
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License as
#  published by the Free Software Foundation; either version 2 of the
#  License, or (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
#  USA
"""Handle GnuPG keys used to trust signed repositories."""

from __future__ import print_function

import os
import os.path
import shutil
import subprocess
import sys
import tempfile

import apt_pkg
from apt_pkg import gettext as _


class AptKeyError(Exception):
    pass


class TrustedKey(object):

    """Represents a trusted key."""

    def __init__(self, name, keyid, date):
        self.raw_name = name
        # Allow to translated some known keys
        self.name = _(name)
        self.keyid = keyid
        self.date = date

    def __str__(self):
        return "%s\n%s %s" % (self.name, self.keyid, self.date)


def _call_apt_key_script(*args, **kwargs):
    """Run the apt-key script with the given arguments."""
    conf = None
    cmd = [apt_pkg.config.find_file("Dir::Bin::Apt-Key", "/usr/bin/apt-key")]
    cmd.extend(args)
    env = os.environ.copy()
    env["LANG"] = "C"
    env["APT_KEY_DONT_WARN_ON_DANGEROUS_USAGE"] = "1"
    try:
        if apt_pkg.config.find_dir("Dir") != "/":
            # If the key is to be installed into a chroot we have to export the
            # configuration from the chroot to the apt-key script by using
            # a temporary APT_CONFIG file. The apt-key script uses apt-config
            # shell internally
            conf = tempfile.NamedTemporaryFile(
                prefix="apt-key", suffix=".conf")
            conf.write(apt_pkg.config.dump().encode("UTF-8"))
            conf.flush()
            env["APT_CONFIG"] = conf.name
        proc = subprocess.Popen(cmd, env=env, universal_newlines=True,
                                stdin=subprocess.PIPE,
                                stdout=subprocess.PIPE,
                                stderr=subprocess.PIPE)

        content = kwargs.get("stdin", None)
        # py2 needs this encoded, py3.3 will crash if it is
        if sys.version_info.major < 3 and isinstance(content, unicode):
            content = content.encode("utf-8")

        output, stderr = proc.communicate(content)

        if proc.returncode:
            raise AptKeyError(
                "The apt-key script failed with return code %s:\n"
                "%s\n"
                "stdout: %s\n"
                "stderr: %s" % (
                    proc.returncode, " ".join(cmd), output, stderr))
        elif stderr:
            sys.stderr.write(stderr)    # Forward stderr

        return output.strip()
    finally:
        if conf is not None:
            conf.close()


def add_key_from_file(filename):
    """Import a GnuPG key file to trust repositores signed by it.

    Keyword arguments:
    filename -- the absolute path to the public GnuPG key file
    """
    if not os.path.abspath(filename):
        raise AptKeyError("An absolute path is required: %s" % filename)
    if not os.access(filename, os.R_OK):
        raise AptKeyError("Key file cannot be accessed: %s" % filename)
    _call_apt_key_script("add", filename)


def add_key_from_keyserver(keyid, keyserver):
    """Import a GnuPG key file to trust repositores signed by it.

    Keyword arguments:
    keyid -- the long keyid (fingerprint) of the key, e.g.
             A1BD8E9D78F7FE5C3E65D8AF8B48AD6246925553
    keyserver -- the URL or hostname of the key server
    """
    tmp_keyring_dir = tempfile.mkdtemp()
    try:
        _add_key_from_keyserver(keyid, keyserver, tmp_keyring_dir)
    except:
        raise
    finally:
        shutil.rmtree(tmp_keyring_dir)


def _add_key_from_keyserver(keyid, keyserver, tmp_keyring_dir):
    if len(keyid) < (160 / 8):
        raise AptKeyError("Only long keyids (v4, 160bit) are supported")
    # create a temp keyring dir
    tmp_secret_keyring = os.path.join(tmp_keyring_dir, "secring.gpg")
    tmp_keyring = os.path.join(tmp_keyring_dir, "pubring.gpg")
    # default options for gpg
    gpg_default_options = [
        "gpg",
        "--no-default-keyring", "--no-options",
        "--homedir", tmp_keyring_dir,
    ]
    # download the key to a temp keyring first
    res = subprocess.call(gpg_default_options + [
        "--secret-keyring", tmp_secret_keyring,
        "--keyring", tmp_keyring,
        "--keyserver", keyserver,
        "--recv", keyid,
    ])
    if res != 0:
        raise AptKeyError("recv from '%s' failed for '%s'" % (
            keyserver, keyid))
    # FIXME:
    # - with gnupg 1.4.18 the downloaded key is actually checked(!),
    #   i.e. gnupg will not import anything that the server sends
    #   into the keyring, so the below checks are now redundant *if*
    #   gnupg 1.4.18 is used

    # now export again using the long key id (to ensure that there is
    # really only this one key in our keyring) and not someone MITM us
    tmp_export_keyring = os.path.join(tmp_keyring_dir, "export-keyring.gpg")
    res = subprocess.call(gpg_default_options + [
        "--keyring", tmp_keyring,
        "--output", tmp_export_keyring,
        "--export", keyid,
    ])
    if res != 0:
        raise AptKeyError("export of '%s' failed", keyid)
    # now verify the fingerprint, this is probably redundant as we
    # exported by the fingerprint in the previous command but its
    # still good paranoia
    output = subprocess.Popen(
        gpg_default_options + [
            "--keyring", tmp_export_keyring,
            "--fingerprint",
            "--batch",
            "--fixed-list-mode",
            "--with-colons",
        ],
        stdout=subprocess.PIPE,
        universal_newlines=True).communicate()[0]
    got_fingerprint = None
    for line in output.splitlines():
        if line.startswith("fpr:"):
            got_fingerprint = line.split(":")[9]
            # stop after the first to ensure no subkey trickery
            break
    # strip the leading "0x" is there is one and uppercase (as this is
    # what gnupg is using)
    signing_key_fingerprint = keyid.replace("0x", "").upper()
    if got_fingerprint != signing_key_fingerprint:
        # make the error match what gnupg >= 1.4.18 will output when
        # it checks the key itself before importing it
        raise AptKeyError(
            "recv from '%s' failed for '%s'" % (
                keyserver, signing_key_fingerprint))
    # finally add it
    add_key_from_file(tmp_export_keyring)


def add_key(content):
    """Import a GnuPG key to trust repositores signed by it.

    Keyword arguments:
    content -- the content of the GnuPG public key
    """
    _call_apt_key_script("adv", "--quiet", "--batch",
                         "--import", "-", stdin=content)


def remove_key(fingerprint):
    """Remove a GnuPG key to no longer trust repositores signed by it.

    Keyword arguments:
    fingerprint -- the fingerprint identifying the key
    """
    _call_apt_key_script("rm", fingerprint)


def export_key(fingerprint):
    """Return the GnuPG key in text format.

    Keyword arguments:
    fingerprint -- the fingerprint identifying the key
    """
    return _call_apt_key_script("export", fingerprint)


def update():
    """Update the local keyring with the archive keyring and remove from
    the local keyring the archive keys which are no longer valid. The
    archive keyring is shipped in the archive-keyring package of your
    distribution, e.g. the debian-archive-keyring package in Debian.
    """
    return _call_apt_key_script("update")


def net_update():
    """Work similar to the update command above, but get the archive
    keyring from an URI instead and validate it against a master key.
    This requires an installed wget(1) and an APT build configured to
    have a server to fetch from and a master keyring to validate. APT
    in Debian does not support this command and relies on update
    instead, but Ubuntu's APT does.
    """
    return _call_apt_key_script("net-update")


def list_keys():
    """Returns a list of TrustedKey instances for each key which is
    used to trust repositories.
    """
    # The output of `apt-key list` is difficult to parse since the
    # --with-colons parameter isn't user
    output = _call_apt_key_script("adv", "--with-colons", "--batch",
                                  "--fixed-list-mode", "--list-keys")
    res = []
    for line in output.split("\n"):
        fields = line.split(":")
        if fields[0] == "pub":
            keyid = fields[4]
        if fields[0] == "uid":
            uid = fields[9]
            creation_date = fields[5]
            key = TrustedKey(uid, keyid, creation_date)
            res.append(key)
    return res

if __name__ == "__main__":
    # Add some known keys we would like to see translated so that they get
    # picked up by gettext
    lambda: _("Ubuntu Archive Automatic Signing Key <ftpmaster@ubuntu.com>")
    lambda: _("Ubuntu CD Image Automatic Signing Key <cdimage@ubuntu.com>")

    apt_pkg.init()
    for trusted_key in list_keys():
        print(trusted_key)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     # cdrom.py - CDROM handling
#
#  Copyright (c) 2005-2009 Canonical
#  Copyright (c) 2009 Julian Andres Klode <jak@debian.org>
#
#  Author: Michael Vogt <michael.vogt@ubuntu.com>
#
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License as
#  published by the Free Software Foundation; either version 2 of the
#  License, or (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
#  USA
"""Classes related to cdrom handling."""
from __future__ import print_function

import glob

import apt_pkg
from apt.progress.base import CdromProgress


class Cdrom(apt_pkg.Cdrom):
    """Support for apt-cdrom like features.

    This class has several optional parameters for initialisation, which may
    be used to influence the behaviour of the object:

    The optional parameter `progress` is a CdromProgress() subclass, which will
    ask for the correct cdrom, etc. If not specified or None, a CdromProgress()
    object will be used.

    The optional parameter `mountpoint` may be used to specify an alternative
    mountpoint.

    If the optional parameter `nomount` is True, the cdroms will not be
    mounted. This is the default behaviour.
    """

    def __init__(self, progress=None, mountpoint=None, nomount=True):
        apt_pkg.Cdrom.__init__(self)
        if progress is None:
            self._progress = CdromProgress()
        else:
            self._progress = progress
        # see if we have a alternative mountpoint
        if mountpoint is not None:
            apt_pkg.config.set("Acquire::cdrom::mount", mountpoint)
        # do not mess with mount points by default
        if nomount:
            apt_pkg.config.set("APT::CDROM::NoMount", "true")
        else:
            apt_pkg.config.set("APT::CDROM::NoMount", "false")

    def add(self, progress=None):
        """Add cdrom to the sources.list."""
        return apt_pkg.Cdrom.add(self, progress or self._progress)

    def ident(self, progress=None):
        """Identify the cdrom."""
        return apt_pkg.Cdrom.ident(self, progress or self._progress)

    @property
    def in_sources_list(self):
        """Check if the cdrom is already in the current sources.list."""
        cd_id = self.ident()
        if cd_id is None:
            # FIXME: throw exception instead
            return False
        # Get a list of files
        src = glob.glob(apt_pkg.config.find_dir("Dir::Etc::sourceparts") + '*')
        src.append(apt_pkg.config.find_file("Dir::Etc::sourcelist"))
        # Check each file
        for fname in src:
            with open(fname) as fobj:
                for line in fobj:
                    if not line.lstrip().startswith("#") and cd_id in line:
                        return True
        return False
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            
[                  @   s  d  Z  d d l m Z m Z m Z m Z m Z d d l m Z d d l Z	 d d l
 Z
 d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z y d d l Z Wn e k
 r d Z Yn Xd d d  Z d d	   Z Gd
 d   d  Z Gd d   d e  Z Gd d   d e
 j e  Z Gd d   d e  Z Gd d   d e  Z Gd d   d e j  Z Gd d   d  Z Gd d   d e  Z Gd d   d e e  Z Gd d   d e e  Z  e! d k rd d l" Z" Gd d    d   Z# e d! d" f  Z$ e$ j% e&  e$ j% d# d$   d%  e$ j' e#   d& d e$ j(   e) d'  e) d(  y e$ j*   Wn3 e+ k
 re) d)  e$ j,   e j- d  Yn Xd S)*a  XML-RPC Servers.

This module can be used to create simple XML-RPC servers
by creating a server and either installing functions, a
class instance, or by extending the SimpleXMLRPCServer
class.

It can also be used to handle XML-RPC requests in a CGI
environment using CGIXMLRPCRequestHandler.

The Doc* classes can be used to create XML-RPC servers that
serve pydoc-style documentation in response to HTTP
GET requests. This documentation is dynamically generated
based on the functions and methods registered with the
server.

A list of possible usage patterns follows:

1. Install functions:

server = SimpleXMLRPCServer(("localhost", 8000))
server.register_function(pow)
server.register_function(lambda x,y: x+y, 'add')
server.serve_forever()

2. Install an instance:

class MyFuncs:
    def __init__(self):
        # make all of the sys functions available through sys.func_name
        import sys
        self.sys = sys
    def _listMethods(self):
        # implement this method so that system.listMethods
        # knows to advertise the sys methods
        return list_public_methods(self) + \
                ['sys.' + method for method in list_public_methods(self.sys)]
    def pow(self, x, y): return pow(x, y)
    def add(self, x, y) : return x + y

server = SimpleXMLRPCServer(("localhost", 8000))
server.register_introspection_functions()
server.register_instance(MyFuncs())
server.serve_forever()

3. Install an instance with custom dispatch method:

class Math:
    def _listMethods(self):
        # this method must be present for system.listMethods
        # to work
        return ['add', 'pow']
    def _methodHelp(self, method):
        # this method must be present for system.methodHelp
        # to work
        if method == 'add':
            return "add(2,3) => 5"
        elif method == 'pow':
            return "pow(x, y[, z]) => number"
        else:
            # By convention, return empty
            # string if no help is available
            return ""
    def _dispatch(self, method, params):
        if method == 'pow':
            return pow(*params)
        elif method == 'add':
            return params[0] + params[1]
        else:
            raise ValueError('bad method')

server = SimpleXMLRPCServer(("localhost", 8000))
server.register_introspection_functions()
server.register_instance(Math())
server.serve_forever()

4. Subclass SimpleXMLRPCServer:

class MathServer(SimpleXMLRPCServer):
    def _dispatch(self, method, params):
        try:
            # We are forcing the 'export_' prefix on methods that are
            # callable through XML-RPC to prevent potential security
            # problems
            func = getattr(self, 'export_' + method)
        except AttributeError:
            raise Exception('method "%s" is not supported' % method)
        else:
            return func(*params)

    def export_add(self, x, y):
        return x + y

server = MathServer(("localhost", 8000))
server.serve_forever()

5. CGI script:

server = CGIXMLRPCRequestHandler()
server.register_function(pow)
server.handle_request()
    )Faultdumpsloadsgzip_encodegzip_decode)BaseHTTPRequestHandlerNTc             C   sg   | r | j  d  } n	 | g } x? | D]7 } | j d  rP t d |   q( t |  |  }  q( W|  S)aG  resolve_dotted_attribute(a, 'b.c.d') => a.b.c.d

    Resolves a dotted attribute name to an object.  Raises
    an AttributeError if any attribute in the chain starts with a '_'.

    If the optional allow_dotted_names argument is false, dots are not
    supported and this function operates similar to getattr(obj, attr).
    ._z(attempt to access private attribute "%s")split
startswithAttributeErrorgetattr)objattrallow_dotted_namesZattrsi r   #/usr/lib/python3.5/xmlrpc/server.pyresolve_dotted_attributez   s    
	r   c                s     f d d   t     D S)zkReturns a list of attribute strings, found in the specified
    object, which represent callable attributesc                s;   g  |  ]1 } | j  d   r t t   |   r |  q S)r	   )r   callabler   ).0Zmember)r   r   r   
<listcomp>   s   	 z'list_public_methods.<locals>.<listcomp>)dir)r   r   )r   r   list_public_methods   s    r   c               @   s   e  Z d  Z d Z d d d d d  Z d d d  Z d d d	  Z d
 d   Z d d   Z d d d d  Z	 d d   Z
 d d   Z d d   Z d d   Z d d   Z d S)SimpleXMLRPCDispatchera&  Mix-in class that dispatches XML-RPC requests.

    This class is used to register XML-RPC method handlers
    and then to dispatch them. This class doesn't need to be
    instanced directly when used by SimpleXMLRPCServer but it
    can be instanced when used by the MultiPathXMLRPCServer
    FNc             C   s7   i  |  _  d  |  _ | |  _ | p$ d |  _ | |  _ d  S)Nzutf-8)funcsinstance
allow_noneencodinguse_builtin_types)selfr   r   r   r   r   r   __init__   s
    			zSimpleXMLRPCDispatcher.__init__c             C   s   | |  _  | |  _ d S)a  Registers an instance to respond to XML-RPC requests.

        Only one instance can be installed at a time.

        If the registered instance has a _dispatch method then that
        method will be called with the name of the XML-RPC method and
        its parameters as a tuple
        e.g. instance._dispatch('add',(2,3))

        If the registered instance does not have a _dispatch method
        then the instance will be searched to find a matching method
        and, if found, will be called. Methods beginning with an '_'
        are considered private and will not be called by
        SimpleXMLRPCServer.

        If a registered function matches an XML-RPC request, then it
        will be called instead of the registered instance.

        If the optional allow_dotted_names argument is true and the
        instance does not have a _dispatch method, method names
        containing dots are supported and resolved, as long as none of
        the name segments start with an '_'.

            *** SECURITY WARNING: ***

            Enabling the allow_dotted_names options allows intruders
            to access your module's global variables and may allow
            intruders to execute arbitrary code on your machine.  Only
            use this option on a secure, closed network.

        N)r   r   )r    r   r   r   r   r   register_instance   s    !	z(SimpleXMLRPCDispatcher.register_instancec             C   s&   | d k r | j  } | |  j | <d S)zRegisters a function to respond to XML-RPC requests.

        The optional name argument can be used to set a Unicode name
        for the function.
        N)__name__r   )r    Zfunctionnamer   r   r   register_function   s    	z(SimpleXMLRPCDispatcher.register_functionc             C   s/   |  j  j d |  j d |  j d |  j i  d S)zRegisters the XML-RPC introspection methods in the system
        namespace.

        see http://xmlrpc.usefulinc.com/doc/reserved.html
        zsystem.listMethodszsystem.methodSignaturezsystem.methodHelpN)r   updatesystem_listMethodssystem_methodSignaturesystem_methodHelp)r    r   r   r    register_introspection_functions   s    	z7SimpleXMLRPCDispatcher.register_introspection_functionsc             C   s   |  j  j d |  j i  d S)zRegisters the XML-RPC multicall method in the system
        namespace.

        see http://www.xmlrpc.com/discuss/msgReader$1208zsystem.multicallN)r   r&   system_multicall)r    r   r   r   register_multicall_functions   s    z3SimpleXMLRPCDispatcher.register_multicall_functionsc             C   s"  y| t  | d |  j \ } } | d k	 r< | | |  } n |  j | |  } | f } t | d d d |  j d |  j } Wn t k
 r } z# t | d |  j d |  j } WYd d } ~ XnN t j   \ } }	 }
 t t d d | |	 f  d |  j d |  j } Yn X| j	 |  j d  S)	a  Dispatches an XML-RPC method from marshalled (XML) data.

        XML-RPC methods are dispatched from the marshalled (XML) data
        using the _dispatch method and the result is returned as
        marshalled data. For backwards compatibility, a dispatch
        function can be provided as an argument (see comment in
        SimpleXMLRPCRequestHandler.do_POST) but overriding the
        existing method through subclassing is the preferred means
        of changing method dispatch behavior.
        r   NZmethodresponse   r   r   z%s:%sxmlcharrefreplace)
r   r   	_dispatchr   r   r   r   sysexc_infoencode)r    datadispatch_methodpathparamsmethodresponsefaultexc_type	exc_valueexc_tbr   r   r   _marshaled_dispatch   s"    	z*SimpleXMLRPCDispatcher._marshaled_dispatchc             C   s   t  |  j j    } |  j d k	 r} t |  j d  rR | t  |  j j    O} n+ t |  j d  s} | t  t |  j   O} t |  S)zwsystem.listMethods() => ['add', 'subtract', 'multiple']

        Returns a list of the methods supported by the server.N_listMethodsr/   )setr   keysr   hasattrr>   r   sorted)r    methodsr   r   r   r'     s    z)SimpleXMLRPCDispatcher.system_listMethodsc             C   s   d S)a#  system.methodSignature('add') => [double, int, int]

        Returns a list describing the signature of the method. In the
        above example, the add method takes two integers as arguments
        and returns a double result.

        This server does NOT support system.methodSignature.zsignatures not supportedr   )r    method_namer   r   r   r(   $  s    z-SimpleXMLRPCDispatcher.system_methodSignaturec             C   s   d } | |  j  k r% |  j  | } nt |  j d k	 r t |  j d  rV |  j j |  St |  j d  s y t |  j | |  j  } Wn t k
 r Yn X| d k r d St j |  Sd S)zsystem.methodHelp('add') => "Adds two integers together"

        Returns a string containing documentation for the specified method.N_methodHelpr/    )	r   r   rA   rE   r   r   r   pydocgetdoc)r    rD   r7   r   r   r   r)   1  s"    z(SimpleXMLRPCDispatcher.system_methodHelpc       
      C   s   g  } x | D] } | d } | d } y  | j  |  j | |  g  Wq t k
 r } z$ | j  d | j d | j i  WYd d } ~ Xq t j   \ } } }	 | j  d d d d | | f i  Yq Xq W| S)zsystem.multicall([{'methodName': 'add', 'params': [2, 2]}, ...]) => [[4], ...]

        Allows the caller to package multiple XML-RPC calls into a single
        request.

        See http://www.xmlrpc.com/discuss/msgReader$1208
        Z
methodNamer6   	faultCodefaultStringNr-   z%s:%s)appendr/   r   rI   rJ   r0   r1   )
r    Z	call_listresultsZcallrD   r6   r9   r:   r;   r<   r   r   r   r+   P  s     


 	" z'SimpleXMLRPCDispatcher.system_multicallc             C   s   d } y |  j  | } Wnw t k
 r |  j d k	 r t |  j d  r[ |  j j | |  Sy t |  j | |  j  } Wn t k
 r Yn XYn X| d k	 r | |   St d |   d S)a  Dispatches the XML-RPC method.

        XML-RPC calls are forwarded to a registered function that
        matches the called XML-RPC method name. If no such function
        exists then the call is forwarded to the registered instance,
        if available.

        If the registered instance has a _dispatch method then that
        method will be called with the name of the XML-RPC method and
        its parameters as a tuple
        e.g. instance._dispatch('add',(2,3))

        If the registered instance does not have a _dispatch method
        then the instance will be searched to find a matching method
        and, if found, will be called.

        Methods beginning with an '_' are considered private and will
        not be called.
        Nr/   zmethod "%s" is not supported)	r   KeyErrorr   rA   r/   r   r   r   	Exception)r    r7   r6   funcr   r   r   r/   p  s"    

z SimpleXMLRPCDispatcher._dispatch)r#   
__module____qualname____doc__r!   r"   r%   r*   r,   r=   r'   r(   r)   r+   r/   r   r   r   r   r      s   $% r   c               @   s   e  Z d  Z d Z d Z d Z d Z d Z e j	 d e j
 e j B Z d d	   Z d
 d   Z d d   Z d d   Z d d   Z d d d d  Z d S)SimpleXMLRPCRequestHandlerzSimple XML-RPC request handler class.

    Handles all HTTP POST requests and attempts to decode them as
    XML-RPC requests.
    //RPC2ix  r-   Tz
                            \s* ([^\s;]+) \s*            #content-coding
                            (;\s* q \s*=\s* ([0-9\.]+))? #q
                            c             C   s   i  } |  j  j d d  } xi | j d  D]X } |  j j |  } | r+ | j d  } | rj t |  n d } | | | j d  <q+ W| S)NzAccept-EncodingrF   ,   g      ?r-   )headersgetr
   	aepatternmatchgroupfloat)r    rZaeer[   vr   r   r   accept_encodings  s    z+SimpleXMLRPCRequestHandler.accept_encodingsc             C   s!   |  j  r |  j |  j  k Sd Sd  S)NT)	rpc_pathsr5   )r    r   r   r   is_rpc_path_valid  s    	z,SimpleXMLRPCRequestHandler.is_rpc_path_validc             C   sp  |  j    s |  j   d Sy d } t |  j d  } g  } xS | r t | |  } |  j j |  } | sm P| j |  | t | d  8} q? Wd j	 |  } |  j
 |  } | d k r d S|  j j | t |  d d  |  j  } Wn t k
 r} z |  j d  t |  j d	  ru|  j j ru|  j d
 t |   t j   }	 t |	 j d d  d  }	 |  j d |	  |  j d d  |  j   WYd d } ~ Xn X|  j d  |  j d d  |  j d k	 r6t |  |  j k r6|  j   j d d  }
 |
 r6y  t |  } |  j d d  Wn t k
 r5Yn X|  j d t t |    |  j   |  j j |  d S)zHandles the HTTP POST request.

        Attempts to interpret all HTTP POST requests as XML-RPC calls,
        which are forwarded to the server's _dispatch method for handling.
        N
   i   zcontent-lengthr-       r/   i  _send_traceback_headerzX-exceptionASCIIbackslashreplacezX-tracebackzContent-length0   zContent-typeztext/xmlgzipr   zContent-Encodingi (  i   ) rc   
report_404intrX   minZrfilereadrK   lenjoindecode_request_contentserverr=   r   r5   rN   send_responserA   rf   send_headerstr	traceback
format_excr2   end_headersencode_thresholdra   rY   r   NotImplementedErrorwfilewrite)r    Zmax_chunk_sizeZsize_remainingLZ
chunk_sizechunkr3   r8   r_   Ztraceqr   r   r   do_POST  sX    
		"
z"SimpleXMLRPCRequestHandler.do_POSTc             C   s   |  j  j d d  j   } | d k r+ | S| d k r y t |  SWq t k
 rm |  j d d |  Yq t k
 r |  j d d  Yq Xn |  j d d |  |  j d d	  |  j   d  S)
Nzcontent-encodingZidentityrk   i  zencoding %r not supportedi  zerror decoding gzip contentzContent-lengthri   )	rX   rY   lowerr   r|   ru   
ValueErrorrv   rz   )r    r3   r   r   r   r   rs     s    z1SimpleXMLRPCRequestHandler.decode_request_contentc             C   s]   |  j  d  d } |  j d d  |  j d t t |    |  j   |  j j |  d  S)Ni  s   No such pagezContent-typez
text/plainzContent-length)ru   rv   rw   rq   rz   r}   r~   )r    r8   r   r   r   rm   !  s    
z%SimpleXMLRPCRequestHandler.report_404-c             C   s#   |  j  j r t j |  | |  d S)z$Selectively log an accepted request.N)rt   logRequestsr   log_request)r    codesizer   r   r   r   *  s    z&SimpleXMLRPCRequestHandler.log_requestN)rT   rU   rl   )r#   rP   rQ   rR   rb   r{   ZwbufsizeZdisable_nagle_algorithmrecompileVERBOSE
IGNORECASErZ   ra   rc   r   rs   rm   r   r   r   r   r   rS     s   G	rS   c               @   s@   e  Z d  Z d Z d Z d Z e d d d d d d d  Z d S)SimpleXMLRPCServerag  Simple XML-RPC server.

    Simple XML-RPC server that allows functions and a single instance
    to be installed to handle requests. The default implementation
    attempts to dispatch XML-RPC calls to the functions or instance
    installed in the server. Override the _dispatch method inherited
    from SimpleXMLRPCDispatcher to change this behavior.
    TFNc             C   s<   | |  _  t j |  | | |  t j j |  | | |  d  S)N)r   r   r!   socketserver	TCPServer)r    addrrequestHandlerr   r   r   bind_and_activater   r   r   r   r!   C  s    	zSimpleXMLRPCServer.__init__)r#   rP   rQ   rR   Zallow_reuse_addressrf   rS   r!   r   r   r   r   r   0  s   		r   c               @   s^   e  Z d  Z d Z e d d d d d d d  Z d d   Z d	 d
   Z d d d d  Z d S)MultiPathXMLRPCServera\  Multipath XML-RPC Server
    This specialization of SimpleXMLRPCServer allows the user to create
    multiple Dispatcher instances and assign them to different
    HTTP request paths.  This makes it possible to run two or more
    'virtual XML-RPC servers' at the same port.
    Make sure that the requestHandler accepts the paths in question.
    TFNc          	   C   sG   t  j |  | | | | | | |  i  |  _ | |  _ | p= d |  _ d  S)Nzutf-8)r   r!   dispatchersr   r   )r    r   r   r   r   r   r   r   r   r   r   r!   T  s
    		zMultiPathXMLRPCServer.__init__c             C   s   | |  j  | <| S)N)r   )r    r5   Z
dispatcherr   r   r   add_dispatcher^  s    z$MultiPathXMLRPCServer.add_dispatcherc             C   s   |  j  | S)N)r   )r    r5   r   r   r   get_dispatcherb  s    z$MultiPathXMLRPCServer.get_dispatcherc             C   s   y  |  j  | j | | |  } Wnj t j   d  d  \ } } t t d d | | f  d |  j d |  j } | j |  j d  } Yn X| S)N   r-   z%s:%sr   r   r.   )	r   r=   r0   r1   r   r   r   r   r2   )r    r3   r4   r5   r8   r:   r;   r   r   r   r=   e  s    z)MultiPathXMLRPCServer._marshaled_dispatch)	r#   rP   rQ   rR   rS   r!   r   r   r=   r   r   r   r   r   L  s   	r   c               @   sR   e  Z d  Z d Z d d d d d  Z d d   Z d d	   Z d d
 d  Z d S)CGIXMLRPCRequestHandlerz3Simple handler for XML-RPC data passed through CGI.FNc             C   s   t  j |  | | |  d  S)N)r   r!   )r    r   r   r   r   r   r   r!   w  s    z CGIXMLRPCRequestHandler.__init__c             C   sh   |  j  |  } t d  t d t |   t   t j j   t j j j |  t j j j   d S)zHandle a single XML-RPC requestzContent-Type: text/xmlzContent-Length: %dN)r=   printrq   r0   stdoutflushbufferr~   )r    request_textr8   r   r   r   handle_xmlrpcz  s    
z%CGIXMLRPCRequestHandler.handle_xmlrpcc             C   s   d } t  j | \ } } t j j d | d | d | i } | j d  } t d | | f  t d t j j  t d t |   t   t	 j
 j   t	 j
 j j |  t	 j
 j j   d	 S)
zHandle a single HTTP GET request.

        Default implementation indicates an error because
        XML-RPC uses the POST method.
        i  r   messageexplainzutf-8zStatus: %d %szContent-Type: %szContent-Length: %dN)r   Z	responseshttprt   ZDEFAULT_ERROR_MESSAGEr2   r   ZDEFAULT_ERROR_CONTENT_TYPErq   r0   r   r   r   r~   )r    r   r   r   r8   r   r   r   
handle_get  s    	z"CGIXMLRPCRequestHandler.handle_getc             C   s   | d k r4 t  j j d d  d k r4 |  j   nk y t t  j j d d   } Wn t t f k
 rs d } Yn X| d k r t j j	 |  } |  j
 |  d S)zHandle a single XML-RPC request passed through a CGI post method.

        If no XML data is given then it is read from stdin. The resulting
        XML-RPC response is printed to stdout along with the correct HTTP
        headers.
        NZREQUEST_METHODZGETZCONTENT_LENGTHr-   rl   )osenvironrY   r   rn   r   	TypeErrorr0   stdinrp   r   )r    r   Zlengthr   r   r   handle_request  s    z&CGIXMLRPCRequestHandler.handle_request)r#   rP   rQ   rR   r!   r   r   r   r   r   r   r   r   t  s
   r   c               @   sU   e  Z d  Z d Z d i  i  i  d d  Z d i  i  i  d d d  Z d d   Z d S)	ServerHTMLDocz7Class used to generate pydoc HTML document for a serverNc             C   s  | p |  j  } g  } d } t j d  } x| j | |  }	 |	 sF P|	 j   \ }
 } | j | | | |
    |	 j   \ } } } } } } | r | |  j d d  } | j d | | f  n | rd t |  } | j d | | |  f  n | r7d t |  } | j d | | |  f  no | | | d  d	 k rs| j |  j	 | | | |   n3 | r| j d
 |  n | j |  j	 | |   | } q- W| j | | | d    d j
 |  S)zMark up some plain text, given a context of symbols to look for.
        Each context dictionary maps object names to anchor names.r   zM\b((http|ftp)://\S+[\w/]|RFC[- ]?(\d+)|PEP[- ]?(\d+)|(self\.)?((?:\w|\.)+))\b"z&quot;z<a href="%s">%s</a>z'http://www.rfc-editor.org/rfc/rfc%d.txtz(http://www.python.org/dev/peps/pep-%04d/r-   (zself.<strong>%s</strong>NrF   )escaper   r   searchspanrK   groupsreplacern   Znamelinkrr   )r    textr   r   classesrC   rL   herepatternr[   startendallZschemeZrfcZpepZselfdotr$   Zurlr   r   r   markup  s8       "
zServerHTMLDoc.markupc          	   C   s  | r | j  p d d | } d }	 d |  j |  |  j |  f }
 t j |  r t j |  } t j | j d d  | j | j | j	 d | j
 d |  j } n] t j |  r t j |  } t j | j | j | j | j	 d | j
 d |  j } n d } t | t  r5| d	 p| } | d p/d } n t j |  } |
 | |	 oa|  j d
 |	  } |  j | |  j | | |  } | od | } d | | f S)z;Produce HTML documentation for a function or method object.rF   r   z$<a name="%s"><strong>%s</strong></a>r-   Nannotationsformatvaluez(...)r   z'<font face="helvetica, arial">%s</font>z<dd><tt>%s</tt></dd>z<dl><dt>%s</dt>%s</dl>
)r#   r   inspectZismethodZgetfullargspecZformatargspecargsZvarargsZvarkwZdefaultsr   r   Z
isfunction
isinstancetuplerG   rH   Zgreyr   	preformat)r    objectr$   modr   r   rC   ZclZanchorZnotetitler   ZargspecZ	docstringZdecldocr   r   r   
docroutine  s<    			zServerHTMLDoc.docroutinec             C   s  i  } x6 | j    D]( \ } } d | | | <| | | | <q W|  j |  } d | } |  j | d d  } |  j | |  j |  }	 |	 o d |	 }	 | d |	 } g  }
 t | j     } x3 | D]+ \ } } |
 j |  j | | d |  q W| |  j d d d	 d
 j	 |
   } | S)z1Produce HTML documentation for an XML-RPC server.z#-z)<big><big><strong>%s</strong></big></big>z#ffffffz#7799eez<tt>%s</tt>z
<p>%s</p>
r   ZMethodsz#eeaa77rF   )
itemsr   Zheadingr   r   rB   rK   r   Z
bigsectionrr   )r    server_nameZpackage_documentationrC   Zfdictkeyvalueheadresultr   contentsZmethod_itemsr   r   r   	docserver  s"    
#	zServerHTMLDoc.docserver)r#   rP   rQ   rR   r   r   r   r   r   r   r   r     s
   ),r   c               @   sR   e  Z d  Z d Z d d   Z d d   Z d d   Z d d	   Z d
 d   Z d S)XMLRPCDocGeneratorzGenerates documentation for an XML-RPC server.

    This class is designed as mix-in and should not
    be constructed directly.
    c             C   s   d |  _  d |  _ d |  _ d  S)NzXML-RPC Server DocumentationzGThis server exports the following methods through the XML-RPC protocol.)r   server_documentationserver_title)r    r   r   r   r!   2  s    		zXMLRPCDocGenerator.__init__c             C   s   | |  _  d S)z8Set the HTML title of the generated server documentationN)r   )r    r   r   r   r   set_server_title:  s    z#XMLRPCDocGenerator.set_server_titlec             C   s   | |  _  d S)z7Set the name of the generated HTML server documentationN)r   )r    r   r   r   r   set_server_name?  s    z"XMLRPCDocGenerator.set_server_namec             C   s   | |  _  d S)z3Set the documentation string for the entire server.N)r   )r    r   r   r   r   set_server_documentationD  s    z+XMLRPCDocGenerator.set_server_documentationc             C   sj  i  } x*|  j    D]} | |  j k r8 |  j | } n |  j d k	 rd d g } t |  j d  r{ |  j j |  | d <t |  j d  r |  j j |  | d <t |  } | d k r | } q%t |  j d  s
y t |  j |  } Wqt k
 r| } YqXq%| } n d s%t	 d   | | | <q Wt
   } | j |  j |  j |  } | j |  j |  S)	a  generate_html_documentation() => html documentation for the server

        Generates HTML documentation for the server using introspection for
        installed functions and instances that do not implement the
        _dispatch method. Alternatively, instances can choose to implement
        the _get_method_argstring(method_name) method to provide the
        argument string used in the documentation and the
        _methodHelp(method_name) method to provide the help text used
        in the documentation.N_get_method_argstringr   rE   r-   r/   zACould not find method in self.functions and no instance installed)NN)r'   r   r   rA   r   rE   r   r   r   AssertionErrorr   r   r   r   Zpager   )r    rC   rD   r7   Zmethod_infoZ
documenterZdocumentationr   r   r   generate_html_documentationI  s:    				z.XMLRPCDocGenerator.generate_html_documentationN)	r#   rP   rQ   rR   r!   r   r   r   r   r   r   r   r   r   +  s   r   c               @   s"   e  Z d  Z d Z d d   Z d S)DocXMLRPCRequestHandlerzXML-RPC and documentation request handler class.

    Handles all HTTP POST requests and attempts to decode them as
    XML-RPC requests.

    Handles all HTTP GET requests and interprets them as requests
    for documentation.
    c             C   s   |  j    s |  j   d S|  j j   j d  } |  j d  |  j d d  |  j d t t |    |  j	   |  j
 j |  d S)z}Handles the HTTP GET request.

        Interpret all HTTP GET requests as requests for server
        documentation.
        Nzutf-8rj   zContent-typez	text/htmlzContent-length)rc   rm   rt   r   r2   ru   rv   rw   rq   rz   r}   r~   )r    r8   r   r   r   do_GET  s    

zDocXMLRPCRequestHandler.do_GETN)r#   rP   rQ   rR   r   r   r   r   r   r   |  s   r   c               @   s4   e  Z d  Z d Z e d d d d d d d  Z d S)DocXMLRPCServerzXML-RPC and HTML documentation server.

    Adds the ability to serve server documentation to the capabilities
    of SimpleXMLRPCServer.
    TFNc          	   C   s3   t  j |  | | | | | | |  t j |   d  S)N)r   r!   r   )r    r   r   r   r   r   r   r   r   r   r   r!     s    	zDocXMLRPCServer.__init__)r#   rP   rQ   rR   r   r!   r   r   r   r   r     s   	r   c               @   s.   e  Z d  Z d Z d d   Z d d   Z d S)DocCGIXMLRPCRequestHandlerzJHandler for XML-RPC data and documentation requests passed through
    CGIc             C   sn   |  j    j d  } t d  t d t |   t   t j j   t j j j |  t j j j   d S)z}Handles the HTTP GET request.

        Interpret all HTTP GET requests as requests for server
        documentation.
        zutf-8zContent-Type: text/htmlzContent-Length: %dN)	r   r2   r   rq   r0   r   r   r   r~   )r    r8   r   r   r   r     s    
z%DocCGIXMLRPCRequestHandler.handle_getc             C   s   t  j |   t j |   d  S)N)r   r!   r   )r    r   r   r   r!     s    z#DocCGIXMLRPCRequestHandler.__init__N)r#   rP   rQ   rR   r   r!   r   r   r   r   r     s   r   __main__c               @   s/   e  Z d  Z d d   Z Gd d   d  Z d S)ExampleServicec             C   s   d S)NZ42r   )r    r   r   r   getData  s    zExampleService.getDatac               @   s"   e  Z d  Z e d d    Z d S)zExampleService.currentTimec               C   s   t  j  j   S)N)datetimeZnowr   r   r   r   getCurrentTime  s    z)ExampleService.currentTime.getCurrentTimeN)r#   rP   rQ   staticmethodr   r   r   r   r   currentTime  s   r   N)r#   rP   rQ   r   r   r   r   r   r   r     s   r   Z	localhosti@  c             C   s   |  | S)Nr   )xyr   r   r   <lambda>  s    r   addr   z&Serving XML-RPC on localhost port 8000zKIt is advisable to run this example server within a secure, closed network.z&
Keyboard interrupt received, exiting.).rR   Zxmlrpc.clientr   r   r   r   r   Zhttp.serverr   r   r   r0   r   r   rG   r   rx   ZfcntlImportErrorr   r   r   rS   r   r   r   r   ZHTMLDocr   r   r   r   r   r#   r   r   rt   r%   powr"   r,   r   Zserve_foreverKeyboardInterruptZserver_closeexitr   r   r   r   <module>f   s\   ( 	(ErQ			




                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ELF          (    *  4       4    (     pD~  D~  D~  p  p                                        
  
               (  (                 $   $         Qtd                          Rtd    ,  ,                 GNU 0<a:#]!@N   j            R.@`uD }0Lj           k   l   m           n       o   p       q               r       s       t   u   v   w                               x               y       z               {   |   }       ~                                                                                                             4CEqXS{=ERG
3}a6G{-wT<i:X,_U
YyWaoD
~y5{wd['4dqe^4qk,TVqU{{A|+Y                    &       	                                                   [                          \             m                                                                               P                                                     1                                                    	                                       	                          V
                          ,                          P             9                          u             %                          z                                       Y                                                                               "                                                    N                          H                          O                                       U             ?             i             -                          a               o                                                                              
                                                                                                                      U                           c             :
                                       7                                       '                          V                           i                            A             >             	                                                      ]             8               R           "                |                          |         Z         a         N   b     "  u   b     "    P  L   "  H  b     "             O  L   "  ]  <r       )  a  L   "  b
  `     "    W      i  U  $    m         -          P     "    4        O     "             tR  0     {           O     "    TP     "     Hc        b  2          &       	   R  p     U	  P    "  c                   	  P    "    l0  d    o                 F  44  X       3         8      
  La  P   "  u   .      
   a  L   "           
  a     "   __gmon_start__ _init _fini _ITM_deregisterTMCloneTable _ITM_registerTMCloneTable __cxa_finalize _Jv_RegisterClasses PyInit_apt_inst PyModule_Create2 PyImport_ImportModule PyObject_GetAttrString PyModule_AddObject PyType_Ready PyAptError PyArMember_Type PyArArchive_Type PyDebFile_Type PyTarFile_Type PyTarMember_Type __aeabi_unwind_cpp_pr0 _ZNSt8ios_base4InitC1Ev __aeabi_atexit _ZNSt8ios_base4InitD1Ev _Z12HandleErrorsP7_object __gxx_personality_v0 _Z12_GetErrorObjv _ZNK11GlobalError5emptyERKNS_7MsgTypeE _ZN11GlobalError10PopMessageERNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE _ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE9_M_appendEPKcj _ZdlPv PyErr_SetString _ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE10_M_replaceEjjPKcj _ZN11GlobalError7DiscardEv _ZSt20__throw_length_errorPKc __cxa_end_cleanup __stack_chk_fail __stack_chk_guard _Z14ListToCharCharP7_objectb PySequence_Size _Znaj PyUnicode_AsUTF8 PySequence_GetItem PyErr_SetNone _ZdaPv __cxa_throw_bad_array_new_length PyExc_TypeError _Z14CharCharToListPPKcm PyList_New PyUnicode_FromString PyList_SetItem _ZN14PyApt_Filename4initEP7_object PyUnicode_EncodeFSDefault _Z11CppTraverseIPN9ARArchive6MemberEEiP7_objectPFiS4_PvES5_ _Z8CppClearIPN9ARArchive6MemberEEiP7_object _Z11CppTraverseIP9ARArchiveEiP7_objectPFiS3_PvES4_ _Z8CppClearIP9ARArchiveEiP7_object PyLong_FromUnsignedLong PyLong_FromUnsignedLongLong PyUnicode_DecodeFSDefaultAndSize PyUnicode_FromFormat _Z13CppDeallocPtrIPN9ARArchive6MemberEEvP7_object _ZN14PyApt_Filename9ConverterEP7_objectPv PyList_Append PyUnicode_FromStringAndSize _ZNK9ARArchive10FindMemberEPKc PyErr_Format PyExc_LookupError PyArg_ParseTuple _ZN6FileFd4SeekEy _ZN6FileFd4ReadEPvyPy PyBytes_FromStringAndSize __cxa_begin_catch __cxa_end_catch PyExc_MemoryError _ZTISt9bad_alloc PyObject_GetIter _ZN6FileFdD1Ev _ZN9ARArchiveD1Ev _ZSt19__throw_logic_errorPKc _ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE9_M_createERjj memcpy strlen _Znwj _ZN10ExtractTarC1ER6FileFdyNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE _ZTV6FileFd _Z9flCombineNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES4_ open64 fchmod fchown write __errno_location PyErr_SetFromErrnoWithFilename close utime PyExc_OSError _Py_TrueStruct PyObject_AsFileDescriptor PyErr_Clear _ZN6FileFdC1Eib _ZN9ARArchiveC1ER6FileFd _ZN6FileFdC1ENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEjm _ZNSt6vectorIN3APT13Configuration10CompressorESaIS2_EED2Ev _ZNSt6vectorIN3APT13Configuration10CompressorESaIS2_EED1Ev _ZN3APT13Configuration14getCompressorsEb _ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE9_M_assignERKS4_ _ZN11GlobalError5ErrorEPKcz PyType_Type _Z11CppTraverseIN12pkgDirStream4ItemEEiP7_objectPFiS3_PvES4_ _Z8CppClearIN12pkgDirStream4ItemEEiP7_object _Z10CppDeallocIP10ExtractTarEvP7_object _Z11CppTraverseIP10ExtractTarEiP7_objectPFiS3_PvES4_ _Z8CppClearIP10ExtractTarEiP7_object _ZN11PyDirStreamD2Ev _ZTV11PyDirStream _ZN11PyDirStreamD1Ev _Z17tarmember_deallocP7_object _ZN11PyDirStream7ProcessERN12pkgDirStream4ItemEPKhyy PyUnicode_DecodeFSDefault PyBool_FromLong _Z10SafeGetCWDB5cxx11v chdir _ZN10ExtractTar2GoER12pkgDirStream _ZTV12pkgDirStream PyObject_Repr _ZN11PyDirStream6DoItemERN12pkgDirStream4ItemERi strcmp _ZnajRKSt9nothrow_t _ZSt7nothrow _ZN11PyDirStream12FinishedFileERN12pkgDirStream4ItemEi strcpy PyObject_CallFunctionObjArgs _Py_NoneStruct PyArg_ParseTupleAndKeywords _ZN11PyDirStreamD0Ev _ZTS11PyDirStream _ZTI11PyDirStream _ZTVN10__cxxabiv120__si_class_type_infoE _ZTI12pkgDirStream _ZN12pkgDirStream4FailERNS_4ItemEi libapt-pkg.so.5.0 libapt-inst.so.2.0 libstdc++.so.6 libm.so.6 libgcc_s.so.1 libpthread.so.0 libc.so.6 ld-linux-armhf.so.3 _edata __bss_start __bss_start__ __bss_end__ __end__ _end GCC_3.5 GLIBC_2.4 APTINST_2.0 CXXABI_1.3.8 CXXABI_1.3 GLIBCXX_3.4.21 CXXABI_ARM_1.3.3 GLIBCXX_3.4 APTPKG_5.0                            	 	                          	 
                    	 
  	                                         
        	     
       	 	                                                                   U&y           ,         ii  
                  }  	         F         ii                `   x        k        q        I        t)                    C           <         ii                                                                  D    P                            4    8    \    `    l    t                    $    (    D                                                                        $    (    0    8    <    D    d                                                                                            @    L    `                            (    X    \    p    x                                                    $    ,    0    8    @    D    L    T    X    `    h    l    t    |                                                                                                      $    ,    0    4    <    @    D    L    P    T    \    `    d    l     E   s   b       2   
            y            5   8   9   ?   C   G            ]   c   d   e   f   {   h   q  <         8       P   T   X   \   `   d   h 	  l   p   t   x   |                                         !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /   0   1   3   4   6    7   :   ;   <   =   >   @   A    B  $ D  ( F  , H  0 I  4 J  8 K  < L  @ M  D N  H O  L P  P Q  T R  X S  \ T  ` U  d V  h W  l X  p Y  t Z  x [  | \   ^   `   a   c   f   g   i  @- -g      x p h ` X P H @ 8 0 (                        x p h ` X P H @ 8 0 (                        x p h ` X P H @ 8 0 (     p@-LPL@P @@<   0
(0( 0    pl c   <e (e 8  p@-0P0@P $@  0  p@tl c   d p@-P@P 0@    0  0   X  P     Pl ,P<L\ \  XX0X 0X0p,l b   |d   f @:  :  ;    <  T=  >  ?  ?  \  ?  \A  p@-P@P Et0@p   ``0` P\\\ \0  X 0 @04  X pk a   dc h   i    F  F  8G  G  XI  0 0   R/Ha   404 0  0 0C S 00/ 0  S//(j $j `   88    A,0A0/ 0  S//i i `   L0L 0  0  S/80@-0  S  
(0 0 0  i L`   a Li 8 80    0  R     0  S
@-3/@^ _   p@-  QP @x  c  PT  
ha`\10  P  K  
   <1`  pA  
 0$0  0 1`  p3  
 00  0 0` s p%  
 00  0 0` e p  
 00  0 |0P W p	  
 0d0   0 p @ p\a   _ 4  4      ,4     4  \  3    3  h  x3  82O-TM0 0$2 @00 0L00  Sd  
  T  
 00C  S 0a  
 0	
@p<`$   0$0 p  P(  4`8 < 4  T P    10C SO      1  U0C	
 S6  P   8 44 @ P
  T  
0 0   0 P    
  0L  0 R#  T0 00  0 :e 0 03/\   <4  P   
 0 P   
,   /] d  3  3  3    P2  1  1  O- p
 `  .p!   H  V  P@    } V   
 0T0B800   q   Y 01 oX[   A- `Q P      P  
0 `  R    V p     pDPE @0  S @   q T A<    0@- @ 0T 0   00 00 
   T0      /X0      /\0      /p@- @T P  PP  
 0  0C ST  0   
X   P  
 0  0C SX  0  
\   P	  
 0  0C S\  0  003/40 0p@`0/003/003/TY   p@- P @ @00 p@0/X   0 0 0$ 0  000 l 0  0    IL.  G- `  w0 0 P  p  8P  U  
0	
 3/ 00 @`  0P , 00C  S 00 03/8P  U W   p@- @  H0 @ `  8@  T  
  P   00C  S 00 03/8@  T p0 00@-M@  P 0 0  P  
  PP   P  
 00C  S 0  003/  0  R  0 P'   P  
 00C  S 0  003/!V d  @-MQ1P  ` @  0  0  P+  
  pP  
0 0 03/ 0 P0 @ 0p    P  
 00C  S 0  003/  0  R
  \0\ 0   P   P  
 00C  S 0  003/U d      T+  A- PA!@1` M      0  P+  
 N pPD  
"    S  R3  P #  P5  
( t "  ( I @    Q/  '0 0  D @   P  
 00C  S 0  003/  0  R   0 0  )Q @p0p 0  a   P  
 00C  S 0  003/[|T d  x  *  p  ,*  )    l)  p@- @ 00C  S 0 P  0 03/ pp@- @ H0  S  P  U  
 y   00   P	  
 0  0C S  0  003/0 p@0/A- @T p  PP`p  
5/  P  X   P  
5/  P  \   P  
5/  P  (0 0 A\0/Q   00@-  R`Mo 0   ^0  
   @B Tp P @   0 T   
  T         0 Q    00    0     0 Q d  '  G-0M8b8"`42p  P    ,  0 00  P^  
 9 PR  
1 0 03/  1 @ P,  0 $$  0  0 $ D0<0< 8<  `P 00  VT 0    
   	 wp "  ` `
 P   
P ? @   P  
 00C  S 0  003/,  0  R
  00 0   @=   P  
 00C  S 0  003/7 # 	 P
$   Y0P d  x  &        $  O-AM2,M0020@0 A$#  U  Pt  
h`  T0F0    
 *  PF  pF0  0  4 F 0 P   
 0F P   
40$  0 p 0  
$ p,  
   W  P"  0?  
 0J P0     Q P  Z0.  
 U
 T0
@P 0 0 *  P	   0 S
1 0  p @ j4 ,`F P   
A=$0  0  0 R  A,t @0<F <080 p
 x00@     |4 6` P   
k| 0 P   
e P P 4M d  A    X  @-Ma`!p1   P       0Z  P  
0P @  8@  T  
  $  P @   P  
 00C  S 0  003/  0  R  \00@        P  
 00C  S 0  003/J d  ,-  x  !  X  p@- MA!@|Px1       `  L00  0  P)  
  P  
   @   P  
 00C  S 0  
   P  
 00C  S 0  003/  0  R   p0 0   @003/   P  
 00C  S 0  003/   P  
 00C  S 0  003/I d  +  x  \       2"0@- @P 4M   ,  PT  
 h  P0   x p pJ  
0  `3/  V` 0 @0 0     ``40  S2     P  
 00C  S 0  003/,  0  R&  40  3/` 0 Vp @0p    
 |  0 0X0    P
4 @    @80 0 P   
&   P  
 00C  S 0  003/, G d      5O-M005  0 0   ,0P0 0 $(0,0b@0 T  
Dp<   0d@ T  
  U<p   
        	  `<  P   
  V
0$ 4 $P0 03/  4 @ ,p  0 $p$  0  0 $ D0<0< 8<  P 00  UpT 0  p  
    p +"  PD P P   
p W7  
`LP
 Y	  
P  P   
	 ZPL  Z  

 |@D
 Y	  
P   U   
s	 ZP@  Z  

 j( 80 P   
e  0 P   
`  P   
\dp Xd`  X  
 S$ 0 P   
N0   0 R    U\@T@    
 x  T V	 T `T  P   
3  V^  Ut@l@    
 c  l` @p 10C S~    ! pp0  S0   00P0  0   l 0 P0   
@0 Td@`     Sd@  
H P  R
`L   	   P   
0d@ S0s.  
      @  P88T  P   
   $ 0 P   
$   W<  P   PT   Z  P
l  P$   ME d      4  0    t  @  A-MQ1Pp 00 @P1  
s  PX +  
 l  PT $  
 ! `P  
P #  P  
( M"   ( "\     0 R  J  000 0  Y? d          d   0  P//0  S  
    B R    
  /  @-03/   0  P//0  S  
    B R    
  /  @-03/  0p@- @  S  P  U  
0  P   
  00   P	  
 0  0C S  0  003/0 p@0/0  G-  W9  
`LPP
 U
  
@0P T    
 Z@L  Z  

 @PD
 U
  
@0P S    
 Z@@  Z  

 ( 80 P   
  0 P   
  P   
dp Xd`   X  
 	 @- @   P   
   P   
   P	  
 0  0C S  0  003/0 @0/0@-  S   
      0  8 4 $ T   P   
_   \     P   
W   T    @o  @o o  @o  @o0 C S P     @o  @o 0      A-(MA1@p` P  0$0|1|      01  P  
   P  
 p.  
<1  ? c 0 P  S  
  p!  
 t @   P  
 00C  S 0  
 0 P   
$  0  R  (003/00  l00     P  
 00C  S 0  003/ p P   
H: d  x    |    0@- @D@     gp  M- @P a  Up`  
   P0  !    S  R     P  
P  U PPP$  
0  0   Q   P  
  S
 R
  !P0 `  P 
000 0  0 0  @8 p    `  A-`Q  Q @P  
   PJ     P  
 00C  S 0D  
   P6  
0  S 9  
$1 p0 03/ P p      q   l   ' $ 0   00C So  0  
  d000     0  S 003/   P0 03/    7 h  l  3G-0ChM`hp H, P      l#l3 @   0 dP,0  P{  
0  P3/  UP 0 @0 0,   PC    p P]  
	    0Tp  X0LpL  
  P P( X   Pc  
  P    0PPp 05  	? PML P P   
h0  S;  ,   P  
 00C  S 0  003/d  0  Rg  h0<p  X4p4L  
  P P$ 2   P=  
  PQ  0  8P	  
1 '4  P
h 00C  S 0  0 03/ @ K @  (
 (0L T0 (PL  0 T0  $
 $04 <0 p$P40  0<       ,   P  
 00C  S 0  003/6  +4 
 P
 L 
 P5 d    t  <   0	  $	  C- Q!P1`,M     $  0 @P3  
1 p   ?  = 	0  S-  @  T4  
 00 0 p  Pp  
 00C  S 0#  
   P  
 00C  S 0  
   P   
    P  
 00C  S 0  003/$  0  R  , @003/003/p0p 0  d @	       P  
 00C  S 0  003/1 d  x    t    t  A-8M(B("@$2` p    4  0     Pd  
  Q  
 0  S0  0 R P 0(0,000 0 0  $ 0  ?  (0  S7     R  
 0  S*  
3 @ P  PP  
 00C  S 0&  
    P  
 00C  S 0"  
,   P   
L   P  
 00C  S 0  003/4  0  R  800   @003/003/ @   P  
 00C  S 0  003/ M  / d  x    t    L   0  P//0  S  
    B R    
  /  @-03/  @- @   P	  
 0  0C S  0  003/0 @0/ 0  P//0  S  
    B R    
  /  @-03/  0 0@- @0 0  P 0  
 00C  S 0  
   P  
 00C  S 0	  
   P   
 003/003/4, t  0 0@- @0 0  P 0  
 00C  S 0  
   P  
 00C  S 0  
   P   
 c 003/003/+ t  @-apt_pkg Error   ArMember    ArArchive   DebFile TarFile TarMember   Functions for working with ar/tar archives and .deb packages.

This module provides useful classes and functions to work with
archives, modelled after the 'TarFile' class in the 'tarfile' module. apt_inst    E:  W:  basic_string::append    ,   Internal Error  <%s object: name:'%s'>  No member named '%s'    O&:extractdata  Member '%s' is too large to read into memory    basic_string::_M_construct null not valid   O&s:gettar  |O&:extractall  O&|O&:extract   O:__new__   .{  }   Internal error, could not locate member %s  control.tar data.tar    debian-binary   No debian archive, missing %s   Represent a single file within an AR archive. For
Debian packages this can be e.g. control.tar.gz. This class provides
information about this file, such as the mode and size.  getmember(name: str) -> ArMember

Return an ArMember object for the member given by 'name'. Raise
LookupError if there is no ArMember with the given name.  gettar(name: str, comp: str) -> TarFile

Return a TarFile object for the member given by 'name' which will be
decompressed using the compression algorithm given by 'comp'.
This is almost equal to:

   member = arfile.getmember(name)
   tarfile = TarFile(file, member.start, member.size, 'gzip')'

It just opens a new TarFile on the given position in the stream.   extractdata(name: str) -> bytes

Return the contents of the member, as a bytes object. Raise
LookupError if there is no ArMember with the given name.   extract(name: str[, target: str]) -> bool

Extract the member given by 'name' into the directory given
by 'target'. If the extraction fails, raise OSError. In case
of success, return True if the file owner could be set or
False if this was not possible. If the requested member
does not exist, raise LookupError.    extractall([target: str]) -> bool

Extract all archive contents into the directory given by 'target'. If
the extraction fails, raise an error. Otherwise, return True if the
owner could be set or False if the owner could not be changed. getmembers() -> list

Return a list of all members in the archive.  getnames() -> list

Return a list of the names of all members in the archive.   ArArchive(file: str/int/file)

Represent an archive in the 4.4 BSD ar format,
which is used for e.g. deb packages.

The parameter 'file' may be a string specifying the path of a file, or
a file-like object providing the fileno() method. It may also be an int
specifying a file descriptor (returned by e.g. os.open()).
The recommended way of using it is to pass in the path to the file.   DebFile(file: str/int/file)

A DebFile object represents a file in the .deb package format.

The parameter 'file' may be a string specifying the path of a file, or
a file-like object providing the fileno() method. It may also be an int
specifying a file descriptor (returned by e.g. os.open()).
The recommended way of using it is to pass in the path to the file.

It differs from ArArchive by providing the members 'control', 'data'
and 'version' for accessing the control.tar.gz, data.tar.$compression 
(all apt compression methods are supported), and debian-binary members 
in the archive. apt_inst.DebFile    control The TarFile object associated with the control.tar.gz member.   data    The TarFile object associated with the data.tar.$compression member. All apt compression methods are supported.     debian_binary   The package version, as contained in debian-binary. apt_inst.ArArchive  getmember   extractdata extract getmembers  getnames    apt_inst.ArMember   gid The group id of the owner.  mode    The mode of the file.   mtime   Last time of modification.  The name of the file.   size    The size of the files.  start   The offset in the archive where the file starts.    uid The user ID of the owner.   11PyDirStream   <%s object: %s> The member %s was too large to read into memory gzip    O|iis   O&  There is no member named '%s'   O|O&    Represent a single member of a 'tar' archive.

This class, which has been modelled after 'tarfile.TarInfo', represents
information about a given member in an archive.  extractdata(member: str) -> bytes

Return the contents of the member, as a bytes object. Raise
LookupError if there is no member with the given name.   extractall([rootdir: str]) -> True

Extract the archive in the current directory. The argument 'rootdir'
can be used to change the target directory.    go(callback: callable[, member: str]) -> True

Go through the archive and call the callable 'callback' for each
member with 2 arguments. The first argument is the TarMember and
the second one is the data, as bytes.

The optional parameter 'member' can be used to specify the member for
which to call the callback. If not specified, it will be called for all
members. If specified and not found, LookupError will be raised.  TarFile(file: str/int/file[, min: int, max: int, comp: str])

The parameter 'file' may be a string specifying the path of a file, or
a file-like object providing the fileno() method. It may also be an int
specifying a file descriptor (returned by e.g. os.open()).

The parameter 'min' describes the offset in the file where the archive
begins and the parameter 'max' is the size of the archive.

The compression of the archive is set by the parameter 'comp'. It can
be set to any program supporting the -d switch, the default being gzip.   apt_inst.TarFile    go  file    min max comp    apt_inst.TarMember  The owner's group ID.   linkname    The target of the link. major   The major ID of the device. minor   The minor ID of the device. The mode (permissions). The size of the file.   The owner's user ID.    isblk   Determine whether the member is a block device. ischr   Determine whether the member is a character device. isdev   Determine whether the member is a device (block, character or FIFO).    isdir   Determine whether the member is a directory.    isfifo  Determine whether the member is a FIFO. isfile  Determine whether the member is a regular file. islnk   Determine whether the member is a hardlink. isreg   Determine whether the member is a regular file, same as isfile().   issym   Determine whether the member is a symbolic link.    @ -0   |             
4      48     -"HH   0     }   /P          \"P@      h    ( 
P8      d,     (@|   H     . jd
 
 
 t
 
 
  
 
 
 
  	 	 	  
      H  <	 0  X|     *x          
 H        P @        P   L<t(   X\   0@TP0llLdT      0   8   P`HP l   |    d                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   L.  *  +  P+  h,  -                         U      W  tR   b  b                              ,     <     F     &     Hc                      o8          L  
              D               #                         o   o  o   o  o                                                    &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &                                  P                                                                                       Xd                                     o  `       5                                                           @     t<  4                                                       PN                                                     p  T       ;                          l `                          @     O  P          ;                                           8F                                                     0q         TP                  46                                       @     O  O                                                                                                   p  p8         8e  =         q  9         q  D         De  HC         q  X6         $q  7                         o  4      o      $p  4      ,p      p  4      p                              p8                                  7          Dq  6      Hq      dq  5      lq      q  5      q      x  (6      q      q  6      q      q  6      q      r  5       r                                     dx  X       La                  U                                       @     a  a                                                       X                                                     x  @       R                  S                                       @     `   a                                                                                                |x  x  x  x      q  \         De  S         xx  ^                         Dq  R      x      x  R      x      x  R      x      y  R      y      dq  R      ,y      q  R      q      x  R      q      q  R      Dy      r  R      \y                          ty  S     |y  y  S     y  y  S     y  8z  lS     @z  pz  XS     xz  z  TS     z  z  0S     z  {  DS     {  X{  S     `{                  A,   aeabi "   6 	
"3ceac7c8a361e8f79f3a23aa5d2140ed98a8f8.debug    cr .shstrtab .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .text .fini .rodata .ARM.extab .ARM.exidx .eh_frame .init_array .fini_array .jcr .data.rel.ro .dynamic .got .data .bss .ARM.attributes .gnu_debuglink                                                       $                     o   8  8                 (         L  L  P	              0                              8   o       *               E   o                       T   	                         ]   	   B   #  #                f         &  &                    a         &  &                  l         *  *  8                 r         Hc  Hc                    x         Pc  Pc  D                          {  {                        p   D~  D~  p                                                                                                                                                     ,                              (                        D D                                                                                    p          -                                  4                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               # Copyright (C) 2009 Canonical
#
# Authors:
#  Michael Vogt
#
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License as
#  published by the Free Software Foundation; either version 2 of the
#  License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
from __future__ import print_function

import os

import apt_pkg


def get_maintenance_end_date(release_date, m_months):
    """
    get the (year, month) tuple when the maintenance for the distribution
    ends. Needs the data of the release and the number of months that
    its is supported as input
    """
    # calc end date
    years = m_months // 12
    months = m_months % 12
    support_end_year = (release_date.year + years +
                        (release_date.month + months) // 12)
    support_end_month = (release_date.month + months) % 12
    # special case: this happens when e.g. doing 2010-06 + 18 months
    if support_end_month == 0:
        support_end_month = 12
        support_end_year -= 1
    return (support_end_year, support_end_month)


def get_release_date_from_release_file(path):
    """
    return the release date as time_t for the given release file
    """
    if not path or not os.path.exists(path):
        return None

    with os.fdopen(apt_pkg.open_maybe_clear_signed_file(path)) as data:
        tag = apt_pkg.TagFile(data)
        section = next(tag)
        if "Date" not in section:
            return None
        date = section["Date"]
        return apt_pkg.str_to_time(date)


def get_release_filename_for_pkg(cache, pkgname, label, release):
    " get the release file that provides this pkg "
    if pkgname not in cache:
        return None
    pkg = cache[pkgname]
    ver = None
    # look for the version that comes from the repos with
    # the given label and origin
    for aver in pkg._pkg.version_list:
        if aver is None or aver.file_list is None:
            continue
        for ver_file, _index in aver.file_list:
            # print verFile
            if (ver_file.origin == label and
                    ver_file.label == label and
                    ver_file.archive == release):
                ver = aver
    if not ver:
        return None
    indexfile = cache._list.find_index(ver.file_list[0][0])
    for metaindex in cache._list.list:
        for m in metaindex.index_files:
            if (indexfile and
                    indexfile.describe == m.describe and
                    indexfile.is_trusted):
                dirname = apt_pkg.config.find_dir("Dir::State::lists")
                for relfile in ['InRelease', 'Release']:
                    name = (apt_pkg.uri_to_filename(metaindex.uri) +
                            "dists_%s_%s" % (metaindex.dist, relfile))
                    if os.path.exists(dirname + name):
                        return dirname + name
    return None
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
<W                 @   s   d  Z  d d l m Z d d l Z d d l m Z d d l m Z m Z e e d d l	 m
 Z
 d e j k ry e j   e j   d d	 d
 g Z d S)z*High-Level Interface for working with apt.    )print_functionN)Package)CacheProblemResolver)CdromZAPTr   r   r   )__doc__Z
__future__r   Zapt_pkgZapt.packager   Z	apt.cacher   r   Z	apt.cdromr   configZinit_configZinit_system__all__ r
   r
   ./usr/lib/python3/dist-packages/apt/__init__.py<module>   s   

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
<WK&                 @   sj  d  Z  d d l m Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l	 Z	 d d l	 m
 Z Gd d   d e  Z Gd d   d e  Z d	 d
   Z d d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d d   Z e d k rfd d   d  d   e	 j   x e   D] Z e e  qRWd S)!z4Handle GnuPG keys used to trust signed repositories.    )print_functionN)gettextc               @   s   e  Z d  Z d S)AptKeyErrorN)__name__
__module____qualname__ r   r   */usr/lib/python3/dist-packages/apt/auth.pyr   (   s   r   c               @   s.   e  Z d  Z d Z d d   Z d d   Z d S)
TrustedKeyzRepresents a trusted key.c             C   s.   | |  _  t |  |  _ | |  _ | |  _ d  S)N)Zraw_name_namekeyiddate)selfr   r   r   r   r   r	   __init__0   s    		zTrustedKey.__init__c             C   s   d |  j  |  j |  j f S)Nz%s
%s %s)r   r   r   )r   r   r   r	   __str__7   s    zTrustedKey.__str__N)r   r   r   __doc__r   r   r   r   r   r	   r
   ,   s   r
   c        	      O   s  d } t  j j d d  g } | j |   t j j   } d | d <d | d <zKt  j j d  d	 k r t j	 d
 d d d  } | j
 t  j j   j d   | j   | j | d <t j | d | d d d t j d t j d t j } | j d d  } t j j d k  r/t | t  r/| j d  } | j |  \ } } | j rxt d | j d j |  | | f   n | rt j j
 |  | j   SWd | d k	 r| j   Xd S)z0Run the apt-key script with the given arguments.NzDir::Bin::Apt-Keyz/usr/bin/apt-keyCZLANG1Z$APT_KEY_DONT_WARN_ON_DANGEROUS_USAGEZDir/prefixzapt-keysuffixz.confzUTF-8Z
APT_CONFIGenvuniversal_newlinesTstdinstdoutstderr   zutf-8zGThe apt-key script failed with return code %s:
%s
stdout: %s
stderr: %s )apt_pkgconfigZ	find_fileextendosenvironcopyZfind_dirtempfileZNamedTemporaryFilewritedumpencodeflushr   
subprocessPopenPIPEgetsysversion_infomajor
isinstanceZunicodecommunicate
returncoder   joinr   stripclose)	argskwargsZconfcmdr   proccontentoutputr   r   r   r	   _call_apt_key_script;   s<    

	
		!	%r=   c             C   sX   t  j j |   s" t d |    t  j |  t  j  sG t d |    t d |   d S)zImport a GnuPG key file to trust repositores signed by it.

    Keyword arguments:
    filename -- the absolute path to the public GnuPG key file
    z An absolute path is required: %szKey file cannot be accessed: %saddN)r"   pathabspathr   accessR_OKr=   )filenamer   r   r	   add_key_from_filej   s
    rD   c             C   sG   t  j   } z& y t |  | |  Wn   Yn XWd t j |  Xd S)zImport a GnuPG key file to trust repositores signed by it.

    Keyword arguments:
    keyid -- the long keyid (fingerprint) of the key, e.g.
             A1BD8E9D78F7FE5C3E65D8AF8B48AD6246925553
    keyserver -- the URL or hostname of the key server
    N)r%   Zmkdtemp_add_key_from_keyservershutilZrmtree)r   	keyservertmp_keyring_dirr   r   r	   add_key_from_keyserverw   s    rI   c          
   C   s  t  |   d  k  r t d   t j j | d  } t j j | d  } d d d d	 | g } t j | d
 | d | d | d |  g  } | d k r t d | |  f   t j j | d  } t j | d | d | d |  g  } | d k r t d |    t j | d | d d d d g d t j d d j	   d } d  }	 x7 | j
   D]) }
 |
 j d  rP|
 j d  d }	 PqPW|  j d d  j   } |	 | k rt d | | f   t |  d  S)!N      z+Only long keyids (v4, 160bit) are supportedzsecring.gpgzpubring.gpgZgpgz--no-default-keyringz--no-optionsz	--homedirz--secret-keyringz	--keyringz--keyserverz--recvr   zrecv from '%s' failed for '%s'zexport-keyring.gpgz--outputz--exportzexport of '%s' failedz--fingerprintz--batchz--fixed-list-modez--with-colonsr   r   Tzfpr::	   Z0x g      4@)lenr   r"   r?   r4   r*   Zcallr+   r,   r2   
splitlines
startswithsplitreplaceupperrD   )r   rG   rH   Ztmp_secret_keyringZtmp_keyringZgpg_default_optionsresZtmp_export_keyringr<   Zgot_fingerprintlineZsigning_key_fingerprintr   r   r	   rE      sT    			
	rE   c             C   s    t  d d d d d d |  d S)zImport a GnuPG key to trust repositores signed by it.

    Keyword arguments:
    content -- the content of the GnuPG public key
    advz--quietz--batchz--import-r   N)r=   )r;   r   r   r	   add_key   s    rY   c             C   s   t  d |   d S)zRemove a GnuPG key to no longer trust repositores signed by it.

    Keyword arguments:
    fingerprint -- the fingerprint identifying the key
    ZrmN)r=   )fingerprintr   r   r	   
remove_key   s    r[   c             C   s   t  d |   S)zxReturn the GnuPG key in text format.

    Keyword arguments:
    fingerprint -- the fingerprint identifying the key
    Zexport)r=   )rZ   r   r   r	   
export_key   s    r\   c               C   s
   t  d  S)a  Update the local keyring with the archive keyring and remove from
    the local keyring the archive keys which are no longer valid. The
    archive keyring is shipped in the archive-keyring package of your
    distribution, e.g. the debian-archive-keyring package in Debian.
    update)r=   r   r   r   r	   r]      s    r]   c               C   s
   t  d  S)ay  Work similar to the update command above, but get the archive
    keyring from an URI instead and validate it against a master key.
    This requires an installed wget(1) and an APT build configured to
    have a server to fetch from and a master keyring to validate. APT
    in Debian does not support this command and relies on update
    instead, but Ubuntu's APT does.
    z
net-update)r=   r   r   r   r	   
net_update   s    r^   c              C   s   t  d d d d d  }  g  } x |  j d  D]r } | j d  } | d d	 k r] | d
 } | d d k r. | d } | d } t | | |  } | j |  q. W| S)zaReturns a list of TrustedKey instances for each key which is
    used to trust repositories.
    rW   z--with-colonsz--batchz--fixed-list-modez--list-keys
rL   r   Zpub   uidrM      )r=   rR   r
   append)r<   rU   rV   Zfieldsr   ra   Zcreation_datekeyr   r   r	   	list_keys   s    


re   __main__c               C   s
   t  d  S)Nz;Ubuntu Archive Automatic Signing Key <ftpmaster@ubuntu.com>)r   r   r   r   r	   <lambda>  s    rg   c               C   s
   t  d  S)Nz:Ubuntu CD Image Automatic Signing Key <cdimage@ubuntu.com>)r   r   r   r   r	   rg     s    )r   Z
__future__r   r"   os.pathrF   r*   r.   r%   r   r   r   	Exceptionr   objectr
   r=   rD   rI   rE   rY   r[   r\   r]   r^   re   r   ZinitZtrusted_keyprintr   r   r   r	   <module>   s6   /F
			


                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   
<W                 @   sP   d  d l  m Z d  d l Z d  d l Z d d   Z d d   Z d d   Z d S)	    )print_functionNc             C   sg   | d } | d } |  j  | |  j | d } |  j | d } | d k r] d } | d 8} | | f S)z
    get the (year, month) tuple when the maintenance for the distribution
    ends. Needs the data of the release and the number of months that
    its is supported as input
       r      )ZyearZmonth)Zrelease_dateZm_monthsZyearsZmonthsZsupport_end_yearZsupport_end_month r   +/usr/lib/python3/dist-packages/apt/utils.pyget_maintenance_end_date   s    



r   c          	   C   s   |  s t  j j |   r d St  j t j |    I } t j |  } t |  } d | k rd d S| d } t j |  SWd QRXd S)zF
    return the release date as time_t for the given release file
    NZDate)	ospathexistsfdopenapt_pkgZopen_maybe_clear_signed_fileZTagFilenextZstr_to_time)r	   datatagZsectionZdater   r   r   "get_release_date_from_release_file-   s    
r   c             C   s  | |  k r d S|  | } d } x | j  j D]q } | d k s- | j d k rQ q- xJ | j D]? \ } } | j | k r[ | j | k r[ | j | k r[ | } q[ Wq- W| s d S|  j j | j d d  }	 x |  j j D] }
 x |
 j	 D] } |	 r |	 j
 | j
 k r |	 j r t j j d  } xU d d g D]G } t j |
 j  d |
 j | f } t j j | |  r,| | Sq,Wq Wq Wd S)z- get the release file that provides this pkg Nr   zDir::State::listsZ	InReleaseZReleasezdists_%s_%s)Z_pkgZversion_listZ	file_listoriginlabelarchiveZ_listZ
find_indexlistZindex_filesZdescribeZ
is_trustedr   configZfind_dirZuri_to_filenameZuriZdistr   r	   r
   )cacheZpkgnamer   releasepkgZverZaverZver_fileZ_indexZ	indexfileZ	metaindexmdirnameZrelfilenamer   r   r   get_release_filename_for_pkg=   s6    
	r   )Z
__future__r   r   r   r   r   r   r   r   r   r   <module>   s
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             # apt/progress/__init__.py - Initialization file for apt.progress.
#
# Copyright (c) 2009 Julian Andres Klode <jak@debian.org>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation; either version 2 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
# USA
"""Progress reporting.

This package provides progress reporting for the python-apt package. The module
'base' provides classes with no output, and the module 'text' provides classes
for terminals, etc.
"""

from __future__ import print_function


__all__ = []
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              # Copyright (c) 2010-2018 Benjamin Peterson
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

"""Utilities for writing code that runs on Python 2 and 3"""

from __future__ import absolute_import

import functools
import itertools
import operator
import sys
import types

__author__ = "Benjamin Peterson <benjamin@python.org>"
__version__ = "1.12.0"


# Useful for very coarse version differentiation.
PY2 = sys.version_info[0] == 2
PY3 = sys.version_info[0] == 3
PY34 = sys.version_info[0:2] >= (3, 4)

if PY3:
    string_types = str,
    integer_types = int,
    class_types = type,
    text_type = str
    binary_type = bytes

    MAXSIZE = sys.maxsize
else:
    string_types = basestring,
    integer_types = (int, long)
    class_types = (type, types.ClassType)
    text_type = unicode
    binary_type = str

    if sys.platform.startswith("java"):
        # Jython always uses 32 bits.
        MAXSIZE = int((1 << 31) - 1)
    else:
        # It's possible to have sizeof(long) != sizeof(Py_ssize_t).
        class X(object):

            def __len__(self):
                return 1 << 31
        try:
            len(X())
        except OverflowError:
            # 32-bit
            MAXSIZE = int((1 << 31) - 1)
        else:
            # 64-bit
            MAXSIZE = int((1 << 63) - 1)
        del X


def _add_doc(func, doc):
    """Add documentation to a function."""
    func.__doc__ = doc


def _import_module(name):
    """Import module, returning the module after the last dot."""
    __import__(name)
    return sys.modules[name]


class _LazyDescr(object):

    def __init__(self, name):
        self.name = name

    def __get__(self, obj, tp):
        result = self._resolve()
        setattr(obj, self.name, result)  # Invokes __set__.
        try:
            # This is a bit ugly, but it avoids running this again by
            # removing this descriptor.
            delattr(obj.__class__, self.name)
        except AttributeError:
            pass
        return result


class MovedModule(_LazyDescr):

    def __init__(self, name, old, new=None):
        super(MovedModule, self).__init__(name)
        if PY3:
            if new is None:
                new = name
            self.mod = new
        else:
            self.mod = old

    def _resolve(self):
        return _import_module(self.mod)

    def __getattr__(self, attr):
        _module = self._resolve()
        value = getattr(_module, attr)
        setattr(self, attr, value)
        return value


class _LazyModule(types.ModuleType):

    def __init__(self, name):
        super(_LazyModule, self).__init__(name)
        self.__doc__ = self.__class__.__doc__

    def __dir__(self):
        attrs = ["__doc__", "__name__"]
        attrs += [attr.name for attr in self._moved_attributes]
        return attrs

    # Subclasses should override this
    _moved_attributes = []


class MovedAttribute(_LazyDescr):

    def __init__(self, name, old_mod, new_mod, old_attr=None, new_attr=None):
        super(MovedAttribute, self).__init__(name)
        if PY3:
            if new_mod is None:
                new_mod = name
            self.mod = new_mod
            if new_attr is None:
                if old_attr is None:
                    new_attr = name
                else:
                    new_attr = old_attr
            self.attr = new_attr
        else:
            self.mod = old_mod
            if old_attr is None:
                old_attr = name
            self.attr = old_attr

    def _resolve(self):
        module = _import_module(self.mod)
        return getattr(module, self.attr)


class _SixMetaPathImporter(object):

    """
    A meta path importer to import six.moves and its submodules.

    This class implements a PEP302 finder and loader. It should be compatible
    with Python 2.5 and all existing versions of Python3
    """

    def __init__(self, six_module_name):
        self.name = six_module_name
        self.known_modules = {}

    def _add_module(self, mod, *fullnames):
        for fullname in fullnames:
            self.known_modules[self.name + "." + fullname] = mod

    def _get_module(self, fullname):
        return self.known_modules[self.name + "." + fullname]

    def find_module(self, fullname, path=None):
        if fullname in self.known_modules:
            return self
        return None

    def __get_module(self, fullname):
        try:
            return self.known_modules[fullname]
        except KeyError:
            raise ImportError("This loader does not know module " + fullname)

    def load_module(self, fullname):
        try:
            # in case of a reload
            return sys.modules[fullname]
        except KeyError:
            pass
        mod = self.__get_module(fullname)
        if isinstance(mod, MovedModule):
            mod = mod._resolve()
        else:
            mod.__loader__ = self
        sys.modules[fullname] = mod
        return mod

    def is_package(self, fullname):
        """
        Return true, if the named module is a package.

        We need this method to get correct spec objects with
        Python 3.4 (see PEP451)
        """
        return hasattr(self.__get_module(fullname), "__path__")

    def get_code(self, fullname):
        """Return None

        Required, if is_package is implemented"""
        self.__get_module(fullname)  # eventually raises ImportError
        return None
    get_source = get_code  # same as get_code

_importer = _SixMetaPathImporter(__name__)


class _MovedItems(_LazyModule):

    """Lazy loading of moved objects"""
    __path__ = []  # mark as package


_moved_attributes = [
    MovedAttribute("cStringIO", "cStringIO", "io", "StringIO"),
    MovedAttribute("filter", "itertools", "builtins", "ifilter", "filter"),
    MovedAttribute("filterfalse", "itertools", "itertools", "ifilterfalse", "filterfalse"),
    MovedAttribute("input", "__builtin__", "builtins", "raw_input", "input"),
    MovedAttribute("intern", "__builtin__", "sys"),
    MovedAttribute("map", "itertools", "builtins", "imap", "map"),
    MovedAttribute("getcwd", "os", "os", "getcwdu", "getcwd"),
    MovedAttribute("getcwdb", "os", "os", "getcwd", "getcwdb"),
    MovedAttribute("getoutput", "commands", "subprocess"),
    MovedAttribute("range", "__builtin__", "builtins", "xrange", "range"),
    MovedAttribute("reload_module", "__builtin__", "importlib" if PY34 else "imp", "reload"),
    MovedAttribute("reduce", "__builtin__", "functools"),
    MovedAttribute("shlex_quote", "pipes", "shlex", "quote"),
    MovedAttribute("StringIO", "StringIO", "io"),
    MovedAttribute("UserDict", "UserDict", "collections"),
    MovedAttribute("UserList", "UserList", "collections"),
    MovedAttribute("UserString", "UserString", "collections"),
    MovedAttribute("xrange", "__builtin__", "builtins", "xrange", "range"),
    MovedAttribute("zip", "itertools", "builtins", "izip", "zip"),
    MovedAttribute("zip_longest", "itertools", "itertools", "izip_longest", "zip_longest"),
    MovedModule("builtins", "__builtin__"),
    MovedModule("configparser", "ConfigParser"),
    MovedModule("copyreg", "copy_reg"),
    MovedModule("dbm_gnu", "gdbm", "dbm.gnu"),
    MovedModule("_dummy_thread", "dummy_thread", "_dummy_thread"),
    MovedModule("http_cookiejar", "cookielib", "http.cookiejar"),
    MovedModule("http_cookies", "Cookie", "http.cookies"),
    MovedModule("html_entities", "htmlentitydefs", "html.entities"),
    MovedModule("html_parser", "HTMLParser", "html.parser"),
    MovedModule("http_client", "httplib", "http.client"),
    MovedModule("email_mime_base", "email.MIMEBase", "email.mime.base"),
    MovedModule("email_mime_image", "email.MIMEImage", "email.mime.image"),
    MovedModule("email_mime_multipart", "email.MIMEMultipart", "email.mime.multipart"),
    MovedModule("email_mime_nonmultipart", "email.MIMENonMultipart", "email.mime.nonmultipart"),
    MovedModule("email_mime_text", "email.MIMEText", "email.mime.text"),
    MovedModule("BaseHTTPServer", "BaseHTTPServer", "http.server"),
    MovedModule("CGIHTTPServer", "CGIHTTPServer", "http.server"),
    MovedModule("SimpleHTTPServer", "SimpleHTTPServer", "http.server"),
    MovedModule("cPickle", "cPickle", "pickle"),
    MovedModule("queue", "Queue"),
    MovedModule("reprlib", "repr"),
    MovedModule("socketserver", "SocketServer"),
    MovedModule("_thread", "thread", "_thread"),
    MovedModule("tkinter", "Tkinter"),
    MovedModule("tkinter_dialog", "Dialog", "tkinter.dialog"),
    MovedModule("tkinter_filedialog", "FileDialog", "tkinter.filedialog"),
    MovedModule("tkinter_scrolledtext", "ScrolledText", "tkinter.scrolledtext"),
    MovedModule("tkinter_simpledialog", "SimpleDialog", "tkinter.simpledialog"),
    MovedModule("tkinter_tix", "Tix", "tkinter.tix"),
    MovedModule("tkinter_ttk", "ttk", "tkinter.ttk"),
    MovedModule("tkinter_constants", "Tkconstants", "tkinter.constants"),
    MovedModule("tkinter_dnd", "Tkdnd", "tkinter.dnd"),
    MovedModule("tkinter_colorchooser", "tkColorChooser",
                "tkinter.colorchooser"),
    MovedModule("tkinter_commondialog", "tkCommonDialog",
                "tkinter.commondialog"),
    MovedModule("tkinter_tkfiledialog", "tkFileDialog", "tkinter.filedialog"),
    MovedModule("tkinter_font", "tkFont", "tkinter.font"),
    MovedModule("tkinter_messagebox", "tkMessageBox", "tkinter.messagebox"),
    MovedModule("tkinter_tksimpledialog", "tkSimpleDialog",
                "tkinter.simpledialog"),
    MovedModule("urllib_parse", __name__ + ".moves.urllib_parse", "urllib.parse"),
    MovedModule("urllib_error", __name__ + ".moves.urllib_error", "urllib.error"),
    MovedModule("urllib", __name__ + ".moves.urllib", __name__ + ".moves.urllib"),
    MovedModule("urllib_robotparser", "robotparser", "urllib.robotparser"),
    MovedModule("xmlrpc_client", "xmlrpclib", "xmlrpc.client"),
    MovedModule("xmlrpc_server", "SimpleXMLRPCServer", "xmlrpc.server"),
]
# Add windows specific modules.
if sys.platform == "win32":
    _moved_attributes += [
        MovedModule("winreg", "_winreg"),
    ]

for attr in _moved_attributes:
    setattr(_MovedItems, attr.name, attr)
    if isinstance(attr, MovedModule):
        _importer._add_module(attr, "moves." + attr.name)
del attr

_MovedItems._moved_attributes = _moved_attributes

moves = _MovedItems(__name__ + ".moves")
_importer._add_module(moves, "moves")


class Module_six_moves_urllib_parse(_LazyModule):

    """Lazy loading of moved objects in six.moves.urllib_parse"""


_urllib_parse_moved_attributes = [
    MovedAttribute("ParseResult", "urlparse", "urllib.parse"),
    MovedAttribute("SplitResult", "urlparse", "urllib.parse"),
    MovedAttribute("parse_qs", "urlparse", "urllib.parse"),
    MovedAttribute("parse_qsl", "urlparse", "urllib.parse"),
    MovedAttribute("urldefrag", "urlparse", "urllib.parse"),
    MovedAttribute("urljoin", "urlparse", "urllib.parse"),
    MovedAttribute("urlparse", "urlparse", "urllib.parse"),
    MovedAttribute("urlsplit", "urlparse", "urllib.parse"),
    MovedAttribute("urlunparse", "urlparse", "urllib.parse"),
    MovedAttribute("urlunsplit", "urlparse", "urllib.parse"),
    MovedAttribute("quote", "urllib", "urllib.parse"),
    MovedAttribute("quote_plus", "urllib", "urllib.parse"),
    MovedAttribute("unquote", "urllib", "urllib.parse"),
    MovedAttribute("unquote_plus", "urllib", "urllib.parse"),
    MovedAttribute("unquote_to_bytes", "urllib", "urllib.parse", "unquote", "unquote_to_bytes"),
    MovedAttribute("urlencode", "urllib", "urllib.parse"),
    MovedAttribute("splitquery", "urllib", "urllib.parse"),
    MovedAttribute("splittag", "urllib", "urllib.parse"),
    MovedAttribute("splituser", "urllib", "urllib.parse"),
    MovedAttribute("splitvalue", "urllib", "urllib.parse"),
    MovedAttribute("uses_fragment", "urlparse", "urllib.parse"),
    MovedAttribute("uses_netloc", "urlparse", "urllib.parse"),
    MovedAttribute("uses_params", "urlparse", "urllib.parse"),
    MovedAttribute("uses_query", "urlparse", "urllib.parse"),
    MovedAttribute("uses_relative", "urlparse", "urllib.parse"),
]
for attr in _urllib_parse_moved_attributes:
    setattr(Module_six_moves_urllib_parse, attr.name, attr)
del attr

Module_six_moves_urllib_parse._moved_attributes = _urllib_parse_moved_attributes

_importer._add_module(Module_six_moves_urllib_parse(__name__ + ".moves.urllib_parse"),
                      "moves.urllib_parse", "moves.urllib.parse")


class Module_six_moves_urllib_error(_LazyModule):

    """Lazy loading of moved objects in six.moves.urllib_error"""


_urllib_error_moved_attributes = [
    MovedAttribute("URLError", "urllib2", "urllib.error"),
    MovedAttribute("HTTPError", "urllib2", "urllib.error"),
    MovedAttribute("ContentTooShortError", "urllib", "urllib.error"),
]
for attr in _urllib_error_moved_attributes:
    setattr(Module_six_moves_urllib_error, attr.name, attr)
del attr

Module_six_moves_urllib_error._moved_attributes = _urllib_error_moved_attributes

_importer._add_module(Module_six_moves_urllib_error(__name__ + ".moves.urllib.error"),
                      "moves.urllib_error", "moves.urllib.error")


class Module_six_moves_urllib_request(_LazyModule):

    """Lazy loading of moved objects in six.moves.urllib_request"""


_urllib_request_moved_attributes = [
    MovedAttribute("urlopen", "urllib2", "urllib.request"),
    MovedAttribute("install_opener", "urllib2", "urllib.request"),
    MovedAttribute("build_opener", "urllib2", "urllib.request"),
    MovedAttribute("pathname2url", "urllib", "urllib.request"),
    MovedAttribute("url2pathname", "urllib", "urllib.request"),
    MovedAttribute("getproxies", "urllib", "urllib.request"),
    MovedAttribute("Request", "urllib2", "urllib.request"),
    MovedAttribute("OpenerDirector", "urllib2", "urllib.request"),
    MovedAttribute("HTTPDefaultErrorHandler", "urllib2", "urllib.request"),
    MovedAttribute("HTTPRedirectHandler", "urllib2", "urllib.request"),
    MovedAttribute("HTTPCookieProcessor", "urllib2", "urllib.request"),
    MovedAttribute("ProxyHandler", "urllib2", "urllib.request"),
    MovedAttribute("BaseHandler", "urllib2", "urllib.request"),
    MovedAttribute("HTTPPasswordMgr", "urllib2", "urllib.request"),
    MovedAttribute("HTTPPasswordMgrWithDefaultRealm", "urllib2", "urllib.request"),
    MovedAttribute("AbstractBasicAuthHandler", "urllib2", "urllib.request"),
    MovedAttribute("HTTPBasicAuthHandler", "urllib2", "urllib.request"),
    MovedAttribute("ProxyBasicAuthHandler", "urllib2", "urllib.request"),
    MovedAttribute("AbstractDigestAuthHandler", "urllib2", "urllib.request"),
    MovedAttribute("HTTPDigestAuthHandler", "urllib2", "urllib.request"),
    MovedAttribute("ProxyDigestAuthHandler", "urllib2", "urllib.request"),
    MovedAttribute("HTTPHandler", "urllib2", "urllib.request"),
    MovedAttribute("HTTPSHandler", "urllib2", "urllib.request"),
    MovedAttribute("FileHandler", "urllib2", "urllib.request"),
    MovedAttribute("FTPHandler", "urllib2", "urllib.request"),
    MovedAttribute("CacheFTPHandler", "urllib2", "urllib.request"),
    MovedAttribute("UnknownHandler", "urllib2", "urllib.request"),
    MovedAttribute("HTTPErrorProcessor", "urllib2", "urllib.request"),
    MovedAttribute("urlretrieve", "urllib", "urllib.request"),
    MovedAttribute("urlcleanup", "urllib", "urllib.request"),
    MovedAttribute("URLopener", "urllib", "urllib.request"),
    MovedAttribute("FancyURLopener", "urllib", "urllib.request"),
    MovedAttribute("proxy_bypass", "urllib", "urllib.request"),
    MovedAttribute("parse_http_list", "urllib2", "urllib.request"),
    MovedAttribute("parse_keqv_list", "urllib2", "urllib.request"),
]
for attr in _urllib_request_moved_attributes:
    setattr(Module_six_moves_urllib_request, attr.name, attr)
del attr

Module_six_moves_urllib_request._moved_attributes = _urllib_request_moved_attributes

_importer._add_module(Module_six_moves_urllib_request(__name__ + ".moves.urllib.request"),
                      "moves.urllib_request", "moves.urllib.request")


class Module_six_moves_urllib_response(_LazyModule):

    """Lazy loading of moved objects in six.moves.urllib_response"""


_urllib_response_moved_attributes = [
    MovedAttribute("addbase", "urllib", "urllib.response"),
    MovedAttribute("addclosehook", "urllib", "urllib.response"),
    MovedAttribute("addinfo", "urllib", "urllib.response"),
    MovedAttribute("addinfourl", "urllib", "urllib.response"),
]
for attr in _urllib_response_moved_attributes:
    setattr(Module_six_moves_urllib_response, attr.name, attr)
del attr

Module_six_moves_urllib_response._moved_attributes = _urllib_response_moved_attributes

_importer._add_module(Module_six_moves_urllib_response(__name__ + ".moves.urllib.response"),
                      "moves.urllib_response", "moves.urllib.response")


class Module_six_moves_urllib_robotparser(_LazyModule):

    """Lazy loading of moved objects in six.moves.urllib_robotparser"""


_urllib_robotparser_moved_attributes = [
    MovedAttribute("RobotFileParser", "robotparser", "urllib.robotparser"),
]
for attr in _urllib_robotparser_moved_attributes:
    setattr(Module_six_moves_urllib_robotparser, attr.name, attr)
del attr

Module_six_moves_urllib_robotparser._moved_attributes = _urllib_robotparser_moved_attributes

_importer._add_module(Module_six_moves_urllib_robotparser(__name__ + ".moves.urllib.robotparser"),
                      "moves.urllib_robotparser", "moves.urllib.robotparser")


class Module_six_moves_urllib(types.ModuleType):

    """Create a six.moves.urllib namespace that resembles the Python 3 namespace"""
    __path__ = []  # mark as package
    parse = _importer._get_module("moves.urllib_parse")
    error = _importer._get_module("moves.urllib_error")
    request = _importer._get_module("moves.urllib_request")
    response = _importer._get_module("moves.urllib_response")
    robotparser = _importer._get_module("moves.urllib_robotparser")

    def __dir__(self):
        return ['parse', 'error', 'request', 'response', 'robotparser']

_importer._add_module(Module_six_moves_urllib(__name__ + ".moves.urllib"),
                      "moves.urllib")


def add_move(move):
    """Add an item to six.moves."""
    setattr(_MovedItems, move.name, move)


def remove_move(name):
    """Remove item from six.moves."""
    try:
        delattr(_MovedItems, name)
    except AttributeError:
        try:
            del moves.__dict__[name]
        except KeyError:
            raise AttributeError("no such move, %r" % (name,))


if PY3:
    _meth_func = "__func__"
    _meth_self = "__self__"

    _func_closure = "__closure__"
    _func_code = "__code__"
    _func_defaults = "__defaults__"
    _func_globals = "__globals__"
else:
    _meth_func = "im_func"
    _meth_self = "im_self"

    _func_closure = "func_closure"
    _func_code = "func_code"
    _func_defaults = "func_defaults"
    _func_globals = "func_globals"


try:
    advance_iterator = next
except NameError:
    def advance_iterator(it):
        return it.next()
next = advance_iterator


try:
    callable = callable
except NameError:
    def callable(obj):
        return any("__call__" in klass.__dict__ for klass in type(obj).__mro__)


if PY3:
    def get_unbound_function(unbound):
        return unbound

    create_bound_method = types.MethodType

    def create_unbound_method(func, cls):
        return func

    Iterator = object
else:
    def get_unbound_function(unbound):
        return unbound.im_func

    def create_bound_method(func, obj):
        return types.MethodType(func, obj, obj.__class__)

    def create_unbound_method(func, cls):
        return types.MethodType(func, None, cls)

    class Iterator(object):

        def next(self):
            return type(self).__next__(self)

    callable = callable
_add_doc(get_unbound_function,
         """Get the function out of a possibly unbound function""")


get_method_function = operator.attrgetter(_meth_func)
get_method_self = operator.attrgetter(_meth_self)
get_function_closure = operator.attrgetter(_func_closure)
get_function_code = operator.attrgetter(_func_code)
get_function_defaults = operator.attrgetter(_func_defaults)
get_function_globals = operator.attrgetter(_func_globals)


if PY3:
    def iterkeys(d, **kw):
        return iter(d.keys(**kw))

    def itervalues(d, **kw):
        return iter(d.values(**kw))

    def iteritems(d, **kw):
        return iter(d.items(**kw))

    def iterlists(d, **kw):
        return iter(d.lists(**kw))

    viewkeys = operator.methodcaller("keys")

    viewvalues = operator.methodcaller("values")

    viewitems = operator.methodcaller("items")
else:
    def iterkeys(d, **kw):
        return d.iterkeys(**kw)

    def itervalues(d, **kw):
        return d.itervalues(**kw)

    def iteritems(d, **kw):
        return d.iteritems(**kw)

    def iterlists(d, **kw):
        return d.iterlists(**kw)

    viewkeys = operator.methodcaller("viewkeys")

    viewvalues = operator.methodcaller("viewvalues")

    viewitems = operator.methodcaller("viewitems")

_add_doc(iterkeys, "Return an iterator over the keys of a dictionary.")
_add_doc(itervalues, "Return an iterator over the values of a dictionary.")
_add_doc(iteritems,
         "Return an iterator over the (key, value) pairs of a dictionary.")
_add_doc(iterlists,
         "Return an iterator over the (key, [values]) pairs of a dictionary.")


if PY3:
    def b(s):
        return s.encode("latin-1")

    def u(s):
        return s
    unichr = chr
    import struct
    int2byte = struct.Struct(">B").pack
    del struct
    byte2int = operator.itemgetter(0)
    indexbytes = operator.getitem
    iterbytes = iter
    import io
    StringIO = io.StringIO
    BytesIO = io.BytesIO
    _assertCountEqual = "assertCountEqual"
    if sys.version_info[1] <= 1:
        _assertRaisesRegex = "assertRaisesRegexp"
        _assertRegex = "assertRegexpMatches"
    else:
        _assertRaisesRegex = "assertRaisesRegex"
        _assertRegex = "assertRegex"
else:
    def b(s):
        return s
    # Workaround for standalone backslash

    def u(s):
        return unicode(s.replace(r'\\', r'\\\\'), "unicode_escape")
    unichr = unichr
    int2byte = chr

    def byte2int(bs):
        return ord(bs[0])

    def indexbytes(buf, i):
        return ord(buf[i])
    iterbytes = functools.partial(itertools.imap, ord)
    import StringIO
    StringIO = BytesIO = StringIO.StringIO
    _assertCountEqual = "assertItemsEqual"
    _assertRaisesRegex = "assertRaisesRegexp"
    _assertRegex = "assertRegexpMatches"
_add_doc(b, """Byte literal""")
_add_doc(u, """Text literal""")


def assertCountEqual(self, *args, **kwargs):
    return getattr(self, _assertCountEqual)(*args, **kwargs)


def assertRaisesRegex(self, *args, **kwargs):
    return getattr(self, _assertRaisesRegex)(*args, **kwargs)


def assertRegex(self, *args, **kwargs):
    return getattr(self, _assertRegex)(*args, **kwargs)


if PY3:
    exec_ = getattr(moves.builtins, "exec")

    def reraise(tp, value, tb=None):
        try:
            if value is None:
                value = tp()
            if value.__traceback__ is not tb:
                raise value.with_traceback(tb)
            raise value
        finally:
            value = None
            tb = None

else:
    def exec_(_code_, _globs_=None, _locs_=None):
        """Execute code in a namespace."""
        if _globs_ is None:
            frame = sys._getframe(1)
            _globs_ = frame.f_globals
            if _locs_ is None:
                _locs_ = frame.f_locals
            del frame
        elif _locs_ is None:
            _locs_ = _globs_
        exec("""exec _code_ in _globs_, _locs_""")

    exec_("""def reraise(tp, value, tb=None):
    try:
        raise tp, value, tb
    finally:
        tb = None
""")


if sys.version_info[:2] == (3, 2):
    exec_("""def raise_from(value, from_value):
    try:
        if from_value is None:
            raise value
        raise value from from_value
    finally:
        value = None
""")
elif sys.version_info[:2] > (3, 2):
    exec_("""def raise_from(value, from_value):
    try:
        raise value from from_value
    finally:
        value = None
""")
else:
    def raise_from(value, from_value):
        raise value


print_ = getattr(moves.builtins, "print", None)
if print_ is None:
    def print_(*args, **kwargs):
        """The new-style print function for Python 2.4 and 2.5."""
        fp = kwargs.pop("file", sys.stdout)
        if fp is None:
            return

        def write(data):
            if not isinstance(data, basestring):
                data = str(data)
            # If the file has an encoding, encode unicode with it.
            if (isinstance(fp, file) and
                    isinstance(data, unicode) and
                    fp.encoding is not None):
                errors = getattr(fp, "errors", None)
                if errors is None:
                    errors = "strict"
                data = data.encode(fp.encoding, errors)
            fp.write(data)
        want_unicode = False
        sep = kwargs.pop("sep", None)
        if sep is not None:
            if isinstance(sep, unicode):
                want_unicode = True
            elif not isinstance(sep, str):
                raise TypeError("sep must be None or a string")
        end = kwargs.pop("end", None)
        if end is not None:
            if isinstance(end, unicode):
                want_unicode = True
            elif not isinstance(end, str):
                raise TypeError("end must be None or a string")
        if kwargs:
            raise TypeError("invalid keyword arguments to print()")
        if not want_unicode:
            for arg in args:
                if isinstance(arg, unicode):
                    want_unicode = True
                    break
        if want_unicode:
            newline = unicode("\n")
            space = unicode(" ")
        else:
            newline = "\n"
            space = " "
        if sep is None:
            sep = space
        if end is None:
            end = newline
        for i, arg in enumerate(args):
            if i:
                write(sep)
            write(arg)
        write(end)
if sys.version_info[:2] < (3, 3):
    _print = print_

    def print_(*args, **kwargs):
        fp = kwargs.get("file", sys.stdout)
        flush = kwargs.pop("flush", False)
        _print(*args, **kwargs)
        if flush and fp is not None:
            fp.flush()

_add_doc(reraise, """Reraise an exception.""")

if sys.version_info[0:2] < (3, 4):
    def wraps(wrapped, assigned=functools.WRAPPER_ASSIGNMENTS,
              updated=functools.WRAPPER_UPDATES):
        def wrapper(f):
            f = functools.wraps(wrapped, assigned, updated)(f)
            f.__wrapped__ = wrapped
            return f
        return wrapper
else:
    wraps = functools.wraps


def with_metaclass(meta, *bases):
    """Create a base class with a metaclass."""
    # This requires a bit of explanation: the basic idea is to make a dummy
    # metaclass for one level of class instantiation that replaces itself with
    # the actual metaclass.
    class metaclass(type):

        def __new__(cls, name, this_bases, d):
            return meta(name, bases, d)

        @classmethod
        def __prepare__(cls, name, this_bases):
            return meta.__prepare__(name, bases)
    return type.__new__(metaclass, 'temporary_class', (), {})


def add_metaclass(metaclass):
    """Class decorator for creating a class with a metaclass."""
    def wrapper(cls):
        orig_vars = cls.__dict__.copy()
        slots = orig_vars.get('__slots__')
        if slots is not None:
            if isinstance(slots, str):
                slots = [slots]
            for slots_var in slots:
                orig_vars.pop(slots_var)
        orig_vars.pop('__dict__', None)
        orig_vars.pop('__weakref__', None)
        if hasattr(cls, '__qualname__'):
            orig_vars['__qualname__'] = cls.__qualname__
        return metaclass(cls.__name__, cls.__bases__, orig_vars)
    return wrapper


def ensure_binary(s, encoding='utf-8', errors='strict'):
    """Coerce **s** to six.binary_type.

    For Python 2:
      - `unicode` -> encoded to `str`
      - `str` -> `str`

    For Python 3:
      - `str` -> encoded to `bytes`
      - `bytes` -> `bytes`
    """
    if isinstance(s, text_type):
        return s.encode(encoding, errors)
    elif isinstance(s, binary_type):
        return s
    else:
        raise TypeError("not expecting type '%s'" % type(s))


def ensure_str(s, encoding='utf-8', errors='strict'):
    """Coerce *s* to `str`.

    For Python 2:
      - `unicode` -> encoded to `str`
      - `str` -> `str`

    For Python 3:
      - `str` -> `str`
      - `bytes` -> decoded to `str`
    """
    if not isinstance(s, (text_type, binary_type)):
        raise TypeError("not expecting type '%s'" % type(s))
    if PY2 and isinstance(s, text_type):
        s = s.encode(encoding, errors)
    elif PY3 and isinstance(s, binary_type):
        s = s.decode(encoding, errors)
    return s


def ensure_text(s, encoding='utf-8', errors='strict'):
    """Coerce *s* to six.text_type.

    For Python 2:
      - `unicode` -> `unicode`
      - `str` -> `unicode`

    For Python 3:
      - `str` -> `str`
      - `bytes` -> decoded to `str`
    """
    if isinstance(s, binary_type):
        return s.decode(encoding, errors)
    elif isinstance(s, text_type):
        return s
    else:
        raise TypeError("not expecting type '%s'" % type(s))



def python_2_unicode_compatible(klass):
    """
    A decorator that defines __unicode__ and __str__ methods under Python 2.
    Under Python 3 it does nothing.

    To support Python 2 and 3 with a single code base, define a __str__ method
    returning text and apply this decorator to the class.
    """
    if PY2:
        if '__str__' not in klass.__dict__:
            raise ValueError("@python_2_unicode_compatible cannot be applied "
                             "to %s because it doesn't define __str__()." %
                             klass.__name__)
        klass.__unicode__ = klass.__str__
        klass.__str__ = lambda self: self.__unicode__().encode('utf-8')
    return klass


# Complete the moves implementation.
# This code is at the end of this module to speed up module loading.
# Turn this module into a package.
__path__ = []  # required for PEP 302 and PEP 451
__package__ = __name__  # see PEP 366 @ReservedAssignment
if globals().get("__spec__") is not None:
    __spec__.submodule_search_locations = []  # PEP 451 @UndefinedVariable
# Remove other six meta path importers, since they cause problems. This can
# happen if six is removed from sys.modules and then reloaded. (Setuptools does
# this for some reason.)
if sys.meta_path:
    for i, importer in enumerate(sys.meta_path):
        # Here's some real nastiness: Another "instance" of the six module might
        # be floating around. Therefore, we can't use isinstance() to check for
        # the six meta path importer, since the other six instance will have
        # inserted an importer with different class.
        if (type(importer).__name__ == "_SixMetaPathImporter" and
                importer.name == __name__):
            del sys.meta_path[i]
            break
    del i, importer
# Finally, add the importer to the meta path import hook.
sys.meta_path.append(_importer)
                                                                                                                                                                                                                                                                                                                            
+v\~              K   @   sV  d  Z  d d l m Z d d l Z d d l Z d d l Z d d l Z d d l Z d Z d Z	 e j
 d d k Z e j
 d d k Z e j
 d d  dk Z e r e f Z e f Z e f Z e Z e Z e j Z n e f Z e e f Z e e j f Z e Z e Z e j j d	  r'e d Z nW Gd d   d e  Z  y e! e     Wn e" k
 rne d Z Yn Xe d Z [  d d   Z# d d   Z$ Gd d   d e  Z% Gd d   d e%  Z& Gd d   d e j'  Z( Gd d   d e%  Z) Gd d   d e  Z* e* e+  Z, Gd d   d e(  Z- e) d d d  d!  e) d" d# d$ d% d"  e) d& d# d# d' d&  e) d( d) d$ d* d(  e) d+ d) d,  e) d- d# d$ d. d-  e) d/ d0 d0 d1 d/  e) d2 d0 d0 d/ d2  e) d3 d4 d5  e) d6 d) d$ d7 d6  e) d8 d) e rd9 n d: d;  e) d< d) d=  e) d> d? d@ dA  e) d! d! d   e) dB dB dC  e) dD dD dC  e) dE dE dC  e) d7 d) d$ d7 d6  e) dF d# d$ dG dF  e) dH d# d# dI dH  e& d$ d)  e& dJ dK  e& dL dM  e& dN dO dP  e& dQ dR dQ  e& dS dT dU  e& dV dW dX  e& dY dZ d[  e& d\ d] d^  e& d_ d` da  e& db dc dd  e& de df dg  e& dh di dj  e& dk dl dm  e& dn do dp  e& dq dq dr  e& ds ds dr  e& dt dt dr  e& du du dv  e& dw dx  e& dy dz  e& d{ d|  e& d} d~ d}  e& d d  e& d d d  e& d d d  e& d d d  e& d d d  e& d d d  e& d d d  e& d d d  e& d d d  e& d d d  e& d d d  e& d d d  e& d d d  e& d d d  e& d d d  e& d e+ d d  e& d e+ d d  e& d e+ d e+ d  e& d d d  e& d d d  e& d d d  g@ Z. e j d k r`e. e& d d  g 7Z. xG e. D]? Z/ e0 e- e/ j1 e/  e2 e/ e&  rge, j3 e/ d e/ j1  qgW[/ e. e- _. e- e+ d  Z4 e, j3 e4 d  Gd d   d e(  Z5 e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) dA d d  e) d d d  e) d d d  e) d d d  e) d d d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  g Z6 x! e6 D] Z/ e0 e5 e/ j1 e/  qvW[/ e6 e5 _. e, j3 e5 e+ d  d d  Gd d   d e(  Z7 e) d d d  e) d d d  e) d d d  g Z8 x! e8 D] Z/ e0 e7 e/ j1 e/  q	W[/ e8 e7 _. e, j3 e7 e+ d  d d  Gd d   d e(  Z9 e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) d d d  e) dd d  e) dd d  e) dd d  e) dd d  e) dd d  e) dd d  e) dd d  e) dd d  e) d	d d  e) d
d d  g# Z: x! e: D] Z/ e0 e9 e/ j1 e/  qW[/ e: e9 _. e, j3 e9 e+ d dd Gdd  de(  Z; e) dd d e) dd d e) dd d e) dd d g Z< x! e< D] Z/ e0 e; e/ j1 e/  q'W[/ e< e; _. e, j3 e; e+ d dd Gdd  de(  Z= e) dd d  g Z> x! e> D] Z/ e0 e= e/ j1 e/  qW[/ e> e= _. e, j3 e= e+ d dd Gdd  de j'  Z? e, j3 e? e+ d  d  d!d"  Z@ d#d$  ZA e r]d%ZB d&ZC d'ZD d(ZE d)ZF d*ZG n$ d+ZB d,ZC d-ZD d.ZE d/ZF d0ZG y
 eH ZI Wn eJ k
 rd1d2  ZI Yn XeI ZH y
 eK ZK Wn eJ k
 rd3d4  ZK Yn Xe rd5d6  ZL e jM ZN d7d8  ZO e ZP n@ d9d6  ZL d:d;  ZN d<d8  ZO Gd=d>  d>e  ZP eK ZK e# eL d? e jQ eB  ZR e jQ eC  ZS e jQ eD  ZT e jQ eE  ZU e jQ eF  ZV e jQ eG  ZW e rd@dA  ZX dBdC  ZY dDdE  ZZ dFdG  Z[ e j\ dH Z] e j\ dI Z^ e j\ dJ Z_ n] dKdA  ZX dLdC  ZY dMdE  ZZ dNdG  Z[ e j\ dO Z] e j\ dP Z^ e j\ dQ Z_ e# eX dR e# eY dS e# eZ dT e# e[ dU e rcdVdW  Z` dXdY  Za eb Zc d d ld Zd ed je dZ jf Zg [d e jh d  Zi e jj Zk el Zm d d ln Zn en jo Zo en jp Zp d[Zq e j
 d
 d
 k rTd\Zr d]Zs qd^Zr d_Zs n| d`dW  Z` dadY  Za ec Zc eb Zg dbdc  Zi ddde  Zk e jt e ju ev  Zm d d lo Zo eo jo Zo Zp dfZq d\Zr d]Zs e# e` dg e# ea dh did[  Zw djd^  Zx dkd_  Zy e rGez e4 j{ dl Z| d dmdn Z} n d d dodp Z| e| dq e j
 d d  dk re| dr n2 e j
 d d  dk re| ds n dtdu  Z~ ez e4 j{ dvd  Z e d k rdwdx  Z e j
 d d  dk  re Z dydx  Z e# e} dz e j
 d d  dk  rTe j e j d{d| Z n	 e j Z d}d~  Z dd  Z dddd Z dddd Z dddd Z dd  Z g  Z e+ Z e   j d d k	 rg  e _ e j rBxL e e j  D]; \ Z Z e e  j+ d k re j1 e+ k re j e =PqW[ [ e j j e,  d S(  z6Utilities for writing code that runs on Python 2 and 3    )absolute_importNz'Benjamin Peterson <benjamin@python.org>z1.12.0         java      c               @   s   e  Z d  Z d d   Z d S)Xc             C   s   d S)Nr   r   l         )selfr
   r
   %/usr/lib/python3/dist-packages/six.py__len__>   s    z	X.__len__N)__name__
__module____qualname__r   r
   r
   r
   r   r	   <   s   r	   ?   c             C   s   | |  _  d S)z Add documentation to a function.N)__doc__)funcdocr
   r
   r   _add_docK   s    r   c             C   s   t  |   t j |  S)z7Import module, returning the module after the last dot.)
__import__sysmodules)namer
   r
   r   _import_moduleP   s    
r   c               @   s(   e  Z d  Z d d   Z d d   Z d S)
_LazyDescrc             C   s   | |  _  d  S)N)r   )r   r   r
   r
   r   __init__X   s    z_LazyDescr.__init__c             C   sO   |  j    } t | |  j |  y t | j |  j  Wn t k
 rJ Yn X| S)N)_resolvesetattrr   delattr	__class__AttributeError)r   objtpresultr
   r
   r   __get__[   s    z_LazyDescr.__get__N)r   r   r   r   r%   r
   r
   r
   r   r   V   s   r   c                   s=   e  Z d  Z d   f d d  Z d d   Z d d   Z   S)MovedModuleNc                sG   t  t |   j |  t r: | d  k r. | } | |  _ n	 | |  _ d  S)N)superr&   r   PY3mod)r   r   oldnew)r    r
   r   r   i   s    zMovedModule.__init__c             C   s   t  |  j  S)N)r   r)   )r   r
   r
   r   r   r   s    zMovedModule._resolvec             C   s/   |  j    } t | |  } t |  | |  | S)N)r   getattrr   )r   attr_modulevaluer
   r
   r   __getattr__u   s    zMovedModule.__getattr__)r   r   r   r   r   r0   r
   r
   )r    r   r&   g   s   	r&   c                   s4   e  Z d  Z   f d d   Z d d   Z g  Z   S)_LazyModulec                s)   t  t |   j |  |  j j |  _ d  S)N)r'   r1   r   r    r   )r   r   )r    r
   r   r   ~   s    z_LazyModule.__init__c             C   s*   d d g } | d d   |  j  D 7} | S)Nr   r   c             S   s   g  |  ] } | j   q Sr
   )r   ).0r-   r
   r
   r   
<listcomp>   s   	 z'_LazyModule.__dir__.<locals>.<listcomp>)_moved_attributes)r   Zattrsr
   r
   r   __dir__   s    z_LazyModule.__dir__)r   r   r   r   r5   r4   r
   r
   )r    r   r1   |   s   r1   c                   s4   e  Z d  Z d d   f d d  Z d d   Z   S)MovedAttributeNc                s   t  t |   j |  t rj | d  k r. | } | |  _ | d  k r^ | d  k rX | } n | } | |  _ n$ | |  _ | d  k r | } | |  _ d  S)N)r'   r6   r   r(   r)   r-   )r   r   Zold_modZnew_modZold_attrZnew_attr)r    r
   r   r      s    			zMovedAttribute.__init__c             C   s   t  |  j  } t | |  j  S)N)r   r)   r,   r-   )r   moduler
   r
   r   r      s    zMovedAttribute._resolve)r   r   r   r   r   r
   r
   )r    r   r6      s   r6   c               @   s   e  Z d  Z d Z d d   Z d d   Z d d   Z d d	 d
  Z d d   Z d d   Z	 d d   Z
 d d   Z e Z d S)_SixMetaPathImporterz
    A meta path importer to import six.moves and its submodules.

    This class implements a PEP302 finder and loader. It should be compatible
    with Python 2.5 and all existing versions of Python3
    c             C   s   | |  _  i  |  _ d  S)N)r   known_modules)r   Zsix_module_namer
   r
   r   r      s    	z_SixMetaPathImporter.__init__c             G   s-   x& | D] } | |  j  |  j d | <q Wd  S)N.)r9   r   )r   r)   Z	fullnamesfullnamer
   r
   r   _add_module   s    z _SixMetaPathImporter._add_modulec             C   s   |  j  |  j d | S)Nr:   )r9   r   )r   r;   r
   r
   r   _get_module   s    z _SixMetaPathImporter._get_moduleNc             C   s   | |  j  k r |  Sd  S)N)r9   )r   r;   pathr
   r
   r   find_module   s    z _SixMetaPathImporter.find_modulec             C   s8   y |  j  | SWn" t k
 r3 t d |   Yn Xd  S)Nz!This loader does not know module )r9   KeyErrorImportError)r   r;   r
   r
   r   Z__get_module   s    z!_SixMetaPathImporter.__get_modulec             C   sk   y t  j | SWn t k
 r# Yn X|  j |  } t | t  rQ | j   } n	 |  | _ | t  j | <| S)N)r   r   r@    _SixMetaPathImporter__get_module
isinstancer&   r   
__loader__)r   r;   r)   r
   r
   r   load_module   s    	z _SixMetaPathImporter.load_modulec             C   s   t  |  j |  d  S)z
        Return true, if the named module is a package.

        We need this method to get correct spec objects with
        Python 3.4 (see PEP451)
        __path__)hasattrrB   )r   r;   r
   r
   r   
is_package   s    z_SixMetaPathImporter.is_packagec             C   s   |  j  |  d S)z;Return None

        Required, if is_package is implementedN)rB   )r   r;   r
   r
   r   get_code   s    z_SixMetaPathImporter.get_code)r   r   r   r   r   r<   r=   r?   rB   rE   rH   rI   
get_sourcer
   r
   r
   r   r8      s   	r8   c               @   s   e  Z d  Z d Z g  Z d S)_MovedItemszLazy loading of moved objectsN)r   r   r   r   rF   r
   r
   r
   r   rK      s   rK   Z	cStringIOioStringIOfilter	itertoolsbuiltinsZifilterfilterfalseZifilterfalseinputZ__builtin__Z	raw_inputinternr   mapimapgetcwdosZgetcwdugetcwdbZ	getoutputZcommands
subprocessrangeZxrangeZreload_module	importlibimpreloadreduce	functoolsZshlex_quoteZpipesZshlexZquoteUserDictcollectionsUserList
UserStringzipZizipzip_longestZizip_longestZconfigparserZConfigParsercopyregZcopy_regZdbm_gnuZgdbmzdbm.gnuZ_dummy_threadZdummy_threadZhttp_cookiejarZ	cookielibzhttp.cookiejarZhttp_cookiesZCookiezhttp.cookiesZhtml_entitiesZhtmlentitydefszhtml.entitiesZhtml_parserZ
HTMLParserzhtml.parserZhttp_clientZhttplibzhttp.clientZemail_mime_basezemail.MIMEBasezemail.mime.baseZemail_mime_imagezemail.MIMEImagezemail.mime.imageZemail_mime_multipartzemail.MIMEMultipartzemail.mime.multipartZemail_mime_nonmultipartzemail.MIMENonMultipartzemail.mime.nonmultipartZemail_mime_textzemail.MIMETextzemail.mime.textZBaseHTTPServerzhttp.serverZCGIHTTPServerZSimpleHTTPServerZcPicklepickleZqueueZQueuereprlibreprZsocketserverZSocketServer_threadZthreadZtkinterZTkinterZtkinter_dialogZDialogztkinter.dialogZtkinter_filedialogZ
FileDialogztkinter.filedialogZtkinter_scrolledtextZScrolledTextztkinter.scrolledtextZtkinter_simpledialogZSimpleDialogztkinter.simpledialogZtkinter_tixZTixztkinter.tixZtkinter_ttkZttkztkinter.ttkZtkinter_constantsZTkconstantsztkinter.constantsZtkinter_dndZTkdndztkinter.dndZtkinter_colorchooserZtkColorChooserztkinter.colorchooserZtkinter_commondialogZtkCommonDialogztkinter.commondialogZtkinter_tkfiledialogZtkFileDialogZtkinter_fontZtkFontztkinter.fontZtkinter_messageboxZtkMessageBoxztkinter.messageboxZtkinter_tksimpledialogZtkSimpleDialogZurllib_parsez.moves.urllib_parsezurllib.parseZurllib_errorz.moves.urllib_errorzurllib.errorZurllibz.moves.urllibZurllib_robotparserrobotparserzurllib.robotparserZxmlrpc_clientZ	xmlrpclibzxmlrpc.clientZxmlrpc_serverZSimpleXMLRPCServerzxmlrpc.serverwin32winreg_winregzmoves.z.movesmovesc               @   s   e  Z d  Z d Z d S)Module_six_moves_urllib_parsez7Lazy loading of moved objects in six.moves.urllib_parseN)r   r   r   r   r
   r
   r
   r   rp   B  s   rp   ZParseResultZurlparseZSplitResultZparse_qsZ	parse_qslZ	urldefragZurljoinZurlsplitZ
urlunparseZ
urlunsplitZ
quote_plusZunquoteZunquote_plusZunquote_to_bytesZ	urlencodeZ
splitqueryZsplittagZ	splituserZ
splitvalueZuses_fragmentZuses_netlocZuses_paramsZ
uses_queryZuses_relativezmoves.urllib_parsezmoves.urllib.parsec               @   s   e  Z d  Z d Z d S)Module_six_moves_urllib_errorz7Lazy loading of moved objects in six.moves.urllib_errorN)r   r   r   r   r
   r
   r
   r   rq   l  s   rq   ZURLErrorZurllib2Z	HTTPErrorZContentTooShortErrorz.moves.urllib.errorzmoves.urllib_errorzmoves.urllib.errorc               @   s   e  Z d  Z d Z d S)Module_six_moves_urllib_requestz9Lazy loading of moved objects in six.moves.urllib_requestN)r   r   r   r   r
   r
   r
   r   rr     s   rr   Zurlopenzurllib.requestZinstall_openerZbuild_openerZpathname2urlZurl2pathnameZ
getproxiesZRequestZOpenerDirectorZHTTPDefaultErrorHandlerZHTTPRedirectHandlerZHTTPCookieProcessorZProxyHandlerZBaseHandlerZHTTPPasswordMgrZHTTPPasswordMgrWithDefaultRealmZAbstractBasicAuthHandlerZHTTPBasicAuthHandlerZProxyBasicAuthHandlerZAbstractDigestAuthHandlerZHTTPDigestAuthHandlerZProxyDigestAuthHandlerZHTTPHandlerZHTTPSHandlerZFileHandlerZ
FTPHandlerZCacheFTPHandlerZUnknownHandlerZHTTPErrorProcessorZurlretrieveZ
urlcleanupZ	URLopenerZFancyURLopenerZproxy_bypassZparse_http_listZparse_keqv_listz.moves.urllib.requestzmoves.urllib_requestzmoves.urllib.requestc               @   s   e  Z d  Z d Z d S) Module_six_moves_urllib_responsez:Lazy loading of moved objects in six.moves.urllib_responseN)r   r   r   r   r
   r
   r
   r   rs     s   rs   Zaddbasezurllib.responseZaddclosehookZaddinfoZ
addinfourlz.moves.urllib.responsezmoves.urllib_responsezmoves.urllib.responsec               @   s   e  Z d  Z d Z d S)#Module_six_moves_urllib_robotparserz=Lazy loading of moved objects in six.moves.urllib_robotparserN)r   r   r   r   r
   r
   r
   r   rt     s   rt   ZRobotFileParserz.moves.urllib.robotparserzmoves.urllib_robotparserzmoves.urllib.robotparserc               @   ss   e  Z d  Z d Z g  Z e j d  Z e j d  Z e j d  Z	 e j d  Z
 e j d  Z d d   Z d	 S)
Module_six_moves_urllibzICreate a six.moves.urllib namespace that resembles the Python 3 namespacezmoves.urllib_parsezmoves.urllib_errorzmoves.urllib_requestzmoves.urllib_responsezmoves.urllib_robotparserc             C   s   d d d d d g S)Nparseerrorrequestresponserk   r
   )r   r
   r
   r   r5     s    zModule_six_moves_urllib.__dir__N)r   r   r   r   rF   	_importerr=   rv   rw   rx   ry   rk   r5   r
   r
   r
   r   ru     s   ru   zmoves.urllibc             C   s   t  t |  j |   d S)zAdd an item to six.moves.N)r   rK   r   )Zmover
   r
   r   add_move  s    r{   c             C   s`   y t  t |   WnH t k
 r[ y t j |  =Wn% t k
 rV t d |  f   Yn XYn Xd S)zRemove item from six.moves.zno such move, %rN)r   rK   r!   ro   __dict__r@   )r   r
   r
   r   remove_move  s    r}   __func____self____closure____code____defaults____globals__im_funcZim_selfZfunc_closureZ	func_codeZfunc_defaultsZfunc_globalsc             C   s
   |  j    S)N)next)itr
   r
   r   advance_iterator  s    r   c             C   s    t  d d   t |   j D  S)Nc             s   s   |  ] } d  | j  k Vq d S)__call__N)r|   )r2   klassr
   r
   r   	<genexpr>  s    zcallable.<locals>.<genexpr>)anytype__mro__)r"   r
   r
   r   callable  s    r   c             C   s   |  S)Nr
   )unboundr
   r
   r   get_unbound_function  s    r   c             C   s   |  S)Nr
   )r   clsr
   r
   r   create_unbound_method#  s    r   c             C   s   |  j  S)N)r   )r   r
   r
   r   r   (  s    c             C   s   t  j |  | | j  S)N)types
MethodTyper    )r   r"   r
   r
   r   create_bound_method+  s    r   c             C   s   t  j |  d  |  S)N)r   r   )r   r   r
   r
   r   r   .  s    c               @   s   e  Z d  Z d d   Z d S)Iteratorc             C   s   t  |   j |   S)N)r   __next__)r   r
   r
   r   r   3  s    zIterator.nextN)r   r   r   r   r
   r
   r
   r   r   1  s   r   z3Get the function out of a possibly unbound functionc             K   s   t  |  j |    S)N)iterkeys)dkwr
   r
   r   iterkeysD  s    r   c             K   s   t  |  j |    S)N)r   values)r   r   r
   r
   r   
itervaluesG  s    r   c             K   s   t  |  j |    S)N)r   items)r   r   r
   r
   r   	iteritemsJ  s    r   c             K   s   t  |  j |    S)N)r   Zlists)r   r   r
   r
   r   	iterlistsM  s    r   r   r   r   c             K   s   |  j  |   S)N)r   )r   r   r
   r
   r   r   V  s    c             K   s   |  j  |   S)N)r   )r   r   r
   r
   r   r   Y  s    c             K   s   |  j  |   S)N)r   )r   r   r
   r
   r   r   \  s    c             K   s   |  j  |   S)N)r   )r   r   r
   r
   r   r   _  s    viewkeys
viewvalues	viewitemsz1Return an iterator over the keys of a dictionary.z3Return an iterator over the values of a dictionary.z?Return an iterator over the (key, value) pairs of a dictionary.zBReturn an iterator over the (key, [values]) pairs of a dictionary.c             C   s   |  j  d  S)Nzlatin-1)encode)sr
   r
   r   bq  s    r   c             C   s   |  S)Nr
   )r   r
   r
   r   ut  s    r   z>BassertCountEqualZassertRaisesRegexpZassertRegexpMatchesassertRaisesRegexassertRegexc             C   s   |  S)Nr
   )r   r
   r
   r   r     s    c             C   s   t  |  j d d  d  S)Nz\\z\\\\Zunicode_escape)unicodereplace)r   r
   r
   r   r     s    c             C   s   t  |  d  S)Nr   )ord)Zbsr
   r
   r   byte2int  s    r   c             C   s   t  |  |  S)N)r   )Zbufir
   r
   r   
indexbytes  s    r   ZassertItemsEqualzByte literalzText literalc             O   s   t  |  t  | |   S)N)r,   _assertCountEqual)r   argskwargsr
   r
   r   r     s    c             O   s   t  |  t  | |   S)N)r,   _assertRaisesRegex)r   r   r   r
   r
   r   r     s    c             O   s   t  |  t  | |   S)N)r,   _assertRegex)r   r   r   r
   r
   r   r     s    execc          
   C   sQ   z= | d  k r |    } | j  | k	 r6 | j |   |  Wd  d  } d  } Xd  S)N)__traceback__with_traceback)r#   r/   tbr
   r
   r   reraise  s    	
r   c             C   s_   | d k r? t  j d  } | j } | d k r9 | j } ~ n | d k rQ | } t d  d S)zExecute code in a namespace.Nr   zexec _code_ in _globs_, _locs_)r   	_getframe	f_globalsf_localsr   )Z_code_Z_globs_Z_locs_framer
   r
   r   exec_  s    		r   zedef reraise(tp, value, tb=None):
    try:
        raise tp, value, tb
    finally:
        tb = None
zdef raise_from(value, from_value):
    try:
        if from_value is None:
            raise value
        raise value from from_value
    finally:
        value = None
zrdef raise_from(value, from_value):
    try:
        raise value from from_value
    finally:
        value = None
c             C   s
   |   d  S)Nr
   )r/   Z
from_valuer
   r
   r   
raise_from  s    r   printc        
         s  | j  d t j      d k r% d S  f d d   } d } | j  d d  } | d k	 r t | t  rs d } n t | t  s t d   | j  d	 d  } | d k	 r t | t  r d } n t | t  s t d
   | r t d   | sx$ |  D] } t | t  r d } Pq W| r?t d  } t d  } n d } d } | d k r]| } | d k ro| } x4 t |   D]& \ }	 } |	 r| |  | |  q|W| |  d S)z4The new-style print function for Python 2.4 and 2.5.fileNc                s   t  |  t  s t |   }  t    t  r t  |  t  r   j d  k	 r t   d d   } | d  k rl d } |  j   j |  }    j |   d  S)Nerrorsstrict)	rC   
basestringstrr   r   encodingr,   r   write)datar   )fpr
   r   r     s    zprint_.<locals>.writeFsepTzsep must be None or a stringendzend must be None or a stringz$invalid keyword arguments to print()
 )popr   stdoutrC   r   r   	TypeError	enumerate)
r   r   r   Zwant_unicoder   r   argnewlineZspacer   r
   )r   r   print_  sL    		
r   c              O   sT   | j  d t j  } | j d d  } t |  |   | rP | d  k	 rP | j   d  S)Nr   flushF)getr   r   r   _printr   )r   r   r   r   r
   r
   r   r     s
    zReraise an exception.c                s       f d d   } | S)Nc                s(   t  j      |   }   |  _ |  S)N)r_   wraps__wrapped__)f)assignedupdatedwrappedr
   r   wrapper*  s    	zwraps.<locals>.wrapperr
   )r   r   r   r   r
   )r   r   r   r   r   (  s    r   c                s5   G   f d d   d t   } t  j | d f  i   S)z%Create a base class with a metaclass.c                   s@   e  Z d  Z    f d d   Z e    f d d    Z d S)z!with_metaclass.<locals>.metaclassc                s    |   |  S)Nr
   )r   r   
this_basesr   )basesmetar
   r   __new__:  s    z)with_metaclass.<locals>.metaclass.__new__c                s    j  |    S)N)__prepare__)r   r   r   )r   r   r
   r   r   =  s    z-with_metaclass.<locals>.metaclass.__prepare__N)r   r   r   r   classmethodr   r
   )r   r   r
   r   	metaclass8  s   r   Ztemporary_class)r   r   )r   r   r   r
   )r   r   r   with_metaclass3  s    r   c                s     f d d   } | S)z6Class decorator for creating a class with a metaclass.c                s   |  j  j   } | j d  } | d  k	 r` t | t  rB | g } x | D] } | j |  qI W| j d d   | j d d   t |  d  r |  j | d <  |  j |  j	 |  S)N	__slots__r|   __weakref__r   )
r|   copyr   rC   r   r   rG   r   r   	__bases__)r   Z	orig_varsslotsZ	slots_var)r   r
   r   r   E  s    	zadd_metaclass.<locals>.wrapperr
   )r   r   r
   )r   r   add_metaclassC  s    r   zutf-8r   c             C   sL   t  |  t  r |  j | |  St  |  t  r2 |  St d t |     d S)zCoerce **s** to six.binary_type.

    For Python 2:
      - `unicode` -> encoded to `str`
      - `str` -> `str`

    For Python 3:
      - `str` -> encoded to `bytes`
      - `bytes` -> `bytes`
    znot expecting type '%s'N)rC   	text_typer   binary_typer   r   )r   r   r   r
   r
   r   ensure_binaryU  s
    r   c             C   s   t  |  t t f  s+ t d t |     t rU t  |  t  rU |  j | |  }  n' t r| t  |  t  r| |  j | |  }  |  S)zCoerce *s* to `str`.

    For Python 2:
      - `unicode` -> encoded to `str`
      - `str` -> `str`

    For Python 3:
      - `str` -> `str`
      - `bytes` -> decoded to `str`
    znot expecting type '%s')	rC   r   r   r   r   PY2r   r(   decode)r   r   r   r
   r
   r   
ensure_strh  s    r   c             C   sL   t  |  t  r |  j | |  St  |  t  r2 |  St d t |     d S)zCoerce *s* to six.text_type.

    For Python 2:
      - `unicode` -> `unicode`
      - `str` -> `unicode`

    For Python 3:
      - `str` -> `str`
      - `bytes` -> decoded to `str`
    znot expecting type '%s'N)rC   r   r   r   r   r   )r   r   r   r
   r
   r   ensure_text|  s
    r   c             C   sG   t  rC d |  j k r( t d |  j   |  j |  _ d d   |  _ |  S)a   
    A decorator that defines __unicode__ and __str__ methods under Python 2.
    Under Python 3 it does nothing.

    To support Python 2 and 3 with a single code base, define a __str__ method
    returning text and apply this decorator to the class.
    __str__zY@python_2_unicode_compatible cannot be applied to %s because it doesn't define __str__().c             S   s   |  j    j d  S)Nzutf-8)__unicode__r   )r   r
   r
   r   <lambda>  s    z-python_2_unicode_compatible.<locals>.<lambda>)r   r|   
ValueErrorr   r   r   )r   r
   r
   r   python_2_unicode_compatible  s    r   __spec__)r   r   l        il        il            l    )r   r   )r   r   )r   r   )r   r   )r   Z
__future__r   r_   rO   operatorr   r   
__author____version__version_infor   r(   ZPY34r   Zstring_typesintZinteger_typesr   Zclass_typesr   bytesr   maxsizeZMAXSIZEr   ZlongZ	ClassTyper   platform
startswithobjectr	   lenOverflowErrorr   r   r   r&   
ModuleTyper1   r6   r8   r   rz   rK   r4   r-   r   r   rC   r<   ro   rp   Z_urllib_parse_moved_attributesrq   Z_urllib_error_moved_attributesrr   Z _urllib_request_moved_attributesrs   Z!_urllib_response_moved_attributesrt   Z$_urllib_robotparser_moved_attributesru   r{   r}   Z
_meth_funcZ
_meth_selfZ_func_closureZ
_func_codeZ_func_defaultsZ_func_globalsr   r   	NameErrorr   r   r   r   r   r   
attrgetterZget_method_functionZget_method_selfZget_function_closureZget_function_codeZget_function_defaultsZget_function_globalsr   r   r   r   methodcallerr   r   r   r   r   chrZunichrZstructZStructZpackZint2byte
itemgetterr   getitemr   r   Z	iterbytesrL   rM   BytesIOr   r   r   partialrU   r   r   r   r   r,   rP   r   r   r   r   r   WRAPPER_ASSIGNMENTSWRAPPER_UPDATESr   r   r   r   r   r   r   rF   __package__globalsr   r   submodule_search_locations	meta_pathr   r   importerappendr
   r
   r
   r   <module>   s  				>					
	
	
	
	
	

							

5			
                                                                                                                                                                                                                        #  Copyright (c) 2005-2009 Canonical
#
#  Author: Michael Vogt <michael.vogt@ubuntu.com>
#
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License as
#  published by the Free Software Foundation; either version 2 of the
#  License, or (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
#  USA
# import the core of apt_pkg
"""High-Level Interface for working with apt."""
from __future__ import print_function

import apt_pkg

# import some fancy classes
from apt.package import Package
from apt.cache import Cache, ProblemResolver
Cache  # pyflakes
ProblemResolver  # pyflakes
from apt.cdrom import Cdrom

# init the package system, but do not re-initialize config
if "APT" not in apt_pkg.config:
    apt_pkg.init_config()
apt_pkg.init_system()

__all__ = ['Cache', 'Cdrom', 'Package']
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                # cache.py - apt cache abstraction
#
#  Copyright (c) 2005-2009 Canonical
#
#  Author: Michael Vogt <michael.vogt@ubuntu.com>
#
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License as
#  published by the Free Software Foundation; either version 2 of the
#  License, or (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
#  USA

from __future__ import print_function

import fnmatch
import os
import warnings
import weakref

import apt_pkg
from apt import Package
import apt.progress.text


class FetchCancelledException(IOError):
    """Exception that is thrown when the user cancels a fetch operation."""


class FetchFailedException(IOError):
    """Exception that is thrown when fetching fails."""


class LockFailedException(IOError):
    """Exception that is thrown when locking fails."""


class CacheClosedException(Exception):
    """Exception that is thrown when the cache is used after close()."""


class Cache(object):
    """Dictionary-like package cache.

    The APT cache file contains a hash table mapping names of binary
    packages to their metadata. A Cache object is the in-core
    representation of the same. It provides access to APTs idea of the
    list of available packages.

    The cache can be used like a mapping from package names to Package
    objects (although only getting items is supported).

    Keyword arguments:
    progress -- a OpProgress object,
    rootdir  -- an alternative root directory. if that is given the system
    sources.list and system lists/files are not read, only file relative
    to the given rootdir,
    memonly  -- build the cache in memory only.


    .. versionchanged:: 1.0

        The cache now supports package names with special architecture
        qualifiers such as :all and :native. It does not export them
        in :meth:`keys()`, though, to keep :meth:`keys()` a unique set.
    """

    def __init__(self, progress=None, rootdir=None, memonly=False):
        self._cache = None
        self._depcache = None
        self._records = None
        self._list = None
        self._callbacks = {}
        self._callbacks2 = {}
        self._weakref = weakref.WeakValueDictionary()
        self._changes_count = -1
        self._sorted_set = None

        self.connect("cache_post_open", "_inc_changes_count")
        self.connect("cache_post_change", "_inc_changes_count")
        if memonly:
            # force apt to build its caches in memory
            apt_pkg.config.set("Dir::Cache::pkgcache", "")
        if rootdir:
            rootdir = os.path.abspath(rootdir)
            if os.path.exists(rootdir + "/etc/apt/apt.conf"):
                apt_pkg.read_config_file(apt_pkg.config,
                                         rootdir + "/etc/apt/apt.conf")
            if os.path.isdir(rootdir + "/etc/apt/apt.conf.d"):
                apt_pkg.read_config_dir(apt_pkg.config,
                                        rootdir + "/etc/apt/apt.conf.d")
            apt_pkg.config.set("Dir", rootdir)
            apt_pkg.config.set("Dir::State::status",
                               rootdir + "/var/lib/dpkg/status")
            # also set dpkg to the rootdir path so that its called for the
            # --print-foreign-architectures call
            apt_pkg.config.set("Dir::bin::dpkg",
                               os.path.join(rootdir, "usr", "bin", "dpkg"))
            # create required dirs/files when run with special rootdir
            # automatically
            self._check_and_create_required_dirs(rootdir)
            # Call InitSystem so the change to Dir::State::Status is actually
            # recognized (LP: #320665)
            apt_pkg.init_system()
        self.open(progress)

    def _inc_changes_count(self):
        """Increase the number of changes"""
        self._changes_count += 1

    def _check_and_create_required_dirs(self, rootdir):
        """
        check if the required apt directories/files are there and if
        not create them
        """
        files = ["/var/lib/dpkg/status",
                 "/etc/apt/sources.list",
                 ]
        dirs = ["/var/lib/dpkg",
                "/etc/apt/",
                "/var/cache/apt/archives/partial",
                "/var/lib/apt/lists/partial",
                ]
        for d in dirs:
            if not os.path.exists(rootdir + d):
                #print "creating: ", rootdir + d
                os.makedirs(rootdir + d)
        for f in files:
            if not os.path.exists(rootdir + f):
                open(rootdir + f, "w").close()

    def _run_callbacks(self, name):
        """ internal helper to run a callback """
        if name in self._callbacks:
            for callback in self._callbacks[name]:
                if callback == '_inc_changes_count':
                    self._inc_changes_count()
                else:
                    callback()

        if name in self._callbacks2:
            for callback, args, kwds in self._callbacks2[name]:
                    callback(self, *args, **kwds)

    def open(self, progress=None):
        """ Open the package cache, after that it can be used like
            a dictionary
        """
        if progress is None:
            progress = apt.progress.base.OpProgress()
        # close old cache on (re)open
        self.close()
        self.op_progress = progress
        self._run_callbacks("cache_pre_open")

        self._cache = apt_pkg.Cache(progress)
        self._depcache = apt_pkg.DepCache(self._cache)
        self._records = apt_pkg.PackageRecords(self._cache)
        self._list = apt_pkg.SourceList()
        self._list.read_main_list()
        self._sorted_set = None
        self._weakref.clear()

        self._have_multi_arch = len(apt_pkg.get_architectures()) > 1

        progress.done()
        self._run_callbacks("cache_post_open")

    def close(self):
        """ Close the package cache """
        # explicitely free the FDs that _records has open
        del self._records
        self._records = None

    def __enter__(self):
        """ Enter the with statement """
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        """ Exit the with statement """
        self.close()

    def __getitem__(self, key):
        """ look like a dictionary (get key) """
        try:
            return self._weakref[key]
        except KeyError:
            key = str(key)
            try:
                rawpkg = self._cache[key]
            except KeyError:
                raise KeyError('The cache has no package named %r' % key)

            # It might be excluded due to not having a version or something
            if not self.__is_real_pkg(rawpkg):
                raise KeyError('The cache has no package named %r' % key)

            pkg = self._rawpkg_to_pkg(rawpkg)
            self._weakref[key] = pkg

            return pkg

    def get(self, key, default=None):
        """Return *self*[*key*] or *default* if *key* not in *self*.

        .. versionadded:: 1.1
        """
        try:
            return self[key]
        except KeyError:
            return default

    def _rawpkg_to_pkg(self, rawpkg):
        """Returns the apt.Package object for an apt_pkg.Package object.

        .. versionadded:: 1.0.0
        """
        fullname = rawpkg.get_fullname(pretty=False)
        try:
            pkg = self._weakref[fullname]
        except KeyError:
            pkg = Package(self, rawpkg)
            self._weakref[fullname] = pkg
        return pkg

    def __iter__(self):
        # We iterate sorted over package names here. With this we read the
        # package lists linearly if we need to access the package records,
        # instead of having to do thousands of random seeks; the latter
        # is disastrous if we use compressed package indexes, and slower than
        # necessary for uncompressed indexes.
        for pkgname in self.keys():
            yield self[pkgname]

    def __is_real_pkg(self, rawpkg):
        """Check if the apt_pkg.Package provided is a real package."""
        return rawpkg.has_versions

    def has_key(self, key):
        return key in self

    def __contains__(self, key):
        try:
            return self.__is_real_pkg(self._cache[key])
        except KeyError:
            return False

    def __len__(self):
        return len(self.keys())

    def keys(self):
        if self._sorted_set is None:
            self._sorted_set = sorted(p.get_fullname(pretty=True)
                                      for p in self._cache.packages
                                        if self.__is_real_pkg(p))
        return list(self._sorted_set)  # We need a copy here, caller may modify

    def get_changes(self):
        """ Get the marked changes """
        changes = []
        marked_keep = self._depcache.marked_keep
        for rawpkg in self._cache.packages:
            if not marked_keep(rawpkg):
                changes.append(self._rawpkg_to_pkg(rawpkg))
        return changes

    def upgrade(self, dist_upgrade=False):
        """Upgrade all packages.

        If the parameter *dist_upgrade* is True, new dependencies will be
        installed as well (and conflicting packages may be removed). The
        default value is False.
        """
        self.cache_pre_change()
        self._depcache.upgrade(dist_upgrade)
        self.cache_post_change()

    @property
    def required_download(self):
        """Get the size of the packages that are required to download."""
        if self._records is None:
            raise CacheClosedException(
                "Cache object used after close() called")
        pm = apt_pkg.PackageManager(self._depcache)
        fetcher = apt_pkg.Acquire()
        pm.get_archives(fetcher, self._list, self._records)
        return fetcher.fetch_needed

    @property
    def required_space(self):
        """Get the size of the additional required space on the fs."""
        return self._depcache.usr_size

    @property
    def req_reinstall_pkgs(self):
        """Return the packages not downloadable packages in reqreinst state."""
        reqreinst = set()
        get_candidate_ver = self._depcache.get_candidate_ver
        states = frozenset((apt_pkg.INSTSTATE_REINSTREQ,
                            apt_pkg.INSTSTATE_HOLD_REINSTREQ))
        for pkg in self._cache.packages:
            cand = get_candidate_ver(pkg)
            if cand and not cand.downloadable and pkg.inst_state in states:
                reqreinst.add(pkg.get_fullname(pretty=True))
        return reqreinst

    def _run_fetcher(self, fetcher):
        # do the actual fetching
        res = fetcher.run()

        # now check the result (this is the code from apt-get.cc)
        failed = False
        err_msg = ""
        for item in fetcher.items:
            if item.status == item.STAT_DONE:
                continue
            if item.STAT_IDLE:
                continue
            err_msg += "Failed to fetch %s %s\n" % (item.desc_uri,
                                                    item.error_text)
            failed = True

        # we raise a exception if the download failed or it was cancelt
        if res == fetcher.RESULT_CANCELLED:
            raise FetchCancelledException(err_msg)
        elif failed:
            raise FetchFailedException(err_msg)
        return res

    def _fetch_archives(self, fetcher, pm):
        """ fetch the needed archives """
        if self._records is None:
            raise CacheClosedException(
                "Cache object used after close() called")

        # get lock
        lockfile = apt_pkg.config.find_dir("Dir::Cache::Archives") + "lock"
        lock = apt_pkg.get_lock(lockfile)
        if lock < 0:
            raise LockFailedException("Failed to lock %s" % lockfile)

        try:
            # this may as well throw a SystemError exception
            if not pm.get_archives(fetcher, self._list, self._records):
                return False
            # now run the fetcher, throw exception if something fails to be
            # fetched
            return self._run_fetcher(fetcher)
        finally:
            os.close(lock)

    def fetch_archives(self, progress=None, fetcher=None):
        """Fetch the archives for all packages marked for install/upgrade.

        You can specify either an :class:`apt.progress.base.AcquireProgress()`
        object for the parameter *progress*, or specify an already
        existing :class:`apt_pkg.Acquire` object for the parameter *fetcher*.

        The return value of the function is undefined. If an error occurred,
        an exception of type :class:`FetchFailedException` or
        :class:`FetchCancelledException` is raised.

        .. versionadded:: 0.8.0
        """
        if progress is not None and fetcher is not None:
            raise ValueError("Takes a progress or a an Acquire object")
        if progress is None:
            progress = apt.progress.text.AcquireProgress()
        if fetcher is None:
            fetcher = apt_pkg.Acquire(progress)

        return self._fetch_archives(fetcher,
                                    apt_pkg.PackageManager(self._depcache))

    def is_virtual_package(self, pkgname):
        """Return whether the package is a virtual package."""
        try:
            pkg = self._cache[pkgname]
        except KeyError:
            return False
        else:
            return bool(pkg.has_provides and not pkg.has_versions)

    def get_providing_packages(self, pkgname, candidate_only=True,
                               include_nonvirtual=False):
        """Return a list of all packages providing a package.

        Return a list of packages which provide the virtual package of the
        specified name.

        If 'candidate_only' is False, return all packages with at
        least one version providing the virtual package. Otherwise,
        return only those packages where the candidate version
        provides the virtual package.

        If 'include_nonvirtual' is True then it will search for all
        packages providing pkgname, even if pkgname is not itself
        a virtual pkg.
        """

        providers = set()
        get_candidate_ver = self._depcache.get_candidate_ver
        try:
            vp = self._cache[pkgname]
            if vp.has_versions and not include_nonvirtual:
                return list(providers)
        except KeyError:
            return list(providers)

        for provides, providesver, version in vp.provides_list:
            rawpkg = version.parent_pkg
            if not candidate_only or (version == get_candidate_ver(rawpkg)):
                providers.add(self._rawpkg_to_pkg(rawpkg))
        return list(providers)

    def update(self, fetch_progress=None, pulse_interval=0,
               raise_on_error=True, sources_list=None):
        """Run the equivalent of apt-get update.

        You probably want to call open() afterwards, in order to utilise the
        new cache. Otherwise, the old cache will be used which can lead to
        strange bugs.

        The first parameter *fetch_progress* may be set to an instance of
        apt.progress.FetchProgress, the default is apt.progress.FetchProgress()
        .
        sources_list -- Update a alternative sources.list than the default.
        Note that the sources.list.d directory is ignored in this case
        """
        lockfile = apt_pkg.config.find_dir("Dir::State::Lists") + "lock"
        lock = apt_pkg.get_lock(lockfile)

        if lock < 0:
            raise LockFailedException("Failed to lock %s" % lockfile)

        if sources_list:
            old_sources_list = apt_pkg.config.find("Dir::Etc::sourcelist")
            old_sources_list_d = apt_pkg.config.find("Dir::Etc::sourceparts")
            old_cleanup = apt_pkg.config.find("APT::List-Cleanup")
            apt_pkg.config.set("Dir::Etc::sourcelist",
                               os.path.abspath(sources_list))
            apt_pkg.config.set("Dir::Etc::sourceparts", "xxx")
            apt_pkg.config.set("APT::List-Cleanup", "0")
            slist = apt_pkg.SourceList()
            slist.read_main_list()
        else:
            slist = self._list

        try:
            if fetch_progress is None:
                fetch_progress = apt.progress.base.AcquireProgress()
            try:
                res = self._cache.update(fetch_progress, slist,
                                         pulse_interval)
            except SystemError as e:
                raise FetchFailedException(e)
            if not res and raise_on_error:
                raise FetchFailedException()
            else:
                return res
        finally:
            os.close(lock)
            if sources_list:
                apt_pkg.config.set("Dir::Etc::sourcelist", old_sources_list)
                apt_pkg.config.set("Dir::Etc::sourceparts", old_sources_list_d)
                apt_pkg.config.set("APT::List-Cleanup", old_cleanup)

    def install_archives(self, pm, install_progress):
        """
        The first parameter *pm* refers to an object returned by
        apt_pkg.PackageManager().

        The second parameter *install_progress* refers to an InstallProgress()
        object of the module apt.progress.
        """
        # compat with older API
        try:
            install_progress.startUpdate()
        except AttributeError:
            install_progress.start_update()
        res = install_progress.run(pm)
        try:
            install_progress.finishUpdate()
        except AttributeError:
            install_progress.finish_update()
        return res

    def commit(self, fetch_progress=None, install_progress=None):
        """Apply the marked changes to the cache.

        The first parameter, *fetch_progress*, refers to a FetchProgress()
        object as found in apt.progress, the default being
        apt.progress.FetchProgress().

        The second parameter, *install_progress*, is a
        apt.progress.InstallProgress() object.
        """
        # FIXME:
        # use the new acquire/pkgmanager interface here,
        # raise exceptions when a download or install fails
        # and send proper error strings to the application.
        # Current a failed download will just display "error"
        # which is less than optimal!

        if fetch_progress is None:
            fetch_progress = apt.progress.base.AcquireProgress()
        if install_progress is None:
            install_progress = apt.progress.base.InstallProgress()

        pm = apt_pkg.PackageManager(self._depcache)
        fetcher = apt_pkg.Acquire(fetch_progress)
        while True:
            # fetch archives first
            res = self._fetch_archives(fetcher, pm)

            # then install
            res = self.install_archives(pm, install_progress)
            if res == pm.RESULT_COMPLETED:
                break
            elif res == pm.RESULT_FAILED:
                raise SystemError("installArchives() failed")
            elif res == pm.RESULT_INCOMPLETE:
                pass
            else:
                raise SystemError("internal-error: unknown result code "
                                  "from InstallArchives: %s" % res)
            # reload the fetcher for media swaping
            fetcher.shutdown()
        return (res == pm.RESULT_COMPLETED)

    def clear(self):
        """ Unmark all changes """
        self._depcache.init()

    # cache changes

    def cache_post_change(self):
        " called internally if the cache has changed, emit a signal then "
        self._run_callbacks("cache_post_change")

    def cache_pre_change(self):
        """ called internally if the cache is about to change, emit
            a signal then """
        self._run_callbacks("cache_pre_change")

    def connect(self, name, callback):
        """Connect to a signal.

        .. deprecated:: 1.0

            Please use connect2() instead, as this function is very
            likely to cause a memory leak.
        """
        if callback != '_inc_changes_count':
            warnings.warn("connect() likely causes a reference"
                          " cycle, use connect2() instead", RuntimeWarning, 2)
        if name not in self._callbacks:
            self._callbacks[name] = []
        self._callbacks[name].append(callback)

    def connect2(self, name, callback, *args, **kwds):
        """Connect to a signal.

        The callback will be passed the cache as an argument, and
        any arguments passed to this function. Make sure that, if you
        pass a method of a class as your callback, your class does not
        contain a reference to the cache.

        Cyclic references to the cache can cause issues if the Cache object
        is replaced by a new one, because the cache keeps a lot of objects and
        tens of open file descriptors.

        currently only used for cache_{post,pre}_{changed,open}.

        .. versionadded:: 1.0
        """
        if name not in self._callbacks2:
            self._callbacks2[name] = []
        self._callbacks2[name].append((callback, args, kwds))

    def actiongroup(self):
        """Return an `ActionGroup` object for the current cache.

        Action groups can be used to speedup actions. The action group is
        active as soon as it is created, and disabled when the object is
        deleted or when release() is called.

        You can use the action group as a context manager, this is the
        recommended way::

            with cache.actiongroup():
                for package in my_selected_packages:
                    package.mark_install()

        This way, the action group is automatically released as soon as the
        with statement block is left. It also has the benefit of making it
        clear which parts of the code run with a action group and which
        don't.
        """
        return apt_pkg.ActionGroup(self._depcache)

    @property
    def dpkg_journal_dirty(self):
        """Return True if the dpkg was interrupted

        All dpkg operations will fail until this is fixed, the action to
        fix the system if dpkg got interrupted is to run
        'dpkg --configure -a' as root.
        """
        dpkg_status_dir = os.path.dirname(
            apt_pkg.config.find_file("Dir::State::status"))
        for f in os.listdir(os.path.join(dpkg_status_dir, "updates")):
            if fnmatch.fnmatch(f, "[0-9]*"):
                return True
        return False

    @property
    def broken_count(self):
        """Return the number of packages with broken dependencies."""
        return self._depcache.broken_count

    @property
    def delete_count(self):
        """Return the number of packages marked for deletion."""
        return self._depcache.del_count

    @property
    def install_count(self):
        """Return the number of packages marked for installation."""
        return self._depcache.inst_count

    @property
    def keep_count(self):
        """Return the number of packages marked as keep."""
        return self._depcache.keep_count


class ProblemResolver(object):
    """Resolve problems due to dependencies and conflicts.

    The first argument 'cache' is an instance of apt.Cache.
    """

    def __init__(self, cache):
        self._resolver = apt_pkg.ProblemResolver(cache._depcache)
        self._cache = cache

    def clear(self, package):
        """Reset the package to the default state."""
        self._resolver.clear(package._pkg)

    def install_protect(self):
        """mark protected packages for install or removal."""
        self._resolver.install_protect()

    def protect(self, package):
        """Protect a package so it won't be removed."""
        self._resolver.protect(package._pkg)

    def remove(self, package):
        """Mark a package for removal."""
        self._resolver.remove(package._pkg)

    def resolve(self):
        """Resolve dependencies, try to remove packages where needed."""
        self._cache.cache_pre_change()
        self._resolver.resolve()
        self._cache.cache_post_change()

    def resolve_by_keep(self):
        """Resolve dependencies, do not try to remove packages."""
        self._cache.cache_pre_change()
        self._resolver.resolve_by_keep()
        self._cache.cache_post_change()


# ----------------------------- experimental interface


class Filter(object):
    """ Filter base class """

    def apply(self, pkg):
        """ Filter function, return True if the package matchs a
            filter criteria and False otherwise
        """
        return True


class MarkedChangesFilter(Filter):
    """ Filter that returns all marked changes """

    def apply(self, pkg):
        if pkg.marked_install or pkg.marked_delete or pkg.marked_upgrade:
            return True
        else:
            return False


class InstalledFilter(Filter):
    """Filter that returns all installed packages.

    .. versionadded:: 1.0.0
    """

    def apply(self, pkg):
        return pkg.is_installed


class _FilteredCacheHelper(object):
    """Helper class for FilteredCache to break a reference cycle."""

    def __init__(self, cache):
        # Do not keep a reference to the cache, or you have a cycle!

        self._filtered = {}
        self._filters = {}
        cache.connect2("cache_post_change", self.filter_cache_post_change)
        cache.connect2("cache_post_open", self.filter_cache_post_change)

    def _reapply_filter(self, cache):
        " internal helper to refilter "
        # Do not keep a reference to the cache, or you have a cycle!
        self._filtered = {}
        for pkg in cache:
            for f in self._filters:
                if f.apply(pkg):
                    self._filtered[pkg.name] = 1
                    break

    def set_filter(self, filter):
        """Set the current active filter."""
        self._filters = []
        self._filters.append(filter)

    def filter_cache_post_change(self, cache):
        """Called internally if the cache changes, emit a signal then."""
        # Do not keep a reference to the cache, or you have a cycle!
        self._reapply_filter(cache)


class FilteredCache(object):
    """ A package cache that is filtered.

        Can work on a existing cache or create a new one
    """

    def __init__(self, cache=None, progress=None):
        if cache is None:
            self.cache = Cache(progress)
        else:
            self.cache = cache
        self._helper = _FilteredCacheHelper(self.cache)

    def __len__(self):
        return len(self._helper._filtered)

    def __getitem__(self, key):
        return self.cache[key]

    def __iter__(self):
        for pkgname in self._helper._filtered:
            yield self.cache[pkgname]

    def keys(self):
        return self._helper._filtered.keys()

    def has_key(self, key):
        return key in self

    def __contains__(self, key):
        try:
            # Normalize package name for multi arch
            return self.cache[key].name in self._helper._filtered
        except KeyError:
            return False

    def set_filter(self, filter):
        """Set the current active filter."""
        self._helper.set_filter(filter)
        self.cache.cache_post_change()

    def filter_cache_post_change(self):
        """Called internally if the cache changes, emit a signal then."""
        self._helper.filter_cache_post_change(self.cache)

    def __getattr__(self, key):
        """we try to look exactly like a real cache."""
        return getattr(self.cache, key)


def cache_pre_changed(cache):
    print("cache pre changed")


def cache_post_changed(cache):
    print("cache post changed")


def _test():
    """Internal test code."""
    print("Cache self test")
    apt_pkg.init()
    cache = Cache(apt.progress.text.OpProgress())
    cache.connect2("cache_pre_change", cache_pre_changed)
    cache.connect2("cache_post_change", cache_post_changed)
    print(("aptitude" in cache))
    pkg = cache["aptitude"]
    print(pkg.name)
    print(len(cache))

    for pkgname in cache.keys():
        assert cache[pkgname].name == pkgname

    cache.upgrade()
    changes = cache.get_changes()
    print(len(changes))
    for pkg in changes:
        assert pkg.name

    # see if fetching works
    for dirname in ["/tmp/pytest", "/tmp/pytest/partial"]:
        if not os.path.exists(dirname):
            os.mkdir(dirname)
    apt_pkg.config.set("Dir::Cache::Archives", "/tmp/pytest")
    pm = apt_pkg.PackageManager(cache._depcache)
    fetcher = apt_pkg.Acquire(apt.progress.text.AcquireProgress())
    cache._fetch_archives(fetcher, pm)
    #sys.exit(1)

    print("Testing filtered cache (argument is old cache)")
    filtered = FilteredCache(cache)
    filtered.cache.connect2("cache_pre_change", cache_pre_changed)
    filtered.cache.connect2("cache_post_change", cache_post_changed)
    filtered.cache.upgrade()
    filtered.set_filter(MarkedChangesFilter())
    print(len(filtered))
    for pkgname in filtered.keys():
        assert pkgname == filtered[pkg].name

    print(len(filtered))

    print("Testing filtered cache (no argument)")
    filtered = FilteredCache(progress=apt.progress.base.OpProgress())
    filtered.cache.connect2("cache_pre_change", cache_pre_changed)
    filtered.cache.connect2("cache_post_change", cache_post_changed)
    filtered.cache.upgrade()
    filtered.set_filter(MarkedChangesFilter())
    print(len(filtered))
    for pkgname in filtered.keys():
        assert pkgname == filtered[pkgname].name

    print(len(filtered))
if __name__ == '__main__':
    _test()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    #  Copyright (c) 2005-2010 Canonical
#
#  Author: Michael Vogt <michael.vogt@ubuntu.com>
#
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License as
#  published by the Free Software Foundation; either version 2 of the
#  License, or (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
#  USA
"""Classes for working with locally available Debian packages."""
from __future__ import print_function

import apt
import apt_inst
import apt_pkg
import gzip
import os
import sys

from apt_pkg import gettext as _
from io import BytesIO


class NoDebArchiveException(IOError):
    """Exception which is raised if a file is no Debian archive."""


class DebPackage(object):
    """A Debian Package (.deb file)."""

    # Constants for comparing the local package file with the version
    # in the cache
    (VERSION_NONE,
     VERSION_OUTDATED,
     VERSION_SAME,
     VERSION_NEWER) = range(4)

    debug = 0

    def __init__(self, filename=None, cache=None):
        if cache is None:
            cache = apt.Cache()
        self._cache = cache
        self._debfile = None
        self.pkgname = ""
        self._sections = {}
        self._need_pkgs = []
        self._check_was_run = False
        self._failure_string = ""
        self._multiarch = None
        if filename:
            self.open(filename)

    def open(self, filename):
        """ open given debfile """
        self._dbg(3, "open '%s'" % filename)
        self._need_pkgs = []
        self._installed_conflicts = set()
        self._failure_string = ""
        self.filename = filename
        self._debfile = apt_inst.DebFile(self.filename)
        control = self._debfile.control.extractdata("control")
        self._sections = apt_pkg.TagSection(control)
        self.pkgname = self._sections["Package"]
        self._check_was_run = False

    def __getitem__(self, key):
        return self._sections[key]

    def __contains__(self, key):
        return key in self._sections

    @property
    def filelist(self):
        """return the list of files in the deb."""
        files = []
        try:
            self._debfile.data.go(lambda item, data: files.append(item.name))
        except SystemError:
            return [_("List of files for '%s' could not be read") %
                    self.filename]
        return files

    @property
    def control_filelist(self):
        """ return the list of files in control.tar.gz """
        control = []
        try:
            self._debfile.control.go(
                lambda item, data: control.append(item.name))
        except SystemError:
            return [_("List of control files for '%s' could not be read") %
                    self.filename]
        return sorted(control)

    # helper that will return a pkgname with a multiarch suffix if needed
    def _maybe_append_multiarch_suffix(self, pkgname,
                                       in_conflict_checking=False):
        # trivial cases
        if ":" in pkgname:
            return pkgname
        if not self._multiarch:
            return pkgname
        elif self._cache.is_virtual_package(pkgname):
            return pkgname
        elif (pkgname in self._cache and
              self._cache[pkgname].candidate and
              self._cache[pkgname].candidate.architecture == "all"):
            return pkgname
        # now do the real multiarch checking
        multiarch_pkgname = "%s:%s" % (pkgname, self._multiarch)
        # the upper layers will handle this
        if multiarch_pkgname not in self._cache:
            return multiarch_pkgname
        # now check the multiarch state
        cand = self._cache[multiarch_pkgname].candidate._cand
        #print pkgname, multiarch_pkgname, cand.multi_arch
        # the default is to add the suffix, unless its a pkg that can satify
        # foreign dependencies
        if cand.multi_arch & cand.MULTI_ARCH_FOREIGN:
            return pkgname
        # for conflicts we need a special case here, any not multiarch enabled
        # package has a implicit conflict
        if (in_conflict_checking and
                not (cand.multi_arch & cand.MULTI_ARCH_SAME)):
            return pkgname
        return multiarch_pkgname

    def _is_or_group_satisfied(self, or_group):
        """Return True if at least one dependency of the or-group is satisfied.

        This method gets an 'or_group' and analyzes if at least one dependency
        of this group is already satisfied.
        """
        self._dbg(2, "_checkOrGroup(): %s " % (or_group))

        for dep in or_group:
            depname = dep[0]
            ver = dep[1]
            oper = dep[2]

            # multiarch
            depname = self._maybe_append_multiarch_suffix(depname)

            # check for virtual pkgs
            if depname not in self._cache:
                if self._cache.is_virtual_package(depname):
                    self._dbg(
                        3, "_is_or_group_satisfied(): %s is virtual dep" %
                        depname)
                    for pkg in self._cache.get_providing_packages(depname):
                        if pkg.is_installed:
                            return True
                continue
            # check real dependency
            inst = self._cache[depname].installed
            if inst is not None and apt_pkg.check_dep(inst.version, oper, ver):
                return True

            # if no real dependency is installed, check if there is
            # a package installed that provides this dependency
            # (e.g. scrollkeeper dependecies are provided by rarian-compat)
            # but only do that if there is no version required in the
            # dependency (we do not supprot versionized dependencies)
            if not oper:
                for ppkg in self._cache.get_providing_packages(
                    depname, include_nonvirtual=True):
                    if ppkg.is_installed:
                        self._dbg(
                            3, "found installed '%s' that provides '%s'" % (
                                ppkg.name, depname))
                        return True
        return False

    def _satisfy_or_group(self, or_group):
        """Try to satisfy the or_group."""
        for dep in or_group:
            depname, ver, oper = dep

            # multiarch
            depname = self._maybe_append_multiarch_suffix(depname)

            # if we don't have it in the cache, it may be virtual
            if depname not in self._cache:
                if not self._cache.is_virtual_package(depname):
                    continue
                providers = self._cache.get_providing_packages(depname)
                # if a package just has a single virtual provider, we
                # just pick that (just like apt)
                if len(providers) != 1:
                    continue
                depname = providers[0].name

            # now check if we can satisfy the deps with the candidate(s)
            # in the cache
            pkg = self._cache[depname]
            cand = self._cache._depcache.get_candidate_ver(pkg._pkg)
            if not cand:
                continue
            if not apt_pkg.check_dep(cand.ver_str, oper, ver):
                continue

            # check if we need to install it
            self._dbg(2, "Need to get: %s" % depname)
            self._need_pkgs.append(depname)
            return True

        # if we reach this point, we failed
        or_str = ""
        for dep in or_group:
            or_str += dep[0]
            if ver and oper:
                or_str += " (%s %s)" % (dep[2], dep[1])
            if dep != or_group[len(or_group) - 1]:
                or_str += "|"
        self._failure_string += _(
            "Dependency is not satisfiable: %s\n") % or_str
        return False

    def _check_single_pkg_conflict(self, pkgname, ver, oper):
        """Return True if a pkg conflicts with a real installed/marked pkg."""
        # FIXME: deal with conflicts against its own provides
        #        (e.g. Provides: ftp-server, Conflicts: ftp-server)
        self._dbg(
            3, "_check_single_pkg_conflict() pkg='%s' ver='%s' oper='%s'" % (
                pkgname, ver, oper))
        pkg = self._cache[pkgname]
        if pkg.is_installed:
            pkgver = pkg.installed.version
        elif pkg.marked_install:
            pkgver = pkg.candidate.version
        else:
            return False
        #print "pkg: %s" % pkgname
        #print "ver: %s" % ver
        #print "pkgver: %s " % pkgver
        #print "oper: %s " % oper
        if (apt_pkg.check_dep(pkgver, oper, ver) and not
                self.replaces_real_pkg(pkgname, oper, ver)):
            self._failure_string += _("Conflicts with the installed package "
                                      "'%s'") % pkg.name
            self._dbg(3, "conflicts with installed pkg '%s'" % pkg.name)
            return True
        return False

    def _check_conflicts_or_group(self, or_group):
        """Check the or-group for conflicts with installed pkgs."""
        self._dbg(2, "_check_conflicts_or_group(): %s " % (or_group))
        for dep in or_group:
            depname = dep[0]
            ver = dep[1]
            oper = dep[2]

            # FIXME: is this good enough? i.e. will apt always populate
            #        the cache with conflicting pkgnames for our arch?
            depname = self._maybe_append_multiarch_suffix(
                depname, in_conflict_checking=True)

            # check conflicts with virtual pkgs
            if depname not in self._cache:
                # FIXME: we have to check for virtual replaces here as
                #        well (to pass tests/gdebi-test8.deb)
                if self._cache.is_virtual_package(depname):
                    for pkg in self._cache.get_providing_packages(depname):
                        self._dbg(3, "conflicts virtual check: %s" % pkg.name)
                        # P/C/R on virtal pkg, e.g. ftpd
                        if self.pkgname == pkg.name:
                            self._dbg(3, "conflict on self, ignoring")
                            continue
                        if self._check_single_pkg_conflict(
                                pkg.name, ver, oper):
                            self._installed_conflicts.add(pkg.name)
                continue
            if self._check_single_pkg_conflict(depname, ver, oper):
                self._installed_conflicts.add(depname)
        return bool(self._installed_conflicts)

    @property
    def conflicts(self):
        """List of package names conflicting with this package."""
        key = "Conflicts"
        try:
            return apt_pkg.parse_depends(self._sections[key], False)
        except KeyError:
            return []

    @property
    def depends(self):
        """List of package names on which this package depends on."""
        depends = []
        # find depends
        for key in "Depends", "Pre-Depends":
            try:
                depends.extend(
                    apt_pkg.parse_depends(self._sections[key], False))
            except KeyError:
                pass
        return depends

    @property
    def provides(self):
        """List of virtual packages which are provided by this package."""
        key = "Provides"
        try:
            return apt_pkg.parse_depends(self._sections[key], False)
        except KeyError:
            return []

    @property
    def replaces(self):
        """List of packages which are replaced by this package."""
        key = "Replaces"
        try:
            return apt_pkg.parse_depends(self._sections[key], False)
        except KeyError:
            return []

    def replaces_real_pkg(self, pkgname, oper, ver):
        """Return True if a given non-virtual package is replaced.

        Return True if the deb packages replaces a real (not virtual)
        packages named (pkgname, oper, ver).
        """
        self._dbg(3, "replaces_real_pkg() %s %s %s" % (pkgname, oper, ver))
        pkg = self._cache[pkgname]
        if pkg.is_installed:
            pkgver = pkg.installed.version
        elif pkg.marked_install:
            pkgver = pkg.candidate.version
        else:
            pkgver = None
        for or_group in self.replaces:
            for (name, ver, oper) in or_group:
                if (name == pkgname and apt_pkg.check_dep(pkgver, oper, ver)):
                    self._dbg(3, "we have a replaces in our package for the "
                                 "conflict against '%s'" % (pkgname))
                    return True
        return False

    def check_conflicts(self):
        """Check if there are conflicts with existing or selected packages.

        Check if the package conflicts with a existing or to be installed
        package. Return True if the pkg is OK.
        """
        res = True
        for or_group in self.conflicts:
            if self._check_conflicts_or_group(or_group):
                #print "Conflicts with a exisiting pkg!"
                #self._failure_string = "Conflicts with a exisiting pkg!"
                res = False
        return res

    def check_breaks_existing_packages(self):
        """
        check if installing the package would break exsisting
        package on the system, e.g. system has:
        smc depends on smc-data (= 1.4)
        and user tries to installs smc-data 1.6
        """
        # show progress information as this step may take some time
        size = float(len(self._cache))
        steps = max(int(size / 50), 1)
        debver = self._sections["Version"]
        debarch = self._sections["Architecture"]
        # store what we provide so that we can later check against that
        provides = [x[0][0] for x in self.provides]
        for (i, pkg) in enumerate(self._cache):
            if i % steps == 0:
                self._cache.op_progress.update(float(i) / size * 100.0)
            if not pkg.is_installed:
                continue
            # check if the exising dependencies are still satisfied
            # with the package
            ver = pkg._pkg.current_ver
            for dep_or in pkg.installed.dependencies:
                for dep in dep_or.or_dependencies:
                    if dep.name == self.pkgname:
                        if not apt_pkg.check_dep(
                                debver, dep.relation, dep.version):
                            self._dbg(2, "would break (depends) %s" % pkg.name)
                            # TRANSLATORS: the first '%s' is the package that
                            # breaks, the second the dependency that makes it
                            # break, the third the relation (e.g. >=) and the
                            # latest the version for the releation
                            self._failure_string += _(
                                "Breaks existing package '%(pkgname)s' "
                                "dependency %(depname)s "
                                "(%(deprelation)s %(depversion)s)") % {
                                    'pkgname': pkg.name,
                                    'depname': dep.name,
                                    'deprelation': dep.relation,
                                    'depversion': dep.version}
                            self._cache.op_progress.done()
                            return False
            # now check if there are conflicts against this package on
            # the existing system
            if "Conflicts" in ver.depends_list:
                for conflicts_ver_list in ver.depends_list["Conflicts"]:
                    for c_or in conflicts_ver_list:
                        if (c_or.target_pkg.name == self.pkgname and
                                c_or.target_pkg.architecture == debarch):
                            if apt_pkg.check_dep(
                                    debver, c_or.comp_type, c_or.target_ver):
                                self._dbg(
                                    2, "would break (conflicts) %s" % pkg.name)
                                # TRANSLATORS: the first '%s' is the package
                                # that conflicts, the second the packagename
                                # that it conflicts with (so the name of the
                                # deb the user tries to install), the third is
                                # the relation (e.g. >=) and the last is the
                                # version for the relation
                                self._failure_string += _(
                                    "Breaks existing package '%(pkgname)s' "
                                    "conflict: %(targetpkg)s "
                                    "(%(comptype)s %(targetver)s)") % {
                                        'pkgname': pkg.name,
                                        'targetpkg': c_or.target_pkg.name,
                                        'comptype': c_or.comp_type,
                                        'targetver': c_or.target_ver}
                                self._cache.op_progress.done()
                                return False
                        if (c_or.target_pkg.name in provides and
                                self.pkgname != pkg.name):
                            self._dbg(
                                2, "would break (conflicts) %s" % provides)
                            self._failure_string += _(
                                "Breaks existing package '%(pkgname)s' "
                                "that conflict: '%(targetpkg)s'. But the "
                                "'%(debfile)s' provides it via: "
                                "'%(provides)s'") % {
                                    'provides': ",".join(provides),
                                    'debfile': self.filename,
                                    'targetpkg': c_or.target_pkg.name,
                                    'pkgname': pkg.name}
                            self._cache.op_progress.done()
                            return False
        self._cache.op_progress.done()
        return True

    def compare_to_version_in_cache(self, use_installed=True):
        """Compare the package to the version available in the cache.

        Checks if the package is already installed or availabe in the cache
        and if so in what version, returns one of (VERSION_NONE,
        VERSION_OUTDATED, VERSION_SAME, VERSION_NEWER).
        """
        self._dbg(3, "compare_to_version_in_cache")
        pkgname = self._sections["Package"]
        architecture = self._sections["Architecture"]

        # Arch qualify the package name
        pkgname = ":".join([pkgname, architecture])

        debver = self._sections["Version"]
        self._dbg(1, "debver: %s" % debver)
        if pkgname in self._cache:
            if use_installed and self._cache[pkgname].installed:
                cachever = self._cache[pkgname].installed.version
            elif not use_installed and self._cache[pkgname].candidate:
                cachever = self._cache[pkgname].candidate.version
            else:
                return self.VERSION_NONE
            if cachever is not None:
                cmp = apt_pkg.version_compare(cachever, debver)
                self._dbg(1, "CompareVersion(debver,instver): %s" % cmp)
                if cmp == 0:
                    return self.VERSION_SAME
                elif cmp < 0:
                    return self.VERSION_NEWER
                elif cmp > 0:
                    return self.VERSION_OUTDATED
        return self.VERSION_NONE

    def check(self, allow_downgrade=False):
        """Check if the package is installable."""
        self._dbg(3, "check")

        self._check_was_run = True

        # check arch
        if "Architecture" not in self._sections:
            self._dbg(1, "ERROR: no architecture field")
            self._failure_string = _("No Architecture field in the package")
            return False
        arch = self._sections["Architecture"]
        if arch != "all" and arch != apt_pkg.config.find("APT::Architecture"):
            if arch in apt_pkg.get_architectures():
                self._multiarch = arch
                self.pkgname = "%s:%s" % (self.pkgname, self._multiarch)
                self._dbg(1, "Found multiarch arch: '%s'" % arch)
            else:
                self._dbg(1, "ERROR: Wrong architecture dude!")
                self._failure_string = _("Wrong architecture '%s' "
                                         "-- Run dpkg --add-architecture to "
                                         "add it and update afterwards") % arch
                return False

        # check version
        if (not allow_downgrade and
            self.compare_to_version_in_cache() == self.VERSION_OUTDATED):
            if self._cache[self.pkgname].installed:
                # the deb is older than the installed
                self._failure_string = _(
                    "A later version is already installed")
                return False

        # FIXME: this sort of error handling sux
        self._failure_string = ""

        # check conflicts
        if not self.check_conflicts():
            return False

        # check if installing it would break anything on the
        # current system
        if not self.check_breaks_existing_packages():
            return False

        # try to satisfy the dependencies
        if not self._satisfy_depends(self.depends):
            return False

        # check for conflicts again (this time with the packages that are
        # makeed for install)
        if not self.check_conflicts():
            return False

        if self._cache._depcache.broken_count > 0:
            self._failure_string = _("Failed to satisfy all dependencies "
                                     "(broken cache)")
            # clean the cache again
            self._cache.clear()
            return False
        return True

    def satisfy_depends_str(self, dependsstr):
        """Satisfy the dependencies in the given string."""
        return self._satisfy_depends(apt_pkg.parse_depends(dependsstr, False))

    def _satisfy_depends(self, depends):
        """Satisfy the dependencies."""
        # turn off MarkAndSweep via a action group (if available)
        try:
            _actiongroup = apt_pkg.ActionGroup(self._cache._depcache)
            _actiongroup  # pyflakes
        except AttributeError:
            pass
        # check depends
        for or_group in depends:
            if not self._is_or_group_satisfied(or_group):
                if not self._satisfy_or_group(or_group):
                    return False
        # now try it out in the cache
        for pkg in self._need_pkgs:
            try:
                self._cache[pkg].mark_install(from_user=False)
            except SystemError:
                self._failure_string = _("Cannot install '%s'") % pkg
                self._cache.clear()
                return False
        return True

    @property
    def missing_deps(self):
        """Return missing dependencies."""
        self._dbg(1, "Installing: %s" % self._need_pkgs)
        if not self._check_was_run:
            raise AttributeError(
                "property only available after check() was run")
        return self._need_pkgs

    @property
    def required_changes(self):
        """Get the changes required to satisfy the dependencies.

        Returns: a tuple with (install, remove, unauthenticated)
        """
        install = []
        remove = []
        unauthenticated = []
        if not self._check_was_run:
            raise AttributeError(
                "property only available after check() was run")
        for pkg in self._cache:
            if pkg.marked_install or pkg.marked_upgrade:
                install.append(pkg.name)
                # check authentication, one authenticated origin is enough
                # libapt will skip non-authenticated origins then
                authenticated = False
                for origin in pkg.candidate.origins:
                    authenticated |= origin.trusted
                if not authenticated:
                    unauthenticated.append(pkg.name)
            if pkg.marked_delete:
                remove.append(pkg.name)
        return (install, remove, unauthenticated)

    @staticmethod
    def to_hex(in_data):
        hex = ""
        for (i, c) in enumerate(in_data):
            if i % 80 == 0:
                hex += "\n"
            hex += "%2.2x " % ord(c)
        return hex

    @staticmethod
    def to_strish(in_data):
        s = ""
        # py2 compat, in_data is type string
        if type(in_data) == str:
            for c in in_data:
                if ord(c) < 10 or ord(c) > 127:
                    s += " "
                else:
                    s += c
        # py3 compat, in_data is type bytes
        else:
            for b in in_data:
                if b < 10 or b > 127:
                    s += " "
                else:
                    s += chr(b)
        return s

    def _get_content(self, part, name, auto_decompress=True, auto_hex=True):
        if name.startswith("./"):
            name = name[2:]
        data = part.extractdata(name)
        # check for zip content
        if name.endswith(".gz") and auto_decompress:
            io = BytesIO(data)
            gz = gzip.GzipFile(fileobj=io)
            data = _("Automatically decompressed:\n\n").encode("utf-8")
            data += gz.read()
        # auto-convert to hex
        try:
            data = data.decode("utf-8")
        except Exception:
            new_data = _("Automatically converted to printable ascii:\n")
            new_data += self.to_strish(data)
            return new_data
        return data

    def control_content(self, name):
        """ return the content of a specific control.tar.gz file """
        try:
            return self._get_content(self._debfile.control, name)
        except LookupError:
            return ""

    def data_content(self, name):
        """ return the content of a specific control.tar.gz file """
        try:
            return self._get_content(self._debfile.data, name)
        except LookupError:
            return ""

    def _dbg(self, level, msg):
        """Write debugging output to sys.stderr."""
        if level <= self.debug:
            print(msg, file=sys.stderr)

    def install(self, install_progress=None):
        """Install the package."""
        if install_progress is None:
            return os.spawnlp(os.P_WAIT, "dpkg", "dpkg", "-i", self.filename)
        else:
            try:
                install_progress.start_update()
            except AttributeError:
                install_progress.startUpdate()
            res = install_progress.run(self.filename)
            try:
                install_progress.finish_update()
            except AttributeError:
                install_progress.finishUpdate()
            return res


class DscSrcPackage(DebPackage):
    """A locally available source package."""

    def __init__(self, filename=None, cache=None):
        DebPackage.__init__(self, None, cache)
        self.filename = filename
        self._depends = []
        self._conflicts = []
        self._installed_conflicts = set()
        self.pkgname = ""
        self.binaries = []
        if self.filename is not None:
            self.open(self.filename)

    @property
    def depends(self):
        """Return the dependencies of the package"""
        return self._depends

    @property
    def conflicts(self):
        """Return the dependencies of the package"""
        return self._conflicts

    @property
    def filelist(self):
        """Return the list of files associated with this dsc file"""
        # Files stanza looks like (hash, size, filename, ...)
        return self._sections['Files'].split()[2::3]

    def open(self, file):
        """Open the package."""
        depends_tags = ["Build-Depends", "Build-Depends-Indep"]
        conflicts_tags = ["Build-Conflicts", "Build-Conflicts-Indep"]
        fd = apt_pkg.open_maybe_clear_signed_file(file)
        fobj = os.fdopen(fd)
        tagfile = apt_pkg.TagFile(fobj)
        try:
            for sec in tagfile:
                for tag in depends_tags:
                    if tag not in sec:
                        continue
                    self._depends.extend(apt_pkg.parse_src_depends(sec[tag]))
                for tag in conflicts_tags:
                    if tag not in sec:
                        continue
                    self._conflicts.extend(apt_pkg.parse_src_depends(sec[tag]))
                if 'Source' in sec:
                    self.pkgname = sec['Source']
                if 'Binary' in sec:
                    self.binaries = [b.strip() for b in
                                     sec['Binary'].split(',')]
                for tag in sec.keys():
                    if tag in sec:
                        self._sections[tag] = sec[tag]
        finally:
            del tagfile
            fobj.close()

        s = _("Install Build-Dependencies for "
              "source package '%s' that builds %s\n") % (self.pkgname,
              " ".join(self.binaries))
        self._sections["Description"] = s
        self._check_was_run = False

    def check(self):
        """Check if the package is installable.."""
        if not self.check_conflicts():
            for pkgname in self._installed_conflicts:
                if self._cache[pkgname]._pkg.essential:
                    raise Exception(_("An essential package would be removed"))
                self._cache[pkgname].mark_delete()
        # properties are ok now
        self._check_was_run = True
        # FIXME: a additional run of the check_conflicts()
        #        after _satisfy_depends() should probably be done
        return self._satisfy_depends(self.depends)


def _test():
    """Test function"""
    from apt.cache import Cache
    from apt.progress.base import InstallProgress

    cache = Cache()

    vp = "www-browser"
    print("%s virtual: %s" % (vp, cache.is_virtual_package(vp)))
    providers = cache.get_providing_packages(vp)
    print("Providers for %s :" % vp)
    for pkg in providers:
        print(" %s" % pkg.name)

    d = DebPackage(sys.argv[1], cache)
    print("Deb: %s" % d.pkgname)
    if not d.check():
        print("can't be satified")
        print(d._failure_string)
    print("missing deps: %s" % d.missing_deps)
    print(d.required_changes)

    print(d.filelist)

    print("Installing ...")
    ret = d.install(InstallProgress())
    print(ret)

    #s = DscSrcPackage(cache, "../tests/3ddesktop_0.2.9-6.dsc")
    #s.check_dep()
    #print "Missing deps: ",s.missingDeps
    #print "Print required changes: ", s.requiredChanges

    s = DscSrcPackage(cache=cache)
    d = "libc6 (>= 2.3.2), libaio (>= 0.3.96) | libaio1 (>= 0.3.96)"
    print(s._satisfy_depends(apt_pkg.parse_depends(d, False)))

if __name__ == "__main__":
    _test()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  # package.py - apt package abstraction
#
#  Copyright (c) 2005-2009 Canonical
#
#  Author: Michael Vogt <michael.vogt@ubuntu.com>
#
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License as
#  published by the Free Software Foundation; either version 2 of the
#  License, or (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
#  USA
"""Functionality related to packages."""
from __future__ import print_function


import os
import sys
import re
import socket
import subprocess

try:
    from http.client import BadStatusLine
    from urllib.error import HTTPError
    from urllib.request import urlopen
except ImportError:
    from httplib import BadStatusLine
    from urllib2 import HTTPError, urlopen

from collections import Mapping, Sequence

import apt_pkg
import apt.progress.text
from apt_pkg import gettext as _

__all__ = ('BaseDependency', 'Dependency', 'Origin', 'Package', 'Record',
           'Version', 'VersionList')

if sys.version_info.major >= 3:
    unicode = str


def _file_is_same(path, size, md5):
    """Return ``True`` if the file is the same."""
    if os.path.exists(path) and os.path.getsize(path) == size:
        with open(path) as fobj:
            return apt_pkg.md5sum(fobj) == md5


class FetchError(Exception):
    """Raised when a file could not be fetched."""


class BaseDependency(object):
    """A single dependency."""

    class __dstr(str):
        """Compare helper for compatibility with old third-party code.

        Old third-party code might still compare the relation with the
        previously used relations (<<,<=,==,!=,>=,>>,) instead of the curently
        used ones (<,<=,=,!=,>=,>,). This compare helper lets < match to <<,
        > match to >> and = match to ==.
        """

        def __eq__(self, other):
            if str.__eq__(self, other):
                return True
            elif str.__eq__(self, '<'):
                return str.__eq__('<<', other)
            elif str.__eq__(self, '>'):
                return str.__eq__('>>', other)
            elif str.__eq__(self, '='):
                return str.__eq__('==', other)
            else:
                return False

        def __ne__(self, other):
            return not self.__eq__(other)

    def __init__(self, version, dep):
        self._version = version  # apt.package.Version
        self._dep = dep  # apt_pkg.Dependency

    def __str__(self):
        return '%s: %s' % (self.rawtype, self.rawstr)

    def __repr__(self):
        return ('<BaseDependency: name:%r relation:%r version:%r rawtype:%r>'
                % (self.name, self.relation, self.version, self.rawtype))

    @property
    def name(self):
        """The name of the target package."""
        return self._dep.target_pkg.name

    @property
    def relation(self):
        """The relation (<, <=, =, !=, >=, >, '') in mathematical notation.

        The empty string will be returned in case of an unversioned dependency.
        """
        return self.__dstr(self._dep.comp_type)

    @property
    def relation_deb(self):
        """The relation (<<, <=, =, !=, >=, >>, '') in Debian notation.

        The empty string will be returned in case of an unversioned dependency.
        For more details see the Debian Policy Manual on the syntax of
        relationship fields:
        https://www.debian.org/doc/debian-policy/ch-relationships.html#s-depsyntax  # noqa

        .. versionadded:: 1.0.0
        """
        return self._dep.comp_type_deb

    @property
    def version(self):
        """The target version or an empty string.

        Note that the version is only an empty string in case of an unversioned
        dependency. In this case the relation is also an empty string.
        """
        return self._dep.target_ver

    @property
    def target_versions(self):
        """A list of all Version objects which satisfy this dependency.

        .. versionadded:: 1.0.0
        """
        tvers = []
        _tvers = self._dep.all_targets()  # [apt_pkg.Version, ...]
        for _tver in _tvers:  # apt_pkg.Version
            _pkg = _tver.parent_pkg  # apt_pkg.Package
            cache = self._version.package._pcache  # apt.cache.Cache
            pkg = cache._rawpkg_to_pkg(_pkg)  # apt.package.Package
            tver = Version(pkg, _tver)  # apt.package.Version
            tvers.append(tver)
        return tvers

    @property
    def installed_target_versions(self):
        """A list of all installed Version objects which satisfy this dep.

        .. versionadded:: 1.0.0
        """
        return [tver for tver in self.target_versions if tver.is_installed]

    @property
    def rawstr(self):
        """String represenation of the dependency.

        Returns the string representation of the dependency as it would be
        written in the debian/control file.  The string representation does not
        include the type of the dependency.

        Example for an unversioned dependency:
          python3

        Example for a versioned dependency:
          python3 >= 3.2

        .. versionadded:: 1.0.0
        """
        if self.version:
            return '%s %s %s' % (self.name, self.relation_deb, self.version)
        else:
            return self.name

    @property
    def rawtype(self):
        """Type of the dependency.

        This should be one of 'Breaks', 'Conflicts', 'Depends', 'Enhances',
        'PreDepends', 'Recommends', 'Replaces', 'Suggests'.

        Additional types might be added in the future.
        """
        return self._dep.dep_type_untranslated

    @property
    def pre_depend(self):
        """Whether this is a PreDepends."""
        return self._dep.dep_type_untranslated == 'PreDepends'


class Dependency(list):
    """Represent an Or-group of dependencies.

    Attributes defined here:
        or_dependencies - The possible choices
        rawstr - String represenation of the Or-group of dependencies
        rawtype - The type of the dependencies in the Or-group
        target_version - A list of Versions which satisfy this Or-group of deps
    """

    def __init__(self, version, base_deps, rawtype):
        super(Dependency, self).__init__(base_deps)
        self._version = version  # apt.package.Version
        self._rawtype = rawtype

    def __str__(self):
        return '%s: %s' % (self.rawtype, self.rawstr)

    def __repr__(self):
        return '<Dependency: [%s]>' % (', '.join(repr(bd) for bd in self))

    @property
    def or_dependencies(self):
        return self

    @property
    def rawstr(self):
        """String represenation of the Or-group of dependencies.

        Returns the string representation of the Or-group of dependencies as it
        would be written in the debian/control file.  The string representation
        does not include the type of the Or-group of dependencies.

        Example:
          python2 >= 2.7 | python3

        .. versionadded:: 1.0.0
        """
        return ' | '.join(bd.rawstr for bd in self)

    @property
    def rawtype(self):
        """Type of the Or-group of dependency.

        This should be one of 'Breaks', 'Conflicts', 'Depends', 'Enhances',
        'PreDepends', 'Recommends', 'Replaces', 'Suggests'.

        Additional types might be added in the future.

        .. versionadded:: 1.0.0
        """
        return self._rawtype

    @property
    def target_versions(self):
        """A list of all Version objects which satisfy this Or-group of deps.

        .. versionadded:: 1.0.0
        """
        tvers = []
        for bd in self:  # apt.package.Dependency
            for tver in bd.target_versions:  # apt.package.Version
                if tver not in tvers:
                    tvers.append(tver)
        return tvers

    @property
    def installed_target_versions(self):
        """A list of all installed Version objects which satisfy this dep.

        .. versionadded:: 1.0.0
        """
        return [tver for tver in self.target_versions if tver.is_installed]


class Origin(object):
    """The origin of a version.

    Attributes defined here:
        archive   - The archive (eg. unstable)
        component - The component (eg. main)
        label     - The Label, as set in the Release file
        origin    - The Origin, as set in the Release file
        codename  - The Codename, as set in the Release file
        site      - The hostname of the site.
        trusted   - Boolean value whether this is trustworthy.
    """

    def __init__(self, pkg, packagefile):
        self.archive = packagefile.archive
        self.component = packagefile.component
        self.label = packagefile.label
        self.origin = packagefile.origin
        self.codename = packagefile.codename
        self.site = packagefile.site
        self.not_automatic = packagefile.not_automatic
        # check the trust
        indexfile = pkg._pcache._list.find_index(packagefile)
        if indexfile and indexfile.is_trusted:
            self.trusted = True
        else:
            self.trusted = False

    def __repr__(self):
        return ("<Origin component:%r archive:%r origin:%r label:%r "
                "site:%r isTrusted:%r>") % (self.component, self.archive,
                                            self.origin, self.label,
                                            self.site, self.trusted)


class Record(Mapping):
    """Record in a Packages file

    Represent a record as stored in a Packages file. You can use this like
    a dictionary mapping the field names of the record to their values::

        >>> record = Record("Package: python-apt\\nVersion: 0.8.0\\n\\n")
        >>> record["Package"]
        'python-apt'
        >>> record["Version"]
        '0.8.0'

    For example, to get the tasks of a package from a cache, you could do::

        package.candidate.record["Tasks"].split()

    Of course, you can also use the :attr:`Version.tasks` property.

    """

    def __init__(self, record_str):
        self._rec = apt_pkg.TagSection(record_str)

    def __hash__(self):
        return hash(self._rec)

    def __str__(self):
        return str(self._rec)

    def __getitem__(self, key):
        return self._rec[key]

    def __contains__(self, key):
        return key in self._rec

    def __iter__(self):
        return iter(self._rec.keys())

    def iteritems(self):
        """An iterator over the (key, value) items of the record."""
        for key in self._rec.keys():
            yield key, self._rec[key]

    def get(self, key, default=None):
        """Return record[key] if key in record, else *default*.

        The parameter *default* must be either a string or None.
        """
        return self._rec.get(key, default)

    def has_key(self, key):
        """deprecated form of ``key in x``."""
        return key in self._rec

    def __len__(self):
        return len(self._rec)


class Version(object):
    """Representation of a package version.

    The Version class contains all information related to a
    specific package version.

    .. versionadded:: 0.7.9
    """

    def __init__(self, package, cand):
        self.package = package
        self._cand = cand

    def _cmp(self, other):
        """Compares against another apt.Version object or a version string.

        This method behaves like Python 2's cmp builtin and returns an integer
        according to the outcome.  The return value is negative in case of
        self < other, zero if self == other and positive if self > other.

        The comparison includes the package name and architecture if other is
        an apt.Version object.  If other isn't an apt.Version object it'll be
        assumed that other is a version string (without package name/arch).

        .. versionchanged:: 1.0.0
        """
        # Assume that other is an apt.Version object.
        try:
            self_name = self.package.fullname
            other_name = other.package.fullname
            if self_name < other_name:
                return -1
            elif self_name > other_name:
                return 1
            return apt_pkg.version_compare(self._cand.ver_str, other.version)
        except AttributeError:
            # Assume that other is a string that only contains the version.
            try:
                return apt_pkg.version_compare(self._cand.ver_str, other)
            except TypeError:
                return NotImplemented

    def __eq__(self, other):
        return self._cmp(other) == 0

    def __ge__(self, other):
        return self._cmp(other) >= 0

    def __gt__(self, other):
        return self._cmp(other) > 0

    def __le__(self, other):
        return self._cmp(other) <= 0

    def __lt__(self, other):
        return self._cmp(other) < 0

    def __ne__(self, other):
        try:
            return self._cmp(other) != 0
        except TypeError:
            return NotImplemented

    def __hash__(self):
        return self._cand.hash

    def __str__(self):
        return '%s=%s' % (self.package.name, self.version)

    def __repr__(self):
        return '<Version: package:%r version:%r>' % (self.package.name,
                                                     self.version)

    @property
    def _records(self):
        """Internal helper that moves the Records to the right position."""
        if self.package._pcache._records.lookup(self._cand.file_list[0]):
            return self.package._pcache._records

    @property
    def _translated_records(self):
        """Internal helper to get the translated description."""
        desc_iter = self._cand.translated_description
        self.package._pcache._records.lookup(desc_iter.file_list.pop(0))
        return self.package._pcache._records

    @property
    def installed_size(self):
        """Return the size of the package when installed."""
        return self._cand.installed_size

    @property
    def homepage(self):
        """Return the homepage for the package."""
        return self._records.homepage

    @property
    def size(self):
        """Return the size of the package."""
        return self._cand.size

    @property
    def architecture(self):
        """Return the architecture of the package version."""
        return self._cand.arch

    @property
    def downloadable(self):
        """Return whether the version of the package is downloadable."""
        return bool(self._cand.downloadable)

    @property
    def is_installed(self):
        """Return wether this version of the package is currently installed.

        .. versionadded:: 1.0.0
        """
        inst_ver = self.package.installed
        return inst_ver and inst_ver._cand.id == self._cand.id

    @property
    def version(self):
        """Return the version as a string."""
        return self._cand.ver_str

    @property
    def summary(self):
        """Return the short description (one line summary)."""
        return self._translated_records.short_desc

    @property
    def raw_description(self):
        """return the long description (raw)."""
        return self._records.long_desc

    @property
    def section(self):
        """Return the section of the package."""
        return self._cand.section

    @property
    def description(self):
        """Return the formatted long description.

        Return the formatted long description according to the Debian policy
        (Chapter 5.6.13).
        See http://www.debian.org/doc/debian-policy/ch-controlfields.html
        for more information.
        """
        desc = ''
        dsc = self._translated_records.long_desc
        try:
            if not isinstance(dsc, unicode):
                # Only convert where needed (i.e. Python 2.X)
                dsc = dsc.decode("utf-8")
        except UnicodeDecodeError as err:
            return _("Invalid unicode in description for '%s' (%s). "
                     "Please report.") % (self.package.name, err)

        lines = iter(dsc.split("\n"))
        # Skip the first line, since its a duplication of the summary
        next(lines)
        for raw_line in lines:
            if raw_line.strip() == ".":
                # The line is just line break
                if not desc.endswith("\n"):
                    desc += "\n\n"
                continue
            if raw_line.startswith("  "):
                # The line should be displayed verbatim without word wrapping
                if not desc.endswith("\n"):
                    line = "\n%s\n" % raw_line[2:]
                else:
                    line = "%s\n" % raw_line[2:]
            elif raw_line.startswith(" "):
                # The line is part of a paragraph.
                if desc.endswith("\n") or desc == "":
                    # Skip the leading white space
                    line = raw_line[1:]
                else:
                    line = raw_line
            else:
                line = raw_line
            # Add current line to the description
            desc += line
        return desc

    @property
    def source_name(self):
        """Return the name of the source package."""
        try:
            return self._records.source_pkg or self.package.shortname
        except IndexError:
            return self.package.shortname

    @property
    def source_version(self):
        """Return the version of the source package."""
        try:
            return self._records.source_ver or self._cand.ver_str
        except IndexError:
            return self._cand.ver_str

    @property
    def priority(self):
        """Return the priority of the package, as string."""
        return self._cand.priority_str

    @property
    def policy_priority(self):
        """Return the internal policy priority as a number.
           See apt_preferences(5) for more information about what it means.
        """
        priority = 0
        policy = self.package._pcache._depcache.policy
        for (packagefile, _unused) in self._cand.file_list:
            priority = max(priority, policy.get_priority(packagefile))
        return priority

    @property
    def record(self):
        """Return a Record() object for this version.

        Return a Record() object for this version which provides access
        to the raw attributes of the candidate version
        """
        return Record(self._records.record)

    def get_dependencies(self, *types):
        """Return a list of Dependency objects for the given types.

        Multiple types can be specified. Possible types are:
        'Breaks', 'Conflicts', 'Depends', 'Enhances', 'PreDepends',
        'Recommends', 'Replaces', 'Suggests'

        Additional types might be added in the future.
        """
        depends_list = []
        depends = self._cand.depends_list
        for type_ in types:
            try:
                for dep_ver_list in depends[type_]:
                    base_deps = []
                    for dep_or in dep_ver_list:
                        base_deps.append(BaseDependency(self, dep_or))
                    depends_list.append(Dependency(self, base_deps, type_))
            except KeyError:
                pass
        return depends_list

    @property
    def provides(self):
        """ Return a list of names that this version provides."""
        return [p[0] for p in self._cand.provides_list]

    @property
    def enhances(self):
        """Return the list of enhances for the package version."""
        return self.get_dependencies("Enhances")

    @property
    def dependencies(self):
        """Return the dependencies of the package version."""
        return self.get_dependencies("PreDepends", "Depends")

    @property
    def recommends(self):
        """Return the recommends of the package version."""
        return self.get_dependencies("Recommends")

    @property
    def suggests(self):
        """Return the suggests of the package version."""
        return self.get_dependencies("Suggests")

    @property
    def origins(self):
        """Return a list of origins for the package version."""
        origins = []
        for (packagefile, _unused) in self._cand.file_list:
            origins.append(Origin(self.package, packagefile))
        return origins

    @property
    def filename(self):
        """Return the path to the file inside the archive.

        .. versionadded:: 0.7.10
        """
        return self._records.filename

    @property
    def md5(self):
        """Return the md5sum of the binary.

        .. versionadded:: 0.7.10
        """
        return self._records.md5_hash

    @property
    def sha1(self):
        """Return the sha1sum of the binary.

        .. versionadded:: 0.7.10
        """
        return self._records.sha1_hash

    @property
    def sha256(self):
        """Return the sha256sum of the binary.

        .. versionadded:: 0.7.10
        """
        return self._records.sha256_hash

    @property
    def tasks(self):
        """Get the tasks of the package.

        A set of the names of the tasks this package belongs to.

        .. versionadded:: 0.8.0
        """
        return set(self.record["Task"].split())

    def _uris(self):
        """Return an iterator over all available urls.

        .. versionadded:: 0.7.10
        """
        for (packagefile, _unused) in self._cand.file_list:
            indexfile = self.package._pcache._list.find_index(packagefile)
            if indexfile:
                yield indexfile.archive_uri(self._records.filename)

    @property
    def uris(self):
        """Return a list of all available uris for the binary.

        .. versionadded:: 0.7.10
        """
        return list(self._uris())

    @property
    def uri(self):
        """Return a single URI for the binary.

        .. versionadded:: 0.7.10
        """
        try:
            return next(iter(self._uris()))
        except StopIteration:
            return None

    def fetch_binary(self, destdir='', progress=None):
        """Fetch the binary version of the package.

        The parameter *destdir* specifies the directory where the package will
        be fetched to.

        The parameter *progress* may refer to an apt_pkg.AcquireProgress()
        object. If not specified or None, apt.progress.text.AcquireProgress()
        is used.

        .. versionadded:: 0.7.10
        """
        base = os.path.basename(self._records.filename)
        destfile = os.path.join(destdir, base)
        if _file_is_same(destfile, self.size, self._records.md5_hash):
            print(('Ignoring already existing file: %s' % destfile))
            return os.path.abspath(destfile)
        acq = apt_pkg.Acquire(progress or apt.progress.text.AcquireProgress())
        acqfile = apt_pkg.AcquireFile(acq, self.uri, self._records.md5_hash,
                                      self.size, base, destfile=destfile)
        acq.run()

        if acqfile.status != acqfile.STAT_DONE:
            raise FetchError("The item %r could not be fetched: %s" %
                             (acqfile.destfile, acqfile.error_text))

        return os.path.abspath(destfile)

    def fetch_source(self, destdir="", progress=None, unpack=True):
        """Get the source code of a package.

        The parameter *destdir* specifies the directory where the source will
        be fetched to.

        The parameter *progress* may refer to an apt_pkg.AcquireProgress()
        object. If not specified or None, apt.progress.text.AcquireProgress()
        is used.

        The parameter *unpack* describes whether the source should be unpacked
        (``True``) or not (``False``). By default, it is unpacked.

        If *unpack* is ``True``, the path to the extracted directory is
        returned. Otherwise, the path to the .dsc file is returned.
        """
        src = apt_pkg.SourceRecords()
        acq = apt_pkg.Acquire(progress or apt.progress.text.AcquireProgress())

        dsc = None
        record = self._records
        source_name = record.source_pkg or self.package.shortname
        source_version = record.source_ver or self._cand.ver_str
        source_lookup = src.lookup(source_name)

        while source_lookup and source_version != src.version:
            source_lookup = src.lookup(source_name)
        if not source_lookup:
            raise ValueError("No source for %r" % self)
        files = list()
        for md5, size, path, type_ in src.files:
            base = os.path.basename(path)
            destfile = os.path.join(destdir, base)
            if type_ == 'dsc':
                dsc = destfile
            if _file_is_same(destfile, size, md5):
                print(('Ignoring already existing file: %s' % destfile))
                continue
            files.append(apt_pkg.AcquireFile(acq, src.index.archive_uri(path),
                         md5, size, base, destfile=destfile))
        acq.run()

        for item in acq.items:
            if item.status != item.STAT_DONE:
                raise FetchError("The item %r could not be fetched: %s" %
                                 (item.destfile, item.error_text))

        if unpack:
            outdir = src.package + '-' + apt_pkg.upstream_version(src.version)
            outdir = os.path.join(destdir, outdir)
            subprocess.check_call(["dpkg-source", "-x", dsc, outdir])
            return os.path.abspath(outdir)
        else:
            return os.path.abspath(dsc)


class VersionList(Sequence):
    """Provide a mapping & sequence interface to all versions of a package.

    This class can be used like a dictionary, where version strings are the
    keys. It can also be used as a sequence, where integers are the keys.

    You can also convert this to a dictionary or a list, using the usual way
    of dict(version_list) or list(version_list). This is useful if you need
    to access the version objects multiple times, because they do not have to
    be recreated this way.

    Examples ('package.versions' being a version list):
        '0.7.92' in package.versions # Check whether 0.7.92 is a valid version.
        package.versions[0] # Return first version or raise IndexError
        package.versions[0:2] # Return a new VersionList for objects 0-2
        package.versions['0.7.92'] # Return version 0.7.92 or raise KeyError
        package.versions.keys() # All keys, as strings.
        max(package.versions)
    """

    def __init__(self, package, slice_=None):
        self._package = package  # apt.package.Package()
        self._versions = package._pkg.version_list  # [apt_pkg.Version(), ...]
        if slice_:
            self._versions = self._versions[slice_]

    def __getitem__(self, item):
        if isinstance(item, slice):
            return self.__class__(self._package, item)
        try:
            # Sequence interface, item is an integer
            return Version(self._package, self._versions[item])
        except TypeError:
            # Dictionary interface item is a string.
            for ver in self._versions:
                if ver.ver_str == item:
                    return Version(self._package, ver)
        raise KeyError("Version: %r not found." % (item))

    def __str__(self):
        return '[%s]' % (', '.join(str(ver) for ver in self))

    def __repr__(self):
        return '<VersionList: %r>' % self.keys()

    def __iter__(self):
        """Return an iterator over all value objects."""
        return (Version(self._package, ver) for ver in self._versions)

    def __contains__(self, item):
        if isinstance(item, Version):  # Sequence interface
            item = item.version
        # Dictionary interface.
        for ver in self._versions:
            if ver.ver_str == item:
                return True
        return False

    def __eq__(self, other):
        return list(self) == list(other)

    def __len__(self):
        return len(self._versions)

    # Mapping interface

    def keys(self):
        """Return a list of all versions, as strings."""
        return [ver.ver_str for ver in self._versions]

    def get(self, key, default=None):
        """Return the key or the default."""
        try:
            return self[key]
        except LookupError:
            return default


class Package(object):
    """Representation of a package in a cache.

    This class provides methods and properties for working with a package. It
    lets you mark the package for installation, check if it is installed, and
    much more.
    """

    def __init__(self, pcache, pkgiter):
        """ Init the Package object """
        self._pkg = pkgiter
        self._pcache = pcache           # python cache in cache.py
        self._changelog = ""            # Cached changelog

    def __str__(self):
        return self.name

    def __repr__(self):
        return '<Package: name:%r architecture=%r id:%r>' % (
            self._pkg.name, self._pkg.architecture, self._pkg.id)

    def __lt__(self, other):
        return self.name < other.name

    def candidate(self):
        """Return the candidate version of the package.

        This property is writeable to allow you to set the candidate version
        of the package. Just assign a Version() object, and it will be set as
        the candidate version.
        """
        cand = self._pcache._depcache.get_candidate_ver(self._pkg)
        if cand is not None:
            return Version(self, cand)

    def __set_candidate(self, version):
        """Set the candidate version of the package."""
        self._pcache.cache_pre_change()
        self._pcache._depcache.set_candidate_ver(self._pkg, version._cand)
        self._pcache.cache_post_change()

    candidate = property(candidate, __set_candidate)

    @property
    def installed(self):
        """Return the currently installed version of the package.

        .. versionadded:: 0.7.9
        """
        if self._pkg.current_ver is not None:
            return Version(self, self._pkg.current_ver)

    @property
    def name(self):
        """Return the name of the package, possibly including architecture.

        If the package is not part of the system's preferred architecture,
        return the same as :attr:`fullname`, otherwise return the same
        as :attr:`shortname`

        .. versionchanged:: 0.7.100.3

        As part of multi-arch, this field now may include architecture
        information.
        """
        return self._pkg.get_fullname(True)

    @property
    def fullname(self):
        """Return the name of the package, including architecture.

        .. versionadded:: 0.7.100.3"""
        return self._pkg.get_fullname(False)

    @property
    def shortname(self):
        """Return the name of the package, without architecture.

        .. versionadded:: 0.7.100.3"""
        return self._pkg.name

    @property
    def id(self):
        """Return a uniq ID for the package.

        This can be used eg. to store additional information about the pkg."""
        return self._pkg.id

    def __hash__(self):
        """Return the hash of the object.

        This returns the same value as ID, which is unique."""
        return self._pkg.id

    @property
    def essential(self):
        """Return True if the package is an essential part of the system."""
        return self._pkg.essential

    def architecture(self):
        """Return the Architecture of the package.

        .. versionchanged:: 0.7.100.3
            This is now the package's architecture in the multi-arch sense,
            previously it was the architecture of the candidate version
            and deprecated.
        """
        return self._pkg.architecture

    @property
    def section(self):
        """Return the section of the package."""
        return self._pkg.section

    # depcache states

    @property
    def marked_install(self):
        """Return ``True`` if the package is marked for install."""
        return self._pcache._depcache.marked_install(self._pkg)

    @property
    def marked_upgrade(self):
        """Return ``True`` if the package is marked for upgrade."""
        return self._pcache._depcache.marked_upgrade(self._pkg)

    @property
    def marked_delete(self):
        """Return ``True`` if the package is marked for delete."""
        return self._pcache._depcache.marked_delete(self._pkg)

    @property
    def marked_keep(self):
        """Return ``True`` if the package is marked for keep."""
        return self._pcache._depcache.marked_keep(self._pkg)

    @property
    def marked_downgrade(self):
        """ Package is marked for downgrade """
        return self._pcache._depcache.marked_downgrade(self._pkg)

    @property
    def marked_reinstall(self):
        """Return ``True`` if the package is marked for reinstall."""
        return self._pcache._depcache.marked_reinstall(self._pkg)

    @property
    def is_installed(self):
        """Return ``True`` if the package is installed."""
        return (self._pkg.current_ver is not None)

    @property
    def is_upgradable(self):
        """Return ``True`` if the package is upgradable."""
        return (self.is_installed and
                self._pcache._depcache.is_upgradable(self._pkg))

    @property
    def is_auto_removable(self):
        """Return ``True`` if the package is no longer required.

        If the package has been installed automatically as a dependency of
        another package, and if no packages depend on it anymore, the package
        is no longer required.
        """
        return ((self.is_installed or self.marked_install) and
                self._pcache._depcache.is_garbage(self._pkg))

    @property
    def is_auto_installed(self):
        """Return whether the package is marked as automatically installed."""
        return self._pcache._depcache.is_auto_installed(self._pkg)
    # sizes

    @property
    def installed_files(self):
        """Return a list of files installed by the package.

        Return a list of unicode names of the files which have
        been installed by this package
        """
        for name in self.name, self.fullname:
            path = "/var/lib/dpkg/info/%s.list" % name
            try:
                with open(path, "rb") as file_list:
                    return file_list.read().decode("utf-8").split(u"\n")
            except EnvironmentError:
                continue

        return []

    def get_changelog(self, uri=None, cancel_lock=None):
        """
        Download the changelog of the package and return it as unicode
        string.

        The parameter *uri* refers to the uri of the changelog file. It may
        contain multiple named variables which will be substitued. These
        variables are (src_section, prefix, src_pkg, src_ver). An example is
        the Ubuntu changelog::

            "http://changelogs.ubuntu.com/changelogs/pool" \\
                "/%(src_section)s/%(prefix)s/%(src_pkg)s" \\
                "/%(src_pkg)s_%(src_ver)s/changelog"

        The parameter *cancel_lock* refers to an instance of threading.Lock,
        which if set, prevents the download.
        """
        # Return a cached changelog if available
        if self._changelog != u"":
            return self._changelog

        if uri is None:
            if not self.candidate:
                pass
            if self.candidate.origins[0].origin == "Debian":
                uri = "http://packages.debian.org/changelogs/pool" \
                      "/%(src_section)s/%(prefix)s/%(src_pkg)s" \
                      "/%(src_pkg)s_%(src_ver)s/changelog"
            elif self.candidate.origins[0].origin == "Ubuntu":
                uri = "http://changelogs.ubuntu.com/changelogs/pool" \
                      "/%(src_section)s/%(prefix)s/%(src_pkg)s" \
                      "/%(src_pkg)s_%(src_ver)s/changelog"
            else:
                res = _("The list of changes is not available")
                return res if isinstance(res, unicode) else res.decode("utf-8")

        # get the src package name
        src_pkg = self.candidate.source_name

        # assume "main" section
        src_section = "main"
        # use the section of the candidate as a starting point
        section = self.candidate.section

        # get the source version
        src_ver = self.candidate.source_version

        try:
            # try to get the source version of the pkg, this differs
            # for some (e.g. libnspr4 on ubuntu)
            # this feature only works if the correct deb-src are in the
            # sources.list otherwise we fall back to the binary version number
            src_records = apt_pkg.SourceRecords()
        except SystemError:
            pass
        else:
            while src_records.lookup(src_pkg):
                if not src_records.version:
                    continue
                if self.candidate.source_version == src_records.version:
                    # Direct match, use it and do not do more lookups.
                    src_ver = src_records.version
                    section = src_records.section
                    break
                if apt_pkg.version_compare(src_records.version, src_ver) > 0:
                    # The version is higher, it seems to match.
                    src_ver = src_records.version
                    section = src_records.section

        section_split = section.split("/", 1)
        if len(section_split) > 1:
            src_section = section_split[0]
        del section_split

        # lib is handled special
        prefix = src_pkg[0]
        if src_pkg.startswith("lib"):
            prefix = "lib" + src_pkg[3]

        # stip epoch
        src_ver_split = src_ver.split(":", 1)
        if len(src_ver_split) > 1:
            src_ver = "".join(src_ver_split[1:])
        del src_ver_split

        uri = uri % {"src_section": src_section,
                     "prefix": prefix,
                     "src_pkg": src_pkg,
                     "src_ver": src_ver}

        timeout = socket.getdefaulttimeout()

        # FIXME: when python2.4 vanishes from the archive,
        #        merge this into a single try..finally block (pep 341)
        try:
            try:
                # Set a timeout for the changelog download
                socket.setdefaulttimeout(2)

                # Check if the download was canceled
                if cancel_lock and cancel_lock.isSet():
                    return u""
                # FIXME: python3.2: Should be closed manually
                changelog_file = urlopen(uri)
                # do only get the lines that are new
                changelog = u""
                regexp = "^%s \((.*)\)(.*)$" % (re.escape(src_pkg))
                while True:
                    # Check if the download was canceled
                    if cancel_lock and cancel_lock.isSet():
                        return u""
                    # Read changelog line by line
                    line_raw = changelog_file.readline()
                    if not line_raw:
                        break
                    # The changelog is encoded in utf-8, but since there isn't
                    # any http header, urllib2 seems to treat it as ascii
                    line = line_raw.decode("utf-8")

                    #print line.encode('utf-8')
                    match = re.match(regexp, line)
                    if match:
                        # strip epoch from installed version
                        # and from changelog too
                        installed = getattr(self.installed, 'version', None)
                        if installed and ":" in installed:
                            installed = installed.split(":", 1)[1]
                        changelog_ver = match.group(1)
                        if changelog_ver and ":" in changelog_ver:
                            changelog_ver = changelog_ver.split(":", 1)[1]

                        if (installed and apt_pkg.version_compare(
                                changelog_ver, installed) <= 0):
                            break
                    # EOF (shouldn't really happen)
                    changelog += line

                # Print an error if we failed to extract a changelog
                if len(changelog) == 0:
                    changelog = _("The list of changes is not available")
                    if not isinstance(changelog, unicode):
                        changelog = changelog.decode("utf-8")
                self._changelog = changelog

            except HTTPError:
                if self.candidate.origins[0].origin == "Ubuntu":
                    res = _("The list of changes is not available yet.\n\n"
                            "Please use "
                            "http://launchpad.net/ubuntu/+source/%s/"
                            "%s/+changelog\n"
                            "until the changes become available or try again "
                            "later.") % (src_pkg, src_ver)
                else:
                    res = _("The list of changes is not available")
                return res if isinstance(res, unicode) else res.decode("utf-8")
            except (IOError, BadStatusLine):
                res = _("Failed to download the list of changes. \nPlease "
                        "check your Internet connection.")
                return res if isinstance(res, unicode) else res.decode("utf-8")
        finally:
            socket.setdefaulttimeout(timeout)
        return self._changelog

    @property
    def versions(self):
        """Return a VersionList() object for all available versions.

        .. versionadded:: 0.7.9
        """
        return VersionList(self)

    @property
    def is_inst_broken(self):
        """Return True if the to-be-installed package is broken."""
        return self._pcache._depcache.is_inst_broken(self._pkg)

    @property
    def is_now_broken(self):
        """Return True if the installed package is broken."""
        return self._pcache._depcache.is_now_broken(self._pkg)

    @property
    def has_config_files(self):
        """Checks whether the package is is the config-files state."""
        return self. _pkg.current_state == apt_pkg.CURSTATE_CONFIG_FILES

    # depcache actions

    def mark_keep(self):
        """Mark a package for keep."""
        self._pcache.cache_pre_change()
        self._pcache._depcache.mark_keep(self._pkg)
        self._pcache.cache_post_change()

    def mark_delete(self, auto_fix=True, purge=False):
        """Mark a package for deletion.

        If *auto_fix* is ``True``, the resolver will be run, trying to fix
        broken packages.  This is the default.

        If *purge* is ``True``, remove the configuration files of the package
        as well.  The default is to keep the configuration.
        """
        self._pcache.cache_pre_change()
        self._pcache._depcache.mark_delete(self._pkg, purge)
        # try to fix broken stuffsta
        if auto_fix and self._pcache._depcache.broken_count > 0:
            fix = apt_pkg.ProblemResolver(self._pcache._depcache)
            fix.clear(self._pkg)
            fix.protect(self._pkg)
            fix.remove(self._pkg)
            fix.install_protect()
            fix.resolve()
        self._pcache.cache_post_change()

    def mark_install(self, auto_fix=True, auto_inst=True, from_user=True):
        """Mark a package for install.

        If *autoFix* is ``True``, the resolver will be run, trying to fix
        broken packages.  This is the default.

        If *autoInst* is ``True``, the dependencies of the packages will be
        installed automatically.  This is the default.

        If *fromUser* is ``True``, this package will not be marked as
        automatically installed. This is the default. Set it to False if you
        want to be able to automatically remove the package at a later stage
        when no other package depends on it.
        """
        self._pcache.cache_pre_change()
        self._pcache._depcache.mark_install(self._pkg, auto_inst, from_user)
        # try to fix broken stuff
        if auto_fix and self._pcache._depcache.broken_count > 0:
            fixer = apt_pkg.ProblemResolver(self._pcache._depcache)
            fixer.clear(self._pkg)
            fixer.protect(self._pkg)
            fixer.resolve(True)
        self._pcache.cache_post_change()

    def mark_upgrade(self, from_user=True):
        """Mark a package for upgrade."""
        if self.is_upgradable:
            auto = self.is_auto_installed
            self.mark_install(from_user=from_user)
            self.mark_auto(auto)
        else:
            # FIXME: we may want to throw a exception here
            sys.stderr.write(("MarkUpgrade() called on a non-upgradeable pkg: "
                              "'%s'\n") % self._pkg.name)

    def mark_auto(self, auto=True):
        """Mark a package as automatically installed.

        Call this function to mark a package as automatically installed. If the
        optional parameter *auto* is set to ``False``, the package will not be
        marked as automatically installed anymore. The default is ``True``.
        """
        self._pcache._depcache.mark_auto(self._pkg, auto)

    def commit(self, fprogress, iprogress):
        """Commit the changes.

        The parameter *fprogress* refers to a apt_pkg.AcquireProgress() object,
        like apt.progress.text.AcquireProgress().

        The parameter *iprogress* refers to an InstallProgress() object, as
        found in apt.progress.base.
        """
        self._pcache._depcache.commit(fprogress, iprogress)


def _test():
    """Self-test."""
    print("Self-test for the Package modul")
    import random
    apt_pkg.init()
    progress = apt.progress.text.OpProgress()
    cache = apt.Cache(progress)
    pkg = cache["apt-utils"]
    print("Name: %s " % pkg.name)
    print("ID: %s " % pkg.id)
    print("Priority (Candidate): %s " % pkg.candidate.priority)
    print("Priority (Installed): %s " % pkg.installed.priority)
    print("Installed: %s " % pkg.installed.version)
    print("Candidate: %s " % pkg.candidate.version)
    print("CandidateDownloadable: %s" % pkg.candidate.downloadable)
    print("CandidateOrigins: %s" % pkg.candidate.origins)
    print("SourcePkg: %s " % pkg.candidate.source_name)
    print("Section: %s " % pkg.section)
    print("Summary: %s" % pkg.candidate.summary)
    print("Description (formatted) :\n%s" % pkg.candidate.description)
    print("Description (unformatted):\n%s" % pkg.candidate.raw_description)
    print("InstalledSize: %s " % pkg.candidate.installed_size)
    print("PackageSize: %s " % pkg.candidate.size)
    print("Dependencies: %s" % pkg.installed.dependencies)
    print("Recommends: %s" % pkg.installed.recommends)
    for dep in pkg.candidate.dependencies:
        print(",".join("%s (%s) (%s) (%s)" % (o.name, o.version, o.relation,
                       o.pre_depend) for o in dep.or_dependencies))
    print("arch: %s" % pkg.candidate.architecture)
    print("homepage: %s" % pkg.candidate.homepage)
    print("rec: ", pkg.candidate.record)

    print(cache["2vcard"].get_changelog())
    for i in True, False:
        print("Running install on random upgradable pkgs with AutoFix: ", i)
        for pkg in cache:
            if pkg.is_upgradable:
                if random.randint(0, 1) == 1:
                    pkg.mark_install(i)
        print("Broken: %s " % cache._depcache.broken_count)
        print("InstCount: %s " % cache._depcache.inst_count)

    print()
    # get a new cache
    for i in True, False:
        print("Randomly remove some packages with AutoFix: %s" % i)
        cache = apt.Cache(progress)
        for name in cache.keys():
            if random.randint(0, 1) == 1:
                try:
                    cache[name].mark_delete(i)
                except SystemError:
                    print("Error trying to remove: %s " % name)
        print("Broken: %s " % cache._depcache.broken_count)
        print("DelCount: %s " % cache._depcache.del_count)

# self-test
if __name__ == "__main__":
    _test()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
<Wu                 @   s  d  d l  m Z d  d l Z d  d l Z d  d l Z d  d l Z d  d l Z d  d l m Z d  d l	 Z Gd d   d e
  Z Gd d   d e
  Z Gd d	   d	 e
  Z Gd
 d   d e  Z Gd d   d e  Z Gd d   d e  Z Gd d   d e  Z Gd d   d e  Z Gd d   d e  Z Gd d   d e  Z Gd d   d e  Z d d   Z d d   Z d d   Z e d  k re   d S)!    )print_functionN)Packagec               @   s   e  Z d  Z d Z d S)FetchCancelledExceptionzAException that is thrown when the user cancels a fetch operation.N)__name__
__module____qualname____doc__ r	   r	   +/usr/lib/python3/dist-packages/apt/cache.pyr   "   s   r   c               @   s   e  Z d  Z d Z d S)FetchFailedExceptionz-Exception that is thrown when fetching fails.N)r   r   r   r   r	   r	   r	   r
   r   &   s   r   c               @   s   e  Z d  Z d Z d S)LockFailedExceptionz,Exception that is thrown when locking fails.N)r   r   r   r   r	   r	   r	   r
   r   *   s   r   c               @   s   e  Z d  Z d Z d S)CacheClosedExceptionz>Exception that is thrown when the cache is used after close().N)r   r   r   r   r	   r	   r	   r
   r   .   s   r   c               @   sb  e  Z d  Z d Z d d d d d  Z d d   Z d d	   Z d
 d   Z d d d  Z d d   Z	 d d   Z
 d d   Z d d   Z d d d  Z d d   Z d d   Z d d   Z d d   Z d  d!   Z d" d#   Z d$ d%   Z d& d'   Z d d( d)  Z e d* d+    Z e d, d-    Z e d. d/    Z d0 d1   Z d2 d3   Z d d d4 d5  Z d6 d7   Z d8 d d9 d:  Z d d; d8 d d< d=  Z  d> d?   Z! d d d@ dA  Z" dB dC   Z# dD dE   Z$ dF dG   Z% dH dI   Z& dJ dK   Z' dL dM   Z( e dN dO    Z) e dP dQ    Z* e dR dS    Z+ e dT dU    Z, e dV dW    Z- d S)XCachea  Dictionary-like package cache.

    The APT cache file contains a hash table mapping names of binary
    packages to their metadata. A Cache object is the in-core
    representation of the same. It provides access to APTs idea of the
    list of available packages.

    The cache can be used like a mapping from package names to Package
    objects (although only getting items is supported).

    Keyword arguments:
    progress -- a OpProgress object,
    rootdir  -- an alternative root directory. if that is given the system
    sources.list and system lists/files are not read, only file relative
    to the given rootdir,
    memonly  -- build the cache in memory only.


    .. versionchanged:: 1.0

        The cache now supports package names with special architecture
        qualifiers such as :all and :native. It does not export them
        in :meth:`keys()`, though, to keep :meth:`keys()` a unique set.
    NFc             C   s|  d  |  _  d  |  _ d  |  _ d  |  _ i  |  _ i  |  _ t j   |  _ d |  _	 d  |  _
 |  j d d  |  j d d  | r t j j d d  | rkt j j |  } t j j | d  r t j t j | d  t j j | d  rt j t j | d  t j j d	 |  t j j d
 | d  t j j d t j j | d d d   |  j |  t j   |  j |  d  S)N   cache_post_open_inc_changes_countcache_post_changezDir::Cache::pkgcache z/etc/apt/apt.confz/etc/apt/apt.conf.dZDirzDir::State::statusz/var/lib/dpkg/statuszDir::bin::dpkgZusrbinZdpkg)_cache	_depcache_records_list
_callbacks_callbacks2weakrefWeakValueDictionary_weakref_changes_count_sorted_setconnectapt_pkgconfigsetospathabspathexistsZread_config_fileisdirZread_config_dirjoin_check_and_create_required_dirsZinit_systemopen)selfprogressrootdirZmemonlyr	   r	   r
   __init__L   s:    								
zCache.__init__c             C   s   |  j  d 7_  d S)zIncrease the number of changesr   N)r   )r-   r	   r	   r
   r   s   s    zCache._inc_changes_countc             C   s   d d g } d d d d g } x5 | D]- } t  j j | |  s% t  j | |  q% Wx; | D]3 } t  j j | |  s] t | | d  j   q] Wd S)	zf
        check if the required apt directories/files are there and if
        not create them
        z/var/lib/dpkg/statusz/etc/apt/sources.listz/var/lib/dpkgz	/etc/apt/z/var/cache/apt/archives/partialz/var/lib/apt/lists/partialwN)r%   r&   r(   makedirsr,   close)r-   r/   filesdirsdfr	   r	   r
   r+   w   s    		z%Cache._check_and_create_required_dirsc             C   s   | |  j  k rG x5 |  j  | D]& } | d k r< |  j   q |   q W| |  j k r x. |  j | D] \ } } } | |  | |  qd Wd S)z# internal helper to run a callback r   N)r   r   r   )r-   namecallbackargskwdsr	   r	   r
   _run_callbacks   s    zCache._run_callbacksc             C   s   | d k r t  j j j   } |  j   | |  _ |  j d  t j |  |  _	 t j
 |  j	  |  _ t j |  j	  |  _ t j   |  _ |  j j   d |  _ |  j j   t t j    d k |  _ | j   |  j d  d S)zY Open the package cache, after that it can be used like
            a dictionary
        NZcache_pre_openr   r   )aptr.   base
OpProgressr3   Zop_progressr<   r"   r   r   ZDepCacher   ZPackageRecordsr   
SourceListr   read_main_listr    r   clearlenZget_architecturesZ_have_multi_archdone)r-   r.   r	   r	   r
   r,      s    
		
z
Cache.openc             C   s   |  `  d |  _  d S)z Close the package cache N)r   )r-   r	   r	   r
   r3      s    zCache.closec             C   s   |  S)z Enter the with statement r	   )r-   r	   r	   r
   	__enter__   s    zCache.__enter__c             C   s   |  j    d S)z Exit the with statement N)r3   )r-   exc_type	exc_value	tracebackr	   r	   r
   __exit__   s    zCache.__exit__c             C   s   y |  j  | SWn t k
 r t |  } y |  j | } Wn" t k
 r` t d |   Yn X|  j |  s t d |   |  j |  } | |  j  | <| SYn Xd S)z" look like a dictionary (get key) z!The cache has no package named %rN)r   KeyErrorstrr   _Cache__is_real_pkg_rawpkg_to_pkg)r-   keyrawpkgpkgr	   r	   r
   __getitem__   s    zCache.__getitem__c             C   s)   y |  | SWn t  k
 r$ | SYn Xd S)zaReturn *self*[*key*] or *default* if *key* not in *self*.

        .. versionadded:: 1.1
        N)rJ   )r-   rN   defaultr	   r	   r
   get   s    z	Cache.getc             C   sX   | j  d d  } y |  j | } Wn. t k
 rS t |  |  } | |  j | <Yn X| S)zgReturns the apt.Package object for an apt_pkg.Package object.

        .. versionadded:: 1.0.0
        prettyF)get_fullnamer   rJ   r   )r-   rO   fullnamerP   r	   r	   r
   rM      s    zCache._rawpkg_to_pkgc             c   s$   x |  j    D] } |  | Vq Wd  S)N)keys)r-   pkgnamer	   r	   r
   __iter__   s    zCache.__iter__c             C   s   | j  S)z8Check if the apt_pkg.Package provided is a real package.)has_versions)r-   rO   r	   r	   r
   Z__is_real_pkg   s    zCache.__is_real_pkgc             C   s
   | |  k S)Nr	   )r-   rN   r	   r	   r
   has_key   s    zCache.has_keyc             C   s5   y |  j  |  j |  SWn t k
 r0 d SYn Xd  S)NF)rL   r   rJ   )r-   rN   r	   r	   r
   __contains__   s    zCache.__contains__c             C   s   t  |  j    S)N)rC   rW   )r-   r	   r	   r
   __len__   s    zCache.__len__c                sD     j  d  k r7 t   f d d     j j D    _  t   j   S)Nc             3   s0   |  ]& }   j  |  r | j d  d  Vq d S)rT   TN)rL   rU   ).0p)r-   r	   r
   	<genexpr>  s   zCache.keys.<locals>.<genexpr>)r    sortedr   packageslist)r-   r	   )r-   r
   rW     s    z
Cache.keysc             C   sO   g  } |  j  j } x6 |  j j D]( } | |  s | j |  j |   q W| S)z Get the marked changes )r   marked_keepr   rb   appendrM   )r-   changesrd   rO   r	   r	   r
   get_changes
  s    zCache.get_changesc             C   s(   |  j    |  j j |  |  j   d S)zUpgrade all packages.

        If the parameter *dist_upgrade* is True, new dependencies will be
        installed as well (and conflicting packages may be removed). The
        default value is False.
        N)cache_pre_changer   upgrader   )r-   Zdist_upgrader	   r	   r
   ri     s    
zCache.upgradec             C   sY   |  j  d k r t d   t j |  j  } t j   } | j | |  j |  j   | j S)z;Get the size of the packages that are required to download.Nz&Cache object used after close() called)	r   r   r"   PackageManagerr   Acquireget_archivesr   Zfetch_needed)r-   pmfetcherr	   r	   r
   required_download  s    	zCache.required_downloadc             C   s
   |  j  j S)z8Get the size of the additional required space on the fs.)r   Zusr_size)r-   r	   r	   r
   required_space)  s    zCache.required_spacec             C   s   t    } |  j j } t t j t j f  } xX |  j j D]J } | |  } | r: | j	 r: | j
 | k r: | j | j d d   q: W| S)zAReturn the packages not downloadable packages in reqreinst state.rT   T)r$   r   get_candidate_ver	frozensetr"   ZINSTSTATE_REINSTREQZINSTSTATE_HOLD_REINSTREQr   rb   ZdownloadableZ
inst_stateaddrU   )r-   Z	reqreinstrq   ZstatesrP   Zcandr	   r	   r
   req_reinstall_pkgs.  s    		zCache.req_reinstall_pkgsc             C   s   | j    } d } d } xR | j D]G } | j | j k r= q" | j rI q" | d | j | j f 7} d } q" W| | j k r t |   n | r t	 |   | S)NFr   zFailed to fetch %s %s
T)
runitemsZstatusZ	STAT_DONEZ	STAT_IDLEZdesc_uriZ
error_textZRESULT_CANCELLEDr   r   )r-   rn   resZfailedZerr_msgitemr	   r	   r
   _run_fetcher;  s     	
zCache._run_fetcherc             C   s   |  j  d k r t d   t j j d  d } t j |  } | d k  r\ t d |   z0 | j | |  j |  j   s~ d S|  j	 |  SWd t
 j |  Xd S)z fetch the needed archives Nz&Cache object used after close() calledzDir::Cache::Archiveslockr   zFailed to lock %sF)r   r   r"   r#   find_dirget_lockr   rl   r   ry   r%   r3   )r-   rn   rm   lockfilerz   r	   r	   r
   _fetch_archivesR  s    	zCache._fetch_archivesc             C   sy   | d k	 r$ | d k	 r$ t  d   | d k rB t j j j   } | d k r] t j |  } |  j | t j |  j	   S)a
  Fetch the archives for all packages marked for install/upgrade.

        You can specify either an :class:`apt.progress.base.AcquireProgress()`
        object for the parameter *progress*, or specify an already
        existing :class:`apt_pkg.Acquire` object for the parameter *fetcher*.

        The return value of the function is undefined. If an error occurred,
        an exception of type :class:`FetchFailedException` or
        :class:`FetchCancelledException` is raised.

        .. versionadded:: 0.8.0
        Nz'Takes a progress or a an Acquire object)

ValueErrorr=   r.   textAcquireProgressr"   rk   r~   rj   r   )r-   r.   rn   r	   r	   r
   fetch_archivesh  s    	zCache.fetch_archivesc             C   sE   y |  j  | } Wn t k
 r) d SYn Xt | j o= | j  Sd S)z0Return whether the package is a virtual package.FN)r   rJ   boolZhas_providesrZ   )r-   rX   rP   r	   r	   r
   is_virtual_package  s
    	zCache.is_virtual_packageTc             C   s   t    } |  j j } y+ |  j | } | j r? | r? t |  SWn t k
 r^ t |  SYn XxR | j D]G \ } } }	 |	 j }
 | s |	 | |
  k ri | j	 |  j
 |
   qi Wt |  S)a)  Return a list of all packages providing a package.

        Return a list of packages which provide the virtual package of the
        specified name.

        If 'candidate_only' is False, return all packages with at
        least one version providing the virtual package. Otherwise,
        return only those packages where the candidate version
        provides the virtual package.

        If 'include_nonvirtual' is True then it will search for all
        packages providing pkgname, even if pkgname is not itself
        a virtual pkg.
        )r$   r   rq   r   rZ   rc   rJ   Zprovides_listZ
parent_pkgrs   rM   )r-   rX   Zcandidate_onlyZinclude_nonvirtualZ	providersrq   ZvpZprovidesZprovidesverversionrO   r	   r	   r
   get_providing_packages  s    		zCache.get_providing_packagesr   c             C   s  t  j j d  d } t  j |  } | d k  rA t d |   | r t  j j d  } t  j j d  } t  j j d  }	 t  j j d t j j	 |   t  j j d d  t  j j d d	  t  j
   }
 |
 j   n	 |  j }
 z | d
 k rt j j j   } y |  j j | |
 |  } Wn1 t k
 rT} z t |   WYd
 d
 } ~ Xn X| rn| rnt    n | SWd
 t j |  | rt  j j d |  t  j j d |  t  j j d |	  Xd
 S)a  Run the equivalent of apt-get update.

        You probably want to call open() afterwards, in order to utilise the
        new cache. Otherwise, the old cache will be used which can lead to
        strange bugs.

        The first parameter *fetch_progress* may be set to an instance of
        apt.progress.FetchProgress, the default is apt.progress.FetchProgress()
        .
        sources_list -- Update a alternative sources.list than the default.
        Note that the sources.list.d directory is ignored in this case
        zDir::State::Listsrz   r   zFailed to lock %szDir::Etc::sourcelistzDir::Etc::sourcepartszAPT::List-CleanupZxxx0N)r"   r#   r{   r|   r   findr$   r%   r&   r'   r@   rA   r   r=   r.   r>   r   r   updateSystemErrorr   r3   )r-   fetch_progressZpulse_intervalZraise_on_errorZsources_listr}   rz   Zold_sources_listZold_sources_list_dZold_cleanupZslistrw   er	   r	   r
   r     s>    	zCache.updatec             C   sm   y | j    Wn t k
 r, | j   Yn X| j |  } y | j   Wn t k
 rh | j   Yn X| S)z
        The first parameter *pm* refers to an object returned by
        apt_pkg.PackageManager().

        The second parameter *install_progress* refers to an InstallProgress()
        object of the module apt.progress.
        )ZstartUpdateAttributeErrorZstart_updateru   ZfinishUpdateZfinish_update)r-   rm   install_progressrw   r	   r	   r
   install_archives  s    	zCache.install_archivesc             C   s   | d k r t  j j j   } | d k r< t  j j j   } t j |  j  } t j |  } x |  j	 | |  } |  j
 | |  } | | j k r Pn@ | | j k r t d   n" | | j k r n t d |   | j   q` W| | j k S)aC  Apply the marked changes to the cache.

        The first parameter, *fetch_progress*, refers to a FetchProgress()
        object as found in apt.progress, the default being
        apt.progress.FetchProgress().

        The second parameter, *install_progress*, is a
        apt.progress.InstallProgress() object.
        NzinstallArchives() failedz<internal-error: unknown result code from InstallArchives: %s)r=   r.   r>   r   ZInstallProgressr"   rj   r   rk   r~   r   ZRESULT_COMPLETEDZRESULT_FAILEDr   ZRESULT_INCOMPLETEZshutdown)r-   r   r   rm   rn   rw   r	   r	   r
   commit  s&    
zCache.commitc             C   s   |  j  j   d S)z Unmark all changes N)r   init)r-   r	   r	   r
   rB     s    zCache.clearc             C   s   |  j  d  d S)z@ called internally if the cache has changed, emit a signal then r   N)r<   )r-   r	   r	   r
   r   !  s    zCache.cache_post_changec             C   s   |  j  d  d S)zS called internally if the cache is about to change, emit
            a signal then rh   N)r<   )r-   r	   r	   r
   rh   %  s    zCache.cache_pre_changec             C   sS   | d k r t  j d t d  | |  j k r; g  |  j | <|  j | j |  d S)zConnect to a signal.

        .. deprecated:: 1.0

            Please use connect2() instead, as this function is very
            likely to cause a memory leak.
        r   zAconnect() likely causes a reference cycle, use connect2() instead   N)warningswarnRuntimeWarningr   re   )r-   r8   r9   r	   r	   r
   r!   *  s    	
zCache.connectc             O   s=   | |  j  k r g  |  j  | <|  j  | j | | | f  d S)a;  Connect to a signal.

        The callback will be passed the cache as an argument, and
        any arguments passed to this function. Make sure that, if you
        pass a method of a class as your callback, your class does not
        contain a reference to the cache.

        Cyclic references to the cache can cause issues if the Cache object
        is replaced by a new one, because the cache keeps a lot of objects and
        tens of open file descriptors.

        currently only used for cache_{post,pre}_{changed,open}.

        .. versionadded:: 1.0
        N)r   re   )r-   r8   r9   r:   r;   r	   r	   r
   connect29  s    zCache.connect2c             C   s   t  j |  j  S)a  Return an `ActionGroup` object for the current cache.

        Action groups can be used to speedup actions. The action group is
        active as soon as it is created, and disabled when the object is
        deleted or when release() is called.

        You can use the action group as a context manager, this is the
        recommended way::

            with cache.actiongroup():
                for package in my_selected_packages:
                    package.mark_install()

        This way, the action group is automatically released as soon as the
        with statement block is left. It also has the benefit of making it
        clear which parts of the code run with a action group and which
        don't.
        )r"   ZActionGroupr   )r-   r	   r	   r
   actiongroupM  s    zCache.actiongroupc             C   sa   t  j j t j j d   } x< t  j t  j j | d   D] } t j | d  r= d Sq= Wd S)zReturn True if the dpkg was interrupted

        All dpkg operations will fail until this is fixed, the action to
        fix the system if dpkg got interrupted is to run
        'dpkg --configure -a' as root.
        zDir::State::statusZupdatesz[0-9]*TF)	r%   r&   dirnamer"   r#   Z	find_filelistdirr*   fnmatch)r-   Zdpkg_status_dirr7   r	   r	   r
   dpkg_journal_dirtyb  s    	%zCache.dpkg_journal_dirtyc             C   s
   |  j  j S)z7Return the number of packages with broken dependencies.)r   broken_count)r-   r	   r	   r
   r   q  s    zCache.broken_countc             C   s
   |  j  j S)z2Return the number of packages marked for deletion.)r   Z	del_count)r-   r	   r	   r
   delete_countv  s    zCache.delete_countc             C   s
   |  j  j S)z6Return the number of packages marked for installation.)r   Z
inst_count)r-   r	   r	   r
   install_count{  s    zCache.install_countc             C   s
   |  j  j S)z-Return the number of packages marked as keep.)r   
keep_count)r-   r	   r	   r
   r     s    zCache.keep_count).r   r   r   r   r0   r   r+   r<   r,   r3   rE   rI   rQ   rS   rM   rY   rL   r[   r\   r]   rW   rg   ri   propertyro   rp   rt   ry   r~   r   r   r   r   r   r   rB   r   rh   r!   r   r   r   r   r   r   r   r	   r	   r	   r
   r   2   sX   '
			3+r   c               @   sj   e  Z d  Z d Z d d   Z d d   Z d d   Z d d	   Z d
 d   Z d d   Z	 d d   Z
 d S)ProblemResolverzuResolve problems due to dependencies and conflicts.

    The first argument 'cache' is an instance of apt.Cache.
    c             C   s"   t  j | j  |  _ | |  _ d  S)N)r"   r   r   	_resolverr   )r-   cacher	   r	   r
   r0     s    zProblemResolver.__init__c             C   s   |  j  j | j  d S)z'Reset the package to the default state.N)r   rB   _pkg)r-   packager	   r	   r
   rB     s    zProblemResolver.clearc             C   s   |  j  j   d S)z/mark protected packages for install or removal.N)r   install_protect)r-   r	   r	   r
   r     s    zProblemResolver.install_protectc             C   s   |  j  j | j  d S)z)Protect a package so it won't be removed.N)r   protectr   )r-   r   r	   r	   r
   r     s    zProblemResolver.protectc             C   s   |  j  j | j  d S)zMark a package for removal.N)r   remover   )r-   r   r	   r	   r
   r     s    zProblemResolver.removec             C   s+   |  j  j   |  j j   |  j  j   d S)z:Resolve dependencies, try to remove packages where needed.N)r   rh   r   resolver   )r-   r	   r	   r
   r     s    zProblemResolver.resolvec             C   s+   |  j  j   |  j j   |  j  j   d S)z4Resolve dependencies, do not try to remove packages.N)r   rh   r   resolve_by_keepr   )r-   r	   r	   r
   r     s    zProblemResolver.resolve_by_keepN)r   r   r   r   r0   rB   r   r   r   r   r   r	   r	   r	   r
   r     s   r   c               @   s"   e  Z d  Z d Z d d   Z d S)Filterz Filter base class c             C   s   d S)zn Filter function, return True if the package matchs a
            filter criteria and False otherwise
        Tr	   )r-   rP   r	   r	   r
   apply  s    zFilter.applyN)r   r   r   r   r   r	   r	   r	   r
   r     s   r   c               @   s"   e  Z d  Z d Z d d   Z d S)MarkedChangesFilterz( Filter that returns all marked changes c             C   s'   | j  s | j s | j r d Sd Sd  S)NTF)Zmarked_installZmarked_deleteZmarked_upgrade)r-   rP   r	   r	   r
   r     s    zMarkedChangesFilter.applyN)r   r   r   r   r   r	   r	   r	   r
   r     s   r   c               @   s"   e  Z d  Z d Z d d   Z d S)InstalledFilterzMFilter that returns all installed packages.

    .. versionadded:: 1.0.0
    c             C   s   | j  S)N)Zis_installed)r-   rP   r	   r	   r
   r     s    zInstalledFilter.applyN)r   r   r   r   r   r	   r	   r	   r
   r     s   r   c               @   sF   e  Z d  Z d Z d d   Z d d   Z d d   Z d d	   Z d
 S)_FilteredCacheHelperz:Helper class for FilteredCache to break a reference cycle.c             C   s<   i  |  _  i  |  _ | j d |  j  | j d |  j  d  S)Nr   r   )	_filtered_filtersr   filter_cache_post_change)r-   r   r	   r	   r
   r0     s    		z_FilteredCacheHelper.__init__c             C   sR   i  |  _  xB | D]: } x1 |  j D]& } | j |  r  d |  j  | j <Pq  Wq Wd S)z internal helper to refilter r   N)r   r   r   r8   )r-   r   rP   r7   r	   r	   r
   _reapply_filter  s    	z$_FilteredCacheHelper._reapply_filterc             C   s   g  |  _  |  j  j |  d S)zSet the current active filter.N)r   re   )r-   filterr	   r	   r
   
set_filter  s    	z_FilteredCacheHelper.set_filterc             C   s   |  j  |  d S)z;Called internally if the cache changes, emit a signal then.N)r   )r-   r   r	   r	   r
   r     s    z-_FilteredCacheHelper.filter_cache_post_changeN)r   r   r   r   r0   r   r   r   r	   r	   r	   r
   r     s
   
r   c               @   s   e  Z d  Z d Z d d d d  Z d d   Z d d   Z d	 d
   Z d d   Z d d   Z	 d d   Z
 d d   Z d d   Z d d   Z d S)FilteredCacheza A package cache that is filtered.

        Can work on a existing cache or create a new one
    Nc             C   s=   | d  k r t  |  |  _ n	 | |  _ t |  j  |  _ d  S)N)r   r   r   _helper)r-   r   r.   r	   r	   r
   r0     s    	zFilteredCache.__init__c             C   s   t  |  j j  S)N)rC   r   r   )r-   r	   r	   r
   r]     s    zFilteredCache.__len__c             C   s   |  j  | S)N)r   )r-   rN   r	   r	   r
   rQ     s    zFilteredCache.__getitem__c             c   s'   x  |  j  j D] } |  j | Vq Wd  S)N)r   r   r   )r-   rX   r	   r	   r
   rY     s    zFilteredCache.__iter__c             C   s   |  j  j j   S)N)r   r   rW   )r-   r	   r	   r
   rW     s    zFilteredCache.keysc             C   s
   | |  k S)Nr	   )r-   rN   r	   r	   r
   r[     s    zFilteredCache.has_keyc             C   s;   y |  j  | j |  j j k SWn t k
 r6 d SYn Xd  S)NF)r   r8   r   r   rJ   )r-   rN   r	   r	   r
   r\     s    zFilteredCache.__contains__c             C   s!   |  j  j |  |  j j   d S)zSet the current active filter.N)r   r   r   r   )r-   r   r	   r	   r
   r     s    zFilteredCache.set_filterc             C   s   |  j  j |  j  d S)z;Called internally if the cache changes, emit a signal then.N)r   r   r   )r-   r	   r	   r
   r     s    z&FilteredCache.filter_cache_post_changec             C   s   t  |  j |  S)z)we try to look exactly like a real cache.)getattrr   )r-   rN   r	   r	   r
   __getattr__  s    zFilteredCache.__getattr__)r   r   r   r   r0   r]   rQ   rY   rW   r[   r\   r   r   r   r	   r	   r	   r
   r     s   r   c             C   s   t  d  d  S)Nzcache pre changed)print)r   r	   r	   r
   cache_pre_changed   s    r   c             C   s   t  d  d  S)Nzcache post changed)r   )r   r	   r	   r
   cache_post_changed$  s    r   c              C   s  t  d  t j   t t j j j    }  |  j d t	  |  j d t
  t  d |  k  |  d } t  | j  t  t |    x- |  j   D] } |  | j | k s t  q W|  j   |  j   } t  t |   x | D] } | j s t  q Wx3 d d g D]% } t j j |  st j |  qWt j j d d  t j |  j  } t j t j j j    } |  j | |  t  d  t |   } | j j d t	  | j j d t
  | j j   | j t    t  t |   x- | j   D] } | | | j k st  qWt  t |   t  d	  t d
 t j j  j    } | j j d t	  | j j d t
  | j j   | j t    t  t |   x- | j   D] } | | | j k st  qWt  t |   d S)zInternal test code.zCache self testrh   r   Zaptitudez/tmp/pytestz/tmp/pytest/partialzDir::Cache::Archivesz.Testing filtered cache (argument is old cache)z$Testing filtered cache (no argument)r.   N)!r   r"   r   r   r=   r.   r   r?   r   r   r   r8   rC   rW   AssertionErrorri   rg   r%   r&   r(   mkdirr#   r$   rj   r   rk   r   r~   r   r   r   r   r>   )r   rP   rX   rf   r   rm   rn   Zfilteredr	   r	   r
   _test(  sV    





r   __main__)Z
__future__r   r   r%   r   r   r"   r=   r   Zapt.progress.textIOErrorr   r   r   	Exceptionr   objectr   r   r   r   r   r   r   r   r   r   r   r	   r	   r	   r
   <module>   s2     V*


 26                                                                                                                                                                                                                                                                                                                                             
<W                 @   s[   d  Z  d d l m Z d d l Z d d l Z d d l m Z Gd d   d e j  Z d S)z"Classes related to cdrom handling.    )print_functionN)CdromProgressc               @   s[   e  Z d  Z d Z d d d d d  Z d d d  Z d d d	  Z e d
 d    Z d S)Cdroma;  Support for apt-cdrom like features.

    This class has several optional parameters for initialisation, which may
    be used to influence the behaviour of the object:

    The optional parameter `progress` is a CdromProgress() subclass, which will
    ask for the correct cdrom, etc. If not specified or None, a CdromProgress()
    object will be used.

    The optional parameter `mountpoint` may be used to specify an alternative
    mountpoint.

    If the optional parameter `nomount` is True, the cdroms will not be
    mounted. This is the default behaviour.
    NTc             C   s   t  j j |   | d  k r+ t   |  _ n	 | |  _ | d  k	 rS t  j j d |  | ro t  j j d d  n t  j j d d  d  S)NzAcquire::cdrom::mountzAPT::CDROM::NoMounttruefalse)apt_pkgr   __init__r   	_progressconfigset)selfprogressZ
mountpointZnomount r   +/usr/lib/python3/dist-packages/apt/cdrom.pyr   0   s    	zCdrom.__init__c             C   s   t  j j |  | p |  j  S)zAdd cdrom to the sources.list.)r   r   addr	   )r   r   r   r   r   r   ?   s    z	Cdrom.addc             C   s   t  j j |  | p |  j  S)zIdentify the cdrom.)r   r   identr	   )r   r   r   r   r   r   C   s    zCdrom.identc             C   s   |  j    } | d k r d St j t j j d  d  } | j t j j d   x[ | D]S } t |  > } x4 | D], } | j   j	 d  rw | | k rw d Sqw WWd QRXq[ Wd S)z:Check if the cdrom is already in the current sources.list.NFzDir::Etc::sourceparts*zDir::Etc::sourcelist#T)
r   globr   r
   Zfind_dirappendZ	find_fileopenlstrip
startswith)r   Zcd_idsrcfnameZfobjliner   r   r   in_sources_listG   s    "zCdrom.in_sources_list)	__name__
__module____qualname____doc__r   r   r   propertyr   r   r   r   r   r      s
   r   )r    Z
__future__r   r   r   Zapt.progress.baser   r   r   r   r   r   <module>   s
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # apt/progress/base.py - Base classes for progress reporting.
#
# Copyright (C) 2009 Julian Andres Klode <jak@debian.org>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation; either version 2 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
# USA
# pylint: disable-msg = R0201
"""Base classes for progress reporting.

Custom progress classes should inherit from these classes. They can also be
used as dummy progress classes which simply do nothing.
"""
from __future__ import print_function

import errno
import fcntl
import os
import re
import select
import sys

import apt_pkg

__all__ = ['AcquireProgress', 'CdromProgress', 'InstallProgress', 'OpProgress']


class AcquireProgress(object):
    """Monitor object for downloads controlled by the Acquire class.

    This is an mostly abstract class. You should subclass it and implement the
    methods to get something useful.
    """

    current_bytes = current_cps = fetched_bytes = last_bytes = total_bytes \
                  = 0.0
    current_items = elapsed_time = total_items = 0

    def done(self, item):
        """Invoked when an item is successfully and completely fetched."""

    def fail(self, item):
        """Invoked when an item could not be fetched."""

    def fetch(self, item):
        """Invoked when some of the item's data is fetched."""

    def ims_hit(self, item):
        """Invoked when an item is confirmed to be up-to-date.

        Invoked when an item is confirmed to be up-to-date. For instance,
        when an HTTP download is informed that the file on the server was
        not modified.
        """

    def media_change(self, media, drive):
        """Prompt the user to change the inserted removable media.

        The parameter 'media' decribes the name of the media type that
        should be changed, whereas the parameter 'drive' should be the
        identifying name of the drive whose media should be changed.

        This method should not return until the user has confirmed to the user
        interface that the media change is complete. It must return True if
        the user confirms the media change, or False to cancel it.
        """
        return False

    def pulse(self, owner):
        """Periodically invoked while the Acquire process is underway.

        This method gets invoked while the Acquire progress given by the
        parameter 'owner' is underway. It should display information about
        the current state.

        This function returns a boolean value indicating whether the
        acquisition should be continued (True) or cancelled (False).
        """
        return True

    def start(self):
        """Invoked when the Acquire process starts running."""
        # Reset all our values.
        self.current_bytes = 0.0
        self.current_cps = 0.0
        self.current_items = 0
        self.elapsed_time = 0
        self.fetched_bytes = 0.0
        self.last_bytes = 0.0
        self.total_bytes = 0.0
        self.total_items = 0

    def stop(self):
        """Invoked when the Acquire process stops running."""


class CdromProgress(object):
    """Base class for reporting the progress of adding a cdrom.

    Can be used with apt_pkg.Cdrom to produce an utility like apt-cdrom. The
    attribute 'total_steps' defines the total number of steps and can be used
    in update() to display the current progress.
    """

    total_steps = 0

    def ask_cdrom_name(self):
        """Ask for the name of the cdrom.

        If a name has been provided, return it. Otherwise, return None to
        cancel the operation.
        """

    def change_cdrom(self):
        """Ask for the CD-ROM to be changed.

        Return True once the cdrom has been changed or False to cancel the
        operation.
        """

    def update(self, text, current):
        """Periodically invoked to update the interface.

        The string 'text' defines the text which should be displayed. The
        integer 'current' defines the number of completed steps.
        """


class InstallProgress(object):
    """Class to report the progress of installing packages."""

    child_pid, percent, select_timeout, status = 0, 0.0, 0.1, ""

    def __init__(self):
        (self.statusfd, self.writefd) = os.pipe()
        # These will leak fds, but fixing this safely requires API changes.
        self.write_stream = os.fdopen(self.writefd, "w")
        self.status_stream = os.fdopen(self.statusfd, "r")
        fcntl.fcntl(self.statusfd, fcntl.F_SETFL, os.O_NONBLOCK)

    def start_update(self):
        """(Abstract) Start update."""

    def finish_update(self):
        """(Abstract) Called when update has finished."""

    def error(self, pkg, errormsg):
        """(Abstract) Called when a error is detected during the install."""

    def conffile(self, current, new):
        """(Abstract) Called when a conffile question from dpkg is detected."""

    def status_change(self, pkg, percent, status):
        """(Abstract) Called when the APT status changed."""

    def dpkg_status_change(self, pkg, status):
        """(Abstract) Called when the dpkg status changed."""

    def processing(self, pkg, stage):
        """(Abstract) Sent just before a processing stage starts.

        The parameter 'stage' is one of "upgrade", "install"
        (both sent before unpacking), "configure", "trigproc", "remove",
        "purge". This method is used for dpkg only.
        """

    def run(self, obj):
        """Install using the object 'obj'.

        This functions runs install actions. The parameter 'obj' may either
        be a PackageManager object in which case its do_install() method is
        called or the path to a deb file.

        If the object is a PackageManager, the functions returns the result
        of calling its do_install() method. Otherwise, the function returns
        the exit status of dpkg. In both cases, 0 means that there were no
        problems.
        """
        pid = self.fork()
        if pid == 0:
            # pm.do_install might raise a exception,
            # when this happens, we need to catch
            # it, otherwise os._exit() is not run
            # and the execution continues in the
            # parent code leading to very confusing bugs
            try:
                os._exit(obj.do_install(self.write_stream.fileno()))
            except AttributeError:
                os._exit(os.spawnlp(os.P_WAIT, "dpkg", "dpkg", "--status-fd",
                                    str(self.write_stream.fileno()), "-i",
                                    obj))
            except Exception as e:
                sys.stderr.write("%s\n" % e)
                os._exit(apt_pkg.PackageManager.RESULT_FAILED)

        self.child_pid = pid
        res = self.wait_child()
        return os.WEXITSTATUS(res)

    def fork(self):
        """Fork."""
        return os.fork()

    def update_interface(self):
        """Update the interface."""
        try:
            line = self.status_stream.readline()
        except IOError as err:
            # resource temporarly unavailable is ignored
            if err.errno != errno.EAGAIN and err.errno != errno.EWOULDBLOCK:
                print(err.strerror)
            return

        pkgname = status = status_str = percent = base = ""

        if line.startswith('pm'):
            try:
                (status, pkgname, percent, status_str) = line.split(":", 3)
            except ValueError:
                # silently ignore lines that can't be parsed
                return
        elif line.startswith('status'):
            try:
                (base, pkgname, status, status_str) = line.split(":", 3)
            except ValueError:
                (base, pkgname, status) = line.split(":", 2)
        elif line.startswith('processing'):
            (status, status_str, pkgname) = line.split(":", 2)
            self.processing(pkgname.strip(), status_str.strip())

        # Always strip the status message
        pkgname = pkgname.strip()
        status_str = status_str.strip()
        status = status.strip()

        if status == 'pmerror' or status == 'error':
            self.error(pkgname, status_str)
        elif status == 'conffile-prompt' or status == 'pmconffile':
            match = re.match("\s*\'(.*)\'\s*\'(.*)\'.*", status_str)
            if match:
                self.conffile(match.group(1), match.group(2))
        elif status == "pmstatus":
            # FIXME: Float comparison
            if float(percent) != self.percent or status_str != self.status:
                self.status_change(pkgname, float(percent), status_str.strip())
                self.percent = float(percent)
                self.status = status_str.strip()
        elif base == "status":
            self.dpkg_status_change(pkgname, status)

    def wait_child(self):
        """Wait for child progress to exit.

        This method is responsible for calling update_interface() from time to
        time. It exits once the child has exited. The return values is the
        full status returned from os.waitpid() (not only the return code).
        """
        (pid, res) = (0, 0)
        while True:
            try:
                select.select([self.status_stream], [], [],
                              self.select_timeout)
            except select.error as error:
                (errno_, _errstr) = error.args
                if errno_ != errno.EINTR:
                    raise

            self.update_interface()
            try:
                (pid, res) = os.waitpid(self.child_pid, os.WNOHANG)
                if pid == self.child_pid:
                    break
            except OSError as err:
                if err.errno == errno.ECHILD:
                    break
                if err.errno != errno.EINTR:
                    raise

        return res


class OpProgress(object):
    """Monitor objects for operations.

    Display the progress of operations such as opening the cache."""

    major_change, op, percent, subop = False, "", 0.0, ""

    def update(self, percent=None):
        """Called periodically to update the user interface.

        You may use the optional argument 'percent' to set the attribute
        'percent' in this call.
        """
        if percent is not None:
            self.percent = percent

    def done(self):
        """Called once an operation has been completed."""
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
<WB                 @   s    d  Z  d d l m Z g  Z d S)zProgress reporting.

This package provides progress reporting for the python-apt package. The module
'base' provides classes with no output, and the module 'text' provides classes
for terminals, etc.
    )print_functionN)__doc__Z
__future__r   __all__ r   r   7/usr/lib/python3/dist-packages/apt/progress/__init__.py<module>   s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        