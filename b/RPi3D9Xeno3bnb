SHA'           => '5.73',
            'DynaLoader'            => '1.17',
            'Env'                   => '1.04',
            'Errno'                 => '1.17',
            'ExtUtils::Manifest'    => '1.62',
            'ExtUtils::Typemaps'    => '3.18',
            'ExtUtils::Typemaps::Cmd'=> '3.18',
            'ExtUtils::Typemaps::InputMap'=> '3.18',
            'ExtUtils::Typemaps::OutputMap'=> '3.18',
            'ExtUtils::Typemaps::Type'=> '3.18',
            'Fatal'                 => '2.13',
            'File::Find'            => '1.23',
            'Hash::Util'            => '0.13',
            'IO::Compress::Adapter::Bzip2'=> '2.058',
            'IO::Compress::Adapter::Deflate'=> '2.058',
            'IO::Compress::Adapter::Identity'=> '2.058',
            'IO::Compress::Base'    => '2.058',
            'IO::Compress::Base::Common'=> '2.058',
            'IO::Compress::Bzip2'   => '2.058',
            'IO::Compress::Deflate' => '2.058',
            'IO::Compress::Gzip'    => '2.058',
            'IO::Compress::Gzip::Constants'=> '2.058',
            'IO::Compress::RawDeflate'=> '2.058',
            'IO::Compress::Zip'     => '2.058',
            'IO::Compress::Zip::Constants'=> '2.058',
            'IO::Compress::Zlib::Constants'=> '2.058',
            'IO::Compress::Zlib::Extra'=> '2.058',
            'IO::Uncompress::Adapter::Bunzip2'=> '2.058',
            'IO::Uncompress::Adapter::Identity'=> '2.058',
            'IO::Uncompress::Adapter::Inflate'=> '2.058',
            'IO::Uncompress::AnyInflate'=> '2.058',
            'IO::Uncompress::AnyUncompress'=> '2.058',
            'IO::Uncompress::Base'  => '2.058',
            'IO::Uncompress::Bunzip2'=> '2.058',
            'IO::Uncompress::Gunzip'=> '2.058',
            'IO::Uncompress::Inflate'=> '2.058',
            'IO::Uncompress::RawInflate'=> '2.058',
            'IO::Uncompress::Unzip' => '2.058',
            'Module::CoreList'      => '2.78',
            'Module::CoreList::TieHashDelta'=> '2.77',
            'Module::Pluggable'     => '4.5',
            'Module::Pluggable::Object'=> '4.5',
            'Opcode'                => '1.25',
            'Sys::Hostname'         => '1.17',
            'Term::UI'              => '0.32',
            'Thread::Queue'         => '3.01',
            'Tie::Hash::NamedCapture'=> '0.09',
            'Unicode::Collate'      => '0.93',
            'Unicode::Collate::CJK::Korean'=> '0.93',
            'Unicode::Collate::Locale'=> '0.93',
            'Unicode::Normalize'    => '1.16',
            'Unicode::UCD'          => '0.47',
            'XS::APItest'           => '0.46',
            '_charnames'            => '1.33',
            'autodie'               => '2.13',
            'autodie::exception'    => '2.13',
            'autodie::exception::system'=> '2.13',
            'autodie::hints'        => '2.13',
            'charnames'             => '1.33',
            're'                    => '0.23',
        },
        removed => {
        }
    },
    5.017007 => {
        delta_from => 5.017006,
        changed => {
            'B'                     => '1.41',
            'CPANPLUS::Dist::Build' => '0.68',
            'CPANPLUS::Dist::Build::Constants'=> '0.68',
            'Compress::Raw::Bzip2'  => '2.059',
            'Compress::Raw::Zlib'   => '2.059',
            'Compress::Zlib'        => '2.059',
            'Cwd'                   => '3.39_03',
            'Data::Dumper'          => '2.139',
            'Devel::Peek'           => '1.11',
            'Digest::SHA'           => '5.80',
            'DynaLoader'            => '1.18',
            'English'               => '1.06',
            'Errno'                 => '1.18',
            'ExtUtils::Command::MM' => '6.64',
            'ExtUtils::Liblist'     => '6.64',
            'ExtUtils::Liblist::Kid'=> '6.64',
            'ExtUtils::MM'          => '6.64',
            'ExtUtils::MM_AIX'      => '6.64',
            'ExtUtils::MM_Any'      => '6.64',
            'ExtUtils::MM_BeOS'     => '6.64',
            'ExtUtils::MM_Cygwin'   => '6.64',
            'ExtUtils::MM_DOS'      => '6.64',
            'ExtUtils::MM_Darwin'   => '6.64',
            'ExtUtils::MM_MacOS'    => '6.64',
            'ExtUtils::MM_NW5'      => '6.64',
            'ExtUtils::MM_OS2'      => '6.64',
            'ExtUtils::MM_QNX'      => '6.64',
            'ExtUtils::MM_UWIN'     => '6.64',
            'ExtUtils::MM_Unix'     => '6.64',
            'ExtUtils::MM_VMS'      => '6.64',
            'ExtUtils::MM_VOS'      => '6.64',
            'ExtUtils::MM_Win32'    => '6.64',
            'ExtUtils::MM_Win95'    => '6.64',
            'ExtUtils::MY'          => '6.64',
            'ExtUtils::MakeMaker'   => '6.64',
            'ExtUtils::MakeMaker::Config'=> '6.64',
            'ExtUtils::Mkbootstrap' => '6.64',
            'ExtUtils::Mksymlists'  => '6.64',
            'ExtUtils::testlib'     => '6.64',
            'File::DosGlob'         => '1.09',
            'File::Glob'            => '1.19',
            'GDBM_File'             => '1.15',
            'IO::Compress::Adapter::Bzip2'=> '2.059',
            'IO::Compress::Adapter::Deflate'=> '2.059',
            'IO::Compress::Adapter::Identity'=> '2.059',
            'IO::Compress::Base'    => '2.059',
            'IO::Compress::Base::Common'=> '2.059',
            'IO::Compress::Bzip2'   => '2.059',
            'IO::Compress::Deflate' => '2.059',
            'IO::Compress::Gzip'    => '2.059',
            'IO::Compress::Gzip::Constants'=> '2.059',
            'IO::Compress::RawDeflate'=> '2.059',
            'IO::Compress::Zip'     => '2.059',
            'IO::Compress::Zip::Constants'=> '2.059',
            'IO::Compress::Zlib::Constants'=> '2.059',
            'IO::Compress::Zlib::Extra'=> '2.059',
            'IO::Uncompress::Adapter::Bunzip2'=> '2.059',
            'IO::Uncompress::Adapter::Identity'=> '2.059',
            'IO::Uncompress::Adapter::Inflate'=> '2.059',
            'IO::Uncompress::AnyInflate'=> '2.059',
            'IO::Uncompress::AnyUncompress'=> '2.059',
            'IO::Uncompress::Base'  => '2.059',
            'IO::Uncompress::Bunzip2'=> '2.059',
            'IO::Uncompress::Gunzip'=> '2.059',
            'IO::Uncompress::Inflate'=> '2.059',
            'IO::Uncompress::RawInflate'=> '2.059',
            'IO::Uncompress::Unzip' => '2.059',
            'List::Util'            => '1.26',
            'List::Util::XS'        => '1.26',
            'Locale::Codes'         => '3.24',
            'Locale::Codes::Constants'=> '3.24',
            'Locale::Codes::Country'=> '3.24',
            'Locale::Codes::Country_Codes'=> '3.24',
            'Locale::Codes::Country_Retired'=> '3.24',
            'Locale::Codes::Currency'=> '3.24',
            'Locale::Codes::Currency_Codes'=> '3.24',
            'Locale::Codes::Currency_Retired'=> '3.24',
            'Locale::Codes::LangExt'=> '3.24',
            'Locale::Codes::LangExt_Codes'=> '3.24',
            'Locale::Codes::LangExt_Retired'=> '3.24',
            'Locale::Codes::LangFam'=> '3.24',
            'Locale::Codes::LangFam_Codes'=> '3.24',
            'Locale::Codes::LangFam_Retired'=> '3.24',
            'Locale::Codes::LangVar'=> '3.24',
            'Locale::Codes::LangVar_Codes'=> '3.24',
            'Locale::Codes::LangVar_Retired'=> '3.24',
            'Locale::Codes::Language'=> '3.24',
            'Locale::Codes::Language_Codes'=> '3.24',
            'Locale::Codes::Language_Retired'=> '3.24',
            'Locale::Codes::Script' => '3.24',
            'Locale::Codes::Script_Codes'=> '3.24',
            'Locale::Codes::Script_Retired'=> '3.24',
            'Locale::Country'       => '3.24',
            'Locale::Currency'      => '3.24',
            'Locale::Language'      => '3.24',
            'Locale::Maketext'      => '1.23',
            'Locale::Script'        => '3.24',
            'Module::CoreList'      => '2.79',
            'Module::CoreList::TieHashDelta'=> '2.79',
            'POSIX'                 => '1.32',
            'Scalar::Util'          => '1.26',
            'Socket'                => '2.006_001',
            'Storable'              => '2.40',
            'Term::ReadLine'        => '1.11',
            'Unicode::Collate'      => '0.96',
            'Unicode::Collate::CJK::Stroke'=> '0.94',
            'Unicode::Collate::CJK::Zhuyin'=> '0.94',
            'Unicode::Collate::Locale'=> '0.96',
            'XS::APItest'           => '0.48',
            'XS::Typemap'           => '0.09',
            '_charnames'            => '1.34',
            'charnames'             => '1.34',
            'feature'               => '1.32',
            'mro'                   => '1.10',
            'sigtrap'               => '1.07',
            'sort'                  => '2.02',
        },
        removed => {
        }
    },
    5.017008 => {
        delta_from => 5.017007,
        changed => {
            'Archive::Extract'      => '0.62',
            'B'                     => '1.42',
            'B::Concise'            => '0.95',
            'Compress::Raw::Bzip2'  => '2.060',
            'Compress::Raw::Zlib'   => '2.060',
            'Compress::Zlib'        => '2.060',
            'Cwd'                   => '3.40',
            'Data::Dumper'          => '2.141',
            'Digest::SHA'           => '5.81',
            'ExtUtils::Install'     => '1.59',
            'File::Fetch'           => '0.38',
            'File::Path'            => '2.09',
            'File::Spec'            => '3.40',
            'File::Spec::Cygwin'    => '3.40',
            'File::Spec::Epoc'      => '3.40',
            'File::Spec::Functions' => '3.40',
            'File::Spec::Mac'       => '3.40',
            'File::Spec::OS2'       => '3.40',
            'File::Spec::Unix'      => '3.40',
            'File::Spec::VMS'       => '3.40',
            'File::Spec::Win32'     => '3.40',
            'HTTP::Tiny'            => '0.025',
            'Hash::Util'            => '0.14',
            'I18N::LangTags'        => '0.39',
            'I18N::LangTags::List'  => '0.39',
            'I18N::Langinfo'        => '0.09',
            'IO'                    => '1.26',
            'IO::Compress::Adapter::Bzip2'=> '2.060',
            'IO::Compress::Adapter::Deflate'=> '2.060',
            'IO::Compress::Adapter::Identity'=> '2.060',
            'IO::Compress::Base'    => '2.060',
            'IO::Compress::Base::Common'=> '2.060',
            'IO::Compress::Bzip2'   => '2.060',
            'IO::Compress::Deflate' => '2.060',
            'IO::Compress::Gzip'    => '2.060',
            'IO::Compress::Gzip::Constants'=> '2.060',
            'IO::Compress::RawDeflate'=> '2.060',
            'IO::Compress::Zip'     => '2.060',
            'IO::Compress::Zip::Constants'=> '2.060',
            'IO::Compress::Zlib::Constants'=> '2.060',
            'IO::Compress::Zlib::Extra'=> '2.060',
            'IO::Uncompress::Adapter::Bunzip2'=> '2.060',
            'IO::Uncompress::Adapter::Identity'=> '2.060',
            'IO::Uncompress::Adapter::Inflate'=> '2.060',
            'IO::Uncompress::AnyInflate'=> '2.060',
            'IO::Uncompress::AnyUncompress'=> '2.060',
            'IO::Uncompress::Base'  => '2.060',
            'IO::Uncompress::Bunzip2'=> '2.060',
            'IO::Uncompress::Gunzip'=> '2.060',
            'IO::Uncompress::Inflate'=> '2.060',
            'IO::Uncompress::RawInflate'=> '2.060',
            'IO::Uncompress::Unzip' => '2.060',
            'List::Util'            => '1.27',
            'List::Util::XS'        => '1.27',
            'Module::CoreList'      => '2.80',
            'Module::CoreList::TieHashDelta'=> '2.80',
            'Pod::Html'             => '1.17',
            'Pod::LaTeX'            => '0.61',
            'Pod::Man'              => '2.27',
            'Pod::Text'             => '3.17',
            'Pod::Text::Color'      => '2.07',
            'Pod::Text::Overstrike' => '2.05',
            'Pod::Text::Termcap'    => '2.07',
            'Safe'                  => '2.34',
            'Scalar::Util'          => '1.27',
            'Socket'                => '2.009',
            'Term::ANSIColor'       => '4.02',
            'Test'                  => '1.26',
            'Unicode::Collate'      => '0.97',
            'XS::APItest'           => '0.51',
            'XS::Typemap'           => '0.10',
            '_charnames'            => '1.35',
            'charnames'             => '1.35',
            'constant'              => '1.25',
            'diagnostics'           => '1.31',
            'threads::shared'       => '1.43',
            'warnings'              => '1.16',
        },
        removed => {
        }
    },
    5.017009 => {
        delta_from => 5.017008,
        changed => {
            'App::Cpan'             => '1.60_02',
            'App::Prove'            => '3.26',
            'App::Prove::State'     => '3.26',
            'App::Prove::State::Result'=> '3.26',
            'App::Prove::State::Result::Test'=> '3.26',
            'Archive::Extract'      => '0.68',
            'Attribute::Handlers'   => '0.94',
            'B::Lint'               => '1.17',
            'B::Lint::Debug'        => '1.17',
            'Benchmark'             => '1.14',
            'CPAN'                  => '2.00',
            'CPAN::Distribution'    => '2.00',
            'CPAN::FirstTime'       => '5.5304',
            'CPAN::Nox'             => '5.5001',
            'CPANPLUS'              => '0.9135',
            'CPANPLUS::Backend'     => '0.9135',
            'CPANPLUS::Backend::RV' => '0.9135',
            'CPANPLUS::Config'      => '0.9135',
            'CPANPLUS::Config::HomeEnv'=> '0.9135',
            'CPANPLUS::Configure'   => '0.9135',
            'CPANPLUS::Configure::Setup'=> '0.9135',
            'CPANPLUS::Dist'        => '0.9135',
            'CPANPLUS::Dist::Autobundle'=> '0.9135',
            'CPANPLUS::Dist::Base'  => '0.9135',
            'CPANPLUS::Dist::Build' => '0.70',
            'CPANPLUS::Dist::Build::Constants'=> '0.70',
            'CPANPLUS::Dist::MM'    => '0.9135',
            'CPANPLUS::Dist::Sample'=> '0.9135',
            'CPANPLUS::Error'       => '0.9135',
            'CPANPLUS::Internals'   => '0.9135',
            'CPANPLUS::Internals::Constants'=> '0.9135',
            'CPANPLUS::Internals::Constants::Report'=> '0.9135',
            'CPANPLUS::Internals::Extract'=> '0.9135',
            'CPANPLUS::Internals::Fetch'=> '0.9135',
            'CPANPLUS::Internals::Report'=> '0.9135',
            'CPANPLUS::Internals::Search'=> '0.9135',
            'CPANPLUS::Internals::Source'=> '0.9135',
            'CPANPLUS::Internals::Source::Memory'=> '0.9135',
            'CPANPLUS::Internals::Source::SQLite'=> '0.9135',
            'CPANPLUS::Internals::Source::SQLite::Tie'=> '0.9135',
            'CPANPLUS::Internals::Utils'=> '0.9135',
            'CPANPLUS::Internals::Utils::Autoflush'=> '0.9135',
            'CPANPLUS::Module'      => '0.9135',
            'CPANPLUS::Module::Author'=> '0.9135',
            'CPANPLUS::Module::Author::Fake'=> '0.9135',
            'CPANPLUS::Module::Checksums'=> '0.9135',
            'CPANPLUS::Module::Fake'=> '0.9135',
            'CPANPLUS::Module::Signature'=> '0.9135',
            'CPANPLUS::Selfupdate'  => '0.9135',
            'CPANPLUS::Shell'       => '0.9135',
            'CPANPLUS::Shell::Classic'=> '0.9135',
            'CPANPLUS::Shell::Default'=> '0.9135',
            'CPANPLUS::Shell::Default::Plugins::CustomSource'=> '0.9135',
            'CPANPLUS::Shell::Default::Plugins::Remote'=> '0.9135',
            'CPANPLUS::Shell::Default::Plugins::Source'=> '0.9135',
            'Config'                => '5.017009',
            'Config::Perl::V'       => '0.17',
            'DBM_Filter'            => '0.05',
            'Data::Dumper'          => '2.142',
            'Digest::SHA'           => '5.82',
            'Encode'                => '2.48',
            'ExtUtils::Installed'   => '1.999003',
            'ExtUtils::Manifest'    => '1.63',
            'ExtUtils::ParseXS::Utilities'=> '3.19',
            'ExtUtils::Typemaps'    => '3.19',
            'File::CheckTree'       => '4.42',
            'File::DosGlob'         => '1.10',
            'File::Temp'            => '0.22_90',
            'Filter::Simple'        => '0.89',
            'IO'                    => '1.27',
            'Log::Message'          => '0.06',
            'Log::Message::Config'  => '0.06',
            'Log::Message::Handlers'=> '0.06',
            'Log::Message::Item'    => '0.06',
            'Log::Message::Simple'  => '0.10',
            'Math::BigInt'          => '1.999',
            'Module::CoreList'      => '2.82',
            'Module::CoreList::TieHashDelta'=> '2.82',
            'Module::Load'          => '0.24',
            'Module::Pluggable'     => '4.6',
            'Module::Pluggable::Object'=> '4.6',
            'OS2::DLL'              => '1.05',
            'OS2::ExtAttr'          => '0.03',
            'OS2::Process'          => '1.08',
            'Object::Accessor'      => '0.46',
            'PerlIO::scalar'        => '0.16',
            'Pod::Checker'          => '1.60',
            'Pod::Find'             => '1.60',
            'Pod::Html'             => '1.18',
            'Pod::InputObjects'     => '1.60',
            'Pod::ParseUtils'       => '1.60',
            'Pod::Parser'           => '1.60',
            'Pod::Perldoc'          => '3.19',
            'Pod::Perldoc::BaseTo'  => '3.19',
            'Pod::Perldoc::GetOptsOO'=> '3.19',
            'Pod::Perldoc::ToANSI'  => '3.19',
            'Pod::Perldoc::ToChecker'=> '3.19',
            'Pod::Perldoc::ToMan'   => '3.19',
            'Pod::Perldoc::ToNroff' => '3.19',
            'Pod::Perldoc::ToPod'   => '3.19',
            'Pod::Perldoc::ToRtf'   => '3.19',
            'Pod::Perldoc::ToTerm'  => '3.19',
            'Pod::Perldoc::ToText'  => '3.19',
            'Pod::Perldoc::ToTk'    => '3.19',
            'Pod::Perldoc::ToXml'   => '3.19',
            'Pod::PlainText'        => '2.06',
            'Pod::Select'           => '1.60',
            'Pod::Usage'            => '1.61',
            'SelfLoader'            => '1.21',
            'TAP::Base'             => '3.26',
            'TAP::Formatter::Base'  => '3.26',
            'TAP::Formatter::Color' => '3.26',
            'TAP::Formatter::Console'=> '3.26',
            'TAP::Formatter::Console::ParallelSession'=> '3.26',
            'TAP::Formatter::Console::Session'=> '3.26',
            'TAP::Formatter::File'  => '3.26',
            'TAP::Formatter::File::Session'=> '3.26',
            'TAP::Formatter::Session'=> '3.26',
            'TAP::Harness'          => '3.26',
            'TAP::Object'           => '3.26',
            'TAP::Parser'           => '3.26',
            'TAP::Parser::Aggregator'=> '3.26',
            'TAP::Parser::Grammar'  => '3.26',
            'TAP::Parser::Iterator' => '3.26',
            'TAP::Parser::Iterator::Array'=> '3.26',
            'TAP::Parser::Iterator::Process'=> '3.26',
            'TAP::Parser::Iterator::Stream'=> '3.26',
            'TAP::Parser::IteratorFactory'=> '3.26',
            'TAP::Parser::Multiplexer'=> '3.26',
            'TAP::Parser::Result'   => '3.26',
            'TAP::Parser::Result::Bailout'=> '3.26',
            'TAP::Parser::Result::Comment'=> '3.26',
            'TAP::Parser::Result::Plan'=> '3.26',
            'TAP::Parser::Result::Pragma'=> '3.26',
            'TAP::Parser::Result::Test'=> '3.26',
            'TAP::Parser::Result::Unknown'=> '3.26',
            'TAP::Parser::Result::Version'=> '3.26',
            'TAP::Parser::Result::YAML'=> '3.26',
            'TAP::Parser::ResultFactory'=> '3.26',
            'TAP::Parser::Scheduler'=> '3.26',
            'TAP::Parser::Scheduler::Job'=> '3.26',
            'TAP::Parser::Scheduler::Spinner'=> '3.26',
            'TAP::Parser::Source'   => '3.26',
            'TAP::Parser::SourceHandler'=> '3.26',
            'TAP::Parser::SourceHandler::Executable'=> '3.26',
            'TAP::Parser::SourceHandler::File'=> '3.26',
            'TAP::Parser::SourceHandler::Handle'=> '3.26',
            'TAP::Parser::SourceHandler::Perl'=> '3.26',
            'TAP::Parser::SourceHandler::RawTAP'=> '3.26',
            'TAP::Parser::Utils'    => '3.26',
            'TAP::Parser::YAMLish::Reader'=> '3.26',
            'TAP::Parser::YAMLish::Writer'=> '3.26',
            'Term::UI'              => '0.34',
            'Test::Harness'         => '3.26',
            'Text::Soundex'         => '3.04',
            'Thread::Queue'         => '3.02',
            'Unicode::UCD'          => '0.50',
            'Win32'                 => '0.46',
            'Win32API::File'        => '0.1201',
            '_charnames'            => '1.36',
            'arybase'               => '0.06',
            'bigint'                => '0.32',
            'bignum'                => '0.32',
            'charnames'             => '1.36',
            'filetest'              => '1.03',
            'locale'                => '1.02',
            'overload'              => '1.21',
            'warnings'              => '1.17',
        },
        removed => {
        }
    },
    5.017010 => {
        delta_from => 5.017009,
        changed => {
            'Benchmark'             => '1.15',
            'Config'                => '5.017009',
            'Data::Dumper'          => '2.145',
            'Digest::SHA'           => '5.84',
            'Encode'                => '2.49',
            'ExtUtils::Command::MM' => '6.65_01',
            'ExtUtils::Liblist'     => '6.65_01',
            'ExtUtils::Liblist::Kid'=> '6.65_01',
            'ExtUtils::MM'          => '6.65_01',
            'ExtUtils::MM_AIX'      => '6.65_01',
            'ExtUtils::MM_Any'      => '6.65_01',
            'ExtUtils::MM_BeOS'     => '6.65_01',
            'ExtUtils::MM_Cygwin'   => '6.65_01',
            'ExtUtils::MM_DOS'      => '6.65_01',
            'ExtUtils::MM_Darwin'   => '6.65_01',
            'ExtUtils::MM_MacOS'    => '6.65_01',
            'ExtUtils::MM_NW5'      => '6.65_01',
            'ExtUtils::MM_OS2'      => '6.65_01',
            'ExtUtils::MM_QNX'      => '6.65_01',
            'ExtUtils::MM_UWIN'     => '6.65_01',
            'ExtUtils::MM_Unix'     => '6.65_01',
            'ExtUtils::MM_VMS'      => '6.65_01',
            'ExtUtils::MM_VOS'      => '6.65_01',
            'ExtUtils::MM_Win32'    => '6.65_01',
            'ExtUtils::MM_Win95'    => '6.65_01',
            'ExtUtils::MY'          => '6.65_01',
            'ExtUtils::MakeMaker'   => '6.65_01',
            'ExtUtils::MakeMaker::Config'=> '6.65_01',
            'ExtUtils::Mkbootstrap' => '6.65_01',
            'ExtUtils::Mksymlists'  => '6.65_01',
            'ExtUtils::testlib'     => '6.65_01',
            'File::Copy'            => '2.26',
            'File::Temp'            => '0.23',
            'Getopt::Long'          => '2.39',
            'Hash::Util'            => '0.15',
            'I18N::Langinfo'        => '0.10',
            'IPC::Cmd'              => '0.80',
            'JSON::PP'              => '2.27202',
            'Locale::Codes'         => '3.25',
            'Locale::Codes::Constants'=> '3.25',
            'Locale::Codes::Country'=> '3.25',
            'Locale::Codes::Country_Codes'=> '3.25',
            'Locale::Codes::Country_Retired'=> '3.25',
            'Locale::Codes::Currency'=> '3.25',
            'Locale::Codes::Currency_Codes'=> '3.25',
            'Locale::Codes::Currency_Retired'=> '3.25',
            'Locale::Codes::LangExt'=> '3.25',
            'Locale::Codes::LangExt_Codes'=> '3.25',
            'Locale::Codes::LangExt_Retired'=> '3.25',
            'Locale::Codes::LangFam'=> '3.25',
            'Locale::Codes::LangFam_Codes'=> '3.25',
            'Locale::Codes::LangFam_Retired'=> '3.25',
            'Locale::Codes::LangVar'=> '3.25',
            'Locale::Codes::LangVar_Codes'=> '3.25',
            'Locale::Codes::LangVar_Retired'=> '3.25',
            'Locale::Codes::Language'=> '3.25',
            'Locale::Codes::Language_Codes'=> '3.25',
            'Locale::Codes::Language_Retired'=> '3.25',
            'Locale::Codes::Script' => '3.25',
            'Locale::Codes::Script_Codes'=> '3.25',
            'Locale::Codes::Script_Retired'=> '3.25',
            'Locale::Country'       => '3.25',
            'Locale::Currency'      => '3.25',
            'Locale::Language'      => '3.25',
            'Locale::Script'        => '3.25',
            'Math::BigFloat'        => '1.998',
            'Math::BigFloat::Trace' => '0.32',
            'Math::BigInt'          => '1.9991',
            'Math::BigInt::CalcEmu' => '1.998',
            'Math::BigInt::Trace'   => '0.32',
            'Math::BigRat'          => '0.2604',
            'Module::CoreList'      => '2.84',
            'Module::CoreList::TieHashDelta'=> '2.84',
            'Module::Pluggable'     => '4.7',
            'Net::Ping'             => '2.41',
            'Perl::OSType'          => '1.003',
            'Pod::Simple'           => '3.26',
            'Pod::Simple::BlackBox' => '3.26',
            'Pod::Simple::Checker'  => '3.26',
            'Pod::Simple::Debug'    => '3.26',
            'Pod::Simple::DumpAsText'=> '3.26',
            'Pod::Simple::DumpAsXML'=> '3.26',
            'Pod::Simple::HTML'     => '3.26',
            'Pod::Simple::HTMLBatch'=> '3.26',
            'Pod::Simple::LinkSection'=> '3.26',
            'Pod::Simple::Methody'  => '3.26',
            'Pod::Simple::Progress' => '3.26',
            'Pod::Simple::PullParser'=> '3.26',
            'Pod::Simple::PullParserEndToken'=> '3.26',
            'Pod::Simple::PullParserStartToken'=> '3.26',
            'Pod::Simple::PullParserTextToken'=> '3.26',
            'Pod::Simple::PullParserToken'=> '3.26',
            'Pod::Simple::RTF'      => '3.26',
            'Pod::Simple::Search'   => '3.26',
            'Pod::Simple::SimpleTree'=> '3.26',
            'Pod::Simple::Text'     => '3.26',
            'Pod::Simple::TextContent'=> '3.26',
            'Pod::Simple::TiedOutFH'=> '3.26',
            'Pod::Simple::Transcode'=> '3.26',
            'Pod::Simple::TranscodeDumb'=> '3.26',
            'Pod::Simple::TranscodeSmart'=> '3.26',
            'Pod::Simple::XHTML'    => '3.26',
            'Pod::Simple::XMLOutStream'=> '3.26',
            'Safe'                  => '2.35',
            'Term::ReadLine'        => '1.12',
            'Text::ParseWords'      => '3.28',
            'Tie::File'             => '0.99',
            'Unicode::UCD'          => '0.51',
            'Win32'                 => '0.47',
            'bigint'                => '0.33',
            'bignum'                => '0.33',
            'bigrat'                => '0.33',
            'constant'              => '1.27',
            'perlfaq'               => '5.0150042',
            'version'               => '0.9902',
        },
        removed => {
        }
    },
    5.017011 => {
        delta_from => 5.017010,
        changed => {
            'App::Cpan'             => '1.61',
            'B::Deparse'            => '1.20',
            'Config'                => '5.017009',
            'Exporter'              => '5.68',
            'Exporter::Heavy'       => '5.68',
            'ExtUtils::CBuilder'    => '0.280210',
            'ExtUtils::Command::MM' => '6.66',
            'ExtUtils::Liblist'     => '6.66',
            'ExtUtils::Liblist::Kid'=> '6.66',
            'ExtUtils::MM'          => '6.66',
            'ExtUtils::MM_AIX'      => '6.66',
            'ExtUtils::MM_Any'      => '6.66',
            'ExtUtils::MM_BeOS'     => '6.66',
            'ExtUtils::MM_Cygwin'   => '6.66',
            'ExtUtils::MM_DOS'      => '6.66',
            'ExtUtils::MM_Darwin'   => '6.66',
            'ExtUtils::MM_MacOS'    => '6.66',
            'ExtUtils::MM_NW5'      => '6.66',
            'ExtUtils::MM_OS2'      => '6.66',
            'ExtUtils::MM_QNX'      => '6.66',
            'ExtUtils::MM_UWIN'     => '6.66',
            'ExtUtils::MM_Unix'     => '6.66',
            'ExtUtils::MM_VMS'      => '6.66',
            'ExtUtils::MM_VOS'      => '6.66',
            'ExtUtils::MM_Win32'    => '6.66',
            'ExtUtils::MM_Win95'    => '6.66',
            'ExtUtils::MY'          => '6.66',
            'ExtUtils::MakeMaker'   => '6.66',
            'ExtUtils::MakeMaker::Config'=> '6.66',
            'ExtUtils::Mkbootstrap' => '6.66',
            'ExtUtils::Mksymlists'  => '6.66',
            'ExtUtils::testlib'     => '6.66',
            'File::Glob'            => '1.20',
            'IO'                    => '1.28',
            'Module::CoreList'      => '2.87',
            'Module::CoreList::TieHashDelta'=> '2.87',
            'Storable'              => '2.41',
            'bigint'                => '0.34',
            'mro'                   => '1.11',
            'overload'              => '1.22',
            'warnings'              => '1.18',
        },
        removed => {
        }
    },
    5.018000 => {
        delta_from => 5.017011,
        changed => {
            'Carp'                  => '1.29',
            'Carp::Heavy'           => '1.29',
            'Config'                => '5.018000',
            'Hash::Util'            => '0.16',
            'IO::Handle'            => '1.34',
            'IO::Socket'            => '1.36',
            'Module::CoreList'      => '2.89',
            'Module::CoreList::TieHashDelta'=> '2.89',
            'Pod::Simple'           => '3.28',
            'Pod::Simple::BlackBox' => '3.28',
            'Pod::Simple::Checker'  => '3.28',
            'Pod::Simple::Debug'    => '3.28',
            'Pod::Simple::DumpAsText'=> '3.28',
            'Pod::Simple::DumpAsXML'=> '3.28',
            'Pod::Simple::HTML'     => '3.28',
            'Pod::Simple::HTMLBatch'=> '3.28',
            'Pod::Simple::LinkSection'=> '3.28',
            'Pod::Simple::Methody'  => '3.28',
            'Pod::Simple::Progress' => '3.28',
            'Pod::Simple::PullParser'=> '3.28',
            'Pod::Simple::PullParserEndToken'=> '3.28',
            'Pod::Simple::PullParserStartToken'=> '3.28',
            'Pod::Simple::PullParserTextToken'=> '3.28',
            'Pod::Simple::PullParserToken'=> '3.28',
            'Pod::Simple::RTF'      => '3.28',
            'Pod::Simple::Search'   => '3.28',
            'Pod::Simple::SimpleTree'=> '3.28',
            'Pod::Simple::Text'     => '3.28',
            'Pod::Simple::TextContent'=> '3.28',
            'Pod::Simple::TiedOutFH'=> '3.28',
            'Pod::Simple::Transcode'=> '3.28',
            'Pod::Simple::TranscodeDumb'=> '3.28',
            'Pod::Simple::TranscodeSmart'=> '3.28',
            'Pod::Simple::XHTML'    => '3.28',
            'Pod::Simple::XMLOutStream'=> '3.28',
        },
        removed => {
        }
    },
    5.018001 => {
        delta_from => 5.018000,
        changed => {
            'B'                     => '1.42_01',
            'Config'                => '5.018001',
            'Digest::SHA'           => '5.84_01',
            'Module::CoreList'      => '2.96',
            'Module::CoreList::TieHashDelta'=> '2.96',
            'Module::CoreList::Utils'=> '2.96',
        },
        removed => {
           'VMS::Filespec'         => 1,
        }
    },
    5.018002 => {
        delta_from => 5.018001,
        changed => {
            'B'                     => '1.42_02',
            'B::Concise'            => '0.95_01',
            'Config'                => '5.018002',
            'File::Glob'            => '1.20_01',
            'Module::CoreList'      => '3.03',
            'Module::CoreList::TieHashDelta'=> '3.03',
            'Module::CoreList::Utils'=> '3.03',
        },
    },
    5.018003 => {
        delta_from => 5.018002,
        changed => {
            'Config'                => '5.018003',
            'Digest::SHA'           => '5.84_02',
            'Module::CoreList'      => '3.12',
            'Module::CoreList::TieHashDelta'=> '3.12',
            'Module::CoreList::Utils'=> '3.12',
        },
    },
    5.018004 => {
        delta_from => 5.018003,
        changed => {
            'Config'                => '5.018004',
            'Module::CoreList'      => '3.13',
            'Module::CoreList::TieHashDelta'=> '3.13',
            'Module::CoreList::Utils'=> '3.13',
        },
    },
    5.019000 => {
        delta_from => 5.018000,
        changed => {
            'Config'                => '5.019000',
            'Getopt::Std'           => '1.08',
            'Module::CoreList'      => '2.91',
            'Module::CoreList::TieHashDelta'=> '2.91',
            'Storable'              => '2.42',
            'feature'               => '1.33',
            'utf8'                  => '1.11',
        },
        removed => {
           'Archive::Extract'      => 1,
           'B::Lint'               => 1,
           'B::Lint::Debug'        => 1,
           'CPANPLUS'              => 1,
           'CPANPLUS::Backend'     => 1,
           'CPANPLUS::Backend::RV' => 1,
           'CPANPLUS::Config'      => 1,
           'CPANPLUS::Config::HomeEnv'=> 1,
           'CPANPLUS::Configure'   => 1,
           'CPANPLUS::Configure::Setup'=> 1,
           'CPANPLUS::Dist'        => 1,
           'CPANPLUS::Dist::Autobundle'=> 1,
           'CPANPLUS::Dist::Base'  => 1,
           'CPANPLUS::Dist::Build' => 1,
           'CPANPLUS::Dist::Build::Constants'=> 1,
           'CPANPLUS::Dist::MM'    => 1,
           'CPANPLUS::Dist::Sample'=> 1,
           'CPANPLUS::Error'       => 1,
           'CPANPLUS::Internals'   => 1,
           'CPANPLUS::Internals::Constants'=> 1,
           'CPANPLUS::Internals::Constants::Report'=> 1,
           'CPANPLUS::Internals::Extract'=> 1,
           'CPANPLUS::Internals::Fetch'=> 1,
           'CPANPLUS::Internals::Report'=> 1,
           'CPANPLUS::Internals::Search'=> 1,
           'CPANPLUS::Internals::Source'=> 1,
           'CPANPLUS::Internals::Source::Memory'=> 1,
           'CPANPLUS::Internals::Source::SQLite'=> 1,
           'CPANPLUS::Internals::Source::SQLite::Tie'=> 1,
           'CPANPLUS::Internals::Utils'=> 1,
           'CPANPLUS::Internals::Utils::Autoflush'=> 1,
           'CPANPLUS::Module'      => 1,
           'CPANPLUS::Module::Author'=> 1,
           'CPANPLUS::Module::Author::Fake'=> 1,
           'CPANPLUS::Module::Checksums'=> 1,
           'CPANPLUS::Module::Fake'=> 1,
           'CPANPLUS::Module::Signature'=> 1,
           'CPANPLUS::Selfupdate'  => 1,
           'CPANPLUS::Shell'       => 1,
           'CPANPLUS::Shell::Classic'=> 1,
           'CPANPLUS::Shell::Default'=> 1,
           'CPANPLUS::Shell::Default::Plugins::CustomSource'=> 1,
           'CPANPLUS::Shell::Default::Plugins::Remote'=> 1,
           'CPANPLUS::Shell::Default::Plugins::Source'=> 1,
           'Devel::InnerPackage'   => 1,
           'File::CheckTree'       => 1,
           'Log::Message'          => 1,
           'Log::Message::Config'  => 1,
           'Log::Message::Handlers'=> 1,
           'Log::Message::Item'    => 1,
           'Log::Message::Simple'  => 1,
           'Module::Pluggable'     => 1,
           'Module::Pluggable::Object'=> 1,
           'Object::Accessor'      => 1,
           'Pod::LaTeX'            => 1,
           'Term::UI'              => 1,
           'Term::UI::History'     => 1,
           'Text::Soundex'         => 1,
        }
    },
    5.019001 => {
        delta_from => 5.019000,
        changed => {
            'App::Prove'            => '3.28',
            'App::Prove::State'     => '3.28',
            'App::Prove::State::Result'=> '3.28',
            'App::Prove::State::Result::Test'=> '3.28',
            'Archive::Tar'          => '1.92',
            'Archive::Tar::Constant'=> '1.92',
            'Archive::Tar::File'    => '1.92',
            'Attribute::Handlers'   => '0.95',
            'B'                     => '1.43',
            'B::Concise'            => '0.96',
            'B::Deparse'            => '1.21',
            'B::Showlex'            => '1.04',
            'Benchmark'             => '1.16',
            'CPAN::Meta'            => '2.131560',
            'CPAN::Meta::Converter' => '2.131560',
            'CPAN::Meta::Feature'   => '2.131560',
            'CPAN::Meta::History'   => '2.131560',
            'CPAN::Meta::Prereqs'   => '2.131560',
            'CPAN::Meta::Spec'      => '2.131560',
            'CPAN::Meta::Validator' => '2.131560',
            'Carp'                  => '1.30',
            'Carp::Heavy'           => '1.30',
            'Compress::Raw::Bzip2'  => '2.061',
            'Compress::Raw::Zlib'   => '2.061',
            'Compress::Zlib'        => '2.061',
            'Config'                => '5.019001',
            'Config::Perl::V'       => '0.18',
            'Cwd'                   => '3.41',
            'DB'                    => '1.06',
            'DB_File'               => '1.828',
            'Data::Dumper'          => '2.146',
            'Encode'                => '2.51',
            'Encode::CN::HZ'        => '2.06',
            'Encode::GSM0338'       => '2.03',
            'Encode::Unicode::UTF7' => '2.07',
            'ExtUtils::CBuilder::Base'=> '0.280210',
            'ExtUtils::CBuilder::Platform::Windows::BCC'=> '0.280210',
            'ExtUtils::Command::MM' => '6.68',
            'ExtUtils::Install'     => '1.60',
            'ExtUtils::Liblist'     => '6.68',
            'ExtUtils::Liblist::Kid'=> '6.68',
            'ExtUtils::MM'          => '6.68',
            'ExtUtils::MM_AIX'      => '6.68',
            'ExtUtils::MM_Any'      => '6.68',
            'ExtUtils::MM_BeOS'     => '6.68',
            'ExtUtils::MM_Cygwin'   => '6.68',
            'ExtUtils::MM_DOS'      => '6.68',
            'ExtUtils::MM_Darwin'   => '6.68',
            'ExtUtils::MM_MacOS'    => '6.68',
            'ExtUtils::MM_NW5'      => '6.68',
            'ExtUtils::MM_OS2'      => '6.68',
            'ExtUtils::MM_QNX'      => '6.68',
            'ExtUtils::MM_UWIN'     => '6.68',
            'ExtUtils::MM_Unix'     => '6.68',
            'ExtUtils::MM_VMS'      => '6.68',
            'ExtUtils::MM_VOS'      => '6.68',
            'ExtUtils::MM_Win32'    => '6.68',
            'ExtUtils::MM_Win95'    => '6.68',
            'ExtUtils::MY'          => '6.68',
            'ExtUtils::MakeMaker'   => '6.68',
            'ExtUtils::MakeMaker::Config'=> '6.68',
            'ExtUtils::Mkbootstrap' => '6.68',
            'ExtUtils::Mksymlists'  => '6.68',
            'ExtUtils::ParseXS'     => '3.19',
            'ExtUtils::testlib'     => '6.68',
            'Fatal'                 => '2.19',
            'File::Copy'            => '2.27',
            'File::DosGlob'         => '1.11',
            'File::Fetch'           => '0.42',
            'File::Find'            => '1.24',
            'File::Spec'            => '3.41',
            'File::Spec::Cygwin'    => '3.41',
            'File::Spec::Epoc'      => '3.41',
            'File::Spec::Mac'       => '3.41',
            'File::Spec::OS2'       => '3.41',
            'File::Spec::Unix'      => '3.41',
            'File::Spec::VMS'       => '3.41',
            'File::Spec::Win32'     => '3.41',
            'File::Temp'            => '0.2301',
            'Filter::Simple'        => '0.90',
            'Filter::Util::Call'    => '1.49',
            'Getopt::Long'          => '2.4',
            'HTTP::Tiny'            => '0.031',
            'Hash::Util::FieldHash' => '1.11',
            'IO::Compress::Adapter::Bzip2'=> '2.061',
            'IO::Compress::Adapter::Deflate'=> '2.061',
            'IO::Compress::Adapter::Identity'=> '2.061',
            'IO::Compress::Base'    => '2.061',
            'IO::Compress::Base::Common'=> '2.061',
            'IO::Compress::Bzip2'   => '2.061',
            'IO::Compress::Deflate' => '2.061',
            'IO::Compress::Gzip'    => '2.061',
            'IO::Compress::Gzip::Constants'=> '2.061',
            'IO::Compress::RawDeflate'=> '2.061',
            'IO::Compress::Zip'     => '2.061',
            'IO::Compress::Zip::Constants'=> '2.061',
            'IO::Compress::Zlib::Constants'=> '2.061',
            'IO::Compress::Zlib::Extra'=> '2.061',
            'IO::Handle'            => '1.35',
            'IO::Uncompress::Adapter::Bunzip2'=> '2.061',
            'IO::Uncompress::Adapter::Identity'=> '2.061',
            'IO::Uncompress::Adapter::Inflate'=> '2.061',
            'IO::Uncompress::AnyInflate'=> '2.061',
            'IO::Uncompress::AnyUncompress'=> '2.061',
            'IO::Uncompress::Base'  => '2.061',
            'IO::Uncompress::Bunzip2'=> '2.061',
            'IO::Uncompress::Gunzip'=> '2.061',
            'IO::Uncompress::Inflate'=> '2.061',
            'IO::Uncompress::RawInflate'=> '2.061',
            'IO::Uncompress::Unzip' => '2.061',
            'IPC::Open3'            => '1.14',
            'Locale::Codes'         => '3.26',
            'Locale::Codes::Constants'=> '3.26',
            'Locale::Codes::Country'=> '3.26',
            'Locale::Codes::Country_Codes'=> '3.26',
            'Locale::Codes::Country_Retired'=> '3.26',
            'Locale::Codes::Currency'=> '3.26',
            'Locale::Codes::Currency_Codes'=> '3.26',
            'Locale::Codes::Currency_Retired'=> '3.26',
            'Locale::Codes::LangExt'=> '3.26',
            'Locale::Codes::LangExt_Codes'=> '3.26',
            'Locale::Codes::LangExt_Retired'=> '3.26',
            'Locale::Codes::LangFam'=> '3.26',
            'Locale::Codes::LangFam_Codes'=> '3.26',
            'Locale::Codes::LangFam_Retired'=> '3.26',
            'Locale::Codes::LangVar'=> '3.26',
            'Locale::Codes::LangVar_Codes'=> '3.26',
            'Locale::Codes::LangVar_Retired'=> '3.26',
            'Locale::Codes::Language'=> '3.26',
            'Locale::Codes::Language_Codes'=> '3.26',
            'Locale::Codes::Language_Retired'=> '3.26',
            'Locale::Codes::Script' => '3.26',
            'Locale::Codes::Script_Codes'=> '3.26',
            'Locale::Codes::Script_Retired'=> '3.26',
            'Locale::Country'       => '3.26',
            'Locale::Currency'      => '3.26',
            'Locale::Language'      => '3.26',
            'Locale::Maketext'      => '1.24',
            'Locale::Script'        => '3.26',
            'Math::BigFloat'        => '1.999',
            'Math::BigInt'          => '1.9992',
            'Math::BigInt::Calc'    => '1.998',
            'Math::BigInt::CalcEmu' => '1.9991',
            'Math::BigRat'          => '0.2606',
            'Module::Build'         => '0.4005',
            'Module::Build::Base'   => '0.4005',
            'Module::Build::Compat' => '0.4005',
            'Module::Build::Config' => '0.4005',
            'Module::Build::Cookbook'=> '0.4005',
            'Module::Build::Dumper' => '0.4005',
            'Module::Build::ModuleInfo'=> '0.4005',
            'Module::Build::Notes'  => '0.4005',
            'Module::Build::PPMMaker'=> '0.4005',
            'Module::Build::Platform::Amiga'=> '0.4005',
            'Module::Build::Platform::Default'=> '0.4005',
            'Module::Build::Platform::EBCDIC'=> '0.4005',
            'Module::Build::Platform::MPEiX'=> '0.4005',
            'Module::Build::Platform::MacOS'=> '0.4005',
            'Module::Build::Platform::RiscOS'=> '0.4005',
            'Module::Build::Platform::Unix'=> '0.4005',
            'Module::Build::Platform::VMS'=> '0.4005',
            'Module::Build::Platform::VOS'=> '0.4005',
            'Module::Build::Platform::Windows'=> '0.4005',
            'Module::Build::Platform::aix'=> '0.4005',
            'Module::Build::Platform::cygwin'=> '0.4005',
            'Module::Build::Platform::darwin'=> '0.4005',
            'Module::Build::Platform::os2'=> '0.4005',
            'Module::Build::PodParser'=> '0.4005',
            'Module::CoreList'      => '2.92',
            'Module::CoreList::TieHashDelta'=> '2.92',
            'Module::CoreList::Utils'=> '2.92',
            'Module::Metadata'      => '1.000014',
            'Net::Ping'             => '2.42',
            'OS2::Process'          => '1.09',
            'POSIX'                 => '1.33',
            'Pod::Find'             => '1.61',
            'Pod::Html'             => '1.19',
            'Pod::InputObjects'     => '1.61',
            'Pod::ParseUtils'       => '1.61',
            'Pod::Parser'           => '1.61',
            'Pod::Perldoc'          => '3.20',
            'Pod::Perldoc::BaseTo'  => '3.20',
            'Pod::Perldoc::GetOptsOO'=> '3.20',
            'Pod::Perldoc::ToANSI'  => '3.20',
            'Pod::Perldoc::ToChecker'=> '3.20',
            'Pod::Perldoc::ToMan'   => '3.20',
            'Pod::Perldoc::ToNroff' => '3.20',
            'Pod::Perldoc::ToPod'   => '3.20',
            'Pod::Perldoc::ToRtf'   => '3.20',
            'Pod::Perldoc::ToTerm'  => '3.20',
            'Pod::Perldoc::ToText'  => '3.20',
            'Pod::Perldoc::ToTk'    => '3.20',
            'Pod::Perldoc::ToXml'   => '3.20',
            'Pod::Select'           => '1.61',
            'Pod::Usage'            => '1.63',
            'Safe'                  => '2.36',
            'Storable'              => '2.43',
            'Sys::Hostname'         => '1.18',
            'Sys::Syslog'           => '0.33',
            'TAP::Base'             => '3.28',
            'TAP::Formatter::Base'  => '3.28',
            'TAP::Formatter::Color' => '3.28',
            'TAP::Formatter::Console'=> '3.28',
            'TAP::Formatter::Console::ParallelSession'=> '3.28',
            'TAP::Formatter::Console::Session'=> '3.28',
            'TAP::Formatter::File'  => '3.28',
            'TAP::Formatter::File::Session'=> '3.28',
            'TAP::Formatter::Session'=> '3.28',
            'TAP::Harness'          => '3.28',
            'TAP::Object'           => '3.28',
            'TAP::Parser'           => '3.28',
            'TAP::Parser::Aggregator'=> '3.28',
            'TAP::Parser::Grammar'  => '3.28',
            'TAP::Parser::Iterator' => '3.28',
            'TAP::Parser::Iterator::Array'=> '3.28',
            'TAP::Parser::Iterator::Process'=> '3.28',
            'TAP::Parser::Iterator::Stream'=> '3.28',
            'TAP::Parser::IteratorFactory'=> '3.28',
            'TAP::Parser::Multiplexer'=> '3.28',
            'TAP::Parser::Result'   => '3.28',
            'TAP::Parser::Result::Bailout'=> '3.28',
            'TAP::Parser::Result::Comment'=> '3.28',
            'TAP::Parser::Result::Plan'=> '3.28',
            'TAP::Parser::Result::Pragma'=> '3.28',
            'TAP::Parser::Result::Test'=> '3.28',
            'TAP::Parser::Result::Unknown'=> '3.28',
            'TAP::Parser::Result::Version'=> '3.28',
            'TAP::Parser::Result::YAML'=> '3.28',
            'TAP::Parser::ResultFactory'=> '3.28',
            'TAP::Parser::Scheduler'=> '3.28',
            'TAP::Parser::Scheduler::Job'=> '3.28',
            'TAP::Parser::Scheduler::Spinner'=> '3.28',
            'TAP::Parser::Source'   => '3.28',
            'TAP::Parser::SourceHandler'=> '3.28',
            'TAP::Parser::SourceHandler::Executable'=> '3.28',
            'TAP::Parser::SourceHandler::File'=> '3.28',
            'TAP::Parser::SourceHandler::Handle'=> '3.28',
            'TAP::Parser::SourceHandler::Perl'=> '3.28',
            'TAP::Parser::SourceHandler::RawTAP'=> '3.28',
            'TAP::Parser::Utils'    => '3.28',
            'TAP::Parser::YAMLish::Reader'=> '3.28',
            'TAP::Parser::YAMLish::Writer'=> '3.28',
            'Term::ReadLine'        => '1.13',
            'Test::Harness'         => '3.28',
            'Text::Tabs'            => '2013.0523',
            'Text::Wrap'            => '2013.0523',
            'Thread'                => '3.04',
            'Tie::File'             => '1.00',
            'Time::Piece'           => '1.2002',
            'Unicode::Collate'      => '0.98',
            'Unicode::UCD'          => '0.53',
            'XS::APItest'           => '0.53',
            '_charnames'            => '1.37',
            'autodie'               => '2.19',
            'autodie::exception'    => '2.19',
            'autodie::exception::system'=> '2.19',
            'autodie::hints'        => '2.19',
            'autodie::skip'         => '2.19',
            'bigint'                => '0.35',
            'charnames'             => '1.38',
            'encoding'              => '2.12',
            'inc::latest'           => '0.4005',
            'mro'                   => '1.12',
            'perlfaq'               => '5.0150043',
            're'                    => '0.25',
            'threads'               => '1.87',
            'threads::shared'       => '1.44',
            'utf8'                  => '1.12',
        },
        removed => {
        }
    },
    5.019002 => {
        delta_from => 5.019001,
        changed => {
            'B'                     => '1.44',
            'B::Concise'            => '0.98',
            'B::Deparse'            => '1.22',
            'Benchmark'             => '1.17',
            'Class::Struct'         => '0.65',
            'Config'                => '5.019002',
            'DB'                    => '1.07',
            'DBM_Filter'            => '0.06',
            'DBM_Filter::compress'  => '0.03',
            'DBM_Filter::encode'    => '0.03',
            'DBM_Filter::int32'     => '0.03',
            'DBM_Filter::null'      => '0.03',
            'DBM_Filter::utf8'      => '0.03',
            'DB_File'               => '1.829',
            'Data::Dumper'          => '2.147',
            'Devel::Peek'           => '1.12',
            'Digest::MD5'           => '2.53',
            'Digest::SHA'           => '5.85',
            'English'               => '1.07',
            'Errno'                 => '1.19',
            'ExtUtils::Embed'       => '1.31',
            'ExtUtils::Miniperl'    => '1',
            'ExtUtils::ParseXS'     => '3.21',
            'ExtUtils::ParseXS::Constants'=> '3.21',
            'ExtUtils::ParseXS::CountLines'=> '3.21',
            'ExtUtils::ParseXS::Eval'=> '3.19',
            'ExtUtils::ParseXS::Utilities'=> '3.21',
            'ExtUtils::Typemaps'    => '3.21',
            'ExtUtils::Typemaps::Cmd'=> '3.21',
            'ExtUtils::Typemaps::InputMap'=> '3.21',
            'ExtUtils::Typemaps::OutputMap'=> '3.21',
            'ExtUtils::Typemaps::Type'=> '3.21',
            'ExtUtils::XSSymSet'    => '1.3',
            'Fatal'                 => '2.20',
            'File::Basename'        => '2.85',
            'File::Spec::VMS'       => '3.43',
            'File::Spec::Win32'     => '3.42',
            'Getopt::Long'          => '2.41',
            'Getopt::Std'           => '1.09',
            'HTTP::Tiny'            => '0.034',
            'Hash::Util::FieldHash' => '1.12',
            'I18N::Langinfo'        => '0.11',
            'IO::Socket::INET'      => '1.34',
            'IO::Socket::UNIX'      => '1.25',
            'IPC::Cmd'              => '0.82',
            'MIME::Base64'          => '3.14',
            'Module::CoreList'      => '2.94',
            'Module::CoreList::TieHashDelta'=> '2.94',
            'Module::CoreList::Utils'=> '2.94',
            'POSIX'                 => '1.34',
            'Params::Check'         => '0.38',
            'Parse::CPAN::Meta'     => '1.4405',
            'Pod::Functions'        => '1.07',
            'Pod::Html'             => '1.2',
            'Safe'                  => '2.37',
            'Socket'                => '2.010',
            'Storable'              => '2.45',
            'Text::ParseWords'      => '3.29',
            'Tie::Array'            => '1.06',
            'Tie::Hash'             => '1.05',
            'Tie::Scalar'           => '1.03',
            'Time::Piece'           => '1.21',
            'Time::Seconds'         => '1.21',
            'XS::APItest'           => '0.54',
            'autodie'               => '2.20',
            'autodie::exception'    => '2.20',
            'autodie::exception::system'=> '2.20',
            'autodie::hints'        => '2.20',
            'autodie::skip'         => '2.20',
            'base'                  => '2.19',
            'deprecate'             => '0.03',
            'if'                    => '0.0603',
            'integer'               => '1.01',
            'strict'                => '1.08',
            'subs'                  => '1.02',
            'vmsish'                => '1.04',
        },
        removed => {
        }
    },
    5.019003 => {
        delta_from => 5.019002,
        changed => {
            'B'                     => '1.45',
            'CPAN::Meta'            => '2.132140',
            'CPAN::Meta::Converter' => '2.132140',
            'CPAN::Meta::Feature'   => '2.132140',
            'CPAN::Meta::History'   => '2.132140',
            'CPAN::Meta::Prereqs'   => '2.132140',
            'CPAN::Meta::Spec'      => '2.132140',
            'CPAN::Meta::Validator' => '2.132140',
            'Carp'                  => '1.31',
            'Carp::Heavy'           => '1.31',
            'Compress::Raw::Bzip2'  => '2.062',
            'Compress::Raw::Zlib'   => '2.062',
            'Compress::Zlib'        => '2.062',
            'Config'                => '5.019003',
            'Config::Perl::V'       => '0.19',
            'Cwd'                   => '3.44',
            'Data::Dumper'          => '2.148',
            'Devel::PPPort'         => '3.21',
            'Devel::Peek'           => '1.13',
            'DynaLoader'            => '1.19',
            'Encode'                => '2.52',
            'Encode::Alias'         => '2.17',
            'Encode::Encoding'      => '2.06',
            'Encode::GSM0338'       => '2.04',
            'Encode::MIME::Header'  => '2.14',
            'Encode::Unicode'       => '2.08',
            'English'               => '1.08',
            'Exporter'              => '5.69',
            'Exporter::Heavy'       => '5.69',
            'ExtUtils::Command::MM' => '6.72',
            'ExtUtils::Liblist'     => '6.72',
            'ExtUtils::Liblist::Kid'=> '6.72',
            'ExtUtils::MM'          => '6.72',
            'ExtUtils::MM_AIX'      => '6.72',
            'ExtUtils::MM_Any'      => '6.72',
            'ExtUtils::MM_BeOS'     => '6.72',
            'ExtUtils::MM_Cygwin'   => '6.72',
            'ExtUtils::MM_DOS'      => '6.72',
            'ExtUtils::MM_Darwin'   => '6.72',
            'ExtUtils::MM_MacOS'    => '6.72',
            'ExtUtils::MM_NW5'      => '6.72',
            'ExtUtils::MM_OS2'      => '6.72',
            'ExtUtils::MM_QNX'      => '6.72',
            'ExtUtils::MM_UWIN'     => '6.72',
            'ExtUtils::MM_Unix'     => '6.72',
            'ExtUtils::MM_VMS'      => '6.72',
            'ExtUtils::MM_VOS'      => '6.72',
            'ExtUtils::MM_Win32'    => '6.72',
            'ExtUtils::MM_Win95'    => '6.72',
            'ExtUtils::MY'          => '6.72',
            'ExtUtils::MakeMaker'   => '6.72',
            'ExtUtils::MakeMaker::Config'=> '6.72',
            'ExtUtils::Mkbootstrap' => '6.72',
            'ExtUtils::Mksymlists'  => '6.72',
            'ExtUtils::ParseXS::Eval'=> '3.21',
            'ExtUtils::testlib'     => '6.72',
            'File::Spec'            => '3.44',
            'File::Spec::Cygwin'    => '3.44',
            'File::Spec::Epoc'      => '3.44',
            'File::Spec::Functions' => '3.44',
            'File::Spec::Mac'       => '3.44',
            'File::Spec::OS2'       => '3.44',
            'File::Spec::Unix'      => '3.44',
            'File::Spec::VMS'       => '3.44',
            'File::Spec::Win32'     => '3.44',
            'Getopt::Std'           => '1.10',
            'IO::Compress::Adapter::Bzip2'=> '2.062',
            'IO::Compress::Adapter::Deflate'=> '2.062',
            'IO::Compress::Adapter::Identity'=> '2.062',
            'IO::Compress::Base'    => '2.062',
            'IO::Compress::Base::Common'=> '2.062',
            'IO::Compress::Bzip2'   => '2.062',
            'IO::Compress::Deflate' => '2.062',
            'IO::Compress::Gzip'    => '2.062',
            'IO::Compress::Gzip::Constants'=> '2.062',
            'IO::Compress::RawDeflate'=> '2.062',
            'IO::Compress::Zip'     => '2.062',
            'IO::Compress::Zip::Constants'=> '2.062',
            'IO::Compress::Zlib::Constants'=> '2.062',
            'IO::Compress::Zlib::Extra'=> '2.062',
            'IO::Uncompress::Adapter::Bunzip2'=> '2.062',
            'IO::Uncompress::Adapter::Identity'=> '2.062',
            'IO::Uncompress::Adapter::Inflate'=> '2.062',
            'IO::Uncompress::AnyInflate'=> '2.062',
            'IO::Uncompress::AnyUncompress'=> '2.062',
            'IO::Uncompress::Base'  => '2.062',
            'IO::Uncompress::Bunzip2'=> '2.062',
            'IO::Uncompress::Gunzip'=> '2.062',
            'IO::Uncompress::Inflate'=> '2.062',
            'IO::Uncompress::RawInflate'=> '2.062',
            'IO::Uncompress::Unzip' => '2.062',
            'IPC::Cmd'              => '0.84',
            'IPC::Msg'              => '2.04',
            'IPC::Open3'            => '1.15',
            'IPC::Semaphore'        => '2.04',
            'IPC::SharedMem'        => '2.04',
            'IPC::SysV'             => '2.04',
            'List::Util'            => '1.31',
            'List::Util::XS'        => '1.31',
            'Math::BigFloat::Trace' => '0.36',
            'Math::BigInt::Trace'   => '0.36',
            'Module::Build'         => '0.4007',
            'Module::Build::Base'   => '0.4007',
            'Module::Build::Compat' => '0.4007',
            'Module::Build::Config' => '0.4007',
            'Module::Build::Cookbook'=> '0.4007',
            'Module::Build::Dumper' => '0.4007',
            'Module::Build::ModuleInfo'=> '0.4007',
            'Module::Build::Notes'  => '0.4007',
            'Module::Build::PPMMaker'=> '0.4007',
            'Module::Build::Platform::Default'=> '0.4007',
            'Module::Build::Platform::MacOS'=> '0.4007',
            'Module::Build::Platform::Unix'=> '0.4007',
            'Module::Build::Platform::VMS'=> '0.4007',
            'Module::Build::Platform::VOS'=> '0.4007',
            'Module::Build::Platform::Windows'=> '0.4007',
            'Module::Build::Platform::aix'=> '0.4007',
            'Module::Build::Platform::cygwin'=> '0.4007',
            'Module::Build::Platform::darwin'=> '0.4007',
            'Module::Build::Platform::os2'=> '0.4007',
            'Module::Build::PodParser'=> '0.4007',
            'Module::CoreList'      => '2.97',
            'Module::CoreList::TieHashDelta'=> '2.97',
            'Module::CoreList::Utils'=> '2.97',
            'Net::Cmd'              => '2.30',
            'Net::Config'           => '1.12',
            'Net::Domain'           => '2.22',
            'Net::FTP'              => '2.78',
            'Net::FTP::dataconn'    => '0.12',
            'Net::NNTP'             => '2.25',
            'Net::Netrc'            => '2.14',
            'Net::POP3'             => '2.30',
            'Net::SMTP'             => '2.32',
            'PerlIO'                => '1.08',
            'Pod::Functions'        => '1.08',
            'Scalar::Util'          => '1.31',
            'Socket'                => '2.011',
            'Storable'              => '2.46',
            'Time::HiRes'           => '1.9726',
            'Time::Piece'           => '1.22',
            'Time::Seconds'         => '1.22',
            'XS::APItest'           => '0.55',
            'bigint'                => '0.36',
            'bignum'                => '0.36',
            'bigrat'                => '0.36',
            'constant'              => '1.28',
            'diagnostics'           => '1.32',
            'inc::latest'           => '0.4007',
            'mro'                   => '1.13',
            'parent'                => '0.226',
            'utf8'                  => '1.13',
            'version'               => '0.9903',
        },
        removed => {
           'Module::Build::Platform::Amiga'=> 1,
           'Module::Build::Platform::EBCDIC'=> 1,
           'Module::Build::Platform::MPEiX'=> 1,
           'Module::Build::Platform::RiscOS'=> 1,
        }
    },
    5.019004 => {
        delta_from => 5.019003,
        changed => {
            'B'                     => '1.46',
            'B::Concise'            => '0.99',
            'B::Deparse'            => '1.23',
            'CPAN'                  => '2.03',
            'CPAN::Meta'            => '2.132620',
            'CPAN::Meta::Converter' => '2.132620',
            'CPAN::Meta::Feature'   => '2.132620',
            'CPAN::Meta::History'   => '2.132620',
            'CPAN::Meta::Prereqs'   => '2.132620',
            'CPAN::Meta::Requirements'=> '2.123',
            'CPAN::Meta::Spec'      => '2.132620',
            'CPAN::Meta::Validator' => '2.132620',
            'Carp'                  => '1.32',
            'Carp::Heavy'           => '1.32',
            'Config'                => '5.019004',
            'Data::Dumper'          => '2.149',
            'Devel::Peek'           => '1.14',
            'DynaLoader'            => '1.20',
            'Encode'                => '2.55',
            'Encode::Alias'         => '2.18',
            'Encode::CN::HZ'        => '2.07',
            'Encode::Encoder'       => '2.03',
            'Encode::Encoding'      => '2.07',
            'Encode::GSM0338'       => '2.05',
            'Encode::Guess'         => '2.06',
            'Encode::JP::JIS7'      => '2.05',
            'Encode::KR::2022_KR'   => '2.03',
            'Encode::MIME::Header'  => '2.15',
            'Encode::MIME::Header::ISO_2022_JP'=> '1.04',
            'Encode::Unicode'       => '2.09',
            'Encode::Unicode::UTF7' => '2.08',
            'Errno'                 => '1.20',
            'Exporter'              => '5.70',
            'Exporter::Heavy'       => '5.70',
            'ExtUtils::CBuilder'    => '0.280212',
            'ExtUtils::CBuilder::Base'=> '0.280212',
            'ExtUtils::CBuilder::Platform::Unix'=> '0.280212',
            'ExtUtils::CBuilder::Platform::VMS'=> '0.280212',
            'ExtUtils::CBuilder::Platform::Windows'=> '0.280212',
            'ExtUtils::CBuilder::Platform::Windows::BCC'=> '0.280212',
            'ExtUtils::CBuilder::Platform::Windows::GCC'=> '0.280212',
            'ExtUtils::CBuilder::Platform::Windows::MSVC'=> '0.280212',
            'ExtUtils::CBuilder::Platform::aix'=> '0.280212',
            'ExtUtils::CBuilder::Platform::cygwin'=> '0.280212',
            'ExtUtils::CBuilder::Platform::darwin'=> '0.280212',
            'ExtUtils::CBuilder::Platform::dec_osf'=> '0.280212',
            'ExtUtils::CBuilder::Platform::os2'=> '0.280212',
            'ExtUtils::Command'     => '1.18',
            'ExtUtils::Command::MM' => '6.76',
            'ExtUtils::Liblist'     => '6.76',
            'ExtUtils::Liblist::Kid'=> '6.76',
            'ExtUtils::MM'          => '6.76',
            'ExtUtils::MM_AIX'      => '6.76',
            'ExtUtils::MM_Any'      => '6.76',
            'ExtUtils::MM_BeOS'     => '6.76',
            'ExtUtils::MM_Cygwin'   => '6.76',
            'ExtUtils::MM_DOS'      => '6.76',
            'ExtUtils::MM_Darwin'   => '6.76',
            'ExtUtils::MM_MacOS'    => '6.76',
            'ExtUtils::MM_NW5'      => '6.76',
            'ExtUtils::MM_OS2'      => '6.76',
            'ExtUtils::MM_QNX'      => '6.76',
            'ExtUtils::MM_UWIN'     => '6.76',
            'ExtUtils::MM_Unix'     => '6.76',
            'ExtUtils::MM_VMS'      => '6.76',
            'ExtUtils::MM_VOS'      => '6.76',
            'ExtUtils::MM_Win32'    => '6.76',
            'ExtUtils::MM_Win95'    => '6.76',
            'ExtUtils::MY'          => '6.76',
            'ExtUtils::MakeMaker'   => '6.76',
            'ExtUtils::MakeMaker::Config'=> '6.76',
            'ExtUtils::Mkbootstrap' => '6.76',
            'ExtUtils::Mksymlists'  => '6.76',
            'ExtUtils::ParseXS'     => '3.23',
            'ExtUtils::ParseXS::Constants'=> '3.23',
            'ExtUtils::ParseXS::CountLines'=> '3.23',
            'ExtUtils::ParseXS::Eval'=> '3.23',
            'ExtUtils::ParseXS::Utilities'=> '3.23',
            'ExtUtils::Typemaps'    => '3.23',
            'ExtUtils::Typemaps::Cmd'=> '3.23',
            'ExtUtils::Typemaps::InputMap'=> '3.23',
            'ExtUtils::Typemaps::OutputMap'=> '3.23',
            'ExtUtils::Typemaps::Type'=> '3.23',
            'ExtUtils::testlib'     => '6.76',
            'Fatal'                 => '2.21',
            'File::Copy'            => '2.28',
            'File::Find'            => '1.25',
            'File::Glob'            => '1.21',
            'FileCache'             => '1.09',
            'HTTP::Tiny'            => '0.035',
            'Hash::Util::FieldHash' => '1.13',
            'I18N::LangTags'        => '0.40',
            'IO'                    => '1.29',
            'IO::Socket'            => '1.37',
            'IPC::Open3'            => '1.16',
            'JSON::PP'              => '2.27202_01',
            'List::Util'            => '1.32',
            'List::Util::XS'        => '1.32',
            'Locale::Codes'         => '3.27',
            'Locale::Codes::Constants'=> '3.27',
            'Locale::Codes::Country'=> '3.27',
            'Locale::Codes::Country_Codes'=> '3.27',
            'Locale::Codes::Country_Retired'=> '3.27',
            'Locale::Codes::Currency'=> '3.27',
            'Locale::Codes::Currency_Codes'=> '3.27',
            'Locale::Codes::Currency_Retired'=> '3.27',
            'Locale::Codes::LangExt'=> '3.27',
            'Locale::Codes::LangExt_Codes'=> '3.27',
            'Locale::Codes::LangExt_Retired'=> '3.27',
            'Locale::Codes::LangFam'=> '3.27',
            'Locale::Codes::LangFam_Codes'=> '3.27',
            'Locale::Codes::LangFam_Retired'=> '3.27',
            'Locale::Codes::LangVar'=> '3.27',
            'Locale::Codes::LangVar_Codes'=> '3.27',
            'Locale::Codes::LangVar_Retired'=> '3.27',
            'Locale::Codes::Language'=> '3.27',
            'Locale::Codes::Language_Codes'=> '3.27',
            'Locale::Codes::Language_Retired'=> '3.27',
            'Locale::Codes::Script' => '3.27',
            'Locale::Codes::Script_Codes'=> '3.27',
            'Locale::Codes::Script_Retired'=> '3.27',
            'Locale::Country'       => '3.27',
            'Locale::Currency'      => '3.27',
            'Locale::Language'      => '3.27',
            'Locale::Script'        => '3.27',
            'Math::BigFloat'        => '1.9991',
            'Math::BigInt'          => '1.9993',
            'Math::BigInt::FastCalc'=> '0.31',
            'Module::CoreList'      => '2.99',
            'Module::CoreList::TieHashDelta'=> '2.99',
            'Module::CoreList::Utils'=> '2.99',
            'Module::Load::Conditional'=> '0.58',
            'Module::Metadata'      => '1.000018',
            'Opcode'                => '1.26',
            'POSIX'                 => '1.35',
            'Parse::CPAN::Meta'     => '1.4407',
            'Perl::OSType'          => '1.005',
            'Pod::Html'             => '1.21',
            'Scalar::Util'          => '1.32',
            'Socket'                => '2.012',
            'Storable'              => '2.47',
            'Term::ReadLine'        => '1.14',
            'Test::Builder'         => '0.98_06',
            'Test::Builder::Module' => '0.98_06',
            'Test::More'            => '0.98_06',
            'Test::Simple'          => '0.98_06',
            'Time::Piece'           => '1.23',
            'Time::Seconds'         => '1.23',
            'Unicode::Collate'      => '0.99',
            'Unicode::UCD'          => '0.54',
            'XS::APItest'           => '0.56',
            'XS::Typemap'           => '0.11',
            '_charnames'            => '1.39',
            'autodie'               => '2.21',
            'autodie::exception'    => '2.21',
            'autodie::exception::system'=> '2.21',
            'autodie::hints'        => '2.21',
            'autodie::skip'         => '2.21',
            'charnames'             => '1.39',
            'diagnostics'           => '1.33',
            'mro'                   => '1.14',
            'parent'                => '0.228',
            'perlfaq'               => '5.0150044',
            're'                    => '0.26',
            'version'               => '0.9904',
            'warnings'              => '1.19',
        },
        removed => {
        }
    },
    5.019005 => {
        delta_from => 5.019004,
        changed => {
            'App::Prove'            => '3.29',
            'App::Prove::State'     => '3.29',
            'App::Prove::State::Result'=> '3.29',
            'App::Prove::State::Result::Test'=> '3.29',
            'CPAN::Meta'            => '2.132830',
            'CPAN::Meta::Converter' => '2.132830',
            'CPAN::Meta::Feature'   => '2.132830',
            'CPAN::Meta::History'   => '2.132830',
            'CPAN::Meta::Prereqs'   => '2.132830',
            'CPAN::Meta::Requirements'=> '2.125',
            'CPAN::Meta::Spec'      => '2.132830',
            'CPAN::Meta::Validator' => '2.132830',
            'CPAN::Meta::YAML'      => '0.010',
            'Config'                => '5.019005',
            'Cwd'                   => '3.45',
            'ExtUtils::Command::MM' => '6.80',
            'ExtUtils::Install'     => '1.61',
            'ExtUtils::Liblist'     => '6.80',
            'ExtUtils::Liblist::Kid'=> '6.80',
            'ExtUtils::MM'          => '6.80',
            'ExtUtils::MM_AIX'      => '6.80',
            'ExtUtils::MM_Any'      => '6.80',
            'ExtUtils::MM_BeOS'     => '6.80',
            'ExtUtils::MM_Cygwin'   => '6.80',
            'ExtUtils::MM_DOS'      => '6.80',
            'ExtUtils::MM_Darwin'   => '6.80',
            'ExtUtils::MM_MacOS'    => '6.80',
            'ExtUtils::MM_NW5'      => '6.80',
            'ExtUtils::MM_OS2'      => '6.80',
            'ExtUtils::MM_QNX'      => '6.80',
            'ExtUtils::MM_UWIN'     => '6.80',
            'ExtUtils::MM_Unix'     => '6.80',
            'ExtUtils::MM_VMS'      => '6.80',
            'ExtUtils::MM_VOS'      => '6.80',
            'ExtUtils::MM_Win32'    => '6.80',
            'ExtUtils::MM_Win95'    => '6.80',
            'ExtUtils::MY'          => '6.80',
            'ExtUtils::MakeMaker'   => '6.80',
            'ExtUtils::MakeMaker::Config'=> '6.80',
            'ExtUtils::Mkbootstrap' => '6.80',
            'ExtUtils::Mksymlists'  => '6.80',
            'ExtUtils::testlib'     => '6.80',
            'Fatal'                 => '2.22',
            'File::Fetch'           => '0.44',
            'File::Glob'            => '1.22',
            'File::Spec'            => '3.45',
            'File::Spec::Cygwin'    => '3.45',
            'File::Spec::Epoc'      => '3.45',
            'File::Spec::Functions' => '3.45',
            'File::Spec::Mac'       => '3.45',
            'File::Spec::OS2'       => '3.45',
            'File::Spec::Unix'      => '3.45',
            'File::Spec::VMS'       => '3.45',
            'File::Spec::Win32'     => '3.45',
            'File::Temp'            => '0.2304',
            'Getopt::Long'          => '2.42',
            'HTTP::Tiny'            => '0.036',
            'IPC::Cmd'              => '0.84_01',
            'JSON::PP'              => '2.27203',
            'List::Util'            => '1.35',
            'List::Util::XS'        => '1.35',
            'Module::CoreList'      => '3.00',
            'Module::CoreList::TieHashDelta'=> '3.00',
            'Module::CoreList::Utils'=> '3.00',
            'Module::Metadata'      => '1.000019',
            'Parse::CPAN::Meta'     => '1.4409',
            'Perl::OSType'          => '1.006',
            'PerlIO::scalar'        => '0.17',
            'Pod::Man'              => '2.28',
            'Pod::Text'             => '3.18',
            'Pod::Text::Termcap'    => '2.08',
            'Scalar::Util'          => '1.35',
            'TAP::Base'             => '3.29',
            'TAP::Formatter::Base'  => '3.29',
            'TAP::Formatter::Color' => '3.29',
            'TAP::Formatter::Console'=> '3.29',
            'TAP::Formatter::Console::ParallelSession'=> '3.29',
            'TAP::Formatter::Console::Session'=> '3.29',
            'TAP::Formatter::File'  => '3.29',
            'TAP::Formatter::File::Session'=> '3.29',
            'TAP::Formatter::Session'=> '3.29',
            'TAP::Harness'          => '3.29',
            'TAP::Harness::Env'     => '3.29',
            'TAP::Object'           => '3.29',
            'TAP::Parser'           => '3.29',
            'TAP::Parser::Aggregator'=> '3.29',
            'TAP::Parser::Grammar'  => '3.29',
            'TAP::Parser::Iterator' => '3.29',
            'TAP::Parser::Iterator::Array'=> '3.29',
            'TAP::Parser::Iterator::Process'=> '3.29',
            'TAP::Parser::Iterator::Stream'=> '3.29',
            'TAP::Parser::IteratorFactory'=> '3.29',
            'TAP::Parser::Multiplexer'=> '3.29',
            'TAP::Parser::Result'   => '3.29',
            'TAP::Parser::Result::Bailout'=> '3.29',
            'TAP::Parser::Result::Comment'=> '3.29',
            'TAP::Parser::Result::Plan'=> '3.29',
            'TAP::Parser::Result::Pragma'=> '3.29',
            'TAP::Parser::Result::Test'=> '3.29',
            'TAP::Parser::Result::Unknown'=> '3.29',
            'TAP::Parser::Result::Version'=> '3.29',
            'TAP::Parser::Result::YAML'=> '3.29',
            'TAP::Parser::ResultFactory'=> '3.29',
            'TAP::Parser::Scheduler'=> '3.29',
            'TAP::Parser::Scheduler::Job'=> '3.29',
            'TAP::Parser::Scheduler::Spinner'=> '3.29',
            'TAP::Parser::Source'   => '3.29',
            'TAP::Parser::SourceHandler'=> '3.29',
            'TAP::Parser::SourceHandler::Executable'=> '3.29',
            'TAP::Parser::SourceHandler::File'=> '3.29',
            'TAP::Parser::SourceHandler::Handle'=> '3.29',
            'TAP::Parser::SourceHandler::Perl'=> '3.29',
            'TAP::Parser::SourceHandler::RawTAP'=> '3.29',
            'TAP::Parser::YAMLish::Reader'=> '3.29',
            'TAP::Parser::YAMLish::Writer'=> '3.29',
            'Test::Builder'         => '0.99',
            'Test::Builder::Module' => '0.99',
            'Test::Builder::Tester' => '1.23_002',
            'Test::Builder::Tester::Color'=> '1.23_002',
            'Test::Harness'         => '3.29',
            'Test::More'            => '0.99',
            'Test::Simple'          => '0.99',
            'Unicode'               => '6.3.0',
            'Unicode::Normalize'    => '1.17',
            'Unicode::UCD'          => '0.55',
            'attributes'            => '0.22',
            'autodie'               => '2.22',
            'autodie::exception'    => '2.22',
            'autodie::exception::system'=> '2.22',
            'autodie::hints'        => '2.22',
            'autodie::skip'         => '2.22',
            'feature'               => '1.34',
            'threads'               => '1.89',
            'warnings'              => '1.20',
        },
        removed => {
            'TAP::Parser::Utils'    => 1,
        }
    },
    5.019006 => {
        delta_from => 5.019005,
        changed => {
            'App::Prove'            => '3.30',
            'App::Prove::State'     => '3.30',
            'App::Prove::State::Result'=> '3.30',
            'App::Prove::State::Result::Test'=> '3.30',
            'Archive::Tar'          => '1.96',
            'Archive::Tar::Constant'=> '1.96',
            'Archive::Tar::File'    => '1.96',
            'AutoLoader'            => '5.74',
            'B'                     => '1.47',
            'B::Concise'            => '0.991',
            'B::Debug'              => '1.19',
            'B::Deparse'            => '1.24',
            'Benchmark'             => '1.18',
            'Compress::Raw::Bzip2'  => '2.063',
            'Compress::Raw::Zlib'   => '2.063',
            'Compress::Zlib'        => '2.063',
            'Config'                => '5.019006',
            'DB_File'               => '1.831',
            'Devel::Peek'           => '1.15',
            'DynaLoader'            => '1.21',
            'Errno'                 => '1.20_01',
            'ExtUtils::Command::MM' => '6.82',
            'ExtUtils::Liblist'     => '6.82',
            'ExtUtils::Liblist::Kid'=> '6.82',
            'ExtUtils::MM'          => '6.82',
            'ExtUtils::MM_AIX'      => '6.82',
            'ExtUtils::MM_Any'      => '6.82',
            'ExtUtils::MM_BeOS'     => '6.82',
            'ExtUtils::MM_Cygwin'   => '6.82',
            'ExtUtils::MM_DOS'      => '6.82',
            'ExtUtils::MM_Darwin'   => '6.82',
            'ExtUtils::MM_MacOS'    => '6.82',
            'ExtUtils::MM_NW5'      => '6.82',
            'ExtUtils::MM_OS2'      => '6.82',
            'ExtUtils::MM_QNX'      => '6.82',
            'ExtUtils::MM_UWIN'     => '6.82',
            'ExtUtils::MM_Unix'     => '6.82',
            'ExtUtils::MM_VMS'      => '6.82',
            'ExtUtils::MM_VOS'      => '6.82',
            'ExtUtils::MM_Win32'    => '6.82',
            'ExtUtils::MM_Win95'    => '6.82',
            'ExtUtils::MY'          => '6.82',
            'ExtUtils::MakeMaker'   => '6.82',
            'ExtUtils::MakeMaker::Config'=> '6.82',
            'ExtUtils::Mkbootstrap' => '6.82',
            'ExtUtils::Mksymlists'  => '6.82',
            'ExtUtils::testlib'     => '6.82',
            'File::DosGlob'         => '1.12',
            'File::Find'            => '1.26',
            'File::Glob'            => '1.23',
            'HTTP::Tiny'            => '0.038',
            'IO'                    => '1.30',
            'IO::Compress::Adapter::Bzip2'=> '2.063',
            'IO::Compress::Adapter::Deflate'=> '2.063',
            'IO::Compress::Adapter::Identity'=> '2.063',
            'IO::Compress::Base'    => '2.063',
            'IO::Compress::Base::Common'=> '2.063',
            'IO::Compress::Bzip2'   => '2.063',
            'IO::Compress::Deflate' => '2.063',
            'IO::Compress::Gzip'    => '2.063',
            'IO::Compress::Gzip::Constants'=> '2.063',
            'IO::Compress::RawDeflate'=> '2.063',
            'IO::Compress::Zip'     => '2.063',
            'IO::Compress::Zip::Constants'=> '2.063',
            'IO::Compress::Zlib::Constants'=> '2.063',
            'IO::Compress::Zlib::Extra'=> '2.063',
            'IO::Select'            => '1.22',
            'IO::Uncompress::Adapter::Bunzip2'=> '2.063',
            'IO::Uncompress::Adapter::Identity'=> '2.063',
            'IO::Uncompress::Adapter::Inflate'=> '2.063',
            'IO::Uncompress::AnyInflate'=> '2.063',
            'IO::Uncompress::AnyUncompress'=> '2.063',
            'IO::Uncompress::Base'  => '2.063',
            'IO::Uncompress::Bunzip2'=> '2.063',
            'IO::Uncompress::Gunzip'=> '2.063',
            'IO::Uncompress::Inflate'=> '2.063',
            'IO::Uncompress::RawInflate'=> '2.063',
            'IO::Uncompress::Unzip' => '2.063',
            'IPC::Cmd'              => '0.90',
            'Locale::Maketext'      => '1.25',
            'Module::Build'         => '0.4202',
            'Module::Build::Base'   => '0.4202',
            'Module::Build::Compat' => '0.4202',
            'Module::Build::Config' => '0.4202',
            'Module::Build::Cookbook'=> '0.4202',
            'Module::Build::Dumper' => '0.4202',
            'Module::Build::ModuleInfo'=> '0.4202',
            'Module::Build::Notes'  => '0.4202',
            'Module::Build::PPMMaker'=> '0.4202',
            'Module::Build::Platform::Default'=> '0.4202',
            'Module::Build::Platform::MacOS'=> '0.4202',
            'Module::Build::Platform::Unix'=> '0.4202',
            'Module::Build::Platform::VMS'=> '0.4202',
            'Module::Build::Platform::VOS'=> '0.4202',
            'Module::Build::Platform::Windows'=> '0.4202',
            'Module::Build::Platform::aix'=> '0.4202',
            'Module::Build::Platform::cygwin'=> '0.4202',
            'Module::Build::Platform::darwin'=> '0.4202',
            'Module::Build::Platform::os2'=> '0.4202',
            'Module::Build::PodParser'=> '0.4202',
            'Module::CoreList'      => '3.01',
            'Module::CoreList::TieHashDelta'=> '3.01',
            'Module::CoreList::Utils'=> '3.01',
            'Opcode'                => '1.27',
            'POSIX'                 => '1.36',
            'Package::Constants'    => '0.04',
            'PerlIO::scalar'        => '0.18',
            'PerlIO::via'           => '0.13',
            'SDBM_File'             => '1.10',
            'Socket'                => '2.013',
            'TAP::Base'             => '3.30',
            'TAP::Formatter::Base'  => '3.30',
            'TAP::Formatter::Color' => '3.30',
            'TAP::Formatter::Console'=> '3.30',
            'TAP::Formatter::Console::ParallelSession'=> '3.30',
            'TAP::Formatter::Console::Session'=> '3.30',
            'TAP::Formatter::File'  => '3.30',
            'TAP::Formatter::File::Session'=> '3.30',
            'TAP::Formatter::Session'=> '3.30',
            'TAP::Harness'          => '3.30',
            'TAP::Harness::Env'     => '3.30',
            'TAP::Object'           => '3.30',
            'TAP::Parser'           => '3.30',
            'TAP::Parser::Aggregator'=> '3.30',
            'TAP::Parser::Grammar'  => '3.30',
            'TAP::Parser::Iterator' => '3.30',
            'TAP::Parser::Iterator::Array'=> '3.30',
            'TAP::Parser::Iterator::Process'=> '3.30',
            'TAP::Parser::Iterator::Stream'=> '3.30',
            'TAP::Parser::IteratorFactory'=> '3.30',
            'TAP::Parser::Multiplexer'=> '3.30',
            'TAP::Parser::Result'   => '3.30',
            'TAP::Parser::Result::Bailout'=> '3.30',
            'TAP::Parser::Result::Comment'=> '3.30',
            'TAP::Parser::Result::Plan'=> '3.30',
            'TAP::Parser::Result::Pragma'=> '3.30',
            'TAP::Parser::Result::Test'=> '3.30',
            'TAP::Parser::Result::Unknown'=> '3.30',
            'TAP::Parser::Result::Version'=> '3.30',
            'TAP::Parser::Result::YAML'=> '3.30',
            'TAP::Parser::ResultFactory'=> '3.30',
            'TAP::Parser::Scheduler'=> '3.30',
            'TAP::Parser::Scheduler::Job'=> '3.30',
            'TAP::Parser::Scheduler::Spinner'=> '3.30',
            'TAP::Parser::Source'   => '3.30',
            'TAP::Parser::SourceHandler'=> '3.30',
            'TAP::Parser::SourceHandler::Executable'=> '3.30',
            'TAP::Parser::SourceHandler::File'=> '3.30',
            'TAP::Parser::SourceHandler::Handle'=> '3.30',
            'TAP::Parser::SourceHandler::Perl'=> '3.30',
            'TAP::Parser::SourceHandler::RawTAP'=> '3.30',
            'TAP::Parser::YAMLish::Reader'=> '3.30',
            'TAP::Parser::YAMLish::Writer'=> '3.30',
            'Term::Cap'             => '1.15',
            'Test::Builder'         => '1.001002',
            'Test::Builder::Module' => '1.001002',
            'Test::Harness'         => '3.30',
            'Test::More'            => '1.001002',
            'Test::Simple'          => '1.001002',
            'Tie::StdHandle'        => '4.4',
            'Unicode::Collate'      => '1.02',
            'Unicode::Collate::CJK::Korean'=> '1.02',
            'Unicode::Collate::Locale'=> '1.02',
            'XS::APItest'           => '0.57',
            'XS::Typemap'           => '0.12',
            'arybase'               => '0.07',
            'bignum'                => '0.37',
            'constant'              => '1.29',
            'fields'                => '2.17',
            'inc::latest'           => '0.4202',
            'threads'               => '1.90',
            'threads::shared'       => '1.45',
        },
        removed => {
        }
    },
    5.019007 => {
        delta_from => 5.019006,
        changed => {
            'CGI'                   => '3.64',
            'CGI::Apache'           => '1.02',
            'CGI::Carp'             => '3.64',
            'CGI::Cookie'           => '1.31',
            'CGI::Fast'             => '1.10',
            'CGI::Pretty'           => '3.64',
            'CGI::Push'             => '1.06',
            'CGI::Switch'           => '1.02',
            'CGI::Util'             => '3.64',
            'CPAN::Meta'            => '2.133380',
            'CPAN::Meta::Converter' => '2.133380',
            'CPAN::Meta::Feature'   => '2.133380',
            'CPAN::Meta::History'   => '2.133380',
            'CPAN::Meta::Prereqs'   => '2.133380',
            'CPAN::Meta::Spec'      => '2.133380',
            'CPAN::Meta::Validator' => '2.133380',
            'Config'                => '5.019007',
            'Data::Dumper'          => '2.150',
            'DynaLoader'            => '1.22',
            'ExtUtils::Command::MM' => '6.84',
            'ExtUtils::Liblist'     => '6.84',
            'ExtUtils::Liblist::Kid'=> '6.84',
            'ExtUtils::MM'          => '6.84',
            'ExtUtils::MM_AIX'      => '6.84',
            'ExtUtils::MM_Any'      => '6.84',
            'ExtUtils::MM_BeOS'     => '6.84',
            'ExtUtils::MM_Cygwin'   => '6.84',
            'ExtUtils::MM_DOS'      => '6.84',
            'ExtUtils::MM_Darwin'   => '6.84',
            'ExtUtils::MM_MacOS'    => '6.84',
            'ExtUtils::MM_NW5'      => '6.84',
            'ExtUtils::MM_OS2'      => '6.84',
            'ExtUtils::MM_QNX'      => '6.84',
            'ExtUtils::MM_UWIN'     => '6.84',
            'ExtUtils::MM_Unix'     => '6.84',
            'ExtUtils::MM_VMS'      => '6.84',
            'ExtUtils::MM_VOS'      => '6.84',
            'ExtUtils::MM_Win32'    => '6.84',
            'ExtUtils::MM_Win95'    => '6.84',
            'ExtUtils::MY'          => '6.84',
            'ExtUtils::MakeMaker'   => '6.84',
            'ExtUtils::MakeMaker::Config'=> '6.84',
            'ExtUtils::Mkbootstrap' => '6.84',
            'ExtUtils::Mksymlists'  => '6.84',
            'ExtUtils::testlib'     => '6.84',
            'File::Fetch'           => '0.46',
            'HTTP::Tiny'            => '0.039',
            'Locale::Codes'         => '3.28',
            'Locale::Codes::Constants'=> '3.28',
            'Locale::Codes::Country'=> '3.28',
            'Locale::Codes::Country_Codes'=> '3.28',
            'Locale::Codes::Country_Retired'=> '3.28',
            'Locale::Codes::Currency'=> '3.28',
            'Locale::Codes::Currency_Codes'=> '3.28',
            'Locale::Codes::Currency_Retired'=> '3.28',
            'Locale::Codes::LangExt'=> '3.28',
            'Locale::Codes::LangExt_Codes'=> '3.28',
            'Locale::Codes::LangExt_Retired'=> '3.28',
            'Locale::Codes::LangFam'=> '3.28',
            'Locale::Codes::LangFam_Codes'=> '3.28',
            'Locale::Codes::LangFam_Retired'=> '3.28',
            'Locale::Codes::LangVar'=> '3.28',
            'Locale::Codes::LangVar_Codes'=> '3.28',
            'Locale::Codes::LangVar_Retired'=> '3.28',
            'Locale::Codes::Language'=> '3.28',
            'Locale::Codes::Language_Codes'=> '3.28',
            'Locale::Codes::Language_Retired'=> '3.28',
            'Locale::Codes::Script' => '3.28',
            'Locale::Codes::Script_Codes'=> '3.28',
            'Locale::Codes::Script_Retired'=> '3.28',
            'Locale::Country'       => '3.28',
            'Locale::Currency'      => '3.28',
            'Locale::Language'      => '3.28',
            'Locale::Script'        => '3.28',
            'Module::Build'         => '0.4203',
            'Module::Build::Base'   => '0.4203',
            'Module::Build::Compat' => '0.4203',
            'Module::Build::Config' => '0.4203',
            'Module::Build::Cookbook'=> '0.4203',
            'Module::Build::Dumper' => '0.4203',
            'Module::Build::ModuleInfo'=> '0.4203',
            'Module::Build::Notes'  => '0.4203',
            'Module::Build::PPMMaker'=> '0.4203',
            'Module::Build::Platform::Default'=> '0.4203',
            'Module::Build::Platform::MacOS'=> '0.4203',
            'Module::Build::Platform::Unix'=> '0.4203',
            'Module::Build::Platform::VMS'=> '0.4203',
            'Module::Build::Platform::VOS'=> '0.4203',
            'Module::Build::Platform::Windows'=> '0.4203',
            'Module::Build::Platform::aix'=> '0.4203',
            'Module::Build::Platform::cygwin'=> '0.4203',
            'Module::Build::Platform::darwin'=> '0.4203',
            'Module::Build::Platform::os2'=> '0.4203',
            'Module::Build::PodParser'=> '0.4203',
            'Module::CoreList'      => '3.02',
            'Module::CoreList::TieHashDelta'=> '3.02',
            'Module::CoreList::Utils'=> '3.02',
            'POSIX'                 => '1.37',
            'PerlIO::encoding'      => '0.17',
            'PerlIO::via'           => '0.14',
            'SDBM_File'             => '1.11',
            'Storable'              => '2.48',
            'Time::Piece'           => '1.24',
            'Time::Seconds'         => '1.24',
            'Unicode::Collate'      => '1.04',
            'Win32'                 => '0.48',
            'XS::APItest'           => '0.58',
            'base'                  => '2.20',
            'constant'              => '1.30',
            'inc::latest'           => '0.4203',
            'threads'               => '1.91',
        },
        removed => {
        }
    },
    5.019008 => {
        delta_from => 5.019007,
        changed => {
            'Config'                => '5.019008',
            'DynaLoader'            => '1.24',
            'Encode'                => '2.57',
            'Errno'                 => '1.20_02',
            'ExtUtils::CBuilder'    => '0.280213',
            'ExtUtils::CBuilder::Base'=> '0.280213',
            'ExtUtils::CBuilder::Platform::Unix'=> '0.280213',
            'ExtUtils::CBuilder::Platform::VMS'=> '0.280213',
            'ExtUtils::CBuilder::Platform::Windows'=> '0.280213',
            'ExtUtils::CBuilder::Platform::Windows::BCC'=> '0.280213',
            'ExtUtils::CBuilder::Platform::Windows::GCC'=> '0.280213',
            'ExtUtils::CBuilder::Platform::Windows::MSVC'=> '0.280213',
            'ExtUtils::CBuilder::Platform::aix'=> '0.280213',
            'ExtUtils::CBuilder::Platform::cygwin'=> '0.280213',
            'ExtUtils::CBuilder::Platform::darwin'=> '0.280213',
            'ExtUtils::CBuilder::Platform::dec_osf'=> '0.280213',
            'ExtUtils::CBuilder::Platform::os2'=> '0.280213',
            'ExtUtils::Command::MM' => '6.86',
            'ExtUtils::Liblist'     => '6.86',
            'ExtUtils::Liblist::Kid'=> '6.86',
            'ExtUtils::MM'          => '6.86',
            'ExtUtils::MM_AIX'      => '6.86',
            'ExtUtils::MM_Any'      => '6.86',
            'ExtUtils::MM_BeOS'     => '6.86',
            'ExtUtils::MM_Cygwin'   => '6.86',
            'ExtUtils::MM_DOS'      => '6.86',
            'ExtUtils::MM_Darwin'   => '6.86',
            'ExtUtils::MM_MacOS'    => '6.86',
            'ExtUtils::MM_NW5'      => '6.86',
            'ExtUtils::MM_OS2'      => '6.86',
            'ExtUtils::MM_QNX'      => '6.86',
            'ExtUtils::MM_UWIN'     => '6.86',
            'ExtUtils::MM_Unix'     => '6.86',
            'ExtUtils::MM_VMS'      => '6.86',
            'ExtUtils::MM_VOS'      => '6.86',
            'ExtUtils::MM_Win32'    => '6.86',
            'ExtUtils::MM_Win95'    => '6.86',
            'ExtUtils::MY'          => '6.86',
            'ExtUtils::MakeMaker'   => '6.86',
            'ExtUtils::MakeMaker::Config'=> '6.86',
            'ExtUtils::Mkbootstrap' => '6.86',
            'ExtUtils::Mksymlists'  => '6.86',
            'ExtUtils::testlib'     => '6.86',
            'File::Copy'            => '2.29',
            'Hash::Util::FieldHash' => '1.14',
            'IO::Socket::IP'        => '0.26',
            'IO::Socket::UNIX'      => '1.26',
            'List::Util'            => '1.36',
            'List::Util::XS'        => '1.36',
            'Module::Build'         => '0.4204',
            'Module::Build::Base'   => '0.4204',
            'Module::Build::Compat' => '0.4204',
            'Module::Build::Config' => '0.4204',
            'Module::Build::Cookbook'=> '0.4204',
            'Module::Build::Dumper' => '0.4204',
            'Module::Build::ModuleInfo'=> '0.4204',
            'Module::Build::Notes'  => '0.4204',
            'Module::Build::PPMMaker'=> '0.4204',
            'Module::Build::Platform::Default'=> '0.4204',
            'Module::Build::Platform::MacOS'=> '0.4204',
            'Module::Build::Platform::Unix'=> '0.4204',
            'Module::Build::Platform::VMS'=> '0.4204',
            'Module::Build::Platform::VOS'=> '0.4204',
            'Module::Build::Platform::Windows'=> '0.4204',
            'Module::Build::Platform::aix'=> '0.4204',
            'Module::Build::Platform::cygwin'=> '0.4204',
            'Module::Build::Platform::darwin'=> '0.4204',
            'Module::Build::Platform::os2'=> '0.4204',
            'Module::Build::PodParser'=> '0.4204',
            'Module::CoreList'      => '3.04',
            'Module::CoreList::TieHashDelta'=> '3.04',
            'Module::CoreList::Utils'=> '3.04',
            'Module::Load'          => '0.28',
            'Module::Load::Conditional'=> '0.60',
            'Net::Config'           => '1.13',
            'Net::FTP::A'           => '1.19',
            'POSIX'                 => '1.38_01',
            'Perl::OSType'          => '1.007',
            'PerlIO::encoding'      => '0.18',
            'Pod::Perldoc'          => '3.21',
            'Pod::Perldoc::BaseTo'  => '3.21',
            'Pod::Perldoc::GetOptsOO'=> '3.21',
            'Pod::Perldoc::ToANSI'  => '3.21',
            'Pod::Perldoc::ToChecker'=> '3.21',
            'Pod::Perldoc::ToMan'   => '3.21',
            'Pod::Perldoc::ToNroff' => '3.21',
            'Pod::Perldoc::ToPod'   => '3.21',
            'Pod::Perldoc::ToRtf'   => '3.21',
            'Pod::Perldoc::ToTerm'  => '3.21',
            'Pod::Perldoc::ToText'  => '3.21',
            'Pod::Perldoc::ToTk'    => '3.21',
            'Pod::Perldoc::ToXml'   => '3.21',
            'Scalar::Util'          => '1.36',
            'Time::Piece'           => '1.27',
            'Time::Seconds'         => '1.27',
            'Unicode::UCD'          => '0.57',
            'XS::APItest'           => '0.59',
            'XSLoader'              => '0.17',
            'base'                  => '2.21',
            'constant'              => '1.31',
            'inc::latest'           => '0.4204',
            'threads::shared'       => '1.46',
            'version'               => '0.9907',
            'version::regex'        => '0.9907',
            'version::vpp'          => '0.9907',
            'warnings'              => '1.21',
        },
        removed => {
        }
    },
    5.019009 => {
        delta_from => 5.019008,
        changed => {
            'B'                     => '1.48',
            'B::Concise'            => '0.992',
            'B::Deparse'            => '1.25',
            'CGI'                   => '3.65',
            'CPAN::Meta::YAML'      => '0.011',
            'Compress::Raw::Bzip2'  => '2.064',
            'Compress::Raw::Zlib'   => '2.065',
            'Compress::Zlib'        => '2.064',
            'Config'                => '5.019009',
            'Config::Perl::V'       => '0.20',
            'Cwd'                   => '3.47',
            'Devel::Peek'           => '1.16',
            'Digest::SHA'           => '5.87',
            'DynaLoader'            => '1.25',
            'English'               => '1.09',
            'ExtUtils::CBuilder'    => '0.280216',
            'ExtUtils::CBuilder::Base'=> '0.280216',
            'ExtUtils::CBuilder::Platform::Unix'=> '0.280216',
            'ExtUtils::CBuilder::Platform::VMS'=> '0.280216',
            'ExtUtils::CBuilder::Platform::Windows'=> '0.280216',
            'ExtUtils::CBuilder::Platform::Windows::BCC'=> '0.280216',
            'ExtUtils::CBuilder::Platform::Windows::GCC'=> '0.280216',
            'ExtUtils::CBuilder::Platform::Windows::MSVC'=> '0.280216',
            'ExtUtils::CBuilder::Platform::aix'=> '0.280216',
            'ExtUtils::CBuilder::Platform::android'=> '0.280216',
            'ExtUtils::CBuilder::Platform::cygwin'=> '0.280216',
            'ExtUtils::CBuilder::Platform::darwin'=> '0.280216',
            'ExtUtils::CBuilder::Platform::dec_osf'=> '0.280216',
            'ExtUtils::CBuilder::Platform::os2'=> '0.280216',
            'ExtUtils::Command::MM' => '6.88',
            'ExtUtils::Embed'       => '1.32',
            'ExtUtils::Install'     => '1.62',
            'ExtUtils::Installed'   => '1.999004',
            'ExtUtils::Liblist'     => '6.88',
            'ExtUtils::Liblist::Kid'=> '6.88',
            'ExtUtils::MM'          => '6.88',
            'ExtUtils::MM_AIX'      => '6.88',
            'ExtUtils::MM_Any'      => '6.88',
            'ExtUtils::MM_BeOS'     => '6.88',
            'ExtUtils::MM_Cygwin'   => '6.88',
            'ExtUtils::MM_DOS'      => '6.88',
            'ExtUtils::MM_Darwin'   => '6.88',
            'ExtUtils::MM_MacOS'    => '6.88',
            'ExtUtils::MM_NW5'      => '6.88',
            'ExtUtils::MM_OS2'      => '6.88',
            'ExtUtils::MM_QNX'      => '6.88',
            'ExtUtils::MM_UWIN'     => '6.88',
            'ExtUtils::MM_Unix'     => '6.88',
            'ExtUtils::MM_VMS'      => '6.88',
            'ExtUtils::MM_VOS'      => '6.88',
            'ExtUtils::MM_Win32'    => '6.88',
            'ExtUtils::MM_Win95'    => '6.88',
            'ExtUtils::MY'          => '6.88',
            'ExtUtils::MakeMaker'   => '6.88',
            'ExtUtils::MakeMaker::Config'=> '6.88',
            'ExtUtils::Mkbootstrap' => '6.88',
            'ExtUtils::Mksymlists'  => '6.88',
            'ExtUtils::Packlist'    => '1.47',
            'ExtUtils::testlib'     => '6.88',
            'Fatal'                 => '2.23',
            'File::Fetch'           => '0.48',
            'File::Spec'            => '3.47',
            'File::Spec::Cygwin'    => '3.47',
            'File::Spec::Epoc'      => '3.47',
            'File::Spec::Functions' => '3.47',
            'File::Spec::Mac'       => '3.47',
            'File::Spec::OS2'       => '3.47',
            'File::Spec::Unix'      => '3.47',
            'File::Spec::VMS'       => '3.47',
            'File::Spec::Win32'     => '3.47',
            'HTTP::Tiny'            => '0.042',
            'IO::Compress::Adapter::Bzip2'=> '2.064',
            'IO::Compress::Adapter::Deflate'=> '2.064',
            'IO::Compress::Adapter::Identity'=> '2.064',
            'IO::Compress::Base'    => '2.064',
            'IO::Compress::Base::Common'=> '2.064',
            'IO::Compress::Bzip2'   => '2.064',
            'IO::Compress::Deflate' => '2.064',
            'IO::Compress::Gzip'    => '2.064',
            'IO::Compress::Gzip::Constants'=> '2.064',
            'IO::Compress::RawDeflate'=> '2.064',
            'IO::Compress::Zip'     => '2.064',
            'IO::Compress::Zip::Constants'=> '2.064',
            'IO::Compress::Zlib::Constants'=> '2.064',
            'IO::Compress::Zlib::Extra'=> '2.064',
            'IO::Socket::INET'      => '1.35',
            'IO::Socket::IP'        => '0.28',
            'IO::Uncompress::Adapter::Bunzip2'=> '2.064',
            'IO::Uncompress::Adapter::Identity'=> '2.064',
            'IO::Uncompress::Adapter::Inflate'=> '2.064',
            'IO::Uncompress::AnyInflate'=> '2.064',
            'IO::Uncompress::AnyUncompress'=> '2.064',
            'IO::Uncompress::Base'  => '2.064',
            'IO::Uncompress::Bunzip2'=> '2.064',
            'IO::Uncompress::Gunzip'=> '2.064',
            'IO::Uncompress::Inflate'=> '2.064',
            'IO::Uncompress::RawInflate'=> '2.064',
            'IO::Uncompress::Unzip' => '2.064',
            'IPC::Cmd'              => '0.92',
            'List::Util'            => '1.38',
            'List::Util::XS'        => '1.38',
            'Locale::Codes'         => '3.29',
            'Locale::Codes::Constants'=> '3.29',
            'Locale::Codes::Country'=> '3.29',
            'Locale::Codes::Country_Codes'=> '3.29',
            'Locale::Codes::Country_Retired'=> '3.29',
            'Locale::Codes::Currency'=> '3.29',
            'Locale::Codes::Currency_Codes'=> '3.29',
            'Locale::Codes::Currency_Retired'=> '3.29',
            'Locale::Codes::LangExt'=> '3.29',
            'Locale::Codes::LangExt_Codes'=> '3.29',
            'Locale::Codes::LangExt_Retired'=> '3.29',
            'Locale::Codes::LangFam'=> '3.29',
            'Locale::Codes::LangFam_Codes'=> '3.29',
            'Locale::Codes::LangFam_Retired'=> '3.29',
            'Locale::Codes::LangVar'=> '3.29',
            'Locale::Codes::LangVar_Codes'=> '3.29',
            'Locale::Codes::LangVar_Retired'=> '3.29',
            'Locale::Codes::Language'=> '3.29',
            'Locale::Codes::Language_Codes'=> '3.29',
            'Locale::Codes::Language_Retired'=> '3.29',
            'Locale::Codes::Script' => '3.29',
            'Locale::Codes::Script_Codes'=> '3.29',
            'Locale::Codes::Script_Retired'=> '3.29',
            'Locale::Country'       => '3.29',
            'Locale::Currency'      => '3.29',
            'Locale::Language'      => '3.29',
            'Locale::Script'        => '3.29',
            'Module::Build'         => '0.4205',
            'Module::Build::Base'   => '0.4205',
            'Module::Build::Compat' => '0.4205',
            'Module::Build::Config' => '0.4205',
            'Module::Build::Cookbook'=> '0.4205',
            'Module::Build::Dumper' => '0.4205',
            'Module::Build::ModuleInfo'=> '0.4205',
            'Module::Build::Notes'  => '0.4205',
            'Module::Build::PPMMaker'=> '0.4205',
            'Module::Build::Platform::Default'=> '0.4205',
            'Module::Build::Platform::MacOS'=> '0.4205',
            'Module::Build::Platform::Unix'=> '0.4205',
            'Module::Build::Platform::VMS'=> '0.4205',
            'Module::Build::Platform::VOS'=> '0.4205',
            'Module::Build::Platform::Windows'=> '0.4205',
            'Module::Build::Platform::aix'=> '0.4205',
            'Module::Build::Platform::cygwin'=> '0.4205',
            'Module::Build::Platform::darwin'=> '0.4205',
            'Module::Build::Platform::os2'=> '0.4205',
            'Module::Build::PodParser'=> '0.4205',
            'Module::CoreList'      => '3.06',
            'Module::CoreList::TieHashDelta'=> '3.06',
            'Module::CoreList::Utils'=> '3.06',
            'Module::Load'          => '0.30',
            'Module::Load::Conditional'=> '0.62',
            'Net::Domain'           => '2.23',
            'Net::FTP'              => '2.79',
            'Net::NNTP'             => '2.26',
            'Net::POP3'             => '2.31',
            'Net::Ping'             => '2.43',
            'Net::SMTP'             => '2.33',
            'POSIX'                 => '1.38_02',
            'Parse::CPAN::Meta'     => '1.4413',
            'Pod::Escapes'          => '1.06',
            'Pod::Find'             => '1.62',
            'Pod::InputObjects'     => '1.62',
            'Pod::ParseUtils'       => '1.62',
            'Pod::Parser'           => '1.62',
            'Pod::Select'           => '1.62',
            'Scalar::Util'          => '1.38',
            'autodie'               => '2.23',
            'autodie::exception'    => '2.23',
            'autodie::exception::system'=> '2.23',
            'autodie::hints'        => '2.23',
            'autodie::skip'         => '2.23',
            'diagnostics'           => '1.34',
            'feature'               => '1.35',
            'inc::latest'           => '0.4205',
            'locale'                => '1.03',
            'mro'                   => '1.15',
            'threads'               => '1.92',
            'version'               => '0.9908',
            'version::regex'        => '0.9908',
            'version::vpp'          => '0.9908',
            'warnings'              => '1.22',
        },
        removed => {
        }
    },
    5.01901 => {
        delta_from => 5.019009,
        changed => {
            'App::Cpan'             => '1.62',
            'Attribute::Handlers'   => '0.96',
            'B::Deparse'            => '1.26',
            'CPAN'                  => '2.04',
            'CPAN::Bundle'          => '5.5001',
            'CPAN::Complete'        => '5.5001',
            'CPAN::Distribution'    => '2.01',
            'CPAN::Distroprefs'     => '6.0001',
            'CPAN::FirstTime'       => '5.5305',
            'CPAN::Meta'            => '2.140640',
            'CPAN::Meta::Converter' => '2.140640',
            'CPAN::Meta::Feature'   => '2.140640',
            'CPAN::Meta::History'   => '2.140640',
            'CPAN::Meta::Prereqs'   => '2.140640',
            'CPAN::Meta::Spec'      => '2.140640',
            'CPAN::Meta::Validator' => '2.140640',
            'CPAN::Meta::YAML'      => '0.012',
            'CPAN::Queue'           => '5.5002',
            'CPAN::Shell'           => '5.5003',
            'CPAN::Tarzip'          => '5.5012',
            'CPAN::Version'         => '5.5003',
            'Carp'                  => '1.33',
            'Carp::Heavy'           => '1.33',
            'Config'                => '5.019010',
            'Data::Dumper'          => '2.151',
            'Devel::PPPort'         => '3.22',
            'Digest::SHA'           => '5.88',
            'ExtUtils::Command::MM' => '6.92',
            'ExtUtils::Install'     => '1.63',
            'ExtUtils::Installed'   => '1.999005',
            'ExtUtils::Liblist'     => '6.92',
            'ExtUtils::Liblist::Kid'=> '6.92',
            'ExtUtils::MM'          => '6.92',
            'ExtUtils::MM_AIX'      => '6.92',
            'ExtUtils::MM_Any'      => '6.92',
            'ExtUtils::MM_BeOS'     => '6.92',
            'ExtUtils::MM_Cygwin'   => '6.92',
            'ExtUtils::MM_DOS'      => '6.92',
            'ExtUtils::MM_Darwin'   => '6.92',
            'ExtUtils::MM_MacOS'    => '6.92',
            'ExtUtils::MM_NW5'      => '6.92',
            'ExtUtils::MM_OS2'      => '6.92',
            'ExtUtils::MM_QNX'      => '6.92',
            'ExtUtils::MM_UWIN'     => '6.92',
            'ExtUtils::MM_Unix'     => '6.92',
            'ExtUtils::MM_VMS'      => '6.92',
            'ExtUtils::MM_VOS'      => '6.92',
            'ExtUtils::MM_Win32'    => '6.92',
            'ExtUtils::MM_Win95'    => '6.92',
            'ExtUtils::MY'          => '6.92',
            'ExtUtils::MakeMaker'   => '6.92',
            'ExtUtils::MakeMaker::Config'=> '6.92',
            'ExtUtils::Mkbootstrap' => '6.92',
            'ExtUtils::Mksymlists'  => '6.92',
            'ExtUtils::Packlist'    => '1.48',
            'ExtUtils::ParseXS'     => '3.24',
            'ExtUtils::ParseXS::Constants'=> '3.24',
            'ExtUtils::ParseXS::CountLines'=> '3.24',
            'ExtUtils::ParseXS::Eval'=> '3.24',
            'ExtUtils::ParseXS::Utilities'=> '3.24',
            'ExtUtils::Typemaps'    => '3.24',
            'ExtUtils::Typemaps::Cmd'=> '3.24',
            'ExtUtils::Typemaps::InputMap'=> '3.24',
            'ExtUtils::Typemaps::OutputMap'=> '3.24',
            'ExtUtils::Typemaps::Type'=> '3.24',
            'ExtUtils::testlib'     => '6.92',
            'File::Find'            => '1.27',
            'Filter::Simple'        => '0.91',
            'HTTP::Tiny'            => '0.043',
            'Hash::Util::FieldHash' => '1.15',
            'IO'                    => '1.31',
            'IO::Socket::IP'        => '0.29',
            'Locale::Codes'         => '3.30',
            'Locale::Codes::Constants'=> '3.30',
            'Locale::Codes::Country'=> '3.30',
            'Locale::Codes::Country_Codes'=> '3.30',
            'Locale::Codes::Country_Retired'=> '3.30',
            'Locale::Codes::Currency'=> '3.30',
            'Locale::Codes::Currency_Codes'=> '3.30',
            'Locale::Codes::Currency_Retired'=> '3.30',
            'Locale::Codes::LangExt'=> '3.30',
            'Locale::Codes::LangExt_Codes'=> '3.30',
            'Locale::Codes::LangExt_Retired'=> '3.30',
            'Locale::Codes::LangFam'=> '3.30',
            'Locale::Codes::LangFam_Codes'=> '3.30',
            'Locale::Codes::LangFam_Retired'=> '3.30',
            'Locale::Codes::LangVar'=> '3.30',
            'Locale::Codes::LangVar_Codes'=> '3.30',
            'Locale::Codes::LangVar_Retired'=> '3.30',
            'Locale::Codes::Language'=> '3.30',
            'Locale::Codes::Language_Codes'=> '3.30',
            'Locale::Codes::Language_Retired'=> '3.30',
            'Locale::Codes::Script' => '3.30',
            'Locale::Codes::Script_Codes'=> '3.30',
            'Locale::Codes::Script_Retired'=> '3.30',
            'Locale::Country'       => '3.30',
            'Locale::Currency'      => '3.30',
            'Locale::Language'      => '3.30',
            'Locale::Script'        => '3.30',
            'Module::CoreList'      => '3.09',
            'Module::CoreList::TieHashDelta'=> '3.09',
            'Module::CoreList::Utils'=> '3.09',
            'Module::Load'          => '0.32',
            'POSIX'                 => '1.38_03',
            'Parse::CPAN::Meta'     => '1.4414',
            'Pod::Perldoc'          => '3.23',
            'Pod::Perldoc::BaseTo'  => '3.23',
            'Pod::Perldoc::GetOptsOO'=> '3.23',
            'Pod::Perldoc::ToANSI'  => '3.23',
            'Pod::Perldoc::ToChecker'=> '3.23',
            'Pod::Perldoc::ToMan'   => '3.23',
            'Pod::Perldoc::ToNroff' => '3.23',
            'Pod::Perldoc::ToPod'   => '3.23',
            'Pod::Perldoc::ToRtf'   => '3.23',
            'Pod::Perldoc::ToTerm'  => '3.23',
            'Pod::Perldoc::ToText'  => '3.23',
            'Pod::Perldoc::ToTk'    => '3.23',
            'Pod::Perldoc::ToXml'   => '3.23',
            'Thread::Queue'         => '3.05',
            'XS::APItest'           => '0.60',
            'XS::Typemap'           => '0.13',
            'autouse'               => '1.08',
            'base'                  => '2.22',
            'charnames'             => '1.40',
            'feature'               => '1.36',
            'mro'                   => '1.16',
            'threads'               => '1.93',
            'warnings'              => '1.23',
            'warnings::register'    => '1.03',
        },
        removed => {
        }
    },
    5.019011 => {
        delta_from => 5.01901,
        changed => {
            'CPAN'                  => '2.05',
            'CPAN::Distribution'    => '2.02',
            'CPAN::FirstTime'       => '5.5306',
            'CPAN::Shell'           => '5.5004',
            'Carp'                  => '1.3301',
            'Carp::Heavy'           => '1.3301',
            'Config'                => '5.019011',
            'ExtUtils::Command::MM' => '6.94',
            'ExtUtils::Install'     => '1.67',
            'ExtUtils::Liblist'     => '6.94',
            'ExtUtils::Liblist::Kid'=> '6.94',
            'ExtUtils::MM'          => '6.94',
            'ExtUtils::MM_AIX'      => '6.94',
            'ExtUtils::MM_Any'      => '6.94',
            'ExtUtils::MM_BeOS'     => '6.94',
            'ExtUtils::MM_Cygwin'   => '6.94',
            'ExtUtils::MM_DOS'      => '6.94',
            'ExtUtils::MM_Darwin'   => '6.94',
            'ExtUtils::MM_MacOS'    => '6.94',
            'ExtUtils::MM_NW5'      => '6.94',
            'ExtUtils::MM_OS2'      => '6.94',
            'ExtUtils::MM_QNX'      => '6.94',
            'ExtUtils::MM_UWIN'     => '6.94',
            'ExtUtils::MM_Unix'     => '6.94',
            'ExtUtils::MM_VMS'      => '6.94',
            'ExtUtils::MM_VOS'      => '6.94',
            'ExtUtils::MM_Win32'    => '6.94',
            'ExtUtils::MM_Win95'    => '6.94',
            'ExtUtils::MY'          => '6.94',
            'ExtUtils::MakeMaker'   => '6.94',
            'ExtUtils::MakeMaker::Config'=> '6.94',
            'ExtUtils::Mkbootstrap' => '6.94',
            'ExtUtils::Mksymlists'  => '6.94',
            'ExtUtils::testlib'     => '6.94',
            'Module::CoreList'      => '3.10',
            'Module::CoreList::TieHashDelta'=> '3.10',
            'Module::CoreList::Utils'=> '3.10',
            'PerlIO'                => '1.09',
            'Storable'              => '2.49',
            'Win32'                 => '0.49',
            'experimental'          => '0.007',
        },
        removed => {
        }
    },
    5.020000 => {
        delta_from => 5.019011,
        changed => {
            'Config'                => '5.02',
            'Devel::PPPort'         => '3.21',
            'Encode'                => '2.60',
            'Errno'                 => '1.20_03',
            'ExtUtils::Command::MM' => '6.98',
            'ExtUtils::Liblist'     => '6.98',
            'ExtUtils::Liblist::Kid'=> '6.98',
            'ExtUtils::MM'          => '6.98',
            'ExtUtils::MM_AIX'      => '6.98',
            'ExtUtils::MM_Any'      => '6.98',
            'ExtUtils::MM_BeOS'     => '6.98',
            'ExtUtils::MM_Cygwin'   => '6.98',
            'ExtUtils::MM_DOS'      => '6.98',
            'ExtUtils::MM_Darwin'   => '6.98',
            'ExtUtils::MM_MacOS'    => '6.98',
            'ExtUtils::MM_NW5'      => '6.98',
            'ExtUtils::MM_OS2'      => '6.98',
            'ExtUtils::MM_QNX'      => '6.98',
            'ExtUtils::MM_UWIN'     => '6.98',
            'ExtUtils::MM_Unix'     => '6.98',
            'ExtUtils::MM_VMS'      => '6.98',
            'ExtUtils::MM_VOS'      => '6.98',
            'ExtUtils::MM_Win32'    => '6.98',
            'ExtUtils::MM_Win95'    => '6.98',
            'ExtUtils::MY'          => '6.98',
            'ExtUtils::MakeMaker'   => '6.98',
            'ExtUtils::MakeMaker::Config'=> '6.98',
            'ExtUtils::Miniperl'    => '1.01',
            'ExtUtils::Mkbootstrap' => '6.98',
            'ExtUtils::Mksymlists'  => '6.98',
            'ExtUtils::testlib'     => '6.98',
            'Pod::Functions::Functions'=> '1.08',
        },
        removed => {
        }
    },
    5.021000 => {
        delta_from => 5.020000,
        changed => {
            'Module::CoreList'      => '5.021001',
            'Module::CoreList::TieHashDelta'=> '5.021001',
            'Module::CoreList::Utils'=> '5.021001',
            'feature'               => '1.37',
        },
        removed => {
            'CGI'                   => 1,
            'CGI::Apache'           => 1,
            'CGI::Carp'             => 1,
            'CGI::Cookie'           => 1,
            'CGI::Fast'             => 1,
            'CGI::Pretty'           => 1,
            'CGI::Push'             => 1,
            'CGI::Switch'           => 1,
            'CGI::Util'             => 1,
            'Module::Build'         => 1,
            'Module::Build::Base'   => 1,
            'Module::Build::Compat' => 1,
            'Module::Build::Config' => 1,
            'Module::Build::ConfigData'=> 1,
            'Module::Build::Cookbook'=> 1,
            'Module::Build::Dumper' => 1,
            'Module::Build::ModuleInfo'=> 1,
            'Module::Build::Notes'  => 1,
            'Module::Build::PPMMaker'=> 1,
            'Module::Build::Platform::Default'=> 1,
            'Module::Build::Platform::MacOS'=> 1,
            'Module::Build::Platform::Unix'=> 1,
            'Module::Build::Platform::VMS'=> 1,
            'Module::Build::Platform::VOS'=> 1,
            'Module::Build::Platform::Windows'=> 1,
            'Module::Build::Platform::aix'=> 1,
            'Module::Build::Platform::cygwin'=> 1,
            'Module::Build::Platform::darwin'=> 1,
            'Module::Build::Platform::os2'=> 1,
            'Module::Build::PodParser'=> 1,
            'Module::Build::Version'=> 1,
            'Module::Build::YAML'   => 1,
            'Package::Constants'    => 1,
            'inc::latest'           => 1,
        }
    },
    5.021001 => {
        delta_from => 5.021000,
        changed => {
            'App::Prove'            => '3.32',
            'App::Prove::State'     => '3.32',
            'App::Prove::State::Result'=> '3.32',
            'App::Prove::State::Result::Test'=> '3.32',
            'Archive::Tar'          => '2.00',
            'Archive::Tar::Constant'=> '2.00',
            'Archive::Tar::File'    => '2.00',
            'B'                     => '1.49',
            'B::Deparse'            => '1.27',
            'Benchmark'             => '1.19',
            'CPAN::Meta'            => '2.141520',
            'CPAN::Meta::Converter' => '2.141520',
            'CPAN::Meta::Feature'   => '2.141520',
            'CPAN::Meta::History'   => '2.141520',
            'CPAN::Meta::Prereqs'   => '2.141520',
            'CPAN::Meta::Spec'      => '2.141520',
            'CPAN::Meta::Validator' => '2.141520',
            'Carp'                  => '1.34',
            'Carp::Heavy'           => '1.34',
            'Config'                => '5.021001',
            'Cwd'                   => '3.48',
            'Data::Dumper'          => '2.152',
            'Devel::PPPort'         => '3.24',
            'Devel::Peek'           => '1.17',
            'Digest::SHA'           => '5.92',
            'DynaLoader'            => '1.26',
            'Encode'                => '2.62',
            'Errno'                 => '1.20_04',
            'Exporter'              => '5.71',
            'Exporter::Heavy'       => '5.71',
            'ExtUtils::Install'     => '1.68',
            'ExtUtils::Miniperl'    => '1.02',
            'ExtUtils::ParseXS'     => '3.25',
            'ExtUtils::ParseXS::Constants'=> '3.25',
            'ExtUtils::ParseXS::CountLines'=> '3.25',
            'ExtUtils::ParseXS::Eval'=> '3.25',
            'ExtUtils::ParseXS::Utilities'=> '3.25',
            'ExtUtils::Typemaps'    => '3.25',
            'ExtUtils::Typemaps::Cmd'=> '3.25',
            'ExtUtils::Typemaps::InputMap'=> '3.25',
            'ExtUtils::Typemaps::OutputMap'=> '3.25',
            'ExtUtils::Typemaps::Type'=> '3.25',
            'Fatal'                 => '2.25',
            'File::Spec'            => '3.48',
            'File::Spec::Cygwin'    => '3.48',
            'File::Spec::Epoc'      => '3.48',
            'File::Spec::Functions' => '3.48',
            'File::Spec::Mac'       => '3.48',
            'File::Spec::OS2'       => '3.48',
            'File::Spec::Unix'      => '3.48',
            'File::Spec::VMS'       => '3.48',
            'File::Spec::Win32'     => '3.48',
            'Hash::Util'            => '0.17',
            'IO'                    => '1.32',
            'List::Util'            => '1.39',
            'List::Util::XS'        => '1.39',
            'Locale::Codes'         => '3.31',
            'Locale::Codes::Constants'=> '3.31',
            'Locale::Codes::Country'=> '3.31',
            'Locale::Codes::Country_Codes'=> '3.31',
            'Locale::Codes::Country_Retired'=> '3.31',
            'Locale::Codes::Currency'=> '3.31',
            'Locale::Codes::Currency_Codes'=> '3.31',
            'Locale::Codes::Currency_Retired'=> '3.31',
            'Locale::Codes::LangExt'=> '3.31',
            'Locale::Codes::LangExt_Codes'=> '3.31',
            'Locale::Codes::LangExt_Retired'=> '3.31',
            'Locale::Codes::LangFam'=> '3.31',
            'Locale::Codes::LangFam_Codes'=> '3.31',
            'Locale::Codes::LangFam_Retired'=> '3.31',
            'Locale::Codes::LangVar'=> '3.31',
            'Locale::Codes::LangVar_Codes'=> '3.31',
            'Locale::Codes::LangVar_Retired'=> '3.31',
            'Locale::Codes::Language'=> '3.31',
            'Locale::Codes::Language_Codes'=> '3.31',
            'Locale::Codes::Language_Retired'=> '3.31',
            'Locale::Codes::Script' => '3.31',
            'Locale::Codes::Script_Codes'=> '3.31',
            'Locale::Codes::Script_Retired'=> '3.31',
            'Locale::Country'       => '3.31',
            'Locale::Currency'      => '3.31',
            'Locale::Language'      => '3.31',
            'Locale::Script'        => '3.31',
            'Math::BigFloat'        => '1.9994',
            'Math::BigInt'          => '1.9995',
            'Math::BigInt::Calc'    => '1.9994',
            'Math::BigInt::CalcEmu' => '1.9994',
            'Math::BigRat'          => '0.2608',
            'Module::CoreList'      => '5.021001_01',
            'Module::CoreList::TieHashDelta'=> '5.021001_01',
            'Module::CoreList::Utils'=> '5.021001_01',
            'Module::Metadata'      => '1.000024',
            'NDBM_File'             => '1.13',
            'Net::Config'           => '1.14',
            'Net::SMTP'             => '2.34',
            'Net::Time'             => '2.11',
            'OS2::Process'          => '1.10',
            'POSIX'                 => '1.40',
            'PerlIO::encoding'      => '0.19',
            'PerlIO::mmap'          => '0.013',
            'PerlIO::scalar'        => '0.19',
            'PerlIO::via'           => '0.15',
            'Pod::Html'             => '1.22',
            'Scalar::Util'          => '1.39',
            'SelfLoader'            => '1.22',
            'Socket'                => '2.014',
            'Storable'              => '2.51',
            'TAP::Base'             => '3.32',
            'TAP::Formatter::Base'  => '3.32',
            'TAP::Formatter::Color' => '3.32',
            'TAP::Formatter::Console'=> '3.32',
            'TAP::Formatter::Console::ParallelSession'=> '3.32',
            'TAP::Formatter::Console::Session'=> '3.32',
            'TAP::Formatter::File'  => '3.32',
            'TAP::Formatter::File::Session'=> '3.32',
            'TAP::Formatter::Session'=> '3.32',
            'TAP::Harness'          => '3.32',
            'TAP::Harness::Env'     => '3.32',
            'TAP::Object'           => '3.32',
            'TAP::Parser'           => '3.32',
            'TAP::Parser::Aggregator'=> '3.32',
            'TAP::Parser::Grammar'  => '3.32',
            'TAP::Parser::Iterator' => '3.32',
            'TAP::Parser::Iterator::Array'=> '3.32',
            'TAP::Parser::Iterator::Process'=> '3.32',
            'TAP::Parser::Iterator::Stream'=> '3.32',
            'TAP::Parser::IteratorFactory'=> '3.32',
            'TAP::Parser::Multiplexer'=> '3.32',
            'TAP::Parser::Result'   => '3.32',
            'TAP::Parser::Result::Bailout'=> '3.32',
            'TAP::Parser::Result::Comment'=> '3.32',
            'TAP::Parser::Result::Plan'=> '3.32',
            'TAP::Parser::Result::Pragma'=> '3.32',
            'TAP::Parser::Result::Test'=> '3.32',
            'TAP::Parser::Result::Unknown'=> '3.32',
            'TAP::Parser::Result::Version'=> '3.32',
            'TAP::Parser::Result::YAML'=> '3.32',
            'TAP::Parser::ResultFactory'=> '3.32',
            'TAP::Parser::Scheduler'=> '3.32',
            'TAP::Parser::Scheduler::Job'=> '3.32',
            'TAP::Parser::Scheduler::Spinner'=> '3.32',
            'TAP::Parser::Source'   => '3.32',
            'TAP::Parser::SourceHandler'=> '3.32',
            'TAP::Parser::SourceHandler::Executable'=> '3.32',
            'TAP::Parser::SourceHandler::File'=> '3.32',
            'TAP::Parser::SourceHandler::Handle'=> '3.32',
            'TAP::Parser::SourceHandler::Perl'=> '3.32',
            'TAP::Parser::SourceHandler::RawTAP'=> '3.32',
            'TAP::Parser::YAMLish::Reader'=> '3.32',
            'TAP::Parser::YAMLish::Writer'=> '3.32',
            'Term::ANSIColor'       => '4.03',
            'Test::Builder'         => '1.001003',
            'Test::Builder::Module' => '1.001003',
            'Test::Builder::Tester' => '1.23_003',
            'Test::Harness'         => '3.32',
            'Test::More'            => '1.001003',
            'Test::Simple'          => '1.001003',
            'Tie::File'             => '1.01',
            'Unicode'               => '7.0.0',
            'Unicode::Collate'      => '1.07',
            'Unicode::Normalize'    => '1.18',
            'Unicode::UCD'          => '0.58',
            'XS::APItest'           => '0.61',
            '_charnames'            => '1.41',
            'autodie'               => '2.25',
            'autodie::Scope::Guard' => '2.25',
            'autodie::Scope::GuardStack'=> '2.25',
            'autodie::ScopeUtil'    => '2.25',
            'autodie::exception'    => '2.25',
            'autodie::exception::system'=> '2.25',
            'autodie::hints'        => '2.25',
            'autodie::skip'         => '2.25',
            'charnames'             => '1.41',
            'locale'                => '1.04',
            'threads'               => '1.94',
            'utf8'                  => '1.14',
            'warnings'              => '1.24',
        },
        removed => {
        }
    },
    5.021002 => {
        delta_from => 5.021001,
        changed => {
            'B'                     => '1.50',
            'Config'                => '5.021002',
            'Cwd'                   => '3.49',
            'Devel::Peek'           => '1.18',
            'ExtUtils::Manifest'    => '1.64',
            'File::Copy'            => '2.30',
            'File::Spec'            => '3.49',
            'File::Spec::Cygwin'    => '3.49',
            'File::Spec::Epoc'      => '3.49',
            'File::Spec::Functions' => '3.49',
            'File::Spec::Mac'       => '3.49',
            'File::Spec::OS2'       => '3.49',
            'File::Spec::Unix'      => '3.49',
            'File::Spec::VMS'       => '3.49',
            'File::Spec::Win32'     => '3.49',
            'Filter::Simple'        => '0.92',
            'Hash::Util'            => '0.18',
            'IO'                    => '1.33',
            'IO::Socket::IP'        => '0.31',
            'IPC::Open3'            => '1.17',
            'Math::BigFloat'        => '1.9996',
            'Math::BigInt'          => '1.9996',
            'Math::BigInt::Calc'    => '1.9996',
            'Math::BigInt::CalcEmu' => '1.9996',
            'Module::CoreList'      => '5.021002',
            'Module::CoreList::TieHashDelta'=> '5.021002',
            'Module::CoreList::Utils'=> '5.021002',
            'POSIX'                 => '1.41',
            'Pod::Usage'            => '1.64',
            'XS::APItest'           => '0.62',
            'arybase'               => '0.08',
            'experimental'          => '0.008',
            'threads'               => '1.95',
            'warnings'              => '1.26',
        },
        removed => {
        }
    },
    5.021003 => {
        delta_from => 5.021002,
        changed => {
            'B::Debug'              => '1.21',
            'CPAN::Meta'            => '2.142060',
            'CPAN::Meta::Converter' => '2.142060',
            'CPAN::Meta::Feature'   => '2.142060',
            'CPAN::Meta::History'   => '2.142060',
            'CPAN::Meta::Merge'     => '2.142060',
            'CPAN::Meta::Prereqs'   => '2.142060',
            'CPAN::Meta::Requirements'=> '2.126',
            'CPAN::Meta::Spec'      => '2.142060',
            'CPAN::Meta::Validator' => '2.142060',
            'Config'                => '5.021003',
            'Config::Perl::V'       => '0.22',
            'ExtUtils::CBuilder'    => '0.280217',
            'ExtUtils::CBuilder::Base'=> '0.280217',
            'ExtUtils::CBuilder::Platform::Unix'=> '0.280217',
            'ExtUtils::CBuilder::Platform::VMS'=> '0.280217',
            'ExtUtils::CBuilder::Platform::Windows'=> '0.280217',
            'ExtUtils::CBuilder::Platform::Windows::BCC'=> '0.280217',
            'ExtUtils::CBuilder::Platform::Windows::GCC'=> '0.280217',
            'ExtUtils::CBuilder::Platform::Windows::MSVC'=> '0.280217',
            'ExtUtils::CBuilder::Platform::aix'=> '0.280217',
            'ExtUtils::CBuilder::Platform::android'=> '0.280217',
            'ExtUtils::CBuilder::Platform::cygwin'=> '0.280217',
            'ExtUtils::CBuilder::Platform::darwin'=> '0.280217',
            'ExtUtils::CBuilder::Platform::dec_osf'=> '0.280217',
            'ExtUtils::CBuilder::Platform::os2'=> '0.280217',
            'ExtUtils::Manifest'    => '1.65',
            'HTTP::Tiny'            => '0.047',
            'IPC::Open3'            => '1.18',
            'Module::CoreList'      => '5.021003',
            'Module::CoreList::TieHashDelta'=> '5.021003',
            'Module::CoreList::Utils'=> '5.021003',
            'Opcode'                => '1.28',
            'POSIX'                 => '1.42',
            'Safe'                  => '2.38',
            'Socket'                => '2.015',
            'Sys::Hostname'         => '1.19',
            'UNIVERSAL'             => '1.12',
            'XS::APItest'           => '0.63',
            'perlfaq'               => '5.0150045',
        },
        removed => {
        }
    },
    5.020001 => {
        delta_from => 5.020000,
        changed => {
            'Config'                => '5.020001',
            'Config::Perl::V'       => '0.22',
            'Cwd'                   => '3.48',
            'Exporter'              => '5.71',
            'Exporter::Heavy'       => '5.71',
            'ExtUtils::CBuilder'    => '0.280217',
            'ExtUtils::CBuilder::Base'=> '0.280217',
            'ExtUtils::CBuilder::Platform::Unix'=> '0.280217',
            'ExtUtils::CBuilder::Platform::VMS'=> '0.280217',
            'ExtUtils::CBuilder::Platform::Windows'=> '0.280217',
            'ExtUtils::CBuilder::Platform::Windows::BCC'=> '0.280217',
            'ExtUtils::CBuilder::Platform::Windows::GCC'=> '0.280217',
            'ExtUtils::CBuilder::Platform::Windows::MSVC'=> '0.280217',
            'ExtUtils::CBuilder::Platform::aix'=> '0.280217',
            'ExtUtils::CBuilder::Platform::android'=> '0.280217',
            'ExtUtils::CBuilder::Platform::cygwin'=> '0.280217',
            'ExtUtils::CBuilder::Platform::darwin'=> '0.280217',
            'ExtUtils::CBuilder::Platform::dec_osf'=> '0.280217',
            'ExtUtils::CBuilder::Platform::os2'=> '0.280217',
            'File::Copy'            => '2.30',
            'File::Spec'            => '3.48',
            'File::Spec::Cygwin'    => '3.48',
            'File::Spec::Epoc'      => '3.48',
            'File::Spec::Functions' => '3.48',
            'File::Spec::Mac'       => '3.48',
            'File::Spec::OS2'       => '3.48',
            'File::Spec::Unix'      => '3.48',
            'File::Spec::VMS'       => '3.48',
            'File::Spec::Win32'     => '3.48',
            'Module::CoreList'      => '5.020001',
            'Module::CoreList::TieHashDelta'=> '5.020001',
            'Module::CoreList::Utils'=> '5.020001',
            'PerlIO::via'           => '0.15',
            'Unicode::UCD'          => '0.58',
            'XS::APItest'           => '0.60_01',
            'utf8'                  => '1.13_01',
            'version'               => '0.9909',
            'version::regex'        => '0.9909',
            'version::vpp'          => '0.9909',
        },
        removed => {
        }
    },
    5.021004 => {
        delta_from => 5.021003,
        changed => {
            'App::Prove'            => '3.33',
            'App::Prove::State'     => '3.33',
            'App::Prove::State::Result'=> '3.33',
            'App::Prove::State::Result::Test'=> '3.33',
            'Archive::Tar'          => '2.02',
            'Archive::Tar::Constant'=> '2.02',
            'Archive::Tar::File'    => '2.02',
            'Attribute::Handlers'   => '0.97',
            'B'                     => '1.51',
            'B::Concise'            => '0.993',
            'B::Deparse'            => '1.28',
            'B::Op_private'         => '5.021004',
            'CPAN::Meta::Requirements'=> '2.128',
            'Config'                => '5.021004',
            'Cwd'                   => '3.50',
            'Data::Dumper'          => '2.154',
            'ExtUtils::CBuilder'    => '0.280219',
            'ExtUtils::CBuilder::Base'=> '0.280219',
            'ExtUtils::CBuilder::Platform::Unix'=> '0.280219',
            'ExtUtils::CBuilder::Platform::VMS'=> '0.280219',
            'ExtUtils::CBuilder::Platform::Windows'=> '0.280219',
            'ExtUtils::CBuilder::Platform::Windows::BCC'=> '0.280219',
            'ExtUtils::CBuilder::Platform::Windows::GCC'=> '0.280219',
            'ExtUtils::CBuilder::Platform::Windows::MSVC'=> '0.280219',
            'ExtUtils::CBuilder::Platform::aix'=> '0.280219',
            'ExtUtils::CBuilder::Platform::android'=> '0.280219',
            'ExtUtils::CBuilder::Platform::cygwin'=> '0.280219',
            'ExtUtils::CBuilder::Platform::darwin'=> '0.280219',
            'ExtUtils::CBuilder::Platform::dec_osf'=> '0.280219',
            'ExtUtils::CBuilder::Platform::os2'=> '0.280219',
            'ExtUtils::Install'     => '2.04',
            'ExtUtils::Installed'   => '2.04',
            'ExtUtils::Liblist::Kid'=> '6.98_01',
            'ExtUtils::Manifest'    => '1.68',
            'ExtUtils::Packlist'    => '2.04',
            'File::Find'            => '1.28',
            'File::Spec'            => '3.50',
            'File::Spec::Cygwin'    => '3.50',
            'File::Spec::Epoc'      => '3.50',
            'File::Spec::Functions' => '3.50',
            'File::Spec::Mac'       => '3.50',
            'File::Spec::OS2'       => '3.50',
            'File::Spec::Unix'      => '3.50',
            'File::Spec::VMS'       => '3.50',
            'File::Spec::Win32'     => '3.50',
            'Getopt::Std'           => '1.11',
            'HTTP::Tiny'            => '0.049',
            'IO'                    => '1.34',
            'IO::Socket::IP'        => '0.32',
            'List::Util'            => '1.41',
            'List::Util::XS'        => '1.41',
            'Locale::Codes'         => '3.32',
            'Locale::Codes::Constants'=> '3.32',
            'Locale::Codes::Country'=> '3.32',
            'Locale::Codes::Country_Codes'=> '3.32',
            'Locale::Codes::Country_Retired'=> '3.32',
            'Locale::Codes::Currency'=> '3.32',
            'Locale::Codes::Currency_Codes'=> '3.32',
            'Locale::Codes::Currency_Retired'=> '3.32',
            'Locale::Codes::LangExt'=> '3.32',
            'Locale::Codes::LangExt_Codes'=> '3.32',
            'Locale::Codes::LangExt_Retired'=> '3.32',
            'Locale::Codes::LangFam'=> '3.32',
            'Locale::Codes::LangFam_Codes'=> '3.32',
            'Locale::Codes::LangFam_Retired'=> '3.32',
            'Locale::Codes::LangVar'=> '3.32',
            'Locale::Codes::LangVar_Codes'=> '3.32',
            'Locale::Codes::LangVar_Retired'=> '3.32',
            'Locale::Codes::Language'=> '3.32',
            'Locale::Codes::Language_Codes'=> '3.32',
            'Locale::Codes::Language_Retired'=> '3.32',
            'Locale::Codes::Script' => '3.32',
            'Locale::Codes::Script_Codes'=> '3.32',
            'Locale::Codes::Script_Retired'=> '3.32',
            'Locale::Country'       => '3.32',
            'Locale::Currency'      => '3.32',
            'Locale::Language'      => '3.32',
            'Locale::Script'        => '3.32',
            'Math::BigFloat'        => '1.9997',
            'Math::BigInt'          => '1.9997',
            'Math::BigInt::Calc'    => '1.9997',
            'Math::BigInt::CalcEmu' => '1.9997',
            'Module::CoreList'      => '5.20140920',
            'Module::CoreList::TieHashDelta'=> '5.20140920',
            'Module::CoreList::Utils'=> '5.20140920',
            'POSIX'                 => '1.43',
            'Pod::Perldoc'          => '3.24',
            'Pod::Perldoc::BaseTo'  => '3.24',
            'Pod::Perldoc::GetOptsOO'=> '3.24',
            'Pod::Perldoc::ToANSI'  => '3.24',
            'Pod::Perldoc::ToChecker'=> '3.24',
            'Pod::Perldoc::ToMan'   => '3.24',
            'Pod::Perldoc::ToNroff' => '3.24',
            'Pod::Perldoc::ToPod'   => '3.24',
            'Pod::Perldoc::ToRtf'   => '3.24',
            'Pod::Perldoc::ToTerm'  => '3.24',
            'Pod::Perldoc::ToText'  => '3.24',
            'Pod::Perldoc::ToTk'    => '3.24',
            'Pod::Perldoc::ToXml'   => '3.24',
            'Scalar::Util'          => '1.41',
            'Sub::Util'             => '1.41',
            'TAP::Base'             => '3.33',
            'TAP::Formatter::Base'  => '3.33',
            'TAP::Formatter::Color' => '3.33',
            'TAP::Formatter::Console'=> '3.33',
            'TAP::Formatter::Console::ParallelSession'=> '3.33',
            'TAP::Formatter::Console::Session'=> '3.33',
            'TAP::Formatter::File'  => '3.33',
            'TAP::Formatter::File::Session'=> '3.33',
            'TAP::Formatter::Session'=> '3.33',
            'TAP::Harness'          => '3.33',
            'TAP::Harness::Env'     => '3.33',
            'TAP::Object'           => '3.33',
            'TAP::Parser'           => '3.33',
            'TAP::Parser::Aggregator'=> '3.33',
            'TAP::Parser::Grammar'  => '3.33',
            'TAP::Parser::Iterator' => '3.33',
            'TAP::Parser::Iterator::Array'=> '3.33',
            'TAP::Parser::Iterator::Process'=> '3.33',
            'TAP::Parser::Iterator::Stream'=> '3.33',
            'TAP::Parser::IteratorFactory'=> '3.33',
            'TAP::Parser::Multiplexer'=> '3.33',
            'TAP::Parser::Result'   => '3.33',
            'TAP::Parser::Result::Bailout'=> '3.33',
            'TAP::Parser::Result::Comment'=> '3.33',
            'TAP::Parser::Result::Plan'=> '3.33',
            'TAP::Parser::Result::Pragma'=> '3.33',
            'TAP::Parser::Result::Test'=> '3.33',
            'TAP::Parser::Result::Unknown'=> '3.33',
            'TAP::Parser::Result::Version'=> '3.33',
            'TAP::Parser::Result::YAML'=> '3.33',
            'TAP::Parser::ResultFactory'=> '3.33',
            'TAP::Parser::Scheduler'=> '3.33',
            'TAP::Parser::Scheduler::Job'=> '3.33',
            'TAP::Parser::Scheduler::Spinner'=> '3.33',
            'TAP::Parser::Source'   => '3.33',
            'TAP::Parser::SourceHandler'=> '3.33',
            'TAP::Parser::SourceHandler::Executable'=> '3.33',
            'TAP::Parser::SourceHandler::File'=> '3.33',
            'TAP::Parser::SourceHandler::Handle'=> '3.33',
            'TAP::Parser::SourceHandler::Perl'=> '3.33',
            'TAP::Parser::SourceHandler::RawTAP'=> '3.33',
            'TAP::Parser::YAMLish::Reader'=> '3.33',
            'TAP::Parser::YAMLish::Writer'=> '3.33',
            'Term::ReadLine'        => '1.15',
            'Test::Builder'         => '1.001006',
            'Test::Builder::Module' => '1.001006',
            'Test::Builder::Tester' => '1.24',
            'Test::Builder::Tester::Color'=> '1.24',
            'Test::Harness'         => '3.33',
            'Test::More'            => '1.001006',
            'Test::Simple'          => '1.001006',
            'Time::Piece'           => '1.29',
            'Time::Seconds'         => '1.29',
            'XS::APItest'           => '0.64',
            '_charnames'            => '1.42',
            'attributes'            => '0.23',
            'bigint'                => '0.37',
            'bignum'                => '0.38',
            'bigrat'                => '0.37',
            'constant'              => '1.32',
            'experimental'          => '0.010',
            'overload'              => '1.23',
            'threads'               => '1.96',
            'version'               => '0.9909',
            'version::regex'        => '0.9909',
            'version::vpp'          => '0.9909',
        },
        removed => {
        }
    },
    5.021005 => {
        delta_from => 5.021004,
        changed => {
            'B'                     => '1.52',
            'B::Concise'            => '0.994',
            'B::Debug'              => '1.22',
            'B::Deparse'            => '1.29',
            'B::Op_private'         => '5.021005',
            'CPAN::Meta'            => '2.142690',
            'CPAN::Meta::Converter' => '2.142690',
            'CPAN::Meta::Feature'   => '2.142690',
            'CPAN::Meta::History'   => '2.142690',
            'CPAN::Meta::Merge'     => '2.142690',
            'CPAN::Meta::Prereqs'   => '2.142690',
            'CPAN::Meta::Spec'      => '2.142690',
            'CPAN::Meta::Validator' => '2.142690',
            'Compress::Raw::Bzip2'  => '2.066',
            'Compress::Raw::Zlib'   => '2.066',
            'Compress::Zlib'        => '2.066',
            'Config'                => '5.021005',
            'Cwd'                   => '3.51',
            'DynaLoader'            => '1.27',
            'Errno'                 => '1.21',
            'ExtUtils::CBuilder'    => '0.280220',
            'ExtUtils::CBuilder::Base'=> '0.280220',
            'ExtUtils::CBuilder::Platform::Unix'=> '0.280220',
            'ExtUtils::CBuilder::Platform::VMS'=> '0.280220',
            'ExtUtils::CBuilder::Platform::Windows'=> '0.280220',
            'ExtUtils::CBuilder::Platform::Windows::BCC'=> '0.280220',
            'ExtUtils::CBuilder::Platform::Windows::GCC'=> '0.280220',
            'ExtUtils::CBuilder::Platform::Windows::MSVC'=> '0.280220',
            'ExtUtils::CBuilder::Platform::aix'=> '0.280220',
            'ExtUtils::CBuilder::Platform::android'=> '0.280220',
            'ExtUtils::CBuilder::Platform::cygwin'=> '0.280220',
            'ExtUtils::CBuilder::Platform::darwin'=> '0.280220',
            'ExtUtils::CBuilder::Platform::dec_osf'=> '0.280220',
            'ExtUtils::CBuilder::Platform::os2'=> '0.280220',
            'ExtUtils::Miniperl'    => '1.03',
            'Fcntl'                 => '1.13',
            'File::Find'            => '1.29',
            'File::Spec'            => '3.51',
            'File::Spec::Cygwin'    => '3.51',
            'File::Spec::Epoc'      => '3.51',
            'File::Spec::Functions' => '3.51',
            'File::Spec::Mac'       => '3.51',
            'File::Spec::OS2'       => '3.51',
            'File::Spec::Unix'      => '3.51',
            'File::Spec::VMS'       => '3.51',
            'File::Spec::Win32'     => '3.51',
            'HTTP::Tiny'            => '0.050',
            'IO::Compress::Adapter::Bzip2'=> '2.066',
            'IO::Compress::Adapter::Deflate'=> '2.066',
            'IO::Compress::Adapter::Identity'=> '2.066',
            'IO::Compress::Base'    => '2.066',
            'IO::Compress::Base::Common'=> '2.066',
            'IO::Compress::Bzip2'   => '2.066',
            'IO::Compress::Deflate' => '2.066',
            'IO::Compress::Gzip'    => '2.066',
            'IO::Compress::Gzip::Constants'=> '2.066',
            'IO::Compress::RawDeflate'=> '2.066',
            'IO::Compress::Zip'     => '2.066',
            'IO::Compress::Zip::Constants'=> '2.066',
            'IO::Compress::Zlib::Constants'=> '2.066',
            'IO::Compress::Zlib::Extra'=> '2.066',
            'IO::Uncompress::Adapter::Bunzip2'=> '2.066',
            'IO::Uncompress::Adapter::Identity'=> '2.066',
            'IO::Uncompress::Adapter::Inflate'=> '2.066',
            'IO::Uncompress::AnyInflate'=> '2.066',
            'IO::Uncompress::AnyUncompress'=> '2.066',
            'IO::Uncompress::Base'  => '2.066',
            'IO::Uncompress::Bunzip2'=> '2.066',
            'IO::Uncompress::Gunzip'=> '2.066',
            'IO::Uncompress::Inflate'=> '2.066',
            'IO::Uncompress::RawInflate'=> '2.066',
            'IO::Uncompress::Unzip' => '2.066',
            'JSON::PP'              => '2.27300',
            'Module::CoreList'      => '5.20141020',
            'Module::CoreList::TieHashDelta'=> '5.20141020',
            'Module::CoreList::Utils'=> '5.20141020',
            'Net::Cmd'              => '3.02',
            'Net::Config'           => '3.02',
            'Net::Domain'           => '3.02',
            'Net::FTP'              => '3.02',
            'Net::FTP::A'           => '3.02',
            'Net::FTP::E'           => '3.02',
            'Net::FTP::I'           => '3.02',
            'Net::FTP::L'           => '3.02',
            'Net::FTP::dataconn'    => '3.02',
            'Net::NNTP'             => '3.02',
            'Net::Netrc'            => '3.02',
            'Net::POP3'             => '3.02',
            'Net::SMTP'             => '3.02',
            'Net::Time'             => '3.02',
            'Opcode'                => '1.29',
            'POSIX'                 => '1.45',
            'Socket'                => '2.016',
            'Test::Builder'         => '1.001008',
            'Test::Builder::Module' => '1.001008',
            'Test::More'            => '1.001008',
            'Test::Simple'          => '1.001008',
            'XS::APItest'           => '0.65',
            'XSLoader'              => '0.18',
            'attributes'            => '0.24',
            'experimental'          => '0.012',
            'feature'               => '1.38',
            'perlfaq'               => '5.0150046',
            're'                    => '0.27',
            'threads::shared'       => '1.47',
            'warnings'              => '1.28',
            'warnings::register'    => '1.04',
        },
        removed => {
        }
    },
    5.021006 => {
        delta_from => 5.021005,
        changed => {
            'App::Prove'            => '3.34',
            'App::Prove::State'     => '3.34',
            'App::Prove::State::Result'=> '3.34',
            'App::Prove::State::Result::Test'=> '3.34',
            'B'                     => '1.53',
            'B::Concise'            => '0.995',
            'B::Deparse'            => '1.30',
            'B::Op_private'         => '5.021006',
            'CPAN::Meta'            => '2.143240',
            'CPAN::Meta::Converter' => '2.143240',
            'CPAN::Meta::Feature'   => '2.143240',
            'CPAN::Meta::History'   => '2.143240',
            'CPAN::Meta::Merge'     => '2.143240',
            'CPAN::Meta::Prereqs'   => '2.143240',
            'CPAN::Meta::Requirements'=> '2.130',
            'CPAN::Meta::Spec'      => '2.143240',
            'CPAN::Meta::Validator' => '2.143240',
            'Config'                => '5.021006',
            'Devel::Peek'           => '1.19',
            'Digest::SHA'           => '5.93',
            'DynaLoader'            => '1.28',
            'Encode'                => '2.64',
            'Exporter'              => '5.72',
            'Exporter::Heavy'       => '5.72',
            'ExtUtils::Command::MM' => '7.02',
            'ExtUtils::Liblist'     => '7.02',
            'ExtUtils::Liblist::Kid'=> '7.02',
            'ExtUtils::MM'          => '7.02',
            'ExtUtils::MM_AIX'      => '7.02',
            'ExtUtils::MM_Any'      => '7.02',
            'ExtUtils::MM_BeOS'     => '7.02',
            'ExtUtils::MM_Cygwin'   => '7.02',
            'ExtUtils::MM_DOS'      => '7.02',
            'ExtUtils::MM_Darwin'   => '7.02',
            'ExtUtils::MM_MacOS'    => '7.02',
            'ExtUtils::MM_NW5'      => '7.02',
            'ExtUtils::MM_OS2'      => '7.02',
            'ExtUtils::MM_QNX'      => '7.02',
            'ExtUtils::MM_UWIN'     => '7.02',
            'ExtUtils::MM_Unix'     => '7.02',
            'ExtUtils::MM_VMS'      => '7.02',
            'ExtUtils::MM_VOS'      => '7.02',
            'ExtUtils::MM_Win32'    => '7.02',
            'ExtUtils::MM_Win95'    => '7.02',
            'ExtUtils::MY'          => '7.02',
            'ExtUtils::MakeMaker'   => '7.02',
            'ExtUtils::MakeMaker::Config'=> '7.02',
            'ExtUtils::MakeMaker::Locale'=> '7.02',
            'ExtUtils::MakeMaker::version'=> '7.02',
            'ExtUtils::MakeMaker::version::regex'=> '7.02',
            'ExtUtils::MakeMaker::version::vpp'=> '7.02',
            'ExtUtils::Manifest'    => '1.69',
            'ExtUtils::Mkbootstrap' => '7.02',
            'ExtUtils::Mksymlists'  => '7.02',
            'ExtUtils::ParseXS'     => '3.26',
            'ExtUtils::ParseXS::Constants'=> '3.26',
            'ExtUtils::ParseXS::CountLines'=> '3.26',
            'ExtUtils::ParseXS::Eval'=> '3.26',
            'ExtUtils::ParseXS::Utilities'=> '3.26',
            'ExtUtils::testlib'     => '7.02',
            'File::Spec::VMS'       => '3.52',
            'HTTP::Tiny'            => '0.051',
            'I18N::Langinfo'        => '0.12',
            'IO::Socket'            => '1.38',
            'Module::CoreList'      => '5.20141120',
            'Module::CoreList::TieHashDelta'=> '5.20141120',
            'Module::CoreList::Utils'=> '5.20141120',
            'POSIX'                 => '1.46',
            'PerlIO::encoding'      => '0.20',
            'PerlIO::scalar'        => '0.20',
            'TAP::Base'             => '3.34',
            'TAP::Formatter::Base'  => '3.34',
            'TAP::Formatter::Color' => '3.34',
            'TAP::Formatter::Console'=> '3.34',
            'TAP::Formatter::Console::ParallelSession'=> '3.34',
            'TAP::Formatter::Console::Session'=> '3.34',
            'TAP::Formatter::File'  => '3.34',
            'TAP::Formatter::File::Session'=> '3.34',
            'TAP::Formatter::Session'=> '3.34',
            'TAP::Harness'          => '3.34',
            'TAP::Harness::Env'     => '3.34',
            'TAP::Object'           => '3.34',
            'TAP::Parser'           => '3.34',
            'TAP::Parser::Aggregator'=> '3.34',
            'TAP::Parser::Grammar'  => '3.34',
            'TAP::Parser::Iterator' => '3.34',
            'TAP::Parser::Iterator::Array'=> '3.34',
            'TAP::Parser::Iterator::Process'=> '3.34',
            'TAP::Parser::Iterator::Stream'=> '3.34',
            'TAP::Parser::IteratorFactory'=> '3.34',
            'TAP::Parser::Multiplexer'=> '3.34',
            'TAP::Parser::Result'   => '3.34',
            'TAP::Parser::Result::Bailout'=> '3.34',
            'TAP::Parser::Result::Comment'=> '3.34',
            'TAP::Parser::Result::Plan'=> '3.34',
            'TAP::Parser::Result::Pragma'=> '3.34',
            'TAP::Parser::Result::Test'=> '3.34',
            'TAP::Parser::Result::Unknown'=> '3.34',
            'TAP::Parser::Result::Version'=> '3.34',
            'TAP::Parser::Result::YAML'=> '3.34',
            'TAP::Parser::ResultFactory'=> '3.34',
            'TAP::Parser::Scheduler'=> '3.34',
            'TAP::Parser::Scheduler::Job'=> '3.34',
            'TAP::Parser::Scheduler::Spinner'=> '3.34',
            'TAP::Parser::Source'   => '3.34',
            'TAP::Parser::SourceHandler'=> '3.34',
            'TAP::Parser::SourceHandler::Executable'=> '3.34',
            'TAP::Parser::SourceHandler::File'=> '3.34',
            'TAP::Parser::SourceHandler::Handle'=> '3.34',
            'TAP::Parser::SourceHandler::Perl'=> '3.34',
            'TAP::Parser::SourceHandler::RawTAP'=> '3.34',
            'TAP::Parser::YAMLish::Reader'=> '3.34',
            'TAP::Parser::YAMLish::Writer'=> '3.34',
            'Test::Builder'         => '1.301001_075',
            'Test::Builder::Module' => '1.301001_075',
            'Test::Builder::Tester' => '1.301001_075',
            'Test::Builder::Tester::Color'=> '1.301001_075',
            'Test::Harness'         => '3.34',
            'Test::More'            => '1.301001_075',
            'Test::More::DeepCheck' => undef,
            'Test::More::DeepCheck::Strict'=> undef,
            'Test::More::DeepCheck::Tolerant'=> undef,
            'Test::More::Tools'     => undef,
            'Test::MostlyLike'      => undef,
            'Test::Simple'          => '1.301001_075',
            'Test::Stream'          => '1.301001_075',
            'Test::Stream::ArrayBase'=> undef,
            'Test::Stream::ArrayBase::Meta'=> undef,
            'Test::Stream::Carp'    => undef,
            'Test::Stream::Context' => undef,
            'Test::Stream::Event'   => undef,
            'Test::Stream::Event::Bail'=> undef,
            'Test::Stream::Event::Child'=> undef,
            'Test::Stream::Event::Diag'=> undef,
            'Test::Stream::Event::Finish'=> undef,
            'Test::Stream::Event::Note'=> undef,
            'Test::Stream::Event::Ok'=> undef,
            'Test::Stream::Event::Plan'=> undef,
            'Test::Stream::Event::Subtest'=> undef,
            'Test::Stream::ExitMagic'=> undef,
            'Test::Stream::ExitMagic::Context'=> undef,
            'Test::Stream::Exporter'=> undef,
            'Test::Stream::Exporter::Meta'=> undef,
            'Test::Stream::IOSets'  => undef,
            'Test::Stream::Meta'    => undef,
            'Test::Stream::PackageUtil'=> undef,
            'Test::Stream::Tester'  => undef,
            'Test::Stream::Tester::Checks'=> undef,
            'Test::Stream::Tester::Checks::Event'=> undef,
            'Test::Stream::Tester::Events'=> undef,
            'Test::Stream::Tester::Events::Event'=> undef,
            'Test::Stream::Tester::Grab'=> undef,
            'Test::Stream::Threads' => undef,
            'Test::Stream::Toolset' => undef,
            'Test::Stream::Util'    => undef,
            'Test::Tester'          => '1.301001_075',
            'Test::Tester::Capture' => undef,
            'Test::use::ok'         => '1.301001_075',
            'Unicode::UCD'          => '0.59',
            'XS::APItest'           => '0.68',
            'XSLoader'              => '0.19',
            'experimental'          => '0.013',
            'locale'                => '1.05',
            'ok'                    => '1.301001_075',
            'overload'              => '1.24',
            're'                    => '0.28',
            'warnings'              => '1.29',
        },
        removed => {
        }
    },
    5.021007 => {
        delta_from => 5.021006,
        changed => {
            'Archive::Tar'          => '2.04',
            'Archive::Tar::Constant'=> '2.04',
            'Archive::Tar::File'    => '2.04',
            'B'                     => '1.54',
            'B::Concise'            => '0.996',
            'B::Deparse'            => '1.31',
            'B::Op_private'         => '5.021007',
            'B::Showlex'            => '1.05',
            'Compress::Raw::Bzip2'  => '2.067',
            'Compress::Raw::Zlib'   => '2.067',
            'Compress::Zlib'        => '2.067',
            'Config'                => '5.021007',
            'Cwd'                   => '3.54',
            'DB_File'               => '1.834',
            'Data::Dumper'          => '2.155',
            'Devel::PPPort'         => '3.25',
            'Devel::Peek'           => '1.20',
            'DynaLoader'            => '1.29',
            'Encode'                => '2.67',
            'Errno'                 => '1.22',
            'ExtUtils::CBuilder'    => '0.280221',
            'ExtUtils::CBuilder::Base'=> '0.280221',
            'ExtUtils::CBuilder::Platform::Unix'=> '0.280221',
            'ExtUtils::CBuilder::Platform::VMS'=> '0.280221',
            'ExtUtils::CBuilder::Platform::Windows'=> '0.280221',
            'ExtUtils::CBuilder::Platform::aix'=> '0.280221',
            'ExtUtils::CBuilder::Platform::android'=> '0.280221',
            'ExtUtils::CBuilder::Platform::cygwin'=> '0.280221',
            'ExtUtils::CBuilder::Platform::darwin'=> '0.280221',
            'ExtUtils::CBuilder::Platform::dec_osf'=> '0.280221',
            'ExtUtils::CBuilder::Platform::os2'=> '0.280221',
            'ExtUtils::Command::MM' => '7.04',
            'ExtUtils::Liblist'     => '7.04',
            'ExtUtils::Liblist::Kid'=> '7.04',
            'ExtUtils::MM'          => '7.04',
            'ExtUtils::MM_AIX'      => '7.04',
            'ExtUtils::MM_Any'      => '7.04',
            'ExtUtils::MM_BeOS'     => '7.04',
            'ExtUtils::MM_Cygwin'   => '7.04',
            'ExtUtils::MM_DOS'      => '7.04',
            'ExtUtils::MM_Darwin'   => '7.04',
            'ExtUtils::MM_MacOS'    => '7.04',
            'ExtUtils::MM_NW5'      => '7.04',
            'ExtUtils::MM_OS2'      => '7.04',
            'ExtUtils::MM_QNX'      => '7.04',
            'ExtUtils::MM_UWIN'     => '7.04',
            'ExtUtils::MM_Unix'     => '7.04',
            'ExtUtils::MM_VMS'      => '7.04',
            'ExtUtils::MM_VOS'      => '7.04',
            'ExtUtils::MM_Win32'    => '7.04',
            'ExtUtils::MM_Win95'    => '7.04',
            'ExtUtils::MY'          => '7.04',
            'ExtUtils::MakeMaker'   => '7.04',
            'ExtUtils::MakeMaker::Config'=> '7.04',
            'ExtUtils::MakeMaker::Locale'=> '7.04',
            'ExtUtils::MakeMaker::version'=> '7.04',
            'ExtUtils::MakeMaker::version::regex'=> '7.04',
            'ExtUtils::MakeMaker::version::vpp'=> '7.04',
            'ExtUtils::Mkbootstrap' => '7.04',
            'ExtUtils::Mksymlists'  => '7.04',
            'ExtUtils::ParseXS'     => '3.27',
            'ExtUtils::ParseXS::Constants'=> '3.27',
            'ExtUtils::ParseXS::CountLines'=> '3.27',
            'ExtUtils::ParseXS::Eval'=> '3.27',
            'ExtUtils::ParseXS::Utilities'=> '3.27',
            'ExtUtils::testlib'     => '7.04',
            'File::Spec'            => '3.53',
            'File::Spec::Cygwin'    => '3.54',
            'File::Spec::Epoc'      => '3.54',
            'File::Spec::Functions' => '3.54',
            'File::Spec::Mac'       => '3.54',
            'File::Spec::OS2'       => '3.54',
            'File::Spec::Unix'      => '3.54',
            'File::Spec::VMS'       => '3.54',
            'File::Spec::Win32'     => '3.54',
            'Filter::Util::Call'    => '1.51',
            'HTTP::Tiny'            => '0.053',
            'IO'                    => '1.35',
            'IO::Compress::Adapter::Bzip2'=> '2.067',
            'IO::Compress::Adapter::Deflate'=> '2.067',
            'IO::Compress::Adapter::Identity'=> '2.067',
            'IO::Compress::Base'    => '2.067',
            'IO::Compress::Base::Common'=> '2.067',
            'IO::Compress::Bzip2'   => '2.067',
            'IO::Compress::Deflate' => '2.067',
            'IO::Compress::Gzip'    => '2.067',
            'IO::Compress::Gzip::Constants'=> '2.067',
            'IO::Compress::RawDeflate'=> '2.067',
            'IO::Compress::Zip'     => '2.067',
            'IO::Compress::Zip::Constants'=> '2.067',
            'IO::Compress::Zlib::Constants'=> '2.067',
            'IO::Compress::Zlib::Extra'=> '2.067',
            'IO::Socket::IP'        => '0.34',
            'IO::Uncompress::Adapter::Bunzip2'=> '2.067',
            'IO::Uncompress::Adapter::Identity'=> '2.067',
            'IO::Uncompress::Adapter::Inflate'=> '2.067',
            'IO::Uncompress::AnyInflate'=> '2.067',
            'IO::Uncompress::AnyUncompress'=> '2.067',
            'IO::Uncompress::Base'  => '2.067',
            'IO::Uncompress::Bunzip2'=> '2.067',
            'IO::Uncompress::Gunzip'=> '2.067',
            'IO::Uncompress::Inflate'=> '2.067',
            'IO::Uncompress::RawInflate'=> '2.067',
            'IO::Uncompress::Unzip' => '2.067',
            'Locale::Codes'         => '3.33',
            'Locale::Codes::Constants'=> '3.33',
            'Locale::Codes::Country'=> '3.33',
            'Locale::Codes::Country_Codes'=> '3.33',
            'Locale::Codes::Country_Retired'=> '3.33',
            'Locale::Codes::Currency'=> '3.33',
            'Locale::Codes::Currency_Codes'=> '3.33',
            'Locale::Codes::Currency_Retired'=> '3.33',
            'Locale::Codes::LangExt'=> '3.33',
            'Locale::Codes::LangExt_Codes'=> '3.33',
            'Locale::Codes::LangExt_Retired'=> '3.33',
            'Locale::Codes::LangFam'=> '3.33',
            'Locale::Codes::LangFam_Codes'=> '3.33',
            'Locale::Codes::LangFam_Retired'=> '3.33',
            'Locale::Codes::LangVar'=> '3.33',
            'Locale::Codes::LangVar_Codes'=> '3.33',
            'Locale::Codes::LangVar_Retired'=> '3.33',
            'Locale::Codes::Language'=> '3.33',
            'Locale::Codes::Language_Codes'=> '3.33',
            'Locale::Codes::Language_Retired'=> '3.33',
            'Locale::Codes::Script' => '3.33',
            'Locale::Codes::Script_Codes'=> '3.33',
            'Locale::Codes::Script_Retired'=> '3.33',
            'Locale::Country'       => '3.33',
            'Locale::Currency'      => '3.33',
            'Locale::Language'      => '3.33',
            'Locale::Maketext'      => '1.26',
            'Locale::Script'        => '3.33',
            'Module::CoreList'      => '5.20141220',
            'Module::CoreList::TieHashDelta'=> '5.20141220',
            'Module::CoreList::Utils'=> '5.20141220',
            'NDBM_File'             => '1.14',
            'Net::Cmd'              => '3.04',
            'Net::Config'           => '3.04',
            'Net::Domain'           => '3.04',
            'Net::FTP'              => '3.04',
            'Net::FTP::A'           => '3.04',
            'Net::FTP::E'           => '3.04',
            'Net::FTP::I'           => '3.04',
            'Net::FTP::L'           => '3.04',
            'Net::FTP::dataconn'    => '3.04',
            'Net::NNTP'             => '3.04',
            'Net::Netrc'            => '3.04',
            'Net::POP3'             => '3.04',
            'Net::SMTP'             => '3.04',
            'Net::Time'             => '3.04',
            'Opcode'                => '1.30',
            'POSIX'                 => '1.48',
            'PerlIO::scalar'        => '0.21',
            'Pod::Escapes'          => '1.07',
            'SDBM_File'             => '1.12',
            'Storable'              => '2.52',
            'Sys::Hostname'         => '1.20',
            'Test::Builder'         => '1.301001_090',
            'Test::Builder::Module' => '1.301001_090',
            'Test::Builder::Tester' => '1.301001_090',
            'Test::Builder::Tester::Color'=> '1.301001_090',
            'Test::CanFork'         => undef,
            'Test::CanThread'       => undef,
            'Test::More'            => '1.301001_090',
            'Test::Simple'          => '1.301001_090',
            'Test::Stream'          => '1.301001_090',
            'Test::Stream::API'     => undef,
            'Test::Stream::ForceExit'=> undef,
            'Test::Stream::Subtest' => undef,
            'Test::Tester'          => '1.301001_090',
            'Test::use::ok'         => '1.301001_090',
            'Unicode::Collate'      => '1.09',
            'Unicode::Collate::CJK::Big5'=> '1.09',
            'Unicode::Collate::CJK::GB2312'=> '1.09',
            'Unicode::Collate::CJK::JISX0208'=> '1.09',
            'Unicode::Collate::CJK::Korean'=> '1.09',
            'Unicode::Collate::CJK::Pinyin'=> '1.09',
            'Unicode::Collate::CJK::Stroke'=> '1.09',
            'Unicode::Collate::CJK::Zhuyin'=> '1.09',
            'Unicode::Collate::Locale'=> '1.09',
            'XS::APItest'           => '0.69',
            'XSLoader'              => '0.20',
            '_charnames'            => '1.43',
            'arybase'               => '0.09',
            'charnames'             => '1.43',
            'feature'               => '1.39',
            'mro'                   => '1.17',
            'ok'                    => '1.301001_090',
            'strict'                => '1.09',
            'threads'               => '1.96_001',
        },
        removed => {
        }
    },
    5.021008 => {
        delta_from => 5.021007,
        changed => {
            'App::Prove'            => '3.35',
            'App::Prove::State'     => '3.35',
            'App::Prove::State::Result'=> '3.35',
            'App::Prove::State::Result::Test'=> '3.35',
            'B'                     => '1.55',
            'B::Deparse'            => '1.32',
            'B::Op_private'         => '5.021008',
            'CPAN::Meta::Requirements'=> '2.131',
            'Compress::Raw::Bzip2'  => '2.068',
            'Compress::Raw::Zlib'   => '2.068',
            'Compress::Zlib'        => '2.068',
            'Config'                => '5.021008',
            'DB_File'               => '1.835',
            'Data::Dumper'          => '2.156',
            'Devel::PPPort'         => '3.28',
            'Devel::Peek'           => '1.21',
            'Digest::MD5'           => '2.54',
            'Digest::SHA'           => '5.95',
            'DynaLoader'            => '1.30',
            'ExtUtils::Command'     => '1.20',
            'ExtUtils::Manifest'    => '1.70',
            'Fatal'                 => '2.26',
            'File::Glob'            => '1.24',
            'Filter::Util::Call'    => '1.54',
            'Getopt::Long'          => '2.43',
            'IO::Compress::Adapter::Bzip2'=> '2.068',
            'IO::Compress::Adapter::Deflate'=> '2.068',
            'IO::Compress::Adapter::Identity'=> '2.068',
            'IO::Compress::Base'    => '2.068',
            'IO::Compress::Base::Common'=> '2.068',
            'IO::Compress::Bzip2'   => '2.068',
            'IO::Compress::Deflate' => '2.068',
            'IO::Compress::Gzip'    => '2.068',
            'IO::Compress::Gzip::Constants'=> '2.068',
            'IO::Compress::RawDeflate'=> '2.068',
            'IO::Compress::Zip'     => '2.068',
            'IO::Compress::Zip::Constants'=> '2.068',
            'IO::Compress::Zlib::Constants'=> '2.068',
            'IO::Compress::Zlib::Extra'=> '2.068',
            'IO::Socket::IP'        => '0.36',
            'IO::Uncompress::Adapter::Bunzip2'=> '2.068',
            'IO::Uncompress::Adapter::Identity'=> '2.068',
            'IO::Uncompress::Adapter::Inflate'=> '2.068',
            'IO::Uncompress::AnyInflate'=> '2.068',
            'IO::Uncompress::AnyUncompress'=> '2.068',
            'IO::Uncompress::Base'  => '2.068',
            'IO::Uncompress::Bunzip2'=> '2.068',
            'IO::Uncompress::Gunzip'=> '2.068',
            'IO::Uncompress::Inflate'=> '2.068',
            'IO::Uncompress::RawInflate'=> '2.068',
            'IO::Uncompress::Unzip' => '2.068',
            'MIME::Base64'          => '3.15',
            'Module::CoreList'      => '5.20150220',
            'Module::CoreList::TieHashDelta'=> '5.20150220',
            'Module::CoreList::Utils'=> '5.20150220',
            'Module::Load::Conditional'=> '0.64',
            'Module::Metadata'      => '1.000026',
            'Net::Cmd'              => '3.05',
            'Net::Config'           => '3.05',
            'Net::Domain'           => '3.05',
            'Net::FTP'              => '3.05',
            'Net::FTP::A'           => '3.05',
            'Net::FTP::E'           => '3.05',
            'Net::FTP::I'           => '3.05',
            'Net::FTP::L'           => '3.05',
            'Net::FTP::dataconn'    => '3.05',
            'Net::NNTP'             => '3.05',
            'Net::Netrc'            => '3.05',
            'Net::POP3'             => '3.05',
            'Net::SMTP'             => '3.05',
            'Net::Time'             => '3.05',
            'Opcode'                => '1.31',
            'POSIX'                 => '1.49',
            'PerlIO::encoding'      => '0.21',
            'Pod::Simple'           => '3.29',
            'Pod::Simple::BlackBox' => '3.29',
            'Pod::Simple::Checker'  => '3.29',
            'Pod::Simple::Debug'    => '3.29',
            'Pod::Simple::DumpAsText'=> '3.29',
            'Pod::Simple::DumpAsXML'=> '3.29',
            'Pod::Simple::HTML'     => '3.29',
            'Pod::Simple::HTMLBatch'=> '3.29',
            'Pod::Simple::LinkSection'=> '3.29',
            'Pod::Simple::Methody'  => '3.29',
            'Pod::Simple::Progress' => '3.29',
            'Pod::Simple::PullParser'=> '3.29',
            'Pod::Simple::PullParserEndToken'=> '3.29',
            'Pod::Simple::PullParserStartToken'=> '3.29',
            'Pod::Simple::PullParserTextToken'=> '3.29',
            'Pod::Simple::PullParserToken'=> '3.29',
            'Pod::Simple::RTF'      => '3.29',
            'Pod::Simple::Search'   => '3.29',
            'Pod::Simple::SimpleTree'=> '3.29',
            'Pod::Simple::Text'     => '3.29',
            'Pod::Simple::TextContent'=> '3.29',
            'Pod::Simple::TiedOutFH'=> '3.29',
            'Pod::Simple::Transcode'=> '3.29',
            'Pod::Simple::TranscodeDumb'=> '3.29',
            'Pod::Simple::TranscodeSmart'=> '3.29',
            'Pod::Simple::XHTML'    => '3.29',
            'Pod::Simple::XMLOutStream'=> '3.29',
            'SDBM_File'             => '1.13',
            'Safe'                  => '2.39',
            'TAP::Base'             => '3.35',
            'TAP::Formatter::Base'  => '3.35',
            'TAP::Formatter::Color' => '3.35',
            'TAP::Formatter::Console'=> '3.35',
            'TAP::Formatter::Console::ParallelSession'=> '3.35',
            'TAP::Formatter::Console::Session'=> '3.35',
            'TAP::Formatter::File'  => '3.35',
            'TAP::Formatter::File::Session'=> '3.35',
            'TAP::Formatter::Session'=> '3.35',
            'TAP::Harness'          => '3.35',
            'TAP::Harness::Env'     => '3.35',
            'TAP::Object'           => '3.35',
            'TAP::Parser'           => '3.35',
            'TAP::Parser::Aggregator'=> '3.35',
            'TAP::Parser::Grammar'  => '3.35',
            'TAP::Parser::Iterator' => '3.35',
            'TAP::Parser::Iterator::Array'=> '3.35',
            'TAP::Parser::Iterator::Process'=> '3.35',
            'TAP::Parser::Iterator::Stream'=> '3.35',
            'TAP::Parser::IteratorFactory'=> '3.35',
            'TAP::Parser::Multiplexer'=> '3.35',
            'TAP::Parser::Result'   => '3.35',
            'TAP::Parser::Result::Bailout'=> '3.35',
            'TAP::Parser::Result::Comment'=> '3.35',
            'TAP::Parser::Result::Plan'=> '3.35',
            'TAP::Parser::Result::Pragma'=> '3.35',
            'TAP::Parser::Result::Test'=> '3.35',
            'TAP::Parser::Result::Unknown'=> '3.35',
            'TAP::Parser::Result::Version'=> '3.35',
            'TAP::Parser::Result::YAML'=> '3.35',
            'TAP::Parser::ResultFactory'=> '3.35',
            'TAP::Parser::Scheduler'=> '3.35',
            'TAP::Parser::Scheduler::Job'=> '3.35',
            'TAP::Parser::Scheduler::Spinner'=> '3.35',
            'TAP::Parser::Source'   => '3.35',
            'TAP::Parser::SourceHandler'=> '3.35',
            'TAP::Parser::SourceHandler::Executable'=> '3.35',
            'TAP::Parser::SourceHandler::File'=> '3.35',
            'TAP::Parser::SourceHandler::Handle'=> '3.35',
            'TAP::Parser::SourceHandler::Perl'=> '3.35',
            'TAP::Parser::SourceHandler::RawTAP'=> '3.35',
            'TAP::Parser::YAMLish::Reader'=> '3.35',
            'TAP::Parser::YAMLish::Writer'=> '3.35',
            'Test::Builder'         => '1.301001_097',
            'Test::Builder::Module' => '1.301001_097',
            'Test::Builder::Tester' => '1.301001_097',
            'Test::Builder::Tester::Color'=> '1.301001_097',
            'Test::Harness'         => '3.35',
            'Test::More'            => '1.301001_097',
            'Test::Simple'          => '1.301001_097',
            'Test::Stream'          => '1.301001_097',
            'Test::Stream::Block'   => undef,
            'Test::Tester'          => '1.301001_097',
            'Test::Tester::CaptureRunner'=> undef,
            'Test::Tester::Delegate'=> undef,
            'Test::use::ok'         => '1.301001_097',
            'Unicode::Collate'      => '1.10',
            'Unicode::Collate::CJK::Big5'=> '1.10',
            'Unicode::Collate::CJK::GB2312'=> '1.10',
            'Unicode::Collate::CJK::JISX0208'=> '1.10',
            'Unicode::Collate::CJK::Korean'=> '1.10',
            'Unicode::Collate::CJK::Pinyin'=> '1.10',
            'Unicode::Collate::CJK::Stroke'=> '1.10',
            'Unicode::Collate::CJK::Zhuyin'=> '1.10',
            'Unicode::Collate::Locale'=> '1.10',
            'VMS::DCLsym'           => '1.06',
            'XS::APItest'           => '0.70',
            'arybase'               => '0.10',
            'attributes'            => '0.25',
            'autodie'               => '2.26',
            'autodie::Scope::Guard' => '2.26',
            'autodie::Scope::GuardStack'=> '2.26',
            'autodie::ScopeUtil'    => '2.26',
            'autodie::exception'    => '2.26',
            'autodie::exception::system'=> '2.26',
            'autodie::hints'        => '2.26',
            'autodie::skip'         => '2.26',
            'ok'                    => '1.301001_097',
            're'                    => '0.30',
            'warnings'              => '1.30',
        },
        removed => {
        }
    },
    5.020002 => {
        delta_from => 5.020001,
        changed => {
            'CPAN::Author'          => '5.5002',
            'CPAN::CacheMgr'        => '5.5002',
            'CPAN::FTP'             => '5.5006',
            'CPAN::HTTP::Client'    => '1.9601',
            'CPAN::HandleConfig'    => '5.5005',
            'CPAN::Index'           => '1.9601',
            'CPAN::LWP::UserAgent'  => '1.9601',
            'CPAN::Mirrors'         => '1.9601',
            'Config'                => '5.020002',
            'Cwd'                   => '3.48_01',
            'Data::Dumper'          => '2.151_01',
            'Errno'                 => '1.20_05',
            'File::Spec'            => '3.48_01',
            'File::Spec::Cygwin'    => '3.48_01',
            'File::Spec::Epoc'      => '3.48_01',
            'File::Spec::Functions' => '3.48_01',
            'File::Spec::Mac'       => '3.48_01',
            'File::Spec::OS2'       => '3.48_01',
            'File::Spec::Unix'      => '3.48_01',
            'File::Spec::VMS'       => '3.48_01',
            'File::Spec::Win32'     => '3.48_01',
            'IO::Socket'            => '1.38',
            'Module::CoreList'      => '5.20150214',
            'Module::CoreList::TieHashDelta'=> '5.20150214',
            'Module::CoreList::Utils'=> '5.20150214',
            'PerlIO::scalar'        => '0.18_01',
            'Pod::PlainText'        => '2.07',
            'Storable'              => '2.49_01',
            'VMS::DCLsym'           => '1.05_01',
            'VMS::Stdio'            => '2.41',
            'attributes'            => '0.23',
            'feature'               => '1.36_01',
        },
        removed => {
        }
    },
    5.021009 => {
        delta_from => 5.021008,
        changed => {
            'B'                     => '1.56',
            'B::Debug'              => '1.23',
            'B::Deparse'            => '1.33',
            'B::Op_private'         => '5.021009',
            'Benchmark'             => '1.20',
            'CPAN::Author'          => '5.5002',
            'CPAN::CacheMgr'        => '5.5002',
            'CPAN::FTP'             => '5.5006',
            'CPAN::HTTP::Client'    => '1.9601',
            'CPAN::HandleConfig'    => '5.5005',
            'CPAN::Index'           => '1.9601',
            'CPAN::LWP::UserAgent'  => '1.9601',
            'CPAN::Meta::Requirements'=> '2.132',
            'CPAN::Mirrors'         => '1.9601',
            'Carp'                  => '1.35',
            'Carp::Heavy'           => '1.35',
            'Config'                => '5.021009',
            'Config::Perl::V'       => '0.23',
            'Data::Dumper'          => '2.157',
            'Devel::Peek'           => '1.22',
            'DynaLoader'            => '1.31',
            'Encode'                => '2.70',
            'Encode::MIME::Header'  => '2.16',
            'Errno'                 => '1.23',
            'ExtUtils::Miniperl'    => '1.04',
            'HTTP::Tiny'            => '0.054',
            'Module::CoreList'      => '5.20150220',
            'Module::CoreList::TieHashDelta'=> '5.20150220',
            'Module::CoreList::Utils'=> '5.20150220',
            'Opcode'                => '1.32',
            'POSIX'                 => '1.51',
            'Perl::OSType'          => '1.008',
            'PerlIO::scalar'        => '0.22',
            'Pod::Find'             => '1.63',
            'Pod::InputObjects'     => '1.63',
            'Pod::ParseUtils'       => '1.63',
            'Pod::Parser'           => '1.63',
            'Pod::Perldoc'          => '3.25',
            'Pod::Perldoc::BaseTo'  => '3.25',
            'Pod::Perldoc::GetOptsOO'=> '3.25',
            'Pod::Perldoc::ToANSI'  => '3.25',
            'Pod::Perldoc::ToChecker'=> '3.25',
            'Pod::Perldoc::ToMan'   => '3.25',
            'Pod::Perldoc::ToNroff' => '3.25',
            'Pod::Perldoc::ToPod'   => '3.25',
            'Pod::Perldoc::ToRtf'   => '3.25',
            'Pod::Perldoc::ToTerm'  => '3.25',
            'Pod::Perldoc::ToText'  => '3.25',
            'Pod::Perldoc::ToTk'    => '3.25',
            'Pod::Perldoc::ToXml'   => '3.25',
            'Pod::PlainText'        => '2.07',
            'Pod::Select'           => '1.63',
            'Socket'                => '2.018',
            'Storable'              => '2.53',
            'Test::Builder'         => '1.301001_098',
            'Test::Builder::Module' => '1.301001_098',
            'Test::Builder::Tester' => '1.301001_098',
            'Test::Builder::Tester::Color'=> '1.301001_098',
            'Test::More'            => '1.301001_098',
            'Test::Simple'          => '1.301001_098',
            'Test::Stream'          => '1.301001_098',
            'Test::Tester'          => '1.301001_098',
            'Test::use::ok'         => '1.301001_098',
            'Unicode::Collate'      => '1.11',
            'Unicode::Collate::CJK::Big5'=> '1.11',
            'Unicode::Collate::CJK::GB2312'=> '1.11',
            'Unicode::Collate::CJK::JISX0208'=> '1.11',
            'Unicode::Collate::CJK::Korean'=> '1.11',
            'Unicode::Collate::CJK::Pinyin'=> '1.11',
            'Unicode::Collate::CJK::Stroke'=> '1.11',
            'Unicode::Collate::CJK::Zhuyin'=> '1.11',
            'Unicode::Collate::Locale'=> '1.11',
            'Unicode::UCD'          => '0.61',
            'VMS::Stdio'            => '2.41',
            'Win32'                 => '0.51',
            'Win32API::File'        => '0.1202',
            'attributes'            => '0.26',
            'bigint'                => '0.39',
            'bignum'                => '0.39',
            'bigrat'                => '0.39',
            'constant'              => '1.33',
            'encoding'              => '2.13',
            'feature'               => '1.40',
            'ok'                    => '1.301001_098',
            'overload'              => '1.25',
            'perlfaq'               => '5.021009',
            're'                    => '0.31',
            'threads::shared'       => '1.48',
            'warnings'              => '1.31',
        },
        removed => {
        }
    },
    5.021010 => {
        delta_from => 5.021009,
        changed => {
            'App::Cpan'             => '1.63',
            'B'                     => '1.57',
            'B::Deparse'            => '1.34',
            'B::Op_private'         => '5.021010',
            'Benchmark'             => '1.2',
            'CPAN'                  => '2.10',
            'CPAN::Distribution'    => '2.04',
            'CPAN::FirstTime'       => '5.5307',
            'CPAN::HTTP::Credentials'=> '1.9601',
            'CPAN::HandleConfig'    => '5.5006',
            'CPAN::Meta'            => '2.150001',
            'CPAN::Meta::Converter' => '2.150001',
            'CPAN::Meta::Feature'   => '2.150001',
            'CPAN::Meta::History'   => '2.150001',
            'CPAN::Meta::Merge'     => '2.150001',
            'CPAN::Meta::Prereqs'   => '2.150001',
            'CPAN::Meta::Spec'      => '2.150001',
            'CPAN::Meta::Validator' => '2.150001',
            'CPAN::Module'          => '5.5002',
            'CPAN::Plugin'          => '0.95',
            'CPAN::Plugin::Specfile'=> '0.01',
            'CPAN::Shell'           => '5.5005',
            'Carp'                  => '1.36',
            'Carp::Heavy'           => '1.36',
            'Config'                => '5.02101',
            'Cwd'                   => '3.55',
            'DB'                    => '1.08',
            'Data::Dumper'          => '2.158',
            'Devel::PPPort'         => '3.31',
            'DynaLoader'            => '1.32',
            'Encode'                => '2.72',
            'Encode::Alias'         => '2.19',
            'File::Spec'            => '3.55',
            'File::Spec::Cygwin'    => '3.55',
            'File::Spec::Epoc'      => '3.55',
            'File::Spec::Functions' => '3.55',
            'File::Spec::Mac'       => '3.55',
            'File::Spec::OS2'       => '3.55',
            'File::Spec::Unix'      => '3.55',
            'File::Spec::VMS'       => '3.55',
            'File::Spec::Win32'     => '3.55',
            'Getopt::Long'          => '2.45',
            'Locale::Codes'         => '3.34',
            'Locale::Codes::Constants'=> '3.34',
            'Locale::Codes::Country'=> '3.34',
            'Locale::Codes::Country_Codes'=> '3.34',
            'Locale::Codes::Country_Retired'=> '3.34',
            'Locale::Codes::Currency'=> '3.34',
            'Locale::Codes::Currency_Codes'=> '3.34',
            'Locale::Codes::Currency_Retired'=> '3.34',
            'Locale::Codes::LangExt'=> '3.34',
            'Locale::Codes::LangExt_Codes'=> '3.34',
            'Locale::Codes::LangExt_Retired'=> '3.34',
            'Locale::Codes::LangFam'=> '3.34',
            'Locale::Codes::LangFam_Codes'=> '3.34',
            'Locale::Codes::LangFam_Retired'=> '3.34',
            'Locale::Codes::LangVar'=> '3.34',
            'Locale::Codes::LangVar_Codes'=> '3.34',
            'Locale::Codes::LangVar_Retired'=> '3.34',
            'Locale::Codes::Language'=> '3.34',
            'Locale::Codes::Language_Codes'=> '3.34',
            'Locale::Codes::Language_Retired'=> '3.34',
            'Locale::Codes::Script' => '3.34',
            'Locale::Codes::Script_Codes'=> '3.34',
            'Locale::Codes::Script_Retired'=> '3.34',
            'Locale::Country'       => '3.34',
            'Locale::Currency'      => '3.34',
            'Locale::Language'      => '3.34',
            'Locale::Script'        => '3.34',
            'Module::CoreList'      => '5.20150320',
            'Module::CoreList::TieHashDelta'=> '5.20150320',
            'Module::CoreList::Utils'=> '5.20150320',
            'POSIX'                 => '1.52',
            'Pod::Functions'        => '1.09',
            'Pod::Functions::Functions'=> '1.09',
            'Term::Complete'        => '1.403',
            'Test::Builder'         => '1.001014',
            'Test::Builder::IO::Scalar'=> '2.113',
            'Test::Builder::Module' => '1.001014',
            'Test::Builder::Tester' => '1.28',
            'Test::Builder::Tester::Color'=> '1.290001',
            'Test::More'            => '1.001014',
            'Test::Simple'          => '1.001014',
            'Test::Tester'          => '0.114',
            'Test::use::ok'         => '0.16',
            'Text::Balanced'        => '2.03',
            'Text::ParseWords'      => '3.30',
            'Unicode::Collate'      => '1.12',
            'Unicode::Collate::CJK::Big5'=> '1.12',
            'Unicode::Collate::CJK::GB2312'=> '1.12',
            'Unicode::Collate::CJK::JISX0208'=> '1.12',
            'Unicode::Collate::CJK::Korean'=> '1.12',
            'Unicode::Collate::CJK::Pinyin'=> '1.12',
            'Unicode::Collate::CJK::Stroke'=> '1.12',
            'Unicode::Collate::CJK::Zhuyin'=> '1.12',
            'Unicode::Collate::Locale'=> '1.12',
            'XS::APItest'           => '0.71',
            'encoding'              => '2.14',
            'locale'                => '1.06',
            'meta_notation'         => undef,
            'ok'                    => '0.16',
            'parent'                => '0.232',
            're'                    => '0.32',
            'sigtrap'               => '1.08',
            'threads'               => '2.01',
            'utf8'                  => '1.15',
        },
        removed => {
            'Test::CanFork'         => 1,
            'Test::CanThread'       => 1,
            'Test::More::DeepCheck' => 1,
            'Test::More::DeepCheck::Strict'=> 1,
            'Test::More::DeepCheck::Tolerant'=> 1,
            'Test::More::Tools'     => 1,
            'Test::MostlyLike'      => 1,
            'Test::Stream'          => 1,
            'Test::Stream::API'     => 1,
            'Test::Stream::ArrayBase'=> 1,
            'Test::Stream::ArrayBase::Meta'=> 1,
            'Test::Stream::Block'   => 1,
            'Test::Stream::Carp'    => 1,
            'Test::Stream::Context' => 1,
            'Test::Stream::Event'   => 1,
            'Test::Stream::Event::Bail'=> 1,
            'Test::Stream::Event::Child'=> 1,
            'Test::Stream::Event::Diag'=> 1,
            'Test::Stream::Event::Finish'=> 1,
            'Test::Stream::Event::Note'=> 1,
            'Test::Stream::Event::Ok'=> 1,
            'Test::Stream::Event::Plan'=> 1,
            'Test::Stream::Event::Subtest'=> 1,
            'Test::Stream::ExitMagic'=> 1,
            'Test::Stream::ExitMagic::Context'=> 1,
            'Test::Stream::Exporter'=> 1,
            'Test::Stream::Exporter::Meta'=> 1,
            'Test::Stream::ForceExit'=> 1,
            'Test::Stream::IOSets'  => 1,
            'Test::Stream::Meta'    => 1,
            'Test::Stream::PackageUtil'=> 1,
            'Test::Stream::Subtest' => 1,
            'Test::Stream::Tester'  => 1,
            'Test::Stream::Tester::Checks'=> 1,
            'Test::Stream::Tester::Checks::Event'=> 1,
            'Test::Stream::Tester::Events'=> 1,
            'Test::Stream::Tester::Events::Event'=> 1,
            'Test::Stream::Tester::Grab'=> 1,
            'Test::Stream::Threads' => 1,
            'Test::Stream::Toolset' => 1,
            'Test::Stream::Util'    => 1,
        }
    },
    5.021011 => {
        delta_from => 5.021010,
        changed => {
            'B'                     => '1.58',
            'B::Deparse'            => '1.35',
            'B::Op_private'         => '5.021011',
            'CPAN'                  => '2.11',
            'Config'                => '5.021011',
            'Config::Perl::V'       => '0.24',
            'Cwd'                   => '3.56',
            'ExtUtils::Miniperl'    => '1.05',
            'ExtUtils::ParseXS'     => '3.28',
            'ExtUtils::ParseXS::Constants'=> '3.28',
            'ExtUtils::ParseXS::CountLines'=> '3.28',
            'ExtUtils::ParseXS::Eval'=> '3.28',
            'ExtUtils::ParseXS::Utilities'=> '3.28',
            'ExtUtils::Typemaps'    => '3.28',
            'ExtUtils::Typemaps::Cmd'=> '3.28',
            'ExtUtils::Typemaps::InputMap'=> '3.28',
            'ExtUtils::Typemaps::OutputMap'=> '3.28',
            'ExtUtils::Typemaps::Type'=> '3.28',
            'File::Spec'            => '3.56',
            'File::Spec::Cygwin'    => '3.56',
            'File::Spec::Epoc'      => '3.56',
            'File::Spec::Functions' => '3.56',
            'File::Spec::Mac'       => '3.56',
            'File::Spec::OS2'       => '3.56',
            'File::Spec::Unix'      => '3.56',
            'File::Spec::VMS'       => '3.56',
            'File::Spec::Win32'     => '3.56',
            'IO::Socket::IP'        => '0.37',
            'Module::CoreList'      => '5.20150420',
            'Module::CoreList::TieHashDelta'=> '5.20150420',
            'Module::CoreList::Utils'=> '5.20150420',
            'PerlIO::mmap'          => '0.014',
            'XS::APItest'           => '0.72',
            'attributes'            => '0.27',
            'if'                    => '0.0604',
            'utf8'                  => '1.16',
            'warnings'              => '1.32',
        },
        removed => {
        }
    },
    5.022000 => {
        delta_from => 5.021011,
        changed => {
            'B::Op_private'         => '5.022000',
            'Config'                => '5.022',
            'ExtUtils::Command::MM' => '7.04_01',
            'ExtUtils::Liblist'     => '7.04_01',
            'ExtUtils::Liblist::Kid'=> '7.04_01',
            'ExtUtils::MM'          => '7.04_01',
            'ExtUtils::MM_AIX'      => '7.04_01',
            'ExtUtils::MM_Any'      => '7.04_01',
            'ExtUtils::MM_BeOS'     => '7.04_01',
            'ExtUtils::MM_Cygwin'   => '7.04_01',
            'ExtUtils::MM_DOS'      => '7.04_01',
            'ExtUtils::MM_Darwin'   => '7.04_01',
            'ExtUtils::MM_MacOS'    => '7.04_01',
            'ExtUtils::MM_NW5'      => '7.04_01',
            'ExtUtils::MM_OS2'      => '7.04_01',
            'ExtUtils::MM_QNX'      => '7.04_01',
            'ExtUtils::MM_UWIN'     => '7.04_01',
            'ExtUtils::MM_Unix'     => '7.04_01',
            'ExtUtils::MM_VMS'      => '7.04_01',
            'ExtUtils::MM_VOS'      => '7.04_01',
            'ExtUtils::MM_Win32'    => '7.04_01',
            'ExtUtils::MM_Win95'    => '7.04_01',
            'ExtUtils::MY'          => '7.04_01',
            'ExtUtils::MakeMaker'   => '7.04_01',
            'ExtUtils::MakeMaker::Config'=> '7.04_01',
            'ExtUtils::MakeMaker::Locale'=> '7.04_01',
            'ExtUtils::MakeMaker::version'=> '7.04_01',
            'ExtUtils::MakeMaker::version::regex'=> '7.04_01',
            'ExtUtils::MakeMaker::version::vpp'=> '7.04_01',
            'ExtUtils::Mkbootstrap' => '7.04_01',
            'ExtUtils::Mksymlists'  => '7.04_01',
            'ExtUtils::testlib'     => '7.04_01',
            'Module::CoreList'      => '5.20150520',
            'Module::CoreList::TieHashDelta'=> '5.20150520',
            'Module::CoreList::Utils'=> '5.20150520',
            'POSIX'                 => '1.53',
            'PerlIO::via::QuotedPrint'=> '0.08',
            'overload'              => '1.26',
            'utf8'                  => '1.17',
        },
        removed => {
        }
    },
    5.023000 => {
        delta_from => 5.022000,
        changed => {
            'B::Op_private'         => '5.023000',
            'CPAN::Meta'            => '2.150005',
            'CPAN::Meta::Converter' => '2.150005',
            'CPAN::Meta::Feature'   => '2.150005',
            'CPAN::Meta::History'   => '2.150005',
            'CPAN::Meta::Merge'     => '2.150005',
            'CPAN::Meta::Prereqs'   => '2.150005',
            'CPAN::Meta::Requirements'=> '2.133',
            'CPAN::Meta::Spec'      => '2.150005',
            'CPAN::Meta::Validator' => '2.150005',
            'CPAN::Meta::YAML'      => '0.016',
            'Config'                => '5.023',
            'Encode'                => '2.73',
            'ExtUtils::CBuilder'    => '0.280223',
            'ExtUtils::CBuilder::Base'=> '0.280223',
            'ExtUtils::CBuilder::Platform::Unix'=> '0.280223',
            'ExtUtils::CBuilder::Platform::VMS'=> '0.280223',
            'ExtUtils::CBuilder::Platform::Windows'=> '0.280223',
            'ExtUtils::CBuilder::Platform::Windows::BCC'=> '0.280223',
            'ExtUtils::CBuilder::Platform::Windows::GCC'=> '0.280223',
            'ExtUtils::CBuilder::Platform::Windows::MSVC'=> '0.280223',
            'ExtUtils::CBuilder::Platform::aix'=> '0.280223',
            'ExtUtils::CBuilder::Platform::android'=> '0.280223',
            'ExtUtils::CBuilder::Platform::cygwin'=> '0.280223',
            'ExtUtils::CBuilder::Platform::darwin'=> '0.280223',
            'ExtUtils::CBuilder::Platform::dec_osf'=> '0.280223',
            'ExtUtils::CBuilder::Platform::os2'=> '0.280223',
            'Fatal'                 => '2.27',
            'Getopt::Long'          => '2.46',
            'HTTP::Tiny'            => '0.056',
            'List::Util'            => '1.42_01',
            'List::Util::XS'        => '1.42_01',
            'Locale::Codes'         => '3.35',
            'Locale::Codes::Constants'=> '3.35',
            'Locale::Codes::Country'=> '3.35',
            'Locale::Codes::Country_Codes'=> '3.35',
            'Locale::Codes::Country_Retired'=> '3.35',
            'Locale::Codes::Currency'=> '3.35',
            'Locale::Codes::Currency_Codes'=> '3.35',
            'Locale::Codes::Currency_Retired'=> '3.35',
            'Locale::Codes::LangExt'=> '3.35',
            'Locale::Codes::LangExt_Codes'=> '3.35',
            'Locale::Codes::LangExt_Retired'=> '3.35',
            'Locale::Codes::LangFam'=> '3.35',
            'Locale::Codes::LangFam_Codes'=> '3.35',
            'Locale::Codes::LangFam_Retired'=> '3.35',
            'Locale::Codes::LangVar'=> '3.35',
            'Locale::Codes::LangVar_Codes'=> '3.35',
            'Locale::Codes::LangVar_Retired'=> '3.35',
            'Locale::Codes::Language'=> '3.35',
            'Locale::Codes::Language_Codes'=> '3.35',
            'Locale::Codes::Language_Retired'=> '3.35',
            'Locale::Codes::Script' => '3.35',
            'Locale::Codes::Script_Codes'=> '3.35',
            'Locale::Codes::Script_Retired'=> '3.35',
            'Locale::Country'       => '3.35',
            'Locale::Currency'      => '3.35',
            'Locale::Language'      => '3.35',
            'Locale::Script'        => '3.35',
            'Math::BigFloat'        => '1.999701',
            'Math::BigInt'          => '1.999701',
            'Math::BigInt::Calc'    => '1.999701',
            'Math::BigInt::CalcEmu' => '1.999701',
            'Math::BigRat'          => '0.260801',
            'Module::CoreList'      => '5.20150620',
            'Module::CoreList::TieHashDelta'=> '5.20150620',
            'Module::CoreList::Utils'=> '5.20150620',
            'Module::Metadata'      => '1.000027',
            'Net::Cmd'              => '3.06',
            'Net::Config'           => '3.06',
            'Net::Domain'           => '3.06',
            'Net::FTP'              => '3.06',
            'Net::FTP::A'           => '3.06',
            'Net::FTP::E'           => '3.06',
            'Net::FTP::I'           => '3.06',
            'Net::FTP::L'           => '3.06',
            'Net::FTP::dataconn'    => '3.06',
            'Net::NNTP'             => '3.06',
            'Net::Netrc'            => '3.06',
            'Net::POP3'             => '3.06',
            'Net::SMTP'             => '3.06',
            'Net::Time'             => '3.06',
            'POSIX'                 => '1.54',
            'Parse::CPAN::Meta'     => '1.4417',
            'Pod::Simple'           => '3.30',
            'Pod::Simple::BlackBox' => '3.30',
            'Pod::Simple::Checker'  => '3.30',
            'Pod::Simple::Debug'    => '3.30',
            'Pod::Simple::DumpAsText'=> '3.30',
            'Pod::Simple::DumpAsXML'=> '3.30',
            'Pod::Simple::HTML'     => '3.30',
            'Pod::Simple::HTMLBatch'=> '3.30',
            'Pod::Simple::LinkSection'=> '3.30',
            'Pod::Simple::Methody'  => '3.30',
            'Pod::Simple::Progress' => '3.30',
            'Pod::Simple::PullParser'=> '3.30',
            'Pod::Simple::PullParserEndToken'=> '3.30',
            'Pod::Simple::PullParserStartToken'=> '3.30',
            'Pod::Simple::PullParserTextToken'=> '3.30',
            'Pod::Simple::PullParserToken'=> '3.30',
            'Pod::Simple::RTF'      => '3.30',
            'Pod::Simple::Search'   => '3.30',
            'Pod::Simple::SimpleTree'=> '3.30',
            'Pod::Simple::Text'     => '3.30',
            'Pod::Simple::TextContent'=> '3.30',
            'Pod::Simple::TiedOutFH'=> '3.30',
            'Pod::Simple::Transcode'=> '3.30',
            'Pod::Simple::TranscodeDumb'=> '3.30',
            'Pod::Simple::TranscodeSmart'=> '3.30',
            'Pod::Simple::XHTML'    => '3.30',
            'Pod::Simple::XMLOutStream'=> '3.30',
            'Pod::Usage'            => '1.67',
            'Scalar::Util'          => '1.42_01',
            'Socket'                => '2.019',
            'Sub::Util'             => '1.42_01',
            'Time::Piece'           => '1.30',
            'Time::Seconds'         => '1.30',
            'UNIVERSAL'             => '1.13',
            'Unicode'               => '8.0.0',
            'XS::APItest'           => '0.73',
            'autodie'               => '2.27',
            'autodie::Scope::Guard' => '2.27',
            'autodie::Scope::GuardStack'=> '2.27',
            'autodie::Util'         => '2.27',
            'autodie::exception'    => '2.27',
            'autodie::exception::system'=> '2.27',
            'autodie::hints'        => '2.27',
            'autodie::skip'         => '2.27',
            'encoding'              => '2.15',
            'feature'               => '1.41',
            'parent'                => '0.234',
            'threads'               => '2.02',
        },
        removed => {
        }
    },
    5.023001 => {
        delta_from => 5.023000,
        changed => {
            'B::Op_private'         => '5.023001',
            'Config'                => '5.023001',
            'DynaLoader'            => '1.33',
            'Encode'                => '2.75',
            'Encode::MIME::Header'  => '2.17',
            'Encode::Unicode'       => '2.13',
            'Fatal'                 => '2.29',
            'File::Path'            => '2.11',
            'Getopt::Long'          => '2.47',
            'I18N::Langinfo'        => '0.13',
            'IPC::Open3'            => '1.19',
            'Module::CoreList'      => '5.20150720',
            'Module::CoreList::TieHashDelta'=> '5.20150720',
            'Module::CoreList::Utils'=> '5.20150720',
            'Net::Cmd'              => '3.07',
            'Net::Config'           => '3.07',
            'Net::Domain'           => '3.07',
            'Net::FTP'              => '3.07',
            'Net::FTP::A'           => '3.07',
            'Net::FTP::E'           => '3.07',
            'Net::FTP::I'           => '3.07',
            'Net::FTP::L'           => '3.07',
            'Net::FTP::dataconn'    => '3.07',
            'Net::NNTP'             => '3.07',
            'Net::Netrc'            => '3.07',
            'Net::POP3'             => '3.07',
            'Net::SMTP'             => '3.07',
            'Net::Time'             => '3.07',
            'Opcode'                => '1.33',
            'POSIX'                 => '1.55',
            'PerlIO::scalar'        => '0.23',
            'Socket'                => '2.020',
            'Storable'              => '2.54',
            'Unicode::Collate'      => '1.14',
            'Unicode::Collate::CJK::Big5'=> '1.14',
            'Unicode::Collate::CJK::GB2312'=> '1.14',
            'Unicode::Collate::CJK::JISX0208'=> '1.14',
            'Unicode::Collate::CJK::Korean'=> '1.14',
            'Unicode::Collate::CJK::Pinyin'=> '1.14',
            'Unicode::Collate::CJK::Stroke'=> '1.14',
            'Unicode::Collate::CJK::Zhuyin'=> '1.14',
            'Unicode::Collate::Locale'=> '1.14',
            'Unicode::Normalize'    => '1.19',
            'XS::APItest'           => '0.74',
            'XS::Typemap'           => '0.14',
            'autodie'               => '2.29',
            'autodie::Scope::Guard' => '2.29',
            'autodie::Scope::GuardStack'=> '2.29',
            'autodie::Util'         => '2.29',
            'autodie::exception'    => '2.29',
            'autodie::exception::system'=> '2.29',
            'autodie::hints'        => '2.29',
            'autodie::skip'         => '2.29',
            'encoding'              => '2.16',
            'feature'               => '1.42',
            'warnings'              => '1.33',
        },
        removed => {
            'autodie::ScopeUtil'    => 1,
        }
    },
    5.023002 => {
        delta_from => 5.023001,
        changed => {
            'Attribute::Handlers'   => '0.99',
            'B::Op_private'         => '5.023002',
            'CPAN::Meta::YAML'      => '0.017',
            'Config'                => '5.023002',
            'Cwd'                   => '3.57',
            'Encode'                => '2.76',
            'ExtUtils::ParseXS'     => '3.29',
            'ExtUtils::ParseXS::Constants'=> '3.29',
            'ExtUtils::ParseXS::CountLines'=> '3.29',
            'ExtUtils::ParseXS::Eval'=> '3.29',
            'ExtUtils::ParseXS::Utilities'=> '3.29',
            'ExtUtils::Typemaps'    => '3.29',
            'File::Find'            => '1.30',
            'File::Spec'            => '3.57',
            'File::Spec::Cygwin'    => '3.57',
            'File::Spec::Epoc'      => '3.57',
            'File::Spec::Functions' => '3.57',
            'File::Spec::Mac'       => '3.57',
            'File::Spec::OS2'       => '3.57',
            'File::Spec::Unix'      => '3.57',
            'File::Spec::VMS'       => '3.57',
            'File::Spec::Win32'     => '3.57',
            'Filter::Util::Call'    => '1.55',
            'Hash::Util'            => '0.19',
            'Module::CoreList'      => '5.20150820',
            'Module::CoreList::TieHashDelta'=> '5.20150820',
            'Module::CoreList::Utils'=> '5.20150820',
            'POSIX'                 => '1.56',
            'Term::Cap'             => '1.17',
            'Unicode::UCD'          => '0.62',
            'perlfaq'               => '5.021010',
        },
        removed => {
        }
    },
    5.020003 => {
        delta_from => 5.020002,
        changed => {
            'Config'                => '5.020003',
            'Errno'                 => '1.20_06',
            'Module::CoreList'      => '5.20150912',
            'Module::CoreList::TieHashDelta'=> '5.20150912',
            'Module::CoreList::Utils'=> '5.20150912',
        },
        removed => {
        }
    },
    5.023003 => {
        delta_from => 5.023002,
        changed => {
            'Amiga::ARexx'          => '0.02',
            'Amiga::Exec'           => '0.01',
            'B'                     => '1.59',
            'B::Op_private'         => '5.023003',
            'Carp'                  => '1.37',
            'Carp::Heavy'           => '1.37',
            'Compress::Raw::Zlib'   => '2.068_01',
            'Config'                => '5.023003',
            'Cwd'                   => '3.58',
            'DynaLoader'            => '1.34',
            'Encode'                => '2.77',
            'Encode::Unicode'       => '2.14',
            'English'               => '1.10',
            'Errno'                 => '1.24',
            'ExtUtils::Command'     => '7.10',
            'ExtUtils::Command::MM' => '7.10',
            'ExtUtils::Liblist'     => '7.10',
            'ExtUtils::Liblist::Kid'=> '7.10',
            'ExtUtils::MM'          => '7.10',
            'ExtUtils::MM_AIX'      => '7.10',
            'ExtUtils::MM_Any'      => '7.10',
            'ExtUtils::MM_BeOS'     => '7.10',
            'ExtUtils::MM_Cygwin'   => '7.10',
            'ExtUtils::MM_DOS'      => '7.10',
            'ExtUtils::MM_Darwin'   => '7.10',
            'ExtUtils::MM_MacOS'    => '7.10',
            'ExtUtils::MM_NW5'      => '7.10',
            'ExtUtils::MM_OS2'      => '7.10',
            'ExtUtils::MM_QNX'      => '7.10',
            'ExtUtils::MM_UWIN'     => '7.10',
            'ExtUtils::MM_Unix'     => '7.10',
            'ExtUtils::MM_VMS'      => '7.10',
            'ExtUtils::MM_VOS'      => '7.10',
            'ExtUtils::MM_Win32'    => '7.10',
            'ExtUtils::MM_Win95'    => '7.10',
            'ExtUtils::MY'          => '7.10',
            'ExtUtils::MakeMaker'   => '7.10',
            'ExtUtils::MakeMaker::Config'=> '7.10',
            'ExtUtils::MakeMaker::Locale'=> '7.10',
            'ExtUtils::MakeMaker::version'=> '7.10',
            'ExtUtils::MakeMaker::version::regex'=> '7.10',
            'ExtUtils::MakeMaker::version::vpp'=> '7.10',
            'ExtUtils::Mkbootstrap' => '7.10',
            'ExtUtils::Mksymlists'  => '7.10',
            'ExtUtils::ParseXS'     => '3.30',
            'ExtUtils::ParseXS::Constants'=> '3.30',
            'ExtUtils::ParseXS::CountLines'=> '3.30',
            'ExtUtils::ParseXS::Eval'=> '3.30',
            'ExtUtils::ParseXS::Utilities'=> '3.30',
            'ExtUtils::Typemaps'    => '3.30',
            'ExtUtils::Typemaps::Cmd'=> '3.30',
            'ExtUtils::Typemaps::InputMap'=> '3.30',
            'ExtUtils::Typemaps::OutputMap'=> '3.30',
            'ExtUtils::Typemaps::Type'=> '3.30',
            'ExtUtils::testlib'     => '7.10',
            'File::Find'            => '1.31',
            'File::Glob'            => '1.25',
            'File::Spec'            => '3.58',
            'File::Spec::AmigaOS'   => '3.58',
            'File::Spec::Cygwin'    => '3.58',
            'File::Spec::Epoc'      => '3.58',
            'File::Spec::Functions' => '3.58',
            'File::Spec::Mac'       => '3.58',
            'File::Spec::OS2'       => '3.58',
            'File::Spec::Unix'      => '3.58',
            'File::Spec::VMS'       => '3.58',
            'File::Spec::Win32'     => '3.58',
            'Hash::Util::FieldHash' => '1.17',
            'Locale::Codes'         => '3.36',
            'Locale::Codes::Constants'=> '3.36',
            'Locale::Codes::Country'=> '3.36',
            'Locale::Codes::Country_Codes'=> '3.36',
            'Locale::Codes::Country_Retired'=> '3.36',
            'Locale::Codes::Currency'=> '3.36',
            'Locale::Codes::Currency_Codes'=> '3.36',
            'Locale::Codes::Currency_Retired'=> '3.36',
            'Locale::Codes::LangExt'=> '3.36',
            'Locale::Codes::LangExt_Codes'=> '3.36',
            'Locale::Codes::LangExt_Retired'=> '3.36',
            'Locale::Codes::LangFam'=> '3.36',
            'Locale::Codes::LangFam_Codes'=> '3.36',
            'Locale::Codes::LangFam_Retired'=> '3.36',
            'Locale::Codes::LangVar'=> '3.36',
            'Locale::Codes::LangVar_Codes'=> '3.36',
            'Locale::Codes::LangVar_Retired'=> '3.36',
            'Locale::Codes::Language'=> '3.36',
            'Locale::Codes::Language_Codes'=> '3.36',
            'Locale::Codes::Language_Retired'=> '3.36',
            'Locale::Codes::Script' => '3.36',
            'Locale::Codes::Script_Codes'=> '3.36',
            'Locale::Codes::Script_Retired'=> '3.36',
            'Locale::Country'       => '3.36',
            'Locale::Currency'      => '3.36',
            'Locale::Language'      => '3.36',
            'Locale::Script'        => '3.36',
            'Math::BigFloat::Trace' => '0.40',
            'Math::BigInt::Trace'   => '0.40',
            'Module::CoreList'      => '5.20150920',
            'Module::CoreList::TieHashDelta'=> '5.20150920',
            'Module::CoreList::Utils'=> '5.20150920',
            'OS2::DLL'              => '1.06',
            'OS2::ExtAttr'          => '0.04',
            'OS2::Process'          => '1.11',
            'OS2::REXX'             => '1.05',
            'POSIX'                 => '1.57',
            'Pod::Perldoc'          => '3.25_01',
            'Socket'                => '2.020_01',
            'Test'                  => '1.27',
            'Thread::Queue'         => '3.06',
            'Time::HiRes'           => '1.9727_02',
            'Unicode::UCD'          => '0.63',
            'Win32'                 => '0.52',
            'XS::APItest'           => '0.75',
            'bigint'                => '0.40',
            'bignum'                => '0.40',
            'bigrat'                => '0.40',
            'encoding'              => '2.17',
            'experimental'          => '0.014',
            'if'                    => '0.0605',
            'locale'                => '1.07',
            'mro'                   => '1.18',
            'threads'               => '2.03',
        },
        removed => {
        }
    },
    5.023004 => {
        delta_from => 5.023003,
        changed => {
            'B'                     => '1.60',
            'B::Op_private'         => '5.023004',
            'Compress::Raw::Bzip2'  => '2.069',
            'Compress::Raw::Zlib'   => '2.069',
            'Compress::Zlib'        => '2.069',
            'Config'                => '5.023004',
            'Devel::PPPort'         => '3.32',
            'DynaLoader'            => '1.35',
            'Encode'                => '2.78',
            'ExtUtils::CBuilder'    => '0.280224',
            'ExtUtils::CBuilder::Base'=> '0.280224',
            'ExtUtils::CBuilder::Platform::Unix'=> '0.280224',
            'ExtUtils::CBuilder::Platform::VMS'=> '0.280224',
            'ExtUtils::CBuilder::Platform::Windows'=> '0.280224',
            'ExtUtils::CBuilder::Platform::Windows::BCC'=> '0.280224',
            'ExtUtils::CBuilder::Platform::Windows::GCC'=> '0.280224',
            'ExtUtils::CBuilder::Platform::Windows::MSVC'=> '0.280224',
            'ExtUtils::CBuilder::Platform::aix'=> '0.280224',
            'ExtUtils::CBuilder::Platform::android'=> '0.280224',
            'ExtUtils::CBuilder::Platform::cygwin'=> '0.280224',
            'ExtUtils::CBuilder::Platform::darwin'=> '0.280224',
            'ExtUtils::CBuilder::Platform::dec_osf'=> '0.280224',
            'ExtUtils::CBuilder::Platform::os2'=> '0.280224',
            'File::Path'            => '2.12',
            'IO'                    => '1.36',
            'IO::Compress::Adapter::Bzip2'=> '2.069',
            'IO::Compress::Adapter::Deflate'=> '2.069',
            'IO::Compress::Adapter::Identity'=> '2.069',
            'IO::Compress::Base'    => '2.069',
            'IO::Compress::Base::Common'=> '2.069',
            'IO::Compress::Bzip2'   => '2.069',
            'IO::Compress::Deflate' => '2.069',
            'IO::Compress::Gzip'    => '2.069',
            'IO::Compress::Gzip::Constants'=> '2.069',
            'IO::Compress::RawDeflate'=> '2.069',
            'IO::Compress::Zip'     => '2.069',
            'IO::Compress::Zip::Constants'=> '2.069',
            'IO::Compress::Zlib::Constants'=> '2.069',
            'IO::Compress::Zlib::Extra'=> '2.069',
            'IO::Poll'              => '0.10',
            'IO::Uncompress::Adapter::Bunzip2'=> '2.069',
            'IO::Uncompress::Adapter::Identity'=> '2.069',
            'IO::Uncompress::Adapter::Inflate'=> '2.069',
            'IO::Uncompress::AnyInflate'=> '2.069',
            'IO::Uncompress::AnyUncompress'=> '2.069',
            'IO::Uncompress::Base'  => '2.069',
            'IO::Uncompress::Bunzip2'=> '2.069',
            'IO::Uncompress::Gunzip'=> '2.069',
            'IO::Uncompress::Inflate'=> '2.069',
            'IO::Uncompress::RawInflate'=> '2.069',
            'IO::Uncompress::Unzip' => '2.069',
            'Math::BigFloat'        => '1.999704',
            'Math::BigFloat::Trace' => '0.41',
            'Math::BigInt'          => '1.999704',
            'Math::BigInt::Calc'    => '1.999704',
            'Math::BigInt::CalcEmu' => '1.999704',
            'Math::BigInt::FastCalc'=> '0.34',
            'Math::BigInt::Trace'   => '0.41',
            'Module::CoreList'      => '5.20151020',
            'Module::CoreList::TieHashDelta'=> '5.20151020',
            'Module::CoreList::Utils'=> '5.20151020',
            'Module::Metadata'      => '1.000029',
            'POSIX'                 => '1.58',
            'Perl::OSType'          => '1.009',
            'PerlIO::encoding'      => '0.22',
            'Socket'                => '2.020_02',
            'Unicode::Normalize'    => '1.21',
            'XS::APItest'           => '0.76',
            'bigint'                => '0.41',
            'bignum'                => '0.41',
            'bigrat'                => '0.41',
            'experimental'          => '0.016',
            'if'                    => '0.0606',
            'warnings'              => '1.35',
        },
        removed => {
        }
    },
    5.023005 => {
        delta_from => 5.023004,
        changed => {
            'B'                     => '1.61',
            'B::Op_private'         => '5.023005',
            'Carp'                  => '1.38',
            'Carp::Heavy'           => '1.38',
            'Config'                => '5.023005',
            'Config::Perl::V'       => '0.25',
            'Cwd'                   => '3.59',
            'Devel::Peek'           => '1.23',
            'Dumpvalue'             => '1.18',
            'DynaLoader'            => '1.36',
            'File::Find'            => '1.32',
            'File::Spec'            => '3.59',
            'File::Spec::AmigaOS'   => '3.59',
            'File::Spec::Cygwin'    => '3.59',
            'File::Spec::Epoc'      => '3.59',
            'File::Spec::Functions' => '3.59',
            'File::Spec::Mac'       => '3.59',
            'File::Spec::OS2'       => '3.59',
            'File::Spec::Unix'      => '3.59',
            'File::Spec::VMS'       => '3.59',
            'File::Spec::Win32'     => '3.59',
            'Getopt::Long'          => '2.48',
            'Hash::Util::FieldHash' => '1.18',
            'IPC::Open3'            => '1.20',
            'Math::BigFloat'        => '1.999710',
            'Math::BigInt'          => '1.999710',
            'Math::BigInt::Calc'    => '1.999710',
            'Math::BigInt::CalcEmu' => '1.999710',
            'Math::BigInt::FastCalc'=> '0.37',
            'Module::CoreList'      => '5.20151120',
            'Module::CoreList::TieHashDelta'=> '5.20151120',
            'Module::CoreList::Utils'=> '5.20151120',
            'Module::Metadata'      => '1.000030',
            'POSIX'                 => '1.59',
            'PerlIO::encoding'      => '0.23',
            'PerlIO::mmap'          => '0.015',
            'PerlIO::scalar'        => '0.24',
            'PerlIO::via'           => '0.16',
            'Pod::Simple'           => '3.32',
            'Pod::Simple::BlackBox' => '3.32',
            'Pod::Simple::Checker'  => '3.32',
            'Pod::Simple::Debug'    => '3.32',
            'Pod::Simple::DumpAsText'=> '3.32',
            'Pod::Simple::DumpAsXML'=> '3.32',
            'Pod::Simple::HTML'     => '3.32',
            'Pod::Simple::HTMLBatch'=> '3.32',
            'Pod::Simple::LinkSection'=> '3.32',
            'Pod::Simple::Methody'  => '3.32',
            'Pod::Simple::Progress' => '3.32',
            'Pod::Simple::PullParser'=> '3.32',
            'Pod::Simple::PullParserEndToken'=> '3.32',
            'Pod::Simple::PullParserStartToken'=> '3.32',
            'Pod::Simple::PullParserTextToken'=> '3.32',
            'Pod::Simple::PullParserToken'=> '3.32',
            'Pod::Simple::RTF'      => '3.32',
            'Pod::Simple::Search'   => '3.32',
            'Pod::Simple::SimpleTree'=> '3.32',
            'Pod::Simple::Text'     => '3.32',
            'Pod::Simple::TextContent'=> '3.32',
            'Pod::Simple::TiedOutFH'=> '3.32',
            'Pod::Simple::Transcode'=> '3.32',
            'Pod::Simple::TranscodeDumb'=> '3.32',
            'Pod::Simple::TranscodeSmart'=> '3.32',
            'Pod::Simple::XHTML'    => '3.32',
            'Pod::Simple::XMLOutStream'=> '3.32',
            'Thread::Queue'         => '3.07',
            'Tie::Scalar'           => '1.04',
            'Time::HiRes'           => '1.9728',
            'Time::Piece'           => '1.31',
            'Time::Seconds'         => '1.31',
            'Unicode::Normalize'    => '1.23',
            'XSLoader'              => '0.21',
            'arybase'               => '0.11',
            'base'                  => '2.22_01',
            'fields'                => '2.22_01',
            'threads'               => '2.04',
            'threads::shared'       => '1.49',
        },
        removed => {
            'ExtUtils::MakeMaker::version::vpp'=> 1,
            'version::vpp'          => 1,
        }
    },
    5.022001 => {
        delta_from => 5.022,
        changed => {
            'B::Op_private'         => '5.022001',
            'Config'                => '5.022001',
            'Module::CoreList'      => '5.20151213',
            'Module::CoreList::TieHashDelta'=> '5.20151213',
            'Module::CoreList::Utils'=> '5.20151213',
            'POSIX'                 => '1.53_01',
            'PerlIO::scalar'        => '0.23',
            'Storable'              => '2.53_01',
            'Win32'                 => '0.52',
            'warnings'              => '1.34',
        },
        removed => {
        }
    },
    5.023006 => {
        delta_from => 5.023005,
        changed => {
            'B::Deparse'            => '1.36',
            'B::Op_private'         => '5.023006',
            'Benchmark'             => '1.21',
            'CPAN::Meta::Requirements'=> '2.140',
            'CPAN::Meta::YAML'      => '0.018',
            'Config'                => '5.023006',
            'Cwd'                   => '3.60',
            'Data::Dumper'          => '2.159',
            'DynaLoader'            => '1.37',
            'File::Spec'            => '3.60',
            'File::Spec::AmigaOS'   => '3.60',
            'File::Spec::Cygwin'    => '3.60',
            'File::Spec::Epoc'      => '3.60',
            'File::Spec::Functions' => '3.60',
            'File::Spec::Mac'       => '3.60',
            'File::Spec::OS2'       => '3.60',
            'File::Spec::Unix'      => '3.60',
            'File::Spec::VMS'       => '3.60',
            'File::Spec::Win32'     => '3.60',
            'Hash::Util::FieldHash' => '1.19',
            'Locale::Codes'         => '3.37',
            'Locale::Codes::Constants'=> '3.37',
            'Locale::Codes::Country'=> '3.37',
            'Locale::Codes::Country_Codes'=> '3.37',
            'Locale::Codes::Country_Retired'=> '3.37',
            'Locale::Codes::Currency'=> '3.37',
            'Locale::Codes::Currency_Codes'=> '3.37',
            'Locale::Codes::Currency_Retired'=> '3.37',
            'Locale::Codes::LangExt'=> '3.37',
            'Locale::Codes::LangExt_Codes'=> '3.37',
            'Locale::Codes::LangExt_Retired'=> '3.37',
            'Locale::Codes::LangFam'=> '3.37',
            'Locale::Codes::LangFam_Codes'=> '3.37',
            'Locale::Codes::LangFam_Retired'=> '3.37',
            'Locale::Codes::LangVar'=> '3.37',
            'Locale::Codes::LangVar_Codes'=> '3.37',
            'Locale::Codes::LangVar_Retired'=> '3.37',
            'Locale::Codes::Language'=> '3.37',
            'Locale::Codes::Language_Codes'=> '3.37',
            'Locale::Codes::Language_Retired'=> '3.37',
            'Locale::Codes::Script' => '3.37',
            'Locale::Codes::Script_Codes'=> '3.37',
            'Locale::Codes::Script_Retired'=> '3.37',
            'Locale::Country'       => '3.37',
            'Locale::Currency'      => '3.37',
            'Locale::Language'      => '3.37',
            'Locale::Script'        => '3.37',
            'Math::BigInt::FastCalc'=> '0.38',
            'Module::CoreList'      => '5.20151220',
            'Module::CoreList::TieHashDelta'=> '5.20151220',
            'Module::CoreList::Utils'=> '5.20151220',
            'Module::Metadata'      => '1.000031',
            'Opcode'                => '1.34',
            'PerlIO::mmap'          => '0.016',
            'Pod::Perldoc'          => '3.25_02',
            'SDBM_File'             => '1.14',
            'Term::ANSIColor'       => '4.04',
            'Test'                  => '1.28',
            'Unicode::Normalize'    => '1.24',
            'XS::APItest'           => '0.77',
            'base'                  => '2.23',
            'encoding::warnings'    => '0.12',
            'fields'                => '2.23',
            'locale'                => '1.08',
            'strict'                => '1.10',
            'threads'               => '2.05',
            'threads::shared'       => '1.50',
            'utf8'                  => '1.18',
        },
        removed => {
        }
    },
    5.023007 => {
        delta_from => 5.023006,
        changed => {
            'App::Prove'            => '3.36',
            'App::Prove::State'     => '3.36',
            'App::Prove::State::Result'=> '3.36',
            'App::Prove::State::Result::Test'=> '3.36',
            'B'                     => '1.62',
            'B::Deparse'            => '1.37',
            'B::Op_private'         => '5.023007',
            'Benchmark'             => '1.22',
            'Config'                => '5.023007',
            'Cwd'                   => '3.62',
            'Data::Dumper'          => '2.160',
            'ExtUtils::ParseXS'     => '3.31',
            'ExtUtils::ParseXS::Constants'=> '3.31',
            'ExtUtils::ParseXS::CountLines'=> '3.31',
            'ExtUtils::ParseXS::Eval'=> '3.31',
            'ExtUtils::ParseXS::Utilities'=> '3.31',
            'ExtUtils::Typemaps'    => '3.31',
            'ExtUtils::Typemaps::Cmd'=> '3.31',
            'ExtUtils::Typemaps::InputMap'=> '3.31',
            'ExtUtils::Typemaps::OutputMap'=> '3.31',
            'ExtUtils::Typemaps::Type'=> '3.31',
            'File::Find'            => '1.33',
            'File::Spec'            => '3.62',
            'File::Spec::AmigaOS'   => '3.62',
            'File::Spec::Cygwin'    => '3.62',
            'File::Spec::Epoc'      => '3.62',
            'File::Spec::Functions' => '3.62',
            'File::Spec::Mac'       => '3.62',
            'File::Spec::OS2'       => '3.62',
            'File::Spec::Unix'      => '3.62',
            'File::Spec::VMS'       => '3.62',
            'File::Spec::Win32'     => '3.62',
            'Math::BigFloat'        => '1.999715',
            'Math::BigFloat::Trace' => '0.42',
            'Math::BigInt'          => '1.999715',
            'Math::BigInt::Calc'    => '1.999715',
            'Math::BigInt::CalcEmu' => '1.999715',
            'Math::BigInt::FastCalc'=> '0.40',
            'Math::BigInt::Trace'   => '0.42',
            'Math::BigRat'          => '0.260802',
            'Module::CoreList'      => '5.20160120',
            'Module::CoreList::TieHashDelta'=> '5.20160120',
            'Module::CoreList::Utils'=> '5.20160120',
            'Net::Cmd'              => '3.08',
            'Net::Config'           => '3.08',
            'Net::Domain'           => '3.08',
            'Net::FTP'              => '3.08',
            'Net::FTP::A'           => '3.08',
            'Net::FTP::E'           => '3.08',
            'Net::FTP::I'           => '3.08',
            'Net::FTP::L'           => '3.08',
            'Net::FTP::dataconn'    => '3.08',
            'Net::NNTP'             => '3.08',
            'Net::Netrc'            => '3.08',
            'Net::POP3'             => '3.08',
            'Net::SMTP'             => '3.08',
            'Net::Time'             => '3.08',
            'Pod::Man'              => '4.04',
            'Pod::ParseLink'        => '4.04',
            'Pod::Text'             => '4.04',
            'Pod::Text::Color'      => '4.04',
            'Pod::Text::Overstrike' => '4.04',
            'Pod::Text::Termcap'    => '4.04',
            'Pod::Usage'            => '1.68',
            'TAP::Base'             => '3.36',
            'TAP::Formatter::Base'  => '3.36',
            'TAP::Formatter::Color' => '3.36',
            'TAP::Formatter::Console'=> '3.36',
            'TAP::Formatter::Console::ParallelSession'=> '3.36',
            'TAP::Formatter::Console::Session'=> '3.36',
            'TAP::Formatter::File'  => '3.36',
            'TAP::Formatter::File::Session'=> '3.36',
            'TAP::Formatter::Session'=> '3.36',
            'TAP::Harness'          => '3.36',
            'TAP::Harness::Env'     => '3.36',
            'TAP::Object'           => '3.36',
            'TAP::Parser'           => '3.36',
            'TAP::Parser::Aggregator'=> '3.36',
            'TAP::Parser::Grammar'  => '3.36',
            'TAP::Parser::Iterator' => '3.36',
            'TAP::Parser::Iterator::Array'=> '3.36',
            'TAP::Parser::Iterator::Process'=> '3.36',
            'TAP::Parser::Iterator::Stream'=> '3.36',
            'TAP::Parser::IteratorFactory'=> '3.36',
            'TAP::Parser::Multiplexer'=> '3.36',
            'TAP::Parser::Result'   => '3.36',
            'TAP::Parser::Result::Bailout'=> '3.36',
            'TAP::Parser::Result::Comment'=> '3.36',
            'TAP::Parser::Result::Plan'=> '3.36',
            'TAP::Parser::Result::Pragma'=> '3.36',
            'TAP::Parser::Result::Test'=> '3.36',
            'TAP::Parser::Result::Unknown'=> '3.36',
            'TAP::Parser::Result::Version'=> '3.36',
            'TAP::Parser::Result::YAML'=> '3.36',
            'TAP::Parser::ResultFactory'=> '3.36',
            'TAP::Parser::Scheduler'=> '3.36',
            'TAP::Parser::Scheduler::Job'=> '3.36',
            'TAP::Parser::Scheduler::Spinner'=> '3.36',
            'TAP::Parser::Source'   => '3.36',
            'TAP::Parser::SourceHandler'=> '3.36',
            'TAP::Parser::SourceHandler::Executable'=> '3.36',
            'TAP::Parser::SourceHandler::File'=> '3.36',
            'TAP::Parser::SourceHandler::Handle'=> '3.36',
            'TAP::Parser::SourceHandler::Perl'=> '3.36',
            'TAP::Parser::SourceHandler::RawTAP'=> '3.36',
            'TAP::Parser::YAMLish::Reader'=> '3.36',
            'TAP::Parser::YAMLish::Writer'=> '3.36',
            'Test::Harness'         => '3.36',
            'Unicode::Normalize'    => '1.25',
            'Unicode::UCD'          => '0.64',
            'XS::APItest'           => '0.78',
            'bigint'                => '0.42',
            'bignum'                => '0.42',
            'bigrat'                => '0.42',
            'utf8'                  => '1.19',
        },
        removed => {
        }
    },
    5.023008 => {
        delta_from => 5.023007,
        changed => {
            'B::Op_private'         => '5.023008',
            'Config'                => '5.023008',
            'Cwd'                   => '3.63',
            'DynaLoader'            => '1.38',
            'Encode'                => '2.80',
            'Encode::Alias'         => '2.20',
            'Encode::MIME::Header'  => '2.19',
            'Encode::Unicode'       => '2.15',
            'ExtUtils::CBuilder'    => '0.280225',
            'ExtUtils::CBuilder::Base'=> '0.280225',
            'ExtUtils::CBuilder::Platform::Unix'=> '0.280225',
            'ExtUtils::CBuilder::Platform::VMS'=> '0.280225',
            'ExtUtils::CBuilder::Platform::Windows'=> '0.280225',
            'ExtUtils::CBuilder::Platform::Windows::BCC'=> '0.280225',
            'ExtUtils::CBuilder::Platform::Windows::GCC'=> '0.280225',
            'ExtUtils::CBuilder::Platform::Windows::MSVC'=> '0.280225',
            'ExtUtils::CBuilder::Platform::aix'=> '0.280225',
            'ExtUtils::CBuilder::Platform::android'=> '0.280225',
            'ExtUtils::CBuilder::Platform::cygwin'=> '0.280225',
            'ExtUtils::CBuilder::Platform::darwin'=> '0.280225',
            'ExtUtils::CBuilder::Platform::dec_osf'=> '0.280225',
            'ExtUtils::CBuilder::Platform::os2'=> '0.280225',
            'ExtUtils::Command::MM' => '7.10_01',
            'ExtUtils::Liblist'     => '7.10_01',
            'ExtUtils::Liblist::Kid'=> '7.10_01',
            'ExtUtils::MM'          => '7.10_01',
            'ExtUtils::MM_AIX'      => '7.10_01',
            'ExtUtils::MM_Any'      => '7.10_01',
            'ExtUtils::MM_BeOS'     => '7.10_01',
            'ExtUtils::MM_Cygwin'   => '7.10_01',
            'ExtUtils::MM_DOS'      => '7.10_01',
            'ExtUtils::MM_Darwin'   => '7.10_01',
            'ExtUtils::MM_MacOS'    => '7.10_01',
            'ExtUtils::MM_NW5'      => '7.10_01',
            'ExtUtils::MM_OS2'      => '7.10_01',
            'ExtUtils::MM_QNX'      => '7.10_01',
            'ExtUtils::MM_UWIN'     => '7.10_01',
            'ExtUtils::MM_Unix'     => '7.10_01',
            'ExtUtils::MM_VMS'      => '7.10_01',
            'ExtUtils::MM_VOS'      => '7.10_01',
            'ExtUtils::MM_Win32'    => '7.10_01',
            'ExtUtils::MM_Win95'    => '7.10_01',
            'ExtUtils::MY'          => '7.10_01',
            'ExtUtils::MakeMaker'   => '7.10_01',
            'ExtUtils::MakeMaker::Config'=> '7.10_01',
            'ExtUtils::MakeMaker::version'=> '7.10_01',
            'ExtUtils::MakeMaker::version::regex'=> '7.10_01',
            'ExtUtils::Mkbootstrap' => '7.10_01',
            'ExtUtils::Mksymlists'  => '7.10_01',
            'ExtUtils::testlib'     => '7.10_01',
            'File::Spec'            => '3.63',
            'File::Spec::AmigaOS'   => '3.63',
            'File::Spec::Cygwin'    => '3.63',
            'File::Spec::Epoc'      => '3.63',
            'File::Spec::Functions' => '3.63',
            'File::Spec::Mac'       => '3.63',
            'File::Spec::OS2'       => '3.63',
            'File::Spec::Unix'      => '3.63',
            'File::Spec::VMS'       => '3.63',
            'File::Spec::Win32'     => '3.63',
            'IPC::Msg'              => '2.05',
            'IPC::Semaphore'        => '2.05',
            'IPC::SharedMem'        => '2.05',
            'IPC::SysV'             => '2.05',
            'Module::CoreList'      => '5.20160121',
            'Module::CoreList::TieHashDelta'=> '5.20160121',
            'Module::CoreList::Utils'=> '5.20160121',
            'ODBM_File'             => '1.13',
            'POSIX'                 => '1.63',
            'PerlIO::encoding'      => '0.24',
            'Pod::Man'              => '4.06',
            'Pod::ParseLink'        => '4.06',
            'Pod::Text'             => '4.06',
            'Pod::Text::Color'      => '4.06',
            'Pod::Text::Overstrike' => '4.06',
            'Pod::Text::Termcap'    => '4.06',
            'Storable'              => '2.55',
            'Time::HiRes'           => '1.9730',
            'XS::APItest'           => '0.79',
        },
        removed => {
        }
    },
    5.023009 => {
        delta_from => 5.023008,
        changed => {
            'Amiga::ARexx'          => '0.04',
            'Amiga::Exec'           => '0.02',
            'B::Op_private'         => '5.023009',
            'Carp'                  => '1.40',
            'Carp::Heavy'           => '1.40',
            'Config'                => '5.023009',
            'Errno'                 => '1.25',
            'ExtUtils::Embed'       => '1.33',
            'File::Find'            => '1.34',
            'File::Glob'            => '1.26',
            'File::Spec::AmigaOS'   => ';.64',
            'IPC::Msg'              => '2.06_01',
            'IPC::Semaphore'        => '2.06_01',
            'IPC::SharedMem'        => '2.06_01',
            'IPC::SysV'             => '2.06_01',
            'List::Util'            => '1.42_02',
            'List::Util::XS'        => '1.42_02',
            'Module::CoreList'      => '5.20160320',
            'Module::CoreList::TieHashDelta'=> '5.20160320',
            'Module::CoreList::Utils'=> '5.20160320',
            'POSIX'                 => '1.64',
            'Pod::Functions'        => '1.10',
            'Pod::Functions::Functions'=> '1.10',
            'Scalar::Util'          => '1.42_02',
            'SelfLoader'            => '1.23',
            'Socket'                => '2.020_03',
            'Storable'              => '2.56',
            'Sub::Util'             => '1.42_02',
            'Thread::Queue'         => '3.08',
            'Tie::File'             => '1.02',
            'Time::HiRes'           => '1.9732',
            'Win32API::File'        => '0.1203',
            'Win32API::File::inc::ExtUtils::Myconst2perl'=> '1',
            'XS::APItest'           => '0.80',
            'autouse'               => '1.11',
            'bytes'                 => '1.05',
            'strict'                => '1.11',
            'threads'               => '2.06',
            'version'               => '0.9916',
            'version::regex'        => '0.9916',
            'warnings'              => '1.36',
        },
        removed => {
            'Win32API::File::ExtUtils::Myconst2perl'=> 1,
        }
    },
    5.022002 => {
        delta_from => 5.022001,
        changed => {
            'B::Op_private'         => '5.022002',
            'Config'                => '5.022002',
            'Cwd'                   => '3.56_01',
            'File::Spec'            => '3.56_01',
            'File::Spec::Cygwin'    => '3.56_01',
            'File::Spec::Epoc'      => '3.56_01',
            'File::Spec::Functions' => '3.56_01',
            'File::Spec::Mac'       => '3.56_01',
            'File::Spec::OS2'       => '3.56_01',
            'File::Spec::Unix'      => '3.56_01',
            'File::Spec::VMS'       => '3.56_01',
            'File::Spec::Win32'     => '3.56_01',
            'Module::CoreList'      => '5.20160429',
            'Module::CoreList::TieHashDelta'=> '5.20160429',
            'Module::CoreList::Utils'=> '5.20160429',
            'XS::APItest'           => '0.72_01',
        },
        removed => {
        }
    },
    5.024000 => {
        delta_from => 5.023009,
        changed => {
            'B::Op_private'         => '5.024000',
            'Config'                => '5.024',
            'File::Copy'            => '2.31',
            'File::Path'            => '2.12_01',
            'File::Spec::AmigaOS'   => '3.64',
            'IO::Handle'            => '1.36',
            'Module::CoreList'      => '5.20160506',
            'Module::CoreList::TieHashDelta'=> '5.20160506',
            'Module::CoreList::Utils'=> '5.20160506',
            'ODBM_File'             => '1.14',
            'POSIX'                 => '1.65',
            'Pod::Man'              => '4.07',
            'Pod::ParseLink'        => '4.07',
            'Pod::Text'             => '4.07',
            'Pod::Text::Color'      => '4.07',
            'Pod::Text::Overstrike' => '4.07',
            'Pod::Text::Termcap'    => '4.07',
            'Thread::Queue'         => '3.09',
            'Time::HiRes'           => '1.9733',
            'threads'               => '2.07',
            'threads::shared'       => '1.51',
            'locale'                => '1.09',
        },
        removed => {
        }
    },
    5.025000 => {
        delta_from => 5.024,
        changed => {
            'B::Op_private'         => '5.025000',
            'Config'                => '5.025',
            'Module::CoreList'      => '5.20160507',
            'Module::CoreList::TieHashDelta'=> '5.20160507',
            'Module::CoreList::Utils'=> '5.20160507',
            'feature'               => '1.43',
        },
        removed => {
        }
    },
    5.025001 => {
        delta_from => 5.025,
        changed => {
            'Archive::Tar'          => '2.08',
            'Archive::Tar::Constant'=> '2.08',
            'Archive::Tar::File'    => '2.08',
            'B::Op_private'         => '5.025001',
            'Carp'                  => '1.41',
            'Carp::Heavy'           => '1.41',
            'Config'                => '5.025001',
            'Config::Perl::V'       => '0.26',
            'DB_File'               => '1.838',
            'Digest::MD5'           => '2.55',
            'IPC::Cmd'              => '0.94',
            'IPC::Msg'              => '2.07',
            'IPC::Semaphore'        => '2.07',
            'IPC::SharedMem'        => '2.07',
            'IPC::SysV'             => '2.07',
            'List::Util'            => '1.45_01',
            'List::Util::XS'        => '1.45_01',
            'Locale::Codes'         => '3.38',
            'Locale::Codes::Constants'=> '3.38',
            'Locale::Codes::Country'=> '3.38',
            'Locale::Codes::Country_Codes'=> '3.38',
            'Locale::Codes::Country_Retired'=> '3.38',
            'Locale::Codes::Currency'=> '3.38',
            'Locale::Codes::Currency_Codes'=> '3.38',
            'Locale::Codes::Currency_Retired'=> '3.38',
            'Locale::Codes::LangExt'=> '3.38',
            'Locale::Codes::LangExt_Codes'=> '3.38',
            'Locale::Codes::LangExt_Retired'=> '3.38',
            'Locale::Codes::LangFam'=> '3.38',
            'Locale::Codes::LangFam_Codes'=> '3.38',
            'Locale::Codes::LangFam_Retired'=> '3.38',
            'Locale::Codes::LangVar'=> '3.38',
            'Locale::Codes::LangVar_Codes'=> '3.38',
            'Locale::Codes::LangVar_Retired'=> '3.38',
            'Locale::Codes::Language'=> '3.38',
            'Locale::Codes::Language_Codes'=> '3.38',
            'Locale::Codes::Language_Retired'=> '3.38',
            'Locale::Codes::Script' => '3.38',
            'Locale::Codes::Script_Codes'=> '3.38',
            'Locale::Codes::Script_Retired'=> '3.38',
            'Locale::Country'       => '3.38',
            'Locale::Currency'      => '3.38',
            'Locale::Language'      => '3.38',
            'Locale::Maketext'      => '1.27',
            'Locale::Script'        => '3.38',
            'Module::CoreList'      => '5.20160520',
            'Module::CoreList::TieHashDelta'=> '5.20160520',
            'Module::CoreList::Utils'=> '5.20160520',
            'Module::Metadata'      => '1.000032',
            'POSIX'                 => '1.69',
            'Scalar::Util'          => '1.45_01',
            'Sub::Util'             => '1.45_01',
            'Sys::Syslog'           => '0.34',
            'Term::ANSIColor'       => '4.05',
            'Test2'                 => '1.302015',
            'Test2::API'            => '1.302015',
            'Test2::API::Breakage'  => '1.302015',
            'Test2::API::Context'   => '1.302015',
            'Test2::API::Instance'  => '1.302015',
            'Test2::API::Stack'     => '1.302015',
            'Test2::Event'          => '1.302015',
            'Test2::Event::Bail'    => '1.302015',
            'Test2::Event::Diag'    => '1.302015',
            'Test2::Event::Exception'=> '1.302015',
            'Test2::Event::Note'    => '1.302015',
            'Test2::Event::Ok'      => '1.302015',
            'Test2::Event::Plan'    => '1.302015',
            'Test2::Event::Skip'    => '1.302015',
            'Test2::Event::Subtest' => '1.302015',
            'Test2::Event::Waiting' => '1.302015',
            'Test2::Formatter'      => '1.302015',
            'Test2::Formatter::TAP' => '1.302015',
            'Test2::Hub'            => '1.302015',
            'Test2::Hub::Interceptor'=> '1.302015',
            'Test2::Hub::Interceptor::Terminator'=> '1.302015',
            'Test2::Hub::Subtest'   => '1.302015',
            'Test2::IPC'            => '1.302015',
            'Test2::IPC::Driver'    => '1.302015',
            'Test2::IPC::Driver::Files'=> '1.302015',
            'Test2::Util'           => '1.302015',
            'Test2::Util::ExternalMeta'=> '1.302015',
            'Test2::Util::HashBase' => '1.302015',
            'Test2::Util::Trace'    => '1.302015',
            'Test::Builder'         => '1.302015',
            'Test::Builder::Formatter'=> '1.302015',
            'Test::Builder::Module' => '1.302015',
            'Test::Builder::Tester' => '1.302015',
            'Test::Builder::Tester::Color'=> '1.302015',
            'Test::Builder::TodoDiag'=> '1.302015',
            'Test::More'            => '1.302015',
            'Test::Simple'          => '1.302015',
            'Test::Tester'          => '1.302015',
            'Test::Tester::Capture' => '1.302015',
            'Test::Tester::CaptureRunner'=> '1.302015',
            'Test::Tester::Delegate'=> '1.302015',
            'Test::use::ok'         => '1.302015',
            'XS::APItest'           => '0.81',
            '_charnames'            => '1.44',
            'charnames'             => '1.44',
            'ok'                    => '1.302015',
            'perlfaq'               => '5.021011',
            're'                    => '0.33',
            'threads'               => '2.08',
            'threads::shared'       => '1.52',
        },
        removed => {
        }
    },
    5.025002 => {
        delta_from => 5.025001,
        changed => {
            'App::Cpan'             => '1.64',
            'B::Op_private'         => '5.025002',
            'CPAN'                  => '2.14',
            'CPAN::Distribution'    => '2.12',
            'CPAN::FTP'             => '5.5007',
            'CPAN::FirstTime'       => '5.5309',
            'CPAN::HandleConfig'    => '5.5007',
            'CPAN::Index'           => '2.12',
            'CPAN::Mirrors'         => '2.12',
            'CPAN::Plugin'          => '0.96',
            'CPAN::Shell'           => '5.5006',
            'Config'                => '5.025002',
            'Cwd'                   => '3.64',
            'Devel::Peek'           => '1.24',
            'DynaLoader'            => '1.39',
            'ExtUtils::Command'     => '7.18',
            'ExtUtils::Command::MM' => '7.18',
            'ExtUtils::Liblist'     => '7.18',
            'ExtUtils::Liblist::Kid'=> '7.18',
            'ExtUtils::MM'          => '7.18',
            'ExtUtils::MM_AIX'      => '7.18',
            'ExtUtils::MM_Any'      => '7.18',
            'ExtUtils::MM_BeOS'     => '7.18',
            'ExtUtils::MM_Cygwin'   => '7.18',
            'ExtUtils::MM_DOS'      => '7.18',
            'ExtUtils::MM_Darwin'   => '7.18',
            'ExtUtils::MM_MacOS'    => '7.18',
            'ExtUtils::MM_NW5'      => '7.18',
            'ExtUtils::MM_OS2'      => '7.18',
            'ExtUtils::MM_QNX'      => '7.18',
            'ExtUtils::MM_UWIN'     => '7.18',
            'ExtUtils::MM_Unix'     => '7.18',
            'ExtUtils::MM_VMS'      => '7.18',
            'ExtUtils::MM_VOS'      => '7.18',
            'ExtUtils::MM_Win32'    => '7.18',
            'ExtUtils::MM_Win95'    => '7.18',
            'ExtUtils::MY'          => '7.18',
            'ExtUtils::MakeMaker'   => '7.18',
            'ExtUtils::MakeMaker::Config'=> '7.18',
            'ExtUtils::MakeMaker::Locale'=> '7.18',
            'ExtUtils::MakeMaker::version'=> '7.18',
            'ExtUtils::MakeMaker::version::regex'=> '7.18',
            'ExtUtils::Miniperl'    => '1.06',
            'ExtUtils::Mkbootstrap' => '7.18',
            'ExtUtils::Mksymlists'  => '7.18',
            'ExtUtils::ParseXS'     => '3.32',
            'ExtUtils::ParseXS::Constants'=> '3.32',
            'ExtUtils::ParseXS::CountLines'=> '3.32',
            'ExtUtils::ParseXS::Eval'=> '3.32',
            'ExtUtils::ParseXS::Utilities'=> '3.32',
            'ExtUtils::Typemaps'    => '3.32',
            'ExtUtils::Typemaps::Cmd'=> '3.32',
            'ExtUtils::Typemaps::InputMap'=> '3.32',
            'ExtUtils::Typemaps::OutputMap'=> '3.32',
            'ExtUtils::Typemaps::Type'=> '3.32',
            'ExtUtils::testlib'     => '7.18',
            'File::Copy'            => '2.32',
            'File::Glob'            => '1.27',
            'File::Spec'            => '3.64',
            'File::Spec::Cygwin'    => '3.64',
            'File::Spec::Epoc'      => '3.64',
            'File::Spec::Functions' => '3.64',
            'File::Spec::Mac'       => '3.64',
            'File::Spec::OS2'       => '3.64',
            'File::Spec::Unix'      => '3.64',
            'File::Spec::VMS'       => '3.64',
            'File::Spec::Win32'     => '3.64',
            'FileHandle'            => '2.03',
            'Getopt::Long'          => '2.49',
            'HTTP::Tiny'            => '0.058',
            'JSON::PP'              => '2.27400',
            'Locale::Codes'         => '3.39',
            'Locale::Codes::Constants'=> '3.39',
            'Locale::Codes::Country'=> '3.39',
            'Locale::Codes::Country_Codes'=> '3.39',
            'Locale::Codes::Country_Retired'=> '3.39',
            'Locale::Codes::Currency'=> '3.39',
            'Locale::Codes::Currency_Codes'=> '3.39',
            'Locale::Codes::Currency_Retired'=> '3.39',
            'Locale::Codes::LangExt'=> '3.39',
            'Locale::Codes::LangExt_Codes'=> '3.39',
            'Locale::Codes::LangExt_Retired'=> '3.39',
            'Locale::Codes::LangFam'=> '3.39',
            'Locale::Codes::LangFam_Codes'=> '3.39',
            'Locale::Codes::LangFam_Retired'=> '3.39',
            'Locale::Codes::LangVar'=> '3.39',
            'Locale::Codes::LangVar_Codes'=> '3.39',
            'Locale::Codes::LangVar_Retired'=> '3.39',
            'Locale::Codes::Language'=> '3.39',
            'Locale::Codes::Language_Codes'=> '3.39',
            'Locale::Codes::Language_Retired'=> '3.39',
            'Locale::Codes::Script' => '3.39',
            'Locale::Codes::Script_Codes'=> '3.39',
            'Locale::Codes::Script_Retired'=> '3.39',
            'Locale::Country'       => '3.39',
            'Locale::Currency'      => '3.39',
            'Locale::Language'      => '3.39',
            'Locale::Script'        => '3.39',
            'Module::CoreList'      => '5.20160620',
            'Module::CoreList::TieHashDelta'=> '5.20160620',
            'Module::CoreList::Utils'=> '5.20160620',
            'Opcode'                => '1.35',
            'POSIX'                 => '1.70',
            'Pod::Checker'          => '1.73',
            'Pod::Functions'        => '1.11',
            'Pod::Functions::Functions'=> '1.11',
            'Pod::Usage'            => '1.69',
            'Test2'                 => '1.302026',
            'Test2::API'            => '1.302026',
            'Test2::API::Breakage'  => '1.302026',
            'Test2::API::Context'   => '1.302026',
            'Test2::API::Instance'  => '1.302026',
            'Test2::API::Stack'     => '1.302026',
            'Test2::Event'          => '1.302026',
            'Test2::Event::Bail'    => '1.302026',
            'Test2::Event::Diag'    => '1.302026',
            'Test2::Event::Exception'=> '1.302026',
            'Test2::Event::Generic' => '1.302026',
            'Test2::Event::Note'    => '1.302026',
            'Test2::Event::Ok'      => '1.302026',
            'Test2::Event::Plan'    => '1.302026',
            'Test2::Event::Skip'    => '1.302026',
            'Test2::Event::Subtest' => '1.302026',
            'Test2::Event::Waiting' => '1.302026',
            'Test2::Formatter'      => '1.302026',
            'Test2::Formatter::TAP' => '1.302026',
            'Test2::Hub'            => '1.302026',
            'Test2::Hub::Interceptor'=> '1.302026',
            'Test2::Hub::Interceptor::Terminator'=> '1.302026',
            'Test2::Hub::Subtest'   => '1.302026',
            'Test2::IPC'            => '1.302026',
            'Test2::IPC::Driver'    => '1.302026',
            'Test2::IPC::Driver::Files'=> '1.302026',
            'Test2::Util'           => '1.302026',
            'Test2::Util::ExternalMeta'=> '1.302026',
            'Test2::Util::HashBase' => '1.302026',
            'Test2::Util::Trace'    => '1.302026',
            'Test::Builder'         => '1.302026',
            'Test::Builder::Formatter'=> '1.302026',
            'Test::Builder::Module' => '1.302026',
            'Test::Builder::Tester' => '1.302026',
            'Test::Builder::Tester::Color'=> '1.302026',
            'Test::Builder::TodoDiag'=> '1.302026',
            'Test::More'            => '1.302026',
            'Test::Simple'          => '1.302026',
            'Test::Tester'          => '1.302026',
            'Test::Tester::Capture' => '1.302026',
            'Test::Tester::CaptureRunner'=> '1.302026',
            'Test::Tester::Delegate'=> '1.302026',
            'Test::use::ok'         => '1.302026',
            'Thread::Queue'         => '3.11',
            'Time::HiRes'           => '1.9734',
            'Unicode::UCD'          => '0.65',
            'VMS::DCLsym'           => '1.07',
            'XS::APItest'           => '0.82',
            'diagnostics'           => '1.35',
            'feature'               => '1.44',
            'ok'                    => '1.302026',
            'threads'               => '2.09',
        },
        removed => {
        }
    },
    5.025003 => {
        delta_from => 5.025002,
        changed => {
            'B::Op_private'         => '5.025003',
            'Config'                => '5.025003',
            'Data::Dumper'          => '2.161',
            'Devel::PPPort'         => '3.35',
            'Encode'                => '2.84',
            'Encode::MIME::Header'  => '2.23',
            'Encode::MIME::Header::ISO_2022_JP'=> '1.07',
            'ExtUtils::ParseXS'     => '3.33',
            'ExtUtils::ParseXS::Constants'=> '3.33',
            'ExtUtils::ParseXS::CountLines'=> '3.33',
            'ExtUtils::ParseXS::Eval'=> '3.33',
            'ExtUtils::ParseXS::Utilities'=> '3.33',
            'ExtUtils::Typemaps'    => '3.33',
            'ExtUtils::Typemaps::Cmd'=> '3.33',
            'ExtUtils::Typemaps::InputMap'=> '3.33',
            'ExtUtils::Typemaps::OutputMap'=> '3.33',
            'ExtUtils::Typemaps::Type'=> '3.33',
            'Hash::Util'            => '0.20',
            'Math::BigFloat'        => '1.999726',
            'Math::BigFloat::Trace' => '0.43',
            'Math::BigInt'          => '1.999726',
            'Math::BigInt::Calc'    => '1.999726',
            'Math::BigInt::CalcEmu' => '1.999726',
            'Math::BigInt::FastCalc'=> '0.42',
            'Math::BigInt::Trace'   => '0.43',
            'Math::BigRat'          => '0.260804',
            'Module::CoreList'      => '5.20160720',
            'Module::CoreList::TieHashDelta'=> '5.20160720',
            'Module::CoreList::Utils'=> '5.20160720',
            'Net::Cmd'              => '3.09',
            'Net::Config'           => '3.09',
            'Net::Domain'           => '3.09',
            'Net::FTP'              => '3.09',
            'Net::FTP::A'           => '3.09',
            'Net::FTP::E'           => '3.09',
            'Net::FTP::I'           => '3.09',
            'Net::FTP::L'           => '3.09',
            'Net::FTP::dataconn'    => '3.09',
            'Net::NNTP'             => '3.09',
            'Net::Netrc'            => '3.09',
            'Net::POP3'             => '3.09',
            'Net::SMTP'             => '3.09',
            'Net::Time'             => '3.09',
            'Parse::CPAN::Meta'     => '1.4422',
            'Perl::OSType'          => '1.010',
            'Test2'                 => '1.302045',
            'Test2::API'            => '1.302045',
            'Test2::API::Breakage'  => '1.302045',
            'Test2::API::Context'   => '1.302045',
            'Test2::API::Instance'  => '1.302045',
            'Test2::API::Stack'     => '1.302045',
            'Test2::Event'          => '1.302045',
            'Test2::Event::Bail'    => '1.302045',
            'Test2::Event::Diag'    => '1.302045',
            'Test2::Event::Exception'=> '1.302045',
            'Test2::Event::Generic' => '1.302045',
            'Test2::Event::Info'    => '1.302045',
            'Test2::Event::Note'    => '1.302045',
            'Test2::Event::Ok'      => '1.302045',
            'Test2::Event::Plan'    => '1.302045',
            'Test2::Event::Skip'    => '1.302045',
            'Test2::Event::Subtest' => '1.302045',
            'Test2::Event::Waiting' => '1.302045',
            'Test2::Formatter'      => '1.302045',
            'Test2::Formatter::TAP' => '1.302045',
            'Test2::Hub'            => '1.302045',
            'Test2::Hub::Interceptor'=> '1.302045',
            'Test2::Hub::Interceptor::Terminator'=> '1.302045',
            'Test2::Hub::Subtest'   => '1.302045',
            'Test2::IPC'            => '1.302045',
            'Test2::IPC::Driver'    => '1.302045',
            'Test2::IPC::Driver::Files'=> '1.302045',
            'Test2::Util'           => '1.302045',
            'Test2::Util::ExternalMeta'=> '1.302045',
            'Test2::Util::HashBase' => '1.302045',
            'Test2::Util::Trace'    => '1.302045',
            'Test::Builder'         => '1.302045',
            'Test::Builder::Formatter'=> '1.302045',
            'Test::Builder::Module' => '1.302045',
            'Test::Builder::Tester' => '1.302045',
            'Test::Builder::Tester::Color'=> '1.302045',
            'Test::Builder::TodoDiag'=> '1.302045',
            'Test::More'            => '1.302045',
            'Test::Simple'          => '1.302045',
            'Test::Tester'          => '1.302045',
            'Test::Tester::Capture' => '1.302045',
            'Test::Tester::CaptureRunner'=> '1.302045',
            'Test::Tester::Delegate'=> '1.302045',
            'Test::use::ok'         => '1.302045',
            'Time::HiRes'           => '1.9739',
            'Unicode'               => '9.0.0',
            'Unicode::UCD'          => '0.66',
            'XSLoader'              => '0.22',
            'bigint'                => '0.43',
            'bignum'                => '0.43',
            'bigrat'                => '0.43',
            'encoding'              => '2.17_01',
            'encoding::warnings'    => '0.13',
            'feature'               => '1.45',
            'ok'                    => '1.302045',
            'version'               => '0.9917',
            'version::regex'        => '0.9917',
            'warnings'              => '1.37',
        },
        removed => {
        }
    },
    5.025004 => {
        delta_from => 5.025003,
        changed => {
            'App::Cpan'             => '1.64_01',
            'App::Prove'            => '3.36_01',
            'App::Prove::State'     => '3.36_01',
            'App::Prove::State::Result'=> '3.36_01',
            'App::Prove::State::Result::Test'=> '3.36_01',
            'Archive::Tar'          => '2.10',
            'Archive::Tar::Constant'=> '2.10',
            'Archive::Tar::File'    => '2.10',
            'B'                     => '1.63',
            'B::Concise'            => '0.998',
            'B::Deparse'            => '1.38',
            'B::Op_private'         => '5.025004',
            'CPAN'                  => '2.14_01',
            'CPAN::Meta'            => '2.150010',
            'CPAN::Meta::Converter' => '2.150010',
            'CPAN::Meta::Feature'   => '2.150010',
            'CPAN::Meta::History'   => '2.150010',
            'CPAN::Meta::Merge'     => '2.150010',
            'CPAN::Meta::Prereqs'   => '2.150010',
            'CPAN::Meta::Spec'      => '2.150010',
            'CPAN::Meta::Validator' => '2.150010',
            'Carp'                  => '1.42',
            'Carp::Heavy'           => '1.42',
            'Compress::Zlib'        => '2.069_01',
            'Config'                => '5.025004',
            'Config::Perl::V'       => '0.27',
            'Cwd'                   => '3.65',
            'Digest'                => '1.17_01',
            'Digest::SHA'           => '5.96',
            'Encode'                => '2.86',
            'Errno'                 => '1.26',
            'ExtUtils::Command'     => '7.24',
            'ExtUtils::Command::MM' => '7.24',
            'ExtUtils::Liblist'     => '7.24',
            'ExtUtils::Liblist::Kid'=> '7.24',
            'ExtUtils::MM'          => '7.24',
            'ExtUtils::MM_AIX'      => '7.24',
            'ExtUtils::MM_Any'      => '7.24',
            'ExtUtils::MM_BeOS'     => '7.24',
            'ExtUtils::MM_Cygwin'   => '7.24',
            'ExtUtils::MM_DOS'      => '7.24',
            'ExtUtils::MM_Darwin'   => '7.24',
            'ExtUtils::MM_MacOS'    => '7.24',
            'ExtUtils::MM_NW5'      => '7.24',
            'ExtUtils::MM_OS2'      => '7.24',
            'ExtUtils::MM_QNX'      => '7.24',
            'ExtUtils::MM_UWIN'     => '7.24',
            'ExtUtils::MM_Unix'     => '7.24',
            'ExtUtils::MM_VMS'      => '7.24',
            'ExtUtils::MM_VOS'      => '7.24',
            'ExtUtils::MM_Win32'    => '7.24',
            'ExtUtils::MM_Win95'    => '7.24',
            'ExtUtils::MY'          => '7.24',
            'ExtUtils::MakeMaker'   => '7.24',
            'ExtUtils::MakeMaker::Config'=> '7.24',
            'ExtUtils::MakeMaker::Locale'=> '7.24',
            'ExtUtils::MakeMaker::version'=> '7.24',
            'ExtUtils::MakeMaker::version::regex'=> '7.24',
            'ExtUtils::Mkbootstrap' => '7.24',
            'ExtUtils::Mksymlists'  => '7.24',
            'ExtUtils::testlib'     => '7.24',
            'File::Fetch'           => '0.52',
            'File::Spec'            => '3.65',
            'File::Spec::AmigaOS'   => '3.65',
            'File::Spec::Cygwin'    => '3.65',
            'File::Spec::Epoc'      => '3.65',
            'File::Spec::Functions' => '3.65',
            'File::Spec::Mac'       => '3.65',
            'File::Spec::OS2'       => '3.65',
            'File::Spec::Unix'      => '3.65',
            'File::Spec::VMS'       => '3.65',
            'File::Spec::Win32'     => '3.65',
            'HTTP::Tiny'            => '0.064',
            'Hash::Util'            => '0.21',
            'I18N::LangTags'        => '0.41',
            'I18N::LangTags::Detect'=> '1.06',
            'IO'                    => '1.37',
            'IO::Compress::Adapter::Bzip2'=> '2.069_01',
            'IO::Compress::Adapter::Deflate'=> '2.069_01',
            'IO::Compress::Adapter::Identity'=> '2.069_01',
            'IO::Compress::Base'    => '2.069_01',
            'IO::Compress::Base::Common'=> '2.069_01',
            'IO::Compress::Bzip2'   => '2.069_01',
            'IO::Compress::Deflate' => '2.069_01',
            'IO::Compress::Gzip'    => '2.069_01',
            'IO::Compress::Gzip::Constants'=> '2.069_01',
            'IO::Compress::RawDeflate'=> '2.069_01',
            'IO::Compress::Zip'     => '2.069_01',
            'IO::Compress::Zip::Constants'=> '2.069_01',
            'IO::Compress::Zlib::Constants'=> '2.069_01',
            'IO::Compress::Zlib::Extra'=> '2.069_01',
            'IO::Socket::IP'        => '0.38',
            'IO::Uncompress::Adapter::Bunzip2'=> '2.069_01',
            'IO::Uncompress::Adapter::Identity'=> '2.069_01',
            'IO::Uncompress::Adapter::Inflate'=> '2.069_01',
            'IO::Uncompress::AnyInflate'=> '2.069_01',
            'IO::Uncompress::AnyUncompress'=> '2.069_01',
            'IO::Uncompress::Base'  => '2.069_01',
            'IO::Uncompress::Bunzip2'=> '2.069_01',
            'IO::Uncompress::Gunzip'=> '2.069_01',
            'IO::Uncompress::Inflate'=> '2.069_01',
            'IO::Uncompress::RawInflate'=> '2.069_01',
            'IO::Uncompress::Unzip' => '2.069_01',
            'IPC::Cmd'              => '0.96',
            'JSON::PP'              => '2.27400_01',
            'Locale::Maketext'      => '1.28',
            'Locale::Maketext::Simple'=> '0.21_01',
            'Math::BigFloat::Trace' => '0.43_01',
            'Math::BigInt::Trace'   => '0.43_01',
            'Memoize'               => '1.03_01',
            'Module::CoreList'      => '5.20160820',
            'Module::CoreList::TieHashDelta'=> '5.20160820',
            'Module::CoreList::Utils'=> '5.20160820',
            'Module::Load::Conditional'=> '0.68',
            'Module::Metadata'      => '1.000033',
            'NEXT'                  => '0.67',
            'Net::Cmd'              => '3.10',
            'Net::Config'           => '3.10',
            'Net::Domain'           => '3.10',
            'Net::FTP'              => '3.10',
            'Net::FTP::A'           => '3.10',
            'Net::FTP::E'           => '3.10',
            'Net::FTP::I'           => '3.10',
            'Net::FTP::L'           => '3.10',
            'Net::FTP::dataconn'    => '3.10',
            'Net::NNTP'             => '3.10',
            'Net::Netrc'            => '3.10',
            'Net::POP3'             => '3.10',
            'Net::Ping'             => '2.44',
            'Net::SMTP'             => '3.10',
            'Net::Time'             => '3.10',
            'Opcode'                => '1.37',
            'POSIX'                 => '1.71',
            'Parse::CPAN::Meta'     => '2.150010',
            'Pod::Html'             => '1.2201',
            'Pod::Perldoc'          => '3.27',
            'Pod::Perldoc::BaseTo'  => '3.27',
            'Pod::Perldoc::GetOptsOO'=> '3.27',
            'Pod::Perldoc::ToANSI'  => '3.27',
            'Pod::Perldoc::ToChecker'=> '3.27',
            'Pod::Perldoc::ToMan'   => '3.27',
            'Pod::Perldoc::ToNroff' => '3.27',
            'Pod::Perldoc::ToPod'   => '3.27',
            'Pod::Perldoc::ToRtf'   => '3.27',
            'Pod::Perldoc::ToTerm'  => '3.27',
            'Pod::Perldoc::ToText'  => '3.27',
            'Pod::Perldoc::ToTk'    => '3.27',
            'Pod::Perldoc::ToXml'   => '3.27',
            'Storable'              => '2.57',
            'Sys::Syslog'           => '0.34_01',
            'TAP::Base'             => '3.36_01',
            'TAP::Formatter::Base'  => '3.36_01',
           'TAP::Formatter::Color' => '3.36_01',
            'TAP::Formatter::Console'=> '3.36_01',
            'TAP::Formatter::Console::ParallelSession'=> '3.36_01',
            'TAP::Formatter::Console::Session'=> '3.36_01',
            'TAP::Formatter::File'  => '3.36_01',
            'TAP::Formatter::File::Session'=> '3.36_01',
            'TAP::Formatter::Session'=> '3.36_01',
            'TAP::Harness'          => '3.36_01',
            'TAP::Harness::Env'     => '3.36_01',
            'TAP::Object'           => '3.36_01',
            'TAP::Parser'           => '3.36_01',
            'TAP::Parser::Aggregator'=> '3.36_01',
            'TAP::Parser::Grammar'  => '3.36_01',
            'TAP::Parser::Iterator' => '3.36_01',
            'TAP::Parser::Iterator::Array'=> '3.36_01',
            'TAP::Parser::Iterator::Process'=> '3.36_01',
            'TAP::Parser::Iterator::Stream'=> '3.36_01',
            'TAP::Parser::IteratorFactory'=> '3.36_01',
            'TAP::Parser::Multiplexer'=> '3.36_01',
            'TAP::Parser::Result'   => '3.36_01',
            'TAP::Parser::Result::Bailout'=> '3.36_01',
            'TAP::Parser::Result::Comment'=> '3.36_01',
            'TAP::Parser::Result::Plan'=> '3.36_01',
            'TAP::Parser::Result::Pragma'=> '3.36_01',
            'TAP::Parser::Result::Test'=> '3.36_01',
            'TAP::Parser::Result::Unknown'=> '3.36_01',
            'TAP::Parser::Result::Version'=> '3.36_01',
            'TAP::Parser::Result::YAML'=> '3.36_01',
            'TAP::Parser::ResultFactory'=> '3.36_01',
            'TAP::Parser::Scheduler'=> '3.36_01',
            'TAP::Parser::Scheduler::Job'=> '3.36_01',
            'TAP::Parser::Scheduler::Spinner'=> '3.36_01',
            'TAP::Parser::Source'   => '3.36_01',
            'TAP::Parser::SourceHandler'=> '3.36_01',
            'TAP::Parser::SourceHandler::Executable'=> '3.36_01',
            'TAP::Parser::SourceHandler::File'=> '3.36_01',
            'TAP::Parser::SourceHandler::Handle'=> '3.36_01',
            'TAP::Parser::SourceHandler::Perl'=> '3.36_01',
            'TAP::Parser::SourceHandler::RawTAP'=> '3.36_01',
            'TAP::Parser::YAMLish::Reader'=> '3.36_01',
            'TAP::Parser::YAMLish::Writer'=> '3.36_01',
            'Test'                  => '1.29',
            'Test2'                 => '1.302052',
            'Test2::API'            => '1.302052',
            'Test2::API::Breakage'  => '1.302052',
            'Test2::API::Context'   => '1.302052',
            'Test2::API::Instance'  => '1.302052',
            'Test2::API::Stack'     => '1.302052',
            'Test2::Event'          => '1.302052',
            'Test2::Event::Bail'    => '1.302052',
            'Test2::Event::Diag'    => '1.302052',
            'Test2::Event::Exception'=> '1.302052',
            'Test2::Event::Generic' => '1.302052',
            'Test2::Event::Info'    => '1.302052',
            'Test2::Event::Note'    => '1.302052',
            'Test2::Event::Ok'      => '1.302052',
            'Test2::Event::Plan'    => '1.302052',
            'Test2::Event::Skip'    => '1.302052',
            'Test2::Event::Subtest' => '1.302052',
            'Test2::Event::Waiting' => '1.302052',
            'Test2::Formatter'      => '1.302052',
            'Test2::Formatter::TAP' => '1.302052',
            'Test2::Hub'            => '1.302052',
            'Test2::Hub::Interceptor'=> '1.302052',
            'Test2::Hub::Interceptor::Terminator'=> '1.302052',
            'Test2::Hub::Subtest'   => '1.302052',
            'Test2::IPC'            => '1.302052',
            'Test2::IPC::Driver'    => '1.302052',
            'Test2::IPC::Driver::Files'=> '1.302052',
            'Test2::Util'           => '1.302052',
            'Test2::Util::ExternalMeta'=> '1.302052',
            'Test2::Util::HashBase' => '1.302052',
            'Test2::Util::Trace'    => '1.302052',
            'Test::Builder'         => '1.302052',
            'Test::Builder::Formatter'=> '1.302052',
            'Test::Builder::Module' => '1.302052',
            'Test::Builder::Tester' => '1.302052',
            'Test::Builder::Tester::Color'=> '1.302052',
            'Test::Builder::TodoDiag'=> '1.302052',
            'Test::Harness'         => '3.36_01',
            'Test::More'            => '1.302052',
            'Test::Simple'          => '1.302052',
            'Test::Tester'          => '1.302052',
            'Test::Tester::Capture' => '1.302052',
            'Test::Tester::CaptureRunner'=> '1.302052',
            'Test::Tester::Delegate'=> '1.302052',
            'Test::use::ok'         => '1.302052',
            'Tie::Hash::NamedCapture'=> '0.10',
            'Time::Local'           => '1.24',
            'XS::APItest'           => '0.83',
            'arybase'               => '0.12',
            'base'                  => '2.24',
            'bigint'                => '0.43_01',
            'bignum'                => '0.43_01',
            'bigrat'                => '0.43_01',
            'encoding'              => '2.18',
            'ok'                    => '1.302052',
        },
        removed => {
        }
    },
    5.025005 => {
        delta_from => 5.025004,
        changed => {
            'B::Op_private'         => '5.025005',
            'Config'                => '5.025005',
            'Filter::Simple'        => '0.93',
            'Locale::Codes'         => '3.40',
            'Locale::Codes::Constants'=> '3.40',
            'Locale::Codes::Country'=> '3.40',
            'Locale::Codes::Country_Codes'=> '3.40',
            'Locale::Codes::Country_Retired'=> '3.40',
            'Locale::Codes::Currency'=> '3.40',
            'Locale::Codes::Currency_Codes'=> '3.40',
            'Locale::Codes::Currency_Retired'=> '3.40',
            'Locale::Codes::LangExt'=> '3.40',
            'Locale::Codes::LangExt_Codes'=> '3.40',
            'Locale::Codes::LangExt_Retired'=> '3.40',
            'Locale::Codes::LangFam'=> '3.40',
            'Locale::Codes::LangFam_Codes'=> '3.40',
            'Locale::Codes::LangFam_Retired'=> '3.40',
            'Locale::Codes::LangVar'=> '3.40',
            'Locale::Codes::LangVar_Codes'=> '3.40',
            'Locale::Codes::LangVar_Retired'=> '3.40',
            'Locale::Codes::Language'=> '3.40',
            'Locale::Codes::Language_Codes'=> '3.40',
            'Locale::Codes::Language_Retired'=> '3.40',
            'Locale::Codes::Script' => '3.40',
            'Locale::Codes::Script_Codes'=> '3.40',
            'Locale::Codes::Script_Retired'=> '3.40',
            'Locale::Country'       => '3.40',
            'Locale::Currency'      => '3.40',
            'Locale::Language'      => '3.40',
            'Locale::Script'        => '3.40',
            'Module::CoreList'      => '5.20160920',
            'Module::CoreList::TieHashDelta'=> '5.20160920',
            'Module::CoreList::Utils'=> '5.20160920',
            'POSIX'                 => '1.72',
            'Sys::Syslog'           => '0.35',
            'Test2'                 => '1.302056',
            'Test2::API'            => '1.302056',
            'Test2::API::Breakage'  => '1.302056',
            'Test2::API::Context'   => '1.302056',
            'Test2::API::Instance'  => '1.302056',
            'Test2::API::Stack'     => '1.302056',
            'Test2::Event'          => '1.302056',
            'Test2::Event::Bail'    => '1.302056',
            'Test2::Event::Diag'    => '1.302056',
            'Test2::Event::Exception'=> '1.302056',
            'Test2::Event::Generic' => '1.302056',
            'Test2::Event::Info'    => '1.302056',
            'Test2::Event::Note'    => '1.302056',
            'Test2::Event::Ok'      => '1.302056',
            'Test2::Event::Plan'    => '1.302056',
            'Test2::Event::Skip'    => '1.302056',
            'Test2::Event::Subtest' => '1.302056',
            'Test2::Event::Waiting' => '1.302056',
            'Test2::Formatter'      => '1.302056',
            'Test2::Formatter::TAP' => '1.302056',
            'Test2::Hub'            => '1.302056',
            'Test2::Hub::Interceptor'=> '1.302056',
            'Test2::Hub::Interceptor::Terminator'=> '1.302056',
            'Test2::Hub::Subtest'   => '1.302056',
            'Test2::IPC'            => '1.302056',
            'Test2::IPC::Driver'    => '1.302056',
            'Test2::IPC::Driver::Files'=> '1.302056',
            'Test2::Util'           => '1.302056',
            'Test2::Util::ExternalMeta'=> '1.302056',
            'Test2::Util::HashBase' => '1.302056',
            'Test2::Util::Trace'    => '1.302056',
            'Test::Builder'         => '1.302056',
            'Test::Builder::Formatter'=> '1.302056',
            'Test::Builder::Module' => '1.302056',
            'Test::Builder::Tester' => '1.302056',
            'Test::Builder::Tester::Color'=> '1.302056',
            'Test::Builder::TodoDiag'=> '1.302056',
            'Test::More'            => '1.302056',
            'Test::Simple'          => '1.302056',
            'Test::Tester'          => '1.302056',
            'Test::Tester::Capture' => '1.302056',
            'Test::Tester::CaptureRunner'=> '1.302056',
            'Test::Tester::Delegate'=> '1.302056',
            'Test::use::ok'         => '1.302056',
            'Thread::Semaphore'     => '2.13',
            'XS::APItest'           => '0.84',
            'XSLoader'              => '0.24',
            'ok'                    => '1.302056',
        },
        removed => {
        }
    },
    5.025006 => {
        delta_from => 5.025005,
        changed => {
            'Archive::Tar'          => '2.14',
            'Archive::Tar::Constant'=> '2.14',
            'Archive::Tar::File'    => '2.14',
            'B'                     => '1.64',
            'B::Concise'            => '0.999',
            'B::Deparse'            => '1.39',
            'B::Op_private'         => '5.025006',
            'Config'                => '5.025006',
            'Data::Dumper'          => '2.162',
            'Devel::Peek'           => '1.25',
            'HTTP::Tiny'            => '0.070',
            'List::Util'            => '1.46',
            'List::Util::XS'        => '1.46',
            'Module::CoreList'      => '5.20161020',
            'Module::CoreList::TieHashDelta'=> '5.20161020',
            'Module::CoreList::Utils'=> '5.20161020',
            'Net::Ping'             => '2.51',
            'OS2::DLL'              => '1.07',
            'Opcode'                => '1.38',
            'POSIX'                 => '1.73',
            'PerlIO::encoding'      => '0.25',
            'Pod::Man'              => '4.08',
            'Pod::ParseLink'        => '4.08',
            'Pod::Text'             => '4.08',
            'Pod::Text::Color'      => '4.08',
            'Pod::Text::Overstrike' => '4.08',
            'Pod::Text::Termcap'    => '4.08',
            'Scalar::Util'          => '1.46',
            'Storable'              => '2.58',
            'Sub::Util'             => '1.46',
            'Test2'                 => '1.302059',
            'Test2::API'            => '1.302059',
            'Test2::API::Breakage'  => '1.302059',
            'Test2::API::Context'   => '1.302059',
            'Test2::API::Instance'  => '1.302059',
            'Test2::API::Stack'     => '1.302059',
            'Test2::Event'          => '1.302059',
            'Test2::Event::Bail'    => '1.302059',
            'Test2::Event::Diag'    => '1.302059',
            'Test2::Event::Exception'=> '1.302059',
            'Test2::Event::Generic' => '1.302059',
            'Test2::Event::Info'    => '1.302059',
            'Test2::Event::Note'    => '1.302059',
            'Test2::Event::Ok'      => '1.302059',
            'Test2::Event::Plan'    => '1.302059',
            'Test2::Event::Skip'    => '1.302059',
            'Test2::Event::Subtest' => '1.302059',
            'Test2::Event::Waiting' => '1.302059',
            'Test2::Formatter'      => '1.302059',
            'Test2::Formatter::TAP' => '1.302059',
            'Test2::Hub'            => '1.302059',
            'Test2::Hub::Interceptor'=> '1.302059',
            'Test2::Hub::Interceptor::Terminator'=> '1.302059',
            'Test2::Hub::Subtest'   => '1.302059',
            'Test2::IPC'            => '1.302059',
            'Test2::IPC::Driver'    => '1.302059',
            'Test2::IPC::Driver::Files'=> '1.302059',
            'Test2::Util'           => '1.302059',
            'Test2::Util::ExternalMeta'=> '1.302059',
            'Test2::Util::HashBase' => '1.302059',
            'Test2::Util::Trace'    => '1.302059',
            'Test::Builder'         => '1.302059',
            'Test::Builder::Formatter'=> '1.302059',
            'Test::Builder::Module' => '1.302059',
            'Test::Builder::Tester' => '1.302059',
            'Test::Builder::Tester::Color'=> '1.302059',
            'Test::Builder::TodoDiag'=> '1.302059',
            'Test::More'            => '1.302059',
            'Test::Simple'          => '1.302059',
            'Test::Tester'          => '1.302059',
            'Test::Tester::Capture' => '1.302059',
            'Test::Tester::CaptureRunner'=> '1.302059',
            'Test::Tester::Delegate'=> '1.302059',
            'Test::use::ok'         => '1.302059',
            'Time::HiRes'           => '1.9740_01',
            'VMS::Stdio'            => '2.42',
            'XS::APItest'           => '0.86',
            'attributes'            => '0.28',
            'mro'                   => '1.19',
            'ok'                    => '1.302059',
            'overload'              => '1.27',
            'parent'                => '0.236',
        },
        removed => {
        }
    },
    5.025007 => {
        delta_from => 5.025006,
        changed => {
            'Archive::Tar'          => '2.18',
            'Archive::Tar::Constant'=> '2.18',
            'Archive::Tar::File'    => '2.18',
            'B'                     => '1.65',
            'B::Op_private'         => '5.025007',
            'Config'                => '5.025007',
            'Cwd'                   => '3.66',
            'Data::Dumper'          => '2.165',
            'Devel::Peek'           => '1.26',
            'DynaLoader'            => '1.40',
            'Errno'                 => '1.27',
            'ExtUtils::ParseXS::Utilities'=> '3.34',
            'File::Spec'            => '3.66',
            'File::Spec::AmigaOS'   => '3.66',
            'File::Spec::Cygwin'    => '3.66',
            'File::Spec::Epoc'      => '3.66',
            'File::Spec::Functions' => '3.66',
            'File::Spec::Mac'       => '3.66',
            'File::Spec::OS2'       => '3.66',
            'File::Spec::Unix'      => '3.66',
            'File::Spec::VMS'       => '3.66',
            'File::Spec::Win32'     => '3.66',
            'Hash::Util'            => '0.22',
            'JSON::PP'              => '2.27400_02',
            'List::Util'            => '1.46_02',
            'List::Util::XS'        => '1.46_02',
            'Math::BigFloat'        => '1.999727',
            'Math::BigInt'          => '1.999727',
            'Math::BigInt::Calc'    => '1.999727',
            'Math::BigInt::CalcEmu' => '1.999727',
            'Math::Complex'         => '1.5901',
            'Module::CoreList'      => '5.20161120',
            'Module::CoreList::TieHashDelta'=> '5.20161120',
            'Module::CoreList::Utils'=> '5.20161120',
            'Net::Ping'             => '2.55',
            'Opcode'                => '1.39',
            'POSIX'                 => '1.75',
            'Pod::Man'              => '4.09',
            'Pod::ParseLink'        => '4.09',
            'Pod::Text'             => '4.09',
            'Pod::Text::Color'      => '4.09',
            'Pod::Text::Overstrike' => '4.09',
            'Pod::Text::Termcap'    => '4.09',
            'Scalar::Util'          => '1.46_02',
            'Storable'              => '2.59',
            'Sub::Util'             => '1.46_02',
            'Term::ANSIColor'       => '4.06',
            'Test2'                 => '1.302062',
            'Test2::API'            => '1.302062',
            'Test2::API::Breakage'  => '1.302062',
            'Test2::API::Context'   => '1.302062',
            'Test2::API::Instance'  => '1.302062',
            'Test2::API::Stack'     => '1.302062',
            'Test2::Event'          => '1.302062',
            'Test2::Event::Bail'    => '1.302062',
            'Test2::Event::Diag'    => '1.302062',
            'Test2::Event::Exception'=> '1.302062',
            'Test2::Event::Generic' => '1.302062',
            'Test2::Event::Info'    => '1.302062',
            'Test2::Event::Note'    => '1.302062',
            'Test2::Event::Ok'      => '1.302062',
            'Test2::Event::Plan'    => '1.302062',
            'Test2::Event::Skip'    => '1.302062',
            'Test2::Event::Subtest' => '1.302062',
            'Test2::Event::Waiting' => '1.302062',
            'Test2::Formatter'      => '1.302062',
            'Test2::Formatter::TAP' => '1.302062',
            'Test2::Hub'            => '1.302062',
            'Test2::Hub::Interceptor'=> '1.302062',
            'Test2::Hub::Interceptor::Terminator'=> '1.302062',
            'Test2::Hub::Subtest'   => '1.302062',
            'Test2::IPC'            => '1.302062',
            'Test2::IPC::Driver'    => '1.302062',
            'Test2::IPC::Driver::Files'=> '1.302062',
            'Test2::Util'           => '1.302062',
            'Test2::Util::ExternalMeta'=> '1.302062',
            'Test2::Util::HashBase' => '1.302062',
            'Test2::Util::Trace'    => '1.302062',
            'Test::Builder'         => '1.302062',
            'Test::Builder::Formatter'=> '1.302062',
            'Test::Builder::Module' => '1.302062',
            'Test::Builder::Tester' => '1.302062',
            'Test::Builder::Tester::Color'=> '1.302062',
            'Test::Builder::TodoDiag'=> '1.302062',
            'Test::More'            => '1.302062',
            'Test::Simple'          => '1.302062',
            'Test::Tester'          => '1.302062',
            'Test::Tester::Capture' => '1.302062',
            'Test::Tester::CaptureRunner'=> '1.302062',
            'Test::Tester::Delegate'=> '1.302062',
            'Test::use::ok'         => '1.302062',
            'Time::HiRes'           => '1.9740_03',
            'Unicode::Collate'      => '1.18',
            'Unicode::Collate::CJK::Big5'=> '1.18',
            'Unicode::Collate::CJK::GB2312'=> '1.18',
            'Unicode::Collate::CJK::JISX0208'=> '1.18',
            'Unicode::Collate::CJK::Korean'=> '1.18',
            'Unicode::Collate::CJK::Pinyin'=> '1.18',
            'Unicode::Collate::CJK::Stroke'=> '1.18',
            'Unicode::Collate::CJK::Zhuyin'=> '1.18',
            'Unicode::Collate::Locale'=> '1.18',
            'Unicode::UCD'          => '0.67',
            'XS::APItest'           => '0.87',
            'XS::Typemap'           => '0.15',
            'mro'                   => '1.20',
            'ok'                    => '1.302062',
            'threads'               => '2.10',
        },
        removed => {
        }
    },
    5.025008 => {
        delta_from => 5.025007,
        changed => {
            'Archive::Tar'          => '2.24',
            'Archive::Tar::Constant'=> '2.24',
            'Archive::Tar::File'    => '2.24',
            'B::Debug'              => '1.24',
            'B::Op_private'         => '5.025008',
            'Config'                => '5.025008',
            'Data::Dumper'          => '2.166',
            'Encode'                => '2.88',
            'Encode::Alias'         => '2.21',
            'Encode::CN::HZ'        => '2.08',
            'Encode::MIME::Header'  => '2.24',
            'Encode::MIME::Name'    => '1.02',
            'Encode::Unicode'       => '2.1501',
            'IO'                    => '1.38',
            'Locale::Codes'         => '3.42',
            'Locale::Codes::Constants'=> '3.42',
            'Locale::Codes::Country'=> '3.42',
            'Locale::Codes::Country_Codes'=> '3.42',
            'Locale::Codes::Country_Retired'=> '3.42',
            'Locale::Codes::Currency'=> '3.42',
            'Locale::Codes::Currency_Codes'=> '3.42',
            'Locale::Codes::Currency_Retired'=> '3.42',
            'Locale::Codes::LangExt'=> '3.42',
            'Locale::Codes::LangExt_Codes'=> '3.42',
            'Locale::Codes::LangExt_Retired'=> '3.42',
            'Locale::Codes::LangFam'=> '3.42',
            'Locale::Codes::LangFam_Codes'=> '3.42',
            'Locale::Codes::LangFam_Retired'=> '3.42',
            'Locale::Codes::LangVar'=> '3.42',
            'Locale::Codes::LangVar_Codes'=> '3.42',
            'Locale::Codes::LangVar_Retired'=> '3.42',
            'Locale::Codes::Language'=> '3.42',
            'Locale::Codes::Language_Codes'=> '3.42',
            'Locale::Codes::Language_Retired'=> '3.42',
            'Locale::Codes::Script' => '3.42',
            'Locale::Codes::Script_Codes'=> '3.42',
            'Locale::Codes::Script_Retired'=> '3.42',
            'Locale::Country'       => '3.42',
            'Locale::Currency'      => '3.42',
            'Locale::Language'      => '3.42',
            'Locale::Script'        => '3.42',
            'Math::BigFloat'        => '1.999806',
            'Math::BigFloat::Trace' => '0.47',
            'Math::BigInt'          => '1.999806',
            'Math::BigInt::Calc'    => '1.999806',
            'Math::BigInt::CalcEmu' => '1.999806',
            'Math::BigInt::FastCalc'=> '0.5005',
            'Math::BigInt::Lib'     => '1.999806',
            'Math::BigInt::Trace'   => '0.47',
            'Math::BigRat'          => '0.2611',
            'Module::CoreList'      => '5.20161220',
            'Module::CoreList::TieHashDelta'=> '5.20161220',
            'Module::CoreList::Utils'=> '5.20161220',
            'POSIX'                 => '1.76',
            'PerlIO::scalar'        => '0.25',
            'Pod::Simple'           => '3.35',
            'Pod::Simple::BlackBox' => '3.35',
            'Pod::Simple::Checker'  => '3.35',
            'Pod::Simple::Debug'    => '3.35',
            'Pod::Simple::DumpAsText'=> '3.35',
            'Pod::Simple::DumpAsXML'=> '3.35',
            'Pod::Simple::HTML'     => '3.35',
            'Pod::Simple::HTMLBatch'=> '3.35',
            'Pod::Simple::LinkSection'=> '3.35',
            'Pod::Simple::Methody'  => '3.35',
            'Pod::Simple::Progress' => '3.35',
            'Pod::Simple::PullParser'=> '3.35',
            'Pod::Simple::PullParserEndToken'=> '3.35',
            'Pod::Simple::PullParserStartToken'=> '3.35',
            'Pod::Simple::PullParserTextToken'=> '3.35',
            'Pod::Simple::PullParserToken'=> '3.35',
            'Pod::Simple::RTF'      => '3.35',
            'Pod::Simple::Search'   => '3.35',
            'Pod::Simple::SimpleTree'=> '3.35',
            'Pod::Simple::Text'     => '3.35',
            'Pod::Simple::TextContent'=> '3.35',
            'Pod::Simple::TiedOutFH'=> '3.35',
            'Pod::Simple::Transcode'=> '3.35',
            'Pod::Simple::TranscodeDumb'=> '3.35',
            'Pod::Simple::TranscodeSmart'=> '3.35',
            'Pod::Simple::XHTML'    => '3.35',
            'Pod::Simple::XMLOutStream'=> '3.35',
            'Test2'                 => '1.302073',
            'Test2::API'            => '1.302073',
            'Test2::API::Breakage'  => '1.302073',
            'Test2::API::Context'   => '1.302073',
            'Test2::API::Instance'  => '1.302073',
            'Test2::API::Stack'     => '1.302073',
            'Test2::Event'          => '1.302073',
            'Test2::Event::Bail'    => '1.302073',
            'Test2::Event::Diag'    => '1.302073',
            'Test2::Event::Encoding'=> '1.302073',
            'Test2::Event::Exception'=> '1.302073',
            'Test2::Event::Generic' => '1.302073',
            'Test2::Event::Info'    => '1.302073',
            'Test2::Event::Note'    => '1.302073',
            'Test2::Event::Ok'      => '1.302073',
            'Test2::Event::Plan'    => '1.302073',
            'Test2::Event::Skip'    => '1.302073',
            'Test2::Event::Subtest' => '1.302073',
            'Test2::Event::TAP::Version'=> '1.302073',
            'Test2::Event::Waiting' => '1.302073',
            'Test2::Formatter'      => '1.302073',
            'Test2::Formatter::TAP' => '1.302073',
            'Test2::Hub'            => '1.302073',
            'Test2::Hub::Interceptor'=> '1.302073',
            'Test2::Hub::Interceptor::Terminator'=> '1.302073',
            'Test2::Hub::Subtest'   => '1.302073',
            'Test2::IPC'            => '1.302073',
            'Test2::IPC::Driver'    => '1.302073',
            'Test2::IPC::Driver::Files'=> '1.302073',
            'Test2::Tools::Tiny'    => '1.302073',
            'Test2::Util'           => '1.302073',
            'Test2::Util::ExternalMeta'=> '1.302073',
            'Test2::Util::HashBase' => '0.002',
            'Test2::Util::Trace'    => '1.302073',
            'Test::Builder'         => '1.302073',
            'Test::Builder::Formatter'=> '1.302073',
            'Test::Builder::Module' => '1.302073',
            'Test::Builder::Tester' => '1.302073',
            'Test::Builder::Tester::Color'=> '1.302073',
            'Test::Builder::TodoDiag'=> '1.302073',
            'Test::More'            => '1.302073',
            'Test::Simple'          => '1.302073',
            'Test::Tester'          => '1.302073',
            'Test::Tester::Capture' => '1.302073',
            'Test::Tester::CaptureRunner'=> '1.302073',
            'Test::Tester::Delegate'=> '1.302073',
            'Test::use::ok'         => '1.302073',
            'Time::HiRes'           => '1.9741',
            'Time::Local'           => '1.25',
            'Unicode::Collate'      => '1.19',
            'Unicode::Collate::CJK::Big5'=> '1.19',
            'Unicode::Collate::CJK::GB2312'=> '1.19',
            'Unicode::Collate::CJK::JISX0208'=> '1.19',
            'Unicode::Collate::CJK::Korean'=> '1.19',
            'Unicode::Collate::CJK::Pinyin'=> '1.19',
            'Unicode::Collate::CJK::Stroke'=> '1.19',
            'Unicode::Collate::CJK::Zhuyin'=> '1.19',
            'Unicode::Collate::Locale'=> '1.19',
            'bigint'                => '0.47',
            'bignum'                => '0.47',
            'bigrat'                => '0.47',
            'encoding'              => '2.19',
            'ok'                    => '1.302073',
        },
        removed => {
        }
    },
    5.024001 => {
        delta_from => 5.024000,
        changed => {
            'App::Cpan'             => '1.63_01',
            'App::Prove'            => '3.36_01',
            'App::Prove::State'     => '3.36_01',
            'App::Prove::State::Result'=> '3.36_01',
            'App::Prove::State::Result::Test'=> '3.36_01',
            'Archive::Tar'          => '2.04_01',
            'Archive::Tar::Constant'=> '2.04_01',
            'Archive::Tar::File'    => '2.04_01',
            'B::Op_private'         => '5.024001',
            'CPAN'                  => '2.11_01',
            'Compress::Zlib'        => '2.069_001',
            'Config'                => '5.024001',
            'Cwd'                   => '3.63_01',
            'Digest'                => '1.17_01',
            'Digest::SHA'           => '5.95_01',
            'Encode'                => '2.80_01',
            'ExtUtils::Command'     => '7.10_02',
            'ExtUtils::Command::MM' => '7.10_02',
            'ExtUtils::Liblist'     => '7.10_02',
            'ExtUtils::Liblist::Kid'=> '7.10_02',
            'ExtUtils::MM'          => '7.10_02',
            'ExtUtils::MM_AIX'      => '7.10_02',
            'ExtUtils::MM_Any'      => '7.10_02',
            'ExtUtils::MM_BeOS'     => '7.10_02',
            'ExtUtils::MM_Cygwin'   => '7.10_02',
            'ExtUtils::MM_DOS'      => '7.10_02',
            'ExtUtils::MM_Darwin'   => '7.10_02',
            'ExtUtils::MM_MacOS'    => '7.10_02',
            'ExtUtils::MM_NW5'      => '7.10_02',
            'ExtUtils::MM_OS2'      => '7.10_02',
            'ExtUtils::MM_QNX'      => '7.10_02',
            'ExtUtils::MM_UWIN'     => '7.10_02',
            'ExtUtils::MM_Unix'     => '7.10_02',
            'ExtUtils::MM_VMS'      => '7.10_02',
            'ExtUtils::MM_VOS'      => '7.10_02',
            'ExtUtils::MM_Win32'    => '7.10_02',
            'ExtUtils::MM_Win95'    => '7.10_02',
            'ExtUtils::MY'          => '7.10_02',
            'ExtUtils::MakeMaker'   => '7.10_02',
            'ExtUtils::MakeMaker::Config'=> '7.10_02',
            'ExtUtils::Mkbootstrap' => '7.10_02',
            'ExtUtils::Mksymlists'  => '7.10_02',
            'ExtUtils::testlib'     => '7.10_02',
            'File::Fetch'           => '0.48_01',
            'File::Spec'            => '3.63_01',
            'File::Spec::Cygwin'    => '3.63_01',
            'File::Spec::Epoc'      => '3.63_01',
            'File::Spec::Functions' => '3.63_01',
            'File::Spec::Mac'       => '3.63_01',
            'File::Spec::OS2'       => '3.63_01',
            'File::Spec::Unix'      => '3.63_01',
            'File::Spec::VMS'       => '3.63_01',
            'File::Spec::Win32'     => '3.63_01',
            'HTTP::Tiny'            => '0.056_001',
            'I18N::LangTags::Detect'=> '1.05_01',
            'IO'                    => '1.36_01',
            'IO::Compress::Adapter::Bzip2'=> '2.069_001',
            'IO::Compress::Adapter::Deflate'=> '2.069_001',
            'IO::Compress::Adapter::Identity'=> '2.069_001',
            'IO::Compress::Base'    => '2.069_001',
            'IO::Compress::Base::Common'=> '2.069_001',
            'IO::Compress::Bzip2'   => '2.069_001',
            'IO::Compress::Deflate' => '2.069_001',
            'IO::Compress::Gzip'    => '2.069_001',
            'IO::Compress::Gzip::Constants'=> '2.069_001',
            'IO::Compress::RawDeflate'=> '2.069_001',
            'IO::Compress::Zip'     => '2.069_001',
            'IO::Compress::Zip::Constants'=> '2.069_001',
            'IO::Compress::Zlib::Constants'=> '2.069_001',
            'IO::Compress::Zlib::Extra'=> '2.069_001',
            'IO::Uncompress::Adapter::Bunzip2'=> '2.069_001',
            'IO::Uncompress::Adapter::Identity'=> '2.069_001',
            'IO::Uncompress::Adapter::Inflate'=> '2.069_001',
            'IO::Uncompress::AnyInflate'=> '2.069_001',
            'IO::Uncompress::AnyUncompress'=> '2.069_001',
            'IO::Uncompress::Base'  => '2.069_001',
            'IO::Uncompress::Bunzip2'=> '2.069_001',
            'IO::Uncompress::Gunzip'=> '2.069_001',
            'IO::Uncompress::Inflate'=> '2.069_001',
            'IO::Uncompress::RawInflate'=> '2.069_001',
            'IO::Uncompress::Unzip' => '2.069_001',
            'IPC::Cmd'              => '0.92_01',
            'JSON::PP'              => '2.27300_01',
            'Locale::Maketext'      => '1.26_01',
            'Locale::Maketext::Simple'=> '0.21_01',
            'Math::BigFloat::Trace' => '0.42_01',
            'Math::BigInt::Trace'   => '0.42_01',
            'Memoize'               => '1.03_01',
            'Module::CoreList'      => '5.20170114_24',
            'Module::CoreList::TieHashDelta'=> '5.20170114_24',
            'Module::CoreList::Utils'=> '5.20170114_24',
            'Module::Metadata::corpus::BOMTest::UTF16BE'=> undef,
            'Module::Metadata::corpus::BOMTest::UTF16LE'=> undef,
            'Module::Metadata::corpus::BOMTest::UTF8'=> '1',
            'Net::Cmd'              => '3.08_01',
            'Net::Config'           => '3.08_01',
            'Net::Domain'           => '3.08_01',
            'Net::FTP'              => '3.08_01',
            'Net::FTP::A'           => '3.08_01',
            'Net::FTP::E'           => '3.08_01',
            'Net::FTP::I'           => '3.08_01',
            'Net::FTP::L'           => '3.08_01',
            'Net::FTP::dataconn'    => '3.08_01',
            'Net::NNTP'             => '3.08_01',
            'Net::Netrc'            => '3.08_01',
            'Net::POP3'             => '3.08_01',
            'Net::Ping'             => '2.43_01',
            'Net::SMTP'             => '3.08_01',
            'Net::Time'             => '3.08_01',
            'Parse::CPAN::Meta'     => '1.4417_001',
            'Pod::Html'             => '1.2201',
            'Pod::Perldoc'          => '3.25_03',
            'Storable'              => '2.56_01',
            'Sys::Syslog'           => '0.33_01',
            'TAP::Base'             => '3.36_01',
            'TAP::Formatter::Base'  => '3.36_01',
            'TAP::Formatter::Color' => '3.36_01',
            'TAP::Formatter::Console'=> '3.36_01',
            'TAP::Formatter::Console::ParallelSession'=> '3.36_01',
            'TAP::Formatter::Console::Session'=> '3.36_01',
            'TAP::Formatter::File'  => '3.36_01',
            'TAP::Formatter::File::Session'=> '3.36_01',
            'TAP::Formatter::Session'=> '3.36_01',
            'TAP::Harness'          => '3.36_01',
            'TAP::Harness::Env'     => '3.36_01',
            'TAP::Object'           => '3.36_01',
            'TAP::Parser'           => '3.36_01',
            'TAP::Parser::Aggregator'=> '3.36_01',
            'TAP::Parser::Grammar'  => '3.36_01',
            'TAP::Parser::Iterator' => '3.36_01',
            'TAP::Parser::Iterator::Array'=> '3.36_01',
            'TAP::Parser::Iterator::Process'=> '3.36_01',
            'TAP::Parser::Iterator::Stream'=> '3.36_01',
            'TAP::Parser::IteratorFactory'=> '3.36_01',
            'TAP::Parser::Multiplexer'=> '3.36_01',
            'TAP::Parser::Result'   => '3.36_01',
            'TAP::Parser::Result::Bailout'=> '3.36_01',
            'TAP::Parser::Result::Comment'=> '3.36_01',
            'TAP::Parser::Result::Plan'=> '3.36_01',
            'TAP::Parser::Result::Pragma'=> '3.36_01',
            'TAP::Parser::Result::Test'=> '3.36_01',
            'TAP::Parser::Result::Unknown'=> '3.36_01',
            'TAP::Parser::Result::Version'=> '3.36_01',
            'TAP::Parser::Result::YAML'=> '3.36_01',
            'TAP::Parser::ResultFactory'=> '3.36_01',
            'TAP::Parser::Scheduler'=> '3.36_01',
            'TAP::Parser::Scheduler::Job'=> '3.36_01',
            'TAP::Parser::Scheduler::Spinner'=> '3.36_01',
            'TAP::Parser::Source'   => '3.36_01',
            'TAP::Parser::SourceHandler'=> '3.36_01',
            'TAP::Parser::SourceHandler::Executable'=> '3.36_01',
            'TAP::Parser::SourceHandler::File'=> '3.36_01',
            'TAP::Parser::SourceHandler::Handle'=> '3.36_01',
            'TAP::Parser::SourceHandler::Perl'=> '3.36_01',
            'TAP::Parser::SourceHandler::RawTAP'=> '3.36_01',
            'TAP::Parser::YAMLish::Reader'=> '3.36_01',
            'TAP::Parser::YAMLish::Writer'=> '3.36_01',
            'Test'                  => '1.28_01',
            'Test::Harness'         => '3.36_01',
            'XSLoader'              => '0.22',
            'bigint'                => '0.42_01',
            'bignum'                => '0.42_01',
            'bigrat'                => '0.42_01',
        },
        removed => {
        }
    },
);

sub is_core
{
    my $module = shift;
    $module = shift if eval { $module->isa(__PACKAGE__) } && @_ > 0 && defined($_[0]) && $_[0] =~ /^\w/;
    my ($module_version, $perl_version);

    $module_version = shift if @_ > 0;
    $perl_version   = @_ > 0 ? shift : $];

    my $first_release = first_release($module);

    return 0 if !defined($first_release) || $first_release > $perl_version;

    my $final_release = removed_from($module);

    return 0 if defined($final_release) && $perl_version >= $final_release;

    # If a minimum version of the module was specified:
    # Step through all perl releases ($prn)
    # so we can find what version of the module
    # was included in the specified version of perl.
    # On the way if we pass the required module version, we can
    # short-circuit and return true
    if (defined($module_version)) {
        # The Perl releases aren't a linear sequence, but a tree. We need to build the path
        # of releases from 5 to the specified release, and follow the module's version(s)
        # along that path.
        my @releases = ($perl_version);
        my $rel = $perl_version;
        while (defined($rel)) {
            # XXX: This line is a sign of failure. -- rjbs, 2015-04-15
            my $this_delta = $delta{$rel} || $delta{ sprintf '%0.6f', $rel };
            $rel = $this_delta->{delta_from};
            unshift(@releases, $rel) if defined($rel);
        }
        RELEASE:
        foreach my $prn (@releases) {
            next RELEASE if $prn < $first_release;
            last RELEASE if $prn > $perl_version;
            next unless defined(my $next_module_version
                                   = $delta{$prn}->{changed}->{$module});
            return 1 if version->parse($next_module_version) >= version->parse($module_version);
        }
        return 0;
    }

    return 1 if !defined($final_release);

    return $perl_version <= $final_release;
}

for my $version (sort { $a <=> $b } keys %delta) {
    my $data = $delta{$version};

    tie %{$version{$version}}, 'Module::CoreList::TieHashDelta',
        $data->{changed}, $data->{removed},
        $data->{delta_from} ? $version{$data->{delta_from}} : undef;
}

%deprecated = (
    5.011    => {
        changed => { map { $_ => 1 } qw/
            Class::ISA
            Pod::Plainer
            Shell
            Switch
        /},
    },
    5.011001 => { delta_from => 5.011 },
    5.011002 => { delta_from => 5.011001 },
    5.011003 => { delta_from => 5.011002 },
    5.011004 => { delta_from => 5.011003 },
    5.011005 => { delta_from => 5.011004 },

    5.012    => { delta_from => 5.011005 },
    5.012001 => { delta_from => 5.012 },
    5.012002 => { delta_from => 5.012001 },
    5.012003 => { delta_from => 5.012002 },
    5.012004 => { delta_from => 5.012003 },
    5.012005 => { delta_from => 5.012004 },

    5.013    => { delta_from => 5.012005 },
    5.013001 => {
        delta_from => 5.013,
        removed => { map { $_ => 1 } qw/
            Class::ISA
            Pod::Plainer
            Switch
        /},
    },
    5.013002 => { delta_from => 5.013001 },
    5.013003 => { delta_from => 5.013002 },
    5.013004 => { delta_from => 5.013003 },
    5.013005 => { delta_from => 5.013004 },
    5.013006 => { delta_from => 5.013005 },
    5.013007 => { delta_from => 5.013006 },
    5.013008 => { delta_from => 5.013007 },
    5.013009 => { delta_from => 5.013008 },
    5.01301  => { delta_from => 5.013009 },
    5.013011 => { delta_from => 5.01301  },

    5.014    => { delta_from => 5.013011 },
    5.014001 => { delta_from => 5.014    },
    5.014002 => { delta_from => 5.014001 },
    5.014003 => { delta_from => 5.014002 },
    5.014004 => { delta_from => 5.014003 },

    5.015    => {
        delta_from => 5.014004,
        removed => { Shell => 1 },
    },
    5.015001 => { delta_from => 5.015    },
    5.015002 => { delta_from => 5.015001 },
    5.015003 => { delta_from => 5.015002 },
    5.015004 => { delta_from => 5.015003 },
    5.015005 => { delta_from => 5.015004 },
    5.015006 => { delta_from => 5.015005 },
    5.015007 => { delta_from => 5.015006 },
    5.015008 => { delta_from => 5.015007 },
    5.015009 => { delta_from => 5.015008 },

    5.016    => { delta_from => 5.015009 },
    5.016001 => { delta_from => 5.016    },
    5.016002 => { delta_from => 5.016001 },
    5.016003 => { delta_from => 5.016002 },

    5.017    => { delta_from => 5.016003 },
    5.017001 => { delta_from => 5.017    },
    5.017002 => { delta_from => 5.017001 },
    5.017003 => { delta_from => 5.017002 },
    5.017004 => { delta_from => 5.017003 },
    5.017005 => { delta_from => 5.017004 },
    5.017006 => { delta_from => 5.017005 },
    5.017007 => { delta_from => 5.017006 },
    5.017008 => {
        delta_from => 5.017007,
        changed => { 'Pod::LaTeX' => 1 },
    },
    5.017009 => {
        delta_from => 5.017008,
        changed => { map { $_ => 1 } qw/
            Archive::Extract
            B::Lint
            B::Lint::Debug
            CPANPLUS
            CPANPLUS::Backend
            CPANPLUS::Backend::RV
            CPANPLUS::Config
            CPANPLUS::Config::HomeEnv
            CPANPLUS::Configure
            CPANPLUS::Configure::Setup
            CPANPLUS::Dist
            CPANPLUS::Dist::Autobundle
            CPANPLUS::Dist::Base
            CPANPLUS::Dist::Build
            CPANPLUS::Dist::Build::Constants
            CPANPLUS::Dist::MM
            CPANPLUS::Dist::Sample
            CPANPLUS::Error
            CPANPLUS::Internals
            CPANPLUS::Internals::Constants
            CPANPLUS::Internals::Constants::Report
            CPANPLUS::Internals::Extract
            CPANPLUS::Internals::Fetch
            CPANPLUS::Internals::Report
            CPANPLUS::Internals::Search
            CPANPLUS::Internals::Source
            CPANPLUS::Internals::Source::Memory
            CPANPLUS::Internals::Source::SQLite
            CPANPLUS::Internals::Source::SQLite::Tie
            CPANPLUS::Internals::Utils
            CPANPLUS::Internals::Utils::Autoflush
            CPANPLUS::Module
            CPANPLUS::Module::Author
            CPANPLUS::Module::Author::Fake
            CPANPLUS::Module::Checksums
            CPANPLUS::Module::Fake
            CPANPLUS::Module::Signature
            CPANPLUS::Selfupdate
            CPANPLUS::Shell
            CPANPLUS::Shell::Classic
            CPANPLUS::Shell::Default
            CPANPLUS::Shell::Default::Plugins::CustomSource
            CPANPLUS::Shell::Default::Plugins::Remote
            CPANPLUS::Shell::Default::Plugins::Source
            Devel::InnerPackage
            File::CheckTree
            Log::Message
            Log::Message::Config
            Log::Message::Handlers
            Log::Message::Item
            Log::Message::Simple
            Module::Pluggable
            Module::Pluggable::Object
            Object::Accessor
            Term::UI
            Term::UI::History
            Text::Soundex
        /},
    },
    5.01701  => { delta_from => 5.017009 },
    5.017011 => { delta_from => 5.01701  },

    5.018    => { delta_from => 5.017011 },
    5.018001 => {
        delta_from => 5.018,
        changed => {
        },
        removed => {
        }
    },
    5.018002 => {
        delta_from => 5.018001,
        changed => {
        },
        removed => {
        }
    },
    5.018003 => {
        delta_from => 5.018,
        changed => {
        },
        removed => {
        }
    },
    5.018004 => {
        delta_from => 5.018,
        changed => {
        },
        removed => {
        }
    },

    5.019    => {
        delta_from => 5.018,
        changed => { 'Module::Build' => 1 },
        removed => { map { $_ => 1 } qw/
            Archive::Extract
            B::Lint
            B::Lint::Debug
            CPANPLUS
            CPANPLUS::Backend
            CPANPLUS::Backend::RV
            CPANPLUS::Config
            CPANPLUS::Config::HomeEnv
            CPANPLUS::Configure
            CPANPLUS::Configure::Setup
            CPANPLUS::Dist
            CPANPLUS::Dist::Autobundle
            CPANPLUS::Dist::Base
            CPANPLUS::Dist::Build
            CPANPLUS::Dist::Build::Constants
            CPANPLUS::Dist::MM
            CPANPLUS::Dist::Sample
            CPANPLUS::Error
            CPANPLUS::Internals
            CPANPLUS::Internals::Constants
            CPANPLUS::Internals::Constants::Report
            CPANPLUS::Internals::Extract
            CPANPLUS::Internals::Fetch
            CPANPLUS::Internals::Report
            CPANPLUS::Internals::Search
            CPANPLUS::Internals::Source
            CPANPLUS::Internals::Source::Memory
            CPANPLUS::Internals::Source::SQLite
            CPANPLUS::Internals::Source::SQLite::Tie
            CPANPLUS::Internals::Utils
            CPANPLUS::Internals::Utils::Autoflush
            CPANPLUS::Module
            CPANPLUS::Module::Author
            CPANPLUS::Module::Author::Fake
            CPANPLUS::Module::Checksums
            CPANPLUS::Module::Fake
            CPANPLUS::Module::Signature
            CPANPLUS::Selfupdate
            CPANPLUS::Shell
            CPANPLUS::Shell::Classic
            CPANPLUS::Shell::Default
            CPANPLUS::Shell::Default::Plugins::CustomSource
            CPANPLUS::Shell::Default::Plugins::Remote
            CPANPLUS::Shell::Default::Plugins::Source
            Devel::InnerPackage
            File::CheckTree
            Log::Message
            Log::Message::Config
            Log::Message::Handlers
            Log::Message::Item
            Log::Message::Simple
            Module::Pluggable
            Module::Pluggable::Object
            Object::Accessor
            Pod::LaTeX
            Term::UI
            Term::UI::History
            Text::Soundex
        /}
    },
    5.019001 => {
        delta_from => 5.019,
        changed => {
        },
        removed => {
        }
    },
    5.019002 => {
        delta_from => 5.019001,
        changed => {
        },
        removed => {
        }
    },
    5.019003 => {
        delta_from => 5.019002,
        changed => {
        },
        removed => {
        }
    },
    5.019004 => {
        delta_from => 5.019003,
        changed => {
            'Module::Build::Base'   => '1',
            'Module::Build::Compat' => '1',
            'Module::Build::Config' => '1',
            'Module::Build::ConfigData'=> '1',
            'Module::Build::Cookbook'=> '1',
            'Module::Build::Dumper' => '1',
            'Module::Build::ModuleInfo'=> '1',
            'Module::Build::Notes'  => '1',
            'Module::Build::PPMMaker'=> '1',
            'Module::Build::Platform::Default'=> '1',
            'Module::Build::Platform::MacOS'=> '1',
            'Module::Build::Platform::Unix'=> '1',
            'Module::Build::Platform::VMS'=> '1',
            'Module::Build::Platform::VOS'=> '1',
            'Module::Build::Platform::Windows'=> '1',
            'Module::Build::Platform::aix'=> '1',
            'Module::Build::Platform::cygwin'=> '1',
            'Module::Build::Platform::darwin'=> '1',
            'Module::Build::Platform::os2'=> '1',
            'Module::Build::PodParser'=> '1',
            'Module::Build::Version'=> '1',
            'Module::Build::YAML'   => '1',
            'inc::latest'           => '1',
        },
        removed => {
        }
    },
    5.019005 => {
        delta_from => 5.019004,
        changed => {
        },
        removed => {
        }
    },
    5.019006 => {
        delta_from => 5.019005,
        changed => {
            'Package::Constants'    => '1',
        },
        removed => {
        }
    },
    5.019007 => {
        delta_from => 5.019006,
        changed => {
            'CGI'                   => '1',
            'CGI::Apache'           => '1',
            'CGI::Carp'             => '1',
            'CGI::Cookie'           => '1',
            'CGI::Fast'             => '1',
            'CGI::Pretty'           => '1',
            'CGI::Push'             => '1',
            'CGI::Switch'           => '1',
            'CGI::Util'             => '1',
        },
        removed => {
        }
    },
    5.019008 => {
        delta_from => 5.019007,
        changed => {
        },
        removed => {
        }
    },
    5.019009 => {
        delta_from => 5.019008,
        changed => {
        },
        removed => {
        }
    },
    5.01901 => {
        delta_from => 5.019009,
        changed => {
        },
        removed => {
        }
    },
    5.019011 => {
        delta_from => 5.019010,
        changed => {
        },
        removed => {
        }
    },
    5.020000 => {
        delta_from => 5.019011,
        changed => {
        },
        removed => {
        }
    },
    5.021000 => {
        delta_from => 5.020000,
        changed => {
        },
        removed => {
            'CGI'                   => 1,
            'CGI::Apache'           => 1,
            'CGI::Carp'             => 1,
            'CGI::Cookie'           => 1,
            'CGI::Fast'             => 1,
            'CGI::Pretty'           => 1,
            'CGI::Push'             => 1,
            'CGI::Switch'           => 1,
            'CGI::Util'             => 1,
            'Module::Build'         => 1,
            'Module::Build::Base'   => 1,
            'Module::Build::Compat' => 1,
            'Module::Build::Config' => 1,
            'Module::Build::ConfigData'=> 1,
            'Module::Build::Cookbook'=> 1,
            'Module::Build::Dumper' => 1,
            'Module::Build::ModuleInfo'=> 1,
            'Module::Build::Notes'  => 1,
            'Module::Build::PPMMaker'=> 1,
            'Module::Build::Platform::Default'=> 1,
            'Module::Build::Platform::MacOS'=> 1,
            'Module::Build::Platform::Unix'=> 1,
            'Module::Build::Platform::VMS'=> 1,
            'Module::Build::Platform::VOS'=> 1,
            'Module::Build::Platform::Windows'=> 1,
            'Module::Build::Platform::aix'=> 1,
            'Module::Build::Platform::cygwin'=> 1,
            'Module::Build::Platform::darwin'=> 1,
            'Module::Build::Platform::os2'=> 1,
            'Module::Build::PodParser'=> 1,
            'Module::Build::Version'=> 1,
            'Module::Build::YAML'   => 1,
            'Package::Constants'    => 1,
            'inc::latest'           => 1,
        }
    },
    5.021001 => {
        delta_from => 5.021000,
        changed => {
        },
        removed => {
        }
    },
    5.021002 => {
        delta_from => 5.021001,
        changed => {
        },
        removed => {
        }
    },
    5.021003 => {
        delta_from => 5.021002,
        changed => {
        },
        removed => {
        }
    },
    5.020001 => {
        delta_from => 5.020000,
        changed => {
        },
        removed => {
        }
    },
    5.021004 => {
        delta_from => 5.021003,
        changed => {
        },
        removed => {
        }
    },
    5.021005 => {
        delta_from => 5.021004,
        changed => {
        },
        removed => {
        }
    },
    5.021006 => {
        delta_from => 5.021005,
        changed => {
        },
        removed => {
        }
    },
    5.021007 => {
        delta_from => 5.021006,
        changed => {
        },
        removed => {
        }
    },
    5.021008 => {
        delta_from => 5.021007,
        changed => {
        },
        removed => {
        }
    },
    5.020002 => {
        delta_from => 5.020001,
        changed => {
        },
        removed => {
        }
    },
    5.021009 => {
        delta_from => 5.021008,
        changed => {
        },
        removed => {
        }
    },
    5.021010 => {
        delta_from => 5.021009,
        changed => {
        },
        removed => {
        }
    },
    5.021011 => {
        delta_from => 5.02101,
        changed => {
        },
        removed => {
        }
    },
    5.022000 => {
        delta_from => 5.021011,
        changed => {
        },
        removed => {
        }
    },
    5.023000 => {
        delta_from => 5.022000,
        changed => {
        },
        removed => {
        }
    },
    5.023001 => {
        delta_from => 5.023000,
        changed => {
        },
        removed => {
        }
    },
    5.023002 => {
        delta_from => 5.023001,
        changed => {
        },
        removed => {
        }
    },
    5.020003 => {
        delta_from => 5.020002,
        changed => {
        },
        removed => {
        }
    },
    5.023003 => {
        delta_from => 5.023002,
        changed => {
        },
        removed => {
        }
    },
    5.023004 => {
        delta_from => 5.023003,
        changed => {
        },
        removed => {
        }
    },
    5.023005 => {
        delta_from => 5.023004,
        changed => {
        },
        removed => {
        }
    },
    5.022001 => {
        delta_from => 5.022,
        changed => {
        },
        removed => {
        }
    },
    5.023006 => {
        delta_from => 5.023005,
        changed => {
        },
        removed => {
        }
    },
    5.023007 => {
        delta_from => 5.023006,
        changed => {
        },
        removed => {
        }
    },
    5.023008 => {
        delta_from => 5.023007,
        changed => {
        },
        removed => {
        }
    },
    5.023009 => {
        delta_from => 5.023008,
        changed => {
        },
        removed => {
        }
    },
    5.022002 => {
        delta_from => 5.022001,
        changed => {
        },
        removed => {
        }
    },
    5.024000 => {
        delta_from => 5.023009,
        changed => {
        },
        removed => {
        }
    },
    5.025000 => {
        delta_from => 5.024,
        changed => {
        },
        removed => {
        }
    },
    5.025001 => {
        delta_from => 5.025,
        changed => {
        },
        removed => {
        }
    },
    5.025002 => {
        delta_from => 5.025001,
        changed => {
        },
        removed => {
        }
    },
    5.025003 => {
        delta_from => 5.025002,
        changed => {
        },
        removed => {
        }
    },
    5.025004 => {
        delta_from => 5.025003,
        changed => {
        },
        removed => {
        }
    },
    5.025005 => {
        delta_from => 5.025004,
        changed => {
        },
        removed => {
        }
    },
    5.025006 => {
        delta_from => 5.025005,
        changed => {
        },
        removed => {
        }
    },
    5.025007 => {
        delta_from => 5.025006,
        changed => {
        },
        removed => {
        }
    },
    5.025008 => {
        delta_from => 5.025007,
        changed => {
        },
        removed => {
        }
    },
    5.024001 => {
        delta_from => 5.024000,
        changed => {
        },
        removed => {
        }
    },
);

for my $version (sort { $a <=> $b } keys %deprecated) {
    my $data = $deprecated{$version};

    tie %{ $deprecated{$version} }, 'Module::CoreList::TieHashDelta',
        $data->{changed}, $data->{removed},
        $data->{delta_from} ? $deprecated{ $data->{delta_from} } : undef;
}

%upstream = (
    'App::Cpan'             => 'cpan',
    'App::Prove'            => 'cpan',
    'App::Prove::State'     => 'cpan',
    'App::Prove::State::Result'=> 'cpan',
    'App::Prove::State::Result::Test'=> 'cpan',
    'Archive::Tar'          => 'cpan',
    'Archive::Tar::Constant'=> 'cpan',
    'Archive::Tar::File'    => 'cpan',
    'AutoLoader'            => 'cpan',
    'AutoSplit'             => 'cpan',
    'B::Debug'              => 'cpan',
    'CPAN'                  => 'cpan',
    'CPAN::Author'          => 'cpan',
    'CPAN::Bundle'          => 'cpan',
    'CPAN::CacheMgr'        => 'cpan',
    'CPAN::Complete'        => 'cpan',
    'CPAN::Debug'           => 'cpan',
    'CPAN::DeferredCode'    => 'cpan',
    'CPAN::Distribution'    => 'cpan',
    'CPAN::Distroprefs'     => 'cpan',
    'CPAN::Distrostatus'    => 'cpan',
    'CPAN::Exception::RecursiveDependency'=> 'cpan',
    'CPAN::Exception::blocked_urllist'=> 'cpan',
    'CPAN::Exception::yaml_not_installed'=> 'cpan',
    'CPAN::Exception::yaml_process_error'=> 'cpan',
    'CPAN::FTP'             => 'cpan',
    'CPAN::FTP::netrc'      => 'cpan',
    'CPAN::FirstTime'       => 'cpan',
    'CPAN::HTTP::Client'    => 'cpan',
    'CPAN::HTTP::Credentials'=> 'cpan',
    'CPAN::HandleConfig'    => 'cpan',
    'CPAN::Index'           => 'cpan',
    'CPAN::InfoObj'         => 'cpan',
    'CPAN::Kwalify'         => 'cpan',
    'CPAN::LWP::UserAgent'  => 'cpan',
    'CPAN::Meta'            => 'cpan',
    'CPAN::Meta::Converter' => 'cpan',
    'CPAN::Meta::Feature'   => 'cpan',
    'CPAN::Meta::History'   => 'cpan',
    'CPAN::Meta::Merge'     => 'cpan',
    'CPAN::Meta::Prereqs'   => 'cpan',
    'CPAN::Meta::Requirements'=> 'cpan',
    'CPAN::Meta::Spec'      => 'cpan',
    'CPAN::Meta::Validator' => 'cpan',
    'CPAN::Meta::YAML'      => 'cpan',
    'CPAN::Mirrors'         => 'cpan',
    'CPAN::Module'          => 'cpan',
    'CPAN::Nox'             => 'cpan',
    'CPAN::Plugin'          => 'cpan',
    'CPAN::Plugin::Specfile'=> 'cpan',
    'CPAN::Prompt'          => 'cpan',
    'CPAN::Queue'           => 'cpan',
    'CPAN::Shell'           => 'cpan',
    'CPAN::Tarzip'          => 'cpan',
    'CPAN::URL'             => 'cpan',
    'CPAN::Version'         => 'cpan',
    'Compress::Raw::Bzip2'  => 'cpan',
    'Compress::Raw::Zlib'   => 'cpan',
    'Compress::Zlib'        => 'cpan',
    'Config::Perl::V'       => 'cpan',
    'DB_File'               => 'cpan',
    'Devel::PPPort'         => 'cpan',
    'Digest'                => 'cpan',
    'Digest::MD5'           => 'cpan',
    'Digest::SHA'           => 'cpan',
    'Digest::base'          => 'cpan',
    'Digest::file'          => 'cpan',
    'Encode'                => 'cpan',
    'Encode::Alias'         => 'cpan',
    'Encode::Byte'          => 'cpan',
    'Encode::CJKConstants'  => 'cpan',
    'Encode::CN'            => 'cpan',
    'Encode::CN::HZ'        => 'cpan',
    'Encode::Config'        => 'cpan',
    'Encode::EBCDIC'        => 'cpan',
    'Encode::Encoder'       => 'cpan',
    'Encode::Encoding'      => 'cpan',
    'Encode::GSM0338'       => 'cpan',
    'Encode::Guess'         => 'cpan',
    'Encode::JP'            => 'cpan',
    'Encode::JP::H2Z'       => 'cpan',
    'Encode::JP::JIS7'      => 'cpan',
    'Encode::KR'            => 'cpan',
    'Encode::KR::2022_KR'   => 'cpan',
    'Encode::MIME::Header'  => 'cpan',
    'Encode::MIME::Header::ISO_2022_JP'=> 'cpan',
    'Encode::MIME::Name'    => 'cpan',
    'Encode::Symbol'        => 'cpan',
    'Encode::TW'            => 'cpan',
    'Encode::Unicode'       => 'cpan',
    'Encode::Unicode::UTF7' => 'cpan',
    'ExtUtils::Command'     => 'cpan',
    'ExtUtils::Command::MM' => 'cpan',
    'ExtUtils::Constant'    => 'cpan',
    'ExtUtils::Constant::Base'=> 'cpan',
    'ExtUtils::Constant::ProxySubs'=> 'cpan',
    'ExtUtils::Constant::Utils'=> 'cpan',
    'ExtUtils::Constant::XS'=> 'cpan',
    'ExtUtils::Install'     => 'cpan',
    'ExtUtils::Installed'   => 'cpan',
    'ExtUtils::Liblist'     => 'cpan',
    'ExtUtils::Liblist::Kid'=> 'cpan',
    'ExtUtils::MM'          => 'cpan',
    'ExtUtils::MM_AIX'      => 'cpan',
    'ExtUtils::MM_Any'      => 'cpan',
    'ExtUtils::MM_BeOS'     => 'cpan',
    'ExtUtils::MM_Cygwin'   => 'cpan',
    'ExtUtils::MM_DOS'      => 'cpan',
    'ExtUtils::MM_Darwin'   => 'cpan',
    'ExtUtils::MM_MacOS'    => 'cpan',
    'ExtUtils::MM_NW5'      => 'cpan',
    'ExtUtils::MM_OS2'      => 'cpan',
    'ExtUtils::MM_QNX'      => 'cpan',
    'ExtUtils::MM_UWIN'     => 'cpan',
    'ExtUtils::MM_Unix'     => 'cpan',
    'ExtUtils::MM_VMS'      => 'cpan',
    'ExtUtils::MM_VOS'      => 'cpan',
    'ExtUtils::MM_Win32'    => 'cpan',
    'ExtUtils::MM_Win95'    => 'cpan',
    'ExtUtils::MY'          => 'cpan',
    'ExtUtils::MakeMaker'   => 'cpan',
    'ExtUtils::MakeMaker::Config'=> 'cpan',
    'ExtUtils::MakeMaker::Locale'=> 'cpan',
    'ExtUtils::MakeMaker::version'=> 'cpan',
    'ExtUtils::MakeMaker::version::regex'=> 'cpan',
    'ExtUtils::Manifest'    => 'cpan',
    'ExtUtils::Mkbootstrap' => 'cpan',
    'ExtUtils::Mksymlists'  => 'cpan',
    'ExtUtils::Packlist'    => 'cpan',
    'ExtUtils::testlib'     => 'cpan',
    'Fatal'                 => 'cpan',
    'File::Fetch'           => 'cpan',
    'File::GlobMapper'      => 'cpan',
    'File::Path'            => 'cpan',
    'File::Temp'            => 'cpan',
    'Filter::Util::Call'    => 'cpan',
    'Getopt::Long'          => 'cpan',
    'HTTP::Tiny'            => 'cpan',
    'IO::Compress::Adapter::Bzip2'=> 'cpan',
    'IO::Compress::Adapter::Deflate'=> 'cpan',
    'IO::Compress::Adapter::Identity'=> 'cpan',
    'IO::Compress::Base'    => 'cpan',
    'IO::Compress::Base::Common'=> 'cpan',
    'IO::Compress::Bzip2'   => 'cpan',
    'IO::Compress::Deflate' => 'cpan',
    'IO::Compress::Gzip'    => 'cpan',
    'IO::Compress::Gzip::Constants'=> 'cpan',
    'IO::Compress::RawDeflate'=> 'cpan',
    'IO::Compress::Zip'     => 'cpan',
    'IO::Compress::Zip::Constants'=> 'cpan',
    'IO::Compress::Zlib::Constants'=> 'cpan',
    'IO::Compress::Zlib::Extra'=> 'cpan',
    'IO::Socket::IP'        => 'cpan',
    'IO::Uncompress::Adapter::Bunzip2'=> 'cpan',
    'IO::Uncompress::Adapter::Identity'=> 'cpan',
    'IO::Uncompress::Adapter::Inflate'=> 'cpan',
    'IO::Uncompress::AnyInflate'=> 'cpan',
    'IO::Uncompress::AnyUncompress'=> 'cpan',
    'IO::Uncompress::Base'  => 'cpan',
    'IO::Uncompress::Bunzip2'=> 'cpan',
    'IO::Uncompress::Gunzip'=> 'cpan',
    'IO::Uncompress::Inflate'=> 'cpan',
    'IO::Uncompress::RawInflate'=> 'cpan',
    'IO::Uncompress::Unzip' => 'cpan',
    'IO::Zlib'              => 'cpan',
    'IPC::Cmd'              => 'cpan',
    'IPC::Msg'              => 'cpan',
    'IPC::Semaphore'        => 'cpan',
    'IPC::SharedMem'        => 'cpan',
    'IPC::SysV'             => 'cpan',
    'JSON::PP'              => 'cpan',
    'JSON::PP::Boolean'     => 'cpan',
    'List::Util'            => 'cpan',
    'List::Util::XS'        => 'cpan',
    'Locale::Codes'         => 'cpan',
    'Locale::Codes::Constants'=> 'cpan',
    'Locale::Codes::Country'=> 'cpan',
    'Locale::Codes::Country_Codes'=> 'cpan',
    'Locale::Codes::Country_Retired'=> 'cpan',
    'Locale::Codes::Currency'=> 'cpan',
    'Locale::Codes::Currency_Codes'=> 'cpan',
    'Locale::Codes::Currency_Retired'=> 'cpan',
    'Locale::Codes::LangExt'=> 'cpan',
    'Locale::Codes::LangExt_Codes'=> 'cpan',
    'Locale::Codes::LangExt_Retired'=> 'cpan',
    'Locale::Codes::LangFam'=> 'cpan',
    'Locale::Codes::LangFam_Codes'=> 'cpan',
    'Locale::Codes::LangFam_Retired'=> 'cpan',
    'Locale::Codes::LangVar'=> 'cpan',
    'Locale::Codes::LangVar_Codes'=> 'cpan',
    'Locale::Codes::LangVar_Retired'=> 'cpan',
    'Locale::Codes::Language'=> 'cpan',
    'Locale::Codes::Language_Codes'=> 'cpan',
    'Locale::Codes::Language_Retired'=> 'cpan',
    'Locale::Codes::Script' => 'cpan',
    'Locale::Codes::Script_Codes'=> 'cpan',
    'Locale::Codes::Script_Retired'=> 'cpan',
    'Locale::Country'       => 'cpan',
    'Locale::Currency'      => 'cpan',
    'Locale::Language'      => 'cpan',
    'Locale::Maketext::Simple'=> 'cpan',
    'Locale::Script'        => 'cpan',
    'MIME::Base64'          => 'cpan',
    'MIME::QuotedPrint'     => 'cpan',
    'Math::BigFloat'        => 'cpan',
    'Math::BigFloat::Trace' => 'cpan',
    'Math::BigInt'          => 'cpan',
    'Math::BigInt::Calc'    => 'cpan',
    'Math::BigInt::CalcEmu' => 'cpan',
    'Math::BigInt::FastCalc'=> 'cpan',
    'Math::BigInt::Trace'   => 'cpan',
    'Math::BigRat'          => 'cpan',
    'Math::Complex'         => 'cpan',
    'Math::Trig'            => 'cpan',
    'Memoize'               => 'cpan',
    'Memoize::AnyDBM_File'  => 'cpan',
    'Memoize::Expire'       => 'cpan',
    'Memoize::ExpireFile'   => 'cpan',
    'Memoize::ExpireTest'   => 'cpan',
    'Memoize::NDBM_File'    => 'cpan',
    'Memoize::SDBM_File'    => 'cpan',
    'Memoize::Storable'     => 'cpan',
    'Module::Load'          => 'cpan',
    'Module::Load::Conditional'=> 'cpan',
    'Module::Loaded'        => 'cpan',
    'Module::Metadata'      => 'cpan',
    'Module::Metadata::corpus::BOMTest::UTF16BE'=> 'cpan',
    'Module::Metadata::corpus::BOMTest::UTF16LE'=> 'cpan',
    'Module::Metadata::corpus::BOMTest::UTF8'=> 'cpan',
    'NEXT'                  => 'cpan',
    'Net::Cmd'              => 'cpan',
    'Net::Config'           => 'cpan',
    'Net::Domain'           => 'cpan',
    'Net::FTP'              => 'cpan',
    'Net::FTP::A'           => 'cpan',
    'Net::FTP::E'           => 'cpan',
    'Net::FTP::I'           => 'cpan',
    'Net::FTP::L'           => 'cpan',
    'Net::FTP::dataconn'    => 'cpan',
    'Net::NNTP'             => 'cpan',
    'Net::Netrc'            => 'cpan',
    'Net::POP3'             => 'cpan',
    'Net::SMTP'             => 'cpan',
    'Net::Time'             => 'cpan',
    'Params::Check'         => 'cpan',
    'Parse::CPAN::Meta'     => 'cpan',
    'Perl::OSType'          => 'cpan',
    'PerlIO::via::QuotedPrint'=> 'cpan',
    'Pod::Checker'          => 'cpan',
    'Pod::Escapes'          => 'cpan',
    'Pod::Find'             => 'cpan',
    'Pod::InputObjects'     => 'cpan',
    'Pod::Man'              => 'cpan',
    'Pod::ParseLink'        => 'cpan',
    'Pod::ParseUtils'       => 'cpan',
    'Pod::Parser'           => 'cpan',
    'Pod::Perldoc'          => 'cpan',
    'Pod::Perldoc::BaseTo'  => 'cpan',
    'Pod::Perldoc::GetOptsOO'=> 'cpan',
    'Pod::Perldoc::ToANSI'  => 'cpan',
    'Pod::Perldoc::ToChecker'=> 'cpan',
    'Pod::Perldoc::ToMan'   => 'cpan',
    'Pod::Perldoc::ToNroff' => 'cpan',
    'Pod::Perldoc::ToPod'   => 'cpan',
    'Pod::Perldoc::ToRtf'   => 'cpan',
    'Pod::Perldoc::ToTerm'  => 'cpan',
    'Pod::Perldoc::ToText'  => 'cpan',
    'Pod::Perldoc::ToTk'    => 'cpan',
    'Pod::Perldoc::ToXml'   => 'cpan',
    'Pod::PlainText'        => 'cpan',
    'Pod::Select'           => 'cpan',
    'Pod::Simple'           => 'cpan',
    'Pod::Simple::BlackBox' => 'cpan',
    'Pod::Simple::Checker'  => 'cpan',
    'Pod::Simple::Debug'    => 'cpan',
    'Pod::Simple::DumpAsText'=> 'cpan',
    'Pod::Simple::DumpAsXML'=> 'cpan',
    'Pod::Simple::HTML'     => 'cpan',
    'Pod::Simple::HTMLBatch'=> 'cpan',
    'Pod::Simple::HTMLLegacy'=> 'cpan',
    'Pod::Simple::LinkSection'=> 'cpan',
    'Pod::Simple::Methody'  => 'cpan',
    'Pod::Simple::Progress' => 'cpan',
    'Pod::Simple::PullParser'=> 'cpan',
    'Pod::Simple::PullParserEndToken'=> 'cpan',
    'Pod::Simple::PullParserStartToken'=> 'cpan',
    'Pod::Simple::PullParserTextToken'=> 'cpan',
    'Pod::Simple::PullParserToken'=> 'cpan',
    'Pod::Simple::RTF'      => 'cpan',
    'Pod::Simple::Search'   => 'cpan',
    'Pod::Simple::SimpleTree'=> 'cpan',
    'Pod::Simple::Text'     => 'cpan',
    'Pod::Simple::TextContent'=> 'cpan',
    'Pod::Simple::TiedOutFH'=> 'cpan',
    'Pod::Simple::Transcode'=> 'cpan',
    'Pod::Simple::TranscodeDumb'=> 'cpan',
    'Pod::Simple::TranscodeSmart'=> 'cpan',
    'Pod::Simple::XHTML'    => 'cpan',
    'Pod::Simple::XMLOutStream'=> 'cpan',
    'Pod::Text'             => 'cpan',
    'Pod::Text::Color'      => 'cpan',
    'Pod::Text::Overstrike' => 'cpan',
    'Pod::Text::Termcap'    => 'cpan',
    'Pod::Usage'            => 'cpan',
    'Scalar::Util'          => 'cpan',
    'Socket'                => 'cpan',
    'Sub::Util'             => 'cpan',
    'Sys::Syslog'           => 'cpan',
    'Sys::Syslog::Win32'    => 'cpan',
    'TAP::Base'             => 'cpan',
    'TAP::Formatter::Base'  => 'cpan',
    'TAP::Formatter::Color' => 'cpan',
    'TAP::Formatter::Console'=> 'cpan',
    'TAP::Formatter::Console::ParallelSession'=> 'cpan',
    'TAP::Formatter::Console::Session'=> 'cpan',
    'TAP::Formatter::File'  => 'cpan',
    'TAP::Formatter::File::Session'=> 'cpan',
    'TAP::Formatter::Session'=> 'cpan',
    'TAP::Harness'          => 'cpan',
    'TAP::Harness::Env'     => 'cpan',
    'TAP::Object'           => 'cpan',
    'TAP::Parser'           => 'cpan',
    'TAP::Parser::Aggregator'=> 'cpan',
    'TAP::Parser::Grammar'  => 'cpan',
    'TAP::Parser::Iterator' => 'cpan',
    'TAP::Parser::Iterator::Array'=> 'cpan',
    'TAP::Parser::Iterator::Process'=> 'cpan',
    'TAP::Parser::Iterator::Stream'=> 'cpan',
    'TAP::Parser::IteratorFactory'=> 'cpan',
    'TAP::Parser::Multiplexer'=> 'cpan',
    'TAP::Parser::Result'   => 'cpan',
    'TAP::Parser::Result::Bailout'=> 'cpan',
    'TAP::Parser::Result::Comment'=> 'cpan',
    'TAP::Parser::Result::Plan'=> 'cpan',
    'TAP::Parser::Result::Pragma'=> 'cpan',
    'TAP::Parser::Result::Test'=> 'cpan',
    'TAP::Parser::Result::Unknown'=> 'cpan',
    'TAP::Parser::Result::Version'=> 'cpan',
    'TAP::Parser::Result::YAML'=> 'cpan',
    'TAP::Parser::ResultFactory'=> 'cpan',
    'TAP::Parser::Scheduler'=> 'cpan',
    'TAP::Parser::Scheduler::Job'=> 'cpan',
    'TAP::Parser::Scheduler::Spinner'=> 'cpan',
    'TAP::Parser::Source'   => 'cpan',
    'TAP::Parser::SourceHandler'=> 'cpan',
    'TAP::Parser::SourceHandler::Executable'=> 'cpan',
    'TAP::Parser::SourceHandler::File'=> 'cpan',
    'TAP::Parser::SourceHandler::Handle'=> 'cpan',
    'TAP::Parser::SourceHandler::Perl'=> 'cpan',
    'TAP::Parser::SourceHandler::RawTAP'=> 'cpan',
    'TAP::Parser::YAMLish::Reader'=> 'cpan',
    'TAP::Parser::YAMLish::Writer'=> 'cpan',
    'Term::ANSIColor'       => 'cpan',
    'Term::Cap'             => 'cpan',
    'Test::Builder'         => 'cpan',
    'Test::Builder::IO::Scalar'=> 'cpan',
    'Test::Builder::Module' => 'cpan',
    'Test::Builder::Tester' => 'cpan',
    'Test::Builder::Tester::Color'=> 'cpan',
    'Test::Harness'         => 'cpan',
    'Test::More'            => 'cpan',
    'Test::Simple'          => 'cpan',
    'Test::Tester'          => 'cpan',
    'Test::Tester::Capture' => 'cpan',
    'Test::Tester::CaptureRunner'=> 'cpan',
    'Test::Tester::Delegate'=> 'cpan',
    'Test::use::ok'         => 'cpan',
    'Text::Balanced'        => 'cpan',
    'Text::ParseWords'      => 'cpan',
    'Text::Tabs'            => 'cpan',
    'Text::Wrap'            => 'cpan',
    'Tie::RefHash'          => 'cpan',
    'Time::Local'           => 'cpan',
    'Time::Piece'           => 'cpan',
    'Time::Seconds'         => 'cpan',
    'Unicode::Collate'      => 'cpan',
    'Unicode::Collate::CJK::Big5'=> 'cpan',
    'Unicode::Collate::CJK::GB2312'=> 'cpan',
    'Unicode::Collate::CJK::JISX0208'=> 'cpan',
    'Unicode::Collate::CJK::Korean'=> 'cpan',
    'Unicode::Collate::CJK::Pinyin'=> 'cpan',
    'Unicode::Collate::CJK::Stroke'=> 'cpan',
    'Unicode::Collate::CJK::Zhuyin'=> 'cpan',
    'Unicode::Collate::Locale'=> 'cpan',
    'Unicode::Normalize'    => 'cpan',
    'Win32'                 => 'cpan',
    'Win32API::File'        => 'cpan',
    'Win32API::File::inc::ExtUtils::Myconst2perl'=> 'cpan',
    'autodie'               => 'cpan',
    'autodie::Scope::Guard' => 'cpan',
    'autodie::Scope::GuardStack'=> 'cpan',
    'autodie::Util'         => 'cpan',
    'autodie::exception'    => 'cpan',
    'autodie::exception::system'=> 'cpan',
    'autodie::hints'        => 'cpan',
    'autodie::skip'         => 'cpan',
    'bigint'                => 'cpan',
    'bignum'                => 'cpan',
    'bigrat'                => 'cpan',
    'encoding'              => 'cpan',
    'experimental'          => 'cpan',
    'ok'                    => 'cpan',
    'parent'                => 'cpan',
    'perlfaq'               => 'cpan',
    'version'               => 'cpan',
    'version::regex'        => 'cpan',
);

%bug_tracker = (
    'App::Cpan'             => undef,
    'App::Prove'            => 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'App::Prove::State'     => 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'App::Prove::State::Result'=> 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'App::Prove::State::Result::Test'=> 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'Archive::Tar'          => undef,
    'Archive::Tar::Constant'=> undef,
    'Archive::Tar::File'    => undef,
    'B::Debug'              => undef,
    'CPAN'                  => undef,
    'CPAN::Author'          => undef,
    'CPAN::Bundle'          => undef,
    'CPAN::CacheMgr'        => undef,
    'CPAN::Complete'        => undef,
    'CPAN::Debug'           => undef,
    'CPAN::DeferredCode'    => undef,
    'CPAN::Distribution'    => undef,
    'CPAN::Distroprefs'     => undef,
    'CPAN::Distrostatus'    => undef,
    'CPAN::Exception::RecursiveDependency'=> undef,
    'CPAN::Exception::blocked_urllist'=> undef,
    'CPAN::Exception::yaml_not_installed'=> undef,
    'CPAN::Exception::yaml_process_error'=> undef,
    'CPAN::FTP'             => undef,
    'CPAN::FTP::netrc'      => undef,
    'CPAN::FirstTime'       => undef,
    'CPAN::HTTP::Client'    => undef,
    'CPAN::HTTP::Credentials'=> undef,
    'CPAN::HandleConfig'    => undef,
    'CPAN::Index'           => undef,
    'CPAN::InfoObj'         => undef,
    'CPAN::Kwalify'         => undef,
    'CPAN::LWP::UserAgent'  => undef,
    'CPAN::Meta'            => 'https://github.com/Perl-Toolchain-Gang/CPAN-Meta/issues',
    'CPAN::Meta::Converter' => 'https://github.com/Perl-Toolchain-Gang/CPAN-Meta/issues',
    'CPAN::Meta::Feature'   => 'https://github.com/Perl-Toolchain-Gang/CPAN-Meta/issues',
    'CPAN::Meta::History'   => 'https://github.com/Perl-Toolchain-Gang/CPAN-Meta/issues',
    'CPAN::Meta::Merge'     => 'https://github.com/Perl-Toolchain-Gang/CPAN-Meta/issues',
    'CPAN::Meta::Prereqs'   => 'https://github.com/Perl-Toolchain-Gang/CPAN-Meta/issues',
    'CPAN::Meta::Requirements'=> 'https://github.com/Perl-Toolchain-Gang/CPAN-Meta-Requirements/issues',
    'CPAN::Meta::Spec'      => 'https://github.com/Perl-Toolchain-Gang/CPAN-Meta/issues',
    'CPAN::Meta::Validator' => 'https://github.com/Perl-Toolchain-Gang/CPAN-Meta/issues',
    'CPAN::Meta::YAML'      => 'https://github.com/Perl-Toolchain-Gang/YAML-Tiny/issues',
    'CPAN::Mirrors'         => undef,
    'CPAN::Module'          => undef,
    'CPAN::Nox'             => undef,
    'CPAN::Plugin'          => undef,
    'CPAN::Plugin::Specfile'=> undef,
    'CPAN::Prompt'          => undef,
    'CPAN::Queue'           => undef,
    'CPAN::Shell'           => undef,
    'CPAN::Tarzip'          => undef,
    'CPAN::URL'             => undef,
    'CPAN::Version'         => undef,
    'Compress::Raw::Bzip2'  => undef,
    'Compress::Raw::Zlib'   => undef,
    'Compress::Zlib'        => undef,
    'Config::Perl::V'       => undef,
    'DB_File'               => undef,
    'Devel::PPPort'         => 'https://github.com/mhx/Devel-PPPort/issues/',
    'Digest'                => undef,
    'Digest::MD5'           => undef,
    'Digest::SHA'           => undef,
    'Digest::base'          => undef,
    'Digest::file'          => undef,
    'Encode'                => undef,
    'Encode::Alias'         => undef,
    'Encode::Byte'          => undef,
    'Encode::CJKConstants'  => undef,
    'Encode::CN'            => undef,
    'Encode::CN::HZ'        => undef,
    'Encode::Config'        => undef,
    'Encode::EBCDIC'        => undef,
    'Encode::Encoder'       => undef,
    'Encode::Encoding'      => undef,
    'Encode::GSM0338'       => undef,
    'Encode::Guess'         => undef,
    'Encode::JP'            => undef,
    'Encode::JP::H2Z'       => undef,
    'Encode::JP::JIS7'      => undef,
    'Encode::KR'            => undef,
    'Encode::KR::2022_KR'   => undef,
    'Encode::MIME::Header'  => undef,
    'Encode::MIME::Header::ISO_2022_JP'=> undef,
    'Encode::MIME::Name'    => undef,
    'Encode::Symbol'        => undef,
    'Encode::TW'            => undef,
    'Encode::Unicode'       => undef,
    'Encode::Unicode::UTF7' => undef,
    'ExtUtils::Command'     => 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker',
    'ExtUtils::Command::MM' => 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker',
    'ExtUtils::Constant'    => undef,
    'ExtUtils::Constant::Base'=> undef,
    'ExtUtils::Constant::ProxySubs'=> undef,
    'ExtUtils::Constant::Utils'=> undef,
    'ExtUtils::Constant::XS'=> undef,
    'ExtUtils::Install'     => 'https://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-Install',
    'ExtUtils::Installed'   => 'https://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-Install',
    'ExtUtils::Liblist'     => 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker',
    'ExtUtils::Liblist::Kid'=> 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker',
    'ExtUtils::MM'          => 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker',
    'ExtUtils::MM_AIX'      => 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker',
    'ExtUtils::MM_Any'      => 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker',
    'ExtUtils::MM_BeOS'     => 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker',
    'ExtUtils::MM_Cygwin'   => 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker',
    'ExtUtils::MM_DOS'      => 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker',
    'ExtUtils::MM_Darwin'   => 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker',
    'ExtUtils::MM_MacOS'    => 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker',
    'ExtUtils::MM_NW5'      => 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker',
    'ExtUtils::MM_OS2'      => 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker',
    'ExtUtils::MM_QNX'      => 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker',
    'ExtUtils::MM_UWIN'     => 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker',
    'ExtUtils::MM_Unix'     => 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker',
    'ExtUtils::MM_VMS'      => 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker',
    'ExtUtils::MM_VOS'      => 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker',
    'ExtUtils::MM_Win32'    => 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker',
    'ExtUtils::MM_Win95'    => 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker',
    'ExtUtils::MY'          => 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker',
    'ExtUtils::MakeMaker'   => 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker',
    'ExtUtils::MakeMaker::Config'=> 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker',
    'ExtUtils::MakeMaker::Locale'=> 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker',
    'ExtUtils::MakeMaker::version'=> 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker',
    'ExtUtils::MakeMaker::version::regex'=> 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker',
    'ExtUtils::Manifest'    => 'http://github.com/Perl-Toolchain-Gang/ExtUtils-Manifest/issues',
    'ExtUtils::Mkbootstrap' => 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker',
    'ExtUtils::Mksymlists'  => 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker',
    'ExtUtils::Packlist'    => 'https://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-Install',
    'ExtUtils::testlib'     => 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker',
    'Fatal'                 => 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=autodie',
    'File::Fetch'           => undef,
    'File::GlobMapper'      => undef,
    'File::Path'            => undef,
    'File::Temp'            => 'http://rt.cpan.org/Public/Dist/Display.html?Name=File-Temp',
    'Filter::Util::Call'    => undef,
    'Getopt::Long'          => undef,
    'HTTP::Tiny'            => 'https://github.com/chansen/p5-http-tiny/issues',
    'IO::Compress::Adapter::Bzip2'=> undef,
    'IO::Compress::Adapter::Deflate'=> undef,
    'IO::Compress::Adapter::Identity'=> undef,
    'IO::Compress::Base'    => undef,
    'IO::Compress::Base::Common'=> undef,
    'IO::Compress::Bzip2'   => undef,
    'IO::Compress::Deflate' => undef,
    'IO::Compress::Gzip'    => undef,
    'IO::Compress::Gzip::Constants'=> undef,
    'IO::Compress::RawDeflate'=> undef,
    'IO::Compress::Zip'     => undef,
    'IO::Compress::Zip::Constants'=> undef,
    'IO::Compress::Zlib::Constants'=> undef,
    'IO::Compress::Zlib::Extra'=> undef,
    'IO::Socket::IP'        => undef,
    'IO::Uncompress::Adapter::Bunzip2'=> undef,
    'IO::Uncompress::Adapter::Identity'=> undef,
    'IO::Uncompress::Adapter::Inflate'=> undef,
    'IO::Uncompress::AnyInflate'=> undef,
    'IO::Uncompress::AnyUncompress'=> undef,
    'IO::Uncompress::Base'  => undef,
    'IO::Uncompress::Bunzip2'=> undef,
    'IO::Uncompress::Gunzip'=> undef,
    'IO::Uncompress::Inflate'=> undef,
    'IO::Uncompress::RawInflate'=> undef,
    'IO::Uncompress::Unzip' => undef,
    'IO::Zlib'              => undef,
    'IPC::Cmd'              => undef,
    'IPC::Msg'              => undef,
    'IPC::Semaphore'        => undef,
    'IPC::SharedMem'        => undef,
    'IPC::SysV'             => undef,
    'JSON::PP'              => undef,
    'JSON::PP::Boolean'     => undef,
    'List::Util'            => 'https://rt.cpan.org/Public/Dist/Display.html?Name=Scalar-List-Utils',
    'List::Util::XS'        => 'https://rt.cpan.org/Public/Dist/Display.html?Name=Scalar-List-Utils',
    'Locale::Codes'         => undef,
    'Locale::Codes::Constants'=> undef,
    'Locale::Codes::Country'=> undef,
    'Locale::Codes::Country_Codes'=> undef,
    'Locale::Codes::Country_Retired'=> undef,
    'Locale::Codes::Currency'=> undef,
    'Locale::Codes::Currency_Codes'=> undef,
    'Locale::Codes::Currency_Retired'=> undef,
    'Locale::Codes::LangExt'=> undef,
    'Locale::Codes::LangExt_Codes'=> undef,
    'Locale::Codes::LangExt_Retired'=> undef,
    'Locale::Codes::LangFam'=> undef,
    'Locale::Codes::LangFam_Codes'=> undef,
    'Locale::Codes::LangFam_Retired'=> undef,
    'Locale::Codes::LangVar'=> undef,
    'Locale::Codes::LangVar_Codes'=> undef,
    'Locale::Codes::LangVar_Retired'=> undef,
    'Locale::Codes::Language'=> undef,
    'Locale::Codes::Language_Codes'=> undef,
    'Locale::Codes::Language_Retired'=> undef,
    'Locale::Codes::Script' => undef,
    'Locale::Codes::Script_Codes'=> undef,
    'Locale::Codes::Script_Retired'=> undef,
    'Locale::Country'       => undef,
    'Locale::Currency'      => undef,
    'Locale::Language'      => undef,
    'Locale::Maketext::Simple'=> undef,
    'Locale::Script'        => undef,
    'MIME::Base64'          => undef,
    'MIME::QuotedPrint'     => undef,
    'Math::BigFloat'        => undef,
    'Math::BigFloat::Trace' => undef,
    'Math::BigInt'          => undef,
    'Math::BigInt::Calc'    => undef,
    'Math::BigInt::CalcEmu' => undef,
    'Math::BigInt::FastCalc'=> undef,
    'Math::BigInt::Trace'   => undef,
    'Math::BigRat'          => undef,
    'Math::Complex'         => undef,
    'Math::Trig'            => undef,
    'Memoize'               => undef,
    'Memoize::AnyDBM_File'  => undef,
    'Memoize::Expire'       => undef,
    'Memoize::ExpireFile'   => undef,
    'Memoize::ExpireTest'   => undef,
    'Memoize::NDBM_File'    => undef,
    'Memoize::SDBM_File'    => undef,
    'Memoize::Storable'     => undef,
    'Module::Load'          => undef,
    'Module::Load::Conditional'=> undef,
    'Module::Loaded'        => undef,
    'Module::Metadata'      => 'https://rt.cpan.org/Public/Dist/Display.html?Name=Module-Metadata',
    'Module::Metadata::corpus::BOMTest::UTF16BE'=> undef,
    'Module::Metadata::corpus::BOMTest::UTF16LE'=> undef,
    'Module::Metadata::corpus::BOMTest::UTF8'=> undef,
    'NEXT'                  => undef,
    'Net::Cmd'              => undef,
    'Net::Config'           => undef,
    'Net::Domain'           => undef,
    'Net::FTP'              => undef,
    'Net::FTP::A'           => undef,
    'Net::FTP::E'           => undef,
    'Net::FTP::I'           => undef,
    'Net::FTP::L'           => undef,
    'Net::FTP::dataconn'    => undef,
    'Net::NNTP'             => undef,
    'Net::Netrc'            => undef,
    'Net::POP3'             => undef,
    'Net::SMTP'             => undef,
    'Net::Time'             => undef,
    'Params::Check'         => undef,
    'Parse::CPAN::Meta'     => 'https://github.com/Perl-Toolchain-Gang/CPAN-Meta/issues',
    'Perl::OSType'          => 'https://github.com/Perl-Toolchain-Gang/Perl-OSType/issues',
    'PerlIO::via::QuotedPrint'=> undef,
    'Pod::Checker'          => undef,
    'Pod::Escapes'          => undef,
    'Pod::Find'             => undef,
    'Pod::InputObjects'     => undef,
    'Pod::Man'              => 'https://rt.cpan.org/Dist/Display.html?Name=podlators',
    'Pod::ParseLink'        => 'https://rt.cpan.org/Dist/Display.html?Name=podlators',
    'Pod::ParseUtils'       => undef,
    'Pod::Parser'           => undef,
    'Pod::Perldoc'          => undef,
    'Pod::Perldoc::BaseTo'  => undef,
    'Pod::Perldoc::GetOptsOO'=> undef,
    'Pod::Perldoc::ToANSI'  => undef,
    'Pod::Perldoc::ToChecker'=> undef,
    'Pod::Perldoc::ToMan'   => undef,
    'Pod::Perldoc::ToNroff' => undef,
    'Pod::Perldoc::ToPod'   => undef,
    'Pod::Perldoc::ToRtf'   => undef,
    'Pod::Perldoc::ToTerm'  => undef,
    'Pod::Perldoc::ToText'  => undef,
    'Pod::Perldoc::ToTk'    => undef,
    'Pod::Perldoc::ToXml'   => undef,
    'Pod::PlainText'        => undef,
    'Pod::Select'           => undef,
    'Pod::Simple'           => 'https://github.com/perl-pod/pod-simple/issues',
    'Pod::Simple::BlackBox' => 'https://github.com/perl-pod/pod-simple/issues',
    'Pod::Simple::Checker'  => 'https://github.com/perl-pod/pod-simple/issues',
    'Pod::Simple::Debug'    => 'https://github.com/perl-pod/pod-simple/issues',
    'Pod::Simple::DumpAsText'=> 'https://github.com/perl-pod/pod-simple/issues',
    'Pod::Simple::DumpAsXML'=> 'https://github.com/perl-pod/pod-simple/issues',
    'Pod::Simple::HTML'     => 'https://github.com/perl-pod/pod-simple/issues',
    'Pod::Simple::HTMLBatch'=> 'https://github.com/perl-pod/pod-simple/issues',
    'Pod::Simple::HTMLLegacy'=> 'https://github.com/perl-pod/pod-simple/issues',
    'Pod::Simple::LinkSection'=> 'https://github.com/perl-pod/pod-simple/issues',
    'Pod::Simple::Methody'  => 'https://github.com/perl-pod/pod-simple/issues',
    'Pod::Simple::Progress' => 'https://github.com/perl-pod/pod-simple/issues',
    'Pod::Simple::PullParser'=> 'https://github.com/perl-pod/pod-simple/issues',
    'Pod::Simple::PullParserEndToken'=> 'https://github.com/perl-pod/pod-simple/issues',
    'Pod::Simple::PullParserStartToken'=> 'https://github.com/perl-pod/pod-simple/issues',
    'Pod::Simple::PullParserTextToken'=> 'https://github.com/perl-pod/pod-simple/issues',
    'Pod::Simple::PullParserToken'=> 'https://github.com/perl-pod/pod-simple/issues',
    'Pod::Simple::RTF'      => 'https://github.com/perl-pod/pod-simple/issues',
    'Pod::Simple::Search'   => 'https://github.com/perl-pod/pod-simple/issues',
    'Pod::Simple::SimpleTree'=> 'https://github.com/perl-pod/pod-simple/issues',
    'Pod::Simple::Text'     => 'https://github.com/perl-pod/pod-simple/issues',
    'Pod::Simple::TextContent'=> 'https://github.com/perl-pod/pod-simple/issues',
    'Pod::Simple::TiedOutFH'=> 'https://github.com/perl-pod/pod-simple/issues',
    'Pod::Simple::Transcode'=> 'https://github.com/perl-pod/pod-simple/issues',
    'Pod::Simple::TranscodeDumb'=> 'https://github.com/perl-pod/pod-simple/issues',
    'Pod::Simple::TranscodeSmart'=> 'https://github.com/perl-pod/pod-simple/issues',
    'Pod::Simple::XHTML'    => 'https://github.com/perl-pod/pod-simple/issues',
    'Pod::Simple::XMLOutStream'=> 'https://github.com/perl-pod/pod-simple/issues',
    'Pod::Text'             => 'https://rt.cpan.org/Dist/Display.html?Name=podlators',
    'Pod::Text::Color'      => 'https://rt.cpan.org/Dist/Display.html?Name=podlators',
    'Pod::Text::Overstrike' => 'https://rt.cpan.org/Dist/Display.html?Name=podlators',
    'Pod::Text::Termcap'    => 'https://rt.cpan.org/Dist/Display.html?Name=podlators',
    'Pod::Usage'            => undef,
    'Scalar::Util'          => 'https://rt.cpan.org/Public/Dist/Display.html?Name=Scalar-List-Utils',
    'Socket'                => undef,
    'Sub::Util'             => 'https://rt.cpan.org/Public/Dist/Display.html?Name=Scalar-List-Utils',
    'Sys::Syslog'           => undef,
    'Sys::Syslog::Win32'    => undef,
    'TAP::Base'             => 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Formatter::Base'  => 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Formatter::Color' => 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Formatter::Console'=> 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Formatter::Console::ParallelSession'=> 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Formatter::Console::Session'=> 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Formatter::File'  => 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Formatter::File::Session'=> 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Formatter::Session'=> 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Harness'          => 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Harness::Env'     => 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Object'           => 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Parser'           => 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Parser::Aggregator'=> 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Parser::Grammar'  => 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Parser::Iterator' => 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Parser::Iterator::Array'=> 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Parser::Iterator::Process'=> 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Parser::Iterator::Stream'=> 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Parser::IteratorFactory'=> 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Parser::Multiplexer'=> 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Parser::Result'   => 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Parser::Result::Bailout'=> 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Parser::Result::Comment'=> 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Parser::Result::Plan'=> 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Parser::Result::Pragma'=> 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Parser::Result::Test'=> 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Parser::Result::Unknown'=> 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Parser::Result::Version'=> 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Parser::Result::YAML'=> 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Parser::ResultFactory'=> 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Parser::Scheduler'=> 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Parser::Scheduler::Job'=> 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Parser::Scheduler::Spinner'=> 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Parser::Source'   => 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Parser::SourceHandler'=> 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Parser::SourceHandler::Executable'=> 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Parser::SourceHandler::File'=> 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Parser::SourceHandler::Handle'=> 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Parser::SourceHandler::Perl'=> 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Parser::SourceHandler::RawTAP'=> 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Parser::YAMLish::Reader'=> 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Parser::YAMLish::Writer'=> 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'Term::ANSIColor'       => 'https://rt.cpan.org/Dist/Display.html?Name=Term-ANSIColor',
    'Term::Cap'             => undef,
    'Test::Builder'         => 'http://github.com/Test-More/test-more/issues',
    'Test::Builder::IO::Scalar'=> 'http://github.com/Test-More/test-more/issues',
    'Test::Builder::Module' => 'http://github.com/Test-More/test-more/issues',
    'Test::Builder::Tester' => 'http://github.com/Test-More/test-more/issues',
    'Test::Builder::Tester::Color'=> 'http://github.com/Test-More/test-more/issues',
    'Test::Harness'         => 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'Test::More'            => 'http://github.com/Test-More/test-more/issues',
    'Test::Simple'          => 'http://github.com/Test-More/test-more/issues',
    'Test::Tester'          => 'http://github.com/Test-More/test-more/issues',
    'Test::Tester::Capture' => 'http://github.com/Test-More/test-more/issues',
    'Test::Tester::CaptureRunner'=> 'http://github.com/Test-More/test-more/issues',
    'Test::Tester::Delegate'=> 'http://github.com/Test-More/test-more/issues',
    'Test::use::ok'         => 'http://github.com/Test-More/test-more/issues',
    'Text::Balanced'        => undef,
    'Text::ParseWords'      => undef,
    'Text::Tabs'            => undef,
    'Text::Wrap'            => undef,
    'Tie::RefHash'          => undef,
    'Time::Local'           => 'https://github.com/houseabsolute/Time-Local/issues',
    'Time::Piece'           => undef,
    'Time::Seconds'         => undef,
    'Unicode::Collate'      => undef,
    'Unicode::Collate::CJK::Big5'=> undef,
    'Unicode::Collate::CJK::GB2312'=> undef,
    'Unicode::Collate::CJK::JISX0208'=> undef,
    'Unicode::Collate::CJK::Korean'=> undef,
    'Unicode::Collate::CJK::Pinyin'=> undef,
    'Unicode::Collate::CJK::Stroke'=> undef,
    'Unicode::Collate::CJK::Zhuyin'=> undef,
    'Unicode::Collate::Locale'=> undef,
    'Unicode::Normalize'    => 'https://rt.cpan.org/Public/Dist/Display.html?Name=Unicode-Normalize',
    'Win32'                 => undef,
    'Win32API::File'        => undef,
    'Win32API::File::inc::ExtUtils::Myconst2perl'=> undef,
    'autodie'               => 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=autodie',
    'autodie::Scope::Guard' => 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=autodie',
    'autodie::Scope::GuardStack'=> 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=autodie',
    'autodie::Util'         => 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=autodie',
    'autodie::exception'    => 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=autodie',
    'autodie::exception::system'=> 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=autodie',
    'autodie::hints'        => 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=autodie',
    'autodie::skip'         => 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=autodie',
    'bigint'                => undef,
    'bignum'                => undef,
    'bigrat'                => undef,
    'encoding'              => undef,
    'experimental'          => 'http://rt.cpan.org/Public/Dist/Display.html?Name=experimental',
    'ok'                    => 'http://github.com/Test-More/test-more/issues',
    'parent'                => undef,
    'perlfaq'               => 'https://github.com/perl-doc-cats/perlfaq/issues',
    'version'               => 'https://rt.cpan.org/Public/Dist/Display.html?Name=version',
    'version::regex'        => 'https://rt.cpan.org/Public/Dist/Display.html?Name=version',
);

# Create aliases with trailing zeros for $] use

$released{'5.000'} = $released{5};
$version{'5.000'} = $version{5};

_create_aliases(\%delta);
_create_aliases(\%released);
_create_aliases(\%version);
_create_aliases(\%deprecated);

sub _create_aliases {
    my ($hash) = @_;

    for my $version (keys %$hash) {
        next unless $version >= 5.006;

        my $padded = sprintf "%0.6f", $version;

        # If the version in string form isn't the same as the numeric version,
        # alias it.
        if ($padded ne $version && $version == $padded) {
            $hash->{$padded} = $hash->{$version};
        }
    }
}

1;
__END__
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 =head1 NAME

Module::CoreList - what modules shipped with versions of perl

=head1 SYNOPSIS

 use Module::CoreList;

 print $Module::CoreList::version{5.00503}{CPAN}; # prints 1.48

 print Module::CoreList->first_release('File::Spec');
 # prints 5.00405

 print Module::CoreList->first_release_by_date('File::Spec');
 # prints 5.005

 print Module::CoreList->first_release('File::Spec', 0.82);
 # prints 5.006001

 if (Module::CoreList::is_core('File::Spec')) {
   print "File::Spec is a core module\n";
 }

 print join ', ', Module::CoreList->find_modules(qr/Data/);
    # prints 'Data::Dumper'
 print join ', ',
          Module::CoreList->find_modules(qr/test::h.*::.*s/i, 5.008008);
    # prints 'Test::Harness::Assert, Test::Harness::Straps'

 print join ", ", @{ $Module::CoreList::families{5.005} };
    # prints "5.005, 5.00503, 5.00504"

=head1 DESCRIPTION

Module::CoreList provides information on which core and dual-life modules shipped
with each version of L<perl>.

It provides a number of mechanisms for querying this information.

There is a utility called L<corelist> provided with this module
which is a convenient way of querying from the command-line.

There is a functional programming API available for programmers to query
information.

Programmers may also query the contained hash structures to find relevant
information.

=head1 FUNCTIONS API

These are the functions that are available, they may either be called as functions or class methods:

  Module::CoreList::first_release('File::Spec'); # as a function

  Module::CoreList->first_release('File::Spec'); # class method

=over

=item C<first_release( MODULE )>

Behaviour since version 2.11

Requires a MODULE name as an argument, returns the perl version when that module first
appeared in core as ordered by perl version number or undef ( in scalar context )
or an empty list ( in list context ) if that module is not in core.

=item C<first_release_by_date( MODULE )>

Requires a MODULE name as an argument, returns the perl version when that module first
appeared in core as ordered by release date or undef ( in scalar context )
or an empty list ( in list context ) if that module is not in core.

=item C<find_modules( REGEX, [ LIST OF PERLS ] )>

Takes a regex as an argument, returns a list of modules that match the regex given.
If only a regex is provided applies to all modules in all perl versions. Optionally
you may provide a list of perl versions to limit the regex search.

=item C<find_version( PERL_VERSION )>

Takes a perl version as an argument. Upon successful completion, returns a
reference to a hash.  Each element of that hash has a key which is the name of
a module (I<e.g.,> 'File::Path') shipped with that version of perl and a value
which is the version number (I<e.g.,> '2.09') of that module which shipped
with that version of perl .  Returns C<undef> otherwise.

=item C<is_core( MODULE, [ MODULE_VERSION, [ PERL_VERSION ] ] )>

Available in version 2.99 and above.

Returns true if MODULE was bundled with the specified version of Perl.
You can optionally specify a minimum version of the module,
and can also specify a version of Perl.
If a version of Perl isn't specified,
C<is_core()> will use the numeric version of Perl that is running (ie C<$]>).

If you want to specify the version of Perl, but don't care about
the version of the module, pass C<undef> for the module version:

=item C<is_deprecated( MODULE, PERL_VERSION )>

Available in version 2.22 and above.

Returns true if MODULE is marked as deprecated in PERL_VERSION.  If PERL_VERSION is
omitted, it defaults to the current version of Perl.

=item C<deprecated_in( MODULE )>

Available in version 2.77 and above.

Returns the first perl version where the MODULE was marked as deprecated. Returns C<undef>
if the MODULE has not been marked as deprecated.

=item C<removed_from( MODULE )>

Available in version 2.32 and above

Takes a module name as an argument, returns the first perl version where that module
was removed from core. Returns undef if the given module was never in core or remains
in core.

=item C<removed_from_by_date( MODULE )>

Available in version 2.32 and above

Takes a module name as an argument, returns the first perl version by release date where that module
was removed from core. Returns undef if the given module was never in core or remains
in core.

=item C<changes_between( PERL_VERSION, PERL_VERSION )>

Available in version 2.66 and above.

Given two perl versions, this returns a list of pairs describing the changes in
core module content between them.  The list is suitable for storing in a hash.
The keys are library names and the values are hashrefs.  Each hashref has an
entry for one or both of C<left> and C<right>, giving the versions of the
library in each of the left and right perl distributions.

For example, it might return these data (among others) for the difference
between 5.008000 and 5.008001:

  'Pod::ParseLink'  => { left => '1.05', right => '1.06' },
  'Pod::ParseUtils' => { left => '0.22', right => '0.3'  },
  'Pod::Perldoc'    => {                 right => '3.10' },
  'Pod::Perldoc::BaseTo' => {            right => undef  },

This shows us two libraries being updated and two being added, one of which has
an undefined version in the right-hand side version.

=back

=head1 DATA STRUCTURES

These are the hash data structures that are available:

=over

=item C<%Module::CoreList::version>

A hash of hashes that is keyed on perl version as indicated
in $].  The second level hash is module => version pairs.

Note, it is possible for the version of a module to be unspecified,
whereby the value is C<undef>, so use C<exists $version{$foo}{$bar}> if
that's what you're testing for.

Starting with 2.10, the special module name C<Unicode> refers to the version of
the Unicode Character Database bundled with Perl.

=item C<%Module::CoreList::delta>

Available in version 3.00 and above.

C<%Module::CoreList::version> is implemented via C<Module::CoreList::TieHashDelta>
using this hash of delta changes.

It is a hash of hashes that is keyed on perl version. Each keyed hash will have the
following keys:

  delta_from - a previous perl version that the changes are based on
  changed    - a hash of module/versions that have changed
  removed    - a hash of modules that have been removed

=item C<%Module::CoreList::released>

Keyed on perl version this contains ISO
formatted versions of the release dates, as gleaned from L<perlhist>.

=item C<%Module::CoreList::families>

New, in 1.96, a hash that
clusters known perl releases by their major versions.

=item C<%Module::CoreList::deprecated>

A hash of hashes keyed on perl version and on module name.
If a module is defined it indicates that that module is
deprecated in that perl version and is scheduled for removal
from core at some future point.

=item C<%Module::CoreList::upstream>

A hash that contains information on where patches should be directed
for each core module.

UPSTREAM indicates where patches should go. C<undef> implies
that this hasn't been discussed for the module at hand.
C<blead> indicates that the copy of the module in the blead
sources is to be considered canonical, C<cpan> means that the
module on CPAN is to be patched first. C<first-come> means
that blead can be patched freely if it is in sync with the
latest release on CPAN.

=item C<%Module::CoreList::bug_tracker>

A hash that contains information on the appropriate bug tracker
for each core module.

BUGS is an email or url to post bug reports.  For modules with
UPSTREAM => 'blead', use perl5-porters@perl.org.  rt.cpan.org
appears to automatically provide a URL for CPAN modules; any value
given here overrides the default:
http://rt.cpan.org/Public/Dist/Display.html?Name=$ModuleName

=back

=head1 CAVEATS

Module::CoreList currently covers the 5.000, 5.001, 5.002, 5.003_07,
5.004, 5.004_05, 5.005, 5.005_03, 5.005_04 and 5.7.3 releases of perl.

All stable releases of perl since 5.6.0 are covered.

All development releases of perl since 5.9.0 are covered.


=head1 HISTORY

Moved to Changes file.

=head1 AUTHOR

Richard Clamp E<lt>richardc@unixbeard.netE<gt>

Currently maintained by the perl 5 porters E<lt>perl5-porters@perl.orgE<gt>.

=head1 LICENSE

Copyright (C) 2002-2009 Richard Clamp.  All Rights Reserved.

This module is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

=head1 SEE ALSO

L<corelist>, L<Module::Info>, L<perl>, L<http://perlpunks.de/corelist>

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     package Module::Load;

$VERSION = '0.32';

use strict;
use warnings;
use File::Spec ();

sub import {
    my $who = _who();
    my $h; shift;

    {   no strict 'refs';

        @_ or (
            *{"${who}::load"} = \&load, # compat to prev version
            *{"${who}::autoload"} = \&autoload,
            return
        );

        map { $h->{$_} = () if defined $_ } @_;

        (exists $h->{none} or exists $h->{''})
            and shift, last;

        ((exists $h->{autoload} and shift,1) or (exists $h->{all} and shift))
            and *{"${who}::autoload"} = \&autoload;

        ((exists $h->{load} and shift,1) or exists $h->{all})
            and *{"${who}::load"} = \&load;

        ((exists $h->{load_remote} and shift,1) or exists $h->{all})
            and *{"${who}::load_remote"} = \&load_remote;

        ((exists $h->{autoload_remote} and shift,1) or exists $h->{all})
            and *{"${who}::autoload_remote"} = \&autoload_remote;

    }

}

sub load(*;@){
    goto &_load;
}

sub autoload(*;@){
    unshift @_, 'autoimport';
    goto &_load;
}

sub load_remote($$;@){
    my ($dst, $src, @exp) = @_;

    eval "package $dst;Module::Load::load('$src', qw/@exp/);";
    $@ && die "$@";
}

sub autoload_remote($$;@){
    my ($dst, $src, @exp) = @_;

    eval "package $dst;Module::Load::autoload('$src', qw/@exp/);";
    $@ && die "$@";
}

sub _load{
    my $autoimport = $_[0] eq 'autoimport' and shift;
    my $mod = shift or return;
    my $who = _who();

    if( _is_file( $mod ) ) {
        require $mod;
    } else {
        LOAD: {
            my $err;
            for my $flag ( qw[1 0] ) {
                my $file = _to_file( $mod, $flag);
                eval { require $file };
                $@ ? $err .= $@ : last LOAD;
            }
            die $err if $err;
        }
    }

    ### This addresses #41883: Module::Load cannot import
    ### non-Exporter module. ->import() routines weren't
    ### properly called when load() was used.

    {   no strict 'refs';
        my $import;

    ((@_ or $autoimport) and (
        $import = $mod->can('import')
        ) and (
        unshift(@_, $mod),
        goto &$import,
        return
        )
    );
    }

}

sub _to_file{
    local $_    = shift;
    my $pm      = shift || '';

    ## trailing blanks ignored by default. [rt #69886]
    my @parts = split /::|'/, $_, -1;
    ## make sure that we can't hop out of @INC
    shift @parts if @parts && !$parts[0];

    ### because of [perl #19213], see caveats ###
    my $file = $^O eq 'MSWin32'
                    ? join "/", @parts
                    : File::Spec->catfile( @parts );

    $file   .= '.pm' if $pm;

    ### on perl's before 5.10 (5.9.5@31746) if you require
    ### a file in VMS format, it's stored in %INC in VMS
    ### format. Therefor, better unixify it first
    ### Patch in reply to John Malmbergs patch (as mentioned
    ### above) on p5p Tue 21 Aug 2007 04:55:07
    $file = VMS::Filespec::unixify($file) if $^O eq 'VMS';

    return $file;
}

sub _who { (caller(1))[0] }

sub _is_file {
    local $_ = shift;
    return  /^\./               ? 1 :
            /[^\w:']/           ? 1 :
            undef
    #' silly bbedit..
}


1;

__END__

=pod

=head1 NAME

Module::Load - runtime require of both modules and files

=head1 SYNOPSIS

  use Module::Load;

  my $module = 'Data::Dumper';

  load Data::Dumper;     # loads that module, but not import any functions
                         # -> cannot use 'Dumper' function

  load 'Data::Dumper';   # ditto
  load $module           # tritto

  autoload Data::Dumper; # loads that module and imports the default functions
                         # -> can use 'Dumper' function

  my $script = 'some/script.pl'
  load $script;
  load 'some/script.pl';  # use quotes because of punctuations

  load thing;             # try 'thing' first, then 'thing.pm'

  load CGI, ':all';       # like 'use CGI qw[:standard]'

=head1 DESCRIPTION

C<Module::Load> eliminates the need to know whether you are trying
to require either a file or a module.

If you consult C<perldoc -f require> you will see that C<require> will
behave differently when given a bareword or a string.

In the case of a string, C<require> assumes you are wanting to load a
file. But in the case of a bareword, it assumes you mean a module.

This gives nasty overhead when you are trying to dynamically require
modules at runtime, since you will need to change the module notation
(C<Acme::Comment>) to a file notation fitting the particular platform
you are on.

C<Module::Load> eliminates the need for this overhead and will
just DWYM.

=head2 Difference between C<load> and C<autoload>

C<Module::Load> imports the two functions - C<load> and C<autoload>

C<autoload> imports the default functions automatically,
but C<load> do not import any functions.

C<autoload> is usable under C<BEGIN{};>.

Both the functions can import the functions that are specified.

Following codes are same.

  load File::Spec::Functions, qw/splitpath/;

  autoload File::Spec::Functions, qw/splitpath/;

=head1 FUNCTIONS

=over 4

=item load

Loads a specified module.

See L</Rules> for detailed loading rule.

=item autoload

Loads a specified module and imports the default functions.

Except importing the functions, 'autoload' is same as 'load'.

=item load_remote

Loads a specified module to the specified package.

  use Module::Load 'load_remote';

  my $pkg = 'Other::Package';

  load_remote $pkg, 'Data::Dumper'; # load a module to 'Other::Package'
                                    # but do not import 'Dumper' function

A module for loading must be quoted.

Except specifing the package and quoting module name,
'load_remote' is same as 'load'.

=item autoload_remote

Loads a specified module and imports the default functions to the specified package.

  use Module::Load 'autoload_remote';

  my $pkg = 'Other::Package';

  autoload_remote $pkg, 'Data::Dumper'; # load a module to 'Other::Package'
                                        # and imports 'Dumper' function

A module for loading must be quoted.

Except specifing the package and quoting module name,
'autoload_remote' is same as 'load_remote'.

=back

=head1 Rules

All functions have the following rules to decide what it thinks
you want:

=over 4

=item *

If the argument has any characters in it other than those matching
C<\w>, C<:> or C<'>, it must be a file

=item *

If the argument matches only C<[\w:']>, it must be a module

=item *

If the argument matches only C<\w>, it could either be a module or a
file. We will try to find C<file.pm> first in C<@INC> and if that
fails, we will try to find C<file> in @INC.  If both fail, we die with
the respective error messages.

=back

=head1 IMPORTS THE FUNCTIONS

'load' and 'autoload' are imported by default, but 'load_remote' and
'autoload_remote' are not imported.

To use 'load_remote' or 'autoload_remote', specify at 'use'.

=over 4

=item "load","autoload","load_remote","autoload_remote"

Imports the selected functions.

  # imports 'load' and 'autoload' (default)
  use Module::Load;

  # imports 'autoload' only
  use Module::Load 'autoload';

  # imports 'autoload' and 'autoload_remote', but don't import 'load';
  use Module::Load qw/autoload autoload_remote/;

=item 'all'

Imports all the functions.

  use Module::Load 'all'; # imports load, autoload, load_remote, autoload_remote

=item '','none',undef

Not import any functions (C<load> and C<autoload> are not imported).

  use Module::Load '';

  use Module::Load 'none';

  use Module::Load undef;

=back

=head1 Caveats

Because of a bug in perl (#19213), at least in version 5.6.1, we have
to hardcode the path separator for a require on Win32 to be C</>, like
on Unix rather than the Win32 C<\>. Otherwise perl will not read its
own %INC accurately double load files if they are required again, or
in the worst case, core dump.

C<Module::Load> cannot do implicit imports, only explicit imports.
(in other words, you always have to specify explicitly what you wish
to import from a module, even if the functions are in that modules'
C<@EXPORT>)

=head1 ACKNOWLEDGEMENTS

Thanks to Jonas B. Nielsen for making explicit imports work.

=head1 BUG REPORTS

Please report bugs or other issues to E<lt>bug-module-load@rt.cpan.org<gt>.

=head1 AUTHOR

This module by Jos Boumans E<lt>kane@cpan.orgE<gt>.

=head1 COPYRIGHT

This library is free software; you may redistribute and/or modify it
under the same terms as Perl itself.

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           package Module::Loaded;

use strict;
use Carp qw[carp];

BEGIN { use base 'Exporter';
        use vars qw[@EXPORT $VERSION];

        $VERSION = '0.08';
        @EXPORT  = qw[mark_as_loaded mark_as_unloaded is_loaded];
}

=head1 NAME

Module::Loaded - mark modules as loaded or unloaded

=head1 SYNOPSIS

    use Module::Loaded;

    $bool = mark_as_loaded('Foo');   # Foo.pm is now marked as loaded
    $loc  = is_loaded('Foo');        # location of Foo.pm set to the
                                     # loaders location
    eval "require 'Foo'";            # is now a no-op

    $bool = mark_as_unloaded('Foo'); # Foo.pm no longer marked as loaded
    eval "require 'Foo'";            # Will try to find Foo.pm in @INC

=head1 DESCRIPTION

When testing applications, often you find yourself needing to provide
functionality in your test environment that would usually be provided
by external modules. Rather than munging the C<%INC> by hand to mark
these external modules as loaded, so they are not attempted to be loaded
by perl, this module offers you a very simple way to mark modules as
loaded and/or unloaded.

=head1 FUNCTIONS

=head2 $bool = mark_as_loaded( PACKAGE );

Marks the package as loaded to perl. C<PACKAGE> can be a bareword or
string.

If the module is already loaded, C<mark_as_loaded> will carp about
this and tell you from where the C<PACKAGE> has been loaded already.

=cut

sub mark_as_loaded (*) {
    my $pm      = shift;
    my $file    = __PACKAGE__->_pm_to_file( $pm ) or return;
    my $who     = [caller]->[1];

    my $where   = is_loaded( $pm );
    if ( defined $where ) {
        carp "'$pm' already marked as loaded ('$where')";

    } else {
        $INC{$file} = $who;
    }

    return 1;
}

=head2 $bool = mark_as_unloaded( PACKAGE );

Marks the package as unloaded to perl, which is the exact opposite
of C<mark_as_loaded>. C<PACKAGE> can be a bareword or string.

If the module is already unloaded, C<mark_as_unloaded> will carp about
this and tell you the C<PACKAGE> has been unloaded already.

=cut

sub mark_as_unloaded (*) {
    my $pm      = shift;
    my $file    = __PACKAGE__->_pm_to_file( $pm ) or return;

    unless( defined is_loaded( $pm ) ) {
        carp "'$pm' already marked as unloaded";

    } else {
        delete $INC{ $file };
    }

    return 1;
}

=head2 $loc = is_loaded( PACKAGE );

C<is_loaded> tells you if C<PACKAGE> has been marked as loaded yet.
C<PACKAGE> can be a bareword or string.

It returns falls if C<PACKAGE> has not been loaded yet and the location
from where it is said to be loaded on success.

=cut

sub is_loaded (*) {
    my $pm      = shift;
    my $file    = __PACKAGE__->_pm_to_file( $pm ) or return;

    return $INC{$file} if exists $INC{$file};

    return;
}


sub _pm_to_file {
    my $pkg = shift;
    my $pm  = shift or return;

    my $file = join '/', split '::', $pm;
    $file .= '.pm';

    return $file;
}

=head1 BUG REPORTS

Please report bugs or other issues to E<lt>bug-module-loaded@rt.cpan.org<gt>.

=head1 AUTHOR

This module by Jos Boumans E<lt>kane@cpan.orgE<gt>.

=head1 COPYRIGHT

This library is free software; you may redistribute and/or modify it
under the same terms as Perl itself.

=cut

# Local variables:
# c-indentation-style: bsd
# c-basic-offset: 4
# indent-tabs-mode: nil
# End:
# vim: expandtab shiftwidth=4:

1;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            # For internal Module::CoreList use only.
package Module::CoreList::TieHashDelta;
use strict;
use vars qw($VERSION);

$VERSION = '5.20170114_24';

sub TIEHASH {
    my ($class, $changed, $removed, $parent) = @_;

    return bless {
        changed => $changed,
        removed => $removed,
        parent => $parent,
        keys_inflated => 0,
    }, $class;
}

sub FETCH {
    my ($self, $key) = @_;

    if (exists $self->{changed}{$key}) {
        return $self->{changed}{$key};
    } elsif (exists $self->{removed}{$key}) {
        return undef;
    } elsif (defined $self->{parent}) {
        return $self->{parent}{$key};
    }
    return undef;
}

sub EXISTS {
    my ($self, $key) = @_;

    restart:
    if (exists $self->{changed}{$key}) {
        return 1;
    } elsif (exists $self->{removed}{$key}) {
        return '';
    } elsif (defined $self->{parent}) {
        $self = tied %{$self->{parent}}; #avoid extreme magic/tie recursion
        goto restart;
    }
    return '';
}

sub FIRSTKEY {
    my ($self) = @_;

    if (not $self->{keys_inflated}) {
        # exceeds the warning limit of 100 calls since 5.23.2
        no warnings 'recursion';

        # This inflates the whole set of hashes... Somewhat expensive, but saves
        # many tied hash calls later.
        my @parent_keys;
        if (defined $self->{parent}) {
            @parent_keys = keys %{$self->{parent}};
        }

        @parent_keys = grep !exists $self->{removed}{$_}, @parent_keys;
        for my $key (@parent_keys) {
            next if exists $self->{changed}->{$key};
            $self->{changed}{$key} = $self->{parent}{$key};
        }

        $self->{keys_inflated} = 1;
    }

    keys %{$self->{changed}}; # reset each
    $self->NEXTKEY;
}

sub NEXTKEY {
    my ($self) = @_;
    each %{$self->{changed}};
}

1;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              # -*- mode: cperl; tab-width: 8; indent-tabs-mode: nil; basic-offset: 2 -*-
# vim:ts=8:sw=2:et:sta:sts=2
package Module::Metadata; # git description: v1.000030-2-g52f466c
# ABSTRACT: Gather package and POD information from perl module files

# Adapted from Perl-licensed code originally distributed with
# Module-Build by Ken Williams

# This module provides routines to gather information about
# perl modules (assuming this may be expanded in the distant
# parrot future to look at other types of modules).

sub __clean_eval { eval $_[0] }
use strict;
use warnings;

our $VERSION = '1.000031'; # TRIAL

use Carp qw/croak/;
use File::Spec;
BEGIN {
       # Try really hard to not depend ony any DynaLoaded module, such as IO::File or Fcntl
       eval {
               require Fcntl; Fcntl->import('SEEK_SET'); 1;
       } or *SEEK_SET = sub { 0 }
}
use version 0.87;
BEGIN {
  if ($INC{'Log/Contextual.pm'}) {
    require "Log/Contextual/WarnLogger.pm"; # Hide from AutoPrereqs
    Log::Contextual->import('log_info',
      '-default_logger' => Log::Contextual::WarnLogger->new({ env_prefix => 'MODULE_METADATA', }),
    );
  }
  else {
    *log_info = sub (&) { warn $_[0]->() };
  }
}
use File::Find qw(find);

my $V_NUM_REGEXP = qr{v?[0-9._]+};  # crudely, a v-string or decimal

my $PKG_FIRST_WORD_REGEXP = qr{ # the FIRST word in a package name
  [a-zA-Z_]                     # the first word CANNOT start with a digit
    (?:
      [\w']?                    # can contain letters, digits, _, or ticks
      \w                        # But, NO multi-ticks or trailing ticks
    )*
}x;

my $PKG_ADDL_WORD_REGEXP = qr{ # the 2nd+ word in a package name
  \w                           # the 2nd+ word CAN start with digits
    (?:
      [\w']?                   # and can contain letters or ticks
      \w                       # But, NO multi-ticks or trailing ticks
    )*
}x;

my $PKG_NAME_REGEXP = qr{ # match a package name
  (?: :: )?               # a pkg name can start with arisdottle
  $PKG_FIRST_WORD_REGEXP  # a package word
  (?:
    (?: :: )+             ### arisdottle (allow one or many times)
    $PKG_ADDL_WORD_REGEXP ### a package word
  )*                      # ^ zero, one or many times
  (?:
    ::                    # allow trailing arisdottle
  )?
}x;

my $PKG_REGEXP  = qr{   # match a package declaration
  ^[\s\{;]*             # intro chars on a line
  package               # the word 'package'
  \s+                   # whitespace
  ($PKG_NAME_REGEXP)    # a package name
  \s*                   # optional whitespace
  ($V_NUM_REGEXP)?        # optional version number
  \s*                   # optional whitesapce
  [;\{]                 # semicolon line terminator or block start (since 5.16)
}x;

my $VARNAME_REGEXP = qr{ # match fully-qualified VERSION name
  ([\$*])         # sigil - $ or *
  (
    (             # optional leading package name
      (?:::|\')?  # possibly starting like just :: (a la $::VERSION)
      (?:\w+(?:::|\'))*  # Foo::Bar:: ...
    )?
    VERSION
  )\b
}x;

my $VERS_REGEXP = qr{ # match a VERSION definition
  (?:
    \(\s*$VARNAME_REGEXP\s*\) # with parens
  |
    $VARNAME_REGEXP           # without parens
  )
  \s*
  =[^=~>]  # = but not ==, nor =~, nor =>
}x;

sub new_from_file {
  my $class    = shift;
  my $filename = File::Spec->rel2abs( shift );

  return undef unless defined( $filename ) && -f $filename;
  return $class->_init(undef, $filename, @_);
}

sub new_from_handle {
  my $class    = shift;
  my $handle   = shift;
  my $filename = shift;
  return undef unless defined($handle) && defined($filename);
  $filename = File::Spec->rel2abs( $filename );

  return $class->_init(undef, $filename, @_, handle => $handle);

}


sub new_from_module {
  my $class   = shift;
  my $module  = shift;
  my %props   = @_;

  $props{inc} ||= \@INC;
  my $filename = $class->find_module_by_name( $module, $props{inc} );
  return undef unless defined( $filename ) && -f $filename;
  return $class->_init($module, $filename, %props);
}

{

  my $compare_versions = sub {
    my ($v1, $op, $v2) = @_;
    $v1 = version->new($v1)
      unless UNIVERSAL::isa($v1,'version');

    my $eval_str = "\$v1 $op \$v2";
    my $result   = eval $eval_str;
    log_info { "error comparing versions: '$eval_str' $@" } if $@;

    return $result;
  };

  my $normalize_version = sub {
    my ($version) = @_;
    if ( $version =~ /[=<>!,]/ ) { # logic, not just version
      # take as is without modification
    }
    elsif ( ref $version eq 'version' ) { # version objects
      $version = $version->is_qv ? $version->normal : $version->stringify;
    }
    elsif ( $version =~ /^[^v][^.]*\.[^.]+\./ ) { # no leading v, multiple dots
      # normalize string tuples without "v": "1.2.3" -> "v1.2.3"
      $version = "v$version";
    }
    else {
      # leave alone
    }
    return $version;
  };

  # separate out some of the conflict resolution logic

  my $resolve_module_versions = sub {
    my $packages = shift;

    my( $file, $version );
    my $err = '';
      foreach my $p ( @$packages ) {
        if ( defined( $p->{version} ) ) {
          if ( defined( $version ) ) {
            if ( $compare_versions->( $version, '!=', $p->{version} ) ) {
              $err .= "  $p->{file} ($p->{version})\n";
            }
            else {
              # same version declared multiple times, ignore
            }
          }
          else {
            $file    = $p->{file};
            $version = $p->{version};
          }
        }
      $file ||= $p->{file} if defined( $p->{file} );
    }

    if ( $err ) {
      $err = "  $file ($version)\n" . $err;
    }

    my %result = (
      file    => $file,
      version => $version,
      err     => $err
    );

    return \%result;
  };

  sub provides {
    my $class = shift;

    croak "provides() requires key/value pairs \n" if @_ % 2;
    my %args = @_;

    croak "provides() takes only one of 'dir' or 'files'\n"
      if $args{dir} && $args{files};

    croak "provides() requires a 'version' argument"
      unless defined $args{version};

    croak "provides() does not support version '$args{version}' metadata"
        unless grep { $args{version} eq $_ } qw/1.4 2/;

    $args{prefix} = 'lib' unless defined $args{prefix};

    my $p;
    if ( $args{dir} ) {
      $p = $class->package_versions_from_directory($args{dir});
    }
    else {
      croak "provides() requires 'files' to be an array reference\n"
        unless ref $args{files} eq 'ARRAY';
      $p = $class->package_versions_from_directory($args{files});
    }

    # Now, fix up files with prefix
    if ( length $args{prefix} ) { # check in case disabled with q{}
      $args{prefix} =~ s{/$}{};
      for my $v ( values %$p ) {
        $v->{file} = "$args{prefix}/$v->{file}";
      }
    }

    return $p
  }

  sub package_versions_from_directory {
    my ( $class, $dir, $files ) = @_;

    my @files;

    if ( $files ) {
      @files = @$files;
    }
    else {
      find( {
        wanted => sub {
          push @files, $_ if -f $_ && /\.pm$/;
        },
        no_chdir => 1,
      }, $dir );
    }

    # First, we enumerate all packages & versions,
    # separating into primary & alternative candidates
    my( %prime, %alt );
    foreach my $file (@files) {
      my $mapped_filename = File::Spec::Unix->abs2rel( $file, $dir );
      my @path = split( /\//, $mapped_filename );
      (my $prime_package = join( '::', @path )) =~ s/\.pm$//;

      my $pm_info = $class->new_from_file( $file );

      foreach my $package ( $pm_info->packages_inside ) {
        next if $package eq 'main';  # main can appear numerous times, ignore
        next if $package eq 'DB';    # special debugging package, ignore
        next if grep /^_/, split( /::/, $package ); # private package, ignore

        my $version = $pm_info->version( $package );

        $prime_package = $package if lc($prime_package) eq lc($package);
        if ( $package eq $prime_package ) {
          if ( exists( $prime{$package} ) ) {
            croak "Unexpected conflict in '$package'; multiple versions found.\n";
          }
          else {
            $mapped_filename = "$package.pm" if lc("$package.pm") eq lc($mapped_filename);
            $prime{$package}{file} = $mapped_filename;
            $prime{$package}{version} = $version if defined( $version );
          }
        }
        else {
          push( @{$alt{$package}}, {
                                    file    => $mapped_filename,
                                    version => $version,
                                   } );
        }
      }
    }

    # Then we iterate over all the packages found above, identifying conflicts
    # and selecting the "best" candidate for recording the file & version
    # for each package.
    foreach my $package ( keys( %alt ) ) {
      my $result = $resolve_module_versions->( $alt{$package} );

      if ( exists( $prime{$package} ) ) { # primary package selected

        if ( $result->{err} ) {
        # Use the selected primary package, but there are conflicting
        # errors among multiple alternative packages that need to be
        # reported
          log_info {
            "Found conflicting versions for package '$package'\n" .
            "  $prime{$package}{file} ($prime{$package}{version})\n" .
            $result->{err}
          };

        }
        elsif ( defined( $result->{version} ) ) {
        # There is a primary package selected, and exactly one
        # alternative package

        if ( exists( $prime{$package}{version} ) &&
             defined( $prime{$package}{version} ) ) {
          # Unless the version of the primary package agrees with the
          # version of the alternative package, report a conflict
        if ( $compare_versions->(
                 $prime{$package}{version}, '!=', $result->{version}
               )
             ) {

            log_info {
              "Found conflicting versions for package '$package'\n" .
              "  $prime{$package}{file} ($prime{$package}{version})\n" .
              "  $result->{file} ($result->{version})\n"
            };
          }

        }
        else {
          # The prime package selected has no version so, we choose to
          # use any alternative package that does have a version
          $prime{$package}{file}    = $result->{file};
          $prime{$package}{version} = $result->{version};
        }

        }
        else {
        # no alt package found with a version, but we have a prime
        # package so we use it whether it has a version or not
        }

      }
      else { # No primary package was selected, use the best alternative

        if ( $result->{err} ) {
          log_info {
            "Found conflicting versions for package '$package'\n" .
            $result->{err}
          };
        }

        # Despite possible conflicting versions, we choose to record
        # something rather than nothing
        $prime{$package}{file}    = $result->{file};
        $prime{$package}{version} = $result->{version}
          if defined( $result->{version} );
      }
    }

    # Normalize versions.  Can't use exists() here because of bug in YAML::Node.
    # XXX "bug in YAML::Node" comment seems irrelevant -- dagolden, 2009-05-18
    for (grep defined $_->{version}, values %prime) {
      $_->{version} = $normalize_version->( $_->{version} );
    }

    return \%prime;
  }
}


sub _init {
  my $class    = shift;
  my $module   = shift;
  my $filename = shift;
  my %props = @_;

  my $handle = delete $props{handle};
  my( %valid_props, @valid_props );
  @valid_props = qw( collect_pod inc );
  @valid_props{@valid_props} = delete( @props{@valid_props} );
  warn "Unknown properties: @{[keys %props]}\n" if scalar( %props );

  my %data = (
    module       => $module,
    filename     => $filename,
    version      => undef,
    packages     => [],
    versions     => {},
    pod          => {},
    pod_headings => [],
    collect_pod  => 0,

    %valid_props,
  );

  my $self = bless(\%data, $class);

  if ( not $handle ) {
    my $filename = $self->{filename};
    open $handle, '<', $filename
      or croak( "Can't open '$filename': $!" );

    $self->_handle_bom($handle, $filename);
  }
  $self->_parse_fh($handle);

  unless($self->{module} and length($self->{module})) {
    my ($v, $d, $f) = File::Spec->splitpath($self->{filename});
    if($f =~ /\.pm$/) {
      $f =~ s/\..+$//;
      my @candidates = grep /$f$/, @{$self->{packages}};
      $self->{module} = shift(@candidates); # punt
    }
    else {
      $self->{module} = 'main';
    }
  }

  $self->{version} = $self->{versions}{$self->{module}}
    if defined( $self->{module} );

  return $self;
}

# class method
sub _do_find_module {
  my $class   = shift;
  my $module  = shift || croak 'find_module_by_name() requires a package name';
  my $dirs    = shift || \@INC;

  my $file = File::Spec->catfile(split( /::/, $module));
  foreach my $dir ( @$dirs ) {
    my $testfile = File::Spec->catfile($dir, $file);
    return [ File::Spec->rel2abs( $testfile ), $dir ]
      if -e $testfile and !-d _;  # For stuff like ExtUtils::xsubpp
    $testfile .= '.pm';
    return [ File::Spec->rel2abs( $testfile ), $dir ]
      if -e $testfile;
  }
  return;
}

# class method
sub find_module_by_name {
  my $found = shift()->_do_find_module(@_) or return;
  return $found->[0];
}

# class method
sub find_module_dir_by_name {
  my $found = shift()->_do_find_module(@_) or return;
  return $found->[1];
}


# given a line of perl code, attempt to parse it if it looks like a
# $VERSION assignment, returning sigil, full name, & package name
sub _parse_version_expression {
  my $self = shift;
  my $line = shift;

  my( $sigil, $variable_name, $package);
  if ( $line =~ /$VERS_REGEXP/o ) {
    ( $sigil, $variable_name, $package) = $2 ? ( $1, $2, $3 ) : ( $4, $5, $6 );
    if ( $package ) {
      $package = ($package eq '::') ? 'main' : $package;
      $package =~ s/::$//;
    }
  }

  return ( $sigil, $variable_name, $package );
}

# Look for a UTF-8/UTF-16BE/UTF-16LE BOM at the beginning of the stream.
# If there's one, then skip it and set the :encoding layer appropriately.
sub _handle_bom {
  my ($self, $fh, $filename) = @_;

  my $pos = tell $fh;
  return unless defined $pos;

  my $buf = ' ' x 2;
  my $count = read $fh, $buf, length $buf;
  return unless defined $count and $count >= 2;

  my $encoding;
  if ( $buf eq "\x{FE}\x{FF}" ) {
    $encoding = 'UTF-16BE';
  }
  elsif ( $buf eq "\x{FF}\x{FE}" ) {
    $encoding = 'UTF-16LE';
  }
  elsif ( $buf eq "\x{EF}\x{BB}" ) {
    $buf = ' ';
    $count = read $fh, $buf, length $buf;
    if ( defined $count and $count >= 1 and $buf eq "\x{BF}" ) {
      $encoding = 'UTF-8';
    }
  }

  if ( defined $encoding ) {
    if ( "$]" >= 5.008 ) {
      binmode( $fh, ":encoding($encoding)" );
    }
  }
  else {
    seek $fh, $pos, SEEK_SET
      or croak( sprintf "Can't reset position to the top of '$filename'" );
  }

  return $encoding;
}

sub _parse_fh {
  my ($self, $fh) = @_;

  my( $in_pod, $seen_end, $need_vers ) = ( 0, 0, 0 );
  my( @packages, %vers, %pod, @pod );
  my $package = 'main';
  my $pod_sect = '';
  my $pod_data = '';
  my $in_end = 0;

  while (defined( my $line = <$fh> )) {
    my $line_num = $.;

    chomp( $line );

    # From toke.c : any line that begins by "=X", where X is an alphabetic
    # character, introduces a POD segment.
    my $is_cut;
    if ( $line =~ /^=([a-zA-Z].*)/ ) {
      my $cmd = $1;
      # Then it goes back to Perl code for "=cutX" where X is a non-alphabetic
      # character (which includes the newline, but here we chomped it away).
      $is_cut = $cmd =~ /^cut(?:[^a-zA-Z]|$)/;
      $in_pod = !$is_cut;
    }

    if ( $in_pod ) {

      if ( $line =~ /^=head[1-4]\s+(.+)\s*$/ ) {
        push( @pod, $1 );
        if ( $self->{collect_pod} && length( $pod_data ) ) {
          $pod{$pod_sect} = $pod_data;
          $pod_data = '';
        }
        $pod_sect = $1;
      }
      elsif ( $self->{collect_pod} ) {
        $pod_data .= "$line\n";
      }
      next;
    }
    elsif ( $is_cut ) {
      if ( $self->{collect_pod} && length( $pod_data ) ) {
        $pod{$pod_sect} = $pod_data;
        $pod_data = '';
      }
      $pod_sect = '';
      next;
    }

    # Skip after __END__
    next if $in_end;

    # Skip comments in code
    next if $line =~ /^\s*#/;

    # Would be nice if we could also check $in_string or something too
    if ($line eq '__END__') {
      $in_end++;
      next;
    }

    last if $line eq '__DATA__';

    # parse $line to see if it's a $VERSION declaration
    my( $version_sigil, $version_fullname, $version_package ) =
      index($line, 'VERSION') >= 1
        ? $self->_parse_version_expression( $line )
        : ();

    if ( $line =~ /$PKG_REGEXP/o ) {
      $package = $1;
      my $version = $2;
      push( @packages, $package ) unless grep( $package eq $_, @packages );
      $need_vers = defined $version ? 0 : 1;

      if ( not exists $vers{$package} and defined $version ){
        # Upgrade to a version object.
        my $dwim_version = eval { _dwim_version($version) };
        croak "Version '$version' from $self->{filename} does not appear to be valid:\n$line\n\nThe fatal error was: $@\n"
          unless defined $dwim_version;  # "0" is OK!
        $vers{$package} = $dwim_version;
      }
    }

    # VERSION defined with full package spec, i.e. $Module::VERSION
    elsif ( $version_fullname && $version_package ) {
      # we do NOT save this package in found @packages
      $need_vers = 0 if $version_package eq $package;

      unless ( defined $vers{$version_package} && length $vers{$version_package} ) {
        $vers{$version_package} = $self->_evaluate_version_line( $version_sigil, $version_fullname, $line );
      }
    }

    # first non-comment line in undeclared package main is VERSION
    elsif ( $package eq 'main' && $version_fullname && !exists($vers{main}) ) {
      $need_vers = 0;
      my $v = $self->_evaluate_version_line( $version_sigil, $version_fullname, $line );
      $vers{$package} = $v;
      push( @packages, 'main' );
    }

    # first non-comment line in undeclared package defines package main
    elsif ( $package eq 'main' && !exists($vers{main}) && $line =~ /\w/ ) {
      $need_vers = 1;
      $vers{main} = '';
      push( @packages, 'main' );
    }

    # only keep if this is the first $VERSION seen
    elsif ( $version_fullname && $need_vers ) {
      $need_vers = 0;
      my $v = $self->_evaluate_version_line( $version_sigil, $version_fullname, $line );

      unless ( defined $vers{$package} && length $vers{$package} ) {
        $vers{$package} = $v;
      }
    }
  } # end loop over each line

  if ( $self->{collect_pod} && length($pod_data) ) {
    $pod{$pod_sect} = $pod_data;
  }

  $self->{versions} = \%vers;
  $self->{packages} = \@packages;
  $self->{pod} = \%pod;
  $self->{pod_headings} = \@pod;
}

{
my $pn = 0;
sub _evaluate_version_line {
  my $self = shift;
  my( $sigil, $variable_name, $line ) = @_;

  # We compile into a local sub because 'use version' would cause
  # compiletime/runtime issues with local()
  $pn++; # everybody gets their own package
  my $eval = qq{ my \$dummy = q#  Hide from _packages_inside()
    #; package Module::Metadata::_version::p${pn};
    use version;
    sub {
      local $sigil$variable_name;
      $line;
      return \$$variable_name if defined \$$variable_name;
      return \$Module::Metadata::_version::p${pn}::$variable_name;
    };
  };

  $eval = $1 if $eval =~ m{^(.+)}s;

  local $^W;
  # Try to get the $VERSION
  my $vsub = __clean_eval($eval);
  # some modules say $VERSION <equal sign> $Foo::Bar::VERSION, but Foo::Bar isn't
  # installed, so we need to hunt in ./lib for it
  if ( $@ =~ /Can't locate/ && -d 'lib' ) {
    local @INC = ('lib',@INC);
    $vsub = __clean_eval($eval);
  }
  warn "Error evaling version line '$eval' in $self->{filename}: $@\n"
    if $@;

  (ref($vsub) eq 'CODE') or
    croak "failed to build version sub for $self->{filename}";

  my $result = eval { $vsub->() };
  # FIXME: $eval is not the right thing to print here
  croak "Could not get version from $self->{filename} by executing:\n$eval\n\nThe fatal error was: $@\n"
    if $@;

  # Upgrade it into a version object
  my $version = eval { _dwim_version($result) };

  # FIXME: $eval is not the right thing to print here
  croak "Version '$result' from $self->{filename} does not appear to be valid:\n$eval\n\nThe fatal error was: $@\n"
    unless defined $version; # "0" is OK!

  return $version;
}
}

# Try to DWIM when things fail the lax version test in obvious ways
{
  my @version_prep = (
    # Best case, it just works
    sub { return shift },

    # If we still don't have a version, try stripping any
    # trailing junk that is prohibited by lax rules
    sub {
      my $v = shift;
      $v =~ s{([0-9])[a-z-].*$}{$1}i; # 1.23-alpha or 1.23b
      return $v;
    },

    # Activestate apparently creates custom versions like '1.23_45_01', which
    # cause version.pm to think it's an invalid alpha.  So check for that
    # and strip them
    sub {
      my $v = shift;
      my $num_dots = () = $v =~ m{(\.)}g;
      my $num_unders = () = $v =~ m{(_)}g;
      my $leading_v = substr($v,0,1) eq 'v';
      if ( ! $leading_v && $num_dots < 2 && $num_unders > 1 ) {
        $v =~ s{_}{}g;
        $num_unders = () = $v =~ m{(_)}g;
      }
      return $v;
    },

    # Worst case, try numifying it like we would have before version objects
    sub {
      my $v = shift;
      no warnings 'numeric';
      return 0 + $v;
    },

  );

  sub _dwim_version {
    my ($result) = shift;

    return $result if ref($result) eq 'version';

    my ($version, $error);
    for my $f (@version_prep) {
      $result = $f->($result);
      $version = eval { version->new($result) };
      $error ||= $@ if $@; # capture first failure
      last if defined $version;
    }

    croak $error unless defined $version;

    return $version;
  }
}

############################################################

# accessors
sub name            { $_[0]->{module}            }

sub filename        { $_[0]->{filename}          }
sub packages_inside { @{$_[0]->{packages}}       }
sub pod_inside      { @{$_[0]->{pod_headings}}   }
sub contains_pod    { 0+@{$_[0]->{pod_headings}} }

sub version {
    my $self = shift;
    my $mod  = shift || $self->{module};
    my $vers;
    if ( defined( $mod ) && length( $mod ) &&
         exists( $self->{versions}{$mod} ) ) {
        return $self->{versions}{$mod};
    }
    else {
        return undef;
    }
}

sub pod {
    my $self = shift;
    my $sect = shift;
    if ( defined( $sect ) && length( $sect ) &&
         exists( $self->{pod}{$sect} ) ) {
        return $self->{pod}{$sect};
    }
    else {
        return undef;
    }
}

sub is_indexable {
  my ($self, $package) = @_;

  my @indexable_packages = grep { $_ ne 'main' } $self->packages_inside;

  # check for specific package, if provided
  return !! grep { $_ eq $package } @indexable_packages if $package;

  # otherwise, check for any indexable packages at all
  return !! @indexable_packages;
}

1;

__END__

=pod

=encoding UTF-8

=head1 NAME

Module::Metadata - Gather package and POD information from perl module files

=head1 VERSION

version 1.000031

=head1 SYNOPSIS

  use Module::Metadata;

  # information about a .pm file
  my $info = Module::Metadata->new_from_file( $file );
  my $version = $info->version;

  # CPAN META 'provides' field for .pm files in a directory
  my $provides = Module::Metadata->provides(
    dir => 'lib', version => 2
  );

=head1 DESCRIPTION

This module provides a standard way to gather metadata about a .pm file through
(mostly) static analysis and (some) code execution.  When determining the
version of a module, the C<$VERSION> assignment is C<eval>ed, as is traditional
in the CPAN toolchain.

=head1 CLASS METHODS

=head2 C<< new_from_file($filename, collect_pod => 1) >>

Constructs a C<Module::Metadata> object given the path to a file.  Returns
undef if the filename does not exist.

C<collect_pod> is a optional boolean argument that determines whether POD
data is collected and stored for reference.  POD data is not collected by
default.  POD headings are always collected.

If the file begins by an UTF-8, UTF-16BE or UTF-16LE byte-order mark, then
it is skipped before processing, and the content of the file is also decoded
appropriately starting from perl 5.8.

=head2 C<< new_from_handle($handle, $filename, collect_pod => 1) >>

This works just like C<new_from_file>, except that a handle can be provided
as the first argument.

Note that there is no validation to confirm that the handle is a handle or
something that can act like one.  Passing something that isn't a handle will
cause a exception when trying to read from it.  The C<filename> argument is
mandatory or undef will be returned.

You are responsible for setting the decoding layers on C<$handle> if
required.

=head2 C<< new_from_module($module, collect_pod => 1, inc => \@dirs) >>

Constructs a C<Module::Metadata> object given a module or package name.
Returns undef if the module cannot be found.

In addition to accepting the C<collect_pod> argument as described above,
this method accepts a C<inc> argument which is a reference to an array of
directories to search for the module.  If none are given, the default is
@INC.

If the file that contains the module begins by an UTF-8, UTF-16BE or
UTF-16LE byte-order mark, then it is skipped before processing, and the
content of the file is also decoded appropriately starting from perl 5.8.

=head2 C<< find_module_by_name($module, \@dirs) >>

Returns the path to a module given the module or package name. A list
of directories can be passed in as an optional parameter, otherwise
@INC is searched.

Can be called as either an object or a class method.

=head2 C<< find_module_dir_by_name($module, \@dirs) >>

Returns the entry in C<@dirs> (or C<@INC> by default) that contains
the module C<$module>. A list of directories can be passed in as an
optional parameter, otherwise @INC is searched.

Can be called as either an object or a class method.

=head2 C<< provides( %options ) >>

This is a convenience wrapper around C<package_versions_from_directory>
to generate a CPAN META C<provides> data structure.  It takes key/value
pairs.  Valid option keys include:

=over

=item version B<(required)>

Specifies which version of the L<CPAN::Meta::Spec> should be used as
the format of the C<provides> output.  Currently only '1.4' and '2'
are supported (and their format is identical).  This may change in
the future as the definition of C<provides> changes.

The C<version> option is required.  If it is omitted or if
an unsupported version is given, then C<provides> will throw an error.

=item dir

Directory to search recursively for F<.pm> files.  May not be specified with
C<files>.

=item files

Array reference of files to examine.  May not be specified with C<dir>.

=item prefix

String to prepend to the C<file> field of the resulting output. This defaults
to F<lib>, which is the common case for most CPAN distributions with their
F<.pm> files in F<lib>.  This option ensures the META information has the
correct relative path even when the C<dir> or C<files> arguments are
absolute or have relative paths from a location other than the distribution
root.

=back

For example, given C<dir> of 'lib' and C<prefix> of 'lib', the return value
is a hashref of the form:

  {
    'Package::Name' => {
      version => '0.123',
      file => 'lib/Package/Name.pm'
    },
    'OtherPackage::Name' => ...
  }

=head2 C<< package_versions_from_directory($dir, \@files?) >>

Scans C<$dir> for .pm files (unless C<@files> is given, in which case looks
for those files in C<$dir> - and reads each file for packages and versions,
returning a hashref of the form:

  {
    'Package::Name' => {
      version => '0.123',
      file => 'Package/Name.pm'
    },
    'OtherPackage::Name' => ...
  }

The C<DB> and C<main> packages are always omitted, as are any "private"
packages that have leading underscores in the namespace (e.g.
C<Foo::_private>)

Note that the file path is relative to C<$dir> if that is specified.
This B<must not> be used directly for CPAN META C<provides>.  See
the C<provides> method instead.

=head2 C<< log_info (internal) >>

Used internally to perform logging; imported from Log::Contextual if
Log::Contextual has already been loaded, otherwise simply calls warn.

=head1 OBJECT METHODS

=head2 C<< name() >>

Returns the name of the package represented by this module. If there
is more than one package, it makes a best guess based on the
filename. If it's a script (i.e. not a *.pm) the package name is
'main'.

=head2 C<< version($package) >>

Returns the version as defined by the $VERSION variable for the
package as returned by the C<name> method if no arguments are
given. If given the name of a package it will attempt to return the
version of that package if it is specified in the file.

=head2 C<< filename() >>

Returns the absolute path to the file.
Note that this file may not actually exist on disk yet, e.g. if the module was read from an in-memory filehandle.

=head2 C<< packages_inside() >>

Returns a list of packages. Note: this is a raw list of packages
discovered (or assumed, in the case of C<main>).  It is not
filtered for C<DB>, C<main> or private packages the way the
C<provides> method does.  Invalid package names are not returned,
for example "Foo:Bar".  Strange but valid package names are
returned, for example "Foo::Bar::", and are left up to the caller
on how to handle.

=head2 C<< pod_inside() >>

Returns a list of POD sections.

=head2 C<< contains_pod() >>

Returns true if there is any POD in the file.

=head2 C<< pod($section) >>

Returns the POD data in the given section.

=head2 C<< is_indexable($package) >> or C<< is_indexable() >>

Available since version 1.000020.

Returns a boolean indicating whether the package (if provided) or any package
(otherwise) is eligible for indexing by PAUSE, the Perl Authors Upload Server.
Note This only checks for valid C<package> declarations, and does not take any
ownership information into account.

=head1 SUPPORT

Bugs may be submitted through L<the RT bug tracker|https://rt.cpan.org/Public/Dist/Display.html?Name=Module-Metadata>
(or L<bug-Module-Metadata@rt.cpan.org|mailto:bug-Module-Metadata@rt.cpan.org>).

There is also a mailing list available for users of this distribution, at
L<http://lists.perl.org/list/cpan-workers.html>.

There is also an irc channel available for users of this distribution, at
L<irc://irc.perl.org/#toolchain>.

=head1 AUTHOR

Original code from Module::Build::ModuleInfo by Ken Williams
<kwilliams@cpan.org>, Randy W. Sims <RandyS@ThePierianSpring.org>

Released as Module::Metadata by Matt S Trout (mst) <mst@shadowcat.co.uk> with
assistance from David Golden (xdg) <dagolden@cpan.org>.

=head1 CONTRIBUTORS

=for stopwords Karen Etheridge David Golden Vincent Pit Matt S Trout Chris Nehren Graham Knop Olivier Mengu Tomas Doran Tatsuhiko Miyagawa tokuhirom Peter Rabbitson Steve Hay Josh Jore Craig A. Berry Mitchell Steinbrunner Edward Zborowski Gareth Harper James Raspass Jerry D. Hedden 'BinGOs' Williams Kent Fredric

=over 4

=item *

Karen Etheridge <ether@cpan.org>

=item *

David Golden <dagolden@cpan.org>

=item *

Vincent Pit <perl@profvince.com>

=item *

Matt S Trout <mst@shadowcat.co.uk>

=item *

Chris Nehren <apeiron@cpan.org>

=item *

Graham Knop <haarg@haarg.org>

=item *

Olivier Mengu <dolmen@cpan.org>

=item *

Tomas Doran <bobtfish@bobtfish.net>

=item *

Tatsuhiko Miyagawa <miyagawa@bulknews.net>

=item *

tokuhirom <tokuhirom@gmail.com>

=item *

Peter Rabbitson <ribasushi@cpan.org>

=item *

Steve Hay <steve.m.hay@googlemail.com>

=item *

Josh Jore <jjore@cpan.org>

=item *

Craig A. Berry <cberry@cpan.org>

=item *

David Mitchell <davem@iabyn.com>

=item *

David Steinbrunner <dsteinbrunner@pobox.com>

=item *

Edward Zborowski <ed@rubensteintech.com>

=item *

Gareth Harper <gareth@broadbean.com>

=item *

James Raspass <jraspass@gmail.com>

=item *

Jerry D. Hedden <jdhedden@cpan.org>

=item *

Chris 'BinGOs' Williams <chris@bingosnet.co.uk>

=item *

Kent Fredric <kentnl@cpan.org>

=back

=head1 COPYRIGHT & LICENSE

Original code Copyright (c) 2001-2011 Ken Williams.
Additional code Copyright (c) 2010-2011 Matt Trout and David Golden.
All rights reserved.

This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

=cut
                                                          package Module::CoreList::Utils;

use strict;
use warnings;
use vars qw[$VERSION %utilities];
use Module::CoreList;
use Module::CoreList::TieHashDelta;

$VERSION = '5.20170114_24';

sub utilities {
    my $perl = shift;
    $perl = shift if eval { $perl->isa(__PACKAGE__) };
    return unless $perl or exists $utilities{$perl};
    return sort keys %{ $utilities{$perl} };
}

sub _released_order {   # Sort helper, to make '?' sort after everything else
    (substr($Module::CoreList::released{$a}, 0, 1) eq "?")
    ? ((substr($Module::CoreList::released{$b}, 0, 1) eq "?")
        ? 0
        : 1)
    : ((substr($Module::CoreList::released{$b}, 0, 1) eq "?")
        ? -1
        : $Module::CoreList::released{$a} cmp $Module::CoreList::released{$b} )
}

sub first_release_raw {
    my $util = shift;
    $util = shift if eval { $util->isa(__PACKAGE__) };
      #and scalar @_ and $_[0] =~ m#\A[a-zA-Z_][0-9a-zA-Z_]*(?:(::|')[0-9a-zA-Z_]+)*\z#;
    my $version = shift;

    my @perls = $version
        ? grep { exists $utilities{$_}{ $util } &&
                        $utilities{$_}{ $util } ge $version } keys %utilities
        : grep { exists $utilities{$_}{ $util }             } keys %utilities;

    return grep { exists $Module::CoreList::released{$_} } @perls;
}

sub first_release_by_date {
    my @perls = &first_release_raw;
    return unless @perls;
    return (sort _released_order @perls)[0];
}

sub first_release {
    my @perls = &first_release_raw;
    return unless @perls;
    return (sort { $a cmp $b } @perls)[0];
}

sub removed_from {
  my @perls = &removed_raw;
  return shift @perls;
}

sub removed_from_by_date {
  my @perls = sort _released_order &removed_raw;
  return shift @perls;
}

sub removed_raw {
  my $util = shift;
  $util = shift if eval { $util->isa(__PACKAGE__) };
  return unless my @perls = sort { $a cmp $b } first_release_raw($util);
  @perls = grep { exists $Module::CoreList::released{$_} } @perls;
  my $last = pop @perls;
  my @removed = grep { $_ > $last } sort { $a cmp $b } keys %utilities;
  return @removed;
}

my %delta = (
    5 => {
        changed => {
            'a2p'                   => '1',
            'c2ph'                  => '1',
            'cppstdin'              => '1',
            'find2perl'             => '1',
            'pstruct'               => '1',
            's2p'                   => '1',
        },
        removed => {
        }
    },

    5.001 => {
        delta_from => 5,
        changed => {
            'h2xs'                  => '1',
        },
        removed => {
        }
    },

    5.002 => {
        delta_from => 5.001,
        changed => {
            'h2ph'                  => '1',
            'perlbug'               => '1',
            'perldoc'               => '1',
            'pod2html'              => '1',
            'pod2latex'             => '1',
            'pod2man'               => '1',
            'pod2text'              => '1',
        },
        removed => {
        }
    },

    5.00307 => {
        delta_from => 5.002,
        changed => {
            'pl2pm'                 => '1',
        },
        removed => {
           'cppstdin'              => 1,
           'pstruct'               => 1,
        }
    },

    5.004 => {
        delta_from => 5.00307,
        changed => {
            'splain'                => '1',
        },
        removed => {
        }
    },

    5.005 => {
        delta_from => 5.00405,
        changed => {
            'perlcc'                => '1',
        },
        removed => {
        }
    },

    5.00503 => {
        delta_from => 5.005,
        changed => {
        },
        removed => {
        }
    },

    5.00405 => {
        delta_from => 5.004,
        changed => {
        },
        removed => {
        }
    },

    5.006 => {
        delta_from => 5.00504,
        changed => {
            'dprofpp'               => '1',
            'pod2usage'             => '1',
            'podchecker'            => '1',
            'podselect'             => '1',
            'pstruct'               => '1',
        },
        removed => {
        }
    },

    5.006001 => {
        delta_from => 5.006,
        changed => {
        },
        removed => {
        }
    },

    5.007003 => {
        delta_from => 5.006002,
        changed => {
            'libnetcfg'             => '1',
            'perlivp'               => '1',
            'psed'                  => '1',
            'xsubpp'                => '1',
        },
        removed => {
        }
    },

    5.008 => {
        delta_from => 5.007003,
        changed => {
            'enc2xs'                => '1',
            'piconv'                => '1',
        },
        removed => {
        }
    },

    5.008001 => {
        delta_from => 5.008,
        changed => {
            'cpan'                  => '1',
        },
        removed => {
        }
    },

    5.009 => {
        delta_from => 5.008009,
        changed => {
        },
        removed => {
           'corelist'              => 1,
           'instmodsh'             => 1,
           'prove'                 => 1,
        }
    },

    5.008002 => {
        delta_from => 5.008001,
        changed => {
        },
        removed => {
        }
    },

    5.006002 => {
        delta_from => 5.006001,
        changed => {
        },
        removed => {
        }
    },

    5.008003 => {
        delta_from => 5.008002,
        changed => {
            'instmodsh'             => '1',
            'prove'                 => '1',
        },
        removed => {
        }
    },

    5.00504 => {
        delta_from => 5.00503,
        changed => {
        },
        removed => {
        }
    },

    5.009001 => {
        delta_from => 5.009,
        changed => {
            'instmodsh'             => '1',
            'prove'                 => '1',
        },
        removed => {
        }
    },

    5.008004 => {
        delta_from => 5.008003,
        changed => {
        },
        removed => {
        }
    },

    5.008005 => {
        delta_from => 5.008004,
        changed => {
        },
        removed => {
        }
    },

    5.008006 => {
        delta_from => 5.008005,
        changed => {
        },
        removed => {
        }
    },

    5.009002 => {
        delta_from => 5.009001,
        changed => {
            'corelist'              => '1',
        },
        removed => {
        }
    },

    5.008007 => {
        delta_from => 5.008006,
        changed => {
        },
        removed => {
        }
    },

    5.009003 => {
        delta_from => 5.009002,
        changed => {
            'ptar'                  => '1',
            'ptardiff'              => '1',
            'shasum'                => '1',
        },
        removed => {
        }
    },

    5.008008 => {
        delta_from => 5.008007,
        changed => {
        },
        removed => {
        }
    },

    5.009004 => {
        delta_from => 5.009003,
        changed => {
            'config_data'           => '1',
        },
        removed => {
        }
    },

    5.009005 => {
        delta_from => 5.009004,
        changed => {
            'cpan2dist'             => '1',
            'cpanp'                 => '1',
            'cpanp-run-perl'        => '1',
        },
        removed => {
           'perlcc'                => 1,
        }
    },

    5.010000 => {
        delta_from => 5.009005,
        changed => {
        },
        removed => {
        }
    },

    5.008009 => {
        delta_from => 5.008008,
        changed => {
            'corelist'              => '1',
        },
        removed => {
        }
    },

    5.010001 => {
        delta_from => 5.010000,
        changed => {
        },
        removed => {
        }
    },

    5.011 => {
        delta_from => 5.010001,
        changed => {
        },
        removed => {
        }
    },

    5.011001 => {
        delta_from => 5.011,
        changed => {
        },
        removed => {
        }
    },

    5.011002 => {
        delta_from => 5.011001,
        changed => {
            'perlthanks'            => '1',
        },
        removed => {
        }
    },

    5.011003 => {
        delta_from => 5.011002,
        changed => {
        },
        removed => {
        }
    },

    5.011004 => {
        delta_from => 5.011003,
        changed => {
        },
        removed => {
        }
    },

    5.011005 => {
        delta_from => 5.011004,
        changed => {
        },
        removed => {
        }
    },

    5.012 => {
        delta_from => 5.011005,
        changed => {
        },
        removed => {
        }
    },

    5.013 => {
        delta_from => 5.012005,
        changed => {
        },
        removed => {
        }
    },

    5.012001 => {
        delta_from => 5.012,
        changed => {
        },
        removed => {
        }
    },

    5.013001 => {
        delta_from => 5.013,
        changed => {
        },
        removed => {
        }
    },

    5.013002 => {
        delta_from => 5.013001,
        changed => {
        },
        removed => {
        }
    },

    5.013003 => {
        delta_from => 5.013002,
        changed => {
        },
        removed => {
        }
    },

    5.013004 => {
        delta_from => 5.013003,
        changed => {
        },
        removed => {
        }
    },

    5.012002 => {
        delta_from => 5.012001,
        changed => {
        },
        removed => {
        }
    },

    5.013005 => {
        delta_from => 5.013004,
        changed => {
        },
        removed => {
        }
    },

    5.013006 => {
        delta_from => 5.013005,
        changed => {
        },
        removed => {
        }
    },

    5.013007 => {
        delta_from => 5.013006,
        changed => {
            'ptargrep'              => '1',
        },
        removed => {
        }
    },

    5.013008 => {
        delta_from => 5.013007,
        changed => {
        },
        removed => {
        }
    },

    5.013009 => {
        delta_from => 5.013008,
        changed => {
            'json_pp'               => '1',
        },
        removed => {
        }
    },

    5.012003 => {
        delta_from => 5.012002,
        changed => {
        },
        removed => {
        }
    },

    5.013010 => {
        delta_from => 5.013009,
        changed => {
        },
        removed => {
        }
    },

    5.013011 => {
        delta_from => 5.013010,
        changed => {
        },
        removed => {
        }
    },

    5.014 => {
        delta_from => 5.013011,
        changed => {
        },
        removed => {
        }
    },

    5.014001 => {
        delta_from => 5.014,
        changed => {
        },
        removed => {
        }
    },

    5.015 => {
        delta_from => 5.014004,
        changed => {
        },
        removed => {
           'dprofpp'               => 1,
        }
    },

    5.012004 => {
        delta_from => 5.012003,
        changed => {
        },
        removed => {
        }
    },

    5.015001 => {
        delta_from => 5.015,
        changed => {
        },
        removed => {
        }
    },

    5.015002 => {
        delta_from => 5.015001,
        changed => {
        },
        removed => {
        }
    },

    5.015003 => {
        delta_from => 5.015002,
        changed => {
        },
        removed => {
        }
    },

    5.014002 => {
        delta_from => 5.014001,
        changed => {
        },
        removed => {
        }
    },

    5.015004 => {
        delta_from => 5.015003,
        changed => {
        },
        removed => {
        }
    },

    5.015005 => {
        delta_from => 5.015004,
        changed => {
        },
        removed => {
        }
    },

    5.015006 => {
        delta_from => 5.015005,
        changed => {
            'zipdetails'            => '1',
        },
        removed => {
        }
    },

    5.015007 => {
        delta_from => 5.015006,
        changed => {
        },
        removed => {
        }
    },

    5.015008 => {
        delta_from => 5.015007,
        changed => {
        },
        removed => {
        }
    },

    5.015009 => {
        delta_from => 5.015008,
        changed => {
        },
        removed => {
        }
    },

    5.016 => {
        delta_from => 5.015009,
        changed => {
        },
        removed => {
        }
    },

    5.017 => {
        delta_from => 5.016003,
        changed => {
        },
        removed => {
        }
    },

    5.017001 => {
        delta_from => 5.017,
        changed => {
        },
        removed => {
        }
    },

    5.017002 => {
        delta_from => 5.017001,
        changed => {
        },
        removed => {
        }
    },

    5.016001 => {
        delta_from => 5.016,
        changed => {
        },
        removed => {
        }
    },

    5.017003 => {
        delta_from => 5.017002,
        changed => {
        },
        removed => {
        }
    },

    5.017004 => {
        delta_from => 5.017003,
        changed => {
        },
        removed => {
        }
    },

    5.014003 => {
        delta_from => 5.014002,
        changed => {
        },
        removed => {
        }
    },

    5.017005 => {
        delta_from => 5.017004,
        changed => {
        },
        removed => {
        }
    },

    5.016002 => {
        delta_from => 5.016001,
        changed => {
        },
        removed => {
        }
    },

    5.012005 => {
        delta_from => 5.012004,
        changed => {
        },
        removed => {
        }
    },

    5.017006 => {
        delta_from => 5.017005,
        changed => {
        },
        removed => {
        }
    },

    5.017007 => {
        delta_from => 5.017006,
        changed => {
        },
        removed => {
        }
    },

    5.017008 => {
        delta_from => 5.017007,
        changed => {
        },
        removed => {
        }
    },

    5.017009 => {
        delta_from => 5.017008,
        changed => {
        },
        removed => {
        }
    },

    5.014004 => {
        delta_from => 5.014003,
        changed => {
        },
        removed => {
        }
    },

    5.016003 => {
        delta_from => 5.016002,
        changed => {
        },
        removed => {
        }
    },

    5.017010 => {
        delta_from => 5.017009,
        changed => {
        },
        removed => {
        }
    },

    5.017011 => {
        delta_from => 5.017010,
        changed => {
        },
        removed => {
        }
    },
    5.018000 => {
        delta_from => 5.017011,
        changed => {
        },
        removed => {
        }
    },
    5.018001 => {
        delta_from => 5.018000,
        changed => {
        },
        removed => {
        }
    },
    5.018002 => {
        delta_from => 5.018001,
        changed => {
        },
        removed => {
        }
    },
    5.018003 => {
        delta_from => 5.018000,
        changed => {
        },
        removed => {
        }
    },
    5.018004 => {
        delta_from => 5.018000,
        changed => {
        },
        removed => {
        }
    },
    5.019000 => {
        delta_from => 5.018000,
        changed => {
        },
        removed => {
            'cpan2dist'             => '1',
            'cpanp'                 => '1',
            'cpanp-run-perl'        => '1',
            'pod2latex'             => '1',
        }
    },
    5.019001 => {
        delta_from => 5.019000,
        changed => {
        },
        removed => {
        }
    },
    5.019002 => {
        delta_from => 5.019001,
        changed => {
        },
        removed => {
        }
    },
    5.019003 => {
        delta_from => 5.019002,
        changed => {
        },
        removed => {
        }
    },
    5.019004 => {
        delta_from => 5.019003,
        changed => {
        },
        removed => {
        }
    },
    5.019005 => {
        delta_from => 5.019004,
        changed => {
        },
        removed => {
        }
    },
    5.019006 => {
        delta_from => 5.019005,
        changed => {
        },
        removed => {
        }
    },
    5.019007 => {
        delta_from => 5.019006,
        changed => {
        },
        removed => {
        }
    },
    5.019008 => {
        delta_from => 5.019007,
        changed => {
        },
        removed => {
        }
    },
    5.019009 => {
        delta_from => 5.019008,
        changed => {
        },
        removed => {
        }
    },
    5.019010 => {
        delta_from => 5.019009,
        changed => {
        },
        removed => {
        }
    },
    5.019011 => {
        delta_from => 5.019010,
        changed => {
        },
        removed => {
        }
    },
    5.020000 => {
        delta_from => 5.019011,
        changed => {
        },
        removed => {
        }
    },
    5.021000 => {
        delta_from => 5.020000,
        changed => {
        },
        removed => {
        }
    },
    5.021001 => {
        delta_from => 5.021000,
        changed => {
        },
        removed => {
            'a2p'                   => 1,
            'config_data'           => 1,
            'find2perl'             => 1,
            'psed'                  => 1,
            's2p'                   => 1,
        }
    },
    5.021002 => {
        delta_from => 5.021001,
        changed => {
        },
        removed => {
        }
    },
    5.021003 => {
        delta_from => 5.021002,
        changed => {
        },
        removed => {
        }
    },
    5.020001 => {
        delta_from => 5.02,
        changed => {
        },
        removed => {
        }
    },
    5.021004 => {
        delta_from => 5.021003,
        changed => {
        },
        removed => {
        }
    },
    5.021005 => {
        delta_from => 5.021004,
        changed => {
        },
        removed => {
        }
    },
    5.021006 => {
        delta_from => 5.021005,
        changed => {
        },
        removed => {
        }
    },
    5.021007 => {
        delta_from => 5.021006,
        changed => {
        },
        removed => {
        }
    },
    5.021008 => {
        delta_from => 5.021007,
        changed => {
        },
        removed => {
        }
    },
    5.020002 => {
        delta_from => 5.020001,
        changed => {
        },
        removed => {
        }
    },
    5.021009 => {
        delta_from => 5.021008,
        changed => {
            'encguess'              => '1',
        },
        removed => {
        }
    },
    5.021010 => {
        delta_from => 5.021009,
        changed => {
        },
        removed => {
        }
    },
    5.021011 => {
        delta_from => 5.02101,
        changed => {
        },
        removed => {
        }
    },
    5.022000 => {
        delta_from => 5.021011,
        changed => {
        },
        removed => {
        }
    },
    5.023000 => {
        delta_from => 5.022000,
        changed => {
        },
        removed => {
        }
    },
    5.023001 => {
        delta_from => 5.023,
        changed => {
        },
        removed => {
        }
    },
    5.023002 => {
        delta_from => 5.023001,
        changed => {
        },
        removed => {
        }
    },
    5.020003 => {
        delta_from => 5.020002,
        changed => {
        },
        removed => {
        }
    },
    5.023003 => {
        delta_from => 5.023002,
        changed => {
        },
        removed => {
        }
    },
    5.023004 => {
        delta_from => 5.023003,
        changed => {
        },
        removed => {
        }
    },
    5.023005 => {
        delta_from => 5.023004,
        changed => {
        },
        removed => {
        }
    },
    5.022001 => {
        delta_from => 5.022,
        changed => {
        },
        removed => {
        }
    },
    5.023006 => {
        delta_from => 5.023005,
        changed => {
        },
        removed => {
        }
    },
    5.023007 => {
        delta_from => 5.023006,
        changed => {
        },
        removed => {
        }
    },
    5.023008 => {
        delta_from => 5.023007,
        changed => {
        },
        removed => {
        }
    },
    5.023009 => {
        delta_from => 5.023008,
        changed => {
        },
        removed => {
        }
    },
    5.022002 => {
        delta_from => 5.022001,
        changed => {
        },
        removed => {
        }
    },
    5.024000 => {
        delta_from => 5.023009,
        changed => {
        },
        removed => {
        }
    },
    5.025000 => {
        delta_from => 5.024000,
        changed => {
        },
        removed => {
        }
    },
    5.025001 => {
        delta_from => 5.025000,
        changed => {
        },
        removed => {
        }
    },
    5.025002 => {
        delta_from => 5.025001,
        changed => {
        },
        removed => {
        }
    },
    5.025003 => {
        delta_from => 5.025002,
        changed => {
        },
        removed => {
        }
    },
    5.025004 => {
        delta_from => 5.025003,
        changed => {
        },
        removed => {
        }
    },
    5.025005 => {
        delta_from => 5.025004,
        changed => {
        },
        removed => {
        }
    },
    5.025006 => {
        delta_from => 5.025005,
        changed => {
        },
        removed => {
        }
    },
    5.025007 => {
        delta_from => 5.025006,
        changed => {
        },
        removed => {
        }
    },
    5.025008 => {
        delta_from => 5.025007,
        changed => {
        },
        removed => {
        }
    },
    5.024001 => {
        delta_from => 5.024000,
        changed => {
        },
        removed => {
        }
    },
);

for my $version (sort { $a <=> $b } keys %delta) {
    my $data = $delta{$version};

    tie %{$utilities{$version}}, 'Module::CoreList::TieHashDelta',
        $data->{changed}, $data->{removed},
        $data->{delta_from} ? $utilities{$data->{delta_from}} : undef;
}

# Create aliases with trailing zeros for $] use

$utilities{'5.000'} = $utilities{5};

_create_aliases(\%utilities);

sub _create_aliases {
    my ($hash) = @_;

    for my $version (keys %$hash) {
        next unless $version >= 5.010;

        my $padded = sprintf "%0.6f", $version;

        # If the version in string form isn't the same as the numeric version,
        # alias it.
        if ($padded ne $version && $version == $padded) {
            $hash->{$padded} = $hash->{$version};
        }
    }
}

'foo';

=pod

=head1 NAME

Module::CoreList::Utils - what utilities shipped with versions of perl

=head1 SYNOPSIS

 use Module::CoreList::Utils;

 print $Module::CoreList::Utils::utilities{5.009003}{ptar}; # prints 1

 print Module::CoreList::Utils->first_release('corelist');
 # prints 5.008009

 print Module::CoreList::Utils->first_release_by_date('corelist');
 # prints 5.009002

=head1 DESCRIPTION

Module::CoreList::Utils provides information on which core and dual-life utilities shipped
with each version of L<perl>.

It provides a number of mechanisms for querying this information.

There is a functional programming API available for programmers to query
information.

Programmers may also query the contained hash structure to find relevant
information.

=head1 FUNCTIONS API

These are the functions that are available, they may either be called as functions or class methods:

  Module::CoreList::Utils::first_release('corelist'); # as a function

  Module::CoreList::Utils->first_release('corelist'); # class method

=over

=item C<utilities>

Requires a perl version as an argument, returns a list of utilities that shipped with
that version of perl, or undef/empty list if that perl doesn't exist.

=item C<first_release( UTILITY )>

Requires a UTILITY name as an argument, returns the perl version when that utility first
appeared in core as ordered by perl version number or undef ( in scalar context )
or an empty list ( in list context ) if that utility is not in core.

=item C<first_release_by_date( UTILITY )>

Requires a UTILITY name as an argument, returns the perl version when that utility first
appeared in core as ordered by release date or undef ( in scalar context )
or an empty list ( in list context ) if that utility is not in core.

=item C<removed_from( UTILITY )>

Takes a UTILITY name as an argument, returns the first perl version where that utility
was removed from core. Returns undef if the given utility was never in core or remains
in core.

=item C<removed_from_by_date( UTILITY )>

Takes a UTILITY name as an argument, returns the first perl version by release date where that
utility was removed from core. Returns undef if the given utility was never in core or remains
in core.

=back

=head1 DATA STRUCTURES

These are the hash data structures that are available:

=over

=item C<%Module::CoreList::Utils::utilities>

A hash of hashes that is keyed on perl version as indicated
in $].  The second level hash is utility / defined pairs.

=back

=head1 AUTHOR

Chris C<BinGOs> Williams <chris@bingosnet.co.uk>

Currently maintained by the perl 5 porters E<lt>perl5-porters@perl.orgE<gt>.

This module is the result of archaeology undertaken during QA Hackathon
in Lancaster, April 2013.

=head1 LICENSE

Copyright (C) 2013 Chris Williams.  All Rights Reserved.

This module is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

=head1 SEE ALSO

L<corelist>, L<Module::CoreList>, L<perl>, L<http://perlpunks.de/corelist>

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  package Module::Load::Conditional;

use strict;

use Module::Load qw/load autoload_remote/;
use Params::Check                       qw[check];
use Locale::Maketext::Simple Style  => 'gettext';

use Carp        ();
use File::Spec  ();
use FileHandle  ();
use version;

use Module::Metadata ();

use constant ON_VMS   => $^O eq 'VMS';
use constant ON_WIN32 => $^O eq 'MSWin32' ? 1 : 0;
use constant QUOTE    => do { ON_WIN32 ? q["] : q['] };

BEGIN {
    use vars        qw[ $VERSION @ISA $VERBOSE $CACHE @EXPORT_OK $DEPRECATED
                        $FIND_VERSION $ERROR $CHECK_INC_HASH];
    use Exporter;
    @ISA            = qw[Exporter];
    $VERSION        = '0.64';
    $VERBOSE        = 0;
    $DEPRECATED     = 0;
    $FIND_VERSION   = 1;
    $CHECK_INC_HASH = 0;
    @EXPORT_OK      = qw[check_install can_load requires];
}

=pod

=head1 NAME

Module::Load::Conditional - Looking up module information / loading at runtime

=head1 SYNOPSIS

    use Module::Load::Conditional qw[can_load check_install requires];


    my $use_list = {
            CPANPLUS        => 0.05,
            LWP             => 5.60,
            'Test::More'    => undef,
    };

    print can_load( modules => $use_list )
            ? 'all modules loaded successfully'
            : 'failed to load required modules';


    my $rv = check_install( module => 'LWP', version => 5.60 )
                or print 'LWP is not installed!';

    print 'LWP up to date' if $rv->{uptodate};
    print "LWP version is $rv->{version}\n";
    print "LWP is installed as file $rv->{file}\n";


    print "LWP requires the following modules to be installed:\n";
    print join "\n", requires('LWP');

    ### allow M::L::C to peek in your %INC rather than just
    ### scanning @INC
    $Module::Load::Conditional::CHECK_INC_HASH = 1;

    ### reset the 'can_load' cache
    undef $Module::Load::Conditional::CACHE;

    ### don't have Module::Load::Conditional issue warnings --
    ### default is '1'
    $Module::Load::Conditional::VERBOSE = 0;

    ### The last error that happened during a call to 'can_load'
    my $err = $Module::Load::Conditional::ERROR;


=head1 DESCRIPTION

Module::Load::Conditional provides simple ways to query and possibly load any of
the modules you have installed on your system during runtime.

It is able to load multiple modules at once or none at all if one of
them was not able to load. It also takes care of any error checking
and so forth.

=head1 Methods

=head2 $href = check_install( module => NAME [, version => VERSION, verbose => BOOL ] );

C<check_install> allows you to verify if a certain module is installed
or not. You may call it with the following arguments:

=over 4

=item module

The name of the module you wish to verify -- this is a required key

=item version

The version this module needs to be -- this is optional

=item verbose

Whether or not to be verbose about what it is doing -- it will default
to $Module::Load::Conditional::VERBOSE

=back

It will return undef if it was not able to find where the module was
installed, or a hash reference with the following keys if it was able
to find the file:

=over 4

=item file

Full path to the file that contains the module

=item dir

Directory, or more exact the C<@INC> entry, where the module was
loaded from.

=item version

The version number of the installed module - this will be C<undef> if
the module had no (or unparsable) version number, or if the variable
C<$Module::Load::Conditional::FIND_VERSION> was set to true.
(See the C<GLOBAL VARIABLES> section below for details)

=item uptodate

A boolean value indicating whether or not the module was found to be
at least the version you specified. If you did not specify a version,
uptodate will always be true if the module was found.
If no parsable version was found in the module, uptodate will also be
true, since C<check_install> had no way to verify clearly.

See also C<$Module::Load::Conditional::DEPRECATED>, which affects
the outcome of this value.

=back

=cut

### this checks if a certain module is installed already ###
### if it returns true, the module in question is already installed
### or we found the file, but couldn't open it, OR there was no version
### to be found in the module
### it will return 0 if the version in the module is LOWER then the one
### we are looking for, or if we couldn't find the desired module to begin with
### if the installed version is higher or equal to the one we want, it will return
### a hashref with he module name and version in it.. so 'true' as well.
sub check_install {
    my %hash = @_;

    my $tmpl = {
            version => { default    => '0.0'    },
            module  => { required   => 1        },
            verbose => { default    => $VERBOSE },
    };

    my $args;
    unless( $args = check( $tmpl, \%hash, $VERBOSE ) ) {
        warn loc( q[A problem occurred checking arguments] ) if $VERBOSE;
        return;
    }

    my $file     = File::Spec->catfile( split /::/, $args->{module} ) . '.pm';
    my $file_inc = File::Spec::Unix->catfile(
                        split /::/, $args->{module}
                    ) . '.pm';

    ### where we store the return value ###
    my $href = {
            file        => undef,
            version     => undef,
            uptodate    => undef,
    };

    my $filename;

    ### check the inc hash if we're allowed to
    if( $CHECK_INC_HASH ) {
        $filename = $href->{'file'} =
            $INC{ $file_inc } if defined $INC{ $file_inc };

        ### find the version by inspecting the package
        if( defined $filename && $FIND_VERSION ) {
            no strict 'refs';
            $href->{version} = ${ "$args->{module}"."::VERSION" };
        }
    }

    ### we didn't find the filename yet by looking in %INC,
    ### so scan the dirs
    unless( $filename ) {

        DIR: for my $dir ( @INC ) {

            my $fh;

            if ( ref $dir ) {
                ### @INC hook -- we invoke it and get the filehandle back
                ### this is actually documented behaviour as of 5.8 ;)

                my $existed_in_inc = $INC{$file_inc};

                if (UNIVERSAL::isa($dir, 'CODE')) {
                    ($fh) = $dir->($dir, $file);

                } elsif (UNIVERSAL::isa($dir, 'ARRAY')) {
                    ($fh) = $dir->[0]->($dir, $file, @{$dir}{1..$#{$dir}})

                } elsif (UNIVERSAL::can($dir, 'INC')) {
                    ($fh) = $dir->INC($file);
                }

                if (!UNIVERSAL::isa($fh, 'GLOB')) {
                    warn loc(q[Cannot open file '%1': %2], $file, $!)
                            if $args->{verbose};
                    next;
                }

                $filename = $INC{$file_inc} || $file;

                delete $INC{$file_inc} if not $existed_in_inc;

            } else {
                $filename = File::Spec->catfile($dir, $file);
                next unless -e $filename;

                $fh = new FileHandle;
                if (!$fh->open($filename)) {
                    warn loc(q[Cannot open file '%1': %2], $file, $!)
                            if $args->{verbose};
                    next;
                }
            }

            ### store the directory we found the file in
            $href->{dir} = $dir;

            ### files need to be in unix format under vms,
            ### or they might be loaded twice
            $href->{file} = ON_VMS
                ? VMS::Filespec::unixify( $filename )
                : $filename;

            ### if we don't need the version, we're done
            last DIR unless $FIND_VERSION;

            ### otherwise, the user wants us to find the version from files
            my $mod_info = Module::Metadata->new_from_handle( $fh, $filename );
            my $ver      = $mod_info->version( $args->{module} );

            if( defined $ver ) {
                $href->{version} = $ver;

                last DIR;
            }
        }
    }

    ### if we couldn't find the file, return undef ###
    return unless defined $href->{file};

    ### only complain if we're expected to find a version higher than 0.0 anyway
    if( $FIND_VERSION and not defined $href->{version} ) {
        {   ### don't warn about the 'not numeric' stuff ###
            local $^W;

            ### if we got here, we didn't find the version
            warn loc(q[Could not check version on '%1'], $args->{module} )
                    if $args->{verbose} and $args->{version} > 0;
        }
        $href->{uptodate} = 1;

    } else {
        ### don't warn about the 'not numeric' stuff ###
        local $^W;

        ### use qv(), as it will deal with developer release number
        ### ie ones containing _ as well. This addresses bug report
        ### #29348: Version compare logic doesn't handle alphas?
        ###
        ### Update from JPeacock: apparently qv() and version->new
        ### are different things, and we *must* use version->new
        ### here, or things like #30056 might start happening

        ### We have to wrap this in an eval as version-0.82 raises
        ### exceptions and not warnings now *sigh*

        eval {

          $href->{uptodate} =
            version->new( $args->{version} ) <= version->new( $href->{version} )
                ? 1
                : 0;

        };
    }

    if ( $DEPRECATED and "$]" >= 5.011 ) {
        require Module::CoreList;
        require Config;

        $href->{uptodate} = 0 if
           exists $Module::CoreList::version{ 0+$] }{ $args->{module} } and
           Module::CoreList::is_deprecated( $args->{module} ) and
           $Config::Config{privlibexp} eq $href->{dir}
           and $Config::Config{privlibexp} ne $Config::Config{sitelibexp};
    }

    return $href;
}

=head2 $bool = can_load( modules => { NAME => VERSION [,NAME => VERSION] }, [verbose => BOOL, nocache => BOOL, autoload => BOOL] )

C<can_load> will take a list of modules, optionally with version
numbers and determine if it is able to load them. If it can load *ALL*
of them, it will. If one or more are unloadable, none will be loaded.

This is particularly useful if you have More Than One Way (tm) to
solve a problem in a program, and only wish to continue down a path
if all modules could be loaded, and not load them if they couldn't.

This function uses the C<load> function or the C<autoload_remote> function
from Module::Load under the hood.

C<can_load> takes the following arguments:

=over 4

=item modules

This is a hashref of module/version pairs. The version indicates the
minimum version to load. If no version is provided, any version is
assumed to be good enough.

=item verbose

This controls whether warnings should be printed if a module failed
to load.
The default is to use the value of $Module::Load::Conditional::VERBOSE.

=item nocache

C<can_load> keeps its results in a cache, so it will not load the
same module twice, nor will it attempt to load a module that has
already failed to load before. By default, C<can_load> will check its
cache, but you can override that by setting C<nocache> to true.

=item autoload

This controls whether imports the functions of a loaded modules to the caller package. The default is no importing any functions.

See the C<autoload> function and the C<autoload_remote> function from L<Module::Load> for details.

=cut

sub can_load {
    my %hash = @_;

    my $tmpl = {
        modules     => { default => {}, strict_type => 1 },
        verbose     => { default => $VERBOSE },
        nocache     => { default => 0 },
        autoload    => { default => 0 },
    };

    my $args;

    unless( $args = check( $tmpl, \%hash, $VERBOSE ) ) {
        $ERROR = loc(q[Problem validating arguments!]);
        warn $ERROR if $VERBOSE;
        return;
    }

    ### layout of $CACHE:
    ### $CACHE = {
    ###     $ module => {
    ###             usable  => BOOL,
    ###             version => \d,
    ###             file    => /path/to/file,
    ###     },
    ### };

    $CACHE ||= {}; # in case it was undef'd

    my $error;
    BLOCK: {
        my $href = $args->{modules};

        my @load;
        for my $mod ( keys %$href ) {

            next if $CACHE->{$mod}->{usable} && !$args->{nocache};

            ### else, check if the hash key is defined already,
            ### meaning $mod => 0,
            ### indicating UNSUCCESSFUL prior attempt of usage

            ### use qv(), as it will deal with developer release number
            ### ie ones containing _ as well. This addresses bug report
            ### #29348: Version compare logic doesn't handle alphas?
            ###
            ### Update from JPeacock: apparently qv() and version->new
            ### are different things, and we *must* use version->new
            ### here, or things like #30056 might start happening
            if (    !$args->{nocache}
                    && defined $CACHE->{$mod}->{usable}
                    && (version->new( $CACHE->{$mod}->{version}||0 )
                        >= version->new( $href->{$mod} ) )
            ) {
                $error = loc( q[Already tried to use '%1', which was unsuccessful], $mod);
                last BLOCK;
            }

            my $mod_data = check_install(
                                    module  => $mod,
                                    version => $href->{$mod}
                                );

            if( !$mod_data or !defined $mod_data->{file} ) {
                $error = loc(q[Could not find or check module '%1'], $mod);
                $CACHE->{$mod}->{usable} = 0;
                last BLOCK;
            }

            map {
                $CACHE->{$mod}->{$_} = $mod_data->{$_}
            } qw[version file uptodate];

            push @load, $mod;
        }

        for my $mod ( @load ) {

            if ( $CACHE->{$mod}->{uptodate} ) {

                if ( $args->{autoload} ) {
                    my $who = (caller())[0];
                    eval { autoload_remote $who, $mod };
                } else {
                    eval { load $mod };
                }

                ### in case anything goes wrong, log the error, the fact
                ### we tried to use this module and return 0;
                if( $@ ) {
                    $error = $@;
                    $CACHE->{$mod}->{usable} = 0;
                    last BLOCK;
                } else {
                    $CACHE->{$mod}->{usable} = 1;
                }

            ### module not found in @INC, store the result in
            ### $CACHE and return 0
            } else {

                $error = loc(q[Module '%1' is not uptodate!], $mod);
                $CACHE->{$mod}->{usable} = 0;
                last BLOCK;
            }
        }

    } # BLOCK

    if( defined $error ) {
        $ERROR = $error;
        Carp::carp( loc(q|%1 [THIS MAY BE A PROBLEM!]|,$error) ) if $args->{verbose};
        return;
    } else {
        return 1;
    }
}

=back

=head2 @list = requires( MODULE );

C<requires> can tell you what other modules a particular module
requires. This is particularly useful when you're intending to write
a module for public release and are listing its prerequisites.

C<requires> takes but one argument: the name of a module.
It will then first check if it can actually load this module, and
return undef if it can't.
Otherwise, it will return a list of modules and pragmas that would
have been loaded on the module's behalf.

Note: The list C<require> returns has originated from your current
perl and your current install.

=cut

sub requires {
    my $who = shift;

    unless( check_install( module => $who ) ) {
        warn loc(q[You do not have module '%1' installed], $who) if $VERBOSE;
        return undef;
    }

    my $lib = join " ", map { qq["-I$_"] } @INC;
    my $oneliner = 'print(join(qq[\n],map{qq[BONG=$_]}keys(%INC)),qq[\n])';
    my $cmd = join '', qq["$^X" $lib -M$who -e], QUOTE, $oneliner, QUOTE;

    return  sort
                grep { !/^$who$/  }
                map  { chomp; s|/|::|g; $_ }
                grep { s|\.pm$||i; }
                map  { s!^BONG\=!!; $_ }
                grep { m!^BONG\=! }
            `$cmd`;
}

1;

__END__

=head1 Global Variables

The behaviour of Module::Load::Conditional can be altered by changing the
following global variables:

=head2 $Module::Load::Conditional::VERBOSE

This controls whether Module::Load::Conditional will issue warnings and
explanations as to why certain things may have failed. If you set it
to 0, Module::Load::Conditional will not output any warnings.
The default is 0;

=head2 $Module::Load::Conditional::FIND_VERSION

This controls whether Module::Load::Conditional will try to parse
(and eval) the version from the module you're trying to load.

If you don't wish to do this, set this variable to C<false>. Understand
then that version comparisons are not possible, and Module::Load::Conditional
can not tell you what module version you have installed.
This may be desirable from a security or performance point of view.
Note that C<$FIND_VERSION> code runs safely under C<taint mode>.

The default is 1;

=head2 $Module::Load::Conditional::CHECK_INC_HASH

This controls whether C<Module::Load::Conditional> checks your
C<%INC> hash to see if a module is available. By default, only
C<@INC> is scanned to see if a module is physically on your
filesystem, or available via an C<@INC-hook>. Setting this variable
to C<true> will trust any entries in C<%INC> and return them for
you.

The default is 0;

=head2 $Module::Load::Conditional::CACHE

This holds the cache of the C<can_load> function. If you explicitly
want to remove the current cache, you can set this variable to
C<undef>

=head2 $Module::Load::Conditional::ERROR

This holds a string of the last error that happened during a call to
C<can_load>. It is useful to inspect this when C<can_load> returns
C<undef>.

=head2 $Module::Load::Conditional::DEPRECATED

This controls whether C<Module::Load::Conditional> checks if
a dual-life core module has been deprecated. If this is set to
true C<check_install> will return false to C<uptodate>, if
a dual-life module is found to be loaded from C<$Config{privlibexp}>

The default is 0;

=head1 See Also

C<Module::Load>

=head1 BUG REPORTS

Please report bugs or other issues to E<lt>bug-module-load-conditional@rt.cpan.orgE<gt>.

=head1 AUTHOR

This module by Jos Boumans E<lt>kane@cpan.orgE<gt>.

=head1 COPYRIGHT

This library is free software; you may redistribute and/or modify it
under the same terms as Perl itself.

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       # Net::Cmd.pm
#
# Versions up to 2.29_1 Copyright (c) 1995-2006 Graham Barr <gbarr@pobox.com>.
# All rights reserved.
# Changes in Version 2.29_2 onwards Copyright (C) 2013-2015 Steve Hay.  All
# rights reserved.
# This module is free software; you can redistribute it and/or modify it under
# the same terms as Perl itself, i.e. under the terms of either the GNU General
# Public License or the Artistic License, as specified in the F<LICENCE> file.

package Net::Cmd;

use 5.008001;

use strict;
use warnings;

use Carp;
use Exporter;
use Symbol 'gensym';
use Errno 'EINTR';

BEGIN {
  if ($^O eq 'os390') {
    require Convert::EBCDIC;

    #    Convert::EBCDIC->import;
  }
}

our $VERSION = "3.08_01";
our @ISA     = qw(Exporter);
our @EXPORT  = qw(CMD_INFO CMD_OK CMD_MORE CMD_REJECT CMD_ERROR CMD_PENDING);

use constant CMD_INFO    => 1;
use constant CMD_OK      => 2;
use constant CMD_MORE    => 3;
use constant CMD_REJECT  => 4;
use constant CMD_ERROR   => 5;
use constant CMD_PENDING => 0;

use constant DEF_REPLY_CODE => 421;

my %debug = ();

my $tr = $^O eq 'os390' ? Convert::EBCDIC->new() : undef;

sub toebcdic {
  my $cmd = shift;

  unless (exists ${*$cmd}{'net_cmd_asciipeer'}) {
    my $string    = $_[0];
    my $ebcdicstr = $tr->toebcdic($string);
    ${*$cmd}{'net_cmd_asciipeer'} = $string !~ /^\d+/ && $ebcdicstr =~ /^\d+/;
  }

  ${*$cmd}{'net_cmd_asciipeer'}
    ? $tr->toebcdic($_[0])
    : $_[0];
}


sub toascii {
  my $cmd = shift;
  ${*$cmd}{'net_cmd_asciipeer'}
    ? $tr->toascii($_[0])
    : $_[0];
}


sub _print_isa {
  no strict 'refs'; ## no critic (TestingAndDebugging::ProhibitNoStrict)

  my $pkg = shift;
  my $cmd = $pkg;

  $debug{$pkg} ||= 0;

  my %done = ();
  my @do   = ($pkg);
  my %spc  = ($pkg, "");

  while ($pkg = shift @do) {
    next if defined $done{$pkg};

    $done{$pkg} = 1;

    my $v =
      defined ${"${pkg}::VERSION"}
      ? "(" . ${"${pkg}::VERSION"} . ")"
      : "";

    my $spc = $spc{$pkg};
    $cmd->debug_print(1, "${spc}${pkg}${v}\n");

    if (@{"${pkg}::ISA"}) {
      @spc{@{"${pkg}::ISA"}} = ("  " . $spc{$pkg}) x @{"${pkg}::ISA"};
      unshift(@do, @{"${pkg}::ISA"});
    }
  }
}


sub debug {
  @_ == 1 or @_ == 2 or croak 'usage: $obj->debug([LEVEL])';

  my ($cmd, $level) = @_;
  my $pkg    = ref($cmd) || $cmd;
  my $oldval = 0;

  if (ref($cmd)) {
    $oldval = ${*$cmd}{'net_cmd_debug'} || 0;
  }
  else {
    $oldval = $debug{$pkg} || 0;
  }

  return $oldval
    unless @_ == 2;

  $level = $debug{$pkg} || 0
    unless defined $level;

  _print_isa($pkg)
    if ($level && !exists $debug{$pkg});

  if (ref($cmd)) {
    ${*$cmd}{'net_cmd_debug'} = $level;
  }
  else {
    $debug{$pkg} = $level;
  }

  $oldval;
}


sub message {
  @_ == 1 or croak 'usage: $obj->message()';

  my $cmd = shift;

  wantarray
    ? @{${*$cmd}{'net_cmd_resp'}}
    : join("", @{${*$cmd}{'net_cmd_resp'}});
}


sub debug_text { $_[2] }


sub debug_print {
  my ($cmd, $out, $text) = @_;
  print STDERR $cmd, ($out ? '>>> ' : '<<< '), $cmd->debug_text($out, $text);
}


sub code {
  @_ == 1 or croak 'usage: $obj->code()';

  my $cmd = shift;

  ${*$cmd}{'net_cmd_code'} = $cmd->DEF_REPLY_CODE
    unless exists ${*$cmd}{'net_cmd_code'};

  ${*$cmd}{'net_cmd_code'};
}


sub status {
  @_ == 1 or croak 'usage: $obj->status()';

  my $cmd = shift;

  substr(${*$cmd}{'net_cmd_code'}, 0, 1);
}


sub set_status {
  @_ == 3 or croak 'usage: $obj->set_status(CODE, MESSAGE)';

  my $cmd = shift;
  my ($code, $resp) = @_;

  $resp = defined $resp ? [$resp] : []
    unless ref($resp);

  (${*$cmd}{'net_cmd_code'}, ${*$cmd}{'net_cmd_resp'}) = ($code, $resp);

  1;
}

sub _syswrite_with_timeout {
  my $cmd = shift;
  my $line = shift;

  my $len    = length($line);
  my $offset = 0;
  my $win    = "";
  vec($win, fileno($cmd), 1) = 1;
  my $timeout = $cmd->timeout || undef;
  my $initial = time;
  my $pending = $timeout;

  local $SIG{PIPE} = 'IGNORE' unless $^O eq 'MacOS';

  while ($len) {
    my $wout;
    my $nfound = select(undef, $wout = $win, undef, $pending);
    if ((defined $nfound and $nfound > 0) or -f $cmd)    # -f for testing on win32
    {
      my $w = syswrite($cmd, $line, $len, $offset);
      if (! defined($w) ) {
        my $err = $!;
        $cmd->close;
        $cmd->_set_status_closed($err);
        return;
      }
      $len -= $w;
      $offset += $w;
    }
    elsif ($nfound == -1) {
      if ( $! == EINTR ) {
        if ( defined($timeout) ) {
          redo if ($pending = $timeout - ( time - $initial ) ) > 0;
          $cmd->_set_status_timeout;
          return;
        }
        redo;
      }
      my $err = $!;
      $cmd->close;
      $cmd->_set_status_closed($err);
      return;
    }
    else {
      $cmd->_set_status_timeout;
      return;
    }
  }

  return 1;
}

sub _set_status_timeout {
  my $cmd = shift;
  my $pkg = ref($cmd) || $cmd;

  $cmd->set_status($cmd->DEF_REPLY_CODE, "[$pkg] Timeout");
  carp(ref($cmd) . ": " . (caller(1))[3] . "(): timeout") if $cmd->debug;
}

sub _set_status_closed {
  my $cmd = shift;
  my $err = shift;
  my $pkg = ref($cmd) || $cmd;

  $cmd->set_status($cmd->DEF_REPLY_CODE, "[$pkg] Connection closed");
  carp(ref($cmd) . ": " . (caller(1))[3]
    . "(): unexpected EOF on command channel: $err") if $cmd->debug;
}

sub _is_closed {
  my $cmd = shift;
  if (!defined fileno($cmd)) {
     $cmd->_set_status_closed($!);
     return 1;
  }
  return 0;
}

sub command {
  my $cmd = shift;

  return $cmd
    if $cmd->_is_closed;

  $cmd->dataend()
    if (exists ${*$cmd}{'net_cmd_last_ch'});

  if (scalar(@_)) {
    my $str = join(
      " ",
      map {
        /\n/
          ? do { my $n = $_; $n =~ tr/\n/ /; $n }
          : $_;
        } @_
    );
    $str = $cmd->toascii($str) if $tr;
    $str .= "\015\012";

    $cmd->debug_print(1, $str)
      if ($cmd->debug);

    # though documented to return undef on failure, the legacy behavior
    # was to return $cmd even on failure, so this odd construct does that
    $cmd->_syswrite_with_timeout($str)
      or return $cmd;
  }

  $cmd;
}


sub ok {
  @_ == 1 or croak 'usage: $obj->ok()';

  my $code = $_[0]->code;
  0 < $code && $code < 400;
}


sub unsupported {
  my $cmd = shift;

  $cmd->set_status(580, 'Unsupported command');

  0;
}


sub getline {
  my $cmd = shift;

  ${*$cmd}{'net_cmd_lines'} ||= [];

  return shift @{${*$cmd}{'net_cmd_lines'}}
    if scalar(@{${*$cmd}{'net_cmd_lines'}});

  my $partial = defined(${*$cmd}{'net_cmd_partial'}) ? ${*$cmd}{'net_cmd_partial'} : "";

  return
    if $cmd->_is_closed;

  my $fd = fileno($cmd);
  my $rin = "";
  vec($rin, $fd, 1) = 1;

  my $buf;

  until (scalar(@{${*$cmd}{'net_cmd_lines'}})) {
    my $timeout = $cmd->timeout || undef;
    my $rout;

    my $select_ret = select($rout = $rin, undef, undef, $timeout);
    if ($select_ret > 0) {
      unless (sysread($cmd, $buf = "", 1024)) {
        my $err = $!;
        $cmd->close;
        $cmd->_set_status_closed($err);
        return;
      }

      substr($buf, 0, 0) = $partial;    ## prepend from last sysread

      my @buf = split(/\015?\012/, $buf, -1);    ## break into lines

      $partial = pop @buf;

      push(@{${*$cmd}{'net_cmd_lines'}}, map {"$_\n"} @buf);

    }
    else {
      $cmd->_set_status_timeout;
      return;
    }
  }

  ${*$cmd}{'net_cmd_partial'} = $partial;

  if ($tr) {
    foreach my $ln (@{${*$cmd}{'net_cmd_lines'}}) {
      $ln = $cmd->toebcdic($ln);
    }
  }

  shift @{${*$cmd}{'net_cmd_lines'}};
}


sub ungetline {
  my ($cmd, $str) = @_;

  ${*$cmd}{'net_cmd_lines'} ||= [];
  unshift(@{${*$cmd}{'net_cmd_lines'}}, $str);
}


sub parse_response {
  return ()
    unless $_[1] =~ s/^(\d\d\d)(.?)//o;
  ($1, $2 eq "-");
}


sub response {
  my $cmd = shift;
  my ($code, $more) = (undef) x 2;

  $cmd->set_status($cmd->DEF_REPLY_CODE, undef); # initialize the response

  while (1) {
    my $str = $cmd->getline();

    return CMD_ERROR
      unless defined($str);

    $cmd->debug_print(0, $str)
      if ($cmd->debug);

    ($code, $more) = $cmd->parse_response($str);
    unless (defined $code) {
      carp("$cmd: response(): parse error in '$str'") if ($cmd->debug);
      $cmd->ungetline($str);
      $@ = $str;   # $@ used as tunneling hack
      return CMD_ERROR;
    }

    ${*$cmd}{'net_cmd_code'} = $code;

    push(@{${*$cmd}{'net_cmd_resp'}}, $str);

    last unless ($more);
  }

  return unless defined $code;
  substr($code, 0, 1);
}


sub read_until_dot {
  my $cmd = shift;
  my $fh  = shift;
  my $arr = [];

  while (1) {
    my $str = $cmd->getline() or return;

    $cmd->debug_print(0, $str)
      if ($cmd->debug & 4);

    last if ($str =~ /^\.\r?\n/o);

    $str =~ s/^\.\././o;

    if (defined $fh) {
      print $fh $str;
    }
    else {
      push(@$arr, $str);
    }
  }

  $arr;
}


sub datasend {
  my $cmd  = shift;
  my $arr  = @_ == 1 && ref($_[0]) ? $_[0] : \@_;
  my $line = join("", @$arr);

  # Perls < 5.10.1 (with the exception of 5.8.9) have a performance problem with
  # the substitutions below when dealing with strings stored internally in
  # UTF-8, so downgrade them (if possible).
  # Data passed to datasend() should be encoded to octets upstream already so
  # shouldn't even have the UTF-8 flag on to start with, but if it so happens
  # that the octets are stored in an upgraded string (as can sometimes occur)
  # then they would still downgrade without fail anyway.
  # Only Unicode codepoints > 0xFF stored in an upgraded string will fail to
  # downgrade. We fail silently in that case, and a "Wide character in print"
  # warning will be emitted later by syswrite().
  utf8::downgrade($line, 1) if $] < 5.010001 && $] != 5.008009;

  return 0
    if $cmd->_is_closed;

  my $last_ch = ${*$cmd}{'net_cmd_last_ch'};

  # We have not send anything yet, so last_ch = "\012" means we are at the start of a line
  $last_ch = ${*$cmd}{'net_cmd_last_ch'} = "\012" unless defined $last_ch;

  return 1 unless length $line;

  if ($cmd->debug) {
    foreach my $b (split(/\n/, $line)) {
      $cmd->debug_print(1, "$b\n");
    }
  }

  $line =~ tr/\r\n/\015\012/ unless "\r" eq "\015";

  my $first_ch = '';

  if ($last_ch eq "\015") {
    # Remove \012 so it does not get prefixed with another \015 below
    # and escape the . if there is one following it because the fixup
    # below will not find it
    $first_ch = "\012" if $line =~ s/^\012(\.?)/$1$1/;
  }
  elsif ($last_ch eq "\012") {
    # Fixup below will not find the . as the first character of the buffer
    $first_ch = "." if $line =~ /^\./;
  }

  $line =~ s/\015?\012(\.?)/\015\012$1$1/sg;

  substr($line, 0, 0) = $first_ch;

  ${*$cmd}{'net_cmd_last_ch'} = substr($line, -1, 1);

  $cmd->_syswrite_with_timeout($line)
    or return;

  1;
}


sub rawdatasend {
  my $cmd  = shift;
  my $arr  = @_ == 1 && ref($_[0]) ? $_[0] : \@_;
  my $line = join("", @$arr);

  return 0
    if $cmd->_is_closed;

  return 1
    unless length($line);

  if ($cmd->debug) {
    my $b = "$cmd>>> ";
    print STDERR $b, join("\n$b", split(/\n/, $line)), "\n";
  }

  $cmd->_syswrite_with_timeout($line)
    or return;

  1;
}


sub dataend {
  my $cmd = shift;

  return 0
    if $cmd->_is_closed;

  my $ch = ${*$cmd}{'net_cmd_last_ch'};
  my $tosend;

  if (!defined $ch) {
    return 1;
  }
  elsif ($ch ne "\012") {
    $tosend = "\015\012";
  }

  $tosend .= ".\015\012";

  $cmd->debug_print(1, ".\n")
    if ($cmd->debug);

  $cmd->_syswrite_with_timeout($tosend)
    or return 0;

  delete ${*$cmd}{'net_cmd_last_ch'};

  $cmd->response() == CMD_OK;
}

# read and write to tied filehandle
sub tied_fh {
  my $cmd = shift;
  ${*$cmd}{'net_cmd_readbuf'} = '';
  my $fh = gensym();
  tie *$fh, ref($cmd), $cmd;
  return $fh;
}

# tie to myself
sub TIEHANDLE {
  my $class = shift;
  my $cmd   = shift;
  return $cmd;
}

# Tied filehandle read.  Reads requested data length, returning
# end-of-file when the dot is encountered.
sub READ {
  my $cmd = shift;
  my ($len, $offset) = @_[1, 2];
  return unless exists ${*$cmd}{'net_cmd_readbuf'};
  my $done = 0;
  while (!$done and length(${*$cmd}{'net_cmd_readbuf'}) < $len) {
    ${*$cmd}{'net_cmd_readbuf'} .= $cmd->getline() or return;
    $done++ if ${*$cmd}{'net_cmd_readbuf'} =~ s/^\.\r?\n\Z//m;
  }

  $_[0] = '';
  substr($_[0], $offset + 0) = substr(${*$cmd}{'net_cmd_readbuf'}, 0, $len);
  substr(${*$cmd}{'net_cmd_readbuf'}, 0, $len) = '';
  delete ${*$cmd}{'net_cmd_readbuf'} if $done;

  return length $_[0];
}


sub READLINE {
  my $cmd = shift;

  # in this context, we use the presence of readbuf to
  # indicate that we have not yet reached the eof
  return unless exists ${*$cmd}{'net_cmd_readbuf'};
  my $line = $cmd->getline;
  return if $line =~ /^\.\r?\n/;
  $line;
}


sub PRINT {
  my $cmd = shift;
  my ($buf, $len, $offset) = @_;
  $len ||= length($buf);
  $offset += 0;
  return unless $cmd->datasend(substr($buf, $offset, $len));
  ${*$cmd}{'net_cmd_sending'}++;    # flag that we should call dataend()
  return $len;
}


sub CLOSE {
  my $cmd = shift;
  my $r = exists(${*$cmd}{'net_cmd_sending'}) ? $cmd->dataend : 1;
  delete ${*$cmd}{'net_cmd_readbuf'};
  delete ${*$cmd}{'net_cmd_sending'};
  $r;
}

1;

__END__


=head1 NAME

Net::Cmd - Network Command class (as used by FTP, SMTP etc)

=head1 SYNOPSIS

    use Net::Cmd;

    @ISA = qw(Net::Cmd);

=head1 DESCRIPTION

C<Net::Cmd> is a collection of methods that can be inherited by a sub class
of C<IO::Handle>. These methods implement the functionality required for a
command based protocol, for example FTP and SMTP.

=head1 USER METHODS

These methods provide a user interface to the C<Net::Cmd> object.

=over 4

=item debug ( VALUE )

Set the level of debug information for this object. If C<VALUE> is not given
then the current state is returned. Otherwise the state is changed to 
C<VALUE> and the previous state returned. 

Different packages
may implement different levels of debug but a non-zero value results in 
copies of all commands and responses also being sent to STDERR.

If C<VALUE> is C<undef> then the debug level will be set to the default
debug level for the class.

This method can also be called as a I<static> method to set/get the default
debug level for a given class.

=item message ()

Returns the text message returned from the last command. In a scalar
context it returns a single string, in a list context it will return
each line as a separate element. (See L<PSEUDO RESPONSES> below.)

=item code ()

Returns the 3-digit code from the last command. If a command is pending
then the value 0 is returned. (See L<PSEUDO RESPONSES> below.)

=item ok ()

Returns non-zero if the last code value was greater than zero and
less than 400. This holds true for most command servers. Servers
where this does not hold may override this method.

=item status ()

Returns the most significant digit of the current status code. If a command
is pending then C<CMD_PENDING> is returned.

=item datasend ( DATA )

Send data to the remote server, converting LF to CRLF. Any line starting
with a '.' will be prefixed with another '.'.
C<DATA> may be an array or a reference to an array.
The C<DATA> passed in must be encoded by the caller to octets of whatever
encoding is required, e.g. by using the Encode module's C<encode()> function.

=item dataend ()

End the sending of data to the remote server. This is done by ensuring that
the data already sent ends with CRLF then sending '.CRLF' to end the
transmission. Once this data has been sent C<dataend> calls C<response> and
returns true if C<response> returns CMD_OK.

=back

=head1 CLASS METHODS

These methods are not intended to be called by the user, but used or 
over-ridden by a sub-class of C<Net::Cmd>

=over 4

=item debug_print ( DIR, TEXT )

Print debugging information. C<DIR> denotes the direction I<true> being
data being sent to the server. Calls C<debug_text> before printing to
STDERR.

=item debug_text ( DIR, TEXT )

This method is called to print debugging information. TEXT is
the text being sent. The method should return the text to be printed.

This is primarily meant for the use of modules such as FTP where passwords
are sent, but we do not want to display them in the debugging information.

=item command ( CMD [, ARGS, ... ])

Send a command to the command server. All arguments are first joined with
a space character and CRLF is appended, this string is then sent to the
command server.

Returns undef upon failure.

=item unsupported ()

Sets the status code to 580 and the response text to 'Unsupported command'.
Returns zero.

=item response ()

Obtain a response from the server. Upon success the most significant digit
of the status code is returned. Upon failure, timeout etc., I<CMD_ERROR> is
returned.

=item parse_response ( TEXT )

This method is called by C<response> as a method with one argument. It should
return an array of 2 values, the 3-digit status code and a flag which is true
when this is part of a multi-line response and this line is not the last.

=item getline ()

Retrieve one line, delimited by CRLF, from the remote server. Returns I<undef>
upon failure.

B<NOTE>: If you do use this method for any reason, please remember to add
some C<debug_print> calls into your method.

=item ungetline ( TEXT )

Unget a line of text from the server.

=item rawdatasend ( DATA )

Send data to the remote server without performing any conversions. C<DATA>
is a scalar.
As with C<datasend()>, the C<DATA> passed in must be encoded by the caller
to octets of whatever encoding is required, e.g. by using the Encode module's
C<encode()> function.

=item read_until_dot ()

Read data from the remote server until a line consisting of a single '.'.
Any lines starting with '..' will have one of the '.'s removed.

Returns a reference to a list containing the lines, or I<undef> upon failure.

=item tied_fh ()

Returns a filehandle tied to the Net::Cmd object.  After issuing a
command, you may read from this filehandle using read() or <>.  The
filehandle will return EOF when the final dot is encountered.
Similarly, you may write to the filehandle in order to send data to
the server after issuing a command that expects data to be written.

See the Net::POP3 and Net::SMTP modules for examples of this.

=back

=head1 PSEUDO RESPONSES

Normally the values returned by C<message()> and C<code()> are
obtained from the remote server, but in a few circumstances, as
detailed below, C<Net::Cmd> will return values that it sets. You
can alter this behavior by overriding DEF_REPLY_CODE() to specify
a different default reply code, or overriding one of the specific
error handling methods below.

=over 4

=item Initial value

Before any command has executed or if an unexpected error occurs
C<code()> will return "421" (temporary connection failure) and
C<message()> will return undef.

=item Connection closed

If the underlying C<IO::Handle> is closed, or if there are
any read or write failures, the file handle will be forced closed,
and C<code()> will return "421" (temporary connection failure)
and C<message()> will return "[$pkg] Connection closed"
(where $pkg is the name of the class that subclassed C<Net::Cmd>).
The _set_status_closed() method can be overridden to set a different
message (by calling set_status()) or otherwise trap this error.

=item Timeout

If there is a read or write timeout C<code()> will return "421"
(temporary connection failure) and C<message()> will return
"[$pkg] Timeout" (where $pkg is the name of the class
that subclassed C<Net::Cmd>). The _set_status_timeout() method
can be overridden to set a different message (by calling set_status())
or otherwise trap this error.

=back

=head1 EXPORTS

C<Net::Cmd> exports six subroutines, five of these, C<CMD_INFO>, C<CMD_OK>,
C<CMD_MORE>, C<CMD_REJECT> and C<CMD_ERROR>, correspond to possible results
of C<response> and C<status>. The sixth is C<CMD_PENDING>.

=head1 AUTHOR

Graham Barr E<lt>F<gbarr@pobox.com>E<gt>

Steve Hay E<lt>F<shay@cpan.org>E<gt> is now maintaining libnet as of version
1.22_02

=head1 COPYRIGHT

Versions up to 2.29_1 Copyright (c) 1995-2006 Graham Barr. All rights reserved.
Changes in Version 2.29_2 onwards Copyright (C) 2013-2014 Steve Hay.  All rights
reserved.

This module is free software; you can redistribute it and/or modify it under the
same terms as Perl itself, i.e. under the terms of either the GNU General Public
License or the Artistic License, as specified in the F<LICENCE> file.

=cut
                # Net::Config.pm
#
# Versions up to 1.11 Copyright (c) 2000 Graham Barr <gbarr@pobox.com>.
# All rights reserved.
# Changes in Version 1.11_01 onwards Copyright (C) 2013-2014 Steve Hay.  All
# rights reserved.
# This module is free software; you can redistribute it and/or modify it under
# the same terms as Perl itself, i.e. under the terms of either the GNU General
# Public License or the Artistic License, as specified in the F<LICENCE> file.

package Net::Config;

use 5.008001;

use strict;
use warnings;

use Exporter;
use Socket qw(inet_aton inet_ntoa);

our @EXPORT  = qw(%NetConfig);
our @ISA     = qw(Net::LocalCfg Exporter);
our $VERSION = "3.08_01";

our($CONFIGURE, $LIBNET_CFG);

eval {
  local @INC = @INC;
  pop @INC if $INC[-1] eq '.';
  local $SIG{__DIE__};
  require Net::LocalCfg;
};

our %NetConfig = (
  nntp_hosts      => [],
  snpp_hosts      => [],
  pop3_hosts      => [],
  smtp_hosts      => [],
  ph_hosts        => [],
  daytime_hosts   => [],
  time_hosts      => [],
  inet_domain     => undef,
  ftp_firewall    => undef,
  ftp_ext_passive => 1,
  ftp_int_passive => 1,
  test_hosts      => 1,
  test_exist      => 1,
);

#
# Try to get as much configuration info as possible from InternetConfig
#
{
## no critic (BuiltinFunctions::ProhibitStringyEval)
$^O eq 'MacOS' and eval <<TRY_INTERNET_CONFIG;
use Mac::InternetConfig;

{
my %nc = (
    nntp_hosts      => [ \$InternetConfig{ kICNNTPHost() } ],
    pop3_hosts      => [ \$InternetConfig{ kICMailAccount() } =~ /\@(.*)/ ],
    smtp_hosts      => [ \$InternetConfig{ kICSMTPHost() } ],
    ftp_testhost    => \$InternetConfig{ kICFTPHost() } ? \$InternetConfig{ kICFTPHost()} : undef,
    ph_hosts        => [ \$InternetConfig{ kICPhHost() }   ],
    ftp_ext_passive => \$InternetConfig{"646F676F\xA5UsePassiveMode"} || 0,
    ftp_int_passive => \$InternetConfig{"646F676F\xA5UsePassiveMode"} || 0,
    socks_hosts     => 
        \$InternetConfig{ kICUseSocks() }    ? [ \$InternetConfig{ kICSocksHost() }    ] : [],
    ftp_firewall    => 
        \$InternetConfig{ kICUseFTPProxy() } ? [ \$InternetConfig{ kICFTPProxyHost() } ] : [],
);
\@NetConfig{keys %nc} = values %nc;
}
TRY_INTERNET_CONFIG
}

my $file = '/etc/perl/Net/libnet.cfg';
my $ref;
if (-f $file) {
  $ref = eval { local $SIG{__DIE__}; do $file };
  if (ref($ref) eq 'HASH') {
    %NetConfig = (%NetConfig, %{$ref});
    $LIBNET_CFG = $file;
  }
}
if ($< == $> and !$CONFIGURE) {
  my $home = eval { local $SIG{__DIE__}; (getpwuid($>))[7] } || $ENV{HOME};
  $home ||= $ENV{HOMEDRIVE} . ($ENV{HOMEPATH} || '') if defined $ENV{HOMEDRIVE};
  if (defined $home) {
    $file      = $home . "/.libnetrc";
    $ref       = eval { local $SIG{__DIE__}; do $file } if -f $file;
    %NetConfig = (%NetConfig, %{$ref})
      if ref($ref) eq 'HASH';
  }
}
my ($k, $v);
while (($k, $v) = each %NetConfig) {
  $NetConfig{$k} = [$v]
    if ($k =~ /_hosts$/ and $k ne "test_hosts" and defined($v) and !ref($v));
}

# Take a hostname and determine if it is inside the firewall


sub requires_firewall {
  shift;    # ignore package
  my $host = shift;

  return 0 unless defined $NetConfig{'ftp_firewall'};

  $host = inet_aton($host) or return -1;
  $host = inet_ntoa($host);

  if (exists $NetConfig{'local_netmask'}) {
    my $quad = unpack("N", pack("C*", split(/\./, $host)));
    my $list = $NetConfig{'local_netmask'};
    $list = [$list] unless ref($list);
    foreach (@$list) {
      my ($net, $bits) = (m#^(\d+\.\d+\.\d+\.\d+)/(\d+)$#) or next;
      my $mask = ~0 << (32 - $bits);
      my $addr = unpack("N", pack("C*", split(/\./, $net)));

      return 0 if (($addr & $mask) == ($quad & $mask));
    }
    return 1;
  }

  return 0;
}

*is_external = \&requires_firewall;

1;

__END__

=head1 NAME

Net::Config - Local configuration data for libnet

=head1 SYNOPSIS

    use Net::Config qw(%NetConfig);

=head1 DESCRIPTION

C<Net::Config> holds configuration data for the modules in the libnet
distribution. During installation you will be asked for these values.

The configuration data is held globally in C</etc/perl/Net/libnet.cfg>,
but a user may override any of these values by providing their own. This
can be done by having a C<.libnetrc> file in their home directory. This file
should return a reference to a HASH containing the keys described below.
For example

    # .libnetrc
    {
        nntp_hosts => [ "my_preferred_host" ],
        ph_hosts   => [ "my_ph_server" ],
    }
    __END__

=head1 METHODS

C<Net::Config> defines the following methods. They are methods as they are
invoked as class methods. This is because C<Net::Config> inherits from
C<Net::LocalCfg> so you can override these methods if you want.

=over 4

=item requires_firewall ( HOST )

Attempts to determine if a given host is outside your firewall. Possible
return values are.

  -1  Cannot lookup hostname
   0  Host is inside firewall (or there is no ftp_firewall entry)
   1  Host is outside the firewall

This is done by using hostname lookup and the C<local_netmask> entry in
the configuration data.

=back

=head1 NetConfig VALUES

=over 4

=item nntp_hosts

=item snpp_hosts

=item pop3_hosts

=item smtp_hosts

=item ph_hosts

=item daytime_hosts

=item time_hosts

Each is a reference to an array of hostnames (in order of preference),
which should be used for the given protocol

=item inet_domain

Your internet domain name

=item ftp_firewall

If you have an FTP proxy firewall (B<NOT> an HTTP or SOCKS firewall)
then this value should be set to the firewall hostname. If your firewall
does not listen to port 21, then this value should be set to
C<"hostname:port"> (eg C<"hostname:99">)

=item ftp_firewall_type

There are many different ftp firewall products available. But unfortunately
there is no standard for how to traverse a firewall.  The list below shows the
sequence of commands that Net::FTP will use

  user        Username for remote host
  pass        Password for remote host
  fwuser      Username for firewall
  fwpass      Password for firewall
  remote.host The hostname of the remote ftp server

=over 4

=item 0Z<>

There is no firewall

=item 1Z<>

     USER user@remote.host
     PASS pass

=item 2Z<>

     USER fwuser
     PASS fwpass
     USER user@remote.host
     PASS pass

=item 3Z<>

     USER fwuser
     PASS fwpass
     SITE remote.site
     USER user
     PASS pass

=item 4Z<>

     USER fwuser
     PASS fwpass
     OPEN remote.site
     USER user
     PASS pass

=item 5Z<>

     USER user@fwuser@remote.site
     PASS pass@fwpass

=item 6Z<>

     USER fwuser@remote.site
     PASS fwpass
     USER user
     PASS pass

=item 7Z<>

     USER user@remote.host
     PASS pass
     AUTH fwuser
     RESP fwpass

=back

=item ftp_ext_passive

=item ftp_int_passive

FTP servers can work in passive or active mode. Active mode is when
you want to transfer data you have to tell the server the address and
port to connect to.  Passive mode is when the server provide the
address and port and you establish the connection.

With some firewalls active mode does not work as the server cannot
connect to your machine (because you are behind a firewall) and the firewall
does not re-write the command. In this case you should set C<ftp_ext_passive>
to a I<true> value.

Some servers are configured to only work in passive mode. If you have
one of these you can force C<Net::FTP> to always transfer in passive
mode; when not going via a firewall, by setting C<ftp_int_passive> to
a I<true> value.

=item local_netmask

A reference to a list of netmask strings in the form C<"134.99.4.0/24">.
These are used by the C<requires_firewall> function to determine if a given
host is inside or outside your firewall.

=back

The following entries are used during installation & testing on the
libnet package

=over 4

=item test_hosts

If true then C<make test> may attempt to connect to hosts given in the
configuration.

=item test_exists

If true then C<Configure> will check each hostname given that it exists

=back

=head1 AUTHOR

Graham Barr E<lt>F<gbarr@pobox.com>E<gt>

Steve Hay E<lt>F<shay@cpan.org>E<gt> is now maintaining libnet as of version
1.22_02

=head1 COPYRIGHT

Versions up to 1.11 Copyright (c) 1998-2011 Graham Barr. All rights reserved.
Changes in Version 1.11_01 onwards Copyright (C) 2013-2014 Steve Hay.  All
rights reserved.

This module is free software; you can redistribute it and/or modify it under the
same terms as Perl itself, i.e. under the terms of either the GNU General Public
License or the Artistic License, as specified in the F<LICENCE> file.

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           # Net::Domain.pm
#
# Versions up to 2.21 Copyright (c) 1995-1998 Graham Barr <gbarr@pobox.com>.
# All rights reserved.
# Changes in Version 2.22 onwards Copyright (C) 2013-2014 Steve Hay.  All rights
# reserved.
# This module is free software; you can redistribute it and/or modify it under
# the same terms as Perl itself, i.e. under the terms of either the GNU General
# Public License or the Artistic License, as specified in the F<LICENCE> file.

package Net::Domain;

use 5.008001;

use strict;
use warnings;

use Carp;
use Exporter;
use Net::Config;

our @ISA       = qw(Exporter);
our @EXPORT_OK = qw(hostname hostdomain hostfqdn domainname);
our $VERSION = "3.08_01";

my ($host, $domain, $fqdn) = (undef, undef, undef);

# Try every conceivable way to get hostname.


sub _hostname {

  # we already know it
  return $host
    if (defined $host);

  if ($^O eq 'MSWin32') {
    require Socket;
    my ($name, $alias, $type, $len, @addr) = gethostbyname($ENV{'COMPUTERNAME'} || 'localhost');
    while (@addr) {
      my $a = shift(@addr);
      $host = gethostbyaddr($a, Socket::AF_INET());
      last if defined $host;
    }
    if (defined($host) && index($host, '.') > 0) {
      $fqdn = $host;
      ($host, $domain) = $fqdn =~ /^([^.]+)\.(.*)$/;
    }
    return $host;
  }
  elsif ($^O eq 'MacOS') {
    chomp($host = `hostname`);
  }
  elsif ($^O eq 'VMS') {    ## multiple varieties of net s/w makes this hard
    $host = $ENV{'UCX$INET_HOST'}      if defined($ENV{'UCX$INET_HOST'});
    $host = $ENV{'MULTINET_HOST_NAME'} if defined($ENV{'MULTINET_HOST_NAME'});
    if (index($host, '.') > 0) {
      $fqdn = $host;
      ($host, $domain) = $fqdn =~ /^([^.]+)\.(.*)$/;
    }
    return $host;
  }
  else {
    local $SIG{'__DIE__'};

    # syscall is preferred since it avoids tainting problems
    eval {
      my $tmp = "\0" x 256;    ## preload scalar
      eval {
        package main;
        require "syscall.ph"; ## no critic (Modules::RequireBarewordIncludes)
        defined(&main::SYS_gethostname);
        }
        || eval {
        package main;
        require "sys/syscall.ph"; ## no critic (Modules::RequireBarewordIncludes)
        defined(&main::SYS_gethostname);
        }
        and $host =
        (syscall(&main::SYS_gethostname, $tmp, 256) == 0)
        ? $tmp
        : undef;
      }

      # POSIX
      || eval {
      require POSIX;
      $host = (POSIX::uname())[1];
      }

      # trusty old hostname command
      || eval {
      chop($host = `(hostname) 2>/dev/null`);    # BSD'ish
      }

      # sysV/POSIX uname command (may truncate)
      || eval {
      chop($host = `uname -n 2>/dev/null`);      ## SYSV'ish && POSIX'ish
      }

      # Apollo pre-SR10
      || eval { $host = (split(/[:. ]/, `/com/host`, 6))[0]; }

      || eval { $host = ""; };
  }

  # remove garbage
  $host =~ s/[\0\r\n]+//go;
  $host =~ s/(\A\.+|\.+\Z)//go;
  $host =~ s/\.\.+/\./go;

  $host;
}


sub _hostdomain {

  # we already know it
  return $domain
    if (defined $domain);

  local $SIG{'__DIE__'};

  return $domain = $NetConfig{'inet_domain'}
    if defined $NetConfig{'inet_domain'};

  # try looking in /etc/resolv.conf
  # putting this here and assuming that it is correct, eliminates
  # calls to gethostbyname, and therefore DNS lookups. This helps
  # those on dialup systems.

  local ($_);

  if (open(my $res, '<', "/etc/resolv.conf")) {
    while (<$res>) {
      $domain = $1
        if (/\A\s*(?:domain|search)\s+(\S+)/);
    }
    close($res);

    return $domain
      if (defined $domain);
  }

  # just try hostname and system calls

  my $host = _hostname();
  my (@hosts);

  @hosts = ($host, "localhost");

  unless (defined($host) && $host =~ /\./) {
    my $dom = undef;
    eval {
      my $tmp = "\0" x 256;    ## preload scalar
      eval {
        package main;
        require "syscall.ph"; ## no critic (Modules::RequireBarewordIncludes)
        }
        || eval {
        package main;
        require "sys/syscall.ph"; ## no critic (Modules::RequireBarewordIncludes)
        }
        and $dom =
        (syscall(&main::SYS_getdomainname, $tmp, 256) == 0)
        ? $tmp
        : undef;
    };

    if ($^O eq 'VMS') {
      $dom ||= $ENV{'TCPIP$INET_DOMAIN'}
        || $ENV{'UCX$INET_DOMAIN'};
    }

    chop($dom = `domainname 2>/dev/null`)
      unless (defined $dom || $^O =~ /^(?:cygwin|MSWin32|android)/);

    if (defined $dom) {
      my @h = ();
      $dom =~ s/^\.+//;
      while (length($dom)) {
        push(@h, "$host.$dom");
        $dom =~ s/^[^.]+.+// or last;
      }
      unshift(@hosts, @h);
    }
  }

  # Attempt to locate FQDN

  foreach (grep { defined $_ } @hosts) {
    my @info = gethostbyname($_);

    next unless @info;

    # look at real name & aliases
    foreach my $site ($info[0], split(/ /, $info[1])) {
      if (rindex($site, ".") > 0) {

        # Extract domain from FQDN

        ($domain = $site) =~ s/\A[^.]+\.//;
        return $domain;
      }
    }
  }

  # Look for environment variable

  $domain ||= $ENV{LOCALDOMAIN} || $ENV{DOMAIN};

  if (defined $domain) {
    $domain =~ s/[\r\n\0]+//g;
    $domain =~ s/(\A\.+|\.+\Z)//g;
    $domain =~ s/\.\.+/\./g;
  }

  $domain;
}


sub domainname {

  return $fqdn
    if (defined $fqdn);

  _hostname();

  # *.local names are special on darwin. If we call gethostbyname below, it
  # may hang while waiting for another, non-existent computer to respond.
  if($^O eq 'darwin' && $host =~ /\.local$/) {
    return $host;
  }

  _hostdomain();

  # Assumption: If the host name does not contain a period
  # and the domain name does, then assume that they are correct
  # this helps to eliminate calls to gethostbyname, and therefore
  # eliminate DNS lookups

  return $fqdn = $host . "." . $domain
    if (defined $host
    and defined $domain
    and $host !~ /\./
    and $domain =~ /\./);

  # For hosts that have no name, just an IP address
  return $fqdn = $host if defined $host and $host =~ /^\d+(\.\d+){3}$/;

  my @host   = defined $host   ? split(/\./, $host)   : ('localhost');
  my @domain = defined $domain ? split(/\./, $domain) : ();
  my @fqdn   = ();

  # Determine from @host & @domain the FQDN

  my @d = @domain;

LOOP:
  while (1) {
    my @h = @host;
    while (@h) {
      my $tmp = join(".", @h, @d);
      if ((gethostbyname($tmp))[0]) {
        @fqdn = (@h, @d);
        $fqdn = $tmp;
        last LOOP;
      }
      pop @h;
    }
    last unless shift @d;
  }

  if (@fqdn) {
    $host = shift @fqdn;
    until ((gethostbyname($host))[0]) {
      $host .= "." . shift @fqdn;
    }
    $domain = join(".", @fqdn);
  }
  else {
    undef $host;
    undef $domain;
    undef $fqdn;
  }

  $fqdn;
}


sub hostfqdn { domainname() }


sub hostname {
  domainname()
    unless (defined $host);
  return $host;
}


sub hostdomain {
  domainname()
    unless (defined $domain);
  return $domain;
}

1;    # Keep require happy

__END__

=head1 NAME

Net::Domain - Attempt to evaluate the current host's internet name and domain

=head1 SYNOPSIS

    use Net::Domain qw(hostname hostfqdn hostdomain domainname);

=head1 DESCRIPTION

Using various methods B<attempt> to find the Fully Qualified Domain Name (FQDN)
of the current host. From this determine the host-name and the host-domain.

Each of the functions will return I<undef> if the FQDN cannot be determined.

=over 4

=item hostfqdn ()

Identify and return the FQDN of the current host.

=item domainname ()

An alias for hostfqdn ().

=item hostname ()

Returns the smallest part of the FQDN which can be used to identify the host.

=item hostdomain ()

Returns the remainder of the FQDN after the I<hostname> has been removed.

=back

=head1 AUTHOR

Graham Barr E<lt>F<gbarr@pobox.com>E<gt>.
Adapted from Sys::Hostname by David Sundstrom E<lt>F<sunds@asictest.sc.ti.com>E<gt>

Steve Hay E<lt>F<shay@cpan.org>E<gt> is now maintaining libnet as of version
1.22_02

=head1 COPYRIGHT

Versions up to 2.21 Copyright (c) 1995-1998 Graham Barr. All rights reserved.
Changes in Version 2.22 onwards Copyright (C) 2013-2014 Steve Hay.  All rights
reserved.

This module is free software; you can redistribute it and/or modify it under the
same terms as Perl itself, i.e. under the terms of either the GNU General Public
License or the Artistic License, as specified in the F<LICENCE> file.

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          # Net::FTP.pm
#
# Versions up to 2.77_2 Copyright (c) 1995-2004 Graham Barr <gbarr@pobox.com>.
# All rights reserved.
# Changes in Version 2.77_3 onwards Copyright (C) 2013-2015 Steve Hay.  All
# rights reserved.
# This module is free software; you can redistribute it and/or modify it under
# the same terms as Perl itself, i.e. under the terms of either the GNU General
# Public License or the Artistic License, as specified in the F<LICENCE> file.
#
# Documentation (at end) improved 1996 by Nathan Torkington <gnat@frii.com>.

package Net::FTP;

use 5.008001;

use strict;
use warnings;

use Carp;
use Fcntl qw(O_WRONLY O_RDONLY O_APPEND O_CREAT O_TRUNC);
use IO::Socket;
use Net::Cmd;
use Net::Config;
use Socket;
use Time::Local;

our $VERSION = '3.08_01';

our $IOCLASS;
my $family_key;
BEGIN {
  # Code for detecting if we can use SSL
  my $ssl_class = eval {
    require IO::Socket::SSL;
    # first version with default CA on most platforms
    no warnings 'numeric';
    IO::Socket::SSL->VERSION(2.007);
  } && 'IO::Socket::SSL';

  my $nossl_warn = !$ssl_class &&
    'To use SSL please install IO::Socket::SSL with version>=2.007';

  # Code for detecting if we can use IPv6
  my $inet6_class = eval {
    require IO::Socket::IP;
    no warnings 'numeric';
    IO::Socket::IP->VERSION(0.20);
  } && 'IO::Socket::IP' || eval {
    require IO::Socket::INET6;
    no warnings 'numeric';
    IO::Socket::INET6->VERSION(2.62);
  } && 'IO::Socket::INET6';

  sub can_ssl   { $ssl_class };
  sub can_inet6 { $inet6_class };

  $IOCLASS = $ssl_class || $inet6_class || 'IO::Socket::INET';
  $family_key =
    ( $ssl_class ? $ssl_class->can_ipv6 : $inet6_class || '' )
      eq 'IO::Socket::IP'
      ? 'Family' : 'Domain';
}

our @ISA = ('Exporter','Net::Cmd',$IOCLASS);

use constant TELNET_IAC => 255;
use constant TELNET_IP  => 244;
use constant TELNET_DM  => 242;

use constant EBCDIC => $^O eq 'os390';

sub new {
  my $pkg = shift;
  my ($peer, %arg);
  if (@_ % 2) {
    $peer = shift;
    %arg  = @_;
  }
  else {
    %arg  = @_;
    $peer = delete $arg{Host};
  }

  my $host      = $peer;
  my $fire      = undef;
  my $fire_type = undef;

  if (exists($arg{Firewall}) || Net::Config->requires_firewall($peer)) {
         $fire = $arg{Firewall}
      || $ENV{FTP_FIREWALL}
      || $NetConfig{ftp_firewall}
      || undef;

    if (defined $fire) {
      $peer = $fire;
      delete $arg{Port};
           $fire_type = $arg{FirewallType}
        || $ENV{FTP_FIREWALL_TYPE}
        || $NetConfig{firewall_type}
        || undef;
    }
  }

  my %tlsargs;
  if (can_ssl()) {
    # for name verification strip port from domain:port, ipv4:port, [ipv6]:port
    (my $hostname = $host) =~s{(?<!:):\d+$}{};
    %tlsargs = (
      SSL_verifycn_scheme => 'ftp',
      SSL_verifycn_name => $hostname,
      # use SNI if supported by IO::Socket::SSL
      $pkg->can_client_sni ? (SSL_hostname => $hostname):(),
      # reuse SSL session of control connection in data connections
      SSL_session_cache => Net::FTP::_SSL_SingleSessionCache->new,
    );
    # user defined SSL arg
    $tlsargs{$_} = $arg{$_} for(grep { m{^SSL_} } keys %arg);

  } elsif ($arg{SSL}) {
    croak("IO::Socket::SSL >= 2.007 needed for SSL support");
  }

  my $ftp = $pkg->SUPER::new(
    PeerAddr  => $peer,
    PeerPort  => $arg{Port} || ($arg{SSL} ? 'ftps(990)' : 'ftp(21)'),
    LocalAddr => $arg{'LocalAddr'},
    $family_key => $arg{Domain} || $arg{Family},
    Proto     => 'tcp',
    Timeout   => defined $arg{Timeout} ? $arg{Timeout} : 120,
    %tlsargs,
    $arg{SSL} ? ():( SSL_startHandshake => 0 ),
  ) or return;

  ${*$ftp}{'net_ftp_host'}    = $host;                             # Remote hostname
  ${*$ftp}{'net_ftp_type'}    = 'A';                               # ASCII/binary/etc mode
  ${*$ftp}{'net_ftp_blksize'} = abs($arg{'BlockSize'} || 10240);

  ${*$ftp}{'net_ftp_localaddr'} = $arg{'LocalAddr'};
  ${*$ftp}{'net_ftp_domain'} = $arg{Domain} || $arg{Family};

  ${*$ftp}{'net_ftp_firewall'} = $fire
    if (defined $fire);
  ${*$ftp}{'net_ftp_firewall_type'} = $fire_type
    if (defined $fire_type);

  ${*$ftp}{'net_ftp_passive'} =
      int exists $arg{Passive} ? $arg{Passive}
    : exists $ENV{FTP_PASSIVE} ? $ENV{FTP_PASSIVE}
    : defined $fire            ? $NetConfig{ftp_ext_passive}
    : $NetConfig{ftp_int_passive};    # Whew! :-)

  ${*$ftp}{net_ftp_tlsargs} = \%tlsargs if %tlsargs;
  if ($arg{SSL}) {
    ${*$ftp}{net_ftp_tlsprot} = 'P';
    ${*$ftp}{net_ftp_tlsdirect} = 1;
  }

  $ftp->hash(exists $arg{Hash} ? $arg{Hash} : 0, 1024);

  $ftp->autoflush(1);

  $ftp->debug(exists $arg{Debug} ? $arg{Debug} : undef);

  unless ($ftp->response() == CMD_OK) {
    $ftp->close();
    # keep @$ if no message. Happens, when response did not start with a code.
    $@ = $ftp->message || $@;
    undef $ftp;
  }

  $ftp;
}

##
## User interface methods
##


sub host {
  my $me = shift;
  ${*$me}{'net_ftp_host'};
}

sub passive {
  my $ftp = shift;
  return ${*$ftp}{'net_ftp_passive'} unless @_;
  ${*$ftp}{'net_ftp_passive'} = shift;
}


sub hash {
  my $ftp = shift;    # self

  my ($h, $b) = @_;
  unless ($h) {
    delete ${*$ftp}{'net_ftp_hash'};
    return [\*STDERR, 0];
  }
  ($h, $b) = (ref($h) ? $h : \*STDERR, $b || 1024);
  select((select($h), $| = 1)[0]);
  $b = 512 if $b < 512;
  ${*$ftp}{'net_ftp_hash'} = [$h, $b];
}


sub quit {
  my $ftp = shift;

  $ftp->_QUIT;
  $ftp->close;
}


sub DESTROY { }


sub ascii  { shift->type('A', @_); }
sub binary { shift->type('I', @_); }


sub ebcdic {
  carp "TYPE E is unsupported, shall default to I";
  shift->type('E', @_);
}


sub byte {
  carp "TYPE L is unsupported, shall default to I";
  shift->type('L', @_);
}

# Allow the user to send a command directly, BE CAREFUL !!


sub quot {
  my $ftp = shift;
  my $cmd = shift;

  $ftp->command(uc $cmd, @_);
  $ftp->response();
}


sub site {
  my $ftp = shift;

  $ftp->command("SITE", @_);
  $ftp->response();
}


sub mdtm {
  my $ftp  = shift;
  my $file = shift;

  # Server Y2K bug workaround
  #
  # sigh; some idiotic FTP servers use ("19%d",tm.tm_year) instead of
  # ("%d",tm.tm_year+1900).  This results in an extra digit in the
  # string returned. To account for this we allow an optional extra
  # digit in the year. Then if the first two digits are 19 we use the
  # remainder, otherwise we subtract 1900 from the whole year.

  $ftp->_MDTM($file)
    && $ftp->message =~ /((\d\d)(\d\d\d?))(\d\d)(\d\d)(\d\d)(\d\d)(\d\d)/
    ? timegm($8, $7, $6, $5, $4 - 1, $2 eq '19' ? $3 : ($1 - 1900))
    : undef;
}


sub size {
  my $ftp  = shift;
  my $file = shift;
  my $io;
  if ($ftp->supported("SIZE")) {
    return $ftp->_SIZE($file)
      ? ($ftp->message =~ /(\d+)\s*(bytes?\s*)?$/)[0]
      : undef;
  }
  elsif ($ftp->supported("STAT")) {
    my @msg;
    return
      unless $ftp->_STAT($file) && (@msg = $ftp->message) == 3;
    foreach my $line (@msg) {
      return (split(/\s+/, $line))[4]
        if $line =~ /^[-rwxSsTt]{10}/;
    }
  }
  else {
    my @files = $ftp->dir($file);
    if (@files) {
      return (split(/\s+/, $1))[4]
        if $files[0] =~ /^([-rwxSsTt]{10}.*)$/;
    }
  }
  undef;
}


sub starttls {
  my $ftp = shift;
  can_ssl() or croak("IO::Socket::SSL >= 2.007 needed for SSL support");
  $ftp->is_SSL and croak("called starttls within SSL session");
  $ftp->_AUTH('TLS') == CMD_OK or return;

  $ftp->connect_SSL or return;
  $ftp->prot('P');
  return 1;
}

sub prot {
  my ($ftp,$prot) = @_;
  $prot eq 'C' or $prot eq 'P' or croak("prot must by C or P");
  $ftp->_PBSZ(0) or return;
  $ftp->_PROT($prot) or return;
  ${*$ftp}{net_ftp_tlsprot} = $prot;
  return 1;
}

sub stoptls {
  my $ftp = shift;
  $ftp->is_SSL or croak("called stoptls outside SSL session");
  ${*$ftp}{net_ftp_tlsdirect} and croak("cannot stoptls direct SSL session");
  $ftp->_CCC() or return;
  $ftp->stop_SSL();
  return 1;
}

sub login {
  my ($ftp, $user, $pass, $acct) = @_;
  my ($ok, $ruser, $fwtype);

  unless (defined $user) {
    require Net::Netrc;

    my $rc = Net::Netrc->lookup(${*$ftp}{'net_ftp_host'});

    ($user, $pass, $acct) = $rc->lpa()
      if ($rc);
  }

  $user ||= "anonymous";
  $ruser = $user;

  $fwtype = ${*$ftp}{'net_ftp_firewall_type'}
    || $NetConfig{'ftp_firewall_type'}
    || 0;

  if ($fwtype && defined ${*$ftp}{'net_ftp_firewall'}) {
    if ($fwtype == 1 || $fwtype == 7) {
      $user .= '@' . ${*$ftp}{'net_ftp_host'};
    }
    else {
      require Net::Netrc;

      my $rc = Net::Netrc->lookup(${*$ftp}{'net_ftp_firewall'});

      my ($fwuser, $fwpass, $fwacct) = $rc ? $rc->lpa() : ();

      if ($fwtype == 5) {
        $user = join('@', $user, $fwuser, ${*$ftp}{'net_ftp_host'});
        $pass = $pass . '@' . $fwpass;
      }
      else {
        if ($fwtype == 2) {
          $user .= '@' . ${*$ftp}{'net_ftp_host'};
        }
        elsif ($fwtype == 6) {
          $fwuser .= '@' . ${*$ftp}{'net_ftp_host'};
        }

        $ok = $ftp->_USER($fwuser);

        return 0 unless $ok == CMD_OK || $ok == CMD_MORE;

        $ok = $ftp->_PASS($fwpass || "");

        return 0 unless $ok == CMD_OK || $ok == CMD_MORE;

        $ok = $ftp->_ACCT($fwacct)
          if defined($fwacct);

        if ($fwtype == 3) {
          $ok = $ftp->command("SITE", ${*$ftp}{'net_ftp_host'})->response;
        }
        elsif ($fwtype == 4) {
          $ok = $ftp->command("OPEN", ${*$ftp}{'net_ftp_host'})->response;
        }

        return 0 unless $ok == CMD_OK || $ok == CMD_MORE;
      }
    }
  }

  $ok = $ftp->_USER($user);

  # Some dumb firewalls don't prefix the connection messages
  $ok = $ftp->response()
    if ($ok == CMD_OK && $ftp->code == 220 && $user =~ /\@/);

  if ($ok == CMD_MORE) {
    unless (defined $pass) {
      require Net::Netrc;

      my $rc = Net::Netrc->lookup(${*$ftp}{'net_ftp_host'}, $ruser);

      ($ruser, $pass, $acct) = $rc->lpa()
        if ($rc);

      $pass = '-anonymous@'
        if (!defined $pass && (!defined($ruser) || $ruser =~ /^anonymous/o));
    }

    $ok = $ftp->_PASS($pass || "");
  }

  $ok = $ftp->_ACCT($acct)
    if (defined($acct) && ($ok == CMD_MORE || $ok == CMD_OK));

  if ($fwtype == 7 && $ok == CMD_OK && defined ${*$ftp}{'net_ftp_firewall'}) {
    my ($f, $auth, $resp) = _auth_id($ftp);
    $ftp->authorize($auth, $resp) if defined($resp);
  }

  $ok == CMD_OK;
}


sub account {
  @_ == 2 or croak 'usage: $ftp->account( ACCT )';
  my $ftp  = shift;
  my $acct = shift;
  $ftp->_ACCT($acct) == CMD_OK;
}


sub _auth_id {
  my ($ftp, $auth, $resp) = @_;

  unless (defined $resp) {
    require Net::Netrc;

    $auth ||= eval { (getpwuid($>))[0] } || $ENV{NAME};

    my $rc = Net::Netrc->lookup(${*$ftp}{'net_ftp_firewall'}, $auth)
      || Net::Netrc->lookup(${*$ftp}{'net_ftp_firewall'});

    ($auth, $resp) = $rc->lpa()
      if ($rc);
  }
  ($ftp, $auth, $resp);
}


sub authorize {
  @_ >= 1 || @_ <= 3 or croak 'usage: $ftp->authorize( [AUTH [, RESP]])';

  my ($ftp, $auth, $resp) = &_auth_id;

  my $ok = $ftp->_AUTH($auth || "");

  return $ftp->_RESP($resp || "")
    if ($ok == CMD_MORE);

  $ok == CMD_OK;
}


sub rename {
  @_ == 3 or croak 'usage: $ftp->rename(FROM, TO)';

  my ($ftp, $from, $to) = @_;

  $ftp->_RNFR($from)
    && $ftp->_RNTO($to);
}


sub type {
  my $ftp    = shift;
  my $type   = shift;
  my $oldval = ${*$ftp}{'net_ftp_type'};

  return $oldval
    unless (defined $type);

  return
    unless ($ftp->_TYPE($type, @_));

  ${*$ftp}{'net_ftp_type'} = join(" ", $type, @_);

  $oldval;
}


sub alloc {
  my $ftp    = shift;
  my $size   = shift;
  my $oldval = ${*$ftp}{'net_ftp_allo'};

  return $oldval
    unless (defined $size);

  return
    unless ($ftp->supported("ALLO") and $ftp->_ALLO($size, @_));

  ${*$ftp}{'net_ftp_allo'} = join(" ", $size, @_);

  $oldval;
}


sub abort {
  my $ftp = shift;

  send($ftp, pack("CCC", TELNET_IAC, TELNET_IP, TELNET_IAC), MSG_OOB);

  $ftp->command(pack("C", TELNET_DM) . "ABOR");

  ${*$ftp}{'net_ftp_dataconn'}->close()
    if defined ${*$ftp}{'net_ftp_dataconn'};

  $ftp->response();

  $ftp->status == CMD_OK;
}


sub get {
  my ($ftp, $remote, $local, $where) = @_;

  my ($loc, $len, $buf, $resp, $data);
  local *FD;

  my $localfd = ref($local) || ref(\$local) eq "GLOB";

  ($local = $remote) =~ s#^.*/##
    unless (defined $local);

  croak("Bad remote filename '$remote'\n")
    if $remote =~ /[\r\n]/s;

  ${*$ftp}{'net_ftp_rest'} = $where if defined $where;
  my $rest = ${*$ftp}{'net_ftp_rest'};

  delete ${*$ftp}{'net_ftp_port'};
  delete ${*$ftp}{'net_ftp_pasv'};

  $data = $ftp->retr($remote)
    or return;

  if ($localfd) {
    $loc = $local;
  }
  else {
    $loc = \*FD;

    unless (sysopen($loc, $local, O_CREAT | O_WRONLY | ($rest ? O_APPEND: O_TRUNC))) {
      carp "Cannot open Local file $local: $!\n";
      $data->abort;
      return;
    }
  }

  if ($ftp->type eq 'I' && !binmode($loc)) {
    carp "Cannot binmode Local file $local: $!\n";
    $data->abort;
    close($loc) unless $localfd;
    return;
  }

  $buf = '';
  my ($count, $hashh, $hashb, $ref) = (0);

  ($hashh, $hashb) = @$ref
    if ($ref = ${*$ftp}{'net_ftp_hash'});

  my $blksize = ${*$ftp}{'net_ftp_blksize'};
  local $\;    # Just in case

  while (1) {
    last unless $len = $data->read($buf, $blksize);

    if (EBCDIC && $ftp->type ne 'I') {
      $buf = $ftp->toebcdic($buf);
      $len = length($buf);
    }

    if ($hashh) {
      $count += $len;
      print $hashh "#" x (int($count / $hashb));
      $count %= $hashb;
    }
    unless (print $loc $buf) {
      carp "Cannot write to Local file $local: $!\n";
      $data->abort;
      close($loc)
        unless $localfd;
      return;
    }
  }

  print $hashh "\n" if $hashh;

  unless ($localfd) {
    unless (close($loc)) {
      carp "Cannot close file $local (perhaps disk space) $!\n";
      return;
    }
  }

  unless ($data->close())    # implied $ftp->response
  {
    carp "Unable to close datastream";
    return;
  }

  return $local;
}


sub cwd {
  @_ == 1 || @_ == 2 or croak 'usage: $ftp->cwd( [ DIR ] )';

  my ($ftp, $dir) = @_;

  $dir = "/" unless defined($dir) && $dir =~ /\S/;

  $dir eq ".."
    ? $ftp->_CDUP()
    : $ftp->_CWD($dir);
}


sub cdup {
  @_ == 1 or croak 'usage: $ftp->cdup()';
  $_[0]->_CDUP;
}


sub pwd {
  @_ == 1 || croak 'usage: $ftp->pwd()';
  my $ftp = shift;

  $ftp->_PWD();
  $ftp->_extract_path;
}

# rmdir( $ftp, $dir, [ $recurse ] )
#
# Removes $dir on remote host via FTP.
# $ftp is handle for remote host
#
# If $recurse is TRUE, the directory and deleted recursively.
# This means all of its contents and subdirectories.
#
# Initial version contributed by Dinkum Software
#
sub rmdir {
  @_ == 2 || @_ == 3 or croak('usage: $ftp->rmdir( DIR [, RECURSE ] )');

  # Pick off the args
  my ($ftp, $dir, $recurse) = @_;
  my $ok;

  return $ok
    if $ok = $ftp->_RMD($dir)
    or !$recurse;

  # Try to delete the contents
  # Get a list of all the files in the directory, excluding the current and parent directories
  my @filelist = map { /^(?:\S+;)+ (.+)$/ ? ($1) : () } grep { !/^(?:\S+;)*type=[cp]dir;/ } $ftp->_list_cmd("MLSD", $dir);

  # Fallback to using the less well-defined NLST command if MLSD fails
  @filelist = grep { !/^\.{1,2}$/ } $ftp->ls($dir)
    unless @filelist;

  return
    unless @filelist;    # failed, it is probably not a directory

  return $ftp->delete($dir)
    if @filelist == 1 and $dir eq $filelist[0];

  # Go thru and delete each file or the directory
  foreach my $file (map { m,/, ? $_ : "$dir/$_" } @filelist) {
    next                 # successfully deleted the file
      if $ftp->delete($file);

    # Failed to delete it, assume its a directory
    # Recurse and ignore errors, the final rmdir() will
    # fail on any errors here
    return $ok
      unless $ok = $ftp->rmdir($file, 1);
  }

  # Directory should be empty
  # Try to remove the directory again
  # Pass results directly to caller
  # If any of the prior deletes failed, this
  # rmdir() will fail because directory is not empty
  return $ftp->_RMD($dir);
}


sub restart {
  @_ == 2 || croak 'usage: $ftp->restart( BYTE_OFFSET )';

  my ($ftp, $where) = @_;

  ${*$ftp}{'net_ftp_rest'} = $where;

  return;
}


sub mkdir {
  @_ == 2 || @_ == 3 or croak 'usage: $ftp->mkdir( DIR [, RECURSE ] )';

  my ($ftp, $dir, $recurse) = @_;

  $ftp->_MKD($dir) || $recurse
    or return;

  my $path = $dir;

  unless ($ftp->ok) {
    my @path = split(m#(?=/+)#, $dir);

    $path = "";

    while (@path) {
      $path .= shift @path;

      $ftp->_MKD($path);

      $path = $ftp->_extract_path($path);
    }

    # If the creation of the last element was not successful, see if we
    # can cd to it, if so then return path

    unless ($ftp->ok) {
      my ($status, $message) = ($ftp->status, $ftp->message);
      my $pwd = $ftp->pwd;

      if ($pwd && $ftp->cwd($dir)) {
        $path = $dir;
        $ftp->cwd($pwd);
      }
      else {
        undef $path;
      }
      $ftp->set_status($status, $message);
    }
  }

  $path;
}


sub delete {
  @_ == 2 || croak 'usage: $ftp->delete( FILENAME )';

  $_[0]->_DELE($_[1]);
}


sub put        { shift->_store_cmd("stor", @_) }
sub put_unique { shift->_store_cmd("stou", @_) }
sub append     { shift->_store_cmd("appe", @_) }


sub nlst { shift->_data_cmd("NLST", @_) }
sub list { shift->_data_cmd("LIST", @_) }
sub retr { shift->_data_cmd("RETR", @_) }
sub stor { shift->_data_cmd("STOR", @_) }
sub stou { shift->_data_cmd("STOU", @_) }
sub appe { shift->_data_cmd("APPE", @_) }


sub _store_cmd {
  my ($ftp, $cmd, $local, $remote) = @_;
  my ($loc, $sock, $len, $buf);
  local *FD;

  my $localfd = ref($local) || ref(\$local) eq "GLOB";

  if (!defined($remote) and 'STOU' ne uc($cmd)) {
    croak 'Must specify remote filename with stream input'
      if $localfd;

    require File::Basename;
    $remote = File::Basename::basename($local);
  }
  if (defined ${*$ftp}{'net_ftp_allo'}) {
    delete ${*$ftp}{'net_ftp_allo'};
  }
  else {

    # if the user hasn't already invoked the alloc method since the last
    # _store_cmd call, figure out if the local file is a regular file(not
    # a pipe, or device) and if so get the file size from stat, and send
    # an ALLO command before sending the STOR, STOU, or APPE command.
    my $size = do { local $^W; -f $local && -s _ };    # no ALLO if sending data from a pipe
    ${*$ftp}{'net_ftp_allo'} = $size if $size;
  }
  croak("Bad remote filename '$remote'\n")
    if defined($remote) and $remote =~ /[\r\n]/s;

  if ($localfd) {
    $loc = $local;
  }
  else {
    $loc = \*FD;

    unless (sysopen($loc, $local, O_RDONLY)) {
      carp "Cannot open Local file $local: $!\n";
      return;
    }
  }

  if ($ftp->type eq 'I' && !binmode($loc)) {
    carp "Cannot binmode Local file $local: $!\n";
    return;
  }

  delete ${*$ftp}{'net_ftp_port'};
  delete ${*$ftp}{'net_ftp_pasv'};

  $sock = $ftp->_data_cmd($cmd, grep { defined } $remote)
    or return;

  $remote = ($ftp->message =~ /\w+\s*:\s*(.*)/)[0]
    if 'STOU' eq uc $cmd;

  my $blksize = ${*$ftp}{'net_ftp_blksize'};

  my ($count, $hashh, $hashb, $ref) = (0);

  ($hashh, $hashb) = @$ref
    if ($ref = ${*$ftp}{'net_ftp_hash'});

  while (1) {
    last unless $len = read($loc, $buf = "", $blksize);

    if (EBCDIC && $ftp->type ne 'I') {
      $buf = $ftp->toascii($buf);
      $len = length($buf);
    }

    if ($hashh) {
      $count += $len;
      print $hashh "#" x (int($count / $hashb));
      $count %= $hashb;
    }

    my $wlen;
    unless (defined($wlen = $sock->write($buf, $len)) && $wlen == $len) {
      $sock->abort;
      close($loc)
        unless $localfd;
      print $hashh "\n" if $hashh;
      return;
    }
  }

  print $hashh "\n" if $hashh;

  close($loc)
    unless $localfd;

  $sock->close()
    or return;

  if ('STOU' eq uc $cmd and $ftp->message =~ m/unique\s+file\s*name\s*:\s*(.*)\)|"(.*)"/) {
    require File::Basename;
    $remote = File::Basename::basename($+);
  }

  return $remote;
}


sub port {
    @_ == 1 || @_ == 2 or croak 'usage: $self->port([PORT])';
    return _eprt('PORT',@_);
}

sub eprt {
  @_ == 1 || @_ == 2 or croak 'usage: $self->eprt([PORT])';
  return _eprt('EPRT',@_);
}

sub _eprt {
  my ($cmd,$ftp,$port) = @_;
  delete ${*$ftp}{net_ftp_intern_port};
  unless ($port) {
    my $listen = ${*$ftp}{net_ftp_listen} ||= $IOCLASS->new(
      Listen    => 1,
      Timeout   => $ftp->timeout,
      LocalAddr => $ftp->sockhost,
      $family_key  => $ftp->sockdomain,
      can_ssl() ? (
        %{ ${*$ftp}{net_ftp_tlsargs} },
        SSL_startHandshake => 0,
      ):(),
    );
    ${*$ftp}{net_ftp_intern_port} = 1;
    my $fam = ($listen->sockdomain == AF_INET) ? 1:2;
    if ( $cmd eq 'EPRT' || $fam == 2 ) {
      $port = "|$fam|".$listen->sockhost."|".$listen->sockport."|";
      $cmd = 'EPRT';
    } else {
      my $p = $listen->sockport;
      $port = join(',',split(m{\.},$listen->sockhost),$p >> 8,$p & 0xff);
    }
  } elsif (ref($port) eq 'ARRAY') {
    $port = join(',',split(m{\.},@$port[0]),@$port[1] >> 8,@$port[1] & 0xff);
  }
  my $ok = $cmd eq 'EPRT' ? $ftp->_EPRT($port) : $ftp->_PORT($port);
  ${*$ftp}{net_ftp_port} = $port if $ok;
  return $ok;
}


sub ls  { shift->_list_cmd("NLST", @_); }
sub dir { shift->_list_cmd("LIST", @_); }


sub pasv {
  my $ftp = shift;
  @_ and croak 'usage: $ftp->port()';
  return $ftp->epsv if $ftp->sockdomain != AF_INET;
  delete ${*$ftp}{net_ftp_intern_port};

  if ( $ftp->_PASV &&
    $ftp->message =~ m{(\d+,\d+,\d+,\d+),(\d+),(\d+)} ) {
    my $port = 256 * $2 + $3;
    ( my $ip = $1 ) =~s{,}{.}g;
    return ${*$ftp}{net_ftp_pasv} = [ $ip,$port ];
  }
  return;
}

sub epsv {
  my $ftp = shift;
  @_ and croak 'usage: $ftp->epsv()';
  delete ${*$ftp}{net_ftp_intern_port};

  $ftp->_EPSV && $ftp->message =~ m{\(([\x33-\x7e])\1\1(\d+)\1\)}
    ? ${*$ftp}{net_ftp_pasv} = [ $ftp->peerhost, $2 ]
    : undef;
}


sub unique_name {
  my $ftp = shift;
  ${*$ftp}{'net_ftp_unique'} || undef;
}


sub supported {
  @_ == 2 or croak 'usage: $ftp->supported( CMD )';
  my $ftp  = shift;
  my $cmd  = uc shift;
  my $hash = ${*$ftp}{'net_ftp_supported'} ||= {};

  return $hash->{$cmd}
    if exists $hash->{$cmd};

  return $hash->{$cmd} = 1
    if $ftp->feature($cmd);

  return $hash->{$cmd} = 0
    unless $ftp->_HELP($cmd);

  my $text = $ftp->message;
  if ($text =~ /following.+commands/i) {
    $text =~ s/^.*\n//;
    while ($text =~ /(\*?)(\w+)(\*?)/sg) {
      $hash->{"\U$2"} = !length("$1$3");
    }
  }
  else {
    $hash->{$cmd} = $text !~ /unimplemented/i;
  }

  $hash->{$cmd} ||= 0;
}

##
## Deprecated methods
##


sub lsl {
  carp "Use of Net::FTP::lsl deprecated, use 'dir'"
    if $^W;
  goto &dir;
}


sub authorise {
  carp "Use of Net::FTP::authorise deprecated, use 'authorize'"
    if $^W;
  goto &authorize;
}


##
## Private methods
##


sub _extract_path {
  my ($ftp, $path) = @_;

  # This tries to work both with and without the quote doubling
  # convention (RFC 959 requires it, but the first 3 servers I checked
  # didn't implement it).  It will fail on a server which uses a quote in
  # the message which isn't a part of or surrounding the path.
  $ftp->ok
    && $ftp->message =~ /(?:^|\s)\"(.*)\"(?:$|\s)/
    && ($path = $1) =~ s/\"\"/\"/g;

  $path;
}

##
## Communication methods
##


sub _dataconn {
  my $ftp = shift;
  my $pkg = "Net::FTP::" . $ftp->type;
  eval "require " . $pkg ## no critic (BuiltinFunctions::ProhibitStringyEval)
    or croak("cannot load $pkg required for type ".$ftp->type);
  $pkg =~ s/ /_/g;
  delete ${*$ftp}{net_ftp_dataconn};

  my $conn;
  my $pasv = ${*$ftp}{net_ftp_pasv};
  if ($pasv) {
    $conn = $pkg->new(
      PeerAddr  => $pasv->[0],
      PeerPort  => $pasv->[1],
      LocalAddr => ${*$ftp}{net_ftp_localaddr},
      $family_key => ${*$ftp}{net_ftp_domain},
      Timeout   => $ftp->timeout,
      can_ssl() ? (
        SSL_startHandshake => 0,
        $ftp->is_SSL ? (
          SSL_reuse_ctx => $ftp,
          SSL_verifycn_name => ${*$ftp}{net_ftp_tlsargs}{SSL_verifycn_name},
          # This will cause the use of SNI if supported by IO::Socket::SSL.
          $ftp->can_client_sni ? (
            SSL_hostname  => ${*$ftp}{net_ftp_tlsargs}{SSL_hostname}
          ):(),
        ) :( %{${*$ftp}{net_ftp_tlsargs}} ),
      ):(),
    ) or return;
  } elsif (my $listen =  delete ${*$ftp}{net_ftp_listen}) {
    $conn = $listen->accept($pkg) or return;
    $conn->timeout($ftp->timeout);
    close($listen);
  } else {
    croak("no listener in active mode");
  }

  if (( ${*$ftp}{net_ftp_tlsprot} || '') eq 'P') {
    if ($conn->connect_SSL) {
      # SSL handshake ok
    } else {
      carp("failed to ssl upgrade dataconn: $IO::Socket::SSL::SSL_ERROR");
      return;
    }
  }

  ${*$ftp}{net_ftp_dataconn} = $conn;
  ${*$conn} = "";
  ${*$conn}{net_ftp_cmd} = $ftp;
  ${*$conn}{net_ftp_blksize} = ${*$ftp}{net_ftp_blksize};
  return $conn;
}


sub _list_cmd {
  my $ftp = shift;
  my $cmd = uc shift;

  delete ${*$ftp}{'net_ftp_port'};
  delete ${*$ftp}{'net_ftp_pasv'};

  my $data = $ftp->_data_cmd($cmd, @_);

  return
    unless (defined $data);

  require Net::FTP::A;
  bless $data, "Net::FTP::A";    # Force ASCII mode

  my $databuf = '';
  my $buf     = '';
  my $blksize = ${*$ftp}{'net_ftp_blksize'};

  while ($data->read($databuf, $blksize)) {
    $buf .= $databuf;
  }

  my $list = [split(/\n/, $buf)];

  $data->close();

  if (EBCDIC) {
    for (@$list) { $_ = $ftp->toebcdic($_) }
  }

  wantarray
    ? @{$list}
    : $list;
}


sub _data_cmd {
  my $ftp   = shift;
  my $cmd   = uc shift;
  my $ok    = 1;
  my $where = delete ${*$ftp}{'net_ftp_rest'} || 0;
  my $arg;

  for my $arg (@_) {
    croak("Bad argument '$arg'\n")
      if $arg =~ /[\r\n]/s;
  }

  if ( ${*$ftp}{'net_ftp_passive'}
    && !defined ${*$ftp}{'net_ftp_pasv'}
    && !defined ${*$ftp}{'net_ftp_port'})
  {
    return unless defined $ftp->pasv;

    if ($where and !$ftp->_REST($where)) {
      my ($status, $message) = ($ftp->status, $ftp->message);
      $ftp->abort;
      $ftp->set_status($status, $message);
      return;
    }

    # first send command, then open data connection
    # otherwise the peer might not do a full accept (with SSL
    # handshake if PROT P)
    $ftp->command($cmd, @_);
    my $data = $ftp->_dataconn();
    if (CMD_INFO == $ftp->response()) {
      $data->reading
        if $data && $cmd =~ /RETR|LIST|NLST|MLSD/;
      return $data;
    }
    $data->_close if $data;

    return;
  }

  $ok = $ftp->port
    unless (defined ${*$ftp}{'net_ftp_port'}
    || defined ${*$ftp}{'net_ftp_pasv'});

  $ok = $ftp->_REST($where)
    if $ok && $where;

  return
    unless $ok;

  if ($cmd =~ /(STOR|APPE|STOU)/ and exists ${*$ftp}{net_ftp_allo} and
      $ftp->supported("ALLO"))
  {
    $ftp->_ALLO(delete ${*$ftp}{net_ftp_allo})
      or return;
  }

  $ftp->command($cmd, @_);

  return 1
    if (defined ${*$ftp}{'net_ftp_pasv'});

  $ok = CMD_INFO == $ftp->response();

  return $ok
    unless exists ${*$ftp}{'net_ftp_intern_port'};

  if ($ok) {
    my $data = $ftp->_dataconn();

    $data->reading
      if $data && $cmd =~ /RETR|LIST|NLST|MLSD/;

    return $data;
  }


  close(delete ${*$ftp}{'net_ftp_listen'});

  return;
}

##
## Over-ride methods (Net::Cmd)
##


sub debug_text { $_[2] =~ /^(pass|resp|acct)/i ? "$1 ....\n" : $_[2]; }


sub command {
  my $ftp = shift;

  delete ${*$ftp}{'net_ftp_port'};
  $ftp->SUPER::command(@_);
}


sub response {
  my $ftp  = shift;
  my $code = $ftp->SUPER::response() || 5;    # assume 500 if undef

  delete ${*$ftp}{'net_ftp_pasv'}
    if ($code != CMD_MORE && $code != CMD_INFO);

  $code;
}


sub parse_response {
  return ($1, $2 eq "-")
    if $_[1] =~ s/^(\d\d\d)([- ]?)//o;

  my $ftp = shift;

  # Darn MS FTP server is a load of CRAP !!!!
  # Expect to see undef here.
  return ()
    unless 0 + (${*$ftp}{'net_cmd_code'} || 0);

  (${*$ftp}{'net_cmd_code'}, 1);
}

##
## Allow 2 servers to talk directly
##


sub pasv_xfer_unique {
  my ($sftp, $sfile, $dftp, $dfile) = @_;
  $sftp->pasv_xfer($sfile, $dftp, $dfile, 1);
}


sub pasv_xfer {
  my ($sftp, $sfile, $dftp, $dfile, $unique) = @_;

  ($dfile = $sfile) =~ s#.*/##
    unless (defined $dfile);

  my $port = $sftp->pasv
    or return;

  $dftp->port($port)
    or return;

  return
    unless ($unique ? $dftp->stou($dfile) : $dftp->stor($dfile));

  unless ($sftp->retr($sfile) && $sftp->response == CMD_INFO) {
    $sftp->retr($sfile);
    $dftp->abort;
    $dftp->response();
    return;
  }

  $dftp->pasv_wait($sftp);
}


sub pasv_wait {
  @_ == 2 or croak 'usage: $ftp->pasv_wait(NON_PASV_FTP)';

  my ($ftp, $non_pasv) = @_;
  my ($file, $rin, $rout);

  vec($rin = '', fileno($ftp), 1) = 1;
  select($rout = $rin, undef, undef, undef);

  my $dres = $ftp->response();
  my $sres = $non_pasv->response();

  return
    unless $dres == CMD_OK && $sres == CMD_OK;

  return
    unless $ftp->ok() && $non_pasv->ok();

  return $1
    if $ftp->message =~ /unique file name:\s*(\S*)\s*\)/;

  return $1
    if $non_pasv->message =~ /unique file name:\s*(\S*)\s*\)/;

  return 1;
}


sub feature {
  @_ == 2 or croak 'usage: $ftp->feature( NAME )';
  my ($ftp, $feat) = @_;

  my $feature = ${*$ftp}{net_ftp_feature} ||= do {
    my @feat;

    # Example response
    # 211-Features:
    #  MDTM
    #  REST STREAM
    #  SIZE
    # 211 End

    @feat = map { /^\s+(.*\S)/ } $ftp->message
      if $ftp->_FEAT;

    \@feat;
  };

  return grep { /^\Q$feat\E\b/i } @$feature;
}


sub cmd { shift->command(@_)->response() }

########################################
#
# RFC959 + RFC2428 + RFC4217 commands
#


sub _ABOR { shift->command("ABOR")->response() == CMD_OK }
sub _ALLO { shift->command("ALLO", @_)->response() == CMD_OK }
sub _CDUP { shift->command("CDUP")->response() == CMD_OK }
sub _NOOP { shift->command("NOOP")->response() == CMD_OK }
sub _PASV { shift->command("PASV")->response() == CMD_OK }
sub _QUIT { shift->command("QUIT")->response() == CMD_OK }
sub _DELE { shift->command("DELE", @_)->response() == CMD_OK }
sub _CWD  { shift->command("CWD", @_)->response() == CMD_OK }
sub _PORT { shift->command("PORT", @_)->response() == CMD_OK }
sub _RMD  { shift->command("RMD", @_)->response() == CMD_OK }
sub _MKD  { shift->command("MKD", @_)->response() == CMD_OK }
sub _PWD  { shift->command("PWD", @_)->response() == CMD_OK }
sub _TYPE { shift->command("TYPE", @_)->response() == CMD_OK }
sub _RNTO { shift->command("RNTO", @_)->response() == CMD_OK }
sub _RESP { shift->command("RESP", @_)->response() == CMD_OK }
sub _MDTM { shift->command("MDTM", @_)->response() == CMD_OK }
sub _SIZE { shift->command("SIZE", @_)->response() == CMD_OK }
sub _HELP { shift->command("HELP", @_)->response() == CMD_OK }
sub _STAT { shift->command("STAT", @_)->response() == CMD_OK }
sub _FEAT { shift->command("FEAT", @_)->response() == CMD_OK }
sub _PBSZ { shift->command("PBSZ", @_)->response() == CMD_OK }
sub _PROT { shift->command("PROT", @_)->response() == CMD_OK }
sub _CCC  { shift->command("CCC", @_)->response() == CMD_OK }
sub _EPRT { shift->command("EPRT", @_)->response() == CMD_OK }
sub _EPSV { shift->command("EPSV", @_)->response() == CMD_OK }
sub _APPE { shift->command("APPE", @_)->response() == CMD_INFO }
sub _LIST { shift->command("LIST", @_)->response() == CMD_INFO }
sub _NLST { shift->command("NLST", @_)->response() == CMD_INFO }
sub _RETR { shift->command("RETR", @_)->response() == CMD_INFO }
sub _STOR { shift->command("STOR", @_)->response() == CMD_INFO }
sub _STOU { shift->command("STOU", @_)->response() == CMD_INFO }
sub _RNFR { shift->command("RNFR", @_)->response() == CMD_MORE }
sub _REST { shift->command("REST", @_)->response() == CMD_MORE }
sub _PASS { shift->command("PASS", @_)->response() }
sub _ACCT { shift->command("ACCT", @_)->response() }
sub _AUTH { shift->command("AUTH", @_)->response() }


sub _USER {
  my $ftp = shift;
  my $ok  = $ftp->command("USER", @_)->response();

  # A certain brain dead firewall :-)
  $ok = $ftp->command("user", @_)->response()
    unless $ok == CMD_MORE or $ok == CMD_OK;

  $ok;
}


sub _SMNT { shift->unsupported(@_) }
sub _MODE { shift->unsupported(@_) }
sub _SYST { shift->unsupported(@_) }
sub _STRU { shift->unsupported(@_) }
sub _REIN { shift->unsupported(@_) }

{
  # Session Cache with single entry
  # used to make sure that we reuse same session for control and data channels
  package Net::FTP::_SSL_SingleSessionCache;
  sub new { my $x; return bless \$x,shift }
  sub add_session {
    my ($cache,$key,$session) = @_;
    Net::SSLeay::SESSION_free($$cache) if $$cache;
    $$cache = $session;
  }
  sub get_session {
    my $cache = shift;
    return $$cache
  }
  sub DESTROY {
    my $cache = shift;
    Net::SSLeay::SESSION_free($$cache) if $$cache;
  }
}

1;

__END__

=head1 NAME

Net::FTP - FTP Client class

=head1 SYNOPSIS

    use Net::FTP;

    $ftp = Net::FTP->new("some.host.name", Debug => 0)
      or die "Cannot connect to some.host.name: $@";

    $ftp->login("anonymous",'-anonymous@')
      or die "Cannot login ", $ftp->message;

    $ftp->cwd("/pub")
      or die "Cannot change working directory ", $ftp->message;

    $ftp->get("that.file")
      or die "get failed ", $ftp->message;

    $ftp->quit;

=head1 DESCRIPTION

C<Net::FTP> is a class implementing a simple FTP client in Perl as
described in RFC959.  It provides wrappers for the commonly used subset of the
RFC959 commands.
If L<IO::Socket::IP> or L<IO::Socket::INET6> is installed it also provides
support for IPv6 as defined in RFC2428.
And with L<IO::Socket::SSL> installed it provides support for implicit FTPS
and explicit FTPS as defined in RFC4217.

The Net::FTP class is a subclass of Net::Cmd and (depending on avaibility) of
IO::Socket::IP, IO::Socket::INET6 or IO::Socket::INET.

=head1 OVERVIEW

FTP stands for File Transfer Protocol.  It is a way of transferring
files between networked machines.  The protocol defines a client
(whose commands are provided by this module) and a server (not
implemented in this module).  Communication is always initiated by the
client, and the server responds with a message and a status code (and
sometimes with data).

The FTP protocol allows files to be sent to or fetched from the
server.  Each transfer involves a B<local file> (on the client) and a
B<remote file> (on the server).  In this module, the same file name
will be used for both local and remote if only one is specified.  This
means that transferring remote file C</path/to/file> will try to put
that file in C</path/to/file> locally, unless you specify a local file
name.

The protocol also defines several standard B<translations> which the
file can undergo during transfer.  These are ASCII, EBCDIC, binary,
and byte.  ASCII is the default type, and indicates that the sender of
files will translate the ends of lines to a standard representation
which the receiver will then translate back into their local
representation.  EBCDIC indicates the file being transferred is in
EBCDIC format.  Binary (also known as image) format sends the data as
a contiguous bit stream.  Byte format transfers the data as bytes, the
values of which remain the same regardless of differences in byte size
between the two machines (in theory - in practice you should only use
this if you really know what you're doing).  This class does not support
the EBCDIC or byte formats, and will default to binary instead if they
are attempted.

=head1 CONSTRUCTOR

=over 4

=item new ([ HOST ] [, OPTIONS ])

This is the constructor for a new Net::FTP object. C<HOST> is the
name of the remote host to which an FTP connection is required.

C<HOST> is optional. If C<HOST> is not given then it may instead be
passed as the C<Host> option described below. 

C<OPTIONS> are passed in a hash like fashion, using key and value pairs.
Possible options are:

B<Host> - FTP host to connect to. It may be a single scalar, as defined for
the C<PeerAddr> option in L<IO::Socket::INET>, or a reference to
an array with hosts to try in turn. The L</host> method will return the value
which was used to connect to the host.

B<Firewall> - The name of a machine which acts as an FTP firewall. This can be
overridden by an environment variable C<FTP_FIREWALL>. If specified, and the
given host cannot be directly connected to, then the
connection is made to the firewall machine and the string C<@hostname> is
appended to the login identifier. This kind of setup is also referred to
as an ftp proxy.

B<FirewallType> - The type of firewall running on the machine indicated by
B<Firewall>. This can be overridden by an environment variable
C<FTP_FIREWALL_TYPE>. For a list of permissible types, see the description of
ftp_firewall_type in L<Net::Config>.

B<BlockSize> - This is the block size that Net::FTP will use when doing
transfers. (defaults to 10240)

B<Port> - The port number to connect to on the remote machine for the
FTP connection

B<SSL> - If the connection should be done from start with SSL, contrary to later
upgrade with C<starttls>.

B<SSL_*> - SSL arguments which will be applied when upgrading the control or
data connection to SSL. You can use SSL arguments as documented in
L<IO::Socket::SSL>, but it will usually use the right arguments already.

B<Timeout> - Set a timeout value in seconds (defaults to 120)

B<Debug> - debug level (see the debug method in L<Net::Cmd>)

B<Passive> - If set to a non-zero value then all data transfers will
be done using passive mode. If set to zero then data transfers will be
done using active mode.  If the machine is connected to the Internet
directly, both passive and active mode should work equally well.
Behind most firewall and NAT configurations passive mode has a better
chance of working.  However, in some rare firewall configurations,
active mode actually works when passive mode doesn't.  Some really old
FTP servers might not implement passive transfers.  If not specified,
then the transfer mode is set by the environment variable
C<FTP_PASSIVE> or if that one is not set by the settings done by the
F<libnetcfg> utility.  If none of these apply then passive mode is
used.

B<Hash> - If given a reference to a file handle (e.g., C<\*STDERR>),
print hash marks (#) on that filehandle every 1024 bytes.  This
simply invokes the C<hash()> method for you, so that hash marks
are displayed for all transfers.  You can, of course, call C<hash()>
explicitly whenever you'd like.

B<LocalAddr> - Local address to use for all socket connections. This
argument will be passed to the super class, i.e. L<IO::Socket::INET>
or L<IO::Socket::IP>.

B<Domain> - Domain to use, i.e. AF_INET or AF_INET6. This
argument will be passed to the IO::Socket super class.
This can be used to enforce IPv4 even with L<IO::Socket::IP>
which would default to IPv6.
B<Family> is accepted as alternative name for B<Domain>.

If the constructor fails undef will be returned and an error message will
be in $@

=back

=head1 METHODS

Unless otherwise stated all methods return either a I<true> or I<false>
value, with I<true> meaning that the operation was a success. When a method
states that it returns a value, failure will be returned as I<undef> or an
empty list.

C<Net::FTP> inherits from C<Net::Cmd> so methods defined in C<Net::Cmd> may
be used to send commands to the remote FTP server in addition to the methods
documented here.

=over 4

=item login ([LOGIN [,PASSWORD [, ACCOUNT] ] ])

Log into the remote FTP server with the given login information. If
no arguments are given then the C<Net::FTP> uses the C<Net::Netrc>
package to lookup the login information for the connected host.
If no information is found then a login of I<anonymous> is used.
If no password is given and the login is I<anonymous> then I<anonymous@>
will be used for password.

If the connection is via a firewall then the C<authorize> method will
be called with no arguments.

=item starttls ()

Upgrade existing plain connection to SSL.
The SSL arguments have to be given in C<new> already because they are needed for
data connections too.

=item stoptls ()

Downgrade existing SSL connection back to plain.
This is needed to work with some FTP helpers at firewalls, which need to see the
PORT and PASV commands and responses to dynamically open the necessary ports.
In this case C<starttls> is usually only done to protect the authorization.

=item prot ( LEVEL )

Set what type of data channel protection the client and server will be using.
Only C<LEVEL>s "C" (clear) and "P" (private) are supported.

=item host ()

Returns the value used by the constructor, and passed to the IO::Socket super
class to connect to the host.

=item account( ACCT )

Set a string identifying the user's account.

=item authorize ( [AUTH [, RESP]])

This is a protocol used by some firewall ftp proxies. It is used
to authorise the user to send data out.  If both arguments are not specified
then C<authorize> uses C<Net::Netrc> to do a lookup.

=item site (ARGS)

Send a SITE command to the remote server and wait for a response.

Returns most significant digit of the response code.

=item ascii ()

Transfer file in ASCII. CRLF translation will be done if required

=item binary ()

Transfer file in binary mode. No transformation will be done.

B<Hint>: If both server and client machines use the same line ending for
text files, then it will be faster to transfer all files in binary mode.

=item type ( [ TYPE ] )

Set or get if files will be transferred in ASCII or binary mode.

=item rename ( OLDNAME, NEWNAME )

Rename a file on the remote FTP server from C<OLDNAME> to C<NEWNAME>. This
is done by sending the RNFR and RNTO commands.

=item delete ( FILENAME )

Send a request to the server to delete C<FILENAME>.

=item cwd ( [ DIR ] )

Attempt to change directory to the directory given in C<$dir>.  If
C<$dir> is C<"..">, the FTP C<CDUP> command is used to attempt to
move up one directory. If no directory is given then an attempt is made
to change the directory to the root directory.

=item cdup ()

Change directory to the parent of the current directory.

=item passive ( [ PASSIVE ] )

Set or get if data connections will be initiated in passive mode.

=item pwd ()

Returns the full pathname of the current directory.

=item restart ( WHERE )

Set the byte offset at which to begin the next data transfer. Net::FTP simply
records this value and uses it when during the next data transfer. For this
reason this method will not return an error, but setting it may cause
a subsequent data transfer to fail.

=item rmdir ( DIR [, RECURSE ])

Remove the directory with the name C<DIR>. If C<RECURSE> is I<true> then
C<rmdir> will attempt to delete everything inside the directory.

=item mkdir ( DIR [, RECURSE ])

Create a new directory with the name C<DIR>. If C<RECURSE> is I<true> then
C<mkdir> will attempt to create all the directories in the given path.

Returns the full pathname to the new directory.

=item alloc ( SIZE [, RECORD_SIZE] )

The alloc command allows you to give the ftp server a hint about the size
of the file about to be transferred using the ALLO ftp command. Some storage
systems use this to make intelligent decisions about how to store the file.
The C<SIZE> argument represents the size of the file in bytes. The
C<RECORD_SIZE> argument indicates a maximum record or page size for files
sent with a record or page structure.

The size of the file will be determined, and sent to the server
automatically for normal files so that this method need only be called if
you are transferring data from a socket, named pipe, or other stream not
associated with a normal file.

=item ls ( [ DIR ] )

Get a directory listing of C<DIR>, or the current directory.

In an array context, returns a list of lines returned from the server. In
a scalar context, returns a reference to a list.

=item dir ( [ DIR ] )

Get a directory listing of C<DIR>, or the current directory in long format.

In an array context, returns a list of lines returned from the server. In
a scalar context, returns a reference to a list.

=item get ( REMOTE_FILE [, LOCAL_FILE [, WHERE]] )

Get C<REMOTE_FILE> from the server and store locally. C<LOCAL_FILE> may be
a filename or a filehandle. If not specified, the file will be stored in
the current directory with the same leafname as the remote file.

If C<WHERE> is given then the first C<WHERE> bytes of the file will
not be transferred, and the remaining bytes will be appended to
the local file if it already exists.

Returns C<LOCAL_FILE>, or the generated local file name if C<LOCAL_FILE>
is not given. If an error was encountered undef is returned.

=item put ( LOCAL_FILE [, REMOTE_FILE ] )

Put a file on the remote server. C<LOCAL_FILE> may be a name or a filehandle.
If C<LOCAL_FILE> is a filehandle then C<REMOTE_FILE> must be specified. If
C<REMOTE_FILE> is not specified then the file will be stored in the current
directory with the same leafname as C<LOCAL_FILE>.

Returns C<REMOTE_FILE>, or the generated remote filename if C<REMOTE_FILE>
is not given.

B<NOTE>: If for some reason the transfer does not complete and an error is
returned then the contents that had been transferred will not be remove
automatically.

=item put_unique ( LOCAL_FILE [, REMOTE_FILE ] )

Same as put but uses the C<STOU> command.

Returns the name of the file on the server.

=item append ( LOCAL_FILE [, REMOTE_FILE ] )

Same as put but appends to the file on the remote server.

Returns C<REMOTE_FILE>, or the generated remote filename if C<REMOTE_FILE>
is not given.

=item unique_name ()

Returns the name of the last file stored on the server using the
C<STOU> command.

=item mdtm ( FILE )

Returns the I<modification time> of the given file

=item size ( FILE )

Returns the size in bytes for the given file as stored on the remote server.

B<NOTE>: The size reported is the size of the stored file on the remote server.
If the file is subsequently transferred from the server in ASCII mode
and the remote server and local machine have different ideas about
"End Of Line" then the size of file on the local machine after transfer
may be different.

=item supported ( CMD )

Returns TRUE if the remote server supports the given command.

=item hash ( [FILEHANDLE_GLOB_REF],[ BYTES_PER_HASH_MARK] )

Called without parameters, or with the first argument false, hash marks
are suppressed.  If the first argument is true but not a reference to a 
file handle glob, then \*STDERR is used.  The second argument is the number
of bytes per hash mark printed, and defaults to 1024.  In all cases the
return value is a reference to an array of two:  the filehandle glob reference
and the bytes per hash mark.

=item feature ( NAME )

Determine if the server supports the specified feature. The return
value is a list of lines the server responded with to describe the
options that it supports for the given feature. If the feature is
unsupported then the empty list is returned.

  if ($ftp->feature( 'MDTM' )) {
    # Do something
  }

  if (grep { /\bTLS\b/ } $ftp->feature('AUTH')) {
    # Server supports TLS
  }

=back

The following methods can return different results depending on
how they are called. If the user explicitly calls either
of the C<pasv> or C<port> methods then these methods will
return a I<true> or I<false> value. If the user does not
call either of these methods then the result will be a
reference to a C<Net::FTP::dataconn> based object.

=over 4

=item nlst ( [ DIR ] )

Send an C<NLST> command to the server, with an optional parameter.

=item list ( [ DIR ] )

Same as C<nlst> but using the C<LIST> command

=item retr ( FILE )

Begin the retrieval of a file called C<FILE> from the remote server.

=item stor ( FILE )

Tell the server that you wish to store a file. C<FILE> is the
name of the new file that should be created.

=item stou ( FILE )

Same as C<stor> but using the C<STOU> command. The name of the unique
file which was created on the server will be available via the C<unique_name>
method after the data connection has been closed.

=item appe ( FILE )

Tell the server that we want to append some data to the end of a file
called C<FILE>. If this file does not exist then create it.

=back

If for some reason you want to have complete control over the data connection,
this includes generating it and calling the C<response> method when required,
then the user can use these methods to do so.

However calling these methods only affects the use of the methods above that
can return a data connection. They have no effect on methods C<get>, C<put>,
C<put_unique> and those that do not require data connections.

=over 4

=item port ( [ PORT ] )

=item eprt ( [ PORT ] )

Send a C<PORT> (IPv4) or C<EPRT> (IPv6) command to the server. If C<PORT> is
specified then it is sent to the server. If not, then a listen socket is created
and the correct information sent to the server.

=item pasv ()

=item epsv ()

Tell the server to go into passive mode (C<pasv> for IPv4, C<epsv> for IPv6).
Returns the text that represents the port on which the server is listening, this
text is in a suitable form to send to another ftp server using the C<port> or
C<eprt> method.

=back

The following methods can be used to transfer files between two remote
servers, providing that these two servers can connect directly to each other.

=over 4

=item pasv_xfer ( SRC_FILE, DEST_SERVER [, DEST_FILE ] )

This method will do a file transfer between two remote ftp servers. If
C<DEST_FILE> is omitted then the leaf name of C<SRC_FILE> will be used.

=item pasv_xfer_unique ( SRC_FILE, DEST_SERVER [, DEST_FILE ] )

Like C<pasv_xfer> but the file is stored on the remote server using
the STOU command.

=item pasv_wait ( NON_PASV_SERVER )

This method can be used to wait for a transfer to complete between a passive
server and a non-passive server. The method should be called on the passive
server with the C<Net::FTP> object for the non-passive server passed as an
argument.

=item abort ()

Abort the current data transfer.

=item quit ()

Send the QUIT command to the remote FTP server and close the socket connection.

=back

=head2 Methods for the adventurous

=over 4

=item quot (CMD [,ARGS])

Send a command, that Net::FTP does not directly support, to the remote
server and wait for a response.

Returns most significant digit of the response code.

B<WARNING> This call should only be used on commands that do not require
data connections. Misuse of this method can hang the connection.

=item can_inet6 ()

Returns whether we can use IPv6.

=item can_ssl ()

Returns whether we can use SSL.

=back

=head1 THE dataconn CLASS

Some of the methods defined in C<Net::FTP> return an object which will
be derived from the C<Net::FTP::dataconn> class. See L<Net::FTP::dataconn> for
more details.

=head1 UNIMPLEMENTED

The following RFC959 commands have not been implemented:

=over 4

=item B<SMNT>

Mount a different file system structure without changing login or
accounting information.

=item B<HELP>

Ask the server for "helpful information" (that's what the RFC says) on
the commands it accepts.

=item B<MODE>

Specifies transfer mode (stream, block or compressed) for file to be
transferred.

=item B<SYST>

Request remote server system identification.

=item B<STAT>

Request remote server status.

=item B<STRU>

Specifies file structure for file to be transferred.

=item B<REIN>

Reinitialize the connection, flushing all I/O and account information.

=back

=head1 REPORTING BUGS

When reporting bugs/problems please include as much information as possible.
It may be difficult for me to reproduce the problem as almost every setup
is different.

A small script which yields the problem will probably be of help. It would
also be useful if this script was run with the extra options C<< Debug => 1 >>
passed to the constructor, and the output sent with the bug report. If you
cannot include a small script then please include a Debug trace from a
run of your program which does yield the problem.

=head1 AUTHOR

Graham Barr E<lt>F<gbarr@pobox.com>E<gt>

Steve Hay E<lt>F<shay@cpan.org>E<gt> is now maintaining libnet as of version
1.22_02

=head1 SEE ALSO

L<Net::Netrc>,
L<Net::Cmd>,
L<IO::Socket::SSL>

ftp(1), ftpd(8), RFC 959, RFC 2428, RFC 4217
http://www.ietf.org/rfc/rfc959.txt
http://www.ietf.org/rfc/rfc2428.txt
http://www.ietf.org/rfc/rfc4217.txt

=head1 USE EXAMPLES

For an example of the use of Net::FTP see

=over 4

=item http://www.csh.rit.edu/~adam/Progs/

C<autoftp> is a program that can retrieve, send, or list files via
the FTP protocol in a non-interactive manner.

=back

=head1 CREDITS

Henry Gabryjelski <henryg@WPI.EDU> - for the suggestion of creating directories
recursively.

Nathan Torkington <gnat@frii.com> - for some input on the documentation.

Roderick Schertler <roderick@gate.net> - for various inputs

=head1 COPYRIGHT

Versions up to 2.77_2 Copyright (c) 1995-2004 Graham Barr. All rights reserved.
Changes in Version 2.77_3 onwards Copyright (C) 2013-2015 Steve Hay.  All rights
reserved.

This module is free software; you can redistribute it and/or modify it under the
same terms as Perl itself, i.e. under the terms of either the GNU General Public
License or the Artistic License, as specified in the F<LICENCE> file.

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          # Net::NNTP.pm
#
# Versions up to 2.24_1 Copyright (c) 1995-1997 Graham Barr <gbarr@pobox.com>.
# All rights reserved.
# Changes in Version 2.25 onwards Copyright (C) 2013-2015 Steve Hay.  All rights
# reserved.
# This module is free software; you can redistribute it and/or modify it under
# the same terms as Perl itself, i.e. under the terms of either the GNU General
# Public License or the Artistic License, as specified in the F<LICENCE> file.

package Net::NNTP;

use 5.008001;

use strict;
use warnings;

use Carp;
use IO::Socket;
use Net::Cmd;
use Net::Config;
use Time::Local;

our $VERSION = "3.08_01";

# Code for detecting if we can use SSL
my $ssl_class = eval {
  require IO::Socket::SSL;
  # first version with default CA on most platforms
  no warnings 'numeric';
  IO::Socket::SSL->VERSION(2.007);
} && 'IO::Socket::SSL';

my $nossl_warn = !$ssl_class &&
  'To use SSL please install IO::Socket::SSL with version>=2.007';

# Code for detecting if we can use IPv6
my $family_key = 'Domain';
my $inet6_class = eval {
  require IO::Socket::IP;
  no warnings 'numeric';
  IO::Socket::IP->VERSION(0.20) || die;
  $family_key = 'Family';
} && 'IO::Socket::IP' || eval {
  require IO::Socket::INET6;
  no warnings 'numeric';
  IO::Socket::INET6->VERSION(2.62);
} && 'IO::Socket::INET6';


sub can_ssl   { $ssl_class };
sub can_inet6 { $inet6_class };

our @ISA = ('Net::Cmd', $inet6_class || 'IO::Socket::INET');


sub new {
  my $self = shift;
  my $type = ref($self) || $self;
  my ($host, %arg);
  if (@_ % 2) {
    $host = shift;
    %arg  = @_;
  }
  else {
    %arg  = @_;
    $host = delete $arg{Host};
  }
  my $obj;

  $host ||= $ENV{NNTPSERVER} || $ENV{NEWSHOST};

  my $hosts = defined $host ? [$host] : $NetConfig{nntp_hosts};

  @{$hosts} = qw(news)
    unless @{$hosts};

  my %connect = ( Proto => 'tcp');

  if ($arg{SSL}) {
    # SSL from start
    die $nossl_warn if ! $ssl_class;
    $arg{Port} ||= 563;
    $connect{$_} = $arg{$_} for(grep { m{^SSL_} } keys %arg);
  }

  foreach my $o (qw(LocalAddr LocalPort Timeout)) {
    $connect{$o} = $arg{$o} if exists $arg{$o};
  }
  $connect{$family_key} = $arg{Domain} || $arg{Family};
  $connect{Timeout} = 120 unless defined $connect{Timeout};
  $connect{PeerPort} = $arg{Port} || 'nntp(119)';
  foreach my $h (@{$hosts}) {
    $connect{PeerAddr} = $h;
    $obj = $type->SUPER::new(%connect) or next;
    ${*$obj}{'net_nntp_host'} = $h;
    ${*$obj}{'net_nntp_arg'} = \%arg;
    if ($arg{SSL}) {
      Net::NNTP::_SSL->start_SSL($obj,%arg) or next;
    }
    last:
  }

  return
    unless defined $obj;

  $obj->autoflush(1);
  $obj->debug(exists $arg{Debug} ? $arg{Debug} : undef);

  unless ($obj->response() == CMD_OK) {
    $obj->close;
    return;
  }

  my $c = $obj->code;
  my @m = $obj->message;

  unless (exists $arg{Reader} && $arg{Reader} == 0) {

    # if server is INN and we have transfer rights the we are currently
    # talking to innd not nnrpd
    if ($obj->reader) {

      # If reader succeeds the we need to consider this code to determine postok
      $c = $obj->code;
    }
    else {

      # I want to ignore this failure, so restore the previous status.
      $obj->set_status($c, \@m);
    }
  }

  ${*$obj}{'net_nntp_post'} = $c == 200 ? 1 : 0;

  $obj;
}


sub host {
  my $me = shift;
  ${*$me}{'net_nntp_host'};
}


sub debug_text {
  my $nntp  = shift;
  my $inout = shift;
  my $text  = shift;

  if ( (ref($nntp) and $nntp->code == 350 and $text =~ /^(\S+)/)
    || ($text =~ /^(authinfo\s+pass)/io))
  {
    $text = "$1 ....\n";
  }

  $text;
}


sub postok {
  @_ == 1 or croak 'usage: $nntp->postok()';
  my $nntp = shift;
  ${*$nntp}{'net_nntp_post'} || 0;
}


sub starttls {
  my $self = shift;
  $ssl_class or die $nossl_warn;
  $self->_STARTTLS or return;
  Net::NNTP::_SSL->start_SSL($self,
    %{ ${*$self}{'net_nntp_arg'} }, # (ssl) args given in new
    @_   # more (ssl) args
  ) or return;
  return 1;
}


sub article {
  @_ >= 1 && @_ <= 3 or croak 'usage: $nntp->article( [ MSGID ], [ FH ] )';
  my $nntp = shift;
  my @fh;

  @fh = (pop) if @_ == 2 || (@_ && (ref($_[0]) || ref(\$_[0]) eq 'GLOB'));

  $nntp->_ARTICLE(@_)
    ? $nntp->read_until_dot(@fh)
    : undef;
}


sub articlefh {
  @_ >= 1 && @_ <= 2 or croak 'usage: $nntp->articlefh( [ MSGID ] )';
  my $nntp = shift;

  return unless $nntp->_ARTICLE(@_);
  return $nntp->tied_fh;
}


sub authinfo {
  @_ == 3 or croak 'usage: $nntp->authinfo( USER, PASS )';
  my ($nntp, $user, $pass) = @_;

  $nntp->_AUTHINFO("USER",      $user) == CMD_MORE
    && $nntp->_AUTHINFO("PASS", $pass) == CMD_OK;
}


sub authinfo_simple {
  @_ == 3 or croak 'usage: $nntp->authinfo( USER, PASS )';
  my ($nntp, $user, $pass) = @_;

  $nntp->_AUTHINFO('SIMPLE') == CMD_MORE
    && $nntp->command($user, $pass)->response == CMD_OK;
}


sub body {
  @_ >= 1 && @_ <= 3 or croak 'usage: $nntp->body( [ MSGID ], [ FH ] )';
  my $nntp = shift;
  my @fh;

  @fh = (pop) if @_ == 2 || (@_ && ref($_[0]) || ref(\$_[0]) eq 'GLOB');

  $nntp->_BODY(@_)
    ? $nntp->read_until_dot(@fh)
    : undef;
}


sub bodyfh {
  @_ >= 1 && @_ <= 2 or croak 'usage: $nntp->bodyfh( [ MSGID ] )';
  my $nntp = shift;
  return unless $nntp->_BODY(@_);
  return $nntp->tied_fh;
}


sub head {
  @_ >= 1 && @_ <= 3 or croak 'usage: $nntp->head( [ MSGID ], [ FH ] )';
  my $nntp = shift;
  my @fh;

  @fh = (pop) if @_ == 2 || (@_ && ref($_[0]) || ref(\$_[0]) eq 'GLOB');

  $nntp->_HEAD(@_)
    ? $nntp->read_until_dot(@fh)
    : undef;
}


sub headfh {
  @_ >= 1 && @_ <= 2 or croak 'usage: $nntp->headfh( [ MSGID ] )';
  my $nntp = shift;
  return unless $nntp->_HEAD(@_);
  return $nntp->tied_fh;
}


sub nntpstat {
  @_ == 1 || @_ == 2 or croak 'usage: $nntp->nntpstat( [ MSGID ] )';
  my $nntp = shift;

  $nntp->_STAT(@_) && $nntp->message =~ /(<[^>]+>)/o
    ? $1
    : undef;
}


sub group {
  @_ == 1 || @_ == 2 or croak 'usage: $nntp->group( [ GROUP ] )';
  my $nntp = shift;
  my $grp  = ${*$nntp}{'net_nntp_group'};

  return $grp
    unless (@_ || wantarray);

  my $newgrp = shift;

  $newgrp = (defined($grp) and length($grp)) ? $grp : ""
    unless defined($newgrp) and length($newgrp);

  return 
    unless $nntp->_GROUP($newgrp) and $nntp->message =~ /(\d+)\s+(\d+)\s+(\d+)\s+(\S+)/;

  my ($count, $first, $last, $group) = ($1, $2, $3, $4);

  # group may be replied as '(current group)'
  $group = ${*$nntp}{'net_nntp_group'}
    if $group =~ /\(/;

  ${*$nntp}{'net_nntp_group'} = $group;

  wantarray
    ? ($count, $first, $last, $group)
    : $group;
}


sub help {
  @_ == 1 or croak 'usage: $nntp->help()';
  my $nntp = shift;

  $nntp->_HELP
    ? $nntp->read_until_dot
    : undef;
}


sub ihave {
  @_ >= 2 or croak 'usage: $nntp->ihave( MESSAGE-ID [, MESSAGE ])';
  my $nntp = shift;
  my $mid  = shift;

  $nntp->_IHAVE($mid) && $nntp->datasend(@_)
    ? @_ == 0 || $nntp->dataend
    : undef;
}


sub last {
  @_ == 1 or croak 'usage: $nntp->last()';
  my $nntp = shift;

  $nntp->_LAST && $nntp->message =~ /(<[^>]+>)/o
    ? $1
    : undef;
}


sub list {
  @_ == 1 or croak 'usage: $nntp->list()';
  my $nntp = shift;

  $nntp->_LIST
    ? $nntp->_grouplist
    : undef;
}


sub newgroups {
  @_ >= 2 or croak 'usage: $nntp->newgroups( SINCE [, DISTRIBUTIONS ])';
  my $nntp = shift;
  my $time = _timestr(shift);
  my $dist = shift || "";

  $dist = join(",", @{$dist})
    if ref($dist);

  $nntp->_NEWGROUPS($time, $dist)
    ? $nntp->_grouplist
    : undef;
}


sub newnews {
  @_ >= 2 && @_ <= 4
    or croak 'usage: $nntp->newnews( SINCE [, GROUPS [, DISTRIBUTIONS ]])';
  my $nntp = shift;
  my $time = _timestr(shift);
  my $grp  = @_ ? shift: $nntp->group;
  my $dist = shift || "";

  $grp ||= "*";
  $grp = join(",", @{$grp})
    if ref($grp);

  $dist = join(",", @{$dist})
    if ref($dist);

  $nntp->_NEWNEWS($grp, $time, $dist)
    ? $nntp->_articlelist
    : undef;
}


sub next {
  @_ == 1 or croak 'usage: $nntp->next()';
  my $nntp = shift;

  $nntp->_NEXT && $nntp->message =~ /(<[^>]+>)/o
    ? $1
    : undef;
}


sub post {
  @_ >= 1 or croak 'usage: $nntp->post( [ MESSAGE ] )';
  my $nntp = shift;

  $nntp->_POST() && $nntp->datasend(@_)
    ? @_ == 0 || $nntp->dataend
    : undef;
}


sub postfh {
  my $nntp = shift;
  return unless $nntp->_POST();
  return $nntp->tied_fh;
}


sub quit {
  @_ == 1 or croak 'usage: $nntp->quit()';
  my $nntp = shift;

  $nntp->_QUIT;
  $nntp->close;
}


sub slave {
  @_ == 1 or croak 'usage: $nntp->slave()';
  my $nntp = shift;

  $nntp->_SLAVE;
}

##
## The following methods are not implemented by all servers
##


sub active {
  @_ == 1 || @_ == 2 or croak 'usage: $nntp->active( [ PATTERN ] )';
  my $nntp = shift;

  $nntp->_LIST('ACTIVE', @_)
    ? $nntp->_grouplist
    : undef;
}


sub active_times {
  @_ == 1 or croak 'usage: $nntp->active_times()';
  my $nntp = shift;

  $nntp->_LIST('ACTIVE.TIMES')
    ? $nntp->_grouplist
    : undef;
}


sub distributions {
  @_ == 1 or croak 'usage: $nntp->distributions()';
  my $nntp = shift;

  $nntp->_LIST('DISTRIBUTIONS')
    ? $nntp->_description
    : undef;
}


sub distribution_patterns {
  @_ == 1 or croak 'usage: $nntp->distributions()';
  my $nntp = shift;

  my $arr;
  local $_;

  ## no critic (ControlStructures::ProhibitMutatingListFunctions)
  $nntp->_LIST('DISTRIB.PATS')
    && ($arr = $nntp->read_until_dot)
    ? [grep { /^\d/ && (chomp, $_ = [split /:/]) } @$arr]
    : undef;
}


sub newsgroups {
  @_ == 1 || @_ == 2 or croak 'usage: $nntp->newsgroups( [ PATTERN ] )';
  my $nntp = shift;

  $nntp->_LIST('NEWSGROUPS', @_)
    ? $nntp->_description
    : undef;
}


sub overview_fmt {
  @_ == 1 or croak 'usage: $nntp->overview_fmt()';
  my $nntp = shift;

  $nntp->_LIST('OVERVIEW.FMT')
    ? $nntp->_articlelist
    : undef;
}


sub subscriptions {
  @_ == 1 or croak 'usage: $nntp->subscriptions()';
  my $nntp = shift;

  $nntp->_LIST('SUBSCRIPTIONS')
    ? $nntp->_articlelist
    : undef;
}


sub listgroup {
  @_ == 1 || @_ == 2 or croak 'usage: $nntp->listgroup( [ GROUP ] )';
  my $nntp = shift;

  $nntp->_LISTGROUP(@_)
    ? $nntp->_articlelist
    : undef;
}


sub reader {
  @_ == 1 or croak 'usage: $nntp->reader()';
  my $nntp = shift;

  $nntp->_MODE('READER');
}


sub xgtitle {
  @_ == 1 || @_ == 2 or croak 'usage: $nntp->xgtitle( [ PATTERN ] )';
  my $nntp = shift;

  $nntp->_XGTITLE(@_)
    ? $nntp->_description
    : undef;
}


sub xhdr {
  @_ >= 2 && @_ <= 4 or croak 'usage: $nntp->xhdr( HEADER, [ MESSAGE-SPEC ] )';
  my $nntp = shift;
  my $hdr  = shift;
  my $arg  = _msg_arg(@_);

  $nntp->_XHDR($hdr, $arg)
    ? $nntp->_description
    : undef;
}


sub xover {
  @_ == 2 || @_ == 3 or croak 'usage: $nntp->xover( MESSAGE-SPEC )';
  my $nntp = shift;
  my $arg  = _msg_arg(@_);

  $nntp->_XOVER($arg)
    ? $nntp->_fieldlist
    : undef;
}


sub xpat {
  @_ == 4 || @_ == 5 or croak '$nntp->xpat( HEADER, PATTERN, MESSAGE-SPEC )';
  my $nntp = shift;
  my $hdr  = shift;
  my $pat  = shift;
  my $arg  = _msg_arg(@_);

  $pat = join(" ", @$pat)
    if ref($pat);

  $nntp->_XPAT($hdr, $arg, $pat)
    ? $nntp->_description
    : undef;
}


sub xpath {
  @_ == 2 or croak 'usage: $nntp->xpath( MESSAGE-ID )';
  my ($nntp, $mid) = @_;

  return
    unless $nntp->_XPATH($mid);

  my $m;
  ($m = $nntp->message) =~ s/^\d+\s+//o;
  my @p = split /\s+/, $m;

  wantarray ? @p : $p[0];
}


sub xrover {
  @_ == 2 || @_ == 3 or croak 'usage: $nntp->xrover( MESSAGE-SPEC )';
  my $nntp = shift;
  my $arg  = _msg_arg(@_);

  $nntp->_XROVER($arg)
    ? $nntp->_description
    : undef;
}


sub date {
  @_ == 1 or croak 'usage: $nntp->date()';
  my $nntp = shift;

  $nntp->_DATE
    && $nntp->message =~ /(\d{4})(\d\d)(\d\d)(\d\d)(\d\d)(\d\d)/
    ? timegm($6, $5, $4, $3, $2 - 1, $1 - 1900)
    : undef;
}


##
## Private subroutines
##


sub _msg_arg {
  my $spec = shift;
  my $arg  = "";

  if (@_) {
    carp "Depriciated passing of two message numbers, " . "pass a reference"
      if $^W;
    $spec = [$spec, $_[0]];
  }

  if (defined $spec) {
    if (ref($spec)) {
      $arg = $spec->[0];
      if (defined $spec->[1]) {
        $arg .= "-"
          if $spec->[1] != $spec->[0];
        $arg .= $spec->[1]
          if $spec->[1] > $spec->[0];
      }
    }
    else {
      $arg = $spec;
    }
  }

  $arg;
}


sub _timestr {
  my $time = shift;
  my @g    = reverse((gmtime($time))[0 .. 5]);
  $g[1] += 1;
  $g[0] %= 100;
  sprintf "%02d%02d%02d %02d%02d%02d GMT", @g;
}


sub _grouplist {
  my $nntp = shift;
  my $arr  = $nntp->read_until_dot
    or return;

  my $hash = {};

  foreach my $ln (@$arr) {
    my @a = split(/[\s\n]+/, $ln);
    $hash->{$a[0]} = [@a[1, 2, 3]];
  }

  $hash;
}


sub _fieldlist {
  my $nntp = shift;
  my $arr  = $nntp->read_until_dot
    or return;

  my $hash = {};

  foreach my $ln (@$arr) {
    my @a = split(/[\t\n]/, $ln);
    my $m = shift @a;
    $hash->{$m} = [@a];
  }

  $hash;
}


sub _articlelist {
  my $nntp = shift;
  my $arr  = $nntp->read_until_dot;

  chomp(@$arr)
    if $arr;

  $arr;
}


sub _description {
  my $nntp = shift;
  my $arr  = $nntp->read_until_dot
    or return;

  my $hash = {};

  foreach my $ln (@$arr) {
    chomp($ln);

    $hash->{$1} = $ln
      if $ln =~ s/^\s*(\S+)\s*//o;
  }

  $hash;

}

##
## The commands
##


sub _ARTICLE  { shift->command('ARTICLE',  @_)->response == CMD_OK }
sub _AUTHINFO { shift->command('AUTHINFO', @_)->response }
sub _BODY     { shift->command('BODY',     @_)->response == CMD_OK }
sub _DATE      { shift->command('DATE')->response == CMD_INFO }
sub _GROUP     { shift->command('GROUP', @_)->response == CMD_OK }
sub _HEAD      { shift->command('HEAD', @_)->response == CMD_OK }
sub _HELP      { shift->command('HELP', @_)->response == CMD_INFO }
sub _IHAVE     { shift->command('IHAVE', @_)->response == CMD_MORE }
sub _LAST      { shift->command('LAST')->response == CMD_OK }
sub _LIST      { shift->command('LIST', @_)->response == CMD_OK }
sub _LISTGROUP { shift->command('LISTGROUP', @_)->response == CMD_OK }
sub _NEWGROUPS { shift->command('NEWGROUPS', @_)->response == CMD_OK }
sub _NEWNEWS   { shift->command('NEWNEWS', @_)->response == CMD_OK }
sub _NEXT      { shift->command('NEXT')->response == CMD_OK }
sub _POST      { shift->command('POST', @_)->response == CMD_MORE }
sub _QUIT      { shift->command('QUIT', @_)->response == CMD_OK }
sub _SLAVE     { shift->command('SLAVE', @_)->response == CMD_OK }
sub _STARTTLS  { shift->command("STARTTLS")->response() == CMD_MORE }
sub _STAT      { shift->command('STAT', @_)->response == CMD_OK }
sub _MODE      { shift->command('MODE', @_)->response == CMD_OK }
sub _XGTITLE   { shift->command('XGTITLE', @_)->response == CMD_OK }
sub _XHDR      { shift->command('XHDR', @_)->response == CMD_OK }
sub _XPAT      { shift->command('XPAT', @_)->response == CMD_OK }
sub _XPATH     { shift->command('XPATH', @_)->response == CMD_OK }
sub _XOVER     { shift->command('XOVER', @_)->response == CMD_OK }
sub _XROVER    { shift->command('XROVER', @_)->response == CMD_OK }
sub _XTHREAD   { shift->unsupported }
sub _XSEARCH   { shift->unsupported }
sub _XINDEX    { shift->unsupported }

##
## IO/perl methods
##


sub DESTROY {
  my $nntp = shift;
  defined(fileno($nntp)) && $nntp->quit;
}

{
  package Net::NNTP::_SSL;
  our @ISA = ( $ssl_class ? ($ssl_class):(), 'Net::NNTP' );
  sub starttls { die "NNTP connection is already in SSL mode" }
  sub start_SSL {
    my ($class,$nntp,%arg) = @_;
    delete @arg{ grep { !m{^SSL_} } keys %arg };
    ( $arg{SSL_verifycn_name} ||= $nntp->host )
        =~s{(?<!:):[\w()]+$}{}; # strip port
    $arg{SSL_hostname} = $arg{SSL_verifycn_name}
        if ! defined $arg{SSL_hostname} && $class->can_client_sni;
    my $ok = $class->SUPER::start_SSL($nntp,
      SSL_verifycn_scheme => 'nntp',
      %arg
    );
    $@ = $ssl_class->errstr if !$ok;
    return $ok;
  }
}




1;

__END__

=head1 NAME

Net::NNTP - NNTP Client class

=head1 SYNOPSIS

    use Net::NNTP;

    $nntp = Net::NNTP->new("some.host.name");
    $nntp->quit;

    # start with SSL, e.g. nntps
    $nntp = Net::NNTP->new("some.host.name", SSL => 1);

    # start with plain and upgrade to SSL
    $nntp = Net::NNTP->new("some.host.name");
    $nntp->starttls;


=head1 DESCRIPTION

C<Net::NNTP> is a class implementing a simple NNTP client in Perl as described
in RFC977 and RFC4642.
With L<IO::Socket::SSL> installed it also provides support for implicit and
explicit TLS encryption, i.e. NNTPS or NNTP+STARTTLS.

The Net::NNTP class is a subclass of Net::Cmd and (depending on avaibility) of
IO::Socket::IP, IO::Socket::INET6 or IO::Socket::INET.

=head1 CONSTRUCTOR

=over 4

=item new ( [ HOST ] [, OPTIONS ])

This is the constructor for a new Net::NNTP object. C<HOST> is the
name of the remote host to which a NNTP connection is required. If not
given then it may be passed as the C<Host> option described below. If no host is passed
then two environment variables are checked, first C<NNTPSERVER> then
C<NEWSHOST>, then C<Net::Config> is checked, and if a host is not found
then C<news> is used.

C<OPTIONS> are passed in a hash like fashion, using key and value pairs.
Possible options are:

B<Host> - NNTP host to connect to. It may be a single scalar, as defined for
the C<PeerAddr> option in L<IO::Socket::INET>, or a reference to
an array with hosts to try in turn. The L</host> method will return the value
which was used to connect to the host.

B<Port> - port to connect to.
Default - 119 for plain NNTP and 563 for immediate SSL (nntps).

B<SSL> - If the connection should be done from start with SSL, contrary to later
upgrade with C<starttls>.
You can use SSL arguments as documented in L<IO::Socket::SSL>, but it will
usually use the right arguments already.

B<Timeout> - Maximum time, in seconds, to wait for a response from the
NNTP server, a value of zero will cause all IO operations to block.
(default: 120)

B<Debug> - Enable the printing of debugging information to STDERR

B<Reader> - If the remote server is INN then initially the connection
will be to innd, by default C<Net::NNTP> will issue a C<MODE READER> command
so that the remote server becomes nnrpd. If the C<Reader> option is given
with a value of zero, then this command will not be sent and the
connection will be left talking to innd.

B<LocalAddr> and B<LocalPort> - These parameters are passed directly
to IO::Socket to allow binding the socket to a specific local address and port.

B<Domain> - This parameter is passed directly to IO::Socket and makes it
possible to enforce IPv4 connections even if L<IO::Socket::IP> is used as super
class. Alternatively B<Family> can be used.

=back

=head1 METHODS

Unless otherwise stated all methods return either a I<true> or I<false>
value, with I<true> meaning that the operation was a success. When a method
states that it returns a value, failure will be returned as I<undef> or an
empty list.

C<Net::NNTP> inherits from C<Net::Cmd> so methods defined in C<Net::Cmd> may
be used to send commands to the remote NNTP server in addition to the methods
documented here.

=over 4

=item host ()

Returns the value used by the constructor, and passed to IO::Socket::INET,
to connect to the host.

=item starttls ()

Upgrade existing plain connection to SSL.
Any arguments necessary for SSL must be given in C<new> already.

=item article ( [ MSGID|MSGNUM ], [FH] )

Retrieve the header, a blank line, then the body (text) of the
specified article. 

If C<FH> is specified then it is expected to be a valid filehandle
and the result will be printed to it, on success a true value will be
returned. If C<FH> is not specified then the return value, on success,
will be a reference to an array containing the article requested, each
entry in the array will contain one line of the article.

If no arguments are passed then the current article in the currently
selected newsgroup is fetched.

C<MSGNUM> is a numeric id of an article in the current newsgroup, and
will change the current article pointer.  C<MSGID> is the message id of
an article as shown in that article's header.  It is anticipated that the
client will obtain the C<MSGID> from a list provided by the C<newnews>
command, from references contained within another article, or from the
message-id provided in the response to some other commands.

If there is an error then C<undef> will be returned.

=item body ( [ MSGID|MSGNUM ], [FH] )

Like C<article> but only fetches the body of the article.

=item head ( [ MSGID|MSGNUM ], [FH] )

Like C<article> but only fetches the headers for the article.

=item articlefh ( [ MSGID|MSGNUM ] )

=item bodyfh ( [ MSGID|MSGNUM ] )

=item headfh ( [ MSGID|MSGNUM ] )

These are similar to article(), body() and head(), but rather than
returning the requested data directly, they return a tied filehandle
from which to read the article.

=item nntpstat ( [ MSGID|MSGNUM ] )

The C<nntpstat> command is similar to the C<article> command except that no
text is returned.  When selecting by message number within a group,
the C<nntpstat> command serves to set the "current article pointer" without
sending text.

Using the C<nntpstat> command to
select by message-id is valid but of questionable value, since a
selection by message-id does B<not> alter the "current article pointer".

Returns the message-id of the "current article".

=item group ( [ GROUP ] )

Set and/or get the current group. If C<GROUP> is not given then information
is returned on the current group.

In a scalar context it returns the group name.

In an array context the return value is a list containing, the number
of articles in the group, the number of the first article, the number
of the last article and the group name.

=item help ( )

Request help text (a short summary of commands that are understood by this
implementation) from the server. Returns the text or undef upon failure.

=item ihave ( MSGID [, MESSAGE ])

The C<ihave> command informs the server that the client has an article
whose id is C<MSGID>.  If the server desires a copy of that
article and C<MESSAGE> has been given then it will be sent.

Returns I<true> if the server desires the article and C<MESSAGE> was
successfully sent, if specified.

If C<MESSAGE> is not specified then the message must be sent using the
C<datasend> and C<dataend> methods from L<Net::Cmd>

C<MESSAGE> can be either an array of lines or a reference to an array
and must be encoded by the caller to octets of whatever encoding is required,
e.g. by using the Encode module's C<encode()> function.

=item last ()

Set the "current article pointer" to the previous article in the current
newsgroup.

Returns the message-id of the article.

=item date ()

Returns the date on the remote server. This date will be in a UNIX time
format (seconds since 1970)

=item postok ()

C<postok> will return I<true> if the servers initial response indicated
that it will allow posting.

=item authinfo ( USER, PASS )

Authenticates to the server (using the original AUTHINFO USER / AUTHINFO PASS
form, defined in RFC2980) using the supplied username and password.  Please
note that the password is sent in clear text to the server.  This command
should not be used with valuable passwords unless the connection to the server
is somehow protected.

=item authinfo_simple ( USER, PASS )

Authenticates to the server (using the proposed NNTP V2 AUTHINFO SIMPLE form,
defined and deprecated in RFC2980) using the supplied username and password.
As with L</authinfo> the password is sent in clear text.

=item list ()

Obtain information about all the active newsgroups. The results is a reference
to a hash where the key is a group name and each value is a reference to an
array. The elements in this array are:- the last article number in the group,
the first article number in the group and any information flags about the group.

=item newgroups ( SINCE [, DISTRIBUTIONS ])

C<SINCE> is a time value and C<DISTRIBUTIONS> is either a distribution
pattern or a reference to a list of distribution patterns.
The result is the same as C<list>, but the
groups return will be limited to those created after C<SINCE> and, if
specified, in one of the distribution areas in C<DISTRIBUTIONS>. 

=item newnews ( SINCE [, GROUPS [, DISTRIBUTIONS ]])

C<SINCE> is a time value. C<GROUPS> is either a group pattern or a reference
to a list of group patterns. C<DISTRIBUTIONS> is either a distribution
pattern or a reference to a list of distribution patterns.

Returns a reference to a list which contains the message-ids of all news posted
after C<SINCE>, that are in a groups which matched C<GROUPS> and a
distribution which matches C<DISTRIBUTIONS>.

=item next ()

Set the "current article pointer" to the next article in the current
newsgroup.

Returns the message-id of the article.

=item post ( [ MESSAGE ] )

Post a new article to the news server. If C<MESSAGE> is specified and posting
is allowed then the message will be sent.

If C<MESSAGE> is not specified then the message must be sent using the
C<datasend> and C<dataend> methods from L<Net::Cmd>

C<MESSAGE> can be either an array of lines or a reference to an array
and must be encoded by the caller to octets of whatever encoding is required,
e.g. by using the Encode module's C<encode()> function.

The message, either sent via C<datasend> or as the C<MESSAGE>
parameter, must be in the format as described by RFC822 and must
contain From:, Newsgroups: and Subject: headers.

=item postfh ()

Post a new article to the news server using a tied filehandle.  If
posting is allowed, this method will return a tied filehandle that you
can print() the contents of the article to be posted.  You must
explicitly close() the filehandle when you are finished posting the
article, and the return value from the close() call will indicate
whether the message was successfully posted.

=item slave ()

Tell the remote server that I am not a user client, but probably another
news server.

=item quit ()

Quit the remote server and close the socket connection.

=item can_inet6 ()

Returns whether we can use IPv6.

=item can_ssl ()

Returns whether we can use SSL.

=back

=head2 Extension methods

These methods use commands that are not part of the RFC977 documentation. Some
servers may not support all of them.

=over 4

=item newsgroups ( [ PATTERN ] )

Returns a reference to a hash where the keys are all the group names which
match C<PATTERN>, or all of the groups if no pattern is specified, and
each value contains the description text for the group.

=item distributions ()

Returns a reference to a hash where the keys are all the possible
distribution names and the values are the distribution descriptions.

=item distribution_patterns ()

Returns a reference to an array where each element, itself an array
reference, consists of the three fields of a line of the distrib.pats list
maintained by some NNTP servers, namely: a weight, a wildmat and a value
which the client may use to construct a Distribution header.

=item subscriptions ()

Returns a reference to a list which contains a list of groups which
are recommended for a new user to subscribe to.

=item overview_fmt ()

Returns a reference to an array which contain the names of the fields returned
by C<xover>.

=item active_times ()

Returns a reference to a hash where the keys are the group names and each
value is a reference to an array containing the time the groups was created
and an identifier, possibly an Email address, of the creator.

=item active ( [ PATTERN ] )

Similar to C<list> but only active groups that match the pattern are returned.
C<PATTERN> can be a group pattern.

=item xgtitle ( PATTERN )

Returns a reference to a hash where the keys are all the group names which
match C<PATTERN> and each value is the description text for the group.

=item xhdr ( HEADER, MESSAGE-SPEC )

Obtain the header field C<HEADER> for all the messages specified. 

The return value will be a reference
to a hash where the keys are the message numbers and each value contains
the text of the requested header for that message.

=item xover ( MESSAGE-SPEC )

The return value will be a reference
to a hash where the keys are the message numbers and each value contains
a reference to an array which contains the overview fields for that
message.

The names of the fields can be obtained by calling C<overview_fmt>.

=item xpath ( MESSAGE-ID )

Returns the path name to the file on the server which contains the specified
message.

=item xpat ( HEADER, PATTERN, MESSAGE-SPEC)

The result is the same as C<xhdr> except the is will be restricted to
headers where the text of the header matches C<PATTERN>

=item xrover ()

The XROVER command returns reference information for the article(s)
specified.

Returns a reference to a HASH where the keys are the message numbers and the
values are the References: lines from the articles

=item listgroup ( [ GROUP ] )

Returns a reference to a list of all the active messages in C<GROUP>, or
the current group if C<GROUP> is not specified.

=item reader ()

Tell the server that you are a reader and not another server.

This is required by some servers. For example if you are connecting to
an INN server and you have transfer permission your connection will
be connected to the transfer daemon, not the NNTP daemon. Issuing
this command will cause the transfer daemon to hand over control
to the NNTP daemon.

Some servers do not understand this command, but issuing it and ignoring
the response is harmless.

=back

=head1 UNSUPPORTED

The following NNTP command are unsupported by the package, and there are
no plans to do so.

    AUTHINFO GENERIC
    XTHREAD
    XSEARCH
    XINDEX

=head1 DEFINITIONS

=over 4

=item MESSAGE-SPEC

C<MESSAGE-SPEC> is either a single message-id, a single message number, or
a reference to a list of two message numbers.

If C<MESSAGE-SPEC> is a reference to a list of two message numbers and the
second number in a range is less than or equal to the first then the range
represents all messages in the group after the first message number.

B<NOTE> For compatibility reasons only with earlier versions of Net::NNTP
a message spec can be passed as a list of two numbers, this is deprecated
and a reference to the list should now be passed

=item PATTERN

The C<NNTP> protocol uses the C<WILDMAT> format for patterns.
The WILDMAT format was first developed by Rich Salz based on
the format used in the UNIX "find" command to articulate
file names. It was developed to provide a uniform mechanism
for matching patterns in the same manner that the UNIX shell
matches filenames.

Patterns are implicitly anchored at the
beginning and end of each string when testing for a match.

There are five pattern matching operations other than a strict
one-to-one match between the pattern and the source to be
checked for a match.

The first is an asterisk C<*> to match any sequence of zero or more
characters.

The second is a question mark C<?> to match any single character. The
third specifies a specific set of characters.

The set is specified as a list of characters, or as a range of characters
where the beginning and end of the range are separated by a minus (or dash)
character, or as any combination of lists and ranges. The dash can
also be included in the set as a character it if is the beginning
or end of the set. This set is enclosed in square brackets. The
close square bracket C<]> may be used in a set if it is the first
character in the set.

The fourth operation is the same as the
logical not of the third operation and is specified the same
way as the third with the addition of a caret character C<^> at
the beginning of the test string just inside the open square
bracket.

The final operation uses the backslash character to
invalidate the special meaning of an open square bracket C<[>,
the asterisk, backslash or the question mark. Two backslashes in
sequence will result in the evaluation of the backslash as a
character with no special meaning.

=over 4

=item Examples

=item C<[^]-]>

matches any single character other than a close square
bracket or a minus sign/dash.

=item C<*bdc>

matches any string that ends with the string "bdc"
including the string "bdc" (without quotes).

=item C<[0-9a-zA-Z]>

matches any single printable alphanumeric ASCII character.

=item C<a??d>

matches any four character string which begins
with a and ends with d.

=back

=back

=head1 SEE ALSO

L<Net::Cmd>,
L<IO::Socket::SSL>

=head1 AUTHOR

Graham Barr E<lt>F<gbarr@pobox.com>E<gt>

Steve Hay E<lt>F<shay@cpan.org>E<gt> is now maintaining libnet as of version
1.22_02

=head1 COPYRIGHT

Versions up to 2.24_1 Copyright (c) 1995-1997 Graham Barr. All rights reserved.
Changes in Version 2.25 onwards Copyright (C) 2013-2015 Steve Hay.  All rights
reserved.

This module is free software; you can redistribute it and/or modify it under the
same terms as Perl itself, i.e. under the terms of either the GNU General Public
License or the Artistic License, as specified in the F<LICENCE> file.

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                # Net::Netrc.pm
#
# Versions up to 2.13 Copyright (c) 1995-1998 Graham Barr <gbarr@pobox.com>.
# All rights reserved.
# Changes in Version 2.13_01 onwards Copyright (C) 2013-2014 Steve Hay.  All
# rights reserved.
# This module is free software; you can redistribute it and/or modify it under
# the same terms as Perl itself, i.e. under the terms of either the GNU General
# Public License or the Artistic License, as specified in the F<LICENCE> file.

package Net::Netrc;

use 5.008001;

use strict;
use warnings;

use Carp;
use FileHandle;

our $VERSION = "3.08_01";

our $TESTING;

my %netrc = ();

sub _readrc {
  my($class, $host) = @_;
  my ($home, $file);

  if ($^O eq "MacOS") {
    $home = $ENV{HOME} || `pwd`;
    chomp($home);
    $file = ($home =~ /:$/ ? $home . "netrc" : $home . ":netrc");
  }
  else {

    # Some OS's don't have "getpwuid", so we default to $ENV{HOME}
    $home = eval { (getpwuid($>))[7] } || $ENV{HOME};
    $home ||= $ENV{HOMEDRIVE} . ($ENV{HOMEPATH} || '') if defined $ENV{HOMEDRIVE};
    if (-e $home . "/.netrc") {
      $file = $home . "/.netrc";
    }
    elsif (-e $home . "/_netrc") {
      $file = $home . "/_netrc";
    }
    else {
      return unless $TESTING;
    }
  }

  my ($login, $pass, $acct) = (undef, undef, undef);
  my $fh;
  local $_;

  $netrc{default} = undef;

  # OS/2 and Win32 do not handle stat in a way compatible with this check :-(
  unless ($^O eq 'os2'
    || $^O eq 'MSWin32'
    || $^O eq 'MacOS'
    || $^O =~ /^cygwin/)
  {
    my @stat = stat($file);

    if (@stat) {
      if ($stat[2] & 077) { ## no critic (ValuesAndExpressions::ProhibitLeadingZeros)
        carp "Bad permissions: $file";
        return;
      }
      if ($stat[4] != $<) {
        carp "Not owner: $file";
        return;
      }
    }
  }

  if ($fh = FileHandle->new($file, "r")) {
    my ($mach, $macdef, $tok, @tok) = (0, 0);

    while (<$fh>) {
      undef $macdef if /\A\n\Z/;

      if ($macdef) {
        push(@$macdef, $_);
        next;
      }

      s/^\s*//;
      chomp;

      while (length && s/^("((?:[^"]+|\\.)*)"|((?:[^\\\s]+|\\.)*))\s*//) {
        (my $tok = $+) =~ s/\\(.)/$1/g;
        push(@tok, $tok);
      }

    TOKEN:
      while (@tok) {
        if ($tok[0] eq "default") {
          shift(@tok);
          $mach = bless {}, $class;
          $netrc{default} = [$mach];

          next TOKEN;
        }

        last TOKEN
          unless @tok > 1;

        $tok = shift(@tok);

        if ($tok eq "machine") {
          my $host = shift @tok;
          $mach = bless {machine => $host}, $class;

          $netrc{$host} = []
            unless exists($netrc{$host});
          push(@{$netrc{$host}}, $mach);
        }
        elsif ($tok =~ /^(login|password|account)$/) {
          next TOKEN unless $mach;
          my $value = shift @tok;

          # Following line added by rmerrell to remove '/' escape char in .netrc
          $value =~ s/\/\\/\\/g;
          $mach->{$1} = $value;
        }
        elsif ($tok eq "macdef") {
          next TOKEN unless $mach;
          my $value = shift @tok;
          $mach->{macdef} = {}
            unless exists $mach->{macdef};
          $macdef = $mach->{machdef}{$value} = [];
        }
      }
    }
    $fh->close();
  }
}


sub lookup {
  my ($class, $mach, $login) = @_;

  $class->_readrc()
    unless exists $netrc{default};

  $mach ||= 'default';
  undef $login
    if $mach eq 'default';

  if (exists $netrc{$mach}) {
    if (defined $login) {
      foreach my $m (@{$netrc{$mach}}) {
        return $m
          if (exists $m->{login} && $m->{login} eq $login);
      }
      return;
    }
    return $netrc{$mach}->[0];
  }

  return $netrc{default}->[0]
    if defined $netrc{default};

  return;
}


sub login {
  my $me = shift;

  exists $me->{login}
    ? $me->{login}
    : undef;
}


sub account {
  my $me = shift;

  exists $me->{account}
    ? $me->{account}
    : undef;
}


sub password {
  my $me = shift;

  exists $me->{password}
    ? $me->{password}
    : undef;
}


sub lpa {
  my $me = shift;
  ($me->login, $me->password, $me->account);
}

1;

__END__

=head1 NAME

Net::Netrc - OO interface to users netrc file

=head1 SYNOPSIS

    use Net::Netrc;

    $mach = Net::Netrc->lookup('some.machine');
    $login = $mach->login;
    ($login, $password, $account) = $mach->lpa;

=head1 DESCRIPTION

C<Net::Netrc> is a class implementing a simple interface to the .netrc file
used as by the ftp program.

C<Net::Netrc> also implements security checks just like the ftp program,
these checks are, first that the .netrc file must be owned by the user and 
second the ownership permissions should be such that only the owner has
read and write access. If these conditions are not met then a warning is
output and the .netrc file is not read.

=head1 THE .netrc FILE

The .netrc file contains login and initialization information used by the
auto-login process.  It resides in the user's home directory.  The following
tokens are recognized; they may be separated by spaces, tabs, or new-lines:

=over 4

=item machine name

Identify a remote machine name. The auto-login process searches
the .netrc file for a machine token that matches the remote machine
specified.  Once a match is made, the subsequent .netrc tokens
are processed, stopping when the end of file is reached or an-
other machine or a default token is encountered.

=item default

This is the same as machine name except that default matches
any name.  There can be only one default token, and it must be
after all machine tokens.  This is normally used as:

    default login anonymous password user@site

thereby giving the user automatic anonymous login to machines
not specified in .netrc.

=item login name

Identify a user on the remote machine.  If this token is present,
the auto-login process will initiate a login using the
specified name.

=item password string

Supply a password.  If this token is present, the auto-login
process will supply the specified string if the remote server
requires a password as part of the login process.

=item account string

Supply an additional account password.  If this token is present,
the auto-login process will supply the specified string
if the remote server requires an additional account password.

=item macdef name

Define a macro. C<Net::Netrc> only parses this field to be compatible
with I<ftp>.

=back

=head1 CONSTRUCTOR

The constructor for a C<Net::Netrc> object is not called new as it does not
really create a new object. But instead is called C<lookup> as this is
essentially what it does.

=over 4

=item lookup ( MACHINE [, LOGIN ])

Lookup and return a reference to the entry for C<MACHINE>. If C<LOGIN> is given
then the entry returned will have the given login. If C<LOGIN> is not given then
the first entry in the .netrc file for C<MACHINE> will be returned.

If a matching entry cannot be found, and a default entry exists, then a
reference to the default entry is returned.

If there is no matching entry found and there is no default defined, or
no .netrc file is found, then C<undef> is returned.

=back

=head1 METHODS

=over 4

=item login ()

Return the login id for the netrc entry

=item password ()

Return the password for the netrc entry

=item account ()

Return the account information for the netrc entry

=item lpa ()

Return a list of login, password and account information for the netrc entry

=back

=head1 AUTHOR

Graham Barr E<lt>F<gbarr@pobox.com>E<gt>

Steve Hay E<lt>F<shay@cpan.org>E<gt> is now maintaining libnet as of version
1.22_02

=head1 SEE ALSO

L<Net::Netrc>,
L<Net::Cmd>

=head1 COPYRIGHT

Versions up to 2.13 Copyright (c) 1995-1998 Graham Barr. All rights reserved.
Changes in Version 2.13_01 onwards Copyright (C) 2013-2014 Steve Hay.  All
rights reserved.

This module is free software; you can redistribute it and/or modify it under the
same terms as Perl itself, i.e. under the terms of either the GNU General Public
License or the Artistic License, as specified in the F<LICENCE> file.

=cut
                                                                                                                                                              # Net::POP3.pm
#
# Versions up to 2.29 Copyright (c) 1995-2004 Graham Barr <gbarr@pobox.com>.
# All rights reserved.
# Changes in Version 2.29_01 onwards Copyright (C) 2013-2015 Steve Hay.  All
# rights reserved.
# This module is free software; you can redistribute it and/or modify it under
# the same terms as Perl itself, i.e. under the terms of either the GNU General
# Public License or the Artistic License, as specified in the F<LICENCE> file.

package Net::POP3;

use 5.008001;

use strict;
use warnings;

use Carp;
use IO::Socket;
use Net::Cmd;
use Net::Config;

our $VERSION = "3.08_01";

# Code for detecting if we can use SSL
my $ssl_class = eval {
  require IO::Socket::SSL;
  # first version with default CA on most platforms
  no warnings 'numeric';
  IO::Socket::SSL->VERSION(2.007);
} && 'IO::Socket::SSL';

my $nossl_warn = !$ssl_class &&
  'To use SSL please install IO::Socket::SSL with version>=2.007';

# Code for detecting if we can use IPv6
my $family_key = 'Domain';
my $inet6_class = eval {
  require IO::Socket::IP;
  no warnings 'numeric';
  IO::Socket::IP->VERSION(0.20) || die;
  $family_key = 'Family';
} && 'IO::Socket::IP' || eval {
  require IO::Socket::INET6;
  no warnings 'numeric';
  IO::Socket::INET6->VERSION(2.62);
} && 'IO::Socket::INET6';


sub can_ssl   { $ssl_class };
sub can_inet6 { $inet6_class };

our @ISA = ('Net::Cmd', $inet6_class || 'IO::Socket::INET');

sub new {
  my $self = shift;
  my $type = ref($self) || $self;
  my ($host, %arg);
  if (@_ % 2) {
    $host = shift;
    %arg  = @_;
  }
  else {
    %arg  = @_;
    $host = delete $arg{Host};
  }
  my $hosts = defined $host ? [$host] : $NetConfig{pop3_hosts};
  my $obj;

  if ($arg{SSL}) {
    # SSL from start
    die $nossl_warn if !$ssl_class;
    $arg{Port} ||= 995;
  }

  $arg{Timeout} = 120 if ! defined $arg{Timeout};

  foreach my $h (@{$hosts}) {
    $obj = $type->SUPER::new(
      PeerAddr => ($host = $h),
      PeerPort => $arg{Port} || 'pop3(110)',
      Proto => 'tcp',
      $family_key => $arg{Domain} || $arg{Family},
      LocalAddr => $arg{LocalAddr},
      LocalPort => exists($arg{ResvPort}) ? $arg{ResvPort} : $arg{LocalPort},
      Timeout => $arg{Timeout},
      )
      and last;
  }

  return
    unless defined $obj;

  ${*$obj}{'net_pop3_arg'} = \%arg;
  ${*$obj}{'net_pop3_host'} = $host;
  if ($arg{SSL}) {
    Net::POP3::_SSL->start_SSL($obj,%arg) or return;
  }

  $obj->autoflush(1);
  $obj->debug(exists $arg{Debug} ? $arg{Debug} : undef);

  unless ($obj->response() == CMD_OK) {
    $obj->close();
    return;
  }

  ${*$obj}{'net_pop3_banner'} = $obj->message;

  $obj;
}


sub host {
  my $me = shift;
  ${*$me}{'net_pop3_host'};
}

##
## We don't want people sending me their passwords when they report problems
## now do we :-)
##


sub debug_text { $_[2] =~ /^(pass|rpop)/i ? "$1 ....\n" : $_[2]; }


sub login {
  @_ >= 1 && @_ <= 3 or croak 'usage: $pop3->login( USER, PASS )';
  my ($me, $user, $pass) = @_;

  if (@_ <= 2) {
    ($user, $pass) = $me->_lookup_credentials($user);
  }

  $me->user($user)
    and $me->pass($pass);
}

sub starttls {
  my $self = shift;
  $ssl_class or die $nossl_warn;
  $self->_STLS or return;
  Net::POP3::_SSL->start_SSL($self,
    %{ ${*$self}{'net_pop3_arg'} }, # (ssl) args given in new
    @_   # more (ssl) args
  ) or return;
  return 1;
}

sub apop {
  @_ >= 1 && @_ <= 3 or croak 'usage: $pop3->apop( USER, PASS )';
  my ($me, $user, $pass) = @_;
  my $banner;
  my $md;

  if (eval { local $SIG{__DIE__}; require Digest::MD5 }) {
    $md = Digest::MD5->new();
  }
  elsif (eval { local $SIG{__DIE__}; require MD5 }) {
    $md = MD5->new();
  }
  else {
    carp "You need to install Digest::MD5 or MD5 to use the APOP command";
    return;
  }

  return
    unless ($banner = (${*$me}{'net_pop3_banner'} =~ /(<.*>)/)[0]);

  if (@_ <= 2) {
    ($user, $pass) = $me->_lookup_credentials($user);
  }

  $md->add($banner, $pass);

  return
    unless ($me->_APOP($user, $md->hexdigest));

  $me->_get_mailbox_count();
}


sub user {
  @_ == 2 or croak 'usage: $pop3->user( USER )';
  $_[0]->_USER($_[1]) ? 1 : undef;
}


sub pass {
  @_ == 2 or croak 'usage: $pop3->pass( PASS )';

  my ($me, $pass) = @_;

  return
    unless ($me->_PASS($pass));

  $me->_get_mailbox_count();
}


sub reset {
  @_ == 1 or croak 'usage: $obj->reset()';

  my $me = shift;

  return 0
    unless ($me->_RSET);

  if (defined ${*$me}{'net_pop3_mail'}) {
    local $_;
    foreach (@{${*$me}{'net_pop3_mail'}}) {
      delete $_->{'net_pop3_deleted'};
    }
  }
}


sub last {
  @_ == 1 or croak 'usage: $obj->last()';

  return
    unless $_[0]->_LAST && $_[0]->message =~ /(\d+)/;

  return $1;
}


sub top {
  @_ == 2 || @_ == 3 or croak 'usage: $pop3->top( MSGNUM [, NUMLINES ])';
  my $me = shift;

  return
    unless $me->_TOP($_[0], $_[1] || 0);

  $me->read_until_dot;
}


sub popstat {
  @_ == 1 or croak 'usage: $pop3->popstat()';
  my $me = shift;

  return ()
    unless $me->_STAT && $me->message =~ /(\d+)\D+(\d+)/;

  ($1 || 0, $2 || 0);
}


sub list {
  @_ == 1 || @_ == 2 or croak 'usage: $pop3->list( [ MSGNUM ] )';
  my $me = shift;

  return
    unless $me->_LIST(@_);

  if (@_) {
    $me->message =~ /\d+\D+(\d+)/;
    return $1 || undef;
  }

  my $info = $me->read_until_dot
    or return;

  my %hash = map { (/(\d+)\D+(\d+)/) } @$info;

  return \%hash;
}


sub get {
  @_ == 2 or @_ == 3 or croak 'usage: $pop3->get( MSGNUM [, FH ])';
  my $me = shift;

  return
    unless $me->_RETR(shift);

  $me->read_until_dot(@_);
}


sub getfh {
  @_ == 2 or croak 'usage: $pop3->getfh( MSGNUM )';
  my $me = shift;

  return unless $me->_RETR(shift);
  return $me->tied_fh;
}


sub delete {
  @_ == 2 or croak 'usage: $pop3->delete( MSGNUM )';
  my $me = shift;
  return 0 unless $me->_DELE(@_);
  ${*$me}{'net_pop3_deleted'} = 1;
}


sub uidl {
  @_ == 1 || @_ == 2 or croak 'usage: $pop3->uidl( [ MSGNUM ] )';
  my $me = shift;
  my $uidl;

  $me->_UIDL(@_)
    or return;
  if (@_) {
    $uidl = ($me->message =~ /\d+\s+([\041-\176]+)/)[0];
  }
  else {
    my $ref = $me->read_until_dot
      or return;
    $uidl = {};
    foreach my $ln (@$ref) {
      my ($msg, $uid) = $ln =~ /^\s*(\d+)\s+([\041-\176]+)/;
      $uidl->{$msg} = $uid;
    }
  }
  return $uidl;
}


sub ping {
  @_ == 2 or croak 'usage: $pop3->ping( USER )';
  my $me = shift;

  return () unless $me->_PING(@_) && $me->message =~ /(\d+)\D+(\d+)/;

  ($1 || 0, $2 || 0);
}


sub _lookup_credentials {
  my ($me, $user) = @_;

  require Net::Netrc;

       $user ||= eval { local $SIG{__DIE__}; (getpwuid($>))[0] }
    || $ENV{NAME}
    || $ENV{USER}
    || $ENV{LOGNAME};

  my $m = Net::Netrc->lookup(${*$me}{'net_pop3_host'}, $user);
  $m ||= Net::Netrc->lookup(${*$me}{'net_pop3_host'});

  my $pass = $m
    ? $m->password || ""
    : "";

  ($user, $pass);
}


sub _get_mailbox_count {
  my ($me) = @_;
  my $ret = ${*$me}{'net_pop3_count'} =
    ($me->message =~ /(\d+)\s+message/io) ? $1 : ($me->popstat)[0];

  $ret ? $ret : "0E0";
}


sub _STAT { shift->command('STAT'       )->response() == CMD_OK }
sub _LIST { shift->command('LIST',    @_)->response() == CMD_OK }
sub _RETR { shift->command('RETR', $_[0])->response() == CMD_OK }
sub _DELE { shift->command('DELE', $_[0])->response() == CMD_OK }
sub _NOOP { shift->command('NOOP'       )->response() == CMD_OK }
sub _RSET { shift->command('RSET'       )->response() == CMD_OK }
sub _QUIT { shift->command('QUIT'       )->response() == CMD_OK }
sub _TOP  { shift->command( 'TOP',    @_)->response() == CMD_OK }
sub _UIDL { shift->command('UIDL',    @_)->response() == CMD_OK }
sub _USER { shift->command('USER', $_[0])->response() == CMD_OK }
sub _PASS { shift->command('PASS', $_[0])->response() == CMD_OK }
sub _APOP { shift->command('APOP',    @_)->response() == CMD_OK }
sub _PING { shift->command('PING', $_[0])->response() == CMD_OK }
sub _RPOP { shift->command('RPOP', $_[0])->response() == CMD_OK }
sub _LAST { shift->command('LAST'       )->response() == CMD_OK }
sub _CAPA { shift->command('CAPA'       )->response() == CMD_OK }
sub _STLS { shift->command("STLS",     )->response() == CMD_OK }


sub quit {
  my $me = shift;

  $me->_QUIT;
  $me->close;
}


sub DESTROY {
  my $me = shift;

  if (defined fileno($me) and ${*$me}{'net_pop3_deleted'}) {
    $me->reset;
    $me->quit;
  }
}

##
## POP3 has weird responses, so we emulate them to look the same :-)
##


sub response {
  my $cmd  = shift;
  my $str  = $cmd->getline() or return;
  my $code = "500";

  $cmd->debug_print(0, $str)
    if ($cmd->debug);

  if ($str =~ s/^\+OK\s*//io) {
    $code = "200";
  }
  elsif ($str =~ s/^\+\s*//io) {
    $code = "300";
  }
  else {
    $str =~ s/^-ERR\s*//io;
  }

  ${*$cmd}{'net_cmd_resp'} = [$str];
  ${*$cmd}{'net_cmd_code'} = $code;

  substr($code, 0, 1);
}


sub capa {
  my $this = shift;
  my ($capa, %capabilities);

  # Fake a capability here
  $capabilities{APOP} = '' if ($this->banner() =~ /<.*>/);

  if ($this->_CAPA()) {
    $capabilities{CAPA} = 1;
    $capa = $this->read_until_dot();
    %capabilities = (%capabilities, map {/^\s*(\S+)\s*(.*)/} @$capa);
  }
  else {

    # Check AUTH for SASL capabilities
    if ($this->command('AUTH')->response() == CMD_OK) {
      my $mechanism = $this->read_until_dot();
      $capabilities{SASL} = join " ", map {m/([A-Z0-9_-]+)/} @{$mechanism};
    }
  }

  return ${*$this}{'net_pop3e_capabilities'} = \%capabilities;
}


sub capabilities {
  my $this = shift;

  ${*$this}{'net_pop3e_capabilities'} || $this->capa;
}


sub auth {
  my ($self, $username, $password) = @_;

  eval {
    require MIME::Base64;
    require Authen::SASL;
  } or $self->set_status(500, ["Need MIME::Base64 and Authen::SASL todo auth"]), return 0;

  my $capa       = $self->capa;
  my $mechanisms = $capa->{SASL} || 'CRAM-MD5';

  my $sasl;

  if (ref($username) and UNIVERSAL::isa($username, 'Authen::SASL')) {
    $sasl = $username;
    my $user_mech = $sasl->mechanism || '';
    my @user_mech = split(/\s+/, $user_mech);
    my %user_mech;
    @user_mech{@user_mech} = ();

    my @server_mech = split(/\s+/, $mechanisms);
    my @mech = @user_mech
      ? grep { exists $user_mech{$_} } @server_mech
      : @server_mech;
    unless (@mech) {
      $self->set_status(
        500,
        [ 'Client SASL mechanisms (',
          join(', ', @user_mech),
          ') do not match the SASL mechnism the server announces (',
          join(', ', @server_mech), ')',
        ]
      );
      return 0;
    }

    $sasl->mechanism(join(" ", @mech));
  }
  else {
    die "auth(username, password)" if not length $username;
    $sasl = Authen::SASL->new(
      mechanism => $mechanisms,
      callback  => {
        user     => $username,
        pass     => $password,
        authname => $username,
      }
    );
  }

  # We should probably allow the user to pass the host, but I don't
  # currently know and SASL mechanisms that are used by smtp that need it
  my ($hostname) = split /:/, ${*$self}{'net_pop3_host'};
  my $client = eval { $sasl->client_new('pop', $hostname, 0) };

  unless ($client) {
    my $mech = $sasl->mechanism;
    $self->set_status(
      500,
      [ " Authen::SASL failure: $@",
        '(please check if your local Authen::SASL installation',
        "supports mechanism '$mech'"
      ]
    );
    return 0;
  }

  my ($token) = $client->client_start
    or do {
    my $mech = $client->mechanism;
    $self->set_status(
      500,
      [ ' Authen::SASL failure:  $client->client_start ',
        "mechanism '$mech' hostname #$hostname#",
        $client->error
      ]
    );
    return 0;
    };

  # We don't support sasl mechanisms that encrypt the socket traffic.
  # todo that we would really need to change the ISA hierarchy
  # so we don't inherit from IO::Socket, but instead hold it in an attribute

  my @cmd = ("AUTH", $client->mechanism);
  my $code;

  push @cmd, MIME::Base64::encode_base64($token, '')
    if defined $token and length $token;

  while (($code = $self->command(@cmd)->response()) == CMD_MORE) {

    my ($token) = $client->client_step(MIME::Base64::decode_base64(($self->message)[0])) or do {
      $self->set_status(
        500,
        [ ' Authen::SASL failure:  $client->client_step ',
          "mechanism '", $client->mechanism, " hostname #$hostname#, ",
          $client->error
        ]
      );
      return 0;
    };

    @cmd = (MIME::Base64::encode_base64(defined $token ? $token : '', ''));
  }

  $code == CMD_OK;
}


sub banner {
  my $this = shift;

  return ${*$this}{'net_pop3_banner'};
}

{
  package Net::POP3::_SSL;
  our @ISA = ( $ssl_class ? ($ssl_class):(), 'Net::POP3' );
  sub starttls { die "POP3 connection is already in SSL mode" }
  sub start_SSL {
    my ($class,$pop3,%arg) = @_;
    delete @arg{ grep { !m{^SSL_} } keys %arg };
    ( $arg{SSL_verifycn_name} ||= $pop3->host )
        =~s{(?<!:):[\w()]+$}{}; # strip port
    $arg{SSL_hostname} = $arg{SSL_verifycn_name}
        if ! defined $arg{SSL_hostname} && $class->can_client_sni;
    $arg{SSL_verifycn_scheme} ||= 'pop3';
    my $ok = $class->SUPER::start_SSL($pop3,%arg);
    $@ = $ssl_class->errstr if !$ok;
    return $ok;
  }
}



1;

__END__

=head1 NAME

Net::POP3 - Post Office Protocol 3 Client class (RFC1939)

=head1 SYNOPSIS

    use Net::POP3;

    # Constructors
    $pop = Net::POP3->new('pop3host');
    $pop = Net::POP3->new('pop3host', Timeout => 60);
    $pop = Net::POP3->new('pop3host', SSL => 1, Timeout => 60);

    if ($pop->login($username, $password) > 0) {
      my $msgnums = $pop->list; # hashref of msgnum => size
      foreach my $msgnum (keys %$msgnums) {
        my $msg = $pop->get($msgnum);
        print @$msg;
        $pop->delete($msgnum);
      }
    }

    $pop->quit;

=head1 DESCRIPTION

This module implements a client interface to the POP3 protocol, enabling
a perl5 application to talk to POP3 servers. This documentation assumes
that you are familiar with the POP3 protocol described in RFC1939.
With L<IO::Socket::SSL> installed it also provides support for implicit and
explicit TLS encryption, i.e. POP3S or POP3+STARTTLS.

A new Net::POP3 object must be created with the I<new> method. Once
this has been done, all POP3 commands are accessed via method calls
on the object.

The Net::POP3 class is a subclass of Net::Cmd and (depending on avaibility) of
IO::Socket::IP, IO::Socket::INET6 or IO::Socket::INET.


=head1 CONSTRUCTOR

=over 4

=item new ( [ HOST ] [, OPTIONS ] )

This is the constructor for a new Net::POP3 object. C<HOST> is the
name of the remote host to which an POP3 connection is required.

C<HOST> is optional. If C<HOST> is not given then it may instead be
passed as the C<Host> option described below. If neither is given then
the C<POP3_Hosts> specified in C<Net::Config> will be used.

C<OPTIONS> are passed in a hash like fashion, using key and value pairs.
Possible options are:

B<Host> - POP3 host to connect to. It may be a single scalar, as defined for
the C<PeerAddr> option in L<IO::Socket::INET>, or a reference to
an array with hosts to try in turn. The L</host> method will return the value
which was used to connect to the host.

B<Port> - port to connect to.
Default - 110 for plain POP3 and 995 for POP3s (direct SSL).

B<SSL> - If the connection should be done from start with SSL, contrary to later
upgrade with C<starttls>.
You can use SSL arguments as documented in L<IO::Socket::SSL>, but it will
usually use the right arguments already.

B<LocalAddr> and B<LocalPort> - These parameters are passed directly
to IO::Socket to allow binding the socket to a specific local address and port.
For compatibility with older versions B<ResvPort> can be used instead of
B<LocalPort>.

B<Domain> - This parameter is passed directly to IO::Socket and makes it
possible to enforce IPv4 connections even if L<IO::Socket::IP> is used as super
class. Alternatively B<Family> can be used.

B<Timeout> - Maximum time, in seconds, to wait for a response from the
POP3 server (default: 120)

B<Debug> - Enable debugging information

=back

=head1 METHODS

Unless otherwise stated all methods return either a I<true> or I<false>
value, with I<true> meaning that the operation was a success. When a method
states that it returns a value, failure will be returned as I<undef> or an
empty list.

C<Net::POP3> inherits from C<Net::Cmd> so methods defined in C<Net::Cmd> may
be used to send commands to the remote POP3 server in addition to the methods
documented here.

=over 4

=item host ()

Returns the value used by the constructor, and passed to IO::Socket::INET,
to connect to the host.

=item auth ( USERNAME, PASSWORD )

Attempt SASL authentication.

=item user ( USER )

Send the USER command.

=item pass ( PASS )

Send the PASS command. Returns the number of messages in the mailbox.

=item login ( [ USER [, PASS ]] )

Send both the USER and PASS commands. If C<PASS> is not given the
C<Net::POP3> uses C<Net::Netrc> to lookup the password using the host
and username. If the username is not specified then the current user name
will be used.

Returns the number of messages in the mailbox. However if there are no
messages on the server the string C<"0E0"> will be returned. This is
will give a true value in a boolean context, but zero in a numeric context.

If there was an error authenticating the user then I<undef> will be returned.

=item starttls ( SSLARGS )

Upgrade existing plain connection to SSL.
You can use SSL arguments as documented in L<IO::Socket::SSL>, but it will
usually use the right arguments already.

=item apop ( [ USER [, PASS ]] )

Authenticate with the server identifying as C<USER> with password C<PASS>.
Similar to L</login>, but the password is not sent in clear text.

To use this method you must have the Digest::MD5 or the MD5 module installed,
otherwise this method will return I<undef>.

=item banner ()

Return the sever's connection banner

=item capa ()

Return a reference to a hash of the capabilities of the server.  APOP
is added as a pseudo capability.  Note that I've been unable to
find a list of the standard capability values, and some appear to
be multi-word and some are not.  We make an attempt at intelligently
parsing them, but it may not be correct.

=item  capabilities ()

Just like capa, but only uses a cache from the last time we asked
the server, so as to avoid asking more than once.

=item top ( MSGNUM [, NUMLINES ] )

Get the header and the first C<NUMLINES> of the body for the message
C<MSGNUM>. Returns a reference to an array which contains the lines of text
read from the server.

=item list ( [ MSGNUM ] )

If called with an argument the C<list> returns the size of the message
in octets.

If called without arguments a reference to a hash is returned. The
keys will be the C<MSGNUM>'s of all undeleted messages and the values will
be their size in octets.

=item get ( MSGNUM [, FH ] )

Get the message C<MSGNUM> from the remote mailbox. If C<FH> is not given
then get returns a reference to an array which contains the lines of
text read from the server. If C<FH> is given then the lines returned
from the server are printed to the filehandle C<FH>.

=item getfh ( MSGNUM )

As per get(), but returns a tied filehandle.  Reading from this
filehandle returns the requested message.  The filehandle will return
EOF at the end of the message and should not be reused.

=item last ()

Returns the highest C<MSGNUM> of all the messages accessed.

=item popstat ()

Returns a list of two elements. These are the number of undeleted
elements and the size of the mbox in octets.

=item ping ( USER )

Returns a list of two elements. These are the number of new messages
and the total number of messages for C<USER>.

=item uidl ( [ MSGNUM ] )

Returns a unique identifier for C<MSGNUM> if given. If C<MSGNUM> is not
given C<uidl> returns a reference to a hash where the keys are the
message numbers and the values are the unique identifiers.

=item delete ( MSGNUM )

Mark message C<MSGNUM> to be deleted from the remote mailbox. All messages
that are marked to be deleted will be removed from the remote mailbox
when the server connection closed.

=item reset ()

Reset the status of the remote POP3 server. This includes resetting the
status of all messages to not be deleted.

=item quit ()

Quit and close the connection to the remote POP3 server. Any messages marked
as deleted will be deleted from the remote mailbox.

=item can_inet6 ()

Returns whether we can use IPv6.

=item can_ssl ()

Returns whether we can use SSL.

=back

=head1 NOTES

If a C<Net::POP3> object goes out of scope before C<quit> method is called
then the C<reset> method will called before the connection is closed. This
means that any messages marked to be deleted will not be.

=head1 SEE ALSO

L<Net::Netrc>,
L<Net::Cmd>,
L<IO::Socket::SSL>

=head1 AUTHOR

Graham Barr E<lt>F<gbarr@pobox.com>E<gt>

Steve Hay E<lt>F<shay@cpan.org>E<gt> is now maintaining libnet as of version
1.22_02

=head1 COPYRIGHT

Versions up to 2.29 Copyright (c) 1995-2004 Graham Barr. All rights reserved.
Changes in Version 2.29_01 onwards Copyright (C) 2013-2015 Steve Hay.  All
rights reserved.

This module is free software; you can redistribute it and/or modify it under the
same terms as Perl itself, i.e. under the terms of either the GNU General Public
License or the Artistic License, as specified in the F<LICENCE> file.

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     package Net::Ping;

require 5.002;
require Exporter;

use strict;
use vars qw(@ISA @EXPORT $VERSION
            $def_timeout $def_proto $def_factor
            $max_datasize $pingstring $hires $source_verify $syn_forking);
use Fcntl qw( F_GETFL F_SETFL O_NONBLOCK );
use Socket qw( SOCK_DGRAM SOCK_STREAM SOCK_RAW PF_INET SOL_SOCKET SO_ERROR IPPROTO_IP IP_TOS IP_TTL
               inet_aton getnameinfo NI_NUMERICHOST sockaddr_in );
use POSIX qw( ENOTCONN ECONNREFUSED ECONNRESET EINPROGRESS EWOULDBLOCK EAGAIN WNOHANG );
use FileHandle;
use Carp;
use Time::HiRes;

@ISA = qw(Exporter);
@EXPORT = qw(pingecho);
$VERSION = "2.43_01";

# Constants

$def_timeout = 5;           # Default timeout to wait for a reply
$def_proto = "tcp";         # Default protocol to use for pinging
$def_factor = 1.2;          # Default exponential backoff rate.
$max_datasize = 1024;       # Maximum data bytes in a packet
# The data we exchange with the server for the stream protocol
$pingstring = "pingschwingping!\n";
$source_verify = 1;         # Default is to verify source endpoint
$syn_forking = 0;

if ($^O =~ /Win32/i) {
  # Hack to avoid this Win32 spewage:
  # Your vendor has not defined POSIX macro ECONNREFUSED
  my @pairs = (ECONNREFUSED => 10061, # "Unknown Error" Special Win32 Response?
	       ENOTCONN     => 10057,
	       ECONNRESET   => 10054,
	       EINPROGRESS  => 10036,
	       EWOULDBLOCK  => 10035,
	  );
  while (my $name = shift @pairs) {
    my $value = shift @pairs;
    # When defined, these all are non-zero
    unless (eval $name) {
      no strict 'refs';
      *{$name} = defined prototype \&{$name} ? sub () {$value} : sub {$value};
    }
  }
#  $syn_forking = 1;    # XXX possibly useful in < Win2K ?
};

# h2ph "asm/socket.h"
# require "asm/socket.ph";
sub SO_BINDTODEVICE {25;}

# Description:  The pingecho() subroutine is provided for backward
# compatibility with the original Net::Ping.  It accepts a host
# name/IP and an optional timeout in seconds.  Create a tcp ping
# object and try pinging the host.  The result of the ping is returned.

sub pingecho
{
  my ($host,              # Name or IP number of host to ping
      $timeout            # Optional timeout in seconds
      ) = @_;
  my ($p);                # A ping object

  $p = Net::Ping->new("tcp", $timeout);
  $p->ping($host);        # Going out of scope closes the connection
}

# Description:  The new() method creates a new ping object.  Optional
# parameters may be specified for the protocol to use, the timeout in
# seconds and the size in bytes of additional data which should be
# included in the packet.
#   After the optional parameters are checked, the data is constructed
# and a socket is opened if appropriate.  The object is returned.

sub new
{
  my ($this,
      $proto,             # Optional protocol to use for pinging
      $timeout,           # Optional timeout in seconds
      $data_size,         # Optional additional bytes of data
      $device,            # Optional device to use
      $tos,               # Optional ToS to set
      $ttl,               # Optional TTL to set
      ) = @_;
  my  $class = ref($this) || $this;
  my  $self = {};
  my ($cnt,               # Count through data bytes
      $min_datasize       # Minimum data bytes required
      );

  bless($self, $class);

  $proto = $def_proto unless $proto;          # Determine the protocol
  croak('Protocol for ping must be "icmp", "udp", "tcp", "syn", "stream", or "external"')
    unless $proto =~ m/^(icmp|udp|tcp|syn|stream|external)$/;
  $self->{"proto"} = $proto;

  $timeout = $def_timeout unless $timeout;    # Determine the timeout
  croak("Default timeout for ping must be greater than 0 seconds")
    if $timeout <= 0;
  $self->{"timeout"} = $timeout;

  $self->{"device"} = $device;

  $self->{"tos"} = $tos;

  if ($self->{"proto"} eq 'icmp') {
    croak('TTL must be from 0 to 255')
      if ($ttl && ($ttl < 0 || $ttl > 255));
    $self->{"ttl"} = $ttl;
  }

  $min_datasize = ($proto eq "udp") ? 1 : 0;  # Determine data size
  $data_size = $min_datasize unless defined($data_size) && $proto ne "tcp";
  croak("Data for ping must be from $min_datasize to $max_datasize bytes")
    if ($data_size < $min_datasize) || ($data_size > $max_datasize);
  $data_size-- if $self->{"proto"} eq "udp";  # We provide the first byte
  $self->{"data_size"} = $data_size;

  $self->{"data"} = "";                       # Construct data bytes
  for ($cnt = 0; $cnt < $self->{"data_size"}; $cnt++)
  {
    $self->{"data"} .= chr($cnt % 256);
  }

  $self->{"local_addr"} = undef;              # Don't bind by default
  $self->{"retrans"} = $def_factor;           # Default exponential backoff rate
  $self->{"econnrefused"} = undef;            # Default Connection refused behavior

  $self->{"seq"} = 0;                         # For counting packets
  if ($self->{"proto"} eq "udp")              # Open a socket
  {
    $self->{"proto_num"} = eval { (getprotobyname('udp'))[2] } ||
      croak("Can't udp protocol by name");
    $self->{"port_num"} = (getservbyname('echo', 'udp'))[2] ||
      croak("Can't get udp echo port by name");
    $self->{"fh"} = FileHandle->new();
    socket($self->{"fh"}, PF_INET, SOCK_DGRAM,
           $self->{"proto_num"}) ||
             croak("udp socket error - $!");
    if ($self->{'device'}) {
      setsockopt($self->{"fh"}, SOL_SOCKET, SO_BINDTODEVICE(), pack("Z*", $self->{'device'}))
        or croak "error binding to device $self->{'device'} $!";
    }
    if ($self->{'tos'}) {
      setsockopt($self->{"fh"}, IPPROTO_IP, IP_TOS, pack("I*", $self->{'tos'}))
        or croak "error configuring tos to $self->{'tos'} $!";
    }
  }
  elsif ($self->{"proto"} eq "icmp")
  {
    croak("icmp ping requires root privilege") if ($> and $^O ne 'VMS' and $^O ne 'cygwin');
    $self->{"proto_num"} = eval { (getprotobyname('icmp'))[2] } ||
      croak("Can't get icmp protocol by name");
    $self->{"pid"} = $$ & 0xffff;           # Save lower 16 bits of pid
    $self->{"fh"} = FileHandle->new();
    socket($self->{"fh"}, PF_INET, SOCK_RAW, $self->{"proto_num"}) ||
      croak("icmp socket error - $!");
    if ($self->{'device'}) {
      setsockopt($self->{"fh"}, SOL_SOCKET, SO_BINDTODEVICE(), pack("Z*", $self->{'device'}))
        or croak "error binding to device $self->{'device'} $!";
    }
    if ($self->{'tos'}) {
      setsockopt($self->{"fh"}, IPPROTO_IP, IP_TOS, pack("I*", $self->{'tos'}))
        or croak "error configuring tos to $self->{'tos'} $!";
    }
    if ($self->{'ttl'}) {
      setsockopt($self->{"fh"}, IPPROTO_IP, IP_TTL, pack("I*", $self->{'ttl'}))
        or croak "error configuring ttl to $self->{'ttl'} $!";
    }
  }
  elsif ($self->{"proto"} eq "tcp" || $self->{"proto"} eq "stream")
  {
    $self->{"proto_num"} = eval { (getprotobyname('tcp'))[2] } ||
      croak("Can't get tcp protocol by name");
    $self->{"port_num"} = (getservbyname('echo', 'tcp'))[2] ||
      croak("Can't get tcp echo port by name");
    $self->{"fh"} = FileHandle->new();
  }
  elsif ($self->{"proto"} eq "syn")
  {
    $self->{"proto_num"} = eval { (getprotobyname('tcp'))[2] } ||
      croak("Can't get tcp protocol by name");
    $self->{"port_num"} = (getservbyname('echo', 'tcp'))[2] ||
      croak("Can't get tcp echo port by name");
    if ($syn_forking) {
      $self->{"fork_rd"} = FileHandle->new();
      $self->{"fork_wr"} = FileHandle->new();
      pipe($self->{"fork_rd"}, $self->{"fork_wr"});
      $self->{"fh"} = FileHandle->new();
      $self->{"good"} = {};
      $self->{"bad"} = {};
    } else {
      $self->{"wbits"} = "";
      $self->{"bad"} = {};
    }
    $self->{"syn"} = {};
    $self->{"stop_time"} = 0;
  }
  elsif ($self->{"proto"} eq "external")
  {
    # No preliminary work needs to be done.
  }

  return($self);
}

# Description: Set the local IP address from which pings will be sent.
# For ICMP and UDP pings, this calls bind() on the already-opened socket;
# for TCP pings, just saves the address to be used when the socket is
# opened.  Returns non-zero if successful; croaks on error.
sub bind
{
  my ($self,
      $local_addr         # Name or IP number of local interface
      ) = @_;
  my ($ip                 # Packed IP number of $local_addr
      );

  croak("Usage: \$p->bind(\$local_addr)") unless @_ == 2;
  croak("already bound") if defined($self->{"local_addr"}) &&
    ($self->{"proto"} eq "udp" || $self->{"proto"} eq "icmp");

  $ip = inet_aton($local_addr);
  croak("nonexistent local address $local_addr") unless defined($ip);
  $self->{"local_addr"} = $ip; # Only used if proto is tcp

  if ($self->{"proto"} eq "udp" || $self->{"proto"} eq "icmp")
  {
  CORE::bind($self->{"fh"}, sockaddr_in(0, $ip)) ||
    croak("$self->{'proto'} bind error - $!");
  }
  elsif (($self->{"proto"} ne "tcp") && ($self->{"proto"} ne "syn"))
  {
    croak("Unknown protocol \"$self->{proto}\" in bind()");
  }

  return 1;
}

# Description: A select() wrapper that compensates for platform
# peculiarities.
sub mselect
{
    if ($_[3] > 0 and $^O eq 'MSWin32') {
	# On windows, select() doesn't process the message loop,
	# but sleep() will, allowing alarm() to interrupt the latter.
	# So we chop up the timeout into smaller pieces and interleave
	# select() and sleep() calls.
	my $t = $_[3];
	my $gran = 0.5;  # polling granularity in seconds
	my @args = @_;
	while (1) {
	    $gran = $t if $gran > $t;
	    my $nfound = select($_[0], $_[1], $_[2], $gran);
	    undef $nfound if $nfound == -1;
	    $t -= $gran;
	    return $nfound if $nfound or !defined($nfound) or $t <= 0;

	    sleep(0);
	    ($_[0], $_[1], $_[2]) = @args;
	}
    }
    else {
	my $nfound = select($_[0], $_[1], $_[2], $_[3]);
	undef $nfound if $nfound == -1;
	return $nfound;
    }
}

# Description: Allow UDP source endpoint comparison to be
#              skipped for those remote interfaces that do
#              not response from the same endpoint.

sub source_verify
{
  my $self = shift;
  $source_verify = 1 unless defined
    ($source_verify = ((defined $self) && (ref $self)) ? shift() : $self);
}

# Description: Set whether or not the connect
# behavior should enforce remote service
# availability as well as reachability.

sub service_check
{
  my $self = shift;
  $self->{"econnrefused"} = 1 unless defined
    ($self->{"econnrefused"} = shift());
}

sub tcp_service_check
{
  service_check(@_);
}

# Description: Set exponential backoff for retransmission.
# Should be > 1 to retain exponential properties.
# If set to 0, retransmissions are disabled.

sub retrans
{
  my $self = shift;
  $self->{"retrans"} = shift;
}

# Description: allows the module to use milliseconds as returned by
# the Time::HiRes module

$hires = 1;
sub hires
{
  my $self = shift;
  $hires = 1 unless defined
    ($hires = ((defined $self) && (ref $self)) ? shift() : $self);
}

sub time
{
  return $hires ? Time::HiRes::time() : CORE::time();
}

# Description: Sets or clears the O_NONBLOCK flag on a file handle.
sub socket_blocking_mode
{
  my ($self,
      $fh,              # the file handle whose flags are to be modified
      $block) = @_;     # if true then set the blocking
                        # mode (clear O_NONBLOCK), otherwise
                        # set the non-blocking mode (set O_NONBLOCK)

  my $flags;
  if ($^O eq 'MSWin32' || $^O eq 'VMS') {
      # FIONBIO enables non-blocking sockets on windows and vms.
      # FIONBIO is (0x80000000|(4<<16)|(ord('f')<<8)|126), as per winsock.h, ioctl.h
      my $f = 0x8004667e;
      my $v = pack("L", $block ? 0 : 1);
      ioctl($fh, $f, $v) or croak("ioctl failed: $!");
      return;
  }
  if ($flags = fcntl($fh, F_GETFL, 0)) {
    $flags = $block ? ($flags & ~O_NONBLOCK) : ($flags | O_NONBLOCK);
    if (!fcntl($fh, F_SETFL, $flags)) {
      croak("fcntl F_SETFL: $!");
    }
  } else {
    croak("fcntl F_GETFL: $!");
  }
}

# Description: Ping a host name or IP number with an optional timeout.
# First lookup the host, and return undef if it is not found.  Otherwise
# perform the specific ping method based on the protocol.  Return the
# result of the ping.

sub ping
{
  my ($self,
      $host,              # Name or IP number of host to ping
      $timeout,           # Seconds after which ping times out
      ) = @_;
  my ($ip,                # Packed IP number of $host
      $ret,               # The return value
      $ping_time,         # When ping began
      );

  croak("Usage: \$p->ping(\$host [, \$timeout])") unless @_ == 2 || @_ == 3;
  $timeout = $self->{"timeout"} unless $timeout;
  croak("Timeout must be greater than 0 seconds") if $timeout <= 0;

  $ip = inet_aton($host);
  return () unless defined($ip);      # Does host exist?

  # Dispatch to the appropriate routine.
  $ping_time = &time();
  if ($self->{"proto"} eq "external") {
    $ret = $self->ping_external($ip, $timeout);
  }
  elsif ($self->{"proto"} eq "udp") {
    $ret = $self->ping_udp($ip, $timeout);
  }
  elsif ($self->{"proto"} eq "icmp") {
    $ret = $self->ping_icmp($ip, $timeout);
  }
  elsif ($self->{"proto"} eq "tcp") {
    $ret = $self->ping_tcp($ip, $timeout);
  }
  elsif ($self->{"proto"} eq "stream") {
    $ret = $self->ping_stream($ip, $timeout);
  }
  elsif ($self->{"proto"} eq "syn") {
    $ret = $self->ping_syn($host, $ip, $ping_time, $ping_time+$timeout);
  } else {
    croak("Unknown protocol \"$self->{proto}\" in ping()");
  }

  return wantarray ? ($ret, &time() - $ping_time, $self->ntop($ip)) : $ret;
}

# Uses Net::Ping::External to do an external ping.
sub ping_external {
  my ($self,
      $ip,                # Packed IP number of the host
      $timeout            # Seconds after which ping times out
     ) = @_;

  eval {
    local @INC = @INC;
    pop @INC if $INC[-1] eq '.';
    require Net::Ping::External;
  }
    or croak('Protocol "external" not supported on your system: Net::Ping::External not found');
  return Net::Ping::External::ping(ip => $ip, timeout => $timeout);
}

use constant ICMP_ECHOREPLY   => 0; # ICMP packet types
use constant ICMP_UNREACHABLE => 3; # ICMP packet types
use constant ICMP_ECHO        => 8;
use constant ICMP_TIME_EXCEEDED => 11; # ICMP packet types
use constant ICMP_PARAMETER_PROBLEM => 12; # ICMP packet types
use constant ICMP_STRUCT      => "C2 n3 A"; # Structure of a minimal ICMP packet
use constant SUBCODE          => 0; # No ICMP subcode for ECHO and ECHOREPLY
use constant ICMP_FLAGS       => 0; # No special flags for send or recv
use constant ICMP_PORT        => 0; # No port with ICMP

sub ping_icmp
{
  my ($self,
      $ip,                # Packed IP number of the host
      $timeout            # Seconds after which ping times out
      ) = @_;

  my ($saddr,             # sockaddr_in with port and ip
      $checksum,          # Checksum of ICMP packet
      $msg,               # ICMP packet to send
      $len_msg,           # Length of $msg
      $rbits,             # Read bits, filehandles for reading
      $nfound,            # Number of ready filehandles found
      $finish_time,       # Time ping should be finished
      $done,              # set to 1 when we are done
      $ret,               # Return value
      $recv_msg,          # Received message including IP header
      $from_saddr,        # sockaddr_in of sender
      $from_port,         # Port packet was sent from
      $from_ip,           # Packed IP of sender
      $from_type,         # ICMP type
      $from_subcode,      # ICMP subcode
      $from_chk,          # ICMP packet checksum
      $from_pid,          # ICMP packet id
      $from_seq,          # ICMP packet sequence
      $from_msg           # ICMP message
      );

  $self->{"seq"} = ($self->{"seq"} + 1) % 65536; # Increment sequence
  $checksum = 0;                          # No checksum for starters
  $msg = pack(ICMP_STRUCT . $self->{"data_size"}, ICMP_ECHO, SUBCODE,
              $checksum, $self->{"pid"}, $self->{"seq"}, $self->{"data"});
  $checksum = Net::Ping->checksum($msg);
  $msg = pack(ICMP_STRUCT . $self->{"data_size"}, ICMP_ECHO, SUBCODE,
              $checksum, $self->{"pid"}, $self->{"seq"}, $self->{"data"});
  $len_msg = length($msg);
  $saddr = sockaddr_in(ICMP_PORT, $ip);
  $self->{"from_ip"} = undef;
  $self->{"from_type"} = undef;
  $self->{"from_subcode"} = undef;
  send($self->{"fh"}, $msg, ICMP_FLAGS, $saddr); # Send the message

  $rbits = "";
  vec($rbits, $self->{"fh"}->fileno(), 1) = 1;
  $ret = 0;
  $done = 0;
  $finish_time = &time() + $timeout;      # Must be done by this time
  while (!$done && $timeout > 0)          # Keep trying if we have time
  {
    $nfound = mselect((my $rout=$rbits), undef, undef, $timeout); # Wait for packet
    $timeout = $finish_time - &time();    # Get remaining time
    if (!defined($nfound))                # Hmm, a strange error
    {
      $ret = undef;
      $done = 1;
    }
    elsif ($nfound)                     # Got a packet from somewhere
    {
      $recv_msg = "";
      $from_pid = -1;
      $from_seq = -1;
      $from_saddr = recv($self->{"fh"}, $recv_msg, 1500, ICMP_FLAGS);
      ($from_port, $from_ip) = sockaddr_in($from_saddr);
      ($from_type, $from_subcode) = unpack("C2", substr($recv_msg, 20, 2));
      if ($from_type == ICMP_ECHOREPLY) {
        ($from_pid, $from_seq) = unpack("n3", substr($recv_msg, 24, 4))
          if length $recv_msg >= 28;
      } else {
        ($from_pid, $from_seq) = unpack("n3", substr($recv_msg, 52, 4))
          if length $recv_msg >= 56;
      }
      $self->{"from_ip"} = $from_ip;
      $self->{"from_type"} = $from_type;
      $self->{"from_subcode"} = $from_subcode;
      next if ($from_pid != $self->{"pid"});
      next if ($from_seq != $self->{"seq"});
      if (! $source_verify || ($self->ntop($from_ip) eq $self->ntop($ip))) { # Does the packet check out?
        if ($from_type == ICMP_ECHOREPLY) {
          $ret = 1;
	        $done = 1;
        } elsif ($from_type == ICMP_UNREACHABLE) {
          $done = 1;
        } elsif ($from_type == ICMP_TIME_EXCEEDED) {
          $ret = 0;
          $done = 1;
        }
      }
    } else {     # Oops, timed out
      $done = 1;
    }
  }
  return $ret;
}

sub icmp_result {
  my ($self) = @_;
  my $ip = $self->{"from_ip"} || "";
  $ip = "\0\0\0\0" unless 4 == length $ip;
  return ($self->ntop($ip),($self->{"from_type"} || 0), ($self->{"from_subcode"} || 0));
}

# Description:  Do a checksum on the message.  Basically sum all of
# the short words and fold the high order bits into the low order bits.

sub checksum
{
  my ($class,
      $msg            # The message to checksum
      ) = @_;
  my ($len_msg,       # Length of the message
      $num_short,     # The number of short words in the message
      $short,         # One short word
      $chk            # The checksum
      );

  $len_msg = length($msg);
  $num_short = int($len_msg / 2);
  $chk = 0;
  foreach $short (unpack("n$num_short", $msg))
  {
    $chk += $short;
  }                                           # Add the odd byte in
  $chk += (unpack("C", substr($msg, $len_msg - 1, 1)) << 8) if $len_msg % 2;
  $chk = ($chk >> 16) + ($chk & 0xffff);      # Fold high into low
  return(~(($chk >> 16) + $chk) & 0xffff);    # Again and complement
}


# Description:  Perform a tcp echo ping.  Since a tcp connection is
# host specific, we have to open and close each connection here.  We
# can't just leave a socket open.  Because of the robust nature of
# tcp, it will take a while before it gives up trying to establish a
# connection.  Therefore, we use select() on a non-blocking socket to
# check against our timeout.  No data bytes are actually
# sent since the successful establishment of a connection is proof
# enough of the reachability of the remote host.  Also, tcp is
# expensive and doesn't need our help to add to the overhead.

sub ping_tcp
{
  my ($self,
      $ip,                # Packed IP number of the host
      $timeout            # Seconds after which ping times out
      ) = @_;
  my ($ret                # The return value
      );

  $! = 0;
  $ret = $self -> tcp_connect( $ip, $timeout);
  if (!$self->{"econnrefused"} &&
      $! == ECONNREFUSED) {
    $ret = 1;  # "Connection refused" means reachable
  }
  $self->{"fh"}->close();
  return $ret;
}

sub tcp_connect
{
  my ($self,
      $ip,                # Packed IP number of the host
      $timeout            # Seconds after which connect times out
      ) = @_;
  my ($saddr);            # Packed IP and Port

  $saddr = sockaddr_in($self->{"port_num"}, $ip);

  my $ret = 0;            # Default to unreachable

  my $do_socket = sub {
    socket($self->{"fh"}, PF_INET, SOCK_STREAM, $self->{"proto_num"}) ||
      croak("tcp socket error - $!");
    if (defined $self->{"local_addr"} &&
        !CORE::bind($self->{"fh"}, sockaddr_in(0, $self->{"local_addr"}))) {
      croak("tcp bind error - $!");
    }
    if ($self->{'device'}) {
      setsockopt($self->{"fh"}, SOL_SOCKET, SO_BINDTODEVICE(), pack("Z*", $self->{'device'}))
        or croak("error binding to device $self->{'device'} $!");
    }
    if ($self->{'tos'}) {
      setsockopt($self->{"fh"}, IPPROTO_IP, IP_TOS, pack("I*", $self->{'tos'}))
        or croak "error configuring tos to $self->{'tos'} $!";
    }
  };
  my $do_connect = sub {
    $self->{"ip"} = $ip;
    # ECONNREFUSED is 10061 on MSWin32. If we pass it as child error through $?,
    # we'll get (10061 & 255) = 77, so we cannot check it in the parent process.
    return ($ret = connect($self->{"fh"}, $saddr) || ($! == ECONNREFUSED && !$self->{"econnrefused"}));
  };
  my $do_connect_nb = sub {
    # Set O_NONBLOCK property on filehandle
    $self->socket_blocking_mode($self->{"fh"}, 0);

    # start the connection attempt
    if (!connect($self->{"fh"}, $saddr)) {
      if ($! == ECONNREFUSED) {
        $ret = 1 unless $self->{"econnrefused"};
      } elsif ($! != EINPROGRESS && ($^O ne 'MSWin32' || $! != EWOULDBLOCK)) {
        # EINPROGRESS is the expected error code after a connect()
        # on a non-blocking socket.  But if the kernel immediately
        # determined that this connect() will never work,
        # Simply respond with "unreachable" status.
        # (This can occur on some platforms with errno
        # EHOSTUNREACH or ENETUNREACH.)
        return 0;
      } else {
        # Got the expected EINPROGRESS.
        # Just wait for connection completion...
        my ($wbits, $wout, $wexc);
        $wout = $wexc = $wbits = "";
        vec($wbits, $self->{"fh"}->fileno, 1) = 1;

        my $nfound = mselect(undef,
			    ($wout = $wbits),
			    ($^O eq 'MSWin32' ? ($wexc = $wbits) : undef),
			    $timeout);
        warn("select: $!") unless defined $nfound;

        if ($nfound && vec($wout, $self->{"fh"}->fileno, 1)) {
          # the socket is ready for writing so the connection
          # attempt completed. test whether the connection
          # attempt was successful or not

          if (getpeername($self->{"fh"})) {
            # Connection established to remote host
            $ret = 1;
          } else {
            # TCP ACK will never come from this host
            # because there was an error connecting.

            # This should set $! to the correct error.
            my $char;
            sysread($self->{"fh"},$char,1);
            $! = ECONNREFUSED if ($! == EAGAIN && $^O =~ /cygwin/i);

            $ret = 1 if (!$self->{"econnrefused"}
                         && $! == ECONNREFUSED);
          }
        } else {
          # the connection attempt timed out (or there were connect
	  # errors on Windows)
	  if ($^O =~ 'MSWin32') {
	      # If the connect will fail on a non-blocking socket,
	      # winsock reports ECONNREFUSED as an exception, and we
	      # need to fetch the socket-level error code via getsockopt()
	      # instead of using the thread-level error code that is in $!.
	      if ($nfound && vec($wexc, $self->{"fh"}->fileno, 1)) {
		  $! = unpack("i", getsockopt($self->{"fh"}, SOL_SOCKET,
			                      SO_ERROR));
	      }
	  }
        }
      }
    } else {
      # Connection established to remote host
      $ret = 1;
    }

    # Unset O_NONBLOCK property on filehandle
    $self->socket_blocking_mode($self->{"fh"}, 1);
    $self->{"ip"} = $ip;
    return $ret;
  };

  if ($syn_forking) {
    # Buggy Winsock API doesn't allow nonblocking connect.
    # Hence, if our OS is Windows, we need to create a separate
    # process to do the blocking connect attempt.
    # XXX Above comments are not true at least for Win2K, where
    # nonblocking connect works.

    $| = 1; # Clear buffer prior to fork to prevent duplicate flushing.
    $self->{'tcp_chld'} = fork;
    if (!$self->{'tcp_chld'}) {
      if (!defined $self->{'tcp_chld'}) {
        # Fork did not work
        warn "Fork error: $!";
        return 0;
      }
      &{ $do_socket }();

      # Try a slow blocking connect() call
      # and report the status to the parent.
      if ( &{ $do_connect }() ) {
        $self->{"fh"}->close();
        # No error
        exit 0;
      } else {
        # Pass the error status to the parent
        # Make sure that $! <= 255
        exit($! <= 255 ? $! : 255);
      }
    }

    &{ $do_socket }();

    my $patience = &time() + $timeout;

    my ($child, $child_errno);
    $? = 0; $child_errno = 0;
    # Wait up to the timeout
    # And clean off the zombie
    do {
      $child = waitpid($self->{'tcp_chld'}, &WNOHANG());
      $child_errno = $? >> 8;
      select(undef, undef, undef, 0.1);
    } while &time() < $patience && $child != $self->{'tcp_chld'};

    if ($child == $self->{'tcp_chld'}) {
      if ($self->{"proto"} eq "stream") {
        # We need the socket connected here, in parent
        # Should be safe to connect because the child finished
        # within the timeout
        &{ $do_connect }();
      }
      # $ret cannot be set by the child process
      $ret = !$child_errno;
    } else {
      # Time must have run out.
      # Put that choking client out of its misery
      kill "KILL", $self->{'tcp_chld'};
      # Clean off the zombie
      waitpid($self->{'tcp_chld'}, 0);
      $ret = 0;
    }
    delete $self->{'tcp_chld'};
    $! = $child_errno;
  } else {
    # Otherwise don't waste the resources to fork

    &{ $do_socket }();

    &{ $do_connect_nb }();
  }

  return $ret;
}

sub DESTROY {
  my $self = shift;
  if ($self->{'proto'} eq 'tcp' &&
      $self->{'tcp_chld'}) {
    # Put that choking client out of its misery
    kill "KILL", $self->{'tcp_chld'};
    # Clean off the zombie
    waitpid($self->{'tcp_chld'}, 0);
  }
}

# This writes the given string to the socket and then reads it
# back.  It returns 1 on success, 0 on failure.
sub tcp_echo
{
  my $self = shift;
  my $timeout = shift;
  my $pingstring = shift;

  my $ret = undef;
  my $time = &time();
  my $wrstr = $pingstring;
  my $rdstr = "";

  eval <<'EOM';
    do {
      my $rin = "";
      vec($rin, $self->{"fh"}->fileno(), 1) = 1;

      my $rout = undef;
      if($wrstr) {
        $rout = "";
        vec($rout, $self->{"fh"}->fileno(), 1) = 1;
      }

      if(mselect($rin, $rout, undef, ($time + $timeout) - &time())) {

        if($rout && vec($rout,$self->{"fh"}->fileno(),1)) {
          my $num = syswrite($self->{"fh"}, $wrstr, length $wrstr);
          if($num) {
            # If it was a partial write, update and try again.
            $wrstr = substr($wrstr,$num);
          } else {
            # There was an error.
            $ret = 0;
          }
        }

        if(vec($rin,$self->{"fh"}->fileno(),1)) {
          my $reply;
          if(sysread($self->{"fh"},$reply,length($pingstring)-length($rdstr))) {
            $rdstr .= $reply;
            $ret = 1 if $rdstr eq $pingstring;
          } else {
            # There was an error.
            $ret = 0;
          }
        }

      }
    } until &time() > ($time + $timeout) || defined($ret);
EOM

  return $ret;
}




# Description: Perform a stream ping.  If the tcp connection isn't
# already open, it opens it.  It then sends some data and waits for
# a reply.  It leaves the stream open on exit.

sub ping_stream
{
  my ($self,
      $ip,                # Packed IP number of the host
      $timeout            # Seconds after which ping times out
      ) = @_;

  # Open the stream if it's not already open
  if(!defined $self->{"fh"}->fileno()) {
    $self->tcp_connect($ip, $timeout) or return 0;
  }

  croak "tried to switch servers while stream pinging"
    if $self->{"ip"} ne $ip;

  return $self->tcp_echo($timeout, $pingstring);
}

# Description: opens the stream.  You would do this if you want to
# separate the overhead of opening the stream from the first ping.

sub open
{
  my ($self,
      $host,              # Host or IP address
      $timeout            # Seconds after which open times out
      ) = @_;

  my ($ip);               # Packed IP number of the host
  $ip = inet_aton($host);
  $timeout = $self->{"timeout"} unless $timeout;

  if($self->{"proto"} eq "stream") {
    if(defined($self->{"fh"}->fileno())) {
      croak("socket is already open");
    } else {
      $self->tcp_connect($ip, $timeout);
    }
  }
}


# Description:  Perform a udp echo ping.  Construct a message of
# at least the one-byte sequence number and any additional data bytes.
# Send the message out and wait for a message to come back.  If we
# get a message, make sure all of its parts match.  If they do, we are
# done.  Otherwise go back and wait for the message until we run out
# of time.  Return the result of our efforts.

use constant UDP_FLAGS => 0; # Nothing special on send or recv
sub ping_udp
{
  my ($self,
      $ip,                # Packed IP number of the host
      $timeout            # Seconds after which ping times out
      ) = @_;

  my ($saddr,             # sockaddr_in with port and ip
      $ret,               # The return value
      $msg,               # Message to be echoed
      $finish_time,       # Time ping should be finished
      $flush,             # Whether socket needs to be disconnected
      $connect,           # Whether socket needs to be connected
      $done,              # Set to 1 when we are done pinging
      $rbits,             # Read bits, filehandles for reading
      $nfound,            # Number of ready filehandles found
      $from_saddr,        # sockaddr_in of sender
      $from_msg,          # Characters echoed by $host
      $from_port,         # Port message was echoed from
      $from_ip            # Packed IP number of sender
      );

  $saddr = sockaddr_in($self->{"port_num"}, $ip);
  $self->{"seq"} = ($self->{"seq"} + 1) % 256;    # Increment sequence
  $msg = chr($self->{"seq"}) . $self->{"data"};   # Add data if any

  if ($self->{"connected"}) {
    if ($self->{"connected"} ne $saddr) {
      # Still connected to wrong destination.
      # Need to flush out the old one.
      $flush = 1;
    }
  } else {
    # Not connected yet.
    # Need to connect() before send()
    $connect = 1;
  }

  # Have to connect() and send() instead of sendto()
  # in order to pick up on the ECONNREFUSED setting
  # from recv() or double send() errno as utilized in
  # the concept by rdw @ perlmonks.  See:
  # http://perlmonks.thepen.com/42898.html
  if ($flush) {
    # Need to socket() again to flush the descriptor
    # This will disconnect from the old saddr.
    socket($self->{"fh"}, PF_INET, SOCK_DGRAM,
           $self->{"proto_num"});
  }
  # Connect the socket if it isn't already connected
  # to the right destination.
  if ($flush || $connect) {
    connect($self->{"fh"}, $saddr);               # Tie destination to socket
    $self->{"connected"} = $saddr;
  }
  send($self->{"fh"}, $msg, UDP_FLAGS);           # Send it

  $rbits = "";
  vec($rbits, $self->{"fh"}->fileno(), 1) = 1;
  $ret = 0;                   # Default to unreachable
  $done = 0;
  my $retrans = 0.01;
  my $factor = $self->{"retrans"};
  $finish_time = &time() + $timeout;       # Ping needs to be done by then
  while (!$done && $timeout > 0)
  {
    if ($factor > 1)
    {
      $timeout = $retrans if $timeout > $retrans;
      $retrans*= $factor; # Exponential backoff
    }
    $nfound  = mselect((my $rout=$rbits), undef, undef, $timeout); # Wait for response
    my $why = $!;
    $timeout = $finish_time - &time();   # Get remaining time

    if (!defined($nfound))  # Hmm, a strange error
    {
      $ret = undef;
      $done = 1;
    }
    elsif ($nfound)         # A packet is waiting
    {
      $from_msg = "";
      $from_saddr = recv($self->{"fh"}, $from_msg, 1500, UDP_FLAGS);
      if (!$from_saddr) {
        # For example an unreachable host will make recv() fail.
        if (!$self->{"econnrefused"} &&
            ($! == ECONNREFUSED ||
             $! == ECONNRESET)) {
          # "Connection refused" means reachable
          # Good, continue
          $ret = 1;
        }
        $done = 1;
      } else {
        ($from_port, $from_ip) = sockaddr_in($from_saddr);
        if (!$source_verify ||
            (($from_ip eq $ip) &&        # Does the packet check out?
             ($from_port == $self->{"port_num"}) &&
             ($from_msg eq $msg)))
        {
          $ret = 1;       # It's a winner
          $done = 1;
        }
      }
    }
    elsif ($timeout <= 0)              # Oops, timed out
    {
      $done = 1;
    }
    else
    {
      # Send another in case the last one dropped
      if (send($self->{"fh"}, $msg, UDP_FLAGS)) {
        # Another send worked?  The previous udp packet
        # must have gotten lost or is still in transit.
        # Hopefully this new packet will arrive safely.
      } else {
        if (!$self->{"econnrefused"} &&
            $! == ECONNREFUSED) {
          # "Connection refused" means reachable
          # Good, continue
          $ret = 1;
        }
        $done = 1;
      }
    }
  }
  return $ret;
}

# Description: Send a TCP SYN packet to host specified.
sub ping_syn
{
  my $self = shift;
  my $host = shift;
  my $ip = shift;
  my $start_time = shift;
  my $stop_time = shift;

  if ($syn_forking) {
    return $self->ping_syn_fork($host, $ip, $start_time, $stop_time);
  }

  my $fh = FileHandle->new();
  my $saddr = sockaddr_in($self->{"port_num"}, $ip);

  # Create TCP socket
  if (!socket ($fh, PF_INET, SOCK_STREAM, $self->{"proto_num"})) {
    croak("tcp socket error - $!");
  }

  if (defined $self->{"local_addr"} &&
      !CORE::bind($fh, sockaddr_in(0, $self->{"local_addr"}))) {
    croak("tcp bind error - $!");
  }

  if ($self->{'device'}) {
    setsockopt($fh, SOL_SOCKET, SO_BINDTODEVICE(), pack("Z*", $self->{'device'}))
      or croak("error binding to device $self->{'device'} $!");
  }
  if ($self->{'tos'}) {
    setsockopt($fh, IPPROTO_IP, IP_TOS, pack("I*", $self->{'tos'}))
      or croak "error configuring tos to $self->{'tos'} $!";
  }
  # Set O_NONBLOCK property on filehandle
  $self->socket_blocking_mode($fh, 0);

  # Attempt the non-blocking connect
  # by just sending the TCP SYN packet
  if (connect($fh, $saddr)) {
    # Non-blocking, yet still connected?
    # Must have connected very quickly,
    # or else it wasn't very non-blocking.
    #warn "WARNING: Nonblocking connect connected anyway? ($^O)";
  } else {
    # Error occurred connecting.
    if ($! == EINPROGRESS || ($^O eq 'MSWin32' && $! == EWOULDBLOCK)) {
      # The connection is just still in progress.
      # This is the expected condition.
    } else {
      # Just save the error and continue on.
      # The ack() can check the status later.
      $self->{"bad"}->{$host} = $!;
    }
  }

  my $entry = [ $host, $ip, $fh, $start_time, $stop_time ];
  $self->{"syn"}->{$fh->fileno} = $entry;
  if ($self->{"stop_time"} < $stop_time) {
    $self->{"stop_time"} = $stop_time;
  }
  vec($self->{"wbits"}, $fh->fileno, 1) = 1;

  return 1;
}

sub ping_syn_fork {
  my ($self, $host, $ip, $start_time, $stop_time) = @_;

  # Buggy Winsock API doesn't allow nonblocking connect.
  # Hence, if our OS is Windows, we need to create a separate
  # process to do the blocking connect attempt.
  my $pid = fork();
  if (defined $pid) {
    if ($pid) {
      # Parent process
      my $entry = [ $host, $ip, $pid, $start_time, $stop_time ];
      $self->{"syn"}->{$pid} = $entry;
      if ($self->{"stop_time"} < $stop_time) {
        $self->{"stop_time"} = $stop_time;
      }
    } else {
      # Child process
      my $saddr = sockaddr_in($self->{"port_num"}, $ip);

      # Create TCP socket
      if (!socket ($self->{"fh"}, PF_INET, SOCK_STREAM, $self->{"proto_num"})) {
        croak("tcp socket error - $!");
      }

      if (defined $self->{"local_addr"} &&
          !CORE::bind($self->{"fh"}, sockaddr_in(0, $self->{"local_addr"}))) {
        croak("tcp bind error - $!");
      }

      if ($self->{'device'}) {
        setsockopt($self->{"fh"}, SOL_SOCKET, SO_BINDTODEVICE(), pack("Z*", $self->{'device'}))
          or croak("error binding to device $self->{'device'} $!");
      }
      if ($self->{'tos'}) {
        setsockopt($self->{"fh"}, IPPROTO_IP, IP_TOS, pack("I*", $self->{'tos'}))
          or croak "error configuring tos to $self->{'tos'} $!";
      }

      $!=0;
      # Try to connect (could take a long time)
      connect($self->{"fh"}, $saddr);
      # Notify parent of connect error status
      my $err = $!+0;
      my $wrstr = "$$ $err";
      # Force to 16 chars including \n
      $wrstr .= " "x(15 - length $wrstr). "\n";
      syswrite($self->{"fork_wr"}, $wrstr, length $wrstr);
      exit;
    }
  } else {
    # fork() failed?
    die "fork: $!";
  }
  return 1;
}

# Description: Wait for TCP ACK from host specified
# from ping_syn above.  If no host is specified, wait
# for TCP ACK from any of the hosts in the SYN queue.
sub ack
{
  my $self = shift;

  if ($self->{"proto"} eq "syn") {
    if ($syn_forking) {
      my @answer = $self->ack_unfork(shift);
      return wantarray ? @answer : $answer[0];
    }
    my $wbits = "";
    my $stop_time = 0;
    if (my $host = shift) {
      # Host passed as arg
      if (exists $self->{"bad"}->{$host}) {
        if (!$self->{"econnrefused"} &&
            $self->{"bad"}->{ $host } &&
            (($! = ECONNREFUSED)>0) &&
            $self->{"bad"}->{ $host } eq "$!") {
          # "Connection refused" means reachable
          # Good, continue
        } else {
          # ECONNREFUSED means no good
          return ();
        }
      }
      my $host_fd = undef;
      foreach my $fd (keys %{ $self->{"syn"} }) {
        my $entry = $self->{"syn"}->{$fd};
        if ($entry->[0] eq $host) {
          $host_fd = $fd;
          $stop_time = $entry->[4]
            || croak("Corrupted SYN entry for [$host]");
          last;
        }
      }
      croak("ack called on [$host] without calling ping first!")
        unless defined $host_fd;
      vec($wbits, $host_fd, 1) = 1;
    } else {
      # No $host passed so scan all hosts
      # Use the latest stop_time
      $stop_time = $self->{"stop_time"};
      # Use all the bits
      $wbits = $self->{"wbits"};
    }

    while ($wbits !~ /^\0*\z/) {
      my $timeout = $stop_time - &time();
      # Force a minimum of 10 ms timeout.
      $timeout = 0.01 if $timeout <= 0.01;

      my $winner_fd = undef;
      my $wout = $wbits;
      my $fd = 0;
      # Do "bad" fds from $wbits first
      while ($wout !~ /^\0*\z/) {
        if (vec($wout, $fd, 1)) {
          # Wipe it from future scanning.
          vec($wout, $fd, 1) = 0;
          if (my $entry = $self->{"syn"}->{$fd}) {
            if ($self->{"bad"}->{ $entry->[0] }) {
              $winner_fd = $fd;
              last;
            }
          }
        }
        $fd++;
      }

      if (defined($winner_fd) or my $nfound = mselect(undef, ($wout=$wbits), undef, $timeout)) {
        if (defined $winner_fd) {
          $fd = $winner_fd;
        } else {
          # Done waiting for one of the ACKs
          $fd = 0;
          # Determine which one
          while ($wout !~ /^\0*\z/ &&
                 !vec($wout, $fd, 1)) {
            $fd++;
          }
        }
        if (my $entry = $self->{"syn"}->{$fd}) {
          # Wipe it from future scanning.
          delete $self->{"syn"}->{$fd};
          vec($self->{"wbits"}, $fd, 1) = 0;
          vec($wbits, $fd, 1) = 0;
          if (!$self->{"econnrefused"} &&
              $self->{"bad"}->{ $entry->[0] } &&
              (($! = ECONNREFUSED)>0) &&
              $self->{"bad"}->{ $entry->[0] } eq "$!") {
            # "Connection refused" means reachable
            # Good, continue
          } elsif (getpeername($entry->[2])) {
            # Connection established to remote host
            # Good, continue
          } else {
            # TCP ACK will never come from this host
            # because there was an error connecting.

            # This should set $! to the correct error.
            my $char;
            sysread($entry->[2],$char,1);
            # Store the excuse why the connection failed.
            $self->{"bad"}->{$entry->[0]} = $!;
            if (!$self->{"econnrefused"} &&
                (($! == ECONNREFUSED) ||
                 ($! == EAGAIN && $^O =~ /cygwin/i))) {
              # "Connection refused" means reachable
              # Good, continue
            } else {
              # No good, try the next socket...
              next;
            }
          }
          # Everything passed okay, return the answer
          return wantarray ?
            ($entry->[0], &time() - $entry->[3], $self->ntop($entry->[1]))
            : $entry->[0];
        } else {
          warn "Corrupted SYN entry: unknown fd [$fd] ready!";
          vec($wbits, $fd, 1) = 0;
          vec($self->{"wbits"}, $fd, 1) = 0;
        }
      } elsif (defined $nfound) {
        # Timed out waiting for ACK
        foreach my $fd (keys %{ $self->{"syn"} }) {
          if (vec($wbits, $fd, 1)) {
            my $entry = $self->{"syn"}->{$fd};
            $self->{"bad"}->{$entry->[0]} = "Timed out";
            vec($wbits, $fd, 1) = 0;
            vec($self->{"wbits"}, $fd, 1) = 0;
            delete $self->{"syn"}->{$fd};
          }
        }
      } else {
        # Weird error occurred with select()
        warn("select: $!");
        $self->{"syn"} = {};
        $wbits = "";
      }
    }
  }
  return ();
}

sub ack_unfork {
  my ($self,$host) = @_;
  my $stop_time = $self->{"stop_time"};
  if ($host) {
    # Host passed as arg
    if (my $entry = $self->{"good"}->{$host}) {
      delete $self->{"good"}->{$host};
      return ($entry->[0], &time() - $entry->[3], $self->ntop($entry->[1]));
    }
  }

  my $rbits = "";
  my $timeout;

  if (keys %{ $self->{"syn"} }) {
    # Scan all hosts that are left
    vec($rbits, fileno($self->{"fork_rd"}), 1) = 1;
    $timeout = $stop_time - &time();
    # Force a minimum of 10 ms timeout.
    $timeout = 0.01 if $timeout < 0.01;
  } else {
    # No hosts left to wait for
    $timeout = 0;
  }

  if ($timeout > 0) {
    my $nfound;
    while ( keys %{ $self->{"syn"} } and
           $nfound = mselect((my $rout=$rbits), undef, undef, $timeout)) {
      # Done waiting for one of the ACKs
      if (!sysread($self->{"fork_rd"}, $_, 16)) {
        # Socket closed, which means all children are done.
        return ();
      }
      my ($pid, $how) = split;
      if ($pid) {
        # Flush the zombie
        waitpid($pid, 0);
        if (my $entry = $self->{"syn"}->{$pid}) {
          # Connection attempt to remote host is done
          delete $self->{"syn"}->{$pid};
          if (!$how || # If there was no error connecting
              (!$self->{"econnrefused"} &&
               $how == ECONNREFUSED)) {  # "Connection refused" means reachable
            if ($host && $entry->[0] ne $host) {
              # A good connection, but not the host we need.
              # Move it from the "syn" hash to the "good" hash.
              $self->{"good"}->{$entry->[0]} = $entry;
              # And wait for the next winner
              next;
            }
            return ($entry->[0], &time() - $entry->[3], $self->ntop($entry->[1]));
          }
        } else {
          # Should never happen
          die "Unknown ping from pid [$pid]";
        }
      } else {
        die "Empty response from status socket?";
      }
    }
    if (defined $nfound) {
      # Timed out waiting for ACK status
    } else {
      # Weird error occurred with select()
      warn("select: $!");
    }
  }
  if (my @synners = keys %{ $self->{"syn"} }) {
    # Kill all the synners
    kill 9, @synners;
    foreach my $pid (@synners) {
      # Wait for the deaths to finish
      # Then flush off the zombie
      waitpid($pid, 0);
    }
  }
  $self->{"syn"} = {};
  return ();
}

# Description:  Tell why the ack() failed
sub nack {
  my $self = shift;
  my $host = shift || croak('Usage> nack($failed_ack_host)');
  return $self->{"bad"}->{$host} || undef;
}

# Description:  Close the connection.

sub close
{
  my ($self) = @_;

  if ($self->{"proto"} eq "syn") {
    delete $self->{"syn"};
  } elsif ($self->{"proto"} eq "tcp") {
    # The connection will already be closed
  } elsif ($self->{"proto"} eq "external") {
    # Nothing to close
  } else {
    $self->{"fh"}->close();
  }
}

sub port_number {
   my $self = shift;
   if(@_) {
       $self->{port_num} = shift @_;
       $self->service_check(1);
   }
   return $self->{port_num};
}

sub ntop {
    my($self, $ip) = @_;

    # Vista doesn't define a inet_ntop.  It has InetNtop instead.
    # Not following ANSI... priceless.  getnameinfo() is defined
    # for Windows 2000 and later, so that may be the choice.

    # Any port will work, even undef, but this will work for now.
    # Socket warns when undef is passed in, but it still works.
    my $port = getservbyname('echo', 'udp');
    my $sockaddr = sockaddr_in $port, $ip;
    my ($error, $address) = getnameinfo($sockaddr, NI_NUMERICHOST);
    if($error) {
      croak $error;
    }
    return $address;
}

1;
__END__

=head1 NAME

Net::Ping - check a remote host for reachability

=head1 SYNOPSIS

    use Net::Ping;

    $p = Net::Ping->new();
    print "$host is alive.\n" if $p->ping($host);
    $p->close();

    $p = Net::Ping->new("icmp");
    $p->bind($my_addr); # Specify source interface of pings
    foreach $host (@host_array)
    {
        print "$host is ";
        print "NOT " unless $p->ping($host, 2);
        print "reachable.\n";
        sleep(1);
    }
    $p->close();

    $p = Net::Ping->new("tcp", 2);
    # Try connecting to the www port instead of the echo port
    $p->port_number(scalar(getservbyname("http", "tcp")));
    while ($stop_time > time())
    {
        print "$host not reachable ", scalar(localtime()), "\n"
            unless $p->ping($host);
        sleep(300);
    }
    undef($p);

    # Like tcp protocol, but with many hosts
    $p = Net::Ping->new("syn");
    $p->port_number(getservbyname("http", "tcp"));
    foreach $host (@host_array) {
      $p->ping($host);
    }
    while (($host,$rtt,$ip) = $p->ack) {
      print "HOST: $host [$ip] ACKed in $rtt seconds.\n";
    }

    # High precision syntax (requires Time::HiRes)
    $p = Net::Ping->new();
    $p->hires();
    ($ret, $duration, $ip) = $p->ping($host, 5.5);
    printf("$host [ip: $ip] is alive (packet return time: %.2f ms)\n",
            1000 * $duration)
      if $ret;
    $p->close();

    # For backward compatibility
    print "$host is alive.\n" if pingecho($host);

=head1 DESCRIPTION

This module contains methods to test the reachability of remote
hosts on a network.  A ping object is first created with optional
parameters, a variable number of hosts may be pinged multiple
times and then the connection is closed.

You may choose one of six different protocols to use for the
ping. The "tcp" protocol is the default. Note that a live remote host
may still fail to be pingable by one or more of these protocols. For
example, www.microsoft.com is generally alive but not "icmp" pingable.

With the "tcp" protocol the ping() method attempts to establish a
connection to the remote host's echo port.  If the connection is
successfully established, the remote host is considered reachable.  No
data is actually echoed.  This protocol does not require any special
privileges but has higher overhead than the "udp" and "icmp" protocols.

Specifying the "udp" protocol causes the ping() method to send a udp
packet to the remote host's echo port.  If the echoed packet is
received from the remote host and the received packet contains the
same data as the packet that was sent, the remote host is considered
reachable.  This protocol does not require any special privileges.
It should be borne in mind that, for a udp ping, a host
will be reported as unreachable if it is not running the
appropriate echo service.  For Unix-like systems see L<inetd(8)>
for more information.

If the "icmp" protocol is specified, the ping() method sends an icmp
echo message to the remote host, which is what the UNIX ping program
does.  If the echoed message is received from the remote host and
the echoed information is correct, the remote host is considered
reachable.  Specifying the "icmp" protocol requires that the program
be run as root or that the program be setuid to root.

If the "external" protocol is specified, the ping() method attempts to
use the C<Net::Ping::External> module to ping the remote host.
C<Net::Ping::External> interfaces with your system's default C<ping>
utility to perform the ping, and generally produces relatively
accurate results. If C<Net::Ping::External> if not installed on your
system, specifying the "external" protocol will result in an error.

If the "syn" protocol is specified, the ping() method will only
send a TCP SYN packet to the remote host then immediately return.
If the syn packet was sent successfully, it will return a true value,
otherwise it will return false.  NOTE: Unlike the other protocols,
the return value does NOT determine if the remote host is alive or
not since the full TCP three-way handshake may not have completed
yet.  The remote host is only considered reachable if it receives
a TCP ACK within the timeout specified.  To begin waiting for the
ACK packets, use the ack() method as explained below.  Use the
"syn" protocol instead the "tcp" protocol to determine reachability
of multiple destinations simultaneously by sending parallel TCP
SYN packets.  It will not block while testing each remote host.
demo/fping is provided in this distribution to demonstrate the
"syn" protocol as an example.
This protocol does not require any special privileges.

=head2 Functions

=over 4

=item Net::Ping->new([$proto [, $def_timeout [, $bytes [, $device [, $tos [, $ttl ]]]]]]);

Create a new ping object.  All of the parameters are optional.  $proto
specifies the protocol to use when doing a ping.  The current choices
are "tcp", "udp", "icmp", "stream", "syn", or "external".
The default is "tcp".

If a default timeout ($def_timeout) in seconds is provided, it is used
when a timeout is not given to the ping() method (below).  The timeout
must be greater than 0 and the default, if not specified, is 5 seconds.

If the number of data bytes ($bytes) is given, that many data bytes
are included in the ping packet sent to the remote host. The number of
data bytes is ignored if the protocol is "tcp".  The minimum (and
default) number of data bytes is 1 if the protocol is "udp" and 0
otherwise.  The maximum number of data bytes that can be specified is
1024.

If $device is given, this device is used to bind the source endpoint
before sending the ping packet.  I believe this only works with
superuser privileges and with udp and icmp protocols at this time.

If $tos is given, this ToS is configured into the socket.

For icmp, $ttl can be specified to set the TTL of the outgoing packet.

=item $p->ping($host [, $timeout]);

Ping the remote host and wait for a response.  $host can be either the
hostname or the IP number of the remote host.  The optional timeout
must be greater than 0 seconds and defaults to whatever was specified
when the ping object was created.  Returns a success flag.  If the
hostname cannot be found or there is a problem with the IP number, the
success flag returned will be undef.  Otherwise, the success flag will
be 1 if the host is reachable and 0 if it is not.  For most practical
purposes, undef and 0 and can be treated as the same case.  In array
context, the elapsed time as well as the string form of the ip the
host resolved to are also returned.  The elapsed time value will
be a float, as returned by the Time::HiRes::time() function, if hires()
has been previously called, otherwise it is returned as an integer.

=item $p->source_verify( { 0 | 1 } );

Allows source endpoint verification to be enabled or disabled.
This is useful for those remote destinations with multiples
interfaces where the response may not originate from the same
endpoint that the original destination endpoint was sent to.
This only affects udp and icmp protocol pings.

This is enabled by default.

=item $p->service_check( { 0 | 1 } );

Set whether or not the connect behavior should enforce
remote service availability as well as reachability.  Normally,
if the remote server reported ECONNREFUSED, it must have been
reachable because of the status packet that it reported.
With this option enabled, the full three-way tcp handshake
must have been established successfully before it will
claim it is reachable.  NOTE:  It still does nothing more
than connect and disconnect.  It does not speak any protocol
(i.e., HTTP or FTP) to ensure the remote server is sane in
any way.  The remote server CPU could be grinding to a halt
and unresponsive to any clients connecting, but if the kernel
throws the ACK packet, it is considered alive anyway.  To
really determine if the server is responding well would be
application specific and is beyond the scope of Net::Ping.
For udp protocol, enabling this option demands that the
remote server replies with the same udp data that it was sent
as defined by the udp echo service.

This affects the "udp", "tcp", and "syn" protocols.

This is disabled by default.

=item $p->tcp_service_check( { 0 | 1 } );

Deprecated method, but does the same as service_check() method.

=item $p->hires( { 0 | 1 } );

Causes this module to use Time::HiRes module, allowing milliseconds
to be returned by subsequent calls to ping().

This is disabled by default.

=item $p->bind($local_addr);

Sets the source address from which pings will be sent.  This must be
the address of one of the interfaces on the local host.  $local_addr
may be specified as a hostname or as a text IP address such as
"192.168.1.1".

If the protocol is set to "tcp", this method may be called any
number of times, and each call to the ping() method (below) will use
the most recent $local_addr.  If the protocol is "icmp" or "udp",
then bind() must be called at most once per object, and (if it is
called at all) must be called before the first call to ping() for that
object.

=item $p->open($host);

When you are using the "stream" protocol, this call pre-opens the
tcp socket.  It's only necessary to do this if you want to
provide a different timeout when creating the connection, or
remove the overhead of establishing the connection from the
first ping.  If you don't call C<open()>, the connection is
automatically opened the first time C<ping()> is called.
This call simply does nothing if you are using any protocol other
than stream.

=item $p->ack( [ $host ] );

When using the "syn" protocol, use this method to determine
the reachability of the remote host.  This method is meant
to be called up to as many times as ping() was called.  Each
call returns the host (as passed to ping()) that came back
with the TCP ACK.  The order in which the hosts are returned
may not necessarily be the same order in which they were
SYN queued using the ping() method.  If the timeout is
reached before the TCP ACK is received, or if the remote
host is not listening on the port attempted, then the TCP
connection will not be established and ack() will return
undef.  In list context, the host, the ack time, and the
dotted ip string will be returned instead of just the host.
If the optional $host argument is specified, the return
value will be pertaining to that host only.
This call simply does nothing if you are using any protocol
other than syn.

=item $p->nack( $failed_ack_host );

The reason that host $failed_ack_host did not receive a
valid ACK.  Useful to find out why when ack( $fail_ack_host )
returns a false value.

=item $p->close();

Close the network connection for this ping object.  The network
connection is also closed by "undef $p".  The network connection is
automatically closed if the ping object goes out of scope (e.g. $p is
local to a subroutine and you leave the subroutine).

=item $p->port_number([$port_number])

When called with a port number, the port number used to ping is set to
$port_number rather than using the echo port.  It also has the effect
of calling C<$p-E<gt>service_check(1)> causing a ping to return a successful
response only if that specific port is accessible.  This function returns
the value of the port that C<ping()> will connect to.

=item pingecho($host [, $timeout]);

To provide backward compatibility with the previous version of
Net::Ping, a pingecho() subroutine is available with the same
functionality as before.  pingecho() uses the tcp protocol.  The
return values and parameters are the same as described for the ping()
method.  This subroutine is obsolete and may be removed in a future
version of Net::Ping.

=back

=head1 NOTES

There will be less network overhead (and some efficiency in your
program) if you specify either the udp or the icmp protocol.  The tcp
protocol will generate 2.5 times or more traffic for each ping than
either udp or icmp.  If many hosts are pinged frequently, you may wish
to implement a small wait (e.g. 25ms or more) between each ping to
avoid flooding your network with packets.

The icmp protocol requires that the program be run as root or that it
be setuid to root.  The other protocols do not require special
privileges, but not all network devices implement tcp or udp echo.

Local hosts should normally respond to pings within milliseconds.
However, on a very congested network it may take up to 3 seconds or
longer to receive an echo packet from the remote host.  If the timeout
is set too low under these conditions, it will appear that the remote
host is not reachable (which is almost the truth).

Reachability doesn't necessarily mean that the remote host is actually
functioning beyond its ability to echo packets.  tcp is slightly better
at indicating the health of a system than icmp because it uses more
of the networking stack to respond.

Because of a lack of anything better, this module uses its own
routines to pack and unpack ICMP packets.  It would be better for a
separate module to be written which understands all of the different
kinds of ICMP packets.

=head1 INSTALL

The latest source tree is available via cvs:

  cvs -z3 -q -d \
    :pserver:anonymous@cvs.roobik.com.:/usr/local/cvsroot/freeware \
    checkout Net-Ping
  cd Net-Ping

The tarball can be created as follows:

  perl Makefile.PL ; make ; make dist

The latest Net::Ping release can be found at CPAN:

  $CPAN/modules/by-module/Net/

1) Extract the tarball

  gtar -zxvf Net-Ping-xxxx.tar.gz
  cd Net-Ping-xxxx

2) Build:

  make realclean
  perl Makefile.PL
  make
  make test

3) Install

  make install

Or install it RPM Style:

  rpm -ta SOURCES/Net-Ping-xxxx.tar.gz

  rpm -ih RPMS/noarch/perl-Net-Ping-xxxx.rpm

=head1 BUGS

For a list of known issues, visit:

https://rt.cpan.org/NoAuth/Bugs.html?Dist=Net-Ping

To report a new bug, visit:

https://rt.cpan.org/NoAuth/ReportBug.html?Queue=Net-Ping

=head1 AUTHORS

  Current maintainer:
    bbb@cpan.org (Rob Brown)

  External protocol:
    colinm@cpan.org (Colin McMillen)

  Stream protocol:
    bronson@trestle.com (Scott Bronson)

  Original pingecho():
    karrer@bernina.ethz.ch (Andreas Karrer)
    pmarquess@bfsec.bt.co.uk (Paul Marquess)

  Original Net::Ping author:
    mose@ns.ccsn.edu (Russell Mosemann)

=head1 COPYRIGHT

Copyright (c) 2002-2003, Rob Brown.  All rights reserved.

Copyright (c) 2001, Colin McMillen.  All rights reserved.

This program is free software; you may redistribute it and/or
modify it under the same terms as Perl itself.

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      # Net::Time.pm
#
# Versions up to 2.10 Copyright (c) 1995-2004 Graham Barr <gbarr@pobox.com>.
# All rights reserved.
# Changes in Version 2.11 onwards Copyright (C) 2014 Steve Hay.  All rights
# reserved.
# This module is free software; you can redistribute it and/or modify it under
# the same terms as Perl itself, i.e. under the terms of either the GNU General
# Public License or the Artistic License, as specified in the F<LICENCE> file.

package Net::Time;

use 5.008001;

use strict;
use warnings;

use Carp;
use Exporter;
use IO::Select;
use IO::Socket;
use Net::Config;

our @ISA       = qw(Exporter);
our @EXPORT_OK = qw(inet_time inet_daytime);

our $VERSION = "3.08_01";

our $TIMEOUT = 120;

sub _socket {
  my ($pname, $pnum, $host, $proto, $timeout) = @_;

  $proto ||= 'udp';

  my $port = (getservbyname($pname, $proto))[2] || $pnum;

  my $hosts = defined $host ? [$host] : $NetConfig{$pname . '_hosts'};

  my $me;

  foreach my $addr (@$hosts) {
    $me = IO::Socket::INET->new(
      PeerAddr => $addr,
      PeerPort => $port,
      Proto    => $proto
      )
      and last;
  }

  return unless $me;

  $me->send("\n")
    if $proto eq 'udp';

  $timeout = $TIMEOUT
    unless defined $timeout;

  IO::Select->new($me)->can_read($timeout)
    ? $me
    : undef;
}


sub inet_time {
  my $s      = _socket('time', 37, @_) || return;
  my $buf    = '';
  my $offset = 0 | 0;

  return
    unless defined $s->recv($buf, length(pack("N", 0)));

  # unpack, we | 0 to ensure we have an unsigned
  my $time = (unpack("N", $buf))[0] | 0;

  # the time protocol return time in seconds since 1900, convert
  # it to a the required format

  if ($^O eq "MacOS") {

    # MacOS return seconds since 1904, 1900 was not a leap year.
    $offset = (4 * 31536000) | 0;
  }
  else {

    # otherwise return seconds since 1972, there were 17 leap years between
    # 1900 and 1972
    $offset = (70 * 31536000 + 17 * 86400) | 0;
  }

  $time - $offset;
}


sub inet_daytime {
  my $s   = _socket('daytime', 13, @_) || return;
  my $buf = '';

  defined($s->recv($buf, 1024))
    ? $buf
    : undef;
}

1;

__END__

=head1 NAME

Net::Time - time and daytime network client interface

=head1 SYNOPSIS

    use Net::Time qw(inet_time inet_daytime);

    print inet_time();          # use default host from Net::Config
    print inet_time('localhost');
    print inet_time('localhost', 'tcp');

    print inet_daytime();       # use default host from Net::Config
    print inet_daytime('localhost');
    print inet_daytime('localhost', 'tcp');

=head1 DESCRIPTION

C<Net::Time> provides subroutines that obtain the time on a remote machine.

=over 4

=item inet_time ( [HOST [, PROTOCOL [, TIMEOUT]]])

Obtain the time on C<HOST>, or some default host if C<HOST> is not given
or not defined, using the protocol as defined in RFC868. The optional
argument C<PROTOCOL> should define the protocol to use, either C<tcp> or
C<udp>. The result will be a time value in the same units as returned
by time() or I<undef> upon failure.

=item inet_daytime ( [HOST [, PROTOCOL [, TIMEOUT]]])

Obtain the time on C<HOST>, or some default host if C<HOST> is not given
or not defined, using the protocol as defined in RFC867. The optional
argument C<PROTOCOL> should define the protocol to use, either C<tcp> or
C<udp>. The result will be an ASCII string or I<undef> upon failure.

=back

=head1 AUTHOR

Graham Barr E<lt>F<gbarr@pobox.com>E<gt>

Steve Hay E<lt>F<shay@cpan.org>E<gt> is now maintaining libnet as of version
1.22_02

=head1 COPYRIGHT

Versions up to 2.11 Copyright (c) 1995-2004 Graham Barr. All rights reserved.
Changes in Version 2.11 onwards Copyright (C) 2014 Steve Hay.  All rights
reserved.

This module is free software; you can redistribute it and/or modify it under the
same terms as Perl itself, i.e. under the terms of either the GNU General Public
License or the Artistic License, as specified in the F<LICENCE> file.

=cut
                                                                                                                                                             package Net::hostent;
use strict;

use 5.006_001;
our $VERSION = '1.01';
our(@EXPORT, @EXPORT_OK, %EXPORT_TAGS);
BEGIN { 
    use Exporter   ();
    @EXPORT      = qw(gethostbyname gethostbyaddr gethost);
    @EXPORT_OK   = qw(
			$h_name	    	@h_aliases
			$h_addrtype 	$h_length
			@h_addr_list 	$h_addr
		   );
    %EXPORT_TAGS = ( FIELDS => [ @EXPORT_OK, @EXPORT ] );
}
use vars      @EXPORT_OK;

# Class::Struct forbids use of @ISA
sub import { goto &Exporter::import }

use Class::Struct qw(struct);
struct 'Net::hostent' => [
   name		=> '$',
   aliases	=> '@',
   addrtype	=> '$',
   'length'	=> '$',
   addr_list	=> '@',
];

sub addr { shift->addr_list->[0] }

sub populate (@) {
    return unless @_;
    my $hob = new();
    $h_name 	 =    $hob->[0]     	     = $_[0];
    @h_aliases	 = @{ $hob->[1] } = split ' ', $_[1];
    $h_addrtype  =    $hob->[2] 	     = $_[2];
    $h_length	 =    $hob->[3] 	     = $_[3];
    $h_addr 	 =                             $_[4];
    @h_addr_list = @{ $hob->[4] } =          @_[ (4 .. $#_) ];
    return $hob;
} 

sub gethostbyname ($)  { populate(CORE::gethostbyname(shift)) } 

sub gethostbyaddr ($;$) { 
    my ($addr, $addrtype);
    $addr = shift;
    require Socket unless @_;
    $addrtype = @_ ? shift : Socket::AF_INET();
    populate(CORE::gethostbyaddr($addr, $addrtype)) 
} 

sub gethost($) {
    if ($_[0] =~ /^\d+(?:\.\d+(?:\.\d+(?:\.\d+)?)?)?$/) {
	require Socket;
	&gethostbyaddr(Socket::inet_aton(shift));
    } else {
	&gethostbyname;
    } 
} 

1;
__END__

=head1 NAME

Net::hostent - by-name interface to Perl's built-in gethost*() functions

=head1 SYNOPSIS

 use Net::hostent;

=head1 DESCRIPTION

This module's default exports override the core gethostbyname() and
gethostbyaddr() functions, replacing them with versions that return
"Net::hostent" objects.  This object has methods that return the similarly
named structure field name from the C's hostent structure from F<netdb.h>;
namely name, aliases, addrtype, length, and addr_list.  The aliases and
addr_list methods return array reference, the rest scalars.  The addr
method is equivalent to the zeroth element in the addr_list array
reference.

You may also import all the structure fields directly into your namespace
as regular variables using the :FIELDS import tag.  (Note that this still
overrides your core functions.)  Access these fields as variables named
with a preceding C<h_>.  Thus, C<$host_obj-E<gt>name()> corresponds to
$h_name if you import the fields.  Array references are available as
regular array variables, so for example C<@{ $host_obj-E<gt>aliases()
}> would be simply @h_aliases.

The gethost() function is a simple front-end that forwards a numeric
argument to gethostbyaddr() by way of Socket::inet_aton, and the rest
to gethostbyname().

To access this functionality without the core overrides,
pass the C<use> an empty import list, and then access
function functions with their full qualified names.
On the other hand, the built-ins are still available
via the C<CORE::> pseudo-package.

=head1 EXAMPLES

 use Net::hostent;
 use Socket;

 @ARGV = ('netscape.com') unless @ARGV;

 for $host ( @ARGV ) {

    unless ($h = gethost($host)) {
	warn "$0: no such host: $host\n";
	next;
    }

    printf "\n%s is %s%s\n", 
	    $host, 
	    lc($h->name) eq lc($host) ? "" : "*really* ",
	    $h->name;

    print "\taliases are ", join(", ", @{$h->aliases}), "\n"
		if @{$h->aliases};     

    if ( @{$h->addr_list} > 1 ) { 
	my $i;
	for $addr ( @{$h->addr_list} ) {
	    printf "\taddr #%d is [%s]\n", $i++, inet_ntoa($addr);
	} 
    } else {
	printf "\taddress is [%s]\n", inet_ntoa($h->addr);
    } 

    if ($h = gethostbyaddr($h->addr)) {
	if (lc($h->name) ne lc($host)) {
	    printf "\tThat addr reverses to host %s!\n", $h->name;
	    $host = $h->name;
	    redo;
	} 
    }
 }

=head1 NOTE

While this class is currently implemented using the Class::Struct
module to build a struct-like class, you shouldn't rely upon this.

=head1 AUTHOR

Tom Christiansen
                                                                               package Net::protoent;
use strict;

use 5.006_001;
our $VERSION = '1.00';
our(@EXPORT, @EXPORT_OK, %EXPORT_TAGS);
BEGIN { 
    use Exporter   ();
    @EXPORT      = qw(getprotobyname getprotobynumber getprotoent getproto);
    @EXPORT_OK   = qw( $p_name @p_aliases $p_proto );
    %EXPORT_TAGS = ( FIELDS => [ @EXPORT_OK, @EXPORT ] );
}
use vars      @EXPORT_OK;

# Class::Struct forbids use of @ISA
sub import { goto &Exporter::import }

use Class::Struct qw(struct);
struct 'Net::protoent' => [
   name		=> '$',
   aliases	=> '@',
   proto	=> '$',
];

sub populate (@) {
    return unless @_;
    my $pob = new();
    $p_name 	 =    $pob->[0]     	     = $_[0];
    @p_aliases	 = @{ $pob->[1] } = split ' ', $_[1];
    $p_proto	 =    $pob->[2] 	     = $_[2];
    return $pob;
} 

sub getprotoent      ( )  { populate(CORE::getprotoent()) } 
sub getprotobyname   ($)  { populate(CORE::getprotobyname(shift)) } 
sub getprotobynumber ($)  { populate(CORE::getprotobynumber(shift)) } 

sub getproto ($;$) {
    no strict 'refs';
    return &{'getprotoby' . ($_[0]=~/^\d+$/ ? 'number' : 'name')}(@_);
}

1;

__END__

=head1 NAME

Net::protoent - by-name interface to Perl's built-in getproto*() functions

=head1 SYNOPSIS

 use Net::protoent;
 $p = getprotobyname(shift || 'tcp') || die "no proto";
 printf "proto for %s is %d, aliases are %s\n",
    $p->name, $p->proto, "@{$p->aliases}";

 use Net::protoent qw(:FIELDS);
 getprotobyname(shift || 'tcp') || die "no proto";
 print "proto for $p_name is $p_proto, aliases are @p_aliases\n";

=head1 DESCRIPTION

This module's default exports override the core getprotoent(),
getprotobyname(), and getnetbyport() functions, replacing them with
versions that return "Net::protoent" objects.  They take default
second arguments of "tcp".  This object has methods that return the
similarly named structure field name from the C's protoent structure
from F<netdb.h>; namely name, aliases, and proto.  The aliases method
returns an array reference, the rest scalars.

You may also import all the structure fields directly into your namespace
as regular variables using the :FIELDS import tag.  (Note that this still
overrides your core functions.)  Access these fields as variables named
with a preceding C<p_>.  Thus, C<$proto_obj-E<gt>name()> corresponds to
$p_name if you import the fields.  Array references are available as
regular array variables, so for example C<@{ $proto_obj-E<gt>aliases()
}> would be simply @p_aliases.

The getproto() function is a simple front-end that forwards a numeric
argument to getprotobyport(), and the rest to getprotobyname().

To access this functionality without the core overrides,
pass the C<use> an empty import list, and then access
function functions with their full qualified names.
On the other hand, the built-ins are still available
via the C<CORE::> pseudo-package.

=head1 NOTE

While this class is currently implemented using the Class::Struct
module to build a struct-like class, you shouldn't rely upon this.

=head1 AUTHOR

Tom Christiansen
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   # Net::SMTP.pm
#
# Versions up to 2.31_1 Copyright (c) 1995-2004 Graham Barr <gbarr@pobox.com>.
# All rights reserved.
# Changes in Version 2.31_2 onwards Copyright (C) 2013-2015 Steve Hay.  All
# rights reserved.
# This module is free software; you can redistribute it and/or modify it under
# the same terms as Perl itself, i.e. under the terms of either the GNU General
# Public License or the Artistic License, as specified in the F<LICENCE> file.

package Net::SMTP;

use 5.008001;

use strict;
use warnings;

use Carp;
use IO::Socket;
use Net::Cmd;
use Net::Config;
use Socket;

our $VERSION = "3.08_01";

# Code for detecting if we can use SSL
my $ssl_class = eval {
  require IO::Socket::SSL;
  # first version with default CA on most platforms
  no warnings 'numeric';
  IO::Socket::SSL->VERSION(2.007);
} && 'IO::Socket::SSL';

my $nossl_warn = !$ssl_class &&
  'To use SSL please install IO::Socket::SSL with version>=2.007';

# Code for detecting if we can use IPv6
my $family_key = 'Domain';
my $inet6_class = eval {
  require IO::Socket::IP;
  no warnings 'numeric';
  IO::Socket::IP->VERSION(0.20) || die;
  $family_key = 'Family';
} && 'IO::Socket::IP' || eval {
  require IO::Socket::INET6;
  no warnings 'numeric';
  IO::Socket::INET6->VERSION(2.62);
} && 'IO::Socket::INET6';

sub can_ssl   { $ssl_class };
sub can_inet6 { $inet6_class };

our @ISA = ('Net::Cmd', $inet6_class || 'IO::Socket::INET');

sub new {
  my $self = shift;
  my $type = ref($self) || $self;
  my ($host, %arg);
  if (@_ % 2) {
    $host = shift;
    %arg  = @_;
  }
  else {
    %arg  = @_;
    $host = delete $arg{Host};
  }

  if ($arg{SSL}) {
    # SSL from start
    die $nossl_warn if !$ssl_class;
    $arg{Port} ||= 465;
  }

  my $hosts = defined $host ? $host : $NetConfig{smtp_hosts};
  my $obj;

  $arg{Timeout} = 120 if ! defined $arg{Timeout};

  foreach my $h (@{ref($hosts) ? $hosts : [$hosts]}) {
    $obj = $type->SUPER::new(
      PeerAddr => ($host = $h),
      PeerPort => $arg{Port} || 'smtp(25)',
      LocalAddr => $arg{LocalAddr},
      LocalPort => $arg{LocalPort},
      $family_key => $arg{Domain} || $arg{Family},
      Proto     => 'tcp',
      Timeout   => $arg{Timeout}
      )
      and last;
  }

  return
    unless defined $obj;

  ${*$obj}{'net_smtp_arg'} = \%arg;
  ${*$obj}{'net_smtp_host'} = $host;

  if ($arg{SSL}) {
    Net::SMTP::_SSL->start_SSL($obj,%arg)
      or return;
  }

  $obj->autoflush(1);

  $obj->debug(exists $arg{Debug} ? $arg{Debug} : undef);

  unless ($obj->response() == CMD_OK) {
    my $err = ref($obj) . ": " . $obj->code . " " . $obj->message;
    $obj->close();
    $@ = $err;
    return;
  }

  ${*$obj}{'net_smtp_exact_addr'} = $arg{ExactAddresses};

  (${*$obj}{'net_smtp_banner'}) = $obj->message;
  (${*$obj}{'net_smtp_domain'}) = $obj->message =~ /\A\s*(\S+)/;

  if (!exists $arg{SendHello} || $arg{SendHello}) {
    unless ($obj->hello($arg{Hello} || "")) {
      my $err = ref($obj) . ": " . $obj->code . " " . $obj->message;
      $obj->close();
      $@ = $err;
      return;
    }
  }

  $obj;
}


sub host {
  my $me = shift;
  ${*$me}{'net_smtp_host'};
}

##
## User interface methods
##


sub banner {
  my $me = shift;

  return ${*$me}{'net_smtp_banner'} || undef;
}


sub domain {
  my $me = shift;

  return ${*$me}{'net_smtp_domain'} || undef;
}


sub etrn {
  my $self = shift;
  defined($self->supports('ETRN', 500, ["Command unknown: 'ETRN'"]))
    && $self->_ETRN(@_);
}


sub auth {
  my ($self, $username, $password) = @_;

  eval {
    require MIME::Base64;
    require Authen::SASL;
  } or $self->set_status(500, ["Need MIME::Base64 and Authen::SASL todo auth"]), return 0;

  my $mechanisms = $self->supports('AUTH', 500, ["Command unknown: 'AUTH'"]);
  return unless defined $mechanisms;

  my $sasl;

  if (ref($username) and UNIVERSAL::isa($username, 'Authen::SASL')) {
    $sasl = $username;
    my $requested_mechanisms = $sasl->mechanism();
    if (! defined($requested_mechanisms) || $requested_mechanisms eq '') {
      $sasl->mechanism($mechanisms);
    }
  }
  else {
    die "auth(username, password)" if not length $username;
    $sasl = Authen::SASL->new(
      mechanism => $mechanisms,
      callback  => {
        user     => $username,
        pass     => $password,
        authname => $username,
      },
      debug => $self->debug
    );
  }

  my $client;
  my $str;
  do {
    if ($client) {
      # $client mechanism failed, so we need to exclude this mechanism from list
      my $failed_mechanism = $client->mechanism;
      return unless defined $failed_mechanism;
      $self->debug_text("Auth mechanism failed: $failed_mechanism")
        if $self->debug;
      $mechanisms =~ s/\b\Q$failed_mechanism\E\b//;
      return unless $mechanisms =~ /\S/;
      $sasl->mechanism($mechanisms);
    }
    
    # We should probably allow the user to pass the host, but I don't
    # currently know and SASL mechanisms that are used by smtp that need it

    $client = $sasl->client_new('smtp', ${*$self}{'net_smtp_host'}, 0);
    $str    = $client->client_start;
  } while (!defined $str);

  # We don't support sasl mechanisms that encrypt the socket traffic.
  # todo that we would really need to change the ISA hierarchy
  # so we don't inherit from IO::Socket, but instead hold it in an attribute

  my @cmd = ("AUTH", $client->mechanism);
  my $code;

  push @cmd, MIME::Base64::encode_base64($str, '')
    if defined $str and length $str;

  while (($code = $self->command(@cmd)->response()) == CMD_MORE) {
    @cmd = (
      MIME::Base64::encode_base64(
        $client->client_step(MIME::Base64::decode_base64(($self->message)[0])), ''
      )
    );
  }

  $code == CMD_OK;
}


sub hello {
  my $me     = shift;
  my $domain = shift || "localhost.localdomain";
  my $ok     = $me->_EHLO($domain);
  my @msg    = $me->message;

  if ($ok) {
    my $h = ${*$me}{'net_smtp_esmtp'} = {};
    foreach my $ln (@msg) {
      $h->{uc $1} = $2
        if $ln =~ /([-\w]+)\b[= \t]*([^\n]*)/;
    }
  }
  elsif ($me->status == CMD_ERROR) {
    @msg = $me->message
      if $ok = $me->_HELO($domain);
  }

  return unless $ok;
  ${*$me}{net_smtp_hello_domain} = $domain;

  $msg[0] =~ /\A\s*(\S+)/;
  return ($1 || " ");
}

sub starttls {
  my $self = shift;
  $ssl_class or die $nossl_warn;
  $self->_STARTTLS or return;
  Net::SMTP::_SSL->start_SSL($self,
    %{ ${*$self}{'net_smtp_arg'} }, # (ssl) args given in new
    @_   # more (ssl) args
  ) or return;

  # another hello after starttls to read new ESMTP capabilities
  return $self->hello(${*$self}{net_smtp_hello_domain});
}


sub supports {
  my $self = shift;
  my $cmd  = uc shift;
  return ${*$self}{'net_smtp_esmtp'}->{$cmd}
    if exists ${*$self}{'net_smtp_esmtp'}->{$cmd};
  $self->set_status(@_)
    if @_;
  return;
}


sub _addr {
  my $self = shift;
  my $addr = shift;
  $addr = "" unless defined $addr;

  if (${*$self}{'net_smtp_exact_addr'}) {
    return $1 if $addr =~ /^\s*(<.*>)\s*$/s;
  }
  else {
    return $1 if $addr =~ /(<[^>]*>)/;
    $addr =~ s/^\s+|\s+$//sg;
  }

  "<$addr>";
}


sub mail {
  my $me   = shift;
  my $addr = _addr($me, shift);
  my $opts = "";

  if (@_) {
    my %opt = @_;
    my ($k, $v);

    if (exists ${*$me}{'net_smtp_esmtp'}) {
      my $esmtp = ${*$me}{'net_smtp_esmtp'};

      if (defined($v = delete $opt{Size})) {
        if (exists $esmtp->{SIZE}) {
          $opts .= sprintf " SIZE=%d", $v + 0;
        }
        else {
          carp 'Net::SMTP::mail: SIZE option not supported by host';
        }
      }

      if (defined($v = delete $opt{Return})) {
        if (exists $esmtp->{DSN}) {
          $opts .= " RET=" . ((uc($v) eq "FULL") ? "FULL" : "HDRS");
        }
        else {
          carp 'Net::SMTP::mail: DSN option not supported by host';
        }
      }

      if (defined($v = delete $opt{Bits})) {
        if ($v eq "8") {
          if (exists $esmtp->{'8BITMIME'}) {
            $opts .= " BODY=8BITMIME";
          }
          else {
            carp 'Net::SMTP::mail: 8BITMIME option not supported by host';
          }
        }
        elsif ($v eq "binary") {
          if (exists $esmtp->{'BINARYMIME'} && exists $esmtp->{'CHUNKING'}) {
            $opts .= " BODY=BINARYMIME";
            ${*$me}{'net_smtp_chunking'} = 1;
          }
          else {
            carp 'Net::SMTP::mail: BINARYMIME option not supported by host';
          }
        }
        elsif (exists $esmtp->{'8BITMIME'} or exists $esmtp->{'BINARYMIME'}) {
          $opts .= " BODY=7BIT";
        }
        else {
          carp 'Net::SMTP::mail: 8BITMIME and BINARYMIME options not supported by host';
        }
      }

      if (defined($v = delete $opt{Transaction})) {
        if (exists $esmtp->{CHECKPOINT}) {
          $opts .= " TRANSID=" . _addr($me, $v);
        }
        else {
          carp 'Net::SMTP::mail: CHECKPOINT option not supported by host';
        }
      }

      if (defined($v = delete $opt{Envelope})) {
        if (exists $esmtp->{DSN}) {
          $v =~ s/([^\041-\176]|=|\+)/sprintf "+%02X", ord($1)/sge;
          $opts .= " ENVID=$v";
        }
        else {
          carp 'Net::SMTP::mail: DSN option not supported by host';
        }
      }

      if (defined($v = delete $opt{ENVID})) {

        # expected to be in a format as required by RFC 3461, xtext-encoded
        if (exists $esmtp->{DSN}) {
          $opts .= " ENVID=$v";
        }
        else {
          carp 'Net::SMTP::mail: DSN option not supported by host';
        }
      }

      if (defined($v = delete $opt{AUTH})) {

        # expected to be in a format as required by RFC 2554,
        # rfc2821-quoted and xtext-encoded, or <>
        if (exists $esmtp->{AUTH}) {
          $v = '<>' if !defined($v) || $v eq '';
          $opts .= " AUTH=$v";
        }
        else {
          carp 'Net::SMTP::mail: AUTH option not supported by host';
        }
      }

      if (defined($v = delete $opt{XVERP})) {
        if (exists $esmtp->{'XVERP'}) {
          $opts .= " XVERP";
        }
        else {
          carp 'Net::SMTP::mail: XVERP option not supported by host';
        }
      }

      carp 'Net::SMTP::recipient: unknown option(s) ' . join(" ", keys %opt) . ' - ignored'
        if scalar keys %opt;
    }
    else {
      carp 'Net::SMTP::mail: ESMTP not supported by host - options discarded :-(';
    }
  }

  $me->_MAIL("FROM:" . $addr . $opts);
}


sub send          { my $me = shift; $me->_SEND("FROM:" . _addr($me, $_[0])) }
sub send_or_mail  { my $me = shift; $me->_SOML("FROM:" . _addr($me, $_[0])) }
sub send_and_mail { my $me = shift; $me->_SAML("FROM:" . _addr($me, $_[0])) }


sub reset {
  my $me = shift;

  $me->dataend()
    if (exists ${*$me}{'net_smtp_lastch'});

  $me->_RSET();
}


sub recipient {
  my $smtp     = shift;
  my $opts     = "";
  my $skip_bad = 0;

  if (@_ && ref($_[-1])) {
    my %opt = %{pop(@_)};
    my $v;

    $skip_bad = delete $opt{'SkipBad'};

    if (exists ${*$smtp}{'net_smtp_esmtp'}) {
      my $esmtp = ${*$smtp}{'net_smtp_esmtp'};

      if (defined($v = delete $opt{Notify})) {
        if (exists $esmtp->{DSN}) {
          $opts .= " NOTIFY=" . join(",", map { uc $_ } @$v);
        }
        else {
          carp 'Net::SMTP::recipient: DSN option not supported by host';
        }
      }

      if (defined($v = delete $opt{ORcpt})) {
        if (exists $esmtp->{DSN}) {
          $opts .= " ORCPT=" . $v;
        }
        else {
          carp 'Net::SMTP::recipient: DSN option not supported by host';
        }
      }

      carp 'Net::SMTP::recipient: unknown option(s) ' . join(" ", keys %opt) . ' - ignored'
        if scalar keys %opt;
    }
    elsif (%opt) {
      carp 'Net::SMTP::recipient: ESMTP not supported by host - options discarded :-(';
    }
  }

  my @ok;
  foreach my $addr (@_) {
    if ($smtp->_RCPT("TO:" . _addr($smtp, $addr) . $opts)) {
      push(@ok, $addr) if $skip_bad;
    }
    elsif (!$skip_bad) {
      return 0;
    }
  }

  return $skip_bad ? @ok : 1;
}

BEGIN {
  *to  = \&recipient;
  *cc  = \&recipient;
  *bcc = \&recipient;
}


sub data {
  my $me = shift;

  if (exists ${*$me}{'net_smtp_chunking'}) {
    carp 'Net::SMTP::data: CHUNKING extension in use, must call bdat instead';
  }
  else {
    my $ok = $me->_DATA() && $me->datasend(@_);

    $ok && @_
      ? $me->dataend
      : $ok;
  }
}


sub bdat {
  my $me = shift;

  if (exists ${*$me}{'net_smtp_chunking'}) {
    my $data = shift;

    $me->_BDAT(length $data)
      && $me->rawdatasend($data)
      && $me->response() == CMD_OK;
  }
  else {
    carp 'Net::SMTP::bdat: CHUNKING extension is not in use, call data instead';
  }
}


sub bdatlast {
  my $me = shift;

  if (exists ${*$me}{'net_smtp_chunking'}) {
    my $data = shift;

    $me->_BDAT(length $data, "LAST")
      && $me->rawdatasend($data)
      && $me->response() == CMD_OK;
  }
  else {
    carp 'Net::SMTP::bdat: CHUNKING extension is not in use, call data instead';
  }
}


sub datafh {
  my $me = shift;
  return unless $me->_DATA();
  return $me->tied_fh;
}


sub expand {
  my $me = shift;

  $me->_EXPN(@_)
    ? ($me->message)
    : ();
}


sub verify { shift->_VRFY(@_) }


sub help {
  my $me = shift;

  $me->_HELP(@_)
    ? scalar $me->message
    : undef;
}


sub quit {
  my $me = shift;

  $me->_QUIT;
  $me->close;
}


sub DESTROY {

  # ignore
}

##
## RFC821 commands
##


sub _EHLO { shift->command("EHLO", @_)->response() == CMD_OK }
sub _HELO { shift->command("HELO", @_)->response() == CMD_OK }
sub _MAIL { shift->command("MAIL", @_)->response() == CMD_OK }
sub _RCPT { shift->command("RCPT", @_)->response() == CMD_OK }
sub _SEND { shift->command("SEND", @_)->response() == CMD_OK }
sub _SAML { shift->command("SAML", @_)->response() == CMD_OK }
sub _SOML { shift->command("SOML", @_)->response() == CMD_OK }
sub _VRFY { shift->command("VRFY", @_)->response() == CMD_OK }
sub _EXPN { shift->command("EXPN", @_)->response() == CMD_OK }
sub _HELP { shift->command("HELP", @_)->response() == CMD_OK }
sub _RSET { shift->command("RSET")->response() == CMD_OK }
sub _NOOP { shift->command("NOOP")->response() == CMD_OK }
sub _QUIT { shift->command("QUIT")->response() == CMD_OK }
sub _DATA { shift->command("DATA")->response() == CMD_MORE }
sub _BDAT { shift->command("BDAT", @_) }
sub _TURN { shift->unsupported(@_); }
sub _ETRN { shift->command("ETRN", @_)->response() == CMD_OK }
sub _AUTH { shift->command("AUTH", @_)->response() == CMD_OK }
sub _STARTTLS { shift->command("STARTTLS")->response() == CMD_OK }


{
  package Net::SMTP::_SSL;
  our @ISA = ( $ssl_class ? ($ssl_class):(), 'Net::SMTP' );
  sub starttls { die "SMTP connection is already in SSL mode" }
  sub start_SSL {
    my ($class,$smtp,%arg) = @_;
    delete @arg{ grep { !m{^SSL_} } keys %arg };
    ( $arg{SSL_verifycn_name} ||= $smtp->host )
        =~s{(?<!:):[\w()]+$}{}; # strip port
    $arg{SSL_hostname} = $arg{SSL_verifycn_name}
        if ! defined $arg{SSL_hostname} && $class->can_client_sni;
    $arg{SSL_verifycn_scheme} ||= 'smtp';
    my $ok = $class->SUPER::start_SSL($smtp,%arg);
    $@ = $ssl_class->errstr if !$ok;
    return $ok;
  }
}



1;

__END__

=head1 NAME

Net::SMTP - Simple Mail Transfer Protocol Client

=head1 SYNOPSIS

    use Net::SMTP;

    # Constructors
    $smtp = Net::SMTP->new('mailhost');
    $smtp = Net::SMTP->new('mailhost', Timeout => 60);

=head1 DESCRIPTION

This module implements a client interface to the SMTP and ESMTP
protocol, enabling a perl5 application to talk to SMTP servers. This
documentation assumes that you are familiar with the concepts of the
SMTP protocol described in RFC2821.
With L<IO::Socket::SSL> installed it also provides support for implicit and
explicit TLS encryption, i.e. SMTPS or SMTP+STARTTLS.

The Net::SMTP class is a subclass of Net::Cmd and (depending on avaibility) of
IO::Socket::IP, IO::Socket::INET6 or IO::Socket::INET.

=head1 EXAMPLES

This example prints the mail domain name of the SMTP server known as mailhost:

    #!/usr/local/bin/perl -w

    use Net::SMTP;

    $smtp = Net::SMTP->new('mailhost');
    print $smtp->domain,"\n";
    $smtp->quit;

This example sends a small message to the postmaster at the SMTP server
known as mailhost:

    #!/usr/local/bin/perl -w

    use Net::SMTP;

    my $smtp = Net::SMTP->new('mailhost');

    $smtp->mail($ENV{USER});
    if ($smtp->to('postmaster')) {
     $smtp->data();
     $smtp->datasend("To: postmaster\n");
     $smtp->datasend("\n");
     $smtp->datasend("A simple test message\n");
     $smtp->dataend();
    } else {
     print "Error: ", $smtp->message();
    }

    $smtp->quit;

=head1 CONSTRUCTOR

=over 4

=item new ( [ HOST ] [, OPTIONS ] )

This is the constructor for a new Net::SMTP object. C<HOST> is the
name of the remote host to which an SMTP connection is required.

On failure C<undef> will be returned and C<$@> will contain the reason
for the failure.

C<HOST> is optional. If C<HOST> is not given then it may instead be
passed as the C<Host> option described below. If neither is given then
the C<SMTP_Hosts> specified in C<Net::Config> will be used.

C<OPTIONS> are passed in a hash like fashion, using key and value pairs.
Possible options are:

B<Hello> - SMTP requires that you identify yourself. This option
specifies a string to pass as your mail domain. If not given localhost.localdomain
will be used.

B<SendHello> - If false then the EHLO (or HELO) command that is normally sent
when constructing the object will not be sent. In that case the command will
have to be sent manually by calling C<hello()> instead.

B<Host> - SMTP host to connect to. It may be a single scalar (hostname[:port]),
as defined for the C<PeerAddr> option in L<IO::Socket::INET>, or a reference to
an array with hosts to try in turn. The L</host> method will return the value
which was used to connect to the host.
Format - C<PeerHost> from L<IO::Socket::INET> new method.

B<Port> - port to connect to.
Default - 25 for plain SMTP and 465 for immediate SSL.

B<SSL> - If the connection should be done from start with SSL, contrary to later
upgrade with C<starttls>.
You can use SSL arguments as documented in L<IO::Socket::SSL>, but it will
usually use the right arguments already.

B<LocalAddr> and B<LocalPort> - These parameters are passed directly
to IO::Socket to allow binding the socket to a specific local address and port.

B<Domain> - This parameter is passed directly to IO::Socket and makes it
possible to enforce IPv4 connections even if L<IO::Socket::IP> is used as super
class. Alternatively B<Family> can be used.

B<Timeout> - Maximum time, in seconds, to wait for a response from the
SMTP server (default: 120)

B<ExactAddresses> - If true the all ADDRESS arguments must be as
defined by C<addr-spec> in RFC2822. If not given, or false, then
Net::SMTP will attempt to extract the address from the value passed.

B<Debug> - Enable debugging information

B<Port> - Select a port on the remote host to connect to (default is 25)

Example:


    $smtp = Net::SMTP->new('mailhost',
                           Hello => 'my.mail.domain',
                           Timeout => 30,
                           Debug   => 1,
                          );

    # the same
    $smtp = Net::SMTP->new(
                           Host => 'mailhost',
                           Hello => 'my.mail.domain',
                           Timeout => 30,
                           Debug   => 1,
                          );

    # the same with direct SSL
    $smtp = Net::SMTP->new('mailhost',
                           Hello => 'my.mail.domain',
                           Timeout => 30,
                           Debug   => 1,
                           SSL     => 1,
                          );

    # Connect to the default server from Net::config
    $smtp = Net::SMTP->new(
                           Hello => 'my.mail.domain',
                           Timeout => 30,
                          );

=back

=head1 METHODS

Unless otherwise stated all methods return either a I<true> or I<false>
value, with I<true> meaning that the operation was a success. When a method
states that it returns a value, failure will be returned as I<undef> or an
empty list.

C<Net::SMTP> inherits from C<Net::Cmd> so methods defined in C<Net::Cmd> may
be used to send commands to the remote SMTP server in addition to the methods
documented here.

=over 4

=item banner ()

Returns the banner message which the server replied with when the
initial connection was made.

=item domain ()

Returns the domain that the remote SMTP server identified itself as during
connection.

=item hello ( DOMAIN )

Tell the remote server the mail domain which you are in using the EHLO
command (or HELO if EHLO fails).  Since this method is invoked
automatically when the Net::SMTP object is constructed the user should
normally not have to call it manually.

=item host ()

Returns the value used by the constructor, and passed to IO::Socket::INET,
to connect to the host.

=item etrn ( DOMAIN )

Request a queue run for the DOMAIN given.

=item starttls ( SSLARGS )

Upgrade existing plain connection to SSL.
You can use SSL arguments as documented in L<IO::Socket::SSL>, but it will
usually use the right arguments already.

=item auth ( USERNAME, PASSWORD )

=item auth ( SASL )

Attempt SASL authentication. Requires Authen::SASL module. The first form
constructs a new Authen::SASL object using the given username and password;
the second form uses the given Authen::SASL object.

=item mail ( ADDRESS [, OPTIONS] )

=item send ( ADDRESS )

=item send_or_mail ( ADDRESS )

=item send_and_mail ( ADDRESS )

Send the appropriate command to the server MAIL, SEND, SOML or SAML. C<ADDRESS>
is the address of the sender. This initiates the sending of a message. The
method C<recipient> should be called for each address that the message is to
be sent to.

The C<mail> method can some additional ESMTP OPTIONS which is passed
in hash like fashion, using key and value pairs.  Possible options are:

 Size        => <bytes>
 Return      => "FULL" | "HDRS"
 Bits        => "7" | "8" | "binary"
 Transaction => <ADDRESS>
 Envelope    => <ENVID>     # xtext-encodes its argument
 ENVID       => <ENVID>     # similar to Envelope, but expects argument encoded
 XVERP       => 1
 AUTH        => <submitter> # encoded address according to RFC 2554

The C<Return> and C<Envelope> parameters are used for DSN (Delivery
Status Notification).

The submitter address in C<AUTH> option is expected to be in a format as
required by RFC 2554, in an RFC2821-quoted form and xtext-encoded, or <> .

=item reset ()

Reset the status of the server. This may be called after a message has been 
initiated, but before any data has been sent, to cancel the sending of the
message.

=item recipient ( ADDRESS [, ADDRESS, [...]] [, OPTIONS ] )

Notify the server that the current message should be sent to all of the
addresses given. Each address is sent as a separate command to the server.
Should the sending of any address result in a failure then the process is
aborted and a I<false> value is returned. It is up to the user to call
C<reset> if they so desire.

The C<recipient> method can also pass additional case-sensitive OPTIONS as an
anonymous hash using key and value pairs.  Possible options are:

  Notify  => ['NEVER'] or ['SUCCESS','FAILURE','DELAY']  (see below)
  ORcpt   => <ORCPT>
  SkipBad => 1        (to ignore bad addresses)

If C<SkipBad> is true the C<recipient> will not return an error when a bad
address is encountered and it will return an array of addresses that did
succeed.

  $smtp->recipient($recipient1,$recipient2);  # Good
  $smtp->recipient($recipient1,$recipient2, { SkipBad => 1 });  # Good
  $smtp->recipient($recipient1,$recipient2, { Notify => ['FAILURE','DELAY'], SkipBad => 1 });  # Good
  @goodrecips=$smtp->recipient(@recipients, { Notify => ['FAILURE'], SkipBad => 1 });  # Good
  $smtp->recipient("$recipient,$recipient2"); # BAD

Notify is used to request Delivery Status Notifications (DSNs), but your
SMTP/ESMTP service may not respect this request depending upon its version and
your site's SMTP configuration.

Leaving out the Notify option usually defaults an SMTP service to its default
behavior equivalent to ['FAILURE'] notifications only, but again this may be
dependent upon your site's SMTP configuration.

The NEVER keyword must appear by itself if used within the Notify option and "requests
that a DSN not be returned to the sender under any conditions."

  {Notify => ['NEVER']}

  $smtp->recipient(@recipients, { Notify => ['NEVER'], SkipBad => 1 });  # Good

You may use any combination of these three values 'SUCCESS','FAILURE','DELAY' in
the anonymous array reference as defined by RFC3461 (see http://www.ietf.org/rfc/rfc3461.txt
for more information.  Note: quotations in this topic from same.).

A Notify parameter of 'SUCCESS' or 'FAILURE' "requests that a DSN be issued on
successful delivery or delivery failure, respectively."

A Notify parameter of 'DELAY' "indicates the sender's willingness to receive
delayed DSNs.  Delayed DSNs may be issued if delivery of a message has been
delayed for an unusual amount of time (as determined by the Message Transfer
Agent (MTA) at which the message is delayed), but the final delivery status
(whether successful or failure) cannot be determined.  The absence of the DELAY
keyword in a NOTIFY parameter requests that a "delayed" DSN NOT be issued under
any conditions."

  {Notify => ['SUCCESS','FAILURE','DELAY']}

  $smtp->recipient(@recipients, { Notify => ['FAILURE','DELAY'], SkipBad => 1 });  # Good

ORcpt is also part of the SMTP DSN extension according to RFC3461.
It is used to pass along the original recipient that the mail was first
sent to.  The machine that generates a DSN will use this address to inform
the sender, because he can't know if recipients get rewritten by mail servers.
It is expected to be in a format as required by RFC3461, xtext-encoded.

=item to ( ADDRESS [, ADDRESS [...]] )

=item cc ( ADDRESS [, ADDRESS [...]] )

=item bcc ( ADDRESS [, ADDRESS [...]] )

Synonyms for C<recipient>.

=item data ( [ DATA ] )

Initiate the sending of the data from the current message. 

C<DATA> may be a reference to a list or a list and must be encoded by the
caller to octets of whatever encoding is required, e.g. by using the Encode
module's C<encode()> function.

If specified the contents of C<DATA> and a termination string C<".\r\n"> is
sent to the server. The result will be true if the data was accepted.

If C<DATA> is not specified then the result will indicate that the server
wishes the data to be sent. The data must then be sent using the C<datasend>
and C<dataend> methods described in L<Net::Cmd>.

=item bdat ( DATA )

=item bdatlast ( DATA )

Use the alternate DATA command "BDAT" of the data chunking service extension
defined in RFC1830 for efficiently sending large MIME messages.

=item expand ( ADDRESS )

Request the server to expand the given address Returns an array
which contains the text read from the server.

=item verify ( ADDRESS )

Verify that C<ADDRESS> is a legitimate mailing address.

Most sites usually disable this feature in their SMTP service configuration.
Use "Debug => 1" option under new() to see if disabled.

=item help ( [ $subject ] )

Request help text from the server. Returns the text or undef upon failure

=item quit ()

Send the QUIT command to the remote SMTP server and close the socket connection.

=item can_inet6 ()

Returns whether we can use IPv6.

=item can_ssl ()

Returns whether we can use SSL.

=back

=head1 ADDRESSES

Net::SMTP attempts to DWIM with addresses that are passed. For
example an application might extract The From: line from an email
and pass that to mail(). While this may work, it is not recommended.
The application should really use a module like L<Mail::Address>
to extract the mail address and pass that.

If C<ExactAddresses> is passed to the constructor, then addresses
should be a valid rfc2821-quoted address, although Net::SMTP will
accept the address surrounded by angle brackets.

 funny user@domain      WRONG
 "funny user"@domain    RIGHT, recommended
 <"funny user"@domain>  OK

=head1 SEE ALSO

L<Net::Cmd>,
L<IO::Socket::SSL>

=head1 AUTHOR

Graham Barr E<lt>F<gbarr@pobox.com>E<gt>

Steve Hay E<lt>F<shay@cpan.org>E<gt> is now maintaining libnet as of version
1.22_02

=head1 COPYRIGHT

Versions up to 2.31_1 Copyright (c) 1995-2004 Graham Barr. All rights reserved.
Changes in Version 2.31_2 onwards Copyright (C) 2013-2015 Steve Hay.  All rights
reserved.

This module is free software; you can redistribute it and/or modify it under the
same terms as Perl itself, i.e. under the terms of either the GNU General Public
License or the Artistic License, as specified in the F<LICENCE> file.

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            =head1 NAME

libnetFAQ - libnet Frequently Asked Questions

=head1 DESCRIPTION

=head2 Where to get this document

This document is distributed with the libnet distribution, and is also
available on the libnet web page at

    http://search.cpan.org/dist/libnet/

=head2 How to contribute to this document

You may report corrections, additions, and suggestions on the
CPAN Request Tracker at

    http://rt.cpan.org/Public/Bug/Report.html?Queue=libnet

=head1 Author and Copyright Information

Copyright (c) 1997-1998 Graham Barr. All rights reserved.
This document is free; you can redistribute it and/or modify it
under the terms of the Artistic License.

Currently maintained by Steve Hay <shay@cpan.org>.

=head2 Disclaimer

This information is offered in good faith and in the hope that it may
be of use, but is not guaranteed to be correct, up to date, or suitable
for any particular purpose whatsoever.  The authors accept no liability
in respect of this information or its use.


=head1 Obtaining and installing libnet

=head2 What is libnet ?

libnet is a collection of perl5 modules which all related to network
programming. The majority of the modules available provided the
client side of popular server-client protocols that are used in
the internet community.

=head2 Which version of perl do I need ?

This version of libnet requires Perl 5.8.1 or higher.

=head2 What other modules do I need ?

No non-core modules are required for normal use, except on os390,
which requires Convert::EBCDIC.

Authen::SASL is required for AUTH support.

IO::Socket::SSL version 2.007 or higher is required for SSL support.

IO::Socket::IP version 0.20 or IO::Socket::INET6 version 2.62 is
required for IPv6 support.

=head2 What machines support libnet ?

libnet itself is an entirely perl-code distribution so it should work
on any machine that perl runs on.

=head2 Where can I get the latest libnet release

The latest libnet release is always on CPAN, you will find it
in 

 http://search.cpan.org/dist/libnet/

=head1 Using Net::FTP

=head2 How do I download files from an FTP server ?

An example taken from an article posted to comp.lang.perl.misc

    #!/your/path/to/perl

    # a module making life easier

    use Net::FTP;

    # for debugging: $ftp = Net::FTP->new('site','Debug',10);
    # open a connection and log in!

    $ftp = Net::FTP->new('target_site.somewhere.xxx');
    $ftp->login('username','password');

    # set transfer mode to binary

    $ftp->binary();

    # change the directory on the ftp site

    $ftp->cwd('/some/path/to/somewhere/');

    foreach $name ('file1', 'file2', 'file3') {

    # get's arguments are in the following order:
    # ftp server's filename
    # filename to save the transfer to on the local machine
    # can be simply used as get($name) if you want the same name

      $ftp->get($name,$name);
    }

    # ftp done!

    $ftp->quit;

=head2 How do I transfer files in binary mode ?

To transfer files without <LF><CR> translation Net::FTP provides
the C<binary> method

    $ftp->binary;

=head2 How can I get the size of a file on a remote FTP server ?

=head2 How can I get the modification time of a file on a remote FTP server ?

=head2 How can I change the permissions of a file on a remote server ?

The FTP protocol does not have a command for changing the permissions
of a file on the remote server. But some ftp servers may allow a chmod
command to be issued via a SITE command, eg

    $ftp->quot('site chmod 0777',$filename);

But this is not guaranteed to work.

=head2 Can I do a reget operation like the ftp command ?

=head2 How do I get a directory listing from an FTP server ?

=head2 Changing directory to "" does not fail ?

Passing an argument of "" to ->cwd() has the same affect of calling ->cwd()
without any arguments. Turn on Debug (I<See below>) and you will see what is
happening

    $ftp = Net::FTP->new($host, Debug => 1);
    $ftp->login;
    $ftp->cwd("");

gives

    Net::FTP=GLOB(0x82196d8)>>> CWD /
    Net::FTP=GLOB(0x82196d8)<<< 250 CWD command successful.

=head2 I am behind a SOCKS firewall, but the Firewall option does not work ?

The Firewall option is only for support of one type of firewall. The type
supported is an ftp proxy.

To use Net::FTP, or any other module in the libnet distribution,
through a SOCKS firewall you must create a socks-ified perl executable
by compiling perl with the socks library.

=head2 I am behind an FTP proxy firewall, but cannot access machines outside ?

Net::FTP implements the most popular ftp proxy firewall approach. The scheme
implemented is that where you log in to the firewall with C<user@hostname>

I have heard of one other type of firewall which requires a login to the
firewall with an account, then a second login with C<user@hostname>. You can
still use Net::FTP to traverse these firewalls, but a more manual approach
must be taken, eg

    $ftp = Net::FTP->new($firewall) or die $@;
    $ftp->login($firewall_user, $firewall_passwd) or die $ftp->message;
    $ftp->login($ext_user . '@' . $ext_host, $ext_passwd) or die $ftp->message.

=head2 My ftp proxy firewall does not listen on port 21

FTP servers usually listen on the same port number, port 21, as any other
FTP server. But there is no reason why this has to be the case.

If you pass a port number to Net::FTP then it assumes this is the port
number of the final destination. By default Net::FTP will always try
to connect to the firewall on port 21.

Net::FTP uses IO::Socket to open the connection and IO::Socket allows
the port number to be specified as part of the hostname. So this problem
can be resolved by either passing a Firewall option like C<"hostname:1234">
or by setting the C<ftp_firewall> option in Net::Config to be a string
in the same form.

=head2 Is it possible to change the file permissions of a file on an FTP server ?

The answer to this is "maybe". The FTP protocol does not specify a command to change
file permissions on a remote host. However many servers do allow you to run the
chmod command via the C<SITE> command. This can be done with

  $ftp->site('chmod','0775',$file);

=head2 I have seen scripts call a method message, but cannot find it documented ?

Net::FTP, like several other packages in libnet, inherits from Net::Cmd, so
all the methods described in Net::Cmd are also available on Net::FTP
objects.

=head2 Why does Net::FTP not implement mput and mget methods

The quick answer is because they are easy to implement yourself. The long
answer is that to write these in such a way that multiple platforms are
supported correctly would just require too much code. Below are
some examples how you can implement these yourself.

sub mput {
  my($ftp,$pattern) = @_;
  foreach my $file (glob($pattern)) {
    $ftp->put($file) or warn $ftp->message;
  }
}

sub mget {
  my($ftp,$pattern) = @_;
  foreach my $file ($ftp->ls($pattern)) {
    $ftp->get($file) or warn $ftp->message;
  }
}


=head1 Using Net::SMTP

=head2 Why can't the part of an Email address after the @ be used as the hostname ?

The part of an Email address which follows the @ is not necessarily a hostname,
it is a mail domain. To find the name of a host to connect for a mail domain
you need to do a DNS MX lookup

=head2 Why does Net::SMTP not do DNS MX lookups ?

Net::SMTP implements the SMTP protocol. The DNS MX lookup is not part
of this protocol.

=head2 The verify method always returns true ?

Well it may seem that way, but it does not. The verify method returns true
if the command succeeded. If you pass verify an address which the
server would normally have to forward to another machine, the command
will succeed with something like

    252 Couldn't verify <someone@there> but will attempt delivery anyway

This command will fail only if you pass it an address in a domain
the server directly delivers for, and that address does not exist.

=head1 Debugging scripts

=head2 How can I debug my scripts that use Net::* modules ?

Most of the libnet client classes allow options to be passed to the
constructor, in most cases one option is called C<Debug>. Passing
this option with a non-zero value will turn on a protocol trace, which
will be sent to STDERR. This trace can be useful to see what commands
are being sent to the remote server and what responses are being
received back.

    #!/your/path/to/perl

    use Net::FTP;

    my $ftp = new Net::FTP($host, Debug => 1);
    $ftp->login('gbarr','password');
    $ftp->quit;

this script would output something like

 Net::FTP: Net::FTP(2.22)
 Net::FTP:   Exporter
 Net::FTP:   Net::Cmd(2.0801)
 Net::FTP:   IO::Socket::INET
 Net::FTP:     IO::Socket(1.1603)
 Net::FTP:       IO::Handle(1.1504)

 Net::FTP=GLOB(0x8152974)<<< 220 imagine FTP server (Version wu-2.4(5) Tue Jul 29 11:17:18 CDT 1997) ready.
 Net::FTP=GLOB(0x8152974)>>> user gbarr
 Net::FTP=GLOB(0x8152974)<<< 331 Password required for gbarr.
 Net::FTP=GLOB(0x8152974)>>> PASS ....
 Net::FTP=GLOB(0x8152974)<<< 230 User gbarr logged in.  Access restrictions apply.
 Net::FTP=GLOB(0x8152974)>>> QUIT
 Net::FTP=GLOB(0x8152974)<<< 221 Goodbye.

The first few lines tell you the modules that Net::FTP uses and their versions,
this is useful data to me when a user reports a bug. The last seven lines
show the communication with the server. Each line has three parts. The first
part is the object itself, this is useful for separating the output
if you are using multiple objects. The second part is either C<<<<<> to
show data coming from the server or C<&gt&gt&gt&gt> to show data
going to the server. The remainder of the line is the command
being sent or response being received.

=head1 AUTHOR AND COPYRIGHT

Copyright (c) 1997 Graham Barr.
All rights reserved.

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                package Net::servent;
use strict;

use 5.006_001;
our $VERSION = '1.01';
our(@EXPORT, @EXPORT_OK, %EXPORT_TAGS);
BEGIN {
    use Exporter   ();
    @EXPORT      = qw(getservbyname getservbyport getservent getserv);
    @EXPORT_OK   = qw( $s_name @s_aliases $s_port $s_proto );
    %EXPORT_TAGS = ( FIELDS => [ @EXPORT_OK, @EXPORT ] );
}
use vars      @EXPORT_OK;

# Class::Struct forbids use of @ISA
sub import { goto &Exporter::import }

use Class::Struct qw(struct);
struct 'Net::servent' => [
   name		=> '$',
   aliases	=> '@',
   port		=> '$',
   proto	=> '$',
];

sub populate (@) {
    return unless @_;
    my $sob = new();
    $s_name 	 =    $sob->[0]     	     = $_[0];
    @s_aliases	 = @{ $sob->[1] } = split ' ', $_[1];
    $s_port	 =    $sob->[2] 	     = $_[2];
    $s_proto	 =    $sob->[3] 	     = $_[3];
    return $sob;
}

sub getservent    (   ) { populate(CORE::getservent()) }
sub getservbyname ($;$) { populate(CORE::getservbyname(shift,shift||'tcp')) }
sub getservbyport ($;$) { populate(CORE::getservbyport(shift,shift||'tcp')) }

sub getserv ($;$) {
    no strict 'refs';
    return &{'getservby' . ($_[0]=~/^\d+$/ ? 'port' : 'name')}(@_);
}

1;

__END__

=head1 NAME

Net::servent - by-name interface to Perl's built-in getserv*() functions

=head1 SYNOPSIS

 use Net::servent;
 $s = getservbyname(shift || 'ftp') || die "no service";
 printf "port for %s is %s, aliases are %s\n",
    $s->name, $s->port, "@{$s->aliases}";

 use Net::servent qw(:FIELDS);
 getservbyname(shift || 'ftp') || die "no service";
 print "port for $s_name is $s_port, aliases are @s_aliases\n";

=head1 DESCRIPTION

This module's default exports override the core getservent(),
getservbyname(), and
getnetbyport() functions, replacing them with versions that return
"Net::servent" objects.  They take default second arguments of "tcp".  This object has methods that return the similarly
named structure field name from the C's servent structure from F<netdb.h>;
namely name, aliases, port, and proto.  The aliases
method returns an array reference, the rest scalars.

You may also import all the structure fields directly into your namespace
as regular variables using the :FIELDS import tag.  (Note that this still
overrides your core functions.)  Access these fields as variables named
with a preceding C<s_>.  Thus, C<$serv_obj-E<gt>name()> corresponds to
$s_name if you import the fields.  Array references are available as
regular array variables, so for example C<@{ $serv_obj-E<gt>aliases()}>
would be simply @s_aliases.

The getserv() function is a simple front-end that forwards a numeric
argument to getservbyport(), and the rest to getservbyname().

To access this functionality without the core overrides,
pass the C<use> an empty import list, and then access
function functions with their full qualified names.
On the other hand, the built-ins are still available
via the C<CORE::> pseudo-package.

=head1 EXAMPLES

 use Net::servent qw(:FIELDS);

 while (@ARGV) {
     my ($service, $proto) = ((split m!/!, shift), 'tcp');
     my $valet = getserv($service, $proto);
     unless ($valet) {
         warn "$0: No service: $service/$proto\n"
         next;
     }
     printf "service $service/$proto is port %d\n", $valet->port;
     print "alias are @s_aliases\n" if @s_aliases;
 }

=head1 NOTE

While this class is currently implemented using the Class::Struct
module to build a struct-like class, you shouldn't rely upon this.

=head1 AUTHOR

Tom Christiansen
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          package Net::netent;
use strict;

use 5.006_001;
our $VERSION = '1.00';
our(@EXPORT, @EXPORT_OK, %EXPORT_TAGS);
BEGIN { 
    use Exporter   ();
    @EXPORT      = qw(getnetbyname getnetbyaddr getnet);
    @EXPORT_OK   = qw(
			$n_name	    	@n_aliases
			$n_addrtype 	$n_net
		   );
    %EXPORT_TAGS = ( FIELDS => [ @EXPORT_OK, @EXPORT ] );
}
use vars      @EXPORT_OK;

# Class::Struct forbids use of @ISA
sub import { goto &Exporter::import }

use Class::Struct qw(struct);
struct 'Net::netent' => [
   name		=> '$',
   aliases	=> '@',
   addrtype	=> '$',
   net		=> '$',
];

sub populate (@) {
    return unless @_;
    my $nob = new();
    $n_name 	 =    $nob->[0]     	     = $_[0];
    @n_aliases	 = @{ $nob->[1] } = split ' ', $_[1];
    $n_addrtype  =    $nob->[2] 	     = $_[2];
    $n_net	 =    $nob->[3] 	     = $_[3];
    return $nob;
} 

sub getnetbyname ($)  { populate(CORE::getnetbyname(shift)) } 

sub getnetbyaddr ($;$) { 
    my ($net, $addrtype);
    $net = shift;
    require Socket if @_;
    $addrtype = @_ ? shift : Socket::AF_INET();
    populate(CORE::getnetbyaddr($net, $addrtype)) 
} 

sub getnet($) {
    if ($_[0] =~ /^\d+(?:\.\d+(?:\.\d+(?:\.\d+)?)?)?$/) {
	require Socket;
	&getnetbyaddr(Socket::inet_aton(shift));
    } else {
	&getnetbyname;
    } 
} 

1;
__END__

=head1 NAME

Net::netent - by-name interface to Perl's built-in getnet*() functions

=head1 SYNOPSIS

 use Net::netent qw(:FIELDS);
 getnetbyname("loopback") 		or die "bad net";
 printf "%s is %08X\n", $n_name, $n_net;

 use Net::netent;

 $n = getnetbyname("loopback") 		or die "bad net";
 { # there's gotta be a better way, eh?
     @bytes = unpack("C4", pack("N", $n->net));
     shift @bytes while @bytes && $bytes[0] == 0;
 }
 printf "%s is %08X [%d.%d.%d.%d]\n", $n->name, $n->net, @bytes;

=head1 DESCRIPTION

This module's default exports override the core getnetbyname() and
getnetbyaddr() functions, replacing them with versions that return
"Net::netent" objects.  This object has methods that return the similarly
named structure field name from the C's netent structure from F<netdb.h>;
namely name, aliases, addrtype, and net.  The aliases 
method returns an array reference, the rest scalars.  

You may also import all the structure fields directly into your namespace
as regular variables using the :FIELDS import tag.  (Note that this still
overrides your core functions.)  Access these fields as variables named
with a preceding C<n_>.  Thus, C<$net_obj-E<gt>name()> corresponds to
$n_name if you import the fields.  Array references are available as
regular array variables, so for example C<@{ $net_obj-E<gt>aliases()
}> would be simply @n_aliases.

The getnet() function is a simple front-end that forwards a numeric
argument to getnetbyaddr(), and the rest
to getnetbyname().

To access this functionality without the core overrides,
pass the C<use> an empty import list, and then access
function functions with their full qualified names.
On the other hand, the built-ins are still available
via the C<CORE::> pseudo-package.

=head1 EXAMPLES

The getnet() functions do this in the Perl core:

    sv_setiv(sv, (I32)nent->n_net);

The gethost() functions do this in the Perl core:

    sv_setpvn(sv, hent->h_addr, len);

That means that the address comes back in binary for the
host functions, and as a regular perl integer for the net ones.
This seems a bug, but here's how to deal with it:

 use strict;
 use Socket;
 use Net::netent;

 @ARGV = ('loopback') unless @ARGV;

 my($n, $net);

 for $net ( @ARGV ) {

     unless ($n = getnetbyname($net)) {
 	warn "$0: no such net: $net\n";
 	next;
     }

     printf "\n%s is %s%s\n", 
 	    $net, 
 	    lc($n->name) eq lc($net) ? "" : "*really* ",
 	    $n->name;

     print "\taliases are ", join(", ", @{$n->aliases}), "\n"
 		if @{$n->aliases};     

     # this is stupid; first, why is this not in binary?
     # second, why am i going through these convolutions
     # to make it looks right
     {
 	my @a = unpack("C4", pack("N", $n->net));
 	shift @a while @a && $a[0] == 0;
 	printf "\taddr is %s [%d.%d.%d.%d]\n", $n->net, @a;
     }

     if ($n = getnetbyaddr($n->net)) {
 	if (lc($n->name) ne lc($net)) {
 	    printf "\tThat addr reverses to net %s!\n", $n->name;
 	    $net = $n->name;
 	    redo;
 	} 
     }
 }

=head1 NOTE

While this class is currently implemented using the Class::Struct
module to build a struct-like class, you shouldn't rely upon this.

=head1 AUTHOR

Tom Christiansen
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ## 
## Package to read/write on ASCII data connections
##

package Net::FTP::A;

use 5.008001;

use strict;
use warnings;

use Carp;
use Net::FTP::dataconn;

our @ISA     = qw(Net::FTP::dataconn);
our $VERSION = "3.08_01";

our $buf;

sub read {
  my $data = shift;
  local *buf = \$_[0];
  shift;
  my $size = shift || croak 'read($buf,$size,[$offset])';
  my $timeout = @_ ? shift: $data->timeout;

  if (length(${*$data}) < $size && !${*$data}{'net_ftp_eof'}) {
    my $blksize = ${*$data}{'net_ftp_blksize'};
    $blksize = $size if $size > $blksize;

    my $l = 0;
    my $n;

  READ:
    {
      my $readbuf = defined(${*$data}{'net_ftp_cr'}) ? "\015" : '';

      $data->can_read($timeout)
        or croak "Timeout";

      if ($n = sysread($data, $readbuf, $blksize, length $readbuf)) {
        ${*$data}{'net_ftp_bytesread'} += $n;
        ${*$data}{'net_ftp_cr'} =
          substr($readbuf, -1) eq "\015"
          ? chop($readbuf)
          : undef;
      }
      else {
        return
          unless defined $n;

        ${*$data}{'net_ftp_eof'} = 1;
      }

      $readbuf =~ s/\015\012/\n/sgo;
      ${*$data} .= $readbuf;

      unless (length(${*$data})) {

        redo READ
          if ($n > 0);

        $size = length(${*$data})
          if ($n == 0);
      }
    }
  }

  $buf = substr(${*$data}, 0, $size);
  substr(${*$data}, 0, $size) = '';

  length $buf;
}


sub write {
  my $data = shift;
  local *buf = \$_[0];
  shift;
  my $size = shift || croak 'write($buf,$size,[$timeout])';
  my $timeout = @_ ? shift: $data->timeout;

  my $nr = (my $tmp = substr($buf, 0, $size)) =~ tr/\r\n/\015\012/;
  $tmp =~ s/(?<!\015)\012/\015\012/sg if $nr;
  $tmp =~ s/^\015// if ${*$data}{'net_ftp_outcr'};
  ${*$data}{'net_ftp_outcr'} = substr($tmp, -1) eq "\015";

  # If the remote server has closed the connection we will be signal'd
  # when we write. This can happen if the disk on the remote server fills up

  local $SIG{PIPE} = 'IGNORE'
    unless ($SIG{PIPE} || '') eq 'IGNORE'
    or $^O eq 'MacOS';

  my $len   = length($tmp);
  my $off   = 0;
  my $wrote = 0;

  my $blksize = ${*$data}{'net_ftp_blksize'};

  while ($len) {
    $data->can_write($timeout)
      or croak "Timeout";

    $off += $wrote;
    $wrote = syswrite($data, substr($tmp, $off), $len > $blksize ? $blksize : $len);
    return
      unless defined($wrote);
    $len -= $wrote;
  }

  $size;
}

1;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             package Net::FTP::E;

use 5.008001;

use strict;
use warnings;

use Net::FTP::I;

our @ISA = qw(Net::FTP::I);
our $VERSION = "3.08_01";

1;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ## 
## Package to read/write on BINARY data connections
##

package Net::FTP::I;

use 5.008001;

use strict;
use warnings;

use Carp;
use Net::FTP::dataconn;

our @ISA     = qw(Net::FTP::dataconn);
our $VERSION = "3.08_01";

our $buf;

sub read {
  my $data = shift;
  local *buf = \$_[0];
  shift;
  my $size = shift || croak 'read($buf,$size,[$timeout])';
  my $timeout = @_ ? shift: $data->timeout;

  my $n;

  if ($size > length ${*$data} and !${*$data}{'net_ftp_eof'}) {
    $data->can_read($timeout)
      or croak "Timeout";

    my $blksize = ${*$data}{'net_ftp_blksize'};
    $blksize = $size if $size > $blksize;

    unless ($n = sysread($data, ${*$data}, $blksize, length ${*$data})) {
      return unless defined $n;
      ${*$data}{'net_ftp_eof'} = 1;
    }
  }

  $buf = substr(${*$data}, 0, $size);

  $n = length($buf);

  substr(${*$data}, 0, $n) = '';

  ${*$data}{'net_ftp_bytesread'} += $n;

  $n;
}


sub write {
  my $data = shift;
  local *buf = \$_[0];
  shift;
  my $size = shift || croak 'write($buf,$size,[$timeout])';
  my $timeout = @_ ? shift: $data->timeout;

  # If the remote server has closed the connection we will be signal'd
  # when we write. This can happen if the disk on the remote server fills up

  local $SIG{PIPE} = 'IGNORE'
    unless ($SIG{PIPE} || '') eq 'IGNORE'
    or $^O eq 'MacOS';
  my $sent = $size;
  my $off  = 0;

  my $blksize = ${*$data}{'net_ftp_blksize'};
  while ($sent > 0) {
    $data->can_write($timeout)
      or croak "Timeout";

    my $n = syswrite($data, $buf, $sent > $blksize ? $blksize : $sent, $off);
    return unless defined($n);
    $sent -= $n;
    $off += $n;
  }

  $size;
}

1;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  package Net::FTP::L;

use 5.008001;

use strict;
use warnings;

use Net::FTP::I;

our @ISA = qw(Net::FTP::I);
our $VERSION = "3.08_01";

1;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ##
## Generic data connection package
##

package Net::FTP::dataconn;

use 5.008001;

use strict;
use warnings;

use Carp;
use Errno;
use Net::Cmd;

our $VERSION = '3.08_01';

$Net::FTP::IOCLASS or die "please load Net::FTP before Net::FTP::dataconn";
our @ISA = $Net::FTP::IOCLASS;

sub reading {
  my $data = shift;
  ${*$data}{'net_ftp_bytesread'} = 0;
}


sub abort {
  my $data = shift;
  my $ftp  = ${*$data}{'net_ftp_cmd'};

  # no need to abort if we have finished the xfer
  return $data->close
    if ${*$data}{'net_ftp_eof'};

  # for some reason if we continuously open RETR connections and not
  # read a single byte, then abort them after a while the server will
  # close our connection, this prevents the unexpected EOF on the
  # command channel -- GMB
  if (exists ${*$data}{'net_ftp_bytesread'}
    && (${*$data}{'net_ftp_bytesread'} == 0))
  {
    my $buf     = "";
    my $timeout = $data->timeout;
    $data->can_read($timeout) && sysread($data, $buf, 1);
  }

  ${*$data}{'net_ftp_eof'} = 1;    # fake

  $ftp->abort;                     # this will close me
}


sub _close {
  my $data = shift;
  my $ftp  = ${*$data}{'net_ftp_cmd'};

  $data->SUPER::close();

  delete ${*$ftp}{'net_ftp_dataconn'}
    if defined $ftp
    && exists ${*$ftp}{'net_ftp_dataconn'}
    && $data == ${*$ftp}{'net_ftp_dataconn'};
}


sub close {
  my $data = shift;
  my $ftp  = ${*$data}{'net_ftp_cmd'};

  if (exists ${*$data}{'net_ftp_bytesread'} && !${*$data}{'net_ftp_eof'}) {
    my $junk;
    eval { local($SIG{__DIE__}); $data->read($junk, 1, 0) };
    return $data->abort unless ${*$data}{'net_ftp_eof'};
  }

  $data->_close;

  return unless defined $ftp;

  $ftp->response() == CMD_OK
    && $ftp->message =~ /unique file name:\s*(\S*)\s*\)/
    && (${*$ftp}{'net_ftp_unique'} = $1);

  $ftp->status == CMD_OK;
}


sub _select {
  my ($data, $timeout, $do_read) = @_;
  my ($rin, $rout, $win, $wout, $tout, $nfound);

  vec($rin = '', fileno($data), 1) = 1;

  ($win, $rin) = ($rin, $win) unless $do_read;

  while (1) {
    $nfound = select($rout = $rin, $wout = $win, undef, $tout = $timeout);

    last if $nfound >= 0;

    croak "select: $!"
      unless $!{EINTR};
  }

  $nfound;
}


sub can_read {
  _select(@_[0, 1], 1);
}


sub can_write {
  _select(@_[0, 1], 0);
}


sub cmd {
  my $ftp = shift;

  ${*$ftp}{'net_ftp_cmd'};
}


sub bytes_read {
  my $ftp = shift;

  ${*$ftp}{'net_ftp_bytesread'} || 0;
}

1;

__END__

=head1 NAME

Net::FTP::dataconn - FTP Client data connection class

=head1 DESCRIPTION

Some of the methods defined in C<Net::FTP> return an object which will
be derived from this class. The dataconn class itself is derived from
the C<IO::Socket::INET> class, so any normal IO operations can be performed.
However the following methods are defined in the dataconn class and IO should
be performed using these.

=over 4

=item read ( BUFFER, SIZE [, TIMEOUT ] )

Read C<SIZE> bytes of data from the server and place it into C<BUFFER>, also
performing any <CRLF> translation necessary. C<TIMEOUT> is optional, if not
given, the timeout value from the command connection will be used.

Returns the number of bytes read before any <CRLF> translation.

=item write ( BUFFER, SIZE [, TIMEOUT ] )

Write C<SIZE> bytes of data from C<BUFFER> to the server, also
performing any <CRLF> translation necessary. C<TIMEOUT> is optional, if not
given, the timeout value from the command connection will be used.

Returns the number of bytes written before any <CRLF> translation.

=item bytes_read ()

Returns the number of bytes read so far.

=item abort ()

Abort the current data transfer.

=item close ()

Close the data connection and get a response from the FTP server. Returns
I<true> if the connection was closed successfully and the first digit of
the response from the server was a '2'.

=back

=cut
                                                                                                                                                                                                                                                                 package Params::Check;

use strict;

use Carp                        qw[carp croak];
use Locale::Maketext::Simple    Style => 'gettext';

BEGIN {
    use Exporter    ();
    use vars        qw[ @ISA $VERSION @EXPORT_OK $VERBOSE $ALLOW_UNKNOWN
                        $STRICT_TYPE $STRIP_LEADING_DASHES $NO_DUPLICATES
                        $PRESERVE_CASE $ONLY_ALLOW_DEFINED $WARNINGS_FATAL
                        $SANITY_CHECK_TEMPLATE $CALLER_DEPTH $_ERROR_STRING
                    ];

    @ISA        =   qw[ Exporter ];
    @EXPORT_OK  =   qw[check allow last_error];

    $VERSION                = '0.38';
    $VERBOSE                = $^W ? 1 : 0;
    $NO_DUPLICATES          = 0;
    $STRIP_LEADING_DASHES   = 0;
    $STRICT_TYPE            = 0;
    $ALLOW_UNKNOWN          = 0;
    $PRESERVE_CASE          = 0;
    $ONLY_ALLOW_DEFINED     = 0;
    $SANITY_CHECK_TEMPLATE  = 1;
    $WARNINGS_FATAL         = 0;
    $CALLER_DEPTH           = 0;
}

my %known_keys = map { $_ => 1 }
                    qw| required allow default strict_type no_override
                        store defined |;

=pod

=head1 NAME

Params::Check - A generic input parsing/checking mechanism.

=head1 SYNOPSIS

    use Params::Check qw[check allow last_error];

    sub fill_personal_info {
        my %hash = @_;
        my $x;

        my $tmpl = {
            firstname   => { required   => 1, defined => 1 },
            lastname    => { required   => 1, store => \$x },
            gender      => { required   => 1,
                             allow      => [qr/M/i, qr/F/i],
                           },
            married     => { allow      => [0,1] },
            age         => { default    => 21,
                             allow      => qr/^\d+$/,
                           },

            phone       => { allow => [ sub { return 1 if /$valid_re/ },
                                        '1-800-PERL' ]
                           },
            id_list     => { default        => [],
                             strict_type    => 1
                           },
            employer    => { default => 'NSA', no_override => 1 },
        };

        ### check() returns a hashref of parsed args on success ###
        my $parsed_args = check( $tmpl, \%hash, $VERBOSE )
                            or die qw[Could not parse arguments!];

        ... other code here ...
    }

    my $ok = allow( $colour, [qw|blue green yellow|] );

    my $error = Params::Check::last_error();


=head1 DESCRIPTION

Params::Check is a generic input parsing/checking mechanism.

It allows you to validate input via a template. The only requirement
is that the arguments must be named.

Params::Check can do the following things for you:

=over 4

=item *

Convert all keys to lowercase

=item *

Check if all required arguments have been provided

=item *

Set arguments that have not been provided to the default

=item *

Weed out arguments that are not supported and warn about them to the
user

=item *

Validate the arguments given by the user based on strings, regexes,
lists or even subroutines

=item *

Enforce type integrity if required

=back

Most of Params::Check's power comes from its template, which we'll
discuss below:

=head1 Template

As you can see in the synopsis, based on your template, the arguments
provided will be validated.

The template can take a different set of rules per key that is used.

The following rules are available:

=over 4

=item default

This is the default value if none was provided by the user.
This is also the type C<strict_type> will look at when checking type
integrity (see below).

=item required

A boolean flag that indicates if this argument was a required
argument. If marked as required and not provided, check() will fail.

=item strict_type

This does a C<ref()> check on the argument provided. The C<ref> of the
argument must be the same as the C<ref> of the default value for this
check to pass.

This is very useful if you insist on taking an array reference as
argument for example.

=item defined

If this template key is true, enforces that if this key is provided by
user input, its value is C<defined>. This just means that the user is
not allowed to pass C<undef> as a value for this key and is equivalent
to:
    allow => sub { defined $_[0] && OTHER TESTS }

=item no_override

This allows you to specify C<constants> in your template. ie, they
keys that are not allowed to be altered by the user. It pretty much
allows you to keep all your C<configurable> data in one place; the
C<Params::Check> template.

=item store

This allows you to pass a reference to a scalar, in which the data
will be stored:

    my $x;
    my $args = check(foo => { default => 1, store => \$x }, $input);

This is basically shorthand for saying:

    my $args = check( { foo => { default => 1 }, $input );
    my $x    = $args->{foo};

You can alter the global variable $Params::Check::NO_DUPLICATES to
control whether the C<store>'d key will still be present in your
result set. See the L<Global Variables> section below.

=item allow

A set of criteria used to validate a particular piece of data if it
has to adhere to particular rules.

See the C<allow()> function for details.

=back

=head1 Functions

=head2 check( \%tmpl, \%args, [$verbose] );

This function is not exported by default, so you'll have to ask for it
via:

    use Params::Check qw[check];

or use its fully qualified name instead.

C<check> takes a list of arguments, as follows:

=over 4

=item Template

This is a hash reference which contains a template as explained in the
C<SYNOPSIS> and C<Template> section.

=item Arguments

This is a reference to a hash of named arguments which need checking.

=item Verbose

A boolean to indicate whether C<check> should be verbose and warn
about what went wrong in a check or not.

You can enable this program wide by setting the package variable
C<$Params::Check::VERBOSE> to a true value. For details, see the
section on C<Global Variables> below.

=back

C<check> will return when it fails, or a hashref with lowercase
keys of parsed arguments when it succeeds.

So a typical call to check would look like this:

    my $parsed = check( \%template, \%arguments, $VERBOSE )
                    or warn q[Arguments could not be parsed!];

A lot of the behaviour of C<check()> can be altered by setting
package variables. See the section on C<Global Variables> for details
on this.

=cut

sub check {
    my ($utmpl, $href, $verbose) = @_;

    ### clear the current error string ###
    _clear_error();

    ### did we get the arguments we need? ###
    if ( !$utmpl or !$href ) {
      _store_error(loc('check() expects two arguments'));
      return unless $WARNINGS_FATAL;
      croak(__PACKAGE__->last_error);
    }

    ### sensible defaults ###
    $verbose ||= $VERBOSE || 0;

    ### XXX what type of template is it? ###
    ### { key => { } } ?
    #if (ref $args eq 'HASH') {
    #    1;
    #}

    ### clean up the template ###
    my $args;

    ### don't even bother to loop, if there's nothing to clean up ###
    if( $PRESERVE_CASE and !$STRIP_LEADING_DASHES ) {
        $args = $href;
    } else {
        ### keys are not aliased ###
        for my $key (keys %$href) {
            my $org = $key;
            $key = lc $key unless $PRESERVE_CASE;
            $key =~ s/^-// if $STRIP_LEADING_DASHES;
            $args->{$key} = $href->{$org};
        }
    }

    my %defs;

    ### which template entries have a 'store' member
    my @want_store;

    ### sanity check + defaults + required keys set? ###
    my $fail;
    for my $key (keys %$utmpl) {
        my $tmpl = $utmpl->{$key};

        ### check if required keys are provided
        ### keys are now lower cased, unless preserve case was enabled
        ### at which point, the utmpl keys must match, but that's the users
        ### problem.
        if( $tmpl->{'required'} and not exists $args->{$key} ) {
            _store_error(
                loc(q|Required option '%1' is not provided for %2 by %3|,
                    $key, _who_was_it(), _who_was_it(1)), $verbose );

            ### mark the error ###
            $fail++;
            next;
        }

        ### next, set the default, make sure the key exists in %defs ###
        $defs{$key} = $tmpl->{'default'}
                        if exists $tmpl->{'default'};

        if( $SANITY_CHECK_TEMPLATE ) {
            ### last, check if they provided any weird template keys
            ### -- do this last so we don't always execute this code.
            ### just a small optimization.
            map {   _store_error(
                        loc(q|Template type '%1' not supported [at key '%2']|,
                        $_, $key), 1, 0 );
            } grep {
                not $known_keys{$_}
            } keys %$tmpl;

            ### make sure you passed a ref, otherwise, complain about it!
            if ( exists $tmpl->{'store'} ) {
                _store_error( loc(
                    q|Store variable for '%1' is not a reference!|, $key
                ), 1, 0 ) unless ref $tmpl->{'store'};
            }
        }

        push @want_store, $key if $tmpl->{'store'};
    }

    ### errors found ###
    return if $fail;

    ### flag to see if anything went wrong ###
    my $wrong;

    ### flag to see if we warned for anything, needed for warnings_fatal
    my $warned;

    for my $key (keys %$args) {
        my $arg = $args->{$key};

        ### you gave us this key, but it's not in the template ###
        unless( $utmpl->{$key} ) {

            ### but we'll allow it anyway ###
            if( $ALLOW_UNKNOWN ) {
                $defs{$key} = $arg;

            ### warn about the error ###
            } else {
                _store_error(
                    loc("Key '%1' is not a valid key for %2 provided by %3",
                        $key, _who_was_it(), _who_was_it(1)), $verbose);
                $warned ||= 1;
            }
            next;
        }

        ### copy of this keys template instructions, to save derefs ###
        my %tmpl = %{$utmpl->{$key}};

        ### check if you're even allowed to override this key ###
        if( $tmpl{'no_override'} ) {
            _store_error(
                loc(q[You are not allowed to override key '%1'].
                    q[for %2 from %3], $key, _who_was_it(), _who_was_it(1)),
                $verbose
            );
            $warned ||= 1;
            next;
        }

        ### check if you were supposed to provide defined() values ###
        if( ($tmpl{'defined'} || $ONLY_ALLOW_DEFINED) and not defined $arg ) {
            _store_error(loc(q|Key '%1' must be defined when passed|, $key),
                $verbose );
            $wrong ||= 1;
            next;
        }

        ### check if they should be of a strict type, and if it is ###
        if( ($tmpl{'strict_type'} || $STRICT_TYPE) and
            (ref $arg ne ref $tmpl{'default'})
        ) {
            _store_error(loc(q|Key '%1' needs to be of type '%2'|,
                        $key, ref $tmpl{'default'} || 'SCALAR'), $verbose );
            $wrong ||= 1;
            next;
        }

        ### check if we have an allow handler, to validate against ###
        ### allow() will report its own errors ###
        if( exists $tmpl{'allow'} and not do {
                local $_ERROR_STRING;
                allow( $arg, $tmpl{'allow'} )
            }
        ) {
            ### stringify the value in the error report -- we don't want dumps
            ### of objects, but we do want to see *roughly* what we passed
            _store_error(loc(q|Key '%1' (%2) is of invalid type for '%3' |.
                             q|provided by %4|,
                            $key, "$arg", _who_was_it(),
                            _who_was_it(1)), $verbose);
            $wrong ||= 1;
            next;
        }

        ### we got here, then all must be OK ###
        $defs{$key} = $arg;

    }

    ### croak with the collected errors if there were errors and
    ### we have the fatal flag toggled.
    croak(__PACKAGE__->last_error) if ($wrong || $warned) && $WARNINGS_FATAL;

    ### done with our loop... if $wrong is set, something went wrong
    ### and the user is already informed, just return...
    return if $wrong;

    ### check if we need to store any of the keys ###
    ### can't do it before, because something may go wrong later,
    ### leaving the user with a few set variables
    for my $key (@want_store) {
        next unless exists $defs{$key};
        my $ref = $utmpl->{$key}{'store'};
        $$ref = $NO_DUPLICATES ? delete $defs{$key} : $defs{$key};
    }

    return \%defs;
}

=head2 allow( $test_me, \@criteria );

The function that handles the C<allow> key in the template is also
available for independent use.

The function takes as first argument a key to test against, and
as second argument any form of criteria that are also allowed by
the C<allow> key in the template.

You can use the following types of values for allow:

=over 4

=item string

The provided argument MUST be equal to the string for the validation
to pass.

=item regexp

The provided argument MUST match the regular expression for the
validation to pass.

=item subroutine

The provided subroutine MUST return true in order for the validation
to pass and the argument accepted.

(This is particularly useful for more complicated data).

=item array ref

The provided argument MUST equal one of the elements of the array
ref for the validation to pass. An array ref can hold all the above
values.

=back

It returns true if the key matched the criteria, or false otherwise.

=cut

sub allow {
    ### use $_[0] and $_[1] since this is hot code... ###
    #my ($val, $ref) = @_;

    ### it's a regexp ###
    if( ref $_[1] eq 'Regexp' ) {
        local $^W;  # silence warnings if $val is undef #
        return if $_[0] !~ /$_[1]/;

    ### it's a sub ###
    } elsif ( ref $_[1] eq 'CODE' ) {
        return unless $_[1]->( $_[0] );

    ### it's an array ###
    } elsif ( ref $_[1] eq 'ARRAY' ) {

        ### loop over the elements, see if one of them says the
        ### value is OK
        ### also, short-circuit when possible
        for ( @{$_[1]} ) {
            return 1 if allow( $_[0], $_ );
        }

        return;

    ### fall back to a simple, but safe 'eq' ###
    } else {
        return unless _safe_eq( $_[0], $_[1] );
    }

    ### we got here, no failures ###
    return 1;
}

### helper functions ###

sub _safe_eq {
    ### only do a straight 'eq' if they're both defined ###
    return defined($_[0]) && defined($_[1])
                ? $_[0] eq $_[1]
                : defined($_[0]) eq defined($_[1]);
}

sub _who_was_it {
    my $level = $_[0] || 0;

    return (caller(2 + $CALLER_DEPTH + $level))[3] || 'ANON'
}

=head2 last_error()

Returns a string containing all warnings and errors reported during
the last time C<check> was called.

This is useful if you want to report then some other way than
C<carp>'ing when the verbose flag is on.

It is exported upon request.

=cut

{   $_ERROR_STRING = '';

    sub _store_error {
        my($err, $verbose, $offset) = @_[0..2];
        $verbose ||= 0;
        $offset  ||= 0;
        my $level   = 1 + $offset;

        local $Carp::CarpLevel = $level;

        carp $err if $verbose;

        $_ERROR_STRING .= $err . "\n";
    }

    sub _clear_error {
        $_ERROR_STRING = '';
    }

    sub last_error { $_ERROR_STRING }
}

1;

=head1 Global Variables

The behaviour of Params::Check can be altered by changing the
following global variables:

=head2 $Params::Check::VERBOSE

This controls whether Params::Check will issue warnings and
explanations as to why certain things may have failed.
If you set it to 0, Params::Check will not output any warnings.

The default is 1 when L<warnings> are enabled, 0 otherwise;

=head2 $Params::Check::STRICT_TYPE

This works like the C<strict_type> option you can pass to C<check>,
which will turn on C<strict_type> globally for all calls to C<check>.

The default is 0;

=head2 $Params::Check::ALLOW_UNKNOWN

If you set this flag, unknown options will still be present in the
return value, rather than filtered out. This is useful if your
subroutine is only interested in a few arguments, and wants to pass
the rest on blindly to perhaps another subroutine.

The default is 0;

=head2 $Params::Check::STRIP_LEADING_DASHES

If you set this flag, all keys passed in the following manner:

    function( -key => 'val' );

will have their leading dashes stripped.

=head2 $Params::Check::NO_DUPLICATES

If set to true, all keys in the template that are marked as to be
stored in a scalar, will also be removed from the result set.

Default is false, meaning that when you use C<store> as a template
key, C<check> will put it both in the scalar you supplied, as well as
in the hashref it returns.

=head2 $Params::Check::PRESERVE_CASE

If set to true, L<Params::Check> will no longer convert all keys from
the user input to lowercase, but instead expect them to be in the
case the template provided. This is useful when you want to use
similar keys with different casing in your templates.

Understand that this removes the case-insensitivity feature of this
module.

Default is 0;

=head2 $Params::Check::ONLY_ALLOW_DEFINED

If set to true, L<Params::Check> will require all values passed to be
C<defined>. If you wish to enable this on a 'per key' basis, use the
template option C<defined> instead.

Default is 0;

=head2 $Params::Check::SANITY_CHECK_TEMPLATE

If set to true, L<Params::Check> will sanity check templates, validating
for errors and unknown keys. Although very useful for debugging, this
can be somewhat slow in hot-code and large loops.

To disable this check, set this variable to C<false>.

Default is 1;

=head2 $Params::Check::WARNINGS_FATAL

If set to true, L<Params::Check> will C<croak> when an error during
template validation occurs, rather than return C<false>.

Default is 0;

=head2 $Params::Check::CALLER_DEPTH

This global modifies the argument given to C<caller()> by
C<Params::Check::check()> and is useful if you have a custom wrapper
function around C<Params::Check::check()>. The value must be an
integer, indicating the number of wrapper functions inserted between
the real function call and C<Params::Check::check()>.

Example wrapper function, using a custom stacktrace:

    sub check {
        my ($template, $args_in) = @_;

        local $Params::Check::WARNINGS_FATAL = 1;
        local $Params::Check::CALLER_DEPTH = $Params::Check::CALLER_DEPTH + 1;
        my $args_out = Params::Check::check($template, $args_in);

        my_stacktrace(Params::Check::last_error) unless $args_out;

        return $args_out;
    }

Default is 0;

=head1 Acknowledgements

Thanks to Richard Soderberg for his performance improvements.

=head1 BUG REPORTS

Please report bugs or other issues to E<lt>bug-params-check@rt.cpan.orgE<gt>.

=head1 AUTHOR

This module by Jos Boumans E<lt>kane@cpan.orgE<gt>.

=head1 COPYRIGHT

This library is free software; you may redistribute and/or modify it
under the same terms as Perl itself.


=cut

# Local variables:
# c-indentation-style: bsd
# c-basic-offset: 4
# indent-tabs-mode: nil
# End:
# vim: expandtab shiftwidth=4:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              use 5.008001;
use strict;
package Parse::CPAN::Meta;
# ABSTRACT: Parse META.yml and META.json CPAN metadata files

our $VERSION = '1.4417_001';

use Exporter;
use Carp 'croak';

our @ISA = qw/Exporter/;
our @EXPORT_OK = qw/Load LoadFile/;

sub load_file {
  my ($class, $filename) = @_;

  my $meta = _slurp($filename);

  if ($filename =~ /\.ya?ml$/) {
    return $class->load_yaml_string($meta);
  }
  elsif ($filename =~ /\.json$/) {
    return $class->load_json_string($meta);
  }
  else {
    $class->load_string($meta); # try to detect yaml/json
  }
}

sub load_string {
  my ($class, $string) = @_;
  if ( $string =~ /^---/ ) { # looks like YAML
    return $class->load_yaml_string($string);
  }
  elsif ( $string =~ /^\s*\{/ ) { # looks like JSON
    return $class->load_json_string($string);
  }
  else { # maybe doc-marker-free YAML
    return $class->load_yaml_string($string);
  }
}

sub load_yaml_string {
  my ($class, $string) = @_;
  my $backend = $class->yaml_backend();
  my $data = eval { no strict 'refs'; &{"$backend\::Load"}($string) };
  croak $@ if $@;
  return $data || {}; # in case document was valid but empty
}

sub load_json_string {
  my ($class, $string) = @_;
  my $data = eval { $class->json_backend()->new->decode($string) };
  croak $@ if $@;
  return $data || {};
}

sub yaml_backend {
  if ($ENV{PERL_CORE} or not defined $ENV{PERL_YAML_BACKEND} ) {
    _can_load( 'CPAN::Meta::YAML', 0.011 )
      or croak "CPAN::Meta::YAML 0.011 is not available\n";
    return "CPAN::Meta::YAML";
  }
  else {
    my $backend = $ENV{PERL_YAML_BACKEND};
    _can_load( $backend )
      or croak "Could not load PERL_YAML_BACKEND '$backend'\n";
    $backend->can("Load")
      or croak "PERL_YAML_BACKEND '$backend' does not implement Load()\n";
    return $backend;
  }
}

sub json_backend {
  if ($ENV{PERL_CORE} or ! $ENV{PERL_JSON_BACKEND} or $ENV{PERL_JSON_BACKEND} eq 'JSON::PP') {
    _can_load( 'JSON::PP' => 2.27103 )
      or croak "JSON::PP 2.27103 is not available\n";
    return 'JSON::PP';
  }
  else {
    _can_load( 'JSON' => 2.5 )
      or croak  "JSON 2.5 is required for " .
                "\$ENV{PERL_JSON_BACKEND} = '$ENV{PERL_JSON_BACKEND}'\n";
    return "JSON";
  }
}

sub _slurp {
  require Encode;
  open my $fh, "<:raw", "$_[0]" ## no critic
    or die "can't open $_[0] for reading: $!";
  my $content = do { local $/; <$fh> };
  $content = Encode::decode('UTF-8', $content, Encode::PERLQQ());
  return $content;
}
  
sub _can_load {
  my ($module, $version) = @_;
  (my $file = $module) =~ s{::}{/}g;
  $file .= ".pm";
  return 1 if $INC{$file};
  return 0 if exists $INC{$file}; # prior load failed
  eval { require $file; 1 }
    or return 0;
  if ( defined $version ) {
    eval { $module->VERSION($version); 1 }
      or return 0;
  }
  return 1;
}

# Kept for backwards compatibility only
# Create an object from a file
sub LoadFile ($) { ## no critic
  return Load(_slurp(shift));
}

# Parse a document from a string.
sub Load ($) { ## no critic
  require CPAN::Meta::YAML;
  my $object = eval { CPAN::Meta::YAML::Load(shift) };
  croak $@ if $@;
  return $object;
}

1;

__END__

=pod

=encoding UTF-8

=head1 NAME

Parse::CPAN::Meta - Parse META.yml and META.json CPAN metadata files

=head1 VERSION

version 1.4417

=head1 SYNOPSIS

    #############################################
    # In your file
    
    ---
    name: My-Distribution
    version: 1.23
    resources:
      homepage: "http://example.com/dist/My-Distribution"
    
    
    #############################################
    # In your program
    
    use Parse::CPAN::Meta;
    
    my $distmeta = Parse::CPAN::Meta->load_file('META.yml');
    
    # Reading properties
    my $name     = $distmeta->{name};
    my $version  = $distmeta->{version};
    my $homepage = $distmeta->{resources}{homepage};

=head1 DESCRIPTION

B<Parse::CPAN::Meta> is a parser for F<META.json> and F<META.yml> files, using
L<JSON::PP> and/or L<CPAN::Meta::YAML>.

B<Parse::CPAN::Meta> provides three methods: C<load_file>, C<load_json_string>,
and C<load_yaml_string>.  These will read and deserialize CPAN metafiles, and
are described below in detail.

B<Parse::CPAN::Meta> provides a legacy API of only two functions,
based on the YAML functions of the same name. Wherever possible,
identical calling semantics are used.  These may only be used with YAML sources.

All error reporting is done with exceptions (die'ing).

Note that META files are expected to be in UTF-8 encoding, only.  When
converted string data, it must first be decoded from UTF-8.

=begin Pod::Coverage




=end Pod::Coverage

=head1 METHODS

=head2 load_file

  my $metadata_structure = Parse::CPAN::Meta->load_file('META.json');

  my $metadata_structure = Parse::CPAN::Meta->load_file('META.yml');

This method will read the named file and deserialize it to a data structure,
determining whether it should be JSON or YAML based on the filename.
The file will be read using the ":utf8" IO layer.

=head2 load_yaml_string

  my $metadata_structure = Parse::CPAN::Meta->load_yaml_string($yaml_string);

This method deserializes the given string of YAML and returns the first
document in it.  (CPAN metadata files should always have only one document.)
If the source was UTF-8 encoded, the string must be decoded before calling
C<load_yaml_string>.

=head2 load_json_string

  my $metadata_structure = Parse::CPAN::Meta->load_json_string($json_string);

This method deserializes the given string of JSON and the result.  
If the source was UTF-8 encoded, the string must be decoded before calling
C<load_json_string>.

=head2 load_string

  my $metadata_structure = Parse::CPAN::Meta->load_string($some_string);

If you don't know whether a string contains YAML or JSON data, this method
will use some heuristics and guess.  If it can't tell, it assumes YAML.

=head2 yaml_backend

  my $backend = Parse::CPAN::Meta->yaml_backend;

Returns the module name of the YAML serializer. See L</ENVIRONMENT>
for details.

=head2 json_backend

  my $backend = Parse::CPAN::Meta->json_backend;

Returns the module name of the JSON serializer.  This will either
be L<JSON::PP> or L<JSON>.  Even if C<PERL_JSON_BACKEND> is set,
this will return L<JSON> as further delegation is handled by
the L<JSON> module.  See L</ENVIRONMENT> for details.

=head1 FUNCTIONS

For maintenance clarity, no functions are exported by default.  These functions
are available for backwards compatibility only and are best avoided in favor of
C<load_file>.

=head2 Load

  my @yaml = Parse::CPAN::Meta::Load( $string );

Parses a string containing a valid YAML stream into a list of Perl data
structures.

=head2 LoadFile

  my @yaml = Parse::CPAN::Meta::LoadFile( 'META.yml' );

Reads the YAML stream from a file instead of a string.

=head1 ENVIRONMENT

=head2 PERL_JSON_BACKEND

By default, L<JSON::PP> will be used for deserializing JSON data. If the
C<PERL_JSON_BACKEND> environment variable exists, is true and is not
"JSON::PP", then the L<JSON> module (version 2.5 or greater) will be loaded and
used to interpret C<PERL_JSON_BACKEND>.  If L<JSON> is not installed or is too
old, an exception will be thrown.

=head2 PERL_YAML_BACKEND

By default, L<CPAN::Meta::YAML> will be used for deserializing YAML data. If
the C<PERL_YAML_BACKEND> environment variable is defined, then it is interpreted
as a module to use for deserialization.  The given module must be installed,
must load correctly and must implement the C<Load()> function or an exception
will be thrown.

=for :stopwords cpan testmatrix url annocpan anno bugtracker rt cpants kwalitee diff irc mailto metadata placeholders metacpan

=head1 SUPPORT

=head2 Bugs / Feature Requests

Please report any bugs or feature requests through the issue tracker
at L<https://github.com/Perl-Toolchain-Gang/Parse-CPAN-Meta/issues>.
You will be notified automatically of any progress on your issue.

=head2 Source Code

This is open source software.  The code repository is available for
public review and contribution under the terms of the license.

L<https://github.com/Perl-Toolchain-Gang/Parse-CPAN-Meta>

  git clone https://github.com/Perl-Toolchain-Gang/Parse-CPAN-Meta.git

=head1 AUTHORS

=over 4

=item *

Adam Kennedy <adamk@cpan.org>

=item *

David Golden <dagolden@cpan.org>

=back

=head1 CONTRIBUTORS

=for stopwords Graham Knop Joshua ben Jore Karen Etheridge Neil Bowers Ricardo Signes Steffen Mueller

=over 4

=item *

Graham Knop <haarg@haarg.org>

=item *

Joshua ben Jore <jjore@cpan.org>

=item *

Karen Etheridge <ether@cpan.org>

=item *

Neil Bowers <neil@bowers.com>

=item *

Ricardo Signes <rjbs@cpan.org>

=item *

Steffen Mueller <smueller@cpan.org>

=back

=head1 COPYRIGHT AND LICENSE

This software is copyright (c) 2015 by Adam Kennedy and Contributors.

This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    package PerlIO::via::QuotedPrint;

$VERSION= '0.08';

# be as strict as possible
use strict;

# modules that we need
use MIME::QuotedPrint (); # no need to pollute this namespace

# satisfy -require-
1;

#-------------------------------------------------------------------------------
#
# Standard Perl features
#
#-------------------------------------------------------------------------------
#  IN: 1 class to bless with
#      2 mode string (ignored)
#      3 file handle of PerlIO layer below (ignored)
# OUT: 1 blessed object

sub PUSHED { bless \*PUSHED,$_[0] } #PUSHED

#-------------------------------------------------------------------------------
#  IN: 1 instantiated object (ignored)
#      2 handle to read from
# OUT: 1 decoded string

sub FILL {

    # decode and return
    my $line= readline( $_[1] );
    return ( defined $line )
      ? MIME::QuotedPrint::decode_qp($line)
      : undef;
} #FILL

#-------------------------------------------------------------------------------
#  IN: 1 instantiated object (ignored)
#      2 buffer to be written
#      3 handle to write to
# OUT: 1 number of bytes written

sub WRITE {

    # encode and write to handle: indicate result
    return ( print { $_[2] } MIME::QuotedPrint::encode_qp( $_[1] ) )
      ? length( $_[1] )
      : -1;
} #WRITE

#-------------------------------------------------------------------------------

__END__

=head1 NAME

PerlIO::via::QuotedPrint - PerlIO layer for quoted-printable strings

=head1 SYNOPSIS

 use PerlIO::via::QuotedPrint;

 open( my $in, '<:via(QuotedPrint)', 'file.qp' )
   or die "Can't open file.qp for reading: $!\n";
 
 open( my $out, '>:via(QuotedPrint)', 'file.qp' )
   or die "Can't open file.qp for writing: $!\n";

=head1 VERSION

This documentation describes version 0.08.

=head1 DESCRIPTION

This module implements a PerlIO layer that works on files encoded in the
quoted-printable format.  It will decode from quoted-printable while reading
from a handle, and it will encode as quoted-printable while writing to a handle.

=head1 REQUIRED MODULES

 MIME::QuotedPrint (any)

=head1 SEE ALSO

L<PerlIO::via>, L<MIME::QuotedPrint>, L<PerlIO::via::Base64>,
L<PerlIO::via::MD5>, L<PerlIO::via::StripHTML>, L<PerlIO::via::Rotate>.

=head1 ACKNOWLEDGEMENTS

Based on example that was initially added to MIME::QuotedPrint.pm for the
5.8.0 distribution of Perl.

=head1 COPYRIGHT

Copyright (c) 2002, 2003, 2004, 2012 Elizabeth Mattijsen.  All rights reserved.
This library is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   use strict;
use warnings;

package Perl::OSType;
# ABSTRACT: Map Perl operating system names to generic types

our $VERSION = '1.009';

require Exporter;
our @ISA = qw(Exporter);

our %EXPORT_TAGS = ( all => [qw( os_type is_os_type )] );

our @EXPORT_OK = @{ $EXPORT_TAGS{all} };

# originally taken from Module::Build by Ken Williams et al.
my %OSTYPES = qw(
  aix         Unix
  bsdos       Unix
  beos        Unix
  bitrig      Unix
  dgux        Unix
  dragonfly   Unix
  dynixptx    Unix
  freebsd     Unix
  linux       Unix
  haiku       Unix
  hpux        Unix
  iphoneos    Unix
  irix        Unix
  darwin      Unix
  machten     Unix
  midnightbsd Unix
  minix       Unix
  mirbsd      Unix
  next        Unix
  openbsd     Unix
  netbsd      Unix
  dec_osf     Unix
  nto         Unix
  svr4        Unix
  svr5        Unix
  sco         Unix
  sco_sv      Unix
  unicos      Unix
  unicosmk    Unix
  solaris     Unix
  sunos       Unix
  cygwin      Unix
  os2         Unix
  interix     Unix
  gnu         Unix
  gnukfreebsd Unix
  nto         Unix
  qnx         Unix
  android     Unix

  dos         Windows
  MSWin32     Windows

  os390       EBCDIC
  os400       EBCDIC
  posix-bc    EBCDIC
  vmesa       EBCDIC

  MacOS       MacOS
  VMS         VMS
  vos         VOS
  riscos      RiscOS
  amigaos     Amiga
  mpeix       MPEiX
);

sub os_type {
    my ($os) = @_;
    $os = $^O unless defined $os;
    return $OSTYPES{$os} || q{};
}

sub is_os_type {
    my ( $type, $os ) = @_;
    return unless $type;
    $os = $^O unless defined $os;
    return os_type($os) eq $type;
}

1;

=pod

=encoding UTF-8

=head1 NAME

Perl::OSType - Map Perl operating system names to generic types

=head1 VERSION

version 1.009

=head1 SYNOPSIS

  use Perl::OSType ':all';

  $current_type = os_type();
  $other_type = os_type('dragonfly'); # gives 'Unix'

=head1 DESCRIPTION

Modules that provide OS-specific behaviors often need to know if
the current operating system matches a more generic type of
operating systems. For example, 'linux' is a type of 'Unix' operating system
and so is 'freebsd'.

This module provides a mapping between an operating system name as given by
C<$^O> and a more generic type.  The initial version is based on the OS type
mappings provided in L<Module::Build> and L<ExtUtils::CBuilder>.  (Thus,
Microsoft operating systems are given the type 'Windows' rather than 'Win32'.)

=head1 USAGE

No functions are exported by default. The export tag ":all" will export
all functions listed below.

=head2 os_type()

  $os_type = os_type();
  $os_type = os_type('MSWin32');

Returns a single, generic OS type for a given operating system name.  With no
arguments, returns the OS type for the current value of C<$^O>.  If the
operating system is not recognized, the function will return the empty string.

=head2 is_os_type()

  $is_windows = is_os_type('Windows');
  $is_unix    = is_os_type('Unix', 'dragonfly');

Given an OS type and OS name, returns true or false if the OS name is of the
given type.  As with C<os_type>, it will use the current operating system as a
default if no OS name is provided.

=head1 SEE ALSO

=over 4

=item *

L<Devel::CheckOS>

=back

=for :stopwords cpan testmatrix url annocpan anno bugtracker rt cpants kwalitee diff irc mailto metadata placeholders metacpan

=head1 SUPPORT

=head2 Bugs / Feature Requests

Please report any bugs or feature requests through the issue tracker
at L<https://github.com/Perl-Toolchain-Gang/Perl-OSType/issues>.
You will be notified automatically of any progress on your issue.

=head2 Source Code

This is open source software.  The code repository is available for
public review and contribution under the terms of the license.

L<https://github.com/Perl-Toolchain-Gang/Perl-OSType>

  git clone https://github.com/Perl-Toolchain-Gang/Perl-OSType.git

=head1 AUTHOR

David Golden <dagolden@cpan.org>

=head1 CONTRIBUTORS

=for stopwords Chris 'BinGOs' Williams Jonas B. Nielsen Owain G. Ainsworth Paul Green Piotr Roszatycki

=over 4

=item *

Chris 'BinGOs' Williams <chris@bingosnet.co.uk>

=item *

Jonas B. Nielsen <jonasbn@hoarfrost.local>

=item *

Owain G. Ainsworth <oga@nicotinebsd.org>

=item *

Paul Green <Paul.Green@stratus.com>

=item *

Piotr Roszatycki <piotr.roszatycki@gmail.com>

=back

=head1 COPYRIGHT AND LICENSE

This software is copyright (c) 2015 by David Golden.

This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.

=cut

__END__


# vim: ts=4 sts=4 sw=4 et:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            #############################################################################
# Pod/Checker.pm -- check pod documents for syntax errors
#
# Copyright (C) 1994-2000 by Bradford Appleton. All rights reserved.
# This file is part of "PodParser". PodParser is free software;
# you can redistribute it and/or modify it under the same terms
# as Perl itself.
#############################################################################

package Pod::Checker;
use strict;

use vars qw($VERSION @ISA @EXPORT %VALID_COMMANDS %VALID_SEQUENCES);
$VERSION = '1.60';  ## Current version of this package
require  5.005;    ## requires this Perl version or later

use Pod::ParseUtils; ## for hyperlinks and lists

=head1 NAME

Pod::Checker, podchecker() - check pod documents for syntax errors

=head1 SYNOPSIS

  use Pod::Checker;

  $num_errors = podchecker($filepath, $outputpath, %options);

  my $checker = new Pod::Checker %options;
  $checker->parse_from_file($filepath, \*STDERR);

=head1 OPTIONS/ARGUMENTS

C<$filepath> is the input POD to read and C<$outputpath> is
where to write POD syntax error messages. Either argument may be a scalar
indicating a file-path, or else a reference to an open filehandle.
If unspecified, the input-file it defaults to C<\*STDIN>, and
the output-file defaults to C<\*STDERR>.

=head2 podchecker()

This function can take a hash of options:

=over 4

=item B<-warnings> =E<gt> I<val>

Turn warnings on/off. I<val> is usually 1 for on, but higher values
trigger additional warnings. See L<"Warnings">.

=back

=head1 DESCRIPTION

B<podchecker> will perform syntax checking of Perl5 POD format documentation.

Curious/ambitious users are welcome to propose additional features they wish
to see in B<Pod::Checker> and B<podchecker> and verify that the checks are
consistent with L<perlpod>.

The following checks are currently performed:

=over 4

=item *

Unknown '=xxxx' commands, unknown 'XE<lt>...E<gt>' interior-sequences,
and unterminated interior sequences.

=item *

Check for proper balancing of C<=begin> and C<=end>. The contents of such
a block are generally ignored, i.e. no syntax checks are performed.

=item *

Check for proper nesting and balancing of C<=over>, C<=item> and C<=back>.

=item *

Check for same nested interior-sequences (e.g.
C<LE<lt>...LE<lt>...E<gt>...E<gt>>).

=item *

Check for malformed or non-existing entities C<EE<lt>...E<gt>>.

=item *

Check for correct syntax of hyperlinks C<LE<lt>...E<gt>>. See L<perlpod>
for details.

=item *

Check for unresolved document-internal links. This check may also reveal
misspelled links that seem to be internal links but should be links
to something else.

=back

=head1 DIAGNOSTICS

=head2 Errors

=over 4

=item * empty =headn

A heading (C<=head1> or C<=head2>) without any text? That ain't no
heading!

=item * =over on line I<N> without closing =back

The C<=over> command does not have a corresponding C<=back> before the
next heading (C<=head1> or C<=head2>) or the end of the file.

=item * =item without previous =over

=item * =back without previous =over

An C<=item> or C<=back> command has been found outside a
C<=over>/C<=back> block.

=item * No argument for =begin

A C<=begin> command was found that is not followed by the formatter
specification.

=item * =end without =begin

A standalone C<=end> command was found.

=item * Nested =begin's

There were at least two consecutive C<=begin> commands without
the corresponding C<=end>. Only one C<=begin> may be active at
a time.

=item * =for without formatter specification

There is no specification of the formatter after the C<=for> command.

=item * Apparent command =foo not preceded by blank line

A command which has ended up in the middle of a paragraph or other command,
such as

  =item one
  =item two <-- bad

=item * unresolved internal link I<NAME>

The given link to I<NAME> does not have a matching node in the current
POD. This also happened when a single word node name is not enclosed in
C<"">.

=item * Unknown command "I<CMD>"

An invalid POD command has been found. Valid are C<=head1>, C<=head2>,
C<=head3>, C<=head4>, C<=over>, C<=item>, C<=back>, C<=begin>, C<=end>,
C<=for>, C<=pod>, C<=cut>

=item * Unknown interior-sequence "I<SEQ>"

An invalid markup command has been encountered. Valid are:
C<BE<lt>E<gt>>, C<CE<lt>E<gt>>, C<EE<lt>E<gt>>, C<FE<lt>E<gt>>,
C<IE<lt>E<gt>>, C<LE<lt>E<gt>>, C<SE<lt>E<gt>>, C<XE<lt>E<gt>>,
C<ZE<lt>E<gt>>

=item * nested commands I<CMD>E<lt>...I<CMD>E<lt>...E<gt>...E<gt>

Two nested identical markup commands have been found. Generally this
does not make sense.

=item * garbled entity I<STRING>

The I<STRING> found cannot be interpreted as a character entity.

=item * Entity number out of range

An entity specified by number (dec, hex, oct) is out of range (1-255).

=item * malformed link LE<lt>E<gt>

The link found cannot be parsed because it does not conform to the
syntax described in L<perlpod>.

=item * nonempty ZE<lt>E<gt>

The C<ZE<lt>E<gt>> sequence is supposed to be empty.

=item * empty XE<lt>E<gt>

The index entry specified contains nothing but whitespace.

=item * Spurious text after =pod / =cut

The commands C<=pod> and C<=cut> do not take any arguments.

=item * Spurious =cut command

A C<=cut> command was found without a preceding POD paragraph.

=item * Spurious =pod command

A C<=pod> command was found after a preceding POD paragraph.

=item * Spurious character(s) after =back

The C<=back> command does not take any arguments.

=back

=head2 Warnings

These may not necessarily cause trouble, but indicate mediocre style.

=over 4

=item * multiple occurrence of link target I<name>

The POD file has some C<=item> and/or C<=head> commands that have
the same text. Potential hyperlinks to such a text cannot be unique then.
This warning is printed only with warning level greater than one.

=item * line containing nothing but whitespace in paragraph

There is some whitespace on a seemingly empty line. POD is very sensitive
to such things, so this is flagged. B<vi> users switch on the B<list>
option to avoid this problem.

=begin _disabled_

=item * file does not start with =head

The file starts with a different POD directive than head.
This is most probably something you do not want.

=end _disabled_

=item * previous =item has no contents

There is a list C<=item> right above the flagged line that has no
text contents. You probably want to delete empty items.

=item * preceding non-item paragraph(s)

A list introduced by C<=over> starts with a text or verbatim paragraph,
but continues with C<=item>s. Move the non-item paragraph out of the
C<=over>/C<=back> block.

=item * =item type mismatch (I<one> vs. I<two>)

A list started with e.g. a bullet-like C<=item> and continued with a
numbered one. This is obviously inconsistent. For most translators the
type of the I<first> C<=item> determines the type of the list.

=item * I<N> unescaped C<E<lt>E<gt>> in paragraph

Angle brackets not written as C<E<lt>ltE<gt>> and C<E<lt>gtE<gt>>
can potentially cause errors as they could be misinterpreted as
markup commands. This is only printed when the -warnings level is
greater than 1.

=item * Unknown entity

A character entity was found that does not belong to the standard
ISO set or the POD specials C<verbar> and C<sol>.

=item * No items in =over

The list opened with C<=over> does not contain any items.

=item * No argument for =item

C<=item> without any parameters is deprecated. It should either be followed
by C<*> to indicate an unordered list, by a number (optionally followed
by a dot) to indicate an ordered (numbered) list or simple text for a
definition list.

=item * empty section in previous paragraph

The previous section (introduced by a C<=head> command) does not contain
any text. This usually indicates that something is missing. Note: A
C<=head1> followed immediately by C<=head2> does not trigger this warning.

=item * Verbatim paragraph in NAME section

The NAME section (C<=head1 NAME>) should consist of a single paragraph
with the script/module name, followed by a dash `-' and a very short
description of what the thing is good for.

=item * =headI<n> without preceding higher level

For example if there is a C<=head2> in the POD file prior to a
C<=head1>.

=back

=head2 Hyperlinks

There are some warnings with respect to malformed hyperlinks:

=over 4

=item * ignoring leading/trailing whitespace in link

There is whitespace at the beginning or the end of the contents of
LE<lt>...E<gt>.

=item * (section) in '$page' deprecated

There is a section detected in the page name of LE<lt>...E<gt>, e.g.
C<LE<lt>passwd(2)E<gt>>. POD hyperlinks may point to POD documents only.
Please write C<CE<lt>passwd(2)E<gt>> instead. Some formatters are able
to expand this to appropriate code. For links to (builtin) functions,
please say C<LE<lt>perlfunc/mkdirE<gt>>, without ().

=item * alternative text/node '%s' contains non-escaped | or /

The characters C<|> and C</> are special in the LE<lt>...E<gt> context.
Although the hyperlink parser does its best to determine which "/" is
text and which is a delimiter in case of doubt, one ought to escape
these literal characters like this:

  /     E<sol>
  |     E<verbar>

=back

=head1 RETURN VALUE

B<podchecker> returns the number of POD syntax errors found or -1 if
there were no POD commands at all found in the file.

=head1 EXAMPLES

See L</SYNOPSIS>

=head1 INTERFACE

While checking, this module collects document properties, e.g. the nodes
for hyperlinks (C<=headX>, C<=item>) and index entries (C<XE<lt>E<gt>>).
POD translators can use this feature to syntax-check and get the nodes in
a first pass before actually starting to convert. This is expensive in terms
of execution time, but allows for very robust conversions.

Since PodParser-1.24 the B<Pod::Checker> module uses only the B<poderror>
method to print errors and warnings. The summary output (e.g.
"Pod syntax OK") has been dropped from the module and has been included in
B<podchecker> (the script). This allows users of B<Pod::Checker> to
control completely the output behavior. Users of B<podchecker> (the script)
get the well-known behavior.

=cut

#############################################################################

#use diagnostics;
use Carp qw(croak);
use Exporter;
use Pod::Parser;

@ISA = qw(Pod::Parser);
@EXPORT = qw(&podchecker);

my %VALID_COMMANDS = (
    'pod'    =>  1,
    'cut'    =>  1,
    'head1'  =>  1,
    'head2'  =>  1,
    'head3'  =>  1,
    'head4'  =>  1,
    'over'   =>  1,
    'back'   =>  1,
    'item'   =>  1,
    'for'    =>  1,
    'begin'  =>  1,
    'end'    =>  1,
    'encoding' =>  1,
);

my %VALID_SEQUENCES = (
    'I'  =>  1,
    'B'  =>  1,
    'S'  =>  1,
    'C'  =>  1,
    'L'  =>  1,
    'F'  =>  1,
    'X'  =>  1,
    'Z'  =>  1,
    'E'  =>  1,
);

# stolen from HTML::Entities
my %ENTITIES = (
 # Some normal chars that have special meaning in SGML context
 amp    => '&',  # ampersand
'gt'    => '>',  # greater than
'lt'    => '<',  # less than
 quot   => '"',  # double quote

 # PUBLIC ISO 8879-1986//ENTITIES Added Latin 1//EN//HTML
 AElig  => '',  # capital AE diphthong (ligature)
 Aacute => '',  # capital A, acute accent
 Acirc  => '',  # capital A, circumflex accent
 Agrave => '',  # capital A, grave accent
 Aring  => '',  # capital A, ring
 Atilde => '',  # capital A, tilde
 Auml   => '',  # capital A, dieresis or umlaut mark
 Ccedil => '',  # capital C, cedilla
 ETH    => '',  # capital Eth, Icelandic
 Eacute => '',  # capital E, acute accent
 Ecirc  => '',  # capital E, circumflex accent
 Egrave => '',  # capital E, grave accent
 Euml   => '',  # capital E, dieresis or umlaut mark
 Iacute => '',  # capital I, acute accent
 Icirc  => '',  # capital I, circumflex accent
 Igrave => '',  # capital I, grave accent
 Iuml   => '',  # capital I, dieresis or umlaut mark
 Ntilde => '',  # capital N, tilde
 Oacute => '',  # capital O, acute accent
 Ocirc  => '',  # capital O, circumflex accent
 Ograve => '',  # capital O, grave accent
 Oslash => '',  # capital O, slash
 Otilde => '',  # capital O, tilde
 Ouml   => '',  # capital O, dieresis or umlaut mark
 THORN  => '',  # capital THORN, Icelandic
 Uacute => '',  # capital U, acute accent
 Ucirc  => '',  # capital U, circumflex accent
 Ugrave => '',  # capital U, grave accent
 Uuml   => '',  # capital U, dieresis or umlaut mark
 Yacute => '',  # capital Y, acute accent
 aacute => '',  # small a, acute accent
 acirc  => '',  # small a, circumflex accent
 aelig  => '',  # small ae diphthong (ligature)
 agrave => '',  # small a, grave accent
 aring  => '',  # small a, ring
 atilde => '',  # small a, tilde
 auml   => '',  # small a, dieresis or umlaut mark
 ccedil => '',  # small c, cedilla
 eacute => '',  # small e, acute accent
 ecirc  => '',  # small e, circumflex accent
 egrave => '',  # small e, grave accent
 eth    => '',  # small eth, Icelandic
 euml   => '',  # small e, dieresis or umlaut mark
 iacute => '',  # small i, acute accent
 icirc  => '',  # small i, circumflex accent
 igrave => '',  # small i, grave accent
 iuml   => '',  # small i, dieresis or umlaut mark
 ntilde => '',  # small n, tilde
 oacute => '',  # small o, acute accent
 ocirc  => '',  # small o, circumflex accent
 ograve => '',  # small o, grave accent
 oslash => '',  # small o, slash
 otilde => '',  # small o, tilde
 ouml   => '',  # small o, dieresis or umlaut mark
 szlig  => '',  # small sharp s, German (sz ligature)
 thorn  => '',  # small thorn, Icelandic
 uacute => '',  # small u, acute accent
 ucirc  => '',  # small u, circumflex accent
 ugrave => '',  # small u, grave accent
 uuml   => '',  # small u, dieresis or umlaut mark
 yacute => '',  # small y, acute accent
 yuml   => '',  # small y, dieresis or umlaut mark

 # Some extra Latin 1 chars that are listed in the HTML3.2 draft (21-May-96)
 copy   => '',  # copyright sign
 reg    => '',  # registered sign
 nbsp   => "\240", # non breaking space

 # Additional ISO-8859/1 entities listed in rfc1866 (section 14)
 iexcl  => '',
 cent   => '',
 pound  => '',
 curren => '',
 yen    => '',
 brvbar => '',
 sect   => '',
 uml    => '',
 ordf   => '',
 laquo  => '',
'not'   => '',    # not is a keyword in perl
 shy    => '',
 macr   => '',
 deg    => '',
 plusmn => '',
 sup1   => '',
 sup2   => '',
 sup3   => '',
 acute  => '',
 micro  => '',
 para   => '',
 middot => '',
 cedil  => '',
 ordm   => '',
 raquo  => '',
 frac14 => '',
 frac12 => '',
 frac34 => '',
 iquest => '',
'times' => '',    # times is a keyword in perl
 divide => '',

# some POD special entities
 verbar => '|',
 sol => '/'
);

##---------------------------------------------------------------------------

##---------------------------------
## Function definitions begin here
##---------------------------------

sub podchecker {
    my ($infile, $outfile, %options) = @_;
    local $_;

    ## Set defaults
    $infile  ||= \*STDIN;
    $outfile ||= \*STDERR;

    ## Now create a pod checker
    my $checker = new Pod::Checker(%options);

    ## Now check the pod document for errors
    $checker->parse_from_file($infile, $outfile);

    ## Return the number of errors found
    return $checker->num_errors();
}

##---------------------------------------------------------------------------

##-------------------------------
## Method definitions begin here
##-------------------------------

##################################

=over 4

=item C<Pod::Checker-E<gt>new( %options )>

Return a reference to a new Pod::Checker object that inherits from
Pod::Parser and is used for calling the required methods later. The
following options are recognized:

C<-warnings =E<gt> num>
  Print warnings if C<num> is true. The higher the value of C<num>,
the more warnings are printed. Currently there are only levels 1 and 2.

C<-quiet =E<gt> num>
  If C<num> is true, do not print any errors/warnings. This is useful
when Pod::Checker is used to munge POD code into plain text from within
POD formatters.

=cut

## sub new {
##     my $this = shift;
##     my $class = ref($this) || $this;
##     my %params = @_;
##     my $self = {%params};
##     bless $self, $class;
##     $self->initialize();
##     return $self;
## }

sub initialize {
    my $self = shift;
    ## Initialize number of errors, and setup an error function to
    ## increment this number and then print to the designated output.
    $self->{_NUM_ERRORS} = 0;
    $self->{_NUM_WARNINGS} = 0;
    $self->{-quiet} ||= 0;
    # set the error handling subroutine
    $self->errorsub($self->{-quiet} ? sub { 1; } : 'poderror');
    $self->{_commands} = 0; # total number of POD commands encountered
    $self->{_list_stack} = []; # stack for nested lists
    $self->{_have_begin} = ''; # stores =begin
    $self->{_links} = []; # stack for internal hyperlinks
    $self->{_nodes} = []; # stack for =head/=item nodes
    $self->{_index} = []; # text in X<>
    # print warnings?
    $self->{-warnings} = 1 unless(defined $self->{-warnings});
    $self->{_current_head1} = ''; # the current =head1 block
    $self->parseopts(-process_cut_cmd => 1, -warnings => $self->{-warnings});
}

##################################

=item C<$checker-E<gt>poderror( @args )>

=item C<$checker-E<gt>poderror( {%opts}, @args )>

Internal method for printing errors and warnings. If no options are
given, simply prints "@_". The following options are recognized and used
to form the output:

  -msg

A message to print prior to C<@args>.

  -line

The line number the error occurred in.

  -file

The file (name) the error occurred in.

  -severity

The error level, should be 'WARNING' or 'ERROR'.

=cut

# Invoked as $self->poderror( @args ), or $self->poderror( {%opts}, @args )
sub poderror {
    my $self = shift;
    my %opts = (ref $_[0]) ? %{shift()} : ();

    ## Retrieve options
    chomp( my $msg  = ($opts{-msg} || '')."@_" );
    my $line = (exists $opts{-line}) ? " at line $opts{-line}" : '';
    my $file = (exists $opts{-file}) ? " in file $opts{-file}" : '';
    unless (exists $opts{-severity}) {
       ## See if can find severity in message prefix
       $opts{-severity} = $1  if ( $msg =~ s/^\**\s*([A-Z]{3,}):\s+// );
    }
    my $severity = (exists $opts{-severity}) ? "*** $opts{-severity}: " : '';

    ## Increment error count and print message "
    ++($self->{_NUM_ERRORS})
        if(!%opts || ($opts{-severity} && $opts{-severity} eq 'ERROR'));
    ++($self->{_NUM_WARNINGS})
        if(!%opts || ($opts{-severity} && $opts{-severity} eq 'WARNING'));
    unless($self->{-quiet}) {
      my $out_fh = $self->output_handle() || \*STDERR;
      print $out_fh ($severity, $msg, $line, $file, "\n")
        if($self->{-warnings} || !%opts || $opts{-severity} ne 'WARNING');
    }
}

##################################

=item C<$checker-E<gt>num_errors()>

Set (if argument specified) and retrieve the number of errors found.

=cut

sub num_errors {
   return (@_ > 1) ? ($_[0]->{_NUM_ERRORS} = $_[1]) : $_[0]->{_NUM_ERRORS};
}

##################################

=item C<$checker-E<gt>num_warnings()>

Set (if argument specified) and retrieve the number of warnings found.

=cut

sub num_warnings {
   return (@_ > 1) ? ($_[0]->{_NUM_WARNINGS} = $_[1]) : $_[0]->{_NUM_WARNINGS};
}

##################################

=item C<$checker-E<gt>name()>

Set (if argument specified) and retrieve the canonical name of POD as
found in the C<=head1 NAME> section.

=cut

sub name {
    return (@_ > 1 && $_[1]) ?
        ($_[0]->{-name} = $_[1]) : $_[0]->{-name};
}

##################################

=item C<$checker-E<gt>node()>

Add (if argument specified) and retrieve the nodes (as defined by C<=headX>
and C<=item>) of the current POD. The nodes are returned in the order of
their occurrence. They consist of plain text, each piece of whitespace is
collapsed to a single blank.

=cut

sub node {
    my ($self,$text) = @_;
    if(defined $text) {
        $text =~ s/\s+$//s; # strip trailing whitespace
        $text =~ s/\s+/ /gs; # collapse whitespace
        # add node, order important!
        push(@{$self->{_nodes}}, $text);
        # keep also a uniqueness counter
        $self->{_unique_nodes}->{$text}++ if($text !~ /^\s*$/s);
        return $text;
    }
    @{$self->{_nodes}};
}

##################################

=item C<$checker-E<gt>idx()>

Add (if argument specified) and retrieve the index entries (as defined by
C<XE<lt>E<gt>>) of the current POD. They consist of plain text, each piece
of whitespace is collapsed to a single blank.

=cut

# set/return index entries of current POD
sub idx {
    my ($self,$text) = @_;
    if(defined $text) {
        $text =~ s/\s+$//s; # strip trailing whitespace
        $text =~ s/\s+/ /gs; # collapse whitespace
        # add node, order important!
        push(@{$self->{_index}}, $text);
        # keep also a uniqueness counter
        $self->{_unique_nodes}->{$text}++ if($text !~ /^\s*$/s);
        return $text;
    }
    @{$self->{_index}};
}

##################################

=item C<$checker-E<gt>hyperlink()>

Add (if argument specified) and retrieve the hyperlinks (as defined by
C<LE<lt>E<gt>>) of the current POD. They consist of a 2-item array: line
number and C<Pod::Hyperlink> object.

=back

=cut

# set/return hyperlinks of the current POD
sub hyperlink {
    my $self = shift;
    if($_[0]) {
        push(@{$self->{_links}}, $_[0]);
        return $_[0];
    }
    @{$self->{_links}};
}

## overrides for Pod::Parser

sub end_pod {
    ## Do some final checks and
    ## print the number of errors found
    my $self   = shift;
    my $infile = $self->input_file();

    if(@{$self->{_list_stack}}) {
        my $list;
        while(($list = $self->_close_list('EOF',$infile)) &&
          $list->indent() ne 'auto') {
            $self->poderror({ -line => 'EOF', -file => $infile,
                -severity => 'ERROR', -msg => '=over on line ' .
                $list->start() . ' without closing =back' });
        }
    }

    # check validity of document internal hyperlinks
    # first build the node names from the paragraph text
    my %nodes;
    foreach($self->node()) {
        $nodes{$_} = 1;
        if(/^(\S+)\s+\S/) {
            # we have more than one word. Use the first as a node, too.
            # This is used heavily in perlfunc.pod
            $nodes{$1} ||= 2; # derived node
        }
    }
    foreach($self->idx()) {
        $nodes{$_} = 3; # index node
    }
    foreach($self->hyperlink()) {
        my ($line,$link) = @$_;
        # _TODO_ what if there is a link to the page itself by the name,
        # e.g. in Tk::Pod : L<Tk::Pod/"DESCRIPTION">
        if($link->node() && !$link->page() && $link->type() ne 'hyperlink') {
            my $node = $self->_check_ptree($self->parse_text($link->node(),
                $line), $line, $infile, 'L');
            if($node && !$nodes{$node}) {
                $self->poderror({ -line => $line || '', -file => $infile,
                    -severity => 'ERROR',
                    -msg => "unresolved internal link '$node'"});
            }
        }
    }

    # check the internal nodes for uniqueness. This pertains to
    # =headX, =item and X<...>
    if($self->{-warnings} && $self->{-warnings}>1) {
      foreach(grep($self->{_unique_nodes}->{$_} > 1,
        keys %{$self->{_unique_nodes}})) {
          $self->poderror({ -line => '-', -file => $infile,
            -severity => 'WARNING',
            -msg => "multiple occurrence of link target '$_'"});
      }
    }

    # no POD found here
    $self->num_errors(-1) if($self->{_commands} == 0);
}

# check a POD command directive
sub command {
    my ($self, $cmd, $paragraph, $line_num, $pod_para) = @_;
    my ($file, $line) = $pod_para->file_line;
    ## Check the command syntax
    my $arg; # this will hold the command argument
    if (! $VALID_COMMANDS{$cmd}) {
       $self->poderror({ -line => $line, -file => $file, -severity => 'ERROR',
                         -msg => "Unknown command '$cmd'" });
    }
    else { # found a valid command
        $self->{_commands}++; # delete this line if below is enabled again

	$self->_commands_in_paragraphs($paragraph, $pod_para);

        ##### following check disabled due to strong request
        #if(!$self->{_commands}++ && $cmd !~ /^head/) {
        #    $self->poderror({ -line => $line, -file => $file,
        #         -severity => 'WARNING',
        #         -msg => "file does not start with =head" });
        #}

        # check syntax of particular command
        if($cmd eq 'over') {
            # check for argument
            $arg = $self->interpolate_and_check($paragraph, $line,$file);
            my $indent = 4; # default
            if($arg && $arg =~ /^\s*(\d+)\s*$/) {
                $indent = $1;
            }
            # start a new list
            $self->_open_list($indent,$line,$file);
        }
        elsif($cmd eq 'item') {
            # are we in a list?
            unless(@{$self->{_list_stack}}) {
                $self->poderror({ -line => $line, -file => $file,
                     -severity => 'ERROR',
                     -msg => '=item without previous =over' });
                # auto-open in case we encounter many more
                $self->_open_list('auto',$line,$file);
            }
            my $list = $self->{_list_stack}->[0];
            # check whether the previous item had some contents
            if(defined $self->{_list_item_contents} &&
              $self->{_list_item_contents} == 0) {
                $self->poderror({ -line => $line, -file => $file,
                     -severity => 'WARNING',
                     -msg => 'previous =item has no contents' });
            }
            if($list->{_has_par}) {
                $self->poderror({ -line => $line, -file => $file,
                     -severity => 'WARNING',
                     -msg => 'preceding non-item paragraph(s)' });
                delete $list->{_has_par};
            }
            # check for argument
            $arg = $self->interpolate_and_check($paragraph, $line, $file);
            if($arg && $arg =~ /(\S+)/) {
                $arg =~ s/[\s\n]+$//;
                my $type;
                if($arg =~ /^[*]\s*(\S*.*)/) {
                  $type = 'bullet';
                  $self->{_list_item_contents} = $1 ? 1 : 0;
                  $arg = $1;
                }
                elsif($arg =~ /^\d+\.?\s+(\S*)/) {
                  $type = 'number';
                  $self->{_list_item_contents} = $1 ? 1 : 0;
                  $arg = $1;
                }
                else {
                  $type = 'definition';
                  $self->{_list_item_contents} = 1;
                }
                my $first = $list->type();
                if($first && $first ne $type) {
                    $self->poderror({ -line => $line, -file => $file,
                       -severity => 'WARNING',
                       -msg => "=item type mismatch ('$first' vs. '$type')"});
                }
                else { # first item
                    $list->type($type);
                }
            }
            else {
                $self->poderror({ -line => $line, -file => $file,
                     -severity => 'WARNING',
                     -msg => 'No argument for =item' });
                $arg = ' '; # empty
                $self->{_list_item_contents} = 0;
            }
            # add this item
            $list->item($arg);
            # remember this node
            $self->node($arg);
        }
        elsif($cmd eq 'back') {
            # check if we have an open list
            unless(@{$self->{_list_stack}}) {
                $self->poderror({ -line => $line, -file => $file,
                         -severity => 'ERROR',
                         -msg => '=back without previous =over' });
            }
            else {
                # check for spurious characters
                $arg = $self->interpolate_and_check($paragraph, $line,$file);
                if($arg && $arg =~ /\S/) {
                    $self->poderror({ -line => $line, -file => $file,
                         -severity => 'ERROR',
                         -msg => 'Spurious character(s) after =back' });
                }
                # close list
                my $list = $self->_close_list($line,$file);
                # check for empty lists
                if(!$list->item() && $self->{-warnings}) {
                    $self->poderror({ -line => $line, -file => $file,
                         -severity => 'WARNING',
                         -msg => 'No items in =over (at line ' .
                         $list->start() . ') / =back list'});
                }
            }
        }
        elsif($cmd =~ /^head(\d+)/) {
            my $hnum = $1;
            $self->{"_have_head_$hnum"}++; # count head types
            if($hnum > 1 && !$self->{'_have_head_'.($hnum -1)}) {
              $self->poderror({ -line => $line, -file => $file,
                   -severity => 'WARNING',
                   -msg => "=head$hnum without preceding higher level"});
            }
            # check whether the previous =head section had some contents
            if(defined $self->{_commands_in_head} &&
              $self->{_commands_in_head} == 0 &&
              defined $self->{_last_head} &&
              $self->{_last_head} >= $hnum) {
                $self->poderror({ -line => $line, -file => $file,
                     -severity => 'WARNING',
                     -msg => 'empty section in previous paragraph'});
            }
            $self->{_commands_in_head} = -1;
            $self->{_last_head} = $hnum;
            # check if there is an open list
            if(@{$self->{_list_stack}}) {
                my $list;
                while(($list = $self->_close_list($line,$file)) &&
                  $list->indent() ne 'auto') {
                    $self->poderror({ -line => $line, -file => $file,
                         -severity => 'ERROR',
                         -msg => '=over on line '. $list->start() .
                         " without closing =back (at $cmd)" });
                }
            }
            # remember this node
            $arg = $self->interpolate_and_check($paragraph, $line,$file);
            $arg =~ s/[\s\n]+$//s;
            $self->node($arg);
            unless(length($arg)) {
                $self->poderror({ -line => $line, -file => $file,
                     -severity => 'ERROR',
                     -msg => "empty =$cmd"});
            }
            if($cmd eq 'head1') {
                $self->{_current_head1} = $arg;
            } else {
                $self->{_current_head1} = '';
            }
        }
        elsif($cmd eq 'begin') {
            if($self->{_have_begin}) {
                # already have a begin
                $self->poderror({ -line => $line, -file => $file,
                     -severity => 'ERROR',
                     -msg => q{Nested =begin's (first at line } .
                     $self->{_have_begin} . ')'});
            }
            else {
                # check for argument
                $arg = $self->interpolate_and_check($paragraph, $line,$file);
                unless($arg && $arg =~ /(\S+)/) {
                    $self->poderror({ -line => $line, -file => $file,
                         -severity => 'ERROR',
                         -msg => 'No argument for =begin'});
                }
                # remember the =begin
                $self->{_have_begin} = "$line:$1";
            }
        }
        elsif($cmd eq 'end') {
            if($self->{_have_begin}) {
                # close the existing =begin
                $self->{_have_begin} = '';
                # check for spurious characters
                $arg = $self->interpolate_and_check($paragraph, $line,$file);
                # the closing argument is optional
                #if($arg && $arg =~ /\S/) {
                #    $self->poderror({ -line => $line, -file => $file,
                #         -severity => 'WARNING',
                #         -msg => "Spurious character(s) after =end" });
                #}
            }
            else {
                # don't have a matching =begin
                $self->poderror({ -line => $line, -file => $file,
                     -severity => 'ERROR',
                     -msg => '=end without =begin' });
            }
        }
        elsif($cmd eq 'for') {
            unless($paragraph =~ /\s*(\S+)\s*/) {
                $self->poderror({ -line => $line, -file => $file,
                     -severity => 'ERROR',
                     -msg => '=for without formatter specification' });
            }
            $arg = ''; # do not expand paragraph below
        }
        elsif($cmd =~ /^(pod|cut)$/) {
            # check for argument
            $arg = $self->interpolate_and_check($paragraph, $line,$file);
            if($arg && $arg =~ /(\S+)/) {
                $self->poderror({ -line => $line, -file => $file,
                      -severity => 'ERROR',
                      -msg => "Spurious text after =$cmd"});
            }
	    if($cmd eq 'cut' && (!$self->{_PREVIOUS} || $self->{_PREVIOUS} eq 'cut')) {
                $self->poderror({ -line => $line, -file => $file,
                      -severity => 'ERROR',
                      -msg => "Spurious =cut command"});
	    }
	    if($cmd eq 'pod' && $self->{_PREVIOUS} && $self->{_PREVIOUS} ne 'cut') {
                $self->poderror({ -line => $line, -file => $file,
                      -severity => 'ERROR',
                      -msg => "Spurious =pod command"});
	    }
        }
    $self->{_commands_in_head}++;
    ## Check the interior sequences in the command-text
    $self->interpolate_and_check($paragraph, $line,$file)
        unless(defined $arg);
    }
}

sub _open_list
{
    my ($self,$indent,$line,$file) = @_;
    my $list = Pod::List->new(
           -indent => $indent,
           -start => $line,
           -file => $file);
    unshift(@{$self->{_list_stack}}, $list);
    undef $self->{_list_item_contents};
    $list;
}

sub _close_list
{
    my ($self,$line,$file) = @_;
    my $list = shift(@{$self->{_list_stack}});
    if(defined $self->{_list_item_contents} &&
      $self->{_list_item_contents} == 0) {
        $self->poderror({ -line => $line, -file => $file,
            -severity => 'WARNING',
            -msg => 'previous =item has no contents' });
    }
    undef $self->{_list_item_contents};
    $list;
}

# process a block of some text
sub interpolate_and_check {
    my ($self, $paragraph, $line, $file) = @_;
    ## Check the interior sequences in the command-text
    # and return the text
    $self->_check_ptree(
        $self->parse_text($paragraph,$line), $line, $file, '');
}

sub _check_ptree {
    my ($self,$ptree,$line,$file,$nestlist) = @_;
    local($_);
    my $text = '';
    # process each node in the parse tree
    foreach(@$ptree) {
        # regular text chunk
        unless(ref) {
            # count the unescaped angle brackets
            # complain only when warning level is greater than 1
            if($self->{-warnings} && $self->{-warnings}>1) {
              my $count;
              if($count = tr/<>/<>/) {
                $self->poderror({ -line => $line, -file => $file,
                     -severity => 'WARNING',
                     -msg => "$count unescaped <> in paragraph" });
                }
            }
            $text .= $_;
            next;
        }
        # have an interior sequence
        my $cmd = $_->cmd_name();
        my $contents = $_->parse_tree();
        ($file,$line) = $_->file_line();
        # check for valid tag
        if (! $VALID_SEQUENCES{$cmd}) {
            $self->poderror({ -line => $line, -file => $file,
                 -severity => 'ERROR',
                 -msg => qq(Unknown interior-sequence '$cmd')});
            # expand it anyway
            $text .= $self->_check_ptree($contents, $line, $file, "$nestlist$cmd");
            next;
        }
        if(index($nestlist, $cmd) != -1) {
            $self->poderror({ -line => $line, -file => $file,
                 -severity => 'WARNING',
                 -msg => "nested commands $cmd<...$cmd<...>...>"});
            # _TODO_ should we add the contents anyway?
            # expand it anyway, see below
        }
        if($cmd eq 'E') {
            # preserve entities
            if(@$contents > 1 || ref $$contents[0] || $$contents[0] !~ /^\w+$/) {
                $self->poderror({ -line => $line, -file => $file,
                    -severity => 'ERROR',
                    -msg => 'garbled entity ' . $_->raw_text()});
                next;
            }
            my $ent = $$contents[0];
            my $val;
            if($ent =~ /^0x[0-9a-f]+$/i) {
                # hexadec entity
                $val = hex($ent);
            }
            elsif($ent =~ /^0\d+$/) {
                # octal
                $val = oct($ent);
            }
            elsif($ent =~ /^\d+$/) {
                # numeric entity
                $val = $ent;
            }
            if(defined $val) {
                if($val>0 && $val<256) {
                    $text .= chr($val);
                }
                else {
                    $self->poderror({ -line => $line, -file => $file,
                        -severity => 'ERROR',
                        -msg => 'Entity number out of range ' . $_->raw_text()});
                }
            }
            elsif($ENTITIES{$ent}) {
                # known ISO entity
                $text .= $ENTITIES{$ent};
            }
            else {
                $self->poderror({ -line => $line, -file => $file,
                    -severity => 'WARNING',
                    -msg => 'Unknown entity ' . $_->raw_text()});
                $text .= "E<$ent>";
            }
        }
        elsif($cmd eq 'L') {
            # try to parse the hyperlink
            my $link = Pod::Hyperlink->new($contents->raw_text());
            unless(defined $link) {
                $self->poderror({ -line => $line, -file => $file,
                    -severity => 'ERROR',
                    -msg => 'malformed link ' . $_->raw_text() ." : $@"});
                next;
            }
            $link->line($line); # remember line
            if($self->{-warnings}) {
                foreach my $w ($link->warning()) {
                    $self->poderror({ -line => $line, -file => $file,
                        -severity => 'WARNING',
                        -msg => $w });
                }
            }
            # check the link text
            $text .= $self->_check_ptree($self->parse_text($link->text(),
                $line), $line, $file, "$nestlist$cmd");
            # remember link
            $self->hyperlink([$line,$link]);
        }
        elsif($cmd =~ /[BCFIS]/) {
            # add the guts
            $text .= $self->_check_ptree($contents, $line, $file, "$nestlist$cmd");
        }
        elsif($cmd eq 'Z') {
            if(length($contents->raw_text())) {
                $self->poderror({ -line => $line, -file => $file,
                    -severity => 'ERROR',
                    -msg => 'Nonempty Z<>'});
            }
        }
        elsif($cmd eq 'X') {
            my $idx = $self->_check_ptree($contents, $line, $file, "$nestlist$cmd");
            if($idx =~ /^\s*$/s) {
                $self->poderror({ -line => $line, -file => $file,
                    -severity => 'ERROR',
                    -msg => 'Empty X<>'});
            }
            else {
                # remember this node
                $self->idx($idx);
            }
        }
        else {
            # not reached
            croak 'internal error';
        }
    }
    $text;
}

# process a block of verbatim text
sub verbatim {
    ## Nothing particular to check
    my ($self, $paragraph, $line_num, $pod_para) = @_;

    $self->_preproc_par($paragraph);
    $self->_commands_in_paragraphs($paragraph, $pod_para);

    if($self->{_current_head1} eq 'NAME') {
        my ($file, $line) = $pod_para->file_line;
        $self->poderror({ -line => $line, -file => $file,
            -severity => 'WARNING',
            -msg => 'Verbatim paragraph in NAME section' });
    }
}

# process a block of regular text
sub textblock {
    my ($self, $paragraph, $line_num, $pod_para) = @_;
    my ($file, $line) = $pod_para->file_line;

    $self->_preproc_par($paragraph);
    $self->_commands_in_paragraphs($paragraph, $pod_para);

    # skip this paragraph if in a =begin block
    unless($self->{_have_begin}) {
        my $block = $self->interpolate_and_check($paragraph, $line,$file);
        if($self->{_current_head1} eq 'NAME') {
            if($block =~ /^\s*(\S+?)\s*[,-]/) {
                # this is the canonical name
                $self->{-name} = $1 unless(defined $self->{-name});
            }
        }
    }
}

sub _preproc_par
{
    my $self = shift;
    $_[0] =~ s/[\s\n]+$//;
    if($_[0]) {
        $self->{_commands_in_head}++;
        $self->{_list_item_contents}++ if(defined $self->{_list_item_contents});
        if(@{$self->{_list_stack}} && !$self->{_list_stack}->[0]->item()) {
            $self->{_list_stack}->[0]->{_has_par} = 1;
        }
    }
}

# look for =foo commands at the start of a line within a paragraph, as for
# instance the following which prints as "* one =item two".
#
#     =item one
#     =item two
#
# Examples of =foo written in docs are expected to be indented in a verbatim
# or marked up C<=foo> so won't be caught.  A double-angle C<< =foo >> could
# have the =foo at the start of a line, but that should be unlikely and is
# easily enough dealt with by not putting a newline after the C<<.
#
sub _commands_in_paragraphs {
  my ($self, $str, $pod_para) = @_;
  while ($str =~ /[^\n]\n=([a-z][a-z0-9]+)/sg) {
    my $cmd = $1;
    my $pos = pos($str);
    if ($VALID_COMMANDS{$cmd}) {
      my ($file, $line) = $pod_para->file_line;
      my $part = substr($str, 0, $pos);
      $line += ($part =~ tr/\n//);  # count of newlines

      $self->poderror
        ({ -line => $line, -file => $file,
           -severity => 'ERROR',
           -msg => "Apparent command =$cmd not preceded by blank line"});
    }
  }
}

1;

__END__

=head1 AUTHOR

Please report bugs using L<http://rt.cpan.org>.

Brad Appleton E<lt>bradapp@enteract.comE<gt> (initial version),
Marek Rouchal E<lt>marekr@cpan.orgE<gt>

Based on code for B<Pod::Text::pod2text()> written by
Tom Christiansen E<lt>tchrist@mox.perl.comE<gt>

B<Pod::Checker> is part of the Pod-Checker distribution, and is based on
L<Pod::Parser>.

=cut

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     package Pod::Escapes;
use strict;
use warnings;
use 5.006;

use vars qw(
  %Code2USASCII
  %Name2character
  %Name2character_number
  %Latin1Code_to_fallback
  %Latin1Char_to_fallback
  $FAR_CHAR
  $FAR_CHAR_NUMBER
  $NOT_ASCII
  @ISA $VERSION @EXPORT_OK %EXPORT_TAGS
);

require Exporter;
@ISA = ('Exporter');
$VERSION = '1.07';
@EXPORT_OK = qw(
  %Code2USASCII
  %Name2character
  %Name2character_number
  %Latin1Code_to_fallback
  %Latin1Char_to_fallback
  e2char
  e2charnum
);
%EXPORT_TAGS = ('ALL' => \@EXPORT_OK);

#==========================================================================

$FAR_CHAR = "?" unless defined $FAR_CHAR;
$FAR_CHAR_NUMBER = ord($FAR_CHAR) unless defined $FAR_CHAR_NUMBER;

$NOT_ASCII = 'A' ne chr(65) unless defined $NOT_ASCII;

#--------------------------------------------------------------------------
sub e2char {
  my $in = $_[0];
  return undef unless defined $in and length $in;
  
  # Convert to decimal:
  if($in =~ m/^(0[0-7]*)$/s ) {
    $in = oct $in;
  } elsif($in =~ m/^0?x([0-9a-fA-F]+)$/s ) {
    $in = hex $1;
  } # else it's decimal, or named

  if($in =~ m/^\d+$/s) {
    if($] < 5.007  and  $in > 255) { # can't be trusted with Unicode
      return $FAR_CHAR;
    } elsif ($] >= 5.007003) {
      return chr(utf8::unicode_to_native($in));
    } elsif ($NOT_ASCII) {
      return $Code2USASCII{$in} # so "65" => "A" everywhere
             || $Latin1Code_to_fallback{$in} # Fallback.
             || $FAR_CHAR; # Fall further back
    } else {
      return chr($in);
    }
  } else {
    return $Name2character{$in}; # returns undef if unknown
  }
}

#--------------------------------------------------------------------------
sub e2charnum {
  my $in = $_[0];
  return undef unless defined $in and length $in;
  
  # Convert to decimal:
  if($in =~ m/^(0[0-7]*)$/s ) {
    $in = oct $in;
  } elsif($in =~ m/^0?x([0-9a-fA-F]+)$/s ) {
    $in = hex $1;
  } # else it's decimal, or named

  if($in =~ m/^[0-9]+$/s) {
    return 0 + $in;
  } else {
    return $Name2character_number{$in}; # returns undef if unknown
  }
}

#--------------------------------------------------------------------------

%Code2USASCII = (
# mostly generated by
#  perl -e "printf qq{  \x25 3s, '\x25s',\n}, $_, chr($_) foreach (32 .. 126)"
   32, ' ',
   33, '!',
   34, '"',
   35, '#',
   36, '$',
   37, '%',
   38, '&',
   39, "'", #!
   40, '(',
   41, ')',
   42, '*',
   43, '+',
   44, ',',
   45, '-',
   46, '.',
   47, '/',
   48, '0',
   49, '1',
   50, '2',
   51, '3',
   52, '4',
   53, '5',
   54, '6',
   55, '7',
   56, '8',
   57, '9',
   58, ':',
   59, ';',
   60, '<',
   61, '=',
   62, '>',
   63, '?',
   64, '@',
   65, 'A',
   66, 'B',
   67, 'C',
   68, 'D',
   69, 'E',
   70, 'F',
   71, 'G',
   72, 'H',
   73, 'I',
   74, 'J',
   75, 'K',
   76, 'L',
   77, 'M',
   78, 'N',
   79, 'O',
   80, 'P',
   81, 'Q',
   82, 'R',
   83, 'S',
   84, 'T',
   85, 'U',
   86, 'V',
   87, 'W',
   88, 'X',
   89, 'Y',
   90, 'Z',
   91, '[',
   92, "\\", #!
   93, ']',
   94, '^',
   95, '_',
   96, '`',
   97, 'a',
   98, 'b',
   99, 'c',
  100, 'd',
  101, 'e',
  102, 'f',
  103, 'g',
  104, 'h',
  105, 'i',
  106, 'j',
  107, 'k',
  108, 'l',
  109, 'm',
  110, 'n',
  111, 'o',
  112, 'p',
  113, 'q',
  114, 'r',
  115, 's',
  116, 't',
  117, 'u',
  118, 'v',
  119, 'w',
  120, 'x',
  121, 'y',
  122, 'z',
  123, '{',
  124, '|',
  125, '}',
  126, '~',
);

#--------------------------------------------------------------------------

%Latin1Code_to_fallback = ();
@Latin1Code_to_fallback{0xA0 .. 0xFF} = (
# Copied from Text/Unidecode/x00.pm:

' ', qq{!}, qq{C/}, 'PS', qq{\$?}, qq{Y=}, qq{|}, 'SS', qq{"}, qq{(c)}, 'a', qq{<<}, qq{!}, "", qq{(r)}, qq{-},
'deg', qq{+-}, '2', '3', qq{'}, 'u', 'P', qq{*}, qq{,}, '1', 'o', qq{>>}, qq{1/4}, qq{1/2}, qq{3/4}, qq{?},
'A', 'A', 'A', 'A', 'A', 'A', 'AE', 'C', 'E', 'E', 'E', 'E', 'I', 'I', 'I', 'I',
'D', 'N', 'O', 'O', 'O', 'O', 'O', 'x', 'O', 'U', 'U', 'U', 'U', 'U', 'Th', 'ss',
'a', 'a', 'a', 'a', 'a', 'a', 'ae', 'c', 'e', 'e', 'e', 'e', 'i', 'i', 'i', 'i',
'd', 'n', 'o', 'o', 'o', 'o', 'o', qq{/}, 'o', 'u', 'u', 'u', 'u', 'y', 'th', 'y',

);

{
  # Now stuff %Latin1Char_to_fallback:
  %Latin1Char_to_fallback = ();
  my($k,$v);
  while( ($k,$v) = each %Latin1Code_to_fallback) {
    $Latin1Char_to_fallback{chr $k} = $v;
    #print chr($k), ' => ', $v, "\n";
  }
}

#--------------------------------------------------------------------------

%Name2character_number = (
 # General XML/XHTML:
 'lt'   => 60,
 'gt'   => 62,
 'quot' => 34,
 'amp'  => 38,
 'apos' => 39,

 # POD-specific:
 'sol'    => 47,
 'verbar' => 124,

 'lchevron' => 171, # legacy for laquo
 'rchevron' => 187, # legacy for raquo

 # Remember, grave looks like \ (as in virtu\)
 #           acute looks like / (as in re/sume/)
 #           circumflex looks like ^ (as in papier ma^che/)
 #           umlaut/dieresis looks like " (as in nai"ve, Chloe")

 # From the XHTML 1 .ent files:
 'nbsp'     , 160,
 'iexcl'    , 161,
 'cent'     , 162,
 'pound'    , 163,
 'curren'   , 164,
 'yen'      , 165,
 'brvbar'   , 166,
 'sect'     , 167,
 'uml'      , 168,
 'copy'     , 169,
 'ordf'     , 170,
 'laquo'    , 171,
 'not'      , 172,
 'shy'      , 173,
 'reg'      , 174,
 'macr'     , 175,
 'deg'      , 176,
 'plusmn'   , 177,
 'sup2'     , 178,
 'sup3'     , 179,
 'acute'    , 180,
 'micro'    , 181,
 'para'     , 182,
 'middot'   , 183,
 'cedil'    , 184,
 'sup1'     , 185,
 'ordm'     , 186,
 'raquo'    , 187,
 'frac14'   , 188,
 'frac12'   , 189,
 'frac34'   , 190,
 'iquest'   , 191,
 'Agrave'   , 192,
 'Aacute'   , 193,
 'Acirc'    , 194,
 'Atilde'   , 195,
 'Auml'     , 196,
 'Aring'    , 197,
 'AElig'    , 198,
 'Ccedil'   , 199,
 'Egrave'   , 200,
 'Eacute'   , 201,
 'Ecirc'    , 202,
 'Euml'     , 203,
 'Igrave'   , 204,
 'Iacute'   , 205,
 'Icirc'    , 206,
 'Iuml'     , 207,
 'ETH'      , 208,
 'Ntilde'   , 209,
 'Ograve'   , 210,
 'Oacute'   , 211,
 'Ocirc'    , 212,
 'Otilde'   , 213,
 'Ouml'     , 214,
 'times'    , 215,
 'Oslash'   , 216,
 'Ugrave'   , 217,
 'Uacute'   , 218,
 'Ucirc'    , 219,
 'Uuml'     , 220,
 'Yacute'   , 221,
 'THORN'    , 222,
 'szlig'    , 223,
 'agrave'   , 224,
 'aacute'   , 225,
 'acirc'    , 226,
 'atilde'   , 227,
 'auml'     , 228,
 'aring'    , 229,
 'aelig'    , 230,
 'ccedil'   , 231,
 'egrave'   , 232,
 'eacute'   , 233,
 'ecirc'    , 234,
 'euml'     , 235,
 'igrave'   , 236,
 'iacute'   , 237,
 'icirc'    , 238,
 'iuml'     , 239,
 'eth'      , 240,
 'ntilde'   , 241,
 'ograve'   , 242,
 'oacute'   , 243,
 'ocirc'    , 244,
 'otilde'   , 245,
 'ouml'     , 246,
 'divide'   , 247,
 'oslash'   , 248,
 'ugrave'   , 249,
 'uacute'   , 250,
 'ucirc'    , 251,
 'uuml'     , 252,
 'yacute'   , 253,
 'thorn'    , 254,
 'yuml'     , 255,

 'fnof'     , 402,
 'Alpha'    , 913,
 'Beta'     , 914,
 'Gamma'    , 915,
 'Delta'    , 916,
 'Epsilon'  , 917,
 'Zeta'     , 918,
 'Eta'      , 919,
 'Theta'    , 920,
 'Iota'     , 921,
 'Kappa'    , 922,
 'Lambda'   , 923,
 'Mu'       , 924,
 'Nu'       , 925,
 'Xi'       , 926,
 'Omicron'  , 927,
 'Pi'       , 928,
 'Rho'      , 929,
 'Sigma'    , 931,
 'Tau'      , 932,
 'Upsilon'  , 933,
 'Phi'      , 934,
 'Chi'      , 935,
 'Psi'      , 936,
 'Omega'    , 937,
 'alpha'    , 945,
 'beta'     , 946,
 'gamma'    , 947,
 'delta'    , 948,
 'epsilon'  , 949,
 'zeta'     , 950,
 'eta'      , 951,
 'theta'    , 952,
 'iota'     , 953,
 'kappa'    , 954,
 'lambda'   , 955,
 'mu'       , 956,
 'nu'       , 957,
 'xi'       , 958,
 'omicron'  , 959,
 'pi'       , 960,
 'rho'      , 961,
 'sigmaf'   , 962,
 'sigma'    , 963,
 'tau'      , 964,
 'upsilon'  , 965,
 'phi'      , 966,
 'chi'      , 967,
 'psi'      , 968,
 'omega'    , 969,
 'thetasym' , 977,
 'upsih'    , 978,
 'piv'      , 982,
 'bull'     , 8226,
 'hellip'   , 8230,
 'prime'    , 8242,
 'Prime'    , 8243,
 'oline'    , 8254,
 'frasl'    , 8260,
 'weierp'   , 8472,
 'image'    , 8465,
 'real'     , 8476,
 'trade'    , 8482,
 'alefsym'  , 8501,
 'larr'     , 8592,
 'uarr'     , 8593,
 'rarr'     , 8594,
 'darr'     , 8595,
 'harr'     , 8596,
 'crarr'    , 8629,
 'lArr'     , 8656,
 'uArr'     , 8657,
 'rArr'     , 8658,
 'dArr'     , 8659,
 'hArr'     , 8660,
 'forall'   , 8704,
 'part'     , 8706,
 'exist'    , 8707,
 'empty'    , 8709,
 'nabla'    , 8711,
 'isin'     , 8712,
 'notin'    , 8713,
 'ni'       , 8715,
 'prod'     , 8719,
 'sum'      , 8721,
 'minus'    , 8722,
 'lowast'   , 8727,
 'radic'    , 8730,
 'prop'     , 8733,
 'infin'    , 8734,
 'ang'      , 8736,
 'and'      , 8743,
 'or'       , 8744,
 'cap'      , 8745,
 'cup'      , 8746,
 'int'      , 8747,
 'there4'   , 8756,
 'sim'      , 8764,
 'cong'     , 8773,
 'asymp'    , 8776,
 'ne'       , 8800,
 'equiv'    , 8801,
 'le'       , 8804,
 'ge'       , 8805,
 'sub'      , 8834,
 'sup'      , 8835,
 'nsub'     , 8836,
 'sube'     , 8838,
 'supe'     , 8839,
 'oplus'    , 8853,
 'otimes'   , 8855,
 'perp'     , 8869,
 'sdot'     , 8901,
 'lceil'    , 8968,
 'rceil'    , 8969,
 'lfloor'   , 8970,
 'rfloor'   , 8971,
 'lang'     , 9001,
 'rang'     , 9002,
 'loz'      , 9674,
 'spades'   , 9824,
 'clubs'    , 9827,
 'hearts'   , 9829,
 'diams'    , 9830,
 'OElig'    , 338,
 'oelig'    , 339,
 'Scaron'   , 352,
 'scaron'   , 353,
 'Yuml'     , 376,
 'circ'     , 710,
 'tilde'    , 732,
 'ensp'     , 8194,
 'emsp'     , 8195,
 'thinsp'   , 8201,
 'zwnj'     , 8204,
 'zwj'      , 8205,
 'lrm'      , 8206,
 'rlm'      , 8207,
 'ndash'    , 8211,
 'mdash'    , 8212,
 'lsquo'    , 8216,
 'rsquo'    , 8217,
 'sbquo'    , 8218,
 'ldquo'    , 8220,
 'rdquo'    , 8221,
 'bdquo'    , 8222,
 'dagger'   , 8224,
 'Dagger'   , 8225,
 'permil'   , 8240,
 'lsaquo'   , 8249,
 'rsaquo'   , 8250,
 'euro'     , 8364,
);


# Fill out %Name2character...
{
  %Name2character = ();
  my($name, $number);
  while( ($name, $number) = each %Name2character_number) {
    if($] < 5.007  and  $number > 255) {
      $Name2character{$name} = $FAR_CHAR;
      # substitute for Unicode characters, for perls
      #  that can't reliably handle them
    } elsif ($] >= 5.007003) {
      $Name2character{$name} = chr utf8::unicode_to_native($number);
      # normal case for more recent Perls where we can translate from Unicode
      # to the native character set.
    }
    elsif (exists $Code2USASCII{$number}) {
      $Name2character{$name} = $Code2USASCII{$number};
      # on older Perls, we can use the translations we have hard-coded in this
      # file, but these don't include the non-ASCII-range characters
    }
    elsif ($NOT_ASCII && $number > 127 && $number < 256) {
      # this range on old non-ASCII-platform perls is wrong
      if (exists $Latin1Code_to_fallback{$number})  {
        $Name2character{$name} = $Latin1Code_to_fallback{$number};
      } else {
        $Name2character{$name} = $FAR_CHAR;
      }
    } else {
      $Name2character{$name} = chr $number;
    }
  }
}

#--------------------------------------------------------------------------
1;
__END__

=head1 NAME

Pod::Escapes - for resolving Pod EE<lt>...E<gt> sequences

=head1 SYNOPSIS

  use Pod::Escapes qw(e2char);
  ...la la la, parsing POD, la la la...
  $text = e2char($e_node->label);
  unless(defined $text) {
    print "Unknown E sequence \"", $e_node->label, "\"!";
  }
  ...else print/interpolate $text...

=head1 DESCRIPTION

This module provides things that are useful in decoding
Pod EE<lt>...E<gt> sequences.  Presumably, it should be used
only by Pod parsers and/or formatters.

By default, Pod::Escapes exports none of its symbols.  But
you can request any of them to be exported.
Either request them individually, as with
C<use Pod::Escapes qw(symbolname symbolname2...);>,
or you can do C<use Pod::Escapes qw(:ALL);> to get all
exportable symbols.

=head1 GOODIES

=over

=item e2char($e_content)

Given a name or number that could appear in a
C<EE<lt>name_or_numE<gt>> sequence, this returns the string that
it stands for.  For example, C<e2char('sol')>, C<e2char('47')>,
C<e2char('0x2F')>, and C<e2char('057')> all return "/",
because C<EE<lt>solE<gt>>, C<EE<lt>47E<gt>>, C<EE<lt>0x2fE<gt>>,
and C<EE<lt>057E<gt>>, all mean "/".  If
the name has no known value (as with a name of "qacute") or is
syntactically invalid (as with a name of "1/4"), this returns undef.

=item e2charnum($e_content)

Given a name or number that could appear in a
C<EE<lt>name_or_numE<gt>> sequence, this returns the number of
the Unicode character that this stands for.  For example,
C<e2char('sol')>, C<e2char('47')>,
C<e2char('0x2F')>, and C<e2char('057')> all return 47,
because C<EE<lt>solE<gt>>, C<EE<lt>47E<gt>>, C<EE<lt>0x2fE<gt>>,
and C<EE<lt>057E<gt>>, all mean "/", whose Unicode number is 47.  If
the name has no known value (as with a name of "qacute") or is
syntactically invalid (as with a name of "1/4"), this returns undef.

=item $Name2character{I<name>}

Maps from names (as in C<EE<lt>I<name>E<gt>>) like "eacute" or "sol"
to the string that each stands for.  Note that this does not
include numerics (like "64" or "x981c").  Under old Perl versions
(before 5.7) you get a "?" in place of characters whose Unicode
value is over 255.

=item $Name2character_number{I<name>}

Maps from names (as in C<EE<lt>I<name>E<gt>>) like "eacute" or "sol"
to the Unicode value that each stands for.  For example,
C<$Name2character_number{'eacute'}> is 201, and
C<$Name2character_number{'eacute'}> is 8364.  You get the correct
Unicode value, regardless of the version of Perl you're using --
which differs from C<%Name2character>'s behavior under pre-5.7 Perls.

Note that this hash does not
include numerics (like "64" or "x981c").

=item $Latin1Code_to_fallback{I<integer>}

For numbers in the range 160 (0x00A0) to 255 (0x00FF), this maps
from the character code for a Latin-1 character (like 233 for
lowercase e-acute) to the US-ASCII character that best aproximates
it (like "e").  You may find this useful if you are rendering
POD in a format that you think deals well only with US-ASCII
characters.

=item $Latin1Char_to_fallback{I<character>}

Just as above, but maps from characters (like "\xE9", 
lowercase e-acute) to characters (like "e").

=item $Code2USASCII{I<integer>}

This maps from US-ASCII codes (like 32) to the corresponding
character (like space, for 32).  Only characters 32 to 126 are
defined.  This is meant for use by C<e2char($x)> when it senses
that it's running on a non-ASCII platform (where chr(32) doesn't
get you a space -- but $Code2USASCII{32} will).  It's
documented here just in case you might find it useful.

=back

=head1 CAVEATS

On Perl versions before 5.7, Unicode characters with a value
over 255 (like lambda or emdash) can't be conveyed.  This
module does work under such early Perl versions, but in the
place of each such character, you get a "?".  Latin-1
characters (characters 160-255) are unaffected.

Under EBCDIC platforms, C<e2char($n)> may not always be the
same as C<chr(e2charnum($n))>, and ditto for
C<$Name2character{$name}> and
C<chr($Name2character_number{$name})>, because the strings are returned as
native, and the numbers are returned as Unicode.
However, for Perls starting with v5.8, C<e2char($n)> is the same as
C<chr(utf8::unicode_to_native(e2charnum($n)))>, and ditto for
C<$Name2character{$name}> and
C<chr(utf8::unicode_to_native($Name2character_number{$name}))>.

=head1 SEE ALSO

L<Pod::Browser> - a pod web server based on L<Catalyst>.

L<Pod::Checker> - check pod documents for syntax errors.

L<Pod::Coverage> - check if the documentation for a module is comprehensive.

L<perlpod> - description of pod format (for people documenting with pod).

L<perlpodspec> - specification of pod format (for people processing it).

L<Text::Unidecode> - ASCII transliteration of Unicode text.

=head1 REPOSITORY

L<https://github.com/neilbowers/Pod-Escapes>

=head1 COPYRIGHT AND DISCLAIMERS

Copyright (c) 2001-2004 Sean M. Burke.  All rights reserved.

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

This program is distributed in the hope that it will be useful, but
without any warranty; without even the implied warranty of
merchantability or fitness for a particular purpose.

Portions of the data tables in this module are derived from the
entity declarations in the W3C XHTML specification.

Currently (October 2001), that's these three:

 http://www.w3.org/TR/xhtml1/DTD/xhtml-lat1.ent
 http://www.w3.org/TR/xhtml1/DTD/xhtml-special.ent
 http://www.w3.org/TR/xhtml1/DTD/xhtml-symbol.ent

=head1 AUTHOR

Sean M. Burke C<sburke@cpan.org>

Now being maintained by Neil Bowers E<lt>neilb@cpan.orgE<gt>

=cut

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# What I used for reading the XHTML .ent files:

my(@norms, @good, @bad);
my $dir = 'c:/sgml/docbook/';
my %escapes;
foreach my $file (qw(
  xhtml-symbol.ent
  xhtml-lat1.ent
  xhtml-special.ent
)) {
  open(IN, "<$dir$file") or die "can't read-open $dir$file: $!";
  print "Reading $file...\n";
  while(<IN>) {
    if(m/<!ENTITY\s+(\S+)\s+"&#([^;]+);">/) {
      my($name, $value) = ($1,$2);
      next if $name eq 'quot' or $name eq 'apos' or $name eq 'gt';
    
      $value = hex $1 if $value =~ m/^x([a-fA-F0-9]+)$/s;
      print "ILLEGAL VALUE $value" unless $value =~ m/^\d+$/s;
      if($value > 255) {
        push @good , sprintf "   %-10s , chr(%s),\n", "'$name'", $value;
        push @bad  , sprintf "   %-10s , \$bad,\n", "'$name'", $value;
      } else {
        push @norms, sprintf " %-10s , chr(%s),\n", "'$name'", $value;
      }
    } elsif(m/<!ENT/) {
      print "# Skipping $_";
    }
  
  }
  close(IN);
}

print @norms;
print "\n ( \$] .= 5.006001 ? (\n";
print @good;
print " ) : (\n";
print @bad;
print " )\n);\n";

__END__
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                # Pod::ParseLink -- Parse an L<> formatting code in POD text.
#
# Copyright 2001, 2008, 2009, 2014 by Russ Allbery <rra@cpan.org>
#
# This program is free software; you may redistribute it and/or modify it
# under the same terms as Perl itself.
#
# This module implements parsing of the text of an L<> formatting code as
# defined in perlpodspec.  It should be suitable for any POD formatter.  It
# exports only one function, parselink(), which returns the five-item parse
# defined in perlpodspec.
#
# Perl core hackers, please note that this module is also separately
# maintained outside of the Perl core as part of the podlators.  Please send
# me any patches at the address above in addition to sending them to the
# standard Perl mailing lists.

##############################################################################
# Modules and declarations
##############################################################################

package Pod::ParseLink;

use 5.006;
use strict;
use warnings;

use vars qw(@EXPORT @ISA $VERSION);

use Exporter;
@ISA    = qw(Exporter);
@EXPORT = qw(parselink);

$VERSION = '4.07';

##############################################################################
# Implementation
##############################################################################

# Parse the name and section portion of a link into a name and section.
sub _parse_section {
    my ($link) = @_;
    $link =~ s/^\s+//;
    $link =~ s/\s+$//;

    # If the whole link is enclosed in quotes, interpret it all as a section
    # even if it contains a slash.
    return (undef, $1) if ($link =~ /^"\s*(.*?)\s*"$/);

    # Split into page and section on slash, and then clean up quoting in the
    # section.  If there is no section and the name contains spaces, also
    # guess that it's an old section link.
    my ($page, $section) = split (/\s*\/\s*/, $link, 2);
    $section =~ s/^"\s*(.*?)\s*"$/$1/ if $section;
    if ($page && $page =~ / / && !defined ($section)) {
        $section = $page;
        $page = undef;
    } else {
        $page = undef unless $page;
        $section = undef unless $section;
    }
    return ($page, $section);
}

# Infer link text from the page and section.
sub _infer_text {
    my ($page, $section) = @_;
    my $inferred;
    if ($page && !$section) {
        $inferred = $page;
    } elsif (!$page && $section) {
        $inferred = '"' . $section . '"';
    } elsif ($page && $section) {
        $inferred = '"' . $section . '" in ' . $page;
    }
    return $inferred;
}

# Given the contents of an L<> formatting code, parse it into the link text,
# the possibly inferred link text, the name or URL, the section, and the type
# of link (pod, man, or url).
sub parselink {
    my ($link) = @_;
    $link =~ s/\s+/ /g;
    my $text;
    if ($link =~ /\|/) {
        ($text, $link) = split (/\|/, $link, 2);
    }
    if ($link =~ /\A\w+:[^:\s]\S*\Z/) {
        my $inferred;
        if (defined ($text) && length ($text) > 0) {
            return ($text, $text, $link, undef, 'url');
        } else {
            return ($text, $link, $link, undef, 'url');
        }
    } else {
        my ($name, $section) = _parse_section ($link);
        my $inferred;
        if (defined ($text) && length ($text) > 0) {
            $inferred = $text;
        } else {
            $inferred = _infer_text ($name, $section);
        }
        my $type = ($name && $name =~ /\(\S*\)/) ? 'man' : 'pod';
        return ($text, $inferred, $name, $section, $type);
    }
}

##############################################################################
# Module return value and documentation
##############################################################################

# Ensure we evaluate to true.
1;
__END__

=head1 NAME

Pod::ParseLink - Parse an LE<lt>E<gt> formatting code in POD text

=for stopwords
markup Allbery URL

=head1 SYNOPSIS

    use Pod::ParseLink;
    my $link = get_link();
    my ($text, $inferred, $name, $section, $type) = parselink($link);

=head1 DESCRIPTION

This module only provides a single function, parselink(), which takes the
text of an LE<lt>E<gt> formatting code and parses it.  It returns the
anchor text for the link (if any was given), the anchor text possibly
inferred from the name and section, the name or URL, the section if any,
and the type of link.  The type will be one of C<url>, C<pod>, or C<man>,
indicating a URL, a link to a POD page, or a link to a Unix manual page.

Parsing is implemented per L<perlpodspec>.  For backward compatibility,
links where there is no section and name contains spaces, or links where the
entirety of the link (except for the anchor text if given) is enclosed in
double-quotes are interpreted as links to a section (LE<lt>/sectionE<gt>).

The inferred anchor text is implemented per L<perlpodspec>:

    L<name>         =>  L<name|name>
    L</section>     =>  L<"section"|/section>
    L<name/section> =>  L<"section" in name|name/section>

The name may contain embedded EE<lt>E<gt> and ZE<lt>E<gt> formatting codes,
and the section, anchor text, and inferred anchor text may contain any
formatting codes.  Any double quotes around the section are removed as part
of the parsing, as is any leading or trailing whitespace.

If the text of the LE<lt>E<gt> escape is entirely enclosed in double
quotes, it's interpreted as a link to a section for backward
compatibility.

No attempt is made to resolve formatting codes.  This must be done after
calling parselink() (since EE<lt>E<gt> formatting codes can be used to
escape characters that would otherwise be significant to the parser and
resolving them before parsing would result in an incorrect parse of a
formatting code like:

    L<verticalE<verbar>barE<sol>slash>

which should be interpreted as a link to the C<vertical|bar/slash> POD page
and not as a link to the C<slash> section of the C<bar> POD page with an
anchor text of C<vertical>.  Note that not only the anchor text will need to
have formatting codes expanded, but so will the target of the link (to deal
with EE<lt>E<gt> and ZE<lt>E<gt> formatting codes), and special handling of
the section may be necessary depending on whether the translator wants to
consider markup in sections to be significant when resolving links.  See
L<perlpodspec> for more information.

=head1 SEE ALSO

L<Pod::Parser>

The current version of this module is always available from its web site at
L<http://www.eyrie.org/~eagle/software/podlators/>.

=head1 AUTHOR

Russ Allbery <rra@cpan.org>.

=head1 COPYRIGHT AND LICENSE

Copyright 2001, 2008, 2009 Russ Allbery <rra@cpan.org>.

This program is free software; you may redistribute it and/or modify it
under the same terms as Perl itself.

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     #############################################################################  
# Pod/Find.pm -- finds files containing POD documentation
#
# Author: Marek Rouchal <marekr@cpan.org>
# 
# Copyright (C) 1999-2000 by Marek Rouchal (and borrowing code
# from Nick Ing-Simmon's PodToHtml). All rights reserved.
# This file is part of "PodParser". Pod::Find is free software;
# you can redistribute it and/or modify it under the same terms
# as Perl itself.
#############################################################################

package Pod::Find;
use strict;

use vars qw($VERSION);
$VERSION = '1.63';   ## Current version of this package
require  5.005;   ## requires this Perl version or later
use Carp;

BEGIN {
   if ($] < 5.006) {
      require Symbol;
      import Symbol;
   }
}

#############################################################################

=head1 NAME

Pod::Find - find POD documents in directory trees

=head1 SYNOPSIS

  use Pod::Find qw(pod_find simplify_name);
  my %pods = pod_find({ -verbose => 1, -inc => 1 });
  foreach(keys %pods) {
     print "found library POD `$pods{$_}' in $_\n";
  }

  print "podname=",simplify_name('a/b/c/mymodule.pod'),"\n";

  $location = pod_where( { -inc => 1 }, "Pod::Find" );

=head1 DESCRIPTION

B<NOTE: This module is considered legacy; modern Perl releases (5.18 and
higher) are going to remove Pod-Parser from core and use L<Pod-Simple>
for all things POD.>

B<Pod::Find> provides a set of functions to locate POD files.  Note that
no function is exported by default to avoid pollution of your namespace,
so be sure to specify them in the B<use> statement if you need them:

  use Pod::Find qw(pod_find);

From this version on the typical SCM (software configuration management)
directories are ignored. These are: RCS, CVS, SCCS, .svn, .hg, .git, .sync

=cut

#use diagnostics;
use Exporter;
use File::Spec;
use File::Find;
use Cwd qw(abs_path cwd);

use vars qw(@ISA @EXPORT_OK $VERSION);
@ISA = qw(Exporter);
@EXPORT_OK = qw(&pod_find &simplify_name &pod_where &contains_pod);

# package global variables
my $SIMPLIFY_RX;

=head2 C<pod_find( { %opts } , @directories )>

The function B<pod_find> searches for POD documents in a given set of
files and/or directories. It returns a hash with the file names as keys
and the POD name as value. The POD name is derived from the file name
and its position in the directory tree.

E.g. when searching in F<$HOME/perl5lib>, the file
F<$HOME/perl5lib/MyModule.pm> would get the POD name I<MyModule>,
whereas F<$HOME/perl5lib/Myclass/Subclass.pm> would be
I<Myclass::Subclass>. The name information can be used for POD
translators.

Only text files containing at least one valid POD command are found.

A warning is printed if more than one POD file with the same POD name
is found, e.g. F<CPAN.pm> in different directories. This usually
indicates duplicate occurrences of modules in the I<@INC> search path.

B<OPTIONS> The first argument for B<pod_find> may be a hash reference
with options. The rest are either directories that are searched
recursively or files.  The POD names of files are the plain basenames
with any Perl-like extension (.pm, .pl, .pod) stripped.

=over 4

=item C<-verbose =E<gt> 1>

Print progress information while scanning.

=item C<-perl =E<gt> 1>

Apply Perl-specific heuristics to find the correct PODs. This includes
stripping Perl-like extensions, omitting subdirectories that are numeric
but do I<not> match the current Perl interpreter's version id, suppressing
F<site_perl> as a module hierarchy name etc.

=item C<-script =E<gt> 1>

Search for PODs in the current Perl interpreter's installation 
B<scriptdir>. This is taken from the local L<Config|Config> module.

=item C<-inc =E<gt> 1>

Search for PODs in the current Perl interpreter's I<@INC> paths. This
automatically considers paths specified in the C<PERL5LIB> environment
as this is included in I<@INC> by the Perl interpreter itself.

=back

=cut

# return a hash of the POD files found
# first argument may be a hashref (options),
# rest is a list of directories to search recursively
sub pod_find
{
    my %opts;
    if(ref $_[0]) {
        %opts = %{shift()};
    }

    $opts{-verbose} ||= 0;
    $opts{-perl}    ||= 0;

    my (@search) = @_;

    if($opts{-script}) {
        require Config;
        push(@search, $Config::Config{scriptdir})
            if -d $Config::Config{scriptdir};
        $opts{-perl} = 1;
    }

    if($opts{-inc}) {
        if ($^O eq 'MacOS') {
            # tolerate '.', './some_dir' and '(../)+some_dir' on Mac OS
            my @new_INC = @INC;
            for (@new_INC) {
                if ( $_ eq '.' ) {
                    $_ = ':';
                } elsif ( $_ =~ s{^((?:\.\./)+)}{':' x (length($1)/3)}e ) {
                    $_ = ':'. $_;
                } else {
                    $_ =~ s{^\./}{:};
                }
            }
            push(@search, grep($_ ne File::Spec->curdir, @new_INC));
        } else {
            my %seen;
            my $curdir = File::Spec->curdir;
	    foreach(@INC) {
                next if $_ eq $curdir;
		my $path = abs_path($_);
                push(@search, $path) unless $seen{$path}++;
            }
        }

        $opts{-perl} = 1;
    }

    if($opts{-perl}) {
        require Config;
        # this code simplifies the POD name for Perl modules:
        # * remove "site_perl"
        # * remove e.g. "i586-linux" (from 'archname')
        # * remove e.g. 5.00503
        # * remove pod/ if followed by *.pod (e.g. in pod/perlfunc.pod)

        # Mac OS:
        # * remove ":?site_perl:"
        # * remove :?pod: if followed by *.pod (e.g. in :pod:perlfunc.pod)

        if ($^O eq 'MacOS') {
            $SIMPLIFY_RX =
              qq!^(?i:\:?site_perl\:|\:?pod\:(?=.*?\\.pod\\z))*!;
        } else {
            $SIMPLIFY_RX =
              qq!^(?i:site(_perl)?/|\Q$Config::Config{archname}\E/|\\d+\\.\\d+([_.]?\\d+)?/|pod/(?=.*?\\.pod\\z))*!;
        }
    }

    my %dirs_visited;
    my %pods;
    my %names;
    my $pwd = cwd();

    foreach my $try (@search) {
        unless(File::Spec->file_name_is_absolute($try)) {
            # make path absolute
            $try = File::Spec->catfile($pwd,$try);
        }
        # simplify path
        # on VMS canonpath will vmsify:[the.path], but File::Find::find
        # wants /unixy/paths
        if ($^O eq 'VMS') {
            $try = VMS::Filespec::unixify($try);
        }
        else {
            $try = File::Spec->canonpath($try);
        }
        my $name;
        if(-f $try) {
            if($name = _check_and_extract_name($try, $opts{-verbose})) {
                _check_for_duplicates($try, $name, \%names, \%pods);
            }
            next;
        }
        my $root_rx = $^O eq 'MacOS' ? qq!^\Q$try\E! : qq!^\Q$try\E/!;
        $root_rx=~ s|//$|/|;  # remove trailing double slash
        File::Find::find( sub {
            my $item = $File::Find::name;
            if(-d) {
                if($item =~ m{/(?:RCS|CVS|SCCS|\.svn|\.hg|\.git|\.sync)$}) {
                    $File::Find::prune = 1;
                    return;
                }
                elsif($dirs_visited{$item}) {
                    warn "Directory '$item' already seen, skipping.\n"
                        if($opts{-verbose});
                    $File::Find::prune = 1;
                    return;
                }
                else {
                    $dirs_visited{$item} = 1;
                }
                if($opts{-perl} && /^(\d+\.[\d_]+)\z/s && eval "$1" != $]) {
                    $File::Find::prune = 1;
                    warn "Perl $] version mismatch on $_, skipping.\n"
                        if($opts{-verbose});
                }
                return;
            }
            if($name = _check_and_extract_name($item, $opts{-verbose}, $root_rx)) {
                _check_for_duplicates($item, $name, \%names, \%pods);
            }
        }, $try); # end of File::Find::find
    }
    chdir $pwd;
    return %pods;
}

sub _check_for_duplicates {
    my ($file, $name, $names_ref, $pods_ref) = @_;
    if($$names_ref{$name}) {
        warn "Duplicate POD found (shadowing?): $name ($file)\n";
        warn '    Already seen in ',
            join(' ', grep($$pods_ref{$_} eq $name, keys %$pods_ref)),"\n";
    }
    else {
        $$names_ref{$name} = 1;
    }
    return $$pods_ref{$file} = $name;
}

sub _check_and_extract_name {
    my ($file, $verbose, $root_rx) = @_;

    # check extension or executable flag
    # this involves testing the .bat extension on Win32!
    unless(-f $file && -T $file && ($file =~ /\.(pod|pm|plx?)\z/i || -x $file )) {
      return;
    }

    return unless contains_pod($file,$verbose);

    # strip non-significant path components
    # TODO what happens on e.g. Win32?
    my $name = $file;
    if(defined $root_rx) {
        $name =~ s/$root_rx//is;
        $name =~ s/$SIMPLIFY_RX//is if(defined $SIMPLIFY_RX);
    }
    else {
        if ($^O eq 'MacOS') {
            $name =~ s/^.*://s;
        } else {
            $name =~ s{^.*/}{}s;
        }
    }
    _simplify($name);
    $name =~ s{/+}{::}g;
    if ($^O eq 'MacOS') {
        $name =~ s{:+}{::}g; # : -> ::
    } else {
        $name =~ s{/+}{::}g; # / -> ::
    }
    return $name;
}

=head2 C<simplify_name( $str )>

The function B<simplify_name> is equivalent to B<basename>, but also
strips Perl-like extensions (.pm, .pl, .pod) and extensions like
F<.bat>, F<.cmd> on Win32 and OS/2, or F<.com> on VMS, respectively.

=cut

# basic simplification of the POD name:
# basename & strip extension
sub simplify_name {
    my ($str) = @_;
    # remove all path components
    if ($^O eq 'MacOS') {
        $str =~ s/^.*://s;
    } else {
        $str =~ s{^.*/}{}s;
    }
    _simplify($str);
    return $str;
}

# internal sub only
sub _simplify {
    # strip Perl's own extensions
    $_[0] =~ s/\.(pod|pm|plx?)\z//i;
    # strip meaningless extensions on Win32 and OS/2
    $_[0] =~ s/\.(bat|exe|cmd)\z//i if($^O =~ /mswin|os2/i);
    # strip meaningless extensions on VMS
    $_[0] =~ s/\.(com)\z//i if($^O eq 'VMS');
}

# contribution from Tim Jenness <t.jenness@jach.hawaii.edu>

=head2 C<pod_where( { %opts }, $pod )>

Returns the location of a pod document given a search directory
and a module (e.g. C<File::Find>) or script (e.g. C<perldoc>) name.

Options:

=over 4

=item C<-inc =E<gt> 1>

Search @INC for the pod and also the C<scriptdir> defined in the
L<Config|Config> module.

=item C<-dirs =E<gt> [ $dir1, $dir2, ... ]>

Reference to an array of search directories. These are searched in order
before looking in C<@INC> (if B<-inc>). Current directory is used if
none are specified.

=item C<-verbose =E<gt> 1>

List directories as they are searched

=back

Returns the full path of the first occurrence to the file.
Package names (eg 'A::B') are automatically converted to directory
names in the selected directory. (eg on unix 'A::B' is converted to
'A/B'). Additionally, '.pm', '.pl' and '.pod' are appended to the
search automatically if required.

A subdirectory F<pod/> is also checked if it exists in any of the given
search directories. This ensures that e.g. L<perlfunc|perlfunc> is
found.

It is assumed that if a module name is supplied, that that name
matches the file name. Pods are not opened to check for the 'NAME'
entry.

A check is made to make sure that the file that is found does 
contain some pod documentation.

=cut

sub pod_where {

  # default options
  my %options = (
         '-inc' => 0,
         '-verbose' => 0,
         '-dirs' => [ File::Spec->curdir ],
        );

  # Check for an options hash as first argument
  if (defined $_[0] && ref($_[0]) eq 'HASH') {
    my $opt = shift;

    # Merge default options with supplied options
    %options = (%options, %$opt);
  }

  # Check usage
  carp 'Usage: pod_where({options}, $pod)' unless (scalar(@_));

  # Read argument
  my $pod = shift;

  # Split on :: and then join the name together using File::Spec
  my @parts = split (/::/, $pod);

  # Get full directory list
  my @search_dirs = @{ $options{'-dirs'} };

  if ($options{'-inc'}) {

    require Config;

    # Add @INC
    if ($^O eq 'MacOS' && $options{'-inc'}) {
        # tolerate '.', './some_dir' and '(../)+some_dir' on Mac OS
        my @new_INC = @INC;
        for (@new_INC) {
            if ( $_ eq '.' ) {
                $_ = ':';
            } elsif ( $_ =~ s{^((?:\.\./)+)}{':' x (length($1)/3)}e ) {
                $_ = ':'. $_;
            } else {
                $_ =~ s{^\./}{:};
            }
        }
        push (@search_dirs, @new_INC);
    } elsif ($options{'-inc'}) {
        push (@search_dirs, @INC);
    }

    # Add location of pod documentation for perl man pages (eg perlfunc)
    # This is a pod directory in the private install tree
    #my $perlpoddir = File::Spec->catdir($Config::Config{'installprivlib'},
    #					'pod');
    #push (@search_dirs, $perlpoddir)
    #  if -d $perlpoddir;

    # Add location of binaries such as pod2text
    push (@search_dirs, $Config::Config{'scriptdir'})
      if -d $Config::Config{'scriptdir'};
  }

  warn 'Search path is: '.join(' ', @search_dirs)."\n"
        if $options{'-verbose'};

  # Loop over directories
  Dir: foreach my $dir ( @search_dirs ) {

    # Don't bother if can't find the directory
    if (-d $dir) {
      warn "Looking in directory $dir\n"
        if $options{'-verbose'};

      # Now concatenate this directory with the pod we are searching for
      my $fullname = File::Spec->catfile($dir, @parts);
      $fullname = VMS::Filespec::unixify($fullname) if $^O eq 'VMS';
      warn "Filename is now $fullname\n"
        if $options{'-verbose'};

      # Loop over possible extensions
      foreach my $ext ('', '.pod', '.pm', '.pl') {
        my $fullext = $fullname . $ext;
        if (-f $fullext &&
         contains_pod($fullext, $options{'-verbose'}) ) {
          warn "FOUND: $fullext\n" if $options{'-verbose'};
          return $fullext;
        }
      }
    } else {
      warn "Directory $dir does not exist\n"
        if $options{'-verbose'};
      next Dir;
    }
    # for some strange reason the path on MacOS/darwin/cygwin is
    # 'pods' not 'pod'
    # this could be the case also for other systems that
    # have a case-tolerant file system, but File::Spec
    # does not recognize 'darwin' yet. And cygwin also has "pods",
    # but is not case tolerant. Oh well...
    if((File::Spec->case_tolerant || $^O =~ /macos|darwin|cygwin/i)
     && -d File::Spec->catdir($dir,'pods')) {
      $dir = File::Spec->catdir($dir,'pods');
      redo Dir;
    }
    if(-d File::Spec->catdir($dir,'pod')) {
      $dir = File::Spec->catdir($dir,'pod');
      redo Dir;
    }
  }
  # No match;
  return;
}

=head2 C<contains_pod( $file , $verbose )>

Returns true if the supplied filename (not POD module) contains some pod
information.

=cut

sub contains_pod {
  my $file = shift;
  my $verbose = 0;
  $verbose = shift if @_;

  # check for one line of POD
  my $podfh;
  if ($] < 5.006) {
    $podfh = gensym();
  }

  unless(open($podfh,"<$file")) {
    warn "Error: $file is unreadable: $!\n";
    return;
  }
  
  local $/ = undef;
  my $pod = <$podfh>;
  close($podfh) || die "Error closing $file: $!\n";
  unless($pod =~ /^=(head\d|pod|over|item|cut)\b/m) {
    warn "No POD in $file, skipping.\n"
      if($verbose);
    return 0;
  }

  return 1;
}

=head1 AUTHOR

Please report bugs using L<http://rt.cpan.org>.

Marek Rouchal E<lt>marekr@cpan.orgE<gt>,
heavily borrowing code from Nick Ing-Simmons' PodToHtml.

Tim Jenness E<lt>t.jenness@jach.hawaii.eduE<gt> provided
C<pod_where> and C<contains_pod>.

B<Pod::Find> is part of the L<Pod::Parser> distribution.

=head1 SEE ALSO

L<Pod::Parser>, L<Pod::Checker>, L<perldoc>

=cut

1;

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  package Pod::Functions;
use strict;

=head1 NAME

Pod::Functions - Group Perl's functions a la perlfunc.pod

=head1 SYNOPSIS

    use Pod::Functions;
    
    my @misc_ops = @{ $Kinds{ 'Misc' } };
    my $misc_dsc = $Type_Description{ 'Misc' };

or

    perl /path/to/lib/Pod/Functions.pm

This will print a grouped list of Perl's functions, like the 
L<perlfunc/"Perl Functions by Category"> section.

=head1 DESCRIPTION

It exports the following variables:

=over 4

=item %Kinds

This holds a hash-of-lists. Each list contains the functions in the category
the key denotes.

=item %Type

In this hash each key represents a function and the value is the category.
The category can be a comma separated list.

=item %Flavor

In this hash each key represents a function and the value is a short 
description of that function.

=item %Type_Description

In this hash each key represents a category of functions and the value is 
a short description of that category.

=item @Type_Order

This list of categories is used to produce the same order as the
L<perlfunc/"Perl Functions by Category"> section.

=back

=cut

our $VERSION = '1.10';

require Exporter;

our @ISA = qw(Exporter);
our @EXPORT = qw(%Kinds %Type %Flavor %Type_Description @Type_Order);

our(%Kinds, %Type, %Flavor, %Type_Description, @Type_Order);

foreach (
    [String     => 'Functions for SCALARs or strings'],
    [Regexp     => 'Regular expressions and pattern matching'],
    [Math       => 'Numeric functions'],
    [ARRAY      => 'Functions for real @ARRAYs'],
    [LIST       => 'Functions for list data'],
    [HASH       => 'Functions for real %HASHes'],
    ['I/O'      => 'Input and output functions'],
    [Binary     => 'Functions for fixed-length data or records'],
    [File       => 'Functions for filehandles, files, or directories'],
    [Flow       => 'Keywords related to the control flow of your Perl program'],
    [Namespace  => 'Keywords related to scoping'],
    [Misc       => 'Miscellaneous functions'],
    [Process    => 'Functions for processes and process groups'],
    [Modules    => 'Keywords related to Perl modules'],
    [Objects    => 'Keywords related to classes and object-orientation'],
    [Socket     => 'Low-level socket functions'],
    [SysV       => 'System V interprocess communication functions'],
    [User       => 'Fetching user and group info'],
    [Network    => 'Fetching network info'],
    [Time       => 'Time-related functions'],
	) {
    push @Type_Order, $_->[0];
    $Type_Description{$_->[0]} = $_->[1];
};

while (<DATA>) {
    chomp;
    s/^#.*//;
    next unless $_;
    my($name, @data) = split "\t", $_;
    $Flavor{$name} = pop @data;
    $Type{$name} = join ',', @data;
    for my $t (@data) {
        push @{$Kinds{$t}}, $name;
    }
}

close DATA;

my( $typedesc, $list );
unless (caller) { 
    foreach my $type ( @Type_Order ) {
	$list = join(", ", sort @{$Kinds{$type}});
	$typedesc = $Type_Description{$type} . ":";
	write;
    } 
}

format = 

^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    $typedesc 
~~ ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    $typedesc 
 ~~  ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
	$list
.

1;

__DATA__
-X	File	a file test (-r, -x, etc)
abs	Math	absolute value function
accept	Socket	accept an incoming socket connect
alarm	Process	schedule a SIGALRM
atan2	Math	arctangent of Y/X in the range -PI to PI
bind	Socket	binds an address to a socket
binmode	I/O	prepare binary files for I/O
bless	Objects	create an object
break	Flow	break out of a C<given> block
caller	Flow	Namespace	get context of the current subroutine call
chdir	File	change your current working directory
chmod	File	changes the permissions on a list of files
chomp	String	remove a trailing record separator from a string
chop	String	remove the last character from a string
chown	File	change the ownership on a list of files
chr	String	get character this number represents
chroot	File	make directory new root for path lookups
close	I/O	close file (or pipe or socket) handle
closedir	I/O	close directory handle
connect	Socket	connect to a remote socket
continue	Flow	optional trailing block in a while or foreach
cos	Math	cosine function
crypt	String	one-way passwd-style encryption
dbmclose	I/O	Objects	breaks binding on a tied dbm file
dbmopen	I/O	Objects	create binding on a tied dbm file
defined	Misc	test whether a value, variable, or function is defined
delete	HASH	deletes a value from a hash
die	Flow	I/O	raise an exception or bail out
do	Flow	Modules	turn a BLOCK into a TERM
dump	Flow	create an immediate core dump
each	ARRAY	HASH	retrieve the next key/value pair from a hash
endgrent	User	be done using group file
endhostent	User	be done using hosts file
endnetent	User	be done using networks file
endprotoent	Network	be done using protocols file
endpwent	User	be done using passwd file
endservent	Network	be done using services file
eof	I/O	test a filehandle for its end
eval	Flow	catch exceptions or compile and run code
evalbytes	Flow	similar to string eval, but intend to parse a bytestream
exec	Process	abandon this program to run another
exists	HASH	test whether a hash key is present
exit	Flow	terminate this program
exp	Math	raise I<e> to a power
fc	String	return casefolded version of a string
fcntl	File	file control system call
__FILE__	Flow	the name of the current source file
fileno	I/O	return file descriptor from filehandle
flock	I/O	lock an entire file with an advisory lock
fork	Process	create a new process just like this one
format	I/O	declare a picture format with use by the write() function
formline	Misc	internal function used for formats
getc	I/O	get the next character from the filehandle
getgrent	User	get next group record
getgrgid	User	get group record given group user ID
getgrnam	User	get group record given group name
gethostbyaddr	Network	get host record given its address
gethostbyname	Network	get host record given name
gethostent	Network	get next hosts record
getlogin	User	return who logged in at this tty
getnetbyaddr	Network	get network record given its address
getnetbyname	Network	get networks record given name
getnetent	Network	get next networks record
getpeername	Socket	find the other end of a socket connection
getpgrp	Process	get process group
getppid	Process	get parent process ID
getpriority	Process	get current nice value
getprotobyname	Network	get protocol record given name
getprotobynumber	Network	get protocol record numeric protocol
getprotoent	Network	get next protocols record
getpwent	User	get next passwd record
getpwnam	User	get passwd record given user login name
getpwuid	User	get passwd record given user ID
getservbyname	Network	get services record given its name
getservbyport	Network	get services record given numeric port
getservent	Network	get next services record
getsockname	Socket	retrieve the sockaddr for a given socket
getsockopt	Socket	get socket options on a given socket
glob	File	expand filenames using wildcards
gmtime	Time	convert UNIX time into record or string using Greenwich time
goto	Flow	create spaghetti code
grep	LIST	locate elements in a list test true against a given criterion
hex	Math	String	convert a hexadecimal string to a number
import	Modules	Namespace	patch a module's namespace into your own
index	String	find a substring within a string
int	Math	get the integer portion of a number
ioctl	File	system-dependent device control system call
join	LIST	join a list into a string using a separator
keys	ARRAY	HASH	retrieve list of indices from a hash
kill	Process	send a signal to a process or process group
last	Flow	exit a block prematurely
lc	String	return lower-case version of a string
lcfirst	String	return a string with just the next letter in lower case
length	String	return the number of characters in a string
__LINE__	Flow	the current source line number
link	File	create a hard link in the filesystem
listen	Socket	register your socket as a server
local	Namespace	create a temporary value for a global variable (dynamic scoping)
localtime	Time	convert UNIX time into record or string using local time
lock	Misc	get a thread lock on a variable, subroutine, or method
log	Math	retrieve the natural logarithm for a number
lstat	File	stat a symbolic link
m//	Regexp	match a string with a regular expression pattern
map	LIST	apply a change to a list to get back a new list with the changes
mkdir	File	create a directory
msgctl	SysV	SysV IPC message control operations
msgget	SysV	get SysV IPC message queue
msgrcv	SysV	receive a SysV IPC message from a message queue
msgsnd	SysV	send a SysV IPC message to a message queue
my	Namespace	declare and assign a local variable (lexical scoping)
next	Flow	iterate a block prematurely
no	Modules	unimport some module symbols or semantics at compile time
oct	Math	String	convert a string to an octal number
open	File	open a file, pipe, or descriptor
opendir	File	open a directory
ord	String	find a character's numeric representation
our	Namespace	declare and assign a package variable (lexical scoping)
pack	Binary	String	convert a list into a binary representation
package	Modules	Namespace	Objects	declare a separate global namespace
__PACKAGE__	Flow	the current package
pipe	Process	open a pair of connected filehandles
pop	ARRAY	remove the last element from an array and return it
pos	Regexp	find or set the offset for the last/next m//g search
print	I/O	output a list to a filehandle
printf	I/O	output a formatted list to a filehandle
prototype	Misc	get the prototype (if any) of a subroutine
push	ARRAY	append one or more elements to an array
q/STRING/	String	singly quote a string
qq/STRING/	String	doubly quote a string
qr/STRING/	Regexp	compile pattern
quotemeta	Regexp	quote regular expression magic characters
qw/STRING/	LIST	quote a list of words
qx/STRING/	Process	backquote quote a string
rand	Math	retrieve the next pseudorandom number
read	Binary	I/O	fixed-length buffered input from a filehandle
readdir	I/O	get a directory from a directory handle
readline	I/O	fetch a record from a file
readlink	File	determine where a symbolic link is pointing
readpipe	Process	execute a system command and collect standard output
recv	Socket	receive a message over a Socket
redo	Flow	start this loop iteration over again
ref	Objects	find out the type of thing being referenced
rename	File	change a filename
require	Modules	load in external functions from a library at runtime
reset	Misc	clear all variables of a given name
return	Flow	get out of a function early
reverse	LIST	String	flip a string or a list
rewinddir	I/O	reset directory handle
rindex	String	right-to-left substring search
rmdir	File	remove a directory
s///	Regexp	replace a pattern with a string
say	I/O	output a list to a filehandle, appending a newline
scalar	Misc	force a scalar context
seek	I/O	reposition file pointer for random-access I/O
seekdir	I/O	reposition directory pointer
select	File	I/O	reset default output or do I/O multiplexing
semctl	SysV	SysV semaphore control operations
semget	SysV	get set of SysV semaphores
semop	SysV	SysV semaphore operations
send	Socket	send a message over a socket
setgrent	User	prepare group file for use
sethostent	Network	prepare hosts file for use
setnetent	Network	prepare networks file for use
setpgrp	Process	set the process group of a process
setpriority	Process	set a process's nice value
setprotoent	Network	prepare protocols file for use
setpwent	User	prepare passwd file for use
setservent	Network	prepare services file for use
setsockopt	Socket	set some socket options
shift	ARRAY	remove the first element of an array, and return it
shmctl	SysV	SysV shared memory operations
shmget	SysV	get SysV shared memory segment identifier
shmread	SysV	read SysV shared memory
shmwrite	SysV	write SysV shared memory
shutdown	Socket	close down just half of a socket connection
sin	Math	return the sine of a number
sleep	Process	block for some number of seconds
socket	Socket	create a socket
socketpair	Socket	create a pair of sockets
sort	LIST	sort a list of values
splice	ARRAY	add or remove elements anywhere in an array
split	Regexp	split up a string using a regexp delimiter
sprintf	String	formatted print into a string
sqrt	Math	square root function
srand	Math	seed the random number generator
stat	File	get a file's status information
state	Namespace	declare and assign a persistent lexical variable
study	Regexp	optimize input data for repeated searches
sub	Flow	declare a subroutine, possibly anonymously
__SUB__	Flow	the current subroutine, or C<undef> if not in a subroutine
substr	String	get or alter a portion of a string
symlink	File	create a symbolic link to a file
syscall	Binary	I/O	execute an arbitrary system call
sysopen	File	open a file, pipe, or descriptor
sysread	Binary	I/O	fixed-length unbuffered input from a filehandle
sysseek	Binary	I/O	position I/O pointer on handle used with sysread and syswrite
system	Process	run a separate program
syswrite	Binary	I/O	fixed-length unbuffered output to a filehandle
tell	I/O	get current seekpointer on a filehandle
telldir	I/O	get current seekpointer on a directory handle
tie	Objects	bind a variable to an object class
tied	Objects	get a reference to the object underlying a tied variable
time	Time	return number of seconds since 1970
times	Process	Time	return elapsed time for self and child processes
tr///	String	transliterate a string
truncate	I/O	shorten a file
uc	String	return upper-case version of a string
ucfirst	String	return a string with just the next letter in upper case
umask	File	set file creation mode mask
undef	Misc	remove a variable or function definition
unlink	File	remove one link to a file
unpack	Binary	LIST	convert binary structure into normal perl variables
unshift	ARRAY	prepend more elements to the beginning of a list
untie	Objects	break a tie binding to a variable
use	Modules	Namespace	Objects	load in a module at compile time and import its namespace
utime	File	set a file's last access and modify times
values	ARRAY	HASH	return a list of the values in a hash
vec	Binary	test or set particular bits in a string
wait	Process	wait for any child process to die
waitpid	Process	wait for a particular child process to die
wantarray	Flow	get void vs scalar vs list context of current subroutine call
warn	I/O	print debugging info
write	I/O	print a picture record
y///	String	transliterate a string
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               package Pod::Html;
use strict;
require Exporter;

use vars qw($VERSION @ISA @EXPORT @EXPORT_OK);
$VERSION = 1.2201;
@ISA = qw(Exporter);
@EXPORT = qw(pod2html htmlify);
@EXPORT_OK = qw(anchorify);

use Carp;
use Config;
use Cwd;
use File::Basename;
use File::Spec;
use File::Spec::Unix;
use Getopt::Long;
use Pod::Simple::Search;
use locale; # make \w work right in non-ASCII lands

=head1 NAME

Pod::Html - module to convert pod files to HTML

=head1 SYNOPSIS

    use Pod::Html;
    pod2html([options]);

=head1 DESCRIPTION

Converts files from pod format (see L<perlpod>) to HTML format.  It
can automatically generate indexes and cross-references, and it keeps
a cache of things it knows how to cross-reference.

=head1 FUNCTIONS

=head2 pod2html

    pod2html("pod2html",
             "--podpath=lib:ext:pod:vms",
             "--podroot=/usr/src/perl",
             "--htmlroot=/perl/nmanual",
             "--recurse",
             "--infile=foo.pod",
             "--outfile=/perl/nmanual/foo.html");

pod2html takes the following arguments:

=over 4

=item backlink

    --backlink

Turns every C<head1> heading into a link back to the top of the page.
By default, no backlinks are generated.

=item cachedir

    --cachedir=name

Creates the directory cache in the given directory.

=item css

    --css=stylesheet

Specify the URL of a cascading style sheet.  Also disables all HTML/CSS
C<style> attributes that are output by default (to avoid conflicts).

=item flush

    --flush

Flushes the directory cache.

=item header

    --header
    --noheader

Creates header and footer blocks containing the text of the C<NAME>
section.  By default, no headers are generated.

=item help

    --help

Displays the usage message.

=item htmldir

    --htmldir=name

Sets the directory to which all cross references in the resulting
html file will be relative. Not passing this causes all links to be
absolute since this is the value that tells Pod::Html the root of the 
documentation tree.

Do not use this and --htmlroot in the same call to pod2html; they are
mutually exclusive.

=item htmlroot

    --htmlroot=name

Sets the base URL for the HTML files.  When cross-references are made,
the HTML root is prepended to the URL.

Do not use this if relative links are desired: use --htmldir instead.

Do not pass both this and --htmldir to pod2html; they are mutually
exclusive.

=item index

    --index
    --noindex

Generate an index at the top of the HTML file.  This is the default
behaviour.

=item infile

    --infile=name

Specify the pod file to convert.  Input is taken from STDIN if no
infile is specified.

=item outfile

    --outfile=name

Specify the HTML file to create.  Output goes to STDOUT if no outfile
is specified.

=item poderrors

    --poderrors
    --nopoderrors

Include a "POD ERRORS" section in the outfile if there were any POD 
errors in the infile. This section is included by default.

=item podpath

    --podpath=name:...:name

Specify which subdirectories of the podroot contain pod files whose
HTML converted forms can be linked to in cross references.

=item podroot

    --podroot=name

Specify the base directory for finding library pods. Default is the
current working directory.

=item quiet

    --quiet
    --noquiet

Don't display I<mostly harmless> warning messages.  These messages
will be displayed by default.  But this is not the same as C<verbose>
mode.

=item recurse

    --recurse
    --norecurse

Recurse into subdirectories specified in podpath (default behaviour).

=item title

    --title=title

Specify the title of the resulting HTML file.

=item verbose

    --verbose
    --noverbose

Display progress messages.  By default, they won't be displayed.

=back

=head2 htmlify

    htmlify($heading);

Converts a pod section specification to a suitable section specification
for HTML. Note that we keep spaces and special characters except
C<", ?> (Netscape problem) and the hyphen (writer's problem...).

=head2 anchorify

    anchorify(@heading);

Similar to C<htmlify()>, but turns non-alphanumerics into underscores.  Note
that C<anchorify()> is not exported by default.

=head1 ENVIRONMENT

Uses C<$Config{pod2html}> to setup default options.

=head1 AUTHOR

Marc Green, E<lt>marcgreen@cpan.orgE<gt>. 

Original version by Tom Christiansen, E<lt>tchrist@perl.comE<gt>.

=head1 SEE ALSO

L<perlpod>

=head1 COPYRIGHT

This program is distributed under the Artistic License.

=cut

my $Cachedir; 
my $Dircache;
my($Htmlroot, $Htmldir, $Htmlfile, $Htmlfileurl);
my($Podfile, @Podpath, $Podroot);
my $Poderrors;
my $Css;

my $Recurse;
my $Quiet;
my $Verbose;
my $Doindex;

my $Backlink;

my($Title, $Header);

my %Pages = ();                 # associative array used to find the location
                                #   of pages referenced by L<> links.

my $Curdir = File::Spec->curdir;

init_globals();

sub init_globals {
    $Cachedir = ".";            # The directory to which directory caches
                                #   will be written.

    $Dircache = "pod2htmd.tmp";

    $Htmlroot = "/";            # http-server base directory from which all
                                #   relative paths in $podpath stem.
    $Htmldir = "";              # The directory to which the html pages
                                #   will (eventually) be written.
    $Htmlfile = "";             # write to stdout by default
    $Htmlfileurl = "";          # The url that other files would use to
                                # refer to this file.  This is only used
                                # to make relative urls that point to
                                # other files.

    $Poderrors = 1;
    $Podfile = "";              # read from stdin by default
    @Podpath = ();              # list of directories containing library pods.
    $Podroot = $Curdir;         # filesystem base directory from which all
                                #   relative paths in $podpath stem.
    $Css = '';                  # Cascading style sheet
    $Recurse = 1;               # recurse on subdirectories in $podpath.
    $Quiet = 0;                 # not quiet by default
    $Verbose = 0;               # not verbose by default
    $Doindex = 1;               # non-zero if we should generate an index
    $Backlink = 0;              # no backlinks added by default
    $Header = 0;                # produce block header/footer
    $Title = '';                # title to give the pod(s)
}

sub pod2html {
    local(@ARGV) = @_;
    local $_;

    init_globals();
    parse_command_line();

    # prevent '//' in urls
    $Htmlroot = "" if $Htmlroot eq "/";
    $Htmldir =~ s#/\z##;

    if (  $Htmlroot eq ''
       && defined( $Htmldir )
       && $Htmldir ne ''
       && substr( $Htmlfile, 0, length( $Htmldir ) ) eq $Htmldir
       ) {
        # Set the 'base' url for this file, so that we can use it
        # as the location from which to calculate relative links
        # to other files. If this is '', then absolute links will
        # be used throughout.
        #$Htmlfileurl = "$Htmldir/" . substr( $Htmlfile, length( $Htmldir ) + 1);
        # Is the above not just "$Htmlfileurl = $Htmlfile"?
        $Htmlfileurl = Pod::Html::_unixify($Htmlfile);

    }

    # load or generate/cache %Pages
    unless (get_cache($Dircache, \@Podpath, $Podroot, $Recurse)) {
        # generate %Pages
        my $pwd = getcwd();
        chdir($Podroot) || 
            die "$0: error changing to directory $Podroot: $!\n";

        # find all pod modules/pages in podpath, store in %Pages
        # - callback used to remove Podroot and extension from each file
        # - laborious to allow '.' in dirnames (e.g., /usr/share/perl/5.14.1)
        Pod::Simple::Search->new->inc(0)->verbose($Verbose)->laborious(1)
            ->callback(\&_save_page)->recurse($Recurse)->survey(@Podpath);

        chdir($pwd) || die "$0: error changing to directory $pwd: $!\n";

        # cache the directory list for later use
        warn "caching directories for later use\n" if $Verbose;
        open my $cache, '>', $Dircache
            or die "$0: error open $Dircache for writing: $!\n";

        print $cache join(":", @Podpath) . "\n$Podroot\n";
        my $_updirs_only = ($Podroot =~ /\.\./) && !($Podroot =~ /[^\.\\\/]/);
        foreach my $key (keys %Pages) {
            if($_updirs_only) {
              my $_dirlevel = $Podroot;
              while($_dirlevel =~ /\.\./) {
                $_dirlevel =~ s/\.\.//;
                # Assume $Pages{$key} has '/' separators (html dir separators).
                $Pages{$key} =~ s/^[\w\s\-\.]+\///;
              }
            }
            print $cache "$key $Pages{$key}\n";
        }

        close $cache or die "error closing $Dircache: $!";
    }

    # set options for the parser
    my $parser = Pod::Simple::XHTML::LocalPodLinks->new();
    $parser->codes_in_verbatim(0);
    $parser->anchor_items(1); # the old Pod::Html always did
    $parser->backlink($Backlink); # linkify =head1 directives
    $parser->htmldir($Htmldir);
    $parser->htmlfileurl($Htmlfileurl);
    $parser->htmlroot($Htmlroot);
    $parser->index($Doindex);
    $parser->no_errata_section(!$Poderrors); # note the inverse
    $parser->output_string(\my $output); # written to file later
    $parser->pages(\%Pages);
    $parser->quiet($Quiet);
    $parser->verbose($Verbose);

    # XXX: implement default title generator in pod::simple::xhtml
    # copy the way the old Pod::Html did it
    $Title = html_escape($Title);

    # We need to add this ourselves because we use our own header, not
    # ::XHTML's header. We need to set $parser->backlink to linkify
    # the =head1 directives
    my $bodyid = $Backlink ? ' id="_podtop_"' : '';

    my $csslink = '';
    my $tdstyle = ' style="background-color: #cccccc; color: #000"';

    if ($Css) {
        $csslink = qq(\n<link rel="stylesheet" href="$Css" type="text/css" />);
        $csslink =~ s,\\,/,g;
        $csslink =~ s,(/.):,$1|,;
        $tdstyle= '';
    }

    # header/footer block
    my $block = $Header ? <<END_OF_BLOCK : '';
<table border="0" width="100%" cellspacing="0" cellpadding="3">
<tr><td class="_podblock_"$tdstyle valign="middle">
<big><strong><span class="_podblock_">&nbsp;$Title</span></strong></big>
</td></tr>
</table>
END_OF_BLOCK

    # create own header/footer because of --header
    $parser->html_header(<<"HTMLHEAD");
<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>$Title</title>$csslink
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:$Config{perladmin}" />
</head>

<body$bodyid>
$block
HTMLHEAD

    $parser->html_footer(<<"HTMLFOOT");
$block
</body>

</html>
HTMLFOOT

    my $input;
    unless (@ARGV && $ARGV[0]) {
        if ($Podfile and $Podfile ne '-') {
            $input = $Podfile;
        } else {
            $input = '-'; # XXX: make a test case for this
        }
    } else {
        $Podfile = $ARGV[0];
        $input = *ARGV;
    }

    warn "Converting input file $Podfile\n" if $Verbose;
    $parser->parse_file($input);

    # Write output to file
    $Htmlfile = "-" unless $Htmlfile; # stdout
    my $fhout;
    if($Htmlfile and $Htmlfile ne '-') {
        open $fhout, ">", $Htmlfile
            or die "$0: cannot open $Htmlfile file for output: $!\n";
    } else {
        open $fhout, ">-";
    }
    binmode $fhout, ":utf8";
    print $fhout $output;
    close $fhout or die "Failed to close $Htmlfile: $!";
    chmod 0644, $Htmlfile unless $Htmlfile eq '-';
}

##############################################################################

sub usage {
    my $podfile = shift;
    warn "$0: $podfile: @_\n" if @_;
    die <<END_OF_USAGE;
Usage:  $0 --help --htmldir=<name> --htmlroot=<URL>
           --infile=<name> --outfile=<name>
           --podpath=<name>:...:<name> --podroot=<name>
           --cachedir=<name> --flush --recurse --norecurse
           --quiet --noquiet --verbose --noverbose
           --index --noindex --backlink --nobacklink
           --header --noheader --poderrors --nopoderrors
           --css=<URL> --title=<name>

  --[no]backlink  - turn =head1 directives into links pointing to the top of
                      the page (off by default).
  --cachedir      - directory for the directory cache files.
  --css           - stylesheet URL
  --flush         - flushes the directory cache.
  --[no]header    - produce block header/footer (default is no headers).
  --help          - prints this message.
  --htmldir       - directory for resulting HTML files.
  --htmlroot      - http-server base directory from which all relative paths
                      in podpath stem (default is /).
  --[no]index     - generate an index at the top of the resulting html
                      (default behaviour).
  --infile        - filename for the pod to convert (input taken from stdin
                      by default).
  --outfile       - filename for the resulting html file (output sent to
                      stdout by default).
  --[no]poderrors - include a POD ERRORS section in the output if there were 
                      any POD errors in the input (default behavior).
  --podpath       - colon-separated list of directories containing library
                      pods (empty by default).
  --podroot       - filesystem base directory from which all relative paths
                      in podpath stem (default is .).
  --[no]quiet     - suppress some benign warning messages (default is off).
  --[no]recurse   - recurse on those subdirectories listed in podpath
                      (default behaviour).
  --title         - title that will appear in resulting html file.
  --[no]verbose   - self-explanatory (off by default).

END_OF_USAGE

}

sub parse_command_line {
    my ($opt_backlink,$opt_cachedir,$opt_css,$opt_flush,$opt_header,
        $opt_help,$opt_htmldir,$opt_htmlroot,$opt_index,$opt_infile,
        $opt_outfile,$opt_poderrors,$opt_podpath,$opt_podroot,
        $opt_quiet,$opt_recurse,$opt_title,$opt_verbose,$opt_libpods);

    unshift @ARGV, split ' ', $Config{pod2html} if $Config{pod2html};
    my $result = GetOptions(
                       'backlink!'  => \$opt_backlink,
                       'cachedir=s' => \$opt_cachedir,
                       'css=s'      => \$opt_css,
                       'flush'      => \$opt_flush,
                       'help'       => \$opt_help,
                       'header!'    => \$opt_header,
                       'htmldir=s'  => \$opt_htmldir,
                       'htmlroot=s' => \$opt_htmlroot,
                       'index!'     => \$opt_index,
                       'infile=s'   => \$opt_infile,
                       'libpods=s'  => \$opt_libpods, # deprecated
                       'outfile=s'  => \$opt_outfile,
                       'poderrors!' => \$opt_poderrors,
                       'podpath=s'  => \$opt_podpath,
                       'podroot=s'  => \$opt_podroot,
                       'quiet!'     => \$opt_quiet,
                       'recurse!'   => \$opt_recurse,
                       'title=s'    => \$opt_title,
                       'verbose!'   => \$opt_verbose,
    );
    usage("-", "invalid parameters") if not $result;

    usage("-") if defined $opt_help;    # see if the user asked for help
    $opt_help = "";                     # just to make -w shut-up.

    @Podpath  = split(":", $opt_podpath) if defined $opt_podpath;
    warn "--libpods is no longer supported" if defined $opt_libpods;

    $Backlink  =          $opt_backlink   if defined $opt_backlink;
    $Cachedir  = _unixify($opt_cachedir)  if defined $opt_cachedir;
    $Css       =          $opt_css        if defined $opt_css;
    $Header    =          $opt_header     if defined $opt_header;
    $Htmldir   = _unixify($opt_htmldir)   if defined $opt_htmldir;
    $Htmlroot  = _unixify($opt_htmlroot)  if defined $opt_htmlroot;
    $Doindex   =          $opt_index      if defined $opt_index;
    $Podfile   = _unixify($opt_infile)    if defined $opt_infile;
    $Htmlfile  = _unixify($opt_outfile)   if defined $opt_outfile;
    $Poderrors =          $opt_poderrors  if defined $opt_poderrors;
    $Podroot   = _unixify($opt_podroot)   if defined $opt_podroot;
    $Quiet     =          $opt_quiet      if defined $opt_quiet;
    $Recurse   =          $opt_recurse    if defined $opt_recurse;
    $Title     =          $opt_title      if defined $opt_title;
    $Verbose   =          $opt_verbose    if defined $opt_verbose;

    warn "Flushing directory caches\n"
        if $opt_verbose && defined $opt_flush;
    $Dircache = "$Cachedir/pod2htmd.tmp";
    if (defined $opt_flush) {
        1 while unlink($Dircache);
    }
}

my $Saved_Cache_Key;

sub get_cache {
    my($dircache, $podpath, $podroot, $recurse) = @_;
    my @cache_key_args = @_;

    # A first-level cache:
    # Don't bother reading the cache files if they still apply
    # and haven't changed since we last read them.

    my $this_cache_key = cache_key(@cache_key_args);
    return 1 if $Saved_Cache_Key and $this_cache_key eq $Saved_Cache_Key;
    $Saved_Cache_Key = $this_cache_key;

    # load the cache of %Pages if possible.  $tests will be
    # non-zero if successful.
    my $tests = 0;
    if (-f $dircache) {
        warn "scanning for directory cache\n" if $Verbose;
        $tests = load_cache($dircache, $podpath, $podroot);
    }

    return $tests;
}

sub cache_key {
    my($dircache, $podpath, $podroot, $recurse) = @_;
    return join('!',$dircache,$recurse,@$podpath,$podroot,stat($dircache));
}

#
# load_cache - tries to find if the cache stored in $dircache is a valid
#  cache of %Pages.  if so, it loads them and returns a non-zero value.
#
sub load_cache {
    my($dircache, $podpath, $podroot) = @_;
    my $tests = 0;
    local $_;

    warn "scanning for directory cache\n" if $Verbose;
    open(my $cachefh, '<', $dircache) ||
        die "$0: error opening $dircache for reading: $!\n";
    $/ = "\n";

    # is it the same podpath?
    $_ = <$cachefh>;
    chomp($_);
    $tests++ if (join(":", @$podpath) eq $_);

    # is it the same podroot?
    $_ = <$cachefh>;
    chomp($_);
    $tests++ if ($podroot eq $_);

    # load the cache if its good
    if ($tests != 2) {
        close($cachefh);
        return 0;
    }

    warn "loading directory cache\n" if $Verbose;
    while (<$cachefh>) {
        /(.*?) (.*)$/;
        $Pages{$1} = $2;
    }

    close($cachefh);
    return 1;
}


#
# html_escape: make text safe for HTML
#
sub html_escape {
    my $rest = $_[0];
    $rest   =~ s/&/&amp;/g;
    $rest   =~ s/</&lt;/g;
    $rest   =~ s/>/&gt;/g;
    $rest   =~ s/"/&quot;/g;
    # &apos; is only in XHTML, not HTML4.  Be conservative
    #$rest   =~ s/'/&apos;/g;
    return $rest;
}

#
# htmlify - converts a pod section specification to a suitable section
# specification for HTML. Note that we keep spaces and special characters
# except ", ? (Netscape problem) and the hyphen (writer's problem...).
#
sub htmlify {
    my( $heading) = @_;
    $heading =~ s/(\s+)/ /g;
    $heading =~ s/\s+\Z//;
    $heading =~ s/\A\s+//;
    # The hyphen is a disgrace to the English language.
    # $heading =~ s/[-"?]//g;
    $heading =~ s/["?]//g;
    $heading = lc( $heading );
    return $heading;
}

#
# similar to htmlify, but turns non-alphanumerics into underscores
#
sub anchorify {
    my ($anchor) = @_;
    $anchor = htmlify($anchor);
    $anchor =~ s/\W/_/g;
    return $anchor;
}

#
# store POD files in %Pages
#
sub _save_page {
    my ($modspec, $modname) = @_;

    # Remove Podroot from path
    $modspec = $Podroot eq File::Spec->curdir
               ? File::Spec->abs2rel($modspec)
               : File::Spec->abs2rel($modspec,
                                     File::Spec->canonpath($Podroot));

    # Convert path to unix style path
    $modspec = Pod::Html::_unixify($modspec);

    my ($file, $dir) = fileparse($modspec, qr/\.[^.]*/); # strip .ext
    $Pages{$modname} = $dir.$file;
}

sub _unixify {
    my $full_path = shift;
    return '' unless $full_path;
    return $full_path if $full_path eq '/';

    my ($vol, $dirs, $file) = File::Spec->splitpath($full_path);
    my @dirs = $dirs eq File::Spec->curdir()
               ? (File::Spec::Unix->curdir())
               : File::Spec->splitdir($dirs);
    if (defined($vol) && $vol) {
        $vol =~ s/:$// if $^O eq 'VMS';
        $vol = uc $vol if $^O eq 'MSWin32';

        if( $dirs[0] ) {
            unshift @dirs, $vol;
        }
        else {
            $dirs[0] = $vol;
        }
    }
    unshift @dirs, '' if File::Spec->file_name_is_absolute($full_path);
    return $file unless scalar(@dirs);
    $full_path = File::Spec::Unix->catfile(File::Spec::Unix->catdir(@dirs),
                                           $file);
    $full_path =~ s|^\/|| if $^O eq 'MSWin32'; # C:/foo works, /C:/foo doesn't
    $full_path =~ s/\^\././g if $^O eq 'VMS'; # unescape dots
    return $full_path;
}

package Pod::Simple::XHTML::LocalPodLinks;
use strict;
use warnings;
use parent 'Pod::Simple::XHTML';

use File::Spec;
use File::Spec::Unix;

__PACKAGE__->_accessorize(
 'htmldir',
 'htmlfileurl',
 'htmlroot',
 'pages', # Page name => relative/path/to/page from root POD dir
 'quiet',
 'verbose',
);

sub resolve_pod_page_link {
    my ($self, $to, $section) = @_;

    return undef unless defined $to || defined $section;
    if (defined $section) {
        $section = '#' . $self->idify($section, 1);
        return $section unless defined $to;
    } else {
        $section = '';
    }

    my $path; # path to $to according to %Pages
    unless (exists $self->pages->{$to}) {
        # Try to find a POD that ends with $to and use that.
        # e.g., given L<XHTML>, if there is no $Podpath/XHTML in %Pages,
        # look for $Podpath/*/XHTML in %Pages, with * being any path,
        # as a substitute (e.g., $Podpath/Pod/Simple/XHTML)
        my @matches;
        foreach my $modname (keys %{$self->pages}) {
            push @matches, $modname if $modname =~ /::\Q$to\E\z/;
        }

        if ($#matches == -1) {
            warn "Cannot find \"$to\" in podpath: " . 
                 "cannot find suitable replacement path, cannot resolve link\n"
                 unless $self->quiet;
            return '';
        } elsif ($#matches == 0) {
            warn "Cannot find \"$to\" in podpath: " .
                 "using $matches[0] as replacement path to $to\n" 
                 unless $self->quiet;
            $path = $self->pages->{$matches[0]};
        } else {
            warn "Cannot find \"$to\" in podpath: " .
                 "more than one possible replacement path to $to, " .
                 "using $matches[-1]\n" unless $self->quiet;
            # Use [-1] so newer (higher numbered) perl PODs are used
            $path = $self->pages->{$matches[-1]};
        }
    } else {
        $path = $self->pages->{$to};
    }

    my $url = File::Spec::Unix->catfile(Pod::Html::_unixify($self->htmlroot),
                                        $path);

    if ($self->htmlfileurl ne '') {
        # then $self->htmlroot eq '' (by definition of htmlfileurl) so
        # $self->htmldir needs to be prepended to link to get the absolute path
        # that will be relativized
        $url = relativize_url(
            File::Spec::Unix->catdir(Pod::Html::_unixify($self->htmldir), $url),
            $self->htmlfileurl # already unixified
        );
    }

    return $url . ".html$section";
}

#
# relativize_url - convert an absolute URL to one relative to a base URL.
# Assumes both end in a filename.
#
sub relativize_url {
    my ($dest, $source) = @_;

    # Remove each file from its path
    my ($dest_volume, $dest_directory, $dest_file) =
        File::Spec::Unix->splitpath( $dest );
    $dest = File::Spec::Unix->catpath( $dest_volume, $dest_directory, '' );

    my ($source_volume, $source_directory, $source_file) =
        File::Spec::Unix->splitpath( $source );
    $source = File::Spec::Unix->catpath( $source_volume, $source_directory, '' );

    my $rel_path = '';
    if ($dest ne '') {
       $rel_path = File::Spec::Unix->abs2rel( $dest, $source );
    }

    if ($rel_path ne '' && substr( $rel_path, -1 ) ne '/') {
        $rel_path .= "/$dest_file";
    } else {
        $rel_path .= "$dest_file";
    }

    return $rel_path;
}

1;
                                    #############################################################################
# Pod/InputObjects.pm -- package which defines objects for input streams
# and paragraphs and commands when parsing POD docs.
#
# Copyright (C) 1996-2000 by Bradford Appleton. All rights reserved.
# This file is part of "PodParser". PodParser is free software;
# you can redistribute it and/or modify it under the same terms
# as Perl itself.
#############################################################################

package Pod::InputObjects;
use strict;

use vars qw($VERSION);
$VERSION = '1.63';  ## Current version of this package
require  5.005;    ## requires this Perl version or later

#############################################################################

=head1 NAME

Pod::InputObjects - objects representing POD input paragraphs, commands, etc.

=head1 SYNOPSIS

    use Pod::InputObjects;

=head1 REQUIRES

perl5.004, Carp

=head1 EXPORTS

Nothing.

=head1 DESCRIPTION

B<NOTE: This module is considered legacy; modern Perl releases (5.18 and
higher) are going to remove Pod-Parser from core and use L<Pod-Simple>
for all things POD.>

This module defines some basic input objects used by B<Pod::Parser> when
reading and parsing POD text from an input source. The following objects
are defined:

=begin __PRIVATE__

=over 4

=item package B<Pod::InputSource>

An object corresponding to a source of POD input text. It is mostly a
wrapper around a filehandle or C<IO::Handle>-type object (or anything
that implements the C<getline()> method) which keeps track of some
additional information relevant to the parsing of PODs.

=back

=end __PRIVATE__

=over 4

=item package B<Pod::Paragraph>

An object corresponding to a paragraph of POD input text. It may be a
plain paragraph, a verbatim paragraph, or a command paragraph (see
L<perlpod>).

=item package B<Pod::InteriorSequence>

An object corresponding to an interior sequence command from the POD
input text (see L<perlpod>).

=item package B<Pod::ParseTree>

An object corresponding to a tree of parsed POD text. Each "node" in
a parse-tree (or I<ptree>) is either a text-string or a reference to
a B<Pod::InteriorSequence> object. The nodes appear in the parse-tree
in the order in which they were parsed from left-to-right.

=back

Each of these input objects are described in further detail in the
sections which follow.

=cut

#############################################################################

package Pod::InputSource;

##---------------------------------------------------------------------------

=begin __PRIVATE__

=head1 B<Pod::InputSource>

This object corresponds to an input source or stream of POD
documentation. When parsing PODs, it is necessary to associate and store
certain context information with each input source. All of this
information is kept together with the stream itself in one of these
C<Pod::InputSource> objects. Each such object is merely a wrapper around
an C<IO::Handle> object of some kind (or at least something that
implements the C<getline()> method). They have the following
methods/attributes:

=end __PRIVATE__

=cut

##---------------------------------------------------------------------------

=begin __PRIVATE__

=head2 B<new()>

        my $pod_input1 = Pod::InputSource->new(-handle => $filehandle);
        my $pod_input2 = new Pod::InputSource(-handle => $filehandle,
                                              -name   => $name);
        my $pod_input3 = new Pod::InputSource(-handle => \*STDIN);
        my $pod_input4 = Pod::InputSource->new(-handle => \*STDIN,
                                               -name => "(STDIN)");

This is a class method that constructs a C<Pod::InputSource> object and
returns a reference to the new input source object. It takes one or more
keyword arguments in the form of a hash. The keyword C<-handle> is
required and designates the corresponding input handle. The keyword
C<-name> is optional and specifies the name associated with the input
handle (typically a file name).

=end __PRIVATE__

=cut

sub new {
    ## Determine if we were called via an object-ref or a classname
    my $this = shift;
    my $class = ref($this) || $this;

    ## Any remaining arguments are treated as initial values for the
    ## hash that is used to represent this object. Note that we default
    ## certain values by specifying them *before* the arguments passed.
    ## If they are in the argument list, they will override the defaults.
    my $self = { -name        => '(unknown)',
                 -handle      => undef,
                 -was_cutting => 0,
                 @_ };

    ## Bless ourselves into the desired class and perform any initialization
    bless $self, $class;
    return $self;
}

##---------------------------------------------------------------------------

=begin __PRIVATE__

=head2 B<name()>

        my $filename = $pod_input->name();
        $pod_input->name($new_filename_to_use);

This method gets/sets the name of the input source (usually a filename).
If no argument is given, it returns a string containing the name of
the input source; otherwise it sets the name of the input source to the
contents of the given argument.

=end __PRIVATE__

=cut

sub name {
   (@_ > 1)  and  $_[0]->{'-name'} = $_[1];
   return $_[0]->{'-name'};
}

## allow 'filename' as an alias for 'name'
*filename = \&name;

##---------------------------------------------------------------------------

=begin __PRIVATE__

=head2 B<handle()>

        my $handle = $pod_input->handle();

Returns a reference to the handle object from which input is read (the
one used to contructed this input source object).

=end __PRIVATE__

=cut

sub handle {
   return $_[0]->{'-handle'};
}

##---------------------------------------------------------------------------

=begin __PRIVATE__

=head2 B<was_cutting()>

        print "Yes.\n" if ($pod_input->was_cutting());

The value of the C<cutting> state (that the B<cutting()> method would
have returned) immediately before any input was read from this input
stream. After all input from this stream has been read, the C<cutting>
state is restored to this value.

=end __PRIVATE__

=cut

sub was_cutting {
   (@_ > 1)  and  $_[0]->{-was_cutting} = $_[1];
   return $_[0]->{-was_cutting};
}

##---------------------------------------------------------------------------

#############################################################################

package Pod::Paragraph;

##---------------------------------------------------------------------------

=head1 B<Pod::Paragraph>

An object representing a paragraph of POD input text.
It has the following methods/attributes:

=cut

##---------------------------------------------------------------------------

=head2 Pod::Paragraph-E<gt>B<new()>

        my $pod_para1 = Pod::Paragraph->new(-text => $text);
        my $pod_para2 = Pod::Paragraph->new(-name => $cmd,
                                            -text => $text);
        my $pod_para3 = new Pod::Paragraph(-text => $text);
        my $pod_para4 = new Pod::Paragraph(-name => $cmd,
                                           -text => $text);
        my $pod_para5 = Pod::Paragraph->new(-name => $cmd,
                                            -text => $text,
                                            -file => $filename,
                                            -line => $line_number);

This is a class method that constructs a C<Pod::Paragraph> object and
returns a reference to the new paragraph object. It may be given one or
two keyword arguments. The C<-text> keyword indicates the corresponding
text of the POD paragraph. The C<-name> keyword indicates the name of
the corresponding POD command, such as C<head1> or C<item> (it should
I<not> contain the C<=> prefix); this is needed only if the POD
paragraph corresponds to a command paragraph. The C<-file> and C<-line>
keywords indicate the filename and line number corresponding to the
beginning of the paragraph 

=cut

sub new {
    ## Determine if we were called via an object-ref or a classname
    my $this = shift;
    my $class = ref($this) || $this;

    ## Any remaining arguments are treated as initial values for the
    ## hash that is used to represent this object. Note that we default
    ## certain values by specifying them *before* the arguments passed.
    ## If they are in the argument list, they will override the defaults.
    my $self = {
          -name       => undef,
          -text       => (@_ == 1) ? shift : undef,
          -file       => '<unknown-file>',
          -line       => 0,
          -prefix     => '=',
          -separator  => ' ',
          -ptree => [],
          @_
    };

    ## Bless ourselves into the desired class and perform any initialization
    bless $self, $class;
    return $self;
}

##---------------------------------------------------------------------------

=head2 $pod_para-E<gt>B<cmd_name()>

        my $para_cmd = $pod_para->cmd_name();

If this paragraph is a command paragraph, then this method will return 
the name of the command (I<without> any leading C<=> prefix).

=cut

sub cmd_name {
   (@_ > 1)  and  $_[0]->{'-name'} = $_[1];
   return $_[0]->{'-name'};
}

## let name() be an alias for cmd_name()
*name = \&cmd_name;

##---------------------------------------------------------------------------

=head2 $pod_para-E<gt>B<text()>

        my $para_text = $pod_para->text();

This method will return the corresponding text of the paragraph.

=cut

sub text {
   (@_ > 1)  and  $_[0]->{'-text'} = $_[1];
   return $_[0]->{'-text'};
}

##---------------------------------------------------------------------------

=head2 $pod_para-E<gt>B<raw_text()>

        my $raw_pod_para = $pod_para->raw_text();

This method will return the I<raw> text of the POD paragraph, exactly
as it appeared in the input.

=cut

sub raw_text {
   return $_[0]->{'-text'}  unless (defined $_[0]->{'-name'});
   return $_[0]->{'-prefix'} . $_[0]->{'-name'} .
          $_[0]->{'-separator'} . $_[0]->{'-text'};
}

##---------------------------------------------------------------------------

=head2 $pod_para-E<gt>B<cmd_prefix()>

        my $prefix = $pod_para->cmd_prefix();

If this paragraph is a command paragraph, then this method will return 
the prefix used to denote the command (which should be the string "="
or "==").

=cut

sub cmd_prefix {
   return $_[0]->{'-prefix'};
}

##---------------------------------------------------------------------------

=head2 $pod_para-E<gt>B<cmd_separator()>

        my $separator = $pod_para->cmd_separator();

If this paragraph is a command paragraph, then this method will return
the text used to separate the command name from the rest of the
paragraph (if any).

=cut

sub cmd_separator {
   return $_[0]->{'-separator'};
}

##---------------------------------------------------------------------------

=head2 $pod_para-E<gt>B<parse_tree()>

        my $ptree = $pod_parser->parse_text( $pod_para->text() );
        $pod_para->parse_tree( $ptree );
        $ptree = $pod_para->parse_tree();

This method will get/set the corresponding parse-tree of the paragraph's text.

=cut

sub parse_tree {
   (@_ > 1)  and  $_[0]->{'-ptree'} = $_[1];
   return $_[0]->{'-ptree'};
}

## let ptree() be an alias for parse_tree()
*ptree = \&parse_tree;

##---------------------------------------------------------------------------

=head2 $pod_para-E<gt>B<file_line()>

        my ($filename, $line_number) = $pod_para->file_line();
        my $position = $pod_para->file_line();

Returns the current filename and line number for the paragraph
object.  If called in a list context, it returns a list of two
elements: first the filename, then the line number. If called in
a scalar context, it returns a string containing the filename, followed
by a colon (':'), followed by the line number.

=cut

sub file_line {
   my @loc = ($_[0]->{'-file'} || '<unknown-file>',
              $_[0]->{'-line'} || 0);
   return (wantarray) ? @loc : join(':', @loc);
}

##---------------------------------------------------------------------------

#############################################################################

package Pod::InteriorSequence;

##---------------------------------------------------------------------------

=head1 B<Pod::InteriorSequence>

An object representing a POD interior sequence command.
It has the following methods/attributes:

=cut

##---------------------------------------------------------------------------

=head2 Pod::InteriorSequence-E<gt>B<new()>

        my $pod_seq1 = Pod::InteriorSequence->new(-name => $cmd
                                                  -ldelim => $delimiter);
        my $pod_seq2 = new Pod::InteriorSequence(-name => $cmd,
                                                 -ldelim => $delimiter);
        my $pod_seq3 = new Pod::InteriorSequence(-name => $cmd,
                                                 -ldelim => $delimiter,
                                                 -file => $filename,
                                                 -line => $line_number);

        my $pod_seq4 = new Pod::InteriorSequence(-name => $cmd, $ptree);
        my $pod_seq5 = new Pod::InteriorSequence($cmd, $ptree);

This is a class method that constructs a C<Pod::InteriorSequence> object
and returns a reference to the new interior sequence object. It should
be given two keyword arguments.  The C<-ldelim> keyword indicates the
corresponding left-delimiter of the interior sequence (e.g. 'E<lt>').
The C<-name> keyword indicates the name of the corresponding interior
sequence command, such as C<I> or C<B> or C<C>. The C<-file> and
C<-line> keywords indicate the filename and line number corresponding
to the beginning of the interior sequence. If the C<$ptree> argument is
given, it must be the last argument, and it must be either string, or
else an array-ref suitable for passing to B<Pod::ParseTree::new> (or
it may be a reference to a Pod::ParseTree object).

=cut

sub new {
    ## Determine if we were called via an object-ref or a classname
    my $this = shift;
    my $class = ref($this) || $this;

    ## See if first argument has no keyword
    if (((@_ <= 2) or (@_ % 2)) and $_[0] !~ /^-\w/) {
       ## Yup - need an implicit '-name' before first parameter
       unshift @_, '-name';
    }

    ## See if odd number of args
    if ((@_ % 2) != 0) {
       ## Yup - need an implicit '-ptree' before the last parameter
       splice @_, $#_, 0, '-ptree';
    }

    ## Any remaining arguments are treated as initial values for the
    ## hash that is used to represent this object. Note that we default
    ## certain values by specifying them *before* the arguments passed.
    ## If they are in the argument list, they will override the defaults.
    my $self = {
          -name       => (@_ == 1) ? $_[0] : undef,
          -file       => '<unknown-file>',
          -line       => 0,
          -ldelim     => '<',
          -rdelim     => '>',
          @_
    };

    ## Initialize contents if they haven't been already
    my $ptree = $self->{'-ptree'} || new Pod::ParseTree();
    if ( ref $ptree =~ /^(ARRAY)?$/ ) {
        ## We have an array-ref, or a normal scalar. Pass it as an
        ## an argument to the ptree-constructor
        $ptree = new Pod::ParseTree($1 ? [$ptree] : $ptree);
    }
    $self->{'-ptree'} = $ptree;

    ## Bless ourselves into the desired class and perform any initialization
    bless $self, $class;
    return $self;
}

##---------------------------------------------------------------------------

=head2 $pod_seq-E<gt>B<cmd_name()>

        my $seq_cmd = $pod_seq->cmd_name();

The name of the interior sequence command.

=cut

sub cmd_name {
   (@_ > 1)  and  $_[0]->{'-name'} = $_[1];
   return $_[0]->{'-name'};
}

## let name() be an alias for cmd_name()
*name = \&cmd_name;

##---------------------------------------------------------------------------

## Private subroutine to set the parent pointer of all the given
## children that are interior-sequences to be $self

sub _set_child2parent_links {
   my ($self, @children) = @_;
   ## Make sure any sequences know who their parent is
   for (@children) {
      next  unless (length  and  ref  and  ref ne 'SCALAR');
      if (UNIVERSAL::isa($_, 'Pod::InteriorSequence') or
          UNIVERSAL::can($_, 'nested'))
      {
          $_->nested($self);
      }
   }
}

## Private subroutine to unset child->parent links

sub _unset_child2parent_links {
   my $self = shift;
   $self->{'-parent_sequence'} = undef;
   my $ptree = $self->{'-ptree'};
   for (@$ptree) {
      next  unless (length  and  ref  and  ref ne 'SCALAR');
      $_->_unset_child2parent_links()
          if UNIVERSAL::isa($_, 'Pod::InteriorSequence');
   }
}

##---------------------------------------------------------------------------

=head2 $pod_seq-E<gt>B<prepend()>

        $pod_seq->prepend($text);
        $pod_seq1->prepend($pod_seq2);

Prepends the given string or parse-tree or sequence object to the parse-tree
of this interior sequence.

=cut

sub prepend {
   my $self  = shift;
   $self->{'-ptree'}->prepend(@_);
   _set_child2parent_links($self, @_);
   return $self;
}

##---------------------------------------------------------------------------

=head2 $pod_seq-E<gt>B<append()>

        $pod_seq->append($text);
        $pod_seq1->append($pod_seq2);

Appends the given string or parse-tree or sequence object to the parse-tree
of this interior sequence.

=cut

sub append {
   my $self = shift;
   $self->{'-ptree'}->append(@_);
   _set_child2parent_links($self, @_);
   return $self;
}

##---------------------------------------------------------------------------

=head2 $pod_seq-E<gt>B<nested()>

        $outer_seq = $pod_seq->nested || print "not nested";

If this interior sequence is nested inside of another interior
sequence, then the outer/parent sequence that contains it is
returned. Otherwise C<undef> is returned.

=cut

sub nested {
   my $self = shift;
  (@_ == 1)  and  $self->{'-parent_sequence'} = shift;
   return  $self->{'-parent_sequence'} || undef;
}

##---------------------------------------------------------------------------

=head2 $pod_seq-E<gt>B<raw_text()>

        my $seq_raw_text = $pod_seq->raw_text();

This method will return the I<raw> text of the POD interior sequence,
exactly as it appeared in the input.

=cut

sub raw_text {
   my $self = shift;
   my $text = $self->{'-name'} . $self->{'-ldelim'};
   for ( $self->{'-ptree'}->children ) {
      $text .= (ref $_) ? $_->raw_text : $_;
   }
   $text .= $self->{'-rdelim'};
   return $text;
}

##---------------------------------------------------------------------------

=head2 $pod_seq-E<gt>B<left_delimiter()>

        my $ldelim = $pod_seq->left_delimiter();

The leftmost delimiter beginning the argument text to the interior
sequence (should be "<").

=cut

sub left_delimiter {
   (@_ > 1)  and  $_[0]->{'-ldelim'} = $_[1];
   return $_[0]->{'-ldelim'};
}

## let ldelim() be an alias for left_delimiter()
*ldelim = \&left_delimiter;

##---------------------------------------------------------------------------

=head2 $pod_seq-E<gt>B<right_delimiter()>

The rightmost delimiter beginning the argument text to the interior
sequence (should be ">").

=cut

sub right_delimiter {
   (@_ > 1)  and  $_[0]->{'-rdelim'} = $_[1];
   return $_[0]->{'-rdelim'};
}

## let rdelim() be an alias for right_delimiter()
*rdelim = \&right_delimiter;

##---------------------------------------------------------------------------

=head2 $pod_seq-E<gt>B<parse_tree()>

        my $ptree = $pod_parser->parse_text($paragraph_text);
        $pod_seq->parse_tree( $ptree );
        $ptree = $pod_seq->parse_tree();

This method will get/set the corresponding parse-tree of the interior
sequence's text.

=cut

sub parse_tree {
   (@_ > 1)  and  $_[0]->{'-ptree'} = $_[1];
   return $_[0]->{'-ptree'};
}

## let ptree() be an alias for parse_tree()
*ptree = \&parse_tree;

##---------------------------------------------------------------------------

=head2 $pod_seq-E<gt>B<file_line()>

        my ($filename, $line_number) = $pod_seq->file_line();
        my $position = $pod_seq->file_line();

Returns the current filename and line number for the interior sequence
object.  If called in a list context, it returns a list of two
elements: first the filename, then the line number. If called in
a scalar context, it returns a string containing the filename, followed
by a colon (':'), followed by the line number.

=cut

sub file_line {
   my @loc = ($_[0]->{'-file'}  || '<unknown-file>',
              $_[0]->{'-line'}  || 0);
   return (wantarray) ? @loc : join(':', @loc);
}

##---------------------------------------------------------------------------

=head2 Pod::InteriorSequence::B<DESTROY()>

This method performs any necessary cleanup for the interior-sequence.
If you override this method then it is B<imperative> that you invoke
the parent method from within your own method, otherwise
I<interior-sequence storage will not be reclaimed upon destruction!>

=cut

sub DESTROY {
   ## We need to get rid of all child->parent pointers throughout the
   ## tree so their reference counts will go to zero and they can be
   ## garbage-collected
   _unset_child2parent_links(@_);
}

##---------------------------------------------------------------------------

#############################################################################

package Pod::ParseTree;

##---------------------------------------------------------------------------

=head1 B<Pod::ParseTree>

This object corresponds to a tree of parsed POD text. As POD text is
scanned from left to right, it is parsed into an ordered list of
text-strings and B<Pod::InteriorSequence> objects (in order of
appearance). A B<Pod::ParseTree> object corresponds to this list of
strings and sequences. Each interior sequence in the parse-tree may
itself contain a parse-tree (since interior sequences may be nested).

=cut

##---------------------------------------------------------------------------

=head2 Pod::ParseTree-E<gt>B<new()>

        my $ptree1 = Pod::ParseTree->new;
        my $ptree2 = new Pod::ParseTree;
        my $ptree4 = Pod::ParseTree->new($array_ref);
        my $ptree3 = new Pod::ParseTree($array_ref);

This is a class method that constructs a C<Pod::Parse_tree> object and
returns a reference to the new parse-tree. If a single-argument is given,
it must be a reference to an array, and is used to initialize the root
(top) of the parse tree.

=cut

sub new {
    ## Determine if we were called via an object-ref or a classname
    my $this = shift;
    my $class = ref($this) || $this;

    my $self = (@_ == 1  and  ref $_[0]) ? $_[0] : [];

    ## Bless ourselves into the desired class and perform any initialization
    bless $self, $class;
    return $self;
}

##---------------------------------------------------------------------------

=head2 $ptree-E<gt>B<top()>

        my $top_node = $ptree->top();
        $ptree->top( $top_node );
        $ptree->top( @children );

This method gets/sets the top node of the parse-tree. If no arguments are
given, it returns the topmost node in the tree (the root), which is also
a B<Pod::ParseTree>. If it is given a single argument that is a reference,
then the reference is assumed to a parse-tree and becomes the new top node.
Otherwise, if arguments are given, they are treated as the new list of
children for the top node.

=cut

sub top {
   my $self = shift;
   if (@_ > 0) {
      @{ $self } = (@_ == 1  and  ref $_[0]) ? ${ @_ } : @_;
   }
   return $self;
}

## let parse_tree() & ptree() be aliases for the 'top' method
*parse_tree = *ptree = \&top;

##---------------------------------------------------------------------------

=head2 $ptree-E<gt>B<children()>

This method gets/sets the children of the top node in the parse-tree.
If no arguments are given, it returns the list (array) of children
(each of which should be either a string or a B<Pod::InteriorSequence>.
Otherwise, if arguments are given, they are treated as the new list of
children for the top node.

=cut

sub children {
   my $self = shift;
   if (@_ > 0) {
      @{ $self } = (@_ == 1  and  ref $_[0]) ? ${ @_ } : @_;
   }
   return @{ $self };
}

##---------------------------------------------------------------------------

=head2 $ptree-E<gt>B<prepend()>

This method prepends the given text or parse-tree to the current parse-tree.
If the first item on the parse-tree is text and the argument is also text,
then the text is prepended to the first item (not added as a separate string).
Otherwise the argument is added as a new string or parse-tree I<before>
the current one.

=cut

use vars qw(@ptree);  ## an alias used for performance reasons

sub prepend {
   my $self = shift;
   local *ptree = $self;
   for (@_) {
      next  unless length;
      if (@ptree && !(ref $ptree[0]) && !(ref $_)) {
         $ptree[0] = $_ . $ptree[0];
      }
      else {
         unshift @ptree, $_;
      }
   }
}

##---------------------------------------------------------------------------

=head2 $ptree-E<gt>B<append()>

This method appends the given text or parse-tree to the current parse-tree.
If the last item on the parse-tree is text and the argument is also text,
then the text is appended to the last item (not added as a separate string).
Otherwise the argument is added as a new string or parse-tree I<after>
the current one.

=cut

sub append {
   my $self = shift;
   local *ptree = $self;
   my $can_append = @ptree && !(ref $ptree[-1]);
   for (@_) {
      if (ref) {
         push @ptree, $_;
      }
      elsif(!length) {
         next;
      }
      elsif ($can_append) {
         $ptree[-1] .= $_;
      }
      else {
         push @ptree, $_;
      }
   }
}

=head2 $ptree-E<gt>B<raw_text()>

        my $ptree_raw_text = $ptree->raw_text();

This method will return the I<raw> text of the POD parse-tree
exactly as it appeared in the input.

=cut

sub raw_text {
   my $self = shift;
   my $text = '';
   for ( @$self ) {
      $text .= (ref $_) ? $_->raw_text : $_;
   }
   return $text;
}

##---------------------------------------------------------------------------

## Private routines to set/unset child->parent links

sub _unset_child2parent_links {
   my $self = shift;
   local *ptree = $self;
   for (@ptree) {
       next  unless (defined and length  and  ref  and  ref ne 'SCALAR');
       $_->_unset_child2parent_links()
           if UNIVERSAL::isa($_, 'Pod::InteriorSequence');
   }
}

sub _set_child2parent_links {
    ## nothing to do, Pod::ParseTrees cant have parent pointers
}

=head2 Pod::ParseTree::B<DESTROY()>

This method performs any necessary cleanup for the parse-tree.
If you override this method then it is B<imperative>
that you invoke the parent method from within your own method,
otherwise I<parse-tree storage will not be reclaimed upon destruction!>

=cut

sub DESTROY {
   ## We need to get rid of all child->parent pointers throughout the
   ## tree so their reference counts will go to zero and they can be
   ## garbage-collected
   _unset_child2parent_links(@_);
}

#############################################################################

=head1 SEE ALSO

B<Pod::InputObjects> is part of the L<Pod::Parser> distribution.

See L<Pod::Parser>, L<Pod::Select>

=head1 AUTHOR

Please report bugs using L<http://rt.cpan.org>.

Brad Appleton E<lt>bradapp@enteract.comE<gt>

=cut

1;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      # Pod::Man -- Convert POD data to formatted *roff input.
#
# This module translates POD documentation into *roff markup using the man
# macro set, and is intended for converting POD documents written as Unix
# manual pages to manual pages that can be read by the man(1) command.  It is
# a replacement for the pod2man command distributed with versions of Perl
# prior to 5.6.
#
# Perl core hackers, please note that this module is also separately
# maintained outside of the Perl core as part of the podlators.  Please send
# me any patches at the address above in addition to sending them to the
# standard Perl mailing lists.
#
# Written by Russ Allbery <rra@cpan.org>
# Substantial contributions by Sean Burke <sburke@cpan.org>
# Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,
#     2010, 2012, 2013, 2014, 2015, 2016 Russ Allbery <rra@cpan.org>
#
# This program is free software; you may redistribute it and/or modify it
# under the same terms as Perl itself.

##############################################################################
# Modules and declarations
##############################################################################

package Pod::Man;

use 5.006;
use strict;
use warnings;

use subs qw(makespace);
use vars qw(@ISA %ESCAPES $PREAMBLE $VERSION);

use Carp qw(carp croak);
use Pod::Simple ();

# Conditionally import Encode and set $HAS_ENCODE if it is available.
our $HAS_ENCODE;
BEGIN {
    $HAS_ENCODE = eval { require Encode };
}

@ISA = qw(Pod::Simple);

$VERSION = '4.07';

# Set the debugging level.  If someone has inserted a debug function into this
# class already, use that.  Otherwise, use any Pod::Simple debug function
# that's defined, and failing that, define a debug level of 10.
BEGIN {
    my $parent = defined (&Pod::Simple::DEBUG) ? \&Pod::Simple::DEBUG : undef;
    unless (defined &DEBUG) {
        *DEBUG = $parent || sub () { 10 };
    }
}

# Import the ASCII constant from Pod::Simple.  This is true iff we're in an
# ASCII-based universe (including such things as ISO 8859-1 and UTF-8), and is
# generally only false for EBCDIC.
BEGIN { *ASCII = \&Pod::Simple::ASCII }

# Pretty-print a data structure.  Only used for debugging.
BEGIN { *pretty = \&Pod::Simple::pretty }

# Formatting instructions for various types of blocks.  cleanup makes hyphens
# hard, adds spaces between consecutive underscores, and escapes backslashes.
# convert translates characters into escapes.  guesswork means to apply the
# transformations done by the guesswork sub.  literal says to protect literal
# quotes from being turned into UTF-8 quotes.  By default, all transformations
# are on except literal, but some elements override.
#
# DEFAULT specifies the default settings.  All other elements should list only
# those settings that they are overriding.  Data indicates =for roff blocks,
# which should be passed along completely verbatim.
#
# Formatting inherits negatively, in the sense that if the parent has turned
# off guesswork, all child elements should leave it off.
my %FORMATTING = (
    DEFAULT  => { cleanup => 1, convert => 1, guesswork => 1, literal => 0 },
    Data     => { cleanup => 0, convert => 0, guesswork => 0, literal => 0 },
    Verbatim => {                             guesswork => 0, literal => 1 },
    C        => {                             guesswork => 0, literal => 1 },
    X        => { cleanup => 0,               guesswork => 0               },
);

##############################################################################
# Object initialization
##############################################################################

# Initialize the object and set various Pod::Simple options that we need.
# Here, we also process any additional options passed to the constructor or
# set up defaults if none were given.  Note that all internal object keys are
# in all-caps, reserving all lower-case object keys for Pod::Simple and user
# arguments.
sub new {
    my $class = shift;
    my $self = $class->SUPER::new;

    # Tell Pod::Simple not to handle S<> by automatically inserting &nbsp;.
    $self->nbsp_for_S (1);

    # Tell Pod::Simple to keep whitespace whenever possible.
    if (my $preserve_whitespace = $self->can ('preserve_whitespace')) {
        $self->$preserve_whitespace (1);
    } else {
        $self->fullstop_space_harden (1);
    }

    # The =for and =begin targets that we accept.
    $self->accept_targets (qw/man MAN roff ROFF/);

    # Ensure that contiguous blocks of code are merged together.  Otherwise,
    # some of the guesswork heuristics don't work right.
    $self->merge_text (1);

    # Pod::Simple doesn't do anything useful with our arguments, but we want
    # to put them in our object as hash keys and values.  This could cause
    # problems if we ever clash with Pod::Simple's own internal class
    # variables.
    %$self = (%$self, @_);

    # Send errors to stderr if requested.
    if ($$self{stderr} and not $$self{errors}) {
        $$self{errors} = 'stderr';
    }
    delete $$self{stderr};

    # Validate the errors parameter and act on it.
    if (not defined $$self{errors}) {
        $$self{errors} = 'pod';
    }
    if ($$self{errors} eq 'stderr' || $$self{errors} eq 'die') {
        $self->no_errata_section (1);
        $self->complain_stderr (1);
        if ($$self{errors} eq 'die') {
            $$self{complain_die} = 1;
        }
    } elsif ($$self{errors} eq 'pod') {
        $self->no_errata_section (0);
        $self->complain_stderr (0);
    } elsif ($$self{errors} eq 'none') {
        $self->no_whining (1);
    } else {
        croak (qq(Invalid errors setting: "$$self{errors}"));
    }
    delete $$self{errors};

    # Degrade back to non-utf8 if Encode is not available.
    #
    # Suppress the warning message when PERL_CORE is set, indicating this is
    # running as part of the core Perl build.  Perl builds podlators (and all
    # pure Perl modules) before Encode and other XS modules, so Encode won't
    # yet be available.  Rely on the Perl core build to generate man pages
    # later, after all the modules are available, so that UTF-8 handling will
    # be correct.
    if ($$self{utf8} and !$HAS_ENCODE) {
        if (!$ENV{PERL_CORE}) {
            carp ('utf8 mode requested but Encode module not available,'
                    . ' falling back to non-utf8');
        }
        delete $$self{utf8};
    }

    # Initialize various other internal constants based on our arguments.
    $self->init_fonts;
    $self->init_quotes;
    $self->init_page;

    # For right now, default to turning on all of the magic.
    $$self{MAGIC_CPP}       = 1;
    $$self{MAGIC_EMDASH}    = 1;
    $$self{MAGIC_FUNC}      = 1;
    $$self{MAGIC_MANREF}    = 1;
    $$self{MAGIC_SMALLCAPS} = 1;
    $$self{MAGIC_VARS}      = 1;

    return $self;
}

# Translate a font string into an escape.
sub toescape { (length ($_[0]) > 1 ? '\f(' : '\f') . $_[0] }

# Determine which fonts the user wishes to use and store them in the object.
# Regular, italic, bold, and bold-italic are constants, but the fixed width
# fonts may be set by the user.  Sets the internal hash key FONTS which is
# used to map our internal font escapes to actual *roff sequences later.
sub init_fonts {
    my ($self) = @_;

    # Figure out the fixed-width font.  If user-supplied, make sure that they
    # are the right length.
    for (qw/fixed fixedbold fixeditalic fixedbolditalic/) {
        my $font = $$self{$_};
        if (defined ($font) && (length ($font) < 1 || length ($font) > 2)) {
            croak qq(roff font should be 1 or 2 chars, not "$font");
        }
    }

    # Set the default fonts.  We can't be sure portably across different
    # implementations what fixed bold-italic may be called (if it's even
    # available), so default to just bold.
    $$self{fixed}           ||= 'CW';
    $$self{fixedbold}       ||= 'CB';
    $$self{fixeditalic}     ||= 'CI';
    $$self{fixedbolditalic} ||= 'CB';

    # Set up a table of font escapes.  First number is fixed-width, second is
    # bold, third is italic.
    $$self{FONTS} = { '000' => '\fR', '001' => '\fI',
                      '010' => '\fB', '011' => '\f(BI',
                      '100' => toescape ($$self{fixed}),
                      '101' => toescape ($$self{fixeditalic}),
                      '110' => toescape ($$self{fixedbold}),
                      '111' => toescape ($$self{fixedbolditalic}) };
}

# Initialize the quotes that we'll be using for C<> text.  This requires some
# special handling, both to parse the user parameter if given and to make sure
# that the quotes will be safe against *roff.  Sets the internal hash keys
# LQUOTE and RQUOTE.
sub init_quotes {
    my ($self) = (@_);

    $$self{quotes} ||= '"';
    if ($$self{quotes} eq 'none') {
        $$self{LQUOTE} = $$self{RQUOTE} = '';
    } elsif (length ($$self{quotes}) == 1) {
        $$self{LQUOTE} = $$self{RQUOTE} = $$self{quotes};
    } elsif (length ($$self{quotes}) % 2 == 0) {
        my $length = length ($$self{quotes}) / 2;
        $$self{LQUOTE} = substr ($$self{quotes}, 0, $length);
        $$self{RQUOTE} = substr ($$self{quotes}, $length);
    } else {
        croak(qq(Invalid quote specification "$$self{quotes}"))
    }

    # Double the first quote; note that this should not be s///g as two double
    # quotes is represented in *roff as three double quotes, not four.  Weird,
    # I know.
    $$self{LQUOTE} =~ s/\"/\"\"/;
    $$self{RQUOTE} =~ s/\"/\"\"/;
}

# Initialize the page title information and indentation from our arguments.
sub init_page {
    my ($self) = @_;

    # We used to try first to get the version number from a local binary, but
    # we shouldn't need that any more.  Get the version from the running Perl.
    # Work a little magic to handle subversions correctly under both the
    # pre-5.6 and the post-5.6 version numbering schemes.
    my @version = ($] =~ /^(\d+)\.(\d{3})(\d{0,3})$/);
    $version[2] ||= 0;
    $version[2] *= 10 ** (3 - length $version[2]);
    for (@version) { $_ += 0 }
    my $version = join ('.', @version);

    # Set the defaults for page titles and indentation if the user didn't
    # override anything.
    $$self{center} = 'User Contributed Perl Documentation'
        unless defined $$self{center};
    $$self{release} = 'perl v' . $version
        unless defined $$self{release};
    $$self{indent} = 4
        unless defined $$self{indent};

    # Double quotes in things that will be quoted.
    for (qw/center release/) {
        $$self{$_} =~ s/\"/\"\"/g if $$self{$_};
    }
}

##############################################################################
# Core parsing
##############################################################################

# This is the glue that connects the code below with Pod::Simple itself.  The
# goal is to convert the event stream coming from the POD parser into method
# calls to handlers once the complete content of a tag has been seen.  Each
# paragraph or POD command will have textual content associated with it, and
# as soon as all of a paragraph or POD command has been seen, that content
# will be passed in to the corresponding method for handling that type of
# object.  The exceptions are handlers for lists, which have opening tag
# handlers and closing tag handlers that will be called right away.
#
# The internal hash key PENDING is used to store the contents of a tag until
# all of it has been seen.  It holds a stack of open tags, each one
# represented by a tuple of the attributes hash for the tag, formatting
# options for the tag (which are inherited), and the contents of the tag.

# Add a block of text to the contents of the current node, formatting it
# according to the current formatting instructions as we do.
sub _handle_text {
    my ($self, $text) = @_;
    DEBUG > 3 and print "== $text\n";
    my $tag = $$self{PENDING}[-1];
    $$tag[2] .= $self->format_text ($$tag[1], $text);
}

# Given an element name, get the corresponding method name.
sub method_for_element {
    my ($self, $element) = @_;
    $element =~ tr/A-Z-/a-z_/;
    $element =~ tr/_a-z0-9//cd;
    return $element;
}

# Handle the start of a new element.  If cmd_element is defined, assume that
# we need to collect the entire tree for this element before passing it to the
# element method, and create a new tree into which we'll collect blocks of
# text and nested elements.  Otherwise, if start_element is defined, call it.
sub _handle_element_start {
    my ($self, $element, $attrs) = @_;
    DEBUG > 3 and print "++ $element (<", join ('> <', %$attrs), ">)\n";
    my $method = $self->method_for_element ($element);

    # If we have a command handler, we need to accumulate the contents of the
    # tag before calling it.  Turn off IN_NAME for any command other than
    # <Para> and the formatting codes so that IN_NAME isn't still set for the
    # first heading after the NAME heading.
    if ($self->can ("cmd_$method")) {
        DEBUG > 2 and print "<$element> starts saving a tag\n";
        $$self{IN_NAME} = 0 if ($element ne 'Para' && length ($element) > 1);

        # How we're going to format embedded text blocks depends on the tag
        # and also depends on our parent tags.  Thankfully, inside tags that
        # turn off guesswork and reformatting, nothing else can turn it back
        # on, so this can be strictly inherited.
        my $formatting = {
            %{ $$self{PENDING}[-1][1] || $FORMATTING{DEFAULT} },
            %{ $FORMATTING{$element} || {} },
        };
        push (@{ $$self{PENDING} }, [ $attrs, $formatting, '' ]);
        DEBUG > 4 and print "Pending: [", pretty ($$self{PENDING}), "]\n";
    } elsif (my $start_method = $self->can ("start_$method")) {
        $self->$start_method ($attrs, '');
    } else {
        DEBUG > 2 and print "No $method start method, skipping\n";
    }
}

# Handle the end of an element.  If we had a cmd_ method for this element,
# this is where we pass along the tree that we built.  Otherwise, if we have
# an end_ method for the element, call that.
sub _handle_element_end {
    my ($self, $element) = @_;
    DEBUG > 3 and print "-- $element\n";
    my $method = $self->method_for_element ($element);

    # If we have a command handler, pull off the pending text and pass it to
    # the handler along with the saved attribute hash.
    if (my $cmd_method = $self->can ("cmd_$method")) {
        DEBUG > 2 and print "</$element> stops saving a tag\n";
        my $tag = pop @{ $$self{PENDING} };
        DEBUG > 4 and print "Popped: [", pretty ($tag), "]\n";
        DEBUG > 4 and print "Pending: [", pretty ($$self{PENDING}), "]\n";
        my $text = $self->$cmd_method ($$tag[0], $$tag[2]);
        if (defined $text) {
            if (@{ $$self{PENDING} } > 1) {
                $$self{PENDING}[-1][2] .= $text;
            } else {
                $self->output ($text);
            }
        }
    } elsif (my $end_method = $self->can ("end_$method")) {
        $self->$end_method ();
    } else {
        DEBUG > 2 and print "No $method end method, skipping\n";
    }
}

##############################################################################
# General formatting
##############################################################################

# Format a text block.  Takes a hash of formatting options and the text to
# format.  Currently, the only formatting options are guesswork, cleanup, and
# convert, all of which are boolean.
sub format_text {
    my ($self, $options, $text) = @_;
    my $guesswork = $$options{guesswork} && !$$self{IN_NAME};
    my $cleanup = $$options{cleanup};
    my $convert = $$options{convert};
    my $literal = $$options{literal};

    # Cleanup just tidies up a few things, telling *roff that the hyphens are
    # hard, putting a bit of space between consecutive underscores, and
    # escaping backslashes.  Be careful not to mangle our character
    # translations by doing this before processing character translation.
    if ($cleanup) {
        $text =~ s/\\/\\e/g;
        $text =~ s/-/\\-/g;
        $text =~ s/_(?=_)/_\\|/g;
    }

    # Normally we do character translation, but we won't even do that in
    # <Data> blocks or if UTF-8 output is desired.
    if ($convert && !$$self{utf8} && ASCII) {
        $text =~ s/([^\x00-\x7F])/$ESCAPES{ord ($1)} || "X"/eg;
    }

    # Ensure that *roff doesn't convert literal quotes to UTF-8 single quotes,
    # but don't mess up our accept escapes.
    if ($literal) {
        $text =~ s/(?<!\\\*)\'/\\*\(Aq/g;
        $text =~ s/(?<!\\\*)\`/\\\`/g;
    }

    # If guesswork is asked for, do that.  This involves more substantial
    # formatting based on various heuristics that may only be appropriate for
    # particular documents.
    if ($guesswork) {
        $text = $self->guesswork ($text);
    }

    return $text;
}

# Handles C<> text, deciding whether to put \*C` around it or not.  This is a
# whole bunch of messy heuristics to try to avoid overquoting, originally from
# Barrie Slaymaker.  This largely duplicates similar code in Pod::Text.
sub quote_literal {
    my $self = shift;
    local $_ = shift;

    # A regex that matches the portion of a variable reference that's the
    # array or hash index, separated out just because we want to use it in
    # several places in the following regex.
    my $index = '(?: \[.*\] | \{.*\} )?';

    # If in NAME section, just return an ASCII quoted string to avoid
    # confusing tools like whatis.
    return qq{"$_"} if $$self{IN_NAME};

    # Check for things that we don't want to quote, and if we find any of
    # them, return the string with just a font change and no quoting.
    m{
      ^\s*
      (?:
         ( [\'\`\"] ) .* \1                             # already quoted
       | \\\*\(Aq .* \\\*\(Aq                           # quoted and escaped
       | \\?\` .* ( \' | \\\*\(Aq )                     # `quoted'
       | \$+ [\#^]? \S $index                           # special ($^Foo, $")
       | [\$\@%&*]+ \#? [:\'\w]+ $index                 # plain var or func
       | [\$\@%&*]* [:\'\w]+ (?: -> )? \(\s*[^\s,]\s*\) # 0/1-arg func call
       | [-+]? ( \d[\d.]* | \.\d+ ) (?: [eE][-+]?\d+ )? # a number
       | 0x [a-fA-F\d]+                                 # a hex constant
      )
      \s*\z
     }xso and return '\f(FS' . $_ . '\f(FE';

    # If we didn't return, go ahead and quote the text.
    return '\f(FS\*(C`' . $_ . "\\*(C'\\f(FE";
}

# Takes a text block to perform guesswork on.  Returns the text block with
# formatting codes added.  This is the code that marks up various Perl
# constructs and things commonly used in man pages without requiring the user
# to add any explicit markup, and is applied to all non-literal text.  We're
# guaranteed that the text we're applying guesswork to does not contain any
# *roff formatting codes.  Note that the inserted font sequences must be
# treated later with mapfonts or textmapfonts.
#
# This method is very fragile, both in the regular expressions it uses and in
# the ordering of those modifications.  Care and testing is required when
# modifying it.
sub guesswork {
    my $self = shift;
    local $_ = shift;
    DEBUG > 5 and print "   Guesswork called on [$_]\n";

    # By the time we reach this point, all hyphens will be escaped by adding a
    # backslash.  We want to undo that escaping if they're part of regular
    # words and there's only a single dash, since that's a real hyphen that
    # *roff gets to consider a possible break point.  Make sure that a dash
    # after the first character of a word stays non-breaking, however.
    #
    # Note that this is not user-controllable; we pretty much have to do this
    # transformation or *roff will mangle the output in unacceptable ways.
    s{
        ( (?:\G|^|\s) [\(\"]* [a-zA-Z] ) ( \\- )?
        ( (?: [a-zA-Z\']+ \\-)+ )
        ( [a-zA-Z\']+ ) (?= [\)\".?!,;:]* (?:\s|\Z|\\\ ) )
        \b
    } {
        my ($prefix, $hyphen, $main, $suffix) = ($1, $2, $3, $4);
        $hyphen ||= '';
        $main =~ s/\\-/-/g;
        $prefix . $hyphen . $main . $suffix;
    }egx;

    # Translate "--" into a real em-dash if it's used like one.  This means
    # that it's either surrounded by whitespace, it follows a regular word, or
    # it occurs between two regular words.
    if ($$self{MAGIC_EMDASH}) {
        s{          (\s) \\-\\- (\s)                } { $1 . '\*(--' . $2 }egx;
        s{ (\b[a-zA-Z]+) \\-\\- (\s|\Z|[a-zA-Z]+\b) } { $1 . '\*(--' . $2 }egx;
    }

    # Make words in all-caps a little bit smaller; they look better that way.
    # However, we don't want to change Perl code (like @ARGV), nor do we want
    # to fix the MIME in MIME-Version since it looks weird with the
    # full-height V.
    #
    # We change only a string of all caps (2) either at the beginning of the
    # line or following regular punctuation (like quotes) or whitespace (1),
    # and followed by either similar punctuation, an em-dash, or the end of
    # the line (3).
    #
    # Allow the text we're changing to small caps to include double quotes,
    # commas, newlines, and periods as long as it doesn't otherwise interrupt
    # the string of small caps and still fits the criteria.  This lets us turn
    # entire warranty disclaimers in man page output into small caps.
    if ($$self{MAGIC_SMALLCAPS}) {
        s{
            ( ^ | [\s\(\"\'\`\[\{<>] | \\[ ]  )                     # (1)
            ( [A-Z] [A-Z] (?: [/A-Z+:\d_\$&] | \\- | [.,\"\s] )* )  # (2)
            (?= [\s>\}\]\(\)\'\".?!,;] | \\*\(-- | \\[ ] | $ )      # (3)
        } {
            $1 . '\s-1' . $2 . '\s0'
        }egx;
    }

    # Note that from this point forward, we have to adjust for \s-1 and \s-0
    # strings inserted around things that we've made small-caps if later
    # transforms should work on those strings.

    # Italicize functions in the form func(), including functions that are in
    # all capitals, but don't italize if there's anything between the parens.
    # The function must start with an alphabetic character or underscore and
    # then consist of word characters or colons.
    if ($$self{MAGIC_FUNC}) {
        s{
            ( \b | \\s-1 )
            ( [A-Za-z_] ([:\w] | \\s-?[01])+ \(\) )
        } {
            $1 . '\f(IS' . $2 . '\f(IE'
        }egx;
    }

    # Change references to manual pages to put the page name in italics but
    # the number in the regular font, with a thin space between the name and
    # the number.  Only recognize func(n) where func starts with an alphabetic
    # character or underscore and contains only word characters, periods (for
    # configuration file man pages), or colons, and n is a single digit,
    # optionally followed by some number of lowercase letters.  Note that this
    # does not recognize man page references like perl(l) or socket(3SOCKET).
    if ($$self{MAGIC_MANREF}) {
        s{
            ( \b | \\s-1 )
            ( [A-Za-z_] (?:[.:\w] | \\- | \\s-?[01])+ )
            ( \( \d [a-z]* \) )
        } {
            $1 . '\f(IS' . $2 . '\f(IE\|' . $3
        }egx;
    }

    # Convert simple Perl variable references to a fixed-width font.  Be
    # careful not to convert functions, though; there are too many subtleties
    # with them to want to perform this transformation.
    if ($$self{MAGIC_VARS}) {
        s{
           ( ^ | \s+ )
           ( [\$\@%] [\w:]+ )
           (?! \( )
        } {
            $1 . '\f(FS' . $2 . '\f(FE'
        }egx;
    }

    # Fix up double quotes.  Unfortunately, we miss this transformation if the
    # quoted text contains any code with formatting codes and there's not much
    # we can effectively do about that, which makes it somewhat unclear if
    # this is really a good idea.
    s{ \" ([^\"]+) \" } { '\*(L"' . $1 . '\*(R"' }egx;

    # Make C++ into \*(C+, which is a squinched version.
    if ($$self{MAGIC_CPP}) {
        s{ \b C\+\+ } {\\*\(C+}gx;
    }

    # Done.
    DEBUG > 5 and print "   Guesswork returning [$_]\n";
    return $_;
}

##############################################################################
# Output
##############################################################################

# When building up the *roff code, we don't use real *roff fonts.  Instead, we
# embed font codes of the form \f(<font>[SE] where <font> is one of B, I, or
# F, S stands for start, and E stands for end.  This method turns these into
# the right start and end codes.
#
# We add this level of complexity because the old pod2man didn't get code like
# B<someI<thing> else> right; after I<> it switched back to normal text rather
# than bold.  We take care of this by using variables that state whether bold,
# italic, or fixed are turned on as a combined pointer to our current font
# sequence, and set each to the number of current nestings of start tags for
# that font.
#
# \fP changes to the previous font, but only one previous font is kept.  We
# don't know what the outside level font is; normally it's R, but if we're
# inside a heading it could be something else.  So arrange things so that the
# outside font is always the "previous" font and end with \fP instead of \fR.
# Idea from Zack Weinberg.
sub mapfonts {
    my ($self, $text) = @_;
    my ($fixed, $bold, $italic) = (0, 0, 0);
    my %magic = (F => \$fixed, B => \$bold, I => \$italic);
    my $last = '\fR';
    $text =~ s<
        \\f\((.)(.)
    > <
        my $sequence = '';
        my $f;
        if ($last ne '\fR') { $sequence = '\fP' }
        ${ $magic{$1} } += ($2 eq 'S') ? 1 : -1;
        $f = $$self{FONTS}{ ($fixed && 1) . ($bold && 1) . ($italic && 1) };
        if ($f eq $last) {
            '';
        } else {
            if ($f ne '\fR') { $sequence .= $f }
            $last = $f;
            $sequence;
        }
    >gxe;
    return $text;
}

# Unfortunately, there is a bug in Solaris 2.6 nroff (not present in GNU
# groff) where the sequence \fB\fP\f(CW\fP leaves the font set to B rather
# than R, presumably because \f(CW doesn't actually do a font change.  To work
# around this, use a separate textmapfonts for text blocks where the default
# font is always R and only use the smart mapfonts for headings.
sub textmapfonts {
    my ($self, $text) = @_;
    my ($fixed, $bold, $italic) = (0, 0, 0);
    my %magic = (F => \$fixed, B => \$bold, I => \$italic);
    $text =~ s<
        \\f\((.)(.)
    > <
        ${ $magic{$1} } += ($2 eq 'S') ? 1 : -1;
        $$self{FONTS}{ ($fixed && 1) . ($bold && 1) . ($italic && 1) };
    >gxe;
    return $text;
}

# Given a command and a single argument that may or may not contain double
# quotes, handle double-quote formatting for it.  If there are no double
# quotes, just return the command followed by the argument in double quotes.
# If there are double quotes, use an if statement to test for nroff, and for
# nroff output the command followed by the argument in double quotes with
# embedded double quotes doubled.  For other formatters, remap paired double
# quotes to LQUOTE and RQUOTE.
sub switchquotes {
    my ($self, $command, $text, $extra) = @_;
    $text =~ s/\\\*\([LR]\"/\"/g;

    # We also have to deal with \*C` and \*C', which are used to add the
    # quotes around C<> text, since they may expand to " and if they do this
    # confuses the .SH macros and the like no end.  Expand them ourselves.
    # Also separate troff from nroff if there are any fixed-width fonts in use
    # to work around problems with Solaris nroff.
    my $c_is_quote = ($$self{LQUOTE} =~ /\"/) || ($$self{RQUOTE} =~ /\"/);
    my $fixedpat = join '|', @{ $$self{FONTS} }{'100', '101', '110', '111'};
    $fixedpat =~ s/\\/\\\\/g;
    $fixedpat =~ s/\(/\\\(/g;
    if ($text =~ m/\"/ || $text =~ m/$fixedpat/) {
        $text =~ s/\"/\"\"/g;
        my $nroff = $text;
        my $troff = $text;
        $troff =~ s/\"\"([^\"]*)\"\"/\`\`$1\'\'/g;
        if ($c_is_quote and $text =~ m/\\\*\(C[\'\`]/) {
            $nroff =~ s/\\\*\(C\`/$$self{LQUOTE}/g;
            $nroff =~ s/\\\*\(C\'/$$self{RQUOTE}/g;
            $troff =~ s/\\\*\(C[\'\`]//g;
        }
        $nroff = qq("$nroff") . ($extra ? " $extra" : '');
        $troff = qq("$troff") . ($extra ? " $extra" : '');

        # Work around the Solaris nroff bug where \f(CW\fP leaves the font set
        # to Roman rather than the actual previous font when used in headings.
        # troff output may still be broken, but at least we can fix nroff by
        # just switching the font changes to the non-fixed versions.
        my $font_end = "(?:\\f[PR]|\Q$$self{FONTS}{100}\E)";
        $nroff =~ s/\Q$$self{FONTS}{100}\E(.*?)\\f([PR])/$1/g;
        $nroff =~ s/\Q$$self{FONTS}{101}\E(.*?)$font_end/\\fI$1\\fP/g;
        $nroff =~ s/\Q$$self{FONTS}{110}\E(.*?)$font_end/\\fB$1\\fP/g;
        $nroff =~ s/\Q$$self{FONTS}{111}\E(.*?)$font_end/\\f\(BI$1\\fP/g;

        # Now finally output the command.  Bother with .ie only if the nroff
        # and troff output aren't the same.
        if ($nroff ne $troff) {
            return ".ie n $command $nroff\n.el $command $troff\n";
        } else {
            return "$command $nroff\n";
        }
    } else {
        $text = qq("$text") . ($extra ? " $extra" : '');
        return "$command $text\n";
    }
}

# Protect leading quotes and periods against interpretation as commands.  Also
# protect anything starting with a backslash, since it could expand or hide
# something that *roff would interpret as a command.  This is overkill, but
# it's much simpler than trying to parse *roff here.
sub protect {
    my ($self, $text) = @_;
    $text =~ s/^([.\'\\])/\\&$1/mg;
    return $text;
}

# Make vertical whitespace if NEEDSPACE is set, appropriate to the indentation
# level the situation.  This function is needed since in *roff one has to
# create vertical whitespace after paragraphs and between some things, but
# other macros create their own whitespace.  Also close out a sequence of
# repeated =items, since calling makespace means we're about to begin the item
# body.
sub makespace {
    my ($self) = @_;
    $self->output (".PD\n") if $$self{ITEMS} > 1;
    $$self{ITEMS} = 0;
    $self->output ($$self{INDENT} > 0 ? ".Sp\n" : ".PP\n")
        if $$self{NEEDSPACE};
}

# Output any pending index entries, and optionally an index entry given as an
# argument.  Support multiple index entries in X<> separated by slashes, and
# strip special escapes from index entries.
sub outindex {
    my ($self, $section, $index) = @_;
    my @entries = map { split m%\s*/\s*% } @{ $$self{INDEX} };
    return unless ($section || @entries);

    # We're about to output all pending entries, so clear our pending queue.
    $$self{INDEX} = [];

    # Build the output.  Regular index entries are marked Xref, and headings
    # pass in their own section.  Undo some *roff formatting on headings.
    my @output;
    if (@entries) {
        push @output, [ 'Xref', join (' ', @entries) ];
    }
    if ($section) {
        $index =~ s/\\-/-/g;
        $index =~ s/\\(?:s-?\d|.\(..|.)//g;
        push @output, [ $section, $index ];
    }

    # Print out the .IX commands.
    for (@output) {
        my ($type, $entry) = @$_;
        $entry =~ s/\s+/ /g;
        $entry =~ s/\"/\"\"/g;
        $entry =~ s/\\/\\\\/g;
        $self->output (".IX $type " . '"' . $entry . '"' . "\n");
    }
}

# Output some text, without any additional changes.
sub output {
    my ($self, @text) = @_;
    if ($$self{ENCODE}) {
        print { $$self{output_fh} } Encode::encode ('UTF-8', join ('', @text));
    } else {
        print { $$self{output_fh} } @text;
    }
}

##############################################################################
# Document initialization
##############################################################################

# Handle the start of the document.  Here we handle empty documents, as well
# as setting up our basic macros in a preamble and building the page title.
sub start_document {
    my ($self, $attrs) = @_;
    if ($$attrs{contentless} && !$$self{ALWAYS_EMIT_SOMETHING}) {
        DEBUG and print "Document is contentless\n";
        $$self{CONTENTLESS} = 1;
    } else {
        delete $$self{CONTENTLESS};
    }

    # When UTF-8 output is set, check whether our output file handle already
    # has a PerlIO encoding layer set.  If it does not, we'll need to encode
    # our output before printing it (handled in the output() sub).  Wrap the
    # check in an eval to handle versions of Perl without PerlIO.
    $$self{ENCODE} = 0;
    if ($$self{utf8}) {
        $$self{ENCODE} = 1;
        eval {
            my @options = (output => 1, details => 1);
            my $flag = (PerlIO::get_layers ($$self{output_fh}, @options))[-1];
            if ($flag & PerlIO::F_UTF8 ()) {
                $$self{ENCODE} = 0;
            }
        }
    }

    # Determine information for the preamble and then output it unless the
    # document was content-free.
    if (!$$self{CONTENTLESS}) {
        my ($name, $section);
        if (defined $$self{name}) {
            $name = $$self{name};
            $section = $$self{section} || 1;
        } else {
            ($name, $section) = $self->devise_title;
        }
        my $date = defined($$self{date}) ? $$self{date} : $self->devise_date;
        $self->preamble ($name, $section, $date)
            unless $self->bare_output or DEBUG > 9;
    }

    # Initialize a few per-document variables.
    $$self{INDENT}    = 0;      # Current indentation level.
    $$self{INDENTS}   = [];     # Stack of indentations.
    $$self{INDEX}     = [];     # Index keys waiting to be printed.
    $$self{IN_NAME}   = 0;      # Whether processing the NAME section.
    $$self{ITEMS}     = 0;      # The number of consecutive =items.
    $$self{ITEMTYPES} = [];     # Stack of =item types, one per list.
    $$self{SHIFTWAIT} = 0;      # Whether there is a shift waiting.
    $$self{SHIFTS}    = [];     # Stack of .RS shifts.
    $$self{PENDING}   = [[]];   # Pending output.
}

# Handle the end of the document.  This handles dying on POD errors, since
# Pod::Parser currently doesn't.  Otherwise, does nothing but print out a
# final comment at the end of the document under debugging.
sub end_document {
    my ($self) = @_;
    if ($$self{complain_die} && $self->errors_seen) {
        croak ("POD document had syntax errors");
    }
    return if $self->bare_output;
    return if ($$self{CONTENTLESS} && !$$self{ALWAYS_EMIT_SOMETHING});
    $self->output (q(.\" [End document]) . "\n") if DEBUG;
}

# Try to figure out the name and section from the file name and return them as
# a list, returning an empty name and section 1 if we can't find any better
# information.  Uses File::Basename and File::Spec as necessary.
sub devise_title {
    my ($self) = @_;
    my $name = $self->source_filename || '';
    my $section = $$self{section} || 1;
    $section = 3 if (!$$self{section} && $name =~ /\.pm\z/i);
    $name =~ s/\.p(od|[lm])\z//i;

    # If Pod::Parser gave us an IO::File reference as the source file name,
    # convert that to the empty string as well.  Then, if we don't have a
    # valid name, emit a warning and convert it to STDIN.
    if ($name =~ /^IO::File(?:=\w+)\(0x[\da-f]+\)$/i) {
        $name = '';
    }
    if ($name eq '') {
        $self->whine (1, 'No name given for document');
        $name = 'STDIN';
    }

    # If the section isn't 3, then the name defaults to just the basename of
    # the file.
    if ($section !~ /^3/) {
        require File::Basename;
        $name = uc File::Basename::basename ($name);
    } else {
        require File::Spec;
        my ($volume, $dirs, $file) = File::Spec->splitpath ($name);

        # Otherwise, assume we're dealing with a module.  We want to figure
        # out the full module name from the path to the file, but we don't
        # want to include too much of the path into the module name.  Lose
        # anything up to the first of:
        #
        #     */lib/*perl*/         standard or site_perl module
        #     */*perl*/lib/         from -Dprefix=/opt/perl
        #     */*perl*/             random module hierarchy
        #
        # Also strip off a leading site, site_perl, or vendor_perl component,
        # any OS-specific component, and any version number component, and
        # strip off an initial component of "lib" or "blib/lib" since that's
        # what ExtUtils::MakeMaker creates.
        #
        # splitdir requires at least File::Spec 0.8.
        my @dirs = File::Spec->splitdir ($dirs);
        if (@dirs) {
            my $cut = 0;
            my $i;
            for ($i = 0; $i < @dirs; $i++) {
                if ($dirs[$i] =~ /perl/) {
                    $cut = $i + 1;
                    $cut++ if ($dirs[$i + 1] && $dirs[$i + 1] eq 'lib');
                    last;
                }
            }
            if ($cut > 0) {
                splice (@dirs, 0, $cut);
                shift @dirs if ($dirs[0] =~ /^(site|vendor)(_perl)?$/);
                shift @dirs if ($dirs[0] =~ /^[\d.]+$/);
                shift @dirs if ($dirs[0] =~ /^(.*-$^O|$^O-.*|$^O)$/);
            }
            shift @dirs if $dirs[0] eq 'lib';
            splice (@dirs, 0, 2) if ($dirs[0] eq 'blib' && $dirs[1] eq 'lib');
        }

        # Remove empty directories when building the module name; they
        # occur too easily on Unix by doubling slashes.
        $name = join ('::', (grep { $_ ? $_ : () } @dirs), $file);
    }
    return ($name, $section);
}

# Determine the modification date and return that, properly formatted in ISO
# format.
#
# If POD_MAN_DATE is set, that overrides anything else.  This can be used for
# reproducible generation of the same file even if the input file timestamps
# are unpredictable or the POD coms from standard input.
#
# Otherwise, if SOURCE_DATE_EPOCH is set and can be parsed as seconds since
# the UNIX epoch, base the timestamp on that.  See
# <https://reproducible-builds.org/specs/source-date-epoch/>
#
# Otherwise, use the modification date of the input if we can stat it.  Be
# aware that Pod::Simple returns the stringification of the file handle as
# source_filename for input from a file handle, so we'll stat some random ref
# string in that case.  If that fails, instead use the current time.
#
# $self - Pod::Man object, used to get the source file
#
# Returns: YYYY-MM-DD date suitable for the left-hand footer
sub devise_date {
    my ($self) = @_;

    # If POD_MAN_DATE is set, always use it.
    if (defined($ENV{POD_MAN_DATE})) {
        return $ENV{POD_MAN_DATE};
    }

    # If SOURCE_DATE_EPOCH is set and can be parsed, use that.
    my $time;
    if (defined($ENV{SOURCE_DATE_EPOCH}) && $ENV{SOURCE_DATE_EPOCH} !~ /\D/) {
        $time = $ENV{SOURCE_DATE_EPOCH};
    }

    # Otherwise, get the input filename and try to stat it.  If that fails,
    # use the current time.
    if (!defined $time) {
        my $input = $self->source_filename;
        if ($input) {
            $time = (stat($input))[9] || time();
        } else {
            $time = time();
        }
    }

    # Can't use POSIX::strftime(), which uses Fcntl, because MakeMaker uses
    # this and it has to work in the core which can't load dynamic libraries.
    # Use gmtime instead of localtime so that the generated man page does not
    # depend on the local time zone setting and is more reproducible
    my ($year, $month, $day) = (gmtime($time))[5,4,3];
    return sprintf("%04d-%02d-%02d", $year + 1900, $month + 1, $day);
}

# Print out the preamble and the title.  The meaning of the arguments to .TH
# unfortunately vary by system; some systems consider the fourth argument to
# be a "source" and others use it as a version number.  Generally it's just
# presented as the left-side footer, though, so it doesn't matter too much if
# a particular system gives it another interpretation.
#
# The order of date and release used to be reversed in older versions of this
# module, but this order is correct for both Solaris and Linux.
sub preamble {
    my ($self, $name, $section, $date) = @_;
    my $preamble = $self->preamble_template (!$$self{utf8});

    # Build the index line and make sure that it will be syntactically valid.
    my $index = "$name $section";
    $index =~ s/\"/\"\"/g;

    # If name or section contain spaces, quote them (section really never
    # should, but we may as well be cautious).
    for ($name, $section) {
        if (/\s/) {
            s/\"/\"\"/g;
            $_ = '"' . $_ . '"';
        }
    }

    # Double quotes in date, since it will be quoted.
    $date =~ s/\"/\"\"/g;

    # Substitute into the preamble the configuration options.
    $preamble =~ s/\@CFONT\@/$$self{fixed}/;
    $preamble =~ s/\@LQUOTE\@/$$self{LQUOTE}/;
    $preamble =~ s/\@RQUOTE\@/$$self{RQUOTE}/;
    chomp $preamble;

    # Get the version information.
    my $version = $self->version_report;

    # Finally output everything.
    $self->output (<<"----END OF HEADER----");
.\\" Automatically generated by $version
.\\"
.\\" Standard preamble:
.\\" ========================================================================
$preamble
.\\" ========================================================================
.\\"
.IX Title "$index"
.TH $name $section "$date" "$$self{release}" "$$self{center}"
.\\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\\" way too many mistakes in technical documents.
.if n .ad l
.nh
----END OF HEADER----
    $self->output (".\\\" [End of preamble]\n") if DEBUG;
}

##############################################################################
# Text blocks
##############################################################################

# Handle a basic block of text.  The only tricky part of this is if this is
# the first paragraph of text after an =over, in which case we have to change
# indentations for *roff.
sub cmd_para {
    my ($self, $attrs, $text) = @_;
    my $line = $$attrs{start_line};

    # Output the paragraph.  We also have to handle =over without =item.  If
    # there's an =over without =item, SHIFTWAIT will be set, and we need to
    # handle creation of the indent here.  Add the shift to SHIFTS so that it
    # will be cleaned up on =back.
    $self->makespace;
    if ($$self{SHIFTWAIT}) {
        $self->output (".RS $$self{INDENT}\n");
        push (@{ $$self{SHIFTS} }, $$self{INDENT});
        $$self{SHIFTWAIT} = 0;
    }

    # Add the line number for debugging, but not in the NAME section just in
    # case the comment would confuse apropos.
    $self->output (".\\\" [At source line $line]\n")
        if defined ($line) && DEBUG && !$$self{IN_NAME};

    # Force exactly one newline at the end and strip unwanted trailing
    # whitespace at the end, but leave "\ " backslashed space from an S< > at
    # the end of a line.  Reverse the text first, to avoid having to scan the
    # entire paragraph.
    $text = reverse $text;
    $text =~ s/\A\s*?(?= \\|\S|\z)/\n/;
    $text = reverse $text;

    # Output the paragraph.
    $self->output ($self->protect ($self->textmapfonts ($text)));
    $self->outindex;
    $$self{NEEDSPACE} = 1;
    return '';
}

# Handle a verbatim paragraph.  Put a null token at the beginning of each line
# to protect against commands and wrap in .Vb/.Ve (which we define in our
# prelude).
sub cmd_verbatim {
    my ($self, $attrs, $text) = @_;

    # Ignore an empty verbatim paragraph.
    return unless $text =~ /\S/;

    # Force exactly one newline at the end and strip unwanted trailing
    # whitespace at the end.  Reverse the text first, to avoid having to scan
    # the entire paragraph.
    $text = reverse $text;
    $text =~ s/\A\s*/\n/;
    $text = reverse $text;

    # Get a count of the number of lines before the first blank line, which
    # we'll pass to .Vb as its parameter.  This tells *roff to keep that many
    # lines together.  We don't want to tell *roff to keep huge blocks
    # together.
    my @lines = split (/\n/, $text);
    my $unbroken = 0;
    for (@lines) {
        last if /^\s*$/;
        $unbroken++;
    }
    $unbroken = 10 if ($unbroken > 12 && !$$self{MAGIC_VNOPAGEBREAK_LIMIT});

    # Prepend a null token to each line.
    $text =~ s/^/\\&/gm;

    # Output the results.
    $self->makespace;
    $self->output (".Vb $unbroken\n$text.Ve\n");
    $$self{NEEDSPACE} = 1;
    return '';
}

# Handle literal text (produced by =for and similar constructs).  Just output
# it with the minimum of changes.
sub cmd_data {
    my ($self, $attrs, $text) = @_;
    $text =~ s/^\n+//;
    $text =~ s/\n{0,2}$/\n/;
    $self->output ($text);
    return '';
}

##############################################################################
# Headings
##############################################################################

# Common code for all headings.  This is called before the actual heading is
# output.  It returns the cleaned up heading text (putting the heading all o