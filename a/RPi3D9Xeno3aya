/* -*- buffer-read-only: t -*-
 *
 *    proto.h
 *
 *    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
 *    2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 * !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
 * This file is built by regen/embed.pl from data in embed.fnc,
 * regen/embed.pl, regen/opcodes, intrpvar.h and perlvars.h.
 * Any changes made here will be lost!
 *
 * Edit those files and run 'make regen_headers' to effect changes.
 */

START_EXTERN_C
PERL_CALLCONV UV	ASCII_TO_NEED(const UV enc, const UV ch)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV int	Perl_Gv_AMupdate(pTHX_ HV* stash, bool destructing);
#define PERL_ARGS_ASSERT_GV_AMUPDATE	\
	assert(stash)
PERL_CALLCONV UV	NATIVE_TO_NEED(const UV enc, const UV ch)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV const char *	Perl_PerlIO_context_layers(pTHX_ const char *mode);
PERL_CALLCONV void*	Perl_Slab_Alloc(pTHX_ size_t sz)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV void	Perl_Slab_Free(pTHX_ void *op);
#define PERL_ARGS_ASSERT_SLAB_FREE	\
	assert(op)
PERL_CALLCONV SV*	Perl__get_encoding(pTHX)
			__attribute__pure__;

PERL_CALLCONV bool	Perl__is_in_locale_category(pTHX_ const bool compiling, const int category);
PERL_CALLCONV bool	Perl__is_uni_FOO(pTHX_ const U8 classnum, const UV c)
			__attribute__warn_unused_result__;

PERL_CALLCONV bool	Perl__is_uni_perl_idcont(pTHX_ UV c)
			__attribute__warn_unused_result__;

PERL_CALLCONV bool	Perl__is_uni_perl_idstart(pTHX_ UV c)
			__attribute__warn_unused_result__;

PERL_CALLCONV bool	Perl__is_utf8_FOO(pTHX_ const U8 classnum, const U8 *p)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT__IS_UTF8_FOO	\
	assert(p)

PERL_CALLCONV bool	Perl__is_utf8_idcont(pTHX_ const U8 *p)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT__IS_UTF8_IDCONT	\
	assert(p)

PERL_CALLCONV bool	Perl__is_utf8_idstart(pTHX_ const U8 *p)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT__IS_UTF8_IDSTART	\
	assert(p)

PERL_CALLCONV bool	Perl__is_utf8_mark(pTHX_ const U8 *p)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT__IS_UTF8_MARK	\
	assert(p)

PERL_CALLCONV bool	Perl__is_utf8_perl_idcont(pTHX_ const U8 *p)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT__IS_UTF8_PERL_IDCONT	\
	assert(p)

PERL_CALLCONV bool	Perl__is_utf8_perl_idstart(pTHX_ const U8 *p)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT__IS_UTF8_PERL_IDSTART	\
	assert(p)

PERL_CALLCONV bool	Perl__is_utf8_xidcont(pTHX_ const U8 *p)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT__IS_UTF8_XIDCONT	\
	assert(p)

PERL_CALLCONV bool	Perl__is_utf8_xidstart(pTHX_ const U8 *p)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT__IS_UTF8_XIDSTART	\
	assert(p)

PERL_CALLCONV UV	Perl__to_uni_fold_flags(pTHX_ UV c, U8 *p, STRLEN *lenp, U8 flags);
#define PERL_ARGS_ASSERT__TO_UNI_FOLD_FLAGS	\
	assert(p); assert(lenp)
PERL_CALLCONV UV	Perl__to_utf8_fold_flags(pTHX_ const U8 *p, U8* ustrp, STRLEN *lenp, U8 flags);
#define PERL_ARGS_ASSERT__TO_UTF8_FOLD_FLAGS	\
	assert(p); assert(ustrp)
PERL_CALLCONV UV	Perl__to_utf8_lower_flags(pTHX_ const U8 *p, U8* ustrp, STRLEN *lenp, bool flags);
#define PERL_ARGS_ASSERT__TO_UTF8_LOWER_FLAGS	\
	assert(p); assert(ustrp)
PERL_CALLCONV UV	Perl__to_utf8_title_flags(pTHX_ const U8 *p, U8* ustrp, STRLEN *lenp, bool flags);
#define PERL_ARGS_ASSERT__TO_UTF8_TITLE_FLAGS	\
	assert(p); assert(ustrp)
PERL_CALLCONV UV	Perl__to_utf8_upper_flags(pTHX_ const U8 *p, U8* ustrp, STRLEN *lenp, bool flags);
#define PERL_ARGS_ASSERT__TO_UTF8_UPPER_FLAGS	\
	assert(p); assert(ustrp)
PERL_CALLCONV void	Perl__warn_problematic_locale(void);
PERL_CALLCONV PADOFFSET	Perl_allocmy(pTHX_ const char *const name, const STRLEN len, const U32 flags);
#define PERL_ARGS_ASSERT_ALLOCMY	\
	assert(name)
PERL_CALLCONV SV*	Perl_amagic_call(pTHX_ SV* left, SV* right, int method, int dir);
#define PERL_ARGS_ASSERT_AMAGIC_CALL	\
	assert(left); assert(right)
PERL_CALLCONV SV *	Perl_amagic_deref_call(pTHX_ SV *ref, int method);
#define PERL_ARGS_ASSERT_AMAGIC_DEREF_CALL	\
	assert(ref)
PERL_CALLCONV bool	Perl_amagic_is_enabled(pTHX_ int method);
PERL_CALLCONV I32	Perl_apply(pTHX_ I32 type, SV** mark, SV** sp);
#define PERL_ARGS_ASSERT_APPLY	\
	assert(mark); assert(sp)
PERL_CALLCONV void	Perl_apply_attrs_string(pTHX_ const char *stashpv, CV *cv, const char *attrstr, STRLEN len);
#define PERL_ARGS_ASSERT_APPLY_ATTRS_STRING	\
	assert(stashpv); assert(cv); assert(attrstr)
PERL_CALLCONV void	Perl_atfork_lock(void);
PERL_CALLCONV void	Perl_atfork_unlock(void);
PERL_CALLCONV SV**	Perl_av_arylen_p(pTHX_ AV *av);
#define PERL_ARGS_ASSERT_AV_ARYLEN_P	\
	assert(av)
PERL_CALLCONV void	Perl_av_clear(pTHX_ AV *av);
#define PERL_ARGS_ASSERT_AV_CLEAR	\
	assert(av)
PERL_CALLCONV void	Perl_av_create_and_push(pTHX_ AV **const avp, SV *const val);
#define PERL_ARGS_ASSERT_AV_CREATE_AND_PUSH	\
	assert(avp); assert(val)
PERL_CALLCONV SV**	Perl_av_create_and_unshift_one(pTHX_ AV **const avp, SV *const val);
#define PERL_ARGS_ASSERT_AV_CREATE_AND_UNSHIFT_ONE	\
	assert(avp); assert(val)
PERL_CALLCONV SV*	Perl_av_delete(pTHX_ AV *av, SSize_t key, I32 flags);
#define PERL_ARGS_ASSERT_AV_DELETE	\
	assert(av)
PERL_CALLCONV bool	Perl_av_exists(pTHX_ AV *av, SSize_t key)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_AV_EXISTS	\
	assert(av)

PERL_CALLCONV void	Perl_av_extend(pTHX_ AV *av, SSize_t key);
#define PERL_ARGS_ASSERT_AV_EXTEND	\
	assert(av)
PERL_CALLCONV void	Perl_av_extend_guts(pTHX_ AV *av, SSize_t key, SSize_t *maxp, SV ***allocp, SV ***arrayp);
#define PERL_ARGS_ASSERT_AV_EXTEND_GUTS	\
	assert(maxp); assert(allocp); assert(arrayp)
PERL_CALLCONV SV**	Perl_av_fetch(pTHX_ AV *av, SSize_t key, I32 lval)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_AV_FETCH	\
	assert(av)

PERL_CALLCONV void	Perl_av_fill(pTHX_ AV *av, SSize_t fill);
#define PERL_ARGS_ASSERT_AV_FILL	\
	assert(av)
PERL_CALLCONV IV*	Perl_av_iter_p(pTHX_ AV *av);
#define PERL_ARGS_ASSERT_AV_ITER_P	\
	assert(av)
PERL_CALLCONV SSize_t	Perl_av_len(pTHX_ AV *av)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_AV_LEN	\
	assert(av)

PERL_CALLCONV AV*	Perl_av_make(pTHX_ SSize_t size, SV **strp)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_AV_MAKE	\
	assert(strp)

PERL_CALLCONV SV*	Perl_av_pop(pTHX_ AV *av);
#define PERL_ARGS_ASSERT_AV_POP	\
	assert(av)
PERL_CALLCONV void	Perl_av_push(pTHX_ AV *av, SV *val);
#define PERL_ARGS_ASSERT_AV_PUSH	\
	assert(av); assert(val)
PERL_CALLCONV void	Perl_av_reify(pTHX_ AV *av);
#define PERL_ARGS_ASSERT_AV_REIFY	\
	assert(av)
PERL_CALLCONV SV*	Perl_av_shift(pTHX_ AV *av)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_AV_SHIFT	\
	assert(av)

PERL_CALLCONV SV**	Perl_av_store(pTHX_ AV *av, SSize_t key, SV *val);
#define PERL_ARGS_ASSERT_AV_STORE	\
	assert(av)
/* PERL_CALLCONV SSize_t	Perl_av_tindex(pTHX_ AV *av)
			__attribute__warn_unused_result__; */

PERL_CALLCONV void	Perl_av_undef(pTHX_ AV *av);
#define PERL_ARGS_ASSERT_AV_UNDEF	\
	assert(av)
PERL_CALLCONV void	Perl_av_unshift(pTHX_ AV *av, SSize_t num);
#define PERL_ARGS_ASSERT_AV_UNSHIFT	\
	assert(av)
PERL_CALLCONV OP*	Perl_bind_match(pTHX_ I32 type, OP *left, OP *right)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_BIND_MATCH	\
	assert(left); assert(right)

PERL_CALLCONV OP*	Perl_block_end(pTHX_ I32 floor, OP* seq)
			__attribute__warn_unused_result__;

PERL_CALLCONV U8	Perl_block_gimme(pTHX)
			__attribute__warn_unused_result__;

PERL_CALLCONV int	Perl_block_start(pTHX_ int full)
			__attribute__warn_unused_result__;

PERL_CALLCONV void	Perl_blockhook_register(pTHX_ BHK *hk);
#define PERL_ARGS_ASSERT_BLOCKHOOK_REGISTER	\
	assert(hk)
PERL_CALLCONV void	Perl_boot_core_PerlIO(pTHX);
PERL_CALLCONV void	Perl_boot_core_UNIVERSAL(pTHX);
PERL_CALLCONV void	Perl_boot_core_mro(pTHX);
PERL_CALLCONV int	Perl_bytes_cmp_utf8(pTHX_ const U8 *b, STRLEN blen, const U8 *u, STRLEN ulen);
#define PERL_ARGS_ASSERT_BYTES_CMP_UTF8	\
	assert(b); assert(u)
PERL_CALLCONV U8*	Perl_bytes_from_utf8(pTHX_ const U8 *s, STRLEN *len, bool *is_utf8);
#define PERL_ARGS_ASSERT_BYTES_FROM_UTF8	\
	assert(s); assert(len)
PERL_CALLCONV U8*	Perl_bytes_to_utf8(pTHX_ const U8 *s, STRLEN *len);
#define PERL_ARGS_ASSERT_BYTES_TO_UTF8	\
	assert(s); assert(len)
PERL_CALLCONV I32	Perl_call_argv(pTHX_ const char* sub_name, I32 flags, char** argv);
#define PERL_ARGS_ASSERT_CALL_ARGV	\
	assert(sub_name); assert(argv)
PERL_CALLCONV void	Perl_call_atexit(pTHX_ ATEXIT_t fn, void *ptr);
PERL_CALLCONV void	Perl_call_list(pTHX_ I32 oldscope, AV *paramList);
#define PERL_ARGS_ASSERT_CALL_LIST	\
	assert(paramList)
PERL_CALLCONV I32	Perl_call_method(pTHX_ const char* methname, I32 flags);
#define PERL_ARGS_ASSERT_CALL_METHOD	\
	assert(methname)
PERL_CALLCONV I32	Perl_call_pv(pTHX_ const char* sub_name, I32 flags);
#define PERL_ARGS_ASSERT_CALL_PV	\
	assert(sub_name)
PERL_CALLCONV I32	Perl_call_sv(pTHX_ SV* sv, VOL I32 flags);
#define PERL_ARGS_ASSERT_CALL_SV	\
	assert(sv)
PERL_CALLCONV const PERL_CONTEXT *	Perl_caller_cx(pTHX_ I32 level, const PERL_CONTEXT **dbcxp);
PERL_CALLCONV Malloc_t	Perl_calloc(MEM_SIZE elements, MEM_SIZE size)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV bool	Perl_cando(pTHX_ Mode_t mode, bool effective, const Stat_t* statbufp)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_CANDO	\
	assert(statbufp)

PERL_CALLCONV I32	Perl_cast_i32(NV f)
			__attribute__warn_unused_result__;

PERL_CALLCONV IV	Perl_cast_iv(NV f)
			__attribute__warn_unused_result__;

PERL_CALLCONV U32	Perl_cast_ulong(NV f)
			__attribute__warn_unused_result__;

PERL_CALLCONV UV	Perl_cast_uv(NV f)
			__attribute__warn_unused_result__;

PERL_CALLCONV bool	Perl_check_utf8_print(pTHX_ const U8 *s, const STRLEN len);
#define PERL_ARGS_ASSERT_CHECK_UTF8_PRINT	\
	assert(s)
PERL_CALLCONV OP *	Perl_ck_anoncode(pTHX_ OP *o)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_CK_ANONCODE	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_backtick(pTHX_ OP *o)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_CK_BACKTICK	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_bitop(pTHX_ OP *o)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_CK_BITOP	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_cmp(pTHX_ OP *o)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_CK_CMP	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_concat(pTHX_ OP *o)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_CK_CONCAT	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_defined(pTHX_ OP *o)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_CK_DEFINED	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_delete(pTHX_ OP *o)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_CK_DELETE	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_each(pTHX_ OP *o)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_CK_EACH	\
	assert(o)

PERL_CALLCONV OP*	Perl_ck_entersub_args_core(pTHX_ OP *entersubop, GV *namegv, SV *protosv);
#define PERL_ARGS_ASSERT_CK_ENTERSUB_ARGS_CORE	\
	assert(entersubop); assert(namegv); assert(protosv)
PERL_CALLCONV OP*	Perl_ck_entersub_args_list(pTHX_ OP *entersubop);
#define PERL_ARGS_ASSERT_CK_ENTERSUB_ARGS_LIST	\
	assert(entersubop)
PERL_CALLCONV OP*	Perl_ck_entersub_args_proto(pTHX_ OP *entersubop, GV *namegv, SV *protosv);
#define PERL_ARGS_ASSERT_CK_ENTERSUB_ARGS_PROTO	\
	assert(entersubop); assert(namegv); assert(protosv)
PERL_CALLCONV OP*	Perl_ck_entersub_args_proto_or_list(pTHX_ OP *entersubop, GV *namegv, SV *protosv);
#define PERL_ARGS_ASSERT_CK_ENTERSUB_ARGS_PROTO_OR_LIST	\
	assert(entersubop); assert(namegv); assert(protosv)
PERL_CALLCONV OP *	Perl_ck_eof(pTHX_ OP *o)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_CK_EOF	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_eval(pTHX_ OP *o)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_CK_EVAL	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_exec(pTHX_ OP *o)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_CK_EXEC	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_exists(pTHX_ OP *o)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_CK_EXISTS	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_ftst(pTHX_ OP *o)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_CK_FTST	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_fun(pTHX_ OP *o)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_CK_FUN	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_glob(pTHX_ OP *o)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_CK_GLOB	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_grep(pTHX_ OP *o)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_CK_GREP	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_index(pTHX_ OP *o)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_CK_INDEX	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_join(pTHX_ OP *o)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_CK_JOIN	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_length(pTHX_ OP *o)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_CK_LENGTH	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_lfun(pTHX_ OP *o)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_CK_LFUN	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_listiob(pTHX_ OP *o)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_CK_LISTIOB	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_match(pTHX_ OP *o)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_CK_MATCH	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_method(pTHX_ OP *o)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_CK_METHOD	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_null(pTHX_ OP *o)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_CK_NULL	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_open(pTHX_ OP *o)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_CK_OPEN	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_prototype(pTHX_ OP *o)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_CK_PROTOTYPE	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_readline(pTHX_ OP *o)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_CK_READLINE	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_refassign(pTHX_ OP *o)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_CK_REFASSIGN	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_repeat(pTHX_ OP *o)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_CK_REPEAT	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_require(pTHX_ OP *o)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_CK_REQUIRE	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_return(pTHX_ OP *o)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_CK_RETURN	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_rfun(pTHX_ OP *o)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_CK_RFUN	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_rvconst(pTHX_ OP *o)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_CK_RVCONST	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_sassign(pTHX_ OP *o)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_CK_SASSIGN	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_select(pTHX_ OP *o)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_CK_SELECT	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_shift(pTHX_ OP *o)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_CK_SHIFT	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_smartmatch(pTHX_ OP *o)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_CK_SMARTMATCH	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_sort(pTHX_ OP *o)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_CK_SORT	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_spair(pTHX_ OP *o)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_CK_SPAIR	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_split(pTHX_ OP *o)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_CK_SPLIT	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_stringify(pTHX_ OP *o)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_CK_STRINGIFY	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_subr(pTHX_ OP *o)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_CK_SUBR	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_substr(pTHX_ OP *o)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_CK_SUBSTR	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_svconst(pTHX_ OP *o)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_CK_SVCONST	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_tell(pTHX_ OP *o)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_CK_TELL	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_trunc(pTHX_ OP *o)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_CK_TRUNC	\
	assert(o)

PERL_CALLCONV void	Perl_ck_warner(pTHX_ U32 err, const char* pat, ...)
			__attribute__format__(__printf__,pTHX_2,pTHX_3);
#define PERL_ARGS_ASSERT_CK_WARNER	\
	assert(pat)

PERL_CALLCONV void	Perl_ck_warner_d(pTHX_ U32 err, const char* pat, ...)
			__attribute__format__(__printf__,pTHX_2,pTHX_3);
#define PERL_ARGS_ASSERT_CK_WARNER_D	\
	assert(pat)

PERL_CALLCONV bool	Perl_ckwarn(pTHX_ U32 w);
PERL_CALLCONV bool	Perl_ckwarn_d(pTHX_ U32 w);
PERL_CALLCONV void	Perl_clear_defarray(pTHX_ AV* av, bool abandon);
#define PERL_ARGS_ASSERT_CLEAR_DEFARRAY	\
	assert(av)
PERL_CALLCONV const COP*	Perl_closest_cop(pTHX_ const COP *cop, const OP *o, const OP *curop, bool opnext);
#define PERL_ARGS_ASSERT_CLOSEST_COP	\
	assert(cop)
PERL_CALLCONV const char *	Perl_cop_fetch_label(pTHX_ COP *const cop, STRLEN *len, U32 *flags);
#define PERL_ARGS_ASSERT_COP_FETCH_LABEL	\
	assert(cop)
PERL_CALLCONV void	Perl_cop_store_label(pTHX_ COP *const cop, const char *label, STRLEN len, U32 flags);
#define PERL_ARGS_ASSERT_COP_STORE_LABEL	\
	assert(cop); assert(label)
PERL_CALLCONV SV *	Perl_core_prototype(pTHX_ SV *sv, const char *name, const int code, int * const opnum);
#define PERL_ARGS_ASSERT_CORE_PROTOTYPE	\
	assert(name)
PERL_CALLCONV OP *	Perl_coresub_op(pTHX_ SV *const coreargssv, const int code, const int opnum);
#define PERL_ARGS_ASSERT_CORESUB_OP	\
	assert(coreargssv)
PERL_CALLCONV void	Perl_create_eval_scope(pTHX_ OP *retop, U32 flags);
PERL_CALLCONV_NO_RET void	Perl_croak(pTHX_ const char* pat, ...)
			__attribute__noreturn__
			__attribute__format__null_ok__(__printf__,pTHX_1,pTHX_2);

PERL_STATIC_NO_RET void	S_croak_memory_wrap(void)
			__attribute__noreturn__;

PERL_CALLCONV_NO_RET void	Perl_croak_no_mem(void)
			__attribute__noreturn__;

PERL_CALLCONV_NO_RET void	Perl_croak_no_modify(void)
			__attribute__noreturn__;

PERL_CALLCONV_NO_RET void	Perl_croak_popstack(void)
			__attribute__noreturn__;

PERL_CALLCONV_NO_RET void	Perl_croak_sv(pTHX_ SV *baseex)
			__attribute__noreturn__;
#define PERL_ARGS_ASSERT_CROAK_SV	\
	assert(baseex)

PERL_CALLCONV_NO_RET void	Perl_croak_xs_usage(const CV *const cv, const char *const params)
			__attribute__noreturn__;
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE	\
	assert(cv); assert(params)

PERL_CALLCONV regexp_engine const *	Perl_current_re_engine(pTHX);
PERL_CALLCONV const char *	Perl_custom_op_desc(pTHX_ const OP *o)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_CUSTOM_OP_DESC	\
	assert(o)

PERL_CALLCONV XOPRETANY	Perl_custom_op_get_field(pTHX_ const OP *o, const xop_flags_enum field)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_CUSTOM_OP_GET_FIELD	\
	assert(o)

PERL_CALLCONV const char *	Perl_custom_op_name(pTHX_ const OP *o)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_CUSTOM_OP_NAME	\
	assert(o)

PERL_CALLCONV void	Perl_custom_op_register(pTHX_ Perl_ppaddr_t ppaddr, const XOP *xop);
#define PERL_ARGS_ASSERT_CUSTOM_OP_REGISTER	\
	assert(ppaddr); assert(xop)
/* PERL_CALLCONV const XOP *	Perl_custom_op_xop(pTHX_ const OP *o)
			__attribute__pure__; */

PERL_CALLCONV void	Perl_cv_ckproto_len_flags(pTHX_ const CV* cv, const GV* gv, const char* p, const STRLEN len, const U32 flags);
#define PERL_ARGS_ASSERT_CV_CKPROTO_LEN_FLAGS	\
	assert(cv)
PERL_CALLCONV CV*	Perl_cv_clone(pTHX_ CV* proto);
#define PERL_ARGS_ASSERT_CV_CLONE	\
	assert(proto)
PERL_CALLCONV CV*	Perl_cv_clone_into(pTHX_ CV* proto, CV *target);
#define PERL_ARGS_ASSERT_CV_CLONE_INTO	\
	assert(proto); assert(target)
PERL_CALLCONV SV*	Perl_cv_const_sv(const CV *const cv)
			__attribute__warn_unused_result__;

PERL_CALLCONV SV*	Perl_cv_const_sv_or_av(const CV *const cv)
			__attribute__warn_unused_result__;

PERL_CALLCONV void	Perl_cv_forget_slab(pTHX_ CV *cv);
PERL_CALLCONV void	Perl_cv_get_call_checker(pTHX_ CV *cv, Perl_call_checker *ckfun_p, SV **ckobj_p);
#define PERL_ARGS_ASSERT_CV_GET_CALL_CHECKER	\
	assert(cv); assert(ckfun_p); assert(ckobj_p)
PERL_CALLCONV SV *	Perl_cv_name(pTHX_ CV *cv, SV *sv, U32 flags);
#define PERL_ARGS_ASSERT_CV_NAME	\
	assert(cv)
PERL_CALLCONV void	Perl_cv_set_call_checker(pTHX_ CV *cv, Perl_call_checker ckfun, SV *ckobj);
#define PERL_ARGS_ASSERT_CV_SET_CALL_CHECKER	\
	assert(cv); assert(ckfun); assert(ckobj)
PERL_CALLCONV void	Perl_cv_set_call_checker_flags(pTHX_ CV *cv, Perl_call_checker ckfun, SV *ckobj, U32 flags);
#define PERL_ARGS_ASSERT_CV_SET_CALL_CHECKER_FLAGS	\
	assert(cv); assert(ckfun); assert(ckobj)
PERL_CALLCONV void	Perl_cv_undef(pTHX_ CV* cv);
#define PERL_ARGS_ASSERT_CV_UNDEF	\
	assert(cv)
PERL_CALLCONV void	Perl_cv_undef_flags(pTHX_ CV* cv, U32 flags);
#define PERL_ARGS_ASSERT_CV_UNDEF_FLAGS	\
	assert(cv)
PERL_CALLCONV GV *	Perl_cvgv_from_hek(pTHX_ CV* cv);
#define PERL_ARGS_ASSERT_CVGV_FROM_HEK	\
	assert(cv)
PERL_CALLCONV void	Perl_cvgv_set(pTHX_ CV* cv, GV* gv);
#define PERL_ARGS_ASSERT_CVGV_SET	\
	assert(cv)
PERL_CALLCONV void	Perl_cvstash_set(pTHX_ CV* cv, HV* stash);
#define PERL_ARGS_ASSERT_CVSTASH_SET	\
	assert(cv)
PERL_CALLCONV void	Perl_cx_dump(pTHX_ PERL_CONTEXT* cx);
#define PERL_ARGS_ASSERT_CX_DUMP	\
	assert(cx)
PERL_CALLCONV I32	Perl_cxinc(pTHX)
			__attribute__warn_unused_result__;

PERL_CALLCONV void	Perl_deb(pTHX_ const char* pat, ...)
			__attribute__format__(__printf__,pTHX_1,pTHX_2);
#define PERL_ARGS_ASSERT_DEB	\
	assert(pat)

PERL_CALLCONV void	Perl_deb_stack_all(pTHX);
PERL_CALLCONV I32	Perl_debop(pTHX_ const OP* o);
#define PERL_ARGS_ASSERT_DEBOP	\
	assert(o)
PERL_CALLCONV void	Perl_debprofdump(pTHX);
PERL_CALLCONV I32	Perl_debstack(pTHX);
PERL_CALLCONV I32	Perl_debstackptrs(pTHX);
PERL_CALLCONV SV *	Perl_defelem_target(pTHX_ SV *sv, MAGIC *mg)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_DEFELEM_TARGET	\
	assert(sv)

PERL_CALLCONV void	Perl_delete_eval_scope(pTHX);
PERL_CALLCONV char*	Perl_delimcpy(char* to, const char* toend, const char* from, const char* fromend, int delim, I32* retlen);
#define PERL_ARGS_ASSERT_DELIMCPY	\
	assert(to); assert(toend); assert(from); assert(fromend); assert(retlen)
PERL_CALLCONV void	Perl_despatch_signals(pTHX);
PERL_CALLCONV_NO_RET OP*	Perl_die(pTHX_ const char* pat, ...)
			__attribute__noreturn__
			__attribute__format__null_ok__(__printf__,pTHX_1,pTHX_2);

PERL_CALLCONV_NO_RET OP*	Perl_die_sv(pTHX_ SV *baseex)
			__attribute__noreturn__;
#define PERL_ARGS_ASSERT_DIE_SV	\
	assert(baseex)

PERL_CALLCONV_NO_RET void	Perl_die_unwind(pTHX_ SV* msv)
			__attribute__noreturn__;
#define PERL_ARGS_ASSERT_DIE_UNWIND	\
	assert(msv)

/* PERL_CALLCONV bool	Perl_do_aexec(pTHX_ SV* really, SV** mark, SV** sp); */
#define PERL_ARGS_ASSERT_DO_AEXEC	\
	assert(mark); assert(sp)
PERL_CALLCONV bool	Perl_do_aexec5(pTHX_ SV* really, SV** mark, SV** sp, int fd, int do_report);
#define PERL_ARGS_ASSERT_DO_AEXEC5	\
	assert(mark); assert(sp)
PERL_CALLCONV int	Perl_do_binmode(pTHX_ PerlIO *fp, int iotype, int mode);
#define PERL_ARGS_ASSERT_DO_BINMODE	\
	assert(fp)
PERL_CALLCONV bool	Perl_do_close(pTHX_ GV* gv, bool not_implicit);
PERL_CALLCONV void	Perl_do_dump_pad(pTHX_ I32 level, PerlIO *file, PADLIST *padlist, int full);
#define PERL_ARGS_ASSERT_DO_DUMP_PAD	\
	assert(file)
PERL_CALLCONV bool	Perl_do_eof(pTHX_ GV* gv);
#define PERL_ARGS_ASSERT_DO_EOF	\
	assert(gv)
PERL_CALLCONV void	Perl_do_execfree(pTHX);
PERL_CALLCONV void	Perl_do_gv_dump(pTHX_ I32 level, PerlIO *file, const char *name, GV *sv);
#define PERL_ARGS_ASSERT_DO_GV_DUMP	\
	assert(file); assert(name)
PERL_CALLCONV void	Perl_do_gvgv_dump(pTHX_ I32 level, PerlIO *file, const char *name, GV *sv);
#define PERL_ARGS_ASSERT_DO_GVGV_DUMP	\
	assert(file); assert(name)
PERL_CALLCONV void	Perl_do_hv_dump(pTHX_ I32 level, PerlIO *file, const char *name, HV *sv);
#define PERL_ARGS_ASSERT_DO_HV_DUMP	\
	assert(file); assert(name)
PERL_CALLCONV void	Perl_do_join(pTHX_ SV *sv, SV *delim, SV **mark, SV **sp);
#define PERL_ARGS_ASSERT_DO_JOIN	\
	assert(sv); assert(delim); assert(mark); assert(sp)
PERL_CALLCONV void	Perl_do_magic_dump(pTHX_ I32 level, PerlIO *file, const MAGIC *mg, I32 nest, I32 maxnest, bool dumpops, STRLEN pvlim);
#define PERL_ARGS_ASSERT_DO_MAGIC_DUMP	\
	assert(file)
PERL_CALLCONV I32	Perl_do_ncmp(pTHX_ SV *const left, SV *const right)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_DO_NCMP	\
	assert(left); assert(right)

PERL_CALLCONV void	Perl_do_op_dump(pTHX_ I32 level, PerlIO *file, const OP *o);
#define PERL_ARGS_ASSERT_DO_OP_DUMP	\
	assert(file)
/* PERL_CALLCONV bool	Perl_do_open(pTHX_ GV* gv, const char* name, I32 len, int as_raw, int rawmode, int rawperm, PerlIO* supplied_fp); */
#define PERL_ARGS_ASSERT_DO_OPEN	\
	assert(gv); assert(name)
PERL_CALLCONV bool	Perl_do_open6(pTHX_ GV *gv, const char *oname, STRLEN len, PerlIO *supplied_fp, SV **svp, U32 num);
#define PERL_ARGS_ASSERT_DO_OPEN6	\
	assert(gv); assert(oname)
PERL_CALLCONV bool	Perl_do_open9(pTHX_ GV *gv, const char *name, I32 len, int as_raw, int rawmode, int rawperm, PerlIO *supplied_fp, SV *svs, I32 num);
#define PERL_ARGS_ASSERT_DO_OPEN9	\
	assert(gv); assert(name); assert(svs)
PERL_CALLCONV bool	Perl_do_open_raw(pTHX_ GV *gv, const char *oname, STRLEN len, int rawmode, int rawperm);
#define PERL_ARGS_ASSERT_DO_OPEN_RAW	\
	assert(gv); assert(oname)
PERL_CALLCONV bool	Perl_do_openn(pTHX_ GV *gv, const char *oname, I32 len, int as_raw, int rawmode, int rawperm, PerlIO *supplied_fp, SV **svp, I32 num);
#define PERL_ARGS_ASSERT_DO_OPENN	\
	assert(gv); assert(oname)
PERL_CALLCONV void	Perl_do_pmop_dump(pTHX_ I32 level, PerlIO *file, const PMOP *pm);
#define PERL_ARGS_ASSERT_DO_PMOP_DUMP	\
	assert(file)
PERL_CALLCONV bool	Perl_do_print(pTHX_ SV* sv, PerlIO* fp);
#define PERL_ARGS_ASSERT_DO_PRINT	\
	assert(fp)
PERL_CALLCONV OP*	Perl_do_readline(pTHX)
			__attribute__warn_unused_result__;

PERL_CALLCONV bool	Perl_do_seek(pTHX_ GV* gv, Off_t pos, int whence);
PERL_CALLCONV void	Perl_do_sprintf(pTHX_ SV* sv, I32 len, SV** sarg);
#define PERL_ARGS_ASSERT_DO_SPRINTF	\
	assert(sv); assert(sarg)
PERL_CALLCONV void	Perl_do_sv_dump(pTHX_ I32 level, PerlIO *file, SV *sv, I32 nest, I32 maxnest, bool dumpops, STRLEN pvlim);
#define PERL_ARGS_ASSERT_DO_SV_DUMP	\
	assert(file)
PERL_CALLCONV Off_t	Perl_do_sysseek(pTHX_ GV* gv, Off_t pos, int whence);
#define PERL_ARGS_ASSERT_DO_SYSSEEK	\
	assert(gv)
PERL_CALLCONV Off_t	Perl_do_tell(pTHX_ GV* gv)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_DO_TELL	\
	assert(gv)

PERL_CALLCONV I32	Perl_do_trans(pTHX_ SV* sv);
#define PERL_ARGS_ASSERT_DO_TRANS	\
	assert(sv)
PERL_CALLCONV UV	Perl_do_vecget(pTHX_ SV* sv, SSize_t offset, int size);
#define PERL_ARGS_ASSERT_DO_VECGET	\
	assert(sv)
PERL_CALLCONV void	Perl_do_vecset(pTHX_ SV* sv);
#define PERL_ARGS_ASSERT_DO_VECSET	\
	assert(sv)
PERL_CALLCONV void	Perl_do_vop(pTHX_ I32 optype, SV* sv, SV* left, SV* right);
#define PERL_ARGS_ASSERT_DO_VOP	\
	assert(sv); assert(left); assert(right)
PERL_CALLCONV OP*	Perl_dofile(pTHX_ OP* term, I32 force_builtin);
#define PERL_ARGS_ASSERT_DOFILE	\
	assert(term)
PERL_CALLCONV bool	Perl_doing_taint(int argc, char** argv, char** env)
			__attribute__warn_unused_result__;

PERL_CALLCONV OP *	Perl_doref(pTHX_ OP *o, I32 type, bool set_op_ref);
#define PERL_ARGS_ASSERT_DOREF	\
	assert(o)
PERL_CALLCONV void	Perl_dounwind(pTHX_ I32 cxix);
PERL_CALLCONV U8	Perl_dowantarray(pTHX)
			__attribute__warn_unused_result__;

PERL_CALLCONV void	Perl_drand48_init_r(perl_drand48_t *random_state, U32 seed);
#define PERL_ARGS_ASSERT_DRAND48_INIT_R	\
	assert(random_state)
PERL_CALLCONV double	Perl_drand48_r(perl_drand48_t *random_state);
#define PERL_ARGS_ASSERT_DRAND48_R	\
	assert(random_state)
PERL_CALLCONV void	Perl_dump_all(pTHX);
PERL_CALLCONV void	Perl_dump_all_perl(pTHX_ bool justperl);
PERL_CALLCONV void	Perl_dump_eval(pTHX);
PERL_CALLCONV void	Perl_dump_form(pTHX_ const GV* gv);
#define PERL_ARGS_ASSERT_DUMP_FORM	\
	assert(gv)
PERL_CALLCONV void	Perl_dump_indent(pTHX_ I32 level, PerlIO *file, const char* pat, ...)
			__attribute__format__(__printf__,pTHX_3,pTHX_4);
#define PERL_ARGS_ASSERT_DUMP_INDENT	\
	assert(file); assert(pat)

PERL_CALLCONV void	Perl_dump_packsubs(pTHX_ const HV* stash);
#define PERL_ARGS_ASSERT_DUMP_PACKSUBS	\
	assert(stash)
PERL_CALLCONV void	Perl_dump_packsubs_perl(pTHX_ const HV* stash, bool justperl);
#define PERL_ARGS_ASSERT_DUMP_PACKSUBS_PERL	\
	assert(stash)
PERL_CALLCONV void	Perl_dump_sub(pTHX_ const GV* gv);
#define PERL_ARGS_ASSERT_DUMP_SUB	\
	assert(gv)
PERL_CALLCONV void	Perl_dump_sub_perl(pTHX_ const GV* gv, bool justperl);
#define PERL_ARGS_ASSERT_DUMP_SUB_PERL	\
	assert(gv)
PERL_CALLCONV void	Perl_dump_vindent(pTHX_ I32 level, PerlIO *file, const char* pat, va_list *args);
#define PERL_ARGS_ASSERT_DUMP_VINDENT	\
	assert(file); assert(pat)
PERL_CALLCONV void	Perl_emulate_cop_io(pTHX_ const COP *const c, SV *const sv);
#define PERL_ARGS_ASSERT_EMULATE_COP_IO	\
	assert(c); assert(sv)
PERL_CALLCONV SV*	Perl_eval_pv(pTHX_ const char* p, I32 croak_on_error);
#define PERL_ARGS_ASSERT_EVAL_PV	\
	assert(p)
PERL_CALLCONV I32	Perl_eval_sv(pTHX_ SV* sv, I32 flags);
#define PERL_ARGS_ASSERT_EVAL_SV	\
	assert(sv)
PERL_CALLCONV void	Perl_fbm_compile(pTHX_ SV* sv, U32 flags);
#define PERL_ARGS_ASSERT_FBM_COMPILE	\
	assert(sv)
PERL_CALLCONV char*	Perl_fbm_instr(pTHX_ unsigned char* big, unsigned char* bigend, SV* littlestr, U32 flags)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_FBM_INSTR	\
	assert(big); assert(bigend); assert(littlestr)

PERL_CALLCONV bool	Perl_feature_is_enabled(pTHX_ const char *const name, STRLEN namelen);
#define PERL_ARGS_ASSERT_FEATURE_IS_ENABLED	\
	assert(name)
PERL_CALLCONV SV*	Perl_filter_add(pTHX_ filter_t funcp, SV* datasv);
PERL_CALLCONV void	Perl_filter_del(pTHX_ filter_t funcp);
#define PERL_ARGS_ASSERT_FILTER_DEL	\
	assert(funcp)
PERL_CALLCONV I32	Perl_filter_read(pTHX_ int idx, SV *buf_sv, int maxlen)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_FILTER_READ	\
	assert(buf_sv)

PERL_CALLCONV void	Perl_finalize_optree(pTHX_ OP* o);
#define PERL_ARGS_ASSERT_FINALIZE_OPTREE	\
	assert(o)
PERL_CALLCONV CV *	Perl_find_lexical_cv(pTHX_ PADOFFSET off);
PERL_CALLCONV CV*	Perl_find_runcv(pTHX_ U32 *db_seqp)
			__attribute__warn_unused_result__;

PERL_CALLCONV CV*	Perl_find_runcv_where(pTHX_ U8 cond, IV arg, U32 *db_seqp)
			__attribute__warn_unused_result__;

PERL_CALLCONV SV*	Perl_find_rundefsv(pTHX);
PERL_CALLCONV PADOFFSET	Perl_find_rundefsvoffset(pTHX)
			__attribute__deprecated__;

PERL_CALLCONV char*	Perl_find_script(pTHX_ const char *scriptname, bool dosearch, const char *const *const search_ext, I32 flags);
#define PERL_ARGS_ASSERT_FIND_SCRIPT	\
	assert(scriptname)
PERL_CALLCONV I32	Perl_foldEQ(const char* a, const char* b, I32 len)
			__attribute__pure__;
#define PERL_ARGS_ASSERT_FOLDEQ	\
	assert(a); assert(b)

PERL_CALLCONV I32	Perl_foldEQ_latin1(const char* a, const char* b, I32 len)
			__attribute__pure__;
#define PERL_ARGS_ASSERT_FOLDEQ_LATIN1	\
	assert(a); assert(b)

PERL_CALLCONV I32	Perl_foldEQ_locale(const char* a, const char* b, I32 len)
			__attribute__pure__;
#define PERL_ARGS_ASSERT_FOLDEQ_LOCALE	\
	assert(a); assert(b)

/* PERL_CALLCONV I32	foldEQ_utf8(pTHX_ const char *s1, char **pe1, UV l1, bool u1, const char *s2, char **pe2, UV l2, bool u2); */
PERL_CALLCONV I32	Perl_foldEQ_utf8_flags(pTHX_ const char *s1, char **pe1, UV l1, bool u1, const char *s2, char **pe2, UV l2, bool u2, U32 flags);
#define PERL_ARGS_ASSERT_FOLDEQ_UTF8_FLAGS	\
	assert(s1); assert(s2)
PERL_CALLCONV char*	Perl_form(pTHX_ const char* pat, ...)
			__attribute__format__(__printf__,pTHX_1,pTHX_2);
#define PERL_ARGS_ASSERT_FORM	\
	assert(pat)

PERL_CALLCONV void	Perl_free_tied_hv_pool(pTHX);
PERL_CALLCONV void	Perl_free_tmps(pTHX);
PERL_CALLCONV AV*	Perl_get_av(pTHX_ const char *name, I32 flags);
#define PERL_ARGS_ASSERT_GET_AV	\
	assert(name)
PERL_CALLCONV void*	Perl_get_context(void)
			__attribute__warn_unused_result__;

PERL_CALLCONV CV*	Perl_get_cv(pTHX_ const char* name, I32 flags);
#define PERL_ARGS_ASSERT_GET_CV	\
	assert(name)
PERL_CALLCONV CV*	Perl_get_cvn_flags(pTHX_ const char* name, STRLEN len, I32 flags);
#define PERL_ARGS_ASSERT_GET_CVN_FLAGS	\
	assert(name)
PERL_CALLCONV void	Perl_get_db_sub(pTHX_ SV **svp, CV *cv);
#define PERL_ARGS_ASSERT_GET_DB_SUB	\
	assert(cv)
PERL_CALLCONV void	Perl_get_hash_seed(pTHX_ unsigned char * const seed_buffer);
#define PERL_ARGS_ASSERT_GET_HASH_SEED	\
	assert(seed_buffer)
PERL_CALLCONV HV*	Perl_get_hv(pTHX_ const char *name, I32 flags);
#define PERL_ARGS_ASSERT_GET_HV	\
	assert(name)
PERL_CALLCONV const char*	Perl_get_no_modify(pTHX)
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV char**	Perl_get_op_descs(pTHX)
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV char**	Perl_get_op_names(pTHX)
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV U32*	Perl_get_opargs(pTHX)
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV PPADDR_t*	Perl_get_ppaddr(pTHX)
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV REGEXP *	Perl_get_re_arg(pTHX_ SV *sv);
PERL_CALLCONV SV*	Perl_get_sv(pTHX_ const char *name, I32 flags);
#define PERL_ARGS_ASSERT_GET_SV	\
	assert(name)
PERL_CALLCONV MGVTBL*	Perl_get_vtbl(pTHX_ int vtbl_id)
			__attribute__warn_unused_result__;

PERL_CALLCONV int	Perl_getcwd_sv(pTHX_ SV* sv);
#define PERL_ARGS_ASSERT_GETCWD_SV	\
	assert(sv)
PERL_CALLCONV void	Perl_gp_free(pTHX_ GV* gv);
PERL_CALLCONV GP*	Perl_gp_ref(pTHX_ GP* gp);
PERL_CALLCONV bool	Perl_grok_atoUV(const char* pv, UV* valptr, const char** endptr);
#define PERL_ARGS_ASSERT_GROK_ATOUV	\
	assert(pv); assert(valptr)
PERL_CALLCONV UV	Perl_grok_bin(pTHX_ const char* start, STRLEN* len_p, I32* flags, NV *result);
#define PERL_ARGS_ASSERT_GROK_BIN	\
	assert(start); assert(len_p); assert(flags)
PERL_CALLCONV UV	Perl_grok_hex(pTHX_ const char* start, STRLEN* len_p, I32* flags, NV *result);
#define PERL_ARGS_ASSERT_GROK_HEX	\
	assert(start); assert(len_p); assert(flags)
PERL_CALLCONV int	Perl_grok_infnan(pTHX_ const char** sp, const char *send);
#define PERL_ARGS_ASSERT_GROK_INFNAN	\
	assert(sp); assert(send)
PERL_CALLCONV int	Perl_grok_number(pTHX_ const char *pv, STRLEN len, UV *valuep);
#define PERL_ARGS_ASSERT_GROK_NUMBER	\
	assert(pv)
PERL_CALLCONV int	Perl_grok_number_flags(pTHX_ const char *pv, STRLEN len, UV *valuep, U32 flags);
#define PERL_ARGS_ASSERT_GROK_NUMBER_FLAGS	\
	assert(pv)
PERL_CALLCONV bool	Perl_grok_numeric_radix(pTHX_ const char **sp, const char *send)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_GROK_NUMERIC_RADIX	\
	assert(sp); assert(send)

PERL_CALLCONV UV	Perl_grok_oct(pTHX_ const char* start, STRLEN* len_p, I32* flags, NV *result);
#define PERL_ARGS_ASSERT_GROK_OCT	\
	assert(start); assert(len_p); assert(flags)
/* PERL_CALLCONV GV*	Perl_gv_AVadd(pTHX_ GV *gv); */
/* PERL_CALLCONV GV*	Perl_gv_HVadd(pTHX_ GV *gv); */
/* PERL_CALLCONV GV*	Perl_gv_IOadd(pTHX_ GV* gv); */
PERL_CALLCONV GV*	Perl_gv_add_by_type(pTHX_ GV *gv, svtype type);
/* PERL_CALLCONV GV*	gv_autoload4(pTHX_ HV* stash, const char* name, STRLEN len, I32 method)
			__attribute__warn_unused_result__; */

PERL_CALLCONV GV*	Perl_gv_autoload_pv(pTHX_ HV* stash, const char* namepv, U32 flags)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_GV_AUTOLOAD_PV	\
	assert(namepv)

PERL_CALLCONV GV*	Perl_gv_autoload_pvn(pTHX_ HV* stash, const char* name, STRLEN len, U32 flags)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_GV_AUTOLOAD_PVN	\
	assert(name)

PERL_CALLCONV GV*	Perl_gv_autoload_sv(pTHX_ HV* stash, SV* namesv, U32 flags)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_GV_AUTOLOAD_SV	\
	assert(namesv)

PERL_CALLCONV void	Perl_gv_check(pTHX_ HV* stash);
#define PERL_ARGS_ASSERT_GV_CHECK	\
	assert(stash)
PERL_CALLCONV SV*	Perl_gv_const_sv(pTHX_ GV* gv)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_GV_CONST_SV	\
	assert(gv)

PERL_CALLCONV void	Perl_gv_dump(pTHX_ GV* gv);
PERL_CALLCONV void	Perl_gv_efullname(pTHX_ SV* sv, const GV* gv);
#define PERL_ARGS_ASSERT_GV_EFULLNAME	\
	assert(sv); assert(gv)
/* PERL_CALLCONV void	Perl_gv_efullname3(pTHX_ SV* sv, const GV* gv, const char* prefix); */
#define PERL_ARGS_ASSERT_GV_EFULLNAME3	\
	assert(sv); assert(gv)
PERL_CALLCONV void	Perl_gv_efullname4(pTHX_ SV* sv, const GV* gv, const char* prefix, bool keepmain);
#define PERL_ARGS_ASSERT_GV_EFULLNAME4	\
	assert(sv); assert(gv)
PERL_CALLCONV GV*	Perl_gv_fetchfile(pTHX_ const char* name);
#define PERL_ARGS_ASSERT_GV_FETCHFILE	\
	assert(name)
PERL_CALLCONV GV*	Perl_gv_fetchfile_flags(pTHX_ const char *const name, const STRLEN len, const U32 flags);
#define PERL_ARGS_ASSERT_GV_FETCHFILE_FLAGS	\
	assert(name)
/* PERL_CALLCONV GV*	gv_fetchmeth(pTHX_ HV* stash, const char* name, STRLEN len, I32 level); */
/* PERL_CALLCONV GV*	gv_fetchmeth_autoload(pTHX_ HV* stash, const char* name, STRLEN len, I32 level); */
PERL_CALLCONV GV*	Perl_gv_fetchmeth_pv(pTHX_ HV* stash, const char* name, I32 level, U32 flags);
#define PERL_ARGS_ASSERT_GV_FETCHMETH_PV	\
	assert(name)
PERL_CALLCONV GV*	Perl_gv_fetchmeth_pv_autoload(pTHX_ HV* stash, const char* name, I32 level, U32 flags);
#define PERL_ARGS_ASSERT_GV_FETCHMETH_PV_AUTOLOAD	\
	assert(name)
PERL_CALLCONV GV*	Perl_gv_fetchmeth_pvn(pTHX_ HV* stash, const char* name, STRLEN len, I32 level, U32 flags);
#define PERL_ARGS_ASSERT_GV_FETCHMETH_PVN	\
	assert(name)
PERL_CALLCONV GV*	Perl_gv_fetchmeth_pvn_autoload(pTHX_ HV* stash, const char* name, STRLEN len, I32 level, U32 flags);
#define PERL_ARGS_ASSERT_GV_FETCHMETH_PVN_AUTOLOAD	\
	assert(name)
PERL_CALLCONV GV*	Perl_gv_fetchmeth_sv(pTHX_ HV* stash, SV* namesv, I32 level, U32 flags);
#define PERL_ARGS_ASSERT_GV_FETCHMETH_SV	\
	assert(namesv)
PERL_CALLCONV GV*	Perl_gv_fetchmeth_sv_autoload(pTHX_ HV* stash, SV* namesv, I32 level, U32 flags);
#define PERL_ARGS_ASSERT_GV_FETCHMETH_SV_AUTOLOAD	\
	assert(namesv)
/* PERL_CALLCONV GV*	Perl_gv_fetchmethod(pTHX_ HV* stash, const char* name); */
#define PERL_ARGS_ASSERT_GV_FETCHMETHOD	\
	assert(stash); assert(name)
PERL_CALLCONV GV*	Perl_gv_fetchmethod_autoload(pTHX_ HV* stash, const char* name, I32 autoload);
#define PERL_ARGS_ASSERT_GV_FETCHMETHOD_AUTOLOAD	\
	assert(stash); assert(name)
PERL_CALLCONV GV*	Perl_gv_fetchmethod_pv_flags(pTHX_ HV* stash, const char* name, U32 flags);
#define PERL_ARGS_ASSERT_GV_FETCHMETHOD_PV_FLAGS	\
	assert(stash); assert(name)
PERL_CALLCONV GV*	Perl_gv_fetchmethod_pvn_flags(pTHX_ HV* stash, const char* name, const STRLEN len, U32 flags);
#define PERL_ARGS_ASSERT_GV_FETCHMETHOD_PVN_FLAGS	\
	assert(stash); assert(name)
PERL_CALLCONV GV*	Perl_gv_fetchmethod_sv_flags(pTHX_ HV* stash, SV* namesv, U32 flags);
#define PERL_ARGS_ASSERT_GV_FETCHMETHOD_SV_FLAGS	\
	assert(stash); assert(namesv)
PERL_CALLCONV GV*	Perl_gv_fetchpv(pTHX_ const char *nambeg, I32 add, const svtype sv_type);
#define PERL_ARGS_ASSERT_GV_FETCHPV	\
	assert(nambeg)
PERL_CALLCONV GV*	Perl_gv_fetchpvn_flags(pTHX_ const char* name, STRLEN len, I32 flags, const svtype sv_type);
#define PERL_ARGS_ASSERT_GV_FETCHPVN_FLAGS	\
	assert(name)
PERL_CALLCONV GV*	Perl_gv_fetchsv(pTHX_ SV *name, I32 flags, const svtype sv_type);
#define PERL_ARGS_ASSERT_GV_FETCHSV	\
	assert(name)
PERL_CALLCONV void	Perl_gv_fullname(pTHX_ SV* sv, const GV* gv);
#define PERL_ARGS_ASSERT_GV_FULLNAME	\
	assert(sv); assert(gv)
/* PERL_CALLCONV void	Perl_gv_fullname3(pTHX_ SV* sv, const GV* gv, const char* prefix); */
#define PERL_ARGS_ASSERT_GV_FULLNAME3	\
	assert(sv); assert(gv)
PERL_CALLCONV void	Perl_gv_fullname4(pTHX_ SV* sv, const GV* gv, const char* prefix, bool keepmain);
#define PERL_ARGS_ASSERT_GV_FULLNAME4	\
	assert(sv); assert(gv)
PERL_CALLCONV CV*	Perl_gv_handler(pTHX_ HV* stash, I32 id)
			__attribute__warn_unused_result__;

/* PERL_CALLCONV void	gv_init(pTHX_ GV* gv, HV* stash, const char* name, STRLEN len, int multi); */
PERL_CALLCONV void	Perl_gv_init_pv(pTHX_ GV* gv, HV* stash, const char* name, U32 flags);
#define PERL_ARGS_ASSERT_GV_INIT_PV	\
	assert(gv); assert(name)
PERL_CALLCONV void	Perl_gv_init_pvn(pTHX_ GV* gv, HV* stash, const char* name, STRLEN len, U32 flags);
#define PERL_ARGS_ASSERT_GV_INIT_PVN	\
	assert(gv); assert(name)
PERL_CALLCONV void	Perl_gv_init_sv(pTHX_ GV* gv, HV* stash, SV* namesv, U32 flags);
#define PERL_ARGS_ASSERT_GV_INIT_SV	\
	assert(gv); assert(namesv)
PERL_CALLCONV void	Perl_gv_name_set(pTHX_ GV* gv, const char *name, U32 len, U32 flags);
#define PERL_ARGS_ASSERT_GV_NAME_SET	\
	assert(gv); assert(name)
PERL_CALLCONV GV *	Perl_gv_override(pTHX_ const char * const name, const STRLEN len);
#define PERL_ARGS_ASSERT_GV_OVERRIDE	\
	assert(name)
PERL_CALLCONV void	Perl_gv_setref(pTHX_ SV *const dstr, SV *const sstr);
#define PERL_ARGS_ASSERT_GV_SETREF	\
	assert(dstr); assert(sstr)
PERL_CALLCONV HV*	Perl_gv_stashpv(pTHX_ const char* name, I32 flags);
#define PERL_ARGS_ASSERT_GV_STASHPV	\
	assert(name)
PERL_CALLCONV HV*	Perl_gv_stashpvn(pTHX_ const char* name, U32 namelen, I32 flags);
#define PERL_ARGS_ASSERT_GV_STASHPVN	\
	assert(name)
PERL_CALLCONV HV*	Perl_gv_stashsv(pTHX_ SV* sv, I32 flags);
#define PERL_ARGS_ASSERT_GV_STASHSV	\
	assert(sv)
PERL_CALLCONV void	Perl_gv_try_downgrade(pTHX_ GV* gv);
#define PERL_ARGS_ASSERT_GV_TRY_DOWNGRADE	\
	assert(gv)
PERL_CALLCONV AV**	Perl_hv_backreferences_p(pTHX_ HV *hv);
#define PERL_ARGS_ASSERT_HV_BACKREFERENCES_P	\
	assert(hv)
PERL_CALLCONV void	Perl_hv_clear(pTHX_ HV *hv);
PERL_CALLCONV void	Perl_hv_clear_placeholders(pTHX_ HV *hv);
#define PERL_ARGS_ASSERT_HV_CLEAR_PLACEHOLDERS	\
	assert(hv)
PERL_CALLCONV void*	Perl_hv_common(pTHX_ HV *hv, SV *keysv, const char* key, STRLEN klen, int flags, int action, SV *val, U32 hash);
PERL_CALLCONV void*	Perl_hv_common_key_len(pTHX_ HV *hv, const char *key, I32 klen_i32, const int action, SV *val, const U32 hash);
#define PERL_ARGS_ASSERT_HV_COMMON_KEY_LEN	\
	assert(key)
PERL_CALLCONV HV *	Perl_hv_copy_hints_hv(pTHX_ HV *const ohv)
			__attribute__warn_unused_result__;

PERL_CALLCONV void	Perl_hv_delayfree_ent(pTHX_ HV *hv, HE *entry);
#define PERL_ARGS_ASSERT_HV_DELAYFREE_ENT	\
	assert(hv)
/* PERL_CALLCONV SV*	Perl_hv_delete(pTHX_ HV *hv, const char *key, I32 klen, I32 flags); */
#define PERL_ARGS_ASSERT_HV_DELETE	\
	assert(key)
/* PERL_CALLCONV SV*	Perl_hv_delete_ent(pTHX_ HV *hv, SV *keysv, I32 flags, U32 hash); */
#define PERL_ARGS_ASSERT_HV_DELETE_ENT	\
	assert(keysv)
PERL_CALLCONV HE**	Perl_hv_eiter_p(pTHX_ HV *hv)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_HV_EITER_P	\
	assert(hv)

PERL_CALLCONV void	Perl_hv_eiter_set(pTHX_ HV *hv, HE *eiter);
#define PERL_ARGS_ASSERT_HV_EITER_SET	\
	assert(hv)
PERL_CALLCONV void	Perl_hv_ename_add(pTHX_ HV *hv, const char *name, U32 len, U32 flags);
#define PERL_ARGS_ASSERT_HV_ENAME_ADD	\
	assert(hv); assert(name)
PERL_CALLCONV void	Perl_hv_ename_delete(pTHX_ HV *hv, const char *name, U32 len, U32 flags);
#define PERL_ARGS_ASSERT_HV_ENAME_DELETE	\
	assert(hv); assert(name)
/* PERL_CALLCONV bool	Perl_hv_exists(pTHX_ HV *hv, const char *key, I32 klen)
			__attribute__warn_unused_result__; */
#define PERL_ARGS_ASSERT_HV_EXISTS	\
	assert(key)

/* PERL_CALLCONV bool	Perl_hv_exists_ent(pTHX_ HV *hv, SV *keysv, U32 hash)
			__attribute__warn_unused_result__; */
#define PERL_ARGS_ASSERT_HV_EXISTS_ENT	\
	assert(keysv)

/* PERL_CALLCONV SV**	Perl_hv_fetch(pTHX_ HV *hv, const char *key, I32 klen, I32 lval); */
#define PERL_ARGS_ASSERT_HV_FETCH	\
	assert(key)
/* PERL_CALLCONV HE*	Perl_hv_fetch_ent(pTHX_ HV *hv, SV *keysv, I32 lval, U32 hash); */
#define PERL_ARGS_ASSERT_HV_FETCH_ENT	\
	assert(keysv)
PERL_CALLCONV STRLEN	Perl_hv_fill(pTHX_ HV *const hv);
#define PERL_ARGS_ASSERT_HV_FILL	\
	assert(hv)
PERL_CALLCONV void	Perl_hv_free_ent(pTHX_ HV *hv, HE *entry);
#define PERL_ARGS_ASSERT_HV_FREE_ENT	\
	assert(hv)
PERL_CALLCONV I32	Perl_hv_iterinit(pTHX_ HV *hv);
#define PERL_ARGS_ASSERT_HV_ITERINIT	\
	assert(hv)
PERL_CALLCONV char*	Perl_hv_iterkey(pTHX_ HE* entry, I32* retlen)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_HV_ITERKEY	\
	assert(entry); assert(retlen)

PERL_CALLCONV SV*	Perl_hv_iterkeysv(pTHX_ HE* entry)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_HV_ITERKEYSV	\
	assert(entry)

/* PERL_CALLCONV HE*	Perl_hv_iternext(pTHX_ HV *hv)
			__attribute__warn_unused_result__; */
#define PERL_ARGS_ASSERT_HV_ITERNEXT	\
	assert(hv)

PERL_CALLCONV HE*	Perl_hv_iternext_flags(pTHX_ HV *hv, I32 flags)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_HV_ITERNEXT_FLAGS	\
	assert(hv)

PERL_CALLCONV SV*	Perl_hv_iternextsv(pTHX_ HV *hv, char **key, I32 *retlen)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_HV_ITERNEXTSV	\
	assert(hv); assert(key); assert(retlen)

PERL_CALLCONV SV*	Perl_hv_iterval(pTHX_ HV *hv, HE *entry)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_HV_ITERVAL	\
	assert(hv); assert(entry)

PERL_CALLCONV void	Perl_hv_ksplit(pTHX_ HV *hv, IV newmax);
#define PERL_ARGS_ASSERT_HV_KSPLIT	\
	assert(hv)
/* PERL_CALLCONV void	Perl_hv_magic(pTHX_ HV *hv, GV *gv, int how); */
#define PERL_ARGS_ASSERT_HV_MAGIC	\
	assert(hv)
PERL_CALLCONV void	Perl_hv_name_set(pTHX_ HV *hv, const char *name, U32 len, U32 flags);
#define PERL_ARGS_ASSERT_HV_NAME_SET	\
	assert(hv)
PERL_CALLCONV I32	Perl_hv_placeholders_get(pTHX_ const HV *hv)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_HV_PLACEHOLDERS_GET	\
	assert(hv)

PERL_CALLCONV SSize_t*	Perl_hv_placeholders_p(pTHX_ HV *hv)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_HV_PLACEHOLDERS_P	\
	assert(hv)

PERL_CALLCONV void	Perl_hv_placeholders_set(pTHX_ HV *hv, I32 ph);
#define PERL_ARGS_ASSERT_HV_PLACEHOLDERS_SET	\
	assert(hv)
PERL_CALLCONV void	Perl_hv_rand_set(pTHX_ HV *hv, U32 new_xhv_rand);
#define PERL_ARGS_ASSERT_HV_RAND_SET	\
	assert(hv)
PERL_CALLCONV I32*	Perl_hv_riter_p(pTHX_ HV *hv)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_HV_RITER_P	\
	assert(hv)

PERL_CALLCONV void	Perl_hv_riter_set(pTHX_ HV *hv, I32 riter);
#define PERL_ARGS_ASSERT_HV_RITER_SET	\
	assert(hv)
PERL_CALLCONV SV*	Perl_hv_scalar(pTHX_ HV *hv)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_HV_SCALAR	\
	assert(hv)

/* PERL_CALLCONV SV**	Perl_hv_store(pTHX_ HV *hv, const char *key, I32 klen, SV *val, U32 hash); */
/* PERL_CALLCONV HE*	Perl_hv_store_ent(pTHX_ HV *hv, SV *key, SV *val, U32 hash); */
/* PERL_CALLCONV SV**	Perl_hv_store_flags(pTHX_ HV *hv, const char *key, I32 klen, SV *val, U32 hash, int flags); */
/* PERL_CALLCONV void	hv_undef(pTHX_ HV *hv); */
PERL_CALLCONV void	Perl_hv_undef_flags(pTHX_ HV *hv, U32 flags);
/* PERL_CALLCONV I32	ibcmp(pTHX_ const char* a, const char* b, I32 len); */
/* PERL_CALLCONV I32	ibcmp_locale(pTHX_ const char* a, const char* b, I32 len); */
/* PERL_CALLCONV I32	ibcmp_utf8(pTHX_ const char *s1, char **pe1, UV l1, bool u1, const char *s2, char **pe2, UV l2, bool u2); */
PERL_CALLCONV void	Perl_init_argv_symbols(pTHX_ int argc, char **argv);
#define PERL_ARGS_ASSERT_INIT_ARGV_SYMBOLS	\
	assert(argv)
PERL_CALLCONV void	Perl_init_constants(pTHX);
PERL_CALLCONV void	Perl_init_dbargs(pTHX);
PERL_CALLCONV void	Perl_init_debugger(pTHX);
PERL_CALLCONV int	Perl_init_i18nl10n(pTHX_ int printwarn);
PERL_CALLCONV int	Perl_init_i18nl14n(pTHX_ int printwarn);
PERL_CALLCONV void	Perl_init_stacks(pTHX);
PERL_CALLCONV void	Perl_init_tm(pTHX_ struct tm *ptm);
#define PERL_ARGS_ASSERT_INIT_TM	\
	assert(ptm)
PERL_CALLCONV char*	Perl_instr(const char* big, const char* little)
			__attribute__warn_unused_result__
			__attribute__pure__;
#define PERL_ARGS_ASSERT_INSTR	\
	assert(big); assert(little)

PERL_CALLCONV U32	Perl_intro_my(pTHX);
PERL_CALLCONV OP*	Perl_invert(pTHX_ OP* cmd)
			__attribute__warn_unused_result__;

PERL_CALLCONV bool	Perl_io_close(pTHX_ IO* io, GV *gv, bool not_implicit, bool warn_on_fail);
#define PERL_ARGS_ASSERT_IO_CLOSE	\
	assert(io)
PERL_CALLCONV bool	Perl_isALNUM_lazy(pTHX_ const char* p)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;
#define PERL_ARGS_ASSERT_ISALNUM_LAZY	\
	assert(p)

PERL_CALLCONV bool	Perl_isIDFIRST_lazy(pTHX_ const char* p)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;
#define PERL_ARGS_ASSERT_ISIDFIRST_LAZY	\
	assert(p)

/* PERL_CALLCONV bool	Perl_is_ascii_string(pTHX_ const U8 *s, STRLEN len)
			__attribute__warn_unused_result__; */

PERL_CALLCONV bool	Perl_is_invariant_string(const U8 *s, STRLEN len)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_IS_INVARIANT_STRING	\
	assert(s)

PERL_CALLCONV I32	Perl_is_lvalue_sub(pTHX)
			__attribute__warn_unused_result__;

PERL_CALLCONV bool	Perl_is_uni_alnum(pTHX_ UV c)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_alnum_lc(pTHX_ UV c)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_alnumc(pTHX_ UV c)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_alnumc_lc(pTHX_ UV c)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_alpha(pTHX_ UV c)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_alpha_lc(pTHX_ UV c)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_ascii(pTHX_ UV c)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_ascii_lc(pTHX_ UV c)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_blank(pTHX_ UV c)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_blank_lc(pTHX_ UV c)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_cntrl(pTHX_ UV c)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_cntrl_lc(pTHX_ UV c)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_digit(pTHX_ UV c)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_digit_lc(pTHX_ UV c)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_graph(pTHX_ UV c)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_graph_lc(pTHX_ UV c)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_idfirst(pTHX_ UV c)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_idfirst_lc(pTHX_ UV c)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_lower(pTHX_ UV c)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_lower_lc(pTHX_ UV c)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_print(pTHX_ UV c)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_print_lc(pTHX_ UV c)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_punct(pTHX_ UV c)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_punct_lc(pTHX_ UV c)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_space(pTHX_ UV c)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_space_lc(pTHX_ UV c)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_upper(pTHX_ UV c)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_upper_lc(pTHX_ UV c)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_xdigit(pTHX_ UV c)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_xdigit_lc(pTHX_ UV c)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_utf8_alnum(pTHX_ const U8 *p)
			__attribute__deprecated__
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_IS_UTF8_ALNUM	\
	assert(p)

PERL_CALLCONV bool	Perl_is_utf8_alnumc(pTHX_ const U8 *p)
			__attribute__deprecated__
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_IS_UTF8_ALNUMC	\
	assert(p)

PERL_CALLCONV bool	Perl_is_utf8_alpha(pTHX_ const U8 *p)
			__attribute__deprecated__
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_IS_UTF8_ALPHA	\
	assert(p)

PERL_CALLCONV bool	Perl_is_utf8_ascii(pTHX_ const U8 *p)
			__attribute__deprecated__
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_IS_UTF8_ASCII	\
	assert(p)

PERL_CALLCONV bool	Perl_is_utf8_blank(pTHX_ const U8 *p)
			__attribute__deprecated__
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_IS_UTF8_BLANK	\
	assert(p)

PERL_CALLCONV STRLEN	Perl_is_utf8_char(const U8 *s)
			__attribute__deprecated__;
#define PERL_ARGS_ASSERT_IS_UTF8_CHAR	\
	assert(s)

/* PERL_CALLCONV STRLEN	Perl_is_utf8_char_buf(const U8 *buf, const U8 *buf_end); */
#define PERL_ARGS_ASSERT_IS_UTF8_CHAR_BUF	\
	assert(buf); assert(buf_end)
PERL_CALLCONV bool	Perl_is_utf8_cntrl(pTHX_ const U8 *p)
			__attribute__deprecated__
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_IS_UTF8_CNTRL	\
	assert(p)

PERL_CALLCONV bool	Perl_is_utf8_digit(pTHX_ const U8 *p)
			__attribute__deprecated__
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_IS_UTF8_DIGIT	\
	assert(p)

PERL_CALLCONV bool	Perl_is_utf8_graph(pTHX_ const U8 *p)
			__attribute__deprecated__
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_IS_UTF8_GRAPH	\
	assert(p)

PERL_CALLCONV bool	Perl_is_utf8_idcont(pTHX_ const U8 *p)
			__attribute__deprecated__
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_IS_UTF8_IDCONT	\
	assert(p)

PERL_CALLCONV bool	Perl_is_utf8_idfirst(pTHX_ const U8 *p)
			__attribute__deprecated__
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_IS_UTF8_IDFIRST	\
	assert(p)

PERL_CALLCONV bool	Perl_is_utf8_lower(pTHX_ const U8 *p)
			__attribute__deprecated__
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_IS_UTF8_LOWER	\
	assert(p)

PERL_CALLCONV bool	Perl_is_utf8_mark(pTHX_ const U8 *p)
			__attribute__deprecated__
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_IS_UTF8_MARK	\
	assert(p)

PERL_CALLCONV bool	Perl_is_utf8_perl_space(pTHX_ const U8 *p)
			__attribute__deprecated__
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_IS_UTF8_PERL_SPACE	\
	assert(p)

PERL_CALLCONV bool	Perl_is_utf8_perl_word(pTHX_ const U8 *p)
			__attribute__deprecated__
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_IS_UTF8_PERL_WORD	\
	assert(p)

PERL_CALLCONV bool	Perl_is_utf8_posix_digit(pTHX_ const U8 *p)
			__attribute__deprecated__
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_IS_UTF8_POSIX_DIGIT	\
	assert(p)

PERL_CALLCONV bool	Perl_is_utf8_print(pTHX_ const U8 *p)
			__attribute__deprecated__
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_IS_UTF8_PRINT	\
	assert(p)

PERL_CALLCONV bool	Perl_is_utf8_punct(pTHX_ const U8 *p)
			__attribute__deprecated__
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_IS_UTF8_PUNCT	\
	assert(p)

PERL_CALLCONV bool	Perl_is_utf8_space(pTHX_ const U8 *p)
			__attribute__deprecated__
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_IS_UTF8_SPACE	\
	assert(p)

PERL_CALLCONV bool	Perl_is_utf8_string(const U8 *s, STRLEN len);
#define PERL_ARGS_ASSERT_IS_UTF8_STRING	\
	assert(s)
/* PERL_CALLCONV bool	Perl_is_utf8_string_loc(const U8 *s, STRLEN len, const U8 **ep); */
#define PERL_ARGS_ASSERT_IS_UTF8_STRING_LOC	\
	assert(s)
PERL_CALLCONV bool	Perl_is_utf8_string_loclen(const U8 *s, STRLEN len, const U8 **ep, STRLEN *el);
#define PERL_ARGS_ASSERT_IS_UTF8_STRING_LOCLEN	\
	assert(s)
PERL_CALLCONV bool	Perl_is_utf8_upper(pTHX_ const U8 *p)
			__attribute__deprecated__
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_IS_UTF8_UPPER	\
	assert(p)

PERL_CALLCONV bool	Perl_is_utf8_xdigit(pTHX_ const U8 *p)
			__attribute__deprecated__
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_IS_UTF8_XDIGIT	\
	assert(p)

PERL_CALLCONV bool	Perl_is_utf8_xidcont(pTHX_ const U8 *p)
			__attribute__deprecated__
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_IS_UTF8_XIDCONT	\
	assert(p)

PERL_CALLCONV bool	Perl_is_utf8_xidfirst(pTHX_ const U8 *p)
			__attribute__deprecated__
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_IS_UTF8_XIDFIRST	\
	assert(p)

PERL_CALLCONV bool	Perl_isinfnan(NV nv);
PERL_CALLCONV bool	Perl_isinfnansv(pTHX_ SV *sv);
#define PERL_ARGS_ASSERT_ISINFNANSV	\
	assert(sv)
PERL_CALLCONV OP*	Perl_jmaybe(pTHX_ OP *o);
#define PERL_ARGS_ASSERT_JMAYBE	\
	assert(o)
PERL_CALLCONV I32	Perl_keyword(pTHX_ const char *name, I32 len, bool all_keywords)
			__attribute__pure__;
#define PERL_ARGS_ASSERT_KEYWORD	\
	assert(name)

PERL_CALLCONV int	Perl_keyword_plugin_standard(pTHX_ char* keyword_ptr, STRLEN keyword_len, OP** op_ptr);
#define PERL_ARGS_ASSERT_KEYWORD_PLUGIN_STANDARD	\
	assert(keyword_ptr); assert(op_ptr)
PERL_CALLCONV void	Perl_leave_adjust_stacks(pTHX_ SV **from_sp, SV **to_sp, U8 gimme, int filter);
#define PERL_ARGS_ASSERT_LEAVE_ADJUST_STACKS	\
	assert(from_sp); assert(to_sp)
PERL_CALLCONV void	Perl_leave_scope(pTHX_ I32 base);
PERL_CALLCONV bool	Perl_lex_bufutf8(pTHX);
PERL_CALLCONV void	Perl_lex_discard_to(pTHX_ char* ptr);
#define PERL_ARGS_ASSERT_LEX_DISCARD_TO	\
	assert(ptr)
PERL_CALLCONV char*	Perl_lex_grow_linestr(pTHX_ STRLEN len);
PERL_CALLCONV bool	Perl_lex_next_chunk(pTHX_ U32 flags);
PERL_CALLCONV I32	Perl_lex_peek_unichar(pTHX_ U32 flags);
PERL_CALLCONV void	Perl_lex_read_space(pTHX_ U32 flags);
PERL_CALLCONV void	Perl_lex_read_to(pTHX_ char* ptr);
#define PERL_ARGS_ASSERT_LEX_READ_TO	\
	assert(ptr)
PERL_CALLCONV I32	Perl_lex_read_unichar(pTHX_ U32 flags);
PERL_CALLCONV void	Perl_lex_start(pTHX_ SV* line, PerlIO *rsfp, U32 flags);
PERL_CALLCONV void	Perl_lex_stuff_pv(pTHX_ const char* pv, U32 flags);
#define PERL_ARGS_ASSERT_LEX_STUFF_PV	\
	assert(pv)
PERL_CALLCONV void	Perl_lex_stuff_pvn(pTHX_ const char* pv, STRLEN len, U32 flags);
#define PERL_ARGS_ASSERT_LEX_STUFF_PVN	\
	assert(pv)
PERL_CALLCONV void	Perl_lex_stuff_sv(pTHX_ SV* sv, U32 flags);
#define PERL_ARGS_ASSERT_LEX_STUFF_SV	\
	assert(sv)
PERL_CALLCONV void	Perl_lex_unstuff(pTHX_ char* ptr);
#define PERL_ARGS_ASSERT_LEX_UNSTUFF	\
	assert(ptr)
PERL_CALLCONV OP*	Perl_list(pTHX_ OP* o);
PERL_CALLCONV void	Perl_load_module(pTHX_ U32 flags, SV* name, SV* ver, ...);
#define PERL_ARGS_ASSERT_LOAD_MODULE	\
	assert(name)
PERL_CALLCONV OP*	Perl_localize(pTHX_ OP *o, I32 lex);
#define PERL_ARGS_ASSERT_LOCALIZE	\
	assert(o)
PERL_CALLCONV I32	Perl_looks_like_number(pTHX_ SV *const sv)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_LOOKS_LIKE_NUMBER	\
	assert(sv)

PERL_CALLCONV int	Perl_magic_clear_all_env(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_CLEAR_ALL_ENV	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_cleararylen_p(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_CLEARARYLEN_P	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_clearenv(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_CLEARENV	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_clearhint(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_CLEARHINT	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_clearhints(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_CLEARHINTS	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_clearisa(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_CLEARISA	\
	assert(mg)
PERL_CALLCONV int	Perl_magic_clearpack(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_CLEARPACK	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_clearsig(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_CLEARSIG	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_copycallchecker(pTHX_ SV* sv, MAGIC *mg, SV *nsv, const char *name, I32 namlen);
#define PERL_ARGS_ASSERT_MAGIC_COPYCALLCHECKER	\
	assert(sv); assert(mg); assert(nsv)
PERL_CALLCONV void	Perl_magic_dump(pTHX_ const MAGIC *mg);
PERL_CALLCONV int	Perl_magic_existspack(pTHX_ SV* sv, const MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_EXISTSPACK	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_freearylen_p(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_FREEARYLEN_P	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_freeovrld(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_FREEOVRLD	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_get(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_GET	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_getarylen(pTHX_ SV* sv, const MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_GETARYLEN	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_getdebugvar(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_GETDEBUGVAR	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_getdefelem(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_GETDEFELEM	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_getnkeys(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_GETNKEYS	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_getpack(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_GETPACK	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_getpos(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_GETPOS	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_getsig(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_GETSIG	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_getsubstr(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_GETSUBSTR	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_gettaint(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_GETTAINT	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_getuvar(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_GETUVAR	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_getvec(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_GETVEC	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_killbackrefs(pTHX_ SV *sv, MAGIC *mg);
#define PERL_ARGS_ASSERT_MAGIC_KILLBACKREFS	\
	assert(sv); assert(mg)
PERL_CALLCONV SV*	Perl_magic_methcall(pTHX_ SV *sv, const MAGIC *mg, SV *meth, U32 flags, U32 argc, ...);
#define PERL_ARGS_ASSERT_MAGIC_METHCALL	\
	assert(sv); assert(mg); assert(meth)
PERL_CALLCONV int	Perl_magic_nextpack(pTHX_ SV *sv, MAGIC *mg, SV *key);
#define PERL_ARGS_ASSERT_MAGIC_NEXTPACK	\
	assert(sv); assert(mg); assert(key)
PERL_CALLCONV U32	Perl_magic_regdata_cnt(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_REGDATA_CNT	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_regdatum_get(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_REGDATUM_GET	\
	assert(sv); assert(mg)
PERL_CALLCONV SV*	Perl_magic_scalarpack(pTHX_ HV *hv, MAGIC *mg);
#define PERL_ARGS_ASSERT_MAGIC_SCALARPACK	\
	assert(hv); assert(mg)
PERL_CALLCONV int	Perl_magic_set(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_SET	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_set_all_env(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_SET_ALL_ENV	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_setarylen(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_SETARYLEN	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_setdbline(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_SETDBLINE	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_setdebugvar(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_SETDEBUGVAR	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_setdefelem(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_SETDEFELEM	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_setenv(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_SETENV	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_sethint(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_SETHINT	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_setisa(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_SETISA	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_setlvref(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_SETLVREF	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_setmglob(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_SETMGLOB	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_setnkeys(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_SETNKEYS	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_setpack(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_SETPACK	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_setpos(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_SETPOS	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_setregexp(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_SETREGEXP	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_setsig(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_SETSIG	\
	assert(mg)
PERL_CALLCONV int	Perl_magic_setsubstr(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_SETSUBSTR	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_settaint(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_SETTAINT	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_setutf8(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_SETUTF8	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_setuvar(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_SETUVAR	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_setvec(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_SETVEC	\
	assert(sv); assert(mg)
PERL_CALLCONV U32	Perl_magic_sizepack(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_SIZEPACK	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_wipepack(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_WIPEPACK	\
	assert(sv); assert(mg)
PERL_CALLCONV Malloc_t	Perl_malloc(MEM_SIZE nbytes)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV I32 *	Perl_markstack_grow(pTHX);
PERL_CALLCONV SV*	Perl_mess(pTHX_ const char* pat, ...)
			__attribute__format__(__printf__,pTHX_1,pTHX_2);
#define PERL_ARGS_ASSERT_MESS	\
	assert(pat)

PERL_CALLCONV SV*	Perl_mess_sv(pTHX_ SV* basemsg, bool consume);
#define PERL_ARGS_ASSERT_MESS_SV	\
	assert(basemsg)
PERL_CALLCONV Free_t	Perl_mfree(Malloc_t where);
PERL_CALLCONV int	Perl_mg_clear(pTHX_ SV* sv);
#define PERL_ARGS_ASSERT_MG_CLEAR	\
	assert(sv)
PERL_CALLCONV int	Perl_mg_copy(pTHX_ SV *sv, SV *nsv, const char *key, I32 klen);
#define PERL_ARGS_ASSERT_MG_COPY	\
	assert(sv); assert(nsv)
PERL_CALLCONV MAGIC*	Perl_mg_find(const SV* sv, int type)
			__attribute__warn_unused_result__;

PERL_CALLCONV MAGIC*	Perl_mg_find_mglob(pTHX_ SV* sv)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_MG_FIND_MGLOB	\
	assert(sv)

PERL_CALLCONV MAGIC*	Perl_mg_findext(const SV* sv, int type, const MGVTBL *vtbl)
			__attribute__warn_unused_result__;

PERL_CALLCONV int	Perl_mg_free(pTHX_ SV* sv);
#define PERL_ARGS_ASSERT_MG_FREE	\
	assert(sv)
PERL_CALLCONV void	Perl_mg_free_type(pTHX_ SV* sv, int how);
#define PERL_ARGS_ASSERT_MG_FREE_TYPE	\
	assert(sv)
PERL_CALLCONV int	Perl_mg_get(pTHX_ SV* sv);
#define PERL_ARGS_ASSERT_MG_GET	\
	assert(sv)
PERL_CALLCONV U32	Perl_mg_length(pTHX_ SV* sv)
			__attribute__deprecated__;
#define PERL_ARGS_ASSERT_MG_LENGTH	\
	assert(sv)

PERL_CALLCONV void	Perl_mg_localize(pTHX_ SV* sv, SV* nsv, bool setmagic);
#define PERL_ARGS_ASSERT_MG_LOCALIZE	\
	assert(sv); assert(nsv)
PERL_CALLCONV void	Perl_mg_magical(SV* sv);
#define PERL_ARGS_ASSERT_MG_MAGICAL	\
	assert(sv)
PERL_CALLCONV int	Perl_mg_set(pTHX_ SV* sv);
#define PERL_ARGS_ASSERT_MG_SET	\
	assert(sv)
PERL_CALLCONV I32	Perl_mg_size(pTHX_ SV* sv);
#define PERL_ARGS_ASSERT_MG_SIZE	\
	assert(sv)
PERL_CALLCONV void	Perl_mini_mktime(struct tm *ptm);
#define PERL_ARGS_ASSERT_MINI_MKTIME	\
	assert(ptm)
PERL_CALLCONV int	Perl_mode_from_discipline(pTHX_ const char* s, STRLEN len);
PERL_CALLCONV void *	Perl_more_bodies(pTHX_ const svtype sv_type, const size_t body_size, const size_t arena_size);
PERL_CALLCONV const char*	Perl_moreswitches(pTHX_ const char* s);
#define PERL_ARGS_ASSERT_MORESWITCHES	\
	assert(s)
PERL_CALLCONV const struct mro_alg *	Perl_mro_get_from_name(pTHX_ SV *name);
#define PERL_ARGS_ASSERT_MRO_GET_FROM_NAME	\
	assert(name)
PERL_CALLCONV AV*	Perl_mro_get_linear_isa(pTHX_ HV* stash);
#define PERL_ARGS_ASSERT_MRO_GET_LINEAR_ISA	\
	assert(stash)
PERL_CALLCONV SV*	Perl_mro_get_private_data(pTHX_ struct mro_meta *const smeta, const struct mro_alg *const which);
#define PERL_ARGS_ASSERT_MRO_GET_PRIVATE_DATA	\
	assert(smeta); assert(which)
PERL_CALLCONV void	Perl_mro_isa_changed_in(pTHX_ HV* stash);
#define PERL_ARGS_ASSERT_MRO_ISA_CHANGED_IN	\
	assert(stash)
PERL_CALLCONV struct mro_meta*	Perl_mro_meta_init(pTHX_ HV* stash);
#define PERL_ARGS_ASSERT_MRO_META_INIT	\
	assert(stash)
PERL_CALLCONV void	Perl_mro_method_changed_in(pTHX_ HV* stash);
#define PERL_ARGS_ASSERT_MRO_METHOD_CHANGED_IN	\
	assert(stash)
PERL_CALLCONV void	Perl_mro_package_moved(pTHX_ HV * const stash, HV * const oldstash, const GV * const gv, U32 flags);
#define PERL_ARGS_ASSERT_MRO_PACKAGE_MOVED	\
	assert(gv)
PERL_CALLCONV void	Perl_mro_register(pTHX_ const struct mro_alg *mro);
#define PERL_ARGS_ASSERT_MRO_REGISTER	\
	assert(mro)
PERL_CALLCONV void	Perl_mro_set_mro(pTHX_ struct mro_meta *const meta, SV *const name);
#define PERL_ARGS_ASSERT_MRO_SET_MRO	\
	assert(meta); assert(name)
PERL_CALLCONV SV*	Perl_mro_set_private_data(pTHX_ struct mro_meta *const smeta, const struct mro_alg *const which, SV *const data);
#define PERL_ARGS_ASSERT_MRO_SET_PRIVATE_DATA	\
	assert(smeta); assert(which); assert(data)
PERL_CALLCONV SV*	Perl_multideref_stringify(pTHX_ const OP* o, CV *cv);
#define PERL_ARGS_ASSERT_MULTIDEREF_STRINGIFY	\
	assert(o)
PERL_CALLCONV NV	Perl_my_atof(pTHX_ const char *s);
#define PERL_ARGS_ASSERT_MY_ATOF	\
	assert(s)
PERL_CALLCONV char*	Perl_my_atof2(pTHX_ const char *s, NV* value);
#define PERL_ARGS_ASSERT_MY_ATOF2	\
	assert(s); assert(value)
PERL_CALLCONV OP *	Perl_my_attrs(pTHX_ OP *o, OP *attrs);
#define PERL_ARGS_ASSERT_MY_ATTRS	\
	assert(o)
PERL_CALLCONV void	Perl_my_clearenv(pTHX);
PERL_CALLCONV int	Perl_my_dirfd(DIR* dir);
PERL_CALLCONV_NO_RET void	Perl_my_exit(pTHX_ U32 status)
			__attribute__noreturn__;

PERL_CALLCONV_NO_RET void	Perl_my_failure_exit(pTHX)
			__attribute__noreturn__;

PERL_CALLCONV I32	Perl_my_fflush_all(pTHX);
PERL_CALLCONV Pid_t	Perl_my_fork(void);
/* PERL_CALLCONV I32	Perl_my_lstat(pTHX); */
PERL_CALLCONV I32	Perl_my_lstat_flags(pTHX_ const U32 flags);
PERL_CALLCONV PerlIO*	Perl_my_popen_list(pTHX_ const char* mode, int n, SV ** args);
#define PERL_ARGS_ASSERT_MY_POPEN_LIST	\
	assert(mode); assert(args)
PERL_CALLCONV void	Perl_my_setenv(pTHX_ const char* nam, const char* val);
PERL_CALLCONV int	Perl_my_snprintf(char *buffer, const Size_t len, const char *format, ...)
			__attribute__format__(__printf__,3,4);
#define PERL_ARGS_ASSERT_MY_SNPRINTF	\
	assert(buffer); assert(format)

PERL_CALLCONV int	Perl_my_socketpair(int family, int type, int protocol, int fd[2]);
/* PERL_CALLCONV I32	Perl_my_stat(pTHX); */
PERL_CALLCONV I32	Perl_my_stat_flags(pTHX_ const U32 flags);
PERL_CALLCONV char*	Perl_my_strerror(pTHX_ const int errnum);
PERL_CALLCONV char *	Perl_my_strftime(pTHX_ const char *fmt, int sec, int min, int hour, int mday, int mon, int year, int wday, int yday, int isdst)
			__attribute__format__(__strftime__,pTHX_1,0);
#define PERL_ARGS_ASSERT_MY_STRFTIME	\
	assert(fmt)

PERL_CALLCONV void	Perl_my_unexec(pTHX);
PERL_CALLCONV int	Perl_my_vsnprintf(char *buffer, const Size_t len, const char *format, va_list ap);
#define PERL_ARGS_ASSERT_MY_VSNPRINTF	\
	assert(buffer); assert(format)
PERL_CALLCONV OP*	Perl_newANONATTRSUB(pTHX_ I32 floor, OP *proto, OP *attrs, OP *block);
PERL_CALLCONV OP*	Perl_newANONHASH(pTHX_ OP* o)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV OP*	Perl_newANONLIST(pTHX_ OP* o)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV OP*	Perl_newANONSUB(pTHX_ I32 floor, OP* proto, OP* block);
PERL_CALLCONV OP*	Perl_newASSIGNOP(pTHX_ I32 flags, OP* left, I32 optype, OP* right)
			__attribute__malloc__
			__attribute__warn_unused_result__;

/* PERL_CALLCONV CV*	newATTRSUB(pTHX_ I32 floor, OP *o, OP *proto, OP *attrs, OP *block); */
PERL_CALLCONV CV*	Perl_newATTRSUB_x(pTHX_ I32 floor, OP *o, OP *proto, OP *attrs, OP *block, bool o_is_gv);
/* PERL_CALLCONV AV*	Perl_newAV(pTHX)
			__attribute__warn_unused_result__; */

PERL_CALLCONV OP*	Perl_newAVREF(pTHX_ OP* o)
			__attribute__malloc__
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWAVREF	\
	assert(o)

PERL_CALLCONV OP*	Perl_newBINOP(pTHX_ I32 type, I32 flags, OP* first, OP* last)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV OP*	Perl_newCONDOP(pTHX_ I32 flags, OP* first, OP* trueop, OP* falseop)
			__attribute__malloc__
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWCONDOP	\
	assert(first)

PERL_CALLCONV CV*	Perl_newCONSTSUB(pTHX_ HV* stash, const char* name, SV* sv);
PERL_CALLCONV CV*	Perl_newCONSTSUB_flags(pTHX_ HV* stash, const char* name, STRLEN len, U32 flags, SV* sv);
PERL_CALLCONV OP*	Perl_newCVREF(pTHX_ I32 flags, OP* o)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV OP*	Perl_newDEFSVOP(pTHX)
			__attribute__warn_unused_result__;

PERL_CALLCONV void	Perl_newFORM(pTHX_ I32 floor, OP* o, OP* block);
PERL_CALLCONV OP*	Perl_newFOROP(pTHX_ I32 flags, OP* sv, OP* expr, OP* block, OP* cont)
			__attribute__malloc__
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWFOROP	\
	assert(expr)

PERL_CALLCONV OP*	Perl_newGIVENOP(pTHX_ OP* cond, OP* block, PADOFFSET defsv_off)
			__attribute__malloc__
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWGIVENOP	\
	assert(cond); assert(block)

PERL_CALLCONV GP *	Perl_newGP(pTHX_ GV *const gv);
#define PERL_ARGS_ASSERT_NEWGP	\
	assert(gv)
PERL_CALLCONV OP*	Perl_newGVOP(pTHX_ I32 type, I32 flags, GV* gv)
			__attribute__malloc__
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWGVOP	\
	assert(gv)

PERL_CALLCONV OP*	Perl_newGVREF(pTHX_ I32 type, OP* o)
			__attribute__malloc__
			__attribute__warn_unused_result__;

/* PERL_CALLCONV GV*	newGVgen(pTHX_ const char* pack); */
PERL_CALLCONV GV*	Perl_newGVgen_flags(pTHX_ const char* pack, U32 flags)
			__attribute__malloc__
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWGVGEN_FLAGS	\
	assert(pack)

/* PERL_CALLCONV HV*	Perl_newHV(pTHX)
			__attribute__warn_unused_result__; */

PERL_CALLCONV OP*	Perl_newHVREF(pTHX_ OP* o)
			__attribute__malloc__
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWHVREF	\
	assert(o)

PERL_CALLCONV HV*	Perl_newHVhv(pTHX_ HV *hv)
			__attribute__malloc__
			__attribute__warn_unused_result__;

/* PERL_CALLCONV IO*	Perl_newIO(pTHX)
			__attribute__malloc__
			__attribute__warn_unused_result__; */

PERL_CALLCONV OP*	Perl_newLISTOP(pTHX_ I32 type, I32 flags, OP* first, OP* last)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV OP*	Perl_newLOGOP(pTHX_ I32 optype, I32 flags, OP *first, OP *other)
			__attribute__malloc__
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWLOGOP	\
	assert(first); assert(other)

PERL_CALLCONV OP*	Perl_newLOOPEX(pTHX_ I32 type, OP* label)
			__attribute__malloc__
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWLOOPEX	\
	assert(label)

PERL_CALLCONV OP*	Perl_newLOOPOP(pTHX_ I32 flags, I32 debuggable, OP* expr, OP* block)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV OP*	Perl_newMETHOP(pTHX_ I32 type, I32 flags, OP* dynamic_meth)
			__attribute__malloc__
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWMETHOP	\
	assert(dynamic_meth)

PERL_CALLCONV OP*	Perl_newMETHOP_named(pTHX_ I32 type, I32 flags, SV* const_meth)
			__attribute__malloc__
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWMETHOP_NAMED	\
	assert(const_meth)

PERL_CALLCONV CV *	Perl_newMYSUB(pTHX_ I32 floor, OP *o, OP *proto, OP *attrs, OP *block);
#define PERL_ARGS_ASSERT_NEWMYSUB	\
	assert(o)
PERL_CALLCONV OP*	Perl_newNULLLIST(pTHX)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV OP*	Perl_newOP(pTHX_ I32 optype, I32 flags)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV PADNAMELIST *	Perl_newPADNAMELIST(size_t max)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV PADNAME *	Perl_newPADNAMEouter(PADNAME *outer)
			__attribute__malloc__
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWPADNAMEOUTER	\
	assert(outer)

PERL_CALLCONV PADNAME *	Perl_newPADNAMEpvn(const char *s, STRLEN len)
			__attribute__malloc__
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWPADNAMEPVN	\
	assert(s)

PERL_CALLCONV OP*	Perl_newPMOP(pTHX_ I32 type, I32 flags)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV void	Perl_newPROG(pTHX_ OP* o);
#define PERL_ARGS_ASSERT_NEWPROG	\
	assert(o)
PERL_CALLCONV OP*	Perl_newPVOP(pTHX_ I32 type, I32 flags, char* pv)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV OP*	Perl_newRANGE(pTHX_ I32 flags, OP* left, OP* right)
			__attribute__malloc__
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWRANGE	\
	assert(left); assert(right)

PERL_CALLCONV SV*	Perl_newRV(pTHX_ SV *const sv)
			__attribute__malloc__
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWRV	\
	assert(sv)

PERL_CALLCONV SV*	Perl_newRV_noinc(pTHX_ SV *const tmpRef)
			__attribute__malloc__
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWRV_NOINC	\
	assert(tmpRef)

PERL_CALLCONV OP*	Perl_newSLICEOP(pTHX_ I32 flags, OP* subscript, OP* listop)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV OP*	Perl_newSTATEOP(pTHX_ I32 flags, char* label, OP* o)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV CV*	Perl_newSTUB(pTHX_ GV *gv, bool fake);
#define PERL_ARGS_ASSERT_NEWSTUB	\
	assert(gv)
/* PERL_CALLCONV CV*	Perl_newSUB(pTHX_ I32 floor, OP* o, OP* proto, OP* block); */
PERL_CALLCONV SV*	Perl_newSV(pTHX_ const STRLEN len)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV OP*	Perl_newSVOP(pTHX_ I32 type, I32 flags, SV* sv)
			__attribute__malloc__
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWSVOP	\
	assert(sv)

PERL_CALLCONV OP*	Perl_newSVREF(pTHX_ OP* o)
			__attribute__malloc__
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWSVREF	\
	assert(o)

PERL_CALLCONV SV*	Perl_newSV_type(pTHX_ const svtype type)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV SV*	Perl_newSVavdefelem(pTHX_ AV *av, SSize_t ix, bool extendible)
			__attribute__malloc__
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWSVAVDEFELEM	\
	assert(av)

PERL_CALLCONV SV*	Perl_newSVhek(pTHX_ const HEK *const hek)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV SV*	Perl_newSViv(pTHX_ const IV i)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV SV*	Perl_newSVnv(pTHX_ const NV n)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV SV*	Perl_newSVpv(pTHX_ const char *const s, const STRLEN len)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV SV*	Perl_newSVpv_share(pTHX_ const char* s, U32 hash)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV SV*	Perl_newSVpvf(pTHX_ const char *const pat, ...)
			__attribute__malloc__
			__attribute__warn_unused_result__
			__attribute__format__(__printf__,pTHX_1,pTHX_2);
#define PERL_ARGS_ASSERT_NEWSVPVF	\
	assert(pat)

PERL_CALLCONV SV*	Perl_newSVpvn(pTHX_ const char *const s, const STRLEN len)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV SV*	Perl_newSVpvn_flags(pTHX_ const char *const s, const STRLEN len, const U32 flags)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV SV*	Perl_newSVpvn_share(pTHX_ const char* s, I32 len, U32 hash)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV SV*	Perl_newSVrv(pTHX_ SV *const rv, const char *const classname);
#define PERL_ARGS_ASSERT_NEWSVRV	\
	assert(rv)
PERL_CALLCONV SV*	Perl_newSVsv(pTHX_ SV *const old)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV SV*	Perl_newSVuv(pTHX_ const UV u)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV OP*	Perl_newUNOP(pTHX_ I32 type, I32 flags, OP* first)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV OP*	Perl_newUNOP_AUX(pTHX_ I32 type, I32 flags, OP* first, UNOP_AUX_item *aux)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV OP*	Perl_newWHENOP(pTHX_ OP* cond, OP* block)
			__attribute__malloc__
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWWHENOP	\
	assert(block)

PERL_CALLCONV OP*	Perl_newWHILEOP(pTHX_ I32 flags, I32 debuggable, LOOP* loop, OP* expr, OP* block, OP* cont, I32 has_my)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV CV*	Perl_newXS(pTHX_ const char *name, XSUBADDR_t subaddr, const char *filename);
#define PERL_ARGS_ASSERT_NEWXS	\
	assert(subaddr); assert(filename)
PERL_CALLCONV CV *	Perl_newXS_deffile(pTHX_ const char *name, XSUBADDR_t subaddr);
#define PERL_ARGS_ASSERT_NEWXS_DEFFILE	\
	assert(name); assert(subaddr)
PERL_CALLCONV CV *	Perl_newXS_flags(pTHX_ const char *name, XSUBADDR_t subaddr, const char *const filename, const char *const proto, U32 flags);
#define PERL_ARGS_ASSERT_NEWXS_FLAGS	\
	assert(subaddr); assert(filename)
PERL_CALLCONV CV *	Perl_newXS_len_flags(pTHX_ const char *name, STRLEN len, XSUBADDR_t subaddr, const char *const filename, const char *const proto, SV **const_svp, U32 flags);
#define PERL_ARGS_ASSERT_NEWXS_LEN_FLAGS	\
	assert(subaddr)
PERL_CALLCONV void	Perl_new_collate(pTHX_ const char* newcoll);
PERL_CALLCONV void	Perl_new_ctype(pTHX_ const char* newctype);
#define PERL_ARGS_ASSERT_NEW_CTYPE	\
	assert(newctype)
PERL_CALLCONV void	Perl_new_numeric(pTHX_ const char* newcoll);
PERL_CALLCONV PERL_SI*	Perl_new_stackinfo(pTHX_ I32 stitems, I32 cxitems)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV SV*	Perl_new_version(pTHX_ SV *ver);
#define PERL_ARGS_ASSERT_NEW_VERSION	\
	assert(ver)
PERL_CALLCONV STRLEN *	Perl_new_warnings_bitfield(pTHX_ STRLEN *buffer, const char *const bits, STRLEN size)
			__attribute__malloc__
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEW_WARNINGS_BITFIELD	\
	assert(bits)

PERL_CALLCONV PerlIO*	Perl_nextargv(pTHX_ GV* gv, bool nomagicopen);
#define PERL_ARGS_ASSERT_NEXTARGV	\
	assert(gv)
PERL_CALLCONV char*	Perl_ninstr(const char* big, const char* bigend, const char* little, const char* lend)
			__attribute__pure__;
#define PERL_ARGS_ASSERT_NINSTR	\
	assert(big); assert(bigend); assert(little); assert(lend)

PERL_CALLCONV_NO_RET void	Perl_noperl_die(const char* pat, ...)
			__attribute__noreturn__
			__attribute__format__(__printf__,1,2);
#define PERL_ARGS_ASSERT_NOPERL_DIE	\
	assert(pat)

PERL_CALLCONV int	Perl_nothreadhook(pTHX);
PERL_CALLCONV OP*	Perl_oopsAV(pTHX_ OP* o)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_OOPSAV	\
	assert(o)

PERL_CALLCONV OP*	Perl_oopsHV(pTHX_ OP* o)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_OOPSHV	\
	assert(o)

PERL_CALLCONV OP*	Perl_op_append_elem(pTHX_ I32 optype, OP* first, OP* last);
PERL_CALLCONV OP*	Perl_op_append_list(pTHX_ I32 optype, OP* first, OP* last);
PERL_CALLCONV void	Perl_op_clear(pTHX_ OP* o);
#define PERL_ARGS_ASSERT_OP_CLEAR	\
	assert(o)
PERL_CALLCONV OP*	Perl_op_contextualize(pTHX_ OP* o, I32 context);
#define PERL_ARGS_ASSERT_OP_CONTEXTUALIZE	\
	assert(o)
PERL_CALLCONV OP*	Perl_op_convert_list(pTHX_ I32 optype, I32 flags, OP* o)
			__attribute__warn_unused_result__;

PERL_CALLCONV void	Perl_op_dump(pTHX_ const OP *o);
#define PERL_ARGS_ASSERT_OP_DUMP	\
	assert(o)
PERL_CALLCONV void	Perl_op_free(pTHX_ OP* arg);
PERL_CALLCONV OP*	Perl_op_linklist(pTHX_ OP *o);
#define PERL_ARGS_ASSERT_OP_LINKLIST	\
	assert(o)
/* PERL_CALLCONV OP*	op_lvalue(pTHX_ OP* o, I32 type); */
PERL_CALLCONV OP*	Perl_op_lvalue_flags(pTHX_ OP* o, I32 type, U32 flags);
PERL_CALLCONV void	Perl_op_null(pTHX_ OP* o);
#define PERL_ARGS_ASSERT_OP_NULL	\
	assert(o)
PERL_CALLCONV OP*	Perl_op_prepend_elem(pTHX_ I32 optype, OP* first, OP* last);
PERL_CALLCONV void	Perl_op_refcnt_lock(pTHX);
PERL_CALLCONV void	Perl_op_refcnt_unlock(pTHX);
PERL_CALLCONV OP*	Perl_op_scope(pTHX_ OP* o);
PERL_CALLCONV OP*	Perl_op_sibling_splice(OP *parent, OP *start, int del_count, OP* insert);
PERL_CALLCONV OP*	Perl_op_unscope(pTHX_ OP* o);
PERL_CALLCONV void	Perl_pack_cat(pTHX_ SV *cat, const char *pat, const char *patend, SV **beglist, SV **endlist, SV ***next_in_list, U32 flags);
#define PERL_ARGS_ASSERT_PACK_CAT	\
	assert(cat); assert(pat); assert(patend); assert(beglist); assert(endlist); assert(next_in_list)
PERL_CALLCONV void	Perl_package(pTHX_ OP* o);
#define PERL_ARGS_ASSERT_PACKAGE	\
	assert(o)
PERL_CALLCONV void	Perl_package_version(pTHX_ OP* v);
#define PERL_ARGS_ASSERT_PACKAGE_VERSION	\
	assert(v)
PERL_CALLCONV void	Perl_packlist(pTHX_ SV *cat, const char *pat, const char *patend, SV **beglist, SV **endlist);
#define PERL_ARGS_ASSERT_PACKLIST	\
	assert(cat); assert(pat); assert(patend); assert(beglist); assert(endlist)
PERL_CALLCONV PADOFFSET	Perl_pad_add_anon(pTHX_ CV* func, I32 optype);
#define PERL_ARGS_ASSERT_PAD_ADD_ANON	\
	assert(func)
PERL_CALLCONV PADOFFSET	Perl_pad_add_name_pv(pTHX_ const char *name, const U32 flags, HV *typestash, HV *ourstash);
#define PERL_ARGS_ASSERT_PAD_ADD_NAME_PV	\
	assert(name)
PERL_CALLCONV PADOFFSET	Perl_pad_add_name_pvn(pTHX_ const char *namepv, STRLEN namelen, U32 flags, HV *typestash, HV *ourstash);
#define PERL_ARGS_ASSERT_PAD_ADD_NAME_PVN	\
	assert(namepv)
PERL_CALLCONV PADOFFSET	Perl_pad_add_name_sv(pTHX_ SV *name, U32 flags, HV *typestash, HV *ourstash);
#define PERL_ARGS_ASSERT_PAD_ADD_NAME_SV	\
	assert(name)
PERL_CALLCONV void	Perl_pad_add_weakref(pTHX_ CV* func);
#define PERL_ARGS_ASSERT_PAD_ADD_WEAKREF	\
	assert(func)
PERL_CALLCONV PADOFFSET	Perl_pad_alloc(pTHX_ I32 optype, U32 tmptype);
PERL_CALLCONV void	Perl_pad_block_start(pTHX_ int full);
PERL_CALLCONV HV*	Perl_pad_compname_type(pTHX_ const PADOFFSET po)
			__attribute__warn_unused_result__;

PERL_CALLCONV PADOFFSET	Perl_pad_findmy_pv(pTHX_ const char* name, U32 flags);
#define PERL_ARGS_ASSERT_PAD_FINDMY_PV	\
	assert(name)
PERL_CALLCONV PADOFFSET	Perl_pad_findmy_pvn(pTHX_ const char* namepv, STRLEN namelen, U32 flags);
#define PERL_ARGS_ASSERT_PAD_FINDMY_PVN	\
	assert(namepv)
PERL_CALLCONV PADOFFSET	Perl_pad_findmy_sv(pTHX_ SV* name, U32 flags);
#define PERL_ARGS_ASSERT_PAD_FINDMY_SV	\
	assert(name)
PERL_CALLCONV void	Perl_pad_fixup_inner_anons(pTHX_ PADLIST *padlist, CV *old_cv, CV *new_cv);
#define PERL_ARGS_ASSERT_PAD_FIXUP_INNER_ANONS	\
	assert(padlist); assert(old_cv); assert(new_cv)
PERL_CALLCONV void	Perl_pad_free(pTHX_ PADOFFSET po);
PERL_CALLCONV OP *	Perl_pad_leavemy(pTHX);
PERL_CALLCONV PADLIST*	Perl_pad_new(pTHX_ int flags)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV void	Perl_pad_push(pTHX_ PADLIST *padlist, int depth);
#define PERL_ARGS_ASSERT_PAD_PUSH	\
	assert(padlist)
PERL_CALLCONV void	Perl_pad_swipe(pTHX_ PADOFFSET po, bool refadjust);
PERL_CALLCONV void	Perl_pad_tidy(pTHX_ padtidy_type type);
PERL_CALLCONV PAD **	Perl_padlist_store(pTHX_ PADLIST *padlist, I32 key, PAD *val);
#define PERL_ARGS_ASSERT_PADLIST_STORE	\
	assert(padlist)
PERL_CALLCONV void	Perl_padname_free(pTHX_ PADNAME *pn);
#define PERL_ARGS_ASSERT_PADNAME_FREE	\
	assert(pn)
PERL_CALLCONV PADNAME *	Perl_padnamelist_fetch(PADNAMELIST *pnl, SSize_t key)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_PADNAMELIST_FETCH	\
	assert(pnl)

PERL_CALLCONV void	Perl_padnamelist_free(pTHX_ PADNAMELIST *pnl);
#define PERL_ARGS_ASSERT_PADNAMELIST_FREE	\
	assert(pnl)
PERL_CALLCONV PADNAME **	Perl_padnamelist_store(pTHX_ PADNAMELIST *pnl, SSize_t key, PADNAME *val);
#define PERL_ARGS_ASSERT_PADNAMELIST_STORE	\
	assert(pnl)
PERL_CALLCONV OP*	Perl_parse_arithexpr(pTHX_ U32 flags);
PERL_CALLCONV OP*	Perl_parse_barestmt(pTHX_ U32 flags);
PERL_CALLCONV OP*	Perl_parse_block(pTHX_ U32 flags);
PERL_CALLCONV OP*	Perl_parse_fullexpr(pTHX_ U32 flags);
PERL_CALLCONV OP*	Perl_parse_fullstmt(pTHX_ U32 flags);
PERL_CALLCONV SV*	Perl_parse_label(pTHX_ U32 flags);
PERL_CALLCONV OP*	Perl_parse_listexpr(pTHX_ U32 flags);
PERL_CALLCONV OP*	Perl_parse_stmtseq(pTHX_ U32 flags);
PERL_CALLCONV OP *	Perl_parse_subsignature(pTHX)
			__attribute__warn_unused_result__;

PERL_CALLCONV OP*	Perl_parse_termexpr(pTHX_ U32 flags);
PERL_CALLCONV U32	Perl_parse_unicode_opts(pTHX_ const char **popt);
#define PERL_ARGS_ASSERT_PARSE_UNICODE_OPTS	\
	assert(popt)
PERL_CALLCONV void	Perl_parser_free(pTHX_ const yy_parser *parser);
#define PERL_ARGS_ASSERT_PARSER_FREE	\
	assert(parser)
PERL_CALLCONV void	Perl_peep(pTHX_ OP* o);
PERL_CALLCONV PerlInterpreter*	perl_alloc(void);
PERL_CALLCONV void	perl_construct(PerlInterpreter *my_perl);
#define PERL_ARGS_ASSERT_PERL_CONSTRUCT	\
	assert(my_perl)
PERL_CALLCONV int	perl_destruct(PerlInterpreter *my_perl);
#define PERL_ARGS_ASSERT_PERL_DESTRUCT	\
	assert(my_perl)
PERL_CALLCONV void	perl_free(PerlInterpreter *my_perl);
#define PERL_ARGS_ASSERT_PERL_FREE	\
	assert(my_perl)
PERL_CALLCONV int	perl_parse(PerlInterpreter *my_perl, XSINIT_t xsinit, int argc, char** argv, char** env);
#define PERL_ARGS_ASSERT_PERL_PARSE	\
	assert(my_perl)
PERL_CALLCONV int	perl_run(PerlInterpreter *my_perl);
#define PERL_ARGS_ASSERT_PERL_RUN	\
	assert(my_perl)
PERL_CALLCONV void	Perl_pmop_dump(pTHX_ PMOP* pm);
PERL_CALLCONV OP*	Perl_pmruntime(pTHX_ OP *o, OP *expr, OP *repl, bool isreg, I32 floor);
#define PERL_ARGS_ASSERT_PMRUNTIME	\
	assert(o); assert(expr)
PERL_CALLCONV void	Perl_pop_scope(pTHX);
PERL_CALLCONV void	Perl_populate_isa(pTHX_ const char *name, STRLEN len, ...);
#define PERL_ARGS_ASSERT_POPULATE_ISA	\
	assert(name)
PERL_CALLCONV REGEXP*	Perl_pregcomp(pTHX_ SV * const pattern, const U32 flags);
#define PERL_ARGS_ASSERT_PREGCOMP	\
	assert(pattern)
PERL_CALLCONV I32	Perl_pregexec(pTHX_ REGEXP * const prog, char* stringarg, char* strend, char* strbeg, SSize_t minend, SV* screamer, U32 nosave);
#define PERL_ARGS_ASSERT_PREGEXEC	\
	assert(prog); assert(stringarg); assert(strend); assert(strbeg); assert(screamer)
PERL_CALLCONV void	Perl_pregfree(pTHX_ REGEXP* r);
PERL_CALLCONV void	Perl_pregfree2(pTHX_ REGEXP *rx);
#define PERL_ARGS_ASSERT_PREGFREE2	\
	assert(rx)
PERL_CALLCONV const char*	Perl_prescan_version(pTHX_ const char *s, bool strict, const char** errstr, bool *sqv, int *ssaw_decimal, int *swidth, bool *salpha);
#define PERL_ARGS_ASSERT_PRESCAN_VERSION	\
	assert(s)
PERL_CALLCONV void	Perl_ptr_table_clear(pTHX_ PTR_TBL_t *const tbl)
			__attribute__deprecated__;

PERL_CALLCONV void*	Perl_ptr_table_fetch(pTHX_ PTR_TBL_t *const tbl, const void *const sv)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_PTR_TABLE_FETCH	\
	assert(tbl)

PERL_CALLCONV void	Perl_ptr_table_free(pTHX_ PTR_TBL_t *const tbl);
PERL_CALLCONV PTR_TBL_t*	Perl_ptr_table_new(pTHX)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV void	Perl_ptr_table_split(pTHX_ PTR_TBL_t *const tbl);
#define PERL_ARGS_ASSERT_PTR_TABLE_SPLIT	\
	assert(tbl)
PERL_CALLCONV void	Perl_ptr_table_store(pTHX_ PTR_TBL_t *const tbl, const void *const oldsv, void *const newsv);
#define PERL_ARGS_ASSERT_PTR_TABLE_STORE	\
	assert(tbl); assert(newsv)
PERL_CALLCONV void	Perl_push_scope(pTHX);
PERL_CALLCONV char*	Perl_pv_display(pTHX_ SV *dsv, const char *pv, STRLEN cur, STRLEN len, STRLEN pvlim);
#define PERL_ARGS_ASSERT_PV_DISPLAY	\
	assert(dsv); assert(pv)
PERL_CALLCONV char*	Perl_pv_escape(pTHX_ SV *dsv, char const * const str, const STRLEN count, const STRLEN max, STRLEN * const escaped, const U32 flags);
#define PERL_ARGS_ASSERT_PV_ESCAPE	\
	assert(str)
PERL_CALLCONV char*	Perl_pv_pretty(pTHX_ SV *dsv, char const * const str, const STRLEN count, const STRLEN max, char const * const start_color, char const * const end_color, const U32 flags);
#define PERL_ARGS_ASSERT_PV_PRETTY	\
	assert(dsv); assert(str)
PERL_CALLCONV char*	Perl_pv_uni_display(pTHX_ SV *dsv, const U8 *spv, STRLEN len, STRLEN pvlim, UV flags);
#define PERL_ARGS_ASSERT_PV_UNI_DISPLAY	\
	assert(dsv); assert(spv)
PERL_CALLCONV void	Perl_qerror(pTHX_ SV* err);
#define PERL_ARGS_ASSERT_QERROR	\
	assert(err)
PERL_CALLCONV REGEXP*	Perl_re_compile(pTHX_ SV * const pattern, U32 orig_rx_flags);
#define PERL_ARGS_ASSERT_RE_COMPILE	\
	assert(pattern)
PERL_CALLCONV char*	Perl_re_intuit_start(pTHX_ REGEXP * const rx, SV* sv, const char* const strbeg, char* strpos, char* strend, const U32 flags, re_scream_pos_data *data);
#define PERL_ARGS_ASSERT_RE_INTUIT_START	\
	assert(rx); assert(strbeg); assert(strpos); assert(strend)
PERL_CALLCONV SV*	Perl_re_intuit_string(pTHX_ REGEXP  *const r);
#define PERL_ARGS_ASSERT_RE_INTUIT_STRING	\
	assert(r)
PERL_CALLCONV REGEXP*	Perl_re_op_compile(pTHX_ SV ** const patternp, int pat_count, OP *expr, const regexp_engine* eng, REGEXP *old_re, bool *is_bare_re, U32 rx_flags, U32 pm_flags);
#define PERL_ARGS_ASSERT_RE_OP_COMPILE	\
	assert(eng)
PERL_CALLCONV Malloc_t	Perl_realloc(Malloc_t where, MEM_SIZE nbytes)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV void	Perl_reentrant_free(pTHX);
PERL_CALLCONV void	Perl_reentrant_init(pTHX);
PERL_CALLCONV void*	Perl_reentrant_retry(const char *f, ...);
#define PERL_ARGS_ASSERT_REENTRANT_RETRY	\
	assert(f)
PERL_CALLCONV void	Perl_reentrant_size(pTHX);
/* PERL_CALLCONV OP*	Perl_ref(pTHX_ OP* o, I32 type); */
PERL_CALLCONV HV *	Perl_refcounted_he_chain_2hv(pTHX_ const struct refcounted_he *c, U32 flags);
PERL_CALLCONV SV *	Perl_refcounted_he_fetch_pv(pTHX_ const struct refcounted_he *chain, const char *key, U32 hash, U32 flags);
#define PERL_ARGS_ASSERT_REFCOUNTED_HE_FETCH_PV	\
	assert(key)
PERL_CALLCONV SV *	Perl_refcounted_he_fetch_pvn(pTHX_ const struct refcounted_he *chain, const char *keypv, STRLEN keylen, U32 hash, U32 flags);
#define PERL_ARGS_ASSERT_REFCOUNTED_HE_FETCH_PVN	\
	assert(keypv)
PERL_CALLCONV SV *	Perl_refcounted_he_fetch_sv(pTHX_ const struct refcounted_he *chain, SV *key, U32 hash, U32 flags);
#define PERL_ARGS_ASSERT_REFCOUNTED_HE_FETCH_SV	\
	assert(key)
PERL_CALLCONV void	Perl_refcounted_he_free(pTHX_ struct refcounted_he *he);
PERL_CALLCONV struct refcounted_he *	Perl_refcounted_he_inc(pTHX_ struct refcounted_he *he);
PERL_CALLCONV struct refcounted_he *	Perl_refcounted_he_new_pv(pTHX_ struct refcounted_he *parent, const char *key, U32 hash, SV *value, U32 flags);
#define PERL_ARGS_ASSERT_REFCOUNTED_HE_NEW_PV	\
	assert(key)
PERL_CALLCONV struct refcounted_he *	Perl_refcounted_he_new_pvn(pTHX_ struct refcounted_he *parent, const char *keypv, STRLEN keylen, U32 hash, SV *value, U32 flags);
#define PERL_ARGS_ASSERT_REFCOUNTED_HE_NEW_PVN	\
	assert(keypv)
PERL_CALLCONV struct refcounted_he *	Perl_refcounted_he_new_sv(pTHX_ struct refcounted_he *parent, SV *key, U32 hash, SV *value, U32 flags);
#define PERL_ARGS_ASSERT_REFCOUNTED_HE_NEW_SV	\
	assert(key)
PERL_CALLCONV SV*	Perl_reg_named_buff(pTHX_ REGEXP * const rx, SV * const key, SV * const value, const U32 flags);
#define PERL_ARGS_ASSERT_REG_NAMED_BUFF	\
	assert(rx)
PERL_CALLCONV SV*	Perl_reg_named_buff_all(pTHX_ REGEXP * const rx, const U32 flags);
#define PERL_ARGS_ASSERT_REG_NAMED_BUFF_ALL	\
	assert(rx)
PERL_CALLCONV bool	Perl_reg_named_buff_exists(pTHX_ REGEXP * const rx, SV * const key, const U32 flags);
#define PERL_ARGS_ASSERT_REG_NAMED_BUFF_EXISTS	\
	assert(rx); assert(key)
PERL_CALLCONV SV*	Perl_reg_named_buff_fetch(pTHX_ REGEXP * const rx, SV * const namesv, const U32 flags);
#define PERL_ARGS_ASSERT_REG_NAMED_BUFF_FETCH	\
	assert(rx); assert(namesv)
PERL_CALLCONV SV*	Perl_reg_named_buff_firstkey(pTHX_ REGEXP * const rx, const U32 flags);
#define PERL_ARGS_ASSERT_REG_NAMED_BUFF_FIRSTKEY	\
	assert(rx)
PERL_CALLCONV SV*	Perl_reg_named_buff_iter(pTHX_ REGEXP * const rx, const SV * const lastkey, const U32 flags);
#define PERL_ARGS_ASSERT_REG_NAMED_BUFF_ITER	\
	assert(rx)
PERL_CALLCONV SV*	Perl_reg_named_buff_nextkey(pTHX_ REGEXP * const rx, const U32 flags);
#define PERL_ARGS_ASSERT_REG_NAMED_BUFF_NEXTKEY	\
	assert(rx)
PERL_CALLCONV SV*	Perl_reg_named_buff_scalar(pTHX_ REGEXP * const rx, const U32 flags);
#define PERL_ARGS_ASSERT_REG_NAMED_BUFF_SCALAR	\
	assert(rx)
PERL_CALLCONV void	Perl_reg_numbered_buff_fetch(pTHX_ REGEXP * const rx, const I32 paren, SV * const sv);
#define PERL_ARGS_ASSERT_REG_NUMBERED_BUFF_FETCH	\
	assert(rx)
PERL_CALLCONV I32	Perl_reg_numbered_buff_length(pTHX_ REGEXP * const rx, const SV * const sv, const I32 paren);
#define PERL_ARGS_ASSERT_REG_NUMBERED_BUFF_LENGTH	\
	assert(rx); assert(sv)
PERL_CALLCONV void	Perl_reg_numbered_buff_store(pTHX_ REGEXP * const rx, const I32 paren, SV const * const value);
#define PERL_ARGS_ASSERT_REG_NUMBERED_BUFF_STORE	\
	assert(rx)
PERL_CALLCONV SV*	Perl_reg_qr_package(pTHX_ REGEXP * const rx);
#define PERL_ARGS_ASSERT_REG_QR_PACKAGE	\
	assert(rx)
PERL_CALLCONV REGEXP*	Perl_reg_temp_copy(pTHX_ REGEXP* ret_x, REGEXP* rx);
#define PERL_ARGS_ASSERT_REG_TEMP_COPY	\
	assert(rx)
PERL_CALLCONV SV*	Perl_regclass_swash(pTHX_ const regexp *prog, const struct regnode *node, bool doinit, SV **listsvp, SV **altsvp);
#define PERL_ARGS_ASSERT_REGCLASS_SWASH	\
	assert(node)
PERL_CALLCONV void	Perl_regdump(pTHX_ const regexp* r);
#define PERL_ARGS_ASSERT_REGDUMP	\
	assert(r)
PERL_CALLCONV I32	Perl_regexec_flags(pTHX_ REGEXP *const rx, char *stringarg, char *strend, char *strbeg, SSize_t minend, SV *sv, void *data, U32 flags);
#define PERL_ARGS_ASSERT_REGEXEC_FLAGS	\
	assert(rx); assert(stringarg); assert(strend); assert(strbeg); assert(sv)
PERL_CALLCONV void	Perl_regfree_internal(pTHX_ REGEXP *const rx);
#define PERL_ARGS_ASSERT_REGFREE_INTERNAL	\
	assert(rx)
PERL_CALLCONV void	Perl_reginitcolors(pTHX);
PERL_CALLCONV regnode*	Perl_regnext(pTHX_ regnode* p)
			__attribute__warn_unused_result__;

PERL_CALLCONV void	Perl_repeatcpy(char* to, const char* from, I32 len, IV count);
#define PERL_ARGS_ASSERT_REPEATCPY	\
	assert(to); assert(from)
PERL_CALLCONV void	Perl_report_evil_fh(pTHX_ const GV *gv);
PERL_CALLCONV void	Perl_report_uninit(pTHX_ const SV *uninit_sv);
PERL_CALLCONV void	Perl_report_wrongway_fh(pTHX_ const GV *gv, const char have);
PERL_CALLCONV void	Perl_require_pv(pTHX_ const char* pv);
#define PERL_ARGS_ASSERT_REQUIRE_PV	\
	assert(pv)
PERL_CALLCONV char*	Perl_rninstr(const char* big, const char* bigend, const char* little, const char* lend)
			__attribute__pure__;
#define PERL_ARGS_ASSERT_RNINSTR	\
	assert(big); assert(bigend); assert(little); assert(lend)

PERL_CALLCONV void	Perl_rpeep(pTHX_ OP* o);
PERL_CALLCONV Sighandler_t	Perl_rsignal(pTHX_ int i, Sighandler_t t);
PERL_CALLCONV int	Perl_rsignal_restore(pTHX_ int i, Sigsave_t* t);
PERL_CALLCONV int	Perl_rsignal_save(pTHX_ int i, Sighandler_t t1, Sigsave_t* save);
#define PERL_ARGS_ASSERT_RSIGNAL_SAVE	\
	assert(save)
PERL_CALLCONV Sighandler_t	Perl_rsignal_state(pTHX_ int i);
PERL_CALLCONV int	Perl_runops_debug(pTHX);
PERL_CALLCONV int	Perl_runops_standard(pTHX);
PERL_CALLCONV CV*	Perl_rv2cv_op_cv(pTHX_ OP *cvop, U32 flags);
#define PERL_ARGS_ASSERT_RV2CV_OP_CV	\
	assert(cvop)
PERL_CALLCONV void	Perl_rxres_save(pTHX_ void **rsp, REGEXP *rx);
#define PERL_ARGS_ASSERT_RXRES_SAVE	\
	assert(rsp); assert(rx)
PERL_CALLCONV Malloc_t	Perl_safesyscalloc(MEM_SIZE elements, MEM_SIZE size)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV Free_t	Perl_safesysfree(Malloc_t where);
PERL_CALLCONV Malloc_t	Perl_safesysmalloc(MEM_SIZE nbytes)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV Malloc_t	Perl_safesysrealloc(Malloc_t where, MEM_SIZE nbytes)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV void	Perl_save_I16(pTHX_ I16* intp);
#define PERL_ARGS_ASSERT_SAVE_I16	\
	assert(intp)
PERL_CALLCONV void	Perl_save_I32(pTHX_ I32* intp);
#define PERL_ARGS_ASSERT_SAVE_I32	\
	assert(intp)
PERL_CALLCONV void	Perl_save_I8(pTHX_ I8* bytep);
#define PERL_ARGS_ASSERT_SAVE_I8	\
	assert(bytep)
PERL_CALLCONV void	Perl_save_adelete(pTHX_ AV *av, SSize_t key);
#define PERL_ARGS_ASSERT_SAVE_ADELETE	\
	assert(av)
/* PERL_CALLCONV void	Perl_save_aelem(pTHX_ AV* av, SSize_t idx, SV **sptr); */
PERL_CALLCONV void	Perl_save_aelem_flags(pTHX_ AV* av, SSize_t idx, SV **sptr, const U32 flags);
#define PERL_ARGS_ASSERT_SAVE_AELEM_FLAGS	\
	assert(av); assert(sptr)
PERL_CALLCONV I32	Perl_save_alloc(pTHX_ I32 size, I32 pad);
PERL_CALLCONV void	Perl_save_aptr(pTHX_ AV** aptr);
#define PERL_ARGS_ASSERT_SAVE_APTR	\
	assert(aptr)
PERL_CALLCONV AV*	Perl_save_ary(pTHX_ GV* gv);
#define PERL_ARGS_ASSERT_SAVE_ARY	\
	assert(gv)
PERL_CALLCONV void	Perl_save_bool(pTHX_ bool* boolp);
#define PERL_ARGS_ASSERT_SAVE_BOOL	\
	assert(boolp)
PERL_CALLCONV void	Perl_save_clearsv(pTHX_ SV** svp);
#define PERL_ARGS_ASSERT_SAVE_CLEARSV	\
	assert(svp)
PERL_CALLCONV void	Perl_save_delete(pTHX_ HV *hv, char *key, I32 klen);
#define PERL_ARGS_ASSERT_SAVE_DELETE	\
	assert(hv); assert(key)
PERL_CALLCONV void	Perl_save_destructor(pTHX_ DESTRUCTORFUNC_NOCONTEXT_t f, void* p);
#define PERL_ARGS_ASSERT_SAVE_DESTRUCTOR	\
	assert(p)
PERL_CALLCONV void	Perl_save_destructor_x(pTHX_ DESTRUCTORFUNC_t f, void* p);
/* PERL_CALLCONV void	Perl_save_freeop(pTHX_ OP* o); */
/* PERL_CALLCONV void	Perl_save_freepv(pTHX_ char* pv); */
/* PERL_CALLCONV void	Perl_save_freesv(pTHX_ SV* sv); */
PERL_CALLCONV void	Perl_save_generic_pvref(pTHX_ char** str);
#define PERL_ARGS_ASSERT_SAVE_GENERIC_PVREF	\
	assert(str)
PERL_CALLCONV void	Perl_save_generic_svref(pTHX_ SV** sptr);
#define PERL_ARGS_ASSERT_SAVE_GENERIC_SVREF	\
	assert(sptr)
PERL_CALLCONV void	Perl_save_gp(pTHX_ GV* gv, I32 empty);
#define PERL_ARGS_ASSERT_SAVE_GP	\
	assert(gv)
PERL_CALLCONV HV*	Perl_save_hash(pTHX_ GV* gv);
#define PERL_ARGS_ASSERT_SAVE_HASH	\
	assert(gv)
PERL_CALLCONV void	Perl_save_hdelete(pTHX_ HV *hv, SV *keysv);
#define PERL_ARGS_ASSERT_SAVE_HDELETE	\
	assert(hv); assert(keysv)
/* PERL_CALLCONV void	Perl_save_helem(pTHX_ HV *hv, SV *key, SV **sptr); */
PERL_CALLCONV void	Perl_save_helem_flags(pTHX_ HV *hv, SV *key, SV **sptr, const U32 flags);
#define PERL_ARGS_ASSERT_SAVE_HELEM_FLAGS	\
	assert(hv); assert(key); assert(sptr)
PERL_CALLCONV void	Perl_save_hints(pTHX);
PERL_CALLCONV void	Perl_save_hptr(pTHX_ HV** hptr);
#define PERL_ARGS_ASSERT_SAVE_HPTR	\
	assert(hptr)
PERL_CALLCONV void	Perl_save_int(pTHX_ int* intp);
#define PERL_ARGS_ASSERT_SAVE_INT	\
	assert(intp)
PERL_CALLCONV void	Perl_save_item(pTHX_ SV* item);
#define PERL_ARGS_ASSERT_SAVE_ITEM	\
	assert(item)
PERL_CALLCONV void	Perl_save_iv(pTHX_ IV *ivp);
#define PERL_ARGS_ASSERT_SAVE_IV	\
	assert(ivp)
PERL_CALLCONV void	Perl_save_list(pTHX_ SV** sarg, I32 maxsarg);
#define PERL_ARGS_ASSERT_SAVE_LIST	\
	assert(sarg)
PERL_CALLCONV void	Perl_save_long(pTHX_ long* longp);
#define PERL_ARGS_ASSERT_SAVE_LONG	\
	assert(longp)
/* PERL_CALLCONV void	Perl_save_mortalizesv(pTHX_ SV* sv); */
#define PERL_ARGS_ASSERT_SAVE_MORTALIZESV	\
	assert(sv)
PERL_CALLCONV void	Perl_save_nogv(pTHX_ GV* gv);
#define PERL_ARGS_ASSERT_SAVE_NOGV	\
	assert(gv)
/* PERL_CALLCONV void	Perl_save_op(pTHX); */
PERL_CALLCONV void	Perl_save_padsv_and_mortalize(pTHX_ PADOFFSET off);
PERL_CALLCONV void	Perl_save_pptr(pTHX_ char** pptr);
#define PERL_ARGS_ASSERT_SAVE_PPTR	\
	assert(pptr)
PERL_CALLCONV void	Perl_save_pushi32ptr(pTHX_ const I32 i, void *const ptr, const int type);
PERL_CALLCONV void	Perl_save_pushptr(pTHX_ void *const ptr, const int type);
PERL_CALLCONV void	Perl_save_pushptrptr(pTHX_ void *const ptr1, void *const ptr2, const int type);
PERL_CALLCONV void	Perl_save_re_context(pTHX);
PERL_CALLCONV SV*	Perl_save_scalar(pTHX_ GV* gv);
#define PERL_ARGS_ASSERT_SAVE_SCALAR	\
	assert(gv)
PERL_CALLCONV void	Perl_save_set_svflags(pTHX_ SV *sv, U32 mask, U32 val);
#define PERL_ARGS_ASSERT_SAVE_SET_SVFLAGS	\
	assert(sv)
PERL_CALLCONV void	Perl_save_shared_pvref(pTHX_ char** str);
#define PERL_ARGS_ASSERT_SAVE_SHARED_PVREF	\
	assert(str)
PERL_CALLCONV void	Perl_save_sptr(pTHX_ SV** sptr);
#define PERL_ARGS_ASSERT_SAVE_SPTR	\
	assert(sptr)
PERL_CALLCONV void	Perl_save_strlen(pTHX_ STRLEN* ptr);
#define PERL_ARGS_ASSERT_SAVE_STRLEN	\
	assert(ptr)
PERL_CALLCONV SV*	Perl_save_svref(pTHX_ SV** sptr);
#define PERL_ARGS_ASSERT_SAVE_SVREF	\
	assert(sptr)
PERL_CALLCONV void	Perl_save_vptr(pTHX_ void *ptr);
#define PERL_ARGS_ASSERT_SAVE_VPTR	\
	assert(ptr)
PERL_CALLCONV char*	Perl_savepv(pTHX_ const char* pv)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV char*	Perl_savepvn(pTHX_ const char* pv, I32 len)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV char*	Perl_savesharedpv(pTHX_ const char* pv)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV char*	Perl_savesharedpvn(pTHX_ const char *const pv, const STRLEN len)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV char*	Perl_savesharedsvpv(pTHX_ SV *sv)
			__attribute__malloc__
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_SAVESHAREDSVPV	\
	assert(sv)

PERL_CALLCONV void	Perl_savestack_grow(pTHX);
PERL_CALLCONV void	Perl_savestack_grow_cnt(pTHX_ I32 need);
PERL_CALLCONV char*	Perl_savesvpv(pTHX_ SV* sv)
			__attribute__malloc__
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_SAVESVPV	\
	assert(sv)

PERL_CALLCONV void	Perl_savetmps(pTHX);
PERL_CALLCONV OP*	Perl_sawparens(pTHX_ OP* o);
PERL_CALLCONV OP*	Perl_scalar(pTHX_ OP* o);
PERL_CALLCONV OP*	Perl_scalarvoid(pTHX_ OP* o);
#define PERL_ARGS_ASSERT_SCALARVOID	\
	assert(o)
PERL_CALLCONV NV	Perl_scan_bin(pTHX_ const char* start, STRLEN len, STRLEN* retlen);
#define PERL_ARGS_ASSERT_SCAN_BIN	\
	assert(start); assert(retlen)
PERL_CALLCONV NV	Perl_scan_hex(pTHX_ const char* start, STRLEN len, STRLEN* retlen);
#define PERL_ARGS_ASSERT_SCAN_HEX	\
	assert(start); assert(retlen)
PERL_CALLCONV char*	Perl_scan_num(pTHX_ const char* s, YYSTYPE *lvalp);
#define PERL_ARGS_ASSERT_SCAN_NUM	\
	assert(s); assert(lvalp)
PERL_CALLCONV NV	Perl_scan_oct(pTHX_ const char* start, STRLEN len, STRLEN* retlen);
#define PERL_ARGS_ASSERT_SCAN_OCT	\
	assert(start); assert(retlen)
PERL_CALLCONV const char*	Perl_scan_version(pTHX_ const char *s, SV *rv, bool qv);
#define PERL_ARGS_ASSERT_SCAN_VERSION	\
	assert(s); assert(rv)
PERL_CALLCONV char*	Perl_scan_vstring(pTHX_ const char *s, const char *const e, SV *sv);
#define PERL_ARGS_ASSERT_SCAN_VSTRING	\
	assert(s); assert(e); assert(sv)
PERL_CALLCONV U32	Perl_seed(pTHX);
PERL_CALLCONV void	Perl_set_caret_X(pTHX);
PERL_CALLCONV void	Perl_set_context(void *t);
#define PERL_ARGS_ASSERT_SET_CONTEXT	\
	assert(t)
PERL_CALLCONV void	Perl_set_numeric_local(pTHX);
PERL_CALLCONV void	Perl_set_numeric_radix(pTHX);
PERL_CALLCONV void	Perl_set_numeric_standard(pTHX);
PERL_CALLCONV void	Perl_setdefout(pTHX_ GV* gv);
#define PERL_ARGS_ASSERT_SETDEFOUT	\
	assert(gv)
PERL_CALLCONV HEK*	Perl_share_hek(pTHX_ const char* str, I32 len, U32 hash);
#define PERL_ARGS_ASSERT_SHARE_HEK	\
	assert(str)
PERL_CALLCONV void	Perl_sortsv(pTHX_ SV** array, size_t num_elts, SVCOMPARE_t cmp);
#define PERL_ARGS_ASSERT_SORTSV	\
	assert(cmp)
PERL_CALLCONV void	Perl_sortsv_flags(pTHX_ SV** array, size_t num_elts, SVCOMPARE_t cmp, U32 flags);
#define PERL_ARGS_ASSERT_SORTSV_FLAGS	\
	assert(cmp)
PERL_CALLCONV SV**	Perl_stack_grow(pTHX_ SV** sp, SV** p, SSize_t n);
#define PERL_ARGS_ASSERT_STACK_GROW	\
	assert(sp); assert(p)
PERL_CALLCONV PerlIO*	Perl_start_glob(pTHX_ SV *tmpglob, IO *io);
#define PERL_ARGS_ASSERT_START_GLOB	\
	assert(tmpglob); assert(io)
PERL_CALLCONV I32	Perl_start_subparse(pTHX_ I32 is_format, U32 flags);
PERL_CALLCONV NV	Perl_str_to_version(pTHX_ SV *sv)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_STR_TO_VERSION	\
	assert(sv)

PERL_CALLCONV void	Perl_sub_crush_depth(pTHX_ CV* cv);
#define PERL_ARGS_ASSERT_SUB_CRUSH_DEPTH	\
	assert(cv)
/* PERL_CALLCONV bool	sv_2bool(pTHX_ SV *const sv); */
PERL_CALLCONV bool	Perl_sv_2bool_flags(pTHX_ SV *sv, I32 flags);
#define PERL_ARGS_ASSERT_SV_2BOOL_FLAGS	\
	assert(sv)
PERL_CALLCONV CV*	Perl_sv_2cv(pTHX_ SV* sv, HV **const st, GV **const gvp, const I32 lref);
#define PERL_ARGS_ASSERT_SV_2CV	\
	assert(st); assert(gvp)
PERL_CALLCONV IO*	Perl_sv_2io(pTHX_ SV *const sv);
#define PERL_ARGS_ASSERT_SV_2IO	\
	assert(sv)
/* PERL_CALLCONV IV	Perl_sv_2iv(pTHX_ SV *sv); */
#define PERL_ARGS_ASSERT_SV_2IV	\
	assert(sv)
PERL_CALLCONV IV	Perl_sv_2iv_flags(pTHX_ SV *const sv, const I32 flags);
#define PERL_ARGS_ASSERT_SV_2IV_FLAGS	\
	assert(sv)
PERL_CALLCONV SV*	Perl_sv_2mortal(pTHX_ SV *const sv);
PERL_CALLCONV SV*	Perl_sv_2num(pTHX_ SV *const sv);
#define PERL_ARGS_ASSERT_SV_2NUM	\
	assert(sv)
PERL_CALLCONV NV	Perl_sv_2nv_flags(pTHX_ SV *const sv, const I32 flags);
#define PERL_ARGS_ASSERT_SV_2NV_FLAGS	\
	assert(sv)
/* PERL_CALLCONV char*	Perl_sv_2pv(pTHX_ SV *sv, STRLEN *lp); */
#define PERL_ARGS_ASSERT_SV_2PV	\
	assert(sv)
PERL_CALLCONV char*	Perl_sv_2pv_flags(pTHX_ SV *const sv, STRLEN *const lp, const I32 flags);
#define PERL_ARGS_ASSERT_SV_2PV_FLAGS	\
	assert(sv)
/* PERL_CALLCONV char*	Perl_sv_2pv_nolen(pTHX_ SV* sv)
			__attribute__warn_unused_result__; */
#define PERL_ARGS_ASSERT_SV_2PV_NOLEN	\
	assert(sv)

PERL_CALLCONV char*	Perl_sv_2pvbyte(pTHX_ SV *sv, STRLEN *const lp);
#define PERL_ARGS_ASSERT_SV_2PVBYTE	\
	assert(sv)
/* PERL_CALLCONV char*	Perl_sv_2pvbyte_nolen(pTHX_ SV* sv)
			__attribute__warn_unused_result__; */
#define PERL_ARGS_ASSERT_SV_2PVBYTE_NOLEN	\
	assert(sv)

PERL_CALLCONV char*	Perl_sv_2pvutf8(pTHX_ SV *sv, STRLEN *const lp);
#define PERL_ARGS_ASSERT_SV_2PVUTF8	\
	assert(sv)
/* PERL_CALLCONV char*	Perl_sv_2pvutf8_nolen(pTHX_ SV* sv)
			__attribute__warn_unused_result__; */
#define PERL_ARGS_ASSERT_SV_2PVUTF8_NOLEN	\
	assert(sv)

/* PERL_CALLCONV UV	Perl_sv_2uv(pTHX_ SV *sv); */
#define PERL_ARGS_ASSERT_SV_2UV	\
	assert(sv)
PERL_CALLCONV UV	Perl_sv_2uv_flags(pTHX_ SV *const sv, const I32 flags);
#define PERL_ARGS_ASSERT_SV_2UV_FLAGS	\
	assert(sv)
PERL_CALLCONV void	Perl_sv_backoff(SV *const sv);
#define PERL_ARGS_ASSERT_SV_BACKOFF	\
	assert(sv)
PERL_CALLCONV SV*	Perl_sv_bless(pTHX_ SV *const sv, HV *const stash);
#define PERL_ARGS_ASSERT_SV_BLESS	\
	assert(sv); assert(stash)
PERL_CALLCONV bool	Perl_sv_cat_decode(pTHX_ SV* dsv, SV *encoding, SV *ssv, int *offset, char* tstr, int tlen);
#define PERL_ARGS_ASSERT_SV_CAT_DECODE	\
	assert(dsv); assert(encoding); assert(ssv); assert(offset); assert(tstr)
PERL_CALLCONV void	Perl_sv_catpv(pTHX_ SV *const sv, const char* ptr);
#define PERL_ARGS_ASSERT_SV_CATPV	\
	assert(sv)
PERL_CALLCONV void	Perl_sv_catpv_flags(pTHX_ SV *dstr, const char *sstr, const I32 flags);
#define PERL_ARGS_ASSERT_SV_CATPV_FLAGS	\
	assert(dstr); assert(sstr)
PERL_CALLCONV void	Perl_sv_catpv_mg(pTHX_ SV *const sv, const char *const ptr);
#define PERL_ARGS_ASSERT_SV_CATPV_MG	\
	assert(sv)
PERL_CALLCONV void	Perl_sv_catpvf(pTHX_ SV *const sv, const char *const pat, ...)
			__attribute__format__(__printf__,pTHX_2,pTHX_3);
#define PERL_ARGS_ASSERT_SV_CATPVF	\
	assert(sv); assert(pat)

PERL_CALLCONV void	Perl_sv_catpvf_mg(pTHX_ SV *const sv, const char *const pat, ...)
			__attribute__format__(__printf__,pTHX_2,pTHX_3);
#define PERL_ARGS_ASSERT_SV_CATPVF_MG	\
	assert(sv); assert(pat)

/* PERL_CALLCONV void	Perl_sv_catpvn(pTHX_ SV *dsv, const char *sstr, STRLEN len); */
#define PERL_ARGS_ASSERT_SV_CATPVN	\
	assert(dsv); assert(sstr)
PERL_CALLCONV void	Perl_sv_catpvn_flags(pTHX_ SV *const dstr, const char *sstr, const STRLEN len, const I32 flags);
#define PERL_ARGS_ASSERT_SV_CATPVN_FLAGS	\
	assert(dstr); assert(sstr)
/* PERL_CALLCONV void	Perl_sv_catpvn_mg(pTHX_ SV *sv, const char *ptr, STRLEN len); */
#define PERL_ARGS_ASSERT_SV_CATPVN_MG	\
	assert(sv); assert(ptr)
/* PERL_CALLCONV void	Perl_sv_catsv(pTHX_ SV *dstr, SV *sstr); */
#define PERL_ARGS_ASSERT_SV_CATSV	\
	assert(dstr)
PERL_CALLCONV void	Perl_sv_catsv_flags(pTHX_ SV *const dsv, SV *const ssv, const I32 flags);
#define PERL_ARGS_ASSERT_SV_CATSV_FLAGS	\
	assert(dsv)
/* PERL_CALLCONV void	Perl_sv_catsv_mg(pTHX_ SV *dsv, SV *ssv); */
#define PERL_ARGS_ASSERT_SV_CATSV_MG	\
	assert(dsv)
PERL_CALLCONV void	Perl_sv_chop(pTHX_ SV *const sv, const char *const ptr);
#define PERL_ARGS_ASSERT_SV_CHOP	\
	assert(sv)
PERL_CALLCONV I32	Perl_sv_clean_all(pTHX);
PERL_CALLCONV void	Perl_sv_clean_objs(pTHX);
PERL_CALLCONV void	Perl_sv_clear(pTHX_ SV *const orig_sv);
#define PERL_ARGS_ASSERT_SV_CLEAR	\
	assert(orig_sv)
PERL_CALLCONV I32	Perl_sv_cmp(pTHX_ SV *const sv1, SV *const sv2);
PERL_CALLCONV I32	Perl_sv_cmp_flags(pTHX_ SV *const sv1, SV *const sv2, const U32 flags);
PERL_CALLCONV I32	Perl_sv_cmp_locale(pTHX_ SV *const sv1, SV *const sv2);
PERL_CALLCONV I32	Perl_sv_cmp_locale_flags(pTHX_ SV *const sv1, SV *const sv2, const U32 flags);
/* PERL_CALLCONV void	Perl_sv_copypv(pTHX_ SV *const dsv, SV *const ssv); */
#define PERL_ARGS_ASSERT_SV_COPYPV	\
	assert(dsv); assert(ssv)
PERL_CALLCONV void	Perl_sv_copypv_flags(pTHX_ SV *const dsv, SV *const ssv, const I32 flags);
#define PERL_ARGS_ASSERT_SV_COPYPV_FLAGS	\
	assert(dsv); assert(ssv)
/* PERL_CALLCONV void	Perl_sv_copypv_nomg(pTHX_ SV *const dsv, SV *const ssv); */
PERL_CALLCONV void	Perl_sv_dec(pTHX_ SV *const sv);
PERL_CALLCONV void	Perl_sv_dec_nomg(pTHX_ SV *const sv);
PERL_CALLCONV void	Perl_sv_del_backref(pTHX_ SV *const tsv, SV *const sv);
#define PERL_ARGS_ASSERT_SV_DEL_BACKREF	\
	assert(tsv); assert(sv)
PERL_CALLCONV bool	Perl_sv_derived_from(pTHX_ SV* sv, const char *const name)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_SV_DERIVED_FROM	\
	assert(sv); assert(name)

PERL_CALLCONV bool	Perl_sv_derived_from_pv(pTHX_ SV* sv, const char *const name, U32 flags)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_SV_DERIVED_FROM_PV	\
	assert(sv); assert(name)

PERL_CALLCONV bool	Perl_sv_derived_from_pvn(pTHX_ SV* sv, const char *const name, const STRLEN len, U32 flags)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_SV_DERIVED_FROM_PVN	\
	assert(sv); assert(name)

PERL_CALLCONV bool	Perl_sv_derived_from_sv(pTHX_ SV* sv, SV *namesv, U32 flags)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_SV_DERIVED_FROM_SV	\
	assert(sv); assert(namesv)

PERL_CALLCONV bool	Perl_sv_destroyable(pTHX_ SV *sv);
PERL_CALLCONV bool	Perl_sv_does(pTHX_ SV* sv, const char *const name)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_SV_DOES	\
	assert(sv); assert(name)

PERL_CALLCONV bool	Perl_sv_does_pv(pTHX_ SV* sv, const char *const name, U32 flags)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_SV_DOES_PV	\
	assert(sv); assert(name)

PERL_CALLCONV bool	Perl_sv_does_pvn(pTHX_ SV* sv, const char *const name, const STRLEN len, U32 flags)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_SV_DOES_PVN	\
	assert(sv); assert(name)

PERL_CALLCONV bool	Perl_sv_does_sv(pTHX_ SV* sv, SV* namesv, U32 flags)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_SV_DOES_SV	\
	assert(sv); assert(namesv)

PERL_CALLCONV void	Perl_sv_dump(pTHX_ SV* sv);
#define PERL_ARGS_ASSERT_SV_DUMP	\
	assert(sv)
/* PERL_CALLCONV I32	sv_eq(pTHX_ SV* sv1, SV* sv2); */
PERL_CALLCONV I32	Perl_sv_eq_flags(pTHX_ SV* sv1, SV* sv2, const U32 flags);
/* PERL_CALLCONV void	Perl_sv_force_normal(pTHX_ SV *sv); */
#define PERL_ARGS_ASSERT_SV_FORCE_NORMAL	\
	assert(sv)
PERL_CALLCONV void	Perl_sv_force_normal_flags(pTHX_ SV *const sv, const U32 flags);
#define PERL_ARGS_ASSERT_SV_FORCE_NORMAL_FLAGS	\
	assert(sv)
PERL_CALLCONV void	Perl_sv_free(pTHX_ SV *const sv);
PERL_CALLCONV void	Perl_sv_free2(pTHX_ SV *const sv, const U32 refcnt);
#define PERL_ARGS_ASSERT_SV_FREE2	\
	assert(sv)
PERL_CALLCONV void	Perl_sv_free_arenas(pTHX);
PERL_CALLCONV SV*	Perl_sv_get_backrefs(SV *const sv)
			__attribute__pure__;
#define PERL_ARGS_ASSERT_SV_GET_BACKREFS	\
	assert(sv)

PERL_CALLCONV char*	Perl_sv_gets(pTHX_ SV *const sv, PerlIO *const fp, I32 append);
#define PERL_ARGS_ASSERT_SV_GETS	\
	assert(sv); assert(fp)
PERL_CALLCONV char*	Perl_sv_grow(pTHX_ SV *const sv, STRLEN newlen);
#define PERL_ARGS_ASSERT_SV_GROW	\
	assert(sv)
PERL_CALLCONV void	Perl_sv_inc(pTHX_ SV *const sv);
PERL_CALLCONV void	Perl_sv_inc_nomg(pTHX_ SV *const sv);
/* PERL_CALLCONV void	Perl_sv_insert(pTHX_ SV *const bigstr, const STRLEN offset, const STRLEN len, const char *const little, const STRLEN littlelen); */
#define PERL_ARGS_ASSERT_SV_INSERT	\
	assert(bigstr); assert(little)
PERL_CALLCONV void	Perl_sv_insert_flags(pTHX_ SV *const bigstr, const STRLEN offset, const STRLEN len, const char *const little, const STRLEN littlelen, const U32 flags);
#define PERL_ARGS_ASSERT_SV_INSERT_FLAGS	\
	assert(bigstr); assert(little)
PERL_CALLCONV int	Perl_sv_isa(pTHX_ SV* sv, const char *const name);
#define PERL_ARGS_ASSERT_SV_ISA	\
	assert(name)
PERL_CALLCONV int	Perl_sv_isobject(pTHX_ SV* sv);
PERL_CALLCONV IV	Perl_sv_iv(pTHX_ SV* sv);
#define PERL_ARGS_ASSERT_SV_IV	\
	assert(sv)
PERL_CALLCONV STRLEN	Perl_sv_len(pTHX_ SV *const sv);
PERL_CALLCONV STRLEN	Perl_sv_len_utf8(pTHX_ SV *const sv);
PERL_CALLCONV STRLEN	Perl_sv_len_utf8_nomg(pTHX_ SV *const sv);
#define PERL_ARGS_ASSERT_SV_LEN_UTF8_NOMG	\
	assert(sv)
PERL_CALLCONV void	Perl_sv_magic(pTHX_ SV *const sv, SV *const obj, const int how, const char *const name, const I32 namlen);
#define PERL_ARGS_ASSERT_SV_MAGIC	\
	assert(sv)
PERL_CALLCONV MAGIC *	Perl_sv_magicext(pTHX_ SV *const sv, SV *const obj, const int how, const MGVTBL *const vtbl, const char *const name, const I32 namlen);
#define PERL_ARGS_ASSERT_SV_MAGICEXT	\
	assert(sv)
PERL_CALLCONV MAGIC *	Perl_sv_magicext_mglob(pTHX_ SV *sv);
#define PERL_ARGS_ASSERT_SV_MAGICEXT_MGLOB	\
	assert(sv)
/* PERL_CALLCONV SV*	Perl_sv_mortalcopy(pTHX_ SV *const oldsv)
			__attribute__malloc__
			__attribute__warn_unused_result__; */

PERL_CALLCONV SV*	Perl_sv_mortalcopy_flags(pTHX_ SV *const oldsv, U32 flags)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV SV*	Perl_sv_newmortal(pTHX)
			__attribute__warn_unused_result__;

PERL_CALLCONV SV*	Perl_sv_newref(pTHX_ SV *const sv);
/* PERL_CALLCONV void	Perl_sv_nolocking(pTHX_ SV *sv); */
PERL_CALLCONV void	Perl_sv_nosharing(pTHX_ SV *sv);
PERL_CALLCONV NV	Perl_sv_nv(pTHX_ SV* sv);
#define PERL_ARGS_ASSERT_SV_NV	\
	assert(sv)
PERL_CALLCONV char*	Perl_sv_peek(pTHX_ SV* sv);
PERL_CALLCONV void	Perl_sv_pos_b2u(pTHX_ SV *const sv, I32 *const offsetp);
#define PERL_ARGS_ASSERT_SV_POS_B2U	\
	assert(offsetp)
PERL_CALLCONV STRLEN	Perl_sv_pos_b2u_flags(pTHX_ SV *const sv, STRLEN const offset, U32 flags);
#define PERL_ARGS_ASSERT_SV_POS_B2U_FLAGS	\
	assert(sv)
PERL_CALLCONV void	Perl_sv_pos_u2b(pTHX_ SV *const sv, I32 *const offsetp, I32 *const lenp);
#define PERL_ARGS_ASSERT_SV_POS_U2B	\
	assert(offsetp)
PERL_CALLCONV STRLEN	Perl_sv_pos_u2b_flags(pTHX_ SV *const sv, STRLEN uoffset, STRLEN *const lenp, U32 flags);
#define PERL_ARGS_ASSERT_SV_POS_U2B_FLAGS	\
	assert(sv)
/* PERL_CALLCONV char*	Perl_sv_pv(pTHX_ SV *sv)
			__attribute__warn_unused_result__; */
#define PERL_ARGS_ASSERT_SV_PV	\
	assert(sv)

/* PERL_CALLCONV char*	Perl_sv_pvbyte(pTHX_ SV *sv)
			__attribute__warn_unused_result__; */
#define PERL_ARGS_ASSERT_SV_PVBYTE	\
	assert(sv)

PERL_CALLCONV char*	Perl_sv_pvbyten(pTHX_ SV *sv, STRLEN *lp);
#define PERL_ARGS_ASSERT_SV_PVBYTEN	\
	assert(sv); assert(lp)
PERL_CALLCONV char*	Perl_sv_pvbyten_force(pTHX_ SV *const sv, STRLEN *const lp);
#define PERL_ARGS_ASSERT_SV_PVBYTEN_FORCE	\
	assert(sv)
PERL_CALLCONV char*	Perl_sv_pvn(pTHX_ SV *sv, STRLEN *lp);
#define PERL_ARGS_ASSERT_SV_PVN	\
	assert(sv); assert(lp)
/* PERL_CALLCONV char*	Perl_sv_pvn_force(pTHX_ SV* sv, STRLEN* lp); */
#define PERL_ARGS_ASSERT_SV_PVN_FORCE	\
	assert(sv)
PERL_CALLCONV char*	Perl_sv_pvn_force_flags(pTHX_ SV *const sv, STRLEN *const lp, const I32 flags);
#define PERL_ARGS_ASSERT_SV_PVN_FORCE_FLAGS	\
	assert(sv)
PERL_CALLCONV char*	Perl_sv_pvn_nomg(pTHX_ SV* sv, STRLEN* lp);
#define PERL_ARGS_ASSERT_SV_PVN_NOMG	\
	assert(sv)
/* PERL_CALLCONV char*	Perl_sv_pvutf8(pTHX_ SV *sv)
			__attribute__warn_unused_result__; */
#define PERL_ARGS_ASSERT_SV_PVUTF8	\
	assert(sv)

PERL_CALLCONV char*	Perl_sv_pvutf8n(pTHX_ SV *sv, STRLEN *lp);
#define PERL_ARGS_ASSERT_SV_PVUTF8N	\
	assert(sv); assert(lp)
PERL_CALLCONV char*	Perl_sv_pvutf8n_force(pTHX_ SV *const sv, STRLEN *const lp);
#define PERL_ARGS_ASSERT_SV_PVUTF8N_FORCE	\
	assert(sv)
PERL_CALLCONV char*	Perl_sv_recode_to_utf8(pTHX_ SV* sv, SV *encoding);
#define PERL_ARGS_ASSERT_SV_RECODE_TO_UTF8	\
	assert(sv); assert(encoding)
PERL_CALLCONV SV*	Perl_sv_ref(pTHX_ SV *dst, const SV *const sv, const int ob);
#define PERL_ARGS_ASSERT_SV_REF	\
	assert(sv)
PERL_CALLCONV const char*	Perl_sv_reftype(pTHX_ const SV *const sv, const int ob)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_SV_REFTYPE	\
	assert(sv)

PERL_CALLCONV void	Perl_sv_replace(pTHX_ SV *const sv, SV *const nsv);
#define PERL_ARGS_ASSERT_SV_REPLACE	\
	assert(sv); assert(nsv)
PERL_CALLCONV void	Perl_sv_report_used(pTHX);
PERL_CALLCONV void	Perl_sv_reset(pTHX_ const char* s, HV *const stash);
#define PERL_ARGS_ASSERT_SV_RESET	\
	assert(s)
PERL_CALLCONV void	Perl_sv_resetpvn(pTHX_ const char* s, STRLEN len, HV *const stash);
PERL_CALLCONV SV*	Perl_sv_rvweaken(pTHX_ SV *const sv);
#define PERL_ARGS_ASSERT_SV_RVWEAKEN	\
	assert(sv)
PERL_CALLCONV void	Perl_sv_sethek(pTHX_ SV *const sv, const HEK *const hek);
#define PERL_ARGS_ASSERT_SV_SETHEK	\
	assert(sv)
PERL_CALLCONV void	Perl_sv_setiv(pTHX_ SV *const sv, const IV num);
#define PERL_ARGS_ASSERT_SV_SETIV	\
	assert(sv)
PERL_CALLCONV void	Perl_sv_setiv_mg(pTHX_ SV *const sv, const IV i);
#define PERL_ARGS_ASSERT_SV_SETIV_MG	\
	assert(sv)
PERL_CALLCONV void	Perl_sv_setnv(pTHX_ SV *const sv, const NV num);
#define PERL_ARGS_ASSERT_SV_SETNV	\
	assert(sv)
PERL_CALLCONV void	Perl_sv_setnv_mg(pTHX_ SV *const sv, const NV num);
#define PERL_ARGS_ASSERT_SV_SETNV_MG	\
	assert(sv)
PERL_CALLCONV void	Perl_sv_setpv(pTHX_ SV *const sv, const char *const ptr);
#define PERL_ARGS_ASSERT_SV_SETPV	\
	assert(sv)
PERL_CALLCONV void	Perl_sv_setpv_mg(pTHX_ SV *const sv, const char *const ptr);
#define PERL_ARGS_ASSERT_SV_SETPV_MG	\
	assert(sv)
PERL_CALLCONV void	Perl_sv_setpvf(pTHX_ SV *const sv, const char *const pat, ...)
			__attribute__format__(__printf__,pTHX_2,pTHX_3);
#define PERL_ARGS_ASSERT_SV_SETPVF	\
	assert(sv); assert(pat)

PERL_CALLCONV void	Perl_sv_setpvf_mg(pTHX_ SV *const sv, const char *const pat, ...)
			__attribute__format__(__printf__,pTHX_2,pTHX_3);
#define PERL_ARGS_ASSERT_SV_SETPVF_MG	\
	assert(sv); assert(pat)

PERL_CALLCONV void	Perl_sv_setpviv(pTHX_ SV *const sv, const IV num);
#define PERL_ARGS_ASSERT_SV_SETPVIV	\
	assert(sv)
PERL_CALLCONV void	Perl_sv_setpviv_mg(pTHX_ SV *const sv, const IV iv);
#define PERL_ARGS_ASSERT_SV_SETPVIV_MG	\
	assert(sv)
PERL_CALLCONV void	Perl_sv_setpvn(pTHX_ SV *const sv, const char *const ptr, const STRLEN len);
#define PERL_ARGS_ASSERT_SV_SETPVN	\
	assert(sv)
PERL_CALLCONV void	Perl_sv_setpvn_mg(pTHX_ SV *const sv, const char *const ptr, const STRLEN len);
#define PERL_ARGS_ASSERT_SV_SETPVN_MG	\
	assert(sv); assert(ptr)
PERL_CALLCONV SV*	Perl_sv_setref_iv(pTHX_ SV *const rv, const char *const classname, const IV iv);
#define PERL_ARGS_ASSERT_SV_SETREF_IV	\
	assert(rv)
PERL_CALLCONV SV*	Perl_sv_setref_nv(pTHX_ SV *const rv, const char *const classname, const NV nv);
#define PERL_ARGS_ASSERT_SV_SETREF_NV	\
	assert(rv)
PERL_CALLCONV SV*	Perl_sv_setref_pv(pTHX_ SV *const rv, const char *const classname, void *const pv);
#define PERL_ARGS_ASSERT_SV_SETREF_PV	\
	assert(rv)
PERL_CALLCONV SV*	Perl_sv_setref_pvn(pTHX_ SV *const rv, const char *const classname, const char *const pv, const STRLEN n);
#define PERL_ARGS_ASSERT_SV_SETREF_PVN	\
	assert(rv); assert(pv)
PERL_CALLCONV SV*	Perl_sv_setref_uv(pTHX_ SV *const rv, const char *const classname, const UV uv);
#define PERL_ARGS_ASSERT_SV_SETREF_UV	\
	assert(rv)
/* PERL_CALLCONV void	Perl_sv_setsv(pTHX_ SV *dstr, SV *sstr); */
#define PERL_ARGS_ASSERT_SV_SETSV	\
	assert(dstr)
PERL_CALLCONV void	Perl_sv_setsv_flags(pTHX_ SV *dstr, SV *sstr, const I32 flags);
#define PERL_ARGS_ASSERT_SV_SETSV_FLAGS	\
	assert(dstr)
PERL_CALLCONV void	Perl_sv_setsv_mg(pTHX_ SV *const dstr, SV *const sstr);
#define PERL_ARGS_ASSERT_SV_SETSV_MG	\
	assert(dstr)
PERL_CALLCONV void	Perl_sv_setuv(pTHX_ SV *const sv, const UV num);
#define PERL_ARGS_ASSERT_SV_SETUV	\
	assert(sv)
PERL_CALLCONV void	Perl_sv_setuv_mg(pTHX_ SV *const sv, const UV u);
#define PERL_ARGS_ASSERT_SV_SETUV_MG	\
	assert(sv)
/* PERL_CALLCONV void	Perl_sv_taint(pTHX_ SV* sv); */
#define PERL_ARGS_ASSERT_SV_TAINT	\
	assert(sv)
PERL_CALLCONV bool	Perl_sv_tainted(pTHX_ SV *const sv)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_SV_TAINTED	\
	assert(sv)

PERL_CALLCONV I32	Perl_sv_true(pTHX_ SV *const sv);
PERL_CALLCONV char*	Perl_sv_uni_display(pTHX_ SV *dsv, SV *ssv, STRLEN pvlim, UV flags)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_SV_UNI_DISPLAY	\
	assert(dsv); assert(ssv)

PERL_CALLCONV int	Perl_sv_unmagic(pTHX_ SV *const sv, const int type);
#define PERL_ARGS_ASSERT_SV_UNMAGIC	\
	assert(sv)
PERL_CALLCONV int	Perl_sv_unmagicext(pTHX_ SV *const sv, const int type, MGVTBL *vtbl);
#define PERL_ARGS_ASSERT_SV_UNMAGICEXT	\
	assert(sv)
/* PERL_CALLCONV void	Perl_sv_unref(pTHX_ SV* sv); */
#define PERL_ARGS_ASSERT_SV_UNREF	\
	assert(sv)
PERL_CALLCONV void	Perl_sv_unref_flags(pTHX_ SV *const ref, const U32 flags);
#define PERL_ARGS_ASSERT_SV_UNREF_FLAGS	\
	assert(ref)
PERL_CALLCONV void	Perl_sv_untaint(pTHX_ SV *const sv);
#define PERL_ARGS_ASSERT_SV_UNTAINT	\
	assert(sv)
PERL_CALLCONV void	Perl_sv_upgrade(pTHX_ SV *const sv, svtype new_type);
#define PERL_ARGS_ASSERT_SV_UPGRADE	\
	assert(sv)
/* PERL_CALLCONV void	Perl_sv_usepvn(pTHX_ SV* sv, char* ptr, STRLEN len); */
#define PERL_ARGS_ASSERT_SV_USEPVN	\
	assert(sv)
PERL_CALLCONV void	Perl_sv_usepvn_flags(pTHX_ SV *const sv, char* ptr, const STRLEN len, const U32 flags);
#define PERL_ARGS_ASSERT_SV_USEPVN_FLAGS	\
	assert(sv)
/* PERL_CALLCONV void	Perl_sv_usepvn_mg(pTHX_ SV *sv, char *ptr, STRLEN len); */
#define PERL_ARGS_ASSERT_SV_USEPVN_MG	\
	assert(sv)
PERL_CALLCONV bool	Perl_sv_utf8_decode(pTHX_ SV *const sv);
#define PERL_ARGS_ASSERT_SV_UTF8_DECODE	\
	assert(sv)
PERL_CALLCONV bool	Perl_sv_utf8_downgrade(pTHX_ SV *const sv, const bool fail_ok);
#define PERL_ARGS_ASSERT_SV_UTF8_DOWNGRADE	\
	assert(sv)
PERL_CALLCONV void	Perl_sv_utf8_encode(pTHX_ SV *const sv);
#define PERL_ARGS_ASSERT_SV_UTF8_ENCODE	\
	assert(sv)
/* PERL_CALLCONV STRLEN	Perl_sv_utf8_upgrade(pTHX_ SV *sv); */
#define PERL_ARGS_ASSERT_SV_UTF8_UPGRADE	\
	assert(sv)
/* PERL_CALLCONV STRLEN	Perl_sv_utf8_upgrade_flags(pTHX_ SV *const sv, const I32 flags); */
PERL_CALLCONV STRLEN	Perl_sv_utf8_upgrade_flags_grow(pTHX_ SV *const sv, const I32 flags, STRLEN extra);
#define PERL_ARGS_ASSERT_SV_UTF8_UPGRADE_FLAGS_GROW	\
	assert(sv)
/* PERL_CALLCONV STRLEN	sv_utf8_upgrade_nomg(pTHX_ SV *sv); */
PERL_CALLCONV UV	Perl_sv_uv(pTHX_ SV* sv);
#define PERL_ARGS_ASSERT_SV_UV	\
	assert(sv)
PERL_CALLCONV void	Perl_sv_vcatpvf(pTHX_ SV *const sv, const char *const pat, va_list *const args);
#define PERL_ARGS_ASSERT_SV_VCATPVF	\
	assert(sv); assert(pat)
PERL_CALLCONV void	Perl_sv_vcatpvf_mg(pTHX_ SV *const sv, const char *const pat, va_list *const args);
#define PERL_ARGS_ASSERT_SV_VCATPVF_MG	\
	assert(sv); assert(pat)
PERL_CALLCONV void	Perl_sv_vcatpvfn(pTHX_ SV *const sv, const char *const pat, const STRLEN patlen, va_list *const args, SV **const svargs, const I32 svmax, bool *const maybe_tainted);
#define PERL_ARGS_ASSERT_SV_VCATPVFN	\
	assert(sv); assert(pat)
PERL_CALLCONV void	Perl_sv_vcatpvfn_flags(pTHX_ SV *const sv, const char *const pat, const STRLEN patlen, va_list *const args, SV **const svargs, const I32 svmax, bool *const maybe_tainted, const U32 flags);
#define PERL_ARGS_ASSERT_SV_VCATPVFN_FLAGS	\
	assert(sv); assert(pat)
PERL_CALLCONV void	Perl_sv_vsetpvf(pTHX_ SV *const sv, const char *const pat, va_list *const args);
#define PERL_ARGS_ASSERT_SV_VSETPVF	\
	assert(sv); assert(pat)
PERL_CALLCONV void	Perl_sv_vsetpvf_mg(pTHX_ SV *const sv, const char *const pat, va_list *const args);
#define PERL_ARGS_ASSERT_SV_VSETPVF_MG	\
	assert(sv); assert(pat)
PERL_CALLCONV void	Perl_sv_vsetpvfn(pTHX_ SV *const sv, const char *const pat, const STRLEN patlen, va_list *const args, SV **const svargs, const I32 svmax, bool *const maybe_tainted);
#define PERL_ARGS_ASSERT_SV_VSETPVFN	\
	assert(sv); assert(pat)
PERL_CALLCONV UV	Perl_swash_fetch(pTHX_ SV *swash, const U8 *ptr, bool do_utf8);
#define PERL_ARGS_ASSERT_SWASH_FETCH	\
	assert(swash); assert(ptr)
PERL_CALLCONV SV*	Perl_swash_init(pTHX_ const char* pkg, const char* name, SV* listsv, I32 minbits, I32 none)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_SWASH_INIT	\
	assert(pkg); assert(name); assert(listsv)

PERL_CALLCONV void	Perl_sync_locale(pTHX);
PERL_CALLCONV void	Perl_sys_init(int* argc, char*** argv);
#define PERL_ARGS_ASSERT_SYS_INIT	\
	assert(argc); assert(argv)
PERL_CALLCONV void	Perl_sys_init3(int* argc, char*** argv, char*** env);
#define PERL_ARGS_ASSERT_SYS_INIT3	\
	assert(argc); assert(argv); assert(env)
PERL_CALLCONV void	Perl_sys_term(void);
PERL_CALLCONV void	Perl_taint_env(pTHX);
PERL_CALLCONV void	Perl_taint_proper(pTHX_ const char* f, const char *const s);
#define PERL_ARGS_ASSERT_TAINT_PROPER	\
	assert(s)
PERL_CALLCONV OP *	Perl_tied_method(pTHX_ SV *methname, SV **sp, SV *const sv, const MAGIC *const mg, const U32 flags, U32 argc, ...);
#define PERL_ARGS_ASSERT_TIED_METHOD	\
	assert(methname); assert(sp); assert(sv); assert(mg)
PERL_CALLCONV SSize_t	Perl_tmps_grow_p(pTHX_ SSize_t ix);
/* PERL_CALLCONV UV	Perl_to_uni_fold(pTHX_ UV c, U8 *p, STRLEN *lenp); */
PERL_CALLCONV UV	Perl_to_uni_lower(pTHX_ UV c, U8 *p, STRLEN *lenp);
#define PERL_ARGS_ASSERT_TO_UNI_LOWER	\
	assert(p); assert(lenp)
PERL_CALLCONV U32	Perl_to_uni_lower_lc(pTHX_ U32 c)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV UV	Perl_to_uni_title(pTHX_ UV c, U8 *p, STRLEN *lenp);
#define PERL_ARGS_ASSERT_TO_UNI_TITLE	\
	assert(p); assert(lenp)
PERL_CALLCONV U32	Perl_to_uni_title_lc(pTHX_ U32 c)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV UV	Perl_to_uni_upper(pTHX_ UV c, U8 *p, STRLEN *lenp);
#define PERL_ARGS_ASSERT_TO_UNI_UPPER	\
	assert(p); assert(lenp)
PERL_CALLCONV U32	Perl_to_uni_upper_lc(pTHX_ U32 c)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV UV	Perl_to_utf8_case(pTHX_ const U8 *p, U8* ustrp, STRLEN *lenp, SV **swashp, const char *normal, const char *special)
			__attribute__deprecated__;
#define PERL_ARGS_ASSERT_TO_UTF8_CASE	\
	assert(p); assert(ustrp); assert(swashp); assert(normal)

/* PERL_CALLCONV UV	Perl_to_utf8_fold(pTHX_ const U8 *p, U8* ustrp, STRLEN *lenp); */
#define PERL_ARGS_ASSERT_TO_UTF8_FOLD	\
	assert(p); assert(ustrp)
/* PERL_CALLCONV UV	Perl_to_utf8_lower(pTHX_ const U8 *p, U8* ustrp, STRLEN *lenp); */
#define PERL_ARGS_ASSERT_TO_UTF8_LOWER	\
	assert(p); assert(ustrp)
/* PERL_CALLCONV UV	Perl_to_utf8_title(pTHX_ const U8 *p, U8* ustrp, STRLEN *lenp); */
#define PERL_ARGS_ASSERT_TO_UTF8_TITLE	\
	assert(p); assert(ustrp)
/* PERL_CALLCONV UV	Perl_to_utf8_upper(pTHX_ const U8 *p, U8* ustrp, STRLEN *lenp); */
#define PERL_ARGS_ASSERT_TO_UTF8_UPPER	\
	assert(p); assert(ustrp)
PERL_CALLCONV bool	Perl_try_amagic_bin(pTHX_ int method, int flags);
PERL_CALLCONV bool	Perl_try_amagic_un(pTHX_ int method, int flags);
PERL_CALLCONV I32	Perl_unpack_str(pTHX_ const char *pat, const char *patend, const char *s, const char *strbeg, const char *strend, char **new_s, I32 ocnt, U32 flags);
#define PERL_ARGS_ASSERT_UNPACK_STR	\
	assert(pat); assert(patend); assert(s); assert(strend)
PERL_CALLCONV I32	Perl_unpackstring(pTHX_ const char *pat, const char *patend, const char *s, const char *strend, U32 flags);
#define PERL_ARGS_ASSERT_UNPACKSTRING	\
	assert(pat); assert(patend); assert(s); assert(strend)
PERL_CALLCONV void	Perl_unshare_hek(pTHX_ HEK* hek);
PERL_CALLCONV void	Perl_unsharepvn(pTHX_ const char* sv, I32 len, U32 hash);
PERL_CALLCONV SV*	Perl_upg_version(pTHX_ SV *ver, bool qv);
#define PERL_ARGS_ASSERT_UPG_VERSION	\
	assert(ver)
PERL_CALLCONV U8*	Perl_utf16_to_utf8(pTHX_ U8* p, U8 *d, I32 bytelen, I32 *newlen);
#define PERL_ARGS_ASSERT_UTF16_TO_UTF8	\
	assert(p); assert(d); assert(newlen)
PERL_CALLCONV U8*	Perl_utf16_to_utf8_reversed(pTHX_ U8* p, U8 *d, I32 bytelen, I32 *newlen);
#define PERL_ARGS_ASSERT_UTF16_TO_UTF8_REVERSED	\
	assert(p); assert(d); assert(newlen)
PERL_CALLCONV IV	Perl_utf8_distance(pTHX_ const U8 *a, const U8 *b)
			__attribute__warn_unused_result__
			__attribute__pure__;
#define PERL_ARGS_ASSERT_UTF8_DISTANCE	\
	assert(a); assert(b)

PERL_CALLCONV U8*	Perl_utf8_hop(const U8 *s, SSize_t off)
			__attribute__warn_unused_result__
			__attribute__pure__;
#define PERL_ARGS_ASSERT_UTF8_HOP	\
	assert(s)

PERL_CALLCONV STRLEN	Perl_utf8_length(pTHX_ const U8* s, const U8 *e)
			__attribute__warn_unused_result__
			__attribute__pure__;
#define PERL_ARGS_ASSERT_UTF8_LENGTH	\
	assert(s); assert(e)

PERL_CALLCONV U8*	Perl_utf8_to_bytes(pTHX_ U8 *s, STRLEN *len);
#define PERL_ARGS_ASSERT_UTF8_TO_BYTES	\
	assert(s); assert(len)
PERL_CALLCONV UV	Perl_utf8_to_uvchr(pTHX_ const U8 *s, STRLEN *retlen)
			__attribute__deprecated__;
#define PERL_ARGS_ASSERT_UTF8_TO_UVCHR	\
	assert(s)

/* PERL_CALLCONV UV	utf8_to_uvchr_buf(pTHX_ const U8 *s, const U8 *send, STRLEN *retlen); */
PERL_CALLCONV UV	Perl_utf8_to_uvuni(pTHX_ const U8 *s, STRLEN *retlen)
			__attribute__deprecated__;
#define PERL_ARGS_ASSERT_UTF8_TO_UVUNI	\
	assert(s)

PERL_CALLCONV UV	Perl_utf8_to_uvuni_buf(pTHX_ const U8 *s, const U8 *send, STRLEN *retlen)
			__attribute__deprecated__;
#define PERL_ARGS_ASSERT_UTF8_TO_UVUNI_BUF	\
	assert(s); assert(send)

PERL_CALLCONV UV	Perl_utf8n_to_uvchr(pTHX_ const U8 *s, STRLEN curlen, STRLEN *retlen, U32 flags);
#define PERL_ARGS_ASSERT_UTF8N_TO_UVCHR	\
	assert(s)
PERL_CALLCONV UV	Perl_utf8n_to_uvuni(pTHX_ const U8 *s, STRLEN curlen, STRLEN *retlen, U32 flags);
#define PERL_ARGS_ASSERT_UTF8N_TO_UVUNI	\
	assert(s)
PERL_CALLCONV void	Perl_utilize(pTHX_ int aver, I32 floor, OP* version, OP* idop, OP* arg);
#define PERL_ARGS_ASSERT_UTILIZE	\
	assert(idop)
/* PERL_CALLCONV U8*	uvchr_to_utf8(pTHX_ U8 *d, UV uv); */
/* PERL_CALLCONV U8*	uvchr_to_utf8_flags(pTHX_ U8 *d, UV uv, UV flags); */
PERL_CALLCONV U8*	Perl_uvoffuni_to_utf8_flags(pTHX_ U8 *d, UV uv, UV flags);
#define PERL_ARGS_ASSERT_UVOFFUNI_TO_UTF8_FLAGS	\
	assert(d)
PERL_CALLCONV U8*	Perl_uvuni_to_utf8(pTHX_ U8 *d, UV uv);
#define PERL_ARGS_ASSERT_UVUNI_TO_UTF8	\
	assert(d)
PERL_CALLCONV U8*	Perl_uvuni_to_utf8_flags(pTHX_ U8 *d, UV uv, UV flags);
#define PERL_ARGS_ASSERT_UVUNI_TO_UTF8_FLAGS	\
	assert(d)
PERL_CALLCONV UV	Perl_valid_utf8_to_uvchr(pTHX_ const U8 *s, STRLEN *retlen);
#define PERL_ARGS_ASSERT_VALID_UTF8_TO_UVCHR	\
	assert(s)
PERL_CALLCONV UV	Perl_valid_utf8_to_uvuni(pTHX_ const U8 *s, STRLEN *retlen)
			__attribute__deprecated__;
#define PERL_ARGS_ASSERT_VALID_UTF8_TO_UVUNI	\
	assert(s)

PERL_CALLCONV bool	Perl_validate_proto(pTHX_ SV *name, SV *proto, bool warn);
#define PERL_ARGS_ASSERT_VALIDATE_PROTO	\
	assert(name)
PERL_CALLCONV int	Perl_vcmp(pTHX_ SV *lhv, SV *rhv);
#define PERL_ARGS_ASSERT_VCMP	\
	assert(lhv); assert(rhv)
PERL_CALLCONV_NO_RET void	Perl_vcroak(pTHX_ const char* pat, va_list* args)
			__attribute__noreturn__;

PERL_CALLCONV void	Perl_vdeb(pTHX_ const char* pat, va_list* args);
#define PERL_ARGS_ASSERT_VDEB	\
	assert(pat)
PERL_CALLCONV char*	Perl_vform(pTHX_ const char* pat, va_list* args);
#define PERL_ARGS_ASSERT_VFORM	\
	assert(pat)
PERL_CALLCONV void	Perl_vivify_defelem(pTHX_ SV* sv);
#define PERL_ARGS_ASSERT_VIVIFY_DEFELEM	\
	assert(sv)
PERL_CALLCONV SV*	Perl_vivify_ref(pTHX_ SV* sv, U32 to_what)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_VIVIFY_REF	\
	assert(sv)

PERL_CALLCONV void	Perl_vload_module(pTHX_ U32 flags, SV* name, SV* ver, va_list* args);
#define PERL_ARGS_ASSERT_VLOAD_MODULE	\
	assert(name)
PERL_CALLCONV SV*	Perl_vmess(pTHX_ const char* pat, va_list* args);
#define PERL_ARGS_ASSERT_VMESS	\
	assert(pat)
PERL_CALLCONV SV*	Perl_vnewSVpvf(pTHX_ const char *const pat, va_list *const args)
			__attribute__malloc__
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_VNEWSVPVF	\
	assert(pat)

PERL_CALLCONV SV*	Perl_vnormal(pTHX_ SV *vs);
#define PERL_ARGS_ASSERT_VNORMAL	\
	assert(vs)
PERL_CALLCONV SV*	Perl_vnumify(pTHX_ SV *vs);
#define PERL_ARGS_ASSERT_VNUMIFY	\
	assert(vs)
PERL_CALLCONV SV*	Perl_vstringify(pTHX_ SV *vs);
#define PERL_ARGS_ASSERT_VSTRINGIFY	\
	assert(vs)
PERL_CALLCONV SV*	Perl_vverify(pTHX_ SV *vs);
#define PERL_ARGS_ASSERT_VVERIFY	\
	assert(vs)
PERL_CALLCONV void	Perl_vwarn(pTHX_ const char* pat, va_list* args);
#define PERL_ARGS_ASSERT_VWARN	\
	assert(pat)
PERL_CALLCONV void	Perl_vwarner(pTHX_ U32 err, const char* pat, va_list* args);
#define PERL_ARGS_ASSERT_VWARNER	\
	assert(pat)
PERL_CALLCONV I32	Perl_wait4pid(pTHX_ Pid_t pid, int* statusp, int flags);
#define PERL_ARGS_ASSERT_WAIT4PID	\
	assert(statusp)
PERL_CALLCONV void	Perl_warn(pTHX_ const char* pat, ...)
			__attribute__format__(__printf__,pTHX_1,pTHX_2);
#define PERL_ARGS_ASSERT_WARN	\
	assert(pat)

PERL_CALLCONV void	Perl_warn_sv(pTHX_ SV *baseex);
#define PERL_ARGS_ASSERT_WARN_SV	\
	assert(baseex)
PERL_CALLCONV void	Perl_warner(pTHX_ U32 err, const char* pat, ...)
			__attribute__format__(__printf__,pTHX_2,pTHX_3);
#define PERL_ARGS_ASSERT_WARNER	\
	assert(pat)

PERL_CALLCONV I32	Perl_was_lvalue_sub(pTHX)
			__attribute__warn_unused_result__;

PERL_CALLCONV void	Perl_watch(pTHX_ char** addr);
#define PERL_ARGS_ASSERT_WATCH	\
	assert(addr)
/* PERL_CALLCONV I32	whichsig(pTHX_ const char* sig); */
PERL_CALLCONV I32	Perl_whichsig_pv(pTHX_ const char* sig);
#define PERL_ARGS_ASSERT_WHICHSIG_PV	\
	assert(sig)
PERL_CALLCONV I32	Perl_whichsig_pvn(pTHX_ const char* sig, STRLEN len);
#define PERL_ARGS_ASSERT_WHICHSIG_PVN	\
	assert(sig)
PERL_CALLCONV I32	Perl_whichsig_sv(pTHX_ SV* sigsv);
#define PERL_ARGS_ASSERT_WHICHSIG_SV	\
	assert(sigsv)
PERL_CALLCONV void	Perl_wrap_op_checker(pTHX_ Optype opcode, Perl_check_t new_checker, Perl_check_t *old_checker_p);
#define PERL_ARGS_ASSERT_WRAP_OP_CHECKER	\
	assert(new_checker); assert(old_checker_p)
PERL_CALLCONV void	Perl_write_to_stderr(pTHX_ SV* msv);
#define PERL_ARGS_ASSERT_WRITE_TO_STDERR	\
	assert(msv)
PERL_CALLCONV void	Perl_xs_boot_epilog(pTHX_ const I32 ax);
PERL_CALLCONV I32	Perl_xs_handshake(const U32 key, void * v_my_perl, const char * file, ...);
#define PERL_ARGS_ASSERT_XS_HANDSHAKE	\
	assert(v_my_perl); assert(file)
PERL_CALLCONV int	Perl_yyerror(pTHX_ const char *const s);
#define PERL_ARGS_ASSERT_YYERROR	\
	assert(s)
PERL_CALLCONV int	Perl_yyerror_pv(pTHX_ const char *const s, U32 flags);
#define PERL_ARGS_ASSERT_YYERROR_PV	\
	assert(s)
PERL_CALLCONV int	Perl_yyerror_pvn(pTHX_ const char *const s, STRLEN len, U32 flags);
#define PERL_ARGS_ASSERT_YYERROR_PVN	\
	assert(s)
PERL_CALLCONV int	Perl_yylex(pTHX);
PERL_CALLCONV int	Perl_yyparse(pTHX_ int gramtype);
PERL_CALLCONV void	Perl_yyunlex(pTHX);
#if !(defined(DEBUGGING))
#  if !defined(NV_PRESERVES_UV)
#    if defined(PERL_IN_SV_C)
STATIC int	S_sv_2iuv_non_preserve(pTHX_ SV *const sv);
#define PERL_ARGS_ASSERT_SV_2IUV_NON_PRESERVE	\
	assert(sv)
#    endif
#  endif
#endif
#if !(defined(HAS_SIGACTION) && defined(SA_SIGINFO))
PERL_CALLCONV Signal_t	Perl_csighandler(int sig);
PERL_CALLCONV Signal_t	Perl_sighandler(int sig);
#endif
#if !(defined(NO_MATHOMS))
PERL_CALLCONV void	Perl_sv_nounlocking(pTHX_ SV *sv);
#endif
#if !(defined(PERL_DEFAULT_DO_EXEC3_IMPLEMENTATION))
PERL_CALLCONV bool	Perl_do_exec(pTHX_ const char* cmd);
#define PERL_ARGS_ASSERT_DO_EXEC	\
	assert(cmd)
#endif
#if !(defined(PERL_GLOBAL_STRUCT_PRIVATE))
#  if defined(PERL_IMPLICIT_CONTEXT)
PERL_CALLCONV void*	Perl_my_cxt_init(pTHX_ int *index, size_t size);
#define PERL_ARGS_ASSERT_MY_CXT_INIT	\
	assert(index)
#  endif
#endif
#if !(defined(WIN32))
/* PERL_CALLCONV char*	my_setlocale(pTHX_ int category, const char* locale)
			__attribute__pure__; */

#endif
#if !(defined(_MSC_VER))
PERL_CALLCONV_NO_RET int	Perl_magic_regdatum_set(pTHX_ SV* sv, MAGIC* mg)
			__attribute__noreturn__;
#define PERL_ARGS_ASSERT_MAGIC_REGDATUM_SET	\
	assert(sv); assert(mg)

#endif
#if !defined(HAS_BZERO) && !defined(HAS_MEMSET)
PERL_CALLCONV void*	Perl_my_bzero(void* vloc, size_t len);
#define PERL_ARGS_ASSERT_MY_BZERO	\
	assert(vloc)
#endif
#if !defined(HAS_GETENV_LEN)
PERL_CALLCONV char*	Perl_getenv_len(pTHX_ const char *env_elem, unsigned long *len);
#define PERL_ARGS_ASSERT_GETENV_LEN	\
	assert(env_elem); assert(len)
#endif
#if !defined(HAS_MEMCMP) || !defined(HAS_SANE_MEMCMP)
PERL_CALLCONV int	Perl_my_memcmp(const void* vs1, const void* vs2, size_t len)
			__attribute__pure__;
#define PERL_ARGS_ASSERT_MY_MEMCMP	\
	assert(vs1); assert(vs2)

#endif
#if !defined(HAS_MEMCPY) || (!defined(HAS_MEMMOVE) && !defined(HAS_SAFE_MEMCPY))
PERL_CALLCONV void*	Perl_my_bcopy(const void* vfrom, void* vto, size_t len);
#define PERL_ARGS_ASSERT_MY_BCOPY	\
	assert(vfrom); assert(vto)
#endif
#if !defined(HAS_MEMSET)
PERL_CALLCONV void*	Perl_my_memset(void* vloc, int ch, size_t len);
#define PERL_ARGS_ASSERT_MY_MEMSET	\
	assert(vloc)
#endif
#if !defined(HAS_MKDIR) || !defined(HAS_RMDIR)
#  if defined(PERL_IN_PP_SYS_C)
STATIC int	S_dooneliner(pTHX_ const char *cmd, const char *filename)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_DOONELINER	\
	assert(cmd); assert(filename)

#  endif
#endif
#if !defined(HAS_RENAME)
PERL_CALLCONV I32	Perl_same_dirent(pTHX_ const char* a, const char* b);
#define PERL_ARGS_ASSERT_SAME_DIRENT	\
	assert(a); assert(b)
#endif
#if !defined(HAS_SIGNBIT)
PERL_CALLCONV int	Perl_signbit(NV f)
			__attribute__pure__;

#endif
#if !defined(HAS_STRLCAT)
PERL_CALLCONV Size_t	Perl_my_strlcat(char *dst, const char *src, Size_t size);
#endif
#if !defined(HAS_STRLCPY)
PERL_CALLCONV Size_t	Perl_my_strlcpy(char *dst, const char *src, Size_t size);
#endif
#if !defined(HAS_TRUNCATE) && !defined(HAS_CHSIZE) && defined(F_FREESP)
PERL_CALLCONV I32	Perl_my_chsize(pTHX_ int fd, Off_t length)
			__attribute__warn_unused_result__;

#endif
#if !defined(NV_PRESERVES_UV)
#  if defined(DEBUGGING)
#    if defined(PERL_IN_SV_C)
STATIC int	S_sv_2iuv_non_preserve(pTHX_ SV *const sv, I32 numtype);
#define PERL_ARGS_ASSERT_SV_2IUV_NON_PRESERVE	\
	assert(sv)
#    endif
#  endif
#endif
#if !defined(PERL_DISABLE_PMC)
#  if defined(PERL_IN_PP_CTL_C)
STATIC PerlIO *	S_doopen_pm(pTHX_ SV *name)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_DOOPEN_PM	\
	assert(name)

#  endif
#endif
#if !defined(PERL_EXT_RE_BUILD)
#  if defined(PERL_IN_REGCOMP_C)
PERL_STATIC_INLINE IV*	S_get_invlist_previous_index_addr(SV* invlist)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_GET_INVLIST_PREVIOUS_INDEX_ADDR	\
	assert(invlist)

PERL_STATIC_INLINE void	S_invlist_clear(pTHX_ SV* invlist);
#define PERL_ARGS_ASSERT_INVLIST_CLEAR	\
	assert(invlist)
PERL_STATIC_INLINE IV	S_invlist_previous_index(SV* const invlist)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_INVLIST_PREVIOUS_INDEX	\
	assert(invlist)

STATIC void	S_invlist_replace_list_destroys_src(pTHX_ SV *dest, SV *src);
#define PERL_ARGS_ASSERT_INVLIST_REPLACE_LIST_DESTROYS_SRC	\
	assert(dest); assert(src)
PERL_STATIC_INLINE void	S_invlist_set_previous_index(SV* const invlist, const IV index);
#define PERL_ARGS_ASSERT_INVLIST_SET_PREVIOUS_INDEX	\
	assert(invlist)
PERL_STATIC_INLINE void	S_invlist_trim(SV* invlist);
#define PERL_ARGS_ASSERT_INVLIST_TRIM	\
	assert(invlist)
#  endif
#endif
#if !defined(PERL_IMPLICIT_SYS)
PERL_CALLCONV I32	Perl_my_pclose(pTHX_ PerlIO* ptr);
PERL_CALLCONV PerlIO*	Perl_my_popen(pTHX_ const char* cmd, const char* mode);
#define PERL_ARGS_ASSERT_MY_POPEN	\
	assert(cmd); assert(mode)
#endif
#if !defined(PERL_IS_MINIPERL)
#  if defined(PERL_IN_PERL_C)
STATIC SV *	S_incpush_if_exists(pTHX_ AV *const av, SV *dir, SV *const stem);
#define PERL_ARGS_ASSERT_INCPUSH_IF_EXISTS	\
	assert(av); assert(dir); assert(stem)
#  endif
#endif
#if !defined(PERL_NO_INLINE_FUNCTIONS)
PERL_STATIC_INLINE STRLEN	S__is_utf8_char_slow(const U8 *s, const U8 *e)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT__IS_UTF8_CHAR_SLOW	\
	assert(s); assert(e)

PERL_STATIC_INLINE void	S_append_utf8_from_native_byte(const U8 byte, U8** dest);
#define PERL_ARGS_ASSERT_APPEND_UTF8_FROM_NATIVE_BYTE	\
	assert(dest)
PERL_STATIC_INLINE SSize_t	S_av_top_index(pTHX_ AV *av)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_AV_TOP_INDEX	\
	assert(av)

PERL_STATIC_INLINE void	S_cx_popblock(pTHX_ PERL_CONTEXT *cx);
#define PERL_ARGS_ASSERT_CX_POPBLOCK	\
	assert(cx)
PERL_STATIC_INLINE void	S_cx_popeval(pTHX_ PERL_CONTEXT *cx);
#define PERL_ARGS_ASSERT_CX_POPEVAL	\
	assert(cx)
PERL_STATIC_INLINE void	S_cx_popformat(pTHX_ PERL_CONTEXT *cx);
#define PERL_ARGS_ASSERT_CX_POPFORMAT	\
	assert(cx)
PERL_STATIC_INLINE void	S_cx_popgiven(pTHX_ PERL_CONTEXT *cx);
#define PERL_ARGS_ASSERT_CX_POPGIVEN	\
	assert(cx)
PERL_STATIC_INLINE void	S_cx_poploop(pTHX_ PERL_CONTEXT *cx);
#define PERL_ARGS_ASSERT_CX_POPLOOP	\
	assert(cx)
PERL_STATIC_INLINE void	S_cx_popsub(pTHX_ PERL_CONTEXT *cx);
#define PERL_ARGS_ASSERT_CX_POPSUB	\
	assert(cx)
PERL_STATIC_INLINE void	S_cx_popsub_args(pTHX_ PERL_CONTEXT *cx);
#define PERL_ARGS_ASSERT_CX_POPSUB_ARGS	\
	assert(cx)
PERL_STATIC_INLINE void	S_cx_popsub_common(pTHX_ PERL_CONTEXT *cx);
#define PERL_ARGS_ASSERT_CX_POPSUB_COMMON	\
	assert(cx)
PERL_STATIC_INLINE void	S_cx_popwhen(pTHX_ PERL_CONTEXT *cx);
#define PERL_ARGS_ASSERT_CX_POPWHEN	\
	assert(cx)
PERL_STATIC_INLINE PERL_CONTEXT *	S_cx_pushblock(pTHX_ U8 type, U8 gimme, SV** sp, I32 saveix);
#define PERL_ARGS_ASSERT_CX_PUSHBLOCK	\
	assert(sp)
PERL_STATIC_INLINE void	S_cx_pusheval(pTHX_ PERL_CONTEXT *cx, OP *retop, SV *namesv);
#define PERL_ARGS_ASSERT_CX_PUSHEVAL	\
	assert(cx)
PERL_STATIC_INLINE void	S_cx_pushformat(pTHX_ PERL_CONTEXT *cx, CV *cv, OP *retop, GV *gv);
#define PERL_ARGS_ASSERT_CX_PUSHFORMAT	\
	assert(cx); assert(cv)
PERL_STATIC_INLINE void	S_cx_pushgiven(pTHX_ PERL_CONTEXT *cx, SV *orig_defsv);
#define PERL_ARGS_ASSERT_CX_PUSHGIVEN	\
	assert(cx)
PERL_STATIC_INLINE void	S_cx_pushloop_for(pTHX_ PERL_CONTEXT *cx, void *itervarp, SV *itersave);
#define PERL_ARGS_ASSERT_CX_PUSHLOOP_FOR	\
	assert(cx); assert(itervarp)
PERL_STATIC_INLINE void	S_cx_pushloop_plain(pTHX_ PERL_CONTEXT *cx);
#define PERL_ARGS_ASSERT_CX_PUSHLOOP_PLAIN	\
	assert(cx)
PERL_STATIC_INLINE void	S_cx_pushsub(pTHX_ PERL_CONTEXT *cx, CV *cv, OP *retop, bool hasargs);
#define PERL_ARGS_ASSERT_CX_PUSHSUB	\
	assert(cx); assert(cv)
PERL_STATIC_INLINE void	S_cx_pushwhen(pTHX_ PERL_CONTEXT *cx);
#define PERL_ARGS_ASSERT_CX_PUSHWHEN	\
	assert(cx)
PERL_STATIC_INLINE void	S_cx_topblock(pTHX_ PERL_CONTEXT *cx);
#define PERL_ARGS_ASSERT_CX_TOPBLOCK	\
	assert(cx)
PERL_STATIC_INLINE bool	S_is_safe_syscall(pTHX_ const char *pv, STRLEN len, const char *what, const char *op_name)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_IS_SAFE_SYSCALL	\
	assert(pv); assert(what); assert(op_name)

PERL_STATIC_INLINE bool	S_sv_only_taint_gmagic(SV *sv);
#define PERL_ARGS_ASSERT_SV_ONLY_TAINT_GMAGIC	\
	assert(sv)
#endif
#if !defined(PERL_NO_UTF16_FILTER)
#  if defined(PERL_IN_TOKE_C)
STATIC U8*	S_add_utf16_textfilter(pTHX_ U8 *const s, bool reversed);
#define PERL_ARGS_ASSERT_ADD_UTF16_TEXTFILTER	\
	assert(s)
STATIC I32	S_utf16_textfilter(pTHX_ int idx, SV *sv, int maxlen);
#define PERL_ARGS_ASSERT_UTF16_TEXTFILTER	\
	assert(sv)
#  endif
#endif
#if !defined(SETUID_SCRIPTS_ARE_SECURE_NOW)
#  if defined(PERL_IN_PERL_C)
STATIC void	S_validate_suid(pTHX_ PerlIO *rsfp);
#define PERL_ARGS_ASSERT_VALIDATE_SUID	\
	assert(rsfp)
#  endif
#endif
#if !defined(SPRINTF_RETURNS_STRLEN)
PERL_CALLCONV int	Perl_my_sprintf(char *buffer, const char *pat, ...);
#define PERL_ARGS_ASSERT_MY_SPRINTF	\
	assert(buffer); assert(pat)
#endif
#if !defined(USE_QUADMATH)
#  if defined(PERL_IN_NUMERIC_C)
STATIC NV	S_mulexp10(NV value, I32 exponent);
#  endif
#endif
#if !defined(WIN32)
PERL_CALLCONV bool	Perl_do_exec3(pTHX_ const char *incmd, int fd, int do_report);
#define PERL_ARGS_ASSERT_DO_EXEC3	\
	assert(incmd)
#endif
#if defined(DEBUGGING)
PERL_CALLCONV int	Perl_get_debug_opts(pTHX_ const char **s, bool givehelp)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_GET_DEBUG_OPTS	\
	assert(s)

PERL_CALLCONV void	Perl_hv_assert(pTHX_ HV *hv);
#define PERL_ARGS_ASSERT_HV_ASSERT	\
	assert(hv)
PERL_CALLCONV void	Perl_pad_setsv(pTHX_ PADOFFSET po, SV* sv);
#define PERL_ARGS_ASSERT_PAD_SETSV	\
	assert(sv)
PERL_CALLCONV SV*	Perl_pad_sv(pTHX_ PADOFFSET po);
PERL_CALLCONV void	Perl_set_padlist(CV * cv, PADLIST * padlist);
#define PERL_ARGS_ASSERT_SET_PADLIST	\
	assert(cv)
#  if defined(PERL_IN_PAD_C)
STATIC void	S_cv_dump(pTHX_ const CV *cv, const char *title);
#define PERL_ARGS_ASSERT_CV_DUMP	\
	assert(cv); assert(title)
#  endif
#  if defined(PERL_IN_REGCOMP_C)
STATIC void	S_dump_trie(pTHX_ const struct _reg_trie_data *trie, HV* widecharmap, AV *revcharmap, U32 depth);
#define PERL_ARGS_ASSERT_DUMP_TRIE	\
	assert(trie); assert(revcharmap)
STATIC void	S_dump_trie_interim_list(pTHX_ const struct _reg_trie_data *trie, HV* widecharmap, AV *revcharmap, U32 next_alloc, U32 depth);
#define PERL_ARGS_ASSERT_DUMP_TRIE_INTERIM_LIST	\
	assert(trie); assert(revcharmap)
STATIC void	S_dump_trie_interim_table(pTHX_ const struct _reg_trie_data *trie, HV* widecharmap, AV *revcharmap, U32 next_alloc, U32 depth);
#define PERL_ARGS_ASSERT_DUMP_TRIE_INTERIM_TABLE	\
	assert(trie); assert(revcharmap)
STATIC const regnode*	S_dumpuntil(pTHX_ const regexp *r, const regnode *start, const regnode *node, const regnode *last, const regnode *plast, SV* sv, I32 indent, U32 depth);
#define PERL_ARGS_ASSERT_DUMPUNTIL	\
	assert(r); assert(start); assert(node); assert(sv)
STATIC bool	S_put_charclass_bitmap_innards(pTHX_ SV* sv, char* bitmap, SV* nonbitmap_invlist, SV* only_utf8_locale_invlist, const regnode * const node);
#define PERL_ARGS_ASSERT_PUT_CHARCLASS_BITMAP_INNARDS	\
	assert(sv); assert(bitmap)
STATIC SV*	S_put_charclass_bitmap_innards_common(pTHX_ SV* invlist, SV* posixes, SV* only_utf8, SV* not_utf8, SV* only_utf8_locale, const bool invert);
#define PERL_ARGS_ASSERT_PUT_CHARCLASS_BITMAP_INNARDS_COMMON	\
	assert(invlist)
STATIC void	S_put_charclass_bitmap_innards_invlist(pTHX_ SV *sv, SV* invlist);
#define PERL_ARGS_ASSERT_PUT_CHARCLASS_BITMAP_INNARDS_INVLIST	\
	assert(sv); assert(invlist)
STATIC void	S_put_code_point(pTHX_ SV* sv, UV c);
#define PERL_ARGS_ASSERT_PUT_CODE_POINT	\
	assert(sv)
STATIC void	S_put_range(pTHX_ SV* sv, UV start, const UV end, const bool allow_literals);
#define PERL_ARGS_ASSERT_PUT_RANGE	\
	assert(sv)
PERL_CALLCONV int	Perl_re_indentf(pTHX_ const char *fmt, U32 depth, ...);
#define PERL_ARGS_ASSERT_RE_INDENTF	\
	assert(fmt)
STATIC void	S_regdump_extflags(pTHX_ const char *lead, const U32 flags);
STATIC void	S_regdump_intflags(pTHX_ const char *lead, const U32 flags);
STATIC U8	S_regtail_study(pTHX_ RExC_state_t *pRExC_state, regnode *p, const regnode *val, U32 depth);
#define PERL_ARGS_ASSERT_REGTAIL_STUDY	\
	assert(pRExC_state); assert(p); assert(val)
#  endif
#  if defined(PERL_IN_REGEXEC_C)
STATIC void	S_debug_start_match(pTHX_ const REGEXP *prog, const bool do_utf8, const char *start, const char *end, const char *blurb);
#define PERL_ARGS_ASSERT_DEBUG_START_MATCH	\
	assert(prog); assert(start); assert(end); assert(blurb)
STATIC void	S_dump_exec_pos(pTHX_ const char *locinput, const regnode *scan, const char *loc_regeol, const char *loc_bostr, const char *loc_reg_starttry, const bool do_utf8, const U32 depth);
#define PERL_ARGS_ASSERT_DUMP_EXEC_POS	\
	assert(locinput); assert(scan); assert(loc_regeol); assert(loc_bostr); assert(loc_reg_starttry)
PERL_CALLCONV int	Perl_re_exec_indentf(pTHX_ const char *fmt, U32 depth, ...);
#define PERL_ARGS_ASSERT_RE_EXEC_INDENTF	\
	assert(fmt)
#  endif
#  if defined(PERL_IN_SV_C)
STATIC void	S_del_sv(pTHX_ SV *p);
#define PERL_ARGS_ASSERT_DEL_SV	\
	assert(p)
#  endif
#  if defined(PERL_IN_TOKE_C)
STATIC void	S_printbuf(pTHX_ const char *const fmt, const char *const s)
			__attribute__format__(__printf__,pTHX_1,0);
#define PERL_ARGS_ASSERT_PRINTBUF	\
	assert(fmt); assert(s)

STATIC int	S_tokereport(pTHX_ I32 rv, const YYSTYPE* lvalp);
#define PERL_ARGS_ASSERT_TOKEREPORT	\
	assert(lvalp)
#  endif
#  if defined(USE_LOCALE)     && (defined(PERL_IN_LOCALE_C) || defined (PERL_EXT_POSIX))
PERL_CALLCONV char *	Perl__setlocale_debug_string(const int category, const char* const locale, const char* const retval)
			__attribute__warn_unused_result__
			__attribute__pure__;

#  endif
#endif
#if defined(DEBUG_LEAKING_SCALARS_FORK_DUMP)
PERL_CALLCONV void	Perl_dump_sv_child(pTHX_ SV *sv);
#define PERL_ARGS_ASSERT_DUMP_SV_CHILD	\
	assert(sv)
#endif
#if defined(HAS_MSG) || defined(HAS_SEM) || defined(HAS_SHM)
PERL_CALLCONV I32	Perl_do_ipcctl(pTHX_ I32 optype, SV** mark, SV** sp);
#define PERL_ARGS_ASSERT_DO_IPCCTL	\
	assert(mark); assert(sp)
PERL_CALLCONV I32	Perl_do_ipcget(pTHX_ I32 optype, SV** mark, SV** sp);
#define PERL_ARGS_ASSERT_DO_IPCGET	\
	assert(mark); assert(sp)
PERL_CALLCONV I32	Perl_do_msgrcv(pTHX_ SV** mark, SV** sp);
#define PERL_ARGS_ASSERT_DO_MSGRCV	\
	assert(mark); assert(sp)
PERL_CALLCONV I32	Perl_do_msgsnd(pTHX_ SV** mark, SV** sp);
#define PERL_ARGS_ASSERT_DO_MSGSND	\
	assert(mark); assert(sp)
PERL_CALLCONV I32	Perl_do_semop(pTHX_ SV** mark, SV** sp);
#define PERL_ARGS_ASSERT_DO_SEMOP	\
	assert(mark); assert(sp)
PERL_CALLCONV I32	Perl_do_shmio(pTHX_ I32 optype, SV** mark, SV** sp);
#define PERL_ARGS_ASSERT_DO_SHMIO	\
	assert(mark); assert(sp)
#endif
#if defined(HAS_SIGACTION) && defined(SA_SIGINFO)
PERL_CALLCONV Signal_t	Perl_csighandler(int sig, siginfo_t *info, void *uap);
PERL_CALLCONV Signal_t	Perl_sighandler(int sig, siginfo_t *info, void *uap);
#endif
#if defined(HAVE_INTERP_INTERN)
PERL_CALLCONV void	Perl_sys_intern_clear(pTHX);
PERL_CALLCONV void	Perl_sys_intern_init(pTHX);
#  if defined(USE_ITHREADS)
PERL_CALLCONV void	Perl_sys_intern_dup(pTHX_ struct interp_intern* src, struct interp_intern* dst);
#define PERL_ARGS_ASSERT_SYS_INTERN_DUP	\
	assert(src); assert(dst)
#  endif
#endif
#if defined(MYMALLOC)
PERL_CALLCONV void	Perl_dump_mstats(pTHX_ const char* s);
#define PERL_ARGS_ASSERT_DUMP_MSTATS	\
	assert(s)
PERL_CALLCONV int	Perl_get_mstats(pTHX_ perl_mstats_t *buf, int buflen, int level);
#define PERL_ARGS_ASSERT_GET_MSTATS	\
	assert(buf)
PERL_CALLCONV MEM_SIZE	Perl_malloc_good_size(size_t nbytes)
			__attribute__warn_unused_result__;

PERL_CALLCONV MEM_SIZE	Perl_malloced_size(void *p)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_MALLOCED_SIZE	\
	assert(p)

#endif
#if defined(NO_MATHOMS)
/* PERL_CALLCONV void	Perl_sv_nounlocking(pTHX_ SV *sv); */
#endif
#if defined(PERL_ANY_COW)
PERL_CALLCONV SV*	Perl_sv_setsv_cow(pTHX_ SV* dstr, SV* sstr);
#define PERL_ARGS_ASSERT_SV_SETSV_COW	\
	assert(sstr)
#endif
#if defined(PERL_CORE)
PERL_CALLCONV void	Perl_opslab_force_free(pTHX_ OPSLAB *slab);
#define PERL_ARGS_ASSERT_OPSLAB_FORCE_FREE	\
	assert(slab)
PERL_CALLCONV void	Perl_opslab_free(pTHX_ OPSLAB *slab);
#define PERL_ARGS_ASSERT_OPSLAB_FREE	\
	assert(slab)
PERL_CALLCONV void	Perl_opslab_free_nopad(pTHX_ OPSLAB *slab);
#define PERL_ARGS_ASSERT_OPSLAB_FREE_NOPAD	\
	assert(slab)
PERL_CALLCONV void	Perl_parser_free_nexttoke_ops(pTHX_ yy_parser *parser, OPSLAB *slab);
#define PERL_ARGS_ASSERT_PARSER_FREE_NEXTTOKE_OPS	\
	assert(parser); assert(slab)
PERL_STATIC_INLINE bool	S_should_warn_nl(const char *pv)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_SHOULD_WARN_NL	\
	assert(pv)

#  if defined(PERL_DEBUG_READONLY_OPS)
PERL_CALLCONV void	Perl_Slab_to_ro(pTHX_ OPSLAB *slab);
#define PERL_ARGS_ASSERT_SLAB_TO_RO	\
	assert(slab)
PERL_CALLCONV void	Perl_Slab_to_rw(pTHX_ OPSLAB *const slab);
#define PERL_ARGS_ASSERT_SLAB_TO_RW	\
	assert(slab)
#  endif
#endif
#if defined(PERL_CORE) || defined (PERL_EXT)
PERL_STATIC_INLINE STRLEN	S_sv_or_pv_pos_u2b(pTHX_ SV *sv, const char *pv, STRLEN pos, STRLEN *lenp);
#define PERL_ARGS_ASSERT_SV_OR_PV_POS_U2B	\
	assert(sv); assert(pv)
#endif
#if defined(PERL_CR_FILTER)
#  if defined(PERL_IN_TOKE_C)
STATIC I32	S_cr_textfilter(pTHX_ int idx, SV *sv, int maxlen);
STATIC void	S_strip_return(pTHX_ SV *sv);
#define PERL_ARGS_ASSERT_STRIP_RETURN	\
	assert(sv)
#  endif
#endif
#if defined(PERL_DEBUG_READONLY_COW)
PERL_CALLCONV void	Perl_sv_buf_to_ro(pTHX_ SV *sv);
#define PERL_ARGS_ASSERT_SV_BUF_TO_RO	\
	assert(sv)
#  if defined(PERL_IN_SV_C)
STATIC void	S_sv_buf_to_rw(pTHX_ SV *sv);
#define PERL_ARGS_ASSERT_SV_BUF_TO_RW	\
	assert(sv)
#  endif
#endif
#if defined(PERL_DEBUG_READONLY_OPS)
PERL_CALLCONV PADOFFSET	Perl_op_refcnt_dec(pTHX_ OP *o);
#define PERL_ARGS_ASSERT_OP_REFCNT_DEC	\
	assert(o)
PERL_CALLCONV OP *	Perl_op_refcnt_inc(pTHX_ OP *o);
#endif
#if defined(PERL_DEFAULT_DO_EXEC3_IMPLEMENTATION)
/* PERL_CALLCONV bool	Perl_do_exec(pTHX_ const char* cmd); */
#endif
#if defined(PERL_DONT_CREATE_GVSV)
/* PERL_CALLCONV GV*	Perl_gv_SVadd(pTHX_ GV *gv); */
#endif
#if defined(PERL_GLOBAL_STRUCT)
PERL_CALLCONV struct perl_vars *	Perl_GetVars(pTHX);
PERL_CALLCONV void	Perl_free_global_struct(pTHX_ struct perl_vars *plvarsp);
#define PERL_ARGS_ASSERT_FREE_GLOBAL_STRUCT	\
	assert(plvarsp)
PERL_CALLCONV struct perl_vars*	Perl_init_global_struct(pTHX);
#endif
#if defined(PERL_GLOBAL_STRUCT_PRIVATE)
#  if defined(PERL_IMPLICIT_CONTEXT)
PERL_CALLCONV int	Perl_my_cxt_index(pTHX_ const char *my_cxt_key);
#define PERL_ARGS_ASSERT_MY_CXT_INDEX	\
	assert(my_cxt_key)
PERL_CALLCONV void*	Perl_my_cxt_init(pTHX_ const char *my_cxt_key, size_t size);
#define PERL_ARGS_ASSERT_MY_CXT_INIT	\
	assert(my_cxt_key)
#  endif
#endif
#if defined(PERL_IMPLICIT_CONTEXT)
PERL_CALLCONV_NO_RET void	Perl_croak_nocontext(const char* pat, ...)
			__attribute__noreturn__
			__attribute__format__null_ok__(__printf__,1,2);

PERL_CALLCONV void	Perl_deb_nocontext(const char* pat, ...)
			__attribute__format__(__printf__,1,2);
#define PERL_ARGS_ASSERT_DEB_NOCONTEXT	\
	assert(pat)

PERL_CALLCONV_NO_RET OP*	Perl_die_nocontext(const char* pat, ...)
			__attribute__noreturn__
			__attribute__format__null_ok__(__printf__,1,2);

PERL_CALLCONV char*	Perl_form_nocontext(const char* pat, ...)
			__attribute__format__(__printf__,1,2);
#define PERL_ARGS_ASSERT_FORM_NOCONTEXT	\
	assert(pat)

PERL_CALLCONV int	Perl_fprintf_nocontext(PerlIO *stream, const char *format, ...)
			__attribute__format__(__printf__,2,3);
#define PERL_ARGS_ASSERT_FPRINTF_NOCONTEXT	\
	assert(stream); assert(format)

PERL_CALLCONV void	Perl_load_module_nocontext(U32 flags, SV* name, SV* ver, ...);
#define PERL_ARGS_ASSERT_LOAD_MODULE_NOCONTEXT	\
	assert(name)
PERL_CALLCONV SV*	Perl_mess_nocontext(const char* pat, ...)
			__attribute__format__(__printf__,1,2);
#define PERL_ARGS_ASSERT_MESS_NOCONTEXT	\
	assert(pat)

PERL_CALLCONV SV*	Perl_newSVpvf_nocontext(const char *const pat, ...)
			__attribute__format__(__printf__,1,2);
#define PERL_ARGS_ASSERT_NEWSVPVF_NOCONTEXT	\
	assert(pat)

PERL_CALLCONV int	Perl_printf_nocontext(const char *format, ...)
			__attribute__format__(__printf__,1,2);
#define PERL_ARGS_ASSERT_PRINTF_NOCONTEXT	\
	assert(format)

PERL_CALLCONV void	Perl_sv_catpvf_mg_nocontext(SV *const sv, const char *const pat, ...)
			__attribute__format__(__printf__,2,3);
#define PERL_ARGS_ASSERT_SV_CATPVF_MG_NOCONTEXT	\
	assert(sv); assert(pat)

PERL_CALLCONV void	Perl_sv_catpvf_nocontext(SV *const sv, const char *const pat, ...)
			__attribute__format__(__printf__,2,3);
#define PERL_ARGS_ASSERT_SV_CATPVF_NOCONTEXT	\
	assert(sv); assert(pat)

PERL_CALLCONV void	Perl_sv_setpvf_mg_nocontext(SV *const sv, const char *const pat, ...)
			__attribute__format__(__printf__,2,3);
#define PERL_ARGS_ASSERT_SV_SETPVF_MG_NOCONTEXT	\
	assert(sv); assert(pat)

PERL_CALLCONV void	Perl_sv_setpvf_nocontext(SV *const sv, const char *const pat, ...)
			__attribute__format__(__printf__,2,3);
#define PERL_ARGS_ASSERT_SV_SETPVF_NOCONTEXT	\
	assert(sv); assert(pat)

PERL_CALLCONV void	Perl_warn_nocontext(const char* pat, ...)
			__attribute__format__(__printf__,1,2);
#define PERL_ARGS_ASSERT_WARN_NOCONTEXT	\
	assert(pat)

PERL_CALLCONV void	Perl_warner_nocontext(U32 err, const char* pat, ...)
			__attribute__format__(__printf__,2,3);
#define PERL_ARGS_ASSERT_WARNER_NOCONTEXT	\
	assert(pat)

#endif
#if defined(PERL_IMPLICIT_SYS)
PERL_CALLCONV PerlInterpreter*	perl_alloc_using(struct IPerlMem *ipM, struct IPerlMem *ipMS, struct IPerlMem *ipMP, struct IPerlEnv *ipE, struct IPerlStdIO *ipStd, struct IPerlLIO *ipLIO, struct IPerlDir *ipD, struct IPerlSock *ipS, struct IPerlProc *ipP);
#define PERL_ARGS_ASSERT_PERL_ALLOC_USING	\
	assert(ipM); assert(ipMS); assert(ipMP); assert(ipE); assert(ipStd); assert(ipLIO); assert(ipD); assert(ipS); assert(ipP)
#  if defined(USE_ITHREADS)
PERL_CALLCONV PerlInterpreter*	perl_clone_using(PerlInterpreter *proto_perl, UV flags, struct IPerlMem* ipM, struct IPerlMem* ipMS, struct IPerlMem* ipMP, struct IPerlEnv* ipE, struct IPerlStdIO* ipStd, struct IPerlLIO* ipLIO, struct IPerlDir* ipD, struct IPerlSock* ipS, struct IPerlProc* ipP);
#define PERL_ARGS_ASSERT_PERL_CLONE_USING	\
	assert(proto_perl); assert(ipM); assert(ipMS); assert(ipMP); assert(ipE); assert(ipStd); assert(ipLIO); assert(ipD); assert(ipS); assert(ipP)
#  endif
#endif
#if defined(PERL_IN_AV_C)
STATIC MAGIC*	S_get_aux_mg(pTHX_ AV *av);
#define PERL_ARGS_ASSERT_GET_AUX_MG	\
	assert(av)
#endif
#if defined(PERL_IN_DEB_C)
STATIC void	S_deb_stack_n(pTHX_ SV** stack_base, I32 stack_min, I32 stack_max, I32 mark_min, I32 mark_max);
#define PERL_ARGS_ASSERT_DEB_STACK_N	\
	assert(stack_base)
#endif
#if defined(PERL_IN_DOIO_C)
STATIC void	S_exec_failed(pTHX_ const char *cmd, int fd, int do_report);
#define PERL_ARGS_ASSERT_EXEC_FAILED	\
	assert(cmd)
STATIC bool	S_ingroup(pTHX_ Gid_t testgid, bool effective)
			__attribute__warn_unused_result__;

STATIC bool	S_openn_cleanup(pTHX_ GV *gv, IO *io, PerlIO *fp, char *mode, const char *oname, PerlIO *saveifp, PerlIO *saveofp, int savefd, char savetype, int writing, bool was_fdopen, const char *type);
#define PERL_ARGS_ASSERT_OPENN_CLEANUP	\
	assert(gv); assert(io); assert(mode); assert(oname)
STATIC IO *	S_openn_setup(pTHX_ GV *gv, char *mode, PerlIO **saveifp, PerlIO **saveofp, int *savefd, char *savetype);
#define PERL_ARGS_ASSERT_OPENN_SETUP	\
	assert(gv); assert(mode); assert(saveifp); assert(saveofp); assert(savefd); assert(savetype)
#endif
#if defined(PERL_IN_DOOP_C)
STATIC I32	S_do_trans_complex(pTHX_ SV * const sv)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_DO_TRANS_COMPLEX	\
	assert(sv)

STATIC I32	S_do_trans_complex_utf8(pTHX_ SV * const sv)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_DO_TRANS_COMPLEX_UTF8	\
	assert(sv)

STATIC I32	S_do_trans_count(pTHX_ SV * const sv)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_DO_TRANS_COUNT	\
	assert(sv)

STATIC I32	S_do_trans_count_utf8(pTHX_ SV * const sv)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_DO_TRANS_COUNT_UTF8	\
	assert(sv)

STATIC I32	S_do_trans_simple(pTHX_ SV * const sv)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_DO_TRANS_SIMPLE	\
	assert(sv)

STATIC I32	S_do_trans_simple_utf8(pTHX_ SV * const sv)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_DO_TRANS_SIMPLE_UTF8	\
	assert(sv)

#endif
#if defined(PERL_IN_DUMP_C)
STATIC CV*	S_deb_curcv(pTHX_ I32 ix);
STATIC void	S_debprof(pTHX_ const OP *o);
#define PERL_ARGS_ASSERT_DEBPROF	\
	assert(o)
STATIC SV*	S_pm_description(pTHX_ const PMOP *pm);
#define PERL_ARGS_ASSERT_PM_DESCRIPTION	\
	assert(pm)
STATIC UV	S_sequence_num(pTHX_ const OP *o);
#endif
#if defined(PERL_IN_DUMP_C) || defined(PERL_IN_HV_C) || defined(PERL_IN_SV_C) || defined(PERL_IN_SCOPE_C)
PERL_CALLCONV void	Perl_hv_kill_backrefs(pTHX_ HV *hv);
#define PERL_ARGS_ASSERT_HV_KILL_BACKREFS	\
	assert(hv)
#endif
#if defined(PERL_IN_GV_C)
STATIC bool	S_find_default_stash(pTHX_ HV **stash, const char *name, STRLEN len, const U32 is_utf8, const I32 add, const svtype sv_type);
#define PERL_ARGS_ASSERT_FIND_DEFAULT_STASH	\
	assert(stash); assert(name)
PERL_STATIC_INLINE GV*	S_gv_fetchmeth_internal(pTHX_ HV* stash, SV* meth, const char* name, STRLEN len, I32 level, U32 flags);
STATIC void	S_gv_init_svtype(pTHX_ GV *gv, const svtype sv_type);
#define PERL_ARGS_ASSERT_GV_INIT_SVTYPE	\
	assert(gv)
STATIC bool	S_gv_is_in_main(pTHX_ const char *name, STRLEN len, const U32 is_utf8);
#define PERL_ARGS_ASSERT_GV_IS_IN_MAIN	\
	assert(name)
STATIC bool	S_gv_magicalize(pTHX_ GV *gv, HV *stash, const char *name, STRLEN len, bool addmg, const svtype sv_type);
#define PERL_ARGS_ASSERT_GV_MAGICALIZE	\
	assert(gv); assert(stash); assert(name)
STATIC void	S_gv_magicalize_isa(pTHX_ GV *gv);
#define PERL_ARGS_ASSERT_GV_MAGICALIZE_ISA	\
	assert(gv)
PERL_STATIC_INLINE HV*	S_gv_stashpvn_internal(pTHX_ const char* name, U32 namelen, I32 flags);
#define PERL_ARGS_ASSERT_GV_STASHPVN_INTERNAL	\
	assert(name)
PERL_STATIC_INLINE HV*	S_gv_stashsvpvn_cached(pTHX_ SV *namesv, const char* name, U32 namelen, I32 flags);
STATIC void	S_maybe_multimagic_gv(pTHX_ GV *gv, const char *name, const svtype sv_type);
#define PERL_ARGS_ASSERT_MAYBE_MULTIMAGIC_GV	\
	assert(gv); assert(name)
STATIC bool	S_parse_gv_stash_name(pTHX_ HV **stash, GV **gv, const char **name, STRLEN *len, const char *nambeg, STRLEN full_len, const U32 is_utf8, const I32 add);
#define PERL_ARGS_ASSERT_PARSE_GV_STASH_NAME	\
	assert(stash); assert(gv); assert(name); assert(len); assert(nambeg)
STATIC HV*	S_require_tie_mod(pTHX_ GV *gv, const char *varpv, SV* namesv, const char *methpv, const U32 flags);
#define PERL_ARGS_ASSERT_REQUIRE_TIE_MOD	\
	assert(gv); assert(varpv); assert(namesv); assert(methpv)
#endif
#if defined(PERL_IN_GV_C) || defined(PERL_IN_SV_C) || defined(PERL_IN_PAD_C) || defined(PERL_IN_OP_C)
PERL_CALLCONV void	Perl_sv_add_backref(pTHX_ SV *const tsv, SV *const sv);
#define PERL_ARGS_ASSERT_SV_ADD_BACKREF	\
	assert(tsv); assert(sv)
#endif
#if defined(PERL_IN_HV_C)
STATIC void	S_clear_placeholders(pTHX_ HV *hv, U32 items);
#define PERL_ARGS_ASSERT_CLEAR_PLACEHOLDERS	\
	assert(hv)
STATIC void	S_hfreeentries(pTHX_ HV *hv);
#define PERL_ARGS_ASSERT_HFREEENTRIES	\
	assert(hv)
STATIC void	S_hsplit(pTHX_ HV *hv, STRLEN const oldsize, STRLEN newsize);
#define PERL_ARGS_ASSERT_HSPLIT	\
	assert(hv)
STATIC struct xpvhv_aux*	S_hv_auxinit(pTHX_ HV *hv);
#define PERL_ARGS_ASSERT_HV_AUXINIT	\
	assert(hv)
STATIC struct xpvhv_aux*	S_hv_auxinit_internal(struct xpvhv_aux *iter);
#define PERL_ARGS_ASSERT_HV_AUXINIT_INTERNAL	\
	assert(iter)
STATIC SV*	S_hv_delete_common(pTHX_ HV *hv, SV *keysv, const char *key, STRLEN klen, int k_flags, I32 d_flags, U32 hash);
STATIC SV*	S_hv_free_ent_ret(pTHX_ HV *hv, HE *entry);
#define PERL_ARGS_ASSERT_HV_FREE_ENT_RET	\
	assert(hv); assert(entry)
STATIC void	S_hv_magic_check(HV *hv, bool *needs_copy, bool *needs_store);
#define PERL_ARGS_ASSERT_HV_MAGIC_CHECK	\
	assert(hv); assert(needs_copy); assert(needs_store)
PERL_STATIC_NO_RET void	S_hv_notallowed(pTHX_ int flags, const char *key, I32 klen, const char *msg)
			__attribute__noreturn__;
#define PERL_ARGS_ASSERT_HV_NOTALLOWED	\
	assert(key); assert(msg)

STATIC HE*	S_new_he(pTHX)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_STATIC_INLINE U32	S_ptr_hash(PTRV u);
STATIC SV *	S_refcounted_he_value(pTHX_ const struct refcounted_he *he);
#define PERL_ARGS_ASSERT_REFCOUNTED_HE_VALUE	\
	assert(he)
STATIC HEK*	S_save_hek_flags(const char *str, I32 len, U32 hash, int flags)
			__attribute__malloc__
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_SAVE_HEK_FLAGS	\
	assert(str)

STATIC HEK*	S_share_hek_flags(pTHX_ const char *str, I32 len, U32 hash, int flags)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_SHARE_HEK_FLAGS	\
	assert(str)

STATIC void	S_unshare_hek_or_pvn(pTHX_ const HEK* hek, const char* str, I32 len, U32 hash);
#endif
#if defined(PERL_IN_HV_C) || defined(PERL_IN_MG_C) || defined(PERL_IN_SV_C)
PERL_CALLCONV void	Perl_sv_kill_backrefs(pTHX_ SV *const sv, AV *const av);
#define PERL_ARGS_ASSERT_SV_KILL_BACKREFS	\
	assert(sv)
#endif
#if defined(PERL_IN_HV_C) || defined(PERL_IN_SV_C)
PERL_CALLCONV SV*	Perl_hfree_next_entry(pTHX_ HV *hv, STRLEN *indexp);
#define PERL_ARGS_ASSERT_HFREE_NEXT_ENTRY	\
	assert(hv); assert(indexp)
#endif
#if defined(PERL_IN_MALLOC_C)
STATIC int	S_adjust_size_and_find_bucket(size_t *nbytes_p);
#define PERL_ARGS_ASSERT_ADJUST_SIZE_AND_FIND_BUCKET	\
	assert(nbytes_p)
#endif
#if defined(PERL_IN_MG_C)
STATIC void	S_fixup_errno_string(pTHX_ SV* sv);
#define PERL_ARGS_ASSERT_FIXUP_ERRNO_STRING	\
	assert(sv)
STATIC SV*	S_magic_methcall1(pTHX_ SV *sv, const MAGIC *mg, SV *meth, U32 flags, int n, SV *val);
#define PERL_ARGS_ASSERT_MAGIC_METHCALL1	\
	assert(sv); assert(mg); assert(meth)
STATIC int	S_magic_methpack(pTHX_ SV *sv, const MAGIC *mg, SV *meth);
#define PERL_ARGS_ASSERT_MAGIC_METHPACK	\
	assert(sv); assert(mg); assert(meth)
STATIC void	S_restore_magic(pTHX_ const void *p);
STATIC void	S_save_magic_flags(pTHX_ I32 mgs_ix, SV *sv, U32 flags);
#define PERL_ARGS_ASSERT_SAVE_MAGIC_FLAGS	\
	assert(sv)
STATIC void	S_unwind_handler_stack(pTHX_ const void *p);
#endif
#if defined(PERL_IN_MG_C) || defined(PERL_IN_PP_C)
PERL_CALLCONV bool	Perl_translate_substr_offsets(STRLEN curlen, IV pos1_iv, bool pos1_is_uv, IV len_iv, bool len_is_uv, STRLEN *posp, STRLEN *lenp);
#define PERL_ARGS_ASSERT_TRANSLATE_SUBSTR_OFFSETS	\
	assert(posp); assert(lenp)
#endif
#if defined(PERL_IN_MRO_C)
STATIC void	S_mro_clean_isarev(pTHX_ HV * const isa, const char * const name, const STRLEN len, HV * const exceptions, U32 hash, U32 flags);
#define PERL_ARGS_ASSERT_MRO_CLEAN_ISAREV	\
	assert(isa); assert(name)
STATIC void	S_mro_gather_and_rename(pTHX_ HV * const stashes, HV * const seen_stashes, HV *stash, HV *oldstash, SV *namesv);
#define PERL_ARGS_ASSERT_MRO_GATHER_AND_RENAME	\
	assert(stashes); assert(seen_stashes); assert(namesv)
STATIC AV*	S_mro_get_linear_isa_dfs(pTHX_ HV* stash, U32 level);
#define PERL_ARGS_ASSERT_MRO_GET_LINEAR_ISA_DFS	\
	assert(stash)
#endif
#if defined(PERL_IN_OP_C)
STATIC void	S_apply_attrs(pTHX_ HV *stash, SV *target, OP *attrs);
#define PERL_ARGS_ASSERT_APPLY_ATTRS	\
	assert(stash); assert(target)
STATIC void	S_apply_attrs_my(pTHX_ HV *stash, OP *target, OP *attrs, OP **imopsp);
#define PERL_ARGS_ASSERT_APPLY_ATTRS_MY	\
	assert(stash); assert(target); assert(imopsp)
STATIC I32	S_assignment_type(pTHX_ const OP *o)
			__attribute__warn_unused_result__;

STATIC void	S_bad_type_gv(pTHX_ I32 n, GV *gv, const OP *kid, const char *t);
#define PERL_ARGS_ASSERT_BAD_TYPE_GV	\
	assert(gv); assert(kid); assert(t)
STATIC void	S_bad_type_pv(pTHX_ I32 n, const char *t, const OP *o, const OP *kid);
#define PERL_ARGS_ASSERT_BAD_TYPE_PV	\
	assert(t); assert(o); assert(kid)
STATIC void	S_clear_special_blocks(pTHX_ const char *const fullname, GV *const gv, CV *const cv);
#define PERL_ARGS_ASSERT_CLEAR_SPECIAL_BLOCKS	\
	assert(fullname); assert(gv); assert(cv)
STATIC void	S_cop_free(pTHX_ COP *cop);
#define PERL_ARGS_ASSERT_COP_FREE	\
	assert(cop)
STATIC OP *	S_dup_attrlist(pTHX_ OP *o);
#define PERL_ARGS_ASSERT_DUP_ATTRLIST	\
	assert(o)
STATIC void	S_finalize_op(pTHX_ OP* o);
#define PERL_ARGS_ASSERT_FINALIZE_OP	\
	assert(o)
STATIC void	S_find_and_forget_pmops(pTHX_ OP *o);
#define PERL_ARGS_ASSERT_FIND_AND_FORGET_PMOPS	\
	assert(o)
STATIC OP*	S_fold_constants(pTHX_ OP *o);
#define PERL_ARGS_ASSERT_FOLD_CONSTANTS	\
	assert(o)
STATIC OP*	S_force_list(pTHX_ OP* arg, bool nullit);
STATIC void	S_forget_pmop(pTHX_ PMOP *const o);
#define PERL_ARGS_ASSERT_FORGET_PMOP	\
	assert(o)
STATIC OP*	S_gen_constant_list(pTHX_ OP* o);
STATIC void	S_inplace_aassign(pTHX_ OP* o);
#define PERL_ARGS_ASSERT_INPLACE_AASSIGN	\
	assert(o)
STATIC bool	S_is_handle_constructor(const OP *o, I32 numargs)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_IS_HANDLE_CONSTRUCTOR	\
	assert(o)

STATIC OP*	S_listkids(pTHX_ OP* o);
STATIC bool	S_looks_like_bool(pTHX_ const OP* o);
#define PERL_ARGS_ASSERT_LOOKS_LIKE_BOOL	\
	assert(o)
STATIC OP*	S_modkids(pTHX_ OP *o, I32 type);
STATIC void	S_move_proto_attr(pTHX_ OP **proto, OP **attrs, const GV *name);
#define PERL_ARGS_ASSERT_MOVE_PROTO_ATTR	\
	assert(proto); assert(attrs); assert(name)
STATIC OP *	S_my_kid(pTHX_ OP *o, OP *attrs, OP **imopsp);
#define PERL_ARGS_ASSERT_MY_KID	\
	assert(imopsp)
STATIC OP*	S_newGIVWHENOP(pTHX_ OP* cond, OP *block, I32 enter_opcode, I32 leave_opcode, PADOFFSET entertarg);
#define PERL_ARGS_ASSERT_NEWGIVWHENOP	\
	assert(block)
PERL_STATIC_INLINE OP*	S_newMETHOP_internal(pTHX_ I32 type, I32 flags, OP* dynamic_meth, SV* const_meth);
STATIC OP*	S_new_logop(pTHX_ I32 type, I32 flags, OP **firstp, OP **otherp)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEW_LOGOP	\
	assert(firstp); assert(otherp)

STATIC void	S_no_bareword_allowed(pTHX_ OP *o);
#define PERL_ARGS_ASSERT_NO_BAREWORD_ALLOWED	\
	assert(o)
STATIC OP*	S_no_fh_allowed(pTHX_ OP *o)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NO_FH_ALLOWED	\
	assert(o)

PERL_STATIC_INLINE OP*	S_op_integerize(pTHX_ OP *o);
#define PERL_ARGS_ASSERT_OP_INTEGERIZE	\
	assert(o)
PERL_STATIC_INLINE OP*	S_op_std_init(pTHX_ OP *o);
#define PERL_ARGS_ASSERT_OP_STD_INIT	\
	assert(o)
STATIC OP*	S_pmtrans(pTHX_ OP* o, OP* expr, OP* repl);
#define PERL_ARGS_ASSERT_PMTRANS	\
	assert(o); assert(expr); assert(repl)
STATIC bool	S_process_special_blocks(pTHX_ I32 floor, const char *const fullname, GV *const gv, CV *const cv);
#define PERL_ARGS_ASSERT_PROCESS_SPECIAL_BLOCKS	\
	assert(fullname); assert(gv); assert(cv)
STATIC OP*	S_ref_array_or_hash(pTHX_ OP* cond);
STATIC OP*	S_refkids(pTHX_ OP* o, I32 type);
STATIC bool	S_scalar_mod_type(const OP *o, I32 type)
			__attribute__warn_unused_result__;

STATIC OP*	S_scalarboolean(pTHX_ OP *o);
#define PERL_ARGS_ASSERT_SCALARBOOLEAN	\
	assert(o)
STATIC OP*	S_scalarkids(pTHX_ OP* o);
STATIC OP*	S_scalarseq(pTHX_ OP* o);
STATIC OP*	S_search_const(pTHX_ OP *o)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_SEARCH_CONST	\
	assert(o)

STATIC void	S_simplify_sort(pTHX_ OP *o);
#define PERL_ARGS_ASSERT_SIMPLIFY_SORT	\
	assert(o)
STATIC OP*	S_too_few_arguments_pv(pTHX_ OP *o, const char* name, U32 flags)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_TOO_FEW_ARGUMENTS_PV	\
	assert(o); assert(name)

STATIC OP*	S_too_many_arguments_pv(pTHX_ OP *o, const char* name, U32 flags);
#define PERL_ARGS_ASSERT_TOO_MANY_ARGUMENTS_PV	\
	assert(o); assert(name)
#  if defined(USE_ITHREADS)
PERL_STATIC_INLINE void	S_op_relocate_sv(pTHX_ SV** svp, PADOFFSET* targp);
#define PERL_ARGS_ASSERT_OP_RELOCATE_SV	\
	assert(svp); assert(targp)
#  endif
#endif
#if defined(PERL_IN_OP_C) || defined(PERL_IN_SV_C)
PERL_CALLCONV void	Perl_report_redefined_cv(pTHX_ const SV *name, const CV *old_cv, SV * const *new_const_svp);
#define PERL_ARGS_ASSERT_REPORT_REDEFINED_CV	\
	assert(name); assert(old_cv)
#endif
#if defined(PERL_IN_PAD_C)
STATIC PADOFFSET	S_pad_alloc_name(pTHX_ PADNAME *name, U32 flags, HV *typestash, HV *ourstash);
#define PERL_ARGS_ASSERT_PAD_ALLOC_NAME	\
	assert(name)
STATIC void	S_pad_check_dup(pTHX_ PADNAME *name, U32 flags, const HV *ourstash);
#define PERL_ARGS_ASSERT_PAD_CHECK_DUP	\
	assert(name)
STATIC PADOFFSET	S_pad_findlex(pTHX_ const char *namepv, STRLEN namelen, U32 flags, const CV* cv, U32 seq, int warn, SV** out_capture, PADNAME** out_name, int *out_flags);
#define PERL_ARGS_ASSERT_PAD_FINDLEX	\
	assert(namepv); assert(cv); assert(out_name); assert(out_flags)
STATIC void	S_pad_reset(pTHX);
#endif
#if defined(PERL_IN_PERL_C)
STATIC void	S_find_beginning(pTHX_ SV* linestr_sv, PerlIO *rsfp);
#define PERL_ARGS_ASSERT_FIND_BEGINNING	\
	assert(linestr_sv); assert(rsfp)
STATIC void	S_forbid_setid(pTHX_ const char flag, const bool suidscript);
STATIC void	S_incpush(pTHX_ const char *const dir, STRLEN len, U32 flags);
#define PERL_ARGS_ASSERT_INCPUSH	\
	assert(dir)
STATIC void	S_incpush_use_sep(pTHX_ const char *p, STRLEN len, U32 flags);
#define PERL_ARGS_ASSERT_INCPUSH_USE_SEP	\
	assert(p)
STATIC void	S_init_ids(pTHX);
STATIC void	S_init_interp(pTHX);
STATIC void	S_init_main_stash(pTHX);
STATIC void	S_init_perllib(pTHX);
STATIC void	S_init_postdump_symbols(pTHX_ int argc, char **argv, char **env);
#define PERL_ARGS_ASSERT_INIT_POSTDUMP_SYMBOLS	\
	assert(argv)
STATIC void	S_init_predump_symbols(pTHX);
STATIC SV*	S_mayberelocate(pTHX_ const char *const dir, STRLEN len, U32 flags);
#define PERL_ARGS_ASSERT_MAYBERELOCATE	\
	assert(dir)
PERL_STATIC_NO_RET void	S_minus_v(pTHX)
			__attribute__noreturn__;

PERL_STATIC_NO_RET void	S_my_exit_jump(pTHX)
			__attribute__noreturn__;

STATIC void	S_nuke_stacks(pTHX);
STATIC PerlIO *	S_open_script(pTHX_ const char *scriptname, bool dosearch, bool *suidscript);
#define PERL_ARGS_ASSERT_OPEN_SCRIPT	\
	assert(scriptname); assert(suidscript)
STATIC void*	S_parse_body(pTHX_ char **env, XSINIT_t xsinit);
PERL_STATIC_NO_RET void	S_run_body(pTHX_ I32 oldscope)
			__attribute__noreturn__;

PERL_STATIC_NO_RET void	S_usage(pTHX)
			__attribute__noreturn__;

#endif
#if defined(PERL_IN_PP_C)
STATIC size_t	S_do_chomp(pTHX_ SV *retval, SV *sv, bool chomping);
#define PERL_ARGS_ASSERT_DO_CHOMP	\
	assert(retval); assert(sv)
STATIC OP*	S_do_delete_local(pTHX);
STATIC SV*	S_refto(pTHX_ SV* sv)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_REFTO	\
	assert(sv)

#endif
#if defined(PERL_IN_PP_C) || defined(PERL_IN_PP_HOT_C)
PERL_CALLCONV GV*	Perl_softref2xv(pTHX_ SV *const sv, const char *const what, const svtype type, SV ***spp)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_SOFTREF2XV	\
	assert(sv); assert(what); assert(spp)

#endif
#if defined(PERL_IN_PP_CTL_C)
STATIC PerlIO *	S_check_type_and_open(pTHX_ SV *name)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_CHECK_TYPE_AND_OPEN	\
	assert(name)

STATIC void	S_destroy_matcher(pTHX_ PMOP* matcher);
#define PERL_ARGS_ASSERT_DESTROY_MATCHER	\
	assert(matcher)
STATIC OP*	S_do_smartmatch(pTHX_ HV* seen_this, HV* seen_other, const bool copied);
STATIC OP*	S_docatch(pTHX_ OP *o)
			__attribute__warn_unused_result__;

STATIC bool	S_doeval_compile(pTHX_ U8 gimme, CV* outside, U32 seq, HV* hh);
STATIC OP*	S_dofindlabel(pTHX_ OP *o, const char *label, STRLEN len, U32 flags, OP **opstack, OP **oplimit)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_DOFINDLABEL	\
	assert(o); assert(label); assert(opstack); assert(oplimit)

STATIC MAGIC *	S_doparseform(pTHX_ SV *sv);
#define PERL_ARGS_ASSERT_DOPARSEFORM	\
	assert(sv)
STATIC I32	S_dopoptoeval(pTHX_ I32 startingblock)
			__attribute__warn_unused_result__;

STATIC I32	S_dopoptogivenfor(pTHX_ I32 startingblock)
			__attribute__warn_unused_result__;

STATIC I32	S_dopoptolabel(pTHX_ const char *label, STRLEN len, U32 flags)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_DOPOPTOLABEL	\
	assert(label)

STATIC I32	S_dopoptoloop(pTHX_ I32 startingblock)
			__attribute__warn_unused_result__;

STATIC I32	S_dopoptosub_at(pTHX_ const PERL_CONTEXT* cxstk, I32 startingblock)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_DOPOPTOSUB_AT	\
	assert(cxstk)

STATIC I32	S_dopoptowhen(pTHX_ I32 startingblock)
			__attribute__warn_unused_result__;

STATIC PMOP*	S_make_matcher(pTHX_ REGEXP* re)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_MAKE_MATCHER	\
	assert(re)

STATIC bool	S_matcher_matches_sv(pTHX_ PMOP* matcher, SV* sv)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_MATCHER_MATCHES_SV	\
	assert(matcher); assert(sv)

STATIC bool	S_num_overflow(NV value, I32 fldsize, I32 frcsize)
			__attribute__warn_unused_result__;

PERL_STATIC_INLINE bool	S_path_is_searchable(const char *name)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_PATH_IS_SEARCHABLE	\
	assert(name)

STATIC I32	S_run_user_filter(pTHX_ int idx, SV *buf_sv, int maxlen)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_RUN_USER_FILTER	\
	assert(buf_sv)

STATIC void	S_rxres_free(pTHX_ void** rsp);
#define PERL_ARGS_ASSERT_RXRES_FREE	\
	assert(rsp)
STATIC void	S_rxres_restore(pTHX_ void **rsp, REGEXP *rx);
#define PERL_ARGS_ASSERT_RXRES_RESTORE	\
	assert(rsp); assert(rx)
STATIC void	S_save_lines(pTHX_ AV *array, SV *sv);
#define PERL_ARGS_ASSERT_SAVE_LINES	\
	assert(sv)
#endif
#if defined(PERL_IN_PP_HOT_C)
STATIC void	S_do_oddball(pTHX_ SV **oddkey, SV **firstkey);
#define PERL_ARGS_ASSERT_DO_ODDBALL	\
	assert(oddkey); assert(firstkey)
PERL_STATIC_INLINE HV*	S_opmethod_stash(pTHX_ SV* meth);
#define PERL_ARGS_ASSERT_OPMETHOD_STASH	\
	assert(meth)
#endif
#if defined(PERL_IN_PP_PACK_C)
STATIC int	S_div128(pTHX_ SV *pnum, bool *done);
#define PERL_ARGS_ASSERT_DIV128	\
	assert(pnum); assert(done)
STATIC char	S_first_symbol(const char *pat, const char *patend);
#define PERL_ARGS_ASSERT_FIRST_SYMBOL	\
	assert(pat); assert(patend)
STATIC const char *	S_get_num(pTHX_ const char *patptr, I32 *lenptr)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_GET_NUM	\
	assert(patptr); assert(lenptr)

STATIC const char *	S_group_end(pTHX_ const char *patptr, const char *patend, char ender);
#define PERL_ARGS_ASSERT_GROUP_END	\
	assert(patptr); assert(patend)
STATIC SV*	S_is_an_int(pTHX_ const char *s, STRLEN l)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_IS_AN_INT	\
	assert(s)

STATIC I32	S_measure_struct(pTHX_ struct tempsym* symptr);
#define PERL_ARGS_ASSERT_MEASURE_STRUCT	\
	assert(symptr)
STATIC SV*	S_mul128(pTHX_ SV *sv, U8 m);
#define PERL_ARGS_ASSERT_MUL128	\
	assert(sv)
STATIC char *	S_my_bytes_to_utf8(const U8 *start, STRLEN len, char *dest, const bool needs_swap)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_MY_BYTES_TO_UTF8	\
	assert(start); assert(dest)

STATIC bool	S_need_utf8(const char *pat, const char *patend);
#define PERL_ARGS_ASSERT_NEED_UTF8	\
	assert(pat); assert(patend)
STATIC bool	S_next_symbol(pTHX_ struct tempsym* symptr);
#define PERL_ARGS_ASSERT_NEXT_SYMBOL	\
	assert(symptr)
STATIC SV **	S_pack_rec(pTHX_ SV *cat, struct tempsym* symptr, SV **beglist, SV **endlist);
#define PERL_ARGS_ASSERT_PACK_REC	\
	assert(cat); assert(symptr); assert(beglist); assert(endlist)
STATIC char *	S_sv_exp_grow(pTHX_ SV *sv, STRLEN needed)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_SV_EXP_GROW	\
	assert(sv)

STATIC I32	S_unpack_rec(pTHX_ struct tempsym* symptr, const char *s, const char *strbeg, const char *strend, const char **new_s);
#define PERL_ARGS_ASSERT_UNPACK_REC	\
	assert(symptr); assert(s); assert(strbeg); assert(strend)
#endif
#if defined(PERL_IN_PP_SORT_C)
STATIC I32	S_amagic_cmp(pTHX_ SV *const str1, SV *const str2);
#define PERL_ARGS_ASSERT_AMAGIC_CMP	\
	assert(str1); assert(str2)
STATIC I32	S_amagic_i_ncmp(pTHX_ SV *const a, SV *const b);
#define PERL_ARGS_ASSERT_AMAGIC_I_NCMP	\
	assert(a); assert(b)
STATIC I32	S_amagic_ncmp(pTHX_ SV *const a, SV *const b);
#define PERL_ARGS_ASSERT_AMAGIC_NCMP	\
	assert(a); assert(b)
STATIC void	S_qsortsvu(pTHX_ SV** array, size_t num_elts, SVCOMPARE_t compare);
#define PERL_ARGS_ASSERT_QSORTSVU	\
	assert(compare)
STATIC I32	S_sortcv(pTHX_ SV *const a, SV *const b);
#define PERL_ARGS_ASSERT_SORTCV	\
	assert(a); assert(b)
STATIC I32	S_sortcv_stacked(pTHX_ SV *const a, SV *const b);
#define PERL_ARGS_ASSERT_SORTCV_STACKED	\
	assert(a); assert(b)
STATIC I32	S_sortcv_xsub(pTHX_ SV *const a, SV *const b);
#define PERL_ARGS_ASSERT_SORTCV_XSUB	\
	assert(a); assert(b)
STATIC I32	S_sv_i_ncmp(pTHX_ SV *const a, SV *const b);
#define PERL_ARGS_ASSERT_SV_I_NCMP	\
	assert(a); assert(b)
STATIC I32	S_sv_ncmp(pTHX_ SV *const a, SV *const b);
#define PERL_ARGS_ASSERT_SV_NCMP	\
	assert(a); assert(b)
#  if defined(USE_LOCALE_COLLATE)
STATIC I32	S_amagic_cmp_locale(pTHX_ SV *const str1, SV *const str2);
#define PERL_ARGS_ASSERT_AMAGIC_CMP_LOCALE	\
	assert(str1); assert(str2)
#  endif
#endif
#if defined(PERL_IN_PP_SYS_C)
STATIC OP*	S_doform(pTHX_ CV *cv, GV *gv, OP *retop);
#define PERL_ARGS_ASSERT_DOFORM	\
	assert(cv); assert(gv)
STATIC SV *	S_space_join_names_mortal(pTHX_ char *const *array);
#define PERL_ARGS_ASSERT_SPACE_JOIN_NAMES_MORTAL	\
	assert(array)
#endif
#if defined(PERL_IN_REGCOMP_C)
STATIC void	S__append_range_to_invlist(pTHX_ SV* const invlist, const UV start, const UV end);
#define PERL_ARGS_ASSERT__APPEND_RANGE_TO_INVLIST	\
	assert(invlist)
PERL_STATIC_INLINE UV*	S__invlist_array_init(SV* const invlist, const bool will_have_0)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT__INVLIST_ARRAY_INIT	\
	assert(invlist)

STATIC SV*	S__make_exactf_invlist(pTHX_ RExC_state_t *pRExC_state, regnode *node)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT__MAKE_EXACTF_INVLIST	\
	assert(pRExC_state); assert(node)

STATIC void	S_add_above_Latin1_folds(pTHX_ RExC_state_t *pRExC_state, const U8 cp, SV** invlist);
#define PERL_ARGS_ASSERT_ADD_ABOVE_LATIN1_FOLDS	\
	assert(pRExC_state); assert(invlist)
PERL_STATIC_INLINE SV*	S_add_cp_to_invlist(pTHX_ SV* invlist, const UV cp)
			__attribute__warn_unused_result__;

STATIC U32	S_add_data(RExC_state_t* const pRExC_state, const char* const s, const U32 n)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_ADD_DATA	\
	assert(pRExC_state); assert(s)

STATIC AV*	S_add_multi_match(pTHX_ AV* multi_char_matches, SV* multi_string, const STRLEN cp_count);
#define PERL_ARGS_ASSERT_ADD_MULTI_MATCH	\
	assert(multi_string)
PERL_STATIC_INLINE void	S_alloc_maybe_populate_EXACT(pTHX_ RExC_state_t *pRExC_state, regnode *node, I32 *flagp, STRLEN len, UV code_point, bool downgradable);
#define PERL_ARGS_ASSERT_ALLOC_MAYBE_POPULATE_EXACT	\
	assert(pRExC_state); assert(node); assert(flagp)
STATIC const char *	S_cntrl_to_mnemonic(const U8 c)
			__attribute__pure__;

PERL_STATIC_INLINE U8	S_compute_EXACTish(RExC_state_t *pRExC_state);
#define PERL_ARGS_ASSERT_COMPUTE_EXACTISH	\
	assert(pRExC_state)
STATIC regnode *	S_construct_ahocorasick_from_trie(pTHX_ RExC_state_t *pRExC_state, regnode *source, U32 depth);
#define PERL_ARGS_ASSERT_CONSTRUCT_AHOCORASICK_FROM_TRIE	\
	assert(pRExC_state); assert(source)
STATIC int	S_edit_distance(const UV *src, const UV *tgt, const STRLEN x, const STRLEN y, const SSize_t maxDistance)
			__attribute__pure__;
#define PERL_ARGS_ASSERT_EDIT_DISTANCE	\
	assert(src); assert(tgt)

STATIC SV*	S_get_ANYOF_cp_list_for_ssc(pTHX_ const RExC_state_t *pRExC_state, const regnode_charclass* const node);
#define PERL_ARGS_ASSERT_GET_ANYOF_CP_LIST_FOR_SSC	\
	assert(pRExC_state); assert(node)
PERL_STATIC_INLINE STRLEN*	S_get_invlist_iter_addr(SV* invlist)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_GET_INVLIST_ITER_ADDR	\
	assert(invlist)

STATIC bool	S_grok_bslash_N(pTHX_ RExC_state_t *pRExC_state, regnode** nodep, UV *code_point_p, int* cp_count, I32 *flagp, const bool strict, const U32 depth);
#define PERL_ARGS_ASSERT_GROK_BSLASH_N	\
	assert(pRExC_state); assert(flagp)
PERL_STATIC_INLINE regnode*	S_handle_named_backref(pTHX_ RExC_state_t *pRExC_state, I32 *flagp, char * parse_start, char ch);
#define PERL_ARGS_ASSERT_HANDLE_NAMED_BACKREF	\
	assert(pRExC_state); assert(flagp); assert(parse_start)
STATIC int	S_handle_possible_posix(pTHX_ RExC_state_t *pRExC_state, const char* const s, char ** updated_parse_ptr, AV** posix_warnings, const bool check_only);
#define PERL_ARGS_ASSERT_HANDLE_POSSIBLE_POSIX	\
	assert(pRExC_state); assert(s)
STATIC regnode*	S_handle_regex_sets(pTHX_ RExC_state_t *pRExC_state, SV ** return_invlist, I32 *flagp, U32 depth, char * const oregcomp_parse);
#define PERL_ARGS_ASSERT_HANDLE_REGEX_SETS	\
	assert(pRExC_state); assert(flagp); assert(oregcomp_parse)
PERL_STATIC_INLINE SV*	S_invlist_clone(pTHX_ SV* const invlist)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_INVLIST_CLONE	\
	assert(invlist)

STATIC SV*	S_invlist_contents(pTHX_ SV* const invlist, const bool traditional_style)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_INVLIST_CONTENTS	\
	assert(invlist)

STATIC void	S_invlist_extend(pTHX_ SV* const invlist, const UV len);
#define PERL_ARGS_ASSERT_INVLIST_EXTEND	\
	assert(invlist)
PERL_STATIC_INLINE UV	S_invlist_highest(SV* const invlist)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_INVLIST_HIGHEST	\
	assert(invlist)

PERL_STATIC_INLINE bool	S_invlist_is_iterating(SV* const invlist)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_INVLIST_IS_ITERATING	\
	assert(invlist)

PERL_STATIC_INLINE void	S_invlist_iterfinish(SV* invlist);
#define PERL_ARGS_ASSERT_INVLIST_ITERFINISH	\
	assert(invlist)
PERL_STATIC_INLINE void	S_invlist_iterinit(SV* invlist);
#define PERL_ARGS_ASSERT_INVLIST_ITERINIT	\
	assert(invlist)
STATIC bool	S_invlist_iternext(SV* invlist, UV* start, UV* end)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_INVLIST_ITERNEXT	\
	assert(invlist); assert(start); assert(end)

PERL_STATIC_INLINE UV	S_invlist_max(SV* const invlist)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_INVLIST_MAX	\
	assert(invlist)

PERL_STATIC_INLINE void	S_invlist_set_len(pTHX_ SV* const invlist, const UV len, const bool offset);
#define PERL_ARGS_ASSERT_INVLIST_SET_LEN	\
	assert(invlist)
STATIC bool	S_is_ssc_worth_it(const RExC_state_t * pRExC_state, const regnode_ssc * ssc);
#define PERL_ARGS_ASSERT_IS_SSC_WORTH_IT	\
	assert(pRExC_state); assert(ssc)
STATIC U32	S_join_exact(pTHX_ RExC_state_t *pRExC_state, regnode *scan, UV *min_subtract, bool *unfolded_multi_char, U32 flags, regnode *val, U32 depth);
#define PERL_ARGS_ASSERT_JOIN_EXACT	\
	assert(pRExC_state); assert(scan); assert(min_subtract); assert(unfolded_multi_char)
STATIC I32	S_make_trie(pTHX_ RExC_state_t *pRExC_state, regnode *startbranch, regnode *first, regnode *last, regnode *tail, U32 word_count, U32 flags, U32 depth);
#define PERL_ARGS_ASSERT_MAKE_TRIE	\
	assert(pRExC_state); assert(startbranch); assert(first); assert(last); assert(tail)
STATIC void	S_nextchar(pTHX_ RExC_state_t *pRExC_state);
#define PERL_ARGS_ASSERT_NEXTCHAR	\
	assert(pRExC_state)
STATIC void	S_output_or_return_posix_warnings(pTHX_ RExC_state_t *pRExC_state, AV* posix_warnings, AV** return_posix_warnings);
#define PERL_ARGS_ASSERT_OUTPUT_OR_RETURN_POSIX_WARNINGS	\
	assert(pRExC_state); assert(posix_warnings)
STATIC void	S_parse_lparen_question_flags(pTHX_ RExC_state_t *pRExC_state);
#define PERL_ARGS_ASSERT_PARSE_LPAREN_QUESTION_FLAGS	\
	assert(pRExC_state)
STATIC void	S_populate_ANYOF_from_invlist(pTHX_ regnode *node, SV** invlist_ptr);
#define PERL_ARGS_ASSERT_POPULATE_ANYOF_FROM_INVLIST	\
	assert(node); assert(invlist_ptr)
PERL_STATIC_NO_RET void	S_re_croak2(pTHX_ bool utf8, const char* pat1, const char* pat2, ...)
			__attribute__noreturn__;
#define PERL_ARGS_ASSERT_RE_CROAK2	\
	assert(pat1); assert(pat2)

STATIC regnode*	S_reg(pTHX_ RExC_state_t *pRExC_state, I32 paren, I32 *flagp, U32 depth);
#define PERL_ARGS_ASSERT_REG	\
	assert(pRExC_state); assert(flagp)
STATIC regnode*	S_reg2Lanode(pTHX_ RExC_state_t *pRExC_state, const U8 op, const U32 arg1, const I32 arg2);
#define PERL_ARGS_ASSERT_REG2LANODE	\
	assert(pRExC_state)
STATIC regnode*	S_reg_node(pTHX_ RExC_state_t *pRExC_state, U8 op);
#define PERL_ARGS_ASSERT_REG_NODE	\
	assert(pRExC_state)
STATIC UV	S_reg_recode(pTHX_ const U8 value, SV **encp);
#define PERL_ARGS_ASSERT_REG_RECODE	\
	assert(encp)
STATIC SV *	S_reg_scan_name(pTHX_ RExC_state_t *pRExC_state, U32 flags);
#define PERL_ARGS_ASSERT_REG_SCAN_NAME	\
	assert(pRExC_state)
PERL_STATIC_INLINE char *	S_reg_skipcomment(RExC_state_t *pRExC_state, char * p);
#define PERL_ARGS_ASSERT_REG_SKIPCOMMENT	\
	assert(pRExC_state); assert(p)
STATIC regnode*	S_reganode(pTHX_ RExC_state_t *pRExC_state, U8 op, U32 arg);
#define PERL_ARGS_ASSERT_REGANODE	\
	assert(pRExC_state)
STATIC regnode*	S_regatom(pTHX_ RExC_state_t *pRExC_state, I32 *flagp, U32 depth);
#define PERL_ARGS_ASSERT_REGATOM	\
	assert(pRExC_state); assert(flagp)
STATIC regnode*	S_regbranch(pTHX_ RExC_state_t *pRExC_state, I32 *flagp, I32 first, U32 depth);
#define PERL_ARGS_ASSERT_REGBRANCH	\
	assert(pRExC_state); assert(flagp)
STATIC regnode*	S_regclass(pTHX_ RExC_state_t *pRExC_state, I32 *flagp, U32 depth, const bool stop_at_1, bool allow_multi_fold, const bool silence_non_portable, const bool strict, bool optimizable, SV** ret_invlist, AV** return_posix_warnings);
#define PERL_ARGS_ASSERT_REGCLASS	\
	assert(pRExC_state); assert(flagp)
STATIC unsigned int	S_regex_set_precedence(const U8 my_operator)
			__attribute__pure__;

STATIC void	S_reginsert(pTHX_ RExC_state_t *pRExC_state, U8 op, regnode *opnd, U32 depth);
#define PERL_ARGS_ASSERT_REGINSERT	\
	assert(pRExC_state); assert(opnd)
STATIC regnode*	S_regnode_guts(pTHX_ RExC_state_t *pRExC_state, const U8 op, const STRLEN extra_len, const char* const name);
#define PERL_ARGS_ASSERT_REGNODE_GUTS	\
	assert(pRExC_state); assert(name)
STATIC regnode*	S_regpiece(pTHX_ RExC_state_t *pRExC_state, I32 *flagp, U32 depth);
#define PERL_ARGS_ASSERT_REGPIECE	\
	assert(pRExC_state); assert(flagp)
STATIC void	S_regtail(pTHX_ RExC_state_t * pRExC_state, const regnode * const p, const regnode * const val, const U32 depth);
#define PERL_ARGS_ASSERT_REGTAIL	\
	assert(pRExC_state); assert(p); assert(val)
STATIC void	S_scan_commit(pTHX_ const RExC_state_t *pRExC_state, struct scan_data_t *data, SSize_t *minlenp, int is_inf);
#define PERL_ARGS_ASSERT_SCAN_COMMIT	\
	assert(pRExC_state); assert(data); assert(minlenp)
STATIC void	S_set_ANYOF_arg(pTHX_ RExC_state_t* const pRExC_state, regnode* const node, SV* const cp_list, SV* const runtime_defns, SV* const only_utf8_locale_list, SV* const swash, const bool has_user_defined_property);
#define PERL_ARGS_ASSERT_SET_ANYOF_ARG	\
	assert(pRExC_state); assert(node)
STATIC void	S_skip_to_be_ignored_text(pTHX_ RExC_state_t *pRExC_state, char ** p, const bool force_to_xmod);
#define PERL_ARGS_ASSERT_SKIP_TO_BE_IGNORED_TEXT	\
	assert(pRExC_state); assert(p)
PERL_STATIC_INLINE void	S_ssc_add_range(pTHX_ regnode_ssc *ssc, UV const start, UV const end);
#define PERL_ARGS_ASSERT_SSC_ADD_RANGE	\
	assert(ssc)
STATIC void	S_ssc_and(pTHX_ const RExC_state_t *pRExC_state, regnode_ssc *ssc, const regnode_charclass *and_with);
#define PERL_ARGS_ASSERT_SSC_AND	\
	assert(pRExC_state); assert(ssc); assert(and_with)
STATIC void	S_ssc_anything(pTHX_ regnode_ssc *ssc);
#define PERL_ARGS_ASSERT_SSC_ANYTHING	\
	assert(ssc)
PERL_STATIC_INLINE void	S_ssc_clear_locale(regnode_ssc *ssc);
#define PERL_ARGS_ASSERT_SSC_CLEAR_LOCALE	\
	assert(ssc)
PERL_STATIC_INLINE void	S_ssc_cp_and(pTHX_ regnode_ssc *ssc, UV const cp);
#define PERL_ARGS_ASSERT_SSC_CP_AND	\
	assert(ssc)
STATIC void	S_ssc_finalize(pTHX_ RExC_state_t *pRExC_state, regnode_ssc *ssc);
#define PERL_ARGS_ASSERT_SSC_FINALIZE	\
	assert(pRExC_state); assert(ssc)
STATIC void	S_ssc_init(pTHX_ const RExC_state_t *pRExC_state, regnode_ssc *ssc);
#define PERL_ARGS_ASSERT_SSC_INIT	\
	assert(pRExC_state); assert(ssc)
PERL_STATIC_INLINE void	S_ssc_intersection(pTHX_ regnode_ssc *ssc, SV* const invlist, const bool invert_2nd);
#define PERL_ARGS_ASSERT_SSC_INTERSECTION	\
	assert(ssc); assert(invlist)
STATIC int	S_ssc_is_anything(const regnode_ssc *ssc)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_SSC_IS_ANYTHING	\
	assert(ssc)

STATIC int	S_ssc_is_cp_posixl_init(const RExC_state_t *pRExC_state, const regnode_ssc *ssc)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_SSC_IS_CP_POSIXL_INIT	\
	assert(pRExC_state); assert(ssc)

STATIC void	S_ssc_or(pTHX_ const RExC_state_t *pRExC_state, regnode_ssc *ssc, const regnode_charclass *or_with);
#define PERL_ARGS_ASSERT_SSC_OR	\
	assert(pRExC_state); assert(ssc); assert(or_with)
PERL_STATIC_INLINE void	S_ssc_union(pTHX_ regnode_ssc *ssc, SV* const invlist, const bool invert_2nd);
#define PERL_ARGS_ASSERT_SSC_UNION	\
	assert(ssc); assert(invlist)
STATIC SSize_t	S_study_chunk(pTHX_ RExC_state_t *pRExC_state, regnode **scanp, SSize_t *minlenp, SSize_t *deltap, regnode *last, struct scan_data_t *data, I32 stopparen, U32 recursed_depth, regnode_ssc *and_withp, U32 flags, U32 depth);
#define PERL_ARGS_ASSERT_STUDY_CHUNK	\
	assert(pRExC_state); assert(scanp); assert(minlenp); assert(deltap); assert(last)
#endif
#if defined(PERL_IN_REGCOMP_C) || defined (PERL_IN_DUMP_C)
PERL_CALLCONV void	Perl__invlist_dump(pTHX_ PerlIO *file, I32 level, const char* const indent, SV* const invlist);
#define PERL_ARGS_ASSERT__INVLIST_DUMP	\
	assert(file); assert(indent); assert(invlist)
#endif
#if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_PERL_C) || defined(PERL_IN_UTF8_C)
PERL_CALLCONV bool	Perl__invlistEQ(pTHX_ SV* const a, SV* const b, const bool complement_b);
#define PERL_ARGS_ASSERT__INVLISTEQ	\
	assert(a); assert(b)
PERL_CALLCONV SV*	Perl__new_invlist_C_array(pTHX_ const UV* const list)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT__NEW_INVLIST_C_ARRAY	\
	assert(list)

#endif
#if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_REGEXEC_C)
PERL_CALLCONV SV*	Perl__get_regclass_nonbitmap_data(pTHX_ const regexp *prog, const struct regnode *node, bool doinit, SV **listsvp, SV **lonly_utf8_locale, SV **output_invlist);
#define PERL_ARGS_ASSERT__GET_REGCLASS_NONBITMAP_DATA	\
	assert(node)
PERL_CALLCONV void	Perl__load_PL_utf8_foldclosures(pTHX);
PERL_CALLCONV int	Perl_re_printf(pTHX_ const char *fmt, ...);
#define PERL_ARGS_ASSERT_RE_PRINTF	\
	assert(fmt)
PERL_CALLCONV void	Perl_regprop(pTHX_ const regexp *prog, SV* sv, const regnode* o, const regmatch_info *reginfo, const RExC_state_t *pRExC_state);
#define PERL_ARGS_ASSERT_REGPROP	\
	assert(sv); assert(o)
#endif
#if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_REGEXEC_C) || defined(PERL_IN_UTF8_C)
PERL_CALLCONV SV*	Perl__get_swash_invlist(pTHX_ SV* const swash)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT__GET_SWASH_INVLIST	\
	assert(swash)

PERL_STATIC_INLINE bool	S__invlist_contains_cp(SV* const invlist, const UV cp)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT__INVLIST_CONTAINS_CP	\
	assert(invlist)

PERL_STATIC_INLINE UV	S__invlist_len(SV* const invlist)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT__INVLIST_LEN	\
	assert(invlist)

PERL_CALLCONV IV	Perl__invlist_search(SV* const invlist, const UV cp)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT__INVLIST_SEARCH	\
	assert(invlist)

PERL_CALLCONV HV*	Perl__swash_inversion_hash(pTHX_ SV* const swash)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT__SWASH_INVERSION_HASH	\
	assert(swash)

PERL_STATIC_INLINE bool*	S_get_invlist_offset_addr(SV* invlist)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_GET_INVLIST_OFFSET_ADDR	\
	assert(invlist)

PERL_STATIC_INLINE UV*	S_invlist_array(SV* const invlist)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_INVLIST_ARRAY	\
	assert(invlist)

#endif
#if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_REGEXEC_C) || defined(PERL_IN_UTF8_C) || defined(PERL_IN_TOKE_C)
PERL_CALLCONV SV*	Perl__core_swash_init(pTHX_ const char* pkg, const char* name, SV* listsv, I32 minbits, I32 none, SV* invlist, U8* const flags_p);
#define PERL_ARGS_ASSERT__CORE_SWASH_INIT	\
	assert(pkg); assert(name); assert(listsv)
#endif
#if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_TOKE_C) || defined(PERL_IN_DQUOTE_C)
PERL_STATIC_INLINE char*	S_form_short_octal_warning(pTHX_ const char * const s, const STRLEN len)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_FORM_SHORT_OCTAL_WARNING	\
	assert(s)

PERL_CALLCONV char	Perl_grok_bslash_c(pTHX_ const char source, const bool output_warning)
			__attribute__warn_unused_result__;

PERL_CALLCONV bool	Perl_grok_bslash_o(pTHX_ char** s, UV* uv, const char** error_msg, const bool output_warning, const bool strict, const bool silence_non_portable, const bool utf8)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_GROK_BSLASH_O	\
	assert(s); assert(uv); assert(error_msg)

PERL_CALLCONV bool	Perl_grok_bslash_x(pTHX_ char** s, UV* uv, const char** error_msg, const bool output_warning, const bool strict, const bool silence_non_portable, const bool utf8)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_GROK_BSLASH_X	\
	assert(s); assert(uv); assert(error_msg)

PERL_STATIC_INLINE I32	S_regcurly(const char *s)
			__attribute__warn_unused_result__
			__attribute__pure__;
#define PERL_ARGS_ASSERT_REGCURLY	\
	assert(s)

#endif
#if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_UTF8_C)
PERL_CALLCONV SV*	Perl__add_range_to_invlist(pTHX_ SV* invlist, const UV start, const UV end)
			__attribute__warn_unused_result__;

/* PERL_CALLCONV void	_invlist_intersection(pTHX_ SV* const a, SV* const b, SV** i); */
PERL_CALLCONV void	Perl__invlist_intersection_maybe_complement_2nd(pTHX_ SV* const a, SV* const b, const bool complement_b, SV** i);
#define PERL_ARGS_ASSERT__INVLIST_INTERSECTION_MAYBE_COMPLEMENT_2ND	\
	assert(b); assert(i)
PERL_CALLCONV void	Perl__invlist_invert(pTHX_ SV* const invlist);
#define PERL_ARGS_ASSERT__INVLIST_INVERT	\
	assert(invlist)
PERL_CALLCONV void	Perl__invlist_populate_swatch(SV* const invlist, const UV start, const UV end, U8* swatch);
#define PERL_ARGS_ASSERT__INVLIST_POPULATE_SWATCH	\
	assert(invlist); assert(swatch)
/* PERL_CALLCONV void	_invlist_subtract(pTHX_ SV* const a, SV* const b, SV** result); */
/* PERL_CALLCONV void	_invlist_union(pTHX_ SV* const a, SV* const b, SV** output); */
PERL_CALLCONV void	Perl__invlist_union_maybe_complement_2nd(pTHX_ SV* const a, SV* const b, const bool complement_b, SV** output);
#define PERL_ARGS_ASSERT__INVLIST_UNION_MAYBE_COMPLEMENT_2ND	\
	assert(b); assert(output)
PERL_CALLCONV SV*	Perl__new_invlist(pTHX_ IV initial_size)
			__attribute__warn_unused_result__;

PERL_CALLCONV SV*	Perl__setup_canned_invlist(pTHX_ const STRLEN size, const UV element0, UV** other_elements_ptr)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT__SETUP_CANNED_INVLIST	\
	assert(other_elements_ptr)

PERL_CALLCONV SV*	Perl__swash_to_invlist(pTHX_ SV* const swash)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT__SWASH_TO_INVLIST	\
	assert(swash)

#endif
#if defined(PERL_IN_REGEXEC_C)
STATIC LB_enum	S_advance_one_LB(pTHX_ U8 ** curpos, const U8 * const strend, const bool utf8_target)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_ADVANCE_ONE_LB	\
	assert(curpos); assert(strend)

STATIC SB_enum	S_advance_one_SB(pTHX_ U8 ** curpos, const U8 * const strend, const bool utf8_target)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_ADVANCE_ONE_SB	\
	assert(curpos); assert(strend)

STATIC WB_enum	S_advance_one_WB(pTHX_ U8 ** curpos, const U8 * const strend, const bool utf8_target, const bool skip_Extend_Format)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_ADVANCE_ONE_WB	\
	assert(curpos); assert(strend)

STATIC LB_enum	S_backup_one_LB(pTHX_ const U8 * const strbeg, U8 ** curpos, const bool utf8_target)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_BACKUP_ONE_LB	\
	assert(strbeg); assert(curpos)

STATIC SB_enum	S_backup_one_SB(pTHX_ const U8 * const strbeg, U8 ** curpos, const bool utf8_target)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_BACKUP_ONE_SB	\
	assert(strbeg); assert(curpos)

STATIC WB_enum	S_backup_one_WB(pTHX_ WB_enum * previous, const U8 * const strbeg, U8 ** curpos, const bool utf8_target)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_BACKUP_ONE_WB	\
	assert(previous); assert(strbeg); assert(curpos)

STATIC char*	S_find_byclass(pTHX_ regexp * prog, const regnode *c, char *s, const char *strend, regmatch_info *reginfo)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_FIND_BYCLASS	\
	assert(prog); assert(c); assert(s); assert(strend)

STATIC bool	S_isFOO_lc(pTHX_ const U8 classnum, const U8 character)
			__attribute__warn_unused_result__;

STATIC bool	S_isFOO_utf8_lc(pTHX_ const U8 classnum, const U8* character)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_ISFOO_UTF8_LC	\
	assert(character)

PERL_STATIC_INLINE bool	S_isGCB(const GCB_enum before, const GCB_enum after)
			__attribute__warn_unused_result__;

STATIC bool	S_isLB(pTHX_ LB_enum before, LB_enum after, const U8 * const strbeg, const U8 * const curpos, const U8 * const strend, const bool utf8_target)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_ISLB	\
	assert(strbeg); assert(curpos); assert(strend)

STATIC bool	S_isSB(pTHX_ SB_enum before, SB_enum after, const U8 * const strbeg, const U8 * const curpos, const U8 * const strend, const bool utf8_target)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_ISSB	\
	assert(strbeg); assert(curpos); assert(strend)

STATIC bool	S_isWB(pTHX_ WB_enum previous, WB_enum before, WB_enum after, const U8 * const strbeg, const U8 * const curpos, const U8 * const strend, const bool utf8_target)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_ISWB	\
	assert(strbeg); assert(curpos); assert(strend)

STATIC I32	S_reg_check_named_buff_matched(const regexp *rex, const regnode *scan)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_REG_CHECK_NAMED_BUFF_MATCHED	\
	assert(rex); assert(scan)

STATIC void	S_regcppop(pTHX_ regexp *rex, U32 *maxopenparen_p);
#define PERL_ARGS_ASSERT_REGCPPOP	\
	assert(rex); assert(maxopenparen_p)
STATIC CHECKPOINT	S_regcppush(pTHX_ const regexp *rex, I32 parenfloor, U32 maxopenparen);
#define PERL_ARGS_ASSERT_REGCPPUSH	\
	assert(rex)
STATIC U8*	S_reghop3(U8 *s, SSize_t off, const U8 *lim)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_REGHOP3	\
	assert(s); assert(lim)

STATIC U8*	S_reghop4(U8 *s, SSize_t off, const U8 *llim, const U8 *rlim)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_REGHOP4	\
	assert(s); assert(llim); assert(rlim)

STATIC U8*	S_reghopmaybe3(U8 *s, SSize_t off, const U8 *lim)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_REGHOPMAYBE3	\
	assert(s); assert(lim)

STATIC bool	S_reginclass(pTHX_ regexp * const prog, const regnode * const n, const U8 * const p, const U8 * const p_end, bool const utf8_target)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_REGINCLASS	\
	assert(n); assert(p); assert(p_end)

STATIC SSize_t	S_regmatch(pTHX_ regmatch_info *reginfo, char *startpos, regnode *prog)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_REGMATCH	\
	assert(reginfo); assert(startpos); assert(prog)

STATIC I32	S_regrepeat(pTHX_ regexp *prog, char **startposp, const regnode *p, regmatch_info *const reginfo, I32 max, int depth)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_REGREPEAT	\
	assert(prog); assert(startposp); assert(p); assert(reginfo)

STATIC bool	S_regtry(pTHX_ regmatch_info *reginfo, char **startposp)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_REGTRY	\
	assert(reginfo); assert(startposp)

STATIC bool	S_to_byte_substr(pTHX_ regexp * prog);
#define PERL_ARGS_ASSERT_TO_BYTE_SUBSTR	\
	assert(prog)
STATIC void	S_to_utf8_substr(pTHX_ regexp * prog);
#define PERL_ARGS_ASSERT_TO_UTF8_SUBSTR	\
	assert(prog)
#endif
#if defined(PERL_IN_SCOPE_C)
STATIC void	S_save_pushptri32ptr(pTHX_ void *const ptr1, const I32 i, void *const ptr2, const int type);
STATIC SV*	S_save_scalar_at(pTHX_ SV **sptr, const U32 flags);
#define PERL_ARGS_ASSERT_SAVE_SCALAR_AT	\
	assert(sptr)
#endif
#if defined(PERL_IN_SV_C)
STATIC char *	S_F0convert(NV nv, char *const endbuf, STRLEN *const len);
#define PERL_ARGS_ASSERT_F0CONVERT	\
	assert(endbuf); assert(len)
STATIC void	S_anonymise_cv_maybe(pTHX_ GV *gv, CV *cv);
#define PERL_ARGS_ASSERT_ANONYMISE_CV_MAYBE	\
	assert(gv); assert(cv)
STATIC void	S_assert_uft8_cache_coherent(pTHX_ const char *const func, STRLEN from_cache, STRLEN real, SV *const sv);
#define PERL_ARGS_ASSERT_ASSERT_UFT8_CACHE_COHERENT	\
	assert(func); assert(sv)
STATIC bool	S_curse(pTHX_ SV * const sv, const bool check_refcnt);
#define PERL_ARGS_ASSERT_CURSE	\
	assert(sv)
STATIC I32	S_expect_number(pTHX_ char **const pattern)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_EXPECT_NUMBER	\
	assert(pattern)

STATIC I32	S_find_array_subscript(pTHX_ const AV *const av, const SV *const val);
#define PERL_ARGS_ASSERT_FIND_ARRAY_SUBSCRIPT	\
	assert(val)
STATIC SV *	S_find_hash_subscript(pTHX_ const HV *const hv, const SV *const val);
#define PERL_ARGS_ASSERT_FIND_HASH_SUBSCRIPT	\
	assert(val)
STATIC SV*	S_find_uninit_var(pTHX_ const OP *const obase, const SV *const uninit_sv, bool match, const char **desc_p);
#define PERL_ARGS_ASSERT_FIND_UNINIT_VAR	\
	assert(desc_p)
STATIC bool	S_glob_2number(pTHX_ GV* const gv);
#define PERL_ARGS_ASSERT_GLOB_2NUMBER	\
	assert(gv)
STATIC void	S_glob_assign_glob(pTHX_ SV *const dstr, SV *const sstr, const int dtype);
#define PERL_ARGS_ASSERT_GLOB_ASSIGN_GLOB	\
	assert(dstr); assert(sstr)
STATIC SV *	S_more_sv(pTHX);
STATIC void	S_not_a_number(pTHX_ SV *const sv);
#define PERL_ARGS_ASSERT_NOT_A_NUMBER	\
	assert(sv)
STATIC void	S_not_incrementable(pTHX_ SV *const sv);
#define PERL_ARGS_ASSERT_NOT_INCREMENTABLE	\
	assert(sv)
STATIC PTR_TBL_ENT_t *	S_ptr_table_find(PTR_TBL_t *const tbl, const void *const sv)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_PTR_TABLE_FIND	\
	assert(tbl)

STATIC bool	S_sv_2iuv_common(pTHX_ SV *const sv);
#define PERL_ARGS_ASSERT_SV_2IUV_COMMON	\
	assert(sv)
STATIC void	S_sv_add_arena(pTHX_ char *const ptr, const U32 size, const U32 flags);
#define PERL_ARGS_ASSERT_SV_ADD_ARENA	\
	assert(ptr)
STATIC const char *	S_sv_display(pTHX_ SV *const sv, char *tmpbuf, STRLEN tmpbuf_size);
#define PERL_ARGS_ASSERT_SV_DISPLAY	\
	assert(sv); assert(tmpbuf)
STATIC STRLEN	S_sv_pos_b2u_midway(pTHX_ const U8 *const s, const U8 *const target, const U8 *end, STRLEN endu);
#define PERL_ARGS_ASSERT_SV_POS_B2U_MIDWAY	\
	assert(s); assert(target); assert(end)
STATIC STRLEN	S_sv_pos_u2b_cached(pTHX_ SV *const sv, MAGIC **const mgp, const U8 *const start, const U8 *const send, STRLEN uoffset, STRLEN uoffset0, STRLEN boffset0);
#define PERL_ARGS_ASSERT_SV_POS_U2B_CACHED	\
	assert(sv); assert(mgp); assert(start); assert(send)
STATIC STRLEN	S_sv_pos_u2b_forwards(const U8 *const start, const U8 *const send, STRLEN *const uoffset, bool *const at_end);
#define PERL_ARGS_ASSERT_SV_POS_U2B_FORWARDS	\
	assert(start); assert(send); assert(uoffset); assert(at_end)
STATIC STRLEN	S_sv_pos_u2b_midway(const U8 *const start, const U8 *send, STRLEN uoffset, const STRLEN uend);
#define PERL_ARGS_ASSERT_SV_POS_U2B_MIDWAY	\
	assert(start); assert(send)
PERL_STATIC_INLINE void	S_sv_unglob(pTHX_ SV *const sv, U32 flags);
#define PERL_ARGS_ASSERT_SV_UNGLOB	\
	assert(sv)
STATIC char *	S_uiv_2buf(char *const buf, const IV iv, UV uv, const int is_uv, char **const peob)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_UIV_2BUF	\
	assert(buf); assert(peob)

STATIC void	S_utf8_mg_len_cache_update(pTHX_ SV *const sv, MAGIC **const mgp, const STRLEN ulen);
#define PERL_ARGS_ASSERT_UTF8_MG_LEN_CACHE_UPDATE	\
	assert(sv); assert(mgp)
STATIC void	S_utf8_mg_pos_cache_update(pTHX_ SV *const sv, MAGIC **const mgp, const STRLEN byte, const STRLEN utf8, const STRLEN blen);
#define PERL_ARGS_ASSERT_UTF8_MG_POS_CACHE_UPDATE	\
	assert(sv); assert(mgp)
STATIC I32	S_visit(pTHX_ SVFUNC_t f, const U32 flags, const U32 mask);
#define PERL_ARGS_ASSERT_VISIT	\
	assert(f)
#  if defined(USE_ITHREADS)
STATIC SV*	S_sv_dup_common(pTHX_ const SV *const sstr, CLONE_PARAMS *const param)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_SV_DUP_COMMON	\
	assert(sstr); assert(param)

STATIC SV **	S_sv_dup_inc_multiple(pTHX_ SV *const *source, SV **dest, SSize_t items, CLONE_PARAMS *const param);
#define PERL_ARGS_ASSERT_SV_DUP_INC_MULTIPLE	\
	assert(source); assert(dest); assert(param)
STATIC void	S_unreferenced_to_tmp_stack(pTHX_ AV *const unreferenced);
#define PERL_ARGS_ASSERT_UNREFERENCED_TO_TMP_STACK	\
	assert(unreferenced)
#  endif
#endif
#if defined(PERL_IN_SV_C) || defined (PERL_IN_OP_C)
PERL_CALLCONV SV *	Perl_varname(pTHX_ const GV *const gv, const char gvtype, PADOFFSET targ, const SV *const keyname, I32 aindex, int subscript_type)
			__attribute__warn_unused_result__;

#endif
#if defined(PERL_IN_TOKE_C)
STATIC int	S_ao(pTHX_ int toketype);
STATIC void	S_check_uni(pTHX);
STATIC void	S_checkcomma(pTHX_ const char *s, const char *name, const char *what);
#define PERL_ARGS_ASSERT_CHECKCOMMA	\
	assert(s); assert(name); assert(what)
STATIC int	S_deprecate_commaless_var_list(pTHX);
STATIC char *	S_filter_gets(pTHX_ SV *sv, STRLEN append)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_FILTER_GETS	\
	assert(sv)

STATIC HV *	S_find_in_my_stash(pTHX_ const char *pkgname, STRLEN len)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_FIND_IN_MY_STASH	\
	assert(pkgname)

STATIC void	S_force_ident(pTHX_ const char *s, int kind);
#define PERL_ARGS_ASSERT_FORCE_IDENT	\
	assert(s)
STATIC void	S_force_ident_maybe_lex(pTHX_ char pit);
STATIC void	S_force_next(pTHX_ I32 type);
STATIC char*	S_force_strict_version(pTHX_ char *s);
#define PERL_ARGS_ASSERT_FORCE_STRICT_VERSION	\
	assert(s)
STATIC char*	S_force_version(pTHX_ char *s, int guessing);
#define PERL_ARGS_ASSERT_FORCE_VERSION	\
	assert(s)
STATIC char*	S_force_word(pTHX_ char *start, int token, int check_keyword, int allow_pack);
#define PERL_ARGS_ASSERT_FORCE_WORD	\
	assert(start)
PERL_STATIC_INLINE SV*	S_get_and_check_backslash_N_name(pTHX_ const char* s, const char* const e)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_GET_AND_CHECK_BACKSLASH_N_NAME	\
	assert(s); assert(e)

STATIC void	S_incline(pTHX_ const char *s);
#define PERL_ARGS_ASSERT_INCLINE	\
	assert(s)
STATIC int	S_intuit_method(pTHX_ char *s, SV *ioname, CV *cv);
#define PERL_ARGS_ASSERT_INTUIT_METHOD	\
	assert(s)
STATIC int	S_intuit_more(pTHX_ char *s);
#define PERL_ARGS_ASSERT_INTUIT_MORE	\
	assert(s)
STATIC I32	S_lop(pTHX_ I32 f, int x, char *s);
#define PERL_ARGS_ASSERT_LOP	\
	assert(s)
PERL_STATIC_NO_RET void	S_missingterm(pTHX_ char *s)
			__attribute__noreturn__;

STATIC SV*	S_new_constant(pTHX_ const char *s, STRLEN len, const char *key, STRLEN keylen, SV *sv, SV *pv, const char *type, STRLEN typelen);
#define PERL_ARGS_ASSERT_NEW_CONSTANT	\
	assert(key); assert(sv)
STATIC void	S_no_op(pTHX_ const char *const what, char *s);
#define PERL_ARGS_ASSERT_NO_OP	\
	assert(what)
STATIC void	S_parse_ident(pTHX_ char **s, char **d, char * const e, int allow_package, bool is_utf8);
#define PERL_ARGS_ASSERT_PARSE_IDENT	\
	assert(s); assert(d); assert(e)
STATIC int	S_pending_ident(pTHX);
STATIC char*	S_scan_const(pTHX_ char *start)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_SCAN_CONST	\
	assert(start)

STATIC char*	S_scan_formline(pTHX_ char *s)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_SCAN_FORMLINE	\
	assert(s)

STATIC char*	S_scan_heredoc(pTHX_ char *s)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_SCAN_HEREDOC	\
	assert(s)

STATIC char*	S_scan_ident(pTHX_ char *s, char *dest, STRLEN destlen, I32 ck_uni);
#define PERL_ARGS_ASSERT_SCAN_IDENT	\
	assert(s); assert(dest)
STATIC char*	S_scan_inputsymbol(pTHX_ char *start)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_SCAN_INPUTSYMBOL	\
	assert(start)

STATIC char*	S_scan_pat(pTHX_ char *start, I32 type)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_SCAN_PAT	\
	assert(start)

STATIC char*	S_scan_str(pTHX_ char *start, int keep_quoted, int keep_delims, int re_reparse, char **delimp)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_SCAN_STR	\
	assert(start)

STATIC char*	S_scan_subst(pTHX_ char *start)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_SCAN_SUBST	\
	assert(start)

STATIC char*	S_scan_trans(pTHX_ char *start)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_SCAN_TRANS	\
	assert(start)

STATIC char*	S_scan_word(pTHX_ char *s, char *dest, STRLEN destlen, int allow_package, STRLEN *slp);
#define PERL_ARGS_ASSERT_SCAN_WORD	\
	assert(s); assert(dest); assert(slp)
STATIC char*	S_skipspace_flags(pTHX_ char *s, U32 flags)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_SKIPSPACE_FLAGS	\
	assert(s)

STATIC I32	S_sublex_done(pTHX)
			__attribute__warn_unused_result__;

STATIC I32	S_sublex_push(pTHX)
			__attribute__warn_unused_result__;

STATIC I32	S_sublex_start(pTHX)
			__attribute__warn_unused_result__;

STATIC char*	S_swallow_bom(pTHX_ U8 *s)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_SWALLOW_BOM	\
	assert(s)

STATIC char *	S_tokenize_use(pTHX_ int is_use, char *s)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_TOKENIZE_USE	\
	assert(s)

STATIC SV*	S_tokeq(pTHX_ SV *sv);
#define PERL_ARGS_ASSERT_TOKEQ	\
	assert(sv)
STATIC void	S_update_debugger_info(pTHX_ SV *orig_sv, const char *const buf, STRLEN len);
STATIC int	S_yywarn(pTHX_ const char *const s, U32 flags);
#define PERL_ARGS_ASSERT_YYWARN	\
	assert(s)
#endif
#if defined(PERL_IN_UNIVERSAL_C)
STATIC bool	S_isa_lookup(pTHX_ HV *stash, const char * const name, STRLEN len, U32 flags);
#define PERL_ARGS_ASSERT_ISA_LOOKUP	\
	assert(stash); assert(name)
#endif
#if defined(PERL_IN_UTF8_C)
STATIC UV	S__to_utf8_case(pTHX_ const UV uv1, const U8 *p, U8* ustrp, STRLEN *lenp, SV **swashp, const char *normal, const char *special);
#define PERL_ARGS_ASSERT__TO_UTF8_CASE	\
	assert(p); assert(ustrp); assert(swashp); assert(normal)
STATIC UV	S_check_locale_boundary_crossing(pTHX_ const U8* const p, const UV result, U8* const ustrp, STRLEN *lenp)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_CHECK_LOCALE_BOUNDARY_CROSSING	\
	assert(p); assert(ustrp); assert(lenp)

PERL_STATIC_INLINE bool	S_is_utf8_common(pTHX_ const U8 *const p, SV **swash, const char * const swashname, SV* const invlist)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_IS_UTF8_COMMON	\
	assert(p); assert(swash); assert(swashname)

STATIC U8*	S_swash_scan_list_line(pTHX_ U8* l, U8* const lend, UV* min, UV* max, UV* val, const bool wants_value, const U8* const typestr)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_SWASH_SCAN_LIST_LINE	\
	assert(l); assert(lend); assert(min); assert(max); assert(val); assert(typestr)

STATIC SV*	S_swatch_get(pTHX_ SV* swash, UV start, UV span)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_SWATCH_GET	\
	assert(swash)

STATIC U8	S_to_lower_latin1(const U8 c, U8 *p, STRLEN *lenp)
			__attribute__warn_unused_result__;

#endif
#if defined(PERL_IN_UTF8_C) || defined(PERL_IN_PP_C)
PERL_CALLCONV UV	Perl__to_upper_title_latin1(pTHX_ const U8 c, U8 *p, STRLEN *lenp, const char S_or_s);
#define PERL_ARGS_ASSERT__TO_UPPER_TITLE_LATIN1	\
	assert(p); assert(lenp)
#endif
#if defined(PERL_IN_UTF8_C) || defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_REGEXEC_C)
PERL_CALLCONV UV	Perl__to_fold_latin1(pTHX_ const U8 c, U8 *p, STRLEN *lenp, const unsigned int flags);
#define PERL_ARGS_ASSERT__TO_FOLD_LATIN1	\
	assert(p); assert(lenp)
#endif
#if defined(PERL_IN_UTIL_C)
STATIC bool	S_ckwarn_common(pTHX_ U32 w);
STATIC bool	S_invoke_exception_hook(pTHX_ SV *ex, bool warn);
STATIC SV*	S_mess_alloc(pTHX);
STATIC SV *	S_with_queued_errors(pTHX_ SV *ex);
#define PERL_ARGS_ASSERT_WITH_QUEUED_ERRORS	\
	assert(ex)
STATIC void	S_xs_version_bootcheck(pTHX_ U32 items, U32 ax, const char *xs_p, STRLEN xs_len);
#define PERL_ARGS_ASSERT_XS_VERSION_BOOTCHECK	\
	assert(xs_p)
#  if defined(PERL_MEM_LOG) && !defined(PERL_MEM_LOG_NOIMPL)
STATIC void	S_mem_log_common(enum mem_log_type mlt, const UV n, const UV typesize, const char *type_name, const SV *sv, Malloc_t oldalloc, Malloc_t newalloc, const char *filename, const int linenumber, const char *funcname);
#define PERL_ARGS_ASSERT_MEM_LOG_COMMON	\
	assert(type_name); assert(filename); assert(funcname)
#  endif
#endif
#if defined(PERL_MEM_LOG)
PERL_CALLCONV Malloc_t	Perl_mem_log_alloc(const UV nconst, UV typesize, const char *type_name, Malloc_t newalloc, const char *filename, const int linenumber, const char *funcname);
#define PERL_ARGS_ASSERT_MEM_LOG_ALLOC	\
	assert(type_name); assert(filename); assert(funcname)
PERL_CALLCONV Malloc_t	Perl_mem_log_free(Malloc_t oldalloc, const char *filename, const int linenumber, const char *funcname);
#define PERL_ARGS_ASSERT_MEM_LOG_FREE	\
	assert(filename); assert(funcname)
PERL_CALLCONV Malloc_t	Perl_mem_log_realloc(const UV n, const UV typesize, const char *type_name, Malloc_t oldalloc, Malloc_t newalloc, const char *filename, const int linenumber, const char *funcname);
#define PERL_ARGS_ASSERT_MEM_LOG_REALLOC	\
	assert(type_name); assert(filename); assert(funcname)
#endif
#if defined(PERL_OP_PARENT)
PERL_CALLCONV OP*	Perl_op_parent(OP *o);
#define PERL_ARGS_ASSERT_OP_PARENT	\
	assert(o)
#endif
#if defined(PERL_USES_PL_PIDSTATUS) && defined(PERL_IN_UTIL_C)
STATIC void	S_pidgone(pTHX_ Pid_t pid, int status);
#endif
#if defined(UNLINK_ALL_VERSIONS)
PERL_CALLCONV I32	Perl_unlnk(pTHX_ const char* f);
#define PERL_ARGS_ASSERT_UNLNK	\
	assert(f)
#endif
#if defined(USE_C_BACKTRACE)
PERL_CALLCONV bool	Perl_dump_c_backtrace(pTHX_ PerlIO* fp, int max_depth, int skip);
#define PERL_ARGS_ASSERT_DUMP_C_BACKTRACE	\
	assert(fp)
/* PERL_CALLCONV void	free_c_backtrace(pTHX_ Perl_c_backtrace* bt); */
PERL_CALLCONV Perl_c_backtrace*	Perl_get_c_backtrace(pTHX_ int max_depth, int skip);
PERL_CALLCONV SV*	Perl_get_c_backtrace_dump(pTHX_ int max_depth, int skip);
#endif
#if defined(USE_DTRACE)
PERL_CALLCONV void	Perl_dtrace_probe_call(pTHX_ CV *cv, bool is_call);
#define PERL_ARGS_ASSERT_DTRACE_PROBE_CALL	\
	assert(cv)
PERL_CALLCONV void	Perl_dtrace_probe_load(pTHX_ const char *name, bool is_loading);
#define PERL_ARGS_ASSERT_DTRACE_PROBE_LOAD	\
	assert(name)
PERL_CALLCONV void	Perl_dtrace_probe_op(pTHX_ const OP *op);
#define PERL_ARGS_ASSERT_DTRACE_PROBE_OP	\
	assert(op)
PERL_CALLCONV void	Perl_dtrace_probe_phase(pTHX_ enum perl_phase phase);
#endif
#if defined(USE_ITHREADS)
PERL_CALLCONV PADOFFSET	Perl_alloccopstash(pTHX_ HV *hv);
#define PERL_ARGS_ASSERT_ALLOCCOPSTASH	\
	assert(hv)
PERL_CALLCONV void*	Perl_any_dup(pTHX_ void* v, const PerlInterpreter* proto_perl)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_ANY_DUP	\
	assert(proto_perl)

PERL_CALLCONV void	Perl_clone_params_del(CLONE_PARAMS *param);
#define PERL_ARGS_ASSERT_CLONE_PARAMS_DEL	\
	assert(param)
PERL_CALLCONV CLONE_PARAMS *	Perl_clone_params_new(PerlInterpreter *const from, PerlInterpreter *const to)
			__attribute__malloc__
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_CLONE_PARAMS_NEW	\
	assert(from); assert(to)

PERL_CALLCONV PERL_CONTEXT*	Perl_cx_dup(pTHX_ PERL_CONTEXT* cx, I32 ix, I32 max, CLONE_PARAMS* param)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_CX_DUP	\
	assert(param)

PERL_CALLCONV DIR*	Perl_dirp_dup(pTHX_ DIR *const dp, CLONE_PARAMS *const param)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_DIRP_DUP	\
	assert(param)

PERL_CALLCONV PerlIO*	Perl_fp_dup(pTHX_ PerlIO *const fp, const char type, CLONE_PARAMS *const param);
#define PERL_ARGS_ASSERT_FP_DUP	\
	assert(param)
PERL_CALLCONV GP*	Perl_gp_dup(pTHX_ GP *const gp, CLONE_PARAMS *const param)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_GP_DUP	\
	assert(param)

PERL_CALLCONV HE*	Perl_he_dup(pTHX_ const HE* e, bool shared, CLONE_PARAMS* param)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_HE_DUP	\
	assert(param)

PERL_CALLCONV HEK*	Perl_hek_dup(pTHX_ HEK* e, CLONE_PARAMS* param)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_HEK_DUP	\
	assert(param)

PERL_CALLCONV MAGIC*	Perl_mg_dup(pTHX_ MAGIC *mg, CLONE_PARAMS *const param)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_MG_DUP	\
	assert(param)

PERL_CALLCONV struct mro_meta*	Perl_mro_meta_dup(pTHX_ struct mro_meta* smeta, CLONE_PARAMS* param);
#define PERL_ARGS_ASSERT_MRO_META_DUP	\
	assert(smeta); assert(param)
PERL_CALLCONV OP*	Perl_newPADOP(pTHX_ I32 type, I32 flags, SV* sv)
			__attribute__malloc__
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWPADOP	\
	assert(sv)

PERL_CALLCONV PADLIST *	Perl_padlist_dup(pTHX_ PADLIST *srcpad, CLONE_PARAMS *param)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_PADLIST_DUP	\
	assert(srcpad); assert(param)

PERL_CALLCONV PADNAME *	Perl_padname_dup(pTHX_ PADNAME *src, CLONE_PARAMS *param)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_PADNAME_DUP	\
	assert(src); assert(param)

PERL_CALLCONV PADNAMELIST *	Perl_padnamelist_dup(pTHX_ PADNAMELIST *srcpad, CLONE_PARAMS *param)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_PADNAMELIST_DUP	\
	assert(srcpad); assert(param)

PERL_CALLCONV yy_parser*	Perl_parser_dup(pTHX_ const yy_parser *const proto, CLONE_PARAMS *const param);
#define PERL_ARGS_ASSERT_PARSER_DUP	\
	assert(param)
PERL_CALLCONV PerlInterpreter*	perl_clone(PerlInterpreter *proto_perl, UV flags);
#define PERL_ARGS_ASSERT_PERL_CLONE	\
	assert(proto_perl)
PERL_CALLCONV void	Perl_re_dup_guts(pTHX_ const REGEXP *sstr, REGEXP *dstr, CLONE_PARAMS* param);
#define PERL_ARGS_ASSERT_RE_DUP_GUTS	\
	assert(sstr); assert(dstr); assert(param)
PERL_CALLCONV void*	Perl_regdupe_internal(pTHX_ REGEXP * const r, CLONE_PARAMS* param);
#define PERL_ARGS_ASSERT_REGDUPE_INTERNAL	\
	assert(r); assert(param)
PERL_CALLCONV void	Perl_rvpv_dup(pTHX_ SV *const dstr, const SV *const sstr, CLONE_PARAMS *const param);
#define PERL_ARGS_ASSERT_RVPV_DUP	\
	assert(dstr); assert(sstr); assert(param)
PERL_CALLCONV PERL_SI*	Perl_si_dup(pTHX_ PERL_SI* si, CLONE_PARAMS* param)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_SI_DUP	\
	assert(param)

PERL_CALLCONV ANY*	Perl_ss_dup(pTHX_ PerlInterpreter* proto_perl, CLONE_PARAMS* param)
			__attribute__malloc__
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_SS_DUP	\
	assert(proto_perl); assert(param)

PERL_CALLCONV SV*	Perl_sv_dup(pTHX_ const SV *const sstr, CLONE_PARAMS *const param)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_SV_DUP	\
	assert(param)

PERL_CALLCONV SV*	Perl_sv_dup_inc(pTHX_ const SV *const sstr, CLONE_PARAMS *const param)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_SV_DUP_INC	\
	assert(param)

#endif
#if defined(USE_LOCALE)     && (defined(PERL_IN_LOCALE_C) || defined (PERL_EXT_POSIX))
PERL_CALLCONV bool	Perl__is_cur_LC_category_utf8(pTHX_ int category);
#endif
#if defined(USE_LOCALE) && defined(PERL_IN_LOCALE_C)
STATIC char*	S_stdize_locale(pTHX_ char* locs);
#define PERL_ARGS_ASSERT_STDIZE_LOCALE	\
	assert(locs)
#endif
#if defined(USE_LOCALE_COLLATE)
PERL_CALLCONV int	Perl_magic_setcollxfrm(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_SETCOLLXFRM	\
	assert(sv); assert(mg)
PERL_CALLCONV char*	Perl_mem_collxfrm(pTHX_ const char* s, STRLEN len, STRLEN* xlen);
#define PERL_ARGS_ASSERT_MEM_COLLXFRM	\
	assert(s); assert(xlen)
/* PERL_CALLCONV char*	sv_collxfrm(pTHX_ SV *const sv, STRLEN *const nxp); */
PERL_CALLCONV char*	Perl_sv_collxfrm_flags(pTHX_ SV *const sv, STRLEN *const nxp, I32 const flags);
#define PERL_ARGS_ASSERT_SV_COLLXFRM_FLAGS	\
	assert(sv); assert(nxp)
#endif
#if defined(USE_PERLIO)
PERL_CALLCONV void	Perl_PerlIO_clearerr(pTHX_ PerlIO *f);
PERL_CALLCONV int	Perl_PerlIO_close(pTHX_ PerlIO *f);
PERL_CALLCONV int	Perl_PerlIO_eof(pTHX_ PerlIO *f);
PERL_CALLCONV int	Perl_PerlIO_error(pTHX_ PerlIO *f);
PERL_CALLCONV int	Perl_PerlIO_fileno(pTHX_ PerlIO *f);
PERL_CALLCONV int	Perl_PerlIO_fill(pTHX_ PerlIO *f);
PERL_CALLCONV int	Perl_PerlIO_flush(pTHX_ PerlIO *f);
PERL_CALLCONV STDCHAR *	Perl_PerlIO_get_base(pTHX_ PerlIO *f);
PERL_CALLCONV SSize_t	Perl_PerlIO_get_bufsiz(pTHX_ PerlIO *f)
			__attribute__warn_unused_result__;

PERL_CALLCONV SSize_t	Perl_PerlIO_get_cnt(pTHX_ PerlIO *f)
			__attribute__warn_unused_result__;

PERL_CALLCONV STDCHAR *	Perl_PerlIO_get_ptr(pTHX_ PerlIO *f);
PERL_CALLCONV SSize_t	Perl_PerlIO_read(pTHX_ PerlIO *f, void *vbuf, Size_t count);
#define PERL_ARGS_ASSERT_PERLIO_READ	\
	assert(vbuf)
PERL_CALLCONV void	Perl_PerlIO_restore_errno(pTHX_ PerlIO *f);
PERL_CALLCONV void	Perl_PerlIO_save_errno(pTHX_ PerlIO *f);
PERL_CALLCONV int	Perl_PerlIO_seek(pTHX_ PerlIO *f, Off_t offset, int whence);
PERL_CALLCONV void	Perl_PerlIO_set_cnt(pTHX_ PerlIO *f, SSize_t cnt);
PERL_CALLCONV void	Perl_PerlIO_set_ptrcnt(pTHX_ PerlIO *f, STDCHAR *ptr, SSize_t cnt);
PERL_CALLCONV void	Perl_PerlIO_setlinebuf(pTHX_ PerlIO *f);
PERL_CALLCONV PerlIO *	Perl_PerlIO_stderr(pTHX)
			__attribute__warn_unused_result__;

PERL_CALLCONV PerlIO *	Perl_PerlIO_stdin(pTHX)
			__attribute__warn_unused_result__;

PERL_CALLCONV PerlIO *	Perl_PerlIO_stdout(pTHX)
			__attribute__warn_unused_result__;

PERL_CALLCONV Off_t	Perl_PerlIO_tell(pTHX_ PerlIO *f);
PERL_CALLCONV SSize_t	Perl_PerlIO_unread(pTHX_ PerlIO *f, const void *vbuf, Size_t count);
#define PERL_ARGS_ASSERT_PERLIO_UNREAD	\
	assert(vbuf)
PERL_CALLCONV SSize_t	Perl_PerlIO_write(pTHX_ PerlIO *f, const void *vbuf, Size_t count);
#define PERL_ARGS_ASSERT_PERLIO_WRITE	\
	assert(vbuf)
#endif
#if defined(USE_QUADMATH)
PERL_CALLCONV bool	Perl_quadmath_format_needed(const char* format);
#define PERL_ARGS_ASSERT_QUADMATH_FORMAT_NEEDED	\
	assert(format)
PERL_CALLCONV const char*	Perl_quadmath_format_single(const char* format);
#define PERL_ARGS_ASSERT_QUADMATH_FORMAT_SINGLE	\
	assert(format)
#endif
#if defined(WIN32)
PERL_CALLCONV char*	Perl_my_setlocale(pTHX_ int category, const char* locale)
			__attribute__pure__;

PERL_CALLCONV_NO_RET void	win32_croak_not_implemented(const char * fname)
			__attribute__noreturn__;
#define PERL_ARGS_ASSERT_WIN32_CROAK_NOT_IMPLEMENTED	\
	assert(fname)

#endif
#if defined(WIN32) || defined(__SYMBIAN32__) || defined(VMS)
PERL_CALLCONV int	Perl_do_aspawn(pTHX_ SV* really, SV** mark, SV** sp);
#define PERL_ARGS_ASSERT_DO_ASPAWN	\
	assert(mark); assert(sp)
PERL_CALLCONV int	Perl_do_spawn(pTHX_ char* cmd);
#define PERL_ARGS_ASSERT_DO_SPAWN	\
	assert(cmd)
PERL_CALLCONV int	Perl_do_spawn_nowait(pTHX_ char* cmd);
#define PERL_ARGS_ASSERT_DO_SPAWN_NOWAIT	\
	assert(cmd)
#endif
#if defined(_MSC_VER)
PERL_CALLCONV int	Perl_magic_regdatum_set(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_REGDATUM_SET	\
	assert(sv); assert(mg)
#endif
#ifdef PERL_CORE
#  include "pp_proto.h"
#endif
END_EXTERN_C

/* ex: set ro: */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   /* -*- buffer-read-only: t -*-
 *
 *    regcharclass.h
 *
 *    Copyright (C) 2007, 2011 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 * !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
 * This file is built by regen/regcharclass.pl.
 * Any changes made here will be lost!
 * WARNING: These macros are for internal Perl core use only, and may be
 * changed or removed without notice.
 */


#ifndef H_REGCHARCLASS   /* Guard against nested #includes */
#define H_REGCHARCLASS 1

#if 'A' == 65 /* ASCII/Latin1 */
/*
	LNBREAK: Line Break: \R

	"\x0D\x0A"      # CRLF - Network (Windows) line ending
	\p{VertSpace}
*/
/*** GENERATED CODE ***/
#define is_LNBREAK_safe(s,e,is_utf8)                                        \
( ((e)-(s) > 2) ?                                                           \
    ( ( 0x0A <= ((U8*)s)[0] && ((U8*)s)[0] <= 0x0C ) ? 1                    \
    : ( 0x0D == ((U8*)s)[0] ) ?                                             \
	( ( 0x0A == ((U8*)s)[1] ) ? 2 : 1 )                                 \
    : ( is_utf8 ) ?                                                         \
	( ( 0xC2 == ((U8*)s)[0] ) ?                                         \
	    ( ( 0x85 == ((U8*)s)[1] ) ? 2 : 0 )                             \
	: ( ( ( 0xE2 == ((U8*)s)[0] ) && ( 0x80 == ((U8*)s)[1] ) ) && ( ( ((U8*)s)[2] & 0xFE ) == 0xA8 ) ) ? 3 : 0 )\
    : ( 0x85 == ((U8*)s)[0] ) )                                             \
: ((e)-(s) > 1) ?                                                           \
    ( ( 0x0A <= ((U8*)s)[0] && ((U8*)s)[0] <= 0x0C ) ? 1                    \
    : ( 0x0D == ((U8*)s)[0] ) ?                                             \
	( ( 0x0A == ((U8*)s)[1] ) ? 2 : 1 )                                 \
    : ( is_utf8 ) ?                                                         \
	( ( ( 0xC2 == ((U8*)s)[0] ) && ( 0x85 == ((U8*)s)[1] ) ) ? 2 : 0 )  \
    : ( 0x85 == ((U8*)s)[0] ) )                                             \
: ((e)-(s) > 0) ?                                                           \
    ( ( 0x0A <= ((U8*)s)[0] && ((U8*)s)[0] <= 0x0D ) ? 1                    \
    : ( !( is_utf8 ) ) ?                                                    \
	( 0x85 == ((U8*)s)[0] )                                             \
    : 0 )                                                                   \
: 0 )

/*** GENERATED CODE ***/
#define is_LNBREAK_utf8_safe(s,e)                                           \
( ((e)-(s) > 2) ?                                                           \
    ( ( 0x0A <= ((U8*)s)[0] && ((U8*)s)[0] <= 0x0C ) ? 1                    \
    : ( 0x0D == ((U8*)s)[0] ) ?                                             \
	( ( 0x0A == ((U8*)s)[1] ) ? 2 : 1 )                                 \
    : ( 0xC2 == ((U8*)s)[0] ) ?                                             \
	( ( 0x85 == ((U8*)s)[1] ) ? 2 : 0 )                                 \
    : ( ( ( 0xE2 == ((U8*)s)[0] ) && ( 0x80 == ((U8*)s)[1] ) ) && ( ( ((U8*)s)[2] & 0xFE ) == 0xA8 ) ) ? 3 : 0 )\
: ((e)-(s) > 1) ?                                                           \
    ( ( 0x0A <= ((U8*)s)[0] && ((U8*)s)[0] <= 0x0C ) ? 1                    \
    : ( 0x0D == ((U8*)s)[0] ) ?                                             \
	( ( 0x0A == ((U8*)s)[1] ) ? 2 : 1 )                                 \
    : ( ( 0xC2 == ((U8*)s)[0] ) && ( 0x85 == ((U8*)s)[1] ) ) ? 2 : 0 )      \
: ((e)-(s) > 0) ?                                                           \
    ( 0x0A <= ((U8*)s)[0] && ((U8*)s)[0] <= 0x0D )                          \
: 0 )

/*** GENERATED CODE ***/
#define is_LNBREAK_latin1_safe(s,e)                                         \
( ((e)-(s) > 1) ?                                                           \
    ( ( ( 0x0A <= ((U8*)s)[0] && ((U8*)s)[0] <= 0x0C ) || 0x85 == ((U8*)s)[0] ) ? 1\
    : ( 0x0D == ((U8*)s)[0] ) ?                                             \
	( ( 0x0A == ((U8*)s)[1] ) ? 2 : 1 )                                 \
    : 0 )                                                                   \
: ((e)-(s) > 0) ?                                                           \
    ( ( 0x0A <= ((U8*)s)[0] && ((U8*)s)[0] <= 0x0D ) || 0x85 == ((U8*)s)[0] )\
: 0 )

/*
	HORIZWS: Horizontal Whitespace: \h \H

	\p{HorizSpace}
*/
/*** GENERATED CODE ***/
#define is_HORIZWS_high(s)                                                  \
( ( 0xE1 == ((U8*)s)[0] ) ?                                                 \
    ( ( ( 0x9A == ((U8*)s)[1] ) && ( 0x80 == ((U8*)s)[2] ) ) ? 3 : 0 )      \
: ( 0xE2 == ((U8*)s)[0] ) ?                                                 \
    ( ( 0x80 == ((U8*)s)[1] ) ?                                             \
	( ( ( ((U8*)s)[2] <= 0x8A ) || 0xAF == ((U8*)s)[2] ) ? 3 : 0 )      \
    : ( ( 0x81 == ((U8*)s)[1] ) && ( 0x9F == ((U8*)s)[2] ) ) ? 3 : 0 )      \
: ( ( ( 0xE3 == ((U8*)s)[0] ) && ( 0x80 == ((U8*)s)[1] ) ) && ( 0x80 == ((U8*)s)[2] ) ) ? 3 : 0 )

/*** GENERATED CODE ***/
#define is_HORIZWS_cp_high(cp)                                              \
( 0x1680 == cp || ( 0x1680 < cp &&                                          \
( ( 0x2000 <= cp && cp <= 0x200A ) || ( 0x200A < cp &&                      \
( 0x202F == cp || ( 0x202F < cp &&                                          \
( 0x205F == cp || 0x3000 == cp ) ) ) ) ) ) )

/*
	VERTWS: Vertical Whitespace: \v \V

	\p{VertSpace}
*/
/*** GENERATED CODE ***/
#define is_VERTWS_high(s)                                                   \
( ( ( ( 0xE2 == ((U8*)s)[0] ) && ( 0x80 == ((U8*)s)[1] ) ) && ( ( ((U8*)s)[2] & 0xFE ) == 0xA8 ) ) ? 3 : 0 )

/*** GENERATED CODE ***/
#define is_VERTWS_cp_high(cp)                                               \
( 0x2028 == cp || 0x2029 == cp )

/*
	XDIGIT: Hexadecimal digits

	\p{XDigit}
*/
/*** GENERATED CODE ***/
#define is_XDIGIT_high(s)                                                   \
( ( 0xEF == ((U8*)s)[0] ) ?                                                 \
    ( ( 0xBC == ((U8*)s)[1] ) ?                                             \
	( ( ( 0x90 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x99 ) || ( 0xA1 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0xA6 ) ) ? 3 : 0 )\
    : ( ( 0xBD == ((U8*)s)[1] ) && ( 0x81 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x86 ) ) ? 3 : 0 )\
: 0 )

/*** GENERATED CODE ***/
#define is_XDIGIT_cp_high(cp)                                               \
( ( 0xFF10 <= cp && cp <= 0xFF19 ) || ( 0xFF19 < cp &&                      \
( ( 0xFF21 <= cp && cp <= 0xFF26 ) || ( 0xFF41 <= cp && cp <= 0xFF46 ) ) ) )

/*
	XPERLSPACE: \p{XPerlSpace}

	\p{XPerlSpace}
*/
/*** GENERATED CODE ***/
#define is_XPERLSPACE_high(s)                                               \
( ( 0xE1 == ((U8*)s)[0] ) ?                                                 \
    ( ( ( 0x9A == ((U8*)s)[1] ) && ( 0x80 == ((U8*)s)[2] ) ) ? 3 : 0 )      \
: ( 0xE2 == ((U8*)s)[0] ) ?                                                 \
    ( ( 0x80 == ((U8*)s)[1] ) ?                                             \
	( ( ( ((U8*)s)[2] <= 0x8A ) || ( ((U8*)s)[2] & 0xFE ) == 0xA8 || 0xAF == ((U8*)s)[2] ) ? 3 : 0 )\
    : ( ( 0x81 == ((U8*)s)[1] ) && ( 0x9F == ((U8*)s)[2] ) ) ? 3 : 0 )      \
: ( ( ( 0xE3 == ((U8*)s)[0] ) && ( 0x80 == ((U8*)s)[1] ) ) && ( 0x80 == ((U8*)s)[2] ) ) ? 3 : 0 )

/*** GENERATED CODE ***/
#define is_XPERLSPACE_cp_high(cp)                                           \
( 0x1680 == cp || ( 0x1680 < cp &&                                          \
( ( 0x2000 <= cp && cp <= 0x200A ) || ( 0x200A < cp &&                      \
( 0x2028 == cp || ( 0x2028 < cp &&                                          \
( 0x2029 == cp || ( 0x2029 < cp &&                                          \
( 0x202F == cp || ( 0x202F < cp &&                                          \
( 0x205F == cp || 0x3000 == cp ) ) ) ) ) ) ) ) ) ) )

/*
	REPLACEMENT: Unicode REPLACEMENT CHARACTER

	0xFFFD
*/
/*** GENERATED CODE ***/
#define is_REPLACEMENT_utf8_safe(s,e)                                       \
( ( ( ( ( ((e) - (s)) >= 3 ) && ( 0xEF == ((U8*)s)[0] ) ) && ( 0xBF == ((U8*)s)[1] ) ) && ( 0xBD == ((U8*)s)[2] ) ) ? 3 : 0 )

/*
	NONCHAR: Non character code points

	\p{_Perl_Nchar}
*/
/*** GENERATED CODE ***/
#define is_NONCHAR_utf8(s)                                                  \
( ( 0xEF == ((U8*)s)[0] ) ?                                                 \
    ( ( 0xB7 == ((U8*)s)[1] ) ?                                             \
	( ( 0x90 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0xAF ) ? 3 : 0 )          \
    : ( ( 0xBF == ((U8*)s)[1] ) && ( ((U8*)s)[2] >= 0xBE ) ) ? 3 : 0 )      \
: ( 0xF0 == ((U8*)s)[0] ) ?                                                 \
    ( ( ( ( ((U8*)s)[1] == 0x9F || ( ( ((U8*)s)[1] & 0xEF ) == 0xAF ) ) && ( 0xBF == ((U8*)s)[2] ) ) && ( ((U8*)s)[3] >= 0xBE ) ) ? 4 : 0 )\
: ( 0xF1 <= ((U8*)s)[0] && ((U8*)s)[0] <= 0xF3 ) ?                          \
    ( ( ( ( ( ((U8*)s)[1] & 0xCF ) == 0x8F ) && ( 0xBF == ((U8*)s)[2] ) ) && ( ((U8*)s)[3] >= 0xBE ) ) ? 4 : 0 )\
: ( ( ( ( 0xF4 == ((U8*)s)[0] ) && ( 0x8F == ((U8*)s)[1] ) ) && ( 0xBF == ((U8*)s)[2] ) ) && ( ((U8*)s)[3] >= 0xBE ) ) ? 4 : 0 )

/*
	SURROGATE: Surrogate characters

	\p{_Perl_Surrogate}
*/
/*** GENERATED CODE ***/
#define is_SURROGATE_utf8(s)                                                \
( ( ( 0xED == ((U8*)s)[0] ) && ( ((U8*)s)[1] >= 0xA0 ) ) ? 3 : 0 )

/*
	QUOTEMETA: Meta-characters that \Q should quote

	\p{_Perl_Quotemeta}
*/
/*** GENERATED CODE ***/
#define is_QUOTEMETA_high(s)                                                \
( ( 0xCD == ((U8*)s)[0] ) ?                                                 \
    ( ( 0x8F == ((U8*)s)[1] ) ? 2 : 0 )                                     \
: ( 0xD8 == ((U8*)s)[0] ) ?                                                 \
    ( ( 0x9C == ((U8*)s)[1] ) ? 2 : 0 )                                     \
: ( 0xE1 == ((U8*)s)[0] ) ?                                                 \
    ( ( 0x85 == ((U8*)s)[1] ) ?                                             \
	( ( 0x9F == ((U8*)s)[2] || 0xA0 == ((U8*)s)[2] ) ? 3 : 0 )          \
    : ( 0x9A == ((U8*)s)[1] ) ?                                             \
	( ( 0x80 == ((U8*)s)[2] ) ? 3 : 0 )                                 \
    : ( 0x9E == ((U8*)s)[1] ) ?                                             \
	( ( ( ((U8*)s)[2] & 0xFE ) == 0xB4 ) ? 3 : 0 )                      \
    : ( ( 0xA0 == ((U8*)s)[1] ) && ( 0x8B <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x8E ) ) ? 3 : 0 )\
: ( 0xE2 == ((U8*)s)[0] ) ?                                                 \
    ( ( 0x80 == ((U8*)s)[1] ) ?                                             \
	( ( ((U8*)s)[2] <= 0xBE ) ? 3 : 0 )                                 \
    : ( 0x81 == ((U8*)s)[1] ) ?                                             \
	( ( ( 0x81 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x93 ) || ( 0x95 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0xAF ) ) ? 3 : 0 )\
    : ( 0x86 == ((U8*)s)[1] ) ?                                             \
	( ( ((U8*)s)[2] >= 0x90 ) ? 3 : 0 )                                 \
    : ( ( 0x87 <= ((U8*)s)[1] && ((U8*)s)[1] <= 0x90 ) || ( 0x94 <= ((U8*)s)[1] && ((U8*)s)[1] <= 0x9C ) || ( 0x9F <= ((U8*)s)[1] && ((U8*)s)[1] <= 0xAF ) || ( ((U8*)s)[1] & 0xFE ) == 0xB8 ) ?\
	3                                                                   \
    : ( 0x91 == ((U8*)s)[1] ) ?                                             \
	( ( ((U8*)s)[2] <= 0x9F ) ? 3 : 0 )                                 \
    : ( 0x9D == ((U8*)s)[1] ) ?                                             \
	( ( ((U8*)s)[2] <= 0xB5 ) ? 3 : 0 )                                 \
    : ( ( 0x9E == ((U8*)s)[1] ) && ( ((U8*)s)[2] >= 0x94 ) ) ? 3 : 0 )      \
: ( 0xE3 == ((U8*)s)[0] ) ?                                                 \
    ( ( 0x80 == ((U8*)s)[1] ) ?                                             \
	( ( ( ((U8*)s)[2] <= 0x83 ) || ( 0x88 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0xA0 ) || 0xB0 == ((U8*)s)[2] ) ? 3 : 0 )\
    : ( ( 0x85 == ((U8*)s)[1] ) && ( 0xA4 == ((U8*)s)[2] ) ) ? 3 : 0 )      \
: ( 0xEF == ((U8*)s)[0] ) ?                                                 \
    ( ( 0xB4 == ((U8*)s)[1] ) ?                                             \
	( ( ((U8*)s)[2] >= 0xBE ) ? 3 : 0 )                                 \
    : ( 0xB8 == ((U8*)s)[1] ) ?                                             \
	( ( ((U8*)s)[2] <= 0x8F ) ? 3 : 0 )                                 \
    : ( 0xB9 == ((U8*)s)[1] ) ?                                             \
	( ( 0x85 == ((U8*)s)[2] || 0x86 == ((U8*)s)[2] ) ? 3 : 0 )          \
    : ( 0xBB == ((U8*)s)[1] ) ?                                             \
	( ( 0xBF == ((U8*)s)[2] ) ? 3 : 0 )                                 \
    : ( 0xBE == ((U8*)s)[1] ) ?                                             \
	( ( 0xA0 == ((U8*)s)[2] ) ? 3 : 0 )                                 \
    : ( ( 0xBF == ((U8*)s)[1] ) && ( 0xB0 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0xB8 ) ) ? 3 : 0 )\
: ( 0xF0 == ((U8*)s)[0] ) ?                                                 \
    ( ( 0x9B == ((U8*)s)[1] ) ?                                             \
	( ( ( 0xB2 == ((U8*)s)[2] ) && ( ( ((U8*)s)[3] & 0xFC ) == 0xA0 ) ) ? 4 : 0 )\
    : ( ( ( 0x9D == ((U8*)s)[1] ) && ( 0x85 == ((U8*)s)[2] ) ) && ( 0xB3 <= ((U8*)s)[3] && ((U8*)s)[3] <= 0xBA ) ) ? 4 : 0 )\
: ( ( 0xF3 == ((U8*)s)[0] ) && ( 0xA0 == ((U8*)s)[1] ) ) ? 4 : 0 )

/*
	MULTI_CHAR_FOLD: multi-char strings that are folded to by a single character

	&regcharclass_multi_char_folds::multi_char_folds(1)
*/
/*** GENERATED CODE ***/
#define is_MULTI_CHAR_FOLD_utf8_safe_part0(s,e)                             \
( ( 0x61 == ((U8*)s)[0] ) ?                                                 \
	( ( ( 0xCA == ((U8*)s)[1] ) && ( 0xBE == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0x66 == ((U8*)s)[0] ) ?                                             \
	( ( 0x66 == ((U8*)s)[1] ) ?                                         \
	    ( ( 0x69 == ((U8*)s)[2] || 0x6C == ((U8*)s)[2] ) ? 3 : 2 )      \
	: ( 0x69 == ((U8*)s)[1] || 0x6C == ((U8*)s)[1] ) ? 2 : 0 )          \
    : ( 0x68 == ((U8*)s)[0] ) ?                                             \
	( ( ( 0xCC == ((U8*)s)[1] ) && ( 0xB1 == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0x69 == ((U8*)s)[0] ) ?                                             \
	( ( ( 0xCC == ((U8*)s)[1] ) && ( 0x87 == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0x6A == ((U8*)s)[0] ) ?                                             \
	( ( ( 0xCC == ((U8*)s)[1] ) && ( 0x8C == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0x73 == ((U8*)s)[0] ) ?                                             \
	( ( 0x73 == ((U8*)s)[1] || 0x74 == ((U8*)s)[1] ) ? 2 : 0 )          \
    : ( 0x74 == ((U8*)s)[0] ) ?                                             \
	( ( ( 0xCC == ((U8*)s)[1] ) && ( 0x88 == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0x77 == ((U8*)s)[0] || 0x79 == ((U8*)s)[0] ) ?                      \
	( ( ( 0xCC == ((U8*)s)[1] ) && ( 0x8A == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0xC5 == ((U8*)s)[0] ) ?                                             \
	( ( ( ( 0xBF == ((U8*)s)[1] ) && ( 0xC5 == ((U8*)s)[2] ) ) && ( 0xBF == ((U8*)s)[3] ) ) ? 4 : 0 )\
    : ( 0xCA == ((U8*)s)[0] ) ?                                             \
	( ( ( 0xBC == ((U8*)s)[1] ) && ( 0x6E == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0xCE == ((U8*)s)[0] ) ?                                             \
	( ( ( ((U8*)s)[1] & 0xFD ) == 0xAC ) ?                              \
	    ( ( ( 0xCE == ((U8*)s)[2] ) && ( 0xB9 == ((U8*)s)[3] ) ) ? 4 : 0 )\
	: ( 0xB1 == ((U8*)s)[1] || 0xB7 == ((U8*)s)[1] ) ?                  \
	    ( ( 0xCD == ((U8*)s)[2] ) ?                                     \
		( ( 0x82 == ((U8*)s)[3] ) ? 4 : 0 )                         \
	    : ( ( 0xCE == ((U8*)s)[2] ) && ( 0xB9 == ((U8*)s)[3] ) ) ? 4 : 0 )\
	: ( ( ( 0xB9 == ((U8*)s)[1] ) && ( 0xCD == ((U8*)s)[2] ) ) && ( 0x82 == ((U8*)s)[3] ) ) ? 4 : 0 )\
    : ( 0xCF == ((U8*)s)[0] ) ?                                             \
	( ( 0x81 == ((U8*)s)[1] ) ?                                         \
	    ( ( ( 0xCC == ((U8*)s)[2] ) && ( 0x93 == ((U8*)s)[3] ) ) ? 4 : 0 )\
	: ( 0x85 == ((U8*)s)[1] ) ?                                         \
	    ( ( 0xCC == ((U8*)s)[2] ) ?                                     \
		( ( 0x93 == ((U8*)s)[3] ) ? 4 : 0 )                         \
	    : ( ( 0xCD == ((U8*)s)[2] ) && ( 0x82 == ((U8*)s)[3] ) ) ? 4 : 0 )\
	: ( 0x89 == ((U8*)s)[1] ) ?                                         \
	    ( ( 0xCD == ((U8*)s)[2] ) ?                                     \
		( ( 0x82 == ((U8*)s)[3] ) ? 4 : 0 )                         \
	    : ( ( 0xCE == ((U8*)s)[2] ) && ( 0xB9 == ((U8*)s)[3] ) ) ? 4 : 0 )\
	: ( ( ( 0x8E == ((U8*)s)[1] ) && ( 0xCE == ((U8*)s)[2] ) ) && ( 0xB9 == ((U8*)s)[3] ) ) ? 4 : 0 )\
    : ( 0xD5 == ((U8*)s)[0] ) ?                                             \
	( ( 0xA5 == ((U8*)s)[1] ) ?                                         \
	    ( ( ( 0xD6 == ((U8*)s)[2] ) && ( 0x82 == ((U8*)s)[3] ) ) ? 4 : 0 )\
	: ( 0xB4 == ((U8*)s)[1] ) ?                                         \
	    ( ( ( 0xD5 == ((U8*)s)[2] ) && ( ( ( ((U8*)s)[3] & 0xF7 ) == 0xA5 ) || ((U8*)s)[3] == 0xAB || ((U8*)s)[3] == 0xB6 ) ) ? 4 : 0 )\
	: ( ( ( 0xBE == ((U8*)s)[1] ) && ( 0xD5 == ((U8*)s)[2] ) ) && ( 0xB6 == ((U8*)s)[3] ) ) ? 4 : 0 )\
    : ( 0xE1 == ((U8*)s)[0] ) ?                                             \
	( ( 0xBC == ((U8*)s)[1] ) ?                                         \
	    ( ( ( ( ( ((U8*)s)[2] & 0xD8 ) == 0x80 ) && ( 0xCE == ((U8*)s)[3] ) ) && ( 0xB9 == ((U8*)s)[4] ) ) ? 5 : 0 )\
	: ( ( ( ( 0xBD == ((U8*)s)[1] ) && ( ( ( ((U8*)s)[2] & 0xF8 ) == 0xA0 ) || ( ( ((U8*)s)[2] & 0xFB ) == 0xB0 ) || ((U8*)s)[2] == 0xBC ) ) && ( 0xCE == ((U8*)s)[3] ) ) && ( 0xB9 == ((U8*)s)[4] ) ) ? 5 : 0 )\
    : 0 )


/*** GENERATED CODE ***/
#define is_MULTI_CHAR_FOLD_utf8_safe_part1(s,e)                             \
( ((e)-(s) > 3) ?                                                           \
    ( ( 0x61 == ((U8*)s)[0] ) ?                                             \
	( ( ( 0xCA == ((U8*)s)[1] ) && ( 0xBE == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0x66 == ((U8*)s)[0] ) ?                                             \
	( ( 0x66 == ((U8*)s)[1] ) ?                                         \
	    ( ( 0x69 == ((U8*)s)[2] || 0x6C == ((U8*)s)[2] ) ? 3 : 2 )      \
	: ( 0x69 == ((U8*)s)[1] || 0x6C == ((U8*)s)[1] ) ? 2 : 0 )          \
    : ( 0x68 == ((U8*)s)[0] ) ?                                             \
	( ( ( 0xCC == ((U8*)s)[1] ) && ( 0xB1 == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0x69 == ((U8*)s)[0] ) ?                                             \
	( ( ( 0xCC == ((U8*)s)[1] ) && ( 0x87 == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0x6A == ((U8*)s)[0] ) ?                                             \
	( ( ( 0xCC == ((U8*)s)[1] ) && ( 0x8C == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0x73 == ((U8*)s)[0] ) ?                                             \
	( ( 0x73 == ((U8*)s)[1] || 0x74 == ((U8*)s)[1] ) ? 2 : 0 )          \
    : ( 0x74 == ((U8*)s)[0] ) ?                                             \
	( ( ( 0xCC == ((U8*)s)[1] ) && ( 0x88 == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0x77 == ((U8*)s)[0] || 0x79 == ((U8*)s)[0] ) ?                      \
	( ( ( 0xCC == ((U8*)s)[1] ) && ( 0x8A == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0xC5 == ((U8*)s)[0] ) ?                                             \
	( ( ( ( 0xBF == ((U8*)s)[1] ) && ( 0xC5 == ((U8*)s)[2] ) ) && ( 0xBF == ((U8*)s)[3] ) ) ? 4 : 0 )\
    : ( 0xCA == ((U8*)s)[0] ) ?                                             \
	( ( ( 0xBC == ((U8*)s)[1] ) && ( 0x6E == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0xCE == ((U8*)s)[0] ) ?                                             \
	( ( ( ((U8*)s)[1] & 0xFD ) == 0xAC ) ?                              \
	    ( ( ( 0xCE == ((U8*)s)[2] ) && ( 0xB9 == ((U8*)s)[3] ) ) ? 4 : 0 )\
	: ( 0xB1 == ((U8*)s)[1] || 0xB7 == ((U8*)s)[1] ) ?                  \
	    ( ( 0xCD == ((U8*)s)[2] ) ?                                     \
		( ( 0x82 == ((U8*)s)[3] ) ? 4 : 0 )                         \
	    : ( ( 0xCE == ((U8*)s)[2] ) && ( 0xB9 == ((U8*)s)[3] ) ) ? 4 : 0 )\
	: ( ( ( 0xB9 == ((U8*)s)[1] ) && ( 0xCD == ((U8*)s)[2] ) ) && ( 0x82 == ((U8*)s)[3] ) ) ? 4 : 0 )\
    : ( 0xCF == ((U8*)s)[0] ) ?                                             \
	( ( 0x81 == ((U8*)s)[1] ) ?                                         \
	    ( ( ( 0xCC == ((U8*)s)[2] ) && ( 0x93 == ((U8*)s)[3] ) ) ? 4 : 0 )\
	: ( 0x85 == ((U8*)s)[1] ) ?                                         \
	    ( ( 0xCC == ((U8*)s)[2] ) ?                                     \
		( ( 0x93 == ((U8*)s)[3] ) ? 4 : 0 )                         \
	    : ( ( 0xCD == ((U8*)s)[2] ) && ( 0x82 == ((U8*)s)[3] ) ) ? 4 : 0 )\
	: ( 0x89 == ((U8*)s)[1] ) ?                                         \
	    ( ( 0xCD == ((U8*)s)[2] ) ?                                     \
		( ( 0x82 == ((U8*)s)[3] ) ? 4 : 0 )                         \
	    : ( ( 0xCE == ((U8*)s)[2] ) && ( 0xB9 == ((U8*)s)[3] ) ) ? 4 : 0 )\
	: ( ( ( 0x8E == ((U8*)s)[1] ) && ( 0xCE == ((U8*)s)[2] ) ) && ( 0xB9 == ((U8*)s)[3] ) ) ? 4 : 0 )\
    : ( 0xD5 == ((U8*)s)[0] ) ?                                             \
	( ( 0xA5 == ((U8*)s)[1] ) ?                                         \
	    ( ( ( 0xD6 == ((U8*)s)[2] ) && ( 0x82 == ((U8*)s)[3] ) ) ? 4 : 0 )\
	: ( 0xB4 == ((U8*)s)[1] ) ?                                         \
	    ( ( ( 0xD5 == ((U8*)s)[2] ) && ( ( ( ((U8*)s)[3] & 0xF7 ) == 0xA5 ) || ((U8*)s)[3] == 0xAB || ((U8*)s)[3] == 0xB6 ) ) ? 4 : 0 )\
	: ( ( ( 0xBE == ((U8*)s)[1] ) && ( 0xD5 == ((U8*)s)[2] ) ) && ( 0xB6 == ((U8*)s)[3] ) ) ? 4 : 0 )\
    : 0 )                                                                   \
: ((e)-(s) > 2) ?                                                           \
    ( ( 0x61 == ((U8*)s)[0] ) ?                                             \
	( ( ( 0xCA == ((U8*)s)[1] ) && ( 0xBE == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0x66 == ((U8*)s)[0] ) ?                                             \
	( ( 0x66 == ((U8*)s)[1] ) ?                                         \
	    ( ( 0x69 == ((U8*)s)[2] || 0x6C == ((U8*)s)[2] ) ? 3 : 2 )      \
	: ( 0x69 == ((U8*)s)[1] || 0x6C == ((U8*)s)[1] ) ? 2 : 0 )          \
    : ( 0x68 == ((U8*)s)[0] ) ?                                             \
	( ( ( 0xCC == ((U8*)s)[1] ) && ( 0xB1 == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0x69 == ((U8*)s)[0] ) ?                                             \
	( ( ( 0xCC == ((U8*)s)[1] ) && ( 0x87 == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0x6A == ((U8*)s)[0] ) ?                                             \
	( ( ( 0xCC == ((U8*)s)[1] ) && ( 0x8C == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0x73 == ((U8*)s)[0] ) ?                                             \
	( ( 0x73 == ((U8*)s)[1] || 0x74 == ((U8*)s)[1] ) ? 2 : 0 )          \
    : ( 0x74 == ((U8*)s)[0] ) ?                                             \
	( ( ( 0xCC == ((U8*)s)[1] ) && ( 0x88 == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0x77 == ((U8*)s)[0] || 0x79 == ((U8*)s)[0] ) ?                      \
	( ( ( 0xCC == ((U8*)s)[1] ) && ( 0x8A == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( ( ( 0xCA == ((U8*)s)[0] ) && ( 0xBC == ((U8*)s)[1] ) ) && ( 0x6E == ((U8*)s)[2] ) ) ? 3 : 0 )\
: ((e)-(s) > 1) ?                                                           \
    ( ( 0x66 == ((U8*)s)[0] ) ?                                             \
	( ( 0x66 == ((U8*)s)[1] || 0x69 == ((U8*)s)[1] || 0x6C == ((U8*)s)[1] ) ? 2 : 0 )\
    : ( ( 0x73 == ((U8*)s)[0] ) && ( 0x73 == ((U8*)s)[1] || 0x74 == ((U8*)s)[1] ) ) ? 2 : 0 )\
: 0 )


/*** GENERATED CODE ***/
#define is_MULTI_CHAR_FOLD_utf8_safe(s,e)                                   \
( ((e)-(s) > 5) ?                                                           \
    ( ( 0x61 == ((U8*)s)[0] ) ?                                             \
	( ( ( 0xCA == ((U8*)s)[1] ) && ( 0xBE == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0x66 == ((U8*)s)[0] ) ?                                             \
	( ( 0x66 == ((U8*)s)[1] ) ?                                         \
	    ( ( 0x69 == ((U8*)s)[2] || 0x6C == ((U8*)s)[2] ) ? 3 : 2 )      \
	: ( 0x69 == ((U8*)s)[1] || 0x6C == ((U8*)s)[1] ) ? 2 : 0 )          \
    : ( 0x68 == ((U8*)s)[0] ) ?                                             \
	( ( ( 0xCC == ((U8*)s)[1] ) && ( 0xB1 == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0x69 == ((U8*)s)[0] ) ?                                             \
	( ( ( 0xCC == ((U8*)s)[1] ) && ( 0x87 == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0x6A == ((U8*)s)[0] ) ?                                             \
	( ( ( 0xCC == ((U8*)s)[1] ) && ( 0x8C == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0x73 == ((U8*)s)[0] ) ?                                             \
	( ( 0x73 == ((U8*)s)[1] || 0x74 == ((U8*)s)[1] ) ? 2 : 0 )          \
    : ( 0x74 == ((U8*)s)[0] ) ?                                             \
	( ( ( 0xCC == ((U8*)s)[1] ) && ( 0x88 == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0x77 == ((U8*)s)[0] || 0x79 == ((U8*)s)[0] ) ?                      \
	( ( ( 0xCC == ((U8*)s)[1] ) && ( 0x8A == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0xC5 == ((U8*)s)[0] ) ?                                             \
	( ( ( ( 0xBF == ((U8*)s)[1] ) && ( 0xC5 == ((U8*)s)[2] ) ) && ( 0xBF == ((U8*)s)[3] ) ) ? 4 : 0 )\
    : ( 0xCA == ((U8*)s)[0] ) ?                                             \
	( ( ( 0xBC == ((U8*)s)[1] ) && ( 0x6E == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0xCE == ((U8*)s)[0] ) ?                                             \
	( ( ( ((U8*)s)[1] & 0xFD ) == 0xAC ) ?                              \
	    ( ( ( 0xCE == ((U8*)s)[2] ) && ( 0xB9 == ((U8*)s)[3] ) ) ? 4 : 0 )\
	: ( 0xB1 == ((U8*)s)[1] || 0xB7 == ((U8*)s)[1] ) ?                  \
	    ( ( 0xCD == ((U8*)s)[2] ) ?                                     \
		( ( 0x82 == ((U8*)s)[3] ) ?                                 \
		    ( ( ( 0xCE == ((U8*)s)[4] ) && ( 0xB9 == ((U8*)s)[5] ) ) ? 6 : 4 )\
		: 0 )                                                       \
	    : ( ( 0xCE == ((U8*)s)[2] ) && ( 0xB9 == ((U8*)s)[3] ) ) ? 4 : 0 )\
	: ( 0xB9 == ((U8*)s)[1] ) ?                                         \
	    ( ( 0xCC == ((U8*)s)[2] ) ?                                     \
		( ( 0x88 == ((U8*)s)[3] ) ?                                 \
		    ( ( 0xCC == ((U8*)s)[4] ) ?                             \
			( ( ( ((U8*)s)[5] & 0xFE ) == 0x80 ) ? 6 : 0 )      \
		    : ( ( 0xCD == ((U8*)s)[4] ) && ( 0x82 == ((U8*)s)[5] ) ) ? 6 : 0 )\
		: 0 )                                                       \
	    : ( ( 0xCD == ((U8*)s)[2] ) && ( 0x82 == ((U8*)s)[3] ) ) ? 4 : 0 )\
	: 0 )                                                               \
    : ( 0xCF == ((U8*)s)[0] ) ?                                             \
	( ( 0x81 == ((U8*)s)[1] ) ?                                         \
	    ( ( ( 0xCC == ((U8*)s)[2] ) && ( 0x93 == ((U8*)s)[3] ) ) ? 4 : 0 )\
	: ( 0x85 == ((U8*)s)[1] ) ?                                         \
	    ( ( 0xCC == ((U8*)s)[2] ) ?                                     \
		( ( 0x88 == ((U8*)s)[3] ) ?                                 \
		    ( ( 0xCC == ((U8*)s)[4] ) ?                             \
			( ( ( ((U8*)s)[5] & 0xFE ) == 0x80 ) ? 6 : 0 )      \
		    : ( ( 0xCD == ((U8*)s)[4] ) && ( 0x82 == ((U8*)s)[5] ) ) ? 6 : 0 )\
		: ( 0x93 == ((U8*)s)[3] ) ?                                 \
		    ( ( 0xCC == ((U8*)s)[4] ) ?                             \
			( ( ( ((U8*)s)[5] & 0xFE ) == 0x80 ) ? 6 : 4 )      \
		    : ( ( 0xCD == ((U8*)s)[4] ) && ( 0x82 == ((U8*)s)[5] ) ) ? 6 : 4 )\
		: 0 )                                                       \
	    : ( ( 0xCD == ((U8*)s)[2] ) && ( 0x82 == ((U8*)s)[3] ) ) ? 4 : 0 )\
	: ( 0x89 == ((U8*)s)[1] ) ?                                         \
	    ( ( 0xCD == ((U8*)s)[2] ) ?                                     \
		( ( 0x82 == ((U8*)s)[3] ) ?                                 \
		    ( ( ( 0xCE == ((U8*)s)[4] ) && ( 0xB9 == ((U8*)s)[5] ) ) ? 6 : 4 )\
		: 0 )                                                       \
	    : ( ( 0xCE == ((U8*)s)[2] ) && ( 0xB9 == ((U8*)s)[3] ) ) ? 4 : 0 )\
	: ( ( ( 0x8E == ((U8*)s)[1] ) && ( 0xCE == ((U8*)s)[2] ) ) && ( 0xB9 == ((U8*)s)[3] ) ) ? 4 : 0 )\
    : ( 0xD5 == ((U8*)s)[0] ) ?                                             \
	( ( 0xA5 == ((U8*)s)[1] ) ?                                         \
	    ( ( ( 0xD6 == ((U8*)s)[2] ) && ( 0x82 == ((U8*)s)[3] ) ) ? 4 : 0 )\
	: ( 0xB4 == ((U8*)s)[1] ) ?                                         \
	    ( ( ( 0xD5 == ((U8*)s)[2] ) && ( ( ( ((U8*)s)[3] & 0xF7 ) == 0xA5 ) || ((U8*)s)[3] == 0xAB || ((U8*)s)[3] == 0xB6 ) ) ? 4 : 0 )\
	: ( ( ( 0xBE == ((U8*)s)[1] ) && ( 0xD5 == ((U8*)s)[2] ) ) && ( 0xB6 == ((U8*)s)[3] ) ) ? 4 : 0 )\
    : ( 0xE1 == ((U8*)s)[0] ) ?                                             \
	( ( 0xBC == ((U8*)s)[1] ) ?                                         \
	    ( ( ( ( ( ((U8*)s)[2] & 0xD8 ) == 0x80 ) && ( 0xCE == ((U8*)s)[3] ) ) && ( 0xB9 == ((U8*)s)[4] ) ) ? 5 : 0 )\
	: ( ( ( ( 0xBD == ((U8*)s)[1] ) && ( ( ( ((U8*)s)[2] & 0xF8 ) == 0xA0 ) || ( ( ((U8*)s)[2] & 0xFB ) == 0xB0 ) || ((U8*)s)[2] == 0xBC ) ) && ( 0xCE == ((U8*)s)[3] ) ) && ( 0xB9 == ((U8*)s)[4] ) ) ? 5 : 0 )\
    : 0 )                                                                   \
: ((e)-(s) > 4) ? is_MULTI_CHAR_FOLD_utf8_safe_part0(s,e) : is_MULTI_CHAR_FOLD_utf8_safe_part1(s,e) )

/*
	MULTI_CHAR_FOLD: multi-char strings that are folded to by a single character

	&regcharclass_multi_char_folds::multi_char_folds(0)
*/
/*** GENERATED CODE ***/
#define is_MULTI_CHAR_FOLD_latin1_safe(s,e)                                 \
( ((e)-(s) > 2) ?                                                           \
    ( ( ( ((U8*)s)[0] & 0xDF ) == 0x46 ) ?                                  \
	( ( ( ((U8*)s)[1] & 0xDF ) == 0x46 ) ?                              \
	    ( ( ( ( ((U8*)s)[2] & 0xDF ) == 0x49 ) || ( ( ((U8*)s)[2] & 0xDF ) == 0x4C ) ) ? 3 : 2 )\
	: ( ( ( ((U8*)s)[1] & 0xDF ) == 0x49 ) || ( ( ((U8*)s)[1] & 0xDF ) == 0x4C ) ) ? 2 : 0 )\
    : ( ( ( ((U8*)s)[0] & 0xDF ) == 0x53 ) && ( ( ( ((U8*)s)[1] & 0xDF ) == 0x53 ) || ( ( ((U8*)s)[1] & 0xDF ) == 0x54 ) ) ) ? 2 : 0 )\
: ((e)-(s) > 1) ?                                                           \
    ( ( ( ((U8*)s)[0] & 0xDF ) == 0x46 ) ?                                  \
	( ( ( ( ((U8*)s)[1] & 0xDF ) == 0x46 ) || ( ( ((U8*)s)[1] & 0xDF ) == 0x49 ) || ( ( ((U8*)s)[1] & 0xDF ) == 0x4C ) ) ? 2 : 0 )\
    : ( ( ( ((U8*)s)[0] & 0xDF ) == 0x53 ) && ( ( ( ((U8*)s)[1] & 0xDF ) == 0x53 ) || ( ( ((U8*)s)[1] & 0xDF ) == 0x54 ) ) ) ? 2 : 0 )\
: 0 )

/*
	FOLDS_TO_MULTI: characters that fold to multi-char strings

	\p{_Perl_Folds_To_Multi_Char}
*/
/*** GENERATED CODE ***/
#define is_FOLDS_TO_MULTI_utf8(s)                                           \
( ( 0xC3 == ((U8*)s)[0] ) ?                                                 \
    ( ( 0x9F == ((U8*)s)[1] ) ? 2 : 0 )                                     \
: ( 0xC4 == ((U8*)s)[0] || 0xC7 == ((U8*)s)[0] ) ?                          \
    ( ( 0xB0 == ((U8*)s)[1] ) ? 2 : 0 )                                     \
: ( 0xC5 == ((U8*)s)[0] ) ?                                                 \
    ( ( 0x89 == ((U8*)s)[1] ) ? 2 : 0 )                                     \
: ( 0xCE == ((U8*)s)[0] ) ?                                                 \
    ( ( ( ((U8*)s)[1] & 0xDF ) == 0x90 ) ? 2 : 0 )                          \
: ( 0xD6 == ((U8*)s)[0] ) ?                                                 \
    ( ( 0x87 == ((U8*)s)[1] ) ? 2 : 0 )                                     \
: ( 0xE1 == ((U8*)s)[0] ) ?                                                 \
    ( ( 0xBA == ((U8*)s)[1] ) ?                                             \
	( ( ( 0x96 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x9A ) || 0x9E == ((U8*)s)[2] ) ? 3 : 0 )\
    : ( 0xBD == ((U8*)s)[1] ) ?                                             \
	( ( ( ((U8*)s)[2] & 0xF9 ) == 0x90 ) ? 3 : 0 )                      \
    : ( 0xBE == ((U8*)s)[1] ) ?                                             \
	( ( ( ( ((U8*)s)[2] & 0xE0 ) == 0x80 ) || ( ( ((U8*)s)[2] & 0xF0 ) == 0xA0 ) || ( ( ((U8*)s)[2] & 0xFA ) == 0xB2 ) || ( ( ((U8*)s)[2] & 0xF7 ) == 0xB4 ) ) ? 3 : 0 )\
    : ( ( 0xBF == ((U8*)s)[1] ) && ( ( ( ((U8*)s)[2] & 0xCA ) == 0x82 ) || ( ( ((U8*)s)[2] & 0xF7 ) == 0x84 ) || ((U8*)s)[2] == 0xA4 || ( ( ((U8*)s)[2] & 0xF7 ) == 0xB4 ) ) ) ? 3 : 0 )\
: ( ( ( 0xEF == ((U8*)s)[0] ) && ( 0xAC == ((U8*)s)[1] ) ) && ( ( ((U8*)s)[2] <= 0x86 ) || ( 0x93 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x97 ) ) ) ? 3 : 0 )

/*
	PROBLEMATIC_LOCALE_FOLD: characters whose fold is problematic under locale

	\p{_Perl_Problematic_Locale_Folds}
*/
/*** GENERATED CODE ***/
#define is_PROBLEMATIC_LOCALE_FOLD_utf8(s)                                  \
( ( ((U8*)s)[0] <= 0x7F ) ? 1                                               \
: ( ( ((U8*)s)[0] & 0xFE ) == 0xC2 ) ?                                      \
    2                                                                       \
: ( 0xC4 == ((U8*)s)[0] || 0xC7 == ((U8*)s)[0] ) ?                          \
    ( ( 0xB0 == ((U8*)s)[1] ) ? 2 : 0 )                                     \
: ( 0xC5 == ((U8*)s)[0] ) ?                                                 \
    ( ( 0x89 == ((U8*)s)[1] || 0xB8 == ((U8*)s)[1] || 0xBF == ((U8*)s)[1] ) ? 2 : 0 )\
: ( 0xCE == ((U8*)s)[0] ) ?                                                 \
    ( ( ( ((U8*)s)[1] & 0xDF ) == 0x9C ) ? 2 : 0 )                          \
: ( 0xE1 == ((U8*)s)[0] ) ?                                                 \
    ( ( ( 0xBA == ((U8*)s)[1] ) && ( ( 0x96 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x9A ) || 0x9E == ((U8*)s)[2] ) ) ? 3 : 0 )\
: ( 0xE2 == ((U8*)s)[0] ) ?                                                 \
    ( ( ( 0x84 == ((U8*)s)[1] ) && ( ( ((U8*)s)[2] & 0xFE ) == 0xAA ) ) ? 3 : 0 )\
: ( ( ( 0xEF == ((U8*)s)[0] ) && ( 0xAC == ((U8*)s)[1] ) ) && ( ((U8*)s)[2] <= 0x86 ) ) ? 3 : 0 )

/*** GENERATED CODE ***/
#define is_PROBLEMATIC_LOCALE_FOLD_cp(cp)                                   \
( cp <= 0xFF || ( 0xFF < cp &&                                              \
( 0x130 == cp || ( 0x130 < cp &&                                            \
( 0x149 == cp || ( 0x149 < cp &&                                            \
( 0x178 == cp || ( 0x178 < cp &&                                            \
( 0x17F == cp || ( 0x17F < cp &&                                            \
( 0x1F0 == cp || ( 0x1F0 < cp &&                                            \
( 0x39C == cp || ( 0x39C < cp &&                                            \
( 0x3BC == cp || ( 0x3BC < cp &&                                            \
( ( 0x1E96 <= cp && cp <= 0x1E9A ) || ( 0x1E9A < cp &&                      \
( 0x1E9E == cp || ( 0x1E9E < cp &&                                          \
( 0x212A == cp || ( 0x212A < cp &&                                          \
( 0x212B == cp || ( 0xFB00 <= cp && cp <= 0xFB06 ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )

/*
	PROBLEMATIC_LOCALE_FOLDEDS_START: The first folded character of folds which are problematic under locale

	\p{_Perl_Problematic_Locale_Foldeds_Start}
*/
/*** GENERATED CODE ***/
#define is_PROBLEMATIC_LOCALE_FOLDEDS_START_utf8(s)                         \
( ( ((U8*)s)[0] <= 0x7F ) ? 1                                               \
: ( ( ((U8*)s)[0] & 0xFE ) == 0xC2 ) ?                                      \
    2                                                                       \
: ( 0xC4 == ((U8*)s)[0] || 0xC7 == ((U8*)s)[0] ) ?                          \
    ( ( 0xB0 == ((U8*)s)[1] ) ? 2 : 0 )                                     \
: ( 0xC5 == ((U8*)s)[0] ) ?                                                 \
    ( ( 0x89 == ((U8*)s)[1] || 0xB8 == ((U8*)s)[1] || 0xBF == ((U8*)s)[1] ) ? 2 : 0 )\
: ( 0xCA == ((U8*)s)[0] ) ?                                                 \
    ( ( 0xBC == ((U8*)s)[1] ) ? 2 : 0 )                                     \
: ( 0xCE == ((U8*)s)[0] ) ?                                                 \
    ( ( ( ((U8*)s)[1] & 0xDF ) == 0x9C ) ? 2 : 0 )                          \
: ( 0xE1 == ((U8*)s)[0] ) ?                                                 \
    ( ( ( 0xBA == ((U8*)s)[1] ) && ( ( 0x96 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x9A ) || 0x9E == ((U8*)s)[2] ) ) ? 3 : 0 )\
: ( 0xE2 == ((U8*)s)[0] ) ?                                                 \
    ( ( ( 0x84 == ((U8*)s)[1] ) && ( ( ((U8*)s)[2] & 0xFE ) == 0xAA ) ) ? 3 : 0 )\
: ( ( ( 0xEF == ((U8*)s)[0] ) && ( 0xAC == ((U8*)s)[1] ) ) && ( ((U8*)s)[2] <= 0x86 ) ) ? 3 : 0 )

/*** GENERATED CODE ***/
#define is_PROBLEMATIC_LOCALE_FOLDEDS_START_cp(cp)                          \
( cp <= 0xFF || ( 0xFF < cp &&                                              \
( 0x130 == cp || ( 0x130 < cp &&                                            \
( 0x149 == cp || ( 0x149 < cp &&                                            \
( 0x178 == cp || ( 0x178 < cp &&                                            \
( 0x17F == cp || ( 0x17F < cp &&                                            \
( 0x1F0 == cp || ( 0x1F0 < cp &&                                            \
( 0x2BC == cp || ( 0x2BC < cp &&                                            \
( 0x39C == cp || ( 0x39C < cp &&                                            \
( 0x3BC == cp || ( 0x3BC < cp &&                                            \
( ( 0x1E96 <= cp && cp <= 0x1E9A ) || ( 0x1E9A < cp &&                      \
( 0x1E9E == cp || ( 0x1E9E < cp &&                                          \
( 0x212A == cp || ( 0x212A < cp &&                                          \
( 0x212B == cp || ( 0xFB00 <= cp && cp <= 0xFB06 ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )

/*
	PATWS: pattern white space

	\p{_Perl_PatWS}
*/
/*** GENERATED CODE ***/
#define is_PATWS_safe(s,e,is_utf8)                                          \
( ( LIKELY((e) > (s)) ) ?                                                   \
    ( ( ( 0x09 <= ((U8*)s)[0] && ((U8*)s)[0] <= 0x0D ) || 0x20 == ((U8*)s)[0] ) ? 1\
    : (! is_utf8 ) ?                                                        \
	    ( 0x85 == ((U8*)s)[0] )                                         \
	: ( LIKELY(((e) - (s)) >= UTF8SKIP(s)) ) ?                          \
	    ( ( 0xC2 == ((U8*)s)[0] ) ?                                     \
		( ( 0x85 == ((U8*)s)[1] ) ? 2 : 0 )                         \
	    : ( ( ( 0xE2 == ((U8*)s)[0] ) && ( 0x80 == ((U8*)s)[1] ) ) && ( ( ((U8*)s)[2] & 0xFE ) == 0x8E || ( ((U8*)s)[2] & 0xFE ) == 0xA8 ) ) ? 3 : 0 )\
	: 0 )                                                               \
: 0 )

/*** GENERATED CODE ***/
#define is_PATWS_cp(cp)                                                     \
( ( 0x09 <= cp && cp <= 0x0D ) || ( 0x0D < cp &&                            \
( 0x20 == cp || ( 0x20 < cp &&                                              \
( 0x85 == cp || ( 0x85 < cp &&                                              \
( 0x200E == cp || ( 0x200E < cp &&                                          \
( 0x200F == cp || ( 0x200F < cp &&                                          \
( 0x2028 == cp || 0x2029 == cp ) ) ) ) ) ) ) ) ) ) )

#endif	/* ASCII/Latin1 */

#if 'A' == 193 /* EBCDIC 1047 */ \
     && '\\' == 224 && '[' == 173 && ']' == 189 && '{' == 192 && '}' == 208 \
     && '^' == 95 && '~' == 161 && '!' == 90 && '#' == 123 && '|' == 79 \
     && '$' == 91 && '@' == 124 && '`' == 121
/*
	LNBREAK: Line Break: \R

	"\x0D\x0A"      # CRLF - Network (Windows) line ending
	\p{VertSpace}
*/
/*** GENERATED CODE ***/
#define is_LNBREAK_safe(s,e,is_utf8)                                        \
( ((e)-(s) > 2) ?                                                           \
    ( ( ( 0x0B == ((U8*)s)[0] || 0x0C == ((U8*)s)[0] ) || 0x15 == ((U8*)s)[0] || 0x25 == ((U8*)s)[0] ) ? 1\
    : ( 0x0D == ((U8*)s)[0] ) ?                                             \
	( ( 0x15 == ((U8*)s)[1] ) ? 2 : 1 )                                 \
    : ( ( ( ( is_utf8 ) && ( 0xCA == ((U8*)s)[0] ) ) && ( 0x42 == ((U8*)s)[1] ) ) && ( 0x49 == ((U8*)s)[2] || 0x4A == ((U8*)s)[2] ) ) ? 3 : 0 )\
: ((e)-(s) > 1) ?                                                           \
    ( ( ( 0x0B == ((U8*)s)[0] || 0x0C == ((U8*)s)[0] ) || 0x15 == ((U8*)s)[0] || 0x25 == ((U8*)s)[0] ) ? 1\
    : ( 0x0D == ((U8*)s)[0] ) ?                                             \
	( ( 0x15 == ((U8*)s)[1] ) ? 2 : 1 )                                 \
    : 0 )                                                                   \
: ((e)-(s) > 0) ?                                                           \
    ( ( 0x0B <= ((U8*)s)[0] && ((U8*)s)[0] <= 0x0D ) || 0x15 == ((U8*)s)[0] || 0x25 == ((U8*)s)[0] )\
: 0 )

/*** GENERATED CODE ***/
#define is_LNBREAK_utf8_safe(s,e)                                           \
( ((e)-(s) > 2) ?                                                           \
    ( ( ( 0x0B == ((U8*)s)[0] || 0x0C == ((U8*)s)[0] ) || 0x15 == ((U8*)s)[0] || 0x25 == ((U8*)s)[0] ) ? 1\
    : ( 0x0D == ((U8*)s)[0] ) ?                                             \
	( ( 0x15 == ((U8*)s)[1] ) ? 2 : 1 )                                 \
    : ( ( ( 0xCA == ((U8*)s)[0] ) && ( 0x42 == ((U8*)s)[1] ) ) && ( 0x49 == ((U8*)s)[2] || 0x4A == ((U8*)s)[2] ) ) ? 3 : 0 )\
: ((e)-(s) > 1) ?                                                           \
    ( ( ( 0x0B == ((U8*)s)[0] || 0x0C == ((U8*)s)[0] ) || 0x15 == ((U8*)s)[0] || 0x25 == ((U8*)s)[0] ) ? 1\
    : ( 0x0D == ((U8*)s)[0] ) ?                                             \
	( ( 0x15 == ((U8*)s)[1] ) ? 2 : 1 )                                 \
    : 0 )                                                                   \
: ((e)-(s) > 0) ?                                                           \
    ( ( 0x0B <= ((U8*)s)[0] && ((U8*)s)[0] <= 0x0D ) || 0x15 == ((U8*)s)[0] || 0x25 == ((U8*)s)[0] )\
: 0 )

/*** GENERATED CODE ***/
#define is_LNBREAK_latin1_safe(s,e)                                         \
( ((e)-(s) > 1) ?                                                           \
    ( ( ( 0x0B == ((U8*)s)[0] || 0x0C == ((U8*)s)[0] ) || 0x15 == ((U8*)s)[0] || 0x25 == ((U8*)s)[0] ) ? 1\
    : ( 0x0D == ((U8*)s)[0] ) ?                                             \
	( ( 0x15 == ((U8*)s)[1] ) ? 2 : 1 )                                 \
    : 0 )                                                                   \
: ((e)-(s) > 0) ?                                                           \
    ( ( 0x0B <= ((U8*)s)[0] && ((U8*)s)[0] <= 0x0D ) || 0x15 == ((U8*)s)[0] || 0x25 == ((U8*)s)[0] )\
: 0 )

/*
	HORIZWS: Horizontal Whitespace: \h \H

	\p{HorizSpace}
*/
/*** GENERATED CODE ***/
#define is_HORIZWS_high(s)                                                  \
( ( 0xBC == ((U8*)s)[0] ) ?                                                 \
    ( ( ( 0x63 == ((U8*)s)[1] ) && ( 0x41 == ((U8*)s)[2] ) ) ? 3 : 0 )      \
: ( 0xCA == ((U8*)s)[0] ) ?                                                 \
    ( ( 0x41 == ((U8*)s)[1] ) ?                                             \
	( ( ( 0x41 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x4A ) || 0x51 == ((U8*)s)[2] ) ? 3 : 0 )\
    : ( 0x42 == ((U8*)s)[1] ) ?                                             \
	( ( 0x56 == ((U8*)s)[2] ) ? 3 : 0 )                                 \
    : ( ( 0x43 == ((U8*)s)[1] ) && ( 0x73 == ((U8*)s)[2] ) ) ? 3 : 0 )      \
: ( ( ( 0xCE == ((U8*)s)[0] ) && ( 0x41 == ((U8*)s)[1] ) ) && ( 0x41 == ((U8*)s)[2] ) ) ? 3 : 0 )

/*** GENERATED CODE ***/
#define is_HORIZWS_cp_high(cp)                                              \
( 0x1680 == cp || ( 0x1680 < cp &&                                          \
( ( 0x2000 <= cp && cp <= 0x200A ) || ( 0x200A < cp &&                      \
( 0x202F == cp || ( 0x202F < cp &&                                          \
( 0x205F == cp || 0x3000 == cp ) ) ) ) ) ) )

/*
	VERTWS: Vertical Whitespace: \v \V

	\p{VertSpace}
*/
/*** GENERATED CODE ***/
#define is_VERTWS_high(s)                                                   \
( ( ( ( 0xCA == ((U8*)s)[0] ) && ( 0x42 == ((U8*)s)[1] ) ) && ( 0x49 == ((U8*)s)[2] || 0x4A == ((U8*)s)[2] ) ) ? 3 : 0 )

/*** GENERATED CODE ***/
#define is_VERTWS_cp_high(cp)                                               \
( 0x2028 == cp || 0x2029 == cp )

/*
	XDIGIT: Hexadecimal digits

	\p{XDigit}
*/
/*** GENERATED CODE ***/
#define is_XDIGIT_high(s)                                                   \
( ( ( 0xDD == ((U8*)s)[0] ) && ( 0x73 == ((U8*)s)[1] ) ) ? ( ( 0x67 == ((U8*)s)[2] ) ?\
	    ( ( ( 0x57 <= ((U8*)s)[3] && ((U8*)s)[3] <= 0x59 ) || ( 0x62 <= ((U8*)s)[3] && ((U8*)s)[3] <= 0x68 ) ) ? 4 : 0 )\
	: ( ( ( ((U8*)s)[2] & 0xFE ) == 0x68 ) && ( 0x42 <= ((U8*)s)[3] && ((U8*)s)[3] <= 0x47 ) ) ? 4 : 0 ) : 0 )

/*** GENERATED CODE ***/
#define is_XDIGIT_cp_high(cp)                                               \
( ( 0xFF10 <= cp && cp <= 0xFF19 ) || ( 0xFF19 < cp &&                      \
( ( 0xFF21 <= cp && cp <= 0xFF26 ) || ( 0xFF41 <= cp && cp <= 0xFF46 ) ) ) )

/*
	XPERLSPACE: \p{XPerlSpace}

	\p{XPerlSpace}
*/
/*** GENERATED CODE ***/
#define is_XPERLSPACE_high(s)                                               \
( ( 0xBC == ((U8*)s)[0] ) ?                                                 \
    ( ( ( 0x63 == ((U8*)s)[1] ) && ( 0x41 == ((U8*)s)[2] ) ) ? 3 : 0 )      \
: ( 0xCA == ((U8*)s)[0] ) ?                                                 \
    ( ( 0x41 == ((U8*)s)[1] ) ?                                             \
	( ( ( 0x41 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x4A ) || 0x51 == ((U8*)s)[2] ) ? 3 : 0 )\
    : ( 0x42 == ((U8*)s)[1] ) ?                                             \
	( ( ( 0x49 == ((U8*)s)[2] || 0x4A == ((U8*)s)[2] ) || 0x56 == ((U8*)s)[2] ) ? 3 : 0 )\
    : ( ( 0x43 == ((U8*)s)[1] ) && ( 0x73 == ((U8*)s)[2] ) ) ? 3 : 0 )      \
: ( ( ( 0xCE == ((U8*)s)[0] ) && ( 0x41 == ((U8*)s)[1] ) ) && ( 0x41 == ((U8*)s)[2] ) ) ? 3 : 0 )

/*** GENERATED CODE ***/
#define is_XPERLSPACE_cp_high(cp)                                           \
( 0x1680 == cp || ( 0x1680 < cp &&                                          \
( ( 0x2000 <= cp && cp <= 0x200A ) || ( 0x200A < cp &&                      \
( 0x2028 == cp || ( 0x2028 < cp &&                                          \
( 0x2029 == cp || ( 0x2029 < cp &&                                          \
( 0x202F == cp || ( 0x202F < cp &&                                          \
( 0x205F == cp || 0x3000 == cp ) ) ) ) ) ) ) ) ) ) )

/*
	REPLACEMENT: Unicode REPLACEMENT CHARACTER

	0xFFFD
*/
/*** GENERATED CODE ***/
#define is_REPLACEMENT_utf8_safe(s,e)                                       \
( ( ( ( ( ( ((e) - (s)) >= 4 ) && ( 0xDD == ((U8*)s)[0] ) ) && ( 0x73 == ((U8*)s)[1] ) ) && ( 0x73 == ((U8*)s)[2] ) ) && ( 0x71 == ((U8*)s)[3] ) ) ? 4 : 0 )

/*
	NONCHAR: Non character code points

	\p{_Perl_Nchar}
*/
/*** GENERATED CODE ***/
#define is_NONCHAR_utf8(s)                                                  \
( ( 0xDD == ((U8*)s)[0] ) ?                                                 \
    ( ( 0x73 == ((U8*)s)[1] ) ?                                             \
	( ( 0x55 == ((U8*)s)[2] ) ?                                         \
	    ( ( ( 0x57 <= ((U8*)s)[3] && ((U8*)s)[3] <= 0x59 ) || ( 0x62 <= ((U8*)s)[3] && ((U8*)s)[3] <= 0x6A ) || ( ((U8*)s)[3] & 0xFC ) == 0x70 ) ? 4 : 0 )\
	: ( 0x56 == ((U8*)s)[2] ) ?                                         \
	    ( ( ( 0x41 <= ((U8*)s)[3] && ((U8*)s)[3] <= 0x4A ) || ( 0x51 <= ((U8*)s)[3] && ((U8*)s)[3] <= 0x56 ) ) ? 4 : 0 )\
	: ( ( 0x73 == ((U8*)s)[2] ) && ( ( ((U8*)s)[3] & 0xFE ) == 0x72 ) ) ? 4 : 0 )\
    : 0 )                                                                   \
: ( 0xDF == ((U8*)s)[0] || 0xEA == ((U8*)s)[0] || 0xEC == ((U8*)s)[0] ) ?   \
    ( ( ( ( 0x73 == ((U8*)s)[1] ) && ( 0x73 == ((U8*)s)[2] ) ) && ( ( ((U8*)s)[3] & 0xFE ) == 0x72 ) ) ? 4 : 0 )\
: ( 0xED == ((U8*)s)[0] ) ?                                                 \
    ( ( ( ( ( ((U8*)s)[1] == 0x4A || ((U8*)s)[1] == 0x52 || ( ( ((U8*)s)[1] & 0xFD ) == 0x54 ) || ((U8*)s)[1] == 0x58 || ((U8*)s)[1] == 0x62 || ( ( ((U8*)s)[1] & 0xFD ) == 0x64 ) || ( ( ((U8*)s)[1] & 0xFD ) == 0x68 ) || ( ( ((U8*)s)[1] & 0xFD ) == 0x71 ) ) && ( 0x73 == ((U8*)s)[2] ) ) && ( 0x73 == ((U8*)s)[3] ) ) && ( ( ((U8*)s)[4] & 0xFE ) == 0x72 ) ) ? 5 : 0 )\
: ( ( ( ( ( 0xEE == ((U8*)s)[0] ) && ( 0x42 == ((U8*)s)[1] ) ) && ( 0x73 == ((U8*)s)[2] ) ) && ( 0x73 == ((U8*)s)[3] ) ) && ( ( ((U8*)s)[4] & 0xFE ) == 0x72 ) ) ? 5 : 0 )

/*
	SURROGATE: Surrogate characters

	\p{_Perl_Surrogate}
*/
/*** GENERATED CODE ***/
#define is_SURROGATE_utf8(s)                                                \
( ( ( ( ( 0xDD == ((U8*)s)[0] ) && ( 0x65 == ((U8*)s)[1] || 0x66 == ((U8*)s)[1] ) ) && ( ( 0x41 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x4A ) || ( 0x51 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x59 ) || ( 0x62 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x6A ) || ( ((U8*)s)[2] & 0xFC ) == 0x70 ) ) && ( ( 0x41 <= ((U8*)s)[3] && ((U8*)s)[3] <= 0x4A ) || ( 0x51 <= ((U8*)s)[3] && ((U8*)s)[3] <= 0x59 ) || ( 0x62 <= ((U8*)s)[3] && ((U8*)s)[3] <= 0x6A ) || ( ((U8*)s)[3] & 0xFC ) == 0x70 ) ) ? 4 : 0 )

/*
	UTF8_CHAR: Matches legal UTF-EBCDIC encoded characters from 2 through 3 bytes

	0xA0 - 0x3FFF
*/
/*** GENERATED CODE ***/
#define is_UTF8_CHAR_utf8_no_length_checks(s)                               \
( ( 0x80 == ((U8*)s)[0] || ( 0x8A <= ((U8*)s)[0] && ((U8*)s)[0] <= 0x90 ) || ( 0x9A <= ((U8*)s)[0] && ((U8*)s)[0] <= 0xA0 ) || ( 0xAA <= ((U8*)s)[0] && ((U8*)s)[0] <= 0xAC ) || ( 0xAE <= ((U8*)s)[0] && ((U8*)s)[0] <= 0xB6 ) ) ?\
    ( ( ( 0x41 <= ((U8*)s)[1] && ((U8*)s)[1] <= 0x4A ) || ( 0x51 <= ((U8*)s)[1] && ((U8*)s)[1] <= 0x59 ) || ( 0x62 <= ((U8*)s)[1] && ((U8*)s)[1] <= 0x6A ) || ( ((U8*)s)[1] & 0xFC ) == 0x70 ) ? 2 : 0 )\
: ( ( ( ( ( ((U8*)s)[0] & 0xFC ) == 0xB8 ) || ((U8*)s)[0] == 0xBC || ( ( ((U8*)s)[0] & 0xFE ) == 0xBE ) || ( ( ((U8*)s)[0] & 0xEE ) == 0xCA ) || ( ( ((U8*)s)[0] & 0xFC ) == 0xCC ) ) && ( ( 0x41 <= ((U8*)s)[1] && ((U8*)s)[1] <= 0x4A ) || ( 0x51 <= ((U8*)s)[1] && ((U8*)s)[1] <= 0x59 ) || ( 0x62 <= ((U8*)s)[1] && ((U8*)s)[1] <= 0x6A ) || ( ((U8*)s)[1] & 0xFC ) == 0x70 ) ) && ( ( 0x41 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x4A ) || ( 0x51 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x59 ) || ( 0x62 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x6A ) || ( ((U8*)s)[2] & 0xFC ) == 0x70 ) ) ? 3 : 0 )

/*
	QUOTEMETA: Meta-characters that \Q should quote

	\p{_Perl_Quotemeta}
*/
/*** GENERATED CODE ***/
#define is_QUOTEMETA_high(s)                                                \
( ( 0xB1 == ((U8*)s)[0] ) ?                                                 \
    ( ( 0x56 == ((U8*)s)[1] ) ? 2 : 0 )                                     \
: ( 0xB8 == ((U8*)s)[0] ) ?                                                 \
    ( ( ( 0x57 == ((U8*)s)[1] ) && ( 0x70 == ((U8*)s)[2] ) ) ? 3 : 0 )      \
: ( 0xBB == ((U8*)s)[0] ) ?                                                 \
    ( ( 0x51 == ((U8*)s)[1] ) ?                                             \
	( ( 0x73 == ((U8*)s)[2] ) ? 3 : 0 )                                 \
    : ( ( 0x52 == ((U8*)s)[1] ) && ( 0x41 == ((U8*)s)[2] ) ) ? 3 : 0 )      \
: ( 0xBC == ((U8*)s)[0] ) ?                                                 \
    ( ( 0x63 == ((U8*)s)[1] ) ?                                             \
	( ( 0x41 == ((U8*)s)[2] ) ? 3 : 0 )                                 \
    : ( ( 0x71 == ((U8*)s)[1] ) && ( 0x63 == ((U8*)s)[2] || 0x64 == ((U8*)s)[2] ) ) ? 3 : 0 )\
: ( 0xBE == ((U8*)s)[0] ) ?                                                 \
    ( ( ( 0x41 == ((U8*)s)[1] ) && ( 0x52 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x55 ) ) ? 3 : 0 )\
: ( 0xCA == ((U8*)s)[0] ) ?                                                 \
    ( ( 0x41 == ((U8*)s)[1] || ( 0x54 <= ((U8*)s)[1] && ((U8*)s)[1] <= 0x59 ) || ( 0x62 <= ((U8*)s)[1] && ((U8*)s)[1] <= 0x6A ) || ( ((U8*)s)[1] & 0xFC ) == 0x70 ) ?\
	( ( ( 0x41 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x4A ) || ( 0x51 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x59 ) || ( 0x62 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x6A ) || ( ((U8*)s)[2] & 0xFC ) == 0x70 ) ? 3 : 0 )\
    : ( 0x42 == ((U8*)s)[1] ) ?                                             \
	( ( ( 0x41 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x4A ) || ( 0x51 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x59 ) || ( 0x62 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x6A ) || ( 0x70 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x72 ) ) ? 3 : 0 )\
    : ( 0x43 == ((U8*)s)[1] ) ?                                             \
	( ( ( 0x42 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x4A ) || ( 0x51 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x59 ) || 0x62 == ((U8*)s)[2] || ( 0x64 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x6A ) || ( ((U8*)s)[2] & 0xFC ) == 0x70 ) ? 3 : 0 )\
    : ( 0x44 == ((U8*)s)[1] ) ?                                             \
	( ( ( 0x41 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x4A ) || ( 0x51 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x56 ) ) ? 3 : 0 )\
    : ( ( 0x53 == ((U8*)s)[1] ) && ( ( 0x57 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x59 ) || ( 0x62 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x6A ) || ( ((U8*)s)[2] & 0xFC ) == 0x70 ) ) ? 3 : 0 )\
: ( 0xCB == ((U8*)s)[0] ) ?                                                 \
    ( ( ( ( ((U8*)s)[1] & 0xE7 ) == 0x41 ) || ( ( ((U8*)s)[1] & 0xCE ) == 0x42 ) || ((U8*)s)[1] == 0x4A || ( ( ((U8*)s)[1] & 0xFC ) == 0x54 ) || ((U8*)s)[1] == 0x58 || ( ( ((U8*)s)[1] & 0xFC ) == 0x64 ) || ( ( ((U8*)s)[1] & 0xFE ) == 0x68 ) || ((U8*)s)[1] == 0x71 ) ?\
	( ( ( 0x41 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x4A ) || ( 0x51 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x59 ) || ( 0x62 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x6A ) || ( ((U8*)s)[2] & 0xFC ) == 0x70 ) ? 3 : 0 )\
    : ( 0x6A == ((U8*)s)[1] ) ?                                             \
	( ( ( 0x41 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x4A ) || ( 0x51 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x59 ) || ( 0x62 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x64 ) ) ? 3 : 0 )\
    : ( ( 0x70 == ((U8*)s)[1] ) && ( ( 0x63 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x6A ) || ( ((U8*)s)[2] & 0xFC ) == 0x70 ) ) ? 3 : 0 )\
: ( 0xCC == ((U8*)s)[0] ) ?                                                 \
    ( ( ( ( 0x41 <= ((U8*)s)[1] && ((U8*)s)[1] <= 0x4A ) || ( 0x51 <= ((U8*)s)[1] && ((U8*)s)[1] <= 0x59 ) || ( 0x62 <= ((U8*)s)[1] && ((U8*)s)[1] <= 0x6A ) || ( ((U8*)s)[1] & 0xFC ) == 0x70 ) && ( ( 0x41 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x4A ) || ( 0x51 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x59 ) || ( 0x62 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x6A ) || ( ((U8*)s)[2] & 0xFC ) == 0x70 ) ) ? 3 : 0 )\
: ( 0xCD == ((U8*)s)[0] ) ?                                                 \
    ( ( ( ( 0x57 <= ((U8*)s)[1] && ((U8*)s)[1] <= 0x59 ) || 0x62 == ((U8*)s)[1] ) && ( ( 0x41 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x4A ) || ( 0x51 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x59 ) || ( 0x62 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x6A ) || ( ((U8*)s)[2] & 0xFC ) == 0x70 ) ) ? 3 : 0 )\
: ( 0xCE == ((U8*)s)[0] ) ?                                                 \
    ( ( 0x41 == ((U8*)s)[1] ) ?                                             \
	( ( ( 0x41 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x44 ) || ( 0x49 == ((U8*)s)[2] || 0x4A == ((U8*)s)[2] ) || ( 0x51 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x59 ) || ( 0x62 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x6A ) || ( ((U8*)s)[2] & 0xFC ) == 0x70 ) ? 3 : 0 )\
    : ( 0x42 == ((U8*)s)[1] ) ?                                             \
	( ( 0x41 == ((U8*)s)[2] || 0x57 == ((U8*)s)[2] ) ? 3 : 0 )          \
    : ( ( 0x52 == ((U8*)s)[1] ) && ( 0x45 == ((U8*)s)[2] ) ) ? 3 : 0 )      \
: ( 0xDD == ((U8*)s)[0] ) ?                                                 \
    ( ( 0x73 == ((U8*)s)[1] ) ?                                             \
	( ( 0x4A == ((U8*)s)[2] ) ?                                         \
	    ( ( ( ((U8*)s)[3] & 0xFE ) == 0x72 ) ? 4 : 0 )                  \
	: ( 0x57 == ((U8*)s)[2] ) ?                                         \
	    ( ( ( 0x41 <= ((U8*)s)[3] && ((U8*)s)[3] <= 0x4A ) || ( 0x51 <= ((U8*)s)[3] && ((U8*)s)[3] <= 0x56 ) ) ? 4 : 0 )\
	: ( 0x59 == ((U8*)s)[2] ) ?                                         \
	    ( ( ( ((U8*)s)[3] & 0xFE ) == 0x46 ) ? 4 : 0 )                  \
	: ( 0x66 == ((U8*)s)[2] ) ?                                         \
	    ( ( 0x73 == ((U8*)s)[3] ) ? 4 : 0 )                             \
	: ( 0x71 == ((U8*)s)[2] ) ?                                         \
	    ( ( 0x41 == ((U8*)s)[3] ) ? 4 : 0 )                             \
	: ( ( 0x73 == ((U8*)s)[2] ) && ( ( 0x57 <= ((U8*)s)[3] && ((U8*)s)[3] <= 0x59 ) || ( 0x62 <= ((U8*)s)[3] && ((U8*)s)[3] <= 0x67 ) ) ) ? 4 : 0 )\
    : 0 )                                                                   \
: ( 0xDF == ((U8*)s)[0] ) ?                                                 \
    ( ( 0x56 == ((U8*)s)[1] ) ?                                             \
	( ( ( 0x46 == ((U8*)s)[2] ) && ( 0x41 <= ((U8*)s)[3] && ((U8*)s)[3] <= 0x44 ) ) ? 4 : 0 )\
    : ( ( ( 0x63 == ((U8*)s)[1] ) && ( 0x52 == ((U8*)s)[2] ) ) && ( 0x62 <= ((U8*)s)[3] && ((U8*)s)[3] <= 0x69 ) ) ? 4 : 0 )\
: ( ( ( ( ( 0xED == ((U8*)s)[0] ) && ( 0x70 == ((U8*)s)[1] ) ) && ( 0x41 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x44 ) ) && ( ( 0x41 <= ((U8*)s)[3] && ((U8*)s)[3] <= 0x4A ) || ( 0x51 <= ((U8*)s)[3] && ((U8*)s)[3] <= 0x59 ) || ( 0x62 <= ((U8*)s)[3] && ((U8*)s)[3] <= 0x6A ) || ( ((U8*)s)[3] & 0xFC ) == 0x70 ) ) && ( ( 0x41 <= ((U8*)s)[4] && ((U8*)s)[4] <= 0x4A ) || ( 0x51 <= ((U8*)s)[4] && ((U8*)s)[4] <= 0x59 ) || ( 0x62 <= ((U8*)s)[4] && ((U8*)s)[4] <= 0x6A ) || ( ((U8*)s)[4] & 0xFC ) == 0x70 ) ) ? 5 : 0 )

/*
	MULTI_CHAR_FOLD: multi-char strings that are folded to by a single character

	&regcharclass_multi_char_folds::multi_char_folds(1)
*/
/*** GENERATED CODE ***/
#define is_MULTI_CHAR_FOLD_utf8_safe_part0(s,e)                             \
( ( 0x81 == ((U8*)s)[0] ) ?                                                 \
	( ( ( 0xAB == ((U8*)s)[1] ) && ( 0x72 == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0x86 == ((U8*)s)[0] ) ?                                             \
	( ( 0x86 == ((U8*)s)[1] ) ?                                         \
	    ( ( 0x89 == ((U8*)s)[2] || 0x93 == ((U8*)s)[2] ) ? 3 : 2 )      \
	: ( 0x89 == ((U8*)s)[1] || 0x93 == ((U8*)s)[1] ) ? 2 : 0 )          \
    : ( 0x88 == ((U8*)s)[0] ) ?                                             \
	( ( ( 0xB0 == ((U8*)s)[1] ) && ( 0x58 == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0x89 == ((U8*)s)[0] ) ?                                             \
	( ( ( 0xAF == ((U8*)s)[1] ) && ( 0x48 == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0x8F == ((U8*)s)[0] ) ?                                             \
	( ( ( ( 0x73 == ((U8*)s)[1] ) && ( 0x8F == ((U8*)s)[2] ) ) && ( 0x73 == ((U8*)s)[3] ) ) ? 4 : 0 )\
    : ( 0x91 == ((U8*)s)[0] ) ?                                             \
	( ( ( 0xAF == ((U8*)s)[1] ) && ( 0x53 == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0xA2 == ((U8*)s)[0] ) ?                                             \
	( ( ( ((U8*)s)[1] & 0xFE ) == 0xA2 ) ? 2 : 0 )                      \
    : ( 0xA3 == ((U8*)s)[0] ) ?                                             \
	( ( ( 0xAF == ((U8*)s)[1] ) && ( 0x49 == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0xA6 == ((U8*)s)[0] || 0xA8 == ((U8*)s)[0] ) ?                      \
	( ( ( 0xAF == ((U8*)s)[1] ) && ( 0x51 == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0xAB == ((U8*)s)[0] ) ?                                             \
	( ( ( 0x70 == ((U8*)s)[1] ) && ( 0x95 == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0xB4 == ((U8*)s)[0] ) ?                                             \
	( ( 0x53 == ((U8*)s)[1] || 0x55 == ((U8*)s)[1] ) ?                  \
	    ( ( ( 0xB4 == ((U8*)s)[2] ) && ( 0x68 == ((U8*)s)[3] ) ) ? 4 : 0 )\
	: ( 0x58 == ((U8*)s)[1] || 0x66 == ((U8*)s)[1] ) ?                  \
	    ( ( 0xB1 == ((U8*)s)[2] ) ?                                     \
		( ( 0x43 == ((U8*)s)[3] ) ? 4 : 0 )                         \
	    : ( ( 0xB4 == ((U8*)s)[2] ) && ( 0x68 == ((U8*)s)[3] ) ) ? 4 : 0 )\
	: ( ( ( 0x68 == ((U8*)s)[1] ) && ( 0xB1 == ((U8*)s)[2] ) ) && ( 0x43 == ((U8*)s)[3] ) ) ? 4 : 0 )\
    : ( 0xB5 == ((U8*)s)[0] ) ?                                             \
	( ( 0x42 == ((U8*)s)[1] ) ?                                         \
	    ( ( ( 0xAF == ((U8*)s)[2] ) && ( 0x62 == ((U8*)s)[3] ) ) ? 4 : 0 )\
	: ( 0x46 == ((U8*)s)[1] ) ?                                         \
	    ( ( 0xAF == ((U8*)s)[2] ) ?                                     \
		( ( 0x62 == ((U8*)s)[3] ) ? 4 : 0 )                         \
	    : ( ( 0xB1 == ((U8*)s)[2] ) && ( 0x43 == ((U8*)s)[3] ) ) ? 4 : 0 )\
	: ( 0x4A == ((U8*)s)[1] ) ?                                         \
	    ( ( 0xB1 == ((U8*)s)[2] ) ?                                     \
		( ( 0x43 == ((U8*)s)[3] ) ? 4 : 0 )                         \
	    : ( ( 0xB4 == ((U8*)s)[2] ) && ( 0x68 == ((U8*)s)[3] ) ) ? 4 : 0 )\
	: ( ( ( 0x55 == ((U8*)s)[1] ) && ( 0xB4 == ((U8*)s)[2] ) ) && ( 0x68 == ((U8*)s)[3] ) ) ? 4 : 0 )\
    : ( 0xBF == ((U8*)s)[0] ) ?                                             \
	( ( 0x67 == ((U8*)s)[1] || 0x68 == ((U8*)s)[1] ) ?                  \
	    ( ( ( ( 0x41 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x48 ) && ( 0xB4 == ((U8*)s)[3] ) ) && ( 0x68 == ((U8*)s)[4] ) ) ? 5 : 0 )\
	: ( ( ( ( 0x6A == ((U8*)s)[1] ) && ( ( 0x41 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x48 ) || 0x57 == ((U8*)s)[2] || 0x63 == ((U8*)s)[2] || 0x70 == ((U8*)s)[2] ) ) && ( 0xB4 == ((U8*)s)[3] ) ) && ( 0x68 == ((U8*)s)[4] ) ) ? 5 : 0 )\
    : 0 )


/*** GENERATED CODE ***/
#define is_MULTI_CHAR_FOLD_utf8_safe_part1(s,e)                             \
( ((e)-(s) > 3) ?                                                           \
    ( ( 0x81 == ((U8*)s)[0] ) ?                                             \
	( ( ( 0xAB == ((U8*)s)[1] ) && ( 0x72 == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0x86 == ((U8*)s)[0] ) ?                                             \
	( ( 0x86 == ((U8*)s)[1] ) ?                                         \
	    ( ( 0x89 == ((U8*)s)[2] || 0x93 == ((U8*)s)[2] ) ? 3 : 2 )      \
	: ( 0x89 == ((U8*)s)[1] || 0x93 == ((U8*)s)[1] ) ? 2 : 0 )          \
    : ( 0x88 == ((U8*)s)[0] ) ?                                             \
	( ( ( 0xB0 == ((U8*)s)[1] ) && ( 0x58 == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0x89 == ((U8*)s)[0] ) ?                                             \
	( ( ( 0xAF == ((U8*)s)[1] ) && ( 0x48 == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0x8F == ((U8*)s)[0] ) ?                                             \
	( ( ( ( 0x73 == ((U8*)s)[1] ) && ( 0x8F == ((U8*)s)[2] ) ) && ( 0x73 == ((U8*)s)[3] ) ) ? 4 : 0 )\
    : ( 0x91 == ((U8*)s)[0] ) ?                                             \
	( ( ( 0xAF == ((U8*)s)[1] ) && ( 0x53 == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0xA2 == ((U8*)s)[0] ) ?                                             \
	( ( ( ((U8*)s)[1] & 0xFE ) == 0xA2 ) ? 2 : 0 )                      \
    : ( 0xA3 == ((U8*)s)[0] ) ?                                             \
	( ( ( 0xAF == ((U8*)s)[1] ) && ( 0x49 == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0xA6 == ((U8*)s)[0] || 0xA8 == ((U8*)s)[0] ) ?                      \
	( ( ( 0xAF == ((U8*)s)[1] ) && ( 0x51 == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0xAB == ((U8*)s)[0] ) ?                                             \
	( ( ( 0x70 == ((U8*)s)[1] ) && ( 0x95 == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0xB4 == ((U8*)s)[0] ) ?                                             \
	( ( 0x53 == ((U8*)s)[1] || 0x55 == ((U8*)s)[1] ) ?                  \
	    ( ( ( 0xB4 == ((U8*)s)[2] ) && ( 0x68 == ((U8*)s)[3] ) ) ? 4 : 0 )\
	: ( 0x58 == ((U8*)s)[1] || 0x66 == ((U8*)s)[1] ) ?                  \
	    ( ( 0xB1 == ((U8*)s)[2] ) ?                                     \
		( ( 0x43 == ((U8*)s)[3] ) ? 4 : 0 )                         \
	    : ( ( 0xB4 == ((U8*)s)[2] ) && ( 0x68 == ((U8*)s)[3] ) ) ? 4 : 0 )\
	: ( ( ( 0x68 == ((U8*)s)[1] ) && ( 0xB1 == ((U8*)s)[2] ) ) && ( 0x43 == ((U8*)s)[3] ) ) ? 4 : 0 )\
    : ( 0xB5 == ((U8*)s)[0] ) ?                                             \
	( ( 0x42 == ((U8*)s)[1] ) ?                                         \
	    ( ( ( 0xAF == ((U8*)s)[2] ) && ( 0x62 == ((U8*)s)[3] ) ) ? 4 : 0 )\
	: ( 0x46 == ((U8*)s)[1] ) ?                                         \
	    ( ( 0xAF == ((U8*)s)[2] ) ?                                     \
		( ( 0x62 == ((U8*)s)[3] ) ? 4 : 0 )                         \
	    : ( ( 0xB1 == ((U8*)s)[2] ) && ( 0x43 == ((U8*)s)[3] ) ) ? 4 : 0 )\
	: ( 0x4A == ((U8*)s)[1] ) ?                                         \
	    ( ( 0xB1 == ((U8*)s)[2] ) ?                                     \
		( ( 0x43 == ((U8*)s)[3] ) ? 4 : 0 )                         \
	    : ( ( 0xB4 == ((U8*)s)[2] ) && ( 0x68 == ((U8*)s)[3] ) ) ? 4 : 0 )\
	: ( ( ( 0x55 == ((U8*)s)[1] ) && ( 0xB4 == ((U8*)s)[2] ) ) && ( 0x68 == ((U8*)s)[3] ) ) ? 4 : 0 )\
    : 0 )                                                                   \
: ((e)-(s) > 2) ?                                                           \
    ( ( 0x81 == ((U8*)s)[0] ) ?                                             \
	( ( ( 0xAB == ((U8*)s)[1] ) && ( 0x72 == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0x86 == ((U8*)s)[0] ) ?                                             \
	( ( 0x86 == ((U8*)s)[1] ) ?                                         \
	    ( ( 0x89 == ((U8*)s)[2] || 0x93 == ((U8*)s)[2] ) ? 3 : 2 )      \
	: ( 0x89 == ((U8*)s)[1] || 0x93 == ((U8*)s)[1] ) ? 2 : 0 )          \
    : ( 0x88 == ((U8*)s)[0] ) ?                                             \
	( ( ( 0xB0 == ((U8*)s)[1] ) && ( 0x58 == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0x89 == ((U8*)s)[0] ) ?                                             \
	( ( ( 0xAF == ((U8*)s)[1] ) && ( 0x48 == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0x91 == ((U8*)s)[0] ) ?                                             \
	( ( ( 0xAF == ((U8*)s)[1] ) && ( 0x53 == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0xA2 == ((U8*)s)[0] ) ?                                             \
	( ( ( ((U8*)s)[1] & 0xFE ) == 0xA2 ) ? 2 : 0 )                      \
    : ( 0xA3 == ((U8*)s)[0] ) ?                                             \
	( ( ( 0xAF == ((U8*)s)[1] ) && ( 0x49 == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0xA6 == ((U8*)s)[0] || 0xA8 == ((U8*)s)[0] ) ?                      \
	( ( ( 0xAF == ((U8*)s)[1] ) && ( 0x51 == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( ( ( 0xAB == ((U8*)s)[0] ) && ( 0x70 == ((U8*)s)[1] ) ) && ( 0x95 == ((U8*)s)[2] ) ) ? 3 : 0 )\
: ((e)-(s) > 1) ?                                                           \
    ( ( 0x86 == ((U8*)s)[0] ) ?                                             \
	( ( 0x86 == ((U8*)s)[1] || 0x89 == ((U8*)s)[1] || 0x93 == ((U8*)s)[1] ) ? 2 : 0 )\
    : ( ( 0xA2 == ((U8*)s)[0] ) && ( ( ((U8*)s)[1] & 0xFE ) == 0xA2 ) ) ? 2 : 0 )\
: 0 )


/*** GENERATED CODE ***/
#define is_MULTI_CHAR_FOLD_utf8_safe(s,e)                                   \
( ((e)-(s) > 5) ?                                                           \
    ( ( 0x81 == ((U8*)s)[0] ) ?                                             \
	( ( ( 0xAB == ((U8*)s)[1] ) && ( 0x72 == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0x86 == ((U8*)s)[0] ) ?                                             \
	( ( 0x86 == ((U8*)s)[1] ) ?                                         \
	    ( ( 0x89 == ((U8*)s)[2] || 0x93 == ((U8*)s)[2] ) ? 3 : 2 )      \
	: ( 0x89 == ((U8*)s)[1] || 0x93 == ((U8*)s)[1] ) ? 2 : 0 )          \
    : ( 0x88 == ((U8*)s)[0] ) ?                                             \
	( ( ( 0xB0 == ((U8*)s)[1] ) && ( 0x58 == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0x89 == ((U8*)s)[0] ) ?                                             \
	( ( ( 0xAF == ((U8*)s)[1] ) && ( 0x48 == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0x8F == ((U8*)s)[0] ) ?                                             \
	( ( ( ( 0x73 == ((U8*)s)[1] ) && ( 0x8F == ((U8*)s)[2] ) ) && ( 0x73 == ((U8*)s)[3] ) ) ? 4 : 0 )\
    : ( 0x91 == ((U8*)s)[0] ) ?                                             \
	( ( ( 0xAF == ((U8*)s)[1] ) && ( 0x53 == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0xA2 == ((U8*)s)[0] ) ?                                             \
	( ( ( ((U8*)s)[1] & 0xFE ) == 0xA2 ) ? 2 : 0 )                      \
    : ( 0xA3 == ((U8*)s)[0] ) ?                                             \
	( ( ( 0xAF == ((U8*)s)[1] ) && ( 0x49 == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0xA6 == ((U8*)s)[0] || 0xA8 == ((U8*)s)[0] ) ?                      \
	( ( ( 0xAF == ((U8*)s)[1] ) && ( 0x51 == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0xAB == ((U8*)s)[0] ) ?                                             \
	( ( ( 0x70 == ((U8*)s)[1] ) && ( 0x95 == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0xB4 == ((U8*)s)[0] ) ?                                             \
	( ( 0x53 == ((U8*)s)[1] || 0x55 == ((U8*)s)[1] ) ?                  \
	    ( ( ( 0xB4 == ((U8*)s)[2] ) && ( 0x68 == ((U8*)s)[3] ) ) ? 4 : 0 )\
	: ( 0x58 == ((U8*)s)[1] || 0x66 == ((U8*)s)[1] ) ?                  \
	    ( ( 0xB1 == ((U8*)s)[2] ) ?                                     \
		( ( 0x43 == ((U8*)s)[3] ) ?                                 \
		    ( ( ( 0xB4 == ((U8*)s)[4] ) && ( 0x68 == ((U8*)s)[5] ) ) ? 6 : 4 )\
		: 0 )                                                       \
	    : ( ( 0xB4 == ((U8*)s)[2] ) && ( 0x68 == ((U8*)s)[3] ) ) ? 4 : 0 )\
	: ( 0x68 == ((U8*)s)[1] ) ?                                         \
	    ( ( 0xAF == ((U8*)s)[2] ) ?                                     \
		( ( 0x49 == ((U8*)s)[3] ) ?                                 \
		    ( ( 0xAF == ((U8*)s)[4] ) ?                             \
			( ( 0x41 == ((U8*)s)[5] || 0x42 == ((U8*)s)[5] ) ? 6 : 0 )\
		    : ( ( 0xB1 == ((U8*)s)[4] ) && ( 0x43 == ((U8*)s)[5] ) ) ? 6 : 0 )\
		: 0 )                                                       \
	    : ( ( 0xB1 == ((U8*)s)[2] ) && ( 0x43 == ((U8*)s)[3] ) ) ? 4 : 0 )\
	: 0 )                                                               \
    : ( 0xB5 == ((U8*)s)[0] ) ?                                             \
	( ( 0x42 == ((U8*)s)[1] ) ?                                         \
	    ( ( ( 0xAF == ((U8*)s)[2] ) && ( 0x62 == ((U8*)s)[3] ) ) ? 4 : 0 )\
	: ( 0x46 == ((U8*)s)[1] ) ?                                         \
	    ( ( 0xAF == ((U8*)s)[2] ) ?                                     \
		( ( 0x49 == ((U8*)s)[3] ) ?                                 \
		    ( ( 0xAF == ((U8*)s)[4] ) ?                             \
			( ( 0x41 == ((U8*)s)[5] || 0x42 == ((U8*)s)[5] ) ? 6 : 0 )\
		    : ( ( 0xB1 == ((U8*)s)[4] ) && ( 0x43 == ((U8*)s)[5] ) ) ? 6 : 0 )\
		: ( 0x62 == ((U8*)s)[3] ) ?                                 \
		    ( ( 0xAF == ((U8*)s)[4] ) ?                             \
			( ( 0x41 == ((U8*)s)[5] || 0x42 == ((U8*)s)[5] ) ? 6 : 4 )\
		    : ( ( 0xB1 == ((U8*)s)[4] ) && ( 0x43 == ((U8*)s)[5] ) ) ? 6 : 4 )\
		: 0 )                                                       \
	    : ( ( 0xB1 == ((U8*)s)[2] ) && ( 0x43 == ((U8*)s)[3] ) ) ? 4 : 0 )\
	: ( 0x4A == ((U8*)s)[1] ) ?                                         \
	    ( ( 0xB1 == ((U8*)s)[2] ) ?                                     \
		( ( 0x43 == ((U8*)s)[3] ) ?                                 \
		    ( ( ( 0xB4 == ((U8*)s)[4] ) && ( 0x68 == ((U8*)s)[5] ) ) ? 6 : 4 )\
		: 0 )                                                       \
	    : ( ( 0xB4 == ((U8*)s)[2] ) && ( 0x68 == ((U8*)s)[3] ) ) ? 4 : 0 )\
	: ( ( ( 0x55 == ((U8*)s)[1] ) && ( 0xB4 == ((U8*)s)[2] ) ) && ( 0x68 == ((U8*)s)[3] ) ) ? 4 : 0 )\
    : ( 0xB8 == ((U8*)s)[0] ) ?                                             \
	( ( 0x52 == ((U8*)s)[1] ) ?                                         \
	    ( ( 0x46 == ((U8*)s)[2] ) ?                                     \
		( ( ( ( 0xB8 == ((U8*)s)[3] ) && ( 0x53 == ((U8*)s)[4] ) ) && ( 0x43 == ((U8*)s)[5] ) ) ? 6 : 0 )\
	    : ( 0x63 == ((U8*)s)[2] ) ?                                     \
		( ( ( ( 0xB8 == ((U8*)s)[3] ) && ( 0x52 == ((U8*)s)[4] ) ) && ( 0x46 == ((U8*)s)[5] || 0x52 == ((U8*)s)[5] || 0x54 == ((U8*)s)[5] || 0x65 == ((U8*)s)[5] ) ) ? 6 : 0 )\
	    : ( ( ( ( 0x72 == ((U8*)s)[2] ) && ( 0xB8 == ((U8*)s)[3] ) ) && ( 0x52 == ((U8*)s)[4] ) ) && ( 0x65 == ((U8*)s)[5] ) ) ? 6 : 0 )\
	: 0 )                                                               \
    : ( 0xBF == ((U8*)s)[0] ) ?                                             \
	( ( 0x67 == ((U8*)s)[1] || 0x68 == ((U8*)s)[1] ) ?                  \
	    ( ( ( ( 0x41 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x48 ) && ( 0xB4 == ((U8*)s)[3] ) ) && ( 0x68 == ((U8*)s)[4] ) ) ? 5 : 0 )\
	: ( ( ( ( 0x6A == ((U8*)s)[1] ) && ( ( 0x41 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x48 ) || 0x57 == ((U8*)s)[2] || 0x63 == ((U8*)s)[2] || 0x70 == ((U8*)s)[2] ) ) && ( 0xB4 == ((U8*)s)[3] ) ) && ( 0x68 == ((U8*)s)[4] ) ) ? 5 : 0 )\
    : 0 )                                                                   \
: ((e)-(s) > 4) ? is_MULTI_CHAR_FOLD_utf8_safe_part0(s,e) : is_MULTI_CHAR_FOLD_utf8_safe_part1(s,e) )

/*
	MULTI_CHAR_FOLD: multi-char strings that are folded to by a single character

	&regcharclass_multi_char_folds::multi_char_folds(0)
*/
/*** GENERATED CODE ***/
#define is_MULTI_CHAR_FOLD_latin1_safe(s,e)                                 \
( ((e)-(s) > 2) ?                                                           \
    ( ( ( ((U8*)s)[0] & 0xBF ) == 0x86 ) ?                                  \
	( ( ( ((U8*)s)[1] & 0xBF ) == 0x86 ) ?                              \
	    ( ( ( ( ((U8*)s)[2] & 0xBF ) == 0x89 ) || ( ( ((U8*)s)[2] & 0xBF ) == 0x93 ) ) ? 3 : 2 )\
	: ( ( ( ((U8*)s)[1] & 0xBF ) == 0x89 ) || ( ( ((U8*)s)[1] & 0xBF ) == 0x93 ) ) ? 2 : 0 )\
    : ( ( ( ((U8*)s)[0] & 0xBF ) == 0xA2 ) && ( ( ((U8*)s)[1] & 0xBE ) == 0xA2 ) ) ? 2 : 0 )\
: ((e)-(s) > 1) ?                                                           \
    ( ( ( ((U8*)s)[0] & 0xBF ) == 0x86 ) ?                                  \
	( ( ( ( ((U8*)s)[1] & 0xBF ) == 0x86 ) || ( ( ((U8*)s)[1] & 0xBF ) == 0x89 ) || ( ( ((U8*)s)[1] & 0xBF ) == 0x93 ) ) ? 2 : 0 )\
    : ( ( ( ((U8*)s)[0] & 0xBF ) == 0xA2 ) && ( ( ((U8*)s)[1] & 0xBE ) == 0xA2 ) ) ? 2 : 0 )\
: 0 )

/*
	FOLDS_TO_MULTI: characters that fold to multi-char strings

	\p{_Perl_Folds_To_Multi_Char}
*/
/*** GENERATED CODE ***/
#define is_FOLDS_TO_MULTI_utf8(s)                                           \
( ( 0x8A == ((U8*)s)[0] ) ?                                                 \
    ( ( 0x73 == ((U8*)s)[1] ) ? 2 : 0 )                                     \
: ( 0x8D == ((U8*)s)[0] || 0x9C == ((U8*)s)[0] || ( 0xB3 == ((U8*)s)[0] || 0xB4 == ((U8*)s)[0] ) ) ?\
    ( ( 0x57 == ((U8*)s)[1] ) ? 2 : 0 )                                     \
: ( 0x8E == ((U8*)s)[0] ) ?                                                 \
    ( ( 0x4A == ((U8*)s)[1] ) ? 2 : 0 )                                     \
: ( 0xB8 == ((U8*)s)[0] ) ?                                                 \
    ( ( ( 0x53 == ((U8*)s)[1] ) && ( 0x48 == ((U8*)s)[2] ) ) ? 3 : 0 )      \
: ( 0xBF == ((U8*)s)[0] ) ?                                                 \
    ( ( 0x63 == ((U8*)s)[1] ) ?                                             \
	( ( ( 0x65 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x69 ) || 0x72 == ((U8*)s)[2] ) ? 3 : 0 )\
    : ( 0x69 == ((U8*)s)[1] ) ?                                             \
	( ( 0x57 == ((U8*)s)[2] || 0x59 == ((U8*)s)[2] || 0x63 == ((U8*)s)[2] || 0x65 == ((U8*)s)[2] ) ? 3 : 0 )\
    : ( 0x70 == ((U8*)s)[1] ) ?                                             \
	( ( ( 0x41 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x4A ) || ( 0x51 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x59 ) || ( 0x62 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x6A ) || ( ((U8*)s)[2] & 0xFC ) == 0x70 ) ? 3 : 0 )\
    : ( 0x71 == ((U8*)s)[1] ) ?                                             \
	( ( ( 0x41 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x4A ) || ( 0x51 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x56 ) || 0x59 == ((U8*)s)[2] || ( ((U8*)s)[2] & 0xFE ) == 0x62 || ( 0x65 == ((U8*)s)[2] || 0x66 == ((U8*)s)[2] ) || 0x70 == ((U8*)s)[2] ) ? 3 : 0 )\
    : ( 0x72 == ((U8*)s)[1] ) ?                                             \
	( ( ( ( ((U8*)s)[2] & 0xFB ) == 0x43 ) || ( ( ((U8*)s)[2] & 0xFE ) == 0x44 ) || ((U8*)s)[2] == 0x48 || ((U8*)s)[2] == 0x53 || ((U8*)s)[2] == 0x59 || ( ( ((U8*)s)[2] & 0xFB ) == 0x62 ) || ((U8*)s)[2] == 0x65 ) ? 3 : 0 )\
    : ( ( 0x73 == ((U8*)s)[1] ) && ( ( ( ((U8*)s)[2] & 0xFB ) == 0x43 ) || ( ( ((U8*)s)[2] & 0xFE ) == 0x44 ) || ((U8*)s)[2] == 0x48 || ((U8*)s)[2] == 0x59 || ( ( ((U8*)s)[2] & 0xFE ) == 0x62 ) || ((U8*)s)[2] == 0x65 || ((U8*)s)[2] == 0x66 || ((U8*)s)[2] == 0x70 ) ) ? 3 : 0 )\
: ( ( ( ( 0xDD == ((U8*)s)[0] ) && ( 0x72 == ((U8*)s)[1] ) ) && ( 0x67 == ((U8*)s)[2] ) ) && ( ( 0x41 <= ((U8*)s)[3] && ((U8*)s)[3] <= 0x47 ) || ( 0x62 <= ((U8*)s)[3] && ((U8*)s)[3] <= 0x66 ) ) ) ? 4 : 0 )

/*
	PROBLEMATIC_LOCALE_FOLD: characters whose fold is problematic under locale

	\p{_Perl_Problematic_Locale_Folds}
*/
/*** GENERATED CODE ***/
#define is_PROBLEMATIC_LOCALE_FOLD_utf8(s)                                  \
( ( ( ( ((U8*)s)[0] & 0xC0 ) == 0x00 ) || ( ( ((U8*)s)[0] & 0xEF ) == 0x40 ) || ( ( ((U8*)s)[0] & 0xDF ) == 0x4B ) || ( ( ((U8*)s)[0] & 0xCC ) == 0x4C ) || ( ( ((U8*)s)[0] & 0xDE ) == 0x5A ) || ( ( ((U8*)s)[0] & 0xFE ) == 0x60 ) || ((U8*)s)[0] == 0x79 || ( ( ((U8*)s)[0] & 0xEF ) == 0x81 ) || ( ( ((U8*)s)[0] & 0xEE ) == 0x82 ) || ( ( ((U8*)s)[0] & 0xEC ) == 0x84 ) || ( ( ((U8*)s)[0] & 0xEE ) == 0x88 ) || ((U8*)s)[0] == 0xA1 || ( ( ((U8*)s)[0] & 0xBE ) == 0xA2 ) || ( ( ((U8*)s)[0] & 0xBC ) == 0xA4 ) || ( ( ((U8*)s)[0] & 0xFE ) == 0xA8 ) || ( ( ((U8*)s)[0] & 0xEF ) == 0xAD ) || ( ( ((U8*)s)[0] & 0xE8 ) == 0xC0 ) || ( ( ((U8*)s)[0] & 0xCE ) == 0xC8 ) || ((U8*)s)[0] == 0xE0 || ( ( ((U8*)s)[0] & 0xF8 ) == 0xF0 ) || ((U8*)s)[0] == 0xFF ) ? 1\
: ( 0x80 == ((U8*)s)[0] || ( ((U8*)s)[0] & 0xFE ) == 0x8A ) ?               \
    ( ( ( 0x41 <= ((U8*)s)[1] && ((U8*)s)[1] <= 0x4A ) || ( 0x51 <= ((U8*)s)[1] && ((U8*)s)[1] <= 0x59 ) || ( 0x62 <= ((U8*)s)[1] && ((U8*)s)[1] <= 0x6A ) || ( ((U8*)s)[1] & 0xFC ) == 0x70 ) ? 2 : 0 )\
: ( 0x8D == ((U8*)s)[0] || 0x9C == ((U8*)s)[0] ) ?                          \
    ( ( 0x57 == ((U8*)s)[1] ) ? 2 : 0 )                                     \
: ( 0x8E == ((U8*)s)[0] ) ?                                                 \
    ( ( 0x4A == ((U8*)s)[1] ) ? 2 : 0 )                                     \
: ( 0x8F == ((U8*)s)[0] ) ?                                                 \
    ( ( 0x67 == ((U8*)s)[1] || 0x73 == ((U8*)s)[1] ) ? 2 : 0 )              \
: ( 0xB3 == ((U8*)s)[0] || 0xB4 == ((U8*)s)[0] ) ?                          \
    ( ( 0x70 == ((U8*)s)[1] ) ? 2 : 0 )                                     \
: ( 0xBF == ((U8*)s)[0] ) ?                                                 \
    ( ( ( 0x63 == ((U8*)s)[1] ) && ( ( 0x65 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x69 ) || 0x72 == ((U8*)s)[2] ) ) ? 3 : 0 )\
: ( 0xCA == ((U8*)s)[0] ) ?                                                 \
    ( ( ( 0x4A == ((U8*)s)[1] ) && ( 0x51 == ((U8*)s)[2] || 0x52 == ((U8*)s)[2] ) ) ? 3 : 0 )\
: ( ( ( ( 0xDD == ((U8*)s)[0] ) && ( 0x72 == ((U8*)s)[1] ) ) && ( 0x67 == ((U8*)s)[2] ) ) && ( 0x41 <= ((U8*)s)[3] && ((U8*)s)[3] <= 0x47 ) ) ? 4 : 0 )

/*** GENERATED CODE ***/
#define is_PROBLEMATIC_LOCALE_FOLD_cp(cp)                                   \
( cp <= 0xFF || ( 0xFF < cp &&                                              \
( 0x130 == cp || ( 0x130 < cp &&                                            \
( 0x149 == cp || ( 0x149 < cp &&                                            \
( 0x178 == cp || ( 0x178 < cp &&                                            \
( 0x17F == cp || ( 0x17F < cp &&                                            \
( 0x1F0 == cp || ( 0x1F0 < cp &&                                            \
( 0x39C == cp || ( 0x39C < cp &&                                            \
( 0x3BC == cp || ( 0x3BC < cp &&                                            \
( ( 0x1E96 <= cp && cp <= 0x1E9A ) || ( 0x1E9A < cp &&                      \
( 0x1E9E == cp || ( 0x1E9E < cp &&                                          \
( 0x212A == cp || ( 0x212A < cp &&                                          \
( 0x212B == cp || ( 0xFB00 <= cp && cp <= 0xFB06 ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )

/*
	PROBLEMATIC_LOCALE_FOLDEDS_START: The first folded character of folds which are problematic under locale

	\p{_Perl_Problematic_Locale_Foldeds_Start}
*/
/*** GENERATED CODE ***/
#define is_PROBLEMATIC_LOCALE_FOLDEDS_START_utf8(s)                         \
( ( ( ( ((U8*)s)[0] & 0xC0 ) == 0x00 ) || ( ( ((U8*)s)[0] & 0xEF ) == 0x40 ) || ( ( ((U8*)s)[0] & 0xDF ) == 0x4B ) || ( ( ((U8*)s)[0] & 0xCC ) == 0x4C ) || ( ( ((U8*)s)[0] & 0xDE ) == 0x5A ) || ( ( ((U8*)s)[0] & 0xFE ) == 0x60 ) || ((U8*)s)[0] == 0x79 || ( ( ((U8*)s)[0] & 0xEF ) == 0x81 ) || ( ( ((U8*)s)[0] & 0xEE ) == 0x82 ) || ( ( ((U8*)s)[0] & 0xEC ) == 0x84 ) || ( ( ((U8*)s)[0] & 0xEE ) == 0x88 ) || ((U8*)s)[0] == 0xA1 || ( ( ((U8*)s)[0] & 0xBE ) == 0xA2 ) || ( ( ((U8*)s)[0] & 0xBC ) == 0xA4 ) || ( ( ((U8*)s)[0] & 0xFE ) == 0xA8 ) || ( ( ((U8*)s)[0] & 0xEF ) == 0xAD ) || ( ( ((U8*)s)[0] & 0xE8 ) == 0xC0 ) || ( ( ((U8*)s)[0] & 0xCE ) == 0xC8 ) || ((U8*)s)[0] == 0xE0 || ( ( ((U8*)s)[0] & 0xF8 ) == 0xF0 ) || ((U8*)s)[0] == 0xFF ) ? 1\
: ( 0x80 == ((U8*)s)[0] || ( ((U8*)s)[0] & 0xFE ) == 0x8A ) ?               \
    ( ( ( 0x41 <= ((U8*)s)[1] && ((U8*)s)[1] <= 0x4A ) || ( 0x51 <= ((U8*)s)[1] && ((U8*)s)[1] <= 0x59 ) || ( 0x62 <= ((U8*)s)[1] && ((U8*)s)[1] <= 0x6A ) || ( ((U8*)s)[1] & 0xFC ) == 0x70 ) ? 2 : 0 )\
: ( 0x8D == ((U8*)s)[0] || 0x9C == ((U8*)s)[0] ) ?                          \
    ( ( 0x57 == ((U8*)s)[1] ) ? 2 : 0 )                                     \
: ( 0x8E == ((U8*)s)[0] ) ?                                                 \
    ( ( 0x4A == ((U8*)s)[1] ) ? 2 : 0 )                                     \
: ( 0x8F == ((U8*)s)[0] ) ?                                                 \
    ( ( 0x67 == ((U8*)s)[1] || 0x73 == ((U8*)s)[1] ) ? 2 : 0 )              \
: ( 0xAB == ((U8*)s)[0] || ( 0xB3 == ((U8*)s)[0] || 0xB4 == ((U8*)s)[0] ) ) ?\
    ( ( 0x70 == ((U8*)s)[1] ) ? 2 : 0 )                                     \
: ( 0xBF == ((U8*)s)[0] ) ?                                                 \
    ( ( ( 0x63 == ((U8*)s)[1] ) && ( ( 0x65 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x69 ) || 0x72 == ((U8*)s)[2] ) ) ? 3 : 0 )\
: ( 0xCA == ((U8*)s)[0] ) ?                                                 \
    ( ( ( 0x4A == ((U8*)s)[1] ) && ( 0x51 == ((U8*)s)[2] || 0x52 == ((U8*)s)[2] ) ) ? 3 : 0 )\
: ( ( ( ( 0xDD == ((U8*)s)[0] ) && ( 0x72 == ((U8*)s)[1] ) ) && ( 0x67 == ((U8*)s)[2] ) ) && ( 0x41 <= ((U8*)s)[3] && ((U8*)s)[3] <= 0x47 ) ) ? 4 : 0 )

/*** GENERATED CODE ***/
#define is_PROBLEMATIC_LOCALE_FOLDEDS_START_cp(cp)                          \
( cp <= 0xFF || ( 0xFF < cp &&                                              \
( 0x130 == cp || ( 0x130 < cp &&                                            \
( 0x149 == cp || ( 0x149 < cp &&                                            \
( 0x178 == cp || ( 0x178 < cp &&                                            \
( 0x17F == cp || ( 0x17F < cp &&                                            \
( 0x1F0 == cp || ( 0x1F0 < cp &&                                            \
( 0x2BC == cp || ( 0x2BC < cp &&                                            \
( 0x39C == cp || ( 0x39C < cp &&                                            \
( 0x3BC == cp || ( 0x3BC < cp &&                                            \
( ( 0x1E96 <= cp && cp <= 0x1E9A ) || ( 0x1E9A < cp &&                      \
( 0x1E9E == cp || ( 0x1E9E < cp &&                                          \
( 0x212A == cp || ( 0x212A < cp &&                                          \
( 0x212B == cp || ( 0xFB00 <= cp && cp <= 0xFB06 ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )

/*
	PATWS: pattern white space

	\p{_Perl_PatWS}
*/
/*** GENERATED CODE ***/
#define is_PATWS_safe(s,e,is_utf8)                                          \
( ( LIKELY((e) > (s)) ) ?                                                   \
    ( ( ( ( ((U8*)s)[0] & 0xEF ) == 0x05 ) || ((U8*)s)[0] == 0x0B || ( ( ((U8*)s)[0] & 0xFE ) == 0x0C ) || ((U8*)s)[0] == 0x25 || ((U8*)s)[0] == 0x40 ) ? 1\
    : ( ( is_utf8 && LIKELY(((e) - (s)) >= UTF8SKIP(s)) ) && ( 0xCA == ((U8*)s)[0] ) ) ? ( ( 0x41 == ((U8*)s)[1] ) ?\
		    ( ( 0x55 == ((U8*)s)[2] || 0x56 == ((U8*)s)[2] ) ? 3 : 0 )\
		: ( ( 0x42 == ((U8*)s)[1] ) && ( 0x49 == ((U8*)s)[2] || 0x4A == ((U8*)s)[2] ) ) ? 3 : 0 ) : 0 )\
: 0 )

/*** GENERATED CODE ***/
#define is_PATWS_cp(cp)                                                     \
( 0x05 == cp || ( 0x05 < cp &&                                              \
( ( 0x0B <= cp && cp <= 0x0D ) || ( 0x0D < cp &&                            \
( 0x15 == cp || ( 0x15 < cp &&                                              \
( 0x25 == cp || ( 0x25 < cp &&                                              \
( 0x40 == cp || ( 0x40 < cp &&                                              \
( 0x200E == cp || ( 0x200E < cp &&                                          \
( 0x200F == cp || ( 0x200F < cp &&                                          \
( 0x2028 == cp || 0x2029 == cp ) ) ) ) ) ) ) ) ) ) ) ) ) ) )

#endif	/* EBCDIC 1047 */

#if 'A' == 193 /* EBCDIC 037 */ \
     && '\\' == 224 && '[' == 186 && ']' == 187 && '{' == 192 && '}' == 208 \
     && '^' == 176 && '~' == 161 && '!' == 90 && '#' == 123 && '|' == 79 \
     && '$' == 91 && '@' == 124 && '`' == 121
/*
	LNBREAK: Line Break: \R

	"\x0D\x0A"      # CRLF - Network (Windows) line ending
	\p{VertSpace}
*/
/*** GENERATED CODE ***/
#define is_LNBREAK_safe(s,e,is_utf8)                                        \
( ((e)-(s) > 2) ?                                                           \
    ( ( ( 0x0B == ((U8*)s)[0] || 0x0C == ((U8*)s)[0] ) || 0x15 == ((U8*)s)[0] || 0x25 == ((U8*)s)[0] ) ? 1\
    : ( 0x0D == ((U8*)s)[0] ) ?                                             \
	( ( 0x25 == ((U8*)s)[1] ) ? 2 : 1 )                                 \
    : ( ( ( ( is_utf8 ) && ( 0xCA == ((U8*)s)[0] ) ) && ( 0x42 == ((U8*)s)[1] ) ) && ( 0x49 == ((U8*)s)[2] || 0x4A == ((U8*)s)[2] ) ) ? 3 : 0 )\
: ((e)-(s) > 1) ?                                                           \
    ( ( ( 0x0B == ((U8*)s)[0] || 0x0C == ((U8*)s)[0] ) || 0x15 == ((U8*)s)[0] || 0x25 == ((U8*)s)[0] ) ? 1\
    : ( 0x0D == ((U8*)s)[0] ) ?                                             \
	( ( 0x25 == ((U8*)s)[1] ) ? 2 : 1 )                                 \
    : 0 )                                                                   \
: ((e)-(s) > 0) ?                                                           \
    ( ( 0x0B <= ((U8*)s)[0] && ((U8*)s)[0] <= 0x0D ) || 0x15 == ((U8*)s)[0] || 0x25 == ((U8*)s)[0] )\
: 0 )

/*** GENERATED CODE ***/
#define is_LNBREAK_utf8_safe(s,e)                                           \
( ((e)-(s) > 2) ?                                                           \
    ( ( ( 0x0B == ((U8*)s)[0] || 0x0C == ((U8*)s)[0] ) || 0x15 == ((U8*)s)[0] || 0x25 == ((U8*)s)[0] ) ? 1\
    : ( 0x0D == ((U8*)s)[0] ) ?                                             \
	( ( 0x25 == ((U8*)s)[1] ) ? 2 : 1 )                                 \
    : ( ( ( 0xCA == ((U8*)s)[0] ) && ( 0x42 == ((U8*)s)[1] ) ) && ( 0x49 == ((U8*)s)[2] || 0x4A == ((U8*)s)[2] ) ) ? 3 : 0 )\
: ((e)-(s) > 1) ?                                                           \
    ( ( ( 0x0B == ((U8*)s)[0] || 0x0C == ((U8*)s)[0] ) || 0x15 == ((U8*)s)[0] || 0x25 == ((U8*)s)[0] ) ? 1\
    : ( 0x0D == ((U8*)s)[0] ) ?                                             \
	( ( 0x25 == ((U8*)s)[1] ) ? 2 : 1 )                                 \
    : 0 )                                                                   \
: ((e)-(s) > 0) ?                                                           \
    ( ( 0x0B <= ((U8*)s)[0] && ((U8*)s)[0] <= 0x0D ) || 0x15 == ((U8*)s)[0] || 0x25 == ((U8*)s)[0] )\
: 0 )

/*** GENERATED CODE ***/
#define is_LNBREAK_latin1_safe(s,e)                                         \
( ((e)-(s) > 1) ?                                                           \
    ( ( ( 0x0B == ((U8*)s)[0] || 0x0C == ((U8*)s)[0] ) || 0x15 == ((U8*)s)[0] || 0x25 == ((U8*)s)[0] ) ? 1\
    : ( 0x0D == ((U8*)s)[0] ) ?                                             \
	( ( 0x25 == ((U8*)s)[1] ) ? 2 : 1 )                                 \
    : 0 )                                                                   \
: ((e)-(s) > 0) ?                                                           \
    ( ( 0x0B <= ((U8*)s)[0] && ((U8*)s)[0] <= 0x0D ) || 0x15 == ((U8*)s)[0] || 0x25 == ((U8*)s)[0] )\
: 0 )

/*
	HORIZWS: Horizontal Whitespace: \h \H

	\p{HorizSpace}
*/
/*** GENERATED CODE ***/
#define is_HORIZWS_high(s)                                                  \
( ( 0xBD == ((U8*)s)[0] ) ?                                                 \
    ( ( ( 0x62 == ((U8*)s)[1] ) && ( 0x41 == ((U8*)s)[2] ) ) ? 3 : 0 )      \
: ( 0xCA == ((U8*)s)[0] ) ?                                                 \
    ( ( 0x41 == ((U8*)s)[1] ) ?                                             \
	( ( ( 0x41 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x4A ) || 0x51 == ((U8*)s)[2] ) ? 3 : 0 )\
    : ( 0x42 == ((U8*)s)[1] ) ?                                             \
	( ( 0x56 == ((U8*)s)[2] ) ? 3 : 0 )                                 \
    : ( ( 0x43 == ((U8*)s)[1] ) && ( 0x72 == ((U8*)s)[2] ) ) ? 3 : 0 )      \
: ( ( ( 0xCE == ((U8*)s)[0] ) && ( 0x41 == ((U8*)s)[1] ) ) && ( 0x41 == ((U8*)s)[2] ) ) ? 3 : 0 )

/*** GENERATED CODE ***/
#define is_HORIZWS_cp_high(cp)                                              \
( 0x1680 == cp || ( 0x1680 < cp &&                                          \
( ( 0x2000 <= cp && cp <= 0x200A ) || ( 0x200A < cp &&                      \
( 0x202F == cp || ( 0x202F < cp &&                                          \
( 0x205F == cp || 0x3000 == cp ) ) ) ) ) ) )

/*
	VERTWS: Vertical Whitespace: \v \V

	\p{VertSpace}
*/
/*** GENERATED CODE ***/
#define is_VERTWS_high(s)                                                   \
( ( ( ( 0xCA == ((U8*)s)[0] ) && ( 0x42 == ((U8*)s)[1] ) ) && ( 0x49 == ((U8*)s)[2] || 0x4A == ((U8*)s)[2] ) ) ? 3 : 0 )

/*** GENERATED CODE ***/
#define is_VERTWS_cp_high(cp)                                               \
( 0x2028 == cp || 0x2029 == cp )

/*
	XDIGIT: Hexadecimal digits

	\p{XDigit}
*/
/*** GENERATED CODE ***/
#define is_XDIGIT_high(s)                                                   \
( ( ( 0xDD == ((U8*)s)[0] ) && ( 0x72 == ((U8*)s)[1] ) ) ? ( ( 0x66 == ((U8*)s)[2] ) ?\
	    ( ( ( ( ((U8*)s)[3] & 0xF7 ) == 0x57 ) || ( ( ((U8*)s)[3] & 0xFE ) == 0x58 ) || ( ( ((U8*)s)[3] & 0xFE ) == 0x62 ) || ( ( ((U8*)s)[3] & 0xFC ) == 0x64 ) ) ? 4 : 0 )\
	: ( ( 0x67 == ((U8*)s)[2] || 0x68 == ((U8*)s)[2] ) && ( 0x42 <= ((U8*)s)[3] && ((U8*)s)[3] <= 0x47 ) ) ? 4 : 0 ) : 0 )

/*** GENERATED CODE ***/
#define is_XDIGIT_cp_high(cp)                                               \
( ( 0xFF10 <= cp && cp <= 0xFF19 ) || ( 0xFF19 < cp &&                      \
( ( 0xFF21 <= cp && cp <= 0xFF26 ) || ( 0xFF41 <= cp && cp <= 0xFF46 ) ) ) )

/*
	XPERLSPACE: \p{XPerlSpace}

	\p{XPerlSpace}
*/
/*** GENERATED CODE ***/
#define is_XPERLSPACE_high(s)                                               \
( ( 0xBD == ((U8*)s)[0] ) ?                                                 \
    ( ( ( 0x62 == ((U8*)s)[1] ) && ( 0x41 == ((U8*)s)[2] ) ) ? 3 : 0 )      \
: ( 0xCA == ((U8*)s)[0] ) ?                                                 \
    ( ( 0x41 == ((U8*)s)[1] ) ?                                             \
	( ( ( 0x41 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x4A ) || 0x51 == ((U8*)s)[2] ) ? 3 : 0 )\
    : ( 0x42 == ((U8*)s)[1] ) ?                                             \
	( ( ( 0x49 == ((U8*)s)[2] || 0x4A == ((U8*)s)[2] ) || 0x56 == ((U8*)s)[2] ) ? 3 : 0 )\
    : ( ( 0x43 == ((U8*)s)[1] ) && ( 0x72 == ((U8*)s)[2] ) ) ? 3 : 0 )      \
: ( ( ( 0xCE == ((U8*)s)[0] ) && ( 0x41 == ((U8*)s)[1] ) ) && ( 0x41 == ((U8*)s)[2] ) ) ? 3 : 0 )

/*** GENERATED CODE ***/
#define is_XPERLSPACE_cp_high(cp)                                           \
( 0x1680 == cp || ( 0x1680 < cp &&                                          \
( ( 0x2000 <= cp && cp <= 0x200A ) || ( 0x200A < cp &&                      \
( 0x2028 == cp || ( 0x2028 < cp &&                                          \
( 0x2029 == cp || ( 0x2029 < cp &&                                          \
( 0x202F == cp || ( 0x202F < cp &&                                          \
( 0x205F == cp || 0x3000 == cp ) ) ) ) ) ) ) ) ) ) )

/*
	REPLACEMENT: Unicode REPLACEMENT CHARACTER

	0xFFFD
*/
/*** GENERATED CODE ***/
#define is_REPLACEMENT_utf8_safe(s,e)                                       \
( ( ( ( ( ( ((e) - (s)) >= 4 ) && ( 0xDD == ((U8*)s)[0] ) ) && ( 0x72 == ((U8*)s)[1] ) ) && ( 0x72 == ((U8*)s)[2] ) ) && ( 0x70 == ((U8*)s)[3] ) ) ? 4 : 0 )

/*
	NONCHAR: Non character code points

	\p{_Perl_Nchar}
*/
/*** GENERATED CODE ***/
#define is_NONCHAR_utf8(s)                                                  \
( ( 0xDD == ((U8*)s)[0] ) ?                                                 \
    ( ( 0x72 == ((U8*)s)[1] ) ?                                             \
	( ( 0x55 == ((U8*)s)[2] ) ?                                         \
	    ( ( ( 0x57 <= ((U8*)s)[3] && ((U8*)s)[3] <= 0x59 ) || 0x5F == ((U8*)s)[3] || ( 0x62 <= ((U8*)s)[3] && ((U8*)s)[3] <= 0x6A ) || ( 0x70 <= ((U8*)s)[3] && ((U8*)s)[3] <= 0x72 ) ) ? 4 : 0 )\
	: ( 0x56 == ((U8*)s)[2] ) ?                                         \
	    ( ( ( 0x41 <= ((U8*)s)[3] && ((U8*)s)[3] <= 0x4A ) || ( 0x51 <= ((U8*)s)[3] && ((U8*)s)[3] <= 0x56 ) ) ? 4 : 0 )\
	: ( ( 0x72 == ((U8*)s)[2] ) && ( 0x71 == ((U8*)s)[3] || 0x72 == ((U8*)s)[3] ) ) ? 4 : 0 )\
    : 0 )                                                                   \
: ( 0xDF == ((U8*)s)[0] || 0xEA == ((U8*)s)[0] || 0xEC == ((U8*)s)[0] ) ?   \
    ( ( ( ( 0x72 == ((U8*)s)[1] ) && ( 0x72 == ((U8*)s)[2] ) ) && ( 0x71 == ((U8*)s)[3] || 0x72 == ((U8*)s)[3] ) ) ? 4 : 0 )\
: ( 0xED == ((U8*)s)[0] ) ?                                                 \
    ( ( ( ( ( ((U8*)s)[1] == 0x4A || ((U8*)s)[1] == 0x52 || ( ( ((U8*)s)[1] & 0xFD ) == 0x54 ) || ((U8*)s)[1] == 0x58 || ((U8*)s)[1] == 0x5F || ((U8*)s)[1] == 0x63 || ( ( ((U8*)s)[1] & 0xFD ) == 0x65 ) || ((U8*)s)[1] == 0x69 || ( ( ((U8*)s)[1] & 0xFD ) == 0x70 ) ) && ( 0x72 == ((U8*)s)[2] ) ) && ( 0x72 == ((U8*)s)[3] ) ) && ( 0x71 == ((U8*)s)[4] || 0x72 == ((U8*)s)[4] ) ) ? 5 : 0 )\
: ( ( ( ( ( 0xEE == ((U8*)s)[0] ) && ( 0x42 == ((U8*)s)[1] ) ) && ( 0x72 == ((U8*)s)[2] ) ) && ( 0x72 == ((U8*)s)[3] ) ) && ( 0x71 == ((U8*)s)[4] || 0x72 == ((U8*)s)[4] ) ) ? 5 : 0 )

/*
	SURROGATE: Surrogate characters

	\p{_Perl_Surrogate}
*/
/*** GENERATED CODE ***/
#define is_SURROGATE_utf8(s)                                                \
( ( ( ( ( 0xDD == ((U8*)s)[0] ) && ( ( ((U8*)s)[1] & 0xFE ) == 0x64 ) ) && ( ( 0x41 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x4A ) || ( 0x51 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x59 ) || 0x5F == ((U8*)s)[2] || ( 0x62 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x6A ) || ( 0x70 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x72 ) ) ) && ( ( 0x41 <= ((U8*)s)[3] && ((U8*)s)[3] <= 0x4A ) || ( 0x51 <= ((U8*)s)[3] && ((U8*)s)[3] <= 0x59 ) || 0x5F == ((U8*)s)[3] || ( 0x62 <= ((U8*)s)[3] && ((U8*)s)[3] <= 0x6A ) || ( 0x70 <= ((U8*)s)[3] && ((U8*)s)[3] <= 0x72 ) ) ) ? 4 : 0 )

/*
	UTF8_CHAR: Matches legal UTF-EBCDIC encoded characters from 2 through 3 bytes

	0xA0 - 0x3FFF
*/
/*** GENERATED CODE ***/
#define is_UTF8_CHAR_utf8_no_length_checks(s)                               \
( ( 0x78 == ((U8*)s)[0] || 0x80 == ((U8*)s)[0] || ( 0x8A <= ((U8*)s)[0] && ((U8*)s)[0] <= 0x90 ) || ( 0x9A <= ((U8*)s)[0] && ((U8*)s)[0] <= 0xA0 ) || ( 0xAA <= ((U8*)s)[0] && ((U8*)s)[0] <= 0xAF ) || ( 0xB1 <= ((U8*)s)[0] && ((U8*)s)[0] <= 0xB5 ) ) ?\
    ( ( ( 0x41 <= ((U8*)s)[1] && ((U8*)s)[1] <= 0x4A ) || ( 0x51 <= ((U8*)s)[1] && ((U8*)s)[1] <= 0x59 ) || 0x5F == ((U8*)s)[1] || ( 0x62 <= ((U8*)s)[1] && ((U8*)s)[1] <= 0x6A ) || ( 0x70 <= ((U8*)s)[1] && ((U8*)s)[1] <= 0x72 ) ) ? 2 : 0 )\
: ( ( ( ((U8*)s)[0] == 0xB7 || ( ( ((U8*)s)[0] & 0xFE ) == 0xB8 ) || ( ( ((U8*)s)[0] & 0xFC ) == 0xBC ) || ( ( ((U8*)s)[0] & 0xEE ) == 0xCA ) || ( ( ((U8*)s)[0] & 0xFC ) == 0xCC ) ) && ( ( 0x41 <= ((U8*)s)[1] && ((U8*)s)[1] <= 0x4A ) || ( 0x51 <= ((U8*)s)[1] && ((U8*)s)[1] <= 0x59 ) || 0x5F == ((U8*)s)[1] || ( 0x62 <= ((U8*)s)[1] && ((U8*)s)[1] <= 0x6A ) || ( 0x70 <= ((U8*)s)[1] && ((U8*)s)[1] <= 0x72 ) ) ) && ( ( 0x41 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x4A ) || ( 0x51 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x59 ) || 0x5F == ((U8*)s)[2] || ( 0x62 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x6A ) || ( 0x70 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x72 ) ) ) ? 3 : 0 )

/*
	QUOTEMETA: Meta-characters that \Q should quote

	\p{_Perl_Quotemeta}
*/
/*** GENERATED CODE ***/
#define is_QUOTEMETA_high_part0(s)                                          \
( ( 0x51 == ((U8*)s)[1] ) ?                                                 \
	( ( 0x72 == ((U8*)s)[2] ) ? 3 : 0 )                                 \
    : ( ( 0x52 == ((U8*)s)[1] ) && ( 0x41 == ((U8*)s)[2] ) ) ? 3 : 0 )


/*** GENERATED CODE ***/
#define is_QUOTEMETA_high_part1(s)                                          \
( ( 0xBD == ((U8*)s)[0] ) ?                                                 \
    ( ( 0x62 == ((U8*)s)[1] ) ?                                             \
	( ( 0x41 == ((U8*)s)[2] ) ? 3 : 0 )                                 \
    : ( ( 0x70 == ((U8*)s)[1] ) && ( ( ((U8*)s)[2] & 0xFE ) == 0x62 ) ) ? 3 : 0 )\
: ( 0xBE == ((U8*)s)[0] ) ?                                                 \
    ( ( ( 0x41 == ((U8*)s)[1] ) && ( 0x52 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x55 ) ) ? 3 : 0 )\
: ( 0xCA == ((U8*)s)[0] ) ?                                                 \
    ( ( 0x41 == ((U8*)s)[1] || ( 0x54 <= ((U8*)s)[1] && ((U8*)s)[1] <= 0x59 ) || 0x5F == ((U8*)s)[1] || ( 0x62 <= ((U8*)s)[1] && ((U8*)s)[1] <= 0x6A ) || ( 0x70 <= ((U8*)s)[1] && ((U8*)s)[1] <= 0x72 ) ) ?\
	( ( ( 0x41 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x4A ) || ( 0x51 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x59 ) || 0x5F == ((U8*)s)[2] || ( 0x62 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x6A ) || ( 0x70 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x72 ) ) ? 3 : 0 )\
    : ( 0x42 == ((U8*)s)[1] ) ?                                             \
	( ( ( 0x41 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x4A ) || ( 0x51 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x59 ) || 0x5F == ((U8*)s)[2] || ( 0x62 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x6A ) || ( ((U8*)s)[2] & 0xFE ) == 0x70 ) ? 3 : 0 )\
    : ( 0x43 == ((U8*)s)[1] ) ?                                             \
	( ( ( 0x42 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x4A ) || ( 0x51 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x59 ) || 0x5F == ((U8*)s)[2] || ( 0x63 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x6A ) || ( 0x70 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x72 ) ) ? 3 : 0 )\
    : ( 0x44 == ((U8*)s)[1] ) ?                                             \
	( ( ( 0x41 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x4A ) || ( 0x51 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x56 ) ) ? 3 : 0 )\
    : ( ( 0x53 == ((U8*)s)[1] ) && ( ( 0x57 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x59 ) || 0x5F == ((U8*)s)[2] || ( 0x62 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x6A ) || ( 0x70 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x72 ) ) ) ? 3 : 0 )\
: ( 0xCB == ((U8*)s)[0] ) ?                                                 \
    ( ( ( 0x41 <= ((U8*)s)[1] && ((U8*)s)[1] <= 0x43 ) || ( 0x49 == ((U8*)s)[1] || 0x4A == ((U8*)s)[1] ) || ( 0x51 <= ((U8*)s)[1] && ((U8*)s)[1] <= 0x59 ) || 0x5F == ((U8*)s)[1] || ( 0x62 <= ((U8*)s)[1] && ((U8*)s)[1] <= 0x68 ) || ( 0x70 <= ((U8*)s)[1] && ((U8*)s)[1] <= 0x72 ) ) ?\
	( ( ( 0x41 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x4A ) || ( 0x51 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x59 ) || 0x5F == ((U8*)s)[2] || ( 0x62 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x6A ) || ( 0x70 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x72 ) ) ? 3 : 0 )\
    : ( 0x69 == ((U8*)s)[1] ) ?                                             \
	( ( ( 0x41 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x4A ) || ( 0x51 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x59 ) || 0x5F == ((U8*)s)[2] || ( ((U8*)s)[2] & 0xFE ) == 0x62 ) ? 3 : 0 )\
    : ( ( 0x6A == ((U8*)s)[1] ) && ( ( 0x62 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x6A ) || ( 0x70 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x72 ) ) ) ? 3 : 0 )\
: ( 0xCC == ((U8*)s)[0] ) ?                                                 \
    ( ( ( ( 0x41 <= ((U8*)s)[1] && ((U8*)s)[1] <= 0x4A ) || ( 0x51 <= ((U8*)s)[1] && ((U8*)s)[1] <= 0x59 ) || 0x5F == ((U8*)s)[1] || ( 0x62 <= ((U8*)s)[1] && ((U8*)s)[1] <= 0x6A ) || ( 0x70 <= ((U8*)s)[1] && ((U8*)s)[1] <= 0x72 ) ) && ( ( 0x41 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x4A ) || ( 0x51 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x59 ) || 0x5F == ((U8*)s)[2] || ( 0x62 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x6A ) || ( 0x70 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x72 ) ) ) ? 3 : 0 )\
: ( 0xCD == ((U8*)s)[0] ) ?                                                 \
    ( ( ( ( ( ((U8*)s)[1] & 0xF7 ) == 0x57 ) || ( ( ((U8*)s)[1] & 0xFE ) == 0x58 ) ) && ( ( 0x41 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x4A ) || ( 0x51 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x59 ) || 0x5F == ((U8*)s)[2] || ( 0x62 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x6A ) || ( 0x70 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x72 ) ) ) ? 3 : 0 )\
: ( 0xCE == ((U8*)s)[0] ) ?                                                 \
    ( ( 0x41 == ((U8*)s)[1] ) ?                                             \
	( ( ( 0x41 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x44 ) || ( 0x49 == ((U8*)s)[2] || 0x4A == ((U8*)s)[2] ) || ( 0x51 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x59 ) || 0x5F == ((U8*)s)[2] || ( 0x62 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x6A ) || ( 0x70 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x72 ) ) ? 3 : 0 )\
    : ( 0x42 == ((U8*)s)[1] ) ?                                             \
	( ( 0x41 == ((U8*)s)[2] || 0x57 == ((U8*)s)[2] ) ? 3 : 0 )          \
    : ( ( 0x52 == ((U8*)s)[1] ) && ( 0x45 == ((U8*)s)[2] ) ) ? 3 : 0 )      \
: ( 0xDD == ((U8*)s)[0] ) ?                                                 \
    ( ( 0x72 == ((U8*)s)[1] ) ?                                             \
	( ( 0x4A == ((U8*)s)[2] ) ?                                         \
	    ( ( 0x71 == ((U8*)s)[3] || 0x72 == ((U8*)s)[3] ) ? 4 : 0 )      \
	: ( 0x57 == ((U8*)s)[2] ) ?                                         \
	    ( ( ( 0x41 <= ((U8*)s)[3] && ((U8*)s)[3] <= 0x4A ) || ( 0x51 <= ((U8*)s)[3] && ((U8*)s)[3] <= 0x56 ) ) ? 4 : 0 )\
	: ( 0x59 == ((U8*)s)[2] ) ?                                         \
	    ( ( ( ((U8*)s)[3] & 0xFE ) == 0x46 ) ? 4 : 0 )                  \
	: ( 0x65 == ((U8*)s)[2] ) ?                                         \
	    ( ( 0x72 == ((U8*)s)[3] ) ? 4 : 0 )                             \
	: ( 0x70 == ((U8*)s)[2] ) ?                                         \
	    ( ( 0x41 == ((U8*)s)[3] ) ? 4 : 0 )                             \
	: ( ( 0x72 == ((U8*)s)[2] ) && ( ( 0x57 <= ((U8*)s)[3] && ((U8*)s)[3] <= 0x59 ) || 0x5F == ((U8*)s)[3] || ( 0x62 <= ((U8*)s)[3] && ((U8*)s)[3] <= 0x66 ) ) ) ? 4 : 0 )\
    : 0 )                                                                   \
: ( 0xDF == ((U8*)s)[0] ) ?                                                 \
    ( ( 0x56 == ((U8*)s)[1] ) ?                                             \
	( ( ( 0x46 == ((U8*)s)[2] ) && ( 0x41 <= ((U8*)s)[3] && ((U8*)s)[3] <= 0x44 ) ) ? 4 : 0 )\
    : ( ( ( 0x62 == ((U8*)s)[1] ) && ( 0x52 == ((U8*)s)[2] ) ) && ( 0x5F == ((U8*)s)[3] || ( 0x62 <= ((U8*)s)[3] && ((U8*)s)[3] <= 0x68 ) ) ) ? 4 : 0 )\
: ( ( ( ( ( 0xED == ((U8*)s)[0] ) && ( 0x6A == ((U8*)s)[1] ) ) && ( 0x41 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x44 ) ) && ( ( 0x41 <= ((U8*)s)[3] && ((U8*)s)[3] <= 0x4A ) || ( 0x51 <= ((U8*)s)[3] && ((U8*)s)[3] <= 0x59 ) || 0x5F == ((U8*)s)[3] || ( 0x62 <= ((U8*)s)[3] && ((U8*)s)[3] <= 0x6A ) || ( 0x70 <= ((U8*)s)[3] && ((U8*)s)[3] <= 0x72 ) ) ) && ( ( 0x41 <= ((U8*)s)[4] && ((U8*)s)[4] <= 0x4A ) || ( 0x51 <= ((U8*)s)[4] && ((U8*)s)[4] <= 0x59 ) || 0x5F == ((U8*)s)[4] || ( 0x62 <= ((U8*)s)[4] && ((U8*)s)[4] <= 0x6A ) || ( 0x70 <= ((U8*)s)[4] && ((U8*)s)[4] <= 0x72 ) ) ) ? 5 : 0 )


/*** GENERATED CODE ***/
#define is_QUOTEMETA_high(s)                                                \
( ( 0xAF == ((U8*)s)[0] ) ?                                                 \
    ( ( 0x56 == ((U8*)s)[1] ) ? 2 : 0 )                                     \
: ( 0xB7 == ((U8*)s)[0] ) ?                                                 \
    ( ( ( 0x57 == ((U8*)s)[1] ) && ( 0x6A == ((U8*)s)[2] ) ) ? 3 : 0 )      \
: ( 0xBC == ((U8*)s)[0] ) ? is_QUOTEMETA_high_part0(s) : is_QUOTEMETA_high_part1(s) )

/*
	MULTI_CHAR_FOLD: multi-char strings that are folded to by a single character

	&regcharclass_multi_char_folds::multi_char_folds(1)
*/
/*** GENERATED CODE ***/
#define is_MULTI_CHAR_FOLD_utf8_safe_part0(s,e)                             \
( ( 0x81 == ((U8*)s)[0] ) ?                                                 \
	( ( ( 0xAA == ((U8*)s)[1] ) && ( 0x71 == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0x86 == ((U8*)s)[0] ) ?                                             \
	( ( 0x86 == ((U8*)s)[1] ) ?                                         \
	    ( ( 0x89 == ((U8*)s)[2] || 0x93 == ((U8*)s)[2] ) ? 3 : 2 )      \
	: ( 0x89 == ((U8*)s)[1] || 0x93 == ((U8*)s)[1] ) ? 2 : 0 )          \
    : ( 0x88 == ((U8*)s)[0] ) ?                                             \
	( ( ( 0xAE == ((U8*)s)[1] ) && ( 0x58 == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0x89 == ((U8*)s)[0] ) ?                                             \
	( ( ( 0xAD == ((U8*)s)[1] ) && ( 0x48 == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0x8E == ((U8*)s)[0] ) ?                                             \
	( ( ( ( 0x72 == ((U8*)s)[1] ) && ( 0x8E == ((U8*)s)[2] ) ) && ( 0x72 == ((U8*)s)[3] ) ) ? 4 : 0 )\
    : ( 0x91 == ((U8*)s)[0] ) ?                                             \
	( ( ( 0xAD == ((U8*)s)[1] ) && ( 0x53 == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0xA2 == ((U8*)s)[0] ) ?                                             \
	( ( ( ((U8*)s)[1] & 0xFE ) == 0xA2 ) ? 2 : 0 )                      \
    : ( 0xA3 == ((U8*)s)[0] ) ?                                             \
	( ( ( 0xAD == ((U8*)s)[1] ) && ( 0x49 == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0xA6 == ((U8*)s)[0] || 0xA8 == ((U8*)s)[0] ) ?                      \
	( ( ( 0xAD == ((U8*)s)[1] ) && ( 0x51 == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0xAA == ((U8*)s)[0] ) ?                                             \
	( ( ( 0x6A == ((U8*)s)[1] ) && ( 0x95 == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0xB3 == ((U8*)s)[0] ) ?                                             \
	( ( 0x53 == ((U8*)s)[1] || 0x55 == ((U8*)s)[1] ) ?                  \
	    ( ( ( 0xB3 == ((U8*)s)[2] ) && ( 0x67 == ((U8*)s)[3] ) ) ? 4 : 0 )\
	: ( 0x58 == ((U8*)s)[1] || 0x65 == ((U8*)s)[1] ) ?                  \
	    ( ( 0xAF == ((U8*)s)[2] ) ?                                     \
		( ( 0x43 == ((U8*)s)[3] ) ? 4 : 0 )                         \
	    : ( ( 0xB3 == ((U8*)s)[2] ) && ( 0x67 == ((U8*)s)[3] ) ) ? 4 : 0 )\
	: ( ( ( 0x67 == ((U8*)s)[1] ) && ( 0xAF == ((U8*)s)[2] ) ) && ( 0x43 == ((U8*)s)[3] ) ) ? 4 : 0 )\
    : ( 0xB4 == ((U8*)s)[0] ) ?                                             \
	( ( 0x42 == ((U8*)s)[1] ) ?                                         \
	    ( ( ( 0xAD == ((U8*)s)[2] ) && ( 0x5F == ((U8*)s)[3] ) ) ? 4 : 0 )\
	: ( 0x46 == ((U8*)s)[1] ) ?                                         \
	    ( ( 0xAD == ((U8*)s)[2] ) ?                                     \
		( ( 0x5F == ((U8*)s)[3] ) ? 4 : 0 )                         \
	    : ( ( 0xAF == ((U8*)s)[2] ) && ( 0x43 == ((U8*)s)[3] ) ) ? 4 : 0 )\
	: ( 0x4A == ((U8*)s)[1] ) ?                                         \
	    ( ( 0xAF == ((U8*)s)[2] ) ?                                     \
		( ( 0x43 == ((U8*)s)[3] ) ? 4 : 0 )                         \
	    : ( ( 0xB3 == ((U8*)s)[2] ) && ( 0x67 == ((U8*)s)[3] ) ) ? 4 : 0 )\
	: ( ( ( 0x55 == ((U8*)s)[1] ) && ( 0xB3 == ((U8*)s)[2] ) ) && ( 0x67 == ((U8*)s)[3] ) ) ? 4 : 0 )\
    : ( 0xBF == ((U8*)s)[0] ) ?                                             \
	( ( ( ((U8*)s)[1] & 0xFE ) == 0x66 ) ?                              \
	    ( ( ( ( 0x41 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x48 ) && ( 0xB3 == ((U8*)s)[3] ) ) && ( 0x67 == ((U8*)s)[4] ) ) ? 5 : 0 )\
	: ( ( ( ( 0x69 == ((U8*)s)[1] ) && ( ( 0x41 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x48 ) || 0x57 == ((U8*)s)[2] || 0x62 == ((U8*)s)[2] || 0x6A == ((U8*)s)[2] ) ) && ( 0xB3 == ((U8*)s)[3] ) ) && ( 0x67 == ((U8*)s)[4] ) ) ? 5 : 0 )\
    : 0 )


/*** GENERATED CODE ***/
#define is_MULTI_CHAR_FOLD_utf8_safe_part1(s,e)                             \
( ((e)-(s) > 3) ?                                                           \
    ( ( 0x81 == ((U8*)s)[0] ) ?                                             \
	( ( ( 0xAA == ((U8*)s)[1] ) && ( 0x71 == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0x86 == ((U8*)s)[0] ) ?                                             \
	( ( 0x86 == ((U8*)s)[1] ) ?                                         \
	    ( ( 0x89 == ((U8*)s)[2] || 0x93 == ((U8*)s)[2] ) ? 3 : 2 )      \
	: ( 0x89 == ((U8*)s)[1] || 0x93 == ((U8*)s)[1] ) ? 2 : 0 )          \
    : ( 0x88 == ((U8*)s)[0] ) ?                                             \
	( ( ( 0xAE == ((U8*)s)[1] ) && ( 0x58 == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0x89 == ((U8*)s)[0] ) ?                                             \
	( ( ( 0xAD == ((U8*)s)[1] ) && ( 0x48 == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0x8E == ((U8*)s)[0] ) ?                                             \
	( ( ( ( 0x72 == ((U8*)s)[1] ) && ( 0x8E == ((U8*)s)[2] ) ) && ( 0x72 == ((U8*)s)[3] ) ) ? 4 : 0 )\
    : ( 0x91 == ((U8*)s)[0] ) ?                                             \
	( ( ( 0xAD == ((U8*)s)[1] ) && ( 0x53 == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0xA2 == ((U8*)s)[0] ) ?                                             \
	( ( ( ((U8*)s)[1] & 0xFE ) == 0xA2 ) ? 2 : 0 )                      \
    : ( 0xA3 == ((U8*)s)[0] ) ?                                             \
	( ( ( 0xAD == ((U8*)s)[1] ) && ( 0x49 == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0xA6 == ((U8*)s)[0] || 0xA8 == ((U8*)s)[0] ) ?                      \
	( ( ( 0xAD == ((U8*)s)[1] ) && ( 0x51 == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0xAA == ((U8*)s)[0] ) ?                                             \
	( ( ( 0x6A == ((U8*)s)[1] ) && ( 0x95 == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0xB3 == ((U8*)s)[0] ) ?                                             \
	( ( 0x53 == ((U8*)s)[1] || 0x55 == ((U8*)s)[1] ) ?                  \
	    ( ( ( 0xB3 == ((U8*)s)[2] ) && ( 0x67 == ((U8*)s)[3] ) ) ? 4 : 0 )\
	: ( 0x58 == ((U8*)s)[1] || 0x65 == ((U8*)s)[1] ) ?                  \
	    ( ( 0xAF == ((U8*)s)[2] ) ?                                     \
		( ( 0x43 == ((U8*)s)[3] ) ? 4 : 0 )                         \
	    : ( ( 0xB3 == ((U8*)s)[2] ) && ( 0x67 == ((U8*)s)[3] ) ) ? 4 : 0 )\
	: ( ( ( 0x67 == ((U8*)s)[1] ) && ( 0xAF == ((U8*)s)[2] ) ) && ( 0x43 == ((U8*)s)[3] ) ) ? 4 : 0 )\
    : ( 0xB4 == ((U8*)s)[0] ) ?                                             \
	( ( 0x42 == ((U8*)s)[1] ) ?                                         \
	    ( ( ( 0xAD == ((U8*)s)[2] ) && ( 0x5F == ((U8*)s)[3] ) ) ? 4 : 0 )\
	: ( 0x46 == ((U8*)s)[1] ) ?                                         \
	    ( ( 0xAD == ((U8*)s)[2] ) ?                                     \
		( ( 0x5F == ((U8*)s)[3] ) ? 4 : 0 )                         \
	    : ( ( 0xAF == ((U8*)s)[2] ) && ( 0x43 == ((U8*)s)[3] ) ) ? 4 : 0 )\
	: ( 0x4A == ((U8*)s)[1] ) ?                                         \
	    ( ( 0xAF == ((U8*)s)[2] ) ?                                     \
		( ( 0x43 == ((U8*)s)[3] ) ? 4 : 0 )                         \
	    : ( ( 0xB3 == ((U8*)s)[2] ) && ( 0x67 == ((U8*)s)[3] ) ) ? 4 : 0 )\
	: ( ( ( 0x55 == ((U8*)s)[1] ) && ( 0xB3 == ((U8*)s)[2] ) ) && ( 0x67 == ((U8*)s)[3] ) ) ? 4 : 0 )\
    : 0 )                                                                   \
: ((e)-(s) > 2) ?                                                           \
    ( ( 0x81 == ((U8*)s)[0] ) ?                                             \
	( ( ( 0xAA == ((U8*)s)[1] ) && ( 0x71 == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0x86 == ((U8*)s)[0] ) ?                                             \
	( ( 0x86 == ((U8*)s)[1] ) ?                                         \
	    ( ( 0x89 == ((U8*)s)[2] || 0x93 == ((U8*)s)[2] ) ? 3 : 2 )      \
	: ( 0x89 == ((U8*)s)[1] || 0x93 == ((U8*)s)[1] ) ? 2 : 0 )          \
    : ( 0x88 == ((U8*)s)[0] ) ?                                             \
	( ( ( 0xAE == ((U8*)s)[1] ) && ( 0x58 == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0x89 == ((U8*)s)[0] ) ?                                             \
	( ( ( 0xAD == ((U8*)s)[1] ) && ( 0x48 == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0x91 == ((U8*)s)[0] ) ?                                             \
	( ( ( 0xAD == ((U8*)s)[1] ) && ( 0x53 == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0xA2 == ((U8*)s)[0] ) ?                                             \
	( ( ( ((U8*)s)[1] & 0xFE ) == 0xA2 ) ? 2 : 0 )                      \
    : ( 0xA3 == ((U8*)s)[0] ) ?                                             \
	( ( ( 0xAD == ((U8*)s)[1] ) && ( 0x49 == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0xA6 == ((U8*)s)[0] || 0xA8 == ((U8*)s)[0] ) ?                      \
	( ( ( 0xAD == ((U8*)s)[1] ) && ( 0x51 == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( ( ( 0xAA == ((U8*)s)[0] ) && ( 0x6A == ((U8*)s)[1] ) ) && ( 0x95 == ((U8*)s)[2] ) ) ? 3 : 0 )\
: ((e)-(s) > 1) ?                                                           \
    ( ( 0x86 == ((U8*)s)[0] ) ?                                             \
	( ( 0x86 == ((U8*)s)[1] || 0x89 == ((U8*)s)[1] || 0x93 == ((U8*)s)[1] ) ? 2 : 0 )\
    : ( ( 0xA2 == ((U8*)s)[0] ) && ( ( ((U8*)s)[1] & 0xFE ) == 0xA2 ) ) ? 2 : 0 )\
: 0 )


/*** GENERATED CODE ***/
#define is_MULTI_CHAR_FOLD_utf8_safe(s,e)                                   \
( ((e)-(s) > 5) ?                                                           \
    ( ( 0x81 == ((U8*)s)[0] ) ?                                             \
	( ( ( 0xAA == ((U8*)s)[1] ) && ( 0x71 == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0x86 == ((U8*)s)[0] ) ?                                             \
	( ( 0x86 == ((U8*)s)[1] ) ?                                         \
	    ( ( 0x89 == ((U8*)s)[2] || 0x93 == ((U8*)s)[2] ) ? 3 : 2 )      \
	: ( 0x89 == ((U8*)s)[1] || 0x93 == ((U8*)s)[1] ) ? 2 : 0 )          \
    : ( 0x88 == ((U8*)s)[0] ) ?                                             \
	( ( ( 0xAE == ((U8*)s)[1] ) && ( 0x58 == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0x89 == ((U8*)s)[0] ) ?                                             \
	( ( ( 0xAD == ((U8*)s)[1] ) && ( 0x48 == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0x8E == ((U8*)s)[0] ) ?                                             \
	( ( ( ( 0x72 == ((U8*)s)[1] ) && ( 0x8E == ((U8*)s)[2] ) ) && ( 0x72 == ((U8*)s)[3] ) ) ? 4 : 0 )\
    : ( 0x91 == ((U8*)s)[0] ) ?                                             \
	( ( ( 0xAD == ((U8*)s)[1] ) && ( 0x53 == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0xA2 == ((U8*)s)[0] ) ?                                             \
	( ( ( ((U8*)s)[1] & 0xFE ) == 0xA2 ) ? 2 : 0 )                      \
    : ( 0xA3 == ((U8*)s)[0] ) ?                                             \
	( ( ( 0xAD == ((U8*)s)[1] ) && ( 0x49 == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0xA6 == ((U8*)s)[0] || 0xA8 == ((U8*)s)[0] ) ?                      \
	( ( ( 0xAD == ((U8*)s)[1] ) && ( 0x51 == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0xAA == ((U8*)s)[0] ) ?                                             \
	( ( ( 0x6A == ((U8*)s)[1] ) && ( 0x95 == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : ( 0xB3 == ((U8*)s)[0] ) ?                                             \
	( ( 0x53 == ((U8*)s)[1] || 0x55 == ((U8*)s)[1] ) ?                  \
	    ( ( ( 0xB3 == ((U8*)s)[2] ) && ( 0x67 == ((U8*)s)[3] ) ) ? 4 : 0 )\
	: ( 0x58 == ((U8*)s)[1] || 0x65 == ((U8*)s)[1] ) ?                  \
	    ( ( 0xAF == ((U8*)s)[2] ) ?                                     \
		( ( 0x43 == ((U8*)s)[3] ) ?                                 \
		    ( ( ( 0xB3 == ((U8*)s)[4] ) && ( 0x67 == ((U8*)s)[5] ) ) ? 6 : 4 )\
		: 0 )                                                       \
	    : ( ( 0xB3 == ((U8*)s)[2] ) && ( 0x67 == ((U8*)s)[3] ) ) ? 4 : 0 )\
	: ( 0x67 == ((U8*)s)[1] ) ?                                         \
	    ( ( 0xAD == ((U8*)s)[2] ) ?                                     \
		( ( 0x49 == ((U8*)s)[3] ) ?                                 \
		    ( ( 0xAD == ((U8*)s)[4] ) ?                             \
			( ( 0x41 == ((U8*)s)[5] || 0x42 == ((U8*)s)[5] ) ? 6 : 0 )\
		    : ( ( 0xAF == ((U8*)s)[4] ) && ( 0x43 == ((U8*)s)[5] ) ) ? 6 : 0 )\
		: 0 )                                                       \
	    : ( ( 0xAF == ((U8*)s)[2] ) && ( 0x43 == ((U8*)s)[3] ) ) ? 4 : 0 )\
	: 0 )                                                               \
    : ( 0xB4 == ((U8*)s)[0] ) ?                                             \
	( ( 0x42 == ((U8*)s)[1] ) ?                                         \
	    ( ( ( 0xAD == ((U8*)s)[2] ) && ( 0x5F == ((U8*)s)[3] ) ) ? 4 : 0 )\
	: ( 0x46 == ((U8*)s)[1] ) ?                                         \
	    ( ( 0xAD == ((U8*)s)[2] ) ?                                     \
		( ( 0x49 == ((U8*)s)[3] ) ?                                 \
		    ( ( 0xAD == ((U8*)s)[4] ) ?                             \
			( ( 0x41 == ((U8*)s)[5] || 0x42 == ((U8*)s)[5] ) ? 6 : 0 )\
		    : ( ( 0xAF == ((U8*)s)[4] ) && ( 0x43 == ((U8*)s)[5] ) ) ? 6 : 0 )\
		: ( 0x5F == ((U8*)s)[3] ) ?                                 \
		    ( ( 0xAD == ((U8*)s)[4] ) ?                             \
			( ( 0x41 == ((U8*)s)[5] || 0x42 == ((U8*)s)[5] ) ? 6 : 4 )\
		    : ( ( 0xAF == ((U8*)s)[4] ) && ( 0x43 == ((U8*)s)[5] ) ) ? 6 : 4 )\
		: 0 )                                                       \
	    : ( ( 0xAF == ((U8*)s)[2] ) && ( 0x43 == ((U8*)s)[3] ) ) ? 4 : 0 )\
	: ( 0x4A == ((U8*)s)[1] ) ?                                         \
	    ( ( 0xAF == ((U8*)s)[2] ) ?                                     \
		( ( 0x43 == ((U8*)s)[3] ) ?                                 \
		    ( ( ( 0xB3 == ((U8*)s)[4] ) && ( 0x67 == ((U8*)s)[5] ) ) ? 6 : 4 )\
		: 0 )                                                       \
	    : ( ( 0xB3 == ((U8*)s)[2] ) && ( 0x67 == ((U8*)s)[3] ) ) ? 4 : 0 )\
	: ( ( ( 0x55 == ((U8*)s)[1] ) && ( 0xB3 == ((U8*)s)[2] ) ) && ( 0x67 == ((U8*)s)[3] ) ) ? 4 : 0 )\
    : ( 0xB7 == ((U8*)s)[0] ) ?                                             \
	( ( 0x52 == ((U8*)s)[1] ) ?                                         \
	    ( ( 0x46 == ((U8*)s)[2] ) ?                                     \
		( ( ( ( 0xB7 == ((U8*)s)[3] ) && ( 0x53 == ((U8*)s)[4] ) ) && ( 0x43 == ((U8*)s)[5] ) ) ? 6 : 0 )\
	    : ( 0x62 == ((U8*)s)[2] ) ?                                     \
		( ( ( ( 0xB7 == ((U8*)s)[3] ) && ( 0x52 == ((U8*)s)[4] ) ) && ( 0x46 == ((U8*)s)[5] || 0x52 == ((U8*)s)[5] || 0x54 == ((U8*)s)[5] || 0x64 == ((U8*)s)[5] ) ) ? 6 : 0 )\
	    : ( ( ( ( 0x71 == ((U8*)s)[2] ) && ( 0xB7 == ((U8*)s)[3] ) ) && ( 0x52 == ((U8*)s)[4] ) ) && ( 0x64 == ((U8*)s)[5] ) ) ? 6 : 0 )\
	: 0 )                                                               \
    : ( 0xBF == ((U8*)s)[0] ) ?                                             \
	( ( ( ((U8*)s)[1] & 0xFE ) == 0x66 ) ?                              \
	    ( ( ( ( 0x41 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x48 ) && ( 0xB3 == ((U8*)s)[3] ) ) && ( 0x67 == ((U8*)s)[4] ) ) ? 5 : 0 )\
	: ( ( ( ( 0x69 == ((U8*)s)[1] ) && ( ( 0x41 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x48 ) || 0x57 == ((U8*)s)[2] || 0x62 == ((U8*)s)[2] || 0x6A == ((U8*)s)[2] ) ) && ( 0xB3 == ((U8*)s)[3] ) ) && ( 0x67 == ((U8*)s)[4] ) ) ? 5 : 0 )\
    : 0 )                                                                   \
: ((e)-(s) > 4) ? is_MULTI_CHAR_FOLD_utf8_safe_part0(s,e) : is_MULTI_CHAR_FOLD_utf8_safe_part1(s,e) )

/*
	MULTI_CHAR_FOLD: multi-char strings that are folded to by a single character

	&regcharclass_multi_char_folds::multi_char_folds(0)
*/
/*** GENERATED CODE ***/
#define is_MULTI_CHAR_FOLD_latin1_safe(s,e)                                 \
( ((e)-(s) > 2) ?                                                           \
    ( ( ( ((U8*)s)[0] & 0xBF ) == 0x86 ) ?                                  \
	( ( ( ((U8*)s)[1] & 0xBF ) == 0x86 ) ?                              \
	    ( ( ( ( ((U8*)s)[2] & 0xBF ) == 0x89 ) || ( ( ((U8*)s)[2] & 0xBF ) == 0x93 ) ) ? 3 : 2 )\
	: ( ( ( ((U8*)s)[1] & 0xBF ) == 0x89 ) || ( ( ((U8*)s)[1] & 0xBF ) == 0x93 ) ) ? 2 : 0 )\
    : ( ( ( ((U8*)s)[0] & 0xBF ) == 0xA2 ) && ( ( ((U8*)s)[1] & 0xBE ) == 0xA2 ) ) ? 2 : 0 )\
: ((e)-(s) > 1) ?                                                           \
    ( ( ( ((U8*)s)[0] & 0xBF ) == 0x86 ) ?                                  \
	( ( ( ( ((U8*)s)[1] & 0xBF ) == 0x86 ) || ( ( ((U8*)s)[1] & 0xBF ) == 0x89 ) || ( ( ((U8*)s)[1] & 0xBF ) == 0x93 ) ) ? 2 : 0 )\
    : ( ( ( ((U8*)s)[0] & 0xBF ) == 0xA2 ) && ( ( ((U8*)s)[1] & 0xBE ) == 0xA2 ) ) ? 2 : 0 )\
: 0 )

/*
	FOLDS_TO_MULTI: characters that fold to multi-char strings

	\p{_Perl_Folds_To_Multi_Char}
*/
/*** GENERATED CODE ***/
#define is_FOLDS_TO_MULTI_utf8(s)                                           \
( ( 0x80 == ((U8*)s)[0] ) ?                                                 \
    ( ( 0x72 == ((U8*)s)[1] ) ? 2 : 0 )                                     \
: ( 0x8C == ((U8*)s)[0] || 0x9B == ((U8*)s)[0] || ( ((U8*)s)[0] & 0xFE ) == 0xB2 ) ?\
    ( ( 0x57 == ((U8*)s)[1] ) ? 2 : 0 )                                     \
: ( 0x8D == ((U8*)s)[0] ) ?                                                 \
    ( ( 0x4A == ((U8*)s)[1] ) ? 2 : 0 )                                     \
: ( 0xB7 == ((U8*)s)[0] ) ?                                                 \
    ( ( ( 0x53 == ((U8*)s)[1] ) && ( 0x48 == ((U8*)s)[2] ) ) ? 3 : 0 )      \
: ( 0xBF == ((U8*)s)[0] ) ?                                                 \
    ( ( 0x62 == ((U8*)s)[1] ) ?                                             \
	( ( ( 0x64 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x68 ) || 0x71 == ((U8*)s)[2] ) ? 3 : 0 )\
    : ( 0x68 == ((U8*)s)[1] ) ?                                             \
	( ( 0x57 == ((U8*)s)[2] || 0x59 == ((U8*)s)[2] || 0x62 == ((U8*)s)[2] || 0x64 == ((U8*)s)[2] ) ? 3 : 0 )\
    : ( 0x6A == ((U8*)s)[1] ) ?                                             \
	( ( ( 0x41 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x4A ) || ( 0x51 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x59 ) || 0x5F == ((U8*)s)[2] || ( 0x62 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x6A ) || ( 0x70 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x72 ) ) ? 3 : 0 )\
    : ( 0x70 == ((U8*)s)[1] ) ?                                             \
	( ( ( 0x41 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x4A ) || ( 0x51 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x56 ) || 0x59 == ((U8*)s)[2] || 0x5F == ((U8*)s)[2] || 0x62 == ((U8*)s)[2] || ( ((U8*)s)[2] & 0xFE ) == 0x64 || 0x6A == ((U8*)s)[2] ) ? 3 : 0 )\
    : ( 0x71 == ((U8*)s)[1] ) ?                                             \
	( ( ( ( ((U8*)s)[2] & 0xFB ) == 0x43 ) || ( ( ((U8*)s)[2] & 0xDE ) == 0x44 ) || ((U8*)s)[2] == 0x48 || ((U8*)s)[2] == 0x53 || ((U8*)s)[2] == 0x59 || ((U8*)s)[2] == 0x5F ) ? 3 : 0 )\
    : ( ( 0x72 == ((U8*)s)[1] ) && ( ( ( ((U8*)s)[2] & 0xFB ) == 0x43 ) || ( ( ((U8*)s)[2] & 0xDE ) == 0x44 ) || ((U8*)s)[2] == 0x48 || ((U8*)s)[2] == 0x59 || ((U8*)s)[2] == 0x5F || ( ( ((U8*)s)[2] & 0xF7 ) == 0x62 ) ) ) ? 3 : 0 )\
: ( ( ( ( 0xDD == ((U8*)s)[0] ) && ( 0x71 == ((U8*)s)[1] ) ) && ( 0x66 == ((U8*)s)[2] ) ) && ( ( 0x41 <= ((U8*)s)[3] && ((U8*)s)[3] <= 0x47 ) || 0x5F == ((U8*)s)[3] || ( 0x62 <= ((U8*)s)[3] && ((U8*)s)[3] <= 0x65 ) ) ) ? 4 : 0 )

/*
	PROBLEMATIC_LOCALE_FOLD: characters whose fold is problematic under locale

	\p{_Perl_Problematic_Locale_Folds}
*/
/*** GENERATED CODE ***/
#define is_PROBLEMATIC_LOCALE_FOLD_utf8(s)                                  \
( ( ( ( ((U8*)s)[0] & 0xC0 ) == 0x00 ) || ( ( ((U8*)s)[0] & 0xEF ) == 0x40 ) || ( ( ((U8*)s)[0] & 0xDF ) == 0x4B ) || ( ( ((U8*)s)[0] & 0xFC ) == 0x4C ) || ( ( ((U8*)s)[0] & 0xDE ) == 0x5A ) || ( ( ((U8*)s)[0] & 0xFE ) == 0x5C ) || ((U8*)s)[0] == 0x5E || ( ( ((U8*)s)[0] & 0xFE ) == 0x60 ) || ( ( ((U8*)s)[0] & 0xEC ) == 0x6C ) || ((U8*)s)[0] == 0x79 || ( ( ((U8*)s)[0] & 0xEF ) == 0x81 ) || ( ( ((U8*)s)[0] & 0xEE ) == 0x82 ) || ( ( ((U8*)s)[0] & 0xEC ) == 0x84 ) || ( ( ((U8*)s)[0] & 0xEE ) == 0x88 ) || ((U8*)s)[0] == 0xA1 || ( ( ((U8*)s)[0] & 0xBE ) == 0xA2 ) || ( ( ((U8*)s)[0] & 0xBC ) == 0xA4 ) || ( ( ((U8*)s)[0] & 0xFE ) == 0xA8 ) || ((U8*)s)[0] == 0xB0 || ( ( ((U8*)s)[0] & 0xFE ) == 0xBA ) || ( ( ((U8*)s)[0] & 0xE8 ) == 0xC0 ) || ( ( ((U8*)s)[0] & 0xCE ) == 0xC8 ) || ((U8*)s)[0] == 0xE0 || ( ( ((U8*)s)[0] & 0xF8 ) == 0xF0 ) || ((U8*)s)[0] == 0xFF ) ? 1\
: ( 0x78 == ((U8*)s)[0] || 0x80 == ((U8*)s)[0] || 0x8A == ((U8*)s)[0] ) ?   \
    ( ( ( 0x41 <= ((U8*)s)[1] && ((U8*)s)[1] <= 0x4A ) || ( 0x51 <= ((U8*)s)[1] && ((U8*)s)[1] <= 0x59 ) || 0x5F == ((U8*)s)[1] || ( 0x62 <= ((U8*)s)[1] && ((U8*)s)[1] <= 0x6A ) || ( 0x70 <= ((U8*)s)[1] && ((U8*)s)[1] <= 0x72 ) ) ? 2 : 0 )\
: ( 0x8C == ((U8*)s)[0] || 0x9B == ((U8*)s)[0] ) ?                          \
    ( ( 0x57 == ((U8*)s)[1] ) ? 2 : 0 )                                     \
: ( 0x8D == ((U8*)s)[0] ) ?                                                 \
    ( ( 0x4A == ((U8*)s)[1] ) ? 2 : 0 )                                     \
: ( 0x8E == ((U8*)s)[0] ) ?                                                 \
    ( ( 0x66 == ((U8*)s)[1] || 0x72 == ((U8*)s)[1] ) ? 2 : 0 )              \
: ( ( ((U8*)s)[0] & 0xFE ) == 0xB2 ) ?                                      \
    ( ( 0x6A == ((U8*)s)[1] ) ? 2 : 0 )                                     \
: ( 0xBF == ((U8*)s)[0] ) ?                                                 \
    ( ( ( 0x62 == ((U8*)s)[1] ) && ( ( 0x64 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x68 ) || 0x71 == ((U8*)s)[2] ) ) ? 3 : 0 )\
: ( 0xCA == ((U8*)s)[0] ) ?                                                 \
    ( ( ( 0x4A == ((U8*)s)[1] ) && ( 0x51 == ((U8*)s)[2] || 0x52 == ((U8*)s)[2] ) ) ? 3 : 0 )\
: ( ( ( ( 0xDD == ((U8*)s)[0] ) && ( 0x71 == ((U8*)s)[1] ) ) && ( 0x66 == ((U8*)s)[2] ) ) && ( 0x41 <= ((U8*)s)[3] && ((U8*)s)[3] <= 0x47 ) ) ? 4 : 0 )

/*** GENERATED CODE ***/
#define is_PROBLEMATIC_LOCALE_FOLD_cp(cp)                                   \
( cp <= 0xFF || ( 0xFF < cp &&                                              \
( 0x130 == cp || ( 0x130 < cp &&                                            \
( 0x149 == cp || ( 0x149 < cp &&                                            \
( 0x178 == cp || ( 0x178 < cp &&                                            \
( 0x17F == cp || ( 0x17F < cp &&                                            \
( 0x1F0 == cp || ( 0x1F0 < cp &&                                            \
( 0x39C == cp || ( 0x39C < cp &&                                            \
( 0x3BC == cp || ( 0x3BC < cp &&                                            \
( ( 0x1E96 <= cp && cp <= 0x1E9A ) || ( 0x1E9A < cp &&                      \
( 0x1E9E == cp || ( 0x1E9E < cp &&                                          \
( 0x212A == cp || ( 0x212A < cp &&                                          \
( 0x212B == cp || ( 0xFB00 <= cp && cp <= 0xFB06 ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )

/*
	PROBLEMATIC_LOCALE_FOLDEDS_START: The first folded character of folds which are problematic under locale

	\p{_Perl_Problematic_Locale_Foldeds_Start}
*/
/*** GENERATED CODE ***/
#define is_PROBLEMATIC_LOCALE_FOLDEDS_START_utf8(s)                         \
( ( ( ( ((U8*)s)[0] & 0xC0 ) == 0x00 ) || ( ( ((U8*)s)[0] & 0xEF ) == 0x40 ) || ( ( ((U8*)s)[0] & 0xDF ) == 0x4B ) || ( ( ((U8*)s)[0] & 0xFC ) == 0x4C ) || ( ( ((U8*)s)[0] & 0xDE ) == 0x5A ) || ( ( ((U8*)s)[0] & 0xFE ) == 0x5C ) || ((U8*)s)[0] == 0x5E || ( ( ((U8*)s)[0] & 0xFE ) == 0x60 ) || ( ( ((U8*)s)[0] & 0xEC ) == 0x6C ) || ((U8*)s)[0] == 0x79 || ( ( ((U8*)s)[0] & 0xEF ) == 0x81 ) || ( ( ((U8*)s)[0] & 0xEE ) == 0x82 ) || ( ( ((U8*)s)[0] & 0xEC ) == 0x84 ) || ( ( ((U8*)s)[0] & 0xEE ) == 0x88 ) || ((U8*)s)[0] == 0xA1 || ( ( ((U8*)s)[0] & 0xBE ) == 0xA2 ) || ( ( ((U8*)s)[0] & 0xBC ) == 0xA4 ) || ( ( ((U8*)s)[0] & 0xFE ) == 0xA8 ) || ((U8*)s)[0] == 0xB0 || ( ( ((U8*)s)[0] & 0xFE ) == 0xBA ) || ( ( ((U8*)s)[0] & 0xE8 ) == 0xC0 ) || ( ( ((U8*)s)[0] & 0xCE ) == 0xC8 ) || ((U8*)s)[0] == 0xE0 || ( ( ((U8*)s)[0] & 0xF8 ) == 0xF0 ) || ((U8*)s)[0] == 0xFF ) ? 1\
: ( 0x78 == ((U8*)s)[0] || 0x80 == ((U8*)s)[0] || 0x8A == ((U8*)s)[0] ) ?   \
    ( ( ( 0x41 <= ((U8*)s)[1] && ((U8*)s)[1] <= 0x4A ) || ( 0x51 <= ((U8*)s)[1] && ((U8*)s)[1] <= 0x59 ) || 0x5F == ((U8*)s)[1] || ( 0x62 <= ((U8*)s)[1] && ((U8*)s)[1] <= 0x6A ) || ( 0x70 <= ((U8*)s)[1] && ((U8*)s)[1] <= 0x72 ) ) ? 2 : 0 )\
: ( 0x8C == ((U8*)s)[0] || 0x9B == ((U8*)s)[0] ) ?                          \
    ( ( 0x57 == ((U8*)s)[1] ) ? 2 : 0 )                                     \
: ( 0x8D == ((U8*)s)[0] ) ?                                                 \
    ( ( 0x4A == ((U8*)s)[1] ) ? 2 : 0 )                                     \
: ( 0x8E == ((U8*)s)[0] ) ?                                                 \
    ( ( 0x66 == ((U8*)s)[1] || 0x72 == ((U8*)s)[1] ) ? 2 : 0 )              \
: ( 0xAA == ((U8*)s)[0] || ( ((U8*)s)[0] & 0xFE ) == 0xB2 ) ?               \
    ( ( 0x6A == ((U8*)s)[1] ) ? 2 : 0 )                                     \
: ( 0xBF == ((U8*)s)[0] ) ?                                                 \
    ( ( ( 0x62 == ((U8*)s)[1] ) && ( ( 0x64 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x68 ) || 0x71 == ((U8*)s)[2] ) ) ? 3 : 0 )\
: ( 0xCA == ((U8*)s)[0] ) ?                                                 \
    ( ( ( 0x4A == ((U8*)s)[1] ) && ( 0x51 == ((U8*)s)[2] || 0x52 == ((U8*)s)[2] ) ) ? 3 : 0 )\
: ( ( ( ( 0xDD == ((U8*)s)[0] ) && ( 0x71 == ((U8*)s)[1] ) ) && ( 0x66 == ((U8*)s)[2] ) ) && ( 0x41 <= ((U8*)s)[3] && ((U8*)s)[3] <= 0x47 ) ) ? 4 : 0 )

/*** GENERATED CODE ***/
#define is_PROBLEMATIC_LOCALE_FOLDEDS_START_cp(cp)                          \
( cp <= 0xFF || ( 0xFF < cp &&                                              \
( 0x130 == cp || ( 0x130 < cp &&                                            \
( 0x149 == cp || ( 0x149 < cp &&                                            \
( 0x178 == cp || ( 0x178 < cp &&                                            \
( 0x17F == cp || ( 0x17F < cp &&                                            \
( 0x1F0 == cp || ( 0x1F0 < cp &&                                            \
( 0x2BC == cp || ( 0x2BC < cp &&                                            \
( 0x39C == cp || ( 0x39C < cp &&                                            \
( 0x3BC == cp || ( 0x3BC < cp &&                                            \
( ( 0x1E96 <= cp && cp <= 0x1E9A ) || ( 0x1E9A < cp &&                      \
( 0x1E9E == cp || ( 0x1E9E < cp &&                                          \
( 0x212A == cp || ( 0x212A < cp &&                                          \
( 0x212B == cp || ( 0xFB00 <= cp && cp <= 0xFB06 ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )

/*
	PATWS: pattern white space

	\p{_Perl_PatWS}
*/
/*** GENERATED CODE ***/
#define is_PATWS_safe(s,e,is_utf8)                                          \
( ( LIKELY((e) > (s)) ) ?                                                   \
    ( ( ( ( ((U8*)s)[0] & 0xEF ) == 0x05 ) || ((U8*)s)[0] == 0x0B || ( ( ((U8*)s)[0] & 0xFE ) == 0x0C ) || ((U8*)s)[0] == 0x25 || ((U8*)s)[0] == 0x40 ) ? 1\
    : ( ( is_utf8 && LIKELY(((e) - (s)) >= UTF8SKIP(s)) ) && ( 0xCA == ((U8*)s)[0] ) ) ? ( ( 0x41 == ((U8*)s)[1] ) ?\
		    ( ( 0x55 == ((U8*)s)[2] || 0x56 == ((U8*)s)[2] ) ? 3 : 0 )\
		: ( ( 0x42 == ((U8*)s)[1] ) && ( 0x49 == ((U8*)s)[2] || 0x4A == ((U8*)s)[2] ) ) ? 3 : 0 ) : 0 )\
: 0 )

/*** GENERATED CODE ***/
#define is_PATWS_cp(cp)                                                     \
( 0x05 == cp || ( 0x05 < cp &&                                              \
( ( 0x0B <= cp && cp <= 0x0D ) || ( 0x0D < cp &&                            \
( 0x15 == cp || ( 0x15 < cp &&                                              \
( 0x25 == cp || ( 0x25 < cp &&                                              \
( 0x40 == cp || ( 0x40 < cp &&                                              \
( 0x200E == cp || ( 0x200E < cp &&                                          \
( 0x200F == cp || ( 0x200F < cp &&                                          \
( 0x2028 == cp || 0x2029 == cp ) ) ) ) ) ) ) ) ) ) ) ) ) ) )

#endif	/* EBCDIC 037 */

#endif /* H_REGCHARCLASS */

/* Generated from:
 * cb3170dd603ad12ba0299440e99e8f50a8afde60ade2ffcbf1ff4a8a53854b90 lib/Unicode/UCD.pm
 * ae98bec7e4f0564758eed81eca5015481ba32581f8a735a825b71b3bba714450 lib/unicore/ArabicShaping.txt
 * 1687fe5994eb7e5c0dab8503fc2a1b3b479d91af9d3b8055941c9bd791f7d0b5 lib/unicore/BidiBrackets.txt
 * 350d1302116194b0b21def287434b55c5088098fbc726e879f7420a391965643 lib/unicore/BidiMirroring.txt
 * 288fc7b85c76bda296e296c8465f1f4baeb456cb814430dfaa0f546bfbe86b4a lib/unicore/Blocks.txt
 * 86e075f2ede997b3fa5965516c75190b5a88bb82d302272d9c3179b7a57af03f lib/unicore/CaseFolding.txt
 * 2fafee5be73bf2817ee669c53c504a6c4aa02ac7344194af18511aea2e05d750 lib/unicore/CompositionExclusions.txt
 * 302f6d6171dc9c6165db86d0226b7923a64cea06c493d339d35436bf137606a3 lib/unicore/DAge.txt
 * ff666dece87dfdbdbf04a2e26a0bfb52c4ba98db1f8965b0b01ddb9e15f97476 lib/unicore/DCoreProperties.txt
 * 6cc76100d402d7dd12bd769ac61158b91e71aad58c8333abb848f1b9c9fdde2d lib/unicore/DNormalizationProps.txt
 * ccc571829b384b8a2c24b7a62f8aa6a891a6e8c48f08513ef84fd6da26dba4bb lib/unicore/EastAsianWidth.txt
 * 2320db06cf88c755ec7b9cfec96dd9e1d774173521dbc3ee7985377c2ab90d32 lib/unicore/HangulSyllableType.txt
 * e52216b5fdb04910e06e94f01cabdf70656b0077c92b756c7b38822626d572f2 lib/unicore/IndicPositionalCategory.txt
 * 4db71a39102e173095cb8bda8b4c35e78fe6b365e443c584b19f081d8c4894fc lib/unicore/IndicSyllabicCategory.txt
 * eeb30346bb545bb45ff16486d9234397bfe1a195bb12b54fc1d9f48f87e8aa5e lib/unicore/Jamo.txt
 * 13e2b7087bcca3163272e64e34e480534bd2f8353a0245c26e6642566f59a60d lib/unicore/LineBreak.txt
 * 9bb54cd7b5509779f269fa60341bcbfca8da8f17d3c4999e44a5a51671d3c402 lib/unicore/NameAliases.txt
 * e4c29d9ceefbe2382af819ac7646265a9e4ea599ce04a90d31bec97cfaa2848f lib/unicore/NamedSequences.txt
 * 70d40297f1bf91397fbdab5a770c12100733e67c5c3398446c5e950715d5e535 lib/unicore/PropList.txt
 * 03a440f2a4b9151043a6bb53d4a4e528b73238079f9d686dc2a5846e6895588a lib/unicore/PropValueAliases.txt
 * 8e8b48c2080d31aa6713f5535aad94a1f7bc9a65cc52563724e5e69b0a3b4196 lib/unicore/PropertyAliases.txt
 * 45d42b1ecbac2263c1c63c95104e63ea64313eb99be94542e040aea11c449f6c lib/unicore/ScriptExtensions.txt
 * 79fbd73ad82c30fdb67d36a349d12667bd58d3e9da6a8ce7dd26383b637ba85f lib/unicore/Scripts.txt
 * fb2025dae3b9b17649b6e379c1cdbddf50641267ca6d2446caeccf4a141fe167 lib/unicore/SpecialCasing.txt
 * 38b17e1118206489a7e0ab5d29d7932212d38838df7d3ec025ecb58e8798ec20 lib/unicore/UnicodeData.txt
 * 0cedd6e0f5cadf57ce9cfc96beccfd083b0faa0809a631a777cd25f0316bfabb lib/unicore/auxiliary/GCBTest.txt
 * 230005412f9a47128e37bc52330766aaa0b5522a53737a89cff66e891e14527a lib/unicore/auxiliary/GraphemeBreakProperty.txt
 * 149b14ab93b06c887a958fb16d0ad01193063ef69cc14f10338ae4d0accd6c28 lib/unicore/auxiliary/LBTest.txt
 * 41bf82452d71ce15eda8c9bb1bb0c20b72205acaaf503e3cb84734ed8e85d33a lib/unicore/auxiliary/SBTest.txt
 * d3b45cdb0a73eeb9d25158336583dfc1e6f64da59537acb0008988b40e6b3b63 lib/unicore/auxiliary/SentenceBreakProperty.txt
 * a661f42a54f7cc4dded72a61c508be2b482f912d4b6cf140335010f0c684dbb9 lib/unicore/auxiliary/WBTest.txt
 * c255bd2e1f163373510679bf4b272eee97b635bfce2a6550d6c10fe5c917f01a lib/unicore/auxiliary/WordBreakProperty.txt
 * 16dac6f1c164a4f52741b71221a8aafb6acb52cd8a436af139da6e93d86efdfb lib/unicore/extracted/DBidiClass.txt
 * c4e78efc041668548117f7462af03b28dfbb2caca5d46a1ae78ae0ce0bb26c4a lib/unicore/extracted/DBinaryProperties.txt
 * 5886bb44aae8f2821663f742793cb91d4ed0923c6840f3bfb73530e37030abf8 lib/unicore/extracted/DCombiningClass.txt
 * 9edba3785ed0e6e46e10f67e2dd0ec3cb0799b7f75f526fe918429576060352e lib/unicore/extracted/DDecompositionType.txt
 * b774387f79b27ae4268ae89450f971408dc9bbbb523426482ab4375c962bd922 lib/unicore/extracted/DEastAsianWidth.txt
 * ba4207d2464077e807b20caf063041142afc0a8a38c328c5c23b3417c9f2da33 lib/unicore/extracted/DGeneralCategory.txt
 * 29fdd151266595eb1b37715937afe0727bb632a2bc1130f0d2314040175df82e lib/unicore/extracted/DJoinGroup.txt
 * 7725fe247da06986e43e89fd316b8b22a0619546d0c1ed499a94b25e9164c150 lib/unicore/extracted/DJoinType.txt
 * 1a0687fb9c6c4567e853913549df0944fe40821279a3e9cdaa6ab8679bc286fd lib/unicore/extracted/DLineBreak.txt
 * 40bcfed3ca727c19e1331f6c33806231d5f7eeeabd2e6a9e06a3740c85d0c250 lib/unicore/extracted/DNumType.txt
 * a18d502bad39d527ac5586d7bc93e29f565859e3bcc24ada627eff606d6f5fed lib/unicore/extracted/DNumValues.txt
 * 285aef7ed2bf69724b1fa9bba177640636f666e1a5dd0ba5e538d4790129bbfe lib/unicore/mktables
 * 462c9aaa608fb2014cd9649af1c5c009485c60b9c8b15b89401fdc10cf6161c6 lib/unicore/version
 * 913d2f93f3cb6cdf1664db888bf840bc4eb074eef824e082fceda24a9445e60c regen/charset_translations.pl
 * d9c04ac46bdd81bb3e26519f2b8eb6242cb12337205add3f7cf092b0c58dccc4 regen/regcharclass.pl
 * 393f8d882713a3ba227351ad0f00ea4839fda74fcf77dcd1cdf31519925adba5 regen/regcharclass_multi_char_folds.pl
 * ex: set ro: */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      /* -*- buffer-read-only: t -*-
   !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
   This file is built by regen/regcomp.pl from regcomp.sym.
   Any changes made here will be lost!
 */

/* Regops and State definitions */

#define REGNODE_MAX           	92
#define REGMATCH_STATE_MAX    	132

#define	END                   	0	/* 0000 End of program. */
#define	SUCCEED               	1	/* 0x01 Return from a subroutine, basically. */
#define	SBOL                  	2	/* 0x02 Match "" at beginning of line: /^/, /\A/ */
#define	BOL                   	2	/* 0x02 type alias */
#define	MBOL                  	3	/* 0x03 Same, assuming multiline: /^/m */
#define	SEOL                  	4	/* 0x04 Match "" at end of line: /$/ */
#define	EOL                   	4	/* 0x04 type alias */
#define	MEOL                  	5	/* 0x05 Same, assuming multiline: /$/m */
#define	EOS                   	6	/* 0x06 Match "" at end of string: /\z/ */
#define	GPOS                  	7	/* 0x07 Matches where last m//g left off. */
#define	BOUND                 	8	/* 0x08 Like BOUNDA for non-utf8, otherwise match "" between any Unicode \w\W or \W\w */
#define	BOUNDL                	9	/* 0x09 Like BOUND/BOUNDU, but \w and \W are defined by current locale */
#define	BOUNDU                	10	/* 0x0a Match "" at any boundary of a given type using Unicode rules */
#define	BOUNDA                	11	/* 0x0b Match "" at any boundary between \w\W or \W\w, where \w is [_a-zA-Z0-9] */
#define	NBOUND                	12	/* 0x0c Like NBOUNDA for non-utf8, otherwise match "" between any Unicode \w\w or \W\W */
#define	NBOUNDL               	13	/* 0x0d Like NBOUND/NBOUNDU, but \w and \W are defined by current locale */
#define	NBOUNDU               	14	/* 0x0e Match "" at any non-boundary of a given type using using Unicode rules */
#define	NBOUNDA               	15	/* 0x0f Match "" betweeen any \w\w or \W\W, where \w is [_a-zA-Z0-9] */
#define	REG_ANY               	16	/* 0x10 Match any one character (except newline). */
#define	SANY                  	17	/* 0x11 Match any one character. */
#define	ANYOF                 	18	/* 0x12 Match character in (or not in) this class, single char match only */
#define	ANYOFD                	19	/* 0x13 Like ANYOF, but /d is in effect */
#define	ANYOFL                	20	/* 0x14 Like ANYOF, but /l is in effect */
#define	POSIXD                	21	/* 0x15 Some [[:class:]] under /d; the FLAGS field gives which one */
#define	POSIXL                	22	/* 0x16 Some [[:class:]] under /l; the FLAGS field gives which one */
#define	POSIXU                	23	/* 0x17 Some [[:class:]] under /u; the FLAGS field gives which one */
#define	POSIXA                	24	/* 0x18 Some [[:class:]] under /a; the FLAGS field gives which one */
#define	NPOSIXD               	25	/* 0x19 complement of POSIXD, [[:^class:]] */
#define	NPOSIXL               	26	/* 0x1a complement of POSIXL, [[:^class:]] */
#define	NPOSIXU               	27	/* 0x1b complement of POSIXU, [[:^class:]] */
#define	NPOSIXA               	28	/* 0x1c complement of POSIXA, [[:^class:]] */
#define	CLUMP                 	29	/* 0x1d Match any extended grapheme cluster sequence */
#define	BRANCH                	30	/* 0x1e Match this alternative, or the next... */
#define	EXACT                 	31	/* 0x1f Match this string (preceded by length). */
#define	EXACTL                	32	/* 0x20 Like EXACT, but /l is in effect (used so locale-related warnings can be checked for). */
#define	EXACTF                	33	/* 0x21 Match this non-UTF-8 string (not guaranteed to be folded) using /id rules (w/len). */
#define	EXACTFL               	34	/* 0x22 Match this string (not guaranteed to be folded) using /il rules (w/len). */
#define	EXACTFU               	35	/* 0x23 Match this string (folded iff in UTF-8, length in folding doesn't change if not in UTF-8) using /iu rules (w/len). */
#define	EXACTFA               	36	/* 0x24 Match this string (not guaranteed to be folded) using /iaa rules (w/len). */
#define	EXACTFU_SS            	37	/* 0x25 Match this string (folded iff in UTF-8, length in folding may change even if not in UTF-8) using /iu rules (w/len). */
#define	EXACTFLU8             	38	/* 0x26 Rare cirucmstances: like EXACTFU, but is under /l, UTF-8, folded, and everything in it is above 255. */
#define	EXACTFA_NO_TRIE       	39	/* 0x27 Match this string (which is not trie-able; not guaranteed to be folded) using /iaa rules (w/len). */
#define	NOTHING               	40	/* 0x28 Match empty string. */
#define	TAIL                  	41	/* 0x29 Match empty string. Can jump here from outside. */
#define	STAR                  	42	/* 0x2a Match this (simple) thing 0 or more times. */
#define	PLUS                  	43	/* 0x2b Match this (simple) thing 1 or more times. */
#define	CURLY                 	44	/* 0x2c Match this simple thing {n,m} times. */
#define	CURLYN                	45	/* 0x2d Capture next-after-this simple thing */
#define	CURLYM                	46	/* 0x2e Capture this medium-complex thing {n,m} times. */
#define	CURLYX                	47	/* 0x2f Match this complex thing {n,m} times. */
#define	WHILEM                	48	/* 0x30 Do curly processing and see if rest matches. */
#define	OPEN                  	49	/* 0x31 Mark this point in input as start of #n. */
#define	CLOSE                 	50	/* 0x32 Analogous to OPEN. */
#define	REF                   	51	/* 0x33 Match some already matched string */
#define	REFF                  	52	/* 0x34 Match already matched string, folded using native charset rules for non-utf8 */
#define	REFFL                 	53	/* 0x35 Match already matched string, folded in loc. */
#define	REFFU                 	54	/* 0x36 Match already matched string, folded using unicode rules for non-utf8 */
#define	REFFA                 	55	/* 0x37 Match already matched string, folded using unicode rules for non-utf8, no mixing ASCII, non-ASCII */
#define	NREF                  	56	/* 0x38 Match some already matched string */
#define	NREFF                 	57	/* 0x39 Match already matched string, folded using native charset rules for non-utf8 */
#define	NREFFL                	58	/* 0x3a Match already matched string, folded in loc. */
#define	NREFFU                	59	/* 0x3b Match already matched string, folded using unicode rules for non-utf8 */
#define	NREFFA                	60	/* 0x3c Match already matched string, folded using unicode rules for non-utf8, no mixing ASCII, non-ASCII */
#define	LONGJMP               	61	/* 0x3d Jump far away. */
#define	BRANCHJ               	62	/* 0x3e BRANCH with long offset. */
#define	IFMATCH               	63	/* 0x3f Succeeds if the following matches. */
#define	UNLESSM               	64	/* 0x40 Fails if the following matches. */
#define	SUSPEND               	65	/* 0x41 "Independent" sub-RE. */
#define	IFTHEN                	66	/* 0x42 Switch, should be preceded by switcher. */
#define	GROUPP                	67	/* 0x43 Whether the group matched. */
#define	EVAL                  	68	/* 0x44 Execute some Perl code. */
#define	MINMOD                	69	/* 0x45 Next operator is not greedy. */
#define	LOGICAL               	70	/* 0x46 Next opcode should set the flag only. */
#define	RENUM                 	71	/* 0x47 Group with independently numbered parens. */
#define	TRIE                  	72	/* 0x48 Match many EXACT(F[ALU]?)? at once. flags==type */
#define	TRIEC                 	73	/* 0x49 Same as TRIE, but with embedded charclass data */
#define	AHOCORASICK           	74	/* 0x4a Aho Corasick stclass. flags==type */
#define	AHOCORASICKC          	75	/* 0x4b Same as AHOCORASICK, but with embedded charclass data */
#define	GOSUB                 	76	/* 0x4c recurse to paren arg1 at (signed) ofs arg2 */
#define	NGROUPP               	77	/* 0x4d Whether the group matched. */
#define	INSUBP                	78	/* 0x4e Whether we are in a specific recurse. */
#define	DEFINEP               	79	/* 0x4f Never execute directly. */
#define	ENDLIKE               	80	/* 0x50 Used only for the type field of verbs */
#define	OPFAIL                	81	/* 0x51 Same as (?!), but with verb arg */
#define	ACCEPT                	82	/* 0x52 Accepts the current matched string, with verbar */
#define	VERB                  	83	/* 0x53 Used only for the type field of verbs */
#define	PRUNE                 	84	/* 0x54 Pattern fails at this startpoint if no-backtracking through this */
#define	MARKPOINT             	85	/* 0x55 Push the current location for rollback by cut. */
#define	SKIP                  	86	/* 0x56 On failure skip forward (to the mark) before retrying */
#define	COMMIT                	87	/* 0x57 Pattern fails outright if backtracking through this */
#define	CUTGROUP              	88	/* 0x58 On failure go to the next alternation in the group */
#define	KEEPS                 	89	/* 0x59 $& begins here. */
#define	LNBREAK               	90	/* 0x5a generic newline pattern */
#define	OPTIMIZED             	91	/* 0x5b Placeholder for dump. */
#define	PSEUDO                	92	/* 0x5c Pseudo opcode for internal use. */
	/* ------------ States ------------- */
#define	TRIE_next             	(REGNODE_MAX + 1)	/* state for TRIE */
#define	TRIE_next_fail        	(REGNODE_MAX + 2)	/* state for TRIE */
#define	EVAL_AB               	(REGNODE_MAX + 3)	/* state for EVAL */
#define	EVAL_AB_fail          	(REGNODE_MAX + 4)	/* state for EVAL */
#define	CURLYX_end            	(REGNODE_MAX + 5)	/* state for CURLYX */
#define	CURLYX_end_fail       	(REGNODE_MAX + 6)	/* state for CURLYX */
#define	WHILEM_A_pre          	(REGNODE_MAX + 7)	/* state for WHILEM */
#define	WHILEM_A_pre_fail     	(REGNODE_MAX + 8)	/* state for WHILEM */
#define	WHILEM_A_min          	(REGNODE_MAX + 9)	/* state for WHILEM */
#define	WHILEM_A_min_fail     	(REGNODE_MAX + 10)	/* state for WHILEM */
#define	WHILEM_A_max          	(REGNODE_MAX + 11)	/* state for WHILEM */
#define	WHILEM_A_max_fail     	(REGNODE_MAX + 12)	/* state for WHILEM */
#define	WHILEM_B_min          	(REGNODE_MAX + 13)	/* state for WHILEM */
#define	WHILEM_B_min_fail     	(REGNODE_MAX + 14)	/* state for WHILEM */
#define	WHILEM_B_max          	(REGNODE_MAX + 15)	/* state for WHILEM */
#define	WHILEM_B_max_fail     	(REGNODE_MAX + 16)	/* state for WHILEM */
#define	BRANCH_next           	(REGNODE_MAX + 17)	/* state for BRANCH */
#define	BRANCH_next_fail      	(REGNODE_MAX + 18)	/* state for BRANCH */
#define	CURLYM_A              	(REGNODE_MAX + 19)	/* state for CURLYM */
#define	CURLYM_A_fail         	(REGNODE_MAX + 20)	/* state for CURLYM */
#define	CURLYM_B              	(REGNODE_MAX + 21)	/* state for CURLYM */
#define	CURLYM_B_fail         	(REGNODE_MAX + 22)	/* state for CURLYM */
#define	IFMATCH_A             	(REGNODE_MAX + 23)	/* state for IFMATCH */
#define	IFMATCH_A_fail        	(REGNODE_MAX + 24)	/* state for IFMATCH */
#define	CURLY_B_min_known     	(REGNODE_MAX + 25)	/* state for CURLY */
#define	CURLY_B_min_known_fail	(REGNODE_MAX + 26)	/* state for CURLY */
#define	CURLY_B_min           	(REGNODE_MAX + 27)	/* state for CURLY */
#define	CURLY_B_min_fail      	(REGNODE_MAX + 28)	/* state for CURLY */
#define	CURLY_B_max           	(REGNODE_MAX + 29)	/* state for CURLY */
#define	CURLY_B_max_fail      	(REGNODE_MAX + 30)	/* state for CURLY */
#define	COMMIT_next           	(REGNODE_MAX + 31)	/* state for COMMIT */
#define	COMMIT_next_fail      	(REGNODE_MAX + 32)	/* state for COMMIT */
#define	MARKPOINT_next        	(REGNODE_MAX + 33)	/* state for MARKPOINT */
#define	MARKPOINT_next_fail   	(REGNODE_MAX + 34)	/* state for MARKPOINT */
#define	SKIP_next             	(REGNODE_MAX + 35)	/* state for SKIP */
#define	SKIP_next_fail        	(REGNODE_MAX + 36)	/* state for SKIP */
#define	CUTGROUP_next         	(REGNODE_MAX + 37)	/* state for CUTGROUP */
#define	CUTGROUP_next_fail    	(REGNODE_MAX + 38)	/* state for CUTGROUP */
#define	KEEPS_next            	(REGNODE_MAX + 39)	/* state for KEEPS */
#define	KEEPS_next_fail       	(REGNODE_MAX + 40)	/* state for KEEPS */

/* PL_regkind[] What type of regop or state is this. */

#ifndef DOINIT
EXTCONST U8 PL_regkind[];
#else
EXTCONST U8 PL_regkind[] = {
	END,      	/* END                    */
	END,      	/* SUCCEED                */
	BOL,      	/* SBOL                   */
	BOL,      	/* MBOL                   */
	EOL,      	/* SEOL                   */
	EOL,      	/* MEOL                   */
	EOL,      	/* EOS                    */
	GPOS,     	/* GPOS                   */
	BOUND,    	/* BOUND                  */
	BOUND,    	/* BOUNDL                 */
	BOUND,    	/* BOUNDU                 */
	BOUND,    	/* BOUNDA                 */
	NBOUND,   	/* NBOUND                 */
	NBOUND,   	/* NBOUNDL                */
	NBOUND,   	/* NBOUNDU                */
	NBOUND,   	/* NBOUNDA                */
	REG_ANY,  	/* REG_ANY                */
	REG_ANY,  	/* SANY                   */
	ANYOF,    	/* ANYOF                  */
	ANYOF,    	/* ANYOFD                 */
	ANYOF,    	/* ANYOFL                 */
	POSIXD,   	/* POSIXD                 */
	POSIXD,   	/* POSIXL                 */
	POSIXD,   	/* POSIXU                 */
	POSIXD,   	/* POSIXA                 */
	NPOSIXD,  	/* NPOSIXD                */
	NPOSIXD,  	/* NPOSIXL                */
	NPOSIXD,  	/* NPOSIXU                */
	NPOSIXD,  	/* NPOSIXA                */
	CLUMP,    	/* CLUMP                  */
	BRANCH,   	/* BRANCH                 */
	EXACT,    	/* EXACT                  */
	EXACT,    	/* EXACTL                 */
	EXACT,    	/* EXACTF                 */
	EXACT,    	/* EXACTFL                */
	EXACT,    	/* EXACTFU                */
	EXACT,    	/* EXACTFA                */
	EXACT,    	/* EXACTFU_SS             */
	EXACT,    	/* EXACTFLU8              */
	EXACT,    	/* EXACTFA_NO_TRIE        */
	NOTHING,  	/* NOTHING                */
	NOTHING,  	/* TAIL                   */
	STAR,     	/* STAR                   */
	PLUS,     	/* PLUS                   */
	CURLY,    	/* CURLY                  */
	CURLY,    	/* CURLYN                 */
	CURLY,    	/* CURLYM                 */
	CURLY,    	/* CURLYX                 */
	WHILEM,   	/* WHILEM                 */
	OPEN,     	/* OPEN                   */
	CLOSE,    	/* CLOSE                  */
	REF,      	/* REF                    */
	REF,      	/* REFF                   */
	REF,      	/* REFFL                  */
	REF,      	/* REFFU                  */
	REF,      	/* REFFA                  */
	REF,      	/* NREF                   */
	REF,      	/* NREFF                  */
	REF,      	/* NREFFL                 */
	REF,      	/* NREFFU                 */
	REF,      	/* NREFFA                 */
	LONGJMP,  	/* LONGJMP                */
	BRANCHJ,  	/* BRANCHJ                */
	BRANCHJ,  	/* IFMATCH                */
	BRANCHJ,  	/* UNLESSM                */
	BRANCHJ,  	/* SUSPEND                */
	BRANCHJ,  	/* IFTHEN                 */
	GROUPP,   	/* GROUPP                 */
	EVAL,     	/* EVAL                   */
	MINMOD,   	/* MINMOD                 */
	LOGICAL,  	/* LOGICAL                */
	BRANCHJ,  	/* RENUM                  */
	TRIE,     	/* TRIE                   */
	TRIE,     	/* TRIEC                  */
	TRIE,     	/* AHOCORASICK            */
	TRIE,     	/* AHOCORASICKC           */
	GOSUB,    	/* GOSUB                  */
	NGROUPP,  	/* NGROUPP                */
	INSUBP,   	/* INSUBP                 */
	DEFINEP,  	/* DEFINEP                */
	ENDLIKE,  	/* ENDLIKE                */
	ENDLIKE,  	/* OPFAIL                 */
	ENDLIKE,  	/* ACCEPT                 */
	VERB,     	/* VERB                   */
	VERB,     	/* PRUNE                  */
	VERB,     	/* MARKPOINT              */
	VERB,     	/* SKIP                   */
	VERB,     	/* COMMIT                 */
	VERB,     	/* CUTGROUP               */
	KEEPS,    	/* KEEPS                  */
	LNBREAK,  	/* LNBREAK                */
	NOTHING,  	/* OPTIMIZED              */
	PSEUDO,   	/* PSEUDO                 */
	/* ------------ States ------------- */
	TRIE,     	/* TRIE_next              */
	TRIE,     	/* TRIE_next_fail         */
	EVAL,     	/* EVAL_AB                */
	EVAL,     	/* EVAL_AB_fail           */
	CURLYX,   	/* CURLYX_end             */
	CURLYX,   	/* CURLYX_end_fail        */
	WHILEM,   	/* WHILEM_A_pre           */
	WHILEM,   	/* WHILEM_A_pre_fail      */
	WHILEM,   	/* WHILEM_A_min           */
	WHILEM,   	/* WHILEM_A_min_fail      */
	WHILEM,   	/* WHILEM_A_max           */
	WHILEM,   	/* WHILEM_A_max_fail      */
	WHILEM,   	/* WHILEM_B_min           */
	WHILEM,   	/* WHILEM_B_min_fail      */
	WHILEM,   	/* WHILEM_B_max           */
	WHILEM,   	/* WHILEM_B_max_fail      */
	BRANCH,   	/* BRANCH_next            */
	BRANCH,   	/* BRANCH_next_fail       */
	CURLYM,   	/* CURLYM_A               */
	CURLYM,   	/* CURLYM_A_fail          */
	CURLYM,   	/* CURLYM_B               */
	CURLYM,   	/* CURLYM_B_fail          */
	IFMATCH,  	/* IFMATCH_A              */
	IFMATCH,  	/* IFMATCH_A_fail         */
	CURLY,    	/* CURLY_B_min_known      */
	CURLY,    	/* CURLY_B_min_known_fail */
	CURLY,    	/* CURLY_B_min            */
	CURLY,    	/* CURLY_B_min_fail       */
	CURLY,    	/* CURLY_B_max            */
	CURLY,    	/* CURLY_B_max_fail       */
	COMMIT,   	/* COMMIT_next            */
	COMMIT,   	/* COMMIT_next_fail       */
	MARKPOINT,	/* MARKPOINT_next         */
	MARKPOINT,	/* MARKPOINT_next_fail    */
	SKIP,     	/* SKIP_next              */
	SKIP,     	/* SKIP_next_fail         */
	CUTGROUP, 	/* CUTGROUP_next          */
	CUTGROUP, 	/* CUTGROUP_next_fail     */
	KEEPS,    	/* KEEPS_next             */
	KEEPS,    	/* KEEPS_next_fail        */
};
#endif

#ifdef REG_COMP_C

/* regarglen[] - How large is the argument part of the node (in regnodes) */

static const U8 regarglen[] = {
	0,                                   	/* END          */
	0,                                   	/* SUCCEED      */
	0,                                   	/* SBOL         */
	0,                                   	/* MBOL         */
	0,                                   	/* SEOL         */
	0,                                   	/* MEOL         */
	0,                                   	/* EOS          */
	0,                                   	/* GPOS         */
	0,                                   	/* BOUND        */
	0,                                   	/* BOUNDL       */
	0,                                   	/* BOUNDU       */
	0,                                   	/* BOUNDA       */
	0,                                   	/* NBOUND       */
	0,                                   	/* NBOUNDL      */
	0,                                   	/* NBOUNDU      */
	0,                                   	/* NBOUNDA      */
	0,                                   	/* REG_ANY      */
	0,                                   	/* SANY         */
	EXTRA_SIZE(struct regnode_1),        	/* ANYOF        */
	EXTRA_SIZE(struct regnode_1),        	/* ANYOFD       */
	EXTRA_SIZE(struct regnode_1),        	/* ANYOFL       */
	0,                                   	/* POSIXD       */
	0,                                   	/* POSIXL       */
	0,                                   	/* POSIXU       */
	0,                                   	/* POSIXA       */
	0,                                   	/* NPOSIXD      */
	0,                                   	/* NPOSIXL      */
	0,                                   	/* NPOSIXU      */
	0,                                   	/* NPOSIXA      */
	0,                                   	/* CLUMP        */
	0,                                   	/* BRANCH       */
	0,                                   	/* EXACT        */
	0,                                   	/* EXACTL       */
	0,                                   	/* EXACTF       */
	0,                                   	/* EXACTFL      */
	0,                                   	/* EXACTFU      */
	0,                                   	/* EXACTFA      */
	0,                                   	/* EXACTFU_SS   */
	0,                                   	/* EXACTFLU8    */
	0,                                   	/* EXACTFA_NO_TRIE */
	0,                                   	/* NOTHING      */
	0,                                   	/* TAIL         */
	0,                                   	/* STAR         */
	0,                                   	/* PLUS         */
	EXTRA_SIZE(struct regnode_2),        	/* CURLY        */
	EXTRA_SIZE(struct regnode_2),        	/* CURLYN       */
	EXTRA_SIZE(struct regnode_2),        	/* CURLYM       */
	EXTRA_SIZE(struct regnode_2),        	/* CURLYX       */
	0,                                   	/* WHILEM       */
	EXTRA_SIZE(struct regnode_1),        	/* OPEN         */
	EXTRA_SIZE(struct regnode_1),        	/* CLOSE        */
	EXTRA_SIZE(struct regnode_1),        	/* REF          */
	EXTRA_SIZE(struct regnode_1),        	/* REFF         */
	EXTRA_SIZE(struct regnode_1),        	/* REFFL        */
	EXTRA_SIZE(struct regnode_1),        	/* REFFU        */
	EXTRA_SIZE(struct regnode_1),        	/* REFFA        */
	EXTRA_SIZE(struct regnode_1),        	/* NREF         */
	EXTRA_SIZE(struct regnode_1),        	/* NREFF        */
	EXTRA_SIZE(struct regnode_1),        	/* NREFFL       */
	EXTRA_SIZE(struct regnode_1),        	/* NREFFU       */
	EXTRA_SIZE(struct regnode_1),        	/* NREFFA       */
	EXTRA_SIZE(struct regnode_1),        	/* LONGJMP      */
	EXTRA_SIZE(struct regnode_1),        	/* BRANCHJ      */
	EXTRA_SIZE(struct regnode_1),        	/* IFMATCH      */
	EXTRA_SIZE(struct regnode_1),        	/* UNLESSM      */
	EXTRA_SIZE(struct regnode_1),        	/* SUSPEND      */
	EXTRA_SIZE(struct regnode_1),        	/* IFTHEN       */
	EXTRA_SIZE(struct regnode_1),        	/* GROUPP       */
	EXTRA_SIZE(struct regnode_2L),       	/* EVAL         */
	0,                                   	/* MINMOD       */
	0,                                   	/* LOGICAL      */
	EXTRA_SIZE(struct regnode_1),        	/* RENUM        */
	EXTRA_SIZE(struct regnode_1),        	/* TRIE         */
	EXTRA_SIZE(struct regnode_charclass),	/* TRIEC        */
	EXTRA_SIZE(struct regnode_1),        	/* AHOCORASICK  */
	EXTRA_SIZE(struct regnode_charclass),	/* AHOCORASICKC */
	EXTRA_SIZE(struct regnode_2L),       	/* GOSUB        */
	EXTRA_SIZE(struct regnode_1),        	/* NGROUPP      */
	EXTRA_SIZE(struct regnode_1),        	/* INSUBP       */
	EXTRA_SIZE(struct regnode_1),        	/* DEFINEP      */
	0,                                   	/* ENDLIKE      */
	EXTRA_SIZE(struct regnode_1),        	/* OPFAIL       */
	EXTRA_SIZE(struct regnode_2L),       	/* ACCEPT       */
	EXTRA_SIZE(struct regnode_1),        	/* VERB         */
	EXTRA_SIZE(struct regnode_1),        	/* PRUNE        */
	EXTRA_SIZE(struct regnode_1),        	/* MARKPOINT    */
	EXTRA_SIZE(struct regnode_1),        	/* SKIP         */
	EXTRA_SIZE(struct regnode_1),        	/* COMMIT       */
	EXTRA_SIZE(struct regnode_1),        	/* CUTGROUP     */
	0,                                   	/* KEEPS        */
	0,                                   	/* LNBREAK      */
	0,                                   	/* OPTIMIZED    */
	0,                                   	/* PSEUDO       */
};

/* reg_off_by_arg[] - Which argument holds the offset to the next node */

static const char reg_off_by_arg[] = {
	0,	/* END          */
	0,	/* SUCCEED      */
	0,	/* SBOL         */
	0,	/* MBOL         */
	0,	/* SEOL         */
	0,	/* MEOL         */
	0,	/* EOS          */
	0,	/* GPOS         */
	0,	/* BOUND        */
	0,	/* BOUNDL       */
	0,	/* BOUNDU       */
	0,	/* BOUNDA       */
	0,	/* NBOUND       */
	0,	/* NBOUNDL      */
	0,	/* NBOUNDU      */
	0,	/* NBOUNDA      */
	0,	/* REG_ANY      */
	0,	/* SANY         */
	0,	/* ANYOF        */
	0,	/* ANYOFD       */
	0,	/* ANYOFL       */
	0,	/* POSIXD       */
	0,	/* POSIXL       */
	0,	/* POSIXU       */
	0,	/* POSIXA       */
	0,	/* NPOSIXD      */
	0,	/* NPOSIXL      */
	0,	/* NPOSIXU      */
	0,	/* NPOSIXA      */
	0,	/* CLUMP        */
	0,	/* BRANCH       */
	0,	/* EXACT        */
	0,	/* EXACTL       */
	0,	/* EXACTF       */
	0,	/* EXACTFL      */
	0,	/* EXACTFU      */
	0,	/* EXACTFA      */
	0,	/* EXACTFU_SS   */
	0,	/* EXACTFLU8    */
	0,	/* EXACTFA_NO_TRIE */
	0,	/* NOTHING      */
	0,	/* TAIL         */
	0,	/* STAR         */
	0,	/* PLUS         */
	0,	/* CURLY        */
	0,	/* CURLYN       */
	0,	/* CURLYM       */
	0,	/* CURLYX       */
	0,	/* WHILEM       */
	0,	/* OPEN         */
	0,	/* CLOSE        */
	0,	/* REF          */
	0,	/* REFF         */
	0,	/* REFFL        */
	0,	/* REFFU        */
	0,	/* REFFA        */
	0,	/* NREF         */
	0,	/* NREFF        */
	0,	/* NREFFL       */
	0,	/* NREFFU       */
	0,	/* NREFFA       */
	1,	/* LONGJMP      */
	1,	/* BRANCHJ      */
	2,	/* IFMATCH      */
	2,	/* UNLESSM      */
	1,	/* SUSPEND      */
	1,	/* IFTHEN       */
	0,	/* GROUPP       */
	0,	/* EVAL         */
	0,	/* MINMOD       */
	0,	/* LOGICAL      */
	1,	/* RENUM        */
	0,	/* TRIE         */
	0,	/* TRIEC        */
	0,	/* AHOCORASICK  */
	0,	/* AHOCORASICKC */
	0,	/* GOSUB        */
	0,	/* NGROUPP      */
	0,	/* INSUBP       */
	0,	/* DEFINEP      */
	0,	/* ENDLIKE      */
	0,	/* OPFAIL       */
	0,	/* ACCEPT       */
	0,	/* VERB         */
	0,	/* PRUNE        */
	0,	/* MARKPOINT    */
	0,	/* SKIP         */
	0,	/* COMMIT       */
	0,	/* CUTGROUP     */
	0,	/* KEEPS        */
	0,	/* LNBREAK      */
	0,	/* OPTIMIZED    */
	0,	/* PSEUDO       */
};

#endif /* REG_COMP_C */


/* reg_name[] - Opcode/state names in string form, for debugging */

#ifndef DOINIT
EXTCONST char * PL_reg_name[];
#else
EXTCONST char * const PL_reg_name[] = {
	"END",                   	/* 0000 */
	"SUCCEED",               	/* 0x01 */
	"SBOL",                  	/* 0x02 */
	"MBOL",                  	/* 0x03 */
	"SEOL",                  	/* 0x04 */
	"MEOL",                  	/* 0x05 */
	"EOS",                   	/* 0x06 */
	"GPOS",                  	/* 0x07 */
	"BOUND",                 	/* 0x08 */
	"BOUNDL",                	/* 0x09 */
	"BOUNDU",                	/* 0x0a */
	"BOUNDA",                	/* 0x0b */
	"NBOUND",                	/* 0x0c */
	"NBOUNDL",               	/* 0x0d */
	"NBOUNDU",               	/* 0x0e */
	"NBOUNDA",               	/* 0x0f */
	"REG_ANY",               	/* 0x10 */
	"SANY",                  	/* 0x11 */
	"ANYOF",                 	/* 0x12 */
	"ANYOFD",                	/* 0x13 */
	"ANYOFL",                	/* 0x14 */
	"POSIXD",                	/* 0x15 */
	"POSIXL",                	/* 0x16 */
	"POSIXU",                	/* 0x17 */
	"POSIXA",                	/* 0x18 */
	"NPOSIXD",               	/* 0x19 */
	"NPOSIXL",               	/* 0x1a */
	"NPOSIXU",               	/* 0x1b */
	"NPOSIXA",               	/* 0x1c */
	"CLUMP",                 	/* 0x1d */
	"BRANCH",                	/* 0x1e */
	"EXACT",                 	/* 0x1f */
	"EXACTL",                	/* 0x20 */
	"EXACTF",                	/* 0x21 */
	"EXACTFL",               	/* 0x22 */
	"EXACTFU",               	/* 0x23 */
	"EXACTFA",               	/* 0x24 */
	"EXACTFU_SS",            	/* 0x25 */
	"EXACTFLU8",             	/* 0x26 */
	"EXACTFA_NO_TRIE",       	/* 0x27 */
	"NOTHING",               	/* 0x28 */
	"TAIL",                  	/* 0x29 */
	"STAR",                  	/* 0x2a */
	"PLUS",                  	/* 0x2b */
	"CURLY",                 	/* 0x2c */
	"CURLYN",                	/* 0x2d */
	"CURLYM",                	/* 0x2e */
	"CURLYX",                	/* 0x2f */
	"WHILEM",                	/* 0x30 */
	"OPEN",                  	/* 0x31 */
	"CLOSE",                 	/* 0x32 */
	"REF",                   	/* 0x33 */
	"REFF",                  	/* 0x34 */
	"REFFL",                 	/* 0x35 */
	"REFFU",                 	/* 0x36 */
	"REFFA",                 	/* 0x37 */
	"NREF",                  	/* 0x38 */
	"NREFF",                 	/* 0x39 */
	"NREFFL",                	/* 0x3a */
	"NREFFU",                	/* 0x3b */
	"NREFFA",                	/* 0x3c */
	"LONGJMP",               	/* 0x3d */
	"BRANCHJ",               	/* 0x3e */
	"IFMATCH",               	/* 0x3f */
	"UNLESSM",               	/* 0x40 */
	"SUSPEND",               	/* 0x41 */
	"IFTHEN",                	/* 0x42 */
	"GROUPP",                	/* 0x43 */
	"EVAL",                  	/* 0x44 */
	"MINMOD",                	/* 0x45 */
	"LOGICAL",               	/* 0x46 */
	"RENUM",                 	/* 0x47 */
	"TRIE",                  	/* 0x48 */
	"TRIEC",                 	/* 0x49 */
	"AHOCORASICK",           	/* 0x4a */
	"AHOCORASICKC",          	/* 0x4b */
	"GOSUB",                 	/* 0x4c */
	"NGROUPP",               	/* 0x4d */
	"INSUBP",                	/* 0x4e */
	"DEFINEP",               	/* 0x4f */
	"ENDLIKE",               	/* 0x50 */
	"OPFAIL",                	/* 0x51 */
	"ACCEPT",                	/* 0x52 */
	"VERB",                  	/* 0x53 */
	"PRUNE",                 	/* 0x54 */
	"MARKPOINT",             	/* 0x55 */
	"SKIP",                  	/* 0x56 */
	"COMMIT",                	/* 0x57 */
	"CUTGROUP",              	/* 0x58 */
	"KEEPS",                 	/* 0x59 */
	"LNBREAK",               	/* 0x5a */
	"OPTIMIZED",             	/* 0x5b */
	"PSEUDO",                	/* 0x5c */
	/* ------------ States ------------- */
	"TRIE_next",             	/* REGNODE_MAX +0x01 */
	"TRIE_next_fail",        	/* REGNODE_MAX +0x02 */
	"EVAL_AB",               	/* REGNODE_MAX +0x03 */
	"EVAL_AB_fail",          	/* REGNODE_MAX +0x04 */
	"CURLYX_end",            	/* REGNODE_MAX +0x05 */
	"CURLYX_end_fail",       	/* REGNODE_MAX +0x06 */
	"WHILEM_A_pre",          	/* REGNODE_MAX +0x07 */
	"WHILEM_A_pre_fail",     	/* REGNODE_MAX +0x08 */
	"WHILEM_A_min",          	/* REGNODE_MAX +0x09 */
	"WHILEM_A_min_fail",     	/* REGNODE_MAX +0x0a */
	"WHILEM_A_max",          	/* REGNODE_MAX +0x0b */
	"WHILEM_A_max_fail",     	/* REGNODE_MAX +0x0c */
	"WHILEM_B_min",          	/* REGNODE_MAX +0x0d */
	"WHILEM_B_min_fail",     	/* REGNODE_MAX +0x0e */
	"WHILEM_B_max",          	/* REGNODE_MAX +0x0f */
	"WHILEM_B_max_fail",     	/* REGNODE_MAX +0x10 */
	"BRANCH_next",           	/* REGNODE_MAX +0x11 */
	"BRANCH_next_fail",      	/* REGNODE_MAX +0x12 */
	"CURLYM_A",              	/* REGNODE_MAX +0x13 */
	"CURLYM_A_fail",         	/* REGNODE_MAX +0x14 */
	"CURLYM_B",              	/* REGNODE_MAX +0x15 */
	"CURLYM_B_fail",         	/* REGNODE_MAX +0x16 */
	"IFMATCH_A",             	/* REGNODE_MAX +0x17 */
	"IFMATCH_A_fail",        	/* REGNODE_MAX +0x18 */
	"CURLY_B_min_known",     	/* REGNODE_MAX +0x19 */
	"CURLY_B_min_known_fail",	/* REGNODE_MAX +0x1a */
	"CURLY_B_min",           	/* REGNODE_MAX +0x1b */
	"CURLY_B_min_fail",      	/* REGNODE_MAX +0x1c */
	"CURLY_B_max",           	/* REGNODE_MAX +0x1d */
	"CURLY_B_max_fail",      	/* REGNODE_MAX +0x1e */
	"COMMIT_next",           	/* REGNODE_MAX +0x1f */
	"COMMIT_next_fail",      	/* REGNODE_MAX +0x20 */
	"MARKPOINT_next",        	/* REGNODE_MAX +0x21 */
	"MARKPOINT_next_fail",   	/* REGNODE_MAX +0x22 */
	"SKIP_next",             	/* REGNODE_MAX +0x23 */
	"SKIP_next_fail",        	/* REGNODE_MAX +0x24 */
	"CUTGROUP_next",         	/* REGNODE_MAX +0x25 */
	"CUTGROUP_next_fail",    	/* REGNODE_MAX +0x26 */
	"KEEPS_next",            	/* REGNODE_MAX +0x27 */
	"KEEPS_next_fail",       	/* REGNODE_MAX +0x28 */
};
#endif /* DOINIT */

/* PL_reg_extflags_name[] - Opcode/state names in string form, for debugging */

#ifndef DOINIT
EXTCONST char * PL_reg_extflags_name[];
#else
EXTCONST char * const PL_reg_extflags_name[] = {
	/* Bits in extflags defined: 11111111111111110000111111111111 */
	"MULTILINE",        /* 0x00000001 */
	"SINGLELINE",       /* 0x00000002 */
	"FOLD",             /* 0x00000004 */
	"EXTENDED",         /* 0x00000008 */
	"EXTENDED_MORE",    /* 0x00000010 */
	"NOCAPTURE",        /* 0x00000020 */
	"KEEPCOPY",         /* 0x00000040 */
	"CHARSET0",         /* 0x00000080 : "CHARSET" - 0x00000380 */
	"CHARSET1",         /* 0x00000100 : "CHARSET" - 0x00000380 */
	"CHARSET2",         /* 0x00000200 : "CHARSET" - 0x00000380 */
	"STRICT",           /* 0x00000400 */
	"SPLIT",            /* 0x00000800 */
	"UNUSED_BIT_12",    /* 0x00001000 */
	"UNUSED_BIT_13",    /* 0x00002000 */
	"UNUSED_BIT_14",    /* 0x00004000 */
	"UNUSED_BIT_15",    /* 0x00008000 */
	"NO_INPLACE_SUBST", /* 0x00010000 */
	"EVAL_SEEN",        /* 0x00020000 */
	"UNBOUNDED_QUANTIFIER_SEEN",/* 0x00040000 */
	"CHECK_ALL",        /* 0x00080000 */
	"MATCH_UTF8",       /* 0x00100000 */
	"USE_INTUIT_NOML",  /* 0x00200000 */
	"USE_INTUIT_ML",    /* 0x00400000 */
	"INTUIT_TAIL",      /* 0x00800000 */
	"IS_ANCHORED",      /* 0x01000000 */
	"COPY_DONE",        /* 0x02000000 */
	"TAINTED_SEEN",     /* 0x04000000 */
	"TAINTED",          /* 0x08000000 */
	"START_ONLY",       /* 0x10000000 */
	"SKIPWHITE",        /* 0x20000000 */
	"WHITE",            /* 0x40000000 */
	"NULL",             /* 0x80000000 */
};
#endif /* DOINIT */

#ifdef DEBUGGING
#  define REG_EXTFLAGS_NAME_SIZE 32
#endif

/* PL_reg_intflags_name[] - Opcode/state names in string form, for debugging */

#ifndef DOINIT
EXTCONST char * PL_reg_intflags_name[];
#else
EXTCONST char * const PL_reg_intflags_name[] = {
	"SKIP",                       /* 0x00000001 - PREGf_SKIP */
	"IMPLICIT",                   /* 0x00000002 - PREGf_IMPLICIT -  Converted .* to ^.*  */
	"NAUGHTY",                    /* 0x00000004 - PREGf_NAUGHTY -  how exponential is this pattern?  */
	"VERBARG_SEEN",               /* 0x00000008 - PREGf_VERBARG_SEEN */
	"CUTGROUP_SEEN",              /* 0x00000010 - PREGf_CUTGROUP_SEEN */
	"USE_RE_EVAL",                /* 0x00000020 - PREGf_USE_RE_EVAL -  compiled with "use re 'eval'"  */
	"NOSCAN",                     /* 0x00000040 - PREGf_NOSCAN */
	"GPOS_SEEN",                  /* 0x00000100 - PREGf_GPOS_SEEN */
	"GPOS_FLOAT",                 /* 0x00000200 - PREGf_GPOS_FLOAT */
	"ANCH_MBOL",                  /* 0x00000400 - PREGf_ANCH_MBOL */
	"ANCH_SBOL",                  /* 0x00000800 - PREGf_ANCH_SBOL */
	"ANCH_GPOS",                  /* 0x00001000 - PREGf_ANCH_GPOS */
	"RECURSE_SEEN",               /* 0x00002000 - PREGf_RECURSE_SEEN */
};
#endif /* DOINIT */

#ifdef DEBUGGING
#  define REG_INTFLAGS_NAME_SIZE 13
#endif

/* The following have no fixed length. U8 so we can do strchr() on it. */
#define REGNODE_VARIES(node) (PL_varies_bitmask[(node) >> 3] & (1 << ((node) & 7)))

#ifndef DOINIT
EXTCONST U8 PL_varies[] __attribute__deprecated__;
#else
EXTCONST U8 PL_varies[] __attribute__deprecated__ = {
    CLUMP, BRANCH, STAR, PLUS, CURLY, CURLYN, CURLYM, CURLYX, WHILEM, REF,
    REFF, REFFL, REFFU, REFFA, NREF, NREFF, NREFFL, NREFFU, NREFFA,
    BRANCHJ, SUSPEND, IFTHEN,
    0
};
#endif /* DOINIT */

#ifndef DOINIT
EXTCONST U8 PL_varies_bitmask[];
#else
EXTCONST U8 PL_varies_bitmask[] = {
    0x00, 0x00, 0x00, 0x60, 0x00, 0xFC, 0xF9, 0x5F, 0x06, 0x00, 0x00, 0x00
};
#endif /* DOINIT */

/* The following always have a length of 1. U8 we can do strchr() on it. */
/* (Note that length 1 means "one character" under UTF8, not "one octet".) */
#define REGNODE_SIMPLE(node) (PL_simple_bitmask[(node) >> 3] & (1 << ((node) & 7)))

#ifndef DOINIT
EXTCONST U8 PL_simple[] __attribute__deprecated__;
#else
EXTCONST U8 PL_simple[] __attribute__deprecated__ = {
    REG_ANY, SANY, ANYOF, ANYOFD, ANYOFL, POSIXD, POSIXL, POSIXU, POSIXA,
    NPOSIXD, NPOSIXL, NPOSIXU, NPOSIXA,
    0
};
#endif /* DOINIT */

#ifndef DOINIT
EXTCONST U8 PL_simple_bitmask[];
#else
EXTCONST U8 PL_simple_bitmask[] = {
    0x00, 0x00, 0xFF, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
#endif /* DOINIT */

/* ex: set ro: */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            /*    sv.h
 *
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
 *    2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

#ifdef sv_flags
#undef sv_flags		/* Convex has this in <signal.h> for sigvec() */
#endif

/*
=head1 SV Flags

=for apidoc AmU||svtype
An enum of flags for Perl types.  These are found in the file F<sv.h>
in the C<svtype> enum.  Test these flags with the C<SvTYPE> macro.

The types are:

    SVt_NULL
    SVt_IV
    SVt_NV
    SVt_RV
    SVt_PV
    SVt_PVIV
    SVt_PVNV
    SVt_PVMG
    SVt_INVLIST
    SVt_REGEXP
    SVt_PVGV
    SVt_PVLV
    SVt_PVAV
    SVt_PVHV
    SVt_PVCV
    SVt_PVFM
    SVt_PVIO

These are most easily explained from the bottom up.

C<SVt_PVIO> is for I/O objects, C<SVt_PVFM> for formats, C<SVt_PVCV> for
subroutines, C<SVt_PVHV> for hashes and C<SVt_PVAV> for arrays.

All the others are scalar types, that is, things that can be bound to a
C<$> variable.  For these, the internal types are mostly orthogonal to
types in the Perl language.

Hence, checking C<< SvTYPE(sv) < SVt_PVAV >> is the best way to see whether
something is a scalar.

C<SVt_PVGV> represents a typeglob.  If C<!SvFAKE(sv)>, then it is a real,
incoercible typeglob.  If C<SvFAKE(sv)>, then it is a scalar to which a
typeglob has been assigned.  Assigning to it again will stop it from being
a typeglob.  C<SVt_PVLV> represents a scalar that delegates to another scalar
behind the scenes.  It is used, e.g., for the return value of C<substr> and
for tied hash and array elements.  It can hold any scalar value, including
a typeglob.  C<SVt_REGEXP> is for regular
expressions.  C<SVt_INVLIST> is for Perl
core internal use only.

C<SVt_PVMG> represents a "normal" scalar (not a typeglob, regular expression,
or delegate).  Since most scalars do not need all the internal fields of a
PVMG, we save memory by allocating smaller structs when possible.  All the
other types are just simpler forms of C<SVt_PVMG>, with fewer internal fields.
C<SVt_NULL> can only hold undef.  C<SVt_IV> can hold undef, an integer, or a
reference.  (C<SVt_RV> is an alias for C<SVt_IV>, which exists for backward
compatibility.)  C<SVt_NV> can hold any of those or a double.  C<SVt_PV> can only
hold C<undef> or a string.  C<SVt_PVIV> is a superset of C<SVt_PV> and C<SVt_IV>.
C<SVt_PVNV> is similar.  C<SVt_PVMG> can hold anything C<SVt_PVNV> can hold, but it
can, but does not have to, be blessed or magical.

=for apidoc AmU||SVt_NULL
Type flag for scalars.  See L</svtype>.

=for apidoc AmU||SVt_IV
Type flag for scalars.  See L</svtype>.

=for apidoc AmU||SVt_NV
Type flag for scalars.  See L</svtype>.

=for apidoc AmU||SVt_PV
Type flag for scalars.  See L</svtype>.

=for apidoc AmU||SVt_PVIV
Type flag for scalars.  See L</svtype>.

=for apidoc AmU||SVt_PVNV
Type flag for scalars.  See L</svtype>.

=for apidoc AmU||SVt_PVMG
Type flag for scalars.  See L</svtype>.

=for apidoc AmU||SVt_INVLIST
Type flag for scalars.  See L</svtype>.

=for apidoc AmU||SVt_REGEXP
Type flag for regular expressions.  See L</svtype>.

=for apidoc AmU||SVt_PVGV
Type flag for typeglobs.  See L</svtype>.

=for apidoc AmU||SVt_PVLV
Type flag for scalars.  See L</svtype>.

=for apidoc AmU||SVt_PVAV
Type flag for arrays.  See L</svtype>.

=for apidoc AmU||SVt_PVHV
Type flag for hashes.  See L</svtype>.

=for apidoc AmU||SVt_PVCV
Type flag for subroutines.  See L</svtype>.

=for apidoc AmU||SVt_PVFM
Type flag for formats.  See L</svtype>.

=for apidoc AmU||SVt_PVIO
Type flag for I/O objects.  See L</svtype>.

=cut

  These are ordered so that the simpler types have a lower value; SvUPGRADE
  doesn't allow you to upgrade from a higher numbered type to a lower numbered
  one; also there is code that assumes that anything that has as a PV component
  has a type numbered >= SVt_PV.
*/


typedef enum {
	SVt_NULL,	/* 0 */
	/* BIND was here, before INVLIST replaced it.  */
	SVt_IV,		/* 1 */
	SVt_NV,		/* 2 */
	/* RV was here, before it was merged with IV.  */
	SVt_PV,		/* 3 */
	SVt_INVLIST,	/* 4, implemented as a PV */
	SVt_PVIV,	/* 5 */
	SVt_PVNV,	/* 6 */
	SVt_PVMG,	/* 7 */
	SVt_REGEXP,	/* 8 */
	/* PVBM was here, before BIND replaced it.  */
	SVt_PVGV,	/* 9 */
	SVt_PVLV,	/* 10 */
	SVt_PVAV,	/* 11 */
	SVt_PVHV,	/* 12 */
	SVt_PVCV,	/* 13 */
	SVt_PVFM,	/* 14 */
	SVt_PVIO,	/* 15 */
	SVt_LAST	/* keep last in enum. used to size arrays */
} svtype;

/* *** any alterations to the SV types above need to be reflected in
 * SVt_MASK and the various PL_valid_types_* tables.  As of this writing those
 * tables are in perl.h.  There are also two affected names tables in dump.c,
 * one in B.xs, and 'bodies_by_type[]' in sv.c */

#define SVt_MASK 0xf	/* smallest bitmask that covers all types */

#ifndef PERL_CORE
/* Although Fast Boyer Moore tables are now being stored in PVGVs, for most
   purposes external code wanting to consider PVBM probably needs to think of
   PVMG instead.  */
#  define SVt_PVBM	SVt_PVMG
/* Anything wanting to create a reference from clean should ensure that it has
   a scalar of type SVt_IV now:  */
#  define SVt_RV	SVt_IV
#endif

/* There is collusion here with sv_clear - sv_clear exits early for SVt_NULL
   so never reaches the clause at the end that uses sv_type_details->body_size
   to determine whether to call safefree(). Hence body_size can be set
   non-zero to record the size of HEs, without fear of bogus frees.  */
#if defined(PERL_IN_HV_C) || defined(PERL_IN_XS_APITEST)
#define HE_SVSLOT	SVt_NULL
#endif
#ifdef PERL_IN_SV_C
#  define SVt_FIRST SVt_NULL	/* the type of SV that new_SV() in sv.c returns */
#endif

#define PERL_ARENA_ROOTS_SIZE	(SVt_LAST)

/* typedefs to eliminate some typing */
typedef struct he HE;
typedef struct hek HEK;

/* Using C's structural equivalence to help emulate C++ inheritance here... */

/* start with 2 sv-head building blocks */
#define _SV_HEAD(ptrtype) \
    ptrtype	sv_any;		/* pointer to body */	\
    U32		sv_refcnt;	/* how many references to us */	\
    U32		sv_flags	/* what we are */

#if NVSIZE <= IVSIZE
#  define _NV_BODYLESS_UNION NV svu_nv;
#else
#  define _NV_BODYLESS_UNION
#endif

#define _SV_HEAD_UNION \
    union {				\
	char*   svu_pv;		/* pointer to malloced string */	\
	IV      svu_iv;			\
	UV      svu_uv;			\
	_NV_BODYLESS_UNION		\
	SV*     svu_rv;		/* pointer to another SV */		\
	struct regexp* svu_rx;		\
	SV**    svu_array;		\
	HE**	svu_hash;		\
	GP*	svu_gp;			\
	PerlIO *svu_fp;			\
    }	sv_u				\
    _SV_HEAD_DEBUG

#ifdef DEBUG_LEAKING_SCALARS
#define _SV_HEAD_DEBUG ;\
    PERL_BITFIELD32 sv_debug_optype:9;	/* the type of OP that allocated us */ \
    PERL_BITFIELD32 sv_debug_inpad:1;	/* was allocated in a pad for an OP */ \
    PERL_BITFIELD32 sv_debug_line:16;	/* the line where we were allocated */ \
    UV		    sv_debug_serial;	/* serial number of sv allocation   */ \
    char *	    sv_debug_file;	/* the file where we were allocated */ \
    SV *	    sv_debug_parent	/* what we were cloned from (ithreads)*/
#else
#define _SV_HEAD_DEBUG
#endif

struct STRUCT_SV {		/* struct sv { */
    _SV_HEAD(void*);
    _SV_HEAD_UNION;
};

struct gv {
    _SV_HEAD(XPVGV*);		/* pointer to xpvgv body */
    _SV_HEAD_UNION;
};

struct cv {
    _SV_HEAD(XPVCV*);		/* pointer to xpvcv body */
    _SV_HEAD_UNION;
};

struct av {
    _SV_HEAD(XPVAV*);		/* pointer to xpvav body */
    _SV_HEAD_UNION;
};

struct hv {
    _SV_HEAD(XPVHV*);		/* pointer to xpvhv body */
    _SV_HEAD_UNION;
};

struct io {
    _SV_HEAD(XPVIO*);		/* pointer to xpvio body */
    _SV_HEAD_UNION;
};

struct p5rx {
    _SV_HEAD(struct regexp*);	/* pointer to regexp body */
    _SV_HEAD_UNION;
};

#undef _SV_HEAD
#undef _SV_HEAD_UNION		/* ensure no pollution */

/*
=head1 SV Manipulation Functions

=for apidoc Am|U32|SvREFCNT|SV* sv
Returns the value of the object's reference count.

=for apidoc Am|SV*|SvREFCNT_inc|SV* sv
Increments the reference count of the given SV, returning the SV.

All of the following C<SvREFCNT_inc>* macros are optimized versions of
C<SvREFCNT_inc>, and can be replaced with C<SvREFCNT_inc>.

=for apidoc Am|SV*|SvREFCNT_inc_NN|SV* sv
Same as C<SvREFCNT_inc>, but can only be used if you know C<sv>
is not C<NULL>.  Since we don't have to check the NULLness, it's faster
and smaller.

=for apidoc Am|void|SvREFCNT_inc_void|SV* sv
Same as C<SvREFCNT_inc>, but can only be used if you don't need the
return value.  The macro doesn't need to return a meaningful value.

=for apidoc Am|void|SvREFCNT_inc_void_NN|SV* sv
Same as C<SvREFCNT_inc>, but can only be used if you don't need the return
value, and you know that C<sv> is not C<NULL>.  The macro doesn't need
to return a meaningful value, or check for NULLness, so it's smaller
and faster.

=for apidoc Am|SV*|SvREFCNT_inc_simple|SV* sv
Same as C<SvREFCNT_inc>, but can only be used with expressions without side
effects.  Since we don't have to store a temporary value, it's faster.

=for apidoc Am|SV*|SvREFCNT_inc_simple_NN|SV* sv
Same as C<SvREFCNT_inc_simple>, but can only be used if you know C<sv>
is not C<NULL>.  Since we don't have to check the NULLness, it's faster
and smaller.

=for apidoc Am|void|SvREFCNT_inc_simple_void|SV* sv
Same as C<SvREFCNT_inc_simple>, but can only be used if you don't need the
return value.  The macro doesn't need to return a meaningful value.

=for apidoc Am|void|SvREFCNT_inc_simple_void_NN|SV* sv
Same as C<SvREFCNT_inc>, but can only be used if you don't need the return
value, and you know that C<sv> is not C<NULL>.  The macro doesn't need
to return a meaningful value, or check for NULLness, so it's smaller
and faster.

=for apidoc Am|void|SvREFCNT_dec|SV* sv
Decrements the reference count of the given SV.  C<sv> may be C<NULL>.

=for apidoc Am|void|SvREFCNT_dec_NN|SV* sv
Same as C<SvREFCNT_dec>, but can only be used if you know C<sv>
is not C<NULL>.  Since we don't have to check the NULLness, it's faster
and smaller.

=for apidoc Am|svtype|SvTYPE|SV* sv
Returns the type of the SV.  See C<L</svtype>>.

=for apidoc Am|void|SvUPGRADE|SV* sv|svtype type
Used to upgrade an SV to a more complex form.  Uses C<sv_upgrade> to
perform the upgrade if necessary.  See C<L</svtype>>.

=cut
*/

#define SvANY(sv)	(sv)->sv_any
#define SvFLAGS(sv)	(sv)->sv_flags
#define SvREFCNT(sv)	(sv)->sv_refcnt

#define SvREFCNT_inc(sv)		S_SvREFCNT_inc(MUTABLE_SV(sv))
#define SvREFCNT_inc_simple(sv)		SvREFCNT_inc(sv)
#define SvREFCNT_inc_NN(sv)		S_SvREFCNT_inc_NN(MUTABLE_SV(sv))
#define SvREFCNT_inc_void(sv)		S_SvREFCNT_inc_void(MUTABLE_SV(sv))

/* These guys don't need the curly blocks */
#define SvREFCNT_inc_simple_void(sv)	STMT_START { if (sv) SvREFCNT(sv)++; } STMT_END
#define SvREFCNT_inc_simple_NN(sv)	(++(SvREFCNT(sv)),MUTABLE_SV(sv))
#define SvREFCNT_inc_void_NN(sv)	(void)(++SvREFCNT(MUTABLE_SV(sv)))
#define SvREFCNT_inc_simple_void_NN(sv)	(void)(++SvREFCNT(MUTABLE_SV(sv)))

#define SvREFCNT_dec(sv)	S_SvREFCNT_dec(aTHX_ MUTABLE_SV(sv))
#define SvREFCNT_dec_NN(sv)	S_SvREFCNT_dec_NN(aTHX_ MUTABLE_SV(sv))

#define SVTYPEMASK	0xff
#define SvTYPE(sv)	((svtype)((sv)->sv_flags & SVTYPEMASK))

/* Sadly there are some parts of the core that have pointers to already-freed
   SV heads, and rely on being able to tell that they are now free. So mark
   them all by using a consistent macro.  */
#define SvIS_FREED(sv)	UNLIKELY(((sv)->sv_flags == SVTYPEMASK))

/* this is defined in this peculiar way to avoid compiler warnings.
 * See the <20121213131428.GD1842@iabyn.com> thread in p5p */
#define SvUPGRADE(sv, mt) \
    ((void)(SvTYPE(sv) >= (mt) || (sv_upgrade(sv, mt),1)))

#define SVf_IOK		0x00000100  /* has valid public integer value */
#define SVf_NOK		0x00000200  /* has valid public numeric value */
#define SVf_POK		0x00000400  /* has valid public pointer value */
#define SVf_ROK		0x00000800  /* has a valid reference pointer */

#define SVp_IOK		0x00001000  /* has valid non-public integer value */
#define SVp_NOK		0x00002000  /* has valid non-public numeric value */
#define SVp_POK		0x00004000  /* has valid non-public pointer value */
#define SVp_SCREAM	0x00008000  /* method name is DOES */
                                    /* eval cx text is ref counted */
#define SVphv_CLONEABLE	SVp_SCREAM  /* PVHV (stashes) clone its objects */
#define SVpgv_GP	SVp_SCREAM  /* GV has a valid GP */
#define SVprv_PCS_IMPORTED  SVp_SCREAM  /* RV is a proxy for a constant
				       subroutine in another package. Set the
				       GvIMPORTED_CV_on() if it needs to be
				       expanded to a real GV */
#define SVf_PROTECT	0x00010000  /* very read-only */
#define SVs_PADTMP	0x00020000  /* in use as tmp */
#define SVs_PADSTALE	0x00040000  /* lexical has gone out of scope;
					only used when !PADTMP */
#define SVs_TEMP	0x00080000  /* mortal (implies string is stealable) */
#define SVs_OBJECT	0x00100000  /* is "blessed" */
#define SVs_GMG		0x00200000  /* has magical get method */
#define SVs_SMG		0x00400000  /* has magical set method */
#define SVs_RMG		0x00800000  /* has random magical methods */

#define SVf_FAKE	0x01000000  /* 0: glob is just a copy
				       1: SV head arena wasn't malloc()ed
				       2: For PVCV, whether CvUNIQUE(cv)
					  refers to an eval or once only
					  [CvEVAL(cv), CvSPECIAL(cv)]
                                       3: HV: informally reserved by DAPM
                                          for vtables */
#define SVf_OOK		0x02000000  /* has valid offset value. For a PVHV this
				       means that a hv_aux struct is present
				       after the main array */
#define SVf_BREAK	0x04000000  /* refcnt is artificially low - used by
				       SVs in final arena cleanup.
				       Set in S_regtry on PL_reg_curpm, so that
				       perl_destruct will skip it.
                                       Used for mark and sweep by OP_AASSIGN
                                       */
#define SVf_READONLY	0x08000000  /* may not be modified */




#define SVf_THINKFIRST	(SVf_READONLY|SVf_PROTECT|SVf_ROK|SVf_FAKE \
			|SVs_RMG|SVf_IsCOW)

#define SVf_OK		(SVf_IOK|SVf_NOK|SVf_POK|SVf_ROK| \
			 SVp_IOK|SVp_NOK|SVp_POK|SVpgv_GP)

#define PRIVSHIFT 4	/* (SVp_?OK >> PRIVSHIFT) == SVf_?OK */

/* Note that SVf_AMAGIC is now only set on stashes.  */
#define SVf_AMAGIC	0x10000000  /* has magical overloaded methods */
#define SVf_IsCOW	0x10000000  /* copy on write (shared hash key if
				       SvLEN == 0) */

/* Ensure this value does not clash with the GV_ADD* flags in gv.h, or the
   CV_CKPROTO_* flags in op.c, or the padadd_* flags in pad.h: */
#define SVf_UTF8        0x20000000  /* SvPV is UTF-8 encoded
				       This is also set on RVs whose overloaded
				       stringification is UTF-8. This might
				       only happen as a side effect of SvPV() */
/* PVHV */
#define SVphv_SHAREKEYS 0x20000000  /* PVHV keys live on shared string table */

/* PVAV could probably use 0x2000000 without conflict. I assume that PVFM can
   be UTF-8 encoded, and PVCVs could well have UTF-8 prototypes. PVIOs haven't
   been restructured, so sometimes get used as string buffers.  */


/* Some private flags. */


/* The SVp_SCREAM|SVpbm_VALID (0x40008000) combination is up for grabs.
   Formerly it was used for pad names, but now it is available.  The core
   is careful to avoid setting both flags.

   SVf_POK, SVp_POK also set:
   0x00004400   Normal
   0x0000C400   method name for DOES (SvSCREAM)
   0x40004400   FBM compiled (SvVALID)
   0x4000C400   *** Formerly used for pad names ***

   0x00008000   GV with GP
   0x00008800   RV with PCS imported
*/
/* PVAV */
#define SVpav_REAL	0x40000000  /* free old entries */
/* PVHV */
#define SVphv_LAZYDEL	0x40000000  /* entry in xhv_eiter must be deleted */
/* This is only set true on a PVGV when it's playing "PVBM", but is tested for
   on any regular scalar (anything <= PVLV) */
#define SVpbm_VALID	0x40000000
/* Only used in toke.c on an SV stored in PL_lex_repl */
#define SVrepl_EVAL	0x40000000  /* Replacement part of s///e */

/* IV, PVIV, PVNV, PVMG, PVGV and (I assume) PVLV  */
#define SVf_IVisUV	0x80000000  /* use XPVUV instead of XPVIV */
/* PVAV */
#define SVpav_REIFY 	0x80000000  /* can become real */
/* PVHV */
#define SVphv_HASKFLAGS	0x80000000  /* keys have flag byte after hash */
/* PVGV when SVpbm_VALID is true */
#define SVpbm_TAIL	0x80000000  /* string has a fake "\n" appended */
/* RV upwards. However, SVf_ROK and SVp_IOK are exclusive  */
#define SVprv_WEAKREF   0x80000000  /* Weak reference */
/* pad name vars only */

#define _XPV_HEAD							\
    HV*		xmg_stash;	/* class package */			\
    union _xmgu	xmg_u;							\
    STRLEN	xpv_cur;	/* length of svu_pv as a C string */    \
    union {								\
	STRLEN	xpvlenu_len; 	/* allocated size */			\
	char *	xpvlenu_pv;	/* regexp string */			\
    } xpv_len_u	

#define xpv_len	xpv_len_u.xpvlenu_len

union _xnvu {
    NV	    xnv_nv;		/* numeric value, if any */
    HV *    xgv_stash;
    struct {
	U32 xlow;
	U32 xhigh;
    }	    xpad_cop_seq;	/* used by pad.c for cop_sequence */
};

union _xivu {
    IV	    xivu_iv;		/* integer value */
    UV	    xivu_uv;
    HEK *   xivu_namehek;	/* xpvlv, xpvgv: GvNAME */
};

union _xmgu {
    MAGIC*  xmg_magic;		/* linked list of magicalness */
    STRLEN  xmg_hash_index;	/* used while freeing hash entries */
};

struct xpv {
    _XPV_HEAD;
};

struct xpviv {
    _XPV_HEAD;
    union _xivu xiv_u;
};

#define xiv_iv xiv_u.xivu_iv

struct xpvuv {
    _XPV_HEAD;
    union _xivu xuv_u;
};

#define xuv_uv xuv_u.xivu_uv

struct xpvnv {
    _XPV_HEAD;
    union _xivu xiv_u;
    union _xnvu xnv_u;
};

/* This structure must match the beginning of struct xpvhv in hv.h. */
struct xpvmg {
    _XPV_HEAD;
    union _xivu xiv_u;
    union _xnvu xnv_u;
};

struct xpvlv {
    _XPV_HEAD;
    union _xivu xiv_u;
    union _xnvu xnv_u;
    union {
	STRLEN	xlvu_targoff;
	SSize_t xlvu_stargoff;
    } xlv_targoff_u;
    STRLEN	xlv_targlen;
    SV*		xlv_targ;
    char	xlv_type;	/* k=keys .=pos x=substr v=vec /=join/re
				 * y=alem/helem/iter t=tie T=tied HE */
    char	xlv_flags;	/* 1 = negative offset  2 = negative len */
};

#define xlv_targoff xlv_targoff_u.xlvu_targoff

struct xpvinvlist {
    _XPV_HEAD;
    IV          prev_index;     /* caches result of previous invlist_search() */
    STRLEN	iterator;       /* Stores where we are in iterating */
    bool	is_offset;	/* The data structure for all inversion lists
                                   begins with an element for code point U+0000.
                                   If this bool is set, the actual list contains
                                   that 0; otherwise, the list actually begins
                                   with the following element.  Thus to invert
                                   the list, merely toggle this flag  */
};

/* This structure works in 3 ways - regular scalar, GV with GP, or fast
   Boyer-Moore.  */
struct xpvgv {
    _XPV_HEAD;
    union _xivu xiv_u;
    union _xnvu xnv_u;
};

typedef U32 cv_flags_t;

#define _XPVCV_COMMON								\
    HV *	xcv_stash;							\
    union {									\
	OP *	xcv_start;							\
	ANY	xcv_xsubany;							\
    }		xcv_start_u;					    		\
    union {									\
	OP *	xcv_root;							\
	void	(*xcv_xsub) (pTHX_ CV*);					\
    }		xcv_root_u;							\
    union {								\
	GV *	xcv_gv;							\
	HEK *	xcv_hek;						\
    }		xcv_gv_u;						\
    char *	xcv_file;							\
    union {									\
	PADLIST *	xcv_padlist;						\
	void *		xcv_hscxt;						\
    }		xcv_padlist_u;							\
    CV *	xcv_outside;							\
    U32		xcv_outside_seq; /* the COP sequence (at the point of our	\
				  * compilation) in the lexically enclosing	\
				  * sub */					\
    cv_flags_t	xcv_flags;						\
    I32	xcv_depth	/* >= 2 indicates recursive call */

/* This structure must match XPVCV in cv.h */

struct xpvfm {
    _XPV_HEAD;
    _XPVCV_COMMON;
};


struct xpvio {
    _XPV_HEAD;
    union _xivu xiv_u;
    /* ifp and ofp are normally the same, but sockets need separate streams */
    PerlIO *	xio_ofp;
    /* Cray addresses everything by word boundaries (64 bits) and
     * code and data pointers cannot be mixed (which is exactly what
     * Perl_filter_add() tries to do with the dirp), hence the
     *  following union trick (as suggested by Gurusamy Sarathy).
     * For further information see Geir Johansen's problem report
     * titled [ID 20000612.002] Perl problem on Cray system
     * The any pointer (known as IoANY()) will also be a good place
     * to hang any IO disciplines to.
     */
    union {
	DIR *	xiou_dirp;	/* for opendir, readdir, etc */
	void *	xiou_any;	/* for alignment */
    } xio_dirpu;
    /* IV xio_lines is now in IVX  $. */
    IV		xio_page;	/* $% */
    IV		xio_page_len;	/* $= */
    IV		xio_lines_left;	/* $- */
    char *	xio_top_name;	/* $^ */
    GV *	xio_top_gv;	/* $^ */
    char *	xio_fmt_name;	/* $~ */
    GV *	xio_fmt_gv;	/* $~ */
    char *	xio_bottom_name;/* $^B */
    GV *	xio_bottom_gv;	/* $^B */
    char	xio_type;
    U8		xio_flags;
};

#define xio_dirp	xio_dirpu.xiou_dirp
#define xio_any		xio_dirpu.xiou_any

#define IOf_ARGV	1	/* this fp iterates over ARGV */
#define IOf_START	2	/* check for null ARGV and substitute '-' */
#define IOf_FLUSH	4	/* this fp wants a flush after write op */
#define IOf_DIDTOP	8	/* just did top of form */
#define IOf_UNTAINT	16	/* consider this fp (and its data) "safe" */
#define IOf_NOLINE	32	/* slurped a pseudo-line from empty file */
#define IOf_FAKE_DIRP	64	/* xio_dirp is fake (source filters kludge)
				   Also, when this is set, SvPVX() is valid */

/* The following macros define implementation-independent predicates on SVs. */

/*
=for apidoc Am|U32|SvNIOK|SV* sv
Returns a U32 value indicating whether the SV contains a number, integer or
double.

=for apidoc Am|U32|SvNIOKp|SV* sv
Returns a U32 value indicating whether the SV contains a number, integer or
double.  Checks the B<private> setting.  Use C<SvNIOK> instead.

=for apidoc Am|void|SvNIOK_off|SV* sv
Unsets the NV/IV status of an SV.

=for apidoc Am|U32|SvOK|SV* sv
Returns a U32 value indicating whether the value is defined.  This is
only meaningful for scalars.

=for apidoc Am|U32|SvIOKp|SV* sv
Returns a U32 value indicating whether the SV contains an integer.  Checks
the B<private> setting.  Use C<SvIOK> instead.

=for apidoc Am|U32|SvNOKp|SV* sv
Returns a U32 value indicating whether the SV contains a double.  Checks the
B<private> setting.  Use C<SvNOK> instead.

=for apidoc Am|U32|SvPOKp|SV* sv
Returns a U32 value indicating whether the SV contains a character string.
Checks the B<private> setting.  Use C<SvPOK> instead.

=for apidoc Am|U32|SvIOK|SV* sv
Returns a U32 value indicating whether the SV contains an integer.

=for apidoc Am|void|SvIOK_on|SV* sv
Tells an SV that it is an integer.

=for apidoc Am|void|SvIOK_off|SV* sv
Unsets the IV status of an SV.

=for apidoc Am|void|SvIOK_only|SV* sv
Tells an SV that it is an integer and disables all other C<OK> bits.

=for apidoc Am|void|SvIOK_only_UV|SV* sv
Tells an SV that it is an unsigned integer and disables all other C<OK> bits.

=for apidoc Am|bool|SvIOK_UV|SV* sv
Returns a boolean indicating whether the SV contains an integer that must be
interpreted as unsigned.  A non-negative integer whose value is within the
range of both an IV and a UV may be be flagged as either C<SvUOK> or C<SVIOK>.

=for apidoc Am|bool|SvUOK|SV* sv
Returns a boolean indicating whether the SV contains an integer that must be
interpreted as unsigned.  A non-negative integer whose value is within the
range of both an IV and a UV may be be flagged as either C<SvUOK> or C<SVIOK>.

=for apidoc Am|bool|SvIOK_notUV|SV* sv
Returns a boolean indicating whether the SV contains a signed integer.

=for apidoc Am|U32|SvNOK|SV* sv
Returns a U32 value indicating whether the SV contains a double.

=for apidoc Am|void|SvNOK_on|SV* sv
Tells an SV that it is a double.

=for apidoc Am|void|SvNOK_off|SV* sv
Unsets the NV status of an SV.

=for apidoc Am|void|SvNOK_only|SV* sv
Tells an SV that it is a double and disables all other OK bits.

=for apidoc Am|U32|SvPOK|SV* sv
Returns a U32 value indicating whether the SV contains a character
string.

=for apidoc Am|void|SvPOK_on|SV* sv
Tells an SV that it is a string.

=for apidoc Am|void|SvPOK_off|SV* sv
Unsets the PV status of an SV.

=for apidoc Am|void|SvPOK_only|SV* sv
Tells an SV that it is a string and disables all other C<OK> bits.
Will also turn off the UTF-8 status.

=for apidoc Am|bool|SvVOK|SV* sv
Returns a boolean indicating whether the SV contains a v-string.

=for apidoc Am|U32|SvOOK|SV* sv
Returns a U32 indicating whether the pointer to the string buffer is offset.
This hack is used internally to speed up removal of characters from the
beginning of a C<SvPV>.  When C<SvOOK> is true, then the start of the
allocated string buffer is actually C<SvOOK_offset()> bytes before C<SvPVX>.
This offset used to be stored in C<SvIVX>, but is now stored within the spare
part of the buffer.

=for apidoc Am|U32|SvROK|SV* sv
Tests if the SV is an RV.

=for apidoc Am|void|SvROK_on|SV* sv
Tells an SV that it is an RV.

=for apidoc Am|void|SvROK_off|SV* sv
Unsets the RV status of an SV.

=for apidoc Am|SV*|SvRV|SV* sv
Dereferences an RV to return the SV.

=for apidoc Am|IV|SvIVX|SV* sv
Returns the raw value in the SV's IV slot, without checks or conversions.
Only use when you are sure C<SvIOK> is true.  See also C<L</SvIV>>.

=for apidoc Am|UV|SvUVX|SV* sv
Returns the raw value in the SV's UV slot, without checks or conversions.
Only use when you are sure C<SvIOK> is true.  See also C<L</SvUV>>.

=for apidoc Am|NV|SvNVX|SV* sv
Returns the raw value in the SV's NV slot, without checks or conversions.
Only use when you are sure C<SvNOK> is true.  See also C<L</SvNV>>.

=for apidoc Am|char*|SvPVX|SV* sv
Returns a pointer to the physical string in the SV.  The SV must contain a
string.  Prior to 5.9.3 it is not safe
to execute this macro unless the SV's
type >= C<SVt_PV>.

This is also used to store the name of an autoloaded subroutine in an XS
AUTOLOAD routine.  See L<perlguts/Autoloading with XSUBs>.

=for apidoc Am|STRLEN|SvCUR|SV* sv
Returns the length of the string which is in the SV.  See C<L</SvLEN>>.

=for apidoc Am|STRLEN|SvLEN|SV* sv
Returns the size of the string buffer in the SV, not including any part
attributable to C<SvOOK>.  See C<L</SvCUR>>.

=for apidoc Am|char*|SvEND|SV* sv
Returns a pointer to the spot just after the last character in
the string which is in the SV, where there is usually a trailing
C<NUL> character (even though Perl scalars do not strictly require it).
See C<L</SvCUR>>.  Access the character as C<*(SvEND(sv))>.

Warning: If C<SvCUR> is equal to C<SvLEN>, then C<SvEND> points to
unallocated memory.

=for apidoc Am|HV*|SvSTASH|SV* sv
Returns the stash of the SV.

=for apidoc Am|void|SvIV_set|SV* sv|IV val
Set the value of the IV pointer in sv to val.  It is possible to perform
the same function of this macro with an lvalue assignment to C<SvIVX>.
With future Perls, however, it will be more efficient to use 
C<SvIV_set> instead of the lvalue assignment to C<SvIVX>.

=for apidoc Am|void|SvNV_set|SV* sv|NV val
Set the value of the NV pointer in C<sv> to val.  See C<L</SvIV_set>>.

=for apidoc Am|void|SvPV_set|SV* sv|char* val
This is probably not what you want to use, you probably wanted
L</sv_usepvn_flags> or L</sv_setpvn> or L</sv_setpvs>.

Set the value of the PV pointer in C<sv> to the Perl allocated
C<NUL>-terminated string C<val>.  See also C<L</SvIV_set>>.

Remember to free the previous PV buffer. There are many things to check.
Beware that the existing pointer may be involved in copy-on-write or other
mischief, so do C<SvOOK_off(sv)> and use C<sv_force_normal> or
C<SvPV_force> (or check the C<SvIsCOW> flag) first to make sure this
modification is safe. Then finally, if it is not a COW, call C<SvPV_free> to
free the previous PV buffer.

=for apidoc Am|void|SvUV_set|SV* sv|UV val
Set the value of the UV pointer in C<sv> to val.  See C<L</SvIV_set>>.

=for apidoc Am|void|SvRV_set|SV* sv|SV* val
Set the value of the RV pointer in C<sv> to val.  See C<L</SvIV_set>>.

=for apidoc Am|void|SvMAGIC_set|SV* sv|MAGIC* val
Set the value of the MAGIC pointer in C<sv> to val.  See C<L</SvIV_set>>.

=for apidoc Am|void|SvSTASH_set|SV* sv|HV* val
Set the value of the STASH pointer in C<sv> to val.  See C<L</SvIV_set>>.

=for apidoc Am|void|SvCUR_set|SV* sv|STRLEN len
Set the current length of the string which is in the SV.  See C<L</SvCUR>>
and C<SvIV_set>>.

=for apidoc Am|void|SvLEN_set|SV* sv|STRLEN len
Set the size of the string buffer for the SV. See C<L</SvLEN>>.

=cut
*/

#define SvNIOK(sv)		(SvFLAGS(sv) & (SVf_IOK|SVf_NOK))
#define SvNIOKp(sv)		(SvFLAGS(sv) & (SVp_IOK|SVp_NOK))
#define SvNIOK_off(sv)		(SvFLAGS(sv) &= ~(SVf_IOK|SVf_NOK| \
						  SVp_IOK|SVp_NOK|SVf_IVisUV))

#define assert_not_ROK(sv)	assert_(!SvROK(sv) || !SvRV(sv))
#define assert_not_glob(sv)	assert_(!isGV_with_GP(sv))

#define SvOK(sv)		(SvFLAGS(sv) & SVf_OK || isREGEXP(sv))
#define SvOK_off(sv)		(assert_not_ROK(sv) assert_not_glob(sv)	\
				 SvFLAGS(sv) &=	~(SVf_OK|		\
						  SVf_IVisUV|SVf_UTF8),	\
							SvOOK_off(sv))
#define SvOK_off_exc_UV(sv)	(assert_not_ROK(sv)			\
				 SvFLAGS(sv) &=	~(SVf_OK|		\
						  SVf_UTF8),		\
							SvOOK_off(sv))

#define SvOKp(sv)		(SvFLAGS(sv) & (SVp_IOK|SVp_NOK|SVp_POK))
#define SvIOKp(sv)		(SvFLAGS(sv) & SVp_IOK)
#define SvIOKp_on(sv)		(assert_not_glob(sv)	\
				    SvFLAGS(sv) |= SVp_IOK)
#define SvNOKp(sv)		(SvFLAGS(sv) & SVp_NOK)
#define SvNOKp_on(sv)		(assert_not_glob(sv) SvFLAGS(sv) |= SVp_NOK)
#define SvPOKp(sv)		(SvFLAGS(sv) & SVp_POK)
#define SvPOKp_on(sv)		(assert_not_ROK(sv) assert_not_glob(sv)	\
				 SvFLAGS(sv) |= SVp_POK)

#define SvIOK(sv)		(SvFLAGS(sv) & SVf_IOK)
#define SvIOK_on(sv)		(assert_not_glob(sv)	\
				    SvFLAGS(sv) |= (SVf_IOK|SVp_IOK))
#define SvIOK_off(sv)		(SvFLAGS(sv) &= ~(SVf_IOK|SVp_IOK|SVf_IVisUV))
#define SvIOK_only(sv)		(SvOK_off(sv), \
				    SvFLAGS(sv) |= (SVf_IOK|SVp_IOK))
#define SvIOK_only_UV(sv)	(assert_not_glob(sv) SvOK_off_exc_UV(sv), \
				    SvFLAGS(sv) |= (SVf_IOK|SVp_IOK))

#define SvIOK_UV(sv)		((SvFLAGS(sv) & (SVf_IOK|SVf_IVisUV))	\
				 == (SVf_IOK|SVf_IVisUV))
#define SvUOK(sv)		SvIOK_UV(sv)
#define SvIOK_notUV(sv)		((SvFLAGS(sv) & (SVf_IOK|SVf_IVisUV))	\
				 == SVf_IOK)

#define SvIsUV(sv)		(SvFLAGS(sv) & SVf_IVisUV)
#define SvIsUV_on(sv)		(SvFLAGS(sv) |= SVf_IVisUV)
#define SvIsUV_off(sv)		(SvFLAGS(sv) &= ~SVf_IVisUV)

#define SvNOK(sv)		(SvFLAGS(sv) & SVf_NOK)
#define SvNOK_on(sv)		(assert_not_glob(sv) \
				 SvFLAGS(sv) |= (SVf_NOK|SVp_NOK))
#define SvNOK_off(sv)		(SvFLAGS(sv) &= ~(SVf_NOK|SVp_NOK))
#define SvNOK_only(sv)		(SvOK_off(sv), \
				    SvFLAGS(sv) |= (SVf_NOK|SVp_NOK))

/*
=for apidoc Am|U32|SvUTF8|SV* sv
Returns a U32 value indicating the UTF-8 status of an SV.  If things are set-up
properly, this indicates whether or not the SV contains UTF-8 encoded data.
You should use this I<after> a call to C<SvPV()> or one of its variants, in
case any call to string overloading updates the internal flag.

If you want to take into account the L<bytes> pragma, use C<L</DO_UTF8>>
instead.

=for apidoc Am|void|SvUTF8_on|SV *sv
Turn on the UTF-8 status of an SV (the data is not changed, just the flag).
Do not use frivolously.

=for apidoc Am|void|SvUTF8_off|SV *sv
Unsets the UTF-8 status of an SV (the data is not changed, just the flag).
Do not use frivolously.

=for apidoc Am|void|SvPOK_only_UTF8|SV* sv
Tells an SV that it is a string and disables all other C<OK> bits,
and leaves the UTF-8 status as it was.

=cut
 */

/* Ensure the return value of this macro does not clash with the GV_ADD* flags
in gv.h: */
#define SvUTF8(sv)		(SvFLAGS(sv) & SVf_UTF8)
#define SvUTF8_on(sv)		(SvFLAGS(sv) |= (SVf_UTF8))
#define SvUTF8_off(sv)		(SvFLAGS(sv) &= ~(SVf_UTF8))

#define SvPOK(sv)		(SvFLAGS(sv) & SVf_POK)
#define SvPOK_on(sv)		(assert_not_ROK(sv) assert_not_glob(sv)	\
				 SvFLAGS(sv) |= (SVf_POK|SVp_POK))
#define SvPOK_off(sv)		(SvFLAGS(sv) &= ~(SVf_POK|SVp_POK))
#define SvPOK_only(sv)		(assert_not_ROK(sv) assert_not_glob(sv)	\
				 SvFLAGS(sv) &= ~(SVf_OK|		\
						  SVf_IVisUV|SVf_UTF8),	\
				    SvFLAGS(sv) |= (SVf_POK|SVp_POK))
#define SvPOK_only_UTF8(sv)	(assert_not_ROK(sv) assert_not_glob(sv)	\
				 SvFLAGS(sv) &= ~(SVf_OK|		\
						  SVf_IVisUV),		\
				    SvFLAGS(sv) |= (SVf_POK|SVp_POK))

#define SvVOK(sv)		(SvMAGICAL(sv)				\
				 && mg_find(sv,PERL_MAGIC_vstring))
/* returns the vstring magic, if any */
#define SvVSTRING_mg(sv)	(SvMAGICAL(sv) \
				 ? mg_find(sv,PERL_MAGIC_vstring) : NULL)

#define SvOOK(sv)		(SvFLAGS(sv) & SVf_OOK)
#define SvOOK_on(sv)		(SvFLAGS(sv) |= SVf_OOK)
#define SvOOK_off(sv)		((void)(SvOOK(sv) && (sv_backoff(sv),0)))

#define SvFAKE(sv)		(SvFLAGS(sv) & SVf_FAKE)
#define SvFAKE_on(sv)		(SvFLAGS(sv) |= SVf_FAKE)
#define SvFAKE_off(sv)		(SvFLAGS(sv) &= ~SVf_FAKE)

#define SvROK(sv)		(SvFLAGS(sv) & SVf_ROK)
#define SvROK_on(sv)		(SvFLAGS(sv) |= SVf_ROK)
#define SvROK_off(sv)		(SvFLAGS(sv) &= ~(SVf_ROK))

#define SvMAGICAL(sv)		(SvFLAGS(sv) & (SVs_GMG|SVs_SMG|SVs_RMG))
#define SvMAGICAL_on(sv)	(SvFLAGS(sv) |= (SVs_GMG|SVs_SMG|SVs_RMG))
#define SvMAGICAL_off(sv)	(SvFLAGS(sv) &= ~(SVs_GMG|SVs_SMG|SVs_RMG))

#define SvGMAGICAL(sv)		(SvFLAGS(sv) & SVs_GMG)
#define SvGMAGICAL_on(sv)	(SvFLAGS(sv) |= SVs_GMG)
#define SvGMAGICAL_off(sv)	(SvFLAGS(sv) &= ~SVs_GMG)

#define SvSMAGICAL(sv)		(SvFLAGS(sv) & SVs_SMG)
#define SvSMAGICAL_on(sv)	(SvFLAGS(sv) |= SVs_SMG)
#define SvSMAGICAL_off(sv)	(SvFLAGS(sv) &= ~SVs_SMG)

#define SvRMAGICAL(sv)		(SvFLAGS(sv) & SVs_RMG)
#define SvRMAGICAL_on(sv)	(SvFLAGS(sv) |= SVs_RMG)
#define SvRMAGICAL_off(sv)	(SvFLAGS(sv) &= ~SVs_RMG)

#define SvAMAGIC(sv)		(SvROK(sv) && SvOBJECT(SvRV(sv)) &&	\
				 HvAMAGIC(SvSTASH(SvRV(sv))))

/* To be used on the stashes themselves: */
#define HvAMAGIC(hv)		(SvFLAGS(hv) & SVf_AMAGIC)
#define HvAMAGIC_on(hv)		(SvFLAGS(hv) |= SVf_AMAGIC)
#define HvAMAGIC_off(hv)	(SvFLAGS(hv) &=~ SVf_AMAGIC)


/* "nog" means "doesn't have get magic" */
#define SvPOK_nog(sv)		((SvFLAGS(sv) & (SVf_POK|SVs_GMG)) == SVf_POK)
#define SvIOK_nog(sv)		((SvFLAGS(sv) & (SVf_IOK|SVs_GMG)) == SVf_IOK)
#define SvUOK_nog(sv)		((SvFLAGS(sv) & (SVf_IOK|SVf_IVisUV|SVs_GMG)) == (SVf_IOK|SVf_IVisUV))
#define SvNOK_nog(sv)		((SvFLAGS(sv) & (SVf_NOK|SVs_GMG)) == SVf_NOK)
#define SvNIOK_nog(sv)		(SvNIOK(sv) && !(SvFLAGS(sv) & SVs_GMG))

#define SvPOK_nogthink(sv)	((SvFLAGS(sv) & (SVf_POK|SVf_THINKFIRST|SVs_GMG)) == SVf_POK)
#define SvIOK_nogthink(sv)	((SvFLAGS(sv) & (SVf_IOK|SVf_THINKFIRST|SVs_GMG)) == SVf_IOK)
#define SvUOK_nogthink(sv)	((SvFLAGS(sv) & (SVf_IOK|SVf_IVisUV|SVf_THINKFIRST|SVs_GMG)) == (SVf_IOK|SVf_IVisUV))
#define SvNOK_nogthink(sv)	((SvFLAGS(sv) & (SVf_NOK|SVf_THINKFIRST|SVs_GMG)) == SVf_NOK)
#define SvNIOK_nogthink(sv)	(SvNIOK(sv) && !(SvFLAGS(sv) & (SVf_THINKFIRST|SVs_GMG)))

#define SvPOK_utf8_nog(sv)	((SvFLAGS(sv) & (SVf_POK|SVf_UTF8|SVs_GMG)) == (SVf_POK|SVf_UTF8))
#define SvPOK_utf8_nogthink(sv)	((SvFLAGS(sv) & (SVf_POK|SVf_UTF8|SVf_THINKFIRST|SVs_GMG)) == (SVf_POK|SVf_UTF8))

#define SvPOK_byte_nog(sv)	((SvFLAGS(sv) & (SVf_POK|SVf_UTF8|SVs_GMG)) == SVf_POK)
#define SvPOK_byte_nogthink(sv)	((SvFLAGS(sv) & (SVf_POK|SVf_UTF8|SVf_THINKFIRST|SVs_GMG)) == SVf_POK)

#define SvPOK_pure_nogthink(sv) \
    ((SvFLAGS(sv) & (SVf_POK|SVf_IOK|SVf_NOK|SVf_ROK|SVpgv_GP|SVf_THINKFIRST|SVs_GMG)) == SVf_POK)
#define SvPOK_utf8_pure_nogthink(sv) \
    ((SvFLAGS(sv) & (SVf_POK|SVf_UTF8|SVf_IOK|SVf_NOK|SVf_ROK|SVpgv_GP|SVf_THINKFIRST|SVs_GMG)) == (SVf_POK|SVf_UTF8))
#define SvPOK_byte_pure_nogthink(sv) \
    ((SvFLAGS(sv) & (SVf_POK|SVf_UTF8|SVf_IOK|SVf_NOK|SVf_ROK|SVpgv_GP|SVf_THINKFIRST|SVs_GMG)) == SVf_POK)

/*
=for apidoc Am|U32|SvGAMAGIC|SV* sv

Returns true if the SV has get magic or
overloading.  If either is true then
the scalar is active data, and has the potential to return a new value every
time it is accessed.  Hence you must be careful to
only read it once per user logical operation and work
with that returned value.  If neither is true then
the scalar's value cannot change unless written to.

=cut
*/

#define SvGAMAGIC(sv)           (SvGMAGICAL(sv) || SvAMAGIC(sv))

#define Gv_AMG(stash) \
	(HvNAME(stash) && Gv_AMupdate(stash,FALSE) \
	    ? 1					    \
	    : (HvAMAGIC_off(stash), 0))

#define SvWEAKREF(sv)		((SvFLAGS(sv) & (SVf_ROK|SVprv_WEAKREF)) \
				  == (SVf_ROK|SVprv_WEAKREF))
#define SvWEAKREF_on(sv)	(SvFLAGS(sv) |=  (SVf_ROK|SVprv_WEAKREF))
#define SvWEAKREF_off(sv)	(SvFLAGS(sv) &= ~(SVf_ROK|SVprv_WEAKREF))

#define SvPCS_IMPORTED(sv)	((SvFLAGS(sv) & (SVf_ROK|SVprv_PCS_IMPORTED)) \
				 == (SVf_ROK|SVprv_PCS_IMPORTED))
#define SvPCS_IMPORTED_on(sv)	(SvFLAGS(sv) |=  (SVf_ROK|SVprv_PCS_IMPORTED))
#define SvPCS_IMPORTED_off(sv)	(SvFLAGS(sv) &= ~(SVf_ROK|SVprv_PCS_IMPORTED))

/*
=for apidoc m|U32|SvTHINKFIRST|SV *sv

A quick flag check to see whether an C<sv> should be passed to C<sv_force_normal>
to be "downgraded" before C<SvIVX> or C<SvPVX> can be modified directly.

For example, if your scalar is a reference and you want to modify the C<SvIVX>
slot, you can't just do C<SvROK_off>, as that will leak the referent.

This is used internally by various sv-modifying functions, such as
C<sv_setsv>, C<sv_setiv> and C<sv_pvn_force>.

One case that this does not handle is a gv without SvFAKE set.  After

    if (SvTHINKFIRST(gv)) sv_force_normal(gv);

it will still be a gv.

C<SvTHINKFIRST> sometimes produces false positives.  In those cases
C<sv_force_normal> does nothing.

=cut
*/

#define SvTHINKFIRST(sv)	(SvFLAGS(sv) & SVf_THINKFIRST)

#define SVs_PADMY		0
#define SvPADMY(sv)		!(SvFLAGS(sv) & SVs_PADTMP)
#ifndef PERL_CORE
# define SvPADMY_on(sv)		SvPADTMP_off(sv)
#endif

#define SvPADTMP(sv)		(SvFLAGS(sv) & (SVs_PADTMP))
#define SvPADSTALE(sv)		(SvFLAGS(sv) & (SVs_PADSTALE))

#define SvPADTMP_on(sv)		(SvFLAGS(sv) |= SVs_PADTMP)
#define SvPADTMP_off(sv)	(SvFLAGS(sv) &= ~SVs_PADTMP)
#define SvPADSTALE_on(sv)	S_SvPADSTALE_on(MUTABLE_SV(sv))
#define SvPADSTALE_off(sv)	S_SvPADSTALE_off(MUTABLE_SV(sv))

#define SvTEMP(sv)		(SvFLAGS(sv) & SVs_TEMP)
#define SvTEMP_on(sv)		(SvFLAGS(sv) |= SVs_TEMP)
#define SvTEMP_off(sv)		(SvFLAGS(sv) &= ~SVs_TEMP)

#define SvOBJECT(sv)		(SvFLAGS(sv) & SVs_OBJECT)
#define SvOBJECT_on(sv)		(SvFLAGS(sv) |= SVs_OBJECT)
#define SvOBJECT_off(sv)	(SvFLAGS(sv) &= ~SVs_OBJECT)

#define SvREADONLY(sv)		(SvFLAGS(sv) & (SVf_READONLY|SVf_PROTECT))
#ifdef PERL_CORE
# define SvREADONLY_on(sv)	(SvFLAGS(sv) |= (SVf_READONLY|SVf_PROTECT))
# define SvREADONLY_off(sv)	(SvFLAGS(sv) &=~(SVf_READONLY|SVf_PROTECT))
#else
# define SvREADONLY_on(sv)	(SvFLAGS(sv) |= SVf_READONLY)
# define SvREADONLY_off(sv)	(SvFLAGS(sv) &= ~SVf_READONLY)
#endif

#define SvSCREAM(sv) ((SvFLAGS(sv) & (SVp_SCREAM|SVp_POK)) == (SVp_SCREAM|SVp_POK))
#define SvSCREAM_on(sv)		(SvFLAGS(sv) |= SVp_SCREAM)
#define SvSCREAM_off(sv)	(SvFLAGS(sv) &= ~SVp_SCREAM)

#ifndef PERL_CORE
#  define SvCOMPILED(sv)	0
#  define SvCOMPILED_on(sv)
#  define SvCOMPILED_off(sv)
#endif

#define SvEVALED(sv)		(SvFLAGS(sv) & SVrepl_EVAL)
#define SvEVALED_on(sv)		(SvFLAGS(sv) |= SVrepl_EVAL)
#define SvEVALED_off(sv)	(SvFLAGS(sv) &= ~SVrepl_EVAL)

#if defined (DEBUGGING) && defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN)
#  define SvVALID(sv)		({ const SV *const _svvalid = (const SV*)(sv); \
				   if (SvFLAGS(_svvalid) & SVpbm_VALID && !SvSCREAM(_svvalid)) \
				       assert(!isGV_with_GP(_svvalid));	\
				   (SvFLAGS(_svvalid) & SVpbm_VALID);	\
				})
#  define SvVALID_on(sv)	({ SV *const _svvalid = MUTABLE_SV(sv);	\
				   assert(!isGV_with_GP(_svvalid));	\
				   assert(!SvSCREAM(_svvalid));		\
				   (SvFLAGS(_svvalid) |= SVpbm_VALID);	\
				})
#  define SvVALID_off(sv)	({ SV *const _svvalid = MUTABLE_SV(sv);	\
				   assert(!isGV_with_GP(_svvalid));	\
				   assert(!SvSCREAM(_svvalid));		\
				   (SvFLAGS(_svvalid) &= ~SVpbm_VALID);	\
				})

#  define SvTAIL(sv)	({ const SV *const _svtail = (const SV *)(sv);	\
			    assert(SvTYPE(_svtail) != SVt_PVAV);	\
			    assert(SvTYPE(_svtail) != SVt_PVHV);	\
			    assert(!SvSCREAM(_svtail));			\
			    (SvFLAGS(sv) & (SVpbm_TAIL|SVpbm_VALID))	\
				== (SVpbm_TAIL|SVpbm_VALID);		\
			})
#else
#  define SvVALID(sv)		((SvFLAGS(sv) & SVpbm_VALID) && !SvSCREAM(sv))
#  define SvVALID_on(sv)	(SvFLAGS(sv) |= SVpbm_VALID)
#  define SvVALID_off(sv)	(SvFLAGS(sv) &= ~SVpbm_VALID)
#  define SvTAIL(sv)	    ((SvFLAGS(sv) & (SVpbm_TAIL|SVpbm_VALID))	\
			     == (SVpbm_TAIL|SVpbm_VALID))

#endif
#define SvTAIL_on(sv)		(SvFLAGS(sv) |= SVpbm_TAIL)
#define SvTAIL_off(sv)		(SvFLAGS(sv) &= ~SVpbm_TAIL)

#define SvRVx(sv) SvRV(sv)

#ifdef PERL_DEBUG_COW
/* Need -0.0 for SvNVX to preserve IEEE FP "negative zero" because
   +0.0 + -0.0 => +0.0 but -0.0 + -0.0 => -0.0 */
#  define SvIVX(sv) (0 + ((XPVIV*) SvANY(sv))->xiv_iv)
#  define SvUVX(sv) (0 + ((XPVUV*) SvANY(sv))->xuv_uv)
#  define SvNVX(sv) (-0.0 + ((XPVNV*) SvANY(sv))->xnv_u.xnv_nv)
#  define SvRV(sv) (0 + (sv)->sv_u.svu_rv)
#  define SvRV_const(sv) (0 + (sv)->sv_u.svu_rv)
/* Don't test the core XS code yet.  */
#  if defined (PERL_CORE) && PERL_DEBUG_COW > 1
#    define SvPVX(sv) (0 + (assert_(!SvREADONLY(sv)) (sv)->sv_u.svu_pv))
#  else
#  define SvPVX(sv) SvPVX_mutable(sv)
#  endif
#  define SvCUR(sv) (0 + ((XPV*) SvANY(sv))->xpv_cur)
#  define SvLEN(sv) (0 + ((XPV*) SvANY(sv))->xpv_len)
#  define SvEND(sv) ((sv)->sv_u.svu_pv + ((XPV*)SvANY(sv))->xpv_cur)

#  define SvMAGIC(sv)	(0 + *(assert_(SvTYPE(sv) >= SVt_PVMG) &((XPVMG*)  SvANY(sv))->xmg_u.xmg_magic))
#  define SvSTASH(sv)	(0 + *(assert_(SvTYPE(sv) >= SVt_PVMG) &((XPVMG*)  SvANY(sv))->xmg_stash))
#else
#  define SvLEN(sv) ((XPV*) SvANY(sv))->xpv_len
#  define SvEND(sv) ((sv)->sv_u.svu_pv + ((XPV*)SvANY(sv))->xpv_cur)

#  if defined (DEBUGGING) && defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN)
/* These get expanded inside other macros that already use a variable _sv  */
#    define SvPVX(sv)							\
	(*({ SV *const _svpvx = MUTABLE_SV(sv);				\
	    assert(PL_valid_types_PVX[SvTYPE(_svpvx) & SVt_MASK]);	\
	    assert(!isGV_with_GP(_svpvx));				\
	    assert(!(SvTYPE(_svpvx) == SVt_PVIO				\
		     && !(IoFLAGS(_svpvx) & IOf_FAKE_DIRP)));		\
	    &((_svpvx)->sv_u.svu_pv);					\
	 }))
#    define SvCUR(sv)							\
	(*({ const SV *const _svcur = (const SV *)(sv);			\
	    assert(PL_valid_types_PVX[SvTYPE(_svcur) & SVt_MASK]	\
		|| SvTYPE(_svcur) == SVt_REGEXP);			\
	    assert(!isGV_with_GP(_svcur));				\
	    assert(!(SvTYPE(_svcur) == SVt_PVIO				\
		     && !(IoFLAGS(_svcur) & IOf_FAKE_DIRP)));		\
	    &(((XPV*) MUTABLE_PTR(SvANY(_svcur)))->xpv_cur);		\
	 }))
#    define SvIVX(sv)							\
	(*({ const SV *const _svivx = (const SV *)(sv);			\
	    assert(PL_valid_types_IVX[SvTYPE(_svivx) & SVt_MASK]);	\
	    assert(!isGV_with_GP(_svivx));				\
	    &(((XPVIV*) MUTABLE_PTR(SvANY(_svivx)))->xiv_iv);		\
	 }))
#    define SvUVX(sv)							\
	(*({ const SV *const _svuvx = (const SV *)(sv);			\
	    assert(PL_valid_types_IVX[SvTYPE(_svuvx) & SVt_MASK]);	\
	    assert(!isGV_with_GP(_svuvx));				\
	    &(((XPVUV*) MUTABLE_PTR(SvANY(_svuvx)))->xuv_uv);		\
	 }))
#    define SvNVX(sv)							\
	(*({ const SV *const _svnvx = (const SV *)(sv);			\
	    assert(PL_valid_types_NVX[SvTYPE(_svnvx) & SVt_MASK]);	\
	    assert(!isGV_with_GP(_svnvx));				\
	    &(((XPVNV*) MUTABLE_PTR(SvANY(_svnvx)))->xnv_u.xnv_nv);	\
	 }))
#    define SvRV(sv)							\
	(*({ SV *const _svrv = MUTABLE_SV(sv);				\
	    assert(PL_valid_types_RV[SvTYPE(_svrv) & SVt_MASK]);	\
	    assert(!isGV_with_GP(_svrv));				\
	    assert(!(SvTYPE(_svrv) == SVt_PVIO				\
		     && !(IoFLAGS(_svrv) & IOf_FAKE_DIRP)));		\
	    &((_svrv)->sv_u.svu_rv);					\
	 }))
#    define SvRV_const(sv)						\
	({ const SV *const _svrv = (const SV *)(sv);			\
	    assert(PL_valid_types_RV[SvTYPE(_svrv) & SVt_MASK]);	\
	    assert(!isGV_with_GP(_svrv));				\
	    assert(!(SvTYPE(_svrv) == SVt_PVIO				\
		     && !(IoFLAGS(_svrv) & IOf_FAKE_DIRP)));		\
	    (_svrv)->sv_u.svu_rv;					\
	 })
#    define SvMAGIC(sv)							\
	(*({ const SV *const _svmagic = (const SV *)(sv);		\
	    assert(SvTYPE(_svmagic) >= SVt_PVMG);			\
	    &(((XPVMG*) MUTABLE_PTR(SvANY(_svmagic)))->xmg_u.xmg_magic); \
	  }))
#    define SvSTASH(sv)							\
	(*({ const SV *const _svstash = (const SV *)(sv);		\
	    assert(SvTYPE(_svstash) >= SVt_PVMG);			\
	    &(((XPVMG*) MUTABLE_PTR(SvANY(_svstash)))->xmg_stash);	\
	  }))
#  else
#    define SvPVX(sv) ((sv)->sv_u.svu_pv)
#    define SvCUR(sv) ((XPV*) SvANY(sv))->xpv_cur
#    define SvIVX(sv) ((XPVIV*) SvANY(sv))->xiv_iv
#    define SvUVX(sv) ((XPVUV*) SvANY(sv))->xuv_uv
#    define SvNVX(sv) ((XPVNV*) SvANY(sv))->xnv_u.xnv_nv
#    define SvRV(sv) ((sv)->sv_u.svu_rv)
#    define SvRV_const(sv) (0 + (sv)->sv_u.svu_rv)
#    define SvMAGIC(sv)	((XPVMG*)  SvANY(sv))->xmg_u.xmg_magic
#    define SvSTASH(sv)	((XPVMG*)  SvANY(sv))->xmg_stash
#  endif
#endif

#ifndef PERL_POISON
/* Given that these two are new, there can't be any existing code using them
 *  as LVALUEs  */
#  define SvPVX_mutable(sv)	(0 + (sv)->sv_u.svu_pv)
#  define SvPVX_const(sv)	((const char*)(0 + (sv)->sv_u.svu_pv))
#else
/* Except for the poison code, which uses & to scribble over the pointer after
   free() is called.  */
#  define SvPVX_mutable(sv)	((sv)->sv_u.svu_pv)
#  define SvPVX_const(sv)	((const char*)((sv)->sv_u.svu_pv))
#endif

#define SvIVXx(sv) SvIVX(sv)
#define SvUVXx(sv) SvUVX(sv)
#define SvNVXx(sv) SvNVX(sv)
#define SvPVXx(sv) SvPVX(sv)
#define SvLENx(sv) SvLEN(sv)
#define SvENDx(sv) ((PL_Sv = (sv)), SvEND(PL_Sv))


/* Ask a scalar nicely to try to become an IV, if possible.
   Not guaranteed to stay returning void */
/* Macro won't actually call sv_2iv if already IOK */
#define SvIV_please(sv) \
	STMT_START {if (!SvIOKp(sv) && (SvFLAGS(sv) & (SVf_NOK|SVf_POK))) \
		(void) SvIV(sv); } STMT_END
#define SvIV_please_nomg(sv) \
	(!(SvFLAGS(sv) & (SVf_IOK|SVp_IOK)) && (SvFLAGS(sv) & (SVf_NOK|SVf_POK)) \
	    ? (sv_2iv_flags(sv, 0), SvIOK(sv))	  \
	    : SvIOK(sv))
#define SvIV_set(sv, val) \
	STMT_START { \
		assert(PL_valid_types_IV_set[SvTYPE(sv) & SVt_MASK]);	\
		assert(!isGV_with_GP(sv));		\
		(((XPVIV*)  SvANY(sv))->xiv_iv = (val)); } STMT_END
#define SvNV_set(sv, val) \
	STMT_START { \
		assert(PL_valid_types_NV_set[SvTYPE(sv) & SVt_MASK]);	\
		assert(!isGV_with_GP(sv));		\
		(((XPVNV*)SvANY(sv))->xnv_u.xnv_nv = (val)); } STMT_END
#define SvPV_set(sv, val) \
	STMT_START { \
		assert(PL_valid_types_PVX[SvTYPE(sv) & SVt_MASK]);	\
		assert(!isGV_with_GP(sv));		\
		assert(!(SvTYPE(sv) == SVt_PVIO		\
		     && !(IoFLAGS(sv) & IOf_FAKE_DIRP))); \
		((sv)->sv_u.svu_pv = (val)); } STMT_END
#define SvUV_set(sv, val) \
	STMT_START { \
		assert(PL_valid_types_IV_set[SvTYPE(sv) & SVt_MASK]);	\
		assert(!isGV_with_GP(sv));		\
		(((XPVUV*)SvANY(sv))->xuv_uv = (val)); } STMT_END
#define SvRV_set(sv, val) \
        STMT_START { \
		assert(PL_valid_types_RV[SvTYPE(sv) & SVt_MASK]);	\
		assert(!isGV_with_GP(sv));		\
		assert(!(SvTYPE(sv) == SVt_PVIO		\
		     && !(IoFLAGS(sv) & IOf_FAKE_DIRP))); \
                ((sv)->sv_u.svu_rv = (val)); } STMT_END
#define SvMAGIC_set(sv, val) \
        STMT_START { assert(SvTYPE(sv) >= SVt_PVMG); \
                (((XPVMG*)SvANY(sv))->xmg_u.xmg_magic = (val)); } STMT_END
#define SvSTASH_set(sv, val) \
        STMT_START { assert(SvTYPE(sv) >= SVt_PVMG); \
                (((XPVMG*)  SvANY(sv))->xmg_stash = (val)); } STMT_END
#define SvCUR_set(sv, val) \
	STMT_START { \
		assert(PL_valid_types_PVX[SvTYPE(sv) & SVt_MASK]	\
			|| SvTYPE(sv) == SVt_REGEXP);	\
		assert(!isGV_with_GP(sv));		\
		assert(!(SvTYPE(sv) == SVt_PVIO		\
		     && !(IoFLAGS(sv) & IOf_FAKE_DIRP))); \
		(((XPV*)  SvANY(sv))->xpv_cur = (val)); } STMT_END
#define SvLEN_set(sv, val) \
	STMT_START { \
		assert(PL_valid_types_PVX[SvTYPE(sv) & SVt_MASK]);	\
		assert(!isGV_with_GP(sv));	\
		assert(!(SvTYPE(sv) == SVt_PVIO		\
		     && !(IoFLAGS(sv) & IOf_FAKE_DIRP))); \
		(((XPV*)  SvANY(sv))->xpv_len = (val)); } STMT_END
#define SvEND_set(sv, val) \
	STMT_START { assert(SvTYPE(sv) >= SVt_PV); \
		SvCUR_set(sv, (val) - SvPVX(sv)); } STMT_END

#define SvPV_renew(sv,n) \
	STMT_START { SvLEN_set(sv, n); \
		SvPV_set((sv), (MEM_WRAP_CHECK_(n,char)			\
				(char*)saferealloc((Malloc_t)SvPVX(sv), \
						   (MEM_SIZE)((n)))));  \
		 } STMT_END

#define SvPV_shrink_to_cur(sv) STMT_START { \
		   const STRLEN _lEnGtH = SvCUR(sv) + 1; \
		   SvPV_renew(sv, _lEnGtH); \
		 } STMT_END

#define SvPV_free(sv)							\
    STMT_START {							\
		     assert(SvTYPE(sv) >= SVt_PV);			\
		     if (SvLEN(sv)) {					\
			 assert(!SvROK(sv));				\
			 if(UNLIKELY(SvOOK(sv))) {			\
			     STRLEN zok; 				\
			     SvOOK_offset(sv, zok);			\
			     SvPV_set(sv, SvPVX_mutable(sv) - zok);	\
			     SvFLAGS(sv) &= ~SVf_OOK;			\
			 }						\
			 Safefree(SvPVX(sv));				\
		     }							\
		 } STMT_END

#ifdef PERL_CORE
/* Code that crops up in three places to take a scalar and ready it to hold
   a reference */
#  define prepare_SV_for_RV(sv)						\
    STMT_START {							\
		    if (SvTYPE(sv) < SVt_PV && SvTYPE(sv) != SVt_IV)	\
			sv_upgrade(sv, SVt_IV);				\
		    else if (SvTYPE(sv) >= SVt_PV) {			\
			SvPV_free(sv);					\
			SvLEN_set(sv, 0);				\
                        SvCUR_set(sv, 0);				\
		    }							\
		 } STMT_END
#endif

#ifndef PERL_CORE
#  define BmFLAGS(sv)		(SvTAIL(sv) ? FBMcf_TAIL : 0)
#endif

#if defined (DEBUGGING) && defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN)
#  define BmUSEFUL(sv)							\
	(*({ SV *const _bmuseful = MUTABLE_SV(sv);			\
	    assert(SvTYPE(_bmuseful) >= SVt_PVIV);			\
	    assert(SvVALID(_bmuseful));					\
	    assert(!SvIOK(_bmuseful));					\
	    &(((XPVIV*) SvANY(_bmuseful))->xiv_u.xivu_iv);              \
	 }))
#else
#  define BmUSEFUL(sv)          ((XPVIV*) SvANY(sv))->xiv_u.xivu_iv

#endif

#ifndef PERL_CORE
# define BmRARE(sv)	0
# define BmPREVIOUS(sv)	0
#endif

#define FmLINES(sv)	((XPVIV*)  SvANY(sv))->xiv_iv

#define LvTYPE(sv)	((XPVLV*)  SvANY(sv))->xlv_type
#define LvTARG(sv)	((XPVLV*)  SvANY(sv))->xlv_targ
#define LvTARGOFF(sv)	((XPVLV*)  SvANY(sv))->xlv_targoff
#define LvSTARGOFF(sv)	((XPVLV*)  SvANY(sv))->xlv_targoff_u.xlvu_stargoff
#define LvTARGLEN(sv)	((XPVLV*)  SvANY(sv))->xlv_targlen
#define LvFLAGS(sv)	((XPVLV*)  SvANY(sv))->xlv_flags

#define IoIFP(sv)	(sv)->sv_u.svu_fp
#define IoOFP(sv)	((XPVIO*)  SvANY(sv))->xio_ofp
#define IoDIRP(sv)	((XPVIO*)  SvANY(sv))->xio_dirp
#define IoANY(sv)	((XPVIO*)  SvANY(sv))->xio_any
#define IoLINES(sv)	((XPVIO*)  SvANY(sv))->xiv_u.xivu_iv
#define IoPAGE(sv)	((XPVIO*)  SvANY(sv))->xio_page
#define IoPAGE_LEN(sv)	((XPVIO*)  SvANY(sv))->xio_page_len
#define IoLINES_LEFT(sv)((XPVIO*)  SvANY(sv))->xio_lines_left
#define IoTOP_NAME(sv)	((XPVIO*)  SvANY(sv))->xio_top_name
#define IoTOP_GV(sv)	((XPVIO*)  SvANY(sv))->xio_top_gv
#define IoFMT_NAME(sv)	((XPVIO*)  SvANY(sv))->xio_fmt_name
#define IoFMT_GV(sv)	((XPVIO*)  SvANY(sv))->xio_fmt_gv
#define IoBOTTOM_NAME(sv)((XPVIO*) SvANY(sv))->xio_bottom_name
#define IoBOTTOM_GV(sv)	((XPVIO*)  SvANY(sv))->xio_bottom_gv
#define IoTYPE(sv)	((XPVIO*)  SvANY(sv))->xio_type
#define IoFLAGS(sv)	((XPVIO*)  SvANY(sv))->xio_flags

/* IoTYPE(sv) is a single character telling the type of I/O connection. */
#define IoTYPE_RDONLY		'<'
#define IoTYPE_WRONLY		'>'
#define IoTYPE_RDWR		'+'
#define IoTYPE_APPEND 		'a'
#define IoTYPE_PIPE		'|'
#define IoTYPE_STD		'-'	/* stdin or stdout */
#define IoTYPE_SOCKET		's'
#define IoTYPE_CLOSED		' '
#define IoTYPE_IMPLICIT		'I'	/* stdin or stdout or stderr */
#define IoTYPE_NUMERIC		'#'	/* fdopen */

/*
=for apidoc Am|bool|SvTAINTED|SV* sv
Checks to see if an SV is tainted.  Returns TRUE if it is, FALSE if
not.

=for apidoc Am|void|SvTAINTED_on|SV* sv
Marks an SV as tainted if tainting is enabled.

=for apidoc Am|void|SvTAINTED_off|SV* sv
Untaints an SV.  Be I<very> careful with this routine, as it short-circuits
some of Perl's fundamental security features.  XS module authors should not
use this function unless they fully understand all the implications of
unconditionally untainting the value.  Untainting should be done in the
standard perl fashion, via a carefully crafted regexp, rather than directly
untainting variables.

=for apidoc Am|void|SvTAINT|SV* sv
Taints an SV if tainting is enabled, and if some input to the current
expression is tainted--usually a variable, but possibly also implicit
inputs such as locale settings.  C<SvTAINT> propagates that taintedness to
the outputs of an expression in a pessimistic fashion; i.e., without paying
attention to precisely which outputs are influenced by which inputs.

=cut
*/

#define sv_taint(sv)	  sv_magic((sv), NULL, PERL_MAGIC_taint, NULL, 0)

#ifdef NO_TAINT_SUPPORT
#   define SvTAINTED(sv) 0
#else
#   define SvTAINTED(sv)	  (SvMAGICAL(sv) && sv_tainted(sv))
#endif
#define SvTAINTED_on(sv)  STMT_START{ if(UNLIKELY(TAINTING_get)){sv_taint(sv);}   }STMT_END
#define SvTAINTED_off(sv) STMT_START{ if(UNLIKELY(TAINTING_get)){sv_untaint(sv);} }STMT_END

#define SvTAINT(sv)			\
    STMT_START {			\
        assert(TAINTING_get || !TAINT_get); \
        if (UNLIKELY(TAINT_get))	\
            SvTAINTED_on(sv);	        \
    } STMT_END

/*
=for apidoc Am|char*|SvPV_force|SV* sv|STRLEN len
Like C<SvPV> but will force the SV into containing a string (C<SvPOK>), and
only a string (C<SvPOK_only>), by hook or by crook.  You need force if you are
going to update the C<SvPVX> directly.  Processes get magic.

Note that coercing an arbitrary scalar into a plain PV will potentially
strip useful data from it.  For example if the SV was C<SvROK>, then the
referent will have its reference count decremented, and the SV itself may
be converted to an C<SvPOK> scalar with a string buffer containing a value
such as C<"ARRAY(0x1234)">.

=for apidoc Am|char*|SvPV_force_nomg|SV* sv|STRLEN len
Like C<SvPV_force>, but doesn't process get magic.

=for apidoc Am|char*|SvPV|SV* sv|STRLEN len
Returns a pointer to the string in the SV, or a stringified form of
the SV if the SV does not contain a string.  The SV may cache the
stringified version becoming C<SvPOK>.  Handles 'get' magic.  The
C<len> variable will be set to the length of the string (this is a macro, so
don't use C<&len>).  See also C<L</SvPVx>> for a version which guarantees to
evaluate C<sv> only once.

Note that there is no guarantee that the return value of C<SvPV()> is
equal to C<SvPVX(sv)>, or that C<SvPVX(sv)> contains valid data, or that
successive calls to C<SvPV(sv)> will return the same pointer value each
time.  This is due to the way that things like overloading and
Copy-On-Write are handled.  In these cases, the return value may point to
a temporary buffer or similar.  If you absolutely need the C<SvPVX> field to
be valid (for example, if you intend to write to it), then see
C<L</SvPV_force>>.

=for apidoc Am|char*|SvPVx|SV* sv|STRLEN len
A version of C<SvPV> which guarantees to evaluate C<sv> only once.
Only use this if C<sv> is an expression with side effects, otherwise use the
more efficient C<SvPV>.

=for apidoc Am|char*|SvPV_nomg|SV* sv|STRLEN len
Like C<SvPV> but doesn't process magic.

=for apidoc Am|char*|SvPV_nolen|SV* sv
Like C<SvPV> but doesn't set a length variable.

=for apidoc Am|char*|SvPV_nomg_nolen|SV* sv
Like C<SvPV_nolen> but doesn't process magic.

=for apidoc Am|IV|SvIV|SV* sv
Coerces the given SV to an integer and returns it.  See C<L</SvIVx>> for a
version which guarantees to evaluate C<sv> only once.

=for apidoc Am|IV|SvIV_nomg|SV* sv
Like C<SvIV> but doesn't process magic.

=for apidoc Am|IV|SvIVx|SV* sv
Coerces the given SV to an integer and returns it.
Guarantees to evaluate C<sv> only once.  Only use
this if C<sv> is an expression with side effects,
otherwise use the more efficient C<SvIV>.

=for apidoc Am|NV|SvNV|SV* sv
Coerce the given SV to a double and return it.  See C<L</SvNVx>> for a version
which guarantees to evaluate C<sv> only once.

=for apidoc Am|NV|SvNV_nomg|SV* sv
Like C<SvNV> but doesn't process magic.

=for apidoc Am|NV|SvNVx|SV* sv
Coerces the given SV to a double and returns it.
Guarantees to evaluate C<sv> only once.  Only use
this if C<sv> is an expression with side effects,
otherwise use the more efficient C<SvNV>.

=for apidoc Am|UV|SvUV|SV* sv
Coerces the given SV to an unsigned integer and returns it.  See C<L</SvUVx>>
for a version which guarantees to evaluate C<sv> only once.

=for apidoc Am|UV|SvUV_nomg|SV* sv
Like C<SvUV> but doesn't process magic.

=for apidoc Am|UV|SvUVx|SV* sv
Coerces the given SV to an unsigned integer and
returns it.  Guarantees to evaluate C<sv> only once.  Only
use this if C<sv> is an expression with side effects,
otherwise use the more efficient C<SvUV>.

=for apidoc Am|bool|SvTRUE|SV* sv
Returns a boolean indicating whether Perl would evaluate the SV as true or
false.  See C<L</SvOK>> for a defined/undefined test.  Handles 'get' magic
unless the scalar is already C<SvPOK>, C<SvIOK> or C<SvNOK> (the public, not the
private flags).

=for apidoc Am|bool|SvTRUE_nomg|SV* sv
Returns a boolean indicating whether Perl would evaluate the SV as true or
false.  See C<L</SvOK>> for a defined/undefined test.  Does not handle 'get' magic.

=for apidoc Am|char*|SvPVutf8_force|SV* sv|STRLEN len
Like C<SvPV_force>, but converts C<sv> to UTF-8 first if necessary.

=for apidoc Am|char*|SvPVutf8|SV* sv|STRLEN len
Like C<SvPV>, but converts C<sv> to UTF-8 first if necessary.

=for apidoc Am|char*|SvPVutf8_nolen|SV* sv
Like C<SvPV_nolen>, but converts C<sv> to UTF-8 first if necessary.

=for apidoc Am|char*|SvPVbyte_force|SV* sv|STRLEN len
Like C<SvPV_force>, but converts C<sv> to byte representation first if necessary.

=for apidoc Am|char*|SvPVbyte|SV* sv|STRLEN len
Like C<SvPV>, but converts C<sv> to byte representation first if necessary.

=for apidoc Am|char*|SvPVbyte_nolen|SV* sv
Like C<SvPV_nolen>, but converts C<sv> to byte representation first if necessary.

=for apidoc Am|char*|SvPVutf8x_force|SV* sv|STRLEN len
Like C<SvPV_force>, but converts C<sv> to UTF-8 first if necessary.
Guarantees to evaluate C<sv> only once; use the more efficient C<SvPVutf8_force>
otherwise.

=for apidoc Am|char*|SvPVutf8x|SV* sv|STRLEN len
Like C<SvPV>, but converts C<sv> to UTF-8 first if necessary.
Guarantees to evaluate C<sv> only once; use the more efficient C<SvPVutf8>
otherwise.

=for apidoc Am|char*|SvPVbytex_force|SV* sv|STRLEN len
Like C<SvPV_force>, but converts C<sv> to byte representation first if necessary.
Guarantees to evaluate C<sv> only once; use the more efficient C<SvPVbyte_force>
otherwise.

=for apidoc Am|char*|SvPVbytex|SV* sv|STRLEN len
Like C<SvPV>, but converts C<sv> to byte representation first if necessary.
Guarantees to evaluate C<sv> only once; use the more efficient C<SvPVbyte>
otherwise.

=for apidoc Am|U32|SvIsCOW|SV* sv
Returns a U32 value indicating whether the SV is Copy-On-Write (either shared
hash key scalars, or full Copy On Write scalars if 5.9.0 is configured for
COW).

=for apidoc Am|bool|SvIsCOW_shared_hash|SV* sv
Returns a boolean indicating whether the SV is Copy-On-Write shared hash key
scalar.

=for apidoc Am|void|sv_catpvn_nomg|SV* sv|const char* ptr|STRLEN len
Like C<sv_catpvn> but doesn't process magic.

=for apidoc Am|void|sv_catpv_nomg|SV* sv|const char* ptr
Like C<sv_catpv> but doesn't process magic.

=for apidoc Am|void|sv_setsv_nomg|SV* dsv|SV* ssv
Like C<sv_setsv> but doesn't process magic.

=for apidoc Am|void|sv_catsv_nomg|SV* dsv|SV* ssv
Like C<sv_catsv> but doesn't process magic.

=for apidoc Amdb|STRLEN|sv_utf8_upgrade_nomg|NN SV *sv

Like C<sv_utf8_upgrade>, but doesn't do magic on C<sv>.

=cut
*/

/* Let us hope that bitmaps for UV and IV are the same */
#define SvIV(sv) (SvIOK_nog(sv) ? SvIVX(sv) : sv_2iv(sv))
#define SvUV(sv) (SvUOK_nog(sv) ? SvUVX(sv) : sv_2uv(sv))
#define SvNV(sv) (SvNOK_nog(sv) ? SvNVX(sv) : sv_2nv(sv))

#define SvIV_nomg(sv) (SvIOK(sv) ? SvIVX(sv) : sv_2iv_flags(sv, 0))
#define SvUV_nomg(sv) (SvIOK(sv) ? SvUVX(sv) : sv_2uv_flags(sv, 0))
#define SvNV_nomg(sv) (SvNOK(sv) ? SvNVX(sv) : sv_2nv_flags(sv, 0))

/* ----*/

#define SvPV(sv, lp)         SvPV_flags(sv, lp, SV_GMAGIC)
#define SvPV_const(sv, lp)   SvPV_flags_const(sv, lp, SV_GMAGIC)
#define SvPV_mutable(sv, lp) SvPV_flags_mutable(sv, lp, SV_GMAGIC)

#define SvPV_flags(sv, lp, flags) \
    (SvPOK_nog(sv) \
     ? ((lp = SvCUR(sv)), SvPVX(sv)) : sv_2pv_flags(sv, &lp, flags))
#define SvPV_flags_const(sv, lp, flags) \
    (SvPOK_nog(sv) \
     ? ((lp = SvCUR(sv)), SvPVX_const(sv)) : \
     (const char*) sv_2pv_flags(sv, &lp, (flags|SV_CONST_RETURN)))
#define SvPV_flags_const_nolen(sv, flags) \
    (SvPOK_nog(sv) \
     ? SvPVX_const(sv) : \
     (const char*) sv_2pv_flags(sv, 0, (flags|SV_CONST_RETURN)))
#define SvPV_flags_mutable(sv, lp, flags) \
    (SvPOK_nog(sv) \
     ? ((lp = SvCUR(sv)), SvPVX_mutable(sv)) : \
     sv_2pv_flags(sv, &lp, (flags|SV_MUTABLE_RETURN)))

#define SvPV_force(sv, lp) SvPV_force_flags(sv, lp, SV_GMAGIC)
#define SvPV_force_nolen(sv) SvPV_force_flags_nolen(sv, SV_GMAGIC)
#define SvPV_force_mutable(sv, lp) SvPV_force_flags_mutable(sv, lp, SV_GMAGIC)

#define SvPV_force_nomg(sv, lp) SvPV_force_flags(sv, lp, 0)
#define SvPV_force_nomg_nolen(sv) SvPV_force_flags_nolen(sv, 0)

#define SvPV_force_flags(sv, lp, flags) \
    (SvPOK_pure_nogthink(sv) \
     ? ((lp = SvCUR(sv)), SvPVX(sv)) : sv_pvn_force_flags(sv, &lp, flags))

#define SvPV_force_flags_nolen(sv, flags) \
    (SvPOK_pure_nogthink(sv) \
     ? SvPVX(sv) : sv_pvn_force_flags(sv, 0, flags))

#define SvPV_force_flags_mutable(sv, lp, flags) \
    (SvPOK_pure_nogthink(sv) \
     ? ((lp = SvCUR(sv)), SvPVX_mutable(sv)) \
     : sv_pvn_force_flags(sv, &lp, flags|SV_MUTABLE_RETURN))

#define SvPV_nolen(sv) \
    (SvPOK_nog(sv) \
     ? SvPVX(sv) : sv_2pv_flags(sv, 0, SV_GMAGIC))

/* "_nomg" in these defines means no mg_get() */
#define SvPV_nomg_nolen(sv) \
    (SvPOK_nog(sv) \
     ? SvPVX(sv) : sv_2pv_flags(sv, 0, 0))

#define SvPV_nolen_const(sv) \
    (SvPOK_nog(sv) \
     ? SvPVX_const(sv) : sv_2pv_flags(sv, 0, SV_GMAGIC|SV_CONST_RETURN))

#define SvPV_nomg(sv, lp) SvPV_flags(sv, lp, 0)
#define SvPV_nomg_const(sv, lp) SvPV_flags_const(sv, lp, 0)
#define SvPV_nomg_const_nolen(sv) SvPV_flags_const_nolen(sv, 0)

/* ----*/

#define SvPVutf8(sv, lp) \
    (SvPOK_utf8_nog(sv) \
     ? ((lp = SvCUR(sv)), SvPVX(sv)) : sv_2pvutf8(sv, &lp))

#define SvPVutf8_force(sv, lp) \
    (SvPOK_utf8_pure_nogthink(sv) \
     ? ((lp = SvCUR(sv)), SvPVX(sv)) : sv_pvutf8n_force(sv, &lp))

#define SvPVutf8_nolen(sv) \
    (SvPOK_utf8_nog(sv) \
     ? SvPVX(sv) : sv_2pvutf8(sv, 0))

/* ----*/

#define SvPVbyte(sv, lp) \
    (SvPOK_byte_nog(sv) \
     ? ((lp = SvCUR(sv)), SvPVX(sv)) : sv_2pvbyte(sv, &lp))

#define SvPVbyte_force(sv, lp) \
    (SvPOK_byte_pure_nogthink(sv) \
     ? ((lp = SvCUR(sv)), SvPVX(sv)) : sv_pvbyten_force(sv, &lp))

#define SvPVbyte_nolen(sv) \
    (SvPOK_byte_nog(sv) \
     ? SvPVX(sv) : sv_2pvbyte(sv, 0))

    
/* define FOOx(): idempotent versions of FOO(). If possible, use a local
 * var to evaluate the arg once; failing that, use a global if possible;
 * failing that, call a function to do the work
 */

#define SvPVx_force(sv, lp) sv_pvn_force(sv, &lp)
#define SvPVutf8x_force(sv, lp) sv_pvutf8n_force(sv, &lp)
#define SvPVbytex_force(sv, lp) sv_pvbyten_force(sv, &lp)

#define SvTRUE(sv)        (LIKELY(sv) && (UNLIKELY(SvGMAGICAL(sv)) ? sv_2bool(sv) : SvTRUE_common(sv, sv_2bool_nomg(sv))))
#define SvTRUE_nomg(sv)   (LIKELY(sv) && (                                SvTRUE_common(sv, sv_2bool_nomg(sv))))
#define SvTRUE_NN(sv)              (UNLIKELY(SvGMAGICAL(sv)) ? sv_2bool(sv) : SvTRUE_common(sv, sv_2bool_nomg(sv)))
#define SvTRUE_nomg_NN(sv) (                                        SvTRUE_common(sv, sv_2bool_nomg(sv)))
#define SvTRUE_common(sv,fallback) (			\
      !SvOK(sv)						\
	? 0						\
    : SvPOK(sv)						\
	? SvPVXtrue(sv)					\
    : (SvFLAGS(sv) & (SVf_IOK|SVf_NOK))			\
	? (   (SvIOK(sv) && SvIVX(sv) != 0)		\
	   || (SvNOK(sv) && SvNVX(sv) != 0.0))		\
    : (fallback))

#if defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN)

#  define SvIVx(sv) ({SV *_sv = MUTABLE_SV(sv); SvIV(_sv); })
#  define SvUVx(sv) ({SV *_sv = MUTABLE_SV(sv); SvUV(_sv); })
#  define SvNVx(sv) ({SV *_sv = MUTABLE_SV(sv); SvNV(_sv); })
#  define SvPVx(sv, lp) ({SV *_sv = (sv); SvPV(_sv, lp); })
#  define SvPVx_const(sv, lp) ({SV *_sv = (sv); SvPV_const(_sv, lp); })
#  define SvPVx_nolen(sv) ({SV *_sv = (sv); SvPV_nolen(_sv); })
#  define SvPVx_nolen_const(sv) ({SV *_sv = (sv); SvPV_nolen_const(_sv); })
#  define SvPVutf8x(sv, lp) ({SV *_sv = (sv); SvPVutf8(_sv, lp); })
#  define SvPVbytex(sv, lp) ({SV *_sv = (sv); SvPVbyte(_sv, lp); })
#  define SvPVbytex_nolen(sv) ({SV *_sv = (sv); SvPVbyte_nolen(_sv); })
#  define SvTRUEx(sv)      ({SV *_sv = (sv); SvTRUE(_sv); })
#  define SvTRUEx_nomg(sv) ({SV *_sv = (sv); SvTRUE_nomg(_sv); })

#else /* __GNUC__ */

/* These inlined macros use globals, which will require a thread
 * declaration in user code, so we avoid them under threads */

#  define SvIVx(sv) ((PL_Sv = (sv)), SvIV(PL_Sv))
#  define SvUVx(sv) ((PL_Sv = (sv)), SvUV(PL_Sv))
#  define SvNVx(sv) ((PL_Sv = (sv)), SvNV(PL_Sv))
#  define SvPVx(sv, lp) ((PL_Sv = (sv)), SvPV(PL_Sv, lp))
#  define SvPVx_const(sv, lp) ((PL_Sv = (sv)), SvPV_const(PL_Sv, lp))
#  define SvPVx_nolen(sv) ((PL_Sv = (sv)), SvPV_nolen(PL_Sv))
#  define SvPVx_nolen_const(sv) ((PL_Sv = (sv)), SvPV_nolen_const(PL_Sv))
#  define SvPVutf8x(sv, lp) ((PL_Sv = (sv)), SvPVutf8(PL_Sv, lp))
#  define SvPVbytex(sv, lp) ((PL_Sv = (sv)), SvPVbyte(PL_Sv, lp))
#  define SvPVbytex_nolen(sv) ((PL_Sv = (sv)), SvPVbyte_nolen(PL_Sv))
#  define SvTRUEx(sv)      ((PL_Sv = (sv)), SvTRUE(PL_Sv))
#  define SvTRUEx_nomg(sv) ((PL_Sv = (sv)), SvTRUE_nomg(PL_Sv))
#endif /* __GNU__ */

#define SvPVXtrue(sv)	(					\
    ((XPV*)SvANY((sv))) 					\
     && (							\
	((XPV*)SvANY((sv)))->xpv_cur > 1			\
	|| (							\
	    ((XPV*)SvANY((sv)))->xpv_cur			\
	    && *(sv)->sv_u.svu_pv != '0'				\
	)							\
    )								\
)

#define SvIsCOW(sv)		(SvFLAGS(sv) & SVf_IsCOW)
#define SvIsCOW_on(sv)		(SvFLAGS(sv) |= SVf_IsCOW)
#define SvIsCOW_off(sv)		(SvFLAGS(sv) &= ~SVf_IsCOW)
#define SvIsCOW_shared_hash(sv)	(SvIsCOW(sv) && SvLEN(sv) == 0)

#define SvSHARED_HEK_FROM_PV(pvx) \
	((struct hek*)(pvx - STRUCT_OFFSET(struct hek, hek_key)))
#define SvSHARED_HASH(sv) (0 + SvSHARED_HEK_FROM_PV(SvPVX_const(sv))->hek_hash)

/* flag values for sv_*_flags functions */
#define SV_IMMEDIATE_UNREF	1
#define SV_GMAGIC		2
#define SV_COW_DROP_PV		4
#define SV_UTF8_NO_ENCODING	8
#define SV_NOSTEAL		16
#define SV_CONST_RETURN		32
#define SV_MUTABLE_RETURN	64
#define SV_SMAGIC		128
#define SV_HAS_TRAILING_NUL	256
#define SV_COW_SHARED_HASH_KEYS	512
/* This one is only enabled for PERL_OLD_COPY_ON_WRITE */
/* XXX This flag actually enabled for any COW.  But it appears not to do
       anything.  Can we just remove it?  Or will it serve some future
       purpose.  */
#define SV_COW_OTHER_PVS	1024
/* Make sv_2pv_flags return NULL if something is undefined.  */
#define SV_UNDEF_RETURNS_NULL	2048
/* Tell sv_utf8_upgrade() to not check to see if an upgrade is really needed.
 * This is used when the caller has already determined it is, and avoids
 * redundant work */
#define SV_FORCE_UTF8_UPGRADE	4096
/* if (after resolving magic etc), the SV is found to be overloaded,
 * don't call the overload magic, just return as-is */
#define SV_SKIP_OVERLOAD	8192
#define SV_CATBYTES		16384
#define SV_CATUTF8		32768

/* The core is safe for this COW optimisation. XS code on CPAN may not be.
   So only default to doing the COW setup if we're in the core.
 */
#ifdef PERL_CORE
#  ifndef SV_DO_COW_SVSETSV
#    define SV_DO_COW_SVSETSV	SV_COW_SHARED_HASH_KEYS|SV_COW_OTHER_PVS
#  endif
#endif

#ifndef SV_DO_COW_SVSETSV
#  define SV_DO_COW_SVSETSV	0
#endif


#define sv_unref(sv)    	sv_unref_flags(sv, 0)
#define sv_force_normal(sv)	sv_force_normal_flags(sv, 0)
#define sv_usepvn(sv, p, l)	sv_usepvn_flags(sv, p, l, 0)
#define sv_usepvn_mg(sv, p, l)	sv_usepvn_flags(sv, p, l, SV_SMAGIC)

/* We are about to replace the SV's current value. So if it's copy on write
   we need to normalise it. Use the SV_COW_DROP_PV flag hint to say that
   the value is about to get thrown away, so drop the PV rather than go to
   the effort of making a read-write copy only for it to get immediately
   discarded.  */

#define SV_CHECK_THINKFIRST_COW_DROP(sv) if (SvTHINKFIRST(sv)) \
				    sv_force_normal_flags(sv, SV_COW_DROP_PV)

#ifdef PERL_COPY_ON_WRITE
#   define SvCANCOW(sv)					    \
	(SvIsCOW(sv)					     \
	 ? SvLEN(sv) ? CowREFCNT(sv) != SV_COW_REFCNT_MAX : 1 \
	 : (SvFLAGS(sv) & CAN_COW_MASK) == CAN_COW_FLAGS       \
			    && SvCUR(sv)+1 < SvLEN(sv))
   /* Note: To allow 256 COW "copies", a refcnt of 0 means 1. */
#   define CowREFCNT(sv)	(*(U8 *)(SvPVX(sv)+SvLEN(sv)-1))
#   define SV_COW_REFCNT_MAX	((1 << sizeof(U8)*8) - 1)
#   define CAN_COW_MASK	(SVf_POK|SVf_ROK|SVp_POK|SVf_FAKE| \
			 SVf_OOK|SVf_BREAK|SVf_READONLY|SVf_PROTECT)
#endif

#define CAN_COW_FLAGS	(SVp_POK|SVf_POK)

#define SV_CHECK_THINKFIRST(sv) if (SvTHINKFIRST(sv)) \
				    sv_force_normal_flags(sv, 0)


/* all these 'functions' are now just macros */

#define sv_pv(sv) SvPV_nolen(sv)
#define sv_pvutf8(sv) SvPVutf8_nolen(sv)
#define sv_pvbyte(sv) SvPVbyte_nolen(sv)

#define sv_pvn_force_nomg(sv, lp) sv_pvn_force_flags(sv, lp, 0)
#define sv_utf8_upgrade_flags(sv, flags) sv_utf8_upgrade_flags_grow(sv, flags, 0)
#define sv_utf8_upgrade_nomg(sv) sv_utf8_upgrade_flags(sv, 0)
#define sv_catpvn_nomg(dsv, sstr, slen) sv_catpvn_flags(dsv, sstr, slen, 0)
#define sv_catpv_nomg(dsv, sstr) sv_catpv_flags(dsv, sstr, 0)
#define sv_setsv(dsv, ssv) \
	sv_setsv_flags(dsv, ssv, SV_GMAGIC|SV_DO_COW_SVSETSV)
#define sv_setsv_nomg(dsv, ssv) sv_setsv_flags(dsv, ssv, SV_DO_COW_SVSETSV)
#define sv_catsv(dsv, ssv) sv_catsv_flags(dsv, ssv, SV_GMAGIC)
#define sv_catsv_nomg(dsv, ssv) sv_catsv_flags(dsv, ssv, 0)
#define sv_catsv_mg(dsv, ssv) sv_catsv_flags(dsv, ssv, SV_GMAGIC|SV_SMAGIC)
#define sv_catpvn(dsv, sstr, slen) sv_catpvn_flags(dsv, sstr, slen, SV_GMAGIC)
#define sv_catpvn_mg(sv, sstr, slen) sv_catpvn_flags(sv, sstr, slen, SV_GMAGIC|SV_SMAGIC);
#define sv_copypv(dsv, ssv) sv_copypv_flags(dsv, ssv, SV_GMAGIC)
#define sv_copypv_nomg(dsv, ssv) sv_copypv_flags(dsv, ssv, 0)
#define sv_2pv(sv, lp) sv_2pv_flags(sv, lp, SV_GMAGIC)
#define sv_2pv_nolen(sv) sv_2pv(sv, 0)
#define sv_2pvbyte_nolen(sv) sv_2pvbyte(sv, 0)
#define sv_2pvutf8_nolen(sv) sv_2pvutf8(sv, 0)
#define sv_2pv_nomg(sv, lp) sv_2pv_flags(sv, lp, 0)
#define sv_pvn_force(sv, lp) sv_pvn_force_flags(sv, lp, SV_GMAGIC)
#define sv_utf8_upgrade(sv) sv_utf8_upgrade_flags(sv, SV_GMAGIC)
#define sv_2iv(sv) sv_2iv_flags(sv, SV_GMAGIC)
#define sv_2uv(sv) sv_2uv_flags(sv, SV_GMAGIC)
#define sv_2nv(sv) sv_2nv_flags(sv, SV_GMAGIC)
#define sv_eq(sv1, sv2) sv_eq_flags(sv1, sv2, SV_GMAGIC)
#define sv_cmp(sv1, sv2) sv_cmp_flags(sv1, sv2, SV_GMAGIC)
#define sv_cmp_locale(sv1, sv2) sv_cmp_locale_flags(sv1, sv2, SV_GMAGIC)
#define sv_collxfrm(sv, nxp) sv_cmp_flags(sv, nxp, SV_GMAGIC)
#define sv_2bool(sv) sv_2bool_flags(sv, SV_GMAGIC)
#define sv_2bool_nomg(sv) sv_2bool_flags(sv, 0)
#define sv_insert(bigstr, offset, len, little, littlelen)		\
	Perl_sv_insert_flags(aTHX_ (bigstr),(offset), (len), (little),	\
			     (littlelen), SV_GMAGIC)
#define sv_mortalcopy(sv) \
	Perl_sv_mortalcopy_flags(aTHX_ sv, SV_GMAGIC|SV_DO_COW_SVSETSV)
#define sv_cathek(sv,hek)					    \
	STMT_START {						     \
	    HEK * const bmxk = hek;				      \
	    sv_catpvn_flags(sv, HEK_KEY(bmxk), HEK_LEN(bmxk),	       \
			    HEK_UTF8(bmxk) ? SV_CATUTF8 : SV_CATBYTES); \
	} STMT_END

/* Should be named SvCatPVN_utf8_upgrade? */
#define sv_catpvn_nomg_utf8_upgrade(dsv, sstr, slen, nsv)	\
	STMT_START {					\
	    if (!(nsv))					\
		nsv = newSVpvn_flags(sstr, slen, SVs_TEMP);	\
	    else					\
		sv_setpvn(nsv, sstr, slen);		\
	    SvUTF8_off(nsv);				\
	    sv_utf8_upgrade(nsv);			\
	    sv_catsv_nomg(dsv, nsv);			\
	} STMT_END
#define sv_catpvn_nomg_maybeutf8(dsv, sstr, slen, is_utf8) \
	sv_catpvn_flags(dsv, sstr, slen, (is_utf8)?SV_CATUTF8:SV_CATBYTES)

#if defined(PERL_CORE) || defined(PERL_EXT)
# define sv_or_pv_len_utf8(sv, pv, bytelen)	      \
    (SvGAMAGIC(sv)				       \
	? utf8_length((U8 *)(pv), (U8 *)(pv)+(bytelen))	\
	: sv_len_utf8(sv))
#endif

/*
=for apidoc Am|SV*|newRV_inc|SV* sv

Creates an RV wrapper for an SV.  The reference count for the original SV is
incremented.

=cut
*/

#define newRV_inc(sv)	newRV(sv)

/* the following macros update any magic values this C<sv> is associated with */

/*
=head1 Magical Functions

=for apidoc Am|void|SvGETMAGIC|SV* sv
Invokes C<mg_get> on an SV if it has 'get' magic.  For example, this
will call C<FETCH> on a tied variable.  This macro evaluates its
argument more than once.

=for apidoc Am|void|SvSETMAGIC|SV* sv
Invokes C<mg_set> on an SV if it has 'set' magic.  This is necessary
after modifying a scalar, in case it is a magical variable like C<$|>
or a tied variable (it calls C<STORE>).  This macro evaluates its
argument more than once.

=for apidoc Am|void|SvSetSV|SV* dsv|SV* ssv
Calls C<sv_setsv> if C<dsv> is not the same as C<ssv>.  May evaluate arguments
more than once.  Does not handle 'set' magic on the destination SV.

=for apidoc Am|void|SvSetSV_nosteal|SV* dsv|SV* ssv
Calls a non-destructive version of C<sv_setsv> if C<dsv> is not the same as
C<ssv>.  May evaluate arguments more than once.

=for apidoc Am|void|SvSetMagicSV|SV* dsv|SV* ssv
Like C<SvSetSV>, but does any set magic required afterwards.

=for apidoc Am|void|SvSetMagicSV_nosteal|SV* dsv|SV* ssv
Like C<SvSetSV_nosteal>, but does any set magic required afterwards.

=for apidoc Am|void|SvSHARE|SV* sv
Arranges for C<sv> to be shared between threads if a suitable module
has been loaded.

=for apidoc Am|void|SvLOCK|SV* sv
Arranges for a mutual exclusion lock to be obtained on C<sv> if a suitable module
has been loaded.

=for apidoc Am|void|SvUNLOCK|SV* sv
Releases a mutual exclusion lock on C<sv> if a suitable module
has been loaded.

=head1 SV Manipulation Functions

=for apidoc Am|char *|SvGROW|SV* sv|STRLEN len
Expands the character buffer in the SV so that it has room for the
indicated number of bytes (remember to reserve space for an extra trailing
C<NUL> character).  Calls C<sv_grow> to perform the expansion if necessary.
Returns a pointer to the character
buffer.  SV must be of type >= C<SVt_PV>.  One
alternative is to call C<sv_grow> if you are not sure of the type of SV.

=cut
*/

#define SvSHARE(sv) PL_sharehook(aTHX_ sv)
#define SvLOCK(sv) PL_lockhook(aTHX_ sv)
#define SvUNLOCK(sv) PL_unlockhook(aTHX_ sv)
#define SvDESTROYABLE(sv) PL_destroyhook(aTHX_ sv)

#define SvGETMAGIC(x) ((void)(UNLIKELY(SvGMAGICAL(x)) && mg_get(x)))
#define SvSETMAGIC(x) STMT_START { if (UNLIKELY(SvSMAGICAL(x))) mg_set(x); } STMT_END

#define SvSetSV_and(dst,src,finally) \
	STMT_START {					\
	    if (LIKELY((dst) != (src))) {		\
		sv_setsv(dst, src);			\
		finally;				\
	    }						\
	} STMT_END
#define SvSetSV_nosteal_and(dst,src,finally) \
	STMT_START {					\
	    if (LIKELY((dst) != (src))) {			\
		sv_setsv_flags(dst, src, SV_GMAGIC | SV_NOSTEAL | SV_DO_COW_SVSETSV);	\
		finally;				\
	    }						\
	} STMT_END

#define SvSetSV(dst,src) \
		SvSetSV_and(dst,src,/*nothing*/;)
#define SvSetSV_nosteal(dst,src) \
		SvSetSV_nosteal_and(dst,src,/*nothing*/;)

#define SvSetMagicSV(dst,src) \
		SvSetSV_and(dst,src,SvSETMAGIC(dst))
#define SvSetMagicSV_nosteal(dst,src) \
		SvSetSV_nosteal_and(dst,src,SvSETMAGIC(dst))


#if !defined(SKIP_DEBUGGING)
#define SvPEEK(sv) sv_peek(sv)
#else
#define SvPEEK(sv) ""
#endif

#define SvIMMORTAL(sv) (SvREADONLY(sv) && ((sv)==&PL_sv_undef || (sv)==&PL_sv_yes || (sv)==&PL_sv_no || (sv)==&PL_sv_placeholder))

#ifdef DEBUGGING
   /* exercise the immortal resurrection code in sv_free2() */
#  define SvREFCNT_IMMORTAL 1000
#else
#  define SvREFCNT_IMMORTAL ((~(U32)0)/2)
#endif

/*
=for apidoc Am|SV *|boolSV|bool b

Returns a true SV if C<b> is a true value, or a false SV if C<b> is 0.

See also C<L</PL_sv_yes>> and C<L</PL_sv_no>>.

=cut
*/

#define boolSV(b) ((b) ? &PL_sv_yes : &PL_sv_no)

#define isGV(sv) (SvTYPE(sv) == SVt_PVGV)
/* If I give every macro argument a different name, then there won't be bugs
   where nested macros get confused. Been there, done that.  */
#define isGV_with_GP(pwadak) \
	(((SvFLAGS(pwadak) & (SVp_POK|SVpgv_GP)) == SVpgv_GP)	\
	&& (SvTYPE(pwadak) == SVt_PVGV || SvTYPE(pwadak) == SVt_PVLV))
#define isGV_with_GP_on(sv)	STMT_START {			       \
	assert (SvTYPE(sv) == SVt_PVGV || SvTYPE(sv) == SVt_PVLV); \
	assert (!SvPOKp(sv));					       \
	assert (!SvIOKp(sv));					       \
	(SvFLAGS(sv) |= SVpgv_GP);				       \
    } STMT_END
#define isGV_with_GP_off(sv)	STMT_START {			       \
	assert (SvTYPE(sv) == SVt_PVGV || SvTYPE(sv) == SVt_PVLV); \
	assert (!SvPOKp(sv));					       \
	assert (!SvIOKp(sv));					       \
	(SvFLAGS(sv) &= ~SVpgv_GP);				       \
    } STMT_END
#define isREGEXP(sv) \
    (SvTYPE(sv) == SVt_REGEXP				      \
     || (SvFLAGS(sv) & (SVTYPEMASK|SVp_POK|SVpgv_GP|SVf_FAKE)) \
	 == (SVt_PVLV|SVf_FAKE))


#ifdef PERL_ANY_COW
# define SvGROW(sv,len) \
	(SvIsCOW(sv) || SvLEN(sv) < (len) ? sv_grow(sv,len) : SvPVX(sv))
#else
# define SvGROW(sv,len) (SvLEN(sv) < (len) ? sv_grow(sv,len) : SvPVX(sv))
#endif
#define SvGROW_mutable(sv,len) \
    (SvLEN(sv) < (len) ? sv_grow(sv,len) : SvPVX_mutable(sv))
#define Sv_Grow sv_grow

#define CLONEf_COPY_STACKS 1
#define CLONEf_KEEP_PTR_TABLE 2
#define CLONEf_CLONE_HOST 4
#define CLONEf_JOIN_IN 8

struct clone_params {
  AV* stashes;
  UV  flags;
  PerlInterpreter *proto_perl;
  PerlInterpreter *new_perl;
  AV *unreferenced;
};

/*
=for apidoc Am|SV*|newSVpvn_utf8|NULLOK const char* s|STRLEN len|U32 utf8

Creates a new SV and copies a string (which may contain C<NUL> (C<\0>)
characters) into it.  If C<utf8> is true, calls
C<SvUTF8_on> on the new SV.  Implemented as a wrapper around C<newSVpvn_flags>.

=cut
*/

#define newSVpvn_utf8(s, len, u) newSVpvn_flags((s), (len), (u) ? SVf_UTF8 : 0)

/*
=for apidoc Amx|SV*|newSVpadname|PADNAME *pn

Creates a new SV containing the pad name.

=cut
*/

#define newSVpadname(pn) newSVpvn_utf8(PadnamePV(pn), PadnameLEN(pn), TRUE)

/*
=for apidoc Am|void|SvOOK_offset|NN SV*sv|STRLEN len

Reads into C<len> the offset from C<SvPVX> back to the true start of the
allocated buffer, which will be non-zero if C<sv_chop> has been used to
efficiently remove characters from start of the buffer.  Implemented as a
macro, which takes the address of C<len>, which must be of type C<STRLEN>.
Evaluates C<sv> more than once.  Sets C<len> to 0 if C<SvOOK(sv)> is false.

=cut
*/

#ifdef DEBUGGING
/* Does the bot know something I don't?
10:28 <@Nicholas> metabatman
10:28 <+meta> Nicholas: crash
*/
#  define SvOOK_offset(sv, offset) STMT_START {				\
	assert(sizeof(offset) == sizeof(STRLEN));			\
	if (SvOOK(sv)) {						\
	    const U8 *_crash = (U8*)SvPVX_const(sv);			\
	    (offset) = *--_crash;					\
	    if (!(offset)) {						\
		_crash -= sizeof(STRLEN);				\
		Copy(_crash, (U8 *)&(offset), sizeof(STRLEN), U8);	\
	    }								\
	    {								\
		/* Validate the preceding buffer's sentinels to		\
		   verify that no-one is using it.  */			\
		const U8 *const _bonk = (U8*)SvPVX_const(sv) - (offset);\
		while (_crash > _bonk) {				\
		    --_crash;						\
		    assert (*_crash == (U8)PTR2UV(_crash));		\
		}							\
	    }								\
	} else {							\
	    (offset) = 0;						\
	}								\
    } STMT_END
#else
    /* This is the same code, but avoids using any temporary variables:  */
#  define SvOOK_offset(sv, offset) STMT_START {				\
	assert(sizeof(offset) == sizeof(STRLEN));			\
	if (SvOOK(sv)) {						\
	    (offset) = ((U8*)SvPVX_const(sv))[-1];			\
	    if (!(offset)) {						\
		Copy(SvPVX_const(sv) - 1 - sizeof(STRLEN),		\
		     (U8*)&(offset), sizeof(STRLEN), U8);		\
	    }								\
	} else {							\
	    (offset) = 0;						\
	}								\
    } STMT_END
#endif

#define newIO()	MUTABLE_IO(newSV_type(SVt_PVIO))

#define SV_CONST(name) \
	PL_sv_consts[SV_CONST_##name] \
		? PL_sv_consts[SV_CONST_##name] \
		: (PL_sv_consts[SV_CONST_##name] = newSVpv_share(#name, 0))

#define SV_CONST_TIESCALAR 0
#define SV_CONST_TIEARRAY 1
#define SV_CONST_TIEHASH 2
#define SV_CONST_TIEHANDLE 3

#define SV_CONST_FETCH 4
#define SV_CONST_FETCHSIZE 5
#define SV_CONST_STORE 6
#define SV_CONST_STORESIZE 7
#define SV_CONST_EXISTS 8

#define SV_CONST_PUSH 9
#define SV_CONST_POP 10
#define SV_CONST_SHIFT 11
#define SV_CONST_UNSHIFT 12
#define SV_CONST_SPLICE 13
#define SV_CONST_EXTEND 14

#define SV_CONST_FIRSTKEY 15
#define SV_CONST_NEXTKEY 16
#define SV_CONST_SCALAR 17

#define SV_CONST_OPEN 18
#define SV_CONST_WRITE 19
#define SV_CONST_PRINT 20
#define SV_CONST_PRINTF 21
#define SV_CONST_READ 22
#define SV_CONST_READLINE 23
#define SV_CONST_GETC 24
#define SV_CONST_SEEK 25
#define SV_CONST_TELL 26
#define SV_CONST_EOF 27
#define SV_CONST_BINMODE 28
#define SV_CONST_FILENO 29
#define SV_CONST_CLOSE 30

#define SV_CONST_DELETE 31
#define SV_CONST_CLEAR 32
#define SV_CONST_UNTIE 33
#define SV_CONST_DESTROY 34

#define SV_CONSTS_COUNT 35

/*
 * Bodyless IVs and NVs!
 *
 * Since 5.9.2, we can avoid allocating a body for SVt_IV-type SVs.
 * Since the larger IV-holding variants of SVs store their integer
 * values in their respective bodies, the family of SvIV() accessor
 * macros would  naively have to branch on the SV type to find the
 * integer value either in the HEAD or BODY. In order to avoid this
 * expensive branch, a clever soul has deployed a great hack:
 * We set up the SvANY pointer such that instead of pointing to a
 * real body, it points into the memory before the location of the
 * head. We compute this pointer such that the location of
 * the integer member of the hypothetical body struct happens to
 * be the same as the location of the integer member of the bodyless
 * SV head. This now means that the SvIV() family of accessors can
 * always read from the (hypothetical or real) body via SvANY.
 *
 * Since the 5.21 dev series, we employ the same trick for NVs
 * if the architecture can support it (NVSIZE <= IVSIZE).
 */

/* The following two macros compute the necessary offsets for the above
 * trick and store them in SvANY for SvIV() (and friends) to use. */

#ifdef PERL_CORE
#  define SET_SVANY_FOR_BODYLESS_IV(sv) \
	SvANY(sv) =   (XPVIV*)((char*)&(sv->sv_u.svu_iv) \
                    - STRUCT_OFFSET(XPVIV, xiv_iv))

#  define SET_SVANY_FOR_BODYLESS_NV(sv) \
	SvANY(sv) =   (XPVNV*)((char*)&(sv->sv_u.svu_nv) \
                    - STRUCT_OFFSET(XPVNV, xnv_u.xnv_nv))
#endif

/*
 * ex: set ts=8 sts=4 sw=4 et:
 */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /* This file was produced by running the config_h.SH script, which
 * gets its values from uconfig.sh, which is generally produced by
 * running Configure.
 *
 * Feel free to modify any of this as the need arises.  Note, however,
 * that running config_h.SH again will wipe out any changes you've made.
 * For a more permanent change edit uconfig.sh and rerun config_h.SH.
 */

/* Package name      : perl5
 * Source directory  : .
 * Configuration time: Thu Jan  1 00:00:00 GMT 1970
 * Configured by     : root@localhost
 * Target system     : unknown
 */

#ifndef _config_h_
#define _config_h_

/* LOC_SED:
 *	This symbol holds the complete pathname to the sed program.
 */
#define LOC_SED 	""	/**/

/* HAS_ALARM:
 *	This symbol, if defined, indicates that the alarm routine is
 *	available.
 */
/*#define HAS_ALARM		/ **/

/* HAS_BCMP:
 *	This symbol is defined if the bcmp() routine is available to
 *	compare blocks of memory.
 */
/*#define HAS_BCMP	/ **/

/* HAS_BCOPY:
 *	This symbol is defined if the bcopy() routine is available to
 *	copy blocks of memory.
 */
/*#define HAS_BCOPY	/ **/

/* HAS_BZERO:
 *	This symbol is defined if the bzero() routine is available to
 *	set a memory block to 0.
 */
/*#define HAS_BZERO	/ **/

/* HAS_CBRT:
 *	This symbol, if defined, indicates that the cbrt() (cube root)
 *	function is available.
 */
/*#define HAS_CBRT	/ **/

/* HAS_CHOWN:
 *	This symbol, if defined, indicates that the chown routine is
 *	available.
 */
/*#define HAS_CHOWN		/ **/

/* HAS_CHROOT:
 *	This symbol, if defined, indicates that the chroot routine is
 *	available.
 */
/*#define HAS_CHROOT		/ **/

/* HAS_CHSIZE:
 *	This symbol, if defined, indicates that the chsize routine is available
 *	to truncate files.  You might need a -lx to get this routine.
 */
/*#define	HAS_CHSIZE		/ **/

/* HAS_CRYPT:
 *	This symbol, if defined, indicates that the crypt routine is available
 *	to encrypt passwords and the like.
 */
/*#define HAS_CRYPT		/ **/

/* HAS_CTERMID:
 *	This symbol, if defined, indicates that the ctermid routine is
 *	available to generate filename for terminal.
 */
/*#define HAS_CTERMID		/ **/

/* HAS_CUSERID:
 *	This symbol, if defined, indicates that the cuserid routine is
 *	available to get character login names.
 */
/*#define HAS_CUSERID		/ **/

/* HAS_DBL_DIG:
 *	This symbol, if defined, indicates that this system's <float.h>
 *	or <limits.h> defines the symbol DBL_DIG, which is the number
 *	of significant digits in a double precision number.  If this
 *	symbol is not defined, a guess of 15 is usually pretty good.
 */
/*#define HAS_DBL_DIG 	/ **/

/* HAS_DIFFTIME:
 *	This symbol, if defined, indicates that the difftime routine is
 *	available.
 */
/*#define HAS_DIFFTIME		/ **/

/* HAS_DLERROR:
 *	This symbol, if defined, indicates that the dlerror routine is
 *	available to return a string describing the last error that
 *	occurred from a call to dlopen(), dlclose() or dlsym().
 */
/*#define HAS_DLERROR	/ **/

/* HAS_DUP2:
 *	This symbol, if defined, indicates that the dup2 routine is
 *	available to duplicate file descriptors.
 */
/*#define HAS_DUP2	/ **/

/* HAS_FCHMOD:
 *	This symbol, if defined, indicates that the fchmod routine is available
 *	to change mode of opened files.  If unavailable, use chmod().
 */
/*#define HAS_FCHMOD		/ **/

/* HAS_FCHOWN:
 *	This symbol, if defined, indicates that the fchown routine is available
 *	to change ownership of opened files.  If unavailable, use chown().
 */
/*#define HAS_FCHOWN		/ **/

/* HAS_FCNTL:
 *	This symbol, if defined, indicates to the C program that
 *	the fcntl() function exists.
 */
/*#define HAS_FCNTL		/ **/

/* HAS_FGETPOS:
 *	This symbol, if defined, indicates that the fgetpos routine is
 *	available to get the file position indicator, similar to ftell().
 */
/*#define HAS_FGETPOS	/ **/

/* HAS_FLOCK:
 *	This symbol, if defined, indicates that the flock routine is
 *	available to do file locking.
 */
/*#define HAS_FLOCK		/ **/

/* HAS_FORK:
 *	This symbol, if defined, indicates that the fork routine is
 *	available.
 */
#define HAS_FORK		/**/

/* HAS_FSETPOS:
 *	This symbol, if defined, indicates that the fsetpos routine is
 *	available to set the file position indicator, similar to fseek().
 */
/*#define HAS_FSETPOS	/ **/

/* HAS_GETTIMEOFDAY:
 *	This symbol, if defined, indicates that the gettimeofday() system
 *	call is available for a sub-second accuracy clock. Usually, the file
 *	<sys/resource.h> needs to be included (see I_SYS_RESOURCE).
 *	The type "Timeval" should be used to refer to "struct timeval".
 */
/*#define HAS_GETTIMEOFDAY	/ **/
#ifdef HAS_GETTIMEOFDAY
#define Timeval struct timeval	/* Structure used by gettimeofday() */
#endif

/* HAS_GETGROUPS:
 *	This symbol, if defined, indicates that the getgroups() routine is
 *	available to get the list of process groups.  If unavailable, multiple
 *	groups are probably not supported.
 */
/*#define HAS_GETGROUPS		/ **/

/* HAS_GETLOGIN:
 *	This symbol, if defined, indicates that the getlogin routine is
 *	available to get the login name.
 */
/*#define HAS_GETLOGIN		/ **/

/* HAS_GETPGID:
 *	This symbol, if defined, indicates to the C program that 
 *	the getpgid(pid) function is available to get the
 *	process group id.
 */
/*#define HAS_GETPGID		/ **/

/* HAS_GETPGRP2:
 *	This symbol, if defined, indicates that the getpgrp2() (as in DG/UX)
 *	routine is available to get the current process group.
 */
/*#define HAS_GETPGRP2		/ **/

/* HAS_GETPPID:
 *	This symbol, if defined, indicates that the getppid routine is
 *	available to get the parent process ID.
 */
/*#define HAS_GETPPID		/ **/

/* HAS_GETPRIORITY:
 *	This symbol, if defined, indicates that the getpriority routine is
 *	available to get a process's priority.
 */
/*#define HAS_GETPRIORITY		/ **/

/* HAS_INET_ATON:
 *	This symbol, if defined, indicates to the C program that the
 *	inet_aton() function is available to parse IP address "dotted-quad"
 *	strings.
 */
/*#define HAS_INET_ATON		/ **/

/* HAS_KILLPG:
 *	This symbol, if defined, indicates that the killpg routine is available
 *	to kill process groups.  If unavailable, you probably should use kill
 *	with a negative process number.
 */
/*#define HAS_KILLPG	/ **/

/* HAS_LINK:
 *	This symbol, if defined, indicates that the link routine is
 *	available to create hard links.
 */
/*#define HAS_LINK	/ **/

/* HAS_LOCALECONV:
 *	This symbol, if defined, indicates that the localeconv routine is
 *	available for numeric and monetary formatting conventions.
 */
/*#define HAS_LOCALECONV	/ **/

/* HAS_LOCKF:
 *	This symbol, if defined, indicates that the lockf routine is
 *	available to do file locking.
 */
/*#define HAS_LOCKF		/ **/

/* HAS_LSTAT:
 *	This symbol, if defined, indicates that the lstat routine is
 *	available to do file stats on symbolic links.
 */
/*#define HAS_LSTAT		/ **/

/* HAS_MBLEN:
 *	This symbol, if defined, indicates that the mblen routine is available
 *	to find the number of bytes in a multibye character.
 */
/*#define HAS_MBLEN		/ **/

/* HAS_MBSTOWCS:
 *	This symbol, if defined, indicates that the mbstowcs routine is
 *	available to convert a multibyte string into a wide character string.
 */
/*#define	HAS_MBSTOWCS		/ **/

/* HAS_MBTOWC:
 *	This symbol, if defined, indicates that the mbtowc routine is available
 *	to convert a multibyte to a wide character.
 */
/*#define HAS_MBTOWC		/ **/

/* HAS_MEMCMP:
 *	This symbol, if defined, indicates that the memcmp routine is available
 *	to compare blocks of memory.
 */
#define HAS_MEMCMP	/**/

/* HAS_MEMCPY:
 *	This symbol, if defined, indicates that the memcpy routine is available
 *	to copy blocks of memory.
 */
#define HAS_MEMCPY	/**/

/* HAS_MEMMOVE:
 *	This symbol, if defined, indicates that the memmove routine is available
 *	to copy potentially overlapping blocks of memory. This should be used
 *	only when HAS_SAFE_BCOPY is not defined. If neither is there, roll your
 *	own version.
 */
/*#define HAS_MEMMOVE	/ **/

/* HAS_MEMSET:
 *	This symbol, if defined, indicates that the memset routine is available
 *	to set blocks of memory.
 */
#define HAS_MEMSET	/**/

/* HAS_MKDIR:
 *	This symbol, if defined, indicates that the mkdir routine is available
 *	to create directories.  Otherwise you should fork off a new process to
 *	exec /bin/mkdir.
 */
/*#define HAS_MKDIR		/ **/

/* HAS_MKFIFO:
 *	This symbol, if defined, indicates that the mkfifo routine is
 *	available to create FIFOs. Otherwise, mknod should be able to
 *	do it for you. However, if mkfifo is there, mknod might require
 *	super-user privileges which mkfifo will not.
 */
/*#define HAS_MKFIFO		/ **/

/* HAS_MKTIME:
 *	This symbol, if defined, indicates that the mktime routine is
 *	available.
 */
/*#define HAS_MKTIME		/ **/

/* HAS_MSYNC:
 *	This symbol, if defined, indicates that the msync system call is
 *	available to synchronize a mapped file.
 */
/*#define HAS_MSYNC		/ **/

/* HAS_MUNMAP:
 *	This symbol, if defined, indicates that the munmap system call is
 *	available to unmap a region, usually mapped by mmap().
 */
/*#define HAS_MUNMAP		/ **/

/* HAS_NICE:
 *	This symbol, if defined, indicates that the nice routine is
 *	available.
 */
/*#define HAS_NICE		/ **/

/* HAS_PATHCONF:
 *	This symbol, if defined, indicates that pathconf() is available
 *	to determine file-system related limits and options associated
 *	with a given filename.
 */
/* HAS_FPATHCONF:
 *	This symbol, if defined, indicates that pathconf() is available
 *	to determine file-system related limits and options associated
 *	with a given open file descriptor.
 */
/*#define HAS_PATHCONF		/ **/
/*#define HAS_FPATHCONF		/ **/

/* HAS_PAUSE:
 *	This symbol, if defined, indicates that the pause routine is
 *	available to suspend a process until a signal is received.
 */
/*#define HAS_PAUSE		/ **/

/* HAS_PIPE:
 *	This symbol, if defined, indicates that the pipe routine is
 *	available to create an inter-process channel.
 */
/*#define HAS_PIPE		/ **/

/* HAS_POLL:
 *	This symbol, if defined, indicates that the poll routine is
 *	available to poll active file descriptors.  Please check I_POLL and
 *	I_SYS_POLL to know which header should be included as well.
 */
/*#define HAS_POLL		/ **/

/* HAS_READDIR:
 *	This symbol, if defined, indicates that the readdir routine is
 *	available to read directory entries. You may have to include
 *	<dirent.h>. See I_DIRENT.
 */
#define HAS_READDIR		/**/

/* HAS_SEEKDIR:
 *	This symbol, if defined, indicates that the seekdir routine is
 *	available. You may have to include <dirent.h>. See I_DIRENT.
 */
/*#define HAS_SEEKDIR		/ **/

/* HAS_TELLDIR:
 *	This symbol, if defined, indicates that the telldir routine is
 *	available. You may have to include <dirent.h>. See I_DIRENT.
 */
/*#define HAS_TELLDIR		/ **/

/* HAS_REWINDDIR:
 *	This symbol, if defined, indicates that the rewinddir routine is
 *	available. You may have to include <dirent.h>. See I_DIRENT.
 */
/*#define HAS_REWINDDIR		/ **/

/* HAS_READLINK:
 *	This symbol, if defined, indicates that the readlink routine is
 *	available to read the value of a symbolic link.
 */
/*#define HAS_READLINK		/ **/

/* HAS_REGCOMP:
 *	This symbol, if defined, indicates that the regcomp() routine is
 *	available to do some regular patern matching (usually on POSIX.2
 *	conforming systems).
 */
#define HAS_REGCOMP		/* POSIX.2 */

/* HAS_RENAME:
 *	This symbol, if defined, indicates that the rename routine is available
 *	to rename files.  Otherwise you should do the unlink(), link(), unlink()
 *	trick.
 */
#define HAS_RENAME	/**/

/* HAS_RMDIR:
 *	This symbol, if defined, indicates that the rmdir routine is
 *	available to remove directories. Otherwise you should fork off a
 *	new process to exec /bin/rmdir.
 */
/*#define HAS_RMDIR		/ **/

/* HAS_SELECT:
 *	This symbol, if defined, indicates that the select routine is
 *	available to select active file descriptors. If the timeout field
 *	is used, <sys/time.h> may need to be included.
 */
/*#define HAS_SELECT	/ **/

/* HAS_SETEGID:
 *	This symbol, if defined, indicates that the setegid routine is available
 *	to change the effective gid of the current program.
 */
/*#define HAS_SETEGID		/ **/

/* HAS_SETEUID:
 *	This symbol, if defined, indicates that the seteuid routine is available
 *	to change the effective uid of the current program.
 */
/*#define HAS_SETEUID		/ **/

/* HAS_SETGROUPS:
 *	This symbol, if defined, indicates that the setgroups() routine is
 *	available to set the list of process groups.  If unavailable, multiple
 *	groups are probably not supported.
 */
/*#define HAS_SETGROUPS		/ **/

/* HAS_SETLINEBUF:
 *	This symbol, if defined, indicates that the setlinebuf routine is
 *	available to change stderr or stdout from block-buffered or unbuffered
 *	to a line-buffered mode.
 */
/*#define HAS_SETLINEBUF		/ **/

/* HAS_SETLOCALE:
 *	This symbol, if defined, indicates that the setlocale routine is
 *	available to handle locale-specific ctype implementations.
 */
/*#define HAS_SETLOCALE	/ **/

/* HAS_SETPGID:
 *	This symbol, if defined, indicates that the setpgid(pid, gpid)
 *	routine is available to set process group ID.
 */
/*#define HAS_SETPGID	/ **/

/* HAS_SETPGRP2:
 *	This symbol, if defined, indicates that the setpgrp2() (as in DG/UX)
 *	routine is available to set the current process group.
 */
/*#define HAS_SETPGRP2		/ **/

/* HAS_SETPRIORITY:
 *	This symbol, if defined, indicates that the setpriority routine is
 *	available to set a process's priority.
 */
/*#define HAS_SETPRIORITY		/ **/

/* HAS_SETREGID:
 *	This symbol, if defined, indicates that the setregid routine is
 *	available to change the real and effective gid of the current
 *	process.
 */
/* HAS_SETRESGID:
 *	This symbol, if defined, indicates that the setresgid routine is
 *	available to change the real, effective and saved gid of the current
 *	process.
 */
/*#define HAS_SETREGID		/ **/
/*#define HAS_SETRESGID		/ **/

/* HAS_SETREUID:
 *	This symbol, if defined, indicates that the setreuid routine is
 *	available to change the real and effective uid of the current
 *	process.
 */
/* HAS_SETRESUID:
 *	This symbol, if defined, indicates that the setresuid routine is
 *	available to change the real, effective and saved uid of the current
 *	process.
 */
/*#define HAS_SETREUID		/ **/
/*#define HAS_SETRESUID		/ **/

/* HAS_SETRGID:
 *	This symbol, if defined, indicates that the setrgid routine is available
 *	to change the real gid of the current program.
 */
/*#define HAS_SETRGID		/ **/

/* HAS_SETRUID:
 *	This symbol, if defined, indicates that the setruid routine is available
 *	to change the real uid of the current program.
 */
/*#define HAS_SETRUID		/ **/

/* HAS_SETSID:
 *	This symbol, if defined, indicates that the setsid routine is
 *	available to set the process group ID.
 */
/*#define HAS_SETSID	/ **/

/* HAS_STAT:
 *	This symbol, if defined, indicates that the stat routine is
 *	available to get file status.
 */
#define HAS_STAT	/**/

/* HAS_STRCHR:
 *	This symbol is defined to indicate that the strchr()/strrchr()
 *	functions are available for string searching. If not, try the
 *	index()/rindex() pair.
 */
/* HAS_INDEX:
 *	This symbol is defined to indicate that the index()/rindex()
 *	functions are available for string searching.
 */
/*#define HAS_STRCHR	/ **/
/*#define HAS_INDEX	/ **/

/* HAS_STRCOLL:
 *	This symbol, if defined, indicates that the strcoll routine is
 *	available to compare strings using collating information.
 */
/*#define HAS_STRCOLL	/ **/

/* HAS_STRTOD:
 *	This symbol, if defined, indicates that the strtod routine is
 *	available to provide better numeric string conversion than atof().
 */
/*#define HAS_STRTOD	/ **/

/* HAS_STRTOL:
 *	This symbol, if defined, indicates that the strtol routine is available
 *	to provide better numeric string conversion than atoi() and friends.
 */
#define HAS_STRTOL	/**/

/* HAS_STRXFRM:
 *	This symbol, if defined, indicates that the strxfrm() routine is
 *	available to transform strings.
 */
/*#define HAS_STRXFRM	/ **/

/* HAS_SYMLINK:
 *	This symbol, if defined, indicates that the symlink routine is available
 *	to create symbolic links.
 */
/*#define HAS_SYMLINK	/ **/

/* HAS_SYSCALL:
 *	This symbol, if defined, indicates that the syscall routine is
 *	available to call arbitrary system calls. If undefined, that's tough.
 */
/*#define HAS_SYSCALL	/ **/

/* HAS_SYSCONF:
 *	This symbol, if defined, indicates that sysconf() is available
 *	to determine system related limits and options.
 */
/*#define HAS_SYSCONF	/ **/

/* HAS_SYSTEM:
 *	This symbol, if defined, indicates that the system routine is
 *	available to issue a shell command.
 */
/*#define HAS_SYSTEM	/ **/

/* HAS_TCGETPGRP:
 *	This symbol, if defined, indicates that the tcgetpgrp routine is
 *	available to get foreground process group ID.
 */
/*#define HAS_TCGETPGRP		/ **/

/* HAS_TCSETPGRP:
 *	This symbol, if defined, indicates that the tcsetpgrp routine is
 *	available to set foreground process group ID.
 */
/*#define HAS_TCSETPGRP		/ **/

/* HAS_TRUNCATE:
 *	This symbol, if defined, indicates that the truncate routine is
 *	available to truncate files.
 */
/*#define HAS_TRUNCATE	/ **/

/* HAS_TZNAME:
 *	This symbol, if defined, indicates that the tzname[] array is
 *	available to access timezone names.
 */
/*#define HAS_TZNAME		/ **/

/* HAS_UMASK:
 *	This symbol, if defined, indicates that the umask routine is
 *	available to set and get the value of the file creation mask.
 */
/*#define HAS_UMASK		/ **/

/* HAS_USLEEP:
 *	This symbol, if defined, indicates that the usleep routine is
 *	available to let the process sleep on a sub-second accuracy.
 */
/*#define HAS_USLEEP		/ **/

/* HAS_WAIT4:
 *	This symbol, if defined, indicates that wait4() exists.
 */
/*#define HAS_WAIT4	/ **/

/* HAS_WAITPID:
 *	This symbol, if defined, indicates that the waitpid routine is
 *	available to wait for child process.
 */
/*#define HAS_WAITPID	/ **/

/* HAS_WCSTOMBS:
 *	This symbol, if defined, indicates that the wcstombs routine is
 *	available to convert wide character strings to multibyte strings.
 */
/*#define HAS_WCSTOMBS	/ **/

/* HAS_WCTOMB:
 *	This symbol, if defined, indicates that the wctomb routine is available
 *	to convert a wide character to a multibyte.
 */
/*#define HAS_WCTOMB		/ **/

/* Groups_t:
 *	This symbol holds the type used for the second argument to
 *	getgroups() and setgroups().  Usually, this is the same as
 *	gidtype (gid_t) , but sometimes it isn't.
 *	It can be int, ushort, gid_t, etc... 
 *	It may be necessary to include <sys/types.h> to get any 
 *	typedef'ed information.  This is only required if you have
 *	getgroups() or setgroups()..
 */
#if defined(HAS_GETGROUPS) || defined(HAS_SETGROUPS)
#define Groups_t int	/* Type for 2nd arg to [sg]etgroups() */
#endif

/* I_ARPA_INET:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <arpa/inet.h> to get inet_addr and friends declarations.
 */
/*#define	I_ARPA_INET		/ **/

/* I_DBM:
 *	This symbol, if defined, indicates that <dbm.h> exists and should
 *	be included.
 */
/* I_RPCSVC_DBM:
 *	This symbol, if defined, indicates that <rpcsvc/dbm.h> exists and
 *	should be included.
 */
/*#define I_DBM	/ **/
/*#define I_RPCSVC_DBM	/ **/

/* I_DLFCN:
 *	This symbol, if defined, indicates that <dlfcn.h> exists and should
 *	be included.
 */
/*#define I_DLFCN		/ **/

/* I_FCNTL:
 *	This manifest constant tells the C program to include <fcntl.h>.
 */
/*#define I_FCNTL	/ **/

/* I_FLOAT:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <float.h> to get definition of symbols like DBL_MAX or
 *	DBL_MIN, i.e. machine dependent floating point values.
 */
/*#define I_FLOAT		/ **/

/* I_GDBM:
 *	This symbol, if defined, indicates that <gdbm.h> exists and should
 *	be included.
 */
/*#define I_GDBM	/ **/

/* I_LIMITS:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <limits.h> to get definition of symbols like WORD_BIT or
 *	LONG_MAX, i.e. machine dependant limitations.
 */
/*#define I_LIMITS		/ **/

/* I_LOCALE:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <locale.h>.
 */
/*#define	I_LOCALE		/ **/

/* I_MATH:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <math.h>.
 */
#define I_MATH		/**/

/* I_MEMORY:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <memory.h>.
 */
/*#define I_MEMORY		/ **/

/* I_NETINET_IN:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <netinet/in.h>. Otherwise, you may try <sys/in.h>.
 */
/*#define I_NETINET_IN	/ **/

/* I_STDDEF:
 *	This symbol, if defined, indicates that <stddef.h> exists and should
 *	be included.
 */
#define I_STDDEF	/**/

/* I_STDLIB:
 *	This symbol, if defined, indicates that <stdlib.h> exists and should
 *	be included.
 */
#define I_STDLIB		/**/

/* I_STRING:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <string.h> (USG systems) instead of <strings.h> (BSD systems).
 */
#define I_STRING		/**/

/* I_SYS_DIR:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/dir.h>.
 */
/*#define I_SYS_DIR		/ **/

/* I_SYS_FILE:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/file.h> to get definition of R_OK and friends.
 */
/*#define I_SYS_FILE		/ **/

/* I_SYS_IOCTL:
 *	This symbol, if defined, indicates that <sys/ioctl.h> exists and should
 *	be included. Otherwise, include <sgtty.h> or <termio.h>.
 */
/* I_SYS_SOCKIO:
 *	This symbol, if defined, indicates the <sys/sockio.h> should be included
 *	to get socket ioctl options, like SIOCATMARK.
 */
/*#define	I_SYS_IOCTL		/ **/
/*#define I_SYS_SOCKIO	/ **/

/* I_SYS_NDIR:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/ndir.h>.
 */
/*#define I_SYS_NDIR	/ **/

/* I_SYS_PARAM:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/param.h>.
 */
/*#define I_SYS_PARAM		/ **/

/* I_SYS_POLL:
 *	This symbol, if defined, indicates that the program may include
 *	<sys/poll.h>.  When I_POLL is also defined, it's probably safest
 *	to only include <poll.h>.
 */
/*#define I_SYS_POLL	/ **/

/* I_SYS_RESOURCE:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/resource.h>.
 */
/*#define I_SYS_RESOURCE		/ **/

/* I_SYS_SELECT:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/select.h> in order to get definition of struct timeval.
 */
/*#define I_SYS_SELECT	/ **/

/* I_SYS_STAT:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/stat.h>.
 */
#define	I_SYS_STAT		/**/

/* I_SYS_TIMES:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/times.h>.
 */
/*#define	I_SYS_TIMES		/ **/

/* I_SYS_TYPES:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/types.h>.
 */
/*#define	I_SYS_TYPES		/ **/

/* I_SYS_UN:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/un.h> to get UNIX domain socket definitions.
 */
/*#define I_SYS_UN		/ **/

/* I_SYS_WAIT:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/wait.h>.
 */
/*#define I_SYS_WAIT	/ **/

/* I_UNISTD:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <unistd.h>.
 */
/*#define I_UNISTD		/ **/

/* I_UTIME:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <utime.h>.
 */
/*#define I_UTIME		/ **/

/* I_VALUES:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <values.h> to get definition of symbols like MINFLOAT or
 *	MAXLONG, i.e. machine dependant limitations.  Probably, you
 *	should use <limits.h> instead, if it is available.
 */
/*#define I_VALUES		/ **/

/* I_VFORK:
 *	This symbol, if defined, indicates to the C program that it should
 *	include vfork.h.
 */
/*#define I_VFORK	/ **/

/* STDCHAR:
 *	This symbol is defined to be the type of char used in stdio.h.
 *	It has the values "unsigned char" or "char".
 */
#define STDCHAR char	/**/

/* CAN_VAPROTO:
 *	This variable is defined on systems supporting prototype declaration
 *	of functions with a variable number of arguments.
 */
/* _V:
 *	This macro is used to declare function parameters in prototypes for
 *	functions with a variable number of parameters. Use double parentheses.
 *	For example:
 *
 *		int printf _V((char *fmt, ...));
 *
 *	Remember to use the plain simple _() macro when declaring a function
 *	with no variable number of arguments, since it might be possible to
 *	have a non-effect _V() macro and still get prototypes via _().
 */
/*#define CAN_VAPROTO	/ **/
#ifdef CAN_VAPROTO
#define	_V(args) args
#else
#define	_V(args) ()
#endif

/* INTSIZE:
 *	This symbol contains the value of sizeof(int) so that the C
 *	preprocessor can make decisions based on it.
 */
/* LONGSIZE:
 *	This symbol contains the value of sizeof(long) so that the C
 *	preprocessor can make decisions based on it.
 */
/* SHORTSIZE:
 *	This symbol contains the value of sizeof(short) so that the C
 *	preprocessor can make decisions based on it.
 */
#define INTSIZE 4		/**/
#define LONGSIZE 4		/**/
#define SHORTSIZE 2		/**/

/* MULTIARCH:
 *	This symbol, if defined, signifies that the build
 *	process will produce some binary files that are going to be
 *	used in a cross-platform environment.  This is the case for
 *	example with the NeXT "fat" binaries that contain executables
 *	for several CPUs.
 */
/*#define MULTIARCH		/ **/

/* HAS_QUAD:
 *	This symbol, if defined, tells that there's a 64-bit integer type,
 *	Quad_t, and its unsigned counterpart, Uquad_t. QUADKIND will be one
 *	of QUAD_IS_INT, QUAD_IS_LONG, QUAD_IS_LONG_LONG, QUAD_IS_INT64_T,
 *	or QUAD_IS___INT64.
 */
/*#define HAS_QUAD	/ **/
#ifdef HAS_QUAD
#   define Quad_t int64_t	/**/
#   define Uquad_t uint64_t	/**/
#   define QUADKIND 4	/**/
#   define QUAD_IS_INT	1
#   define QUAD_IS_LONG	2
#   define QUAD_IS_LONG_LONG	3
#   define QUAD_IS_INT64_T	4
#   define QUAD_IS___INT64	5
#endif

/* HAS_ACCESSX:
 *	This symbol, if defined, indicates that the accessx routine is
 *	available to do extended access checks.
 */
/*#define HAS_ACCESSX		/ **/

/* HAS_EACCESS:
 *	This symbol, if defined, indicates that the eaccess routine is
 *	available to do extended access checks.
 */
/*#define HAS_EACCESS		/ **/

/* I_SYS_ACCESS:
 *     This symbol, if defined, indicates to the C program that it should
 *     include <sys/access.h>.
 */
/*#define   I_SYS_ACCESS                / **/

/* I_SYS_SECURITY:
 *     This symbol, if defined, indicates to the C program that it should
 *     include <sys/security.h>.
 */
/*#define   I_SYS_SECURITY	/ **/

/* MEM_ALIGNBYTES:
 *	This symbol contains the number of bytes required to align a
 *	double, or a long double when applicable. Usual values are 2,
 *	4 and 8. The default is eight, for safety.  For cross-compiling
 *  	or multiarch support, Configure will set a minimum of 8.
 */
#define MEM_ALIGNBYTES 4

/* BYTEORDER:
 *	This symbol holds the hexadecimal constant defined in byteorder,
 *	in a UV, i.e. 0x1234 or 0x4321 or 0x12345678, etc...
 *	If the compiler supports cross-compiling or multiple-architecture
 *	binaries, use compiler-defined macros to
 *	determine the byte order.
 */
#if defined(MULTIARCH)
#  ifdef __LITTLE_ENDIAN__
#    if LONGSIZE == 4
#      define BYTEORDER 0x1234
#    else
#      if LONGSIZE == 8
#        define BYTEORDER 0x12345678
#      endif
#    endif
#  else
#    ifdef __BIG_ENDIAN__
#      if LONGSIZE == 4
#        define BYTEORDER 0x4321
#      else
#        if LONGSIZE == 8
#          define BYTEORDER 0x87654321
#        endif
#      endif
#    endif
#  endif
#else
#define BYTEORDER 0x1234	/* large digits for MSB */
#endif

/* CHARBITS:
 *	This symbol contains the size of a char, so that the C preprocessor
 *	can make decisions based on it.
 */
#define CHARBITS 8		/**/

/* CASTI32:
 *	This symbol is defined if the C compiler can cast negative
 *	or large floating point numbers to 32-bit ints.
 */
/*#define	CASTI32		/ **/

/* CASTNEGFLOAT:
 *	This symbol is defined if the C compiler can cast negative
 *	numbers to unsigned longs, ints and shorts.
 */
/* CASTFLAGS:
 *	This symbol contains flags that say what difficulties the compiler
 *	has casting odd floating values to unsigned long:
 *		0 = ok
 *		1 = couldn't cast < 0
 *		2 = couldn't cast >= 0x80000000
 *		4 = couldn't cast in argument expression list
 */
/*#define	CASTNEGFLOAT		/ **/
#define CASTFLAGS 0		/**/

/* VOID_CLOSEDIR:
 *	This symbol, if defined, indicates that the closedir() routine
 *	does not return a value.
 */
/*#define VOID_CLOSEDIR		/ **/

/* HAS_FD_SET:
 *	This symbol, when defined, indicates presence of the fd_set typedef
 *	in <sys/types.h>
 */
/*#define HAS_FD_SET	/ **/

/* Gconvert:
 *	This preprocessor macro is defined to convert a floating point
 *	number to a string without a trailing decimal point.  This
 *	emulates the behavior of sprintf("%g"), but is sometimes much more
 *	efficient.  If gconvert() is not available, but gcvt() drops the
 *	trailing decimal point, then gcvt() is used.  If all else fails,
 *	a macro using sprintf("%g") is used. Arguments for the Gconvert
 *	macro are: value, number of digits, whether trailing zeros should
 *	be retained, and the output buffer.
 *	The usual values are:
 *		d_Gconvert='gconvert((x),(n),(t),(b))'
 *		d_Gconvert='gcvt((x),(n),(b))'
 *		d_Gconvert='sprintf((b),"%.*g",(n),(x))'
 *	The last two assume trailing zeros should not be kept.
 */
#define Gconvert(x,n,t,b) sprintf((b),"%.*g",(n),(x))

/* HAS_GETPAGESIZE:
 *	This symbol, if defined, indicates that the getpagesize system call
 *	is available to get system page size, which is the granularity of
 *	many memory management calls.
 */
/*#define HAS_GETPAGESIZE		/ **/

/* HAS_GNULIBC:
 *	This symbol, if defined, indicates to the C program that
 *	the GNU C library is being used.  A better check is to use
 *	the __GLIBC__ and __GLIBC_MINOR__ symbols supplied with glibc.
 */
/*#define HAS_GNULIBC  	/ **/
#if defined(HAS_GNULIBC) && !defined(_GNU_SOURCE)
#   define _GNU_SOURCE
#endif

/* HAS_ISASCII:
 *	This manifest constant lets the C program know that isascii
 *	is available.
 */
/*#define HAS_ISASCII		/ **/

/* HAS_LCHOWN:
 *	This symbol, if defined, indicates that the lchown routine is
 *	available to operate on a symbolic link (instead of following the
 *	link).
 */
/*#define HAS_LCHOWN		/ **/

/* HAS_OPEN3:
 *	This manifest constant lets the C program know that the three
 *	argument form of open(2) is available.
 */
/*#define HAS_OPEN3		/ **/

/* HAS_SAFE_BCOPY:
 *	This symbol, if defined, indicates that the bcopy routine is available
 *	to copy potentially overlapping memory blocks. Normally, you should
 *	probably use memmove() or memcpy(). If neither is defined, roll your
 *	own version.
 */
/*#define HAS_SAFE_BCOPY	/ **/

/* HAS_SAFE_MEMCPY:
 *	This symbol, if defined, indicates that the memcpy routine is available
 *	to copy potentially overlapping memory blocks.  If you need to
 *	copy overlapping memory blocks, you should check HAS_MEMMOVE and
 *	use memmove() instead, if available.
 */
/*#define HAS_SAFE_MEMCPY	/ **/

/* HAS_SANE_MEMCMP:
 *	This symbol, if defined, indicates that the memcmp routine is available
 *	and can be used to compare relative magnitudes of chars with their high
 *	bits set.  If it is not defined, roll your own version.
 */
/*#define HAS_SANE_MEMCMP	/ **/

/* HAS_SIGACTION:
 *	This symbol, if defined, indicates that Vr4's sigaction() routine
 *	is available.
 */
/*#define HAS_SIGACTION	/ **/

/* HAS_SIGINFO_SI_ERRNO:
 *	This symbol, if defined, indicates that siginfo_t has the
 *	si_errno member
 */
/* HAS_SIGINFO_SI_PID:
 *	This symbol, if defined, indicates that siginfo_t has the
 *	si_pid member
 */
/* HAS_SIGINFO_SI_UID:
 *	This symbol, if defined, indicates that siginfo_t has the
 *	si_uid member
 */
/* HAS_SIGINFO_SI_ADDR:
 *	This symbol, if defined, indicates that siginfo_t has the
 *	si_addr member
 */
/* HAS_SIGINFO_SI_STATUS:
 *	This symbol, if defined, indicates that siginfo_t has the
 *	si_status member
 */
/* HAS_SIGINFO_SI_BAND:
 *	This symbol, if defined, indicates that siginfo_t has the
 *	si_band member
 */
/* HAS_SIGINFO_SI_VALUE:
 *	This symbol, if defined, indicates that siginfo_t has the
 *	si_value member
 */
/*#define	HAS_SIGINFO_SI_ERRNO	/ **/
/*#define	HAS_SIGINFO_SI_PID	/ **/
/*#define	HAS_SIGINFO_SI_UID	/ **/
/*#define	HAS_SIGINFO_SI_ADDR	/ **/
/*#define	HAS_SIGINFO_SI_STATUS	/ **/
/*#define	HAS_SIGINFO_SI_BAND	/ **/
/*#define	HAS_SIGINFO_SI_VALUE	/ **/

/* HAS_SIGSETJMP:
 *	This variable indicates to the C program that the sigsetjmp()
 *	routine is available to save the calling process's registers
 *	and stack environment for later use by siglongjmp(), and
 *	to optionally save the process's signal mask.  See
 *	Sigjmp_buf, Sigsetjmp, and Siglongjmp.
 */
/* Sigjmp_buf:
 *	This is the buffer type to be used with Sigsetjmp and Siglongjmp.
 */
/* Sigsetjmp:
 *	This macro is used in the same way as sigsetjmp(), but will invoke
 *	traditional setjmp() if sigsetjmp isn't available.
 *	See HAS_SIGSETJMP.
 */
/* Siglongjmp:
 *	This macro is used in the same way as siglongjmp(), but will invoke
 *	traditional longjmp() if siglongjmp isn't available.
 *	See HAS_SIGSETJMP.
 */
/*#define HAS_SIGSETJMP	/ **/
#ifdef HAS_SIGSETJMP
#define Sigjmp_buf sigjmp_buf
#define Sigsetjmp(buf,save_mask) sigsetjmp((buf),(save_mask))
#define Siglongjmp(buf,retval) siglongjmp((buf),(retval))
#else
#define Sigjmp_buf jmp_buf
#define Sigsetjmp(buf,save_mask) setjmp((buf))
#define Siglongjmp(buf,retval) longjmp((buf),(retval))
#endif

/* HAS_STATIC_INLINE:
 *	This symbol, if defined, indicates that the C compiler supports
 *	C99-style static inline.  That is, the function can't be called
 *	from another translation unit.
 */
/* PERL_STATIC_INLINE:
 *	This symbol gives the best-guess incantation to use for static
 *	inline functions.  If HAS_STATIC_INLINE is defined, this will
 *	give C99-style inline.  If HAS_STATIC_INLINE is not defined,
 *	this will give a plain 'static'.  It will always be defined
 *	to something that gives static linkage.
 *	Possibilities include
 *		static inline       (c99)
 *		static __inline__   (gcc -ansi)
 *		static __inline     (MSVC)
 *		static _inline      (older MSVC)
 *		static              (c89 compilers)
 */
/*#define HAS_STATIC_INLINE				/ **/
#define PERL_STATIC_INLINE static	/**/

/* USE_STDIO_PTR:
 *	This symbol is defined if the _ptr and _cnt fields (or similar)
 *	of the stdio FILE structure can be used to access the stdio buffer
 *	for a file handle.  If this is defined, then the FILE_ptr(fp)
 *	and FILE_cnt(fp) macros will also be defined and should be used
 *	to access these fields.
 */
/* FILE_ptr:
 *	This macro is used to access the _ptr field (or equivalent) of the
 *	FILE structure pointed to by its argument. This macro will always be
 *	defined if USE_STDIO_PTR is defined.
 */
/* STDIO_PTR_LVALUE:
 *	This symbol is defined if the FILE_ptr macro can be used as an
 *	lvalue.
 */
/* FILE_cnt:
 *	This macro is used to access the _cnt field (or equivalent) of the
 *	FILE structure pointed to by its argument. This macro will always be
 *	defined if USE_STDIO_PTR is defined.
 */
/* STDIO_CNT_LVALUE:
 *	This symbol is defined if the FILE_cnt macro can be used as an
 *	lvalue.
 */
/* STDIO_PTR_LVAL_SETS_CNT:
 *	This symbol is defined if using the FILE_ptr macro as an lvalue
 *	to increase the pointer by n has the side effect of decreasing the
 *	value of File_cnt(fp) by n.
 */
/* STDIO_PTR_LVAL_NOCHANGE_CNT:
 *	This symbol is defined if using the FILE_ptr macro as an lvalue
 *	to increase the pointer by n leaves File_cnt(fp) unchanged.
 */
/*#define USE_STDIO_PTR 	/ **/
#ifdef USE_STDIO_PTR
#define FILE_ptr(fp)	((fp)->_IO_read_ptr)
/*#define STDIO_PTR_LVALUE 		/ **/
#define FILE_cnt(fp)	((fp)->_IO_read_end - (fp)->_IO_read_ptr)
/*#define STDIO_CNT_LVALUE 		/ **/
/*#define STDIO_PTR_LVAL_SETS_CNT	/ **/
/*#define STDIO_PTR_LVAL_NOCHANGE_CNT	/ **/
#endif

/* USE_STDIO_BASE:
 *	This symbol is defined if the _base field (or similar) of the
 *	stdio FILE structure can be used to access the stdio buffer for
 *	a file handle.  If this is defined, then the FILE_base(fp) macro
 *	will also be defined and should be used to access this field.
 *	Also, the FILE_bufsiz(fp) macro will be defined and should be used
 *	to determine the number of bytes in the buffer.  USE_STDIO_BASE
 *	will never be defined unless USE_STDIO_PTR is.
 */
/* FILE_base:
 *	This macro is used to access the _base field (or equivalent) of the
 *	FILE structure pointed to by its argument. This macro will always be
 *	defined if USE_STDIO_BASE is defined.
 */
/* FILE_bufsiz:
 *	This macro is used to determine the number of bytes in the I/O
 *	buffer pointed to by _base field (or equivalent) of the FILE
 *	structure pointed to its argument. This macro will always be defined
 *	if USE_STDIO_BASE is defined.
 */
/*#define USE_STDIO_BASE 	/ **/
#ifdef USE_STDIO_BASE
#define FILE_base(fp)	((fp)->_IO_read_base)
#define FILE_bufsiz(fp)	((fp)->_IO_read_end - (fp)->_IO_read_base)
#endif

/* HAS_VPRINTF:
 *	This symbol, if defined, indicates that the vprintf routine is available
 *	to printf with a pointer to an argument list.  If unavailable, you
 *	may need to write your own, probably in terms of _doprnt().
 */
/* USE_CHAR_VSPRINTF:
 *	This symbol is defined if this system has vsprintf() returning type
 *	(char*).  The trend seems to be to declare it as "int vsprintf()".  It
 *	is up to the package author to declare vsprintf correctly based on the
 *	symbol.
 */
#define HAS_VPRINTF	/**/
/*#define USE_CHAR_VSPRINTF 	/ **/

/* DOUBLESIZE:
 *	This symbol contains the size of a double, so that the C preprocessor
 *	can make decisions based on it.
 */
#define DOUBLESIZE 8		/**/

/* I_TIME:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <time.h>.
 */
/* I_SYS_TIME:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/time.h>.
 */
/* I_SYS_TIME_KERNEL:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/time.h> with KERNEL defined.
 */
/* HAS_TM_TM_ZONE:
 *	This symbol, if defined, indicates to the C program that
 *	the struct tm has a tm_zone field.
 */
/* HAS_TM_TM_GMTOFF:
 *	This symbol, if defined, indicates to the C program that
 *	the struct tm has a tm_gmtoff field.
 */
#define I_TIME		/**/
/*#define I_SYS_TIME		/ **/
/*#define I_SYS_TIME_KERNEL		/ **/
/*#define HAS_TM_TM_ZONE		/ **/
/*#define HAS_TM_TM_GMTOFF		/ **/

/* VAL_O_NONBLOCK:
 *	This symbol is to be used during open() or fcntl(F_SETFL) to turn on
 *	non-blocking I/O for the file descriptor. Note that there is no way
 *	back, i.e. you cannot turn it blocking again this way. If you wish to
 *	alternatively switch between blocking and non-blocking, use the
 *	ioctl(FIOSNBIO) call instead, but that is not supported by all devices.
 */
/* VAL_EAGAIN:
 *	This symbol holds the errno error code set by read() when no data was
 *	present on the non-blocking file descriptor.
 */
/* RD_NODATA:
 *	This symbol holds the return code from read() when no data is present
 *	on the non-blocking file descriptor. Be careful! If EOF_NONBLOCK is
 *	not defined, then you can't distinguish between no data and EOF by
 *	issuing a read(). You'll have to find another way to tell for sure!
 */
/* EOF_NONBLOCK:
 *	This symbol, if defined, indicates to the C program that a read() on
 *	a non-blocking file descriptor will return 0 on EOF, and not the value
 *	held in RD_NODATA (-1 usually, in that case!).
 */
#define VAL_O_NONBLOCK O_NONBLOCK
#define VAL_EAGAIN EAGAIN
#define RD_NODATA -1
#undef EOF_NONBLOCK

/* PTRSIZE:
 *	This symbol contains the size of a pointer, so that the C preprocessor
 *	can make decisions based on it.  It will be sizeof(void *) if
 *	the compiler supports (void *); otherwise it will be
 *	sizeof(char *).
 */
#define PTRSIZE 4		/**/

/* Drand01:
 *	This macro is to be used to generate uniformly distributed
 *	random numbers over the range [0., 1.[.  You may have to supply
 *	an 'extern double drand48();' in your program since SunOS 4.1.3
 *	doesn't provide you with anything relevant in its headers.
 *	See HAS_DRAND48_PROTO.
 */
/* Rand_seed_t:
 *	This symbol defines the type of the argument of the
 *	random seed function.
 */
/* seedDrand01:
 *	This symbol defines the macro to be used in seeding the
 *	random number generator (see Drand01).
 */
/* RANDBITS:
 *	This symbol indicates how many bits are produced by the
 *	function used to generate normalized random numbers.
 *	Values include 15, 16, 31, and 48.
 */
#define Drand01()		Perl_drand48()		/**/
#define Rand_seed_t		U32		/**/
#define seedDrand01(x)	Perl_drand48_init((Rand_seed_t)x)	/**/
#define RANDBITS		48		/**/

/* SSize_t:
 *	This symbol holds the type used by functions that return
 *	a count of bytes or an error condition.  It must be a signed type.
 *	It is usually ssize_t, but may be long or int, etc.
 *	It may be necessary to include <sys/types.h> or <unistd.h>
 *	to get any typedef'ed information.
 *	We will pick a type such that sizeof(SSize_t) == sizeof(Size_t).
 */
#define SSize_t int	 /* signed count of bytes */

/* EBCDIC:
 *	This symbol, if defined, indicates that this system uses
 *	EBCDIC encoding.
 */
/*#define	EBCDIC 		/ **/

/* ARCHLIB:
 *	This variable, if defined, holds the name of the directory in
 *	which the user wants to put architecture-dependent public
 *	library files for perl5.  It is most often a local directory
 *	such as /usr/local/lib.  Programs using this variable must be
 *	prepared to deal with filename expansion.  If ARCHLIB is the
 *	same as PRIVLIB, it is not defined, since presumably the
 *	program already searches PRIVLIB.
 */
/* ARCHLIB_EXP:
 *	This symbol contains the ~name expanded version of ARCHLIB, to be used
 *	in programs that are not prepared to deal with ~ expansion at run-time.
 */
/*#define ARCHLIB "/usr/local/lib/perl5/5.24/unknown"		/ **/
/*#define ARCHLIB_EXP "/usr/local/lib/perl5/5.24/unknown"		/ **/

/* BIN:
 *	This symbol holds the path of the bin directory where the package will
 *	be installed. Program must be prepared to deal with ~name substitution.
 */
/* BIN_EXP:
 *	This symbol is the filename expanded version of the BIN symbol, for
 *	programs that do not want to deal with that at run-time.
 */
/* PERL_RELOCATABLE_INC:
 *	This symbol, if defined, indicates that we'd like to relocate entries
 *	in @INC at run time based on the location of the perl binary.
 */
#define BIN "/usr/local/bin"	/**/
#define BIN_EXP "/usr/local/bin"	/**/
#define PERL_RELOCATABLE_INC "undef" 		/**/

/* PERL_INC_VERSION_LIST:
 *	This variable specifies the list of subdirectories in over
 *	which perl.c:incpush() and lib/lib.pm will automatically
 *	search when adding directories to @INC, in a format suitable
 *	for a C initialization string.  See the inc_version_list entry
 *	in Porting/Glossary for more details.
 */
/*#define PERL_INC_VERSION_LIST NULL		/ **/

/* INSTALL_USR_BIN_PERL:
 *	This symbol, if defined, indicates that Perl is to be installed
 * 	also as /usr/bin/perl.
 */
/*#define INSTALL_USR_BIN_PERL	/ **/

/* PERL_OTHERLIBDIRS:
 *	This variable contains a colon-separated set of paths for the perl
 *	binary to search for additional library files or modules.
 *	These directories will be tacked to the end of @INC.
 *	Perl will automatically search below each path for version-
 *	and architecture-specific directories.  See PERL_INC_VERSION_LIST
 *	for more details.
 */
/*#define PERL_OTHERLIBDIRS " "		/ **/

/* PRIVLIB:
 *	This symbol contains the name of the private library for this package.
 *	The library is private in the sense that it needn't be in anyone's
 *	execution path, but it should be accessible by the world.  The program
 *	should be prepared to do ~ expansion.
 */
/* PRIVLIB_EXP:
 *	This symbol contains the ~name expanded version of PRIVLIB, to be used
 *	in programs that are not prepared to deal with ~ expansion at run-time.
 */
#define PRIVLIB "/usr/local/lib/perl5/5.24"		/**/
#define PRIVLIB_EXP "/usr/local/lib/perl5/5.24"		/**/

/* SITEARCH:
 *	This symbol contains the name of the private library for this package.
 *	The library is private in the sense that it needn't be in anyone's
 *	execution path, but it should be accessible by the world.  The program
 *	should be prepared to do ~ expansion.
 *	The standard distribution will put nothing in this directory.
 *	After perl has been installed, users may install their own local
 *	architecture-dependent modules in this directory with
 *		MakeMaker Makefile.PL
 *	or equivalent.  See INSTALL for details.
 */
/* SITEARCH_EXP:
 *	This symbol contains the ~name expanded version of SITEARCH, to be used
 *	in programs that are not prepared to deal with ~ expansion at run-time.
 */
/*#define SITEARCH "/usr/local/lib/perl5/5.24/unknown"		/ **/
/*#define SITEARCH_EXP "/usr/local/lib/perl5/5.24/unknown"		/ **/

/* SITELIB:
 *	This symbol contains the name of the private library for this package.
 *	The library is private in the sense that it needn't be in anyone's
 *	execution path, but it should be accessible by the world.  The program
 *	should be prepared to do ~ expansion.
 *	The standard distribution will put nothing in this directory.
 *	After perl has been installed, users may install their own local
 *	architecture-independent modules in this directory with
 *		MakeMaker Makefile.PL
 *	or equivalent.  See INSTALL for details.
 */
/* SITELIB_EXP:
 *	This symbol contains the ~name expanded version of SITELIB, to be used
 *	in programs that are not prepared to deal with ~ expansion at run-time.
 */
/* SITELIB_STEM:
 *	This define is SITELIB_EXP with any trailing version-specific component
 *	removed.  The elements in inc_version_list (inc_version_list.U) can
 *	be tacked onto this variable to generate a list of directories to search.
 */
#define SITELIB "/usr/local/lib/perl5/5.24"		/**/
#define SITELIB_EXP "/usr/local/lib/perl5/5.24"		/**/
#define SITELIB_STEM "/usr/local/lib/perl5"		/**/

/* PERL_VENDORARCH:
 *	If defined, this symbol contains the name of a private library.
 *	The library is private in the sense that it needn't be in anyone's
 *	execution path, but it should be accessible by the world.
 *	It may have a ~ on the front.
 *	The standard distribution will put nothing in this directory.
 *	Vendors who distribute perl may wish to place their own
 *	architecture-dependent modules and extensions in this directory with
 *		MakeMaker Makefile.PL INSTALLDIRS=vendor
 *	or equivalent.  See INSTALL for details.
 */
/* PERL_VENDORARCH_EXP:
 *	This symbol contains the ~name expanded version of PERL_VENDORARCH, to be used
 *	in programs that are not prepared to deal with ~ expansion at run-time.
 */
/*#define PERL_VENDORARCH ""		/ **/
/*#define PERL_VENDORARCH_EXP ""		/ **/

/* PERL_VENDORLIB_EXP:
 *	This symbol contains the ~name expanded version of VENDORLIB, to be used
 *	in programs that are not prepared to deal with ~ expansion at run-time.
 */
/* PERL_VENDORLIB_STEM:
 *	This define is PERL_VENDORLIB_EXP with any trailing version-specific component
 *	removed.  The elements in inc_version_list (inc_version_list.U) can
 *	be tacked onto this variable to generate a list of directories to search.
 */
/*#define PERL_VENDORLIB_EXP ""		/ **/
/*#define PERL_VENDORLIB_STEM ""		/ **/

/* OSNAME:
 *	This symbol contains the name of the operating system, as determined
 *	by Configure.  You shouldn't rely on it too much; the specific
 *	feature tests from Configure are generally more reliable.
 */
/* OSVERS:
 *	This symbol contains the version of the operating system, as determined
 *	by Configure.  You shouldn't rely on it too much; the specific
 *	feature tests from Configure are generally more reliable.
 */
#define OSNAME "unknown"		/**/
#define OSVERS "unknown"		/**/

/* CAT2:
 *	This macro concatenates 2 tokens together.
 */
/* STRINGIFY:
 *	This macro surrounds its token with double quotes.
 */
#if 42 == 1
#define CAT2(a,b)	a/**/b
#define STRINGIFY(a)	"a"
#endif
#if 42 == 42
#define PeRl_CaTiFy(a, b)	a ## b
#define PeRl_StGiFy(a)	#a
#define CAT2(a,b)	PeRl_CaTiFy(a,b)
#define StGiFy(a)	PeRl_StGiFy(a)
#define STRINGIFY(a)	PeRl_StGiFy(a)
#endif
#if 42 != 1 && 42 != 42
#include "Bletch: How does this C preprocessor concatenate tokens?"
#endif

/* CPPSTDIN:
 *	This symbol contains the first part of the string which will invoke
 *	the C preprocessor on the standard input and produce to standard
 *	output.	 Typical value of "cc -E" or "/lib/cpp", but it can also
 *	call a wrapper. See CPPRUN.
 */
/* CPPMINUS:
 *	This symbol contains the second part of the string which will invoke
 *	the C preprocessor on the standard input and produce to standard
 *	output.  This symbol will have the value "-" if CPPSTDIN needs a minus
 *	to specify standard input, otherwise the value is "".
 */
/* CPPRUN:
 *	This symbol contains the string which will invoke a C preprocessor on
 *	the standard input and produce to standard output. It needs to end
 *	with CPPLAST, after all other preprocessor flags have been specified.
 *	The main difference with CPPSTDIN is that this program will never be a
 *	pointer to a shell wrapper, i.e. it will be empty if no preprocessor is
 *	available directly to the user. Note that it may well be different from
 *	the preprocessor used to compile the C program.
 */
/* CPPLAST:
 *	This symbol is intended to be used along with CPPRUN in the same manner
 *	symbol CPPMINUS is used with CPPSTDIN. It contains either "-" or "".
 */
#define CPPSTDIN "cc -E"
#define CPPMINUS "-"
#define CPPRUN "cc -E"
#define CPPLAST "-"

/* HAS_ACCESS:
 *	This manifest constant lets the C program know that the access()
 *	system call is available to check for accessibility using real UID/GID.
 *	(always present on UNIX.)
 */
/*#define HAS_ACCESS		/ **/

/* HASATTRIBUTE_FORMAT:
 *	Can we handle GCC attribute for checking printf-style formats
 */
/* PRINTF_FORMAT_NULL_OK:
 *	Allows __printf__ format to be null when checking printf-style
 */
/* HASATTRIBUTE_MALLOC:
 *	Can we handle GCC attribute for malloc-style functions.
 */
/* HASATTRIBUTE_NONNULL:
 *	Can we handle GCC attribute for nonnull function parms.
 */
/* HASATTRIBUTE_NORETURN:
 *	Can we handle GCC attribute for functions that do not return
 */
/* HASATTRIBUTE_PURE:
 *	Can we handle GCC attribute for pure functions
 */
/* HASATTRIBUTE_UNUSED:
 *	Can we handle GCC attribute for unused variables and arguments
 */
/* HASATTRIBUTE_DEPRECATED:
 *	Can we handle GCC attribute for marking deprecated APIs
 */
/* HASATTRIBUTE_WARN_UNUSED_RESULT:
 *	Can we handle GCC attribute for warning on unused results
 */
/*#define HASATTRIBUTE_DEPRECATED	/ **/
/*#define HASATTRIBUTE_FORMAT	/ **/
/*#define PRINTF_FORMAT_NULL_OK	/ **/
/*#define HASATTRIBUTE_NORETURN	/ **/
/*#define HASATTRIBUTE_MALLOC	/ **/
/*#define HASATTRIBUTE_NONNULL	/ **/
/*#define HASATTRIBUTE_PURE	/ **/
/*#define HASATTRIBUTE_UNUSED	/ **/
/*#define HASATTRIBUTE_WARN_UNUSED_RESULT	/ **/

/* HAS_BACKTRACE:
 *	This symbol, if defined, indicates that the backtrace() routine is
 *	available to get a stack trace.  The <execinfo.h> header must be
 *	included to use this routine.
 */
/*#define HAS_BACKTRACE	/ **/

/* HASCONST:
 *	This symbol, if defined, indicates that this C compiler knows about
 *	the const type. There is no need to actually test for that symbol
 *	within your programs. The mere use of the "const" keyword will
 *	trigger the necessary tests.
 */
/*#define HASCONST	/ **/
#ifndef HASCONST
#define const
#endif

/* HAS_CSH:
 *	This symbol, if defined, indicates that the C-shell exists.
 */
/* CSH:
 *	This symbol, if defined, contains the full pathname of csh.
 */
/*#define HAS_CSH		/ **/
#ifdef HAS_CSH
#define CSH ""	/**/
#endif

/* HAS_DLADDR:
 *	This symbol, if defined, indicates that the dladdr() routine is
 *	available to query dynamic linker information for an address.
 *	The <dlfcn.h> header must be included to use this routine.
 */
/*#define HAS_DLADDR	/ **/

/* SETUID_SCRIPTS_ARE_SECURE_NOW:
 *	This symbol, if defined, indicates that the bug that prevents
 *	setuid scripts from being secure is not present in this kernel.
 */
/* DOSUID:
 *	This symbol, if defined, indicates that the C program should
 *	check the script that it is executing for setuid/setgid bits, and
 *	attempt to emulate setuid/setgid on systems that have disabled
 *	setuid #! scripts because the kernel can't do it securely.
 *	It is up to the package designer to make sure that this emulation
 *	is done securely.  Among other things, it should do an fstat on
 *	the script it just opened to make sure it really is a setuid/setgid
 *	script, it should make sure the arguments passed correspond exactly
 *	to the argument on the #! line, and it should not trust any
 *	subprocesses to which it must pass the filename rather than the
 *	file descriptor of the script to be executed.
 */
/*#define SETUID_SCRIPTS_ARE_SECURE_NOW	/ **/
/*#define DOSUID		/ **/

/* HAS_ENDGRENT:
 *	This symbol, if defined, indicates that the getgrent routine is
 *	available for finalizing sequential access of the group database.
 */
/*#define HAS_ENDGRENT		/ **/

/* HAS_ENDHOSTENT:
 *	This symbol, if defined, indicates that the endhostent() routine is
 *	available to close whatever was being used for host queries.
 */
/*#define HAS_ENDHOSTENT		/ **/

/* HAS_ENDNETENT:
 *	This symbol, if defined, indicates that the endnetent() routine is
 *	available to close whatever was being used for network queries.
 */
/*#define HAS_ENDNETENT		/ **/

/* HAS_ENDPROTOENT:
 *	This symbol, if defined, indicates that the endprotoent() routine is
 *	available to close whatever was being used for protocol queries.
 */
/*#define HAS_ENDPROTOENT		/ **/

/* HAS_ENDPWENT:
 *	This symbol, if defined, indicates that the getgrent routine is
 *	available for finalizing sequential access of the passwd database.
 */
/*#define HAS_ENDPWENT		/ **/

/* HAS_ENDSERVENT:
 *	This symbol, if defined, indicates that the endservent() routine is
 *	available to close whatever was being used for service queries.
 */
/*#define HAS_ENDSERVENT		/ **/

/* FLEXFILENAMES:
 *	This symbol, if defined, indicates that the system supports filenames
 *	longer than 14 characters.
 */
/*#define	FLEXFILENAMES		/ **/

/* HAS_GETGRENT:
 *	This symbol, if defined, indicates that the getgrent routine is
 *	available for sequential access of the group database.
 */
/*#define HAS_GETGRENT		/ **/

/* HAS_GETHOSTBYADDR:
 *	This symbol, if defined, indicates that the gethostbyaddr() routine is
 *	available to look up hosts by their IP addresses.
 */
/*#define HAS_GETHOSTBYADDR		/ **/

/* HAS_GETHOSTBYNAME:
 *	This symbol, if defined, indicates that the gethostbyname() routine is
 *	available to look up host names in some data base or other.
 */
/*#define HAS_GETHOSTBYNAME		/ **/

/* HAS_GETHOSTENT:
 *	This symbol, if defined, indicates that the gethostent() routine is
 *	available to look up host names in some data base or another.
 */
/*#define HAS_GETHOSTENT		/ **/

/* HAS_GETHOSTNAME:
 *	This symbol, if defined, indicates that the C program may use the
 *	gethostname() routine to derive the host name.  See also HAS_UNAME
 *	and PHOSTNAME.
 */
/* HAS_UNAME:
 *	This symbol, if defined, indicates that the C program may use the
 *	uname() routine to derive the host name.  See also HAS_GETHOSTNAME
 *	and PHOSTNAME.
 */
/* PHOSTNAME:
 *	This symbol, if defined, indicates the command to feed to the
 *	popen() routine to derive the host name.  See also HAS_GETHOSTNAME
 *	and HAS_UNAME.	Note that the command uses a fully qualified path,
 *	so that it is safe even if used by a process with super-user
 *	privileges.
 */
/* HAS_PHOSTNAME:
 *	This symbol, if defined, indicates that the C program may use the
 *	contents of PHOSTNAME as a command to feed to the popen() routine
 *	to derive the host name.
 */
/*#define HAS_GETHOSTNAME	/ **/
/*#define HAS_UNAME		/ **/
/*#define HAS_PHOSTNAME	/ **/
#ifdef HAS_PHOSTNAME
#define PHOSTNAME "/bin/hostname"	/* How to get the host name */
#endif

/* HAS_GETNETBYADDR:
 *	This symbol, if defined, indicates that the getnetbyaddr() routine is
 *	available to look up networks by their IP addresses.
 */
/*#define HAS_GETNETBYADDR		/ **/

/* HAS_GETNETBYNAME:
 *	This symbol, if defined, indicates that the getnetbyname() routine is
 *	available to look up networks by their names.
 */
/*#define HAS_GETNETBYNAME		/ **/

/* HAS_GETNETENT:
 *	This symbol, if defined, indicates that the getnetent() routine is
 *	available to look up network names in some data base or another.
 */
/*#define HAS_GETNETENT		/ **/

/* HAS_GETPROTOENT:
 *	This symbol, if defined, indicates that the getprotoent() routine is
 *	available to look up protocols in some data base or another.
 */
/*#define HAS_GETPROTOENT		/ **/

/* HAS_GETPGRP:
 *	This symbol, if defined, indicates that the getpgrp routine is
 *	available to get the current process group.
 */
/* USE_BSD_GETPGRP:
 *	This symbol, if defined, indicates that getpgrp needs one
 *	arguments whereas USG one needs none.
 */
/*#define HAS_GETPGRP		/ **/
/*#define USE_BSD_GETPGRP	/ **/

/* HAS_GETPROTOBYNAME:
 *	This symbol, if defined, indicates that the getprotobyname()
 *	routine is available to look up protocols by their name.
 */
/* HAS_GETPROTOBYNUMBER:
 *	This symbol, if defined, indicates that the getprotobynumber()
 *	routine is available to look up protocols by their number.
 */
/*#define HAS_GETPROTOBYNAME		/ **/
/*#define HAS_GETPROTOBYNUMBER		/ **/

/* HAS_GETPWENT:
 *	This symbol, if defined, indicates that the getpwent routine is
 *	available for sequential access of the passwd database.
 *	If this is not available, the older getpw() function may be available.
 */
/*#define HAS_GETPWENT		/ **/

/* HAS_GETSERVENT:
 *	This symbol, if defined, indicates that the getservent() routine is
 *	available to look up network services in some data base or another.
 */
/*#define HAS_GETSERVENT		/ **/

/* HAS_GETSERVBYNAME:
 *	This symbol, if defined, indicates that the getservbyname()
 *	routine is available to look up services by their name.
 */
/* HAS_GETSERVBYPORT:
 *	This symbol, if defined, indicates that the getservbyport()
 *	routine is available to look up services by their port.
 */
/*#define HAS_GETSERVBYNAME		/ **/
/*#define HAS_GETSERVBYPORT		/ **/

/* HAS_HTONL:
 *	This symbol, if defined, indicates that the htonl() routine (and
 *	friends htons() ntohl() ntohs()) are available to do network
 *	order byte swapping.
 */
/* HAS_HTONS:
 *	This symbol, if defined, indicates that the htons() routine (and
 *	friends htonl() ntohl() ntohs()) are available to do network
 *	order byte swapping.
 */
/* HAS_NTOHL:
 *	This symbol, if defined, indicates that the ntohl() routine (and
 *	friends htonl() htons() ntohs()) are available to do network
 *	order byte swapping.
 */
/* HAS_NTOHS:
 *	This symbol, if defined, indicates that the ntohs() routine (and
 *	friends htonl() htons() ntohl()) are available to do network
 *	order byte swapping.
 */
/*#define HAS_HTONL		/ **/
/*#define HAS_HTONS		/ **/
/*#define HAS_NTOHL		/ **/
/*#define HAS_NTOHS		/ **/

/* HAS_LONG_DOUBLE:
 *	This symbol will be defined if the C compiler supports long
 *	doubles.
 */
/* LONG_DOUBLESIZE:
 *	This symbol contains the size of a long double, so that the
 *	C preprocessor can make decisions based on it.  It is only
 *	defined if the system supports long doubles.  Note that this
 *	is sizeof(long double), which may include unused bytes.
 */
/* HAS_LDEXPL:
 *	This symbol, if defined, indicates that the ldexpl routine is
 *	available to shift a long double floating-point number
 *	by an integral power of 2.
 */
/* LONG_DOUBLEKIND:
 *	LONG_DOUBLEKIND will be one of
 *	LONG_DOUBLE_IS_DOUBLE
 *	LONG_DOUBLE_IS_IEEE_754_128_BIT_LITTLE_ENDIAN
 *	LONG_DOUBLE_IS_IEEE_754_128_BIT_BIG_ENDIAN
 *	LONG_DOUBLE_IS_X86_80_BIT_LITTLE_ENDIAN
 *	LONG_DOUBLE_IS_X86_80_BIT_BIG_ENDIAN
 *	LONG_DOUBLE_IS_DOUBLEDOUBLE_128_BIT_LE_LE
 *	LONG_DOUBLE_IS_DOUBLEDOUBLE_128_BIT_BE_BE
 *	LONG_DOUBLE_IS_DOUBLEDOUBLE_128_BIT_LE_BE
 *	LONG_DOUBLE_IS_DOUBLEDOUBLE_128_BIT_BE_LE
 *	LONG_DOUBLE_IS_UNKNOWN_FORMAT
 *	It is only defined if the system supports long doubles.
 */
/*#define  HAS_LDEXPL		/ **/
/*#define HAS_LONG_DOUBLE		/ **/
#ifdef HAS_LONG_DOUBLE
#define LONG_DOUBLESIZE 8		/**/
#define LONG_DOUBLEKIND 0		/**/
#define LONG_DOUBLE_IS_DOUBLE				0
#define LONG_DOUBLE_IS_IEEE_754_128_BIT_LITTLE_ENDIAN	1
#define LONG_DOUBLE_IS_IEEE_754_128_BIT_BIG_ENDIAN	2
#define LONG_DOUBLE_IS_X86_80_BIT_LITTLE_ENDIAN		3
#define LONG_DOUBLE_IS_X86_80_BIT_BIG_ENDIAN		4
#define LONG_DOUBLE_IS_DOUBLEDOUBLE_128_BIT_LE_LE	5
#define LONG_DOUBLE_IS_DOUBLEDOUBLE_128_BIT_BE_BE	6
#define LONG_DOUBLE_IS_DOUBLEDOUBLE_128_BIT_LE_BE	7
#define LONG_DOUBLE_IS_DOUBLEDOUBLE_128_BIT_BE_LE	8
#define LONG_DOUBLE_IS_UNKNOWN_FORMAT			-1
#define LONG_DOUBLE_IS_DOUBLEDOUBLE_128_BIT_LITTLE_ENDIAN	LONG_DOUBLE_IS_DOUBLEDOUBLE_128_BIT_LE_LE /* back-compat */
#define LONG_DOUBLE_IS_DOUBLEDOUBLE_128_BIT_BIG_ENDIAN	LONG_DOUBLE_IS_DOUBLEDOUBLE_128_BIT_BE_BE /* back-compat */
#endif

/* HAS_LONG_LONG:
 *	This symbol will be defined if the C compiler supports long long.
 */
/* LONGLONGSIZE:
 *	This symbol contains the size of a long long, so that the
 *	C preprocessor can make decisions based on it.  It is only
 *	defined if the system supports long long.
 */
/*#define HAS_LONG_LONG		/ **/
#ifdef HAS_LONG_LONG
#define LONGLONGSIZE 8		/**/
#endif

/* HAS_MEMCHR:
 *	This symbol, if defined, indicates that the memchr routine is available
 *	to locate characters within a C string.
 */
#define HAS_MEMCHR	/**/

/* HAS_MKSTEMP:
 *	This symbol, if defined, indicates that the mkstemp routine is
 *	available to exclusively create and open a uniquely named
 *	temporary file.
 */
/*#define HAS_MKSTEMP		/ **/

/* HAS_MMAP:
 *	This symbol, if defined, indicates that the mmap system call is
 *	available to map a file into memory.
 */
/* Mmap_t:
 *	This symbol holds the return type of the mmap() system call
 *	(and simultaneously the type of the first argument).
 *	Usually set to 'void *' or 'caddr_t'.
 */
/*#define HAS_MMAP		/ **/
#define Mmap_t void *	/**/

/* HAS_MSG:
 *	This symbol, if defined, indicates that the entire msg*(2) library is
 *	supported (IPC mechanism based on message queues).
 */
/*#define HAS_MSG		/ **/

/* HAS_SEM:
 *	This symbol, if defined, indicates that the entire sem*(2) library is
 *	supported.
 */
/*#define HAS_SEM		/ **/

/* HAS_SETGRENT:
 *	This symbol, if defined, indicates that the setgrent routine is
 *	available for initializing sequential access of the group database.
 */
/*#define HAS_SETGRENT		/ **/

/* HAS_SETHOSTENT:
 *	This symbol, if defined, indicates that the sethostent() routine is
 *	available.
 */
/*#define HAS_SETHOSTENT		/ **/

/* HAS_SETNETENT:
 *	This symbol, if defined, indicates that the setnetent() routine is
 *	available.
 */
/*#define HAS_SETNETENT		/ **/

/* HAS_SETPROTOENT:
 *	This symbol, if defined, indicates that the setprotoent() routine is
 *	available.
 */
/*#define HAS_SETPROTOENT		/ **/

/* HAS_SETPGRP:
 *	This symbol, if defined, indicates that the setpgrp routine is
 *	available to set the current process group.
 */
/* USE_BSD_SETPGRP:
 *	This symbol, if defined, indicates that setpgrp needs two
 *	arguments whereas USG one needs none.  See also HAS_SETPGID
 *	for a POSIX interface.
 */
/*#define HAS_SETPGRP		/ **/
/*#define USE_BSD_SETPGRP	/ **/

/* HAS_SETPWENT:
 *	This symbol, if defined, indicates that the setpwent routine is
 *	available for initializing sequential access of the passwd database.
 */
/*#define HAS_SETPWENT		/ **/

/* HAS_SETSERVENT:
 *	This symbol, if defined, indicates that the setservent() routine is
 *	available.
 */
/*#define HAS_SETSERVENT		/ **/

/* HAS_SETVBUF:
 *	This symbol, if defined, indicates that the setvbuf routine is
 *	available to change buffering on an open stdio stream.
 *	to a line-buffered mode.
 */
/*#define HAS_SETVBUF		/ **/

/* HAS_SHM:
 *	This symbol, if defined, indicates that the entire shm*(2) library is
 *	supported.
 */
/*#define HAS_SHM		/ **/

/* Shmat_t:
 *	This symbol holds the return type of the shmat() system call.
 *	Usually set to 'void *' or 'char *'.
 */
/* HAS_SHMAT_PROTOTYPE:
 *	This symbol, if defined, indicates that the sys/shm.h includes
 *	a prototype for shmat().  Otherwise, it is up to the program to
 *	guess one.  Shmat_t shmat(int, Shmat_t, int) is a good guess,
 *	but not always right so it should be emitted by the program only
 *	when HAS_SHMAT_PROTOTYPE is not defined to avoid conflicting defs.
 */
#define Shmat_t void *	/**/
/*#define HAS_SHMAT_PROTOTYPE	/ **/

/* HAS_SOCKET:
 *	This symbol, if defined, indicates that the BSD socket interface is
 *	supported.
 */
/* HAS_SOCKETPAIR:
 *	This symbol, if defined, indicates that the BSD socketpair() call is
 *	supported.
 */
/* HAS_SOCKADDR_SA_LEN:
 *	This symbol, if defined, indicates that the struct sockaddr
 *	structure has a member called sa_len, indicating the length of
 *	the structure.
 */
/* HAS_SOCKADDR_IN6:
 *	This symbol, if defined, indicates the availability of
 *	struct sockaddr_in6;
 */
/* HAS_SIN6_SCOPE_ID:
 *	This symbol, if defined, indicates that the struct sockaddr_in6
 *	structure has a member called sin6_scope_id.
 */
/* HAS_IP_MREQ:
 *	This symbol, if defined, indicates the availability of
 *	struct ip_mreq;
 */
/* HAS_IP_MREQ_SOURCE:
 *	This symbol, if defined, indicates the availability of
 *	struct ip_mreq_source;
 */
/* HAS_IPV6_MREQ:
 *	This symbol, if defined, indicates the availability of
 *	struct ipv6_mreq;
 */
/* HAS_IPV6_MREQ_SOURCE:
 *	This symbol, if defined, indicates the availability of
 *	struct ipv6_mreq_source;
 */
/*#define	HAS_SOCKET		/ **/
/*#define	HAS_SOCKETPAIR	/ **/
/*#define	HAS_SOCKADDR_SA_LEN	/ **/
/*#define	HAS_SOCKADDR_IN6	/ **/
/*#define	HAS_SIN6_SCOPE_ID	/ **/
/*#define	HAS_IP_MREQ	/ **/
/*#define	HAS_IP_MREQ_SOURCE	/ **/
/*#define	HAS_IPV6_MREQ	/ **/
/*#define	HAS_IPV6_MREQ_SOURCE	/ **/

/* USE_STAT_BLOCKS:
 *	This symbol is defined if this system has a stat structure declaring
 *	st_blksize and st_blocks.
 */
#ifndef USE_STAT_BLOCKS
/*#define USE_STAT_BLOCKS 	/ **/
#endif

/* USE_STRUCT_COPY:
 *	This symbol, if defined, indicates that this C compiler knows how
 *	to copy structures.  If undefined, you'll need to use a block copy
 *	routine of some sort instead.
 */
/*#define	USE_STRUCT_COPY	/ **/

/* HAS_STRERROR:
 *	This symbol, if defined, indicates that the strerror routine is
 *	available to translate error numbers to strings. See the writeup
 *	of Strerror() in this file before you try to define your own.
 */
/* HAS_SYS_ERRLIST:
 *	This symbol, if defined, indicates that the sys_errlist array is
 *	available to translate error numbers to strings. The extern int
 *	sys_nerr gives the size of that table.
 */
/* Strerror:
 *	This preprocessor symbol is defined as a macro if strerror() is
 *	not available to translate error numbers to strings but sys_errlist[]
 *	array is there.
 */
/*#define HAS_STRERROR		/ **/
/*#define HAS_SYS_ERRLIST	/ **/
#define Strerror(e) strerror(e)

/* HAS_STRTOUL:
 *	This symbol, if defined, indicates that the strtoul routine is
 *	available to provide conversion of strings to unsigned long.
 */
#define HAS_STRTOUL	/**/

/* HAS_UNION_SEMUN:
 *	This symbol, if defined, indicates that the union semun is
 *	defined by including <sys/sem.h>.  If not, the user code
 *	probably needs to define it as:
 *	union semun {
 *	    int val;
 *	    struct semid_ds *buf;
 *	    unsigned short *array;
 *	}
 */
/* USE_SEMCTL_SEMUN:
 *	This symbol, if defined, indicates that union semun is
 *	used for semctl IPC_STAT.
 */
/* USE_SEMCTL_SEMID_DS:
 *	This symbol, if defined, indicates that struct semid_ds * is
 *	used for semctl IPC_STAT.
 */
/*#define HAS_UNION_SEMUN	/ **/
/*#define USE_SEMCTL_SEMUN	/ **/
/*#define USE_SEMCTL_SEMID_DS	/ **/

/* HAS_VFORK:
 *	This symbol, if defined, indicates that vfork() exists.
 */
/*#define HAS_VFORK	/ **/

/* HAS_PSEUDOFORK:
 *	This symbol, if defined, indicates that an emulation of the
 *	fork routine is available.
 */
/*#define HAS_PSEUDOFORK	/ **/

/* Signal_t:
 *	This symbol's value is either "void" or "int", corresponding to the
 *	appropriate return type of a signal handler.  Thus, you can declare
 *	a signal handler using "Signal_t (*handler)()", and define the
 *	handler using "Signal_t handler(sig)".
 */
#define Signal_t int	/* Signal handler's return type */

/* HASVOLATILE:
 *	This symbol, if defined, indicates that this C compiler knows about
 *	the volatile declaration.
 */
/*#define	HASVOLATILE	/ **/
#ifndef HASVOLATILE
#define volatile
#endif

/* I_DIRENT:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <dirent.h>. Using this symbol also triggers the definition
 *	of the Direntry_t define which ends up being 'struct dirent' or
 *	'struct direct' depending on the availability of <dirent.h>.
 */
/* DIRNAMLEN:
 *	This symbol, if defined, indicates to the C program that the length
 *	of directory entry names is provided by a d_namlen field.  Otherwise
 *	you need to do strlen() on the d_name field.
 */
/* Direntry_t:
 *	This symbol is set to 'struct direct' or 'struct dirent' depending on
 *	whether dirent is available or not. You should use this pseudo type to
 *	portably declare your directory entries.
 */
#define I_DIRENT		/**/
/*#define DIRNAMLEN	/ **/
#define Direntry_t struct dirent

/* I_EXECINFO:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <execinfo.h> for backtrace() support.
 */
/*#define I_EXECINFO		/ **/

/* I_GRP:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <grp.h>.
 */
/* GRPASSWD:
 *	This symbol, if defined, indicates to the C program that struct group
 *	in <grp.h> contains gr_passwd.
 */
/*#define I_GRP		/ **/
/*#define GRPASSWD	/ **/

/* I_NDBM:
 *	This symbol, if defined, indicates that <ndbm.h> exists and should
 *	be included.
 */
/* I_GDBMNDBM:
 *	This symbol, if defined, indicates that <gdbm/ndbm.h> exists and should
 *	be included.  This was the location of the ndbm.h compatibility file
 *	in RedHat 7.1.
 */
/* I_GDBM_NDBM:
 *	This symbol, if defined, indicates that <gdbm-ndbm.h> exists and should
 *	be included.  This is the location of the ndbm.h compatibility file
 *	in Debian 4.0.
 */
/* NDBM_H_USES_PROTOTYPES:
 *	This symbol, if defined, indicates that <ndbm.h> uses real ANSI C
 *	prototypes instead of K&R style function declarations without any
 *	parameter information. While ANSI C prototypes are supported in C++,
 *	K&R style function declarations will yield errors.
 */
/* GDBMNDBM_H_USES_PROTOTYPES:
 *	This symbol, if defined, indicates that <gdbm/ndbm.h> uses real ANSI C
 *	prototypes instead of K&R style function declarations without any
 *	parameter information. While ANSI C prototypes are supported in C++,
 *	K&R style function declarations will yield errors.
 */
/* GDBM_NDBM_H_USES_PROTOTYPES:
 *	This symbol, if defined, indicates that <gdbm-ndbm.h> uses real ANSI C
 *	prototypes instead of K&R style function declarations without any
 *	parameter information. While ANSI C prototypes are supported in C++,
 *	K&R style function declarations will yield errors.
 */
/*#define I_NDBM	/ **/
/*#define I_GDBMNDBM	/ **/
/*#define I_GDBM_NDBM	/ **/
/*#define NDBM_H_USES_PROTOTYPES	/ **/
/*#define GDBMNDBM_H_USES_PROTOTYPES	/ **/
/*#define GDBM_NDBM_H_USES_PROTOTYPES	/ **/

/* I_NETDB:
 *	This symbol, if defined, indicates that <netdb.h> exists and
 *	should be included.
 */
/*#define I_NETDB		/ **/

/* I_NET_ERRNO:
 *	This symbol, if defined, indicates that <net/errno.h> exists and
 *	should be included.
 */
/*#define I_NET_ERRNO		/ **/

/* I_PWD:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <pwd.h>.
 */
/* PWQUOTA:
 *	This symbol, if defined, indicates to the C program that struct passwd
 *	contains pw_quota.
 */
/* PWAGE:
 *	This symbol, if defined, indicates to the C program that struct passwd
 *	contains pw_age.
 */
/* PWCHANGE:
 *	This symbol, if defined, indicates to the C program that struct passwd
 *	contains pw_change.
 */
/* PWCLASS:
 *	This symbol, if defined, indicates to the C program that struct passwd
 *	contains pw_class.
 */
/* PWEXPIRE:
 *	This symbol, if defined, indicates to the C program that struct passwd
 *	contains pw_expire.
 */
/* PWCOMMENT:
 *	This symbol, if defined, indicates to the C program that struct passwd
 *	contains pw_comment.
 */
/* PWGECOS:
 *	This symbol, if defined, indicates to the C program that struct passwd
 *	contains pw_gecos.
 */
/* PWPASSWD:
 *	This symbol, if defined, indicates to the C program that struct passwd
 *	contains pw_passwd.
 */
/*#define I_PWD		/ **/
/*#define PWQUOTA	/ **/
/*#define PWAGE	/ **/
/*#define PWCHANGE	/ **/
/*#define PWCLASS	/ **/
/*#define PWEXPIRE	/ **/
/*#define PWCOMMENT	/ **/
/*#define PWGECOS	/ **/
/*#define PWPASSWD	/ **/

/* I_SYSUIO:
 *	This symbol, if defined, indicates that <sys/uio.h> exists and
 *	should be included.
 */
/*#define	I_SYSUIO		/ **/

/* I_TERMIO:
 *	This symbol, if defined, indicates that the program should include
 *	<termio.h> rather than <sgtty.h>.  There are also differences in
 *	the ioctl() calls that depend on the value of this symbol.
 */
/* I_TERMIOS:
 *	This symbol, if defined, indicates that the program should include
 *	the POSIX termios.h rather than sgtty.h or termio.h.
 *	There are also differences in the ioctl() calls that depend on the
 *	value of this symbol.
 */
/* I_SGTTY:
 *	This symbol, if defined, indicates that the program should include
 *	<sgtty.h> rather than <termio.h>.  There are also differences in
 *	the ioctl() calls that depend on the value of this symbol.
 */
/*#define I_TERMIO		/ **/
/*#define I_TERMIOS		/ **/
/*#define I_SGTTY		/ **/

/* I_STDARG:
 *	This symbol, if defined, indicates that <stdarg.h> exists and should
 *	be included.
 */
/* I_VARARGS:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <varargs.h>.
 */
#define I_STDARG		/**/
/*#define I_VARARGS	/ **/

/* Free_t:
 *	This variable contains the return type of free().  It is usually
 * void, but occasionally int.
 */
/* Malloc_t:
 *	This symbol is the type of pointer returned by malloc and realloc.
 */
#define Malloc_t void *			/**/
#define Free_t void			/**/

/* PERL_MALLOC_WRAP:
 *	This symbol, if defined, indicates that we'd like malloc wrap checks.
 */
/*#define PERL_MALLOC_WRAP		/ **/

/* MYMALLOC:
 *	This symbol, if defined, indicates that we're using our own malloc.
 */
/*#define MYMALLOC			/ **/

/* CAN_PROTOTYPE:
 *	If defined, this macro indicates that the C compiler can handle
 *	function prototypes.
 */
/* _:
 *	This macro is used to declare function parameters for folks who want
 *	to make declarations with prototypes using a different style than
 *	the above macros.  Use double parentheses.  For example:
 *
 *		int main _((int argc, char *argv[]));
 */
/*#define	CAN_PROTOTYPE	/ **/
#ifdef CAN_PROTOTYPE
#define	_(args) args
#else
#define	_(args) ()
#endif

/* SH_PATH:
 *	This symbol contains the full pathname to the shell used on this
 *	on this system to execute Bourne shell scripts.  Usually, this will be
 *	/bin/sh, though it's possible that some systems will have /bin/ksh,
 *	/bin/pdksh, /bin/ash, /bin/bash, or even something such as
 *	D:/bin/sh.exe.
 */
#define SH_PATH "/bin/sh"  /**/

/* SIG_NAME:
 *	This symbol contains a list of signal names in order of
 *	signal number. This is intended
 *	to be used as a static array initialization, like this:
 *		char *sig_name[] = { SIG_NAME };
 *	The signals in the list are separated with commas, and each signal
 *	is surrounded by double quotes. There is no leading SIG in the signal
 *	name, i.e. SIGQUIT is known as "QUIT".
 *	Gaps in the signal numbers (up to NSIG) are filled in with NUMnn,
 *	etc., where nn is the actual signal number (e.g. NUM37).
 *	The signal number for sig_name[i] is stored in sig_num[i].
 *	The last element is 0 to terminate the list with a NULL.  This
 *	corresponds to the 0 at the end of the sig_name_init list.
 *	Note that this variable is initialized from the sig_name_init,
 *	not from sig_name (which is unused).
 */
/* SIG_NUM:
 *	This symbol contains a list of signal numbers, in the same order as the
 *	SIG_NAME list. It is suitable for static array initialization, as in:
 *		int sig_num[] = { SIG_NUM };
 *	The signals in the list are separated with commas, and the indices
 *	within that list and the SIG_NAME list match, so it's easy to compute
 *	the signal name from a number or vice versa at the price of a small
 *	dynamic linear lookup.
 *	Duplicates are allowed, but are moved to the end of the list.
 *	The signal number corresponding to sig_name[i] is sig_number[i].
 *	if (i < NSIG) then sig_number[i] == i.
 *	The last element is 0, corresponding to the 0 at the end of
 *	the sig_name_init list.
 *	Note that this variable is initialized from the sig_num_init,
 *	not from sig_num (which is unused).
 */
/* SIG_SIZE:
 *	This variable contains the number of elements of the SIG_NAME
 *	and SIG_NUM arrays, excluding the final NULL entry.
 */
#define SIG_NAME 0		/**/
#define SIG_NUM  0		/**/
#define SIG_SIZE 1			/**/

/* USE_CROSS_COMPILE:
 *	This symbol, if defined, indicates that Perl is being cross-compiled.
 */
/* PERL_TARGETARCH:
 *	This symbol, if defined, indicates the target architecture
 *	Perl has been cross-compiled to.  Undefined if not a cross-compile.
 */
#ifndef USE_CROSS_COMPILE
/*#define	USE_CROSS_COMPILE	/ **/
#define	PERL_TARGETARCH	""	/**/
#endif

/* PERL_USE_DEVEL:
 *	This symbol, if defined, indicates that Perl was configured with
 *	-Dusedevel, to enable development features.  This should not be
 *	done for production builds.
 */
/*#define	PERL_USE_DEVEL		/ **/

/* HAS_ATOLF:
 *	This symbol, if defined, indicates that the atolf routine is
 *	available to convert strings into long doubles.
 */
/*#define HAS_ATOLF		/ **/

/* HAS_ATOLL:
 *	This symbol, if defined, indicates that the atoll routine is
 *	available to convert strings into long longs.
 */
/*#define HAS_ATOLL		/ **/

/* HAS__FWALK:
 *	This symbol, if defined, indicates that the _fwalk system call is
 *	available to apply a function to all the file handles.
 */
/*#define HAS__FWALK		/ **/

/* HAS_ACOSH:
 *	This symbol, if defined, indicates that the acosh routine is
 *	available to do the inverse hyperbolic cosine function.
 */
/*#define HAS_ACOSH		/ **/

/* HAS_AINTL:
 *	This symbol, if defined, indicates that the aintl routine is
 *	available.  If copysignl is also present we can emulate modfl.
 */
/*#define HAS_AINTL		/ **/

/* HAS_ASINH:
 *	This symbol, if defined, indicates that the asinh routine is
 *	available to do the inverse hyperbolic sine function.
 */
/*#define HAS_ASINH		/ **/

/* HAS_ATANH:
 *	This symbol, if defined, indicates that the atanh routine is
 *	available to do the inverse hyperbolic tangent function.
 */
/*#define HAS_ATANH		/ **/

/* HAS_BUILTIN_CHOOSE_EXPR:
 *	Can we handle GCC builtin for compile-time ternary-like expressions
 */
/* HAS_BUILTIN_EXPECT:
 *	Can we handle GCC builtin for telling that certain values are more
 *	likely
 */
/*#define HAS_BUILTIN_EXPECT	/ **/
/*#define HAS_BUILTIN_CHOOSE_EXPR	/ **/

/* HAS_C99_VARIADIC_MACROS:
 *	If defined, the compiler supports C99 variadic macros.
 */
/*#define	HAS_C99_VARIADIC_MACROS	/ **/

/* HAS_CLASS:
 *	This symbol, if defined, indicates that the class routine is
 *	available to classify doubles.  Available for example in AIX.
 *	The returned values are defined in <float.h> and are:
 *
 *	FP_PLUS_NORM	Positive normalized, nonzero
 *	FP_MINUS_NORM	Negative normalized, nonzero
 *	FP_PLUS_DENORM	Positive denormalized, nonzero
 *	FP_MINUS_DENORM	Negative denormalized, nonzero
 *	FP_PLUS_ZERO	+0.0
 *	FP_MINUS_ZERO	-0.0
 *	FP_PLUS_INF	+INF
 *	FP_MINUS_INF	-INF
 *	FP_NANS		Signaling Not a Number (NaNS)
 *	FP_NANQ		Quiet Not a Number (NaNQ)
 */
/*#define HAS_CLASS		/ **/

/* HAS_CLEARENV:
 *	This symbol, if defined, indicates that the clearenv () routine is
 *	available for use.
 */
/*#define HAS_CLEARENV		/ **/

/* HAS_STRUCT_CMSGHDR:
 *	This symbol, if defined, indicates that the struct cmsghdr
 *	is supported.
 */
/*#define HAS_STRUCT_CMSGHDR	/ **/

/* HAS_COPYSIGN:
 *	This symbol, if defined, indicates that the copysign routine is
 *	available to do the copysign function.
 */
/*#define HAS_COPYSIGN		/ **/

/* HAS_COPYSIGNL:
 *	This symbol, if defined, indicates that the copysignl routine is
 *	available.  If aintl is also present we can emulate modfl.
 */
/*#define HAS_COPYSIGNL		/ **/

/* USE_CPLUSPLUS:
 *	This symbol, if defined, indicates that a C++ compiler was
 *	used to compiled Perl and will be used to compile extensions.
 */
/*#define USE_CPLUSPLUS		/ **/

/* HAS_DBMINIT_PROTO:
 *	This symbol, if defined, indicates that the system provides
 *	a prototype for the dbminit() function.  Otherwise, it is up
 *	to the program to supply one.  A good guess is
 *		extern int dbminit(char *);
 */
/*#define	HAS_DBMINIT_PROTO	/ **/

/* HAS_DIR_DD_FD:
 *	This symbol, if defined, indicates that the the DIR* dirstream
 *	structure contains a member variable named dd_fd.
 */
/*#define HAS_DIR_DD_FD		/ **/

/* HAS_DIRFD:
 *	This manifest constant lets the C program know that dirfd
 *	is available.
 */
/*#define HAS_DIRFD		/ **/

/* DLSYM_NEEDS_UNDERSCORE:
 *	This symbol, if defined, indicates that we need to prepend an
 *	underscore to the symbol name before calling dlsym().  This only
 *	makes sense if you *have* dlsym, which we will presume is the
 *	case if you're using dl_dlopen.xs.
 */
/*#define 	DLSYM_NEEDS_UNDERSCORE 	/ **/

/* HAS_ERF:
 *	This symbol, if defined, indicates that the erf routine is
 *	available to do the error function.
 */
/*#define HAS_ERF		/ **/

/* HAS_ERFC:
 *	This symbol, if defined, indicates that the erfc routine is
 *	available to do the complementary error function.
 */
/*#define HAS_ERFC		/ **/

/* HAS_EXP2:
 *	This symbol, if defined, indicates that the exp2 routine is
 *	available to do the 2**x function.
 */
/*#define HAS_EXP2		/ **/

/* HAS_EXPM1:
 *	This symbol, if defined, indicates that the expm1 routine is
 *	available to do the exp(x) - 1 when x is near 1 function.
 */
/*#define HAS_EXPM1		/ **/

/* HAS_FAST_STDIO:
 *	This symbol, if defined, indicates that the "fast stdio"
 *	is available to manipulate the stdio buffers directly.
 */
/*#define HAS_FAST_STDIO		/ **/

/* HAS_FCHDIR:
 *	This symbol, if defined, indicates that the fchdir routine is
 *	available to change directory using a file descriptor.
 */
/*#define HAS_FCHDIR		/ **/

/* FCNTL_CAN_LOCK:
 *	This symbol, if defined, indicates that fcntl() can be used
 *	for file locking.  Normally on Unix systems this is defined.
 *	It may be undefined on VMS.
 */
/*#define FCNTL_CAN_LOCK		/ **/

/* HAS_FDCLOSE:
 *	This symbol, if defined, indicates that the fdclose routine is
 *	available to free a FILE structure without closing the underlying
 *	file descriptor.  This function appeared in FreeBSD 10.2.
 */
/*#define HAS_FDCLOSE		/ **/

/* HAS_FDIM:
 *	This symbol, if defined, indicates that the fdim routine is
 *	available to do the positive difference function.
 */
/*#define HAS_FDIM		/ **/

/* HAS_FEGETROUND:
 *	This symbol, if defined, indicates that the fegetround routine is
 *	available to return the macro corresponding to the current rounding
 *	mode.
 */
/*#define HAS_FEGETROUND	/ **/

/* HAS_FINITE:
 *	This symbol, if defined, indicates that the finite routine is
 *	available to check whether a double is finite (non-infinity non-NaN).
 */
/*#define HAS_FINITE		/ **/

/* HAS_FINITEL:
 *	This symbol, if defined, indicates that the finitel routine is
 *	available to check whether a long double is finite
 *	(non-infinity non-NaN).
 */
/*#define HAS_FINITEL		/ **/

/* HAS_FLOCK_PROTO:
 *	This symbol, if defined, indicates that the system provides
 *	a prototype for the flock() function.  Otherwise, it is up
 *	to the program to supply one.  A good guess is
 *		extern int flock(int, int);
 */
/*#define	HAS_FLOCK_PROTO	/ **/

/* HAS_FMA:
 *	This symbol, if defined, indicates that the fma routine is
 *	available to do the multiply-add function.
 */
/*#define HAS_FMA		/ **/

/* HAS_FMAX:
 *	This symbol, if defined, indicates that the fmax routine is
 *	available to do the maximum function.
 */
/*#define HAS_FMAX		/ **/

/* HAS_FMIN:
 *	This symbol, if defined, indicates that the fmin routine is
 *	available to do the minimum function.
 */
/*#define HAS_FMIN		/ **/

/* HAS_FP_CLASS:
 *	This symbol, if defined, indicates that the fp_class routine is
 *	available to classify doubles.  Available for example in Digital UNIX.
 *	The returned values are defined in <math.h> and are:
 *
 *	FP_SNAN           Signaling NaN (Not-a-Number)
 *	FP_QNAN           Quiet NaN (Not-a-Number)
 *	FP_POS_INF        +infinity
 *	FP_NEG_INF        -infinity
 *	FP_POS_NORM       Positive normalized
 *	FP_NEG_NORM       Negative normalized
 *	FP_POS_DENORM     Positive denormalized
 *	FP_NEG_DENORM     Negative denormalized
 *	FP_POS_ZERO       +0.0 (positive zero)
 *	FP_NEG_ZERO       -0.0 (negative zero)
 */
/*#define HAS_FP_CLASS		/ **/

/* HAS_FP_CLASSL:
 *	This symbol, if defined, indicates that the fp_classl routine is
 *	available to classify long doubles.  Available for example in
 *	Digital UNIX.  See for possible values HAS_FP_CLASS.
 */
/*#define HAS_FP_CLASSL		/ **/

/* HAS_FPCLASS:
 *	This symbol, if defined, indicates that the fpclass routine is
 *	available to classify doubles.  Available for example in Solaris/SVR4.
 *	The returned values are defined in <ieeefp.h> and are:
 *
 *	FP_SNAN		signaling NaN
 *	FP_QNAN		quiet NaN
 *	FP_NINF		negative infinity
 *	FP_PINF		positive infinity
 *	FP_NDENORM	negative denormalized non-zero
 *	FP_PDENORM	positive denormalized non-zero
 *	FP_NZERO	negative zero
 *	FP_PZERO	positive zero
 *	FP_NNORM	negative normalized non-zero
 *	FP_PNORM	positive normalized non-zero
 */
/*#define HAS_FPCLASS		/ **/

/* HAS_FPCLASSIFY:
 *	This symbol, if defined, indicates that the fpclassify routine is
 *	available to classify doubles.  Available for example in HP-UX.
 *	The returned values are defined in <math.h> and are
 *
 *           FP_NORMAL     Normalized
 *           FP_ZERO       Zero
 *           FP_INFINITE   Infinity
 *           FP_SUBNORMAL  Denormalized
 *           FP_NAN        NaN
 *
 */
/* HAS_FP_CLASSIFY:
 *	This symbol, if defined, indicates that the fp_classify routine is
 *	available to classify doubles. The values are defined in <math.h>
 *
 *           FP_NORMAL     Normalized
 *           FP_ZERO       Zero
 *           FP_INFINITE   Infinity
 *           FP_SUBNORMAL  Denormalized
 *           FP_NAN        NaN
 *
 */
/*#define	HAS_FPCLASSIFY		/ **/
/*#define	HAS_FP_CLASSIFY		/ **/

/* HAS_FPCLASSL:
 *	This symbol, if defined, indicates that the fpclassl routine is
 *	available to classify long doubles.  Available for example in IRIX.
 *	The returned values are defined in <ieeefp.h> and are:
 *
 *	FP_SNAN		signaling NaN
 *	FP_QNAN		quiet NaN
 *	FP_NINF		negative infinity
 *	FP_PINF		positive infinity
 *	FP_NDENORM	negative denormalized non-zero
 *	FP_PDENORM	positive denormalized non-zero
 *	FP_NZERO	negative zero
 *	FP_PZERO	positive zero
 *	FP_NNORM	negative normalized non-zero
 *	FP_PNORM	positive normalized non-zero
 */
/*#define HAS_FPCLASSL		/ **/

/* HAS_FPGETROUND:
 *	This symbol, if defined, indicates that the fpgetround routine is
 *	available to get the floating point rounding mode.
 */
/*#define HAS_FPGETROUND		/ **/

/* HAS_FPOS64_T:
 *	This symbol will be defined if the C compiler supports fpos64_t.
 */
/*#define	HAS_FPOS64_T    	/ **/

/* HAS_FREXPL:
 *	This symbol, if defined, indicates that the frexpl routine is
 *	available to break a long double floating-point number into
 *	a normalized fraction and an integral power of 2.
 */
/*#define HAS_FREXPL		/ **/

/* HAS_STRUCT_FS_DATA:
 *	This symbol, if defined, indicates that the struct fs_data
 *	to do statfs() is supported.
 */
/*#define HAS_STRUCT_FS_DATA	/ **/

/* HAS_FSEEKO:
 *	This symbol, if defined, indicates that the fseeko routine is
 *	available to fseek beyond 32 bits (useful for ILP32 hosts).
 */
/*#define HAS_FSEEKO		/ **/

/* HAS_FSTATFS:
 *	This symbol, if defined, indicates that the fstatfs routine is
 *	available to stat filesystems by file descriptors.
 */
/*#define HAS_FSTATFS		/ **/

/* HAS_FSYNC:
 *	This symbol, if defined, indicates that the fsync routine is
 *	available to write a file's modified data and attributes to
 *	permanent storage.
 */
/*#define HAS_FSYNC		/ **/

/* HAS_FTELLO:
 *	This symbol, if defined, indicates that the ftello routine is
 *	available to ftell beyond 32 bits (useful for ILP32 hosts).
 */
/*#define HAS_FTELLO		/ **/

/* HAS_FUTIMES:
 *	This symbol, if defined, indicates that the futimes routine is
 *	available to change file descriptor time stamps with struct timevals.
 */
/*#define HAS_FUTIMES		/ **/

/* HAS_GETADDRINFO:
 *	This symbol, if defined, indicates that the getaddrinfo() function
 *	is available for use.
 */
/*#define HAS_GETADDRINFO		/ **/

/* HAS_GETCWD:
 *	This symbol, if defined, indicates that the getcwd routine is
 *	available to get the current working directory.
 */
/*#define HAS_GETCWD		/ **/

/* HAS_GETESPWNAM:
 *	This symbol, if defined, indicates that the getespwnam system call is
 *	available to retrieve enhanced (shadow) password entries by name.
 */
/*#define HAS_GETESPWNAM		/ **/

/* HAS_GETFSSTAT:
 *	This symbol, if defined, indicates that the getfsstat routine is
 *	available to stat filesystems in bulk.
 */
/*#define HAS_GETFSSTAT		/ **/

/* HAS_GETITIMER:
 *	This symbol, if defined, indicates that the getitimer routine is
 *	available to return interval timers.
 */
/*#define HAS_GETITIMER		/ **/

/* HAS_GETMNT:
 *	This symbol, if defined, indicates that the getmnt routine is
 *	available to get filesystem mount info by filename.
 */
/*#define HAS_GETMNT		/ **/

/* HAS_GETMNTENT:
 *	This symbol, if defined, indicates that the getmntent routine is
 *	available to iterate through mounted file systems to get their info.
 */
/*#define HAS_GETMNTENT		/ **/

/* HAS_GETNAMEINFO:
 *	This symbol, if defined, indicates that the getnameinfo() function
 *	is available for use.
 */
/*#define HAS_GETNAMEINFO		/ **/

/* HAS_GETPRPWNAM:
 *	This symbol, if defined, indicates that the getprpwnam system call is
 *	available to retrieve protected (shadow) password entries by name.
 */
/*#define HAS_GETPRPWNAM		/ **/

/* HAS_GETSPNAM:
 *	This symbol, if defined, indicates that the getspnam system call is
 *	available to retrieve SysV shadow password entries by name.
 */
/*#define HAS_GETSPNAM		/ **/

/* HAS_HASMNTOPT:
 *	This symbol, if defined, indicates that the hasmntopt routine is
 *	available to query the mount options of file systems.
 */
/*#define HAS_HASMNTOPT		/ **/

/* HAS_HYPOT:
 *	This symbol, if defined, indicates that the hypot routine is
 *	available to do the hypotenuse function.
 */
/*#define HAS_HYPOT		/ **/

/* HAS_ILOGB:
 *	This symbol, if defined, indicates that the ilogb routine is
 *	available to get integer exponent of a floating-point value.
 */
/*#define HAS_ILOGB		/ **/

/* HAS_ILOGBL:
 *	This symbol, if defined, indicates that the ilogbl routine is
 *	available.  If scalbnl is also present we can emulate frexpl.
 */
/*#define HAS_ILOGBL		/ **/

/* HAS_INETNTOP:
 *	This symbol, if defined, indicates that the inet_ntop() function
 *	is available to parse IPv4 and IPv6 strings.
 */
/*#define HAS_INETNTOP		/ **/

/* HAS_INETPTON:
 *	This symbol, if defined, indicates that the inet_pton() function
 *	is available to parse IPv4 and IPv6 strings.
 */
/*#define HAS_INETPTON		/ **/

/* HAS_INT64_T:
 *     This symbol will defined if the C compiler supports int64_t.
 *     Usually the <inttypes.h> needs to be included, but sometimes
 *	<sys/types.h> is enough.
 */
/*#define     HAS_INT64_T               / **/

/* HAS_ISBLANK:
 *	This manifest constant lets the C program know that isblank
 *	is available.
 */
/*#define HAS_ISBLANK		/ **/

/* HAS_ISFINITE:
 *	This symbol, if defined, indicates that the isfinite routine is
 *	available to check whether a double is finite (non-infinity non-NaN).
 */
/*#define HAS_ISFINITE		/ **/

/* HAS_ISFINITEL:
 *	This symbol, if defined, indicates that the isfinitel routine is
 *	available to check whether a long double is finite.
 *	(non-infinity non-NaN).
 */
/*#define HAS_ISFINITEL		/ **/

/* HAS_ISINF:
 *	This symbol, if defined, indicates that the isinf routine is
 *	available to check whether a double is an infinity.
 */
/*#define HAS_ISINF		/ **/

/* HAS_ISINFL:
 *	This symbol, if defined, indicates that the isinfl routine is
 *	available to check whether a long double is an infinity.
 */
/*#define HAS_ISINFL		/ **/

/* HAS_ISLESS:
 *	This symbol, if defined, indicates that the isless routine is
 *	available to do the isless function.
 */
/*#define HAS_ISLESS		/ **/

/* HAS_ISNAN:
 *	This symbol, if defined, indicates that the isnan routine is
 *	available to check whether a double is a NaN.
 */
/*#define HAS_ISNAN		/ **/

/* HAS_ISNANL:
 *	This symbol, if defined, indicates that the isnanl routine is
 *	available to check whether a long double is a NaN.
 */
/*#define HAS_ISNANL		/ **/

/* HAS_ISNORMAL:
 *	This symbol, if defined, indicates that the isnormal routine is
 *	available to check whether a double is normal (non-zero normalized).
 */
/*#define HAS_ISNORMAL		/ **/

/* HAS_J0:
 *	This symbol, if defined, indicates to the C program that the
 *	j0() function is available for Bessel functions of the first
 *	kind of the order zero, for doubles.
 */
/* HAS_J0L:
 *	This symbol, if defined, indicates to the C program that the
 *	j0l() function is available for Bessel functions of the first
 *	kind of the order zero, for long doubles.
 */
/*#define	HAS_J0		/ **/
/*#define	HAS_J0L		/ **/

/* HAS_LC_MONETARY_2008:
 *	This symbol, if defined, indicates that the localeconv routine is
 *	available and has the additional members added in POSIX 1003.1-2008.
 */
/*#define HAS_LC_MONETARY_2008		/ **/

/* HAS_LDBL_DIG:
 *	This symbol, if defined, indicates that this system's <float.h>
 *	or <limits.h> defines the symbol LDBL_DIG, which is the number
 *	of significant digits in a long double precision number. Unlike
 *	for DBL_DIG, there's no good guess for LDBL_DIG if it is undefined.
 */
/*#define HAS_LDBL_DIG 	/ * */

/* HAS_LGAMMA:
 *	This symbol, if defined, indicates that the lgamma routine is
 *	available to do the log gamma function.  See also HAS_TGAMMA and
 *	HAS_LGAMMA_R.
 */
/*#define HAS_LGAMMA		/ **/

/* HAS_LGAMMA_R:
 *	This symbol, if defined, indicates that the lgamma_r routine is
 *	available to do the log gamma function without using the global
 *	signgam variable.
 */
/*#define HAS_LGAMMA_R		/ **/

/* LIBM_LIB_VERSION:
 *	This symbol, if defined, indicates that libm exports _LIB_VERSION
 *	and that math.h defines the enum to manipulate it.
 */
/*#define LIBM_LIB_VERSION		/ **/

/* HAS_LLRINT:
 *	This symbol, if defined, indicates that the llrint routine is
 *	available to return the long long value closest to a double
 *	(according to the current rounding mode).
 */
/*#define HAS_LLRINT		/ **/

/* HAS_LLRINTL:
 *	This symbol, if defined, indicates that the llrintl routine is
 *	available to return the long long value closest to a long double
 *	(according to the current rounding mode).
 */
/*#define HAS_LLRINTL		/ **/

/* HAS_LLROUND:
 *	This symbol, if defined, indicates that the llround routine is
 *	available to return the nearest long long value.
 */
/*#define HAS_LLROUND		/ **/

/* HAS_LLROUNDL:
 *	This symbol, if defined, indicates that the llroundl routine is
 *	available to return the nearest long long value away from zero of
 *	the long double argument value.
 */
/*#define HAS_LLROUNDL		/ **/

/* HAS_LOG1P:
 *	This symbol, if defined, indicates that the log1p routine is
 *	available to do the logarithm of 1 plus argument function.
 */
/*#define HAS_LOG1P		/ **/

/* HAS_LOG2:
 *	This symbol, if defined, indicates that the log2 routine is
 *	available to do the log2 function.
 */
/*#define HAS_LOG2		/ **/

/* HAS_LOGB:
 *	This symbol, if defined, indicates that the logb routine is
 *	available to do the logb function.
 */
/*#define HAS_LOGB		/ **/

/* HAS_LRINT:
 *	This symbol, if defined, indicates that the lrint routine is
 *	available to return the integral value closest to a double
 *	(according to the current rounding mode).
 */
/*#define HAS_LRINT		/ **/

/* HAS_LRINTL:
 *	This symbol, if defined, indicates that the lrintl routine is
 *	available to return the integral value closest to a long double
 *	(according to the current rounding mode).
 */
/*#define HAS_LRINTL		/ **/

/* HAS_LROUND:
 *	This symbol, if defined, indicates that the lround routine is
 *	available to return the nearest integral value.
 */
/*#define HAS_LROUND		/ **/

/* HAS_LROUNDL:
 *	This symbol, if defined, indicates that the lroundl routine is
 *	available to return the nearest integral value away from zero of
 *	the long double argument value.
 */
/*#define HAS_LROUNDL		/ **/

/* HAS_MADVISE:
 *	This symbol, if defined, indicates that the madvise system call is
 *	available to map a file into memory.
 */
/*#define HAS_MADVISE		/ **/

/* HAS_MALLOC_SIZE:
 *	This symbol, if defined, indicates that the malloc_size
 *	routine is available for use.
 */
/*#define HAS_MALLOC_SIZE		/ **/

/* HAS_MALLOC_GOOD_SIZE:
 *	This symbol, if defined, indicates that the malloc_good_size
 *	routine is available for use.
 */
/*#define HAS_MALLOC_GOOD_SIZE	/ **/

/* HAS_MEMMEM:
 *	This symbol, if defined, indicates that the memmem routine is
 *	available to return a pointer to the start of the first occurance
 *	of a substring in a memory area (or NULL if not found).
 */
/*#define HAS_MEMMEM		/ **/

/* HAS_MKDTEMP:
 *	This symbol, if defined, indicates that the mkdtemp routine is
 *	available to exclusively create a uniquely named temporary directory.
 */
/*#define HAS_MKDTEMP		/ **/

/* HAS_MKSTEMPS:
 *	This symbol, if defined, indicates that the mkstemps routine is
 *	available to exclusively create and open a uniquely named
 *	(with a suffix) temporary file.
 */
/*#define HAS_MKSTEMPS		/ **/

/* HAS_MODFL:
 *	This symbol, if defined, indicates that the modfl routine is
 *	available to split a long double x into a fractional part f and
 *	an integer part i such that |f| < 1.0 and (f + i) = x.
 */
/* HAS_MODFL_PROTO:
 *	This symbol, if defined, indicates that the system provides
 *	a prototype for the modfl() function.  Otherwise, it is up
 *	to the program to supply one.
 */
/*#define HAS_MODFL		/ **/
/*#define HAS_MODFL_PROTO		/ **/

/* HAS_MPROTECT:
 *	This symbol, if defined, indicates that the mprotect system call is
 *	available to modify the access protection of a memory mapped file.
 */
/*#define HAS_MPROTECT		/ **/

/* HAS_STRUCT_MSGHDR:
 *	This symbol, if defined, indicates that the struct msghdr
 *	is supported.
 */
/*#define HAS_STRUCT_MSGHDR	/ **/

/* HAS_NAN:
 *	This symbol, if defined, indicates that the nan routine is
 *	available to generate NaN.
 */
/*#define HAS_NAN		/ **/

/* HAS_NEARBYINT:
 *	This symbol, if defined, indicates that the nearbyint routine is
 *	available to return the integral value closest to (according to
 *	the current rounding mode) to x.
 */
/*#define HAS_NEARBYINT		/ **/

/* HAS_NEWLOCALE:
 *	This symbol, if defined, indicates that the newlocale routine is
 *	available to return a new locale object or modify an existing
 *	locale object.
 */
/* HAS_FREELOCALE:
 *	This symbol, if defined, indicates that the freelocale routine is
 *	available to deallocates the resources associated with a locale object.
 */
/* HAS_USELOCALE:
 *	This symbol, if defined, indicates that the uselocale routine is
 *	available to set the current locale for the calling thread.
 */
/*#define	HAS_NEWLOCALE	/ **/
/*#define	HAS_FREELOCALE	/ **/
/*#define	HAS_USELOCALE	/ **/

/* HAS_NEXTAFTER:
 *	This symbol, if defined, indicates that the nextafter routine is
 *	available to return the next machine representable double from
 *	x in direction y.
 */
/*#define HAS_NEXTAFTER		/ **/

/* HAS_NEXTTOWARD:
 *	This symbol, if defined, indicates that the nexttoward routine is
 *	available to return the next machine representable long double from
 *	x in direction y.
 */
/*#define HAS_NEXTTOWARD		/ **/

/* HAS_NL_LANGINFO:
 *	This symbol, if defined, indicates that the nl_langinfo routine is
 *	available to return local data.  You will also need <langinfo.h>
 *	and therefore I_LANGINFO.
 */
/*#define HAS_NL_LANGINFO		/ **/

/* HAS_OFF64_T:
 *	This symbol will be defined if the C compiler supports off64_t.
 */
/*#define	HAS_OFF64_T    		/ **/

/* HAS_PRCTL:
 *	This symbol, if defined, indicates that the prctl routine is
 *	available to set process title.
 *	Note that there are at least two prctl variants: Linux and Irix.
 *	While they are somewhat similar, they are incompatible.
 */
/* HAS_PRCTL_SET_NAME:
 *	This symbol, if defined, indicates that the prctl routine is
 *	available to set process title and supports PR_SET_NAME.
 */
/*#define HAS_PRCTL		/ **/
/*#define HAS_PRCTL_SET_NAME		/ **/

/* HAS_PROCSELFEXE:
 *	This symbol is defined if PROCSELFEXE_PATH is a symlink
 *	to the absolute pathname of the executing program.
 */
/* PROCSELFEXE_PATH:
 *	If HAS_PROCSELFEXE is defined this symbol is the filename
 *	of the symbolic link pointing to the absolute pathname of
 *	the executing program.
 */
/*#define HAS_PROCSELFEXE	/ **/
#if defined(HAS_PROCSELFEXE) && !defined(PROCSELFEXE_PATH)
#define PROCSELFEXE_PATH		/**/
#endif

/* HAS_PTHREAD_ATTR_SETSCOPE:
 *	This symbol, if defined, indicates that the pthread_attr_setscope
 *	system call is available to set the contention scope attribute of
 *	a thread attribute object.
 */
/*#define HAS_PTHREAD_ATTR_SETSCOPE		/ **/

/* HAS_PTRDIFF_T:
 *	This symbol will be defined if the C compiler supports ptrdiff_t.
 */
#define	HAS_PTRDIFF_T    		/**/

/* HAS_READV:
 *	This symbol, if defined, indicates that the readv routine is
 *	available to do gather reads.  You will also need <sys/uio.h>
 *	and there I_SYSUIO.
 */
/*#define HAS_READV		/ **/

/* HAS_RECVMSG:
 *	This symbol, if defined, indicates that the recvmsg routine is
 *	available to send structured socket messages.
 */
/*#define HAS_RECVMSG		/ **/

/* HAS_REMAINDER:
 *	This symbol, if defined, indicates that the remainder routine is
 *	available to return the floating-point remainder.
 */
/*#define HAS_REMAINDER		/ **/

/* HAS_REMQUO:
 *	This symbol, if defined, indicates that the remquo routine is
 *	available to return the remainder and part of quotient.
 */
/*#define HAS_REMQUO		/ **/

/* HAS_RINT:
 *	This symbol, if defined, indicates that the rint routine is
 *	available to return the nearest integral value to x as double
 *	using the current rounding mode.
 */
/*#define HAS_RINT		/ **/

/* HAS_ROUND:
 *	This symbol, if defined, indicates that the round routine is
 *	available to round to nearest integer, away from zero.
 */
/*#define HAS_ROUND		/ **/

/* HAS_SBRK_PROTO:
 *	This symbol, if defined, indicates that the system provides
 *	a prototype for the sbrk() function.  Otherwise, it is up
 *	to the program to supply one.  Good guesses are
 *		extern void* sbrk(int);
 *		extern void* sbrk(size_t);
 */
/*#define	HAS_SBRK_PROTO	/ **/

/* HAS_SCALBN:
 *	This symbol, if defined, indicates that the scalbn routine is
 *	available to multiply floating-point number by integral power
 *	of radix.
 */
/*#define HAS_SCALBN		/ **/

/* HAS_SCALBNL:
 *	This symbol, if defined, indicates that the scalbnl routine is
 *	available.  If ilogbl is also present we can emulate frexpl.
 */
/*#define HAS_SCALBNL		/ **/

/* HAS_SENDMSG:
 *	This symbol, if defined, indicates that the sendmsg routine is
 *	available to send structured socket messages.
 */
/*#define HAS_SENDMSG		/ **/

/* HAS_SETITIMER:
 *	This symbol, if defined, indicates that the setitimer routine is
 *	available to set interval timers.
 */
/*#define HAS_SETITIMER		/ **/

/* HAS_SETPROCTITLE:
 *	This symbol, if defined, indicates that the setproctitle routine is
 *	available to set process title.
 */
/*#define HAS_SETPROCTITLE		/ **/

/* HAS_SIGNBIT:
 *	This symbol, if defined, indicates that the signbit routine is
 *	available to check if the given number has the sign bit set.
 *	This should include correct testing of -0.0.  This will only be set
 *	if the signbit() routine is safe to use with the NV type used internally
 *	in perl.  Users should call Perl_signbit(), which will be #defined to
 *	the system's signbit() function or macro if this symbol is defined.
 */
/*#define HAS_SIGNBIT		/ **/

/* HAS_SIGPROCMASK:
 *	This symbol, if defined, indicates that the sigprocmask
 *	system call is available to examine or change the signal mask
 *	of the calling process.
 */
/*#define HAS_SIGPROCMASK		/ **/

/* USE_SITECUSTOMIZE:
 *	This symbol, if defined, indicates that sitecustomize should
 *	be used.
 */
#ifndef USE_SITECUSTOMIZE
/*#define	USE_SITECUSTOMIZE		/ **/
#endif

/* HAS_SNPRINTF:
 *	This symbol, if defined, indicates that the snprintf () library
 *	function is available for use.
 */
/* HAS_VSNPRINTF:
 *	This symbol, if defined, indicates that the vsnprintf () library
 *	function is available for use.
 */
/*#define HAS_SNPRINTF	/ **/
/*#define HAS_VSNPRINTF	/ **/

/* HAS_SOCKATMARK:
 *	This symbol, if defined, indicates that the sockatmark routine is
 *	available to test whether a socket is at the out-of-band mark.
 */
/*#define HAS_SOCKATMARK		/ **/

/* HAS_SOCKATMARK_PROTO:
 *	This symbol, if defined, indicates that the system provides
 *	a prototype for the sockatmark() function.  Otherwise, it is up
 *	to the program to supply one.  A good guess is
 *		extern int sockatmark(int);
 */
/*#define	HAS_SOCKATMARK_PROTO	/ **/

/* HAS_SOCKS5_INIT:
 *	This symbol, if defined, indicates that the socks5_init routine is
 *	available to initialize SOCKS 5.
 */
/*#define HAS_SOCKS5_INIT		/ **/

/* SPRINTF_RETURNS_STRLEN:
 *	This variable defines whether sprintf returns the length of the string
 *	(as per the ANSI spec). Some C libraries retain compatibility with
 *	pre-ANSI C and return a pointer to the passed in buffer; for these
 *	this variable will be undef.
 */
/*#define SPRINTF_RETURNS_STRLEN	/ **/

/* HAS_SQRTL:
 *	This symbol, if defined, indicates that the sqrtl routine is
 *	available to do long double square roots.
 */
/*#define HAS_SQRTL		/ **/

/* HAS_SETRESGID_PROTO:
 *	This symbol, if defined, indicates that the system provides
 *	a prototype for the setresgid() function.  Otherwise, it is up
 *	to the program to supply one.  Good guesses are
 *		extern int setresgid(uid_t ruid, uid_t euid, uid_t suid);
 */
/*#define	HAS_SETRESGID_PROTO	/ **/

/* HAS_SETRESUID_PROTO:
 *	This symbol, if defined, indicates that the system provides
 *	a prototype for the setresuid() function.  Otherwise, it is up
 *	to the program to supply one.  Good guesses are
 *		extern int setresuid(uid_t ruid, uid_t euid, uid_t suid);
 */
/*#define	HAS_SETRESUID_PROTO	/ **/

/* HAS_STRUCT_STATFS_F_FLAGS:
 *	This symbol, if defined, indicates that the struct statfs
 *	does have the f_flags member containing the mount flags of
 *	the filesystem containing the file.
 *	This kind of struct statfs is coming from <sys/mount.h> (BSD 4.3),
 *	not from <sys/statfs.h> (SYSV).  Older BSDs (like Ultrix) do not
 *	have statfs() and struct statfs, they have ustat() and getmnt()
 *	with struct ustat and struct fs_data.
 */
/*#define HAS_STRUCT_STATFS_F_FLAGS		/ **/

/* HAS_STRUCT_STATFS:
 *	This symbol, if defined, indicates that the struct statfs
 *	to do statfs() is supported.
 */
/*#define HAS_STRUCT_STATFS	/ **/

/* HAS_FSTATVFS:
 *	This symbol, if defined, indicates that the fstatvfs routine is
 *	available to stat filesystems by file descriptors.
 */
/*#define HAS_FSTATVFS		/ **/

/* HAS_STRFTIME:
 *	This symbol, if defined, indicates that the strftime routine is
 *	available to do time formatting.
 */
/*#define HAS_STRFTIME		/ **/

/* HAS_STRLCAT:
 *	This symbol, if defined, indicates that the strlcat () routine is
 *	available to do string concatenation.
 */
/*#define HAS_STRLCAT		/ **/

/* HAS_STRLCPY:
 *	This symbol, if defined, indicates that the strlcpy () routine is
 *	available to do string copying.
 */
/*#define HAS_STRLCPY		/ **/

/* HAS_STRTOLD:
 *	This symbol, if defined, indicates that the strtold routine is
 *	available to convert strings to long doubles.
 */
/*#define HAS_STRTOLD		/ **/

/* HAS_STRTOLL:
 *	This symbol, if defined, indicates that the strtoll routine is
 *	available to convert strings to long longs.
 */
/*#define HAS_STRTOLL		/ **/

/* HAS_STRTOQ:
 *	This symbol, if defined, indicates that the strtoq routine is
 *	available to convert strings to long longs (quads).
 */
/*#define HAS_STRTOQ		/ **/

/* HAS_STRTOULL:
 *	This symbol, if defined, indicates that the strtoull routine is
 *	available to convert strings to unsigned long longs.
 */
/*#define HAS_STRTOULL		/ **/

/* HAS_STRTOUQ:
 *	This symbol, if defined, indicates that the strtouq routine is
 *	available to convert strings to unsigned long longs (quads).
 */
/*#define HAS_STRTOUQ		/ **/

/* HAS_SYSCALL_PROTO:
 *	This symbol, if defined, indicates that the system provides
 *	a prototype for the syscall() function.  Otherwise, it is up
 *	to the program to supply one.  Good guesses are
 *		extern int syscall(int,  ...);
 *		extern int syscall(long, ...);
 */
/*#define	HAS_SYSCALL_PROTO	/ **/

/* HAS_TELLDIR_PROTO:
 *	This symbol, if defined, indicates that the system provides
 *	a prototype for the telldir() function.  Otherwise, it is up
 *	to the program to supply one.  A good guess is
 *		extern long telldir(DIR*);
 */
/*#define	HAS_TELLDIR_PROTO	/ **/

/* HAS_TGAMMA:
 *	This symbol, if defined, indicates that the tgamma routine is
 *	available to do the gamma function. See also HAS_LGAMMA.
 */
/*#define HAS_TGAMMA		/ **/

/* HAS_CTIME64:
 *	This symbol, if defined, indicates that the ctime64 () routine is
 *	available to do the 64bit variant of ctime ()
 */
/* HAS_LOCALTIME64:
 *	This symbol, if defined, indicates that the localtime64 () routine is
 *	available to do the 64bit variant of localtime ()
 */
/* HAS_GMTIME64:
 *	This symbol, if defined, indicates that the gmtime64 () routine is
 *	available to do the 64bit variant of gmtime ()
 */
/* HAS_MKTIME64:
 *	This symbol, if defined, indicates that the mktime64 () routine is
 *	available to do the 64bit variant of mktime ()
 */
/* HAS_DIFFTIME64:
 *	This symbol, if defined, indicates that the difftime64 () routine is
 *	available to do the 64bit variant of difftime ()
 */
/* HAS_ASCTIME64:
 *	This symbol, if defined, indicates that the asctime64 () routine is
 *	available to do the 64bit variant of asctime ()
 */
/*#define	HAS_CTIME64		/ **/
/*#define	HAS_LOCALTIME64		/ **/
/*#define	HAS_GMTIME64		/ **/
/*#define	HAS_MKTIME64		/ **/
/*#define	HAS_DIFFTIME64		/ **/
/*#define	HAS_ASCTIME64		/ **/

/* HAS_TIMEGM:
 *	This symbol, if defined, indicates that the timegm routine is
 *	available to do the opposite of gmtime ()
 */
/*#define HAS_TIMEGM		/ **/

/* HAS_TRUNC:
 *	This symbol, if defined, indicates that the trunc routine is
 *	available to round doubles towards zero.
 */
/*#define HAS_TRUNC		/ **/

/* HAS_TRUNCL:
 *	This symbol, if defined, indicates that the truncl routine is
 *	available. If copysignl is also present we can emulate modfl.
 */
/*#define HAS_TRUNCL		/ **/

/* U32_ALIGNMENT_REQUIRED:
 *	This symbol, if defined, indicates that you must access
 *	character data through U32-aligned pointers.
 */
#ifndef U32_ALIGNMENT_REQUIRED
#define U32_ALIGNMENT_REQUIRED	/**/
#endif

/* HAS_UALARM:
 *	This symbol, if defined, indicates that the ualarm routine is
 *	available to do alarms with microsecond granularity.
 */
/*#define HAS_UALARM		/ **/

/* HAS_UNORDERED:
 *	This symbol, if defined, indicates that the unordered routine is
 *	available to check whether two doubles are unordered
 *	(effectively: whether either of them is NaN)
 */
/*#define HAS_UNORDERED		/ **/

/* HAS_UNSETENV:
 *	This symbol, if defined, indicates that the unsetenv () routine is
 *	available for use.
 */
/*#define HAS_UNSETENV		/ **/

/* HAS_USLEEP_PROTO:
 *	This symbol, if defined, indicates that the system provides
 *	a prototype for the usleep() function.  Otherwise, it is up
 *	to the program to supply one.  A good guess is
 *		extern int usleep(useconds_t);
 */
/*#define	HAS_USLEEP_PROTO	/ **/

/* HAS_USTAT:
 *	This symbol, if defined, indicates that the ustat system call is
 *	available to query file system statistics by dev_t.
 */
/*#define HAS_USTAT		/ **/

/* HAS_WCSCMP:
 *	This symbol, if defined, indicates that the wcscmp routine is
 *	available to compare two wide character strings.
 */
/*#define HAS_WCSCMP	/ **/

/* HAS_WCSXFRM:
 *	This symbol, if defined, indicates that the wcsxfrm routine is
 *	available to tranform a wide character string for wcscmp().
 */
/*#define HAS_WCSXFRM	/ **/

/* HAS_WRITEV:
 *	This symbol, if defined, indicates that the writev routine is
 *	available to do scatter writes.
 */
/*#define HAS_WRITEV		/ **/

/* USE_DYNAMIC_LOADING:
 *	This symbol, if defined, indicates that dynamic loading of
 *	some sort is available.
 */
/*#define USE_DYNAMIC_LOADING		/ **/

/* FFLUSH_NULL:
 *	This symbol, if defined, tells that fflush(NULL) correctly
 *	flushes all pending stdio output without side effects. In
 *	particular, on some platforms calling fflush(NULL) *still*
 *	corrupts STDIN if it is a pipe.
 */
/* FFLUSH_ALL:
 *	This symbol, if defined, tells that to flush
 *	all pending stdio output one must loop through all
 *	the stdio file handles stored in an array and fflush them.
 *	Note that if fflushNULL is defined, fflushall will not
 *	even be probed for and will be left undefined.
 */
/*#define	FFLUSH_NULL 		/ **/
/*#define	FFLUSH_ALL 		/ **/

/* I_ASSERT:
 *	This symbol, if defined, indicates that <assert.h> exists and
 *	could be included by the C program to get the assert() macro.
 */
#define	I_ASSERT		/**/

/* I_BFD:
 *	This symbol, if defined, indicates that <bfd.h> exists and
 *	can be included.
 */
/*#define	I_BFD		/ **/

/* I_CRYPT:
 *	This symbol, if defined, indicates that <crypt.h> exists and
 *	should be included.
 */
/*#define	I_CRYPT		/ **/

/* DB_Prefix_t:
 *	This symbol contains the type of the prefix structure element
 *	in the <db.h> header file.  In older versions of DB, it was
 *	int, while in newer ones it is u_int32_t.
 */
/* DB_Hash_t:
 *	This symbol contains the type of the prefix structure element
 *	in the <db.h> header file.  In older versions of DB, it was
 *	int, while in newer ones it is size_t.
 */
/* DB_VERSION_MAJOR_CFG:
 *	This symbol, if defined, defines the major version number of
 *	Berkeley DB found in the <db.h> header when Perl was configured.
 */
/* DB_VERSION_MINOR_CFG:
 *	This symbol, if defined, defines the minor version number of
 *	Berkeley DB found in the <db.h> header when Perl was configured.
 *	For DB version 1 this is always 0.
 */
/* DB_VERSION_PATCH_CFG:
 *	This symbol, if defined, defines the patch version number of
 *	Berkeley DB found in the <db.h> header when Perl was configured.
 *	For DB version 1 this is always 0.
 */
#define DB_Hash_t	u_int32_t		/**/
#define DB_Prefix_t	size_t  	/**/
#define DB_VERSION_MAJOR_CFG	0  	/**/
#define DB_VERSION_MINOR_CFG	0  	/**/
#define DB_VERSION_PATCH_CFG	0  	/**/

/* I_FENV:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <fenv.h> to get the floating point environment definitions.
 */
/*#define I_FENV		/ **/

/* I_FP:
 *	This symbol, if defined, indicates that <fp.h> exists and
 *	should be included.
 */
/*#define	I_FP		/ **/

/* I_FP_CLASS:
 *	This symbol, if defined, indicates that <fp_class.h> exists and
 *	should be included.
 */
/*#define	I_FP_CLASS		/ **/

/* I_IEEEFP:
 *	This symbol, if defined, indicates that <ieeefp.h> exists and
 *	should be included.
 */
/*#define	I_IEEEFP		/ **/

/* I_INTTYPES:
 *     This symbol, if defined, indicates to the C program that it should
 *     include <inttypes.h>.
 */
/*#define   I_INTTYPES                / **/

/* I_LANGINFO:
 *	This symbol, if defined, indicates that <langinfo.h> exists and
 *	should be included.
 */
/*#define	I_LANGINFO		/ **/

/* I_LIBUTIL:
 *	This symbol, if defined, indicates that <libutil.h> exists and
 *	should be included.
 */
/*#define	I_LIBUTIL		/ **/

/* I_MALLOCMALLOC:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <malloc/malloc.h>.
 */
/*#define I_MALLOCMALLOC		/ **/

/* I_MNTENT:
 *	This symbol, if defined, indicates that <mntent.h> exists and
 *	should be included.
 */
/*#define	I_MNTENT		/ **/

/* I_NETINET_TCP:
 *     This symbol, if defined, indicates to the C program that it should
 *     include <netinet/tcp.h>.
 */
/*#define   I_NETINET_TCP                / **/

/* I_POLL:
 *	This symbol, if defined, indicates that <poll.h> exists and
 *	should be included. (see also HAS_POLL)
 */
/*#define	I_POLL		/ **/

/* I_PROT:
 *	This symbol, if defined, indicates that <prot.h> exists and
 *	should be included.
 */
/*#define	I_PROT		/ **/

/* I_QUADMATH:
 *	This symbol, if defined, indicates that <quadmath.h> exists and
 *	should be included.
 */
/*#define	I_QUADMATH		/ **/

/* I_SHADOW:
 *	This symbol, if defined, indicates that <shadow.h> exists and
 *	should be included.
 */
/*#define	I_SHADOW		/ **/

/* I_SOCKS:
 *	This symbol, if defined, indicates that <socks.h> exists and
 *	should be included.
 */
/*#define	I_SOCKS		/ **/

/* I_STDBOOL:
 *	This symbol, if defined, indicates that <stdbool.h> exists and
 *	can be included.
 */
/*#define	I_STDBOOL		/ **/

/* I_STDINT:
 *	This symbol, if defined, indicates that <stdint.h> exists and
 *	should be included.
 */
/*#define I_STDINT		/ **/

/* I_SUNMATH:
 *	This symbol, if defined, indicates that <sunmath.h> exists and
 *	should be included.
 */
/*#define	I_SUNMATH		/ **/

/* I_SYSLOG:
 *	This symbol, if defined, indicates that <syslog.h> exists and
 *	should be included.
 */
/*#define	I_SYSLOG		/ **/

/* I_SYSMODE:
 *	This symbol, if defined, indicates that <sys/mode.h> exists and
 *	should be included.
 */
/*#define	I_SYSMODE		/ **/

/* I_SYS_MOUNT:
 *	This symbol, if defined, indicates that <sys/mount.h> exists and
 *	should be included.
 */
/*#define	I_SYS_MOUNT		/ **/

/* I_SYS_STATFS:
 *	This symbol, if defined, indicates that <sys/statfs.h> exists.
 */
/*#define	I_SYS_STATFS		/ **/

/* I_SYS_STATVFS:
 *	This symbol, if defined, indicates that <sys/statvfs.h> exists and
 *	should be included.
 */
/*#define	I_SYS_STATVFS		/ **/

/* I_SYSUTSNAME:
 *	This symbol, if defined, indicates that <sys/utsname.h> exists and
 *	should be included.
 */
/*#define	I_SYSUTSNAME		/ **/

/* I_SYS_VFS:
 *	This symbol, if defined, indicates that <sys/vfs.h> exists and
 *	should be included.
 */
/*#define	I_SYS_VFS		/ **/

/* I_USTAT:
 *	This symbol, if defined, indicates that <ustat.h> exists and
 *	should be included.
 */
/*#define	I_USTAT		/ **/

/* DOUBLEINFBYTES:
 *	This symbol, if defined, is a comma-separated list of
 *	hexadecimal bytes for the double precision infinity.
 */
/* DOUBLENANBYTES:
 *	This symbol, if defined, is a comma-separated list of
 *	hexadecimal bytes (0xHH) for the double precision not-a-number.
 */
/* LONGDBLINFBYTES:
 *	This symbol, if defined, is a comma-separated list of
 *	hexadecimal bytes for the long double precision infinity.
 */
/* LONGDBLNANBYTES:
 *	This symbol, if defined, is a comma-separated list of
 *	hexadecimal bytes (0xHH) for the long double precision not-a-number.
 */
#define DOUBLEINFBYTES  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x7f		/**/
#define DOUBLENANBYTES  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x7f		/**/
#define LONGDBLINFBYTES 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00		/**/
#define LONGDBLNANBYTES 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00		/**/

/* PERL_PRIfldbl:
 *	This symbol, if defined, contains the string used by stdio to
 *	format long doubles (format 'f') for output.
 */
/* PERL_PRIgldbl:
 *	This symbol, if defined, contains the string used by stdio to
 *	format long doubles (format 'g') for output.
 */
/* PERL_PRIeldbl:
 *	This symbol, if defined, contains the string used by stdio to
 *	format long doubles (format 'e') for output.
 */
/* PERL_SCNfldbl:
 *	This symbol, if defined, contains the string used by stdio to
 *	format long doubles (format 'f') for input.
 */
/* DOUBLEKIND:
 *	DOUBLEKIND will be one of
 *	DOUBLE_IS_IEEE_754_32_BIT_LITTLE_ENDIAN
 *	DOUBLE_IS_IEEE_754_32_BIT_BIG_ENDIAN
 *	DOUBLE_IS_IEEE_754_64_BIT_LITTLE_ENDIAN
 *	DOUBLE_IS_IEEE_754_64_BIT_BIG_ENDIAN
 *	DOUBLE_IS_IEEE_754_128_BIT_LITTLE_ENDIAN
 *	DOUBLE_IS_IEEE_754_128_BIT_BIG_ENDIAN
 *	DOUBLE_IS_IEEE_754_64_BIT_MIXED_ENDIAN_LE_BE
 *	DOUBLE_IS_IEEE_754_64_BIT_MIXED_ENDIAN_BE_LE
 *	DOUBLE_IS_UNKNOWN_FORMAT
 */
#define DOUBLEKIND 3		/**/
#define DOUBLE_IS_IEEE_754_32_BIT_LITTLE_ENDIAN	1
#define DOUBLE_IS_IEEE_754_32_BIT_BIG_ENDIAN	2
#define DOUBLE_IS_IEEE_754_64_BIT_LITTLE_ENDIAN	3
#define DOUBLE_IS_IEEE_754_64_BIT_BIG_ENDIAN	4
#define DOUBLE_IS_IEEE_754_128_BIT_LITTLE_ENDIAN	5
#define DOUBLE_IS_IEEE_754_128_BIT_BIG_ENDIAN	6
#define DOUBLE_IS_IEEE_754_64_BIT_MIXED_ENDIAN_LE_BE	7
#define DOUBLE_IS_IEEE_754_64_BIT_MIXED_ENDIAN_BE_LE	8
#define DOUBLE_IS_UNKNOWN_FORMAT		-1
/*#define PERL_PRIfldbl	"llf"	/ **/
/*#define PERL_PRIgldbl	"llg"	/ **/
/*#define PERL_PRIeldbl	"lle"	/ **/
/*#define PERL_SCNfldbl	"llf"	/ **/

/* DOUBLEMANTBITS:
 *	This symbol, if defined, tells how many mantissa bits
 *	there are in double precision floating point format.
 *	Note that this is usually DBL_MANT_DIG minus one, since
 *	with the standard IEEE 754 formats DBL_MANT_DIG includes
 *	the implicit bit, which doesn't really exist.
 */
/* LONGDBLMANTBITS:
 *	This symbol, if defined, tells how many mantissa bits
 *	there are in long double precision floating point format.
 *	Note that this can be LDBL_MANT_DIG minus one,
 *	since LDBL_MANT_DIG can include the IEEE 754 implicit bit.
 *	The common x86-style 80-bit long double does not have
 *	an implicit bit.
 */
/* NVMANTBITS:
 *	This symbol, if defined, tells how many mantissa bits
 *	(not including implicit bit) there are in a Perl NV.
 *	This depends on which floating point type was chosen.
 */
#define DOUBLEMANTBITS  52
#define LONGDBLMANTBITS 64
#define NVMANTBITS      52

/* NEED_VA_COPY:
 *	This symbol, if defined, indicates that the system stores
 *	the variable argument list datatype, va_list, in a format
 *	that cannot be copied by simple assignment, so that some
 *	other means must be used when copying is required.
 *	As such systems vary in their provision (or non-provision)
 *	of copying mechanisms, handy.h defines a platform-
 *	independent macro, Perl_va_copy(src, dst), to do the job.
 */
#define	NEED_VA_COPY		/**/

/* IVTYPE:
 *	This symbol defines the C type used for Perl's IV.
 */
/* UVTYPE:
 *	This symbol defines the C type used for Perl's UV.
 */
/* I8TYPE:
 *	This symbol defines the C type used for Perl's I8.
 */
/* U8TYPE:
 *	This symbol defines the C type used for Perl's U8.
 */
/* I16TYPE:
 *	This symbol defines the C type used for Perl's I16.
 */
/* U16TYPE:
 *	This symbol defines the C type used for Perl's U16.
 */
/* I32TYPE:
 *	This symbol defines the C type used for Perl's I32.
 */
/* U32TYPE:
 *	This symbol defines the C type used for Perl's U32.
 */
/* I64TYPE:
 *	This symbol defines the C type used for Perl's I64.
 */
/* U64TYPE:
 *	This symbol defines the C type used for Perl's U64.
 */
/* NVTYPE:
 *	This symbol defines the C type used for Perl's NV.
 */
/* IVSIZE:
 *	This symbol contains the sizeof(IV).
 */
/* UVSIZE:
 *	This symbol contains the sizeof(UV).
 */
/* I8SIZE:
 *	This symbol contains the sizeof(I8).
 */
/* U8SIZE:
 *	This symbol contains the sizeof(U8).
 */
/* I16SIZE:
 *	This symbol contains the sizeof(I16).
 */
/* U16SIZE:
 *	This symbol contains the sizeof(U16).
 */
/* I32SIZE:
 *	This symbol contains the sizeof(I32).
 */
/* U32SIZE:
 *	This symbol contains the sizeof(U32).
 */
/* I64SIZE:
 *	This symbol contains the sizeof(I64).
 */
/* U64SIZE:
 *	This symbol contains the sizeof(U64).
 */
/* NVSIZE:
 *	This symbol contains the sizeof(NV).
 *	Note that some floating point formats have unused bytes.
 *	The most notable example is the x86* 80-bit extended precision
 *	which comes in byte sizes of 12 and 16 (for 32 and 64 bit
 *	platforms, respectively), but which only uses 10 bytes.
 *	Perl compiled with -Duselongdouble on x86* is like this.
 */
/* NV_PRESERVES_UV:
 *	This symbol, if defined, indicates that a variable of type NVTYPE
 *	can preserve all the bits of a variable of type UVTYPE.
 */
/* NV_PRESERVES_UV_BITS:
 *	This symbol contains the number of bits a variable of type NVTYPE
 *	can preserve of a variable of type UVTYPE.
 */
/* NV_OVERFLOWS_INTEGERS_AT:
 *	This symbol gives the largest integer value that NVs can hold. This
 *	value + 1.0 cannot be stored accurately. It is expressed as constant
 *	floating point expression to reduce the chance of decimal/binary
 *	conversion issues. If it can not be determined, the value 0 is given.
 */
/* NV_ZERO_IS_ALLBITS_ZERO:
 *	This symbol, if defined, indicates that a variable of type NVTYPE
 *	stores 0.0 in memory as all bits zero.
 */
#define	IVTYPE		long		/**/
#define	UVTYPE		unsigned long		/**/
#define	I8TYPE		signed char		/**/
#define	U8TYPE		unsigned char		/**/
#define	I16TYPE		short	/**/
#define	U16TYPE		unsigned short	/**/
#define	I32TYPE		long	/**/
#define	U32TYPE		unsigned long	/**/
#ifdef HAS_QUAD
#define	I64TYPE		int64_t	/**/
#define	U64TYPE		uint64_t	/**/
#endif
#define	NVTYPE		double		/**/
#define	IVSIZE		4		/**/
#define	UVSIZE		4		/**/
#define	I8SIZE		1		/**/
#define	U8SIZE		1		/**/
#define	I16SIZE		2	/**/
#define	U16SIZE		2	/**/
#define	I32SIZE		4	/**/
#define	U32SIZE		4	/**/
#ifdef HAS_QUAD
#define	I64SIZE		8	/**/
#define	U64SIZE		8	/**/
#endif
#define	NVSIZE		8		/**/
#undef	NV_PRESERVES_UV
#define	NV_PRESERVES_UV_BITS	0
#define	NV_OVERFLOWS_INTEGERS_AT	256.0*256.0*256.0*256.0*256.0*256.0*2.0*2.0*2.0*2.0*2.0
#undef	NV_ZERO_IS_ALLBITS_ZERO
#if UVSIZE == 8
#   ifdef BYTEORDER
#       if BYTEORDER == 0x1234
#           undef BYTEORDER
#           define BYTEORDER 0x12345678
#       else
#           if BYTEORDER == 0x4321
#               undef BYTEORDER
#               define BYTEORDER 0x87654321
#           endif
#       endif
#   endif
#endif

/* IVdf:
 *	This symbol defines the format string used for printing a Perl IV
 *	as a signed decimal integer.
 */
/* UVuf:
 *	This symbol defines the format string used for printing a Perl UV
 *	as an unsigned decimal integer.
 */
/* UVof:
 *	This symbol defines the format string used for printing a Perl UV
 *	as an unsigned octal integer.
 */
/* UVxf:
 *	This symbol defines the format string used for printing a Perl UV
 *	as an unsigned hexadecimal integer in lowercase abcdef.
 */
/* UVXf:
 *	This symbol defines the format string used for printing a Perl UV
 *	as an unsigned hexadecimal integer in uppercase ABCDEF.
 */
/* NVef:
 *	This symbol defines the format string used for printing a Perl NV
 *	using %e-ish floating point format.
 */
/* NVff:
 *	This symbol defines the format string used for printing a Perl NV
 *	using %f-ish floating point format.
 */
/* NVgf:
 *	This symbol defines the format string used for printing a Perl NV
 *	using %g-ish floating point format.
 */
#define	IVdf		"ld"		/**/
#define	UVuf		"lu"		/**/
#define	UVof		"lo"		/**/
#define	UVxf		"lx"		/**/
#define	UVXf		"lX"		/**/
#define	NVef		"e"		/**/
#define	NVff		"f"		/**/
#define	NVgf		"g"		/**/

/* SELECT_MIN_BITS:
 *	This symbol holds the minimum number of bits operated by select.
 *	That is, if you do select(n, ...), how many bits at least will be
 *	cleared in the masks if some activity is detected.  Usually this
 *	is either n or 32*ceil(n/32), especially many little-endians do
 *	the latter.  This is only useful if you have select(), naturally.
 */
#define SELECT_MIN_BITS 	32	/**/

/* ST_INO_SIZE:
 *	This variable contains the size of struct stat's st_ino in bytes.
 */
/* ST_INO_SIGN:
 *	This symbol holds the signedness of struct stat's st_ino.
 *	1 for unsigned, -1 for signed.
 */
#define ST_INO_SIGN 1	/* st_ino sign */
#define ST_INO_SIZE 4	/* st_ino size */

/* STARTPERL:
 *	This variable contains the string to put in front of a perl
 *	script to make sure (one hopes) that it runs with perl and not
 *	some shell.
 */
#define STARTPERL "#!perl"		/**/

/* HAS_STDIO_STREAM_ARRAY:
 *	This symbol, if defined, tells that there is an array
 *	holding the stdio streams.
 */
/* STDIO_STREAM_ARRAY:
 *	This symbol tells the name of the array holding the stdio streams.
 *	Usual values include _iob, __iob, and __sF.
 */
/*#define	HAS_STDIO_STREAM_ARRAY	/ **/
#ifdef HAS_STDIO_STREAM_ARRAY
#define STDIO_STREAM_ARRAY	
#endif

/* GMTIME_MAX:
 *	This symbol contains the maximum value for the time_t offset that
 *	the system function gmtime () accepts, and defaults to 0
 */
/* GMTIME_MIN:
 *	This symbol contains the minimum value for the time_t offset that
 *	the system function gmtime () accepts, and defaults to 0
 */
/* LOCALTIME_MAX:
 *	This symbol contains the maximum value for the time_t offset that
 *	the system function localtime () accepts, and defaults to 0
 */
/* LOCALTIME_MIN:
 *	This symbol contains the minimum value for the time_t offset that
 *	the system function localtime () accepts, and defaults to 0
 */
#define GMTIME_MAX		2147483647	/**/
#define GMTIME_MIN		0	/**/
#define LOCALTIME_MAX	2147483647	/**/
#define LOCALTIME_MIN	0	/**/

/* USE_64_BIT_INT:
 *	This symbol, if defined, indicates that 64-bit integers should
 *	be used when available.  If not defined, the native integers
 *	will be employed (be they 32 or 64 bits).  The minimal possible
 *	64-bitness is used, just enough to get 64-bit integers into Perl.
 *	This may mean using for example "long longs", while your memory
 *	may still be limited to 2 gigabytes.
 */
/* USE_64_BIT_ALL:
 *	This symbol, if defined, indicates that 64-bit integers should
 *	be used when available.  If not defined, the native integers
 *	will be used (be they 32 or 64 bits).  The maximal possible
 *	64-bitness is employed: LP64 or ILP64, meaning that you will
 *	be able to use more than 2 gigabytes of memory.  This mode is
 *	even more binary incompatible than USE_64_BIT_INT. You may not
 *	be able to run the resulting executable in a 32-bit CPU at all or
 *	you may need at least to reboot your OS to 64-bit mode.
 */
#ifndef USE_64_BIT_INT
/*#define	USE_64_BIT_INT		/ **/
#endif
#ifndef USE_64_BIT_ALL
/*#define	USE_64_BIT_ALL		/ **/
#endif

/* USE_CBACKTRACE:
 *	This symbol, if defined, indicates that Perl should
 *	be built with support for backtrace.
 */
/*#define USE_CBACKTRACE		/ **/

/* USE_DTRACE:
 *	This symbol, if defined, indicates that Perl should
 *	be built with support for DTrace.
 */
/*#define USE_DTRACE		/ **/

/* USE_FAST_STDIO:
 *	This symbol, if defined, indicates that Perl should
 *	be built to use 'fast stdio'.
 *	Defaults to define in Perls 5.8 and earlier, to undef later.
 */
#ifndef USE_FAST_STDIO
/*#define	USE_FAST_STDIO		/ **/
#endif

/* USE_KERN_PROC_PATHNAME:
 *	This symbol, if defined, indicates that we can use sysctl with
 *	KERN_PROC_PATHNAME to get a full path for the executable, and hence
 * 	convert $^X to an absolute path.
 */
/*#define USE_KERN_PROC_PATHNAME	/ **/

/* USE_LARGE_FILES:
 *	This symbol, if defined, indicates that large file support
 *	should be used when available.
 */
#ifndef USE_LARGE_FILES
/*#define	USE_LARGE_FILES		/ **/
#endif

/* USE_LONG_DOUBLE:
 *	This symbol, if defined, indicates that long doubles should
 *	be used when available.
 */
#ifndef USE_LONG_DOUBLE
/*#define	USE_LONG_DOUBLE		/ **/
#endif

/* USE_MORE_BITS:
 *	This symbol, if defined, indicates that 64-bit interfaces and
 *	long doubles should be used when available.
 */
#ifndef USE_MORE_BITS
/*#define	USE_MORE_BITS		/ **/
#endif

/* MULTIPLICITY:
 *	This symbol, if defined, indicates that Perl should
 *	be built to use multiplicity.
 */
#ifndef MULTIPLICITY
/*#define	MULTIPLICITY		/ **/
#endif

/* USE_NSGETEXECUTABLEPATH:
 *	This symbol, if defined, indicates that we can use _NSGetExecutablePath
 *	and realpath to get a full path for the executable, and hence convert
 *	$^X to an absolute path.
 */
/*#define USE_NSGETEXECUTABLEPATH	/ **/

/* USE_PERLIO:
 *	This symbol, if defined, indicates that the PerlIO abstraction should
 *	be used throughout.  If not defined, stdio should be
 *	used in a fully backward compatible manner.
 */
#ifndef USE_PERLIO
/*#define	USE_PERLIO		/ **/
#endif

/* USE_QUADMATH:
 *	This symbol, if defined, indicates that the quadmath library should
 *	be used when available.
 */
#ifndef USE_QUADMATH
/*#define	USE_QUADMATH		/ **/
#endif

/* USE_SOCKS:
 *	This symbol, if defined, indicates that Perl should
 *	be built to use socks.
 */
#ifndef USE_SOCKS
/*#define	USE_SOCKS		/ **/
#endif

/* HAS_DRAND48_PROTO:
 *	This symbol, if defined, indicates that the system provides
 *	a prototype for the drand48() function.  Otherwise, it is up
 *	to the program to supply one.  A good guess is
 *		extern double drand48(void);
 */
/*#define	HAS_DRAND48_PROTO	/ **/

/* HAS_GETHOST_PROTOS:
 *	This symbol, if defined, indicates that <netdb.h> includes
 *	prototypes for gethostent(), gethostbyname(), and
 *	gethostbyaddr().  Otherwise, it is up to the program to guess
 *	them.  See netdbtype.U for probing for various Netdb_xxx_t types.
 */
/*#define	HAS_GETHOST_PROTOS	/ **/

/* HAS_GETNET_PROTOS:
 *	This symbol, if defined, indicates that <netdb.h> includes
 *	prototypes for getnetent(), getnetbyname(), and
 *	getnetbyaddr().  Otherwise, it is up to the program to guess
 *	them.  See netdbtype.U for probing for various Netdb_xxx_t types.
 */
/*#define	HAS_GETNET_PROTOS	/ **/

/* HAS_GETPROTO_PROTOS:
 *	This symbol, if defined, indicates that <netdb.h> includes
 *	prototypes for getprotoent(), getprotobyname(), and
 *	getprotobyaddr().  Otherwise, it is up to the program to guess
 *	them.  See netdbtype.U for probing for various Netdb_xxx_t types.
 */
/*#define	HAS_GETPROTO_PROTOS	/ **/

/* HAS_GETSERV_PROTOS:
 *	This symbol, if defined, indicates that <netdb.h> includes
 *	prototypes for getservent(), getservbyname(), and
 *	getservbyaddr().  Otherwise, it is up to the program to guess
 *	them.  See netdbtype.U for probing for various Netdb_xxx_t types.
 */
/*#define	HAS_GETSERV_PROTOS	/ **/

/* HAS_LSEEK_PROTO:
 *	This symbol, if defined, indicates that the system provides
 *	a prototype for the lseek() function.  Otherwise, it is up
 *	to the program to supply one.  A good guess is
 *		extern off_t lseek(int, off_t, int);
 */
/*#define	HAS_LSEEK_PROTO	/ **/

/* Netdb_host_t:
 *	This symbol holds the type used for the 1st argument
 *	to gethostbyaddr().
 */
/* Netdb_hlen_t:
 *	This symbol holds the type used for the 2nd argument
 *	to gethostbyaddr().
 */
/* Netdb_name_t:
 *	This symbol holds the type used for the argument to
 *	gethostbyname().
 */
/* Netdb_net_t:
 *	This symbol holds the type used for the 1st argument to
 *	getnetbyaddr().
 */
#define Netdb_host_t		const char * /**/
#define Netdb_hlen_t		int /**/
#define Netdb_name_t		const char * /**/
#define Netdb_net_t		unsigned long /**/

/* Select_fd_set_t:
 *	This symbol holds the type used for the 2nd, 3rd, and 4th
 *	arguments to select.  Usually, this is 'fd_set *', if HAS_FD_SET
 *	is defined, and 'int *' otherwise.  This is only useful if you
 *	have select(), of course.
 */
#define Select_fd_set_t 	int	/**/

/* Sock_size_t:
 *	This symbol holds the type used for the size argument of
 *	various socket calls (just the base type, not the pointer-to).
 */
#define Sock_size_t		int /**/

/* ARCHNAME:
 *	This symbol holds a string representing the architecture name.
 *	It may be used to construct an architecture-dependant pathname
 *	where library files may be held under a private library, for
 *	instance.
 */
#define ARCHNAME "unknown"		/**/

/* HAS_ASCTIME_R:
 *	This symbol, if defined, indicates that the asctime_r routine
 *	is available to asctime re-entrantly.
 */
/* ASCTIME_R_PROTO:
 *	This symbol encodes the prototype of asctime_r.
 *	It is zero if d_asctime_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_asctime_r
 *	is defined.
 */
/*#define HAS_ASCTIME_R	   / **/
#define ASCTIME_R_PROTO 0	   /**/

/* HAS_CRYPT_R:
 *	This symbol, if defined, indicates that the crypt_r routine
 *	is available to crypt re-entrantly.
 */
/* CRYPT_R_PROTO:
 *	This symbol encodes the prototype of crypt_r.
 *	It is zero if d_crypt_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_crypt_r
 *	is defined.
 */
/*#define HAS_CRYPT_R	   / **/
#define CRYPT_R_PROTO 0	   /**/

/* HAS_CTERMID_R:
 *	This symbol, if defined, indicates that the ctermid_r routine
 *	is available to ctermid re-entrantly.
 */
/* CTERMID_R_PROTO:
 *	This symbol encodes the prototype of ctermid_r.
 *	It is zero if d_ctermid_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_ctermid_r
 *	is defined.
 */
/*#define HAS_CTERMID_R	   / **/
#define CTERMID_R_PROTO 0	   /**/

/* HAS_CTIME_R:
 *	This symbol, if defined, indicates that the ctime_r routine
 *	is available to ctime re-entrantly.
 */
/* CTIME_R_PROTO:
 *	This symbol encodes the prototype of ctime_r.
 *	It is zero if d_ctime_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_ctime_r
 *	is defined.
 */
/*#define HAS_CTIME_R	   / **/
#define CTIME_R_PROTO 0	   /**/

/* HAS_DRAND48_R:
 *	This symbol, if defined, indicates that the drand48_r routine
 *	is available to drand48 re-entrantly.
 */
/* DRAND48_R_PROTO:
 *	This symbol encodes the prototype of drand48_r.
 *	It is zero if d_drand48_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_drand48_r
 *	is defined.
 */
/*#define HAS_DRAND48_R	   / **/
#define DRAND48_R_PROTO 0	   /**/

/* HAS_ENDGRENT_R:
 *	This symbol, if defined, indicates that the endgrent_r routine
 *	is available to endgrent re-entrantly.
 */
/* ENDGRENT_R_PROTO:
 *	This symbol encodes the prototype of endgrent_r.
 *	It is zero if d_endgrent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_endgrent_r
 *	is defined.
 */
/*#define HAS_ENDGRENT_R	   / **/
#define ENDGRENT_R_PROTO 0	   /**/

/* HAS_ENDHOSTENT_R:
 *	This symbol, if defined, indicates that the endhostent_r routine
 *	is available to endhostent re-entrantly.
 */
/* ENDHOSTENT_R_PROTO:
 *	This symbol encodes the prototype of endhostent_r.
 *	It is zero if d_endhostent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_endhostent_r
 *	is defined.
 */
/*#define HAS_ENDHOSTENT_R	   / **/
#define ENDHOSTENT_R_PROTO 0	   /**/

/* HAS_ENDNETENT_R:
 *	This symbol, if defined, indicates that the endnetent_r routine
 *	is available to endnetent re-entrantly.
 */
/* ENDNETENT_R_PROTO:
 *	This symbol encodes the prototype of endnetent_r.
 *	It is zero if d_endnetent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_endnetent_r
 *	is defined.
 */
/*#define HAS_ENDNETENT_R	   / **/
#define ENDNETENT_R_PROTO 0	   /**/

/* HAS_ENDPROTOENT_R:
 *	This symbol, if defined, indicates that the endprotoent_r routine
 *	is available to endprotoent re-entrantly.
 */
/* ENDPROTOENT_R_PROTO:
 *	This symbol encodes the prototype of endprotoent_r.
 *	It is zero if d_endprotoent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_endprotoent_r
 *	is defined.
 */
/*#define HAS_ENDPROTOENT_R	   / **/
#define ENDPROTOENT_R_PROTO 0	   /**/

/* HAS_ENDPWENT_R:
 *	This symbol, if defined, indicates that the endpwent_r routine
 *	is available to endpwent re-entrantly.
 */
/* ENDPWENT_R_PROTO:
 *	This symbol encodes the prototype of endpwent_r.
 *	It is zero if d_endpwent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_endpwent_r
 *	is defined.
 */
/*#define HAS_ENDPWENT_R	   / **/
#define ENDPWENT_R_PROTO 0	   /**/

/* HAS_ENDSERVENT_R:
 *	This symbol, if defined, indicates that the endservent_r routine
 *	is available to endservent re-entrantly.
 */
/* ENDSERVENT_R_PROTO:
 *	This symbol encodes the prototype of endservent_r.
 *	It is zero if d_endservent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_endservent_r
 *	is defined.
 */
/*#define HAS_ENDSERVENT_R	   / **/
#define ENDSERVENT_R_PROTO 0	   /**/

/* HAS_GETGRENT_R:
 *	This symbol, if defined, indicates that the getgrent_r routine
 *	is available to getgrent re-entrantly.
 */
/* GETGRENT_R_PROTO:
 *	This symbol encodes the prototype of getgrent_r.
 *	It is zero if d_getgrent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_getgrent_r
 *	is defined.
 */
/*#define HAS_GETGRENT_R	   / **/
#define GETGRENT_R_PROTO 0	   /**/

/* HAS_GETGRGID_R:
 *	This symbol, if defined, indicates that the getgrgid_r routine
 *	is available to getgrgid re-entrantly.
 */
/* GETGRGID_R_PROTO:
 *	This symbol encodes the prototype of getgrgid_r.
 *	It is zero if d_getgrgid_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_getgrgid_r
 *	is defined.
 */
/*#define HAS_GETGRGID_R	   / **/
#define GETGRGID_R_PROTO 0	   /**/

/* HAS_GETGRNAM_R:
 *	This symbol, if defined, indicates that the getgrnam_r routine
 *	is available to getgrnam re-entrantly.
 */
/* GETGRNAM_R_PROTO:
 *	This symbol encodes the prototype of getgrnam_r.
 *	It is zero if d_getgrnam_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_getgrnam_r
 *	is defined.
 */
/*#define HAS_GETGRNAM_R	   / **/
#define GETGRNAM_R_PROTO 0	   /**/

/* HAS_GETHOSTBYADDR_R:
 *	This symbol, if defined, indicates that the gethostbyaddr_r routine
 *	is available to gethostbyaddr re-entrantly.
 */
/* GETHOSTBYADDR_R_PROTO:
 *	This symbol encodes the prototype of gethostbyaddr_r.
 *	It is zero if d_gethostbyaddr_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_gethostbyaddr_r
 *	is defined.
 */
/*#define HAS_GETHOSTBYADDR_R	   / **/
#define GETHOSTBYADDR_R_PROTO 0	   /**/

/* HAS_GETHOSTBYNAME_R:
 *	This symbol, if defined, indicates that the gethostbyname_r routine
 *	is available to gethostbyname re-entrantly.
 */
/* GETHOSTBYNAME_R_PROTO:
 *	This symbol encodes the prototype of gethostbyname_r.
 *	It is zero if d_gethostbyname_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_gethostbyname_r
 *	is defined.
 */
/*#define HAS_GETHOSTBYNAME_R	   / **/
#define GETHOSTBYNAME_R_PROTO 0	   /**/

/* HAS_GETHOSTENT_R:
 *	This symbol, if defined, indicates that the gethostent_r routine
 *	is available to gethostent re-entrantly.
 */
/* GETHOSTENT_R_PROTO:
 *	This symbol encodes the prototype of gethostent_r.
 *	It is zero if d_gethostent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_gethostent_r
 *	is defined.
 */
/*#define HAS_GETHOSTENT_R	   / **/
#define GETHOSTENT_R_PROTO 0	   /**/

/* HAS_GETLOGIN_R:
 *	This symbol, if defined, indicates that the getlogin_r routine
 *	is available to getlogin re-entrantly.
 */
/* GETLOGIN_R_PROTO:
 *	This symbol encodes the prototype of getlogin_r.
 *	It is zero if d_getlogin_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_getlogin_r
 *	is defined.
 */
/*#define HAS_GETLOGIN_R	   / **/
#define GETLOGIN_R_PROTO 0	   /**/

/* HAS_GETNETBYADDR_R:
 *	This symbol, if defined, indicates that the getnetbyaddr_r routine
 *	is available to getnetbyaddr re-entrantly.
 */
/* GETNETBYADDR_R_PROTO:
 *	This symbol encodes the prototype of getnetbyaddr_r.
 *	It is zero if d_getnetbyaddr_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_getnetbyaddr_r
 *	is defined.
 */
/*#define HAS_GETNETBYADDR_R	   / **/
#define GETNETBYADDR_R_PROTO 0	   /**/

/* HAS_GETNETBYNAME_R:
 *	This symbol, if defined, indicates that the getnetbyname_r routine
 *	is available to getnetbyname re-entrantly.
 */
/* GETNETBYNAME_R_PROTO:
 *	This symbol encodes the prototype of getnetbyname_r.
 *	It is zero if d_getnetbyname_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_getnetbyname_r
 *	is defined.
 */
/*#define HAS_GETNETBYNAME_R	   / **/
#define GETNETBYNAME_R_PROTO 0	   /**/

/* HAS_GETNETENT_R:
 *	This symbol, if defined, indicates that the getnetent_r routine
 *	is available to getnetent re-entrantly.
 */
/* GETNETENT_R_PROTO:
 *	This symbol encodes the prototype of getnetent_r.
 *	It is zero if d_getnetent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_getnetent_r
 *	is defined.
 */
/*#define HAS_GETNETENT_R	   / **/
#define GETNETENT_R_PROTO 0	   /**/

/* HAS_GETPROTOBYNAME_R:
 *	This symbol, if defined, indicates that the getprotobyname_r routine
 *	is available to getprotobyname re-entrantly.
 */
/* GETPROTOBYNAME_R_PROTO:
 *	This symbol encodes the prototype of getprotobyname_r.
 *	It is zero if d_getprotobyname_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_getprotobyname_r
 *	is defined.
 */
/*#define HAS_GETPROTOBYNAME_R	   / **/
#define GETPROTOBYNAME_R_PROTO 0	   /**/

/* HAS_GETPROTOBYNUMBER_R:
 *	This symbol, if defined, indicates that the getprotobynumber_r routine
 *	is available to getprotobynumber re-entrantly.
 */
/* GETPROTOBYNUMBER_R_PROTO:
 *	This symbol encodes the prototype of getprotobynumber_r.
 *	It is zero if d_getprotobynumber_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_getprotobynumber_r
 *	is defined.
 */
/*#define HAS_GETPROTOBYNUMBER_R	   / **/
#define GETPROTOBYNUMBER_R_PROTO 0	   /**/

/* HAS_GETPROTOENT_R:
 *	This symbol, if defined, indicates that the getprotoent_r routine
 *	is available to getprotoent re-entrantly.
 */
/* GETPROTOENT_R_PROTO:
 *	This symbol encodes the prototype of getprotoent_r.
 *	It is zero if d_getprotoent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_getprotoent_r
 *	is defined.
 */
/*#define HAS_GETPROTOENT_R	   / **/
#define GETPROTOENT_R_PROTO 0	   /**/

/* HAS_GETPWENT_R:
 *	This symbol, if defined, indicates that the getpwent_r routine
 *	is available to getpwent re-entrantly.
 */
/* GETPWENT_R_PROTO:
 *	This symbol encodes the prototype of getpwent_r.
 *	It is zero if d_getpwent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_getpwent_r
 *	is defined.
 */
/*#define HAS_GETPWENT_R	   / **/
#define GETPWENT_R_PROTO 0	   /**/

/* HAS_GETPWNAM_R:
 *	This symbol, if defined, indicates that the getpwnam_r routine
 *	is available to getpwnam re-entrantly.
 */
/* GETPWNAM_R_PROTO:
 *	This symbol encodes the prototype of getpwnam_r.
 *	It is zero if d_getpwnam_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_getpwnam_r
 *	is defined.
 */
/*#define HAS_GETPWNAM_R	   / **/
#define GETPWNAM_R_PROTO 0	   /**/

/* HAS_GETPWUID_R:
 *	This symbol, if defined, indicates that the getpwuid_r routine
 *	is available to getpwuid re-entrantly.
 */
/* GETPWUID_R_PROTO:
 *	This symbol encodes the prototype of getpwuid_r.
 *	It is zero if d_getpwuid_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_getpwuid_r
 *	is defined.
 */
/*#define HAS_GETPWUID_R	   / **/
#define GETPWUID_R_PROTO 0	   /**/

/* HAS_GETSERVBYNAME_R:
 *	This symbol, if defined, indicates that the getservbyname_r routine
 *	is available to getservbyname re-entrantly.
 */
/* GETSERVBYNAME_R_PROTO:
 *	This symbol encodes the prototype of getservbyname_r.
 *	It is zero if d_getservbyname_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_getservbyname_r
 *	is defined.
 */
/*#define HAS_GETSERVBYNAME_R	   / **/
#define GETSERVBYNAME_R_PROTO 0	   /**/

/* HAS_GETSERVBYPORT_R:
 *	This symbol, if defined, indicates that the getservbyport_r routine
 *	is available to getservbyport re-entrantly.
 */
/* GETSERVBYPORT_R_PROTO:
 *	This symbol encodes the prototype of getservbyport_r.
 *	It is zero if d_getservbyport_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_getservbyport_r
 *	is defined.
 */
/*#define HAS_GETSERVBYPORT_R	   / **/
#define GETSERVBYPORT_R_PROTO 0	   /**/

/* HAS_GETSERVENT_R:
 *	This symbol, if defined, indicates that the getservent_r routine
 *	is available to getservent re-entrantly.
 */
/* GETSERVENT_R_PROTO:
 *	This symbol encodes the prototype of getservent_r.
 *	It is zero if d_getservent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_getservent_r
 *	is defined.
 */
/*#define HAS_GETSERVENT_R	   / **/
#define GETSERVENT_R_PROTO 0	   /**/

/* HAS_GETSPNAM_R:
 *	This symbol, if defined, indicates that the getspnam_r routine
 *	is available to getspnam re-entrantly.
 */
/* GETSPNAM_R_PROTO:
 *	This symbol encodes the prototype of getspnam_r.
 *	It is zero if d_getspnam_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_getspnam_r
 *	is defined.
 */
/*#define HAS_GETSPNAM_R	   / **/
#define GETSPNAM_R_PROTO 0	   /**/

/* HAS_GMTIME_R:
 *	This symbol, if defined, indicates that the gmtime_r routine
 *	is available to gmtime re-entrantly.
 */
/* GMTIME_R_PROTO:
 *	This symbol encodes the prototype of gmtime_r.
 *	It is zero if d_gmtime_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_gmtime_r
 *	is defined.
 */
/*#define HAS_GMTIME_R	   / **/
#define GMTIME_R_PROTO 0	   /**/

/* HAS_LOCALTIME_R:
 *	This symbol, if defined, indicates that the localtime_r routine
 *	is available to localtime re-entrantly.
 */
/* LOCALTIME_R_NEEDS_TZSET:
 *	Many libc's localtime_r implementations do not call tzset,
 *	making them differ from localtime(), and making timezone
 *	changes using $ENV{TZ} without explicitly calling tzset
 *	impossible. This symbol makes us call tzset before localtime_r
 */
/*#define LOCALTIME_R_NEEDS_TZSET / **/
#ifdef LOCALTIME_R_NEEDS_TZSET
#define L_R_TZSET tzset(),
#else
#define L_R_TZSET
#endif

/* LOCALTIME_R_PROTO:
 *	This symbol encodes the prototype of localtime_r.
 *	It is zero if d_localtime_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_localtime_r
 *	is defined.
 */
/*#define HAS_LOCALTIME_R	   / **/
#define LOCALTIME_R_PROTO 0	   /**/

/* OLD_PTHREAD_CREATE_JOINABLE:
 *	This symbol, if defined, indicates how to create pthread
 *	in joinable (aka undetached) state.  NOTE: not defined
 *	if pthread.h already has defined PTHREAD_CREATE_JOINABLE
 *	(the new version of the constant).
 *	If defined, known values are PTHREAD_CREATE_UNDETACHED
 *	and __UNDETACHED.
 */
/*#define OLD_PTHREAD_CREATE_JOINABLE  / **/

/* HAS_PTHREAD_ATFORK:
 *	This symbol, if defined, indicates that the pthread_atfork routine
 *	is available to setup fork handlers.
 */
/*#define HAS_PTHREAD_ATFORK		/ **/

/* HAS_PTHREAD_YIELD:
 *	This symbol, if defined, indicates that the pthread_yield
 *	routine is available to yield the execution of the current
 *	thread.	 sched_yield is preferable to pthread_yield.
 */
/* SCHED_YIELD:
 *	This symbol defines the way to yield the execution of
 *	the current thread.  Known ways are sched_yield,
 *	pthread_yield, and pthread_yield with NULL.
 */
/* HAS_SCHED_YIELD:
 *	This symbol, if defined, indicates that the sched_yield
 *	routine is available to yield the execution of the current
 *	thread.	 sched_yield is preferable to pthread_yield.
 */
/*#define HAS_PTHREAD_YIELD	/ **/
#define SCHED_YIELD	sched_yield()	/**/
/*#define HAS_SCHED_YIELD	/ **/

/* HAS_RANDOM_R:
 *	This symbol, if defined, indicates that the random_r routine
 *	is available to random re-entrantly.
 */
/* RANDOM_R_PROTO:
 *	This symbol encodes the prototype of random_r.
 *	It is zero if d_random_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_random_r
 *	is defined.
 */
/*#define HAS_RANDOM_R	   / **/
#define RANDOM_R_PROTO 0	   /**/

/* HAS_READDIR64_R:
 *	This symbol, if defined, indicates that the readdir64_r routine
 *	is available to readdir64 re-entrantly.
 */
/* READDIR64_R_PROTO:
 *	This symbol encodes the prototype of readdir64_r.
 *	It is zero if d_readdir64_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_readdir64_r
 *	is defined.
 */
/*#define HAS_READDIR64_R	   / **/
#define READDIR64_R_PROTO 0	   /**/

/* HAS_READDIR_R:
 *	This symbol, if defined, indicates that the readdir_r routine
 *	is available to readdir re-entrantly.
 */
/* READDIR_R_PROTO:
 *	This symbol encodes the prototype of readdir_r.
 *	It is zero if d_readdir_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_readdir_r
 *	is defined.
 */
/*#define HAS_READDIR_R	   / **/
#define READDIR_R_PROTO 0	   /**/

/* HAS_SETGRENT_R:
 *	This symbol, if defined, indicates that the setgrent_r routine
 *	is available to setgrent re-entrantly.
 */
/* SETGRENT_R_PROTO:
 *	This symbol encodes the prototype of setgrent_r.
 *	It is zero if d_setgrent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_setgrent_r
 *	is defined.
 */
/*#define HAS_SETGRENT_R	   / **/
#define SETGRENT_R_PROTO 0	   /**/

/* HAS_SETHOSTENT_R:
 *	This symbol, if defined, indicates that the sethostent_r routine
 *	is available to sethostent re-entrantly.
 */
/* SETHOSTENT_R_PROTO:
 *	This symbol encodes the prototype of sethostent_r.
 *	It is zero if d_sethostent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_sethostent_r
 *	is defined.
 */
/*#define HAS_SETHOSTENT_R	   / **/
#define SETHOSTENT_R_PROTO 0	   /**/

/* HAS_SETLOCALE_R:
 *	This symbol, if defined, indicates that the setlocale_r routine
 *	is available to setlocale re-entrantly.
 */
/* SETLOCALE_R_PROTO:
 *	This symbol encodes the prototype of setlocale_r.
 *	It is zero if d_setlocale_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_setlocale_r
 *	is defined.
 */
/*#define HAS_SETLOCALE_R	   / **/
#define SETLOCALE_R_PROTO 0	   /**/

/* HAS_SETNETENT_R:
 *	This symbol, if defined, indicates that the setnetent_r routine
 *	is available to setnetent re-entrantly.
 */
/* SETNETENT_R_PROTO:
 *	This symbol encodes the prototype of setnetent_r.
 *	It is zero if d_setnetent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_setnetent_r
 *	is defined.
 */
/*#define HAS_SETNETENT_R	   / **/
#define SETNETENT_R_PROTO 0	   /**/

/* HAS_SETPROTOENT_R:
 *	This symbol, if defined, indicates that the setprotoent_r routine
 *	is available to setprotoent re-entrantly.
 */
/* SETPROTOENT_R_PROTO:
 *	This symbol encodes the prototype of setprotoent_r.
 *	It is zero if d_setprotoent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_setprotoent_r
 *	is defined.
 */
/*#define HAS_SETPROTOENT_R	   / **/
#define SETPROTOENT_R_PROTO 0	   /**/

/* HAS_SETPWENT_R:
 *	This symbol, if defined, indicates that the setpwent_r routine
 *	is available to setpwent re-entrantly.
 */
/* SETPWENT_R_PROTO:
 *	This symbol encodes the prototype of setpwent_r.
 *	It is zero if d_setpwent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_setpwent_r
 *	is defined.
 */
/*#define HAS_SETPWENT_R	   / **/
#define SETPWENT_R_PROTO 0	   /**/

/* HAS_SETSERVENT_R:
 *	This symbol, if defined, indicates that the setservent_r routine
 *	is available to setservent re-entrantly.
 */
/* SETSERVENT_R_PROTO:
 *	This symbol encodes the prototype of setservent_r.
 *	It is zero if d_setservent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_setservent_r
 *	is defined.
 */
/*#define HAS_SETSERVENT_R	   / **/
#define SETSERVENT_R_PROTO 0	   /**/

/* HAS_SRAND48_R:
 *	This symbol, if defined, indicates that the srand48_r routine
 *	is available to srand48 re-entrantly.
 */
/* SRAND48_R_PROTO:
 *	This symbol encodes the prototype of srand48_r.
 *	It is zero if d_srand48_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_srand48_r
 *	is defined.
 */
/*#define HAS_SRAND48_R	   / **/
#define SRAND48_R_PROTO 0	   /**/

/* HAS_SRANDOM_R:
 *	This symbol, if defined, indicates that the srandom_r routine
 *	is available to srandom re-entrantly.
 */
/* SRANDOM_R_PROTO:
 *	This symbol encodes the prototype of srandom_r.
 *	It is zero if d_srandom_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_srandom_r
 *	is defined.
 */
/*#define HAS_SRANDOM_R	   / **/
#define SRANDOM_R_PROTO 0	   /**/

/* HAS_STRERROR_R:
 *	This symbol, if defined, indicates that the strerror_r routine
 *	is available to strerror re-entrantly.
 */
/* STRERROR_R_PROTO:
 *	This symbol encodes the prototype of strerror_r.
 *	It is zero if d_strerror_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_strerror_r
 *	is defined.
 */
/*#define HAS_STRERROR_R	   / **/
#define STRERROR_R_PROTO 0	   /**/

/* HAS_TMPNAM_R:
 *	This symbol, if defined, indicates that the tmpnam_r routine
 *	is available to tmpnam re-entrantly.
 */
/* TMPNAM_R_PROTO:
 *	This symbol encodes the prototype of tmpnam_r.
 *	It is zero if d_tmpnam_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_tmpnam_r
 *	is defined.
 */
/*#define HAS_TMPNAM_R	   / **/
#define TMPNAM_R_PROTO 0	   /**/

/* HAS_TTYNAME_R:
 *	This symbol, if defined, indicates that the ttyname_r routine
 *	is available to ttyname re-entrantly.
 */
/* TTYNAME_R_PROTO:
 *	This symbol encodes the prototype of ttyname_r.
 *	It is zero if d_ttyname_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_ttyname_r
 *	is defined.
 */
/*#define HAS_TTYNAME_R	   / **/
#define TTYNAME_R_PROTO 0	   /**/

/* I_MACH_CTHREADS:
 *     This symbol, if defined, indicates to the C program that it should
 *     include <mach/cthreads.h>.
 */
/*#define   I_MACH_CTHREADS	/ **/

/* I_PTHREAD:
 *     This symbol, if defined, indicates to the C program that it should
 *     include <pthread.h>.
 */
/*#define   I_PTHREAD	/ **/

/* USE_ITHREADS:
 *	This symbol, if defined, indicates that Perl should be built to
 *	use the interpreter-based threading implementation.
 */
/* USE_5005THREADS:
 *	This symbol, if defined, indicates that Perl should be built to
 *	use the 5.005-based threading implementation.
 *	Only valid up to 5.8.x.
 */
/* OLD_PTHREADS_API:
 *	This symbol, if defined, indicates that Perl should
 *	be built to use the old draft POSIX threads API.
 */
/* USE_REENTRANT_API:
 *	This symbol, if defined, indicates that Perl should
 *	try to use the various _r versions of library functions.
 *	This is extremely experimental.
 */
/*#define	USE_5005THREADS		/ **/
/*#define	USE_ITHREADS		/ **/
#if defined(USE_5005THREADS) && !defined(USE_ITHREADS)
#define		USE_THREADS		/* until src is revised*/
#endif
/*#define	OLD_PTHREADS_API		/ **/
/*#define	USE_REENTRANT_API	/ **/

/* HAS_TIME:
 *	This symbol, if defined, indicates that the time() routine exists.
 */
/* Time_t:
 *	This symbol holds the type returned by time(). It can be long,
 *	or time_t on BSD sites (in which case <sys/types.h> should be
 *	included).
 */
#define HAS_TIME		/**/
#define Time_t time_t		/* Time type */

/* HAS_TIMES:
 *	This symbol, if defined, indicates that the times() routine exists.
 *	Note that this became obsolete on some systems (SUNOS), which now
 * use getrusage(). It may be necessary to include <sys/times.h>.
 */
/*#define HAS_TIMES		/ **/

/* Fpos_t:
 *	This symbol holds the type used to declare file positions in libc.
 *	It can be fpos_t, long, uint, etc... It may be necessary to include
 *	<sys/types.h> to get any typedef'ed information.
 */
#define Fpos_t int		/* File position type */

/* Gid_t_f:
 *	This symbol defines the format string used for printing a Gid_t.
 */
#define	Gid_t_f		"lu"		/**/

/* Gid_t_sign:
 *	This symbol holds the signedness of a Gid_t.
 *	1 for unsigned, -1 for signed.
 */
#define Gid_t_sign	1		/* GID sign */

/* Gid_t_size:
 *	This symbol holds the size of a Gid_t in bytes.
 */
#define Gid_t_size 4		/* GID size */

/* Gid_t:
 *	This symbol holds the return type of getgid() and the type of
 *	argument to setrgid() and related functions.  Typically,
 *	it is the type of group ids in the kernel. It can be int, ushort,
 *	gid_t, etc... It may be necessary to include <sys/types.h> to get
 *	any typedef'ed information.
 */
#define Gid_t int		/* Type for getgid(), etc... */

/* Off_t:
 *	This symbol holds the type used to declare offsets in the kernel.
 *	It can be int, long, off_t, etc... It may be necessary to include
 *	<sys/types.h> to get any typedef'ed information.
 */
/* LSEEKSIZE:
 *	This symbol holds the number of bytes used by the Off_t.
 */
/* Off_t_size:
 *	This symbol holds the number of bytes used by the Off_t.
 */
#define Off_t int		/* <offset> type */
#define LSEEKSIZE 4		/* <offset> size */
#define Off_t_size 4	/* <offset> size */

/* Mode_t:
 *	This symbol holds the type used to declare file modes
 *	for systems calls.  It is usually mode_t, but may be
 *	int or unsigned short.  It may be necessary to include <sys/types.h>
 *	to get any typedef'ed information.
 */
#define Mode_t int	 /* file mode parameter for system calls */

/* Pid_t:
 *	This symbol holds the type used to declare process ids in the kernel.
 *	It can be int, uint, pid_t, etc... It may be necessary to include
 *	<sys/types.h> to get any typedef'ed information.
 */
#define Pid_t int		/* PID type */

/* Size_t_size:
 *	This symbol holds the size of a Size_t in bytes.
 */
#define Size_t_size 4		/**/

/* Size_t:
 *	This symbol holds the type used to declare length parameters
 *	for string functions.  It is usually size_t, but may be
 *	unsigned long, int, etc.  It may be necessary to include
 *	<sys/types.h> to get any typedef'ed information.
 */
#define Size_t size_t	 /* length parameter for string functions */

/* Uid_t_f:
 *	This symbol defines the format string used for printing a Uid_t.
 */
#define	Uid_t_f		"lu"		/**/

/* Uid_t_sign:
 *	This symbol holds the signedness of a Uid_t.
 *	1 for unsigned, -1 for signed.
 */
#define Uid_t_sign	1		/* UID sign */

/* Uid_t_size:
 *	This symbol holds the size of a Uid_t in bytes.
 */
#define Uid_t_size 4		/* UID size */

/* Uid_t:
 *	This symbol holds the type used to declare user ids in the kernel.
 *	It can be int, ushort, uid_t, etc... It may be necessary to include
 *	<sys/types.h> to get any typedef'ed information.
 */
#define Uid_t int		/* UID type */

#endif

/* Generated from:
 * ce61c4f18e82f6356cdae44c5336ceac1d3253033d7449651927f5633be5c3c2 config_h.SH
 * fc611849cb5b1e14ec1687b255dac15414cc5e2e11b192d94e08136cfe277f75 uconfig.sh
 * ex: set ro: */
                                                                                                                                                                                                                                                                                                                                                  /* -*- buffer-read-only: t -*-
 * !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
 * This file is built by regen/unicode_constants.pl from Unicode data.
 * Any changes made here will be lost!
 */


#ifndef H_UNICODE_CONSTANTS   /* Guard against nested #includes */
#define H_UNICODE_CONSTANTS   1

/* This file contains #defines for the version of Unicode being used and
 * various Unicode code points.  The values the code point macros expand to
 * are the native Unicode code point, or all or portions of the UTF-8 encoding
 * for the code point.  In the former case, the macro name has the suffix
 * "_NATIVE"; otherwise, the suffix "_UTF8".
 *
 * The macros that have the suffix "_UTF8" may have further suffixes, as
 * follows:
 *  "_FIRST_BYTE" if the value is just the first byte of the UTF-8
 *                representation; the value will be a numeric constant.
 *  "_TAIL"       if instead it represents all but the first byte.  This, and
 *                with no additional suffix are both string constants */

#define UNICODE_MAJOR_VERSION   8
#define UNICODE_DOT_VERSION     0
#define UNICODE_DOT_DOT_VERSION 0


#if 'A' == 65 /* ASCII/Latin1 */
#   define LATIN_SMALL_LETTER_LONG_S_UTF8  "\xC5\xBF"    /* U+017F */

#   define COMBINING_GRAVE_ACCENT_UTF8  "\xCC\x80"    /* U+0300 */

#   define GREEK_CAPITAL_LETTER_IOTA_UTF8  "\xCE\x99"    /* U+0399 */
#   define GREEK_SMALL_LETTER_MU_UTF8  "\xCE\xBC"    /* U+03BC */

#   define LATIN_CAPITAL_LETTER_SHARP_S_UTF8  "\xE1\xBA\x9E"    /* U+1E9E */

#   define LATIN_SMALL_LIGATURE_LONG_S_T_UTF8  "\xEF\xAC\x85"    /* U+FB05 */
#   define LATIN_SMALL_LIGATURE_ST_UTF8  "\xEF\xAC\x86"    /* U+FB06 */
#   define LATIN_CAPITAL_LETTER_I_WITH_DOT_ABOVE_UTF8  "\xC4\xB0"    /* U+0130 */
#   define LATIN_SMALL_LETTER_DOTLESS_I_UTF8  "\xC4\xB1"    /* U+0131 */

#   define HYPHEN_UTF8  "\xE2\x80\x90"    /* U+2010 */
#   define BOM_UTF8_FIRST_BYTE  0xEF    /* U+FEFF */
#   define BOM_UTF8_TAIL  "\xBB\xBF"    /* U+FEFF */

#   define NBSP_NATIVE  0xA0    /* U+00A0 */
#   define NBSP_UTF8  "\xC2\xA0"    /* U+00A0 */

#   define DEL_NATIVE  0x7F    /* U+007F */
#   define CR_NATIVE  0x0D    /* U+000D */
#   define LF_NATIVE  0x0A    /* U+000A */
#   define VT_NATIVE  0x0B    /* U+000B */
#   define ESC_NATIVE  0x1B    /* U+001B */
#   define LATIN_SMALL_LETTER_SHARP_S_NATIVE  0xDF    /* U+00DF */
#   define LATIN_SMALL_LETTER_A_WITH_RING_ABOVE_NATIVE  0xE5    /* U+00E5 */
#   define LATIN_CAPITAL_LETTER_A_WITH_RING_ABOVE_NATIVE  0xC5    /* U+00C5 */
#   define LATIN_SMALL_LETTER_Y_WITH_DIAERESIS_NATIVE  0xFF    /* U+00FF */
#   define MICRO_SIGN_NATIVE  0xB5    /* U+00B5 */
#   define MAX_PRINT_A_FOR_USE_ONLY_BY_REGCOMP_DOT_C   0x7E   /* The max code point that isPRINT_A */

#endif	/* ASCII/Latin1 */

#if 'A' == 193 /* EBCDIC 1047 */ \
     && '\\' == 224 && '[' == 173 && ']' == 189 && '{' == 192 && '}' == 208 \
     && '^' == 95 && '~' == 161 && '!' == 90 && '#' == 123 && '|' == 79 \
     && '$' == 91 && '@' == 124 && '`' == 121
#   define LATIN_SMALL_LETTER_LONG_S_UTF8  "\x8F\x73"    /* U+017F */

#   define COMBINING_GRAVE_ACCENT_UTF8  "\xAF\x41"    /* U+0300 */

#   define GREEK_CAPITAL_LETTER_IOTA_UTF8  "\xB3\x68"    /* U+0399 */
#   define GREEK_SMALL_LETTER_MU_UTF8  "\xB4\x70"    /* U+03BC */

#   define LATIN_CAPITAL_LETTER_SHARP_S_UTF8  "\xBF\x63\x72"    /* U+1E9E */

#   define LATIN_SMALL_LIGATURE_LONG_S_T_UTF8  "\xDD\x72\x67\x46"    /* U+FB05 */
#   define LATIN_SMALL_LIGATURE_ST_UTF8  "\xDD\x72\x67\x47"    /* U+FB06 */
#   define LATIN_CAPITAL_LETTER_I_WITH_DOT_ABOVE_UTF8  "\x8D\x57"    /* U+0130 */
#   define LATIN_SMALL_LETTER_DOTLESS_I_UTF8  "\x8D\x58"    /* U+0131 */

#   define HYPHEN_UTF8  "\xCA\x41\x57"    /* U+2010 */
#   define BOM_UTF8_FIRST_BYTE  0xDD    /* U+FEFF */
#   define BOM_UTF8_TAIL  "\x73\x66\x73"    /* U+FEFF */

#   define NBSP_NATIVE  0x41    /* U+00A0 */
#   define NBSP_UTF8  "\x80\x41"    /* U+00A0 */

#   define DEL_NATIVE  0x07    /* U+007F */
#   define CR_NATIVE  0x0D    /* U+000D */
#   define LF_NATIVE  0x15    /* U+000A */
#   define VT_NATIVE  0x0B    /* U+000B */
#   define ESC_NATIVE  0x27    /* U+001B */
#   define LATIN_SMALL_LETTER_SHARP_S_NATIVE  0x59    /* U+00DF */
#   define LATIN_SMALL_LETTER_A_WITH_RING_ABOVE_NATIVE  0x47    /* U+00E5 */
#   define LATIN_CAPITAL_LETTER_A_WITH_RING_ABOVE_NATIVE  0x67    /* U+00C5 */
#   define LATIN_SMALL_LETTER_Y_WITH_DIAERESIS_NATIVE  0xDF    /* U+00FF */
#   define MICRO_SIGN_NATIVE  0xA0    /* U+00B5 */
#   define MAX_PRINT_A_FOR_USE_ONLY_BY_REGCOMP_DOT_C   0xF9   /* The max code point that isPRINT_A */

#endif	/* EBCDIC 1047 */

#if 'A' == 193 /* EBCDIC 037 */ \
     && '\\' == 224 && '[' == 186 && ']' == 187 && '{' == 192 && '}' == 208 \
     && '^' == 176 && '~' == 161 && '!' == 90 && '#' == 123 && '|' == 79 \
     && '$' == 91 && '@' == 124 && '`' == 121
#   define LATIN_SMALL_LETTER_LONG_S_UTF8  "\x8E\x72"    /* U+017F */

#   define COMBINING_GRAVE_ACCENT_UTF8  "\xAD\x41"    /* U+0300 */

#   define GREEK_CAPITAL_LETTER_IOTA_UTF8  "\xB2\x67"    /* U+0399 */
#   define GREEK_SMALL_LETTER_MU_UTF8  "\xB3\x6A"    /* U+03BC */

#   define LATIN_CAPITAL_LETTER_SHARP_S_UTF8  "\xBF\x62\x71"    /* U+1E9E */

#   define LATIN_SMALL_LIGATURE_LONG_S_T_UTF8  "\xDD\x71\x66\x46"    /* U+FB05 */
#   define LATIN_SMALL_LIGATURE_ST_UTF8  "\xDD\x71\x66\x47"    /* U+FB06 */
#   define LATIN_CAPITAL_LETTER_I_WITH_DOT_ABOVE_UTF8  "\x8C\x57"    /* U+0130 */
#   define LATIN_SMALL_LETTER_DOTLESS_I_UTF8  "\x8C\x58"    /* U+0131 */

#   define HYPHEN_UTF8  "\xCA\x41\x57"    /* U+2010 */
#   define BOM_UTF8_FIRST_BYTE  0xDD    /* U+FEFF */
#   define BOM_UTF8_TAIL  "\x72\x65\x72"    /* U+FEFF */

#   define NBSP_NATIVE  0x41    /* U+00A0 */
#   define NBSP_UTF8  "\x78\x41"    /* U+00A0 */

#   define DEL_NATIVE  0x07    /* U+007F */
#   define CR_NATIVE  0x0D    /* U+000D */
#   define LF_NATIVE  0x25    /* U+000A */
#   define VT_NATIVE  0x0B    /* U+000B */
#   define ESC_NATIVE  0x27    /* U+001B */
#   define LATIN_SMALL_LETTER_SHARP_S_NATIVE  0x59    /* U+00DF */
#   define LATIN_SMALL_LETTER_A_WITH_RING_ABOVE_NATIVE  0x47    /* U+00E5 */
#   define LATIN_CAPITAL_LETTER_A_WITH_RING_ABOVE_NATIVE  0x67    /* U+00C5 */
#   define LATIN_SMALL_LETTER_Y_WITH_DIAERESIS_NATIVE  0xDF    /* U+00FF */
#   define MICRO_SIGN_NATIVE  0xA0    /* U+00B5 */
#   define MAX_PRINT_A_FOR_USE_ONLY_BY_REGCOMP_DOT_C   0xF9   /* The max code point that isPRINT_A */

#endif	/* EBCDIC 037 */

/* The number of code points not matching \pC */
#define NON_OTHER_COUNT_FOR_USE_ONLY_BY_REGCOMP_DOT_C  120522

/* The highest code point that has any type of case change */
#define HIGHEST_CASE_CHANGING_CP_FOR_USE_ONLY_BY_UTF8_DOT_C  0x118DF

#endif /* H_UNICODE_CONSTANTS */

/* ex: set ro: */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    /*    utf8.h
 *
 * This file contains definitions for use with the UTF-8 encoding.  It
 * actually also works with the variant UTF-8 encoding called UTF-EBCDIC, and
 * hides almost all of the differences between these from the caller.  In other
 * words, someone should #include this file, and if the code is being compiled
 * on an EBCDIC platform, things should mostly just work.
 *
 *    Copyright (C) 2000, 2001, 2002, 2005, 2006, 2007, 2009,
 *    2010, 2011 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

#ifndef H_UTF8      /* Guard against recursive inclusion */
#define H_UTF8 1

/* Use UTF-8 as the default script encoding?
 * Turning this on will break scripts having non-UTF-8 binary
 * data (such as Latin-1) in string literals. */
#ifdef USE_UTF8_SCRIPTS
#    define USE_UTF8_IN_NAMES (!IN_BYTES)
#else
#    define USE_UTF8_IN_NAMES (PL_hints & HINT_UTF8)
#endif

#include "regcharclass.h"
#include "unicode_constants.h"

/* For to_utf8_fold_flags, q.v. */
#define FOLD_FLAGS_LOCALE       0x1
#define FOLD_FLAGS_FULL         0x2
#define FOLD_FLAGS_NOMIX_ASCII  0x4

/* For _core_swash_init(), internal core use only */
#define _CORE_SWASH_INIT_USER_DEFINED_PROPERTY 0x1
#define _CORE_SWASH_INIT_RETURN_IF_UNDEF       0x2
#define _CORE_SWASH_INIT_ACCEPT_INVLIST        0x4

/*
=head1 Unicode Support
L<perlguts/Unicode Support> has an introduction to this API.

See also L</Character classification>,
and L</Character case changing>.
Various functions outside this section also work specially with Unicode.
Search for the string "utf8" in this document.

=for apidoc is_ascii_string

This is a misleadingly-named synonym for L</is_invariant_string>.
On ASCII-ish platforms, the name isn't misleading: the ASCII-range characters
are exactly the UTF-8 invariants.  But EBCDIC machines have more invariants
than just the ASCII characters, so C<is_invariant_string> is preferred.

=cut
*/
#define is_ascii_string(s, len)     is_invariant_string(s, len)

#define uvchr_to_utf8(a,b)          uvchr_to_utf8_flags(a,b,0)
#define uvchr_to_utf8_flags(d,uv,flags)                                        \
                            uvoffuni_to_utf8_flags(d,NATIVE_TO_UNI(uv),flags)
#define utf8_to_uvchr_buf(s, e, lenp)                                          \
                     utf8n_to_uvchr(s, (U8*)(e) - (U8*)(s), lenp,              \
                                    ckWARN_d(WARN_UTF8) ? 0 : UTF8_ALLOW_ANY)

#define to_uni_fold(c, p, lenp) _to_uni_fold_flags(c, p, lenp, FOLD_FLAGS_FULL)
#define to_utf8_fold(c, p, lenp) _to_utf8_fold_flags(c, p, lenp, FOLD_FLAGS_FULL)
#define to_utf8_lower(a,b,c) _to_utf8_lower_flags(a,b,c,0)
#define to_utf8_upper(a,b,c) _to_utf8_upper_flags(a,b,c,0)
#define to_utf8_title(a,b,c) _to_utf8_title_flags(a,b,c,0)

/* Source backward compatibility. */
#define is_utf8_string_loc(s, len, ep)	is_utf8_string_loclen(s, len, ep, 0)

#define foldEQ_utf8(s1, pe1, l1, u1, s2, pe2, l2, u2) \
		    foldEQ_utf8_flags(s1, pe1, l1, u1, s2, pe2, l2, u2, 0)
#define FOLDEQ_UTF8_NOMIX_ASCII   (1 << 0)
#define FOLDEQ_LOCALE             (1 << 1)
#define FOLDEQ_S1_ALREADY_FOLDED  (1 << 2)
#define FOLDEQ_S2_ALREADY_FOLDED  (1 << 3)
#define FOLDEQ_S1_FOLDS_SANE      (1 << 4)
#define FOLDEQ_S2_FOLDS_SANE      (1 << 5)

#define ibcmp_utf8(s1, pe1, l1, u1, s2, pe2, l2, u2) \
		    cBOOL(! foldEQ_utf8(s1, pe1, l1, u1, s2, pe2, l2, u2))

#ifdef EBCDIC
/* The equivalent of these macros but implementing UTF-EBCDIC
   are in the following header file:
 */

#include "utfebcdic.h"

#else	/* ! EBCDIC */
START_EXTERN_C

/* How wide can a single UTF-8 encoded character become in bytes. */
/* NOTE: Strictly speaking Perl's UTF-8 should not be called UTF-8 since UTF-8
 * is an encoding of Unicode, and Unicode's upper limit, 0x10FFFF, can be
 * expressed with 4 bytes.  However, Perl thinks of UTF-8 as a way to encode
 * non-negative integers in a binary format, even those above Unicode */
#define UTF8_MAXBYTES 13

#ifdef DOINIT
EXTCONST unsigned char PL_utf8skip[] = {
/* 0x00 */ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, /* ascii */
/* 0x10 */ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, /* ascii */
/* 0x20 */ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, /* ascii */
/* 0x30 */ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, /* ascii */
/* 0x40 */ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, /* ascii */
/* 0x50 */ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, /* ascii */
/* 0x60 */ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, /* ascii */
/* 0x70 */ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, /* ascii */
/* 0x80 */ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, /* bogus: continuation byte */
/* 0x90 */ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, /* bogus: continuation byte */
/* 0xA0 */ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, /* bogus: continuation byte */
/* 0xB0 */ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, /* bogus: continuation byte */
/* 0xC0 */ 2,2,				    /* overlong */
/* 0xC2 */     2,2,2,2,2,2,2,2,2,2,2,2,2,2, /* U+0080 to U+03FF */
/* 0xD0 */ 2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, /* U+0400 to U+07FF */
/* 0xE0 */ 3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3, /* U+0800 to U+FFFF */
/* 0xF0 */ 4,4,4,4,4,4,4,4,5,5,5,5,6,6,	    /* above BMP to 2**31 - 1 */
           /* Perl extended (never was official UTF-8).  Up to 36 bit */
/* 0xFE */                             7,
           /* More extended, Up to 72 bits (64-bit + reserved) */
/* 0xFF */                               UTF8_MAXBYTES
};
#else
EXTCONST unsigned char PL_utf8skip[];
#endif

END_EXTERN_C

#if defined(_MSC_VER) && _MSC_VER < 1400
/* older MSVC versions have a smallish macro buffer */
#define PERL_SMALL_MACRO_BUFFER
#endif

/* Native character to/from iso-8859-1.  Are the identity functions on ASCII
 * platforms */
#ifdef PERL_SMALL_MACRO_BUFFER
#define NATIVE_TO_LATIN1(ch)     ((U8)(ch))
#define LATIN1_TO_NATIVE(ch)     ((U8)(ch))
#else
#define NATIVE_TO_LATIN1(ch)     (__ASSERT_(FITS_IN_8_BITS(ch)) ((U8) (ch)))
#define LATIN1_TO_NATIVE(ch)     (__ASSERT_(FITS_IN_8_BITS(ch)) ((U8) (ch)))
#endif

/* I8 is an intermediate version of UTF-8 used only in UTF-EBCDIC.  We thus
 * consider it to be identical to UTF-8 on ASCII platforms.  Strictly speaking
 * UTF-8 and UTF-EBCDIC are two different things, but we often conflate them
 * because they are 8-bit encodings that serve the same purpose in Perl, and
 * rarely do we need to distinguish them.  The term "NATIVE_UTF8" applies to
 * whichever one is applicable on the current platform */
#ifdef PERL_SMALL_MACRO_BUFFER
#define NATIVE_UTF8_TO_I8(ch) (ch)
#define I8_TO_NATIVE_UTF8(ch) (ch)
#else
#define NATIVE_UTF8_TO_I8(ch) (__ASSERT_(FITS_IN_8_BITS(ch)) ((U8) (ch)))
#define I8_TO_NATIVE_UTF8(ch) (__ASSERT_(FITS_IN_8_BITS(ch)) ((U8) (ch)))
#endif

/* Transforms in wide UV chars */
#define UNI_TO_NATIVE(ch)        ((UV) (ch))
#define NATIVE_TO_UNI(ch)        ((UV) (ch))

/*

 The following table is from Unicode 3.2.

 Code Points		1st Byte  2nd Byte  3rd Byte  4th Byte

   U+0000..U+007F	00..7F
   U+0080..U+07FF     * C2..DF    80..BF
   U+0800..U+0FFF	E0      * A0..BF    80..BF
   U+1000..U+CFFF       E1..EC    80..BF    80..BF
   U+D000..U+D7FF       ED        80..9F    80..BF
   U+D800..U+DFFF       ED        A0..BF    80..BF  (surrogates)
   U+E000..U+FFFF       EE..EF    80..BF    80..BF
  U+10000..U+3FFFF	F0      * 90..BF    80..BF    80..BF
  U+40000..U+FFFFF	F1..F3    80..BF    80..BF    80..BF
 U+100000..U+10FFFF	F4        80..8F    80..BF    80..BF
    Below are non-Unicode code points
 U+110000..U+13FFFF	F4        90..BF    80..BF    80..BF
 U+110000..U+1FFFFF	F5..F7    80..BF    80..BF    80..BF
 U+200000..:            F8..    * 88..BF    80..BF    80..BF    80..BF

Note the gaps before several of the byte entries above marked by '*'.  These are
caused by legal UTF-8 avoiding non-shortest encodings: it is technically
possible to UTF-8-encode a single code point in different ways, but that is
explicitly forbidden, and the shortest possible encoding should always be used
(and that is what Perl does).  The non-shortest ones are called 'overlongs'.

 */

/*
 Another way to look at it, as bits:

                  Code Points      1st Byte   2nd Byte   3rd Byte   4th Byte

                        0aaa aaaa  0aaa aaaa
              0000 0bbb bbaa aaaa  110b bbbb  10aa aaaa
              cccc bbbb bbaa aaaa  1110 cccc  10bb bbbb  10aa aaaa
 00 000d ddcc cccc bbbb bbaa aaaa  1111 0ddd  10cc cccc  10bb bbbb  10aa aaaa

As you can see, the continuation bytes all begin with C<10>, and the
leading bits of the start byte tell how many bytes there are in the
encoded character.

Perl's extended UTF-8 means we can have start bytes up to FF.

*/

/* Is the representation of the Unicode code point 'cp' the same regardless of
 * being encoded in UTF-8 or not? */
#define OFFUNI_IS_INVARIANT(cp)     isASCII(cp)

/* Is the representation of the code point 'cp' the same regardless of
 * being encoded in UTF-8 or not?  'cp' is native if < 256; Unicode otherwise
 * */
#define UVCHR_IS_INVARIANT(cp)      OFFUNI_IS_INVARIANT(cp)

/* This defines the bits that are to be in the continuation bytes of a multi-byte
 * UTF-8 encoded character that mark it is a continuation byte. */
#define UTF_CONTINUATION_MARK		0x80

/* Misleadingly named: is the UTF8-encoded byte 'c' part of a variant sequence
 * in UTF-8?  This is the inverse of UTF8_IS_INVARIANT.  The |0 makes sure this
 * isn't mistakenly called with a ptr argument */
#define UTF8_IS_CONTINUED(c)        (((U8)((c) | 0)) &  UTF_CONTINUATION_MARK)

/* Is the byte 'c' the first byte of a multi-byte UTF8-8 encoded sequence?
 * This doesn't catch invariants (they are single-byte).  It also excludes the
 * illegal overlong sequences that begin with C0 and C1.  The |0 makes sure
 * this isn't mistakenly called with a ptr argument */
#define UTF8_IS_START(c)            (((U8)((c) | 0)) >= 0xc2)

/* For use in UTF8_IS_CONTINUATION() below */
#define UTF_IS_CONTINUATION_MASK    0xC0

/* Is the byte 'c' part of a multi-byte UTF8-8 encoded sequence, and not the
 * first byte thereof?  The |0 makes sure this isn't mistakenly called with a
 * ptr argument */
#define UTF8_IS_CONTINUATION(c)                                             \
    ((((U8)((c) | 0)) & UTF_IS_CONTINUATION_MASK) == UTF_CONTINUATION_MARK)

/* Is the UTF8-encoded byte 'c' the first byte of a two byte sequence?  Use
 * UTF8_IS_NEXT_CHAR_DOWNGRADEABLE() instead if the input isn't known to
 * be well-formed.  Masking with 0xfe allows the low bit to be 0 or 1; thus
 * this matches 0xc[23].  The |0 makes sure this isn't mistakenly called with a
 * ptr argument */
#define UTF8_IS_DOWNGRADEABLE_START(c)	((((U8)((c) | 0)) & 0xfe) == 0xc2)

/* Is the UTF8-encoded byte 'c' the first byte of a sequence of bytes that
 * represent a code point > 255?  The |0 makes sure this isn't mistakenly
 * called with a ptr argument */
#define UTF8_IS_ABOVE_LATIN1(c)     (((U8)((c) | 0)) >= 0xc4)

/* This is the number of low-order bits a continuation byte in a UTF-8 encoded
 * sequence contributes to the specification of the code point.  In the bit
 * maps above, you see that the first 2 bits are a constant '10', leaving 6 of
 * real information */
#define UTF_ACCUMULATION_SHIFT		6

/* ^? is defined to be DEL on ASCII systems.  See the definition of toCTRL()
 * for more */
#define QUESTION_MARK_CTRL  DEL_NATIVE

/* Surrogates, non-character code points and above-Unicode code points are
 * problematic in some contexts.  This allows code that needs to check for
 * those to to quickly exclude the vast majority of code points it will
 * encounter */
#define isUTF8_POSSIBLY_PROBLEMATIC(c) ((U8) c >= 0xED)

#endif /* EBCDIC vs ASCII */

/* 2**UTF_ACCUMULATION_SHIFT - 1 */
#define UTF_CONTINUATION_MASK  ((U8) ((1U << UTF_ACCUMULATION_SHIFT) - 1))

/* Internal macro to be used only in this file to aid in constructing other
 * publicly accessible macros.
 * The number of bytes required to express this uv in UTF-8, for just those
 * uv's requiring 2 through 6 bytes, as these are common to all platforms and
 * word sizes.  The number of bytes needed is given by the number of leading 1
 * bits in the start byte.  There are 32 start bytes that have 2 initial 1 bits
 * (C0-DF); there are 16 that have 3 initial 1 bits (E0-EF); 8 that have 4
 * initial 1 bits (F0-F8); 4 that have 5 initial 1 bits (F9-FB), and 2 that
 * have 6 initial 1 bits (FC-FD).  The largest number a string of n bytes can
 * represent is       (the number of possible start bytes for 'n')
 *                  * (the number of possiblities for each start byte
 * The latter in turn is
 *                  2  ** (  (how many continuation bytes there are)
 *                         * (the number of bits of information each
 *                            continuation byte holds))
 *
 * If we were on a platform where we could use a fast find first set bit
 * instruction (or count leading zeros instruction) this could be replaced by
 * using that to find the log2 of the uv, and divide that by the number of bits
 * of information in each continuation byte, adjusting for large cases and how
 * much information is in a start byte for that length */
#define __COMMON_UNI_SKIP(uv)                                               \
          (UV) (uv) < (32 * (1U << (    UTF_ACCUMULATION_SHIFT))) ? 2 :     \
          (UV) (uv) < (16 * (1U << (2 * UTF_ACCUMULATION_SHIFT))) ? 3 :     \
          (UV) (uv) < ( 8 * (1U << (3 * UTF_ACCUMULATION_SHIFT))) ? 4 :     \
          (UV) (uv) < ( 4 * (1U << (4 * UTF_ACCUMULATION_SHIFT))) ? 5 :     \
          (UV) (uv) < ( 2 * (1U << (5 * UTF_ACCUMULATION_SHIFT))) ? 6 :

/* Internal macro to be used only in this file.
 * This adds to __COMMON_UNI_SKIP the details at this platform's upper range.
 * For any-sized EBCDIC platforms, or 64-bit ASCII ones, we need one more test
 * to see if just 7 bytes is needed, or if the maximum is needed.  For 32-bit
 * ASCII platforms, everything is representable by 7 bytes */
#if defined(UV_IS_QUAD) || defined(EBCDIC)
#   define __BASE_UNI_SKIP(uv) (__COMMON_UNI_SKIP(uv)                       \
     (UV) (uv) < ((UV) 1U << (6 * UTF_ACCUMULATION_SHIFT)) ? 7 : UTF8_MAXBYTES)
#else
#   define __BASE_UNI_SKIP(uv) (__COMMON_UNI_SKIP(uv) 7)
#endif

/* The next two macros use the base macro defined above, and add in the tests
 * at the low-end of the range, for just 1 byte, yielding complete macros,
 * publicly accessible. */

/* Input is a true Unicode (not-native) code point */
#define OFFUNISKIP(uv) (OFFUNI_IS_INVARIANT(uv) ? 1 : __BASE_UNI_SKIP(uv))

/*

=for apidoc Am|STRLEN|UVCHR_SKIP|UV cp
returns the number of bytes required to represent the code point C<cp> when
encoded as UTF-8.  C<cp> is a native (ASCII or EBCDIC) code point if less than
255; a Unicode code point otherwise.

=cut
 */
#define UVCHR_SKIP(uv) ( UVCHR_IS_INVARIANT(uv) ? 1 : __BASE_UNI_SKIP(uv))

/* As explained in the comments for __COMMON_UNI_SKIP, 32 start bytes with
 * UTF_ACCUMULATION_SHIFT bits of information each */
#define MAX_UTF8_TWO_BYTE (32 * (1U << UTF_ACCUMULATION_SHIFT) - 1)

/* constrained by EBCDIC which has 5 bits per continuation byte */
#define MAX_PORTABLE_UTF8_TWO_BYTE (32 * (1U << 5) - 1)

/* The maximum number of UTF-8 bytes a single Unicode character can
 * uppercase/lowercase/fold into.  Unicode guarantees that the maximum
 * expansion is UTF8_MAX_FOLD_CHAR_EXPAND characters, but any above-Unicode
 * code point will fold to itself, so we only have to look at the expansion of
 * the maximum Unicode code point.  But this number may be less than the space
 * occupied by a very large code point under Perl's extended UTF-8.  We have to
 * make it large enough to fit any single character.  (It turns out that ASCII
 * and EBCDIC differ in which is larger) */
#define UTF8_MAXBYTES_CASE	                                                \
        (UTF8_MAXBYTES >= (UTF8_MAX_FOLD_CHAR_EXPAND * OFFUNISKIP(0x10FFFF))    \
                           ? UTF8_MAXBYTES                                      \
                           : (UTF8_MAX_FOLD_CHAR_EXPAND * OFFUNISKIP(0x10FFFF)))

/* Rest of these are attributes of Unicode and perl's internals rather than the
 * encoding, or happen to be the same in both ASCII and EBCDIC (at least at
 * this level; the macros that some of these call may have different
 * definitions in the two encodings */

/* In domain restricted to ASCII, these may make more sense to the reader than
 * the ones with Latin1 in the name */
#define NATIVE_TO_ASCII(ch)      NATIVE_TO_LATIN1(ch)
#define ASCII_TO_NATIVE(ch)      LATIN1_TO_NATIVE(ch)

/* More or less misleadingly-named defines, retained for back compat */
#define NATIVE_TO_UTF(ch)        NATIVE_UTF8_TO_I8(ch)
#define NATIVE_TO_I8(ch)         NATIVE_UTF8_TO_I8(ch)
#define UTF_TO_NATIVE(ch)        I8_TO_NATIVE_UTF8(ch)
#define I8_TO_NATIVE(ch)         I8_TO_NATIVE_UTF8(ch)
#define NATIVE8_TO_UNI(ch)       NATIVE_TO_LATIN1(ch)

/* This defines the 1-bits that are to be in the first byte of a multi-byte
 * UTF-8 encoded character that mark it as a start byte and give the number of
 * bytes that comprise the character. 'len' is the number of bytes in the
 * multi-byte sequence. */
#define UTF_START_MARK(len) (((len) >  7) ? 0xFF : (0xFF & (0xFE << (7-(len)))))

/* Masks out the initial one bits in a start byte, leaving the real data ones.
 * Doesn't work on an invariant byte.  'len' is the number of bytes in the
 * multi-byte sequence that comprises the character. */
#define UTF_START_MASK(len) (((len) >= 7) ? 0x00 : (0x1F >> ((len)-2)))

/* Adds a UTF8 continuation byte 'new' of information to a running total code
 * point 'old' of all the continuation bytes so far.  This is designed to be
 * used in a loop to convert from UTF-8 to the code point represented.  Note
 * that this is asymmetric on EBCDIC platforms, in that the 'new' parameter is
 * the UTF-EBCDIC byte, whereas the 'old' parameter is a Unicode (not EBCDIC)
 * code point in process of being generated */
#define UTF8_ACCUMULATE(old, new) (((old) << UTF_ACCUMULATION_SHIFT)           \
                                   | ((NATIVE_UTF8_TO_I8((U8)new))             \
                                       & UTF_CONTINUATION_MASK))

/* If a value is anded with this, and the result is non-zero, then using the
 * original value in UTF8_ACCUMULATE will overflow, shifting bits off the left
 * */
#define UTF_ACCUMULATION_OVERFLOW_MASK					\
    (((UV) UTF_CONTINUATION_MASK) << ((sizeof(UV) * CHARBITS)           \
           - UTF_ACCUMULATION_SHIFT))

/* This works in the face of malformed UTF-8. */
#define UTF8_IS_NEXT_CHAR_DOWNGRADEABLE(s, e) (UTF8_IS_DOWNGRADEABLE_START(*s) \
                                               && ( (e) - (s) > 1)             \
                                               && UTF8_IS_CONTINUATION(*((s)+1)))

/* Number of bytes a code point occupies in UTF-8. */
#define NATIVE_SKIP(uv) UVCHR_SKIP(uv)

/* Most code which says UNISKIP is really thinking in terms of native code
 * points (0-255) plus all those beyond.  This is an imprecise term, but having
 * it means existing code continues to work.  For precision, use UVCHR_SKIP,
 * NATIVE_SKIP, or OFFUNISKIP */
#define UNISKIP(uv)   UVCHR_SKIP(uv)

/* Longer, but more accurate name */
#define UTF8_IS_ABOVE_LATIN1_START(c)     UTF8_IS_ABOVE_LATIN1(c)

/* Convert a UTF-8 variant Latin1 character to a native code point value.
 * Needs just one iteration of accumulate.  Should be used only if it is known
 * that the code point is < 256, and is not UTF-8 invariant.  Use the slower
 * but more general TWO_BYTE_UTF8_TO_NATIVE() which handles any code point
 * representable by two bytes (which turns out to be up through
 * MAX_PORTABLE_UTF8_TWO_BYTE).  The two parameters are:
 *  HI: a downgradable start byte;
 *  LO: continuation.
 * */
#define EIGHT_BIT_UTF8_TO_NATIVE(HI, LO)                                        \
    ( __ASSERT_(UTF8_IS_DOWNGRADEABLE_START(HI))                                \
      __ASSERT_(UTF8_IS_CONTINUATION(LO))                                       \
     LATIN1_TO_NATIVE(UTF8_ACCUMULATE((                                         \
                            NATIVE_UTF8_TO_I8(HI) & UTF_START_MASK(2)), (LO))))

/* Convert a two (not one) byte utf8 character to a native code point value.
 * Needs just one iteration of accumulate.  Should not be used unless it is
 * known that the two bytes are legal: 1) two-byte start, and 2) continuation.
 * Note that the result can be larger than 255 if the input character is not
 * downgradable */
#define TWO_BYTE_UTF8_TO_NATIVE(HI, LO) \
    ( __ASSERT_(PL_utf8skip[HI] == 2)                                           \
      __ASSERT_(UTF8_IS_CONTINUATION(LO))                                       \
     UNI_TO_NATIVE(UTF8_ACCUMULATE((NATIVE_UTF8_TO_I8(HI) & UTF_START_MASK(2)), \
                                   (LO))))

/* Should never be used, and be deprecated */
#define TWO_BYTE_UTF8_TO_UNI(HI, LO) NATIVE_TO_UNI(TWO_BYTE_UTF8_TO_NATIVE(HI, LO))

/*

=for apidoc Am|STRLEN|UTF8SKIP|char* s
returns the number of bytes in the UTF-8 encoded character whose first (perhaps
only) byte is pointed to by C<s>.

=cut
 */
#define UTF8SKIP(s)  PL_utf8skip[*(const U8*)(s)]
#define UTF8_SKIP(s) UTF8SKIP(s)

/* Most code that says 'UNI_' really means the native value for code points up
 * through 255 */
#define UNI_IS_INVARIANT(cp)   UVCHR_IS_INVARIANT(cp)

/* Is the byte 'c' the same character when encoded in UTF-8 as when not.  This
 * works on both UTF-8 encoded strings and non-encoded, as it returns TRUE in
 * each for the exact same set of bit patterns.  It is valid on a subset of
 * what UVCHR_IS_INVARIANT is valid on, so can just use that; and the compiler
 * should optimize out anything extraneous given the implementation of the
 * latter.  The |0 makes sure this isn't mistakenly called with a ptr argument.
 * */
#define UTF8_IS_INVARIANT(c)	UVCHR_IS_INVARIANT((c) | 0)

/* Like the above, but its name implies a non-UTF8 input, which as the comments
 * above show, doesn't matter as to its implementation */
#define NATIVE_BYTE_IS_INVARIANT(c)	UVCHR_IS_INVARIANT(c)

/* The macros in the next 4 sets are used to generate the two utf8 or utfebcdic
 * bytes from an ordinal that is known to fit into exactly two (not one) bytes;
 * it must be less than 0x3FF to work across both encodings. */

/* These two are helper macros for the other three sets, and should not be used
 * directly anywhere else.  'translate_function' is either NATIVE_TO_LATIN1
 * (which works for code points up through 0xFF) or NATIVE_TO_UNI which works
 * for any code point */
#define __BASE_TWO_BYTE_HI(c, translate_function)                               \
           (__ASSERT_(! UVCHR_IS_INVARIANT(c))                                  \
            I8_TO_NATIVE_UTF8((translate_function(c) >> UTF_ACCUMULATION_SHIFT) \
                              | UTF_START_MARK(2)))
#define __BASE_TWO_BYTE_LO(c, translate_function)                               \
             (__ASSERT_(! UVCHR_IS_INVARIANT(c))                                \
              I8_TO_NATIVE_UTF8((translate_function(c) & UTF_CONTINUATION_MASK) \
                                 | UTF_CONTINUATION_MARK))

/* The next two macros should not be used.  They were designed to be usable as
 * the case label of a switch statement, but this doesn't work for EBCDIC.  Use
 * regen/unicode_constants.pl instead */
#define UTF8_TWO_BYTE_HI_nocast(c)  __BASE_TWO_BYTE_HI(c, NATIVE_TO_UNI)
#define UTF8_TWO_BYTE_LO_nocast(c)  __BASE_TWO_BYTE_LO(c, NATIVE_TO_UNI)

/* The next two macros are used when the source should be a single byte
 * character; checked for under DEBUGGING */
#define UTF8_EIGHT_BIT_HI(c) (__ASSERT_(FITS_IN_8_BITS(c))                    \
                             ( __BASE_TWO_BYTE_HI(c, NATIVE_TO_LATIN1)))
#define UTF8_EIGHT_BIT_LO(c) (__ASSERT_(FITS_IN_8_BITS(c))                    \
                             (__BASE_TWO_BYTE_LO(c, NATIVE_TO_LATIN1)))

/* These final two macros in the series are used when the source can be any
 * code point whose UTF-8 is known to occupy 2 bytes; they are less efficient
 * than the EIGHT_BIT versions on EBCDIC platforms.  We use the logical '~'
 * operator instead of "<=" to avoid getting compiler warnings.
 * MAX_UTF8_TWO_BYTE should be exactly all one bits in the lower few
 * places, so the ~ works */
#define UTF8_TWO_BYTE_HI(c)                                                    \
       (__ASSERT_((sizeof(c) ==  1)                                            \
                  || !(((WIDEST_UTYPE)(c)) & ~MAX_UTF8_TWO_BYTE))              \
        (__BASE_TWO_BYTE_HI(c, NATIVE_TO_UNI)))
#define UTF8_TWO_BYTE_LO(c)                                                    \
       (__ASSERT_((sizeof(c) ==  1)                                            \
                  || !(((WIDEST_UTYPE)(c)) & ~MAX_UTF8_TWO_BYTE))              \
        (__BASE_TWO_BYTE_LO(c, NATIVE_TO_UNI)))

/* This is illegal in any well-formed UTF-8 in both EBCDIC and ASCII
 * as it is only in overlongs. */
#define ILLEGAL_UTF8_BYTE   I8_TO_NATIVE_UTF8(0xC1)

/*
 * 'UTF' is whether or not p is encoded in UTF8.  The names 'foo_lazy_if' stem
 * from an earlier version of these macros in which they didn't call the
 * foo_utf8() macros (i.e. were 'lazy') unless they decided that *p is the
 * beginning of a utf8 character.  Now that foo_utf8() determines that itself,
 * no need to do it again here
 */
#define isIDFIRST_lazy_if(p,UTF) ((IN_BYTES || !UTF)                \
				 ? isIDFIRST(*(p))                  \
				 : isIDFIRST_utf8((const U8*)p))
#define isWORDCHAR_lazy_if(p,UTF)   ((IN_BYTES || (!UTF))           \
				 ? isWORDCHAR(*(p))                 \
				 : isWORDCHAR_utf8((const U8*)p))
#define isALNUM_lazy_if(p,UTF)   isWORDCHAR_lazy_if(p,UTF)

#define UTF8_MAXLEN UTF8_MAXBYTES

/* A Unicode character can fold to up to 3 characters */
#define UTF8_MAX_FOLD_CHAR_EXPAND 3

#define IN_BYTES (CopHINTS_get(PL_curcop) & HINT_BYTES)

/*

=for apidoc Am|bool|DO_UTF8|SV* sv
Returns a bool giving whether or not the PV in C<sv> is to be treated as being
encoded in UTF-8.

You should use this I<after> a call to C<SvPV()> or one of its variants, in
case any call to string overloading updates the internal UTF-8 encoding flag.

=cut
*/
#define DO_UTF8(sv) (SvUTF8(sv) && !IN_BYTES)

/* Should all strings be treated as Unicode, and not just UTF-8 encoded ones?
 * Is so within 'feature unicode_strings' or 'locale :not_characters', and not
 * within 'use bytes'.  UTF-8 locales are not tested for here, but perhaps
 * could be */
#define IN_UNI_8_BIT                                                             \
	    (((CopHINTS_get(PL_curcop) & (HINT_UNI_8_BIT))                       \
               || (CopHINTS_get(PL_curcop) & HINT_LOCALE_PARTIAL                 \
                   /* -1 below is for :not_characters */                         \
                   && _is_in_locale_category(FALSE, -1)))                        \
              && ! IN_BYTES)


#define UTF8_ALLOW_EMPTY		0x0001	/* Allow a zero length string */

/* Allow first byte to be a continuation byte */
#define UTF8_ALLOW_CONTINUATION		0x0002

/* Allow second... bytes to be non-continuation bytes */
#define UTF8_ALLOW_NON_CONTINUATION	0x0004

/* expecting more bytes than were available in the string */
#define UTF8_ALLOW_SHORT		0x0008

/* Overlong sequence; i.e., the code point can be specified in fewer bytes. */
#define UTF8_ALLOW_LONG                 0x0010

#define UTF8_DISALLOW_SURROGATE		0x0020	/* Unicode surrogates */
#define UTF8_WARN_SURROGATE		0x0040

#define UTF8_DISALLOW_NONCHAR           0x0080	/* Unicode non-character */
#define UTF8_WARN_NONCHAR               0x0100	/*  code points */

#define UTF8_DISALLOW_SUPER		0x0200	/* Super-set of Unicode: code */
#define UTF8_WARN_SUPER		        0x0400	/* points above the legal max */

/* Code points which never were part of the original UTF-8 standard, which only
 * went up to 2 ** 31 - 1.  Note that these all overflow a signed 32-bit word,
 * The first byte of these code points is FE or FF on ASCII platforms.  If the
 * first byte is FF, it will overflow a 32-bit word. */
#define UTF8_DISALLOW_ABOVE_31_BIT      0x0800
#define UTF8_WARN_ABOVE_31_BIT          0x1000

/* For back compat, these old names are misleading for UTF_EBCDIC */
#define UTF8_DISALLOW_FE_FF             UTF8_DISALLOW_ABOVE_31_BIT
#define UTF8_WARN_FE_FF                 UTF8_WARN_ABOVE_31_BIT

#define UTF8_CHECK_ONLY			0x2000

/* For backwards source compatibility.  They do nothing, as the default now
 * includes what they used to mean.  The first one's meaning was to allow the
 * just the single non-character 0xFFFF */
#define UTF8_ALLOW_FFFF 0
#define UTF8_ALLOW_SURROGATE 0

#define UTF8_DISALLOW_ILLEGAL_INTERCHANGE                                       \
                       ( UTF8_DISALLOW_SUPER|UTF8_DISALLOW_NONCHAR              \
                        |UTF8_DISALLOW_SURROGATE)
#define UTF8_WARN_ILLEGAL_INTERCHANGE \
                         (UTF8_WARN_SUPER|UTF8_WARN_NONCHAR|UTF8_WARN_SURROGATE)
#define UTF8_ALLOW_ANY                                                          \
	    (~( UTF8_DISALLOW_ILLEGAL_INTERCHANGE|UTF8_DISALLOW_ABOVE_31_BIT    \
               |UTF8_WARN_ILLEGAL_INTERCHANGE|UTF8_WARN_ABOVE_31_BIT))
#define UTF8_ALLOW_ANYUV                                                        \
         (UTF8_ALLOW_EMPTY                                                      \
	  & ~(UTF8_DISALLOW_ILLEGAL_INTERCHANGE|UTF8_WARN_ILLEGAL_INTERCHANGE))
#define UTF8_ALLOW_DEFAULT		(ckWARN(WARN_UTF8) ? 0 : \
					 UTF8_ALLOW_ANYUV)

/* Several of the macros below have a second parameter that is currently
 * unused; but could be used in the future to make sure that the input is
 * well-formed. */

#define UTF8_IS_SURROGATE(s, e) cBOOL(is_SURROGATE_utf8(s))
#define UTF8_IS_REPLACEMENT(s, send) cBOOL(is_REPLACEMENT_utf8_safe(s,send))

/*		  ASCII		     EBCDIC I8
 * U+10FFFF: \xF4\x8F\xBF\xBF	\xF9\xA1\xBF\xBF\xBF	max legal Unicode
 * U+110000: \xF4\x90\x80\x80	\xF9\xA2\xA0\xA0\xA0
 * U+110001: \xF4\x90\x80\x81	\xF9\xA2\xA0\xA0\xA1
 *
 * BE AWARE that this test doesn't rule out malformed code points, in
 * particular overlongs */
#ifdef EBCDIC /* Both versions assume well-formed UTF8 */
#   define UTF8_IS_SUPER(s, e) (NATIVE_UTF8_TO_I8(* (U8*) (s)) >= 0xF9          \
                         && (NATIVE_UTF8_TO_I8(* (U8*) (s)) > 0xF9              \
                             || (NATIVE_UTF8_TO_I8(* ((U8*) (s) + 1)) >= 0xA2)))
#else
#   define UTF8_IS_SUPER(s, e) (*(U8*) (s) >= 0xF4                              \
                           && (*(U8*) (s) > 0xF4 || (*((U8*) (s) + 1) >= 0x90)))
#endif

/* These are now machine generated, and the 'given' clause is no longer
 * applicable */
#define UTF8_IS_NONCHAR_GIVEN_THAT_NON_SUPER_AND_GE_PROBLEMATIC(s, e)          \
                                                    cBOOL(is_NONCHAR_utf8(s))
#define UTF8_IS_NONCHAR(s, e)                                                  \
                UTF8_IS_NONCHAR_GIVEN_THAT_NON_SUPER_AND_GE_PROBLEMATIC(s, e)

#define UNICODE_SURROGATE_FIRST		0xD800
#define UNICODE_SURROGATE_LAST		0xDFFF
#define UNICODE_REPLACEMENT		0xFFFD
#define UNICODE_BYTE_ORDER_MARK		0xFEFF

/* Though our UTF-8 encoding can go beyond this,
 * let's be conservative and do as Unicode says. */
#define PERL_UNICODE_MAX	0x10FFFF

#define UNICODE_WARN_SURROGATE        0x0001	/* UTF-16 surrogates */
#define UNICODE_WARN_NONCHAR          0x0002	/* Non-char code points */
#define UNICODE_WARN_SUPER            0x0004	/* Above 0x10FFFF */
#define UNICODE_WARN_ABOVE_31_BIT     0x0008	/* Above 0x7FFF_FFFF */
#define UNICODE_DISALLOW_SURROGATE    0x0010
#define UNICODE_DISALLOW_NONCHAR      0x0020
#define UNICODE_DISALLOW_SUPER        0x0040
#define UNICODE_DISALLOW_ABOVE_31_BIT 0x0080
#define UNICODE_WARN_ILLEGAL_INTERCHANGE                                      \
            (UNICODE_WARN_SURROGATE|UNICODE_WARN_NONCHAR|UNICODE_WARN_SUPER)
#define UNICODE_DISALLOW_ILLEGAL_INTERCHANGE                                  \
 (UNICODE_DISALLOW_SURROGATE|UNICODE_DISALLOW_NONCHAR|UNICODE_DISALLOW_SUPER)

/* For backward source compatibility, as are now the default */
#define UNICODE_ALLOW_SURROGATE 0
#define UNICODE_ALLOW_SUPER	0
#define UNICODE_ALLOW_ANY	0

/* This matches the 2048 code points between UNICODE_SURROGATE_FIRST (0xD800) and
 * UNICODE_SURROGATE_LAST (0xDFFF) */
#define UNICODE_IS_SURROGATE(uv)        (((UV) (uv) & (~0xFFFF | 0xF800))       \
                                                                    == 0xD800)

#define UNICODE_IS_REPLACEMENT(uv)	((UV) (uv) == UNICODE_REPLACEMENT)
#define UNICODE_IS_BYTE_ORDER_MARK(uv)	((UV) (uv) == UNICODE_BYTE_ORDER_MARK)

/* Is 'uv' one of the 32 contiguous-range noncharacters? */
#define UNICODE_IS_32_CONTIGUOUS_NONCHARS(uv)      ((UV) (uv) >= 0xFDD0         \
                                                 && (UV) (uv) <= 0xFDEF)

/* Is 'uv' one of the 34 plane-ending noncharacters 0xFFFE, 0xFFFF, 0x1FFFE,
 * 0x1FFFF, ... 0x10FFFE, 0x10FFFF, given that we know that 'uv' is not above
 * the Unicode legal max */
#define UNICODE_IS_END_PLANE_NONCHAR_GIVEN_NOT_SUPER(uv)                        \
                                              (((UV) (uv) & 0xFFFE) == 0xFFFE)

#define UNICODE_IS_NONCHAR(uv)                                                  \
    (   UNICODE_IS_32_CONTIGUOUS_NONCHARS(uv)                                   \
     || (   LIKELY( ! UNICODE_IS_SUPER(uv))                                     \
         && UNICODE_IS_END_PLANE_NONCHAR_GIVEN_NOT_SUPER(uv)))

#define UNICODE_IS_SUPER(uv)    ((UV) (uv) > PERL_UNICODE_MAX)
#define UNICODE_IS_ABOVE_31_BIT(uv)    ((UV) (uv) > 0x7FFFFFFF)

#define LATIN_SMALL_LETTER_SHARP_S      LATIN_SMALL_LETTER_SHARP_S_NATIVE
#define LATIN_SMALL_LETTER_Y_WITH_DIAERESIS                                  \
                                LATIN_SMALL_LETTER_Y_WITH_DIAERESIS_NATIVE
#define MICRO_SIGN      MICRO_SIGN_NATIVE
#define LATIN_CAPITAL_LETTER_A_WITH_RING_ABOVE                               \
                            LATIN_CAPITAL_LETTER_A_WITH_RING_ABOVE_NATIVE
#define LATIN_SMALL_LETTER_A_WITH_RING_ABOVE                                 \
                                LATIN_SMALL_LETTER_A_WITH_RING_ABOVE_NATIVE
#define UNICODE_GREEK_CAPITAL_LETTER_SIGMA	0x03A3
#define UNICODE_GREEK_SMALL_LETTER_FINAL_SIGMA	0x03C2
#define UNICODE_GREEK_SMALL_LETTER_SIGMA	0x03C3
#define GREEK_SMALL_LETTER_MU                   0x03BC
#define GREEK_CAPITAL_LETTER_MU                 0x039C	/* Upper and title case
                                                           of MICRON */
#define LATIN_CAPITAL_LETTER_Y_WITH_DIAERESIS   0x0178	/* Also is title case */
#ifdef LATIN_CAPITAL_LETTER_SHARP_S_UTF8
#   define LATIN_CAPITAL_LETTER_SHARP_S	        0x1E9E
#endif
#define LATIN_CAPITAL_LETTER_I_WITH_DOT_ABOVE   0x130
#define LATIN_SMALL_LETTER_DOTLESS_I            0x131
#define LATIN_SMALL_LETTER_LONG_S               0x017F
#define LATIN_SMALL_LIGATURE_LONG_S_T           0xFB05
#define LATIN_SMALL_LIGATURE_ST                 0xFB06
#define KELVIN_SIGN                             0x212A
#define ANGSTROM_SIGN                           0x212B

#define UNI_DISPLAY_ISPRINT	0x0001
#define UNI_DISPLAY_BACKSLASH	0x0002
#define UNI_DISPLAY_QQ		(UNI_DISPLAY_ISPRINT|UNI_DISPLAY_BACKSLASH)
#define UNI_DISPLAY_REGEX	(UNI_DISPLAY_ISPRINT|UNI_DISPLAY_BACKSLASH)

#define ANYOF_FOLD_SHARP_S(node, input, end)	\
	(ANYOF_BITMAP_TEST(node, LATIN_SMALL_LETTER_SHARP_S) && \
	 (ANYOF_NONBITMAP(node)) && \
	 (ANYOF_FLAGS(node) & ANYOF_LOC_NONBITMAP_FOLD) && \
	 ((end) > (input) + 1) && \
	 isALPHA_FOLD_EQ((input)[0], 's'))

#define SHARP_S_SKIP 2

/* If you want to exclude surrogates, and beyond legal Unicode, see the blame
 * log for earlier versions which gave details for these */

/* A helper macro for isUTF8_CHAR, so use that one, and not this one.  This is
 * retained solely for backwards compatibility and may be deprecated and
 * removed in a future Perl version.
 *
 * regen/regcharclass.pl generates is_UTF8_CHAR_utf8() macros for up to these
 * number of bytes.  So this has to be coordinated with that file */
#ifdef EBCDIC
#   define IS_UTF8_CHAR_FAST(n) ((n) <= 3)
#else
#   define IS_UTF8_CHAR_FAST(n) ((n) <= 4)
#endif

#ifndef EBCDIC
/* A helper macro for isUTF8_CHAR, so use that one instead of this.  This was
 * generated by regen/regcharclass.pl, and then moved here.  The lines that
 * generated it were then commented out.  This was done solely because it takes
 * on the order of 10 minutes to generate, and is never going to change, unless
 * the generated code is improved.
 *
 * The EBCDIC versions have been cut to not cover all of legal Unicode,
 * otherwise they take too long to generate; besides there is a separate one
 * for each code page, so they are in regcharclass.h instead of here */
/*
	UTF8_CHAR: Matches legal UTF-8 encoded characters from 2 through 4 bytes

	0x80 - 0x1FFFFF
*/
/*** GENERATED CODE ***/
#define is_UTF8_CHAR_utf8_no_length_checks(s)                               \
( ( 0xC2 <= ((U8*)s)[0] && ((U8*)s)[0] <= 0xDF ) ?                          \
    ( ( ( ((U8*)s)[1] & 0xC0 ) == 0x80 ) ? 2 : 0 )                          \
: ( 0xE0 == ((U8*)s)[0] ) ?                                                 \
    ( ( ( ( ((U8*)s)[1] & 0xE0 ) == 0xA0 ) && ( ( ((U8*)s)[2] & 0xC0 ) == 0x80 ) ) ? 3 : 0 )\
: ( 0xE1 <= ((U8*)s)[0] && ((U8*)s)[0] <= 0xEF ) ?                          \
    ( ( ( ( ((U8*)s)[1] & 0xC0 ) == 0x80 ) && ( ( ((U8*)s)[2] & 0xC0 ) == 0x80 ) ) ? 3 : 0 )\
: ( 0xF0 == ((U8*)s)[0] ) ?                                                 \
    ( ( ( ( 0x90 <= ((U8*)s)[1] && ((U8*)s)[1] <= 0xBF ) && ( ( ((U8*)s)[2] & 0xC0 ) == 0x80 ) ) && ( ( ((U8*)s)[3] & 0xC0 ) == 0x80 ) ) ? 4 : 0 )\
: ( ( ( ( 0xF1 <= ((U8*)s)[0] && ((U8*)s)[0] <= 0xF7 ) && ( ( ((U8*)s)[1] & 0xC0 ) == 0x80 ) ) && ( ( ((U8*)s)[2] & 0xC0 ) == 0x80 ) ) && ( ( ((U8*)s)[3] & 0xC0 ) == 0x80 ) ) ? 4 : 0 )
#endif

/*

=for apidoc Am|STRLEN|isUTF8_CHAR|const U8 *s|const U8 *e

Returns the number of bytes beginning at C<s> which form a legal UTF-8 (or
UTF-EBCDIC) encoded character, looking no further than S<C<e - s>> bytes into
C<s>.  Returns 0 if the sequence starting at C<s> through S<C<e - 1>> is not
well-formed UTF-8.

Note that an INVARIANT character (i.e. ASCII on non-EBCDIC
machines) is a valid UTF-8 character.

=cut
*/

#define isUTF8_CHAR(s, e)   (UNLIKELY((e) <= (s))                           \
                             ? 0                                            \
                             : (UTF8_IS_INVARIANT(*s))                      \
                               ? 1                                          \
                               : UNLIKELY(((e) - (s)) < UTF8SKIP(s))        \
                                 ? 0                                        \
                                 : LIKELY(IS_UTF8_CHAR_FAST(UTF8SKIP(s)))   \
                                   ? is_UTF8_CHAR_utf8_no_length_checks(s)  \
                                   : _is_utf8_char_slow(s, e))

#define is_utf8_char_buf(buf, buf_end) isUTF8_CHAR(buf, buf_end)

/* Do not use; should be deprecated.  Use isUTF8_CHAR() instead; this is
 * retained solely for backwards compatibility */
#define IS_UTF8_CHAR(p, n)      (isUTF8_CHAR(p, (p) + (n)) == n)

#endif /* H_UTF8 */

/*
 * ex: set ts=8 sts=4 sw=4 et:
 */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    /* -*- buffer-read-only: t -*-
   !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
   This file is built by regen/warnings.pl.
   Any changes made here will be lost!
 */


#define Off(x)			((x) / 8)
#define Bit(x)			(1 << ((x) % 8))
#define IsSet(a, x)		((a)[Off(x)] & Bit(x))


#define G_WARN_OFF		0 	/* $^W == 0 */
#define G_WARN_ON		1	/* -w flag and $^W != 0 */
#define G_WARN_ALL_ON		2	/* -W flag */
#define G_WARN_ALL_OFF		4	/* -X flag */
#define G_WARN_ONCE		8	/* set if 'once' ever enabled */
#define G_WARN_ALL_MASK		(G_WARN_ALL_ON|G_WARN_ALL_OFF)

#define pWARN_STD		NULL
#define pWARN_ALL		(((STRLEN*)0)+1)    /* use warnings 'all' */
#define pWARN_NONE		(((STRLEN*)0)+2)    /* no  warnings 'all' */

#define specialWARN(x)		((x) == pWARN_STD || (x) == pWARN_ALL ||	\
				 (x) == pWARN_NONE)

/* if PL_warnhook is set to this value, then warnings die */
#define PERL_WARNHOOK_FATAL	(&PL_sv_placeholder)

/* Warnings Categories added in Perl 5.008 */

#define WARN_ALL			 0
#define WARN_CLOSURE			 1
#define WARN_DEPRECATED			 2
#define WARN_EXITING			 3
#define WARN_GLOB			 4
#define WARN_IO				 5
#define WARN_CLOSED			 6
#define WARN_EXEC			 7
#define WARN_LAYER			 8
#define WARN_NEWLINE			 9
#define WARN_PIPE			 10
#define WARN_UNOPENED			 11
#define WARN_MISC			 12
#define WARN_NUMERIC			 13
#define WARN_ONCE			 14
#define WARN_OVERFLOW			 15
#define WARN_PACK			 16
#define WARN_PORTABLE			 17
#define WARN_RECURSION			 18
#define WARN_REDEFINE			 19
#define WARN_REGEXP			 20
#define WARN_SEVERE			 21
#define WARN_DEBUGGING			 22
#define WARN_INPLACE			 23
#define WARN_INTERNAL			 24
#define WARN_MALLOC			 25
#define WARN_SIGNAL			 26
#define WARN_SUBSTR			 27
#define WARN_SYNTAX			 28
#define WARN_AMBIGUOUS			 29
#define WARN_BAREWORD			 30
#define WARN_DIGIT			 31
#define WARN_PARENTHESIS		 32
#define WARN_PRECEDENCE			 33
#define WARN_PRINTF			 34
#define WARN_PROTOTYPE			 35
#define WARN_QW				 36
#define WARN_RESERVED			 37
#define WARN_SEMICOLON			 38
#define WARN_TAINT			 39
#define WARN_THREADS			 40
#define WARN_UNINITIALIZED		 41
#define WARN_UNPACK			 42
#define WARN_UNTIE			 43
#define WARN_UTF8			 44
#define WARN_VOID			 45

/* Warnings Categories added in Perl 5.011 */

#define WARN_IMPRECISION		 46
#define WARN_ILLEGALPROTO		 47

/* Warnings Categories added in Perl 5.013 */

#define WARN_NON_UNICODE		 48
#define WARN_NONCHAR			 49
#define WARN_SURROGATE			 50

/* Warnings Categories added in Perl 5.017 */

#define WARN_EXPERIMENTAL		 51
#define WARN_EXPERIMENTAL__LEXICAL_SUBS	 52
#define WARN_EXPERIMENTAL__REGEX_SETS	 53
#define WARN_EXPERIMENTAL__SMARTMATCH	 54

/* Warnings Categories added in Perl 5.019 */

#define WARN_EXPERIMENTAL__POSTDEREF	 55
#define WARN_EXPERIMENTAL__SIGNATURES	 56
#define WARN_SYSCALLS			 57

/* Warnings Categories added in Perl 5.021 */

#define WARN_EXPERIMENTAL__BITWISE	 58
#define WARN_EXPERIMENTAL__CONST_ATTR	 59
#define WARN_EXPERIMENTAL__RE_STRICT	 60
#define WARN_EXPERIMENTAL__REFALIASING	 61
#define WARN_EXPERIMENTAL__WIN32_PERLIO	 62
#define WARN_LOCALE			 63
#define WARN_MISSING			 64
#define WARN_REDUNDANT			 65

#define WARNsize			 17
#define WARN_ALLstring			 "\125\125\125\125\125\125\125\125\125\125\125\125\125\125\125\125\125"
#define WARN_NONEstring			 "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"

#define isLEXWARN_on 	cBOOL(PL_curcop->cop_warnings != pWARN_STD)
#define isLEXWARN_off	cBOOL(PL_curcop->cop_warnings == pWARN_STD)
#define isWARN_ONCE	(PL_dowarn & (G_WARN_ON|G_WARN_ONCE))
#define isWARN_on(c,x)	(IsSet((U8 *)(c + 1), 2*(x)))
#define isWARNf_on(c,x)	(IsSet((U8 *)(c + 1), 2*(x)+1))

#define DUP_WARNINGS(p)		\
    (specialWARN(p) ? (STRLEN*)(p)	\
    : (STRLEN*)CopyD(p, PerlMemShared_malloc(sizeof(*p)+*p), sizeof(*p)+*p, \
		     			     char))

#define ckWARN(w)		Perl_ckwarn(aTHX_ packWARN(w))

/* The w1, w2 ... should be independent warnings categories; one shouldn't be
 * a subcategory of any other */

#define ckWARN2(w1,w2)		Perl_ckwarn(aTHX_ packWARN2(w1,w2))
#define ckWARN3(w1,w2,w3)	Perl_ckwarn(aTHX_ packWARN3(w1,w2,w3))
#define ckWARN4(w1,w2,w3,w4)	Perl_ckwarn(aTHX_ packWARN4(w1,w2,w3,w4))

#define ckWARN_d(w)		Perl_ckwarn_d(aTHX_ packWARN(w))
#define ckWARN2_d(w1,w2)	Perl_ckwarn_d(aTHX_ packWARN2(w1,w2))
#define ckWARN3_d(w1,w2,w3)	Perl_ckwarn_d(aTHX_ packWARN3(w1,w2,w3))
#define ckWARN4_d(w1,w2,w3,w4)	Perl_ckwarn_d(aTHX_ packWARN4(w1,w2,w3,w4))

#define WARNshift		8

#define packWARN(a)		(a                                      )

/* The a, b, ... should be independent warnings categories; one shouldn't be
 * a subcategory of any other */

#define packWARN2(a,b)		((a) | ((b)<<8)                         )
#define packWARN3(a,b,c)	((a) | ((b)<<8) | ((c)<<16)             )
#define packWARN4(a,b,c,d)	((a) | ((b)<<8) | ((c)<<16) | ((d) <<24))

#define unpackWARN1(x)		((x)        & 0xFF)
#define unpackWARN2(x)		(((x) >>8)  & 0xFF)
#define unpackWARN3(x)		(((x) >>16) & 0xFF)
#define unpackWARN4(x)		(((x) >>24) & 0xFF)

#define ckDEAD(x)							\
	   ( ! specialWARN(PL_curcop->cop_warnings) &&			\
	    ( isWARNf_on(PL_curcop->cop_warnings, WARN_ALL) || 		\
	      isWARNf_on(PL_curcop->cop_warnings, unpackWARN1(x)) ||	\
	      isWARNf_on(PL_curcop->cop_warnings, unpackWARN2(x)) ||	\
	      isWARNf_on(PL_curcop->cop_warnings, unpackWARN3(x)) ||	\
	      isWARNf_on(PL_curcop->cop_warnings, unpackWARN4(x))))

/* end of file warnings.h */

/* ex: set ro: */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      /*    utfebcdic.h
 *
 *    Copyright (C) 2001, 2002, 2003, 2005, 2006, 2007, 2009,
 *    2010, 2011 by Larry Wall, Nick Ing-Simmons, and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 * Macros to implement UTF-EBCDIC as perl's internal encoding
 * Adapted from version 7.1 of Unicode Technical Report #16:
 *  http://www.unicode.org/unicode/reports/tr16
 *
 * To summarize, the way it works is:
 * To convert an EBCDIC code point to UTF-EBCDIC:
 *  1)	convert to Unicode.  No conversion is necesary for code points above
 *      255, as Unicode and EBCDIC are identical in this range.  For smaller
 *      code points, the conversion is done by lookup in the PL_e2a table (with
 *      inverse PL_a2e) in the generated file 'ebcdic_tables.h'.  The 'a'
 *      stands for ASCII platform, meaning 0-255 Unicode.
 *  2)	convert that to a utf8-like string called I8 ('I' stands for
 *	intermediate) with variant characters occupying multiple bytes.  This
 *	step is similar to the utf8-creating step from Unicode, but the details
 *	are different.  This transformation is called UTF8-Mod.  There is a
 *	chart about the bit patterns in a comment later in this file.  But
 *	essentially here are the differences:
 *			    UTF8		I8
 *	invariant byte	    starts with 0	starts with 0 or 100
 *	continuation byte   starts with 10	starts with 101
 *	start byte	    same in both: if the code point requires N bytes,
 *			    then the leading N bits are 1, followed by a 0.  If
 *			    all 8 bits in the first byte are 1, the code point
 *			    will occupy 14 bytes (compared to 13 in Perl's
 *			    extended UTF-8).  This is incompatible with what
 *			    tr16 implies should be the representation of code
 *			    points 2**30 and above, but allows Perl to be able
 *			    to represent all code points that fit in a 64-bit
 *			    word in either our extended UTF-EBCDIC or UTF-8.
 *  3)	Use the algorithm in tr16 to convert each byte from step 2 into
 *	final UTF-EBCDIC.  This is done by table lookup from a table
 *	constructed from the algorithm, reproduced in ebcdic_tables.h as
 *	PL_utf2e, with its inverse being PL_e2utf.  They are constructed so that
 *	all EBCDIC invariants remain invariant, but no others do, and the first
 *	byte of a variant will always have its upper bit set.  But note that
 *	the upper bit of some invariants is also 1.  The table also is designed
 *	so that lexically comparing two UTF-EBCDIC-variant characters yields
 *	the Unicode code point order.  (To get native code point order, one has
 *	to convert the latin1-range characters to their native code point
 *	value.)
 *
 *  For example, the ordinal value of 'A' is 193 in EBCDIC, and also is 193 in
 *  UTF-EBCDIC.  Step 1) converts it to 65, Step 2 leaves it at 65, and Step 3
 *  converts it back to 193.  As an example of how a variant character works,
 *  take LATIN SMALL LETTER Y WITH DIAERESIS, which is typically 0xDF in
 *  EBCDIC.  Step 1 converts it to the Unicode value, 0xFF.  Step 2 converts
 *  that to two bytes = 11000111 10111111 = C7 BF, and Step 3 converts those to
 *  0x8B 0x73.
 *
 * If you're starting from Unicode, skip step 1.  For UTF-EBCDIC to straight
 * EBCDIC, reverse the steps.
 *
 * The EBCDIC invariants have been chosen to be those characters whose Unicode
 * equivalents have ordinal numbers less than 160, that is the same characters
 * that are expressible in ASCII, plus the C1 controls.  So there are 160
 * invariants instead of the 128 in UTF-8.
 *
 * The purpose of Step 3 is to make the encoding be invariant for the chosen
 * characters.  This messes up the convenient patterns found in step 2, so
 * generally, one has to undo step 3 into a temporary to use them.  However,
 * one "shadow", or parallel table, PL_utf8skip, has been constructed that
 * doesn't require undoing things.  It is such that for each byte, it says
 * how long the sequence is if that (UTF-EBCDIC) byte were to begin it
 *
 * There are actually 3 slightly different UTF-EBCDIC encodings in
 * ebcdic_tables.h, one for each of the code pages recognized by Perl.  That
 * means that there are actually three different sets of tables, one for each
 * code page.  (If Perl is compiled on platforms using another EBCDIC code
 * page, it may not compile, or Perl may silently mistake it for one of the
 * three.)
 *
 * Note that tr16 actually only specifies one version of UTF-EBCDIC, based on
 * the 1047 encoding, and which is supposed to be used for all code pages.
 * But this doesn't work.  To illustrate the problem, consider the '^' character.
 * On a 037 code page it is the single byte 176, whereas under 1047 UTF-EBCDIC
 * it is the single byte 95.  If Perl implemented tr16 exactly, it would mean
 * that changing a string containing '^' to UTF-EBCDIC would change that '^'
 * from 176 to 95 (and vice-versa), violating the rule that ASCII-range
 * characters are the same in UTF-8 or not.  Much code in Perl assumes this
 * rule.  See for example
 * http://grokbase.com/t/perl/mvs/025xf0yhmn/utf-ebcdic-for-posix-bc-malformed-utf-8-character
 * What Perl does is create a version of UTF-EBCDIC suited to each code page;
 * the one for the 1047 code page is identical to what's specified in tr16.
 * This complicates interchanging files between computers using different code
 * pages.  Best is to convert to I8 before sending them, as the I8
 * representation is the same no matter what the underlying code page is.
 *
 * Because of the way UTF-EBCDIC is constructed, the lowest 32 code points that
 * aren't equivalent to ASCII characters nor C1 controls form the set of
 * continuation bytes; the remaining 64 non-ASCII, non-control code points form
 * the potential start bytes, in order.  (However, the first 5 of these lead to
 * malformed overlongs, so there really are only 59 start bytes, and the first
 * three of the 59 are the start bytes for the Latin1 range.)  Hence the
 * UTF-EBCDIC for the smallest variant code point, 0x160, will have likely 0x41
 * as its continuation byte, provided 0x41 isn't an ASCII or C1 equivalent.
 * And its start byte will be the code point that is 37 (32+5) non-ASCII,
 * non-control code points past it.  (0 - 3F are controls, and 40 is SPACE,
 * leaving 41 as the first potentially available one.)  In contrast, on ASCII
 * platforms, the first 64 (not 32) non-ASCII code points are the continuation
 * bytes.  And the first 2 (not 5) potential start bytes form overlong
 * malformed sequences.
 *
 * EBCDIC characters above 0xFF are the same as Unicode in Perl's
 * implementation of all 3 encodings, so for those Step 1 is trivial.
 *
 * (Note that the entries for invariant characters are necessarily the same in
 * PL_e2a and PL_e2utf; likewise for their inverses.)
 *
 * UTF-EBCDIC strings are the same length or longer than UTF-8 representations
 * of the same string.  The maximum code point representable as 2 bytes in
 * UTF-EBCDIC is 0x3FFF, instead of 0x7FFF in UTF-8.
 */

START_EXTERN_C

#ifdef DOINIT

#include "ebcdic_tables.h"

#else
EXTCONST U8 PL_utf8skip[];
EXTCONST U8 PL_e2utf[];
EXTCONST U8 PL_utf2e[];
EXTCONST U8 PL_e2a[];
EXTCONST U8 PL_a2e[];
EXTCONST U8 PL_fold[];
EXTCONST U8 PL_fold_latin1[];
EXTCONST U8 PL_latin1_lc[];
EXTCONST U8 PL_mod_latin1_uc[];
#endif

END_EXTERN_C

/* EBCDIC-happy ways of converting native code to UTF-8 */

/* Use these when ch is known to be < 256 */
#define NATIVE_TO_LATIN1(ch)            (__ASSERT_(FITS_IN_8_BITS(ch)) PL_e2a[(U8)(ch)])
#define LATIN1_TO_NATIVE(ch)            (__ASSERT_(FITS_IN_8_BITS(ch)) PL_a2e[(U8)(ch)])

/* Use these on bytes */
#define NATIVE_UTF8_TO_I8(b)           (__ASSERT_(FITS_IN_8_BITS(b)) PL_e2utf[(U8)(b)])
#define I8_TO_NATIVE_UTF8(b)           (__ASSERT_(FITS_IN_8_BITS(b)) PL_utf2e[(U8)(b)])

/* Transforms in wide UV chars */
#define NATIVE_TO_UNI(ch)    (FITS_IN_8_BITS(ch) ? NATIVE_TO_LATIN1(ch) : (UV) (ch))
#define UNI_TO_NATIVE(ch)    (FITS_IN_8_BITS(ch) ? LATIN1_TO_NATIVE(ch) : (UV) (ch))

/* How wide can a single UTF-8 encoded character become in bytes. */
/* NOTE: Strictly speaking Perl's UTF-8 should not be called UTF-8 since UTF-8
 * is an encoding of Unicode, and Unicode's upper limit, 0x10FFFF, can be
 * expressed with 5 bytes.  However, Perl thinks of UTF-8 as a way to encode
 * non-negative integers in a binary format, even those above Unicode.  14 is
 * the smallest number that covers 2**64
 *
 * WARNING: This number must be in sync with the value in
 * regen/charset_translations.pl. */
#define UTF8_MAXBYTES 14

/*
  The following table is adapted from tr16, it shows the I8 encoding of Unicode code points.

        Unicode                         U32 Bit pattern 1st Byte 2nd Byte 3rd Byte 4th Byte 5th Byte 6th Byte 7th Byte
    U+0000..U+007F                     000000000xxxxxxx 0xxxxxxx
    U+0080..U+009F                     00000000100xxxxx 100xxxxx
    U+00A0..U+03FF                     000000yyyyyxxxxx 110yyyyy 101xxxxx
    U+0400..U+3FFF                     00zzzzyyyyyxxxxx 1110zzzz 101yyyyy 101xxxxx
    U+4000..U+3FFFF                 0wwwzzzzzyyyyyxxxxx 11110www 101zzzzz 101yyyyy 101xxxxx
   U+40000..U+3FFFFF            0vvwwwwwzzzzzyyyyyxxxxx 111110vv 101wwwww 101zzzzz 101yyyyy 101xxxxx
  U+400000..U+3FFFFFF       0uvvvvvwwwwwzzzzzyyyyyxxxxx 1111110u 101vvvvv 101wwwww 101zzzzz 101yyyyy 101xxxxx
 U+4000000..U+3FFFFFFF 00uuuuuvvvvvwwwwwzzzzzyyyyyxxxxx 11111110 101uuuuu 101vvvvv 101wwwww 101zzzzz 101yyyyy 101xxxxx

Beyond this, Perl uses an incompatible extension, similar to the one used in
regular UTF-8.  There are now 14 bytes.  A full 32 bits of information thus looks like this:
                                                        1st Byte  2nd-7th 8th Byte 9th Byte 10th B   11th B   12th B   13th B   14th B
U+40000000..U+FFFFFFFF ttuuuuuvvvvvwwwwwzzzzzyyyyyxxxxx 11111111 10100000 101000tt 101uuuuu 101vvvvv 101wwwww 101zzzzz 101yyyyy 101xxxxx

For 32-bit words, the 2nd through 7th bytes effectively function as leading
zeros.  Above 32 bits, these fill up, with each byte yielding 5 bits of
information, so that with 13 continuation bytes, we can handle 65 bits, just
above what a 64 bit word can hold */


/* This is a fundamental property of UTF-EBCDIC */
#define OFFUNI_IS_INVARIANT(c) (((UV)(c)) <  0xA0)

/* It turns out that on EBCDIC platforms, the invariants are the characters
 * that have ASCII equivalents, plus the C1 controls.  Since the C0 controls
 * and DELETE are ASCII, this is the same as: (isASCII(uv) || isCNTRL_L1(uv))
 * */
#define UVCHR_IS_INVARIANT(uv) cBOOL(FITS_IN_8_BITS(uv)                        \
   && (PL_charclass[(U8) (uv)] & (_CC_mask(_CC_ASCII) | _CC_mask(_CC_CNTRL))))

/* UTF-EBCDIC semantic macros - We used to transform back into I8 and then
 * compare, but now only have to do a single lookup by using a bit in
 * l1_char_class_tab.h.
 * Comments as to the meaning of each are given at their corresponding utf8.h
 * definitions. */

#define UTF8_IS_START(c)		_generic_isCC(c, _CC_UTF8_IS_START)

#define UTF_IS_CONTINUATION_MASK    0xE0

#define UTF8_IS_CONTINUATION(c)		_generic_isCC(c, _CC_UTF8_IS_CONTINUATION)

/* The above instead could be written as this:
#define UTF8_IS_CONTINUATION(c)                                                 \
            (((NATIVE_UTF8_TO_I8(c) & UTF_IS_CONTINUATION_MASK)                 \
                                                == UTF_CONTINUATION_MARK)
 */

/* Equivalent to ! UVCHR_IS_INVARIANT(c) */
#define UTF8_IS_CONTINUED(c) 		cBOOL(FITS_IN_8_BITS(c)                 \
   && ! (PL_charclass[(U8) (c)] & (_CC_mask(_CC_ASCII) | _CC_mask(_CC_CNTRL))))

#define UTF8_IS_DOWNGRADEABLE_START(c)   _generic_isCC(c,                       \
                                              _CC_UTF8_IS_DOWNGRADEABLE_START)

/* Equivalent to (UTF8_IS_START(c) && ! UTF8_IS_DOWNGRADEABLE_START(c))
 * Makes sure that the START bit is set and the DOWNGRADEABLE bit isn't */
#define UTF8_IS_ABOVE_LATIN1(c) cBOOL(FITS_IN_8_BITS(c)                         \
  && ((PL_charclass[(U8) (c)] & ( _CC_mask(_CC_UTF8_IS_START)                   \
                                 |_CC_mask(_CC_UTF8_IS_DOWNGRADEABLE_START)))   \
                        == _CC_mask(_CC_UTF8_IS_START)))

#define isUTF8_POSSIBLY_PROBLEMATIC(c)                                          \
                _generic_isCC(c, _CC_UTF8_START_BYTE_IS_FOR_AT_LEAST_SURROGATE)

#define UTF_CONTINUATION_MARK		0xA0
#define UTF_ACCUMULATION_SHIFT		5

/* ^? is defined to be APC on EBCDIC systems.  See the definition of toCTRL()
 * for more */
#define QUESTION_MARK_CTRL   LATIN1_TO_NATIVE(0x9F)

/*
 * ex: set ts=8 sts=4 sw=4 et:
 */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      /*    util.h
 *
 *    Copyright (C) 1991, 1992, 1993, 1999, 2001, 2002, 2003, 2004, 2005,
 *    2007, by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

#ifdef VMS
#  define PERL_FILE_IS_ABSOLUTE(f) \
	(*(f) == '/'							\
	 || (strchr(f,':')						\
	     || ((*(f) == '[' || *(f) == '<')				\
		 && (isWORDCHAR((f)[1]) || strchr("$-_]>",(f)[1])))))

#else		/* !VMS */
#  if defined(WIN32) || defined(__CYGWIN__)
#    define PERL_FILE_IS_ABSOLUTE(f) \
	(*(f) == '/' || *(f) == '\\'		/* UNC/rooted path */	\
	 || ((f)[0] && (f)[1] == ':'))		/* drive name */
#  else		/* !WIN32 */
#  ifdef NETWARE
#    define PERL_FILE_IS_ABSOLUTE(f) \
	(((f)[0] && (f)[1] == ':')		/* drive name */	\
	 || ((f)[0] == '\\' && (f)[1] == '\\')	/* UNC path */	\
	 ||	((f)[3] == ':'))				/* volume name, currently only sys */
#  else		/* !NETWARE */
#    if defined(DOSISH) || defined(__SYMBIAN32__)
#      define PERL_FILE_IS_ABSOLUTE(f) \
	(*(f) == '/'							\
	 || ((f)[0] && (f)[1] == ':'))		/* drive name */
#    else	/* NEITHER DOSISH NOR SYMBIANISH */
#      define PERL_FILE_IS_ABSOLUTE(f)	(*(f) == '/')
#    endif	/* DOSISH */
#   endif	/* NETWARE */
#  endif	/* WIN32 */
#endif		/* VMS */

/*
=head1 Miscellaneous Functions

=for apidoc ibcmp

This is a synonym for S<C<(! foldEQ())>>

=for apidoc ibcmp_locale

This is a synonym for S<C<(! foldEQ_locale())>>

=cut
*/
#define ibcmp(s1, s2, len)         cBOOL(! foldEQ(s1, s2, len))
#define ibcmp_locale(s1, s2, len)  cBOOL(! foldEQ_locale(s1, s2, len))

/* outside the core, perl.h undefs HAS_QUAD if IV isn't 64-bit
   We can't swap this to HAS_QUAD, because the logic here affects the type of
   perl_drand48_t below, and that is visible outside of the core.  */
#if defined(U64TYPE) && !defined(USING_MSVC6)
/* use a faster implementation when quads are available,
 * but not with VC6 on Windows */
#    define PERL_DRAND48_QUAD
#endif

#ifdef PERL_DRAND48_QUAD

/* U64 is only defined under PERL_CORE, but this needs to be visible
 * elsewhere so the definition of PerlInterpreter is complete.
 */
typedef U64TYPE perl_drand48_t;

#else

struct PERL_DRAND48_T {
    U16 seed[3];
};

typedef struct PERL_DRAND48_T perl_drand48_t;

#endif

#define PL_RANDOM_STATE_TYPE perl_drand48_t

#define Perl_drand48_init(seed) (Perl_drand48_init_r(&PL_random_state, (seed)))
#define Perl_drand48() (Perl_drand48_r(&PL_random_state))

#ifdef USE_C_BACKTRACE

typedef struct {
    /* The number of frames returned. */
    UV frame_count;
    /* The total size of the Perl_c_backtrace, including this header,
     * the frames, and the name strings. */
    UV total_bytes;
} Perl_c_backtrace_header;

typedef struct {
    void*  addr;  /* the program counter at this frame */

    /* We could use Dl_info (as used by dladdr()) for many of these but
     * that would be naughty towards non-dlfcn systems (hi there, Win32). */

    void*  symbol_addr; /* symbol address (hint: try symbol_addr - addr) */
    void*  object_base_addr;   /* base address of the shared object */

    /* The offsets are from the beginning of the whole backtrace,
     * which makes the backtrace relocatable. */
    STRLEN object_name_offset; /* pathname of the shared object */
    STRLEN object_name_size;   /* length of the pathname */
    STRLEN symbol_name_offset; /* symbol name */
    STRLEN symbol_name_size;   /* length of the symbol name */
    STRLEN source_name_offset; /* source code file name */
    STRLEN source_name_size;   /* length of the source code file name */
    STRLEN source_line_number; /* source code line number */

    /* OS X notes: atos(1) (more recently, "xcrun atos"), but the C
     * API atos() uses is unknown (private "Symbolicator" framework,
     * might require Objective-C even if the API would be known).
     * Currently we open read pipe to "xcrun atos" and parse the
     * output - quite disgusting.  And that won't work if the
     * Developer Tools isn't installed. */

    /* FreeBSD notes: execinfo.h exists, but probably would need also
     * the library -lexecinfo.  BFD exists if the pkg devel/binutils
     * has been installed, but there seems to be a known problem that
     * the "bfd.h" getting installed refers to "ansidecl.h", which
     * doesn't get installed. */

    /* Win32 notes: as moral equivalents of backtrace() + dladdr(),
     * one could possibly first use GetCurrentProcess() +
     * SymInitialize(), and then CaptureStackBackTrace() +
     * SymFromAddr(). */

    /* Note that using the compiler optimizer easily leads into much
     * of this information, like the symbol names (think inlining),
     * and source code locations getting lost or confused.  In many
     * cases keeping the debug information (-g) is necessary.
     *
     * Note that for example with gcc you can do both -O and -g.
     *
     * Note, however, that on some platforms (e.g. OSX + clang (cc))
     * backtrace() + dladdr() works fine without -g. */

    /* For example: the mere presence of <bfd.h> is no guarantee: e.g.
     * OS X has that, but BFD does not seem to work on the OSX executables.
     *
     * Another niceness would be to able to see something about
     * the function arguments, however gdb/lldb manage to do that. */
} Perl_c_backtrace_frame;

typedef struct {
    Perl_c_backtrace_header header;
    Perl_c_backtrace_frame  frame_info[1];
    /* After the header come:
     * (1) header.frame_count frames
     * (2) frame_count times the \0-terminated strings (object_name
     * and so forth).  The frames contain the pointers to the starts
     * of these strings, and the lengths of these strings. */
} Perl_c_backtrace;

#define Perl_free_c_backtrace(bt) Safefree(bt)

#endif /* USE_C_BACKTRACE */

/* Use a packed 32 bit constant "key" to start the handshake. The key defines
   ABI compatibility, and how to process the vararg list.

   Note, some bits may be taken from INTRPSIZE (but then a simple x86 AX register
   can't be used to read it) and 4 bits from API version len can also be taken,
   since v00.00.00 is 9 bytes long. XS version length should not have any bits
   taken since XS_VERSION lengths can get quite long since they are user
   selectable. These spare bits allow for additional features for the varargs
   stuff or ABI compat test flags in the future.
*/
#define HSm_APIVERLEN 0x0000001F /* perl version string won't be more than 31 chars */
#define HS_APIVERLEN_MAX HSm_APIVERLEN
#define HSm_XSVERLEN 0x0000FF00 /* if 0, not present, dont check, die if over 255*/
#define HS_XSVERLEN_MAX 0xFF
/* uses var file to set default filename for newXS_deffile to use for CvFILE */
#define HSf_SETXSUBFN 0x00000020
#define HSf_POPMARK 0x00000040 /* popmark mode or you must supply ax and items */
#define HSf_IMP_CXT 0x00000080 /* ABI, threaded/PERL_IMPLICIT_CONTEXT, pTHX_ present */
#define HSm_INTRPSIZE 0xFFFF0000 /* ABI, interp struct size */
/* A mask of bits in the key which must always match between a XS mod and interp.
   Also if all ABI bits in a key are true, skip all ABI checks, it is very
   the unlikely interp size will all 1 bits */
/* Maybe HSm_APIVERLEN one day if Perl_xs_apiversion_bootcheck is changed to a memcmp */
#define HSm_KEY_MATCH (HSm_INTRPSIZE|HSf_IMP_CXT)
#define HSf_NOCHK HSm_KEY_MATCH  /* if all ABI bits are 1 in the key, dont chk */


#define HS_GETINTERPSIZE(key) ((key) >> 16)
/* if in the future "" and NULL must be separated, XSVERLEN would be 0
means arg not present, 1 is empty string/null byte */
/* (((key) & 0x0000FF00) >> 8) is less efficient on Visual C */
#define HS_GETXSVERLEN(key) ((key) >> 8 & 0xFF)
#define HS_GETAPIVERLEN(key) ((key) & HSm_APIVERLEN)

/* internal to util.h macro to create a packed handshake key, all args must be constants */
/* U32 return = (U16 interpsize, bool cxt, bool setxsubfn, bool popmark,
   U5 (FIVE!) apiverlen, U8 xsverlen) */
#define HS_KEYp(interpsize, cxt, setxsubfn, popmark, apiverlen, xsverlen) \
    (((interpsize)  << 16) \
    | ((xsverlen) > HS_XSVERLEN_MAX \
        ? (Perl_croak_nocontext("panic: handshake overflow"), HS_XSVERLEN_MAX) \
        : (xsverlen) << 8) \
    | (cBOOL(setxsubfn) ? HSf_SETXSUBFN : 0) \
    | (cBOOL(cxt) ? HSf_IMP_CXT : 0) \
    | (cBOOL(popmark) ? HSf_POPMARK : 0) \
    | ((apiverlen) > HS_APIVERLEN_MAX \
        ? (Perl_croak_nocontext("panic: handshake overflow"), HS_APIVERLEN_MAX) \
        : (apiverlen)))
/* overflows above will optimize away unless they will execute */

/* public macro for core usage to create a packed handshake key but this is
   not public API. This more friendly version already collected all ABI info */
/* U32 return = (bool setxsubfn, bool popmark, "litteral_string_api_ver",
   "litteral_string_xs_ver") */
#ifdef PERL_IMPLICIT_CONTEXT
#  define HS_KEY(setxsubfn, popmark, apiver, xsver) \
    HS_KEYp(sizeof(PerlInterpreter), TRUE, setxsubfn, popmark, \
    sizeof("" apiver "")-1, sizeof("" xsver "")-1)
#  define HS_CXT aTHX
#else
#  define HS_KEY(setxsubfn, popmark, apiver, xsver) \
    HS_KEYp(sizeof(struct PerlHandShakeInterpreter), FALSE, setxsubfn, popmark, \
    sizeof("" apiver "")-1, sizeof("" xsver "")-1)
#  define HS_CXT cv
#endif

/*
 * ex: set ts=8 sts=4 sw=4 et:
 */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 {
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 
    16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 
    32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 
    48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
package Compress::Raw::Bzip2;

use strict ;
use warnings ;

require 5.006 ;
require Exporter;
use Carp ;

use bytes ;
our ($VERSION, $XS_VERSION, @ISA, @EXPORT, $AUTOLOAD);

$VERSION = '2.069';
$XS_VERSION = $VERSION; 
$VERSION = eval $VERSION;

@ISA = qw(Exporter);
# Items to export into callers namespace by default. Note: do not export
# names by default without a very good reason. Use EXPORT_OK instead.
# Do not simply export all your public functions/methods/constants.
@EXPORT = qw(
		BZ_RUN
		BZ_FLUSH
		BZ_FINISH

		BZ_OK
		BZ_RUN_OK
		BZ_FLUSH_OK
		BZ_FINISH_OK
		BZ_STREAM_END
		BZ_SEQUENCE_ERROR
		BZ_PARAM_ERROR
		BZ_MEM_ERROR
		BZ_DATA_ERROR
		BZ_DATA_ERROR_MAGIC
		BZ_IO_ERROR
		BZ_UNEXPECTED_EOF
		BZ_OUTBUFF_FULL
		BZ_CONFIG_ERROR

    );

sub AUTOLOAD {
    my($constname);
    ($constname = $AUTOLOAD) =~ s/.*:://;
    my ($error, $val) = constant($constname);
    Carp::croak $error if $error;
    no strict 'refs';
    *{$AUTOLOAD} = sub { $val };
    goto &{$AUTOLOAD};

}

use constant FLAG_APPEND             => 1 ;
use constant FLAG_CRC                => 2 ;
use constant FLAG_ADLER              => 4 ;
use constant FLAG_CONSUME_INPUT      => 8 ;

eval {
    require XSLoader;
    XSLoader::load('Compress::Raw::Bzip2', $XS_VERSION);
    1;
} 
or do {
    require DynaLoader;
    local @ISA = qw(DynaLoader);
    bootstrap Compress::Raw::Bzip2 $XS_VERSION ; 
};

#sub Compress::Raw::Bzip2::new
#{
#    my $class = shift ;
#    my ($ptr, $status) = _new(@_);
#    return wantarray ? (undef, $status) : undef
#        unless $ptr ;
#    my $obj = bless [$ptr], $class ;
#    return wantarray ? ($obj, $status) : $obj;
#}
#
#package Compress::Raw::Bunzip2 ;
#
#sub Compress::Raw::Bunzip2::new
#{
#    my $class = shift ;
#    my ($ptr, $status) = _new(@_);
#    return wantarray ? (undef, $status) : undef
#        unless $ptr ;
#    my $obj = bless [$ptr], $class ;
#    return wantarray ? ($obj, $status) : $obj;
#}

sub Compress::Raw::Bzip2::STORABLE_freeze
{
    my $type = ref shift;
    croak "Cannot freeze $type object\n";
}

sub Compress::Raw::Bzip2::STORABLE_thaw
{
    my $type = ref shift;
    croak "Cannot thaw $type object\n";
}

sub Compress::Raw::Bunzip2::STORABLE_freeze
{
    my $type = ref shift;
    croak "Cannot freeze $type object\n";
}

sub Compress::Raw::Bunzip2::STORABLE_thaw
{
    my $type = ref shift;
    croak "Cannot thaw $type object\n";
}


package Compress::Raw::Bzip2;

1;

__END__


=head1 NAME

Compress::Raw::Bzip2 - Low-Level Interface to bzip2 compression library

=head1 SYNOPSIS

    use Compress::Raw::Bzip2 ;

    my ($bz, $status) = new Compress::Raw::Bzip2 [OPTS]
        or die "Cannot create bzip2 object: $bzerno\n";
    
    $status = $bz->bzdeflate($input, $output);
    $status = $bz->bzflush($output);
    $status = $bz->bzclose($output);

    my ($bz, $status) = new Compress::Raw::Bunzip2 [OPTS]
        or die "Cannot create bunzip2 object: $bzerno\n";
    
    $status = $bz->bzinflate($input, $output);

    my $version = Compress::Raw::Bzip2::bzlibversion();

=head1 DESCRIPTION

C<Compress::Raw::Bzip2> provides an interface to the in-memory
compression/uncompression functions from the bzip2 compression library. 

Although the primary purpose for the existence of C<Compress::Raw::Bzip2>
is for use by the  C<IO::Compress::Bzip2> and C<IO::Compress::Bunzip2>
modules, it can be used on its own for simple compression/uncompression
tasks.

=head1 Compression

=head2 ($z, $status) = new Compress::Raw::Bzip2 $appendOutput, $blockSize100k, $workfactor;

Creates a new compression object. 

If successful, it will return the initialised compression object, C<$z>
and a C<$status> of C<BZ_OK> in a list context. In scalar context it
returns the deflation object, C<$z>, only.

If not successful, the returned compression object, C<$z>, will be
I<undef> and C<$status> will hold the a I<bzip2> error code.

Below is a list of the valid options:

=over 5

=item B<$appendOutput>

Controls whether the compressed data is appended to the output buffer in
the C<bzdeflate>, C<bzflush> and C<bzclose> methods.

Defaults to 1.

=item B<$blockSize100k>

To quote the bzip2 documentation

    blockSize100k specifies the block size to be used for compression. It
    should be a value between 1 and 9 inclusive, and the actual block size
    used is 100000 x this figure. 9 gives the best compression but takes
    most memory.

Defaults to 1.

=item B<$workfactor>

To quote the bzip2 documentation

    This parameter controls how the compression phase behaves when
    presented with worst case, highly repetitive, input data. If
    compression runs into difficulties caused by repetitive data, the
    library switches from the standard sorting algorithm to a fallback
    algorithm. The fallback is slower than the standard algorithm by
    perhaps a factor of three, but always behaves reasonably, no matter how
    bad the input.

    Lower values of workFactor reduce the amount of effort the standard
    algorithm will expend before resorting to the fallback. You should set
    this parameter carefully; too low, and many inputs will be handled by
    the fallback algorithm and so compress rather slowly, too high, and
    your average-to-worst case compression times can become very large. The
    default value of 30 gives reasonable behaviour over a wide range of
    circumstances.

    Allowable values range from 0 to 250 inclusive. 0 is a special case,
    equivalent to using the default value of 30.

Defaults to 0.

=back

=head2 $status = $bz->bzdeflate($input, $output);

Reads the contents of C<$input>, compresses it and writes the compressed
data to C<$output>.

Returns C<BZ_RUN_OK> on success and a C<bzip2> error code on failure.

If C<appendOutput> is enabled in the constructor for the bzip2 object, the
compressed data will be appended to C<$output>. If not enabled, C<$output>
will be truncated before the compressed data is written to it.

=head2 $status = $bz->bzflush($output);

Flushes any pending compressed data to C<$output>.

Returns C<BZ_RUN_OK> on success and a C<bzip2> error code on failure.

=head2 $status = $bz->bzclose($output);

Terminates the compressed data stream and flushes any pending compressed
data to C<$output>.

Returns C<BZ_STREAM_END> on success and a C<bzip2> error code on failure.

=head2 Example

=head1 Uncompression

=head2 ($z, $status) = new Compress::Raw::Bunzip2 $appendOutput, $consumeInput, $small, $verbosity, $limitOutput;

If successful, it will return the initialised uncompression object, C<$z>
and a C<$status> of C<BZ_OK> in a list context. In scalar context it
returns the deflation object, C<$z>, only.

If not successful, the returned uncompression object, C<$z>, will be
I<undef> and C<$status> will hold the a I<bzip2> error code.

Below is a list of the valid options:

=over 5

=item B<$appendOutput>

Controls whether the compressed data is appended to the output buffer in the
C<bzinflate>, C<bzflush> and C<bzclose> methods.

Defaults to 1.

=item B<$consumeInput>

=item B<$small>

To quote the bzip2 documentation

    If small is nonzero, the library will use an alternative decompression
    algorithm which uses less memory but at the cost of decompressing more
    slowly (roughly speaking, half the speed, but the maximum memory
    requirement drops to around 2300k). 

Defaults to 0.

=item B<$limitOutput>

The C<LimitOutput> option changes the behavior of the C<< $i->bzinflate >>
method so that the amount of memory used by the output buffer can be
limited. 

When C<LimitOutput> is used the size of the output buffer used will either
be the 16k or the amount of memory already allocated to C<$output>,
whichever is larger. Predicting the output size available is tricky, so
don't rely on getting an exact output buffer size.

When C<LimitOutout> is not specified C<< $i->bzinflate >> will use as much
memory as it takes to write all the uncompressed data it creates by
uncompressing the input buffer.

If C<LimitOutput> is enabled, the C<ConsumeInput> option will also be
enabled.

This option defaults to false.

=item B<$verbosity>

This parameter is ignored.

Defaults to 0.

=back

=head2 $status = $z->bzinflate($input, $output);

Uncompresses C<$input> and writes the uncompressed data to C<$output>. 

Returns C<BZ_OK> if the uncompression was successful, but the end of the
compressed data stream has not been reached. Returns C<BZ_STREAM_END> on
successful uncompression and the end of the compression stream has been
reached.

If C<consumeInput> is enabled in the constructor for the bunzip2 object,
C<$input> will have all compressed data removed from it after
uncompression. On C<BZ_OK> return this will mean that C<$input> will be an
empty string; when C<BZ_STREAM_END> C<$input> will either be an empty
string or will contain whatever data immediately followed the compressed
data stream.

If C<appendOutput> is enabled in the constructor for the bunzip2 object,
the uncompressed data will be appended to C<$output>. If not enabled,
C<$output> will be truncated before the uncompressed data is written to it.

=head1 Misc

=head2 my $version = Compress::Raw::Bzip2::bzlibversion();

Returns the version of the underlying bzip2 library.

=head1 Constants

The following bzip2 constants are exported by this module

		BZ_RUN
		BZ_FLUSH
		BZ_FINISH

		BZ_OK
		BZ_RUN_OK
		BZ_FLUSH_OK
		BZ_FINISH_OK
		BZ_STREAM_END
		BZ_SEQUENCE_ERROR
		BZ_PARAM_ERROR
		BZ_MEM_ERROR
		BZ_DATA_ERROR
		BZ_DATA_ERROR_MAGIC
		BZ_IO_ERROR
		BZ_UNEXPECTED_EOF
		BZ_OUTBUFF_FULL
		BZ_CONFIG_ERROR

=head1 SEE ALSO

L<Compress::Zlib>, L<IO::Compress::Gzip>, L<IO::Uncompress::Gunzip>, L<IO::Compress::Deflate>, L<IO::Uncompress::Inflate>, L<IO::Compress::RawDeflate>, L<IO::Uncompress::RawInflate>, L<IO::Compress::Bzip2>, L<IO::Uncompress::Bunzip2>, L<IO::Compress::Lzma>, L<IO::Uncompress::UnLzma>, L<IO::Compress::Xz>, L<IO::Uncompress::UnXz>, L<IO::Compress::Lzop>, L<IO::Uncompress::UnLzop>, L<IO::Compress::Lzf>, L<IO::Uncompress::UnLzf>, L<IO::Uncompress::AnyInflate>, L<IO::Uncompress::AnyUncompress>

L<IO::Compress::FAQ|IO::Compress::FAQ>

L<File::GlobMapper|File::GlobMapper>, L<Archive::Zip|Archive::Zip>,
L<Archive::Tar|Archive::Tar>,
L<IO::Zlib|IO::Zlib>

The primary site for the bzip2 program is F<http://www.bzip.org>.

See the module L<Compress::Bzip2|Compress::Bzip2>

=head1 AUTHOR

This module was written by Paul Marquess, F<pmqs@cpan.org>. 

=head1 MODIFICATION HISTORY

See the Changes file.

=head1 COPYRIGHT AND LICENSE

Copyright (c) 2005-2015 Paul Marquess. All rights reserved.

This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
package Compress::Raw::Zlib;

require 5.006 ;
require Exporter;
use Carp ;

use strict ;
use warnings ;
use bytes ;
our ($VERSION, $XS_VERSION, @ISA, @EXPORT, %EXPORT_TAGS, @EXPORT_OK, $AUTOLOAD, %DEFLATE_CONSTANTS, @DEFLATE_CONSTANTS);

$VERSION = '2.069';
$XS_VERSION = $VERSION; 
$VERSION = eval $VERSION;

@ISA = qw(Exporter);
%EXPORT_TAGS = ( flush     => [qw{  
                                    Z_NO_FLUSH
                                    Z_PARTIAL_FLUSH
                                    Z_SYNC_FLUSH
                                    Z_FULL_FLUSH
                                    Z_FINISH
                                    Z_BLOCK
                              }],
                 level     => [qw{  
                                    Z_NO_COMPRESSION
                                    Z_BEST_SPEED
                                    Z_BEST_COMPRESSION
                                    Z_DEFAULT_COMPRESSION
                              }],
                 strategy  => [qw{  
                                    Z_FILTERED
                                    Z_HUFFMAN_ONLY
                                    Z_RLE
                                    Z_FIXED
                                    Z_DEFAULT_STRATEGY
                              }],
                 status   => [qw{  
                                    Z_OK
                                    Z_STREAM_END
                                    Z_NEED_DICT
                                    Z_ERRNO
                                    Z_STREAM_ERROR
                                    Z_DATA_ERROR  
                                    Z_MEM_ERROR   
                                    Z_BUF_ERROR 
                                    Z_VERSION_ERROR 
                              }],                              
              );

%DEFLATE_CONSTANTS = %EXPORT_TAGS;

# Items to export into callers namespace by default. Note: do not export
# names by default without a very good reason. Use EXPORT_OK instead.
# Do not simply export all your public functions/methods/constants.
@DEFLATE_CONSTANTS = 
@EXPORT = qw(
        ZLIB_VERSION
        ZLIB_VERNUM

        
        OS_CODE

        MAX_MEM_LEVEL
        MAX_WBITS

        Z_ASCII
        Z_BEST_COMPRESSION
        Z_BEST_SPEED
        Z_BINARY
        Z_BLOCK
        Z_BUF_ERROR
        Z_DATA_ERROR
        Z_DEFAULT_COMPRESSION
        Z_DEFAULT_STRATEGY
        Z_DEFLATED
        Z_ERRNO
        Z_FILTERED
        Z_FIXED
        Z_FINISH
        Z_FULL_FLUSH
        Z_HUFFMAN_ONLY
        Z_MEM_ERROR
        Z_NEED_DICT
        Z_NO_COMPRESSION
        Z_NO_FLUSH
        Z_NULL
        Z_OK
        Z_PARTIAL_FLUSH
        Z_RLE
        Z_STREAM_END
        Z_STREAM_ERROR
        Z_SYNC_FLUSH
        Z_TREES
        Z_UNKNOWN
        Z_VERSION_ERROR

        WANT_GZIP
        WANT_GZIP_OR_ZLIB
);

push @EXPORT, qw(crc32 adler32 DEF_WBITS);

use constant WANT_GZIP           => 16;
use constant WANT_GZIP_OR_ZLIB   => 32;

sub AUTOLOAD {
    my($constname);
    ($constname = $AUTOLOAD) =~ s/.*:://;
    my ($error, $val) = constant($constname);
    Carp::croak $error if $error;
    no strict 'refs';
    *{$AUTOLOAD} = sub { $val };
    goto &{$AUTOLOAD};
}

use constant FLAG_APPEND             => 1 ;
use constant FLAG_CRC                => 2 ;
use constant FLAG_ADLER              => 4 ;
use constant FLAG_CONSUME_INPUT      => 8 ;
use constant FLAG_LIMIT_OUTPUT       => 16 ;

eval {
    require XSLoader;
    XSLoader::load('Compress::Raw::Zlib', $XS_VERSION);
    1;
} 
or do {
    require DynaLoader;
    local @ISA = qw(DynaLoader);
    bootstrap Compress::Raw::Zlib $XS_VERSION ; 
};
 

use constant Parse_any      => 0x01;
use constant Parse_unsigned => 0x02;
use constant Parse_signed   => 0x04;
use constant Parse_boolean  => 0x08;
#use constant Parse_string   => 0x10;
#use constant Parse_custom   => 0x12;

#use constant Parse_store_ref => 0x100 ;

use constant OFF_PARSED     => 0 ;
use constant OFF_TYPE       => 1 ;
use constant OFF_DEFAULT    => 2 ;
use constant OFF_FIXED      => 3 ;
use constant OFF_FIRST_ONLY => 4 ;
use constant OFF_STICKY     => 5 ;



sub ParseParameters
{
    my $level = shift || 0 ; 

    my $sub = (caller($level + 1))[3] ;
    #local $Carp::CarpLevel = 1 ;
    my $p = new Compress::Raw::Zlib::Parameters() ;
    $p->parse(@_)
        or croak "$sub: $p->{Error}" ;

    return $p;
}


sub Compress::Raw::Zlib::Parameters::new
{
    my $class = shift ;

    my $obj = { Error => '',
                Got   => {},
              } ;

    #return bless $obj, ref($class) || $class || __PACKAGE__ ;
    return bless $obj, 'Compress::Raw::Zlib::Parameters' ;
}

sub Compress::Raw::Zlib::Parameters::setError
{
    my $self = shift ;
    my $error = shift ;
    my $retval = @_ ? shift : undef ;

    $self->{Error} = $error ;
    return $retval;
}
          
#sub getError
#{
#    my $self = shift ;
#    return $self->{Error} ;
#}
          
sub Compress::Raw::Zlib::Parameters::parse
{
    my $self = shift ;

    my $default = shift ;

    my $got = $self->{Got} ;
    my $firstTime = keys %{ $got } == 0 ;

    my (@Bad) ;
    my @entered = () ;

    # Allow the options to be passed as a hash reference or
    # as the complete hash.
    if (@_ == 0) {
        @entered = () ;
    }
    elsif (@_ == 1) {
        my $href = $_[0] ;    
        return $self->setError("Expected even number of parameters, got 1")
            if ! defined $href or ! ref $href or ref $href ne "HASH" ;
 
        foreach my $key (keys %$href) {
            push @entered, $key ;
            push @entered, \$href->{$key} ;
        }
    }
    else {
        my $count = @_;
        return $self->setError("Expected even number of parameters, got $count")
            if $count % 2 != 0 ;
        
        for my $i (0.. $count / 2 - 1) {
            push @entered, $_[2* $i] ;
            push @entered, \$_[2* $i+1] ;
        }
    }


    while (my ($key, $v) = each %$default)
    {
        croak "need 4 params [@$v]"
            if @$v != 4 ;

        my ($first_only, $sticky, $type, $value) = @$v ;
        my $x ;
        $self->_checkType($key, \$value, $type, 0, \$x) 
            or return undef ;

        $key = lc $key;

        if ($firstTime || ! $sticky) {
            $got->{$key} = [0, $type, $value, $x, $first_only, $sticky] ;
        }

        $got->{$key}[OFF_PARSED] = 0 ;
    }

    for my $i (0.. @entered / 2 - 1) {
        my $key = $entered[2* $i] ;
        my $value = $entered[2* $i+1] ;

        #print "Key [$key] Value [$value]" ;
        #print defined $$value ? "[$$value]\n" : "[undef]\n";

        $key =~ s/^-// ;
        my $canonkey = lc $key;
 
        if ($got->{$canonkey} && ($firstTime ||
                                  ! $got->{$canonkey}[OFF_FIRST_ONLY]  ))
        {
            my $type = $got->{$canonkey}[OFF_TYPE] ;
            my $s ;
            $self->_checkType($key, $value, $type, 1, \$s)
                or return undef ;
            #$value = $$value unless $type & Parse_store_ref ;
            $value = $$value ;
            $got->{$canonkey} = [1, $type, $value, $s] ;
        }
        else
          { push (@Bad, $key) }
    }
 
    if (@Bad) {
        my ($bad) = join(", ", @Bad) ;
        return $self->setError("unknown key value(s) @Bad") ;
    }

    return 1;
}

sub Compress::Raw::Zlib::Parameters::_checkType
{
    my $self = shift ;

    my $key   = shift ;
    my $value = shift ;
    my $type  = shift ;
    my $validate  = shift ;
    my $output  = shift;

    #local $Carp::CarpLevel = $level ;
    #print "PARSE $type $key $value $validate $sub\n" ;
#    if ( $type & Parse_store_ref)
#    {
#        #$value = $$value
#        #    if ref ${ $value } ;
#
#        $$output = $value ;
#        return 1;
#    }

    $value = $$value ;

    if ($type & Parse_any)
    {
        $$output = $value ;
        return 1;
    }
    elsif ($type & Parse_unsigned)
    {
        return $self->setError("Parameter '$key' must be an unsigned int, got 'undef'")
            if $validate && ! defined $value ;
        return $self->setError("Parameter '$key' must be an unsigned int, got '$value'")
            if $validate && $value !~ /^\d+$/;

        $$output = defined $value ? $value : 0 ;    
        return 1;
    }
    elsif ($type & Parse_signed)
    {
        return $self->setError("Parameter '$key' must be a signed int, got 'undef'")
            if $validate && ! defined $value ;
        return $self->setError("Parameter '$key' must be a signed int, got '$value'")
            if $validate && $value !~ /^-?\d+$/;

        $$output = defined $value ? $value : 0 ;    
        return 1 ;
    }
    elsif ($type & Parse_boolean)
    {
        return $self->setError("Parameter '$key' must be an int, got '$value'")
            if $validate && defined $value && $value !~ /^\d*$/;
        $$output =  defined $value ? $value != 0 : 0 ;    
        return 1;
    }
#    elsif ($type & Parse_string)
#    {
#        $$output = defined $value ? $value : "" ;    
#        return 1;
#    }

    $$output = $value ;
    return 1;
}



sub Compress::Raw::Zlib::Parameters::parsed
{
    my $self = shift ;
    my $name = shift ;

    return $self->{Got}{lc $name}[OFF_PARSED] ;
}

sub Compress::Raw::Zlib::Parameters::value
{
    my $self = shift ;
    my $name = shift ;

    if (@_)
    {
        $self->{Got}{lc $name}[OFF_PARSED]  = 1;
        $self->{Got}{lc $name}[OFF_DEFAULT] = $_[0] ;
        $self->{Got}{lc $name}[OFF_FIXED]   = $_[0] ;
    }

    return $self->{Got}{lc $name}[OFF_FIXED] ;
}

our $OPTIONS_deflate =   
    {
        'AppendOutput'  => [1, 1, Parse_boolean,  0],
        'CRC32'         => [1, 1, Parse_boolean,  0],
        'ADLER32'       => [1, 1, Parse_boolean,  0],
        'Bufsize'       => [1, 1, Parse_unsigned, 4096],

        'Level'         => [1, 1, Parse_signed,   Z_DEFAULT_COMPRESSION()],
        'Method'        => [1, 1, Parse_unsigned, Z_DEFLATED()],
        'WindowBits'    => [1, 1, Parse_signed,   MAX_WBITS()],
        'MemLevel'      => [1, 1, Parse_unsigned, MAX_MEM_LEVEL()],
        'Strategy'      => [1, 1, Parse_unsigned, Z_DEFAULT_STRATEGY()],
        'Dictionary'    => [1, 1, Parse_any,      ""],
    };

sub Compress::Raw::Zlib::Deflate::new
{
    my $pkg = shift ;
    my ($got) = ParseParameters(0, $OPTIONS_deflate, @_);

    croak "Compress::Raw::Zlib::Deflate::new: Bufsize must be >= 1, you specified " . 
            $got->value('Bufsize')
        unless $got->value('Bufsize') >= 1;

    my $flags = 0 ;
    $flags |= FLAG_APPEND if $got->value('AppendOutput') ;
    $flags |= FLAG_CRC    if $got->value('CRC32') ;
    $flags |= FLAG_ADLER  if $got->value('ADLER32') ;

    my $windowBits =  $got->value('WindowBits');
    $windowBits += MAX_WBITS()
        if ($windowBits & MAX_WBITS()) == 0 ;

    _deflateInit($flags,
                $got->value('Level'), 
                $got->value('Method'), 
                $windowBits, 
                $got->value('MemLevel'), 
                $got->value('Strategy'), 
                $got->value('Bufsize'),
                $got->value('Dictionary')) ;

}

sub Compress::Raw::Zlib::deflateStream::STORABLE_freeze
{
    my $type = ref shift;
    croak "Cannot freeze $type object\n";
}

sub Compress::Raw::Zlib::deflateStream::STORABLE_thaw
{
    my $type = ref shift;
    croak "Cannot thaw $type object\n";
}


our $OPTIONS_inflate = 
    {
        'AppendOutput'  => [1, 1, Parse_boolean,  0],
        'LimitOutput'   => [1, 1, Parse_boolean,  0],
        'CRC32'         => [1, 1, Parse_boolean,  0],
        'ADLER32'       => [1, 1, Parse_boolean,  0],
        'ConsumeInput'  => [1, 1, Parse_boolean,  1],
        'Bufsize'       => [1, 1, Parse_unsigned, 4096],
 
        'WindowBits'    => [1, 1, Parse_signed,   MAX_WBITS()],
        'Dictionary'    => [1, 1, Parse_any,      ""],
    } ;

sub Compress::Raw::Zlib::Inflate::new
{
    my $pkg = shift ;
    my ($got) = ParseParameters(0, $OPTIONS_inflate, @_);

    croak "Compress::Raw::Zlib::Inflate::new: Bufsize must be >= 1, you specified " . 
            $got->value('Bufsize')
        unless $got->value('Bufsize') >= 1;

    my $flags = 0 ;
    $flags |= FLAG_APPEND if $got->value('AppendOutput') ;
    $flags |= FLAG_CRC    if $got->value('CRC32') ;
    $flags |= FLAG_ADLER  if $got->value('ADLER32') ;
    $flags |= FLAG_CONSUME_INPUT if $got->value('ConsumeInput') ;
    $flags |= FLAG_LIMIT_OUTPUT if $got->value('LimitOutput') ;


    my $windowBits =  $got->value('WindowBits');
    $windowBits += MAX_WBITS()
        if ($windowBits & MAX_WBITS()) == 0 ;

    _inflateInit($flags, $windowBits, $got->value('Bufsize'), 
                 $got->value('Dictionary')) ;
}

sub Compress::Raw::Zlib::inflateStream::STORABLE_freeze
{
    my $type = ref shift;
    croak "Cannot freeze $type object\n";
}

sub Compress::Raw::Zlib::inflateStream::STORABLE_thaw
{
    my $type = ref shift;
    croak "Cannot thaw $type object\n";
}

sub Compress::Raw::Zlib::InflateScan::new
{
    my $pkg = shift ;
    my ($got) = ParseParameters(0,
                    {
                        'CRC32'         => [1, 1, Parse_boolean,  0],
                        'ADLER32'       => [1, 1, Parse_boolean,  0],
                        'Bufsize'       => [1, 1, Parse_unsigned, 4096],
                 
                        'WindowBits'    => [1, 1, Parse_signed,   -MAX_WBITS()],
                        'Dictionary'    => [1, 1, Parse_any,      ""],
            }, @_) ;


    croak "Compress::Raw::Zlib::InflateScan::new: Bufsize must be >= 1, you specified " . 
            $got->value('Bufsize')
        unless $got->value('Bufsize') >= 1;

    my $flags = 0 ;
    #$flags |= FLAG_APPEND if $got->value('AppendOutput') ;
    $flags |= FLAG_CRC    if $got->value('CRC32') ;
    $flags |= FLAG_ADLER  if $got->value('ADLER32') ;
    #$flags |= FLAG_CONSUME_INPUT if $got->value('ConsumeInput') ;

    _inflateScanInit($flags, $got->value('WindowBits'), $got->value('Bufsize'), 
                 '') ;
}

sub Compress::Raw::Zlib::inflateScanStream::createDeflateStream
{
    my $pkg = shift ;
    my ($got) = ParseParameters(0,
            {
                'AppendOutput'  => [1, 1, Parse_boolean,  0],
                'CRC32'         => [1, 1, Parse_boolean,  0],
                'ADLER32'       => [1, 1, Parse_boolean,  0],
                'Bufsize'       => [1, 1, Parse_unsigned, 4096],
 
                'Level'         => [1, 1, Parse_signed,   Z_DEFAULT_COMPRESSION()],
                'Method'        => [1, 1, Parse_unsigned, Z_DEFLATED()],
                'WindowBits'    => [1, 1, Parse_signed,   - MAX_WBITS()],
                'MemLevel'      => [1, 1, Parse_unsigned, MAX_MEM_LEVEL()],
                'Strategy'      => [1, 1, Parse_unsigned, Z_DEFAULT_STRATEGY()],
            }, @_) ;

    croak "Compress::Raw::Zlib::InflateScan::createDeflateStream: Bufsize must be >= 1, you specified " . 
            $got->value('Bufsize')
        unless $got->value('Bufsize') >= 1;

    my $flags = 0 ;
    $flags |= FLAG_APPEND if $got->value('AppendOutput') ;
    $flags |= FLAG_CRC    if $got->value('CRC32') ;
    $flags |= FLAG_ADLER  if $got->value('ADLER32') ;

    $pkg->_createDeflateStream($flags,
                $got->value('Level'), 
                $got->value('Method'), 
                $got->value('WindowBits'), 
                $got->value('MemLevel'), 
                $got->value('Strategy'), 
                $got->value('Bufsize'),
                ) ;

}

sub Compress::Raw::Zlib::inflateScanStream::inflate
{
    my $self = shift ;
    my $buffer = $_[1];
    my $eof = $_[2];

    my $status = $self->scan(@_);

    if ($status == Z_OK() && $_[2]) {
        my $byte = ' ';
        
        $status = $self->scan(\$byte, $_[1]) ;
    }
    
    return $status ;
}

sub Compress::Raw::Zlib::deflateStream::deflateParams
{
    my $self = shift ;
    my ($got) = ParseParameters(0, {
                'Level'      => [1, 1, Parse_signed,   undef],
                'Strategy'   => [1, 1, Parse_unsigned, undef],
                'Bufsize'    => [1, 1, Parse_unsigned, undef],
                }, 
                @_) ;

    croak "Compress::Raw::Zlib::deflateParams needs Level and/or Strategy"
        unless $got->parsed('Level') + $got->parsed('Strategy') +
            $got->parsed('Bufsize');

    croak "Compress::Raw::Zlib::Inflate::deflateParams: Bufsize must be >= 1, you specified " . 
            $got->value('Bufsize')
        if $got->parsed('Bufsize') && $got->value('Bufsize') <= 1;

    my $flags = 0;
    $flags |= 1 if $got->parsed('Level') ;
    $flags |= 2 if $got->parsed('Strategy') ;
    $flags |= 4 if $got->parsed('Bufsize') ;

    $self->_deflateParams($flags, $got->value('Level'), 
                          $got->value('Strategy'), $got->value('Bufsize'));

}


1;
__END__


=head1 NAME

Compress::Raw::Zlib - Low-Level Interface to zlib compression library

=head1 SYNOPSIS

    use Compress::Raw::Zlib ;

    ($d, $status) = new Compress::Raw::Zlib::Deflate( [OPT] ) ;
    $status = $d->deflate($input, $output) ;
    $status = $d->flush($output [, $flush_type]) ;
    $d->deflateReset() ;
    $d->deflateParams(OPTS) ;
    $d->deflateTune(OPTS) ;
    $d->dict_adler() ;
    $d->crc32() ;
    $d->adler32() ;
    $d->total_in() ;
    $d->total_out() ;
    $d->msg() ;
    $d->get_Strategy();
    $d->get_Level();
    $d->get_BufSize();

    ($i, $status) = new Compress::Raw::Zlib::Inflate( [OPT] ) ;
    $status = $i->inflate($input, $output [, $eof]) ;
    $status = $i->inflateSync($input) ;
    $i->inflateReset() ;
    $i->dict_adler() ;
    $d->crc32() ;
    $d->adler32() ;
    $i->total_in() ;
    $i->total_out() ;
    $i->msg() ;
    $d->get_BufSize();

    $crc = adler32($buffer [,$crc]) ;
    $crc = crc32($buffer [,$crc]) ;

    $crc = crc32_combine($crc1, $crc2, $len2);
    $adler = adler32_combine($adler1, $adler2, $len2);

    my $version = Compress::Raw::Zlib::zlib_version();
    my $flags = Compress::Raw::Zlib::zlibCompileFlags();

=head1 DESCRIPTION

The I<Compress::Raw::Zlib> module provides a Perl interface to the I<zlib>
compression library (see L</AUTHOR> for details about where to get
I<zlib>). 

=head1 Compress::Raw::Zlib::Deflate

This section defines an interface that allows in-memory compression using
the I<deflate> interface provided by zlib.

Here is a definition of the interface available:

=head2 B<($d, $status) = new Compress::Raw::Zlib::Deflate( [OPT] ) >

Initialises a deflation object. 

If you are familiar with the I<zlib> library, it combines the
features of the I<zlib> functions C<deflateInit>, C<deflateInit2>
and C<deflateSetDictionary>.

If successful, it will return the initialised deflation object, C<$d>
and a C<$status> of C<Z_OK> in a list context. In scalar context it
returns the deflation object, C<$d>, only.

If not successful, the returned deflation object, C<$d>, will be
I<undef> and C<$status> will hold the a I<zlib> error code.

The function optionally takes a number of named options specified as
C<< Name => value >> pairs. This allows individual options to be
tailored without having to specify them all in the parameter list.

For backward compatibility, it is also possible to pass the parameters
as a reference to a hash containing the name=>value pairs.

Below is a list of the valid options:

=over 5

=item B<-Level>

Defines the compression level. Valid values are 0 through 9,
C<Z_NO_COMPRESSION>, C<Z_BEST_SPEED>, C<Z_BEST_COMPRESSION>, and
C<Z_DEFAULT_COMPRESSION>.

The default is C<Z_DEFAULT_COMPRESSION>.

=item B<-Method>

Defines the compression method. The only valid value at present (and
the default) is C<Z_DEFLATED>.

=item B<-WindowBits>

To compress an RFC 1950 data stream, set C<WindowBits> to a positive
number between 8 and 15.

To compress an RFC 1951 data stream, set C<WindowBits> to C<-MAX_WBITS>.

To compress an RFC 1952 data stream (i.e. gzip), set C<WindowBits> to
C<WANT_GZIP>.

For a definition of the meaning and valid values for C<WindowBits>
refer to the I<zlib> documentation for I<deflateInit2>.

Defaults to C<MAX_WBITS>.

=item B<-MemLevel>

For a definition of the meaning and valid values for C<MemLevel>
refer to the I<zlib> documentation for I<deflateInit2>.

Defaults to MAX_MEM_LEVEL.

=item B<-Strategy>

Defines the strategy used to tune the compression. The valid values are
C<Z_DEFAULT_STRATEGY>, C<Z_FILTERED>, C<Z_RLE>, C<Z_FIXED> and
C<Z_HUFFMAN_ONLY>.

The default is C<Z_DEFAULT_STRATEGY>.

=item B<-Dictionary>

When a dictionary is specified I<Compress::Raw::Zlib> will automatically
call C<deflateSetDictionary> directly after calling C<deflateInit>. The
Adler32 value for the dictionary can be obtained by calling the method 
C<$d-E<gt>dict_adler()>.

The default is no dictionary.

=item B<-Bufsize>

Sets the initial size for the output buffer used by the C<$d-E<gt>deflate>
and C<$d-E<gt>flush> methods. If the buffer has to be
reallocated to increase the size, it will grow in increments of
C<Bufsize>.

The default buffer size is 4096.

=item B<-AppendOutput>

This option controls how data is written to the output buffer by the
C<$d-E<gt>deflate> and C<$d-E<gt>flush> methods.

If the C<AppendOutput> option is set to false, the output buffers in the
C<$d-E<gt>deflate> and C<$d-E<gt>flush>  methods will be truncated before
uncompressed data is written to them.

If the option is set to true, uncompressed data will be appended to the
output buffer in the C<$d-E<gt>deflate> and C<$d-E<gt>flush> methods.

This option defaults to false.

=item B<-CRC32>

If set to true, a crc32 checksum of the uncompressed data will be
calculated. Use the C<$d-E<gt>crc32> method to retrieve this value.

This option defaults to false.

=item B<-ADLER32>

If set to true, an adler32 checksum of the uncompressed data will be
calculated. Use the C<$d-E<gt>adler32> method to retrieve this value.

This option defaults to false.

=back

Here is an example of using the C<Compress::Raw::Zlib::Deflate> optional
parameter list to override the default buffer size and compression
level. All other options will take their default values.

    my $d = new Compress::Raw::Zlib::Deflate ( -Bufsize => 300, 
                                               -Level   => Z_BEST_SPEED ) ;

=head2 B<$status = $d-E<gt>deflate($input, $output)>

Deflates the contents of C<$input> and writes the compressed data to
C<$output>.

The C<$input> and C<$output> parameters can be either scalars or scalar
references.

When finished, C<$input> will be completely processed (assuming there
were no errors). If the deflation was successful it writes the deflated
data to C<$output> and returns a status value of C<Z_OK>.

On error, it returns a I<zlib> error code.

If the C<AppendOutput> option is set to true in the constructor for
the C<$d> object, the compressed data will be appended to C<$output>. If
it is false, C<$output> will be truncated before any compressed data is
written to it.

B<Note>: This method will not necessarily write compressed data to
C<$output> every time it is called. So do not assume that there has been
an error if the contents of C<$output> is empty on returning from
this method. As long as the return code from the method is C<Z_OK>,
the deflate has succeeded.

=head2 B<$status = $d-E<gt>flush($output [, $flush_type]) >

Typically used to finish the deflation. Any pending output will be
written to C<$output>.

Returns C<Z_OK> if successful.

Note that flushing can seriously degrade the compression ratio, so it
should only be used to terminate a decompression (using C<Z_FINISH>) or
when you want to create a I<full flush point> (using C<Z_FULL_FLUSH>).

By default the C<flush_type> used is C<Z_FINISH>. Other valid values
for C<flush_type> are C<Z_NO_FLUSH>, C<Z_PARTIAL_FLUSH>, C<Z_SYNC_FLUSH>
and C<Z_FULL_FLUSH>. It is strongly recommended that you only set the
C<flush_type> parameter if you fully understand the implications of
what it does. See the C<zlib> documentation for details.

If the C<AppendOutput> option is set to true in the constructor for
the C<$d> object, the compressed data will be appended to C<$output>. If
it is false, C<$output> will be truncated before any compressed data is
written to it.

=head2 B<$status = $d-E<gt>deflateReset() >

This method will reset the deflation object C<$d>. It can be used when you
are compressing multiple data streams and want to use the same object to
compress each of them. It should only be used once the previous data stream
has been flushed successfully, i.e. a call to C<< $d->flush(Z_FINISH) >> has
returned C<Z_OK>.

Returns C<Z_OK> if successful.

=head2 B<$status = $d-E<gt>deflateParams([OPT])>

Change settings for the deflate object C<$d>.

The list of the valid options is shown below. Options not specified
will remain unchanged.

=over 5

=item B<-Level>

Defines the compression level. Valid values are 0 through 9,
C<Z_NO_COMPRESSION>, C<Z_BEST_SPEED>, C<Z_BEST_COMPRESSION>, and
C<Z_DEFAULT_COMPRESSION>.

=item B<-Strategy>

Defines the strategy used to tune the compression. The valid values are
C<Z_DEFAULT_STRATEGY>, C<Z_FILTERED> and C<Z_HUFFMAN_ONLY>. 

=item B<-BufSize>

Sets the initial size for the output buffer used by the C<$d-E<gt>deflate>
and C<$d-E<gt>flush> methods. If the buffer has to be
reallocated to increase the size, it will grow in increments of
C<Bufsize>.

=back

=head2 B<$status = $d-E<gt>deflateTune($good_length, $max_lazy, $nice_length, $max_chain)>

Tune the internal settings for the deflate object C<$d>. This option is
only available if you are running zlib 1.2.2.3 or better.

Refer to the documentation in zlib.h for instructions on how to fly
C<deflateTune>.

=head2 B<$d-E<gt>dict_adler()>

Returns the adler32 value for the dictionary.

=head2 B<$d-E<gt>crc32()>

Returns the crc32 value for the uncompressed data to date. 

If the C<CRC32> option is not enabled in the constructor for this object,
this method will always return 0;

=head2 B<$d-E<gt>adler32()>

Returns the adler32 value for the uncompressed data to date. 

=head2 B<$d-E<gt>msg()>

Returns the last error message generated by zlib.

=head2 B<$d-E<gt>total_in()>

Returns the total number of bytes uncompressed bytes input to deflate.

=head2 B<$d-E<gt>total_out()>

Returns the total number of compressed bytes output from deflate.

=head2 B<$d-E<gt>get_Strategy()>

Returns the deflation strategy currently used. Valid values are
C<Z_DEFAULT_STRATEGY>, C<Z_FILTERED> and C<Z_HUFFMAN_ONLY>. 

=head2 B<$d-E<gt>get_Level()>

Returns the compression level being used. 

=head2 B<$d-E<gt>get_BufSize()>

Returns the buffer size used to carry out the compression.

=head2 Example

Here is a trivial example of using C<deflate>. It simply reads standard
input, deflates it and writes it to standard output.

    use strict ;
    use warnings ;

    use Compress::Raw::Zlib ;

    binmode STDIN;
    binmode STDOUT;
    my $x = new Compress::Raw::Zlib::Deflate
       or die "Cannot create a deflation stream\n" ;

    my ($output, $status) ;
    while (<>)
    {
        $status = $x->deflate($_, $output) ;
    
        $status == Z_OK
            or die "deflation failed\n" ;
    
        print $output ;
    }
    
    $status = $x->flush($output) ;
    
    $status == Z_OK
        or die "deflation failed\n" ;
    
    print $output ;

=head1 Compress::Raw::Zlib::Inflate

This section defines an interface that allows in-memory uncompression using
the I<inflate> interface provided by zlib.

Here is a definition of the interface:

=head2 B< ($i, $status) = new Compress::Raw::Zlib::Inflate( [OPT] ) >

Initialises an inflation object. 

In a list context it returns the inflation object, C<$i>, and the
I<zlib> status code (C<$status>). In a scalar context it returns the
inflation object only.

If successful, C<$i> will hold the inflation object and C<$status> will
be C<Z_OK>.

If not successful, C<$i> will be I<undef> and C<$status> will hold the
I<zlib> error code.

The function optionally takes a number of named options specified as
C<< -Name => value >> pairs. This allows individual options to be
tailored without having to specify them all in the parameter list.

For backward compatibility, it is also possible to pass the parameters
as a reference to a hash containing the C<< name=>value >> pairs.

Here is a list of the valid options:

=over 5

=item B<-WindowBits>

To uncompress an RFC 1950 data stream, set C<WindowBits> to a positive
number between 8 and 15.

To uncompress an RFC 1951 data stream, set C<WindowBits> to C<-MAX_WBITS>.

To uncompress an RFC 1952 data stream (i.e. gzip), set C<WindowBits> to
C<WANT_GZIP>.

To auto-detect and uncompress an RFC 1950 or RFC 1952 data stream (i.e.
gzip), set C<WindowBits> to C<WANT_GZIP_OR_ZLIB>.

For a full definition of the meaning and valid values for C<WindowBits>
refer to the I<zlib> documentation for I<inflateInit2>.

Defaults to C<MAX_WBITS>.

=item B<-Bufsize>

Sets the initial size for the output buffer used by the C<$i-E<gt>inflate>
method. If the output buffer in this method has to be reallocated to
increase the size, it will grow in increments of C<Bufsize>.

Default is 4096.

=item B<-Dictionary>

The default is no dictionary.

=item B<-AppendOutput>

This option controls how data is written to the output buffer by the
C<$i-E<gt>inflate> method.

If the option is set to false, the output buffer in the C<$i-E<gt>inflate>
method will be truncated before uncompressed data is written to it.

If the option is set to true, uncompressed data will be appended to the
output buffer by the C<$i-E<gt>inflate> method.

This option defaults to false.

=item B<-CRC32>

If set to true, a crc32 checksum of the uncompressed data will be
calculated. Use the C<$i-E<gt>crc32> method to retrieve this value.

This option defaults to false.

=item B<-ADLER32>

If set to true, an adler32 checksum of the uncompressed data will be
calculated. Use the C<$i-E<gt>adler32> method to retrieve this value.

This option defaults to false.

=item B<-ConsumeInput>

If set to true, this option will remove compressed data from the input
buffer of the C<< $i->inflate >> method as the inflate progresses.

This option can be useful when you are processing compressed data that is
embedded in another file/buffer. In this case the data that immediately
follows the compressed stream will be left in the input buffer.

This option defaults to true.

=item B<-LimitOutput>

The C<LimitOutput> option changes the behavior of the C<< $i->inflate >>
method so that the amount of memory used by the output buffer can be
limited. 

When C<LimitOutput> is used the size of the output buffer used will either
be the value of the C<Bufsize> option or the amount of memory already
allocated to C<$output>, whichever is larger. Predicting the output size
available is tricky, so don't rely on getting an exact output buffer size.

When C<LimitOutout> is not specified C<< $i->inflate >> will use as much
memory as it takes to write all the uncompressed data it creates by
uncompressing the input buffer.

If C<LimitOutput> is enabled, the C<ConsumeInput> option will also be
enabled.

This option defaults to false.

See L</The LimitOutput option> for a discussion on why C<LimitOutput> is
needed and how to use it.

=back

Here is an example of using an optional parameter to override the default
buffer size.

    my ($i, $status) = new Compress::Raw::Zlib::Inflate( -Bufsize => 300 ) ;

=head2 B< $status = $i-E<gt>inflate($input, $output [,$eof]) >

Inflates the complete contents of C<$input> and writes the uncompressed
data to C<$output>. The C<$input> and C<$output> parameters can either be
scalars or scalar references.

Returns C<Z_OK> if successful and C<Z_STREAM_END> if the end of the
compressed data has been successfully reached. 

If not successful C<$status> will hold the I<zlib> error code.

If the C<ConsumeInput> option has been set to true when the
C<Compress::Raw::Zlib::Inflate> object is created, the C<$input> parameter
is modified by C<inflate>. On completion it will contain what remains
of the input buffer after inflation. In practice, this means that when
the return status is C<Z_OK> the C<$input> parameter will contain an
empty string, and when the return status is C<Z_STREAM_END> the C<$input>
parameter will contains what (if anything) was stored in the input buffer
after the deflated data stream.

This feature is useful when processing a file format that encapsulates
a compressed data stream (e.g. gzip, zip) and there is useful data
immediately after the deflation stream.

If the C<AppendOutput> option is set to true in the constructor for
this object, the uncompressed data will be appended to C<$output>. If
it is false, C<$output> will be truncated before any uncompressed data
is written to it.

The C<$eof> parameter needs a bit of explanation. 

Prior to version 1.2.0, zlib assumed that there was at least one trailing
byte immediately after the compressed data stream when it was carrying out
decompression. This normally isn't a problem because the majority of zlib
applications guarantee that there will be data directly after the
compressed data stream.  For example, both gzip (RFC 1950) and zip both
define trailing data that follows the compressed data stream.

The C<$eof> parameter only needs to be used if B<all> of the following
conditions apply

=over 5

=item 1 

You are either using a copy of zlib that is older than version 1.2.0 or you
want your application code to be able to run with as many different
versions of zlib as possible.

=item 2

You have set the C<WindowBits> parameter to C<-MAX_WBITS> in the constructor
for this object, i.e. you are uncompressing a raw deflated data stream
(RFC 1951).

=item 3

There is no data immediately after the compressed data stream.

=back

If B<all> of these are the case, then you need to set the C<$eof> parameter
to true on the final call (and only the final call) to C<$i-E<gt>inflate>. 

If you have built this module with zlib >= 1.2.0, the C<$eof> parameter is
ignored. You can still set it if you want, but it won't be used behind the
scenes.

=head2 B<$status = $i-E<gt>inflateSync($input)>

This method can be used to attempt to recover good data from a compressed
data stream that is partially corrupt.
It scans C<$input> until it reaches either a I<full flush point> or the
end of the buffer.

If a I<full flush point> is found, C<Z_OK> is returned and C<$input>
will be have all data up to the flush point removed. This data can then be
passed to the C<$i-E<gt>inflate> method to be uncompressed.

Any other return code means that a flush point was not found. If more
data is available, C<inflateSync> can be called repeatedly with more
compressed data until the flush point is found.

Note I<full flush points> are not present by default in compressed
data streams. They must have been added explicitly when the data stream
was created by calling C<Compress::Deflate::flush>  with C<Z_FULL_FLUSH>.

=head2 B<$status = $i-E<gt>inflateReset() >

This method will reset the inflation object C<$i>. It can be used when you
are uncompressing multiple data streams and want to use the same object to
uncompress each of them. 

Returns C<Z_OK> if successful.

=head2 B<$i-E<gt>dict_adler()>

Returns the adler32 value for the dictionary.

=head2 B<$i-E<gt>crc32()>

Returns the crc32 value for the uncompressed data to date.

If the C<CRC32> option is not enabled in the constructor for this object,
this method will always return 0;

=head2 B<$i-E<gt>adler32()>

Returns the adler32 value for the uncompressed data to date.

If the C<ADLER32> option is not enabled in the constructor for this object,
this method will always return 0;

=head2 B<$i-E<gt>msg()>

Returns the last error message generated by zlib.

=head2 B<$i-E<gt>total_in()>

Returns the total number of bytes compressed bytes input to inflate.

=head2 B<$i-E<gt>total_out()>

Returns the total number of uncompressed bytes output from inflate.

=head2 B<$d-E<gt>get_BufSize()>

Returns the buffer size used to carry out the decompression.

=head2 Examples

Here is an example of using C<inflate>.

    use strict ;
    use warnings ;
    
    use Compress::Raw::Zlib;
    
    my $x = new Compress::Raw::Zlib::Inflate()
       or die "Cannot create a inflation stream\n" ;
    
    my $input = '' ;
    binmode STDIN;
    binmode STDOUT;
    
    my ($output, $status) ;
    while (read(STDIN, $input, 4096))
    {
        $status = $x->inflate($input, $output) ;
    
        print $output ;
    
        last if $status != Z_OK ;
    }
    
    die "inflation failed\n"
        unless $status == Z_STREAM_END ;

The next example show how to use the C<LimitOutput> option. Notice the use
of two nested loops in this case. The outer loop reads the data from the
input source - STDIN and the inner loop repeatedly calls C<inflate> until
C<$input> is exhausted, we get an error, or the end of the stream is
reached. One point worth remembering is by using the C<LimitOutput> option
you also get C<ConsumeInput> set as well - this makes the code below much
simpler.

    use strict ;
    use warnings ;
    
    use Compress::Raw::Zlib;
    
    my $x = new Compress::Raw::Zlib::Inflate(LimitOutput => 1)
       or die "Cannot create a inflation stream\n" ;
    
    my $input = '' ;
    binmode STDIN;
    binmode STDOUT;
    
    my ($output, $status) ;

  OUTER:
    while (read(STDIN, $input, 4096))
    {
        do
        {
            $status = $x->inflate($input, $output) ;

            print $output ;

            last OUTER
                unless $status == Z_OK || $status == Z_BUF_ERROR ;
        }
        while ($status == Z_OK && length $input);
    }
    
    die "inflation failed\n"
        unless $status == Z_STREAM_END ;

=head1 CHECKSUM FUNCTIONS

Two functions are provided by I<zlib> to calculate checksums. For the
Perl interface, the order of the two parameters in both functions has
been reversed. This allows both running checksums and one off
calculations to be done.

    $crc = adler32($buffer [,$crc]) ;
    $crc = crc32($buffer [,$crc]) ;

The buffer parameters can either be a scalar or a scalar reference.

If the $crc parameters is C<undef>, the crc value will be reset.

If you have built this module with zlib 1.2.3 or better, two more
CRC-related functions are available.

    $crc = crc32_combine($crc1, $crc2, $len2);
    $adler = adler32_combine($adler1, $adler2, $len2);

These functions allow checksums to be merged.
Refer to the I<zlib> documentation for more details.

=head1 Misc

=head2 my $version = Compress::Raw::Zlib::zlib_version();

Returns the version of the zlib library.

=head2  my $flags = Compress::Raw::Zlib::zlibCompileFlags();

Returns the flags indicating compile-time options that were used to build 
the zlib library. See the zlib documentation for a description of the flags
returned by C<zlibCompileFlags>.

Note that when the zlib sources are built along with this module the
C<sprintf> flags (bits 24, 25 and 26) should be ignored.

If you are using zlib 1.2.0 or older, C<zlibCompileFlags> will return 0. 

=head1 The LimitOutput option.

By default C<< $i->inflate($input, $output) >> will uncompress I<all> data
in C<$input> and write I<all> of the uncompressed data it has generated to
C<$output>. This makes the interface to C<inflate> much simpler - if the
method has uncompressed C<$input> successfully I<all> compressed data in
C<$input> will have been dealt with. So if you are reading from an input
source and uncompressing as you go the code will look something like this

    use strict ;
    use warnings ;
    
    use Compress::Raw::Zlib;
    
    my $x = new Compress::Raw::Zlib::Inflate()
       or die "Cannot create a inflation stream\n" ;
    
    my $input = '' ;
    
    my ($output, $status) ;
    while (read(STDIN, $input, 4096))
    {
        $status = $x->inflate($input, $output) ;
    
        print $output ;
    
        last if $status != Z_OK ;
    }
    
    die "inflation failed\n"
        unless $status == Z_STREAM_END ;

The points to note are 

=over 5

=item *

The main processing loop in the code handles reading of compressed data
from STDIN.

=item *

The status code returned from C<inflate> will only trigger termination of
the main processing loop if it isn't C<Z_OK>. When C<LimitOutput> has not
been used the C<Z_OK> status means that the end of the compressed
data stream has been reached or there has been an error in uncompression.

=item *

After the call to C<inflate> I<all> of the uncompressed data in C<$input>
will have been processed. This means the subsequent call to C<read> can
overwrite it's contents without any problem.

=back

For most use-cases the behavior described above is acceptable (this module
and it's predecessor, C<Compress::Zlib>, have used it for over 10 years
without an issue), but in a few very specific use-cases the amount of
memory required for C<$output> can prohibitively large. For example, if the
compressed data stream contains the same pattern repeated thousands of
times, a relatively small compressed data stream can uncompress into
hundreds of megabytes.  Remember C<inflate> will keep allocating memory
until I<all> the uncompressed data has been written to the output buffer -
the size of C<$output> is unbounded. 

The C<LimitOutput> option is designed to help with this use-case.

The main difference in your code when using C<LimitOutput> is having to
deal with cases where the C<$input> parameter still contains some
uncompressed data that C<inflate> hasn't processed yet. The status code
returned from C<inflate> will be C<Z_OK> if uncompression took place and
C<Z_BUF_ERROR> if the output buffer is full.

Below is typical code that shows how to use C<LimitOutput>.

    use strict ;
    use warnings ;
    
    use Compress::Raw::Zlib;
    
    my $x = new Compress::Raw::Zlib::Inflate(LimitOutput => 1)
       or die "Cannot create a inflation stream\n" ;
    
    my $input = '' ;
    binmode STDIN;
    binmode STDOUT;
    
    my ($output, $status) ;

  OUTER:
    while (read(STDIN, $input, 4096))
    {
        do
        {
            $status = $x->inflate($input, $output) ;

            print $output ;

            last OUTER
                unless $status == Z_OK || $status == Z_BUF_ERROR ;
        }
        while ($status == Z_OK && length $input);
    }
    
    die "inflation failed\n"
        unless $status == Z_STREAM_END ;

Points to note this time:

=over 5

=item *

There are now two nested loops in the code: the outer loop for reading the
compressed data from STDIN, as before; and the inner loop to carry out the
uncompression.

=item *

There are two exit points from the inner uncompression loop.

Firstly when C<inflate> has returned a status other than C<Z_OK> or
C<Z_BUF_ERROR>.  This means that either the end of the compressed data
stream has been reached (C<Z_STREAM_END>) or there is an error in the
compressed data. In either of these cases there is no point in continuing
with reading the compressed data, so both loops are terminated.

The second exit point tests if there is any data left in the input buffer,
C<$input> - remember that the C<ConsumeInput> option is automatically
enabled when C<LimitOutput> is used.  When the input buffer has been
exhausted, the outer loop can run again and overwrite a now empty
C<$input>.

=back

=head1 ACCESSING ZIP FILES

Although it is possible (with some effort on your part) to use this module
to access .zip files, there are other perl modules available that will do
all the hard work for you. Check out C<Archive::Zip>,
C<Archive::Zip::SimpleZip>, C<IO::Compress::Zip> and
C<IO::Uncompress::Unzip>.

=head1 FAQ

=head2 Compatibility with Unix compress/uncompress.

This module is not compatible with Unix C<compress>.

If you have the C<uncompress> program available, you can use this to read
compressed files

    open F, "uncompress -c $filename |";
    while (<F>)
    {
        ...

Alternatively, if you have the C<gunzip> program available, you can use
this to read compressed files

    open F, "gunzip -c $filename |";
    while (<F>)
    {
        ...

and this to write compress files, if you have the C<compress> program
available

    open F, "| compress -c $filename ";
    print F "data";
    ...
    close F ;

=head2 Accessing .tar.Z files

See previous FAQ item.

If the C<Archive::Tar> module is installed and either the C<uncompress> or
C<gunzip> programs are available, you can use one of these workarounds to
read C<.tar.Z> files.

Firstly with C<uncompress>

    use strict;
    use warnings;
    use Archive::Tar;

    open F, "uncompress -c $filename |";
    my $tar = Archive::Tar->new(*F);
    ...

and this with C<gunzip>

    use strict;
    use warnings;
    use Archive::Tar;

    open F, "gunzip -c $filename |";
    my $tar = Archive::Tar->new(*F);
    ...

Similarly, if the C<compress> program is available, you can use this to
write a C<.tar.Z> file

    use strict;
    use warnings;
    use Archive::Tar;
    use IO::File;

    my $fh = new IO::File "| compress -c >$filename";
    my $tar = Archive::Tar->new();
    ...
    $tar->write($fh);
    $fh->close ;

=head2 Zlib Library Version Support

By default C<Compress::Raw::Zlib> will build with a private copy of version
1.2.5 of the zlib library. (See the F<README> file for details of
how to override this behaviour)

If you decide to use a different version of the zlib library, you need to be
aware of the following issues

=over 5

=item *

First off, you must have zlib 1.0.5 or better.

=item *

You need to have zlib 1.2.1 or better if you want to use the C<-Merge>
option with C<IO::Compress::Gzip>, C<IO::Compress::Deflate> and
C<IO::Compress::RawDeflate>.

=back

=head1 CONSTANTS

All the I<zlib> constants are automatically imported when you make use
of I<Compress::Raw::Zlib>.

=head1 SEE ALSO

L<Compress::Zlib>, L<IO::Compress::Gzip>, L<IO::Uncompress::Gunzip>, L<IO::Compress::Deflate>, L<IO::Uncompress::Inflate>, L<IO::Compress::RawDeflate>, L<IO::Uncompress::RawInflate>, L<IO::Compress::Bzip2>, L<IO::Uncompress::Bunzip2>, L<IO::Compress::Lzma>, L<IO::Uncompress::UnLzma>, L<IO::Compress::Xz>, L<IO::Uncompress::UnXz>, L<IO::Compress::Lzop>, L<IO::Uncompress::UnLzop>, L<IO::Compress::Lzf>, L<IO::Uncompress::UnLzf>, L<IO::Uncompress::AnyInflate>, L<IO::Uncompress::AnyUncompress>

L<IO::Compress::FAQ|IO::Compress::FAQ>

L<File::GlobMapper|File::GlobMapper>, L<Archive::Zip|Archive::Zip>,
L<Archive::Tar|Archive::Tar>,
L<IO::Zlib|IO::Zlib>

For RFC 1950, 1951 and 1952 see 
F<http://www.faqs.org/rfcs/rfc1950.html>,
F<http://www.faqs.org/rfcs/rfc1951.html> and
F<http://www.faqs.org/rfcs/rfc1952.html>

The I<zlib> compression library was written by Jean-loup Gailly
F<gzip@prep.ai.mit.edu> and Mark Adler F<madler@alumni.caltech.edu>.

The primary site for the I<zlib> compression library is
F<http://www.zlib.org>.

The primary site for gzip is F<http://www.gzip.org>.

=head1 AUTHOR

This module was written by Paul Marquess, F<pmqs@cpan.org>. 

=head1 MODIFICATION HISTORY

See the Changes file.

=head1 COPYRIGHT AND LICENSE

Copyright (c) 2005-2015 Paul Marquess. All rights reserved.

This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              #
# Data/Dumper.pm
#
# convert perl data structures into perl syntax suitable for both printing
# and eval
#
# Documentation at the __END__
#

package Data::Dumper;

BEGIN {
    $VERSION = '2.160'; # Don't forget to set version and release
}               # date in POD below!

#$| = 1;

use 5.006_001;
require Exporter;
require overload;

use Carp;

BEGIN {
    @ISA = qw(Exporter);
    @EXPORT = qw(Dumper);
    @EXPORT_OK = qw(DumperX);

    # if run under miniperl, or otherwise lacking dynamic loading,
    # XSLoader should be attempted to load, or the pure perl flag
    # toggled on load failure.
    eval {
        require XSLoader;
        XSLoader::load( 'Data::Dumper' );
        1
    }
    or $Useperl = 1;
}

my $IS_ASCII  = ord 'A' ==  65;

# module vars and their defaults
$Indent     = 2         unless defined $Indent;
$Trailingcomma = 0      unless defined $Trailingcomma;
$Purity     = 0         unless defined $Purity;
$Pad        = ""        unless defined $Pad;
$Varname    = "VAR"     unless defined $Varname;
$Useqq      = 0         unless defined $Useqq;
$Terse      = 0         unless defined $Terse;
$Freezer    = ""        unless defined $Freezer;
$Toaster    = ""        unless defined $Toaster;
$Deepcopy   = 0         unless defined $Deepcopy;
$Quotekeys  = 1         unless defined $Quotekeys;
$Bless      = "bless"   unless defined $Bless;
#$Expdepth   = 0         unless defined $Expdepth;
$Maxdepth   = 0         unless defined $Maxdepth;
$Pair       = ' => '    unless defined $Pair;
$Useperl    = 0         unless defined $Useperl;
$Sortkeys   = 0         unless defined $Sortkeys;
$Deparse    = 0         unless defined $Deparse;
$Sparseseen = 0         unless defined $Sparseseen;
$Maxrecurse = 1000      unless defined $Maxrecurse;

#
# expects an arrayref of values to be dumped.
# can optionally pass an arrayref of names for the values.
# names must have leading $ sign stripped. begin the name with *
# to cause output of arrays and hashes rather than refs.
#
sub new {
  my($c, $v, $n) = @_;

  croak "Usage:  PACKAGE->new(ARRAYREF, [ARRAYREF])"
    unless (defined($v) && (ref($v) eq 'ARRAY'));
  $n = [] unless (defined($n) && (ref($n) eq 'ARRAY'));

  my($s) = {
        level      => 0,           # current recursive depth
        indent     => $Indent,     # various styles of indenting
        trailingcomma => $Trailingcomma, # whether to add comma after last elem
        pad        => $Pad,        # all lines prefixed by this string
        xpad       => "",          # padding-per-level
        apad       => "",          # added padding for hash keys n such
        sep        => "",          # list separator
        pair       => $Pair,    # hash key/value separator: defaults to ' => '
        seen       => {},          # local (nested) refs (id => [name, val])
        todump     => $v,          # values to dump []
        names      => $n,          # optional names for values []
        varname    => $Varname,    # prefix to use for tagging nameless ones
        purity     => $Purity,     # degree to which output is evalable
        useqq      => $Useqq,      # use "" for strings (backslashitis ensues)
        terse      => $Terse,      # avoid name output (where feasible)
        freezer    => $Freezer,    # name of Freezer method for objects
        toaster    => $Toaster,    # name of method to revive objects
        deepcopy   => $Deepcopy,   # do not cross-ref, except to stop recursion
        quotekeys  => $Quotekeys,  # quote hash keys
        'bless'    => $Bless,    # keyword to use for "bless"
#        expdepth   => $Expdepth,   # cutoff depth for explicit dumping
        maxdepth   => $Maxdepth,   # depth beyond which we give up
	maxrecurse => $Maxrecurse, # depth beyond which we abort
        useperl    => $Useperl,    # use the pure Perl implementation
        sortkeys   => $Sortkeys,   # flag or filter for sorting hash keys
        deparse    => $Deparse,    # use B::Deparse for coderefs
        noseen     => $Sparseseen, # do not populate the seen hash unless necessary
       };

  if ($Indent > 0) {
    $s->{xpad} = "  ";
    $s->{sep} = "\n";
  }
  return bless($s, $c);
}

# Packed numeric addresses take less memory. Plus pack is faster than sprintf

# Most users of current versions of Data::Dumper will be 5.008 or later.
# Anyone on 5.6.1 and 5.6.2 upgrading will be rare (particularly judging by
# the bug reports from users on those platforms), so for the common case avoid
# complexity, and avoid even compiling the unneeded code.

sub init_refaddr_format {
}

sub format_refaddr {
    require Scalar::Util;
    pack "J", Scalar::Util::refaddr(shift);
};

if ($] < 5.008) {
    eval <<'EOC' or die;
    no warnings 'redefine';
    my $refaddr_format;
    sub init_refaddr_format {
        require Config;
        my $f = $Config::Config{uvxformat};
        $f =~ tr/"//d;
        $refaddr_format = "0x%" . $f;
    }

    sub format_refaddr {
        require Scalar::Util;
        sprintf $refaddr_format, Scalar::Util::refaddr(shift);
    }

    1
EOC
}

#
# add-to or query the table of already seen references
#
sub Seen {
  my($s, $g) = @_;
  if (defined($g) && (ref($g) eq 'HASH'))  {
    init_refaddr_format();
    my($k, $v, $id);
    while (($k, $v) = each %$g) {
      if (defined $v) {
        if (ref $v) {
          $id = format_refaddr($v);
          if ($k =~ /^[*](.*)$/) {
            $k = (ref $v eq 'ARRAY') ? ( "\\\@" . $1 ) :
                 (ref $v eq 'HASH')  ? ( "\\\%" . $1 ) :
                 (ref $v eq 'CODE')  ? ( "\\\&" . $1 ) :
                 (   "\$" . $1 ) ;
          }
          elsif ($k !~ /^\$/) {
            $k = "\$" . $k;
          }
          $s->{seen}{$id} = [$k, $v];
        }
        else {
          carp "Only refs supported, ignoring non-ref item \$$k";
        }
      }
      else {
        carp "Value of ref must be defined; ignoring undefined item \$$k";
      }
    }
    return $s;
  }
  else {
    return map { @$_ } values %{$s->{seen}};
  }
}

#
# set or query the values to be dumped
#
sub Values {
  my($s, $v) = @_;
  if (defined($v)) {
    if (ref($v) eq 'ARRAY')  {
      $s->{todump} = [@$v];        # make a copy
      return $s;
    }
    else {
      croak "Argument to Values, if provided, must be array ref";
    }
  }
  else {
    return @{$s->{todump}};
  }
}

#
# set or query the names of the values to be dumped
#
sub Names {
  my($s, $n) = @_;
  if (defined($n)) {
    if (ref($n) eq 'ARRAY') {
      $s->{names} = [@$n];         # make a copy
      return $s;
    }
    else {
      croak "Argument to Names, if provided, must be array ref";
    }
  }
  else {
    return @{$s->{names}};
  }
}

sub DESTROY {}

sub Dump {
    return &Dumpxs
    unless $Data::Dumper::Useperl || (ref($_[0]) && $_[0]->{useperl})
        || $Data::Dumper::Deparse || (ref($_[0]) && $_[0]->{deparse})

            # Use pure perl version on earlier releases on EBCDIC platforms
        || (! $IS_ASCII && $] lt 5.021_010);
    return &Dumpperl;
}

#
# dump the refs in the current dumper object.
# expects same args as new() if called via package name.
#
sub Dumpperl {
  my($s) = shift;
  my(@out, $val, $name);
  my($i) = 0;
  local(@post);
  init_refaddr_format();

  $s = $s->new(@_) unless ref $s;

  for $val (@{$s->{todump}}) {
    @post = ();
    $name = $s->{names}[$i++];
    $name = $s->_refine_name($name, $val, $i);

    my $valstr;
    {
      local($s->{apad}) = $s->{apad};
      $s->{apad} .= ' ' x (length($name) + 3) if $s->{indent} >= 2 and !$s->{terse};
      $valstr = $s->_dump($val, $name);
    }

    $valstr = "$name = " . $valstr . ';' if @post or !$s->{terse};
    my $out = $s->_compose_out($valstr, \@post);

    push @out, $out;
  }
  return wantarray ? @out : join('', @out);
}

# wrap string in single quotes (escaping if needed)
sub _quote {
    my $val = shift;
    $val =~ s/([\\\'])/\\$1/g;
    return  "'" . $val .  "'";
}

# Old Perls (5.14-) have trouble resetting vstring magic when it is no
# longer valid.
use constant _bad_vsmg => defined &_vstring && (_vstring(~v0)||'') eq "v0";

#
# twist, toil and turn;
# and recurse, of course.
# sometimes sordidly;
# and curse if no recourse.
#
sub _dump {
  my($s, $val, $name) = @_;
  my($out, $type, $id, $sname);

  $type = ref $val;
  $out = "";

  if ($type) {

    # Call the freezer method if it's specified and the object has the
    # method.  Trap errors and warn() instead of die()ing, like the XS
    # implementation.
    my $freezer = $s->{freezer};
    if ($freezer and UNIVERSAL::can($val, $freezer)) {
      eval { $val->$freezer() };
      warn "WARNING(Freezer method call failed): $@" if $@;
    }

    require Scalar::Util;
    my $realpack = Scalar::Util::blessed($val);
    my $realtype = $realpack ? Scalar::Util::reftype($val) : ref $val;
    $id = format_refaddr($val);

    # Note: By this point $name is always defined and of non-zero length.
    # Keep a tab on it so that we do not fall into recursive pit.
    if (exists $s->{seen}{$id}) {
      if ($s->{purity} and $s->{level} > 0) {
        $out = ($realtype eq 'HASH')  ? '{}' :
               ($realtype eq 'ARRAY') ? '[]' :
               'do{my $o}' ;
        push @post, $name . " = " . $s->{seen}{$id}[0];
      }
      else {
        $out = $s->{seen}{$id}[0];
        if ($name =~ /^([\@\%])/) {
          my $start = $1;
          if ($out =~ /^\\$start/) {
            $out = substr($out, 1);
          }
          else {
            $out = $start . '{' . $out . '}';
          }
        }
      }
      return $out;
    }
    else {
      # store our name
      $s->{seen}{$id} = [ (
          ($name =~ /^[@%]/)
            ? ('\\' . $name )
            : ($realtype eq 'CODE' and $name =~ /^[*](.*)$/)
              ? ('\\&' . $1 )
              : $name
        ), $val ];
    }
    my $no_bless = 0;
    my $is_regex = 0;
    if ( $realpack and ($] >= 5.009005 ? re::is_regexp($val) : $realpack eq 'Regexp') ) {
        $is_regex = 1;
        $no_bless = $realpack eq 'Regexp';
    }

    # If purity is not set and maxdepth is set, then check depth:
    # if we have reached maximum depth, return the string
    # representation of the thing we are currently examining
    # at this depth (i.e., 'Foo=ARRAY(0xdeadbeef)').
    if (!$s->{purity}
      and defined($s->{maxdepth})
      and $s->{maxdepth} > 0
      and $s->{level} >= $s->{maxdepth})
    {
      return qq['$val'];
    }

    # avoid recursing infinitely [perl #122111]
    if ($s->{maxrecurse} > 0
        and $s->{level} >= $s->{maxrecurse}) {
        die "Recursion limit of $s->{maxrecurse} exceeded";
    }

    # we have a blessed ref
    my ($blesspad);
    if ($realpack and !$no_bless) {
      $out = $s->{'bless'} . '( ';
      $blesspad = $s->{apad};
      $s->{apad} .= '       ' if ($s->{indent} >= 2);
    }

    $s->{level}++;
    my $ipad = $s->{xpad} x $s->{level};

    if ($is_regex) {
        my $pat;
        my $flags = "";
        if (defined(*re::regexp_pattern{CODE})) {
          ($pat, $flags) = re::regexp_pattern($val);
        }
        else {
          $pat = "$val";
        }
        $pat =~ s <(\\.)|/> { $1 || '\\/' }ge;
        $out .= "qr/$pat/$flags";
    }
    elsif ($realtype eq 'SCALAR' || $realtype eq 'REF'
    || $realtype eq 'VSTRING') {
      if ($realpack) {
        $out .= 'do{\\(my $o = ' . $s->_dump($$val, "\${$name}") . ')}';
      }
      else {
        $out .= '\\' . $s->_dump($$val, "\${$name}");
      }
    }
    elsif ($realtype eq 'GLOB') {
      $out .= '\\' . $s->_dump($$val, "*{$name}");
    }
    elsif ($realtype eq 'ARRAY') {
      my($pad, $mname);
      my($i) = 0;
      $out .= ($name =~ /^\@/) ? '(' : '[';
      $pad = $s->{sep} . $s->{pad} . $s->{apad};
      ($name =~ /^\@(.*)$/) ? ($mname = "\$" . $1) :
    # omit -> if $foo->[0]->{bar}, but not ${$foo->[0]}->{bar}
        ($name =~ /^\\?[\%\@\*\$][^{].*[]}]$/) ? ($mname = $name) :
        ($mname = $name . '->');
      $mname .= '->' if $mname =~ /^\*.+\{[A-Z]+\}$/;
      for my $v (@$val) {
        $sname = $mname . '[' . $i . ']';
        $out .= $pad . $ipad . '#' . $i
          if $s->{indent} >= 3;
        $out .= $pad . $ipad . $s->_dump($v, $sname);
        $out .= ","
            if $i++ < $#$val
            || ($s->{trailingcomma} && $s->{indent} >= 1);
      }
      $out .= $pad . ($s->{xpad} x ($s->{level} - 1)) if $i;
      $out .= ($name =~ /^\@/) ? ')' : ']';
    }
    elsif ($realtype eq 'HASH') {
      my ($k, $v, $pad, $lpad, $mname, $pair);
      $out .= ($name =~ /^\%/) ? '(' : '{';
      $pad = $s->{sep} . $s->{pad} . $s->{apad};
      $lpad = $s->{apad};
      $pair = $s->{pair};
      ($name =~ /^\%(.*)$/) ? ($mname = "\$" . $1) :
    # omit -> if $foo->[0]->{bar}, but not ${$foo->[0]}->{bar}
        ($name =~ /^\\?[\%\@\*\$][^{].*[]}]$/) ? ($mname = $name) :
        ($mname = $name . '->');
      $mname .= '->' if $mname =~ /^\*.+\{[A-Z]+\}$/;
      my $sortkeys = defined($s->{sortkeys}) ? $s->{sortkeys} : '';
      my $keys = [];
      if ($sortkeys) {
        if (ref($s->{sortkeys}) eq 'CODE') {
          $keys = $s->{sortkeys}($val);
          unless (ref($keys) eq 'ARRAY') {
            carp "Sortkeys subroutine did not return ARRAYREF";
            $keys = [];
          }
        }
        else {
          $keys = [ sort keys %$val ];
        }
      }

      # Ensure hash iterator is reset
      keys(%$val);

      my $key;
      while (($k, $v) = ! $sortkeys ? (each %$val) :
         @$keys ? ($key = shift(@$keys), $val->{$key}) :
         () )
      {
        my $nk = $s->_dump($k, "");

        # _dump doesn't quote numbers of this form
        if ($s->{quotekeys} && $nk =~ /^(?:0|-?[1-9][0-9]{0,8})\z/) {
          $nk = $s->{useqq} ? qq("$nk") : qq('$nk');
        }
        elsif (!$s->{quotekeys} and $nk =~ /^[\"\']([A-Za-z_]\w*)[\"\']$/) {
          $nk = $1
        }

        $sname = $mname . '{' . $nk . '}';
        $out .= $pad . $ipad . $nk . $pair;

        # temporarily alter apad
        $s->{apad} .= (" " x (length($nk) + 4))
          if $s->{indent} >= 2;
        $out .= $s->_dump($val->{$k}, $sname) . ",";
        $s->{apad} = $lpad
          if $s->{indent} >= 2;
      }
      if (substr($out, -1) eq ',') {
        chop $out if !$s->{trailingcomma} || !$s->{indent};
        $out .= $pad . ($s->{xpad} x ($s->{level} - 1));
      }
      $out .= ($name =~ /^\%/) ? ')' : '}';
    }
    elsif ($realtype eq 'CODE') {
      if ($s->{deparse}) {
        require B::Deparse;
        my $sub =  'sub ' . (B::Deparse->new)->coderef2text($val);
        $pad    =  $s->{sep} . $s->{pad} . $s->{apad} . $s->{xpad} x ($s->{level} - 1);
        $sub    =~ s/\n/$pad/gse;
        $out   .=  $sub;
      }
      else {
        $out .= 'sub { "DUMMY" }';
        carp "Encountered CODE ref, using dummy placeholder" if $s->{purity};
      }
    }
    else {
      croak "Can't handle '$realtype' type";
    }

    if ($realpack and !$no_bless) { # we have a blessed ref
      $out .= ', ' . _quote($realpack) . ' )';
      $out .= '->' . $s->{toaster} . '()'
        if $s->{toaster} ne '';
      $s->{apad} = $blesspad;
    }
    $s->{level}--;
  }
  else {                                 # simple scalar

    my $ref = \$_[1];
    my $v;
    # first, catalog the scalar
    if ($name ne '') {
      $id = format_refaddr($ref);
      if (exists $s->{seen}{$id}) {
        if ($s->{seen}{$id}[2]) {
          $out = $s->{seen}{$id}[0];
          #warn "[<$out]\n";
          return "\${$out}";
        }
      }
      else {
        #warn "[>\\$name]\n";
        $s->{seen}{$id} = ["\\$name", $ref];
      }
    }
    $ref = \$val;
    if (ref($ref) eq 'GLOB') {  # glob
      my $name = substr($val, 1);
      if ($name =~ /^[A-Za-z_][\w:]*$/ && $name ne 'main::') {
        $name =~ s/^main::/::/;
        $sname = $name;
      }
      else {
        $sname = $s->_dump(
          $name eq 'main::' || $] < 5.007 && $name eq "main::\0"
            ? ''
            : $name,
          "",
        );
        $sname = '{' . $sname . '}';
      }
      if ($s->{purity}) {
        my $k;
        local ($s->{level}) = 0;
        for $k (qw(SCALAR ARRAY HASH)) {
          my $gval = *$val{$k};
          next unless defined $gval;
          next if $k eq "SCALAR" && ! defined $$gval;  # always there

          # _dump can push into @post, so we hold our place using $postlen
          my $postlen = scalar @post;
          $post[$postlen] = "\*$sname = ";
          local ($s->{apad}) = " " x length($post[$postlen]) if $s->{indent} >= 2;
          $post[$postlen] .= $s->_dump($gval, "\*$sname\{$k\}");
        }
      }
      $out .= '*' . $sname;
    }
    elsif (!defined($val)) {
      $out .= "undef";
    }
    elsif (defined &_vstring and $v = _vstring($val)
      and !_bad_vsmg || eval $v eq $val) {
      $out .= $v;
    }
    elsif (!defined &_vstring
       and ref $ref eq 'VSTRING' || eval{Scalar::Util::isvstring($val)}) {
      $out .= sprintf "%vd", $val;
    }
    # \d here would treat "1\x{660}" as a safe decimal number
    elsif ($val =~ /^(?:0|-?[1-9][0-9]{0,8})\z/) { # safe decimal number
      $out .= $val;
    }
    else {                 # string
      if ($s->{useqq} or $val =~ tr/\0-\377//c) {
        # Fall back to qq if there's Unicode
        $out .= qquote($val, $s->{useqq});
      }
      else {
        $out .= _quote($val);
      }
    }
  }
  if ($id) {
    # if we made it this far, $id was added to seen list at current
    # level, so remove it to get deep copies
    if ($s->{deepcopy}) {
      delete($s->{seen}{$id});
    }
    elsif ($name) {
      $s->{seen}{$id}[2] = 1;
    }
  }
  return $out;
}

#
# non-OO style of earlier version
#
sub Dumper {
  return Data::Dumper->Dump([@_]);
}

# compat stub
sub DumperX {
  return Data::Dumper->Dumpxs([@_], []);
}

#
# reset the "seen" cache
#
sub Reset {
  my($s) = shift;
  $s->{seen} = {};
  return $s;
}

sub Indent {
  my($s, $v) = @_;
  if (defined($v)) {
    if ($v == 0) {
      $s->{xpad} = "";
      $s->{sep} = "";
    }
    else {
      $s->{xpad} = "  ";
      $s->{sep} = "\n";
    }
    $s->{indent} = $v;
    return $s;
  }
  else {
    return $s->{indent};
  }
}

sub Trailingcomma {
  my($s, $v) = @_;
  defined($v) ? (($s->{trailingcomma} = $v), return $s) : $s->{trailingcomma};
}

sub Pair {
    my($s, $v) = @_;
    defined($v) ? (($s->{pair} = $v), return $s) : $s->{pair};
}

sub Pad {
  my($s, $v) = @_;
  defined($v) ? (($s->{pad} = $v), return $s) : $s->{pad};
}

sub Varname {
  my($s, $v) = @_;
  defined($v) ? (($s->{varname} = $v), return $s) : $s->{varname};
}

sub Purity {
  my($s, $v) = @_;
  defined($v) ? (($s->{purity} = $v), return $s) : $s->{purity};
}

sub Useqq {
  my($s, $v) = @_;
  defined($v) ? (($s->{useqq} = $v), return $s) : $s->{useqq};
}

sub Terse {
  my($s, $v) = @_;
  defined($v) ? (($s->{terse} = $v), return $s) : $s->{terse};
}

sub Freezer {
  my($s, $v) = @_;
  defined($v) ? (($s->{freezer} = $v), return $s) : $s->{freezer};
}

sub Toaster {
  my($s, $v) = @_;
  defined($v) ? (($s->{toaster} = $v), return $s) : $s->{toaster};
}

sub Deepcopy {
  my($s, $v) = @_;
  defined($v) ? (($s->{deepcopy} = $v), return $s) : $s->{deepcopy};
}

sub Quotekeys {
  my($s, $v) = @_;
  defined($v) ? (($s->{quotekeys} = $v), return $s) : $s->{quotekeys};
}

sub Bless {
  my($s, $v) = @_;
  defined($v) ? (($s->{'bless'} = $v), return $s) : $s->{'bless'};
}

sub Maxdepth {
  my($s, $v) = @_;
  defined($v) ? (($s->{'maxdepth'} = $v), return $s) : $s->{'maxdepth'};
}

sub Maxrecurse {
  my($s, $v) = @_;
  defined($v) ? (($s->{'maxrecurse'} = $v), return $s) : $s->{'maxrecurse'};
}

sub Useperl {
  my($s, $v) = @_;
  defined($v) ? (($s->{'useperl'} = $v), return $s) : $s->{'useperl'};
}

sub Sortkeys {
  my($s, $v) = @_;
  defined($v) ? (($s->{'sortkeys'} = $v), return $s) : $s->{'sortkeys'};
}

sub Deparse {
  my($s, $v) = @_;
  defined($v) ? (($s->{'deparse'} = $v), return $s) : $s->{'deparse'};
}

sub Sparseseen {
  my($s, $v) = @_;
  defined($v) ? (($s->{'noseen'} = $v), return $s) : $s->{'noseen'};
}

# used by qquote below
my %esc = (
    "\a" => "\\a",
    "\b" => "\\b",
    "\t" => "\\t",
    "\n" => "\\n",
    "\f" => "\\f",
    "\r" => "\\r",
    "\e" => "\\e",
);

my $low_controls = ($IS_ASCII)

                   # This includes \177, because traditionally it has been
                   # output as octal, even though it isn't really a "low"
                   # control
                   ? qr/[\0-\x1f\177]/

                     # EBCDIC low controls.
                   : qr/[\0-\x3f]/;

# put a string value in double quotes
sub qquote {
  local($_) = shift;
  s/([\\\"\@\$])/\\$1/g;

  # This efficiently changes the high ordinal characters to \x{} if the utf8
  # flag is on.  On ASCII platforms, the high ordinals are all the
  # non-ASCII's.  On EBCDIC platforms, we don't include in these the non-ASCII
  # controls whose ordinals are less than SPACE, excluded below by the range
  # \0-\x3f.  On ASCII platforms this range just compiles as part of :ascii:.
  # On EBCDIC platforms, there is just one outlier high ordinal control, and
  # it gets output as \x{}.
  my $bytes; { use bytes; $bytes = length }
  s/([^[:ascii:]\0-\x3f])/sprintf("\\x{%x}",ord($1))/ge
    if $bytes > length

       # The above doesn't get the EBCDIC outlier high ordinal control when
       # the string is UTF-8 but there are no UTF-8 variant characters in it.
       # We want that to come out as \x{} anyway.  We need is_utf8() to do
       # this.
       || (! $IS_ASCII && $] ge 5.008_001 && utf8::is_utf8($_));

  return qq("$_") unless /[[:^print:]]/;  # fast exit if only printables

  # Here, there is at least one non-printable to output.  First, translate the
  # escapes.
  s/([\a\b\t\n\f\r\e])/$esc{$1}/g;

  # no need for 3 digits in escape for octals not followed by a digit.
  s/($low_controls)(?!\d)/'\\'.sprintf('%o',ord($1))/eg;

  # But otherwise use 3 digits
  s/($low_controls)/'\\'.sprintf('%03o',ord($1))/eg;

    # all but last branch below not supported --BEHAVIOR SUBJECT TO CHANGE--
  my $high = shift || "";
    if ($high eq "iso8859") {   # Doesn't escape the Latin1 printables
      if ($IS_ASCII) {
        s/([\200-\240])/'\\'.sprintf('%o',ord($1))/eg;
      }
      elsif ($] ge 5.007_003) {
        my $high_control = utf8::unicode_to_native(0x9F);
        s/$high_control/sprintf('\\%o',ord($1))/eg;
      }
    } elsif ($high eq "utf8") {
#     Some discussion of what to do here is in
#       https://rt.perl.org/Ticket/Display.html?id=113088
#     use utf8;
#     $str =~ s/([^\040-\176])/sprintf "\\x{%04x}", ord($1)/ge;
    } elsif ($high eq "8bit") {
        # leave it as it is
    } else {
      s/([[:^ascii:]])/'\\'.sprintf('%03o',ord($1))/eg;
      #s/([^\040-\176])/sprintf "\\x{%04x}", ord($1)/ge;
    }

  return qq("$_");
}

# helper sub to sort hash keys in Perl < 5.8.0 where we don't have
# access to sortsv() from XS
sub _sortkeys { [ sort keys %{$_[0]} ] }

sub _refine_name {
    my $s = shift;
    my ($name, $val, $i) = @_;
    if (defined $name) {
      if ($name =~ /^[*](.*)$/) {
        if (defined $val) {
            $name = (ref $val eq 'ARRAY') ? ( "\@" . $1 ) :
              (ref $val eq 'HASH')  ? ( "\%" . $1 ) :
              (ref $val eq 'CODE')  ? ( "\*" . $1 ) :
              ( "\$" . $1 ) ;
        }
        else {
          $name = "\$" . $1;
        }
      }
      elsif ($name !~ /^\$/) {
        $name = "\$" . $name;
      }
    }
    else { # no names provided
      $name = "\$" . $s->{varname} . $i;
    }
    return $name;
}

sub _compose_out {
    my $s = shift;
    my ($valstr, $postref) = @_;
    my $out = "";
    $out .= $s->{pad} . $valstr . $s->{sep};
    if (@{$postref}) {
        $out .= $s->{pad} .
            join(';' . $s->{sep} . $s->{pad}, @{$postref}) .
            ';' .
            $s->{sep};
    }
    return $out;
}

1;
__END__

=head1 NAME

Data::Dumper - stringified perl data structures, suitable for both printing and C<eval>

=head1 SYNOPSIS

    use Data::Dumper;

    # simple procedural interface
    print Dumper($foo, $bar);

    # extended usage with names
    print Data::Dumper->Dump([$foo, $bar], [qw(foo *ary)]);

    # configuration variables
    {
      local $Data::Dumper::Purity = 1;
      eval Data::Dumper->Dump([$foo, $bar], [qw(foo *ary)]);
    }

    # OO usage
    $d = Data::Dumper->new([$foo, $bar], [qw(foo *ary)]);
       ...
    print $d->Dump;
       ...
    $d->Purity(1)->Terse(1)->Deepcopy(1);
    eval $d->Dump;


=head1 DESCRIPTION

Given a list of scalars or reference variables, writes out their contents in
perl syntax. The references can also be objects.  The content of each
variable is output in a single Perl statement.  Handles self-referential
structures correctly.

The return value can be C<eval>ed to get back an identical copy of the
original reference structure.  (Please do consider the security implications
of eval'ing code from untrusted sources!)

Any references that are the same as one of those passed in will be named
C<$VAR>I<n> (where I<n> is a numeric suffix), and other duplicate references
to substructures within C<$VAR>I<n> will be appropriately labeled using arrow
notation.  You can specify names for individual values to be dumped if you
use the C<Dump()> method, or you can change the default C<$VAR> prefix to
something else.  See C<$Data::Dumper::Varname> and C<$Data::Dumper::Terse>
below.

The default output of self-referential structures can be C<eval>ed, but the
nested references to C<$VAR>I<n> will be undefined, since a recursive
structure cannot be constructed using one Perl statement.  You should set the
C<Purity> flag to 1 to get additional statements that will correctly fill in
these references.  Moreover, if C<eval>ed when strictures are in effect,
you need to ensure that any variables it accesses are previously declared.

In the extended usage form, the references to be dumped can be given
user-specified names.  If a name begins with a C<*>, the output will
describe the dereferenced type of the supplied reference for hashes and
arrays, and coderefs.  Output of names will be avoided where possible if
the C<Terse> flag is set.

In many cases, methods that are used to set the internal state of the
object will return the object itself, so method calls can be conveniently
chained together.

Several styles of output are possible, all controlled by setting
the C<Indent> flag.  See L<Configuration Variables or Methods> below
for details.


=head2 Methods

=over 4

=item I<PACKAGE>->new(I<ARRAYREF [>, I<ARRAYREF]>)

Returns a newly created C<Data::Dumper> object.  The first argument is an
anonymous array of values to be dumped.  The optional second argument is an
anonymous array of names for the values.  The names need not have a leading
C<$> sign, and must be comprised of alphanumeric characters.  You can begin
a name with a C<*> to specify that the dereferenced type must be dumped
instead of the reference itself, for ARRAY and HASH references.

The prefix specified by C<$Data::Dumper::Varname> will be used with a
numeric suffix if the name for a value is undefined.

Data::Dumper will catalog all references encountered while dumping the
values. Cross-references (in the form of names of substructures in perl
syntax) will be inserted at all possible points, preserving any structural
interdependencies in the original set of values.  Structure traversal is
depth-first,  and proceeds in order from the first supplied value to
the last.

=item I<$OBJ>->Dump  I<or>  I<PACKAGE>->Dump(I<ARRAYREF [>, I<ARRAYREF]>)

Returns the stringified form of the values stored in the object (preserving
the order in which they were supplied to C<new>), subject to the
configuration options below.  In a list context, it returns a list
of strings corresponding to the supplied values.

The second form, for convenience, simply calls the C<new> method on its
arguments before dumping the object immediately.

=item I<$OBJ>->Seen(I<[HASHREF]>)

Queries or adds to the internal table of already encountered references.
You must use C<Reset> to explicitly clear the table if needed.  Such
references are not dumped; instead, their names are inserted wherever they
are encountered subsequently.  This is useful especially for properly
dumping subroutine references.

Expects an anonymous hash of name => value pairs.  Same rules apply for names
as in C<new>.  If no argument is supplied, will return the "seen" list of
name => value pairs, in a list context.  Otherwise, returns the object
itself.

=item I<$OBJ>->Values(I<[ARRAYREF]>)

Queries or replaces the internal array of values that will be dumped.  When
called without arguments, returns the values as a list.  When called with a
reference to an array of replacement values, returns the object itself.  When
called with any other type of argument, dies.

=item I<$OBJ>->Names(I<[ARRAYREF]>)

Queries or replaces the internal array of user supplied names for the values
that will be dumped.  When called without arguments, returns the names.  When
called with an array of replacement names, returns the object itself.  If the
number of replacement names exceeds the number of values to be named, the
excess names will not be used.  If the number of replacement names falls short
of the number of values to be named, the list of replacement names will be
exhausted and remaining values will not be renamed.  When
called with any other type of argument, dies.

=item I<$OBJ>->Reset

Clears the internal table of "seen" references and returns the object
itself.

=back

=head2 Functions

=over 4

=item Dumper(I<LIST>)

Returns the stringified form of the values in the list, subject to the
configuration options below.  The values will be named C<$VAR>I<n> in the
output, where I<n> is a numeric suffix.  Will return a list of strings
in a list context.

=back

=head2 Configuration Variables or Methods

Several configuration variables can be used to control the kind of output
generated when using the procedural interface.  These variables are usually
C<local>ized in a block so that other parts of the code are not affected by
the change.

These variables determine the default state of the object created by calling
the C<new> method, but cannot be used to alter the state of the object
thereafter.  The equivalent method names should be used instead to query
or set the internal state of the object.

The method forms return the object itself when called with arguments,
so that they can be chained together nicely.

=over 4

=item *

$Data::Dumper::Indent  I<or>  I<$OBJ>->Indent(I<[NEWVAL]>)

Controls the style of indentation.  It can be set to 0, 1, 2 or 3.  Style 0
spews output without any newlines, indentation, or spaces between list
items.  It is the most compact format possible that can still be called
valid perl.  Style 1 outputs a readable form with newlines but no fancy
indentation (each level in the structure is simply indented by a fixed
amount of whitespace).  Style 2 (the default) outputs a very readable form
which takes into account the length of hash keys (so the hash value lines
up).  Style 3 is like style 2, but also annotates the elements of arrays
with their index (but the comment is on its own line, so array output
consumes twice the number of lines).  Style 2 is the default.

=item *

$Data::Dumper::Trailingcomma  I<or>  I<$OBJ>->Trailingcomma(I<[NEWVAL]>)

Controls whether a comma is added after the last element of an array or
hash. Even when true, no comma is added between the last element of an array
or hash and a closing bracket when they appear on the same line. The default
is false.

=item *

$Data::Dumper::Purity  I<or>  I<$OBJ>->Purity(I<[NEWVAL]>)

Controls the degree to which the output can be C<eval>ed to recreate the
supplied reference structures.  Setting it to 1 will output additional perl
statements that will correctly recreate nested references.  The default is
0.

=item *

$Data::Dumper::Pad  I<or>  I<$OBJ>->Pad(I<[NEWVAL]>)

Specifies the string that will be prefixed to every line of the output.
Empty string by default.

=item *

$Data::Dumper::Varname  I<or>  I<$OBJ>->Varname(I<[NEWVAL]>)

Contains the prefix to use for tagging variable names in the output. The
default is "VAR".

=item *

$Data::Dumper::Useqq  I<or>  I<$OBJ>->Useqq(I<[NEWVAL]>)

When set, enables the use of double quotes for representing string values.
Whitespace other than space will be represented as C<[\n\t\r]>, "unsafe"
characters will be backslashed, and unprintable characters will be output as
quoted octal integers.  The default is 0.

=item *

$Data::Dumper::Terse  I<or>  I<$OBJ>->Terse(I<[NEWVAL]>)

When set, Data::Dumper will emit single, non-self-referential values as
atoms/terms rather than statements.  This means that the C<$VAR>I<n> names
will be avoided where possible, but be advised that such output may not
always be parseable by C<eval>.

=item *

$Data::Dumper::Freezer  I<or>  $I<OBJ>->Freezer(I<[NEWVAL]>)

Can be set to a method name, or to an empty string to disable the feature.
Data::Dumper will invoke that method via the object before attempting to
stringify it.  This method can alter the contents of the object (if, for
instance, it contains data allocated from C), and even rebless it in a
different package.  The client is responsible for making sure the specified
method can be called via the object, and that the object ends up containing
only perl data types after the method has been called.  Defaults to an empty
string.

If an object does not support the method specified (determined using
UNIVERSAL::can()) then the call will be skipped.  If the method dies a
warning will be generated.

=item *

$Data::Dumper::Toaster  I<or>  $I<OBJ>->Toaster(I<[NEWVAL]>)

Can be set to a method name, or to an empty string to disable the feature.
Data::Dumper will emit a method call for any objects that are to be dumped
using the syntax C<bless(DATA, CLASS)-E<gt>METHOD()>.  Note that this means that
the method specified will have to perform any modifications required on the
object (like creating new state within it, and/or reblessing it in a
different package) and then return it.  The client is responsible for making
sure the method can be called via the object, and that it returns a valid
object.  Defaults to an empty string.

=item *

$Data::Dumper::Deepcopy  I<or>  $I<OBJ>->Deepcopy(I<[NEWVAL]>)

Can be set to a boolean value to enable deep copies of structures.
Cross-referencing will then only be done when absolutely essential
(i.e., to break reference cycles).  Default is 0.

=item *

$Data::Dumper::Quotekeys  I<or>  $I<OBJ>->Quotekeys(I<[NEWVAL]>)

Can be set to a boolean value to control whether hash keys are quoted.
A defined false value will avoid quoting hash keys when it looks like a simple
string.  Default is 1, which will always enclose hash keys in quotes.

=item *

$Data::Dumper::Bless  I<or>  $I<OBJ>->Bless(I<[NEWVAL]>)

Can be set to a string that specifies an alternative to the C<bless>
builtin operator used to create objects.  A function with the specified
name should exist, and should accept the same arguments as the builtin.
Default is C<bless>.

=item *

$Data::Dumper::Pair  I<or>  $I<OBJ>->Pair(I<[NEWVAL]>)

Can be set to a string that specifies the separator between hash keys
and values. To dump nested hash, array and scalar values to JavaScript,
use: C<$Data::Dumper::Pair = ' : ';>. Implementing C<bless> in JavaScript
is left as an exercise for the reader.
A function with the specified name exists, and accepts the same arguments
as the builtin.

Default is: C< =E<gt> >.

=item *

$Data::Dumper::Maxdepth  I<or>  $I<OBJ>->Maxdepth(I<[NEWVAL]>)

Can be set to a positive integer that specifies the depth beyond which
we don't venture into a structure.  Has no effect when
C<Data::Dumper::Purity> is set.  (Useful in debugger when we often don't
want to see more than enough).  Default is 0, which means there is
no maximum depth.

=item *

$Data::Dumper::Maxrecurse  I<or>  $I<OBJ>->Maxrecurse(I<[NEWVAL]>)

Can be set to a positive integer that specifies the depth beyond which
recursion into a structure will throw an exception.  This is intended
as a security measure to prevent perl running out of stack space when
dumping an excessively deep structure.  Can be set to 0 to remove the
limit.  Default is 1000.

=item *

$Data::Dumper::Useperl  I<or>  $I<OBJ>->Useperl(I<[NEWVAL]>)

Can be set to a boolean value which controls whether the pure Perl
implementation of C<Data::Dumper> is used. The C<Data::Dumper> module is
a dual implementation, with almost all functionality written in both
pure Perl and also in XS ('C'). Since the XS version is much faster, it
will always be used if possible. This option lets you override the
default behavior, usually for testing purposes only. Default is 0, which
means the XS implementation will be used if possible.

=item *

$Data::Dumper::Sortkeys  I<or>  $I<OBJ>->Sortkeys(I<[NEWVAL]>)

Can be set to a boolean value to control whether hash keys are dumped in
sorted order. A true value will cause the keys of all hashes to be
dumped in Perl's default sort order. Can also be set to a subroutine
reference which will be called for each hash that is dumped. In this
case C<Data::Dumper> will call the subroutine once for each hash,
passing it the reference of the hash. The purpose of the subroutine is
to return a reference to an array of the keys that will be dumped, in
the order that they should be dumped. Using this feature, you can
control both the order of the keys, and which keys are actually used. In
other words, this subroutine acts as a filter by which you can exclude
certain keys from being dumped. Default is 0, which means that hash keys
are not sorted.

=item *

$Data::Dumper::Deparse  I<or>  $I<OBJ>->Deparse(I<[NEWVAL]>)

Can be set to a boolean value to control whether code references are
turned into perl source code. If set to a true value, C<B::Deparse>
will be used to get the source of the code reference. Using this option
will force using the Perl implementation of the dumper, since the fast
XSUB implementation doesn't support it.

Caution : use this option only if you know that your coderefs will be
properly reconstructed by C<B::Deparse>.

=item *

$Data::Dumper::Sparseseen I<or>  $I<OBJ>->Sparseseen(I<[NEWVAL]>)

By default, Data::Dumper builds up the "seen" hash of scalars that
it has encountered during serialization. This is very expensive.
This seen hash is necessary to support and even just detect circular
references. It is exposed to the user via the C<Seen()> call both
for writing and reading.

If you, as a user, do not need explicit access to the "seen" hash,
then you can set the C<Sparseseen> option to allow Data::Dumper
to eschew building the "seen" hash for scalars that are known not
to possess more than one reference. This speeds up serialization
considerably if you use the XS implementation.

Note: If you turn on C<Sparseseen>, then you must not rely on the
content of the seen hash since its contents will be an
implementation detail!

=back

=head2 Exports

=over 4

=item Dumper

=back

=head1 EXAMPLES

Run these code snippets to get a quick feel for the behavior of this
module.  When you are through with these examples, you may want to
add or change the various configuration variables described above,
to see their behavior.  (See the testsuite in the Data::Dumper
distribution for more examples.)


    use Data::Dumper;

    package Foo;
    sub new {bless {'a' => 1, 'b' => sub { return "foo" }}, $_[0]};

    package Fuz;                       # a weird REF-REF-SCALAR object
    sub new {bless \($_ = \ 'fu\'z'), $_[0]};

    package main;
    $foo = Foo->new;
    $fuz = Fuz->new;
    $boo = [ 1, [], "abcd", \*foo,
             {1 => 'a', 023 => 'b', 0x45 => 'c'},
             \\"p\q\'r", $foo, $fuz];

    ########
    # simple usage
    ########

    $bar = eval(Dumper($boo));
    print($@) if $@;
    print Dumper($boo), Dumper($bar);  # pretty print (no array indices)

    $Data::Dumper::Terse = 1;        # don't output names where feasible
    $Data::Dumper::Indent = 0;       # turn off all pretty print
    print Dumper($boo), "\n";

    $Data::Dumper::Indent = 1;       # mild pretty print
    print Dumper($boo);

    $Data::Dumper::Indent = 3;       # pretty print with array indices
    print Dumper($boo);

    $Data::Dumper::Useqq = 1;        # print strings in double quotes
    print Dumper($boo);

    $Data::Dumper::Pair = " : ";     # specify hash key/value separator
    print Dumper($boo);


    ########
    # recursive structures
    ########

    @c = ('c');
    $c = \@c;
    $b = {};
    $a = [1, $b, $c];
    $b->{a} = $a;
    $b->{b} = $a->[1];
    $b->{c} = $a->[2];
    print Data::Dumper->Dump([$a,$b,$c], [qw(a b c)]);


    $Data::Dumper::Purity = 1;         # fill in the holes for eval
    print Data::Dumper->Dump([$a, $b], [qw(*a b)]); # print as @a
    print Data::Dumper->Dump([$b, $a], [qw(*b a)]); # print as %b


    $Data::Dumper::Deepcopy = 1;       # avoid cross-refs
    print Data::Dumper->Dump([$b, $a], [qw(*b a)]);


    $Data::Dumper::Purity = 0;         # avoid cross-refs
    print Data::Dumper->Dump([$b, $a], [qw(*b a)]);

    ########
    # deep structures
    ########

    $a = "pearl";
    $b = [ $a ];
    $c = { 'b' => $b };
    $d = [ $c ];
    $e = { 'd' => $d };
    $f = { 'e' => $e };
    print Data::Dumper->Dump([$f], [qw(f)]);

    $Data::Dumper::Maxdepth = 3;       # no deeper than 3 refs down
    print Data::Dumper->Dump([$f], [qw(f)]);


    ########
    # object-oriented usage
    ########

    $d = Data::Dumper->new([$a,$b], [qw(a b)]);
    $d->Seen({'*c' => $c});            # stash a ref without printing it
    $d->Indent(3);
    print $d->Dump;
    $d->Reset->Purity(0);              # empty the seen cache
    print join "----\n", $d->Dump;


    ########
    # persistence
    ########

    package Foo;
    sub new { bless { state => 'awake' }, shift }
    sub Freeze {
        my $s = shift;
        print STDERR "preparing to sleep\n";
        $s->{state} = 'asleep';
        return bless $s, 'Foo::ZZZ';
    }

    package Foo::ZZZ;
    sub Thaw {
        my $s = shift;
        print STDERR "waking up\n";
        $s->{state} = 'awake';
        return bless $s, 'Foo';
    }

    package main;
    use Data::Dumper;
    $a = Foo->new;
    $b = Data::Dumper->new([$a], ['c']);
    $b->Freezer('Freeze');
    $b->Toaster('Thaw');
    $c = $b->Dump;
    print $c;
    $d = eval $c;
    print Data::Dumper->Dump([$d], ['d']);


    ########
    # symbol substitution (useful for recreating CODE refs)
    ########

    sub foo { print "foo speaking\n" }
    *other = \&foo;
    $bar = [ \&other ];
    $d = Data::Dumper->new([\&other,$bar],['*other','bar']);
    $d->Seen({ '*foo' => \&foo });
    print $d->Dump;


    ########
    # sorting and filtering hash keys
    ########

    $Data::Dumper::Sortkeys = \&my_filter;
    my $foo = { map { (ord, "$_$_$_") } 'I'..'Q' };
    my $bar = { %$foo };
    my $baz = { reverse %$foo };
    print Dumper [ $foo, $bar, $baz ];

    sub my_filter {
        my ($hash) = @_;
        # return an array ref containing the hash keys to dump
        # in the order that you want them to be dumped
        return [
          # Sort the keys of %$foo in reverse numeric order
            $hash eq $foo ? (sort {$b <=> $a} keys %$hash) :
          # Only dump the odd number keys of %$bar
            $hash eq $bar ? (grep {$_ % 2} keys %$hash) :
          # Sort keys in default order for all other hashes
            (sort keys %$hash)
        ];
    }

=head1 BUGS

Due to limitations of Perl subroutine call semantics, you cannot pass an
array or hash.  Prepend it with a C<\> to pass its reference instead.  This
will be remedied in time, now that Perl has subroutine prototypes.
For now, you need to use the extended usage form, and prepend the
name with a C<*> to output it as a hash or array.

C<Data::Dumper> cheats with CODE references.  If a code reference is
encountered in the structure being processed (and if you haven't set
the C<Deparse> flag), an anonymous subroutine that
contains the string '"DUMMY"' will be inserted in its place, and a warning
will be printed if C<Purity> is set.  You can C<eval> the result, but bear
in mind that the anonymous sub that gets created is just a placeholder.
Someday, perl will have a switch to cache-on-demand the string
representation of a compiled piece of code, I hope.  If you have prior
knowledge of all the code refs that your data structures are likely
to have, you can use the C<Seen> method to pre-seed the internal reference
table and make the dumped output point to them, instead.  See L</EXAMPLES>
above.

The C<Deparse> flag makes Dump() run slower, since the XSUB
implementation does not support it.

SCALAR objects have the weirdest looking C<bless> workaround.

Pure Perl version of C<Data::Dumper> escapes UTF-8 strings correctly
only in Perl 5.8.0 and later.

=head2 NOTE

Starting from Perl 5.8.1 different runs of Perl will have different
ordering of hash keys.  The change was done for greater security,
see L<perlsec/"Algorithmic Complexity Attacks">.  This means that
different runs of Perl will have different Data::Dumper outputs if
the data contains hashes.  If you need to have identical Data::Dumper
outputs from different runs of Perl, use the environment variable
PERL_HASH_SEED, see L<perlrun/PERL_HASH_SEED>.  Using this restores
the old (platform-specific) ordering: an even prettier solution might
be to use the C<Sortkeys> filter of Data::Dumper.

=head1 AUTHOR

Gurusamy Sarathy        gsar@activestate.com

Copyright (c) 1996-2014 Gurusamy Sarathy. All rights reserved.
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

=head1 VERSION

Version 2.160  (January 12 2016)

=head1 SEE ALSO

perl(1)

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ################################################################################
#
#  !!!!! Do NOT edit this file directly! -- Edit PPPort_pm.PL instead. !!!!!
#
#  This file was automatically generated from the definition files in the
#  parts/inc/ subdirectory by PPPort_pm.PL. To learn more about how all this
#  works, please read the F<HACKERS> file that came with this distribution.
#
################################################################################
#
#  Perl/Pollution/Portability
#
################################################################################
#
#  Version 3.x, Copyright (C) 2004-2013, Marcus Holland-Moritz.
#  Version 2.x, Copyright (C) 2001, Paul Marquess.
#  Version 1.x, Copyright (C) 1999, Kenneth Albanowski.
#
#  This program is free software; you can redistribute it and/or
#  modify it under the same terms as Perl itself.
#
################################################################################

=head1 NAME

Devel::PPPort - Perl/Pollution/Portability

=head1 SYNOPSIS

    Devel::PPPort::WriteFile();   # defaults to ./ppport.h
    Devel::PPPort::WriteFile('someheader.h');

    # Same as above but retrieve contents rather than write file
    my $contents = Devel::PPPort::GetFileContents();
    my $contents = Devel::PPPort::GetFileContents('someheader.h');

=head1 DESCRIPTION

Perl's API has changed over time, gaining new features, new functions,
increasing its flexibility, and reducing the impact on the C namespace
environment (reduced pollution). The header file written by this module,
typically F<ppport.h>, attempts to bring some of the newer Perl API
features to older versions of Perl, so that you can worry less about
keeping track of old releases, but users can still reap the benefit.

C<Devel::PPPort> contains two functions, C<WriteFile> and C<GetFileContents>.
C<WriteFile>'s only purpose is to write the F<ppport.h> C header file.
This file contains a series of macros and, if explicitly requested, functions
that allow XS modules to be built using older versions of Perl. Currently,
Perl versions from 5.003 to 5.20 are supported.

C<GetFileContents> can be used to retrieve the file contents rather than
writing it out.

This module is used by C<h2xs> to write the file F<ppport.h>.

=head2 Why use ppport.h?

You should use F<ppport.h> in modern code so that your code will work
with the widest range of Perl interpreters possible, without significant
additional work.

You should attempt older code to fully use F<ppport.h>, because the
reduced pollution of newer Perl versions is an important thing. It's so
important that the old polluting ways of original Perl modules will not be
supported very far into the future, and your module will almost certainly
break! By adapting to it now, you'll gain compatibility and a sense of
having done the electronic ecology some good.

=head2 How to use ppport.h

Don't direct the users of your module to download C<Devel::PPPort>.
They are most probably no XS writers. Also, don't make F<ppport.h>
optional. Rather, just take the most recent copy of F<ppport.h> that
you can find (e.g. by generating it with the latest C<Devel::PPPort>
release from CPAN), copy it into your project, adjust your project to
use it, and distribute the header along with your module.

=head2 Running ppport.h

But F<ppport.h> is more than just a C header. It's also a Perl script
that can check your source code. It will suggest hints and portability
notes, and can even make suggestions on how to change your code. You
can run it like any other Perl program:

    perl ppport.h [options] [files]

It also has embedded documentation, so you can use

    perldoc ppport.h

to find out more about how to use it.

=head1 FUNCTIONS

=head2 WriteFile

C<WriteFile> takes one optional argument. When called with one
argument, it expects to be passed a filename. When called with
no arguments, it defaults to the filename F<ppport.h>.

The function returns a true value if the file was written successfully.
Otherwise it returns a false value.

=head2 GetFileContents

C<GetFileContents> behaves like C<WriteFile> above, but returns the contents
of the would-be file rather than writing it out.

=head1 COMPATIBILITY

F<ppport.h> supports Perl versions from 5.003 to 5.20
in threaded and non-threaded configurations.

=head2 Provided Perl compatibility API

The header file written by this module, typically F<ppport.h>, provides
access to the following elements of the Perl API that is not available
in older Perl releases:

    _aMY_CXT
    _pMY_CXT
    aMY_CXT
    aMY_CXT_
    aTHX
    aTHX_
    aTHXR
    aTHXR_
    AvFILLp
    boolSV
    call_argv
    call_method
    call_pv
    call_sv
    caller_cx
    ckWARN
    CopFILE
    CopFILE_set
    CopFILEAV
    CopFILEGV
    CopFILEGV_set
    CopFILESV
    CopSTASH
    CopSTASH_eq
    CopSTASH_set
    CopSTASHPV
    CopSTASHPV_set
    CopyD
    CPERLscope
    dAX
    dAXMARK
    DEFSV
    DEFSV_set
    dITEMS
    dMY_CXT
    dMY_CXT_SV
    dNOOP
    dTHR
    dTHX
    dTHXa
    dTHXoa
    dTHXR
    dUNDERBAR
    dVAR
    dXCPT
    dXSTARG
    END_EXTERN_C
    ERRSV
    eval_pv
    eval_sv
    EXTERN_C
    G_METHOD
    get_av
    get_cv
    get_cvn_flags
    get_cvs
    get_hv
    get_sv
    grok_bin
    grok_hex
    grok_number
    GROK_NUMERIC_RADIX
    grok_numeric_radix
    grok_oct
    gv_fetchpvn_flags
    gv_fetchpvs
    gv_fetchsv
    gv_stashpvn
    gv_stashpvs
    GvSVn
    HEf_SVKEY
    HeUTF8
    hv_fetchs
    hv_stores
    HvNAME_get
    HvNAMELEN_get
    IN_LOCALE
    IN_LOCALE_COMPILETIME
    IN_LOCALE_RUNTIME
    IN_PERL_COMPILETIME
    INT2PTR
    IS_NUMBER_GREATER_THAN_UV_MAX
    IS_NUMBER_IN_UV
    IS_NUMBER_INFINITY
    IS_NUMBER_NAN
    IS_NUMBER_NEG
    IS_NUMBER_NOT_INT
    isALNUMC
    isASCII
    isBLANK
    isCNTRL
    isGRAPH
    isGV_with_GP
    isPRINT
    isPSXSPC
    isPUNCT
    isXDIGIT
    IVdf
    IVSIZE
    IVTYPE
    load_module
    memEQ
    memEQs
    memNE
    memNEs
    mg_findext
    MoveD
    mPUSHi
    mPUSHn
    mPUSHp
    mPUSHs
    mPUSHu
    MUTABLE_PTR
    MUTABLE_SV
    mXPUSHi
    mXPUSHn
    mXPUSHp
    mXPUSHs
    mXPUSHu
    MY_CXT
    MY_CXT_CLONE
    MY_CXT_INIT
    my_snprintf
    my_sprintf
    my_strlcat
    my_strlcpy
    newCONSTSUB
    newRV_inc
    newRV_noinc
    newSV_type
    newSVpvn
    newSVpvn_flags
    newSVpvn_share
    newSVpvn_utf8
    newSVpvs
    newSVpvs_flags
    newSVpvs_share
    newSVuv
    Newx
    Newxc
    Newxz
    NOOP
    NUM2PTR
    NVef
    NVff
    NVgf
    NVTYPE
    packWARN
    PERL_ABS
    PERL_BCDVERSION
    PERL_GCC_BRACE_GROUPS_FORBIDDEN
    PERL_HASH
    PERL_INT_MAX
    PERL_INT_MIN
    PERL_LONG_MAX
    PERL_LONG_MIN
    PERL_MAGIC_arylen
    PERL_MAGIC_backref
    PERL_MAGIC_bm
    PERL_MAGIC_collxfrm
    PERL_MAGIC_dbfile
    PERL_MAGIC_dbline
    PERL_MAGIC_defelem
    PERL_MAGIC_env
    PERL_MAGIC_envelem
    PERL_MAGIC_ext
    PERL_MAGIC_fm
    PERL_MAGIC_glob
    PERL_MAGIC_isa
    PERL_MAGIC_isaelem
    PERL_MAGIC_mutex
    PERL_MAGIC_nkeys
    PERL_MAGIC_overload
    PERL_MAGIC_overload_elem
    PERL_MAGIC_overload_table
    PERL_MAGIC_pos
    PERL_MAGIC_qr
    PERL_MAGIC_regdata
    PERL_MAGIC_regdatum
    PERL_MAGIC_regex_global
    PERL_MAGIC_shared
    PERL_MAGIC_shared_scalar
    PERL_MAGIC_sig
    PERL_MAGIC_sigelem
    PERL_MAGIC_substr
    PERL_MAGIC_sv
    PERL_MAGIC_taint
    PERL_MAGIC_tied
    PERL_MAGIC_tiedelem
    PERL_MAGIC_tiedscalar
    PERL_MAGIC_utf8
    PERL_MAGIC_uvar
    PERL_MAGIC_uvar_elem
    PERL_MAGIC_vec
    PERL_MAGIC_vstring
    PERL_PV_ESCAPE_ALL
    PERL_PV_ESCAPE_FIRSTCHAR
    PERL_PV_ESCAPE_NOBACKSLASH
    PERL_PV_ESCAPE_NOCLEAR
    PERL_PV_ESCAPE_QUOTE
    PERL_PV_ESCAPE_RE
    PERL_PV_ESCAPE_UNI
    PERL_PV_ESCAPE_UNI_DETECT
    PERL_PV_PRETTY_DUMP
    PERL_PV_PRETTY_ELLIPSES
    PERL_PV_PRETTY_LTGT
    PERL_PV_PRETTY_NOCLEAR
    PERL_PV_PRETTY_QUOTE
    PERL_PV_PRETTY_REGPROP
    PERL_QUAD_MAX
    PERL_QUAD_MIN
    PERL_REVISION
    PERL_SCAN_ALLOW_UNDERSCORES
    PERL_SCAN_DISALLOW_PREFIX
    PERL_SCAN_GREATER_THAN_UV_MAX
    PERL_SCAN_SILENT_ILLDIGIT
    PERL_SHORT_MAX
    PERL_SHORT_MIN
    PERL_SIGNALS_UNSAFE_FLAG
    PERL_SUBVERSION
    PERL_UCHAR_MAX
    PERL_UCHAR_MIN
    PERL_UINT_MAX
    PERL_UINT_MIN
    PERL_ULONG_MAX
    PERL_ULONG_MIN
    PERL_UNUSED_ARG
    PERL_UNUSED_CONTEXT
    PERL_UNUSED_DECL
    PERL_UNUSED_VAR
    PERL_UQUAD_MAX
    PERL_UQUAD_MIN
    PERL_USE_GCC_BRACE_GROUPS
    PERL_USHORT_MAX
    PERL_USHORT_MIN
    PERL_VERSION
    Perl_warner
    Perl_warner_nocontext
    PERLIO_FUNCS_CAST
    PERLIO_FUNCS_DECL
    PL_bufend
    PL_bufptr
    PL_compiling
    PL_copline
    PL_curcop
    PL_curstash
    PL_DBsignal
    PL_DBsingle
    PL_DBsub
    PL_DBtrace
    PL_debstash
    PL_defgv
    PL_diehook
    PL_dirty
    PL_dowarn
    PL_errgv
    PL_error_count
    PL_expect
    PL_hexdigit
    PL_hints
    PL_in_my
    PL_in_my_stash
    PL_laststatval
    PL_lex_state
    PL_lex_stuff
    PL_linestr
    PL_na
    PL_no_modify
    PL_parser
    PL_perl_destruct_level
    PL_perldb
    PL_ppaddr
    PL_rsfp
    PL_rsfp_filters
    PL_signals
    PL_stack_base
    PL_stack_sp
    PL_statcache
    PL_stdingv
    PL_Sv
    PL_sv_arenaroot
    PL_sv_no
    PL_sv_undef
    PL_sv_yes
    PL_tainted
    PL_tainting
    PL_tokenbuf
    pMY_CXT
    pMY_CXT_
    Poison
    PoisonFree
    PoisonNew
    PoisonWith
    pTHX
    pTHX_
    PTR2IV
    PTR2nat
    PTR2NV
    PTR2ul
    PTR2UV
    PTRV
    PUSHmortal
    PUSHu
    pv_display
    pv_escape
    pv_pretty
    SAVE_DEFSV
    START_EXTERN_C
    START_MY_CXT
    STMT_END
    STMT_START
    STR_WITH_LEN
    sv_2pv_flags
    sv_2pv_nolen
    sv_2pvbyte
    sv_2pvbyte_nolen
    sv_2uv
    sv_catpv_mg
    sv_catpvf_mg
    sv_catpvf_mg_nocontext
    sv_catpvn_mg
    sv_catpvn_nomg
    sv_catpvs
    sv_catsv_mg
    sv_catsv_nomg
    SV_CONST_RETURN
    SV_COW_DROP_PV
    SV_COW_SHARED_HASH_KEYS
    SV_GMAGIC
    SV_HAS_TRAILING_NUL
    SV_IMMEDIATE_UNREF
    sv_magic_portable
    SV_MUTABLE_RETURN
    SV_NOSTEAL
    sv_pvn_force_flags
    sv_pvn_nomg
    sv_setiv_mg
    sv_setnv_mg
    sv_setpv_mg
    sv_setpvf_mg
    sv_setpvf_mg_nocontext
    sv_setpvn_mg
    sv_setpvs
    sv_setsv_mg
    sv_setsv_nomg
    sv_setuv
    sv_setuv_mg
    SV_SMAGIC
    sv_unmagicext
    sv_usepvn_mg
    SV_UTF8_NO_ENCODING
    sv_uv
    sv_vcatpvf
    sv_vcatpvf_mg
    sv_vsetpvf
    sv_vsetpvf_mg
    SVf
    SVf_UTF8
    SVfARG
    SvGETMAGIC
    SvIV_nomg
    SvMAGIC_set
    SvPV_const
    SvPV_flags
    SvPV_flags_const
    SvPV_flags_const_nolen
    SvPV_flags_mutable
    SvPV_force
    SvPV_force_flags
    SvPV_force_flags_mutable
    SvPV_force_flags_nolen
    SvPV_force_mutable
    SvPV_force_nolen
    SvPV_force_nomg
    SvPV_force_nomg_nolen
    SvPV_mutable
    SvPV_nolen
    SvPV_nolen_const
    SvPV_nomg
    SvPV_nomg_const
    SvPV_nomg_const_nolen
    SvPV_nomg_nolen
    SvPV_renew
    SvPVbyte
    SvPVX_const
    SvPVX_mutable
    SvREFCNT_inc
    SvREFCNT_inc_NN
    SvREFCNT_inc_simple
    SvREFCNT_inc_simple_NN
    SvREFCNT_inc_simple_void
    SvREFCNT_inc_simple_void_NN
    SvREFCNT_inc_void
    SvREFCNT_inc_void_NN
    SvRV_set
    SvSHARED_HASH
    SvSTASH_set
    SvUOK
    SvUV
    SvUV_nomg
    SvUV_set
    SvUVX
    SvUVx
    SvUVXx
    SvVSTRING_mg
    UNDERBAR
    UTF8_MAXBYTES
    UVof
    UVSIZE
    UVTYPE
    UVuf
    UVXf
    UVxf
    vload_module
    vnewSVpvf
    WARN_ALL
    WARN_AMBIGUOUS
    WARN_ASSERTIONS
    WARN_BAREWORD
    WARN_CLOSED
    WARN_CLOSURE
    WARN_DEBUGGING
    WARN_DEPRECATED
    WARN_DIGIT
    WARN_EXEC
    WARN_EXITING
    WARN_GLOB
    WARN_INPLACE
    WARN_INTERNAL
    WARN_IO
    WARN_LAYER
    WARN_MALLOC
    WARN_MISC
    WARN_NEWLINE
    WARN_NUMERIC
    WARN_ONCE
    WARN_OVERFLOW
    WARN_PACK
    WARN_PARENTHESIS
    WARN_PIPE
    WARN_PORTABLE
    WARN_PRECEDENCE
    WARN_PRINTF
    WARN_PROTOTYPE
    WARN_QW
    WARN_RECURSION
    WARN_REDEFINE
    WARN_REGEXP
    WARN_RESERVED
    WARN_SEMICOLON
    WARN_SEVERE
    WARN_SIGNAL
    WARN_SUBSTR
    WARN_SYNTAX
    WARN_TAINT
    WARN_THREADS
    WARN_UNINITIALIZED
    WARN_UNOPENED
    WARN_UNPACK
    WARN_UNTIE
    WARN_UTF8
    WARN_VOID
    warner
    WIDEST_UTYPE
    XCPT_CATCH
    XCPT_RETHROW
    XCPT_TRY_END
    XCPT_TRY_START
    XPUSHmortal
    XPUSHu
    XSprePUSH
    XSPROTO
    XSRETURN
    XSRETURN_UV
    XST_mUV
    ZeroD

=head2 Perl API not supported by ppport.h

There is still a big part of the API not supported by F<ppport.h>.
Either because it doesn't make sense to back-port that part of the API,
or simply because it hasn't been implemented yet. Patches welcome!

Here's a list of the currently unsupported API, and also the version of
Perl below which it is unsupported:

=over 4

=item perl 5.21.8

  BhkDISABLE
  BhkENABLE
  BhkENTRY_set
  MULTICALL
  PERL_SYS_TERM
  POP_MULTICALL
  PUSH_MULTICALL
  PadARRAY
  PadMAX
  PadlistARRAY
  PadlistMAX
  PadlistNAMES
  PadlistNAMESARRAY
  PadlistNAMESMAX
  PadnameLEN
  PadnamePV
  PadnameREFCNT
  PadnameREFCNT_dec
  PadnameSV
  PadnamelistARRAY
  PadnamelistMAX
  PadnamelistREFCNT
  PadnamelistREFCNT_dec
  XS_APIVERSION_BOOTCHECK
  XS_EXTERNAL
  XS_INTERNAL
  XS_VERSION_BOOTCHECK
  XopDISABLE
  XopENABLE
  XopENTRY
  XopENTRYCUSTOM
  XopENTRY_set
  cophh_new_empty
  my_lstat
  my_stat
  reentrant_free
  reentrant_init
  reentrant_retry
  reentrant_size
  ref
  sv_get_backrefs
  sv_setref_pvs

=item perl 5.21.7

  OpHAS_SIBLING
  OpSIBLING
  OpSIBLING_set
  PadnameUTF8
  is_invariant_string
  newPADNAMELIST
  newPADNAMEouter
  newPADNAMEpvn
  newUNOP_AUX
  padnamelist_fetch
  padnamelist_store

=item perl 5.21.6

  newDEFSVOP
  op_convert_list

=item perl 5.21.5

  cv_name
  newMETHOP
  newMETHOP_named

=item perl 5.21.4

  cv_set_call_checker_flags
  grok_infnan
  isinfnan
  sync_locale

=item perl 5.21.2

  grok_number_flags
  op_parent
  op_sibling_splice

=item perl 5.21.1

  _is_in_locale_category
  _is_utf8_char_slow
  _is_utf8_idcont
  _is_utf8_idstart
  _is_utf8_xidcont
  _is_utf8_xidstart
  isALNUM_lazy
  isIDFIRST_lazy
  isUTF8_CHAR
  markstack_grow
  my_strerror

=item perl 5.19.10

  OP_TYPE_IS_OR_WAS

=item perl 5.19.9

  _to_utf8_fold_flags
  _to_utf8_lower_flags
  _to_utf8_title_flags
  _to_utf8_upper_flags

=item perl 5.19.7

  OP_TYPE_IS

=item perl 5.19.4

  append_utf8_from_native_byte
  is_safe_syscall
  uvoffuni_to_utf8_flags

=item perl 5.19.3

  croak_memory_wrap
  sv_pos_b2u_flags

=item perl 5.19.2

  SVt_INVLIST

=item perl 5.19.1

  re_intuit_start
  toFOLD
  toFOLD_utf8
  toLOWER_L1
  toTITLE

=item perl 5.18.0

  hv_rand_set

=item perl 5.17.9

  av_tindex
  av_top_index

=item perl 5.17.8

  _is_uni_FOO
  _is_uni_perl_idcont
  _is_utf8_FOO
  _is_utf8_mark
  _is_utf8_perl_idcont
  isALPHANUMERIC
  isIDCONT

=item perl 5.17.7

  SvREFCNT_dec_NN
  _is_uni_perl_idstart
  _is_utf8_perl_idstart
  is_uni_alnumc
  is_uni_alnumc_lc
  is_utf8_alnumc

=item perl 5.17.6

  READ_XDIGIT

=item perl 5.17.4

  PL_comppad_name
  PadlistREFCNT
  newMYSUB
  newSVpadname

=item perl 5.17.2

  is_uni_blank
  is_uni_blank_lc
  is_utf8_blank
  sv_copypv_flags
  sv_copypv_nomg
  sv_vcatpvfn_flags

=item perl 5.15.9

  utf8_to_uvchr_buf
  utf8_to_uvuni_buf
  valid_utf8_to_uvchr
  valid_utf8_to_uvuni

=item perl 5.15.8

  is_utf8_char_buf
  wrap_op_checker

=item perl 5.15.7

  toLOWER_utf8
  toTITLE_utf8
  toUPPER_utf8
  to_utf8_fold
  to_utf8_lower
  to_utf8_title
  to_utf8_upper

=item perl 5.15.6

  newCONSTSUB_flags

=item perl 5.15.4

  HvENAMELEN
  HvENAMEUTF8
  HvNAMELEN
  HvNAMEUTF8
  gv_autoload_pv
  gv_autoload_pvn
  gv_autoload_sv
  gv_fetchmeth_pv
  gv_fetchmeth_pv_autoload
  gv_fetchmeth_pvn
  gv_fetchmeth_pvn_autoload
  gv_fetchmeth_sv
  gv_fetchmeth_sv_autoload
  gv_fetchmethod_pv_flags
  gv_fetchmethod_pvn_flags
  gv_fetchmethod_sv_flags
  gv_init_pv
  gv_init_pvn
  gv_init_sv
  newGVgen_flags
  sv_derived_from_pv
  sv_derived_from_pvn
  sv_derived_from_sv
  sv_does_pv
  sv_does_pvn
  sv_does_sv
  whichsig_pv
  whichsig_pvn
  whichsig_sv

=item perl 5.15.1

  cop_fetch_label
  cop_store_label
  pad_add_name_pv
  pad_add_name_pvn
  pad_add_name_pvs
  pad_add_name_sv
  pad_findmy_pv
  pad_findmy_pvn
  pad_findmy_pvs
  pad_findmy_sv

=item perl 5.14.0

  _to_uni_fold_flags

=item perl 5.13.10

  foldEQ_utf8_flags
  is_utf8_xidcont
  is_utf8_xidfirst

=item perl 5.13.8

  foldEQ_latin1
  parse_arithexpr
  parse_fullexpr
  parse_listexpr
  parse_termexpr

=item perl 5.13.7

  HvENAME
  OP_CLASS
  XopFLAGS
  amagic_deref_call
  bytes_cmp_utf8
  cop_hints_2hv
  cop_hints_fetch_pv
  cop_hints_fetch_pvn
  cop_hints_fetch_pvs
  cop_hints_fetch_sv
  cophh_2hv
  cophh_copy
  cophh_delete_pv
  cophh_delete_pvn
  cophh_delete_pvs
  cophh_delete_sv
  cophh_fetch_pv
  cophh_fetch_pvn
  cophh_fetch_pvs
  cophh_fetch_sv
  cophh_free
  cophh_store_pv
  cophh_store_pvn
  cophh_store_pvs
  cophh_store_sv
  custom_op_register
  custom_op_xop
  newFOROP
  newWHILEOP
  op_lvalue
  op_scope
  parse_barestmt
  parse_block
  parse_label

=item perl 5.13.6

  LINKLIST
  SvTRUE_nomg
  ck_entersub_args_list
  ck_entersub_args_proto
  ck_entersub_args_proto_or_list
  cv_get_call_checker
  cv_set_call_checker
  isWORDCHAR
  lex_stuff_pv
  mg_free_type
  newSVpv_share
  op_append_elem
  op_append_list
  op_contextualize
  op_linklist
  op_prepend_elem
  parse_stmtseq
  rv2cv_op_cv
  savesharedpvs
  savesharedsvpv
  sv_2bool_flags
  sv_catpv_flags
  sv_catpv_nomg
  sv_catpvs_flags
  sv_catpvs_mg
  sv_catpvs_nomg
  sv_cmp_flags
  sv_cmp_locale_flags
  sv_collxfrm_flags
  sv_eq_flags
  sv_setpvs_mg

=item perl 5.13.5

  PL_rpeepp
  isOCTAL
  lex_stuff_pvs
  parse_fullstmt

=item perl 5.13.3

  blockhook_register
  croak_no_modify

=item perl 5.13.2

  SvNV_nomg
  find_rundefsv
  foldEQ
  foldEQ_locale
  foldEQ_utf8
  hv_fill
  sv_dec_nomg
  sv_inc_nomg

=item perl 5.13.1

  croak_sv
  die_sv
  mess_sv
  sv_2nv_flags
  warn_sv

=item perl 5.11.5

  sv_pos_u2b_flags

=item perl 5.11.4

  prescan_version

=item perl 5.11.2

  PL_keyword_plugin
  lex_bufutf8
  lex_discard_to
  lex_grow_linestr
  lex_next_chunk
  lex_peek_unichar
  lex_read_space
  lex_read_to
  lex_read_unichar
  lex_stuff_pvn
  lex_stuff_sv
  lex_unstuff

=item perl 5.11.1

  ck_warner
  ck_warner_d
  is_utf8_perl_space
  is_utf8_perl_word
  is_utf8_posix_digit

=item perl 5.11.0

  Gv_AMupdate
  PL_opfreehook
  SVt_REGEXP
  SvOOK_offset
  av_iter_p
  gv_add_by_type
  is_ascii_string
  pregfree2
  save_adelete
  save_aelem_flags
  save_hdelete
  save_helem_flags
  sv_utf8_upgrade_flags_grow

=item perl 5.10.1

  croak_xs_usage
  mro_get_from_name
  mro_get_private_data
  mro_register
  mro_set_mro
  mro_set_private_data
  save_hints
  save_padsv_and_mortalize
  save_pushi32ptr
  save_pushptr
  save_pushptrptr
  sv_insert_flags

=item perl 5.10.0

  hv_common
  hv_common_key_len
  sv_destroyable
  sys_init
  sys_init3
  sys_term

=item perl 5.9.5

  Perl_signbit
  SvRX
  SvRXOK
  av_create_and_push
  av_create_and_unshift_one
  gv_fetchfile_flags
  lex_start
  mro_get_linear_isa
  mro_method_changed_in
  my_dirfd
  pregcomp
  ptr_table_clear
  ptr_table_fetch
  ptr_table_free
  ptr_table_new
  ptr_table_split
  ptr_table_store
  re_compile
  reg_named_buff_all
  reg_named_buff_exists
  reg_named_buff_fetch
  reg_named_buff_firstkey
  reg_named_buff_nextkey
  reg_named_buff_scalar
  regfree_internal
  savesharedpvn
  scan_vstring
  upg_version

=item perl 5.9.4

  PerlIO_context_layers
  gv_name_set
  hv_copy_hints_hv
  my_vsnprintf
  newXS_flags
  regclass_swash
  sv_does
  sv_usepvn_flags

=item perl 5.9.3

  av_arylen_p
  ckwarn
  ckwarn_d
  csighandler
  dMULTICALL
  doref
  gv_const_sv
  hv_eiter_p
  hv_eiter_set
  hv_name_set
  hv_placeholders_get
  hv_placeholders_set
  hv_riter_p
  hv_riter_set
  is_utf8_string_loclen
  newGIVENOP
  newSVhek
  newWHENOP
  pad_compname_type
  savepvs
  sortsv_flags
  vverify

=item perl 5.9.2

  SvPVbyte_force
  find_rundefsvoffset
  op_refcnt_lock
  op_refcnt_unlock
  savesvpv
  vnormal

=item perl 5.9.1

  hv_clear_placeholders
  hv_scalar
  scan_version
  sv_2iv_flags
  sv_2uv_flags

=item perl 5.9.0

  new_version
  save_set_svflags
  vcmp
  vnumify
  vstringify

=item perl 5.8.3

  SvIsCOW
  SvIsCOW_shared_hash

=item perl 5.8.1

  CvPADLIST
  PL_comppad
  SvVOK
  doing_taint
  find_runcv
  is_utf8_string_loc
  packlist
  pad_add_anon
  pad_new
  pad_tidy
  save_bool
  savestack_grow_cnt
  seed
  sv_cat_decode
  sv_setpviv
  sv_setpviv_mg
  unpackstring

=item perl 5.8.0

  HeUTF8
  hv_iternext_flags
  hv_store_flags
  is_utf8_idcont
  nothreadhook

=item perl 5.7.3

  OP_DESC
  OP_NAME
  PL_peepp
  PerlIO_clearerr
  PerlIO_close
  PerlIO_eof
  PerlIO_error
  PerlIO_fileno
  PerlIO_fill
  PerlIO_flush
  PerlIO_get_base
  PerlIO_get_bufsiz
  PerlIO_get_cnt
  PerlIO_get_ptr
  PerlIO_read
  PerlIO_seek
  PerlIO_set_cnt
  PerlIO_set_ptrcnt
  PerlIO_setlinebuf
  PerlIO_stderr
  PerlIO_stdin
  PerlIO_stdout
  PerlIO_tell
  PerlIO_unread
  PerlIO_write
  SvLOCK
  SvSHARE
  SvUNLOCK
  atfork_lock
  atfork_unlock
  custom_op_desc
  custom_op_name
  deb
  debstack
  debstackptrs
  gv_fetchmeth_autoload
  ibcmp_utf8
  my_fork
  my_socketpair
  pack_cat
  perl_destruct
  pv_uni_display
  save_shared_pvref
  savesharedpv
  sortsv
  sv_magicext
  sv_nolocking
  sv_nosharing
  sv_recode_to_utf8
  sv_uni_display
  toFOLD_uni
  toLOWER_uni
  toTITLE_uni
  toUPPER_uni
  to_uni_fold
  to_uni_lower
  to_uni_title
  to_uni_upper
  to_utf8_case
  unpack_str
  uvchr_to_utf8_flags
  uvuni_to_utf8_flags
  vdeb

=item perl 5.7.2

  calloc
  getcwd_sv
  init_tm
  malloc
  mfree
  mini_mktime
  my_atof2
  my_strftime
  op_null
  realloc
  sv_catpvn_flags
  sv_catsv_flags
  sv_setsv_flags
  sv_utf8_upgrade_flags
  sv_utf8_upgrade_nomg
  swash_fetch

=item perl 5.7.1

  ASCII_TO_NEED
  NATIVE_TO_NEED
  POPpbytex
  bytes_from_utf8
  despatch_signals
  do_openn
  gv_handler
  is_lvalue_sub
  my_popen_list
  save_mortalizesv
  scan_num
  sv_force_normal_flags
  sv_setref_uv
  sv_unref_flags
  sv_utf8_upgrade
  utf8_length
  utf8_to_uvchr
  utf8_to_uvuni
  utf8n_to_uvchr
  utf8n_to_uvuni
  uvchr_to_utf8
  uvuni_to_utf8

=item perl 5.6.1

  SvGAMAGIC
  apply_attrs_string
  bytes_to_utf8
  gv_efullname4
  gv_fullname4
  is_utf8_string
  save_generic_pvref
  utf16_to_utf8
  utf16_to_utf8_reversed
  utf8_to_bytes

=item perl 5.6.0

  PERL_SYS_INIT3
  PL_check
  SvIOK_UV
  SvIOK_notUV
  SvIOK_only_UV
  SvPOK_only_UTF8
  SvPVbyte_nolen
  SvPVbytex
  SvPVbytex_force
  SvPVutf8
  SvPVutf8_force
  SvPVutf8_nolen
  SvPVutf8x
  SvPVutf8x_force
  SvUOK
  SvUTF8
  SvUTF8_off
  SvUTF8_on
  av_delete
  av_exists
  call_atexit
  caller_cx
  cast_i32
  cast_iv
  cast_ulong
  cast_uv
  do_gv_dump
  do_gvgv_dump
  do_hv_dump
  do_magic_dump
  do_op_dump
  do_open9
  do_pmop_dump
  do_sv_dump
  dump_all
  dump_eval
  dump_form
  dump_indent
  dump_packsubs
  dump_sub
  dump_vindent
  get_context
  get_ppaddr
  gv_dump
  init_i18nl10n
  init_i18nl14n
  is_uni_alnum
  is_uni_alnum_lc
  is_uni_alpha
  is_uni_alpha_lc
  is_uni_ascii
  is_uni_ascii_lc
  is_uni_cntrl
  is_uni_cntrl_lc
  is_uni_digit
  is_uni_digit_lc
  is_uni_graph
  is_uni_graph_lc
  is_uni_idfirst
  is_uni_idfirst_lc
  is_uni_lower
  is_uni_lower_lc
  is_uni_print
  is_uni_print_lc
  is_uni_punct
  is_uni_punct_lc
  is_uni_space
  is_uni_space_lc
  is_uni_upper
  is_uni_upper_lc
  is_uni_xdigit
  is_uni_xdigit_lc
  is_utf8_alnum
  is_utf8_alpha
  is_utf8_ascii
  is_utf8_char
  is_utf8_cntrl
  is_utf8_digit
  is_utf8_graph
  is_utf8_idfirst
  is_utf8_lower
  is_utf8_mark
  is_utf8_print
  is_utf8_punct
  is_utf8_space
  is_utf8_upper
  is_utf8_xdigit
  magic_dump
  mess
  my_atof
  my_fflush_all
  newANONATTRSUB
  newATTRSUB
  newXS
  newXSproto
  new_collate
  new_ctype
  new_numeric
  op_dump
  perl_parse
  pmop_dump
  re_intuit_string
  reginitcolors
  require_pv
  safesyscalloc
  safesysfree
  safesysmalloc
  safesysrealloc
  save_I8
  save_alloc
  save_destructor
  save_destructor_x
  save_re_context
  save_vptr
  scan_bin
  set_context
  set_numeric_local
  set_numeric_radix
  set_numeric_standard
  str_to_version
  sv_2pvutf8
  sv_2pvutf8_nolen
  sv_force_normal
  sv_len_utf8
  sv_pos_b2u
  sv_pos_u2b
  sv_pv
  sv_pvbyte
  sv_pvbyten
  sv_pvbyten_force
  sv_pvutf8
  sv_pvutf8n
  sv_pvutf8n_force
  sv_rvweaken
  sv_utf8_decode
  sv_utf8_downgrade
  sv_utf8_encode
  swash_init
  to_uni_lower_lc
  to_uni_title_lc
  to_uni_upper_lc
  utf8_distance
  utf8_hop
  vcroak
  vform
  vmess
  vwarn
  vwarner

=item perl 5.005_03

  POPpx
  get_vtbl
  save_generic_svref

=item perl 5.005

  PL_curpad
  PL_modglobal
  cx_dump
  debop
  debprofdump
  fbm_compile
  fbm_instr
  get_op_descs
  get_op_names
  init_stacks
  mg_length
  mg_size
  newHVhv
  new_stackinfo
  regdump
  regexec_flags
  regnext
  runops_debug
  runops_standard
  save_iv
  save_op
  sv_iv
  sv_nv
  sv_peek
  sv_pvn
  sv_pvn_nomg
  sv_true

=item perl 5.004_05

  CopyD
  MoveD
  do_binmode
  save_aelem
  save_helem

=item perl 5.004

  GIMME_V
  G_VOID
  HePV
  HeSVKEY_set
  SvSetMagicSV
  SvSetMagicSV_nosteal
  SvSetSV_nosteal
  SvTAINTED
  SvTAINTED_off
  SvTAINTED_on
  block_end
  block_gimme
  block_start
  call_list
  delimcpy
  form
  gv_autoload4
  gv_fetchmethod_autoload
  hv_delayfree_ent
  hv_free_ent
  ibcmp_locale
  intro_my
  my_failure_exit
  newSVpvf
  rsignal
  rsignal_state
  save_I16
  save_gp
  share_hek
  start_subparse
  sv_catpvf
  sv_catpvf_mg
  sv_cmp_locale
  sv_derived_from
  sv_magic_portable
  sv_setpvf
  sv_setpvf_mg
  sv_taint
  sv_tainted
  sv_untaint
  sv_vcatpvf
  sv_vcatpvf_mg
  sv_vcatpvfn
  sv_vsetpvf
  sv_vsetpvf_mg
  sv_vsetpvfn
  toLOWER_LC
  vnewSVpvf
  warner

=item perl 5.003_07

  HeHASH
  HeKEY
  HeKLEN
  HeSVKEY
  HeSVKEY_force
  HeVAL
  cv_const_sv
  do_open
  gv_efullname3
  gv_fullname3
  hv_delete_ent
  hv_exists_ent
  hv_fetch_ent
  hv_iterkeysv
  hv_ksplit
  hv_store_ent
  my_pclose
  my_popen
  sv_gets
  unsharepvn

=back

=head1 BUGS

If you find any bugs, C<Devel::PPPort> doesn't seem to build on your
system, or any of its tests fail, please file an issue here:
L<https://github.com/mhx/Devel-PPPort/issues/>

=head1 AUTHORS

=over 2

=item *

Version 1.x of Devel::PPPort was written by Kenneth Albanowski.

=item *

Version 2.x was ported to the Perl core by Paul Marquess.

=item *

Version 3.x was ported back to CPAN by Marcus Holland-Moritz.

=item * 

Versions >= 3.22 are maintained with support from Matthew Horsfall (alh).

=back

=head1 COPYRIGHT

Version 3.x, Copyright (C) 2004-2013, Marcus Holland-Moritz.

Version 2.x, Copyright (C) 2001, Paul Marquess.

Version 1.x, Copyright (C) 1999, Kenneth Albanowski.

This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

=head1 SEE ALSO

See L<h2xs>, L<ppport.h>.

=cut

package Devel::PPPort;

use strict;
use vars qw($VERSION $data);

$VERSION = '3.32';

sub _init_data
{
  $data = do { local $/; <DATA> };
  my $pkg = 'Devel::PPPort';
  $data =~ s/__PERL_VERSION__/$]/g;
  $data =~ s/__VERSION__/$VERSION/g;
  $data =~ s/__PKG__/$pkg/g;
  $data =~ s/^\|>//gm;
}

sub GetFileContents {
  my $file = shift || 'ppport.h';
  defined $data or _init_data();
  my $copy = $data;
  $copy =~ s/\bppport\.h\b/$file/g;

  return $copy;
}

sub WriteFile
{
  my $file = shift || 'ppport.h';
  my $data = GetFileContents($file);
  open F, ">$file" or return undef;
  print F $data;
  close F;

  return 1;
}

1;

__DATA__
#if 0
<<'SKIP';
#endif
/*
----------------------------------------------------------------------

    ppport.h -- Perl/Pollution/Portability Version __VERSION__

    Automatically created by __PKG__ running under perl __PERL_VERSION__.

    Do NOT edit this file directly! -- Edit PPPort_pm.PL and the
    includes in parts/inc/ instead.

    Use 'perldoc ppport.h' to view the documentation below.

----------------------------------------------------------------------

SKIP

|>=pod
|>
|>=head1 NAME
|>
|>ppport.h - Perl/Pollution/Portability version __VERSION__
|>
|>=head1 SYNOPSIS
|>
|>  perl ppport.h [options] [source files]
|>
|>  Searches current directory for files if no [source files] are given
|>
|>  --help                      show short help
|>
|>  --version                   show version
|>
|>  --patch=file                write one patch file with changes
|>  --copy=suffix               write changed copies with suffix
|>  --diff=program              use diff program and options
|>
|>  --compat-version=version    provide compatibility with Perl version
|>  --cplusplus                 accept C++ comments
|>
|>  --quiet                     don't output anything except fatal errors
|>  --nodiag                    don't show diagnostics
|>  --nohints                   don't show hints
|>  --nochanges                 don't suggest changes
|>  --nofilter                  don't filter input files
|>
|>  --strip                     strip all script and doc functionality from
|>                              ppport.h
|>
|>  --list-provided             list provided API
|>  --list-unsupported          list unsupported API
|>  --api-info=name             show Perl API portability information
|>
|>=head1 COMPATIBILITY
|>
|>This version of F<ppport.h> is designed to support operation with Perl
|>installations back to 5.003, and has been tested up to 5.20.
|>
|>=head1 OPTIONS
|>
|>=head2 --help
|>
|>Display a brief usage summary.
|>
|>=head2 --version
|>
|>Display the version of F<ppport.h>.
|>
|>=head2 --patch=I<file>
|>
|>If this option is given, a single patch file will be created if
|>any changes are suggested. This requires a working diff program
|>to be installed on your system.
|>
|>=head2 --copy=I<suffix>
|>
|>If this option is given, a copy of each file will be saved with
|>the given suffix that contains the suggested changes. This does
|>not require any external programs. Note that this does not
|>automagically add a dot between the original filename and the
|>suffix. If you want the dot, you have to include it in the option
|>argument.
|>
|>If neither C<--patch> or C<--copy> are given, the default is to
|>simply print the diffs for each file. This requires either
|>C<Text::Diff> or a C<diff> program to be installed.
|>
|>=head2 --diff=I<program>
|>
|>Manually set the diff program and options to use. The default
|>is to use C<Text::Diff>, when installed, and output unified
|>context diffs.
|>
|>=head2 --compat-version=I<version>
|>
|>Tell F<ppport.h> to check for compatibility with the given
|>Perl version. The default is to check for compatibility with Perl
|>version 5.003. You can use this option to reduce the output
|>of F<ppport.h> if you intend to be backward compatible only
|>down to a certain Perl version.
|>
|>=head2 --cplusplus
|>
|>Usually, F<ppport.h> will detect C++ style comments and
|>replace them with C style comments for portability reasons.
|>Using this option instructs F<ppport.h> to leave C++
|>comments untouched.
|>
|>=head2 --quiet
|>
|>Be quiet. Don't print anything except fatal errors.
|>
|>=head2 --nodiag
|>
|>Don't output any diagnostic messages. Only portability
|>alerts will be printed.
|>
|>=head2 --nohints
|>
|>Don't output any hints. Hints often contain useful portability
|>notes. Warnings will still be displayed.
|>
|>=head2 --nochanges
|>
|>Don't suggest any changes. Only give diagnostic output and hints
|>unless these are also deactivated.
|>
|>=head2 --nofilter
|>
|>Don't filter the list of input files. By default, files not looking
|>like source code (i.e. not *.xs, *.c, *.cc, *.cpp or *.h) are skipped.
|>
|>=head2 --strip
|>
|>Strip all script and documentation functionality from F<ppport.h>.
|>This reduces the size of F<ppport.h> dramatically and may be useful
|>if you want to include F<ppport.h> in smaller modules without
|>increasing their distribution size too much.
|>
|>The stripped F<ppport.h> will have a C<--unstrip> option that allows
|>you to undo the stripping, but only if an appropriate C<Devel::PPPort>
|>module is installed.
|>
|>=head2 --list-provided
|>
|>Lists the API elements for which compatibility is provided by
|>F<ppport.h>. Also lists if it must be explicitly requested,
|>if it has dependencies, and if there are hints or warnings for it.
|>
|>=head2 --list-unsupported
|>
|>Lists the API elements that are known not to be supported by
|>F<ppport.h> and below which version of Perl they probably
|>won't be available or work.
|>
|>=head2 --api-info=I<name>
|>
|>Show portability information for API elements matching I<name>.
|>If I<name> is surrounded by slashes, it is interpreted as a regular
|>expression.
|>
|>=head1 DESCRIPTION
|>
|>In order for a Perl extension (XS) module to be as portable as possible
|>across differing versions of Perl itself, certain steps need to be taken.
|>
|>=over 4
|>
|>=item *
|>
|>Including this header is the first major one. This alone will give you
|>access to a large part of the Perl API that hasn't been available in
|>earlier Perl releases. Use
|>
|>    perl ppport.h --list-provided
|>
|>to see which API elements are provided by ppport.h.
|>
|>=item *
|>
|>You should avoid using deprecated parts of the API. For example, using
|>global Perl variables without the C<PL_> prefix is deprecated. Also,
|>some API functions used to have a C<perl_> prefix. Using this form is
|>also deprecated. You can safely use the supported API, as F<ppport.h>
|>will provide wrappers for older Perl versions.
|>
|>=item *
|>
|>If you use one of a few functions or variables that were not present in
|>earlier versions of Perl, and that can't be provided using a macro, you
|>have to explicitly request support for these functions by adding one or
|>more C<#define>s in your source code before the inclusion of F<ppport.h>.
|>
|>These functions or variables will be marked C<explicit> in the list shown
|>by C<--list-provided>.
|>
|>Depending on whether you module has a single or multiple files that
|>use such functions or variables, you want either C<static> or global
|>variants.
|>
|>For a C<static> function or variable (used only in a single source
|>file), use:
|>
|>    #define NEED_function
|>    #define NEED_variable
|>
|>For a global function or variable (used in multiple source files),
|>use:
|>
|>    #define NEED_function_GLOBAL
|>    #define NEED_variable_GLOBAL
|>
|>Note that you mustn't have more than one global request for the
|>same function or variable in your project.
|>
|>    Function / Variable       Static Request               Global Request
|>    -----------------------------------------------------------------------------------------
|>    PL_parser                 NEED_PL_parser               NEED_PL_parser_GLOBAL
|>    PL_signals                NEED_PL_signals              NEED_PL_signals_GLOBAL
|>    caller_cx()               NEED_caller_cx               NEED_caller_cx_GLOBAL
|>    eval_pv()                 NEED_eval_pv                 NEED_eval_pv_GLOBAL
|>    grok_bin()                NEED_grok_bin                NEED_grok_bin_GLOBAL
|>    grok_hex()                NEED_grok_hex                NEED_grok_hex_GLOBAL
|>    grok_number()             NEED_grok_number             NEED_grok_number_GLOBAL
|>    grok_numeric_radix()      NEED_grok_numeric_radix      NEED_grok_numeric_radix_GLOBAL
|>    grok_oct()                NEED_grok_oct                NEED_grok_oct_GLOBAL
|>    load_module()             NEED_load_module             NEED_load_module_GLOBAL
|>    mg_findext()              NEED_mg_findext              NEED_mg_findext_GLOBAL
|>    my_snprintf()             NEED_my_snprintf             NEED_my_snprintf_GLOBAL
|>    my_sprintf()              NEED_my_sprintf              NEED_my_sprintf_GLOBAL
|>    my_strlcat()              NEED_my_strlcat              NEED_my_strlcat_GLOBAL
|>    my_strlcpy()              NEED_my_strlcpy              NEED_my_strlcpy_GLOBAL
|>    newCONSTSUB()             NEED_newCONSTSUB             NEED_newCONSTSUB_GLOBAL
|>    newRV_noinc()             NEED_newRV_noinc             NEED_newRV_noinc_GLOBAL
|>    newSV_type()              NEED_newSV_type              NEED_newSV_type_GLOBAL
|>    newSVpvn_flags()          NEED_newSVpvn_flags          NEED_newSVpvn_flags_GLOBAL
|>    newSVpvn_share()          NEED_newSVpvn_share          NEED_newSVpvn_share_GLOBAL
|>    pv_display()              NEED_pv_display              NEED_pv_display_GLOBAL
|>    pv_escape()               NEED_pv_escape               NEED_pv_escape_GLOBAL
|>    pv_pretty()               NEED_pv_pretty               NEED_pv_pretty_GLOBAL
|>    sv_2pv_flags()            NEED_sv_2pv_flags            NEED_sv_2pv_flags_GLOBAL
|>    sv_2pvbyte()              NEED_sv_2pvbyte              NEED_sv_2pvbyte_GLOBAL
|>    sv_catpvf_mg()            NEED_sv_catpvf_mg            NEED_sv_catpvf_mg_GLOBAL
|>    sv_catpvf_mg_nocontext()  NEED_sv_catpvf_mg_nocontext  NEED_sv_catpvf_mg_nocontext_GLOBAL
|>    sv_pvn_force_flags()      NEED_sv_pvn_force_flags      NEED_sv_pvn_force_flags_GLOBAL
|>    sv_setpvf_mg()            NEED_sv_setpvf_mg            NEED_sv_setpvf_mg_GLOBAL
|>    sv_setpvf_mg_nocontext()  NEED_sv_setpvf_mg_nocontext  NEED_sv_setpvf_mg_nocontext_GLOBAL
|>    sv_unmagicext()           NEED_sv_unmagicext           NEED_sv_unmagicext_GLOBAL
|>    vload_module()            NEED_vload_module            NEED_vload_module_GLOBAL
|>    vnewSVpvf()               NEED_vnewSVpvf               NEED_vnewSVpvf_GLOBAL
|>    warner()                  NEED_warner                  NEED_warner_GLOBAL
|>
|>To avoid namespace conflicts, you can change the namespace of the
|>explicitly exported functions / variables using the C<DPPP_NAMESPACE>
|>macro. Just C<#define> the macro before including C<ppport.h>:
|>
|>    #define DPPP_NAMESPACE MyOwnNamespace_
|>    #include "ppport.h"
|>
|>The default namespace is C<DPPP_>.
|>
|>=back
|>
|>The good thing is that most of the above can be checked by running
|>F<ppport.h> on your source code. See the next section for
|>details.
|>
|>=head1 EXAMPLES
|>
|>To verify whether F<ppport.h> is needed for your module, whether you
|>should make any changes to your code, and whether any special defines
|>should be used, F<ppport.h> can be run as a Perl script to check your
|>source code. Simply say:
|>
|>    perl ppport.h
|>
|>The result will usually be a list of patches suggesting changes
|>that should at least be acceptable, if not necessarily the most
|>efficient solution, or a fix for all possible problems.
|>
|>If you know that your XS module uses features only available in
|>newer Perl releases, if you're aware that it uses C++ comments,
|>and if you want all suggestions as a single patch file, you could
|>use something like this:
|>
|>    perl ppport.h --compat-version=5.6.0 --cplusplus --patch=test.diff
|>
|>If you only want your code to be scanned without any suggestions
|>for changes, use:
|>
|>    perl ppport.h --nochanges
|>
|>You can specify a different C<diff> program or options, using
|>the C<--diff> option:
|>
|>    perl ppport.h --diff='diff -C 10'
|>
|>This would output context diffs with 10 lines of context.
|>
|>If you want to create patched copies of your files instead, use:
|>
|>    perl ppport.h --copy=.new
|>
|>To display portability information for the C<newSVpvn> function,
|>use:
|>
|>    perl ppport.h --api-info=newSVpvn
|>
|>Since the argument to C<--api-info> can be a regular expression,
|>you can use
|>
|>    perl ppport.h --api-info=/_nomg$/
|>
|>to display portability information for all C<_nomg> functions or
|>
|>    perl ppport.h --api-info=/./
|>
|>to display information for all known API elements.
|>
|>=head1 BUGS
|>
|>If this version of F<ppport.h> is causing failure during
|>the compilation of this module, please check if newer versions
|>of either this module or C<Devel::PPPort> are available on CPAN
|>before sending a bug report.
|>
|>If F<ppport.h> was generated using the latest version of
|>C<Devel::PPPort> and is causing failure of this module, please
|>file a bug report here: L<https://github.com/mhx/Devel-PPPort/issues/>
|>
|>Please include the following information:
|>
|>=over 4
|>
|>=item 1.
|>
|>The complete output from running "perl -V"
|>
|>=item 2.
|>
|>This file.
|>
|>=item 3.
|>
|>The name and version of the module you were trying to build.
|>
|>=item 4.
|>
|>A full log of the build that failed.
|>
|>=item 5.
|>
|>Any other information that you think could be relevant.
|>
|>=back
|>
|>For the latest version of this code, please get the C<Devel::PPPort>
|>module from CPAN.
|>
|>=head1 COPYRIGHT
|>
|>Version 3.x, Copyright (c) 2004-2013, Marcus Holland-Moritz.
|>
|>Version 2.x, Copyright (C) 2001, Paul Marquess.
|>
|>Version 1.x, Copyright (C) 1999, Kenneth Albanowski.
|>
|>This program is free software; you can redistribute it and/or
|>modify it under the same terms as Perl itself.
|>
|>=head1 SEE ALSO
|>
|>See L<Devel::PPPort>.
|>
|>=cut

use strict;

# Disable broken TRIE-optimization
BEGIN { eval '${^RE_TRIE_MAXBUF} = -1' if $] >= 5.009004 && $] <= 5.009005 }

my $VERSION = __VERSION__;

my %opt = (
  quiet     => 0,
  diag      => 1,
  hints     => 1,
  changes   => 1,
  cplusplus => 0,
  filter    => 1,
  strip     => 0,
  version   => 0,
);

my($ppport) = $0 =~ /([\w.]+)$/;
my $LF = '(?:\r\n|[\r\n])';   # line feed
my $HS = "[ \t]";             # horizontal whitespace

# Never use C comments in this file!
my $ccs  = '/'.'*';
my $cce  = '*'.'/';
my $rccs = quotemeta $ccs;
my $rcce = quotemeta $cce;

eval {
  require Getopt::Long;
  Getopt::Long::GetOptions(\%opt, qw(
    help quiet diag! filter! hints! changes! cplusplus strip version
    patch=s copy=s diff=s compat-version=s
    list-provided list-unsupported api-info=s
  )) or usage();
};

if ($@ and grep /^-/, @ARGV) {
  usage() if "@ARGV" =~ /^--?h(?:elp)?$/;
  die "Getopt::Long not found. Please don't use any options.\n";
}

if ($opt{version}) {
  print "This is $0 $VERSION.\n";
  exit 0;
}

usage() if $opt{help};
strip() if $opt{strip};

if (exists $opt{'compat-version'}) {
  my($r,$v,$s) = eval { parse_version($opt{'compat-version'}) };
  if ($@) {
    die "Invalid version number format: '$opt{'compat-version'}'\n";
  }
  die "Only Perl 5 is supported\n" if $r != 5;
  die "Invalid version number: $opt{'compat-version'}\n" if $v >= 1000 || $s >= 1000;
  $opt{'compat-version'} = sprintf "%d.%03d%03d", $r, $v, $s;
}
else {
  $opt{'compat-version'} = 5;
}

my %API = map { /^(\w+)\|([^|]*)\|([^|]*)\|(\w*)$/
                ? ( $1 => {
                      ($2                  ? ( base     => $2 ) : ()),
                      ($3                  ? ( todo     => $3 ) : ()),
                      (index($4, 'v') >= 0 ? ( varargs  => 1  ) : ()),
                      (index($4, 'p') >= 0 ? ( provided => 1  ) : ()),
                      (index($4, 'n') >= 0 ? ( nothxarg => 1  ) : ()),
                    } )
                : die "invalid spec: $_" } qw(
ASCII_TO_NEED||5.007001|n
AvFILLp|5.004050||p
AvFILL|||
BhkDISABLE||5.021008|
BhkENABLE||5.021008|
BhkENTRY_set||5.021008|
BhkENTRY|||
BhkFLAGS|||
CALL_BLOCK_HOOKS|||
CLASS|||n
CPERLscope|5.005000||p
CX_CURPAD_SAVE|||
CX_CURPAD_SV|||
CopFILEAV|5.006000||p
CopFILEGV_set|5.006000||p
CopFILEGV|5.006000||p
CopFILESV|5.006000||p
CopFILE_set|5.006000||p
CopFILE|5.006000||p
CopSTASHPV_set|5.006000||p
CopSTASHPV|5.006000||p
CopSTASH_eq|5.006000||p
CopSTASH_set|5.006000||p
CopSTASH|5.006000||p
CopyD|5.009002|5.004050|p
Copy|||
CvPADLIST||5.008001|
CvSTASH|||
CvWEAKOUTSIDE|||
DEFSV_set|5.010001||p
DEFSV|5.004050||p
END_EXTERN_C|5.005000||p
ENTER|||
ERRSV|5.004050||p
EXTEND|||
EXTERN_C|5.005000||p
F0convert|||n
FREETMPS|||
GIMME_V||5.004000|n
GIMME|||n
GROK_NUMERIC_RADIX|5.007002||p
G_ARRAY|||
G_DISCARD|||
G_EVAL|||
G_METHOD|5.006001||p
G_NOARGS|||
G_SCALAR|||
G_VOID||5.004000|
GetVars|||
GvAV|||
GvCV|||
GvHV|||
GvSVn|5.009003||p
GvSV|||
Gv_AMupdate||5.011000|
HEf_SVKEY|5.003070||p
HeHASH||5.003070|
HeKEY||5.003070|
HeKLEN||5.003070|
HePV||5.004000|
HeSVKEY_force||5.003070|
HeSVKEY_set||5.004000|
HeSVKEY||5.003070|
HeUTF8|5.010001|5.008000|p
HeVAL||5.003070|
HvENAMELEN||5.015004|
HvENAMEUTF8||5.015004|
HvENAME||5.013007|
HvNAMELEN_get|5.009003||p
HvNAMELEN||5.015004|
HvNAMEUTF8||5.015004|
HvNAME_get|5.009003||p
HvNAME|||
INT2PTR|5.006000||p
IN_LOCALE_COMPILETIME|5.007002||p
IN_LOCALE_RUNTIME|5.007002||p
IN_LOCALE|5.007002||p
IN_PERL_COMPILETIME|5.008001||p
IS_NUMBER_GREATER_THAN_UV_MAX|5.007002||p
IS_NUMBER_INFINITY|5.007002||p
IS_NUMBER_IN_UV|5.007002||p
IS_NUMBER_NAN|5.007003||p
IS_NUMBER_NEG|5.007002||p
IS_NUMBER_NOT_INT|5.007002||p
IVSIZE|5.006000||p
IVTYPE|5.006000||p
IVdf|5.006000||p
LEAVE|||
LINKLIST||5.013006|
LVRET|||
MARK|||
MULTICALL||5.021008|
MUTABLE_PTR|5.010001||p
MUTABLE_SV|5.010001||p
MY_CXT_CLONE|5.009002||p
MY_CXT_INIT|5.007003||p
MY_CXT|5.007003||p
MoveD|5.009002|5.004050|p
Move|||
NATIVE_TO_NEED||5.007001|n
NOOP|5.005000||p
NUM2PTR|5.006000||p
NVTYPE|5.006000||p
NVef|5.006001||p
NVff|5.006001||p
NVgf|5.006001||p
Newxc|5.009003||p
Newxz|5.009003||p
Newx|5.009003||p
Nullav|||
Nullch|||
Nullcv|||
Nullhv|||
Nullsv|||
OP_CLASS||5.013007|
OP_DESC||5.007003|
OP_NAME||5.007003|
OP_TYPE_IS_OR_WAS||5.019010|
OP_TYPE_IS||5.019007|
ORIGMARK|||
OpHAS_SIBLING||5.021007|
OpSIBLING_set||5.021007|
OpSIBLING||5.021007|
PAD_BASE_SV|||
PAD_CLONE_VARS|||
PAD_COMPNAME_FLAGS|||
PAD_COMPNAME_GEN_set|||
PAD_COMPNAME_GEN|||
PAD_COMPNAME_OURSTASH|||
PAD_COMPNAME_PV|||
PAD_COMPNAME_TYPE|||
PAD_RESTORE_LOCAL|||
PAD_SAVE_LOCAL|||
PAD_SAVE_SETNULLPAD|||
PAD_SETSV|||
PAD_SET_CUR_NOSAVE|||
PAD_SET_CUR|||
PAD_SVl|||
PAD_SV|||
PERLIO_FUNCS_CAST|5.009003||p
PERLIO_FUNCS_DECL|5.009003||p
PERL_ABS|5.008001||p
PERL_BCDVERSION|5.021008||p
PERL_GCC_BRACE_GROUPS_FORBIDDEN|5.008001||p
PERL_HASH|5.003070||p
PERL_INT_MAX|5.003070||p
PERL_INT_MIN|5.003070||p
PERL_LONG_MAX|5.003070||p
PERL_LONG_MIN|5.003070||p
PERL_MAGIC_arylen|5.007002||p
PERL_MAGIC_backref|5.007002||p
PERL_MAGIC_bm|5.007002||p
PERL_MAGIC_collxfrm|5.007002||p
PERL_MAGIC_dbfile|5.007002||p
PERL_MAGIC_dbline|5.007002||p
PERL_MAGIC_defelem|5.007002||p
PERL_MAGIC_envelem|5.007002||p
PERL_MAGIC_env|5.007002||p
PERL_MAGIC_ext|5.007002||p
PERL_MAGIC_fm|5.007002||p
PERL_MAGIC_glob|5.021008||p
PERL_MAGIC_isaelem|5.007002||p
PERL_MAGIC_isa|5.007002||p
PERL_MAGIC_mutex|5.021008||p
PERL_MAGIC_nkeys|5.007002||p
PERL_MAGIC_overload_elem|5.021008||p
PERL_MAGIC_overload_table|5.007002||p
PERL_MAGIC_overload|5.021008||p
PERL_MAGIC_pos|5.007002||p
PERL_MAGIC_qr|5.007002||p
PERL_MAGIC_regdata|5.007002||p
PERL_MAGIC_regdatum|5.007002||p
PERL_MAGIC_regex_global|5.007002||p
PERL_MAGIC_shared_scalar|5.007003||p
PERL_MAGIC_shared|5.007003||p
PERL_MAGIC_sigelem|5.007002||p
PERL_MAGIC_sig|5.007002||p
PERL_MAGIC_substr|5.007002||p
PERL_MAGIC_sv|5.007002||p
PERL_MAGIC_taint|5.007002||p
PERL_MAGIC_tiedelem|5.007002||p
PERL_MAGIC_tiedscalar|5.007002||p
PERL_MAGIC_tied|5.007002||p
PERL_MAGIC_utf8|5.008001||p
PERL_MAGIC_uvar_elem|5.007003||p
PERL_MAGIC_uvar|5.007002||p
PERL_MAGIC_vec|5.007002||p
PERL_MAGIC_vstring|5.008001||p
PERL_PV_ESCAPE_ALL|5.009004||p
PERL_PV_ESCAPE_FIRSTCHAR|5.009004||p
PERL_PV_ESCAPE_NOBACKSLASH|5.009004||p
PERL_PV_ESCAPE_NOCLEAR|5.009004||p
PERL_PV_ESCAPE_QUOTE|5.009004||p
PERL_PV_ESCAPE_RE|5.009005||p
PERL_PV_ESCAPE_UNI_DETECT|5.009004||p
PERL_PV_ESCAPE_UNI|5.009004||p
PERL_PV_PRETTY_DUMP|5.009004||p
PERL_PV_PRETTY_ELLIPSES|5.010000||p
PERL_PV_PRETTY_LTGT|5.009004||p
PERL_PV_PRETTY_NOCLEAR|5.010000||p
PERL_PV_PRETTY_QUOTE|5.009004||p
PERL_PV_PRETTY_REGPROP|5.009004||p
PERL_QUAD_MAX|5.003070||p
PERL_QUAD_MIN|5.003070||p
PERL_REVISION|5.006000||p
PERL_SCAN_ALLOW_UNDERSCORES|5.007003||p
PERL_SCAN_DISALLOW_PREFIX|5.007003||p
PERL_SCAN_GREATER_THAN_UV_MAX|5.007003||p
PERL_SCAN_SILENT_ILLDIGIT|5.008001||p
PERL_SHORT_MAX|5.003070||p
PERL_SHORT_MIN|5.003070||p
PERL_SIGNALS_UNSAFE_FLAG|5.008001||p
PERL_SUBVERSION|5.006000||p
PERL_SYS_INIT3||5.006000|
PERL_SYS_INIT|||
PERL_SYS_TERM||5.021008|
PERL_UCHAR_MAX|5.003070||p
PERL_UCHAR_MIN|5.003070||p
PERL_UINT_MAX|5.003070||p
PERL_UINT_MIN|5.003070||p
PERL_ULONG_MAX|5.003070||p
PERL_ULONG_MIN|5.003070||p
PERL_UNUSED_ARG|5.009003||p
PERL_UNUSED_CONTEXT|5.009004||p
PERL_UNUSED_DECL|5.007002||p
PERL_UNUSED_VAR|5.007002||p
PERL_UQUAD_MAX|5.003070||p
PERL_UQUAD_MIN|5.003070||p
PERL_USE_GCC_BRACE_GROUPS|5.009004||p
PERL_USHORT_MAX|5.003070||p
PERL_USHORT_MIN|5.003070||p
PERL_VERSION|5.006000||p
PL_DBsignal|5.005000||p
PL_DBsingle|||pn
PL_DBsub|||pn
PL_DBtrace|||pn
PL_Sv|5.005000||p
PL_bufend|5.021008||p
PL_bufptr|5.021008||p
PL_check||5.006000|
PL_compiling|5.004050||p
PL_comppad_name||5.017004|
PL_comppad||5.008001|
PL_copline|5.021008||p
PL_curcop|5.004050||p
PL_curpad||5.005000|
PL_curstash|5.004050||p
PL_debstash|5.004050||p
PL_defgv|5.004050||p
PL_diehook|5.004050||p
PL_dirty|5.004050||p
PL_dowarn|||pn
PL_errgv|5.004050||p
PL_error_count|5.021008||p
PL_expect|5.021008||p
PL_hexdigit|5.005000||p
PL_hints|5.005000||p
PL_in_my_stash|5.021008||p
PL_in_my|5.021008||p
PL_keyword_plugin||5.011002|
PL_last_in_gv|||n
PL_laststatval|5.005000||p
PL_lex_state|5.021008||p
PL_lex_stuff|5.021008||p
PL_linestr|5.021008||p
PL_modglobal||5.005000|n
PL_na|5.004050||pn
PL_no_modify|5.006000||p
PL_ofsgv|||n
PL_opfreehook||5.011000|n
PL_parser|5.009005||p
PL_peepp||5.007003|n
PL_perl_destruct_level|5.004050||p
PL_perldb|5.004050||p
PL_ppaddr|5.006000||p
PL_rpeepp||5.013005|n
PL_rsfp_filters|5.021008||p
PL_rsfp|5.021008||p
PL_rs|||n
PL_signals|5.008001||p
PL_stack_base|5.004050||p
PL_stack_sp|5.004050||p
PL_statcache|5.005000||p
PL_stdingv|5.004050||p
PL_sv_arenaroot|5.004050||p
PL_sv_no|5.004050||pn
PL_sv_undef|5.004050||pn
PL_sv_yes|5.004050||pn
PL_tainted|5.004050||p
PL_tainting|5.004050||p
PL_tokenbuf|5.021008||p
POP_MULTICALL||5.021008|
POPi|||n
POPl|||n
POPn|||n
POPpbytex||5.007001|n
POPpx||5.005030|n
POPp|||n
POPs|||n
PTR2IV|5.006000||p
PTR2NV|5.006000||p
PTR2UV|5.006000||p
PTR2nat|5.009003||p
PTR2ul|5.007001||p
PTRV|5.006000||p
PUSHMARK|||
PUSH_MULTICALL||5.021008|
PUSHi|||
PUSHmortal|5.009002||p
PUSHn|||
PUSHp|||
PUSHs|||
PUSHu|5.004000||p
PUTBACK|||
PadARRAY||5.021008|
PadMAX||5.021008|
PadlistARRAY||5.021008|
PadlistMAX||5.021008|
PadlistNAMESARRAY||5.021008|
PadlistNAMESMAX||5.021008|
PadlistNAMES||5.021008|
PadlistREFCNT||5.017004|
PadnameIsOUR|||
PadnameIsSTATE|||
PadnameLEN||5.021008|
PadnameOURSTASH|||
PadnameOUTER|||
PadnamePV||5.021008|
PadnameREFCNT_dec||5.021008|
PadnameREFCNT||5.021008|
PadnameSV||5.021008|
PadnameTYPE|||
PadnameUTF8||5.021007|
PadnamelistARRAY||5.021008|
PadnamelistMAX||5.021008|
PadnamelistREFCNT_dec||5.021008|
PadnamelistREFCNT||5.021008|
PerlIO_clearerr||5.007003|
PerlIO_close||5.007003|
PerlIO_context_layers||5.009004|
PerlIO_eof||5.007003|
PerlIO_error||5.007003|
PerlIO_fileno||5.007003|
PerlIO_fill||5.007003|
PerlIO_flush||5.007003|
PerlIO_get_base||5.007003|
PerlIO_get_bufsiz||5.007003|
PerlIO_get_cnt||5.007003|
PerlIO_get_ptr||5.007003|
PerlIO_read||5.007003|
PerlIO_restore_errno|||
PerlIO_save_errno|||
PerlIO_seek||5.007003|
PerlIO_set_cnt||5.007003|
PerlIO_set_ptrcnt||5.007003|
PerlIO_setlinebuf||5.007003|
PerlIO_stderr||5.007003|
PerlIO_stdin||5.007003|
PerlIO_stdout||5.007003|
PerlIO_tell||5.007003|
PerlIO_unread||5.007003|
PerlIO_write||5.007003|
Perl_signbit||5.009005|n
PoisonFree|5.009004||p
PoisonNew|5.009004||p
PoisonWith|5.009004||p
Poison|5.008000||p
READ_XDIGIT||5.017006|
RETVAL|||n
Renewc|||
Renew|||
SAVECLEARSV|||
SAVECOMPPAD|||
SAVEPADSV|||
SAVETMPS|||
SAVE_DEFSV|5.004050||p
SPAGAIN|||
SP|||
START_EXTERN_C|5.005000||p
START_MY_CXT|5.007003||p
STMT_END|||p
STMT_START|||p
STR_WITH_LEN|5.009003||p
ST|||
SV_CONST_RETURN|5.009003||p
SV_COW_DROP_PV|5.008001||p
SV_COW_SHARED_HASH_KEYS|5.009005||p
SV_GMAGIC|5.007002||p
SV_HAS_TRAILING_NUL|5.009004||p
SV_IMMEDIATE_UNREF|5.007001||p
SV_MUTABLE_RETURN|5.009003||p
SV_NOSTEAL|5.009002||p
SV_SMAGIC|5.009003||p
SV_UTF8_NO_ENCODING|5.008001||p
SVfARG|5.009005||p
SVf_UTF8|5.006000||p
SVf|5.006000||p
SVt_INVLIST||5.019002|
SVt_IV|||
SVt_NULL|||
SVt_NV|||
SVt_PVAV|||
SVt_PVCV|||
SVt_PVFM|||
SVt_PVGV|||
SVt_PVHV|||
SVt_PVIO|||
SVt_PVIV|||
SVt_PVLV|||
SVt_PVMG|||
SVt_PVNV|||
SVt_PV|||
SVt_REGEXP||5.011000|
Safefree|||
Slab_Alloc|||
Slab_Free|||
Slab_to_ro|||
Slab_to_rw|||
StructCopy|||
SvCUR_set|||
SvCUR|||
SvEND|||
SvGAMAGIC||5.006001|
SvGETMAGIC|5.004050||p
SvGROW|||
SvIOK_UV||5.006000|
SvIOK_notUV||5.006000|
SvIOK_off|||
SvIOK_only_UV||5.006000|
SvIOK_only|||
SvIOK_on|||
SvIOKp|||
SvIOK|||
SvIVX|||
SvIV_nomg|5.009001||p
SvIV_set|||
SvIVx|||
SvIV|||
SvIsCOW_shared_hash||5.008003|
SvIsCOW||5.008003|
SvLEN_set|||
SvLEN|||
SvLOCK||5.007003|
SvMAGIC_set|5.009003||p
SvNIOK_off|||
SvNIOKp|||
SvNIOK|||
SvNOK_off|||
SvNOK_only|||
SvNOK_on|||
SvNOKp|||
SvNOK|||
SvNVX|||
SvNV_nomg||5.013002|
SvNV_set|||
SvNVx|||
SvNV|||
SvOK|||
SvOOK_offset||5.011000|
SvOOK|||
SvPOK_off|||
SvPOK_only_UTF8||5.006000|
SvPOK_only|||
SvPOK_on|||
SvPOKp|||
SvPOK|||
SvPVX_const|5.009003||p
SvPVX_mutable|5.009003||p
SvPVX|||
SvPV_const|5.009003||p
SvPV_flags_const_nolen|5.009003||p
SvPV_flags_const|5.009003||p
SvPV_flags_mutable|5.009003||p
SvPV_flags|5.007002||p
SvPV_force_flags_mutable|5.009003||p
SvPV_force_flags_nolen|5.009003||p
SvPV_force_flags|5.007002||p
SvPV_force_mutable|5.009003||p
SvPV_force_nolen|5.009003||p
SvPV_force_nomg_nolen|5.009003||p
SvPV_force_nomg|5.007002||p
SvPV_force|||p
SvPV_mutable|5.009003||p
SvPV_nolen_const|5.009003||p
SvPV_nolen|5.006000||p
SvPV_nomg_const_nolen|5.009003||p
SvPV_nomg_const|5.009003||p
SvPV_nomg_nolen|5.013007||p
SvPV_nomg|5.007002||p
SvPV_renew|5.009003||p
SvPV_set|||
SvPVbyte_force||5.009002|
SvPVbyte_nolen||5.006000|
SvPVbytex_force||5.006000|
SvPVbytex||5.006000|
SvPVbyte|5.006000||p
SvPVutf8_force||5.006000|
SvPVutf8_nolen||5.006000|
SvPVutf8x_force||5.006000|
SvPVutf8x||5.006000|
SvPVutf8||5.006000|
SvPVx|||
SvPV|||
SvREFCNT_dec_NN||5.017007|
SvREFCNT_dec|||
SvREFCNT_inc_NN|5.009004||p
SvREFCNT_inc_simple_NN|5.009004||p
SvREFCNT_inc_simple_void_NN|5.009004||p
SvREFCNT_inc_simple_void|5.009004||p
SvREFCNT_inc_simple|5.009004||p
SvREFCNT_inc_void_NN|5.009004||p
SvREFCNT_inc_void|5.009004||p
SvREFCNT_inc|||p
SvREFCNT|||
SvROK_off|||
SvROK_on|||
SvROK|||
SvRV_set|5.009003||p
SvRV|||
SvRXOK||5.009005|
SvRX||5.009005|
SvSETMAGIC|||
SvSHARED_HASH|5.009003||p
SvSHARE||5.007003|
SvSTASH_set|5.009003||p
SvSTASH|||
SvSetMagicSV_nosteal||5.004000|
SvSetMagicSV||5.004000|
SvSetSV_nosteal||5.004000|
SvSetSV|||
SvTAINTED_off||5.004000|
SvTAINTED_on||5.004000|
SvTAINTED||5.004000|
SvTAINT|||
SvTHINKFIRST|||
SvTRUE_nomg||5.013006|
SvTRUE|||
SvTYPE|||
SvUNLOCK||5.007003|
SvUOK|5.007001|5.006000|p
SvUPGRADE|||
SvUTF8_off||5.006000|
SvUTF8_on||5.006000|
SvUTF8||5.006000|
SvUVXx|5.004000||p
SvUVX|5.004000||p
SvUV_nomg|5.009001||p
SvUV_set|5.009003||p
SvUVx|5.004000||p
SvUV|5.004000||p
SvVOK||5.008001|
SvVSTRING_mg|5.009004||p
THIS|||n
UNDERBAR|5.009002||p
UTF8_MAXBYTES|5.009002||p
UVSIZE|5.006000||p
UVTYPE|5.006000||p
UVXf|5.007001||p
UVof|5.006000||p
UVuf|5.006000||p
UVxf|5.006000||p
WARN_ALL|5.006000||p
WARN_AMBIGUOUS|5.006000||p
WARN_ASSERTIONS|5.021008||p
WARN_BAREWORD|5.006000||p
WARN_CLOSED|5.006000||p
WARN_CLOSURE|5.006000||p
WARN_DEBUGGING|5.006000||p
WARN_DEPRECATED|5.006000||p
WARN_DIGIT|5.006000||p
WARN_EXEC|5.006000||p
WARN_EXITING|5.006000||p
WARN_GLOB|5.006000||p
WARN_INPLACE|5.006000||p
WARN_INTERNAL|5.006000||p
WARN_IO|5.006000||p
WARN_LAYER|5.008000||p
WARN_MALLOC|5.006000||p
WARN_MISC|5.006000||p
WARN_NEWLINE|5.006000||p
WARN_NUMERIC|5.006000||p
WARN_ONCE|5.006000||p
WARN_OVERFLOW|5.006000||p
WARN_PACK|5.006000||p
WARN_PARENTHESIS|5.006000||p
WARN_PIPE|5.006000||p
WARN_PORTABLE|5.006000||p
WARN_PRECEDENCE|5.006000||p
WARN_PRINTF|5.006000||p
WARN_PROTOTYPE|5.006000||p
WARN_QW|5.006000||p
WARN_RECURSION|5.006000||p
WARN_REDEFINE|5.006000||p
WARN_REGEXP|5.006000||p
WARN_RESERVED|5.006000||p
WARN_SEMICOLON|5.006000||p
WARN_SEVERE|5.006000||p
WARN_SIGNAL|5.006000||p
WARN_SUBSTR|5.006000||p
WARN_SYNTAX|5.006000||p
WARN_TAINT|5.006000||p
WARN_THREADS|5.008000||p
WARN_UNINITIALIZED|5.006000||p
WARN_UNOPENED|5.006000||p
WARN_UNPACK|5.006000||p
WARN_UNTIE|5.006000||p
WARN_UTF8|5.006000||p
WARN_VOID|5.006000||p
WIDEST_UTYPE|5.015004||p
XCPT_CATCH|5.009002||p
XCPT_RETHROW|5.009002||p
XCPT_TRY_END|5.009002||p
XCPT_TRY_START|5.009002||p
XPUSHi|||
XPUSHmortal|5.009002||p
XPUSHn|||
XPUSHp|||
XPUSHs|||
XPUSHu|5.004000||p
XSPROTO|5.010000||p
XSRETURN_EMPTY|||
XSRETURN_IV|||
XSRETURN_NO|||
XSRETURN_NV|||
XSRETURN_PV|||
XSRETURN_UNDEF|||
XSRETURN_UV|5.008001||p
XSRETURN_YES|||
XSRETURN|||p
XST_mIV|||
XST_mNO|||
XST_mNV|||
XST_mPV|||
XST_mUNDEF|||
XST_mUV|5.008001||p
XST_mYES|||
XS_APIVERSION_BOOTCHECK||5.021008|
XS_EXTERNAL||5.021008|
XS_INTERNAL||5.021008|
XS_VERSION_BOOTCHECK||5.021008|
XS_VERSION|||
XSprePUSH|5.006000||p
XS|||
XopDISABLE||5.021008|
XopENABLE||5.021008|
XopENTRYCUSTOM||5.021008|
XopENTRY_set||5.021008|
XopENTRY||5.021008|
XopFLAGS||5.013007|
ZeroD|5.009002||p
Zero|||
_aMY_CXT|5.007003||p
_add_range_to_invlist|||
_append_range_to_invlist|||
_core_swash_init|||
_get_encoding|||
_get_regclass_nonbitmap_data|||
_get_swash_invlist|||
_invlist_array_init|||n
_invlist_contains_cp|||n
_invlist_contents|||
_invlist_dump|||
_invlist_intersection_maybe_complement_2nd|||
_invlist_intersection|||
_invlist_invert|||
_invlist_len|||n
_invlist_populate_swatch|||n
_invlist_search|||n
_invlist_subtract|||
_invlist_union_maybe_complement_2nd|||
_invlist_union|||
_is_cur_LC_category_utf8|||
_is_in_locale_category||5.021001|
_is_uni_FOO||5.017008|
_is_uni_perl_idcont||5.017008|
_is_uni_perl_idstart||5.017007|
_is_utf8_FOO||5.017008|
_is_utf8_char_slow||5.021001|n
_is_utf8_idcont||5.021001|
_is_utf8_idstart||5.021001|
_is_utf8_mark||5.017008|
_is_utf8_perl_idcont||5.017008|
_is_utf8_perl_idstart||5.017007|
_is_utf8_xidcont||5.021001|
_is_utf8_xidstart||5.021001|
_load_PL_utf8_foldclosures|||
_make_exactf_invlist|||
_new_invlist_C_array|||
_new_invlist|||
_pMY_CXT|5.007003||p
_setup_canned_invlist|||
_swash_inversion_hash|||
_swash_to_invlist|||
_to_fold_latin1|||
_to_uni_fold_flags||5.014000|
_to_upper_title_latin1|||
_to_utf8_fold_flags||5.019009|
_to_utf8_lower_flags||5.019009|
_to_utf8_title_flags||5.019009|
_to_utf8_upper_flags||5.019009|
_warn_problematic_locale|||n
aMY_CXT_|5.007003||p
aMY_CXT|5.007003||p
aTHXR_|5.021008||p
aTHXR|5.021008||p
aTHX_|5.006000||p
aTHX|5.006000||p
aassign_common_vars|||
add_above_Latin1_folds|||
add_cp_to_invlist|||
add_data|||n
add_multi_match|||
add_utf16_textfilter|||
adjust_size_and_find_bucket|||n
advance_one_SB|||
advance_one_WB|||
alloc_maybe_populate_EXACT|||
alloccopstash|||
allocmy|||
amagic_call|||
amagic_cmp_locale|||
amagic_cmp|||
amagic_deref_call||5.013007|
amagic_i_ncmp|||
amagic_is_enabled|||
amagic_ncmp|||
anonymise_cv_maybe|||
any_dup|||
ao|||
append_utf8_from_native_byte||5.019004|n
apply_attrs_my|||
apply_attrs_string||5.006001|
apply_attrs|||
apply|||
assert_uft8_cache_coherent|||
assignment_type|||
atfork_lock||5.007003|n
atfork_unlock||5.007003|n
av_arylen_p||5.009003|
av_clear|||
av_create_and_push||5.009005|
av_create_and_unshift_one||5.009005|
av_delete||5.006000|
av_exists||5.006000|
av_extend_guts|||
av_extend|||
av_fetch|||
av_fill|||
av_iter_p||5.011000|
av_len|||
av_make|||
av_pop|||
av_push|||
av_reify|||
av_shift|||
av_store|||
av_tindex||5.017009|
av_top_index||5.017009|
av_undef|||
av_unshift|||
ax|||n
backup_one_SB|||
backup_one_WB|||
bad_type_gv|||
bad_type_pv|||
bind_match|||
block_end||5.004000|
block_gimme||5.004000|
block_start||5.004000|
blockhook_register||5.013003|
boolSV|5.004000||p
boot_core_PerlIO|||
boot_core_UNIVERSAL|||
boot_core_mro|||
bytes_cmp_utf8||5.013007|
bytes_from_utf8||5.007001|
bytes_to_utf8||5.006001|
call_argv|5.006000||p
call_atexit||5.006000|
call_list||5.004000|
call_method|5.006000||p
call_pv|5.006000||p
call_sv|5.006000||p
caller_cx|5.013005|5.006000|p
calloc||5.007002|n
cando|||
cast_i32||5.006000|n
cast_iv||5.006000|n
cast_ulong||5.006000|n
cast_uv||5.006000|n
check_locale_boundary_crossing|||
check_type_and_open|||
check_uni|||
check_utf8_print|||
checkcomma|||
ckWARN|5.006000||p
ck_entersub_args_core|||
ck_entersub_args_list||5.013006|
ck_entersub_args_proto_or_list||5.013006|
ck_entersub_args_proto||5.013006|
ck_warner_d||5.011001|v
ck_warner||5.011001|v
ckwarn_common|||
ckwarn_d||5.009003|
ckwarn||5.009003|
clear_placeholders|||
clear_special_blocks|||
clone_params_del|||n
clone_params_new|||n
closest_cop|||
cntrl_to_mnemonic|||n
compute_EXACTish|||n
construct_ahocorasick_from_trie|||
cop_fetch_label||5.015001|
cop_free|||
cop_hints_2hv||5.013007|
cop_hints_fetch_pvn||5.013007|
cop_hints_fetch_pvs||5.013007|
cop_hints_fetch_pv||5.013007|
cop_hints_fetch_sv||5.013007|
cop_store_label||5.015001|
cophh_2hv||5.013007|
cophh_copy||5.013007|
cophh_delete_pvn||5.013007|
cophh_delete_pvs||5.013007|
cophh_delete_pv||5.013007|
cophh_delete_sv||5.013007|
cophh_fetch_pvn||5.013007|
cophh_fetch_pvs||5.013007|
cophh_fetch_pv||5.013007|
cophh_fetch_sv||5.013007|
cophh_free||5.013007|
cophh_new_empty||5.021008|
cophh_store_pvn||5.013007|
cophh_store_pvs||5.013007|
cophh_store_pv||5.013007|
cophh_store_sv||5.013007|
core_prototype|||
coresub_op|||
could_it_be_a_POSIX_class|||n
cr_textfilter|||
create_eval_scope|||
croak_memory_wrap||5.019003|n
croak_no_mem|||n
croak_no_modify||5.013003|n
croak_nocontext|||vn
croak_popstack|||n
croak_sv||5.013001|
croak_xs_usage||5.010001|n
croak|||v
csighandler||5.009003|n
current_re_engine|||
curse|||
custom_op_desc||5.007003|
custom_op_get_field|||
custom_op_name||5.007003|
custom_op_register||5.013007|
custom_op_xop||5.013007|
cv_ckproto_len_flags|||
cv_clone_into|||
cv_clone|||
cv_const_sv_or_av|||n
cv_const_sv||5.003070|n
cv_dump|||
cv_forget_slab|||
cv_get_call_checker||5.013006|
cv_name||5.021005|
cv_set_call_checker_flags||5.021004|
cv_set_call_checker||5.013006|
cv_undef_flags|||
cv_undef|||
cvgv_from_hek|||
cvgv_set|||
cvstash_set|||
cx_dump||5.005000|
cx_dup|||
cxinc|||
dAXMARK|5.009003||p
dAX|5.007002||p
dITEMS|5.007002||p
dMARK|||
dMULTICALL||5.009003|
dMY_CXT_SV|5.007003||p
dMY_CXT|5.007003||p
dNOOP|5.006000||p
dORIGMARK|||
dSP|||
dTHR|5.004050||p
dTHXR|5.021008||p
dTHXa|5.006000||p
dTHXoa|5.006000||p
dTHX|5.006000||p
dUNDERBAR|5.009002||p
dVAR|5.009003||p
dXCPT|5.009002||p
dXSARGS|||
dXSI32|||
dXSTARG|5.006000||p
deb_curcv|||
deb_nocontext|||vn
deb_stack_all|||
deb_stack_n|||
debop||5.005000|
debprofdump||5.005000|
debprof|||
debstackptrs||5.007003|
debstack||5.007003|
debug_start_match|||
deb||5.007003|v
defelem_target|||
del_sv|||
delete_eval_scope|||
delimcpy||5.004000|n
deprecate_commaless_var_list|||
despatch_signals||5.007001|
destroy_matcher|||
die_nocontext|||vn
die_sv||5.013001|
die_unwind|||
die|||v
dirp_dup|||
div128|||
djSP|||
do_aexec5|||
do_aexec|||
do_aspawn|||
do_binmode||5.004050|
do_chomp|||
do_close|||
do_delete_local|||
do_dump_pad|||
do_eof|||
do_exec3|||
do_execfree|||
do_exec|||
do_gv_dump||5.006000|
do_gvgv_dump||5.006000|
do_hv_dump||5.006000|
do_ipcctl|||
do_ipcget|||
do_join|||
do_magic_dump||5.006000|
do_msgrcv|||
do_msgsnd|||
do_ncmp|||
do_oddball|||
do_op_dump||5.006000|
do_open6|||
do_open9||5.006000|
do_open_raw|||
do_openn||5.007001|
do_open||5.003070|
do_pmop_dump||5.006000|
do_print|||
do_readline|||
do_seek|||
do_semop|||
do_shmio|||
do_smartmatch|||
do_spawn_nowait|||
do_spawn|||
do_sprintf|||
do_sv_dump||5.006000|
do_sysseek|||
do_tell|||
do_trans_complex_utf8|||
do_trans_complex|||
do_trans_count_utf8|||
do_trans_count|||
do_trans_simple_utf8|||
do_trans_simple|||
do_trans|||
do_vecget|||
do_vecset|||
do_vop|||
docatch|||
doeval|||
dofile|||
dofindlabel|||
doform|||
doing_taint||5.008001|n
dooneliner|||
doopen_pm|||
doparseform|||
dopoptoeval|||
dopoptogiven|||
dopoptolabel|||
dopoptoloop|||
dopoptosub_at|||
dopoptowhen|||
doref||5.009003|
dounwind|||
dowantarray|||
drand48_init_r|||n
drand48_r|||n
dump_all_perl|||
dump_all||5.006000|
dump_c_backtrace|||
dump_eval||5.006000|
dump_exec_pos|||
dump_form||5.006000|
dump_indent||5.006000|v
dump_mstats|||
dump_packsubs_perl|||
dump_packsubs||5.006000|
dump_sub_perl|||
dump_sub||5.006000|
dump_sv_child|||
dump_trie_interim_list|||
dump_trie_interim_table|||
dump_trie|||
dump_vindent||5.006000|
dumpuntil|||
dup_attrlist|||
emulate_cop_io|||
eval_pv|5.006000||p
eval_sv|5.006000||p
exec_failed|||
expect_number|||
fbm_compile||5.005000|
fbm_instr||5.005000|
feature_is_enabled|||
filter_add|||
filter_del|||
filter_gets|||
filter_read|||
finalize_optree|||
finalize_op|||
find_and_forget_pmops|||
find_array_subscript|||
find_beginning|||
find_byclass|||
find_default_stash|||
find_hash_subscript|||
find_in_my_stash|||
find_lexical_cv|||
find_runcv_where|||
find_runcv||5.008001|
find_rundefsv2|||
find_rundefsvoffset||5.009002|
find_rundefsv||5.013002|
find_script|||
find_uninit_var|||
first_symbol|||n
fixup_errno_string|||
foldEQ_latin1||5.013008|n
foldEQ_locale||5.013002|n
foldEQ_utf8_flags||5.013010|
foldEQ_utf8||5.013002|
foldEQ||5.013002|n
fold_constants|||
forbid_setid|||
force_ident_maybe_lex|||
force_ident|||
force_list|||
force_next|||
force_strict_version|||
force_version|||
force_word|||
forget_pmop|||
form_nocontext|||vn
form_short_octal_warning|||
form||5.004000|v
fp_dup|||
fprintf_nocontext|||vn
free_c_backtrace|||
free_global_struct|||
free_tied_hv_pool|||
free_tmps|||
gen_constant_list|||
get_ANYOF_cp_list_for_ssc|||
get_and_check_backslash_N_name|||
get_aux_mg|||
get_av|5.006000||p
get_c_backtrace_dump|||
get_c_backtrace|||
get_context||5.006000|n
get_cvn_flags|5.009005||p
get_cvs|5.011000||p
get_cv|5.006000||p
get_db_sub|||
get_debug_opts|||
get_hash_seed|||
get_hv|5.006000||p
get_invlist_iter_addr|||n
get_invlist_offset_addr|||n
get_invlist_previous_index_addr|||n
get_mstats|||
get_no_modify|||
get_num|||
get_op_descs||5.005000|
get_op_names||5.005000|
get_opargs|||
get_ppaddr||5.006000|
get_re_arg|||
get_sv|5.006000||p
get_vtbl||5.005030|
getcwd_sv||5.007002|
getenv_len|||
glob_2number|||
glob_assign_glob|||
gp_dup|||
gp_free|||
gp_ref|||
grok_atoUV|||n
grok_bin|5.007003||p
grok_bslash_N|||
grok_bslash_c|||
grok_bslash_o|||
grok_bslash_x|||
grok_hex|5.007003||p
grok_infnan||5.021004|
grok_number_flags||5.021002|
grok_number|5.007002||p
grok_numeric_radix|5.007002||p
grok_oct|5.007003||p
group_end|||
gv_AVadd|||
gv_HVadd|||
gv_IOadd|||
gv_SVadd|||
gv_add_by_type||5.011000|
gv_autoload4||5.004000|
gv_autoload_pvn||5.015004|
gv_autoload_pv||5.015004|
gv_autoload_sv||5.015004|
gv_check|||
gv_const_sv||5.009003|
gv_dump||5.006000|
gv_efullname3||5.003070|
gv_efullname4||5.006001|
gv_efullname|||
gv_fetchfile_flags||5.009005|
gv_fetchfile|||
gv_fetchmeth_autoload||5.007003|
gv_fetchmeth_internal|||
gv_fetchmeth_pv_autoload||5.015004|
gv_fetchmeth_pvn_autoload||5.015004|
gv_fetchmeth_pvn||5.015004|
gv_fetchmeth_pv||5.015004|
gv_fetchmeth_sv_autoload||5.015004|
gv_fetchmeth_sv||5.015004|
gv_fetchmethod_autoload||5.004000|
gv_fetchmethod_pv_flags||5.015004|
gv_fetchmethod_pvn_flags||5.015004|
gv_fetchmethod_sv_flags||5.015004|
gv_fetchmethod|||
gv_fetchmeth|||
gv_fetchpvn_flags|5.009002||p
gv_fetchpvs|5.009004||p
gv_fetchpv|||
gv_fetchsv|5.009002||p
gv_fullname3||5.003070|
gv_fullname4||5.006001|
gv_fullname|||
gv_handler||5.007001|
gv_init_pvn||5.015004|
gv_init_pv||5.015004|
gv_init_svtype|||
gv_init_sv||5.015004|
gv_init|||
gv_is_in_main|||
gv_magicalize_isa|||
gv_magicalize|||
gv_name_set||5.009004|
gv_override|||
gv_setref|||
gv_stashpvn_internal|||
gv_stashpvn|5.003070||p
gv_stashpvs|5.009003||p
gv_stashpv|||
gv_stashsvpvn_cached|||
gv_stashsv|||
gv_try_downgrade|||
handle_regex_sets|||
he_dup|||
hek_dup|||
hfree_next_entry|||
hfreeentries|||
hsplit|||
hv_assert|||
hv_auxinit_internal|||n
hv_auxinit|||
hv_backreferences_p|||
hv_clear_placeholders||5.009001|
hv_clear|||
hv_common_key_len||5.010000|
hv_common||5.010000|
hv_copy_hints_hv||5.009004|
hv_delayfree_ent||5.004000|
hv_delete_common|||
hv_delete_ent||5.003070|
hv_delete|||
hv_eiter_p||5.009003|
hv_eiter_set||5.009003|
hv_ename_add|||
hv_ename_delete|||
hv_exists_ent||5.003070|
hv_exists|||
hv_fetch_ent||5.003070|
hv_fetchs|5.009003||p
hv_fetch|||
hv_fill||5.013002|
hv_free_ent_ret|||
hv_free_ent||5.004000|
hv_iterinit|||
hv_iterkeysv||5.003070|
hv_iterkey|||
hv_iternext_flags||5.008000|
hv_iternextsv|||
hv_iternext|||
hv_iterval|||
hv_kill_backrefs|||
hv_ksplit||5.003070|
hv_magic_check|||n
hv_magic|||
hv_name_set||5.009003|
hv_notallowed|||
hv_placeholders_get||5.009003|
hv_placeholders_p|||
hv_placeholders_set||5.009003|
hv_rand_set||5.018000|
hv_riter_p||5.009003|
hv_riter_set||5.009003|
hv_scalar||5.009001|
hv_store_ent||5.003070|
hv_store_flags||5.008000|
hv_stores|5.009004||p
hv_store|||
hv_undef_flags|||
hv_undef|||
ibcmp_locale||5.004000|
ibcmp_utf8||5.007003|
ibcmp|||
incline|||
incpush_if_exists|||
incpush_use_sep|||
incpush|||
ingroup|||
init_argv_symbols|||
init_constants|||
init_dbargs|||
init_debugger|||
init_global_struct|||
init_i18nl10n||5.006000|
init_i18nl14n||5.006000|
init_ids|||
init_interp|||
init_main_stash|||
init_perllib|||
init_postdump_symbols|||
init_predump_symbols|||
init_stacks||5.005000|
init_tm||5.007002|
inplace_aassign|||
instr|||n
intro_my||5.004000|
intuit_method|||
intuit_more|||
invert|||
invlist_array|||n
invlist_clone|||
invlist_extend|||
invlist_highest|||n
invlist_is_iterating|||n
invlist_iterfinish|||n
invlist_iterinit|||n
invlist_iternext|||n
invlist_max|||n
invlist_previous_index|||n
invlist_set_len|||
invlist_set_previous_index|||n
invlist_trim|||n
invoke_exception_hook|||
io_close|||
isALNUMC|5.006000||p
isALNUM_lazy||5.021001|
isALPHANUMERIC||5.017008|
isALPHA|||
isASCII|5.006000||p
isBLANK|5.006001||p
isCNTRL|5.006000||p
isDIGIT|||
isFOO_lc|||
isFOO_utf8_lc|||
isGCB|||n
isGRAPH|5.006000||p
isGV_with_GP|5.009004||p
isIDCONT||5.017008|
isIDFIRST_lazy||5.021001|
isIDFIRST|||
isLOWER|||
isOCTAL||5.013005|
isPRINT|5.004000||p
isPSXSPC|5.006001||p
isPUNCT|5.006000||p
isSB|||
isSPACE|||
isUPPER|||
isUTF8_CHAR||5.021001|
isWB|||
isWORDCHAR||5.013006|
isXDIGIT|5.006000||p
is_an_int|||
is_ascii_string||5.011000|
is_handle_constructor|||n
is_invariant_string||5.021007|n
is_lvalue_sub||5.007001|
is_safe_syscall||5.019004|
is_ssc_worth_it|||n
is_uni_alnum_lc||5.006000|
is_uni_alnumc_lc||5.017007|
is_uni_alnumc||5.017007|
is_uni_alnum||5.006000|
is_uni_alpha_lc||5.006000|
is_uni_alpha||5.006000|
is_uni_ascii_lc||5.006000|
is_uni_ascii||5.006000|
is_uni_blank_lc||5.017002|
is_uni_blank||5.017002|
is_uni_cntrl_lc||5.006000|
is_uni_cntrl||5.006000|
is_uni_digit_lc||5.006000|
is_uni_digit||5.006000|
is_uni_graph_lc||5.006000|
is_uni_graph||5.006000|
is_uni_idfirst_lc||5.006000|
is_uni_idfirst||5.006000|
is_uni_lower_lc||5.006000|
is_uni_lower||5.006000|
is_uni_print_lc||5.006000|
is_uni_print||5.006000|
is_uni_punct_lc||5.006000|
is_uni_punct||5.006000|
is_uni_space_lc||5.006000|
is_uni_space||5.006000|
is_uni_upper_lc||5.006000|
is_uni_upper||5.006000|
is_uni_xdigit_lc||5.006000|
is_uni_xdigit||5.006000|
is_utf8_alnumc||5.017007|
is_utf8_alnum||5.006000|
is_utf8_alpha||5.006000|
is_utf8_ascii||5.006000|
is_utf8_blank||5.017002|
is_utf8_char_buf||5.015008|n
is_utf8_char||5.006000|n
is_utf8_cntrl||5.006000|
is_utf8_common|||
is_utf8_digit||5.006000|
is_utf8_graph||5.006000|
is_utf8_idcont||5.008000|
is_utf8_idfirst||5.006000|
is_utf8_lower||5.006000|
is_utf8_mark||5.006000|
is_utf8_perl_space||5.011001|
is_utf8_perl_word||5.011001|
is_utf8_posix_digit||5.011001|
is_utf8_print||5.006000|
is_utf8_punct||5.006000|
is_utf8_space||5.006000|
is_utf8_string_loclen||5.009003|n
is_utf8_string_loc||5.008001|n
is_utf8_string||5.006001|n
is_utf8_upper||5.006000|
is_utf8_xdigit||5.006000|
is_utf8_xidcont||5.013010|
is_utf8_xidfirst||5.013010|
isa_lookup|||
isinfnansv|||
isinfnan||5.021004|n
items|||n
ix|||n
jmaybe|||
join_exact|||
keyword_plugin_standard|||
keyword|||
leave_common|||
leave_scope|||
lex_bufutf8||5.011002|
lex_discard_to||5.011002|
lex_grow_linestr||5.011002|
lex_next_chunk||5.011002|
lex_peek_unichar||5.011002|
lex_read_space||5.011002|
lex_read_to||5.011002|
lex_read_unichar||5.011002|
lex_start||5.009005|
lex_stuff_pvn||5.011002|
lex_stuff_pvs||5.013005|
lex_stuff_pv||5.013006|
lex_stuff_sv||5.011002|
lex_unstuff||5.011002|
listkids|||
list|||
load_module_nocontext|||vn
load_module|5.006000||pv
localize|||
looks_like_bool|||
looks_like_number|||
lop|||
mPUSHi|5.009002||p
mPUSHn|5.009002||p
mPUSHp|5.009002||p
mPUSHs|5.010001||p
mPUSHu|5.009002||p
mXPUSHi|5.009002||p
mXPUSHn|5.009002||p
mXPUSHp|5.009002||p
mXPUSHs|5.010001||p
mXPUSHu|5.009002||p
magic_clear_all_env|||
magic_cleararylen_p|||
magic_clearenv|||
magic_clearhints|||
magic_clearhint|||
magic_clearisa|||
magic_clearpack|||
magic_clearsig|||
magic_copycallchecker|||
magic_dump||5.006000|
magic_existspack|||
magic_freearylen_p|||
magic_freeovrld|||
magic_getarylen|||
magic_getdebugvar|||
magic_getdefelem|||
magic_getnkeys|||
magic_getpack|||
magic_getpos|||
magic_getsig|||
magic_getsubstr|||
magic_gettaint|||
magic_getuvar|||
magic_getvec|||
magic_get|||
magic_killbackrefs|||
magic_methcall1|||
magic_methcall|||v
magic_methpack|||
magic_nextpack|||
magic_regdata_cnt|||
magic_regdatum_get|||
magic_regdatum_set|||
magic_scalarpack|||
magic_set_all_env|||
magic_setarylen|||
magic_setcollxfrm|||
magic_setdbline|||
magic_setdebugvar|||
magic_setdefelem|||
magic_setenv|||
magic_sethint|||
magic_setisa|||
magic_setlvref|||
magic_setmglob|||
magic_setnkeys|||
magic_setpack|||
magic_setpos|||
magic_setregexp|||
magic_setsig|||
magic_setsubstr|||
magic_settaint|||
magic_setutf8|||
magic_setuvar|||
magic_setvec|||
magic_set|||
magic_sizepack|||
magic_wipepack|||
make_matcher|||
make_trie|||
malloc_good_size|||n
malloced_size|||n
malloc||5.007002|n
markstack_grow||5.021001|
matcher_matches_sv|||
maybe_multimagic_gv|||
mayberelocate|||
measure_struct|||
memEQs|5.009005||p
memEQ|5.004000||p
memNEs|5.009005||p
memNE|5.004000||p
mem_collxfrm|||
mem_log_common|||n
mess_alloc|||
mess_nocontext|||vn
mess_sv||5.013001|
mess||5.006000|v
mfree||5.007002|n
mg_clear|||
mg_copy|||
mg_dup|||
mg_find_mglob|||
mg_findext|5.013008||pn
mg_find|||n
mg_free_type||5.013006|
mg_free|||
mg_get|||
mg_length||5.005000|
mg_localize|||
mg_magical|||n
mg_set|||
mg_size||5.005000|
mini_mktime||5.007002|n
minus_v|||
missingterm|||
mode_from_discipline|||
modkids|||
more_bodies|||
more_sv|||
moreswitches|||
move_proto_attr|||
mro_clean_isarev|||
mro_gather_and_rename|||
mro_get_from_name||5.010001|
mro_get_linear_isa_dfs|||
mro_get_linear_isa||5.009005|
mro_get_private_data||5.010001|
mro_isa_changed_in|||
mro_meta_dup|||
mro_meta_init|||
mro_method_changed_in||5.009005|
mro_package_moved|||
mro_register||5.010001|
mro_set_mro||5.010001|
mro_set_private_data||5.010001|
mul128|||
mulexp10|||n
multideref_stringify|||
my_atof2||5.007002|
my_atof||5.006000|
my_attrs|||
my_bcopy|||n
my_bytes_to_utf8|||n
my_bzero|||n
my_chsize|||
my_clearenv|||
my_cxt_index|||
my_cxt_init|||
my_dirfd||5.009005|n
my_exit_jump|||
my_exit|||
my_failure_exit||5.004000|
my_fflush_all||5.006000|
my_fork||5.007003|n
my_kid|||
my_lstat_flags|||
my_lstat||5.021008|
my_memcmp|||n
my_memset|||n
my_pclose||5.003070|
my_popen_list||5.007001|
my_popen||5.003070|
my_setenv|||
my_setlocale|||
my_snprintf|5.009004||pvn
my_socketpair||5.007003|n
my_sprintf|5.009003||pvn
my_stat_flags|||
my_stat||5.021008|
my_strerror||5.021001|
my_strftime||5.007002|
my_strlcat|5.009004||pn
my_strlcpy|5.009004||pn
my_unexec|||
my_vsnprintf||5.009004|n
need_utf8|||n
newANONATTRSUB||5.006000|
newANONHASH|||
newANONLIST|||
newANONSUB|||
newASSIGNOP|||
newATTRSUB_x|||
newATTRSUB||5.006000|
newAVREF|||
newAV|||
newBINOP|||
newCONDOP|||
newCONSTSUB_flags||5.015006|
newCONSTSUB|5.004050||p
newCVREF|||
newDEFSVOP||5.021006|
newFORM|||
newFOROP||5.013007|
newGIVENOP||5.009003|
newGIVWHENOP|||
newGP|||
newGVOP|||
newGVREF|||
newGVgen_flags||5.015004|
newGVgen|||
newHVREF|||
newHVhv||5.005000|
newHV|||
newIO|||
newLISTOP|||
newLOGOP|||
newLOOPEX|||
newLOOPOP|||
newMETHOP_internal|||
newMETHOP_named||5.021005|
newMETHOP||5.021005|
newMYSUB||5.017004|
newNULLLIST|||
newOP|||
newPADNAMELIST||5.021007|n
newPADNAMEouter||5.021007|n
newPADNAMEpvn||5.021007|n
newPADOP|||
newPMOP|||
newPROG|||
newPVOP|||
newRANGE|||
newRV_inc|5.004000||p
newRV_noinc|5.004000||p
newRV|||
newSLICEOP|||
newSTATEOP|||
newSTUB|||
newSUB|||
newSVOP|||
newSVREF|||
newSV_type|5.009005||p
newSVavdefelem|||
newSVhek||5.009003|
newSViv|||
newSVnv|||
newSVpadname||5.017004|
newSVpv_share||5.013006|
newSVpvf_nocontext|||vn
newSVpvf||5.004000|v
newSVpvn_flags|5.010001||p
newSVpvn_share|5.007001||p
newSVpvn_utf8|5.010001||p
newSVpvn|5.004050||p
newSVpvs_flags|5.010001||p
newSVpvs_share|5.009003||p
newSVpvs|5.009003||p
newSVpv|||
newSVrv|||
newSVsv|||
newSVuv|5.006000||p
newSV|||
newUNOP_AUX||5.021007|
newUNOP|||
newWHENOP||5.009003|
newWHILEOP||5.013007|
newXS_deffile|||
newXS_flags||5.009004|
newXS_len_flags|||
newXSproto||5.006000|
newXS||5.006000|
new_collate||5.006000|
new_constant|||
new_ctype||5.006000|
new_he|||
new_logop|||
new_numeric||5.006000|
new_stackinfo||5.005000|
new_version||5.009000|
new_warnings_bitfield|||
next_symbol|||
nextargv|||
nextchar|||
ninstr|||n
no_bareword_allowed|||
no_fh_allowed|||
no_op|||
noperl_die|||vn
not_a_number|||
not_incrementable|||
nothreadhook||5.008000|
nuke_stacks|||
num_overflow|||n
oopsAV|||
oopsHV|||
op_append_elem||5.013006|
op_append_list||5.013006|
op_clear|||
op_contextualize||5.013006|
op_convert_list||5.021006|
op_dump||5.006000|
op_free|||
op_integerize|||
op_linklist||5.013006|
op_lvalue_flags|||
op_lvalue||5.013007|
op_null||5.007002|
op_parent||5.021002|n
op_prepend_elem||5.013006|
op_refcnt_dec|||
op_refcnt_inc|||
op_refcnt_lock||5.009002|
op_refcnt_unlock||5.009002|
op_relocate_sv|||
op_scope||5.013007|
op_sibling_splice||5.021002|n
op_std_init|||
op_unscope|||
open_script|||
openn_cleanup|||
openn_setup|||
opmethod_stash|||
opslab_force_free|||
opslab_free_nopad|||
opslab_free|||
pMY_CXT_|5.007003||p
pMY_CXT|5.007003||p
pTHX_|5.006000||p
pTHX|5.006000||p
packWARN|5.007003||p
pack_cat||5.007003|
pack_rec|||
package_version|||
package|||
packlist||5.008001|
pad_add_anon||5.008001|
pad_add_name_pvn||5.015001|
pad_add_name_pvs||5.015001|
pad_add_name_pv||5.015001|
pad_add_name_sv||5.015001|
pad_add_weakref|||
pad_alloc_name|||
pad_alloc|||
pad_block_start|||
pad_check_dup|||
pad_compname_type||5.009003|
pad_findlex|||
pad_findmy_pvn||5.015001|
pad_findmy_pvs||5.015001|
pad_findmy_pv||5.015001|
pad_findmy_sv||5.015001|
pad_fixup_inner_anons|||
pad_free|||
pad_leavemy|||
pad_new||5.008001|
pad_push|||
pad_reset|||
pad_setsv|||
pad_sv|||
pad_swipe|||
pad_tidy||5.008001|
padlist_dup|||
padlist_store|||
padname_dup|||
padname_free|||
padnamelist_dup|||
padnamelist_fetch||5.021007|n
padnamelist_free|||
padnamelist_store||5.021007|
parse_arithexpr||5.013008|
parse_barestmt||5.013007|
parse_block||5.013007|
parse_body|||
parse_fullexpr||5.013008|
parse_fullstmt||5.013005|
parse_gv_stash_name|||
parse_ident|||
parse_label||5.013007|
parse_listexpr||5.013008|
parse_lparen_question_flags|||
parse_stmtseq||5.013006|
parse_subsignature|||
parse_termexpr||5.013008|
parse_unicode_opts|||
parser_dup|||
parser_free_nexttoke_ops|||
parser_free|||
path_is_searchable|||n
peep|||
pending_ident|||
perl_alloc_using|||n
perl_alloc|||n
perl_clone_using|||n
perl_clone|||n
perl_construct|||n
perl_destruct||5.007003|n
perl_free|||n
perl_parse||5.006000|n
perl_run|||n
pidgone|||
pm_description|||
pmop_dump||5.006000|
pmruntime|||
pmtrans|||
pop_scope|||
populate_ANYOF_from_invlist|||
populate_isa|||v
pregcomp||5.009005|
pregexec|||
pregfree2||5.011000|
pregfree|||
prescan_version||5.011004|
printbuf|||
printf_nocontext|||vn
process_special_blocks|||
ptr_hash|||n
ptr_table_clear||5.009005|
ptr_table_fetch||5.009005|
ptr_table_find|||n
ptr_table_free||5.009005|
ptr_table_new||5.009005|
ptr_table_split||5.009005|
ptr_table_store||5.009005|
push_scope|||
put_charclass_bitmap_innards|||
put_code_point|||
put_range|||
pv_display|5.006000||p
pv_escape|5.009004||p
pv_pretty|5.009004||p
pv_uni_display||5.007003|
qerror|||
qsortsvu|||
quadmath_format_needed|||n
quadmath_format_single|||n
re_compile||5.009005|
re_croak2|||
re_dup_guts|||
re_intuit_start||5.019001|
re_intuit_string||5.006000|
re_op_compile|||
realloc||5.007002|n
reentrant_free||5.021008|
reentrant_init||5.021008|
reentrant_retry||5.021008|vn
reentrant_size||5.021008|
ref_array_or_hash|||
refcounted_he_chain_2hv|||
refcounted_he_fetch_pvn|||
refcounted_he_fetch_pvs|||
refcounted_he_fetch_pv|||
refcounted_he_fetch_sv|||
refcounted_he_free|||
refcounted_he_inc|||
refcounted_he_new_pvn|||
refcounted_he_new_pvs|||
refcounted_he_new_pv|||
refcounted_he_new_sv|||
refcounted_he_value|||
refkids|||
refto|||
ref||5.021008|
reg2Lanode|||
reg_check_named_buff_matched|||n
reg_named_buff_all||5.009005|
reg_named_buff_exists||5.009005|
reg_named_buff_fetch||5.009005|
reg_named_buff_firstkey||5.009005|
reg_named_buff_iter|||
reg_named_buff_nextkey||5.009005|
reg_named_buff_scalar||5.009005|
reg_named_buff|||
reg_node|||
reg_numbered_buff_fetch|||
reg_numbered_buff_length|||
reg_numbered_buff_store|||
reg_qr_package|||
reg_recode|||
reg_scan_name|||
reg_skipcomment|||n
reg_temp_copy|||
reganode|||
regatom|||
regbranch|||
regclass_swash||5.009004|
regclass|||
regcppop|||
regcppush|||
regcurly|||n
regdump_extflags|||
regdump_intflags|||
regdump||5.005000|
regdupe_internal|||
regexec_flags||5.005000|
regfree_internal||5.009005|
reghop3|||n
reghop4|||n
reghopmaybe3|||n
reginclass|||
reginitcolors||5.006000|
reginsert|||
regmatch|||
regnext||5.005000|
regnode_guts|||
regpatws|||n
regpiece|||
regpposixcc|||
regprop|||
regrepeat|||
regtail_study|||
regtail|||
regtry|||
reg|||
repeatcpy|||n
report_evil_fh|||
report_redefined_cv|||
report_uninit|||
report_wrongway_fh|||
require_pv||5.006000|
require_tie_mod|||
restore_magic|||
rninstr|||n
rpeep|||
rsignal_restore|||
rsignal_save|||
rsignal_state||5.004000|
rsignal||5.004000|
run_body|||
run_user_filter|||
runops_debug||5.005000|
runops_standard||5.005000|
rv2cv_op_cv||5.013006|
rvpv_dup|||
rxres_free|||
rxres_restore|||
rxres_save|||
safesyscalloc||5.006000|n
safesysfree||5.006000|n
safesysmalloc||5.006000|n
safesysrealloc||5.006000|n
same_dirent|||
save_I16||5.004000|
save_I32|||
save_I8||5.006000|
save_adelete||5.011000|
save_aelem_flags||5.011000|
save_aelem||5.004050|
save_aliased_sv|||
save_alloc||5.006000|
save_aptr|||
save_ary|||
save_bool||5.008001|
save_clearsv|||
save_delete|||
save_destructor_x||5.006000|
save_destructor||5.006000|
save_freeop|||
save_freepv|||
save_freesv|||
save_generic_pvref||5.006001|
save_generic_svref||5.005030|
save_gp||5.004000|
save_hash|||
save_hdelete||5.011000|
save_hek_flags|||n
save_helem_flags||5.011000|
save_helem||5.004050|
save_hints||5.010001|
save_hptr|||
save_int|||
save_item|||
save_iv||5.005000|
save_lines|||
save_list|||
save_long|||
save_magic_flags|||
save_mortalizesv||5.007001|
save_nogv|||
save_op||5.005000|
save_padsv_and_mortalize||5.010001|
save_pptr|||
save_pushi32ptr||5.010001|
save_pushptri32ptr|||
save_pushptrptr||5.010001|
save_pushptr||5.010001|
save_re_context||5.006000|
save_scalar_at|||
save_scalar|||
save_set_svflags||5.009000|
save_shared_pvref||5.007003|
save_sptr|||
save_strlen|||
save_svref|||
save_vptr||5.006000|
savepvn|||
savepvs||5.009003|
savepv|||
savesharedpvn||5.009005|
savesharedpvs||5.013006|
savesharedpv||5.007003|
savesharedsvpv||5.013006|
savestack_grow_cnt||5.008001|
savestack_grow|||
savesvpv||5.009002|
sawparens|||
scalar_mod_type|||n
scalarboolean|||
scalarkids|||
scalarseq|||
scalarvoid|||
scalar|||
scan_bin||5.006000|
scan_commit|||
scan_const|||
scan_formline|||
scan_heredoc|||
scan_hex|||
scan_ident|||
scan_inputsymbol|||
scan_num||5.007001|
scan_oct|||
scan_pat|||
scan_str|||
scan_subst|||
scan_trans|||
scan_version||5.009001|
scan_vstring||5.009005|
scan_word|||
search_const|||
seed||5.008001|
sequence_num|||
set_ANYOF_arg|||
set_caret_X|||
set_context||5.006000|n
set_numeric_local||5.006000|
set_numeric_radix||5.006000|
set_numeric_standard||5.006000|
set_padlist|||n
setdefout|||
share_hek_flags|||
share_hek||5.004000|
should_warn_nl|||n
si_dup|||
sighandler|||n
simplify_sort|||
skipspace_flags|||
softref2xv|||
sortcv_stacked|||
sortcv_xsub|||
sortcv|||
sortsv_flags||5.009003|
sortsv||5.007003|
space_join_names_mortal|||
ss_dup|||
ssc_add_range|||
ssc_and|||
ssc_anything|||
ssc_clear_locale|||n
ssc_cp_and|||
ssc_finalize|||
ssc_init|||
ssc_intersection|||
ssc_is_anything|||n
ssc_is_cp_posixl_init|||n
ssc_or|||
ssc_union|||
stack_grow|||
start_glob|||
start_subparse||5.004000|
stdize_locale|||
strEQ|||
strGE|||
strGT|||
strLE|||
strLT|||
strNE|||
str_to_version||5.006000|
strip_return|||
strnEQ|||
strnNE|||
study_chunk|||
sub_crush_depth|||
sublex_done|||
sublex_push|||
sublex_start|||
sv_2bool_flags||5.013006|
sv_2bool|||
sv_2cv|||
sv_2io|||
sv_2iuv_common|||
sv_2iuv_non_preserve|||
sv_2iv_flags||5.009001|
sv_2iv|||
sv_2mortal|||
sv_2num|||
sv_2nv_flags||5.013001|
sv_2pv_flags|5.007002||p
sv_2pv_nolen|5.006000||p
sv_2pvbyte_nolen|5.006000||p
sv_2pvbyte|5.006000||p
sv_2pvutf8_nolen||5.006000|
sv_2pvutf8||5.006000|
sv_2pv|||
sv_2uv_flags||5.009001|
sv_2uv|5.004000||p
sv_add_arena|||
sv_add_backref|||
sv_backoff|||n
sv_bless|||
sv_buf_to_ro|||
sv_buf_to_rw|||
sv_cat_decode||5.008001|
sv_catpv_flags||5.013006|
sv_catpv_mg|5.004050||p
sv_catpv_nomg||5.013006|
sv_catpvf_mg_nocontext|||pvn
sv_catpvf_mg|5.006000|5.004000|pv
sv_catpvf_nocontext|||vn
sv_catpvf||5.004000|v
sv_catpvn_flags||5.007002|
sv_catpvn_mg|5.004050||p
sv_catpvn_nomg|5.007002||p
sv_catpvn|||
sv_catpvs_flags||5.013006|
sv_catpvs_mg||5.013006|
sv_catpvs_nomg||5.013006|
sv_catpvs|5.009003||p
sv_catpv|||
sv_catsv_flags||5.007002|
sv_catsv_mg|5.004050||p
sv_catsv_nomg|5.007002||p
sv_catsv|||
sv_chop|||
sv_clean_all|||
sv_clean_objs|||
sv_clear|||
sv_cmp_flags||5.013006|
sv_cmp_locale_flags||5.013006|
sv_cmp_locale||5.004000|
sv_cmp|||
sv_collxfrm_flags||5.013006|
sv_collxfrm|||
sv_copypv_flags||5.017002|
sv_copypv_nomg||5.017002|
sv_copypv|||
sv_dec_nomg||5.013002|
sv_dec|||
sv_del_backref|||
sv_derived_from_pvn||5.015004|
sv_derived_from_pv||5.015004|
sv_derived_from_sv||5.015004|
sv_derived_from||5.004000|
sv_destroyable||5.010000|
sv_display|||
sv_does_pvn||5.015004|
sv_does_pv||5.015004|
sv_does_sv||5.015004|
sv_does||5.009004|
sv_dump|||
sv_dup_common|||
sv_dup_inc_multiple|||
sv_dup_inc|||
sv_dup|||
sv_eq_flags||5.013006|
sv_eq|||
sv_exp_grow|||
sv_force_normal_flags||5.007001|
sv_force_normal||5.006000|
sv_free2|||
sv_free_arenas|||
sv_free|||
sv_get_backrefs||5.021008|n
sv_gets||5.003070|
sv_grow|||
sv_i_ncmp|||
sv_inc_nomg||5.013002|
sv_inc|||
sv_insert_flags||5.010001|
sv_insert|||
sv_isa|||
sv_isobject|||
sv_iv||5.005000|
sv_kill_backrefs|||
sv_len_utf8_nomg|||
sv_len_utf8||5.006000|
sv_len|||
sv_magic_portable|5.021008|5.004000|p
sv_magicext_mglob|||
sv_magicext||5.007003|
sv_magic|||
sv_mortalcopy_flags|||
sv_mortalcopy|||
sv_ncmp|||
sv_newmortal|||
sv_newref|||
sv_nolocking||5.007003|
sv_nosharing||5.007003|
sv_nounlocking|||
sv_nv||5.005000|
sv_only_taint_gmagic|||n
sv_or_pv_pos_u2b|||
sv_peek||5.005000|
sv_pos_b2u_flags||5.019003|
sv_pos_b2u_midway|||
sv_pos_b2u||5.006000|
sv_pos_u2b_cached|||
sv_pos_u2b_flags||5.011005|
sv_pos_u2b_forwards|||n
sv_pos_u2b_midway|||n
sv_pos_u2b||5.006000|
sv_pvbyten_force||5.006000|
sv_pvbyten||5.006000|
sv_pvbyte||5.006000|
sv_pvn_force_flags|5.007002||p
sv_pvn_force|||
sv_pvn_nomg|5.007003|5.005000|p
sv_pvn||5.005000|
sv_pvutf8n_force||5.006000|
sv_pvutf8n||5.006000|
sv_pvutf8||5.006000|
sv_pv||5.006000|
sv_recode_to_utf8||5.007003|
sv_reftype|||
sv_ref|||
sv_release_COW|||
sv_replace|||
sv_report_used|||
sv_resetpvn|||
sv_reset|||
sv_rvweaken||5.006000|
sv_sethek|||
sv_setiv_mg|5.004050||p
sv_setiv|||
sv_setnv_mg|5.006000||p
sv_setnv|||
sv_setpv_mg|5.004050||p
sv_setpvf_mg_nocontext|||pvn
sv_setpvf_mg|5.006000|5.004000|pv
sv_setpvf_nocontext|||vn
sv_setpvf||5.004000|v
sv_setpviv_mg||5.008001|
sv_setpviv||5.008001|
sv_setpvn_mg|5.004050||p
sv_setpvn|||
sv_setpvs_mg||5.013006|
sv_setpvs|5.009004||p
sv_setpv|||
sv_setref_iv|||
sv_setref_nv|||
sv_setref_pvn|||
sv_setref_pvs||5.021008|
sv_setref_pv|||
sv_setref_uv||5.007001|
sv_setsv_cow|||
sv_setsv_flags||5.007002|
sv_setsv_mg|5.004050||p
sv_setsv_nomg|5.007002||p
sv_setsv|||
sv_setuv_mg|5.004050||p
sv_setuv|5.004000||p
sv_tainted||5.004000|
sv_taint||5.004000|
sv_true||5.005000|
sv_unglob|||
sv_uni_display||5.007003|
sv_unmagicext|5.013008||p
sv_unmagic|||
sv_unref_flags||5.007001|
sv_unref|||
sv_untaint||5.004000|
sv_upgrade|||
sv_usepvn_flags||5.009004|
sv_usepvn_mg|5.004050||p
sv_usepvn|||
sv_utf8_decode||5.006000|
sv_utf8_downgrade||5.006000|
sv_utf8_encode||5.006000|
sv_utf8_upgrade_flags_grow||5.011000|
sv_utf8_upgrade_flags||5.007002|
sv_utf8_upgrade_nomg||5.007002|
sv_utf8_upgrade||5.007001|
sv_uv|5.005000||p
sv_vcatpvf_mg|5.006000|5.004000|p
sv_vcatpvfn_flags||5.017002|
sv_vcatpvfn||5.004000|
sv_vcatpvf|5.006000|5.004000|p
sv_vsetpvf_mg|5.006000|5.004000|p
sv_vsetpvfn||5.004000|
sv_vsetpvf|5.006000|5.004000|p
svtype|||
swallow_bom|||
swash_fetch||5.007002|
swash_init||5.006000|
swash_scan_list_line|||
swatch_get|||
sync_locale||5.021004|
sys_init3||5.010000|n
sys_init||5.010000|n
sys_intern_clear|||
sys_intern_dup|||
sys_intern_init|||
sys_term||5.010000|n
taint_env|||
taint_proper|||
tied_method|||v
tmps_grow_p|||
toFOLD_uni||5.007003|
toFOLD_utf8||5.019001|
toFOLD||5.019001|
toLOWER_L1||5.019001|
toLOWER_LC||5.004000|
toLOWER_uni||5.007003|
toLOWER_utf8||5.015007|
toLOWER|||
toTITLE_uni||5.007003|
toTITLE_utf8||5.015007|
toTITLE||5.019001|
toUPPER_uni||5.007003|
toUPPER_utf8||5.015007|
toUPPER|||
to_byte_substr|||
to_lower_latin1|||n
to_uni_fold||5.007003|
to_uni_lower_lc||5.006000|
to_uni_lower||5.007003|
to_uni_title_lc||5.006000|
to_uni_title||5.007003|
to_uni_upper_lc||5.006000|
to_uni_upper||5.007003|
to_utf8_case||5.007003|
to_utf8_fold||5.015007|
to_utf8_lower||5.015007|
to_utf8_substr|||
to_utf8_title||5.015007|
to_utf8_upper||5.015007|
tokenize_use|||
tokeq|||
tokereport|||
too_few_arguments_pv|||
too_many_arguments_pv|||
translate_substr_offsets|||n
try_amagic_bin|||
try_amagic_un|||
uiv_2buf|||n
unlnk|||
unpack_rec|||
unpack_str||5.007003|
unpackstring||5.008001|
unreferenced_to_tmp_stack|||
unshare_hek_or_pvn|||
unshare_hek|||
unsharepvn||5.003070|
unwind_handler_stack|||
update_debugger_info|||
upg_version||5.009005|
usage|||
utf16_textfilter|||
utf16_to_utf8_reversed||5.006001|
utf16_to_utf8||5.006001|
utf8_distance||5.006000|
utf8_hop||5.006000|n
utf8_length||5.007001|
utf8_mg_len_cache_update|||
utf8_mg_pos_cache_update|||
utf8_to_bytes||5.006001|
utf8_to_uvchr_buf||5.015009|
utf8_to_uvchr||5.007001|
utf8_to_uvuni_buf||5.015009|
utf8_to_uvuni||5.007001|
utf8n_to_uvchr||5.007001|
utf8n_to_uvuni||5.007001|
utilize|||
uvchr_to_utf8_flags||5.007003|
uvchr_to_utf8||5.007001|
uvoffuni_to_utf8_flags||5.019004|
uvuni_to_utf8_flags||5.007003|
uvuni_to_utf8||5.007001|
valid_utf8_to_uvchr||5.015009|
valid_utf8_to_uvuni||5.015009|
validate_proto|||
validate_suid|||
varname|||
vcmp||5.009000|
vcroak||5.006000|
vdeb||5.007003|
vform||5.006000|
visit|||
vivify_defelem|||
vivify_ref|||
vload_module|5.006000||p
vmess||5.006000|
vnewSVpvf|5.006000|5.004000|p
vnormal||5.009002|
vnumify||5.009000|
vstringify||5.009000|
vverify||5.009003|
vwarner||5.006000|
vwarn||5.006000|
wait4pid|||
warn_nocontext|||vn
warn_sv||5.013001|
warner_nocontext|||vn
warner|5.006000|5.004000|pv
warn|||v
was_lvalue_sub|||
watch|||
whichsig_pvn||5.015004|
whichsig_pv||5.015004|
whichsig_sv||5.015004|
whichsig|||
win32_croak_not_implemented|||n
with_queued_errors|||
wrap_op_checker||5.015008|
write_to_stderr|||
xs_boot_epilog|||
xs_handshake|||vn
xs_version_bootcheck|||
yyerror_pvn|||
yyerror_pv|||
yyerror|||
yylex|||
yyparse|||
yyunlex|||
yywarn|||
);

if (exists $opt{'list-unsupported'}) {
  my $f;
  for $f (sort { lc $a cmp lc $b } keys %API) {
    next unless $API{$f}{todo};
    print "$f ", '.'x(40-length($f)), " ", format_version($API{$f}{todo}), "\n";
  }
  exit 0;
}

# Scan for possible replacement candidates

my(%replace, %need, %hints, %warnings, %depends);
my $replace = 0;
my($hint, $define, $function);

sub find_api
{
  my $code = shift;
  $code =~ s{
    / (?: \*[^*]*\*+(?:[^$ccs][^*]*\*+)* / | /[^\r\n]*)
  | "[^"\\]*(?:\\.[^"\\]*)*"
  | '[^'\\]*(?:\\.[^'\\]*)*' }{}egsx;
  grep { exists $API{$_} } $code =~ /(\w+)/mg;
}

while (<DATA>) {
  if ($hint) {
    my $h = $hint->[0] eq 'Hint' ? \%hints : \%warnings;
    if (m{^\s*\*\s(.*?)\s*$}) {
      for (@{$hint->[1]}) {
        $h->{$_} ||= '';  # suppress warning with older perls
        $h->{$_} .= "$1\n";
      }
    }
    else { undef $hint }
  }

  $hint = [$1, [split /,?\s+/, $2]]
      if m{^\s*$rccs\s+(Hint|Warning):\s+(\w+(?:,?\s+\w+)*)\s*$};

  if ($define) {
    if ($define->[1] =~ /\\$/) {
      $define->[1] .= $_;
    }
    else {
      if (exists $API{$define->[0]} && $define->[1] !~ /^DPPP_\(/) {
        my @n = find_api($define->[1]);
        push @{$depends{$define->[0]}}, @n if @n
      }
      undef $define;
    }
  }

  $define = [$1, $2] if m{^\s*#\s*define\s+(\w+)(?:\([^)]*\))?\s+(.*)};

  if ($function) {
    if (/^}/) {
      if (exists $API{$function->[0]}) {
        my @n = find_api($function->[1]);
        push @{$depends{$function->[0]}}, @n if @n
      }
      undef $function;
    }
    else {
      $function->[1] .= $_;
    }
  }

  $function = [$1, ''] if m{^DPPP_\(my_(\w+)\)};

  $replace     = $1 if m{^\s*$rccs\s+Replace:\s+(\d+)\s+$rcce\s*$};
  $replace{$2} = $1 if $replace and m{^\s*#\s*define\s+(\w+)(?:\([^)]*\))?\s+(\w+)};
  $replace{$2} = $1 if m{^\s*#\s*define\s+(\w+)(?:\([^)]*\))?\s+(\w+).*$rccs\s+Replace\s+$rcce};
  $replace{$1} = $2 if m{^\s*$rccs\s+Replace (\w+) with (\w+)\s+$rcce\s*$};

  if (m{^\s*$rccs\s+(\w+(\s*,\s*\w+)*)\s+depends\s+on\s+(\w+(\s*,\s*\w+)*)\s+$rcce\s*$}) {
    my @deps = map { s/\s+//g; $_ } split /,/, $3;
    my $d;
    for $d (map { s/\s+//g; $_ } split /,/, $1) {
      push @{$depends{$d}}, @deps;
    }
  }

  $need{$1} = 1 if m{^#if\s+defined\(NEED_(\w+)(?:_GLOBAL)?\)};
}

for (values %depends) {
  my %s;
  $_ = [sort grep !$s{$_}++, @$_];
}

if (exists $opt{'api-info'}) {
  my $f;
  my $count = 0;
  my $match = $opt{'api-info'} =~ m!^/(.*)/$! ? $1 : "^\Q$opt{'api-info'}\E\$";
  for $f (sort { lc $a cmp lc $b } keys %API) {
    next unless $f =~ /$match/;
    print "\n=== $f ===\n\n";
    my $info = 0;
    if ($API{$f}{base} || $API{$f}{todo}) {
      my $base = format_version($API{$f}{base} || $API{$f}{todo});
      print "Supported at least starting from perl-$base.\n";
      $info++;
    }
    if ($API{$f}{provided}) {
      my $todo = $API{$f}{todo} ? format_version($API{$f}{todo}) : "5.003";
      print "Support by $ppport provided back to perl-$todo.\n";
      print "Support needs to be explicitly requested by NEED_$f.\n" if exists $need{$f};
      print "Depends on: ", join(', ', @{$depends{$f}}), ".\n" if exists $depends{$f};
      print "\n$hints{$f}" if exists $hints{$f};
      print "\nWARNING:\n$warnings{$f}" if exists $warnings{$f};
      $info++;
    }
    print "No portability information available.\n" unless $info;
    $count++;
  }
  $count or print "Found no API matching '$opt{'api-info'}'.";
  print "\n";
  exit 0;
}

if (exists $opt{'list-provided'}) {
  my $f;
  for $f (sort { lc $a cmp lc $b } keys %API) {
    next unless $API{$f}{provided};
    my @flags;
    push @flags, 'explicit' if exists $need{$f};
    push @flags, 'depend'   if exists $depends{$f};
    push @flags, 'hint'     if exists $hints{$f};
    push @flags, 'warning'  if exists $warnings{$f};
    my $flags = @flags ? '  ['.join(', ', @flags).']' : '';
    print "$f$flags\n";
  }
  exit 0;
}

my @files;
my @srcext = qw( .xs .c .h .cc .cpp -c.inc -xs.inc );
my $srcext = join '|', map { quotemeta $_ } @srcext;

if (@ARGV) {
  my %seen;
  for (@ARGV) {
    if (-e) {
      if (-f) {
        push @files, $_ unless $seen{$_}++;
      }
      else { warn "'$_' is not a file.\n" }
    }
    else {
      my @new = grep { -f } glob $_
          or warn "'$_' does not exist.\n";
      push @files, grep { !$seen{$_}++ } @new;
    }
  }
}
else {
  eval {
    require File::Find;
    File::Find::find(sub {
      $File::Find::name =~ /($srcext)$/i
          and push @files, $File::Find::name;
    }, '.');
  };
  if ($@) {
    @files = map { glob "*$_" } @srcext;
  }
}

if (!@ARGV || $opt{filter}) {
  my(@in, @out);
  my %xsc = map { /(.*)\.xs$/ ? ("$1.c" => 1, "$1.cc" => 1) : () } @files;
  for (@files) {
    my $out = exists $xsc{$_} || /\b\Q$ppport\E$/i || !/($srcext)$/i;
    push @{ $out ? \@out : \@in }, $_;
  }
  if (@ARGV && @out) {
    warning("Skipping the following files (use --nofilter to avoid this):\n| ", join "\n| ", @out);
  }
  @files = @in;
}

die "No input files given!\n" unless @files;

my(%files, %global, %revreplace);
%revreplace = reverse %replace;
my $filename;
my $patch_opened = 0;

for $filename (@files) {
  unless (open IN, "<$filename") {
    warn "Unable to read from $filename: $!\n";
    next;
  }

  info("Scanning $filename ...");

  my $c = do { local $/; <IN> };
  close IN;

  my %file = (orig => $c, changes => 0);

  # Temporarily remove C/XS comments and strings from the code
  my @ccom;

  $c =~ s{
    ( ^$HS*\#$HS*include\b[^\r\n]+\b(?:\Q$ppport\E|XSUB\.h)\b[^\r\n]*
    | ^$HS*\#$HS*(?:define|elif|if(?:def)?)\b[^\r\n]* )
  | ( ^$HS*\#[^\r\n]*
    | "[^"\\]*(?:\\.[^"\\]*)*"
    | '[^'\\]*(?:\\.[^'\\]*)*'
    | / (?: \*[^*]*\*+(?:[^$ccs][^*]*\*+)* / | /[^\r\n]* ) )
  }{ defined $2 and push @ccom, $2;
     defined $1 ? $1 : "$ccs$#ccom$cce" }mgsex;

  $file{ccom} = \@ccom;
  $file{code} = $c;
  $file{has_inc_ppport} = $c =~ /^$HS*#$HS*include[^\r\n]+\b\Q$ppport\E\b/m;

  my $func;

  for $func (keys %API) {
    my $match = $func;
    $match .= "|$revreplace{$func}" if exists $revreplace{$func};
    if ($c =~ /\b(?:Perl_)?($match)\b/) {
      $file{uses_replace}{$1}++ if exists $revreplace{$func} && $1 eq $revreplace{$func};
      $file{uses_Perl}{$func}++ if $c =~ /\bPerl_$func\b/;
      if (exists $API{$func}{provided}) {
        $file{uses_provided}{$func}++;
        if (!exists $API{$func}{base} || $API{$func}{base} > $opt{'compat-version'}) {
          $file{uses}{$func}++;
          my @deps = rec_depend($func);
          if (@deps) {
            $file{uses_deps}{$func} = \@deps;
            for (@deps) {
              $file{uses}{$_} = 0 unless exists $file{uses}{$_};
            }
          }
          for ($func, @deps) {
            $file{needs}{$_} = 'static' if exists $need{$_};
          }
        }
      }
      if (exists $API{$func}{todo} && $API{$func}{todo} > $opt{'compat-version'}) {
        if ($c =~ /\b$func\b/) {
          $file{uses_todo}{$func}++;
        }
      }
    }
  }

  while ($c =~ /^$HS*#$HS*define$HS+(NEED_(\w+?)(_GLOBAL)?)\b/mg) {
    if (exists $need{$2}) {
      $file{defined $3 ? 'needed_global' : 'needed_static'}{$2}++;
    }
    else { warning("Possibly wrong #define $1 in $filename") }
  }

  for (qw(uses needs uses_todo needed_global needed_static)) {
    for $func (keys %{$file{$_}}) {
      push @{$global{$_}{$func}}, $filename;
    }
  }

  $files{$filename} = \%file;
}

# Globally resolve NEED_'s
my $need;
for $need (keys %{$global{needs}}) {
  if (@{$global{needs}{$need}} > 1) {
    my @targets = @{$global{needs}{$need}};
    my @t = grep $files{$_}{needed_global}{$need}, @targets;
    @targets = @t if @t;
    @t = grep /\.xs$/i, @targets;
    @targets = @t if @t;
    my $target = shift @targets;
    $files{$target}{needs}{$need} = 'global';
    for (@{$global{needs}{$need}}) {
      $files{$_}{needs}{$need} = 'extern' if $_ ne $target;
    }
  }
}

for $filename (@files) {
  exists $files{$filename} or next;

  info("=== Analyzing $filename ===");

  my %file = %{$files{$filename}};
  my $func;
  my $c = $file{code};
  my $warnings = 0;

  for $func (sort keys %{$file{uses_Perl}}) {
    if ($API{$func}{varargs}) {
      unless ($API{$func}{nothxarg}) {
        my $changes = ($c =~ s{\b(Perl_$func\s*\(\s*)(?!aTHX_?)(\)|[^\s)]*\))}
                              { $1 . ($2 eq ')' ? 'aTHX' : 'aTHX_ ') . $2 }ge);
        if ($changes) {
          warning("Doesn't pass interpreter argument aTHX to Perl_$func");
          $file{changes} += $changes;
        }
      }
    }
    else {
      warning("Uses Perl_$func instead of $func");
      $file{changes} += ($c =~ s{\bPerl_$func(\s*)\((\s*aTHX_?)?\s*}
                                {$func$1(}g);
    }
  }

  for $func (sort keys %{$file{uses_replace}}) {
    warning("Uses $func instead of $replace{$func}");
    $file{changes} += ($c =~ s/\b$func\b/$replace{$func}/g);
  }

  for $func (sort keys %{$file{uses_provided}}) {
    if ($file{uses}{$func}) {
      if (exists $file{uses_deps}{$func}) {
        diag("Uses $func, which depends on ", join(', ', @{$file{uses_deps}{$func}}));
      }
      else {
        diag("Uses $func");
      }
    }
    $warnings += hint($func);
  }

  unless ($opt{quiet}) {
    for $func (sort keys %{$file{uses_todo}}) {
      print "*** WARNING: Uses $func, which may not be portable below perl ",
            format_version($API{$func}{todo}), ", even with '$ppport'\n";
      $warnings++;
    }
  }

  for $func (sort keys %{$file{needed_static}}) {
    my $message = '';
    if (not exists $file{uses}{$func}) {
      $message = "No need to define NEED_$func if $func is never used";
    }
    elsif (exists $file{needs}{$func} && $file{needs}{$func} ne 'static') {
      $message = "No need to define NEED_$func when already needed globally";
    }
    if ($message) {
      diag($message);
      $file{changes} += ($c =~ s/^$HS*#$HS*define$HS+NEED_$func\b.*$LF//mg);
    }
  }

  for $func (sort keys %{$file{needed_global}}) {
    my $message = '';
    if (not exists $global{uses}{$func}) {
      $message = "No need to define NEED_${func}_GLOBAL if $func is never used";
    }
    elsif (exists $file{needs}{$func}) {
      if ($file{needs}{$func} eq 'extern') {
        $message = "No need to define NEED_${func}_GLOBAL when already needed globally";
      }
      elsif ($file{needs}{$func} eq 'static') {
        $message = "No need to define NEED_${func}_GLOBAL when only used in this file";
      }
    }
    if ($message) {
      diag($message);
      $file{changes} += ($c =~ s/^$HS*#$HS*define$HS+NEED_${func}_GLOBAL\b.*$LF//mg);
    }
  }

  $file{needs_inc_ppport} = keys %{$file{uses}};

  if ($file{needs_inc_ppport}) {
    my $pp = '';

    for $func (sort keys %{$file{needs}}) {
      my $type = $file{needs}{$func};
      next if $type eq 'extern';
      my $suffix = $type eq 'global' ? '_GLOBAL' : '';
      unless (exists $file{"needed_$type"}{$func}) {
        if ($type eq 'global') {
          diag("Files [@{$global{needs}{$func}}] need $func, adding global request");
        }
        else {
          diag("File needs $func, adding static request");
        }
        $pp .= "#define NEED_$func$suffix\n";
      }
    }

    if ($pp && ($c =~ s/^(?=$HS*#$HS*define$HS+NEED_\w+)/$pp/m)) {
      $pp = '';
      $file{changes}++;
    }

    unless ($file{has_inc_ppport}) {
      diag("Needs to include '$ppport'");
      $pp .= qq(#include "$ppport"\n)
    }

    if ($pp) {
      $file{changes} += ($c =~ s/^($HS*#$HS*define$HS+NEED_\w+.*?)^/$1$pp/ms)
                     || ($c =~ s/^(?=$HS*#$HS*include.*\Q$ppport\E)/$pp/m)
                     || ($c =~ s/^($HS*#$HS*include.*XSUB.*\s*?)^/$1$pp/m)
                     || ($c =~ s/^/$pp/);
    }
  }
  else {
    if ($file{has_inc_ppport}) {
      diag("No need to include '$ppport'");
      $file{changes} += ($c =~ s/^$HS*?#$HS*include.*\Q$ppport\E.*?$LF//m);
    }
  }

  # put back in our C comments
  my $ix;
  my $cppc = 0;
  my @ccom = @{$file{ccom}};
  for $ix (0 .. $#ccom) {
    if (!$opt{cplusplus} && $ccom[$ix] =~ s!^//!!) {
      $cppc++;
      $file{changes} += $c =~ s/$rccs$ix$rcce/$ccs$ccom[$ix] $cce/;
    }
    else {
      $c =~ s/$rccs$ix$rcce/$ccom[$ix]/;
    }
  }

  if ($cppc) {
    my $s = $cppc != 1 ? 's' : '';
    warning("Uses $cppc C++ style comment$s, which is not portable");
  }

  my $s = $warnings != 1 ? 's' : '';
  my $warn = $warnings ? " ($warnings warning$s)" : '';
  info("Analysis completed$warn");

  if ($file{changes}) {
    if (exists $opt{copy}) {
      my $newfile = "$filename$opt{copy}";
      if (-e $newfile) {
        error("'$newfile' already exists, refusing to write copy of '$filename'");
      }
      else {
        local *F;
        if (open F, ">$newfile") {
          info("Writing copy of '$filename' with changes to '$newfile'");
          print F $c;
          close F;
        }
        else {
          error("Cannot open '$newfile' for writing: $!");
        }
      }
    }
    elsif (exists $opt{patch} || $opt{changes}) {
      if (exists $opt{patch}) {
        unless ($patch_opened) {
          if (open PATCH, ">$opt{patch}") {
            $patch_opened = 1;
          }
          else {
            error("Cannot open '$opt{patch}' for writing: $!");
            delete $opt{patch};
            $opt{changes} = 1;
            goto fallback;
          }
        }
        mydiff(\*PATCH, $filename, $c);
      }
      else {
fallback:
        info("Suggested changes:");
        mydiff(\*STDOUT, $filename, $c);
      }
    }
    else {
      my $s = $file{changes} == 1 ? '' : 's';
      info("$file{changes} potentially required change$s detected");
    }
  }
  else {
    info("Looks good");
  }
}

close PATCH if $patch_opened;

exit 0;


sub try_use { eval "use @_;"; return $@ eq '' }

sub mydiff
{
  local *F = shift;
  my($file, $str) = @_;
  my $diff;

  if (exists $opt{diff}) {
    $diff = run_diff($opt{diff}, $file, $str);
  }

  if (!defined $diff and try_use('Text::Diff')) {
    $diff = Text::Diff::diff($file, \$str, { STYLE => 'Unified' });
    $diff = <<HEADER . $diff;
--- $file
+++ $file.patched
HEADER
  }

  if (!defined $diff) {
    $diff = run_diff('diff -u', $file, $str);
  }

  if (!defined $diff) {
    $diff = run_diff('diff', $file, $str);
  }

  if (!defined $diff) {
    error("Cannot generate a diff. Please install Text::Diff or use --copy.");
    return;
  }

  print F $diff;
}

sub run_diff
{
  my($prog, $file, $str) = @_;
  my $tmp = 'dppptemp';
  my $suf = 'aaa';
  my $diff = '';
  local *F;

  while (-e "$tmp.$suf") { $suf++ }
  $tmp = "$tmp.$suf";

  if (open F, ">$tmp") {
    print F $str;
    close F;

    if (open F, "$prog $file $tmp |") {
      while (<F>) {
        s/\Q$tmp\E/$file.patched/;
        $diff .= $_;
      }
      close F;
      unlink $tmp;
      return $diff;
    }

    unlink $tmp;
  }
  else {
    error("Cannot open '$tmp' for writing: $!");
  }

  return undef;
}

sub rec_depend
{
  my($func, $seen) = @_;
  return () unless exists $depends{$func};
  $seen = {%{$seen||{}}};
  return () if $seen->{$func}++;
  my %s;
  grep !$s{$_}++, map { ($_, rec_depend($_, $seen)) } @{$depends{$func}};
}

sub parse_version
{
  my $ver = shift;

  if ($ver =~ /^(\d+)\.(\d+)\.(\d+)$/) {
    return ($1, $2, $3);
  }
  elsif ($ver !~ /^\d+\.[\d_]+$/) {
    die "cannot parse version '$ver'\n";
  }

  $ver =~ s/_//g;
  $ver =~ s/$/000000/;

  my($r,$v,$s) = $ver =~ /(\d+)\.(\d{3})(\d{3})/;

  $v = int $v;
  $s = int $s;

  if ($r < 5 || ($r == 5 && $v < 6)) {
    if ($s % 10) {
      die "cannot parse version '$ver'\n";
    }
  }

  return ($r, $v, $s);
}

sub format_version
{
  my $ver = shift;

  $ver =~ s/$/000000/;
  my($r,$v,$s) = $ver =~ /(\d+)\.(\d{3})(\d{3})/;

  $v = int $v;
  $s = int $s;

  if ($r < 5 || ($r == 5 && $v < 6)) {
    if ($s % 10) {
      die "invalid version '$ver'\n";
    }
    $s /= 10;

    $ver = sprintf "%d.%03d", $r, $v;
    $s > 0 and $ver .= sprintf "_%02d", $s;

    return $ver;
  }

  return sprintf "%d.%d.%d", $r, $v, $s;
}

sub info
{
  $opt{quiet} and return;
  print @_, "\n";
}

sub diag
{
  $opt{quiet} and return;
  $opt{diag} and print @_, "\n";
}

sub warning
{
  $opt{quiet} and return;
  print "*** ", @_, "\n";
}

sub error
{
  print "*** ERROR: ", @_, "\n";
}

my %given_hints;
my %given_warnings;
sub hint
{
  $opt{quiet} and return;
  my $func = shift;
  my $rv = 0;
  if (exists $warnings{$func} && !$given_warnings{$func}++) {
    my $warn = $warnings{$func};
    $warn =~ s!^!*** !mg;
    print "*** WARNING: $func\n", $warn;
    $rv++;
  }
  if ($opt{hints} && exists $hints{$func} && !$given_hints{$func}++) {
    my $hint = $hints{$func};
    $hint =~ s/^/   /mg;
    print "   --- hint for $func ---\n", $hint;
  }
  $rv;
}

sub usage
{
  my($usage) = do { local(@ARGV,$/)=($0); <> } =~ /^=head\d$HS+SYNOPSIS\s*^(.*?)\s*^=/ms;
  my %M = ( 'I' => '*' );
  $usage =~ s/^\s*perl\s+\S+/$^X $0/;
  $usage =~ s/([A-Z])<([^>]+)>/$M{$1}$2$M{$1}/g;

  print <<ENDUSAGE;

Usage: $usage

See perldoc $0 for details.

ENDUSAGE

  exit 2;
}

sub strip
{
  my $self = do { local(@ARGV,$/)=($0); <> };
  my($copy) = $self =~ /^=head\d\s+COPYRIGHT\s*^(.*?)^=\w+/ms;
  $copy =~ s/^(?=\S+)/    /gms;
  $self =~ s/^$HS+Do NOT edit.*?(?=^-)/$copy/ms;
  $self =~ s/^SKIP.*(?=^__DATA__)/SKIP
if (\@ARGV && \$ARGV[0] eq '--unstrip') {
  eval { require Devel::PPPort };
  \$@ and die "Cannot require Devel::PPPort, please install.\\n";
  if (eval \$Devel::PPPort::VERSION < $VERSION) {
    die "$0 was originally generated with Devel::PPPort $VERSION.\\n"
      . "Your Devel::PPPort is only version \$Devel::PPPort::VERSION.\\n"
      . "Please install a newer version, or --unstrip will not work.\\n";
  }
  Devel::PPPort::WriteFile(\$0);
  exit 0;
}
print <<END;

Sorry, but this is a stripped version of \$0.

To be able to use its original script and doc functionality,
please try to regenerate this file using:

  \$^X \$0 --unstrip

END
/ms;
  my($pl, $c) = $self =~ /(.*^__DATA__)(.*)/ms;
  $c =~ s{
    / (?: \*[^*]*\*+(?:[^$ccs][^*]*\*+)* / | /[^\r\n]*)
  | ( "[^"\\]*(?:\\.[^"\\]*)*"
    | '[^'\\]*(?:\\.[^'\\]*)*' )
  | ($HS+) }{ defined $2 ? ' ' : ($1 || '') }gsex;
  $c =~ s!\s+$!!mg;
  $c =~ s!^$LF!!mg;
  $c =~ s!^\s*#\s*!#!mg;
  $c =~ s!^\s+!!mg;

  open OUT, ">$0" or die "cannot strip $0: $!\n";
  print OUT "$pl$c\n";

  exit 0;
}

__DATA__
*/

#ifndef _P_P_PORTABILITY_H_
#define _P_P_PORTABILITY_H_

#ifndef DPPP_NAMESPACE
#  define DPPP_NAMESPACE DPPP_
#endif

#define DPPP_CAT2(x,y) CAT2(x,y)
#define DPPP_(name) DPPP_CAT2(DPPP_NAMESPACE, name)

#ifndef PERL_REVISION
#  if !defined(__PATCHLEVEL_H_INCLUDED__) && !(defined(PATCHLEVEL) && defined(SUBVERSION))
#    define PERL_PATCHLEVEL_H_IMPLICIT
#    include <patchlevel.h>
#  endif
#  if !(defined(PERL_VERSION) || (defined(SUBVERSION) && defined(PATCHLEVEL)))
#    include <could_not_find_Perl_patchlevel.h>
#  endif
#  ifndef PERL_REVISION
#    define PERL_REVISION       (5)
     /* Replace: 1 */
#    define PERL_VERSION        PATCHLEVEL
#    define PERL_SUBVERSION     SUBVERSION
     /* Replace PERL_PATCHLEVEL with PERL_VERSION */
     /* Replace: 0 */
#  endif
#endif

#define _dpppDEC2BCD(dec) ((((dec)/100)<<8)|((((dec)%100)/10)<<4)|((dec)%10))
#define PERL_BCDVERSION ((_dpppDEC2BCD(PERL_REVISION)<<24)|(_dpppDEC2BCD(PERL_VERSION)<<12)|_dpppDEC2BCD(PERL_SUBVERSION))

/* It is very unlikely that anyone will try to use this with Perl 6
   (or greater), but who knows.
 */
#if PERL_REVISION != 5
#  error ppport.h only works with Perl version 5
#endif /* PERL_REVISION != 5 */
#ifndef dTHR
#  define dTHR                           dNOOP
#endif
#ifndef dTHX
#  define dTHX                           dNOOP
#endif

#ifndef dTHXa
#  define dTHXa(x)                       dNOOP
#endif
#ifndef pTHX
#  define pTHX                           void
#endif

#ifndef pTHX_
#  define pTHX_
#endif

#ifndef aTHX
#  define aTHX
#endif

#ifndef aTHX_
#  define aTHX_
#endif

#if (PERL_BCDVERSION < 0x5006000)
#  ifdef USE_THREADS
#    define aTHXR  thr
#    define aTHXR_ thr,
#  else
#    define aTHXR
#    define aTHXR_
#  endif
#  define dTHXR  dTHR
#else
#  define aTHXR  aTHX
#  define aTHXR_ aTHX_
#  define dTHXR  dTHX
#endif
#ifndef dTHXoa
#  define dTHXoa(x)                      dTHXa(x)
#endif

#ifdef I_LIMITS
#  include <limits.h>
#endif

#ifndef PERL_UCHAR_MIN
#  define PERL_UCHAR_MIN ((unsigned char)0)
#endif

#ifndef PERL_UCHAR_MAX
#  ifdef UCHAR_MAX
#    define PERL_UCHAR_MAX ((unsigned char)UCHAR_MAX)
#  else
#    ifdef MAXUCHAR
#      define PERL_UCHAR_MAX ((unsigned char)MAXUCHAR)
#    else
#      define PERL_UCHAR_MAX ((unsigned char)~(unsigned)0)
#    endif
#  endif
#endif

#ifndef PERL_USHORT_MIN
#  define PERL_USHORT_MIN ((unsigned short)0)
#endif

#ifndef PERL_USHORT_MAX
#  ifdef USHORT_MAX
#    define PERL_USHORT_MAX ((unsigned short)USHORT_MAX)
#  else
#    ifdef MAXUSHORT
#      define PERL_USHORT_MAX ((unsigned short)MAXUSHORT)
#    else
#      ifdef USHRT_MAX
#        define PERL_USHORT_MAX ((unsigned short)USHRT_MAX)
#      else
#        define PERL_USHORT_MAX ((unsigned short)~(unsigned)0)
#      endif
#    endif
#  endif
#endif

#ifndef PERL_SHORT_MAX
#  ifdef SHORT_MAX
#    define PERL_SHORT_MAX ((short)SHORT_MAX)
#  else
#    ifdef MAXSHORT    /* Often used in <values.h> */
#      define PERL_SHORT_MAX ((short)MAXSHORT)
#    else
#      ifdef SHRT_MAX
#        define PERL_SHORT_MAX ((short)SHRT_MAX)
#      else
#        define PERL_SHORT_MAX ((short) (PERL_USHORT_MAX >> 1))
#      endif
#    endif
#  endif
#endif

#ifndef PERL_SHORT_MIN
#  ifdef SHORT_MIN
#    define PERL_SHORT_MIN ((short)SHORT_MIN)
#  else
#    ifdef MINSHORT
#      define PERL_SHORT_MIN ((short)MINSHORT)
#    else
#      ifdef SHRT_MIN
#        define PERL_SHORT_MIN ((short)SHRT_MIN)
#      else
#        define PERL_SHORT_MIN (-PERL_SHORT_MAX - ((3 & -1) == 3))
#      endif
#    endif
#  endif
#endif

#ifndef PERL_UINT_MAX
#  ifdef UINT_MAX
#    define PERL_UINT_MAX ((unsigned int)UINT_MAX)
#  else
#    ifdef MAXUINT
#      define PERL_UINT_MAX ((unsigned int)MAXUINT)
#    else
#      define PERL_UINT_MAX (~(unsigned int)0)
#    endif
#  endif
#endif

#ifndef PERL_UINT_MIN
#  define PERL_UINT_MIN ((unsigned int)0)
#endif

#ifndef PERL_INT_MAX
#  ifdef INT_MAX
#    define PERL_INT_MAX ((int)INT_MAX)
#  else
#    ifdef MAXINT    /* Often used in <values.h> */
#      define PERL_INT_MAX ((int)MAXINT)
#    else
#      define PERL_INT_MAX ((int)(PERL_UINT_MAX >> 1))
#    endif
#  endif
#endif

#ifndef PERL_INT_MIN
#  ifdef INT_MIN
#    define PERL_INT_MIN ((int)INT_MIN)
#  else
#    ifdef MININT
#      define PERL_INT_MIN ((int)MININT)
#    else
#      define PERL_INT_MIN (-PERL_INT_MAX - ((3 & -1) == 3))
#    endif
#  endif
#endif

#ifndef PERL_ULONG_MAX
#  ifdef ULONG_MAX
#    define PERL_ULONG_MAX ((unsigned long)ULONG_MAX)
#  else
#    ifdef MAXULONG
#      define PERL_ULONG_MAX ((unsigned long)MAXULONG)
#    else
#      define PERL_ULONG_MAX (~(unsigned long)0)
#    endif
#  endif
#endif

#ifndef PERL_ULONG_MIN
#  define PERL_ULONG_MIN ((unsigned long)0L)
#endif

#ifndef PERL_LONG_MAX
#  ifdef LONG_MAX
#    define PERL_LONG_MAX ((long)LONG_MAX)
#  else
#    ifdef MAXLONG
#      define PERL_LONG_MAX ((long)MAXLONG)
#    else
#      define PERL_LONG_MAX ((long) (PERL_ULONG_MAX >> 1))
#    endif
#  endif
#endif

#ifndef PERL_LONG_MIN
#  ifdef LONG_MIN
#    define PERL_LONG_MIN ((long)LONG_MIN)
#  else
#    ifdef MINLONG
#      define PERL_LONG_MIN ((long)MINLONG)
#    else
#      define PERL_LONG_MIN (-PERL_LONG_MAX - ((3 & -1) == 3))
#    endif
#  endif
#endif

#if defined(HAS_QUAD) && (defined(convex) || defined(uts))
#  ifndef PERL_UQUAD_MAX
#    ifdef ULONGLONG_MAX
#      define PERL_UQUAD_MAX ((unsigned long long)ULONGLONG_MAX)
#    else
#      ifdef MAXULONGLONG
#        define PERL_UQUAD_MAX ((unsigned long long)MAXULONGLONG)
#      else
#        define PERL_UQUAD_MAX (~(unsigned long long)0)
#      endif
#    endif
#  endif

#  ifndef PERL_UQUAD_MIN
#    define PERL_UQUAD_MIN ((unsigned long long)0L)
#  endif

#  ifndef PERL_QUAD_MAX
#    ifdef LONGLONG_MAX
#      define PERL_QUAD_MAX ((long long)LONGLONG_MAX)
#    else
#      ifdef MAXLONGLONG
#        define PERL_QUAD_MAX ((long long)MAXLONGLONG)
#      else
#        define PERL_QUAD_MAX ((long long) (PERL_UQUAD_MAX >> 1))
#      endif
#    endif
#  endif

#  ifndef PERL_QUAD_MIN
#    ifdef LONGLONG_MIN
#      define PERL_QUAD_MIN ((long long)LONGLONG_MIN)
#    else
#      ifdef MINLONGLONG
#        define PERL_QUAD_MIN ((long long)MINLONGLONG)
#      else
#        define PERL_QUAD_MIN (-PERL_QUAD_MAX - ((3 & -1) == 3))
#      endif
#    endif
#  endif
#endif

/* This is based on code from 5.003 perl.h */
#ifdef HAS_QUAD
#  ifdef cray
#ifndef IVTYPE
#  define IVTYPE                         int
#endif

#ifndef IV_MIN
#  define IV_MIN                         PERL_INT_MIN
#endif

#ifndef IV_MAX
#  define IV_MAX                         PERL_INT_MAX
#endif

#ifndef UV_MIN
#  define UV_MIN                         PERL_UINT_MIN
#endif

#ifndef UV_MAX
#  define UV_MAX                         PERL_UINT_MAX
#endif

#    ifdef INTSIZE
#ifndef IVSIZE
#  define IVSIZE                         INTSIZE
#endif

#    endif
#  else
#    if defined(convex) || defined(uts)
#ifndef IVTYPE
#  define IVTYPE                         long long
#endif

#ifndef IV_MIN
#  define IV_MIN                         PERL_QUAD_MIN
#endif

#ifndef IV_MAX
#  define IV_MAX                         PERL_QUAD_MAX
#endif

#ifndef UV_MIN
#  define UV_MIN                         PERL_UQUAD_MIN
#endif

#ifndef UV_MAX
#  define UV_MAX                         PERL_UQUAD_MAX
#endif

#      ifdef LONGLONGSIZE
#ifndef IVSIZE
#  define IVSIZE                         LONGLONGSIZE
#endif

#      endif
#    else
#ifndef IVTYPE
#  define IVTYPE                         long
#endif

#ifndef IV_MIN
#  define IV_MIN                         PERL_LONG_MIN
#endif

#ifndef IV_MAX
#  define IV_MAX                         PERL_LONG_MAX
#endif

#ifndef UV_MIN
#  define UV_MIN                         PERL_ULONG_MIN
#endif

#ifndef UV_MAX
#  define UV_MAX                         PERL_ULONG_MAX
#endif

#      ifdef LONGSIZE
#ifndef IVSIZE
#  define IVSIZE                         LONGSIZE
#endif

#      endif
#    endif
#  endif
#ifndef IVSIZE
#  define IVSIZE                         8
#endif

#ifndef LONGSIZE
#  define LONGSIZE                       8
#endif

#ifndef PERL_QUAD_MIN
#  define PERL_QUAD_MIN                  IV_MIN
#endif

#ifndef PERL_QUAD_MAX
#  define PERL_QUAD_MAX                  IV_MAX
#endif

#ifndef PERL_UQUAD_MIN
#  define PERL_UQUAD_MIN                 UV_MIN
#endif

#ifndef PERL_UQUAD_MAX
#  define PERL_UQUAD_MAX                 UV_MAX
#endif

#else
#ifndef IVTYPE
#  define IVTYPE                         long
#endif

#ifndef LONGSIZE
#  define LONGSIZE                       4
#endif

#ifndef IV_MIN
#  define IV_MIN                         PERL_LONG_MIN
#endif

#ifndef IV_MAX
#  define IV_MAX                         PERL_LONG_MAX
#endif

#ifndef UV_MIN
#  define UV_MIN                         PERL_ULONG_MIN
#endif

#ifndef UV_MAX
#  define UV_MAX                         PERL_ULONG_MAX
#endif

#endif

#ifndef IVSIZE
#  ifdef LONGSIZE
#    define IVSIZE LONGSIZE
#  else
#    define IVSIZE 4 /* A bold guess, but the best we can make. */
#  endif
#endif
#ifndef UVTYPE
#  define UVTYPE                         unsigned IVTYPE
#endif

#ifndef UVSIZE
#  define UVSIZE                         IVSIZE
#endif
#ifndef sv_setuv
#  define sv_setuv(sv, uv)               \
               STMT_START {                         \
                 UV TeMpUv = uv;                    \
                 if (TeMpUv <= IV_MAX)              \
                   sv_setiv(sv, TeMpUv);            \
                 else                               \
                   sv_setnv(sv, (double)TeMpUv);    \
               } STMT_END
#endif
#ifndef newSVuv
#  define newSVuv(uv)                    ((uv) <= IV_MAX ? newSViv((IV)uv) : newSVnv((NV)uv))
#endif
#ifndef sv_2uv
#  define sv_2uv(sv)                     ((PL_Sv = (sv)), (UV) (SvNOK(PL_Sv) ? SvNV(PL_Sv) : sv_2nv(PL_Sv)))
#endif

#ifndef SvUVX
#  define SvUVX(sv)                      ((UV)SvIVX(sv))
#endif

#ifndef SvUVXx
#  define SvUVXx(sv)                     SvUVX(sv)
#endif

#ifndef SvUV
#  define SvUV(sv)                       (SvIOK(sv) ? SvUVX(sv) : sv_2uv(sv))
#endif

#ifndef SvUVx
#  define SvUVx(sv)                      ((PL_Sv = (sv)), SvUV(PL_Sv))
#endif

/* Hint: sv_uv
 * Always use the SvUVx() macro instead of sv_uv().
 */
#ifndef sv_uv
#  define sv_uv(sv)                      SvUVx(sv)
#endif

#if !defined(SvUOK) && defined(SvIOK_UV)
#  define SvUOK(sv) SvIOK_UV(sv)
#endif
#ifndef XST_mUV
#  define XST_mUV(i,v)                   (ST(i) = sv_2mortal(newSVuv(v))  )
#endif

#ifndef XSRETURN_UV
#  define XSRETURN_UV(v)                 STMT_START { XST_mUV(0,v);  XSRETURN(1); } STMT_END
#endif
#ifndef PUSHu
#  define PUSHu(u)                       STMT_START { sv_setuv(TARG, (UV)(u)); PUSHTARG;  } STMT_END
#endif

#ifndef XPUSHu
#  define XPUSHu(u)                      STMT_START { sv_setuv(TARG, (UV)(u)); XPUSHTARG; } STMT_END
#endif

#ifdef HAS_MEMCMP
#ifndef memNE
#  define memNE(s1,s2,l)                 (memcmp(s1,s2,l))
#endif

#ifndef memEQ
#  define memEQ(s1,s2,l)                 (!memcmp(s1,s2,l))
#endif

#else
#ifndef memNE
#  define memNE(s1,s2,l)                 (bcmp(s1,s2,l))
#endif

#ifndef memEQ
#  define memEQ(s1,s2,l)                 (!bcmp(s1,s2,l))
#endif

#endif
#ifndef memEQs
#  define memEQs(s1, l, s2)              \
                   (sizeof(s2)-1 == l && memEQ(s1, (s2 ""), (sizeof(s2)-1)))
#endif

#ifndef memNEs
#  define memNEs(s1, l, s2)              !memEQs(s1, l, s2)
#endif
#ifndef MoveD
#  define MoveD(s,d,n,t)                 memmove((char*)(d),(char*)(s), (n) * sizeof(t))
#endif

#ifndef CopyD
#  define CopyD(s,d,n,t)                 memcpy((char*)(d),(char*)(s), (n) * sizeof(t))
#endif

#ifdef HAS_MEMSET
#ifndef ZeroD
#  define ZeroD(d,n,t)                   memzero((char*)(d), (n) * sizeof(t))
#endif

#else
#ifndef ZeroD
#  define ZeroD(d,n,t)                   ((void)memzero((char*)(d), (n) * sizeof(t)), d)
#endif

#endif
#ifndef PoisonWith
#  define PoisonWith(d,n,t,b)            (void)memset((char*)(d), (U8)(b), (n) * sizeof(t))
#endif

#ifndef PoisonNew
#  define PoisonNew(d,n,t)               PoisonWith(d,n,t,0xAB)
#endif

#ifndef PoisonFree
#  define PoisonFree(d,n,t)              PoisonWith(d,n,t,0xEF)
#endif

#ifndef Poison
#  define Poison(d,n,t)                  PoisonFree(d,n,t)
#endif
#ifndef Newx
#  define Newx(v,n,t)                    New(0,v,n,t)
#endif

#ifndef Newxc
#  define Newxc(v,n,t,c)                 Newc(0,v,n,t,c)
#endif

#ifndef Newxz
#  define Newxz(v,n,t)                   Newz(0,v,n,t)
#endif

#ifndef PERL_UNUSED_DECL
#  ifdef HASATTRIBUTE
#    if (defined(__GNUC__) && defined(__cplusplus)) || defined(__INTEL_COMPILER)
#      define PERL_UNUSED_DECL
#    else
#      define PERL_UNUSED_DECL __attribute__((unused))
#    endif
#  else
#    define PERL_UNUSED_DECL
#  endif
#endif

#ifndef PERL_UNUSED_ARG
#  if defined(lint) && defined(S_SPLINT_S) /* www.splint.org */
#    include <note.h>
#    define PERL_UNUSED_ARG(x) NOTE(ARGUNUSED(x))
#  else
#    define PERL_UNUSED_ARG(x) ((void)x)
#  endif
#endif

#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(x) ((void)x)
#endif

#ifndef PERL_UNUSED_CONTEXT
#  ifdef USE_ITHREADS
#    define PERL_UNUSED_CONTEXT PERL_UNUSED_ARG(my_perl)
#  else
#    define PERL_UNUSED_CONTEXT
#  endif
#endif
#ifndef NOOP
#  define NOOP                           /*EMPTY*/(void)0
#endif

#ifndef dNOOP
#  define dNOOP                          extern int /*@unused@*/ Perl___notused PERL_UNUSED_DECL
#endif

#ifndef NVTYPE
#  if defined(USE_LONG_DOUBLE) && defined(HAS_LONG_DOUBLE)
#    define NVTYPE long double
#  else
#    define NVTYPE double
#  endif
typedef NVTYPE NV;
#endif

#ifndef INT2PTR
#  if (IVSIZE == PTRSIZE) && (UVSIZE == PTRSIZE)
#    define PTRV                  UV
#    define INT2PTR(any,d)        (any)(d)
#  else
#    if PTRSIZE == LONGSIZE
#      define PTRV                unsigned long
#    else
#      define PTRV                unsigned
#    endif
#    define INT2PTR(any,d)        (any)(PTRV)(d)
#  endif
#endif

#ifndef PTR2ul
#  if PTRSIZE == LONGSIZE
#    define PTR2ul(p)     (unsigned long)(p)
#  else
#    define PTR2ul(p)     INT2PTR(unsigned long,p)
#  endif
#endif
#ifndef PTR2nat
#  define PTR2nat(p)                     (PTRV)(p)
#endif

#ifndef NUM2PTR
#  define NUM2PTR(any,d)                 (any)PTR2nat(d)
#endif

#ifndef PTR2IV
#  define PTR2IV(p)                      INT2PTR(IV,p)
#endif

#ifndef PTR2UV
#  define PTR2UV(p)                      INT2PTR(UV,p)
#endif

#ifndef PTR2NV
#  define PTR2NV(p)                      NUM2PTR(NV,p)
#endif

#undef START_EXTERN_C
#undef END_EXTERN_C
#undef EXTERN_C
#ifdef __cplusplus
#  define START_EXTERN_C extern "C" {
#  define END_EXTERN_C }
#  define EXTERN_C extern "C"
#else
#  define START_EXTERN_C
#  define END_EXTERN_C
#  define EXTERN_C extern
#endif

#if defined(PERL_GCC_PEDANTIC)
#  ifndef PERL_GCC_BRACE_GROUPS_FORBIDDEN
#    define PERL_GCC_BRACE_GROUPS_FORBIDDEN
#  endif
#endif

#if defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN) && !defined(__cplusplus)
#  ifndef PERL_USE_GCC_BRACE_GROUPS
#    define PERL_USE_GCC_BRACE_GROUPS
#  endif
#endif

#undef STMT_START
#undef STMT_END
#ifdef PERL_USE_GCC_BRACE_GROUPS
#  define STMT_START    (void)( /* gcc supports ``({ STATEMENTS; })'' */
#  define STMT_END      )
#else
#  if defined(VOIDFLAGS) && (VOIDFLAGS) && (defined(sun) || defined(__sun__)) && !defined(__GNUC__)
#    define STMT_START  if (1)
#    define STMT_END    else (void)0
#  else
#    define STMT_START  do
#    define STMT_END    while (0)
#  endif
#endif
#ifndef boolSV
#  define boolSV(b)                      ((b) ? &PL_sv_yes : &PL_sv_no)
#endif

/* DEFSV appears first in 5.004_56 */
#ifndef DEFSV
#  define DEFSV                          GvSV(PL_defgv)
#endif

#ifndef SAVE_DEFSV
#  define SAVE_DEFSV                     SAVESPTR(GvSV(PL_defgv))
#endif

#ifndef DEFSV_set
#  define DEFSV_set(sv)                  (DEFSV = (sv))
#endif

/* Older perls (<=5.003) lack AvFILLp */
#ifndef AvFILLp
#  define AvFILLp                        AvFILL
#endif
#ifndef ERRSV
#  define ERRSV                          get_sv("@",FALSE)
#endif

/* Hint: gv_stashpvn
 * This function's backport doesn't support the length parameter, but
 * rather ignores it. Portability can only be ensured if the length
 * parameter is used for speed reasons, but the length can always be
 * correctly computed from the string argument.
 */
#ifndef gv_stashpvn
#  define gv_stashpvn(str,len,create)    gv_stashpv(str,create)
#endif

/* Replace: 1 */
#ifndef get_cv
#  define get_cv                         perl_get_cv
#endif

#ifndef get_sv
#  define get_sv                         perl_get_sv
#endif

#ifndef get_av
#  define get_av                         perl_get_av
#endif

#ifndef get_hv
#  define get_hv                         perl_get_hv
#endif

/* Replace: 0 */
#ifndef dUNDERBAR
#  define dUNDERBAR                      dNOOP
#endif

#ifndef UNDERBAR
#  define UNDERBAR                       DEFSV
#endif
#ifndef dAX
#  define dAX                            I32 ax = MARK - PL_stack_base + 1
#endif

#ifndef dITEMS
#  define dITEMS                         I32 items = SP - MARK
#endif
#ifndef dXSTARG
#  define dXSTARG                        SV * targ = sv_newmortal()
#endif
#ifndef dAXMARK
#  define dAXMARK                        I32 ax = POPMARK; \
                               register SV ** const mark = PL_stack_base + ax++
#endif
#ifndef XSprePUSH
#  define XSprePUSH                      (sp = PL_stack_base + ax - 1)
#endif

#if (PERL_BCDVERSION < 0x5005000)
#  undef XSRETURN
#  define XSRETURN(off)                                   \
      STMT_START {                                        \
          PL_stack_sp = PL_stack_base + ax + ((off) - 1); \
          return;                                         \
      } STMT_END
#endif
#ifndef XSPROTO
#  define XSPROTO(name)                  void name(pTHX_ CV* cv)
#endif

#ifndef SVfARG
#  define SVfARG(p)                      ((void*)(p))
#endif
#ifndef PERL_ABS
#  define PERL_ABS(x)                    ((x) < 0 ? -(x) : (x))
#endif
#ifndef dVAR
#  define dVAR                           dNOOP
#endif
#ifndef SVf
#  define SVf                            "_"
#endif
#ifndef UTF8_MAXBYTES
#  define UTF8_MAXBYTES                  UTF8_MAXLEN
#endif
#ifndef CPERLscope
#  define CPERLscope(x)                  x
#endif
#ifndef PERL_HASH
#  define PERL_HASH(hash,str,len)        \
     STMT_START { \
        const char *s_PeRlHaSh = str; \
        I32 i_PeRlHaSh = len; \
        U32 hash_PeRlHaSh = 0; \
        while (i_PeRlHaSh--) \
            hash_PeRlHaSh = hash_PeRlHaSh * 33 + *s_PeRlHaSh++; \
        (hash) = hash_PeRlHaSh; \
    } STMT_END
#endif

#ifndef PERLIO_FUNCS_DECL
# ifdef PERLIO_FUNCS_CONST
#  define PERLIO_FUNCS_DECL(funcs) const PerlIO_funcs funcs
#  define PERLIO_FUNCS_CAST(funcs) (PerlIO_funcs*)(funcs)
# else
#  define PERLIO_FUNCS_DECL(funcs) PerlIO_funcs funcs
#  define PERLIO_FUNCS_CAST(funcs) (funcs)
# endif
#endif

/* provide these typedefs for older perls */
#if (PERL_BCDVERSION < 0x5009003)

# ifdef ARGSproto
typedef OP* (CPERLscope(*Perl_ppaddr_t))(ARGSproto);
# else
typedef OP* (CPERLscope(*Perl_ppaddr_t))(pTHX);
# endif

typedef OP* (CPERLscope(*Perl_check_t)) (pTHX_ OP*);

#endif
#ifndef isPSXSPC
#  define isPSXSPC(c)                    (isSPACE(c) || (c) == '\v')
#endif

#ifndef isBLANK
#  define isBLANK(c)                     ((c) == ' ' || (c) == '\t')
#endif

#ifdef EBCDIC
#ifndef isALNUMC
#  define isALNUMC(c)                    isalnum(c)
#endif

#ifndef isASCII
#  define isASCII(c)                     isascii(c)
#endif

#ifndef isCNTRL
#  define isCNTRL(c)                     iscntrl(c)
#endif

#ifndef isGRAPH
#  define isGRAPH(c)                     isgraph(c)
#endif

#ifndef isPRINT
#  define isPRINT(c)                     isprint(c)
#endif

#ifndef isPUNCT
#  define isPUNCT(c)                     ispunct(c)
#endif

#ifndef isXDIGIT
#  define isXDIGIT(c)                    isxdigit(c)
#endif

#else
# if (PERL_BCDVERSION < 0x5010000)
/* Hint: isPRINT
 * The implementation in older perl versions includes all of the
 * isSPACE() characters, which is wrong. The version provided by
 * Devel::PPPort always overrides a present buggy version.
 */
#  undef isPRINT
# endif

#ifdef HAS_QUAD
# ifdef U64TYPE
#  define WIDEST_UTYPE U64TYPE
# else
#  define WIDEST_UTYPE Quad_t
# endif
#else
# define WIDEST_UTYPE U32
#endif
#ifndef isALNUMC
#  define isALNUMC(c)                    (isALPHA(c) || isDIGIT(c))
#endif

#ifndef isASCII
#  define isASCII(c)                     ((WIDEST_UTYPE) (c) <= 127)
#endif

#ifndef isCNTRL
#  define isCNTRL(c)                     ((WIDEST_UTYPE) (c) < ' ' || (c) == 127)
#endif

#ifndef isGRAPH
#  define isGRAPH(c)                     (isALNUM(c) || isPUNCT(c))
#endif

#ifndef isPRINT
#  define isPRINT(c)                     (((c) >= 32 && (c) < 127))
#endif

#ifndef isPUNCT
#  define isPUNCT(c)                     (((c) >= 33 && (c) <= 47) || ((c) >= 58 && (c) <= 64)  || ((c) >= 91 && (c) <= 96) || ((c) >= 123 && (c) <= 126))
#endif

#ifndef isXDIGIT
#  define isXDIGIT(c)                    (isDIGIT(c) || ((c) >= 'a' && (c) <= 'f') || ((c) >= 'A' && (c) <= 'F'))
#endif

#endif

/* Until we figure out how to support this in older perls... */
#if (PERL_BCDVERSION >= 0x5008000)
#ifndef HeUTF8
#  define HeUTF8(he)                     ((HeKLEN(he) == HEf_SVKEY) ?            \
                                 SvUTF8(HeKEY_sv(he)) :                 \
                                 (U32)HeKUTF8(he))
#endif

#endif

#ifndef PERL_SIGNALS_UNSAFE_FLAG

#define PERL_SIGNALS_UNSAFE_FLAG 0x0001

#if (PERL_BCDVERSION < 0x5008000)
#  define D_PPP_PERL_SIGNALS_INIT   PERL_SIGNALS_UNSAFE_FLAG
#else
#  define D_PPP_PERL_SIGNALS_INIT   0
#endif

#if defined(NEED_PL_signals)
static U32 DPPP_(my_PL_signals) = D_PPP_PERL_SIGNALS_INIT;
#elif defined(NEED_PL_signals_GLOBAL)
U32 DPPP_(my_PL_signals) = D_PPP_PERL_SIGNALS_INIT;
#else
extern U32 DPPP_(my_PL_signals);
#endif
#define PL_signals DPPP_(my_PL_signals)

#endif

/* Hint: PL_ppaddr
 * Calling an op via PL_ppaddr requires passing a context argument
 * for threaded builds. Since the context argument is different for
 * 5.005 perls, you can use aTHXR (supplied by ppport.h), which will
 * automatically be defined as the correct argument.
 */

#if (PERL_BCDVERSION <= 0x5005005)
/* Replace: 1 */
#  define PL_ppaddr                 ppaddr
#  define PL_no_modify              no_modify
/* Replace: 0 */
#endif

#if (PERL_BCDVERSION <= 0x5004005)
/* Replace: 1 */
#  define PL_DBsignal               DBsignal
#  define PL_DBsingle               DBsingle
#  define PL_DBsub                  DBsub
#  define PL_DBtrace                DBtrace
#  define PL_Sv                     Sv
#  define PL_bufend                 bufend
#  define PL_bufptr                 bufptr
#  define PL_compiling              compiling
#  define PL_copline                copline
#  define PL_curcop                 curcop
#  define PL_curstash               curstash
#  define PL_debstash               debstash
#  define PL_defgv                  defgv
#  define PL_diehook                diehook
#  define PL_dirty                  dirty
#  define PL_dowarn                 dowarn
#  define PL_errgv                  errgv
#  define PL_error_count            error_count
#  define PL_expect                 expect
#  define PL_hexdigit               hexdigit
#  define PL_hints                  hints
#  define PL_in_my                  in_my
#  define PL_laststatval            laststatval
#  define PL_lex_state              lex_state
#  define PL_lex_stuff              lex_stuff
#  define PL_linestr                linestr
#  define PL_na                     na
#  define PL_perl_destruct_level    perl_destruct_level
#  define PL_perldb                 perldb
#  define PL_rsfp_filters           rsfp_filters
#  define PL_rsfp                   rsfp
#  define PL_stack_base             stack_base
#  define PL_stack_sp               stack_sp
#  define PL_statcache              statcache
#  define PL_stdingv                stdingv
#  define PL_sv_arenaroot           sv_arenaroot
#  define PL_sv_no                  sv_no
#  define PL_sv_undef               sv_undef
#  define PL_sv_yes                 sv_yes
#  define PL_tainted                tainted
#  define PL_tainting               tainting
#  define PL_tokenbuf               tokenbuf
/* Replace: 0 */
#endif

/* Warning: PL_parser
 * For perl versions earlier than 5.9.5, this is an always
 * non-NULL dummy. Also, it cannot be dereferenced. Don't
 * use it if you can avoid is and unless you absolutely know
 * what you're doing.
 * If you always check that PL_parser is non-NULL, you can
 * define DPPP_PL_parser_NO_DUMMY to avoid the creation of
 * a dummy parser structure.
 */

#if (PERL_BCDVERSION >= 0x5009005)
# ifdef DPPP_PL_parser_NO_DUMMY
#  define D_PPP_my_PL_parser_var(var) ((PL_parser ? PL_parser : \
                (croak("panic: PL_parser == NULL in %s:%d", \
                       __FILE__, __LINE__), (yy_parser *) NULL))->var)
# else
#  ifdef DPPP_PL_parser_NO_DUMMY_WARNING
#   define D_PPP_parser_dummy_warning(var)
#  else
#   define D_PPP_parser_dummy_warning(var) \
             warn("warning: dummy PL_" #var " used in %s:%d", __FILE__, __LINE__),
#  endif
#  define D_PPP_my_PL_parser_var(var) ((PL_parser ? PL_parser : \
                (D_PPP_parser_dummy_warning(var) &DPPP_(dummy_PL_parser)))->var)
#if defined(NEED_PL_parser)
static yy_parser DPPP_(dummy_PL_parser);
#elif defined(NEED_PL_parser_GLOBAL)
yy_parser DPPP_(dummy_PL_parser);
#else
extern yy_parser DPPP_(dummy_PL_parser);
#endif

# endif

/* PL_expect, PL_copline, PL_rsfp, PL_rsfp_filters, PL_linestr, PL_bufptr, PL_bufend, PL_lex_state, PL_lex_stuff, PL_tokenbuf depends on PL_parser */
/* Warning: PL_expect, PL_copline, PL_rsfp, PL_rsfp_filters, PL_linestr, PL_bufptr, PL_bufend, PL_lex_state, PL_lex_stuff, PL_tokenbuf
 * Do not use this variable unless you know exactly what you're
 * doint. It is internal to the perl parser and may change or even
 * be removed in the future. As of perl 5.9.5, you have to check
 * for (PL_parser != NULL) for this variable to have any effect.
 * An always non-NULL PL_parser dummy is provided for earlier
 * perl versions.
 * If PL_parser is NULL when you try to access this variable, a
 * dummy is being accessed instead and a warning is issued unless
 * you define DPPP_PL_parser_NO_DUMMY_WARNING.
 * If DPPP_PL_parser_NO_DUMMY is defined, the code trying to access
 * this variable will croak with a panic message.
 */

# define PL_expect         D_PPP_my_PL_parser_var(expect)
# define PL_copline        D_PPP_my_PL_parser_var(copline)
# define PL_rsfp           D_PPP_my_PL_parser_var(rsfp)
# define PL_rsfp_filters   D_PPP_my_PL_parser_var(rsfp_filters)
# define PL_linestr        D_PPP_my_PL_parser_var(linestr)
# define PL_bufptr         D_PPP_my_PL_parser_var(bufptr)
# define PL_bufend         D_PPP_my_PL_parser_var(bufend)
# define PL_lex_state      D_PPP_my_PL_parser_var(lex_state)
# define PL_lex_stuff      D_PPP_my_PL_parser_var(lex_stuff)
# define PL_tokenbuf       D_PPP_my_PL_parser_var(tokenbuf)
# define PL_in_my          D_PPP_my_PL_parser_var(in_my)
# define PL_in_my_stash    D_PPP_my_PL_parser_var(in_my_stash)
# define PL_error_count    D_PPP_my_PL_parser_var(error_count)


#else

/* ensure that PL_parser != NULL and cannot be dereferenced */
# define PL_parser         ((void *) 1)

#endif
#ifndef mPUSHs
#  define mPUSHs(s)                      PUSHs(sv_2mortal(s))
#endif

#ifndef PUSHmortal
#  define PUSHmortal                     PUSHs(sv_newmortal())
#endif

#ifndef mPUSHp
#  define mPUSHp(p,l)                    sv_setpvn(PUSHmortal, (p), (l))
#endif

#ifndef mPUSHn
#  define mPUSHn(n)                      sv_setnv(PUSHmortal, (NV)(n))
#endif

#ifndef mPUSHi
#  define mPUSHi(i)                      sv_setiv(PUSHmortal, (IV)(i))
#endif

#ifndef mPUSHu
#  define mPUSHu(u)                      sv_setuv(PUSHmortal, (UV)(u))
#endif
#ifndef mXPUSHs
#  define mXPUSHs(s)                     XPUSHs(sv_2mortal(s))
#endif

#ifndef XPUSHmortal
#  define XPUSHmortal                    XPUSHs(sv_newmortal())
#endif

#ifndef mXPUSHp
#  define mXPUSHp(p,l)                   STMT_START { EXTEND(sp,1); sv_setpvn(PUSHmortal, (p), (l)); } STMT_END
#endif

#ifndef mXPUSHn
#  define mXPUSHn(n)                     STMT_START { EXTEND(sp,1); sv_setnv(PUSHmortal, (NV)(n)); } STMT_END
#endif

#ifndef mXPUSHi
#  define mXPUSHi(i)                     STMT_START { EXTEND(sp,1); sv_setiv(PUSHmortal, (IV)(i)); } STMT_END
#endif

#ifndef mXPUSHu
#  define mXPUSHu(u)                     STMT_START { EXTEND(sp,1); sv_setuv(PUSHmortal, (UV)(u)); } STMT_END
#endif

/* Replace: 1 */
#ifndef call_sv
#  define call_sv                        perl_call_sv
#endif

#ifndef call_pv
#  define call_pv                        perl_call_pv
#endif

#ifndef call_argv
#  define call_argv                      perl_call_argv
#endif

#ifndef call_method
#  define call_method                    perl_call_method
#endif
#ifndef eval_sv
#  define eval_sv                        perl_eval_sv
#endif

/* Replace: 0 */
#ifndef PERL_LOADMOD_DENY
#  define PERL_LOADMOD_DENY              0x1
#endif

#ifndef PERL_LOADMOD_NOIMPORT
#  define PERL_LOADMOD_NOIMPORT          0x2
#endif

#ifndef PERL_LOADMOD_IMPORT_OPS
#  define PERL_LOADMOD_IMPORT_OPS        0x4
#endif

#ifndef G_METHOD
# define G_METHOD               64
# ifdef call_sv
#  undef call_sv
# endif
# if (PERL_BCDVERSION < 0x5006000)
#  define call_sv(sv, flags)  ((flags) & G_METHOD ? perl_call_method((char *) SvPV_nolen_const(sv), \
                                (flags) & ~G_METHOD) : perl_call_sv(sv, flags))
# else
#  define call_sv(sv, flags)  ((flags) & G_METHOD ? Perl_call_method(aTHX_ (char *) SvPV_nolen_const(sv), \
                                (flags) & ~G_METHOD) : Perl_call_sv(aTHX_ sv, flags))
# endif
#endif

/* Replace perl_eval_pv with eval_pv */

#ifndef eval_pv
#if defined(NEED_eval_pv)
static SV* DPPP_(my_eval_pv)(char *p, I32 croak_on_error);
static
#else
extern SV* DPPP_(my_eval_pv)(char *p, I32 croak_on_error);
#endif

#ifdef eval_pv
#  undef eval_pv
#endif
#define eval_pv(a,b) DPPP_(my_eval_pv)(aTHX_ a,b)
#define Perl_eval_pv DPPP_(my_eval_pv)

#if defined(NEED_eval_pv) || defined(NEED_eval_pv_GLOBAL)

SV*
DPPP_(my_eval_pv)(char *p, I32 croak_on_error)
{
    dSP;
    SV* sv = newSVpv(p, 0);

    PUSHMARK(sp);
    eval_sv(sv, G_SCALAR);
    SvREFCNT_dec(sv);

    SPAGAIN;
    sv = POPs;
    PUTBACK;

    if (croak_on_error && SvTRUE(GvSV(errgv)))
        croak(SvPVx(GvSV(errgv), na));

    return sv;
}

#endif
#endif

#ifndef vload_module
#if defined(NEED_vload_module)
static void DPPP_(my_vload_module)(U32 flags, SV *name, SV *ver, va_list *args);
static
#else
extern void DPPP_(my_vload_module)(U32 flags, SV *name, SV *ver, va_list *args);
#endif

#ifdef vload_module
#  undef vload_module
#endif
#define vload_module(a,b,c,d) DPPP_(my_vload_module)(aTHX_ a,b,c,d)
#define Perl_vload_module DPPP_(my_vload_module)

#if defined(NEED_vload_module) || defined(NEED_vload_module_GLOBAL)

void
DPPP_(my_vload_module)(U32 flags, SV *name, SV *ver, va_list *args)
{
    dTHR;
    dVAR;
    OP *veop, *imop;

    OP * const modname = newSVOP(OP_CONST, 0, name);
    /* 5.005 has a somewhat hacky force_normal that doesn't croak on
       SvREADONLY() if PL_compling is true. Current perls take care in
       ck_require() to correctly turn off SvREADONLY before calling
       force_normal_flags(). This seems a better fix than fudging PL_compling
     */
    SvREADONLY_off(((SVOP*)modname)->op_sv);
    modname->op_private |= OPpCONST_BARE;
    if (ver) {
        veop = newSVOP(OP_CONST, 0, ver);
    }
    else
        veop = NULL;
    if (flags & PERL_LOADMOD_NOIMPORT) {
        imop = sawparens(newNULLLIST());
    }
    else if (flags & PERL_LOADMOD_IMPORT_OPS) {
        imop = va_arg(*args, OP*);
    }
    else {
        SV *sv;
        imop = NULL;
        sv = va_arg(*args, SV*);
        while (sv) {
            imop = append_elem(OP_LIST, imop, newSVOP(OP_CONST, 0, sv));
            sv = va_arg(*args, SV*);
        }
    }
    {
        const line_t ocopline = PL_copline;
        COP * const ocurcop = PL_curcop;
        const int oexpect = PL_expect;

#if (PERL_BCDVERSION >= 0x5004000)
        utilize(!(flags & PERL_LOADMOD_DENY), start_subparse(FALSE, 0),
                veop, modname, imop);
#elif (PERL_BCDVERSION > 0x5003000)
        utilize(!(flags & PERL_LOADMOD_DENY), start_subparse(),
                veop, modname, imop);
#else
        utilize(!(flags & PERL_LOADMOD_DENY), start_subparse(),
                modname, imop);
#endif
        PL_expect = oexpect;
        PL_copline = ocopline;
        PL_curcop = ocurcop;
    }
}

#endif
#endif

#ifndef load_module
#if defined(NEED_load_module)
static void DPPP_(my_load_module)(U32 flags, SV *name, SV *ver, ...);
static
#else
extern void DPPP_(my_load_module)(U32 flags, SV *name, SV *ver, ...);
#endif

#ifdef load_module
#  undef load_module
#endif
#define load_module DPPP_(my_load_module)
#define Perl_load_module DPPP_(my_load_module)

#if defined(NEED_load_module) || defined(NEED_load_module_GLOBAL)

void
DPPP_(my_load_module)(U32 flags, SV *name, SV *ver, ...)
{
    va_list args;
    va_start(args, ver);
    vload_module(flags, name, ver, &args);
    va_end(args);
}

#endif
#endif
#ifndef newRV_inc
#  define newRV_inc(sv)                  newRV(sv)   /* Replace */
#endif

#ifndef newRV_noinc
#if defined(NEED_newRV_noinc)
static SV * DPPP_(my_newRV_noinc)(SV *sv);
static
#else
extern SV * DPPP_(my_newRV_noinc)(SV *sv);
#endif

#ifdef newRV_noinc
#  undef newRV_noinc
#endif
#define newRV_noinc(a) DPPP_(my_newRV_noinc)(aTHX_ a)
#define Perl_newRV_noinc DPPP_(my_newRV_noinc)

#if defined(NEED_newRV_noinc) || defined(NEED_newRV_noinc_GLOBAL)
SV *
DPPP_(my_newRV_noinc)(SV *sv)
{
  SV *rv = (SV *)newRV(sv);
  SvREFCNT_dec(sv);
  return rv;
}
#endif
#endif

/* Hint: newCONSTSUB
 * Returns a CV* as of perl-5.7.1. This return value is not supported
 * by Devel::PPPort.
 */

/* newCONSTSUB from IO.xs is in the core starting with 5.004_63 */
#if (PERL_BCDVERSION < 0x5004063) && (PERL_BCDVERSION != 0x5004005)
#if defined(NEED_newCONSTSUB)
static void DPPP_(my_newCONSTSUB)(HV *stash, const char *name, SV *sv);
static
#else
extern void DPPP_(my_newCONSTSUB)(HV *stash, const char *name, SV *sv);
#endif

#ifdef newCONSTSUB
#  undef newCONSTSUB
#endif
#define newCONSTSUB(a,b,c) DPPP_(my_newCONSTSUB)(aTHX_ a,b,c)
#define Perl_newCONSTSUB DPPP_(my_newCONSTSUB)

#if defined(NEED_newCONSTSUB) || defined(NEED_newCONSTSUB_GLOBAL)

/* This is just a trick to avoid a dependency of newCONSTSUB on PL_parser */
/* (There's no PL_parser in perl < 5.005, so this is completely safe)     */
#define D_PPP_PL_copline PL_copline

void
DPPP_(my_newCONSTSUB)(HV *stash, const char *name, SV *sv)
{
        U32 oldhints = PL_hints;
        HV *old_cop_stash = PL_curcop->cop_stash;
        HV *old_curstash = PL_curstash;
        line_t oldline = PL_curcop->cop_line;
        PL_curcop->cop_line = D_PPP_PL_copline;

        PL_hints &= ~HINT_BLOCK_SCOPE;
        if (stash)
                PL_curstash = PL_curcop->cop_stash = stash;

        newSUB(

#if   (PERL_BCDVERSION < 0x5003022)
                start_subparse(),
#elif (PERL_BCDVERSION == 0x5003022)
                start_subparse(0),
#else  /* 5.003_23  onwards */
                start_subparse(FALSE, 0),
#endif

                newSVOP(OP_CONST, 0, newSVpv((char *) name, 0)),
                newSVOP(OP_CONST, 0, &PL_sv_no),   /* SvPV(&PL_sv_no) == "" -- GMB */
                newSTATEOP(0, Nullch, newSVOP(OP_CONST, 0, sv))
        );

        PL_hints = oldhints;
        PL_curcop->cop_stash = old_cop_stash;
        PL_curstash = old_curstash;
        PL_curcop->cop_line = oldline;
}
#endif
#endif

/*
 * Boilerplate macros for initializing and accessing interpreter-local
 * data from C.  All statics in extensions should be reworked to use
 * this, if you want to make the extension thread-safe.  See ext/re/re.xs
 * for an example of the use of these macros.
 *
 * Code that uses these macros is responsible for the following:
 * 1. #define MY_CXT_KEY to a unique string, e.g. "DynaLoader_guts"
 * 2. Declare a typedef named my_cxt_t that is a structure that contains
 *    all the data that needs to be interpreter-local.
 * 3. Use the START_MY_CXT macro after the declaration of my_cxt_t.
 * 4. Use the MY_CXT_INIT macro such that it is called exactly once
 *    (typically put in the BOOT: section).
 * 5. Use the members of the my_cxt_t structure everywhere as
 *    MY_CXT.member.
 * 6. Use the dMY_CXT macro (a declaration) in all the functions that
 *    access MY_CXT.
 */

#if defined(MULTIPLICITY) || defined(PERL_OBJECT) || \
    defined(PERL_CAPI)    || defined(PERL_IMPLICIT_CONTEXT)

#ifndef START_MY_CXT

/* This must appear in all extensions that define a my_cxt_t structure,
 * right after the definition (i.e. at file scope).  The non-threads
 * case below uses it to declare the data as static. */
#define START_MY_CXT

#if (PERL_BCDVERSION < 0x5004068)
/* Fetches the SV that keeps the per-interpreter data. */
#define dMY_CXT_SV \
        SV *my_cxt_sv = get_sv(MY_CXT_KEY, FALSE)
#else /* >= perl5.004_68 */
#define dMY_CXT_SV \
        SV *my_cxt_sv = *hv_fetch(PL_modglobal, MY_CXT_KEY,             \
                                  sizeof(MY_CXT_KEY)-1, TRUE)
#endif /* < perl5.004_68 */

/* This declaration should be used within all functions that use the
 * interpreter-local data. */
#define dMY_CXT \
        dMY_CXT_SV;                                                     \
        my_cxt_t *my_cxtp = INT2PTR(my_cxt_t*,SvUV(my_cxt_sv))

/* Creates and zeroes the per-interpreter data.
 * (We allocate my_cxtp in a Perl SV so that it will be released when
 * the interpreter goes away.) */
#define MY_CXT_INIT \
        dMY_CXT_SV;                                                     \
        /* newSV() allocates one more than needed */                    \
        my_cxt_t *my_cxtp = (my_cxt_t*)SvPVX(newSV(sizeof(my_cxt_t)-1));\
        Zero(my_cxtp, 1, my_cxt_t);                                     \
        sv_setuv(my_cxt_sv, PTR2UV(my_cxtp))

/* This macro must be used to access members of the my_cxt_t structure.
 * e.g. MYCXT.some_data */
#define MY_CXT          (*my_cxtp)

/* Judicious use of these macros can reduce the number of times dMY_CXT
 * is used.  Use is similar to pTHX, aTHX etc. */
#define pMY_CXT         my_cxt_t *my_cxtp
#define pMY_CXT_        pMY_CXT,
#define _pMY_CXT        ,pMY_CXT
#define aMY_CXT         my_cxtp
#define aMY_CXT_        aMY_CXT,
#define _aMY_CXT        ,aMY_CXT

#endif /* START_MY_CXT */

#ifndef MY_CXT_CLONE
/* Clones the per-interpreter data. */
#define MY_CXT_CLONE \
        dMY_CXT_SV;                                                     \
        my_cxt_t *my_cxtp = (my_cxt_t*)SvPVX(newSV(sizeof(my_cxt_t)-1));\
        Copy(INT2PTR(my_cxt_t*, SvUV(my_cxt_sv)), my_cxtp, 1, my_cxt_t);\
        sv_setuv(my_cxt_sv, PTR2UV(my_cxtp))
#endif

#else /* single interpreter */

#ifndef START_MY_CXT

#define START_MY_CXT    static my_cxt_t my_cxt;
#define dMY_CXT_SV      dNOOP
#define dMY_CXT         dNOOP
#define MY_CXT_INIT     NOOP
#define MY_CXT          my_cxt

#define pMY_CXT         void
#define pMY_CXT_
#define _pMY_CXT
#define aMY_CXT
#define aMY_CXT_
#define _aMY_CXT

#endif /* START_MY_CXT */

#ifndef MY_CXT_CLONE
#define MY_CXT_CLONE    NOOP
#endif

#endif

#ifndef IVdf
#  if IVSIZE == LONGSIZE
#    define     IVdf      "ld"
#    define     UVuf      "lu"
#    define     UVof      "lo"
#    define     UVxf      "lx"
#    define     UVXf      "lX"
#  elif IVSIZE == INTSIZE
#    define   IVdf      "d"
#    define   UVuf      "u"
#    define   UVof      "o"
#    define   UVxf      "x"
#    define   UVXf      "X"
#  else
#    error "cannot define IV/UV formats"
#  endif
#endif

#ifndef NVef
#  if defined(USE_LONG_DOUBLE) && defined(HAS_LONG_DOUBLE) && \
      defined(PERL_PRIfldbl) && (PERL_BCDVERSION != 0x5006000)
            /* Not very likely, but let's try anyway. */
#    define NVef          PERL_PRIeldbl
#    define NVff          PERL_PRIfldbl
#    define NVgf          PERL_PRIgldbl
#  else
#    define NVef          "e"
#    define NVff          "f"
#    define NVgf          "g"
#  endif
#endif

#ifndef SvREFCNT_inc
#  ifdef PERL_USE_GCC_BRACE_GROUPS
#    define SvREFCNT_inc(sv)            \
      ({                                \
          SV * const _sv = (SV*)(sv);   \
          if (_sv)                      \
               (SvREFCNT(_sv))++;       \
          _sv;                          \
      })
#  else
#    define SvREFCNT_inc(sv)    \
          ((PL_Sv=(SV*)(sv)) ? (++(SvREFCNT(PL_Sv)),PL_Sv) : NULL)
#  endif
#endif

#ifndef SvREFCNT_inc_simple
#  ifdef PERL_USE_GCC_BRACE_GROUPS
#    define SvREFCNT_inc_simple(sv)     \
      ({                                        \
          if (sv)                               \
               (SvREFCNT(sv))++;                \
          (SV *)(sv);                           \
      })
#  else
#    define SvREFCNT_inc_simple(sv) \
          ((sv) ? (SvREFCNT(sv)++,(SV*)(sv)) : NULL)
#  endif
#endif

#ifndef SvREFCNT_inc_NN
#  ifdef PERL_USE_GCC_BRACE_GROUPS
#    define SvREFCNT_inc_NN(sv)         \
      ({                                        \
          SV * const _sv = (SV*)(sv);   \
          SvREFCNT(_sv)++;              \
          _sv;                          \
      })
#  else
#    define SvREFCNT_inc_NN(sv) \
          (PL_Sv=(SV*)(sv),++(SvREFCNT(PL_Sv)),PL_Sv)
#  endif
#endif

#ifndef SvREFCNT_inc_void
#  ifdef PERL_USE_GCC_BRACE_GROUPS
#    define SvREFCNT_inc_void(sv)               \
      ({                                        \
          SV * const _sv = (SV*)(sv);   \
          if (_sv)                      \
              (void)(SvREFCNT(_sv)++);  \
      })
#  else
#    define SvREFCNT_inc_void(sv) \
          (void)((PL_Sv=(SV*)(sv)) ? ++(SvREFCNT(PL_Sv)) : 0)
#  endif
#endif
#ifndef SvREFCNT_inc_simple_void
#  define SvREFCNT_inc_simple_void(sv)   STMT_START { if (sv) SvREFCNT(sv)++; } STMT_END
#endif

#ifndef SvREFCNT_inc_simple_NN
#  define SvREFCNT_inc_simple_NN(sv)     (++SvREFCNT(sv), (SV*)(sv))
#endif

#ifndef SvREFCNT_inc_void_NN
#  define SvREFCNT_inc_void_NN(sv)       (void)(++SvREFCNT((SV*)(sv)))
#endif

#ifndef SvREFCNT_inc_simple_void_NN
#  define SvREFCNT_inc_simple_void_NN(sv) (void)(++SvREFCNT((SV*)(sv)))
#endif

#ifndef newSV_type

#if defined(NEED_newSV_type)
static SV* DPPP_(my_newSV_type)(pTHX_ svtype const t);
static
#else
extern SV* DPPP_(my_newSV_type)(pTHX_ svtype const t);
#endif

#ifdef newSV_type
#  undef newSV_type
#endif
#define newSV_type(a) DPPP_(my_newSV_type)(aTHX_ a)
#define Perl_newSV_type DPPP_(my_newSV_type)

#if defined(NEED_newSV_type) || defined(NEED_newSV_type_GLOBAL)

SV*
DPPP_(my_newSV_type)(pTHX_ svtype const t)
{
  SV* const sv = newSV(0);
  sv_upgrade(sv, t);
  return sv;
}

#endif

#endif

#if (PERL_BCDVERSION < 0x5006000)
# define D_PPP_CONSTPV_ARG(x)  ((char *) (x))
#else
# define D_PPP_CONSTPV_ARG(x)  (x)
#endif
#ifndef newSVpvn
#  define newSVpvn(data,len)             ((data)                                              \
                                    ? ((len) ? newSVpv((data), (len)) : newSVpv("", 0)) \
                                    : newSV(0))
#endif
#ifndef newSVpvn_utf8
#  define newSVpvn_utf8(s, len, u)       newSVpvn_flags((s), (len), (u) ? SVf_UTF8 : 0)
#endif
#ifndef SVf_UTF8
#  define SVf_UTF8                       0
#endif

#ifndef newSVpvn_flags

#if defined(NEED_newSVpvn_flags)
static SV * DPPP_(my_newSVpvn_flags)(pTHX_ const char *s, STRLEN len, U32 flags);
static
#else
extern SV * DPPP_(my_newSVpvn_flags)(pTHX_ const char *s, STRLEN len, U32 flags);
#endif

#ifdef newSVpvn_flags
#  undef newSVpvn_flags
#endif
#define newSVpvn_flags(a,b,c) DPPP_(my_newSVpvn_flags)(aTHX_ a,b,c)
#define Perl_newSVpvn_flags DPPP_(my_newSVpvn_flags)

#if defined(NEED_newSVpvn_flags) || defined(NEED_newSVpvn_flags_GLOBAL)

SV *
DPPP_(my_newSVpvn_flags)(pTHX_ const char *s, STRLEN len, U32 flags)
{
  SV *sv = newSVpvn(D_PPP_CONSTPV_ARG(s), len);
  SvFLAGS(sv) |= (flags & SVf_UTF8);
  return (flags & SVs_TEMP) ? sv_2mortal(sv) : sv;
}

#endif

#endif

/* Backwards compatibility stuff... :-( */
#if !defined(NEED_sv_2pv_flags) && defined(NEED_sv_2pv_nolen)
#  define NEED_sv_2pv_flags
#endif
#if !defined(NEED_sv_2pv_flags_GLOBAL) && defined(NEED_sv_2pv_nolen_GLOBAL)
#  define NEED_sv_2pv_flags_GLOBAL
#endif

/* Hint: sv_2pv_nolen
 * Use the SvPV_nolen() or SvPV_nolen_const() macros instead of sv_2pv_nolen().
 */
#ifndef sv_2pv_nolen
#  define sv_2pv_nolen(sv)               SvPV_nolen(sv)
#endif

#ifdef SvPVbyte

/* Hint: SvPVbyte
 * Does not work in perl-5.6.1, ppport.h implements a version
 * borrowed from perl-5.7.3.
 */

#if (PERL_BCDVERSION < 0x5007000)

#if defined(NEED_sv_2pvbyte)
static char * DPPP_(my_sv_2pvbyte)(pTHX_ SV *sv, STRLEN *lp);
static
#else
extern char * DPPP_(my_sv_2pvbyte)(pTHX_ SV *sv, STRLEN *lp);
#endif

#ifdef sv_2pvbyte
#  undef sv_2pvbyte
#endif
#define sv_2pvbyte(a,b) DPPP_(my_sv_2pvbyte)(aTHX_ a,b)
#define Perl_sv_2pvbyte DPPP_(my_sv_2pvbyte)

#if defined(NEED_sv_2pvbyte) || defined(NEED_sv_2pvbyte_GLOBAL)

char *
DPPP_(my_sv_2pvbyte)(pTHX_ SV *sv, STRLEN *lp)
{
  sv_utf8_downgrade(sv,0);
  return SvPV(sv,*lp);
}

#endif

/* Hint: sv_2pvbyte
 * Use the SvPVbyte() macro instead of sv_2pvbyte().
 */

#undef SvPVbyte

#define SvPVbyte(sv, lp)                                                \
        ((SvFLAGS(sv) & (SVf_POK|SVf_UTF8)) == (SVf_POK)                \
         ? ((lp = SvCUR(sv)), SvPVX(sv)) : sv_2pvbyte(sv, &lp))

#endif

#else

#  define SvPVbyte          SvPV
#  define sv_2pvbyte        sv_2pv

#endif
#ifndef sv_2pvbyte_nolen
#  define sv_2pvbyte_nolen(sv)           sv_2pv_nolen(sv)
#endif

/* Hint: sv_pvn
 * Always use the SvPV() macro instead of sv_pvn().
 */

/* Hint: sv_pvn_force
 * Always use the SvPV_force() macro instead of sv_pvn_force().
 */

/* If these are undefined, they're not handled by the core anyway */
#ifndef SV_IMMEDIATE_UNREF
#  define SV_IMMEDIATE_UNREF             0
#endif

#ifndef SV_GMAGIC
#  define SV_GMAGIC                      0
#endif

#ifndef SV_COW_DROP_PV
#  define SV_COW_DROP_PV                 0
#endif

#ifndef SV_UTF8_NO_ENCODING
#  define SV_UTF8_NO_ENCODING            0
#endif

#ifndef SV_NOSTEAL
#  define SV_NOSTEAL                     0
#endif

#ifndef SV_CONST_RETURN
#  define SV_CONST_RETURN                0
#endif

#ifndef SV_MUTABLE_RETURN
#  define SV_MUTABLE_RETURN              0
#endif

#ifndef SV_SMAGIC
#  define SV_SMAGIC                      0
#endif

#ifndef SV_HAS_TRAILING_NUL
#  define SV_HAS_TRAILING_NUL            0
#endif

#ifndef SV_COW_SHARED_HASH_KEYS
#  define SV_COW_SHARED_HASH_KEYS        0
#endif

#if (PERL_BCDVERSION < 0x5007002)

#if defined(NEED_sv_2pv_flags)
static char * DPPP_(my_sv_2pv_flags)(pTHX_ SV *sv, STRLEN *lp, I32 flags);
static
#else
extern char * DPPP_(my_sv_2pv_flags)(pTHX_ SV *sv, STRLEN *lp, I32 flags);
#endif

#ifdef sv_2pv_flags
#  undef sv_2pv_flags
#endif
#define sv_2pv_flags(a,b,c) DPPP_(my_sv_2pv_flags)(aTHX_ a,b,c)
#define Perl_sv_2pv_flags DPPP_(my_sv_2pv_flags)

#if defined(NEED_sv_2pv_flags) || defined(NEED_sv_2pv_flags_GLOBAL)

char *
DPPP_(my_sv_2pv_flags)(pTHX_ SV *sv, STRLEN *lp, I32 flags)
{
  STRLEN n_a = (STRLEN) flags;
  return sv_2pv(sv, lp ? lp : &n_a);
}

#endif

#if defined(NEED_sv_pvn_force_flags)
static char * DPPP_(my_sv_pvn_force_flags)(pTHX_ SV *sv, STRLEN *lp, I32 flags);
static
#else
extern char * DPPP_(my_sv_pvn_force_flags)(pTHX_ SV *sv, STRLEN *lp, I32 flags);
#endif

#ifdef sv_pvn_force_flags
#  undef sv_pvn_force_flags
#endif
#define sv_pvn_force_flags(a,b,c) DPPP_(my_sv_pvn_force_flags)(aTHX_ a,b,c)
#define Perl_sv_pvn_force_flags DPPP_(my_sv_pvn_force_flags)

#if defined(NEED_sv_pvn_force_flags) || defined(NEED_sv_pvn_force_flags_GLOBAL)

char *
DPPP_(my_sv_pvn_force_flags)(pTHX_ SV *sv, STRLEN *lp, I32 flags)
{
  STRLEN n_a = (STRLEN) flags;
  return sv_pvn_force(sv, lp ? lp : &n_a);
}

#endif

#endif

#if (PERL_BCDVERSION < 0x5008008) || ( (PERL_BCDVERSION >= 0x5009000) && (PERL_BCDVERSION < 0x5009003) )
# define DPPP_SVPV_NOLEN_LP_ARG &PL_na
#else
# define DPPP_SVPV_NOLEN_LP_ARG 0
#endif
#ifndef SvPV_const
#  define SvPV_const(sv, lp)             SvPV_flags_const(sv, lp, SV_GMAGIC)
#endif

#ifndef SvPV_mutable
#  define SvPV_mutable(sv, lp)           SvPV_flags_mutable(sv, lp, SV_GMAGIC)
#endif
#ifndef SvPV_flags
#  define SvPV_flags(sv, lp, flags)      \
                 ((SvFLAGS(sv) & (SVf_POK)) == SVf_POK \
                  ? ((lp = SvCUR(sv)), SvPVX(sv)) : sv_2pv_flags(sv, &lp, flags))
#endif
#ifndef SvPV_flags_const
#  define SvPV_flags_const(sv, lp, flags) \
                 ((SvFLAGS(sv) & (SVf_POK)) == SVf_POK \
                  ? ((lp = SvCUR(sv)), SvPVX_const(sv)) : \
                  (const char*) sv_2pv_flags(sv, &lp, flags|SV_CONST_RETURN))
#endif
#ifndef SvPV_flags_const_nolen
#  define SvPV_flags_const_nolen(sv, flags) \
                 ((SvFLAGS(sv) & (SVf_POK)) == SVf_POK \
                  ? SvPVX_const(sv) : \
                  (const char*) sv_2pv_flags(sv, DPPP_SVPV_NOLEN_LP_ARG, flags|SV_CONST_RETURN))
#endif
#ifndef SvPV_flags_mutable
#  define SvPV_flags_mutable(sv, lp, flags) \
                 ((SvFLAGS(sv) & (SVf_POK)) == SVf_POK \
                  ? ((lp = SvCUR(sv)), SvPVX_mutable(sv)) : \
                  sv_2pv_flags(sv, &lp, flags|SV_MUTABLE_RETURN))
#endif
#ifndef SvPV_force
#  define SvPV_force(sv, lp)             SvPV_force_flags(sv, lp, SV_GMAGIC)
#endif

#ifndef SvPV_force_nolen
#  define SvPV_force_nolen(sv)           SvPV_force_flags_nolen(sv, SV_GMAGIC)
#endif

#ifndef SvPV_force_mutable
#  define SvPV_force_mutable(sv, lp)     SvPV_force_flags_mutable(sv, lp, SV_GMAGIC)
#endif

#ifndef SvPV_force_nomg
#  define SvPV_force_nomg(sv, lp)        SvPV_force_flags(sv, lp, 0)
#endif

#ifndef SvPV_force_nomg_nolen
#  define SvPV_force_nomg_nolen(sv)      SvPV_force_flags_nolen(sv, 0)
#endif
#ifndef SvPV_force_flags
#  define SvPV_force_flags(sv, lp, flags) \
                 ((SvFLAGS(sv) & (SVf_POK|SVf_THINKFIRST)) == SVf_POK \
                 ? ((lp = SvCUR(sv)), SvPVX(sv)) : sv_pvn_force_flags(sv, &lp, flags))
#endif
#ifndef SvPV_force_flags_nolen
#  define SvPV_force_flags_nolen(sv, flags) \
                 ((SvFLAGS(sv) & (SVf_POK|SVf_THINKFIRST)) == SVf_POK \
                 ? SvPVX(sv) : sv_pvn_force_flags(sv, DPPP_SVPV_NOLEN_LP_ARG, flags))
#endif
#ifndef SvPV_force_flags_mutable
#  define SvPV_force_flags_mutable(sv, lp, flags) \
                 ((SvFLAGS(sv) & (SVf_POK|SVf_THINKFIRST)) == SVf_POK \
                 ? ((lp = SvCUR(sv)), SvPVX_mutable(sv)) \
                  : sv_pvn_force_flags(sv, &lp, flags|SV_MUTABLE_RETURN))
#endif
#ifndef SvPV_nolen
#  define SvPV_nolen(sv)                 \
                 ((SvFLAGS(sv) & (SVf_POK)) == SVf_POK \
                  ? SvPVX(sv) : sv_2pv_flags(sv, DPPP_SVPV_NOLEN_LP_ARG, SV_GMAGIC))
#endif
#ifndef SvPV_nolen_const
#  define SvPV_nolen_const(sv)           \
                 ((SvFLAGS(sv) & (SVf_POK)) == SVf_POK \
                  ? SvPVX_const(sv) : sv_2pv_flags(sv, DPPP_SVPV_NOLEN_LP_ARG, SV_GMAGIC|SV_CONST_RETURN))
#endif
#ifndef SvPV_nomg
#  define SvPV_nomg(sv, lp)              SvPV_flags(sv, lp, 0)
#endif

#ifndef SvPV_nomg_const
#  define SvPV_nomg_const(sv, lp)        SvPV_flags_const(sv, lp, 0)
#endif

#ifndef SvPV_nomg_const_nolen
#  define SvPV_nomg_const_nolen(sv)      SvPV_flags_const_nolen(sv, 0)
#endif

#ifndef SvPV_nomg_nolen
#  define SvPV_nomg_nolen(sv)            ((SvFLAGS(sv) & (SVf_POK)) == SVf_POK \
                                    ? SvPVX(sv) : sv_2pv_flags(sv, DPPP_SVPV_NOLEN_LP_ARG, 0))
#endif
#ifndef SvPV_renew
#  define SvPV_renew(sv,n)               STMT_START { SvLEN_set(sv, n); \
                 SvPV_set((sv), (char *) saferealloc(          \
                       (Malloc_t)SvPVX(sv), (MEM_SIZE)((n)))); \
               } STMT_END
#endif
#ifndef SvMAGIC_set
#  define SvMAGIC_set(sv, val)           \
                STMT_START { assert(SvTYPE(sv) >= SVt_PVMG); \
                (((XPVMG*) SvANY(sv))->xmg_magic = (val)); } STMT_END
#endif

#if (PERL_BCDVERSION < 0x5009003)
#ifndef SvPVX_const
#  define SvPVX_const(sv)                ((const char*) (0 + SvPVX(sv)))
#endif

#ifndef SvPVX_mutable
#  define SvPVX_mutable(sv)              (0 + SvPVX(sv))
#endif
#ifndef SvRV_set
#  define SvRV_set(sv, val)              \
                STMT_START { assert(SvTYPE(sv) >=  SVt_RV); \
                (((XRV*) SvANY(sv))->xrv_rv = (val)); } STMT_END
#endif

#else
#ifndef SvPVX_const
#  define SvPVX_const(sv)                ((const char*)((sv)->sv_u.svu_pv))
#endif

#ifndef SvPVX_mutable
#  define SvPVX_mutable(sv)              ((sv)->sv_u.svu_pv)
#endif
#ifndef SvRV_set
#  define SvRV_set(sv, val)              \
                STMT_START { assert(SvTYPE(sv) >=  SVt_RV); \
                ((sv)->sv_u.svu_rv = (val)); } STMT_END
#endif

#endif
#ifndef SvSTASH_set
#  define SvSTASH_set(sv, val)           \
                STMT_START { assert(SvTYPE(sv) >= SVt_PVMG); \
                (((XPVMG*) SvANY(sv))->xmg_stash = (val)); } STMT_END
#endif

#if (PERL_BCDVERSION < 0x5004000)
#ifndef SvUV_set
#  define SvUV_set(sv, val)              \
                STMT_START { assert(SvTYPE(sv) == SVt_IV || SvTYPE(sv) >= SVt_PVIV); \
                (((XPVIV*) SvANY(sv))->xiv_iv = (IV) (val)); } STMT_END
#endif

#else
#ifndef SvUV_set
#  define SvUV_set(sv, val)              \
                STMT_START { assert(SvTYPE(sv) == SVt_IV || SvTYPE(sv) >= SVt_PVIV); \
                (((XPVUV*) SvANY(sv))->xuv_uv = (val)); } STMT_END
#endif

#endif

#if (PERL_BCDVERSION >= 0x5004000) && !defined(vnewSVpvf)
#if defined(NEED_vnewSVpvf)
static SV * DPPP_(my_vnewSVpvf)(pTHX_ const char *pat, va_list *args);
static
#else
extern SV * DPPP_(my_vnewSVpvf)(pTHX_ const char *pat, va_list *args);
#endif

#ifdef vnewSVpvf
#  undef vnewSVpvf
#endif
#define vnewSVpvf(a,b) DPPP_(my_vnewSVpvf)(aTHX_ a,b)
#define Perl_vnewSVpvf DPPP_(my_vnewSVpvf)

#if defined(NEED_vnewSVpvf) || defined(NEED_vnewSVpvf_GLOBAL)

SV *
DPPP_(my_vnewSVpvf)(pTHX_ const char *pat, va_list *args)
{
  register SV *sv = newSV(0);
  sv_vsetpvfn(sv, pat, strlen(pat), args, Null(SV**), 0, Null(bool*));
  return sv;
}

#endif
#endif

#if (PERL_BCDVERSION >= 0x5004000) && !defined(sv_vcatpvf)
#  define sv_vcatpvf(sv, pat, args)  sv_vcatpvfn(sv, pat, strlen(pat), args, Null(SV**), 0, Null(bool*))
#endif

#if (PERL_BCDVERSION >= 0x5004000) && !defined(sv_vsetpvf)
#  define sv_vsetpvf(sv, pat, args)  sv_vsetpvfn(sv, pat, strlen(pat), args, Null(SV**), 0, Null(bool*))
#endif

#if (PERL_BCDVERSION >= 0x5004000) && !defined(sv_catpvf_mg)
#if defined(NEED_sv_catpvf_mg)
static void DPPP_(my_sv_catpvf_mg)(pTHX_ SV *sv, const char *pat, ...);
static
#else
extern void DPPP_(my_sv_catpvf_mg)(pTHX_ SV *sv, const char *pat, ...);
#endif

#define Perl_sv_catpvf_mg DPPP_(my_sv_catpvf_mg)

#if defined(NEED_sv_catpvf_mg) || defined(NEED_sv_catpvf_mg_GLOBAL)

void
DPPP_(my_sv_catpvf_mg)(pTHX_ SV *sv, const char *pat, ...)
{
  va_list args;
  va_start(args, pat);
  sv_vcatpvfn(sv, pat, strlen(pat), &args, Null(SV**), 0, Null(bool*));
  SvSETMAGIC(sv);
  va_end(args);
}

#endif
#endif

#ifdef PERL_IMPLICIT_CONTEXT
#if (PERL_BCDVERSION >= 0x5004000) && !defined(sv_catpvf_mg_nocontext)
#if defined(NEED_sv_catpvf_mg_nocontext)
static void DPPP_(my_sv_catpvf_mg_nocontext)(SV *sv, const char *pat, ...);
static
#else
extern void DPPP_(my_sv_catpvf_mg_nocontext)(SV *sv, const char *pat, ...);
#endif

#define sv_catpvf_mg_nocontext DPPP_(my_sv_catpvf_mg_nocontext)
#define Perl_sv_catpvf_mg_nocontext DPPP_(my_sv_catpvf_mg_nocontext)

#if defined(NEED_sv_catpvf_mg_nocontext) || defined(NEED_sv_catpvf_mg_nocontext_GLOBAL)

void
DPPP_(my_sv_catpvf_mg_nocontext)(SV *sv, const char *pat, ...)
{
  dTHX;
  va_list args;
  va_start(args, pat);
  sv_vcatpvfn(sv, pat, strlen(pat), &args, Null(SV**), 0, Null(bool*));
  SvSETMAGIC(sv);
  va_end(args);
}

#endif
#endif
#endif

/* sv_catpvf_mg depends on sv_catpvf_mg_nocontext */
#ifndef sv_catpvf_mg
#  ifdef PERL_IMPLICIT_CONTEXT
#    define sv_catpvf_mg   Perl_sv_catpvf_mg_nocontext
#  else
#    define sv_catpvf_mg   Perl_sv_catpvf_mg
#  endif
#endif

#if (PERL_BCDVERSION >= 0x5004000) && !defined(sv_vcatpvf_mg)
#  define sv_vcatpvf_mg(sv, pat, args)                                     \
   STMT_START {                                                            \
     sv_vcatpvfn(sv, pat, strlen(pat), args, Null(SV**), 0, Null(bool*));  \
     SvSETMAGIC(sv);                                                       \
   } STMT_END
#endif

#if (PERL_BCDVERSION >= 0x5004000) && !defined(sv_setpvf_mg)
#if defined(NEED_sv_setpvf_mg)
static void DPPP_(my_sv_setpvf_mg)(pTHX_ SV *sv, const char *pat, ...);
static
#else
extern void DPPP_(my_sv_setpvf_mg)(pTHX_ SV *sv, const char *pat, ...);
#endif

#define Perl_sv_setpvf_mg DPPP_(my_sv_setpvf_mg)

#if defined(NEED_sv_setpvf_mg) || defined(NEED_sv_setpvf_mg_GLOBAL)

void
DPPP_(my_sv_setpvf_mg)(pTHX_ SV *sv, const char *pat, ...)
{
  va_list args;
  va_start(args, pat);
  sv_vsetpvfn(sv, pat, strlen(pat), &args, Null(SV**), 0, Null(bool*));
  SvSETMAGIC(sv);
  va_end(args);
}

#endif
#endif

#ifdef PERL_IMPLICIT_CONTEXT
#if (PERL_BCDVERSION >= 0x5004000) && !defined(sv_setpvf_mg_nocontext)
#if defined(NEED_sv_setpvf_mg_nocontext)
static void DPPP_(my_sv_setpvf_mg_nocontext)(SV *sv, const char *pat, ...);
static
#else
extern void DPPP_(my_sv_setpvf_mg_nocontext)(SV *sv, const char *pat, ...);
#endif

#define sv_setpvf_mg_nocontext DPPP_(my_sv_setpvf_mg_nocontext)
#define Perl_sv_setpvf_mg_nocontext DPPP_(my_sv_setpvf_mg_nocontext)

#if defined(NEED_sv_setpvf_mg_nocontext) || defined(NEED_sv_setpvf_mg_nocontext_GLOBAL)

void
DPPP_(my_sv_setpvf_mg_nocontext)(SV *sv, const char *pat, ...)
{
  dTHX;
  va_list args;
  va_start(args, pat);
  sv_vsetpvfn(sv, pat, strlen(pat), &args, Null(SV**), 0, Null(bool*));
  SvSETMAGIC(sv);
  va_end(args);
}

#endif
#endif
#endif

/* sv_setpvf_mg depends on sv_setpvf_mg_nocontext */
#ifndef sv_setpvf_mg
#  ifdef PERL_IMPLICIT_CONTEXT
#    define sv_setpvf_mg   Perl_sv_setpvf_mg_nocontext
#  else
#    define sv_setpvf_mg   Perl_sv_setpvf_mg
#  endif
#endif

#if (PERL_BCDVERSION >= 0x5004000) && !defined(sv_vsetpvf_mg)
#  define sv_vsetpvf_mg(sv, pat, args)                                     \
   STMT_START {                                                            \
     sv_vsetpvfn(sv, pat, strlen(pat), args, Null(SV**), 0, Null(bool*));  \
     SvSETMAGIC(sv);                                                       \
   } STMT_END
#endif

/* Hint: newSVpvn_share
 * The SVs created by this function only mimic the behaviour of
 * shared PVs without really being shared. Only use if you know
 * what you're doing.
 */

#ifndef newSVpvn_share

#if defined(NEED_newSVpvn_share)
static SV * DPPP_(my_newSVpvn_share)(pTHX_ const char *src, I32 len, U32 hash);
static
#else
extern SV * DPPP_(my_newSVpvn_share)(pTHX_ const char *src, I32 len, U32 hash);
#endif

#ifdef newSVpvn_share
#  undef newSVpvn_share
#endif
#define newSVpvn_share(a,b,c) DPPP_(my_newSVpvn_share)(aTHX_ a,b,c)
#define Perl_newSVpvn_share DPPP_(my_newSVpvn_share)

#if defined(NEED_newSVpvn_share) || defined(NEED_newSVpvn_share_GLOBAL)

SV *
DPPP_(my_newSVpvn_share)(pTHX_ const char *src, I32 len, U32 hash)
{
  SV *sv;
  if (len < 0)
    len = -len;
  if (!hash)
    PERL_HASH(hash, (char*) src, len);
  sv = newSVpvn((char *) src, len);
  sv_upgrade(sv, SVt_PVIV);
  SvIVX(sv) = hash;
  SvREADONLY_on(sv);
  SvPOK_on(sv);
  return sv;
}

#endif

#endif
#ifndef SvSHARED_HASH
#  define SvSHARED_HASH(sv)              (0 + SvUVX(sv))
#endif
#ifndef HvNAME_get
#  define HvNAME_get(hv)                 HvNAME(hv)
#endif
#ifndef HvNAMELEN_get
#  define HvNAMELEN_get(hv)              (HvNAME_get(hv) ? (I32)strlen(HvNAME_get(hv)) : 0)
#endif
#ifndef GvSVn
#  define GvSVn(gv)                      GvSV(gv)
#endif

#ifndef isGV_with_GP
#  define isGV_with_GP(gv)               isGV(gv)
#endif

#ifndef gv_fetchpvn_flags
#  define gv_fetchpvn_flags(name, len, flags, svt) gv_fetchpv(name, flags, svt)
#endif

#ifndef gv_fetchsv
#  define gv_fetchsv(name, flags, svt)   gv_fetchpv(SvPV_nolen_const(name), flags, svt)
#endif
#ifndef get_cvn_flags
#  define get_cvn_flags(name, namelen, flags) get_cv(name, flags)
#endif
#ifndef WARN_ALL
#  define WARN_ALL                       0
#endif

#ifndef WARN_CLOSURE
#  define WARN_CLOSURE                   1
#endif

#ifndef WARN_DEPRECATED
#  define WARN_DEPRECATED                2
#endif

#ifndef WARN_EXITING
#  define WARN_EXITING                   3
#endif

#ifndef WARN_GLOB
#  define WARN_GLOB                      4
#endif

#ifndef WARN_IO
#  define WARN_IO                        5
#endif

#ifndef WARN_CLOSED
#  define WARN_CLOSED                    6
#endif

#ifndef WARN_EXEC
#  define WARN_EXEC                      7
#endif

#ifndef WARN_LAYER
#  define WARN_LAYER                     8
#endif

#ifndef WARN_NEWLINE
#  define WARN_NEWLINE                   9
#endif

#ifndef WARN_PIPE
#  define WARN_PIPE                      10
#endif

#ifndef WARN_UNOPENED
#  define WARN_UNOPENED                  11
#endif

#ifndef WARN_MISC
#  define WARN_MISC                      12
#endif

#ifndef WARN_NUMERIC
#  define WARN_NUMERIC                   13
#endif

#ifndef WARN_ONCE
#  define WARN_ONCE                      14
#endif

#ifndef WARN_OVERFLOW
#  define WARN_OVERFLOW                  15
#endif

#ifndef WARN_PACK
#  define WARN_PACK                      16
#endif

#ifndef WARN_PORTABLE
#  define WARN_PORTABLE                  17
#endif

#ifndef WARN_RECURSION
#  define WARN_RECURSION                 18
#endif

#ifndef WARN_REDEFINE
#  define WARN_REDEFINE                  19
#endif

#ifndef WARN_REGEXP
#  define WARN_REGEXP                    20
#endif

#ifndef WARN_SEVERE
#  define WARN_SEVERE                    21
#endif

#ifndef WARN_DEBUGGING
#  define WARN_DEBUGGING                 22
#endif

#ifndef WARN_INPLACE
#  define WARN_INPLACE                   23
#endif

#ifndef WARN_INTERNAL
#  define WARN_INTERNAL                  24
#endif

#ifndef WARN_MALLOC
#  define WARN_MALLOC                    25
#endif

#ifndef WARN_SIGNAL
#  define WARN_SIGNAL                    26
#endif

#ifndef WARN_SUBSTR
#  define WARN_SUBSTR                    27
#endif

#ifndef WARN_SYNTAX
#  define WARN_SYNTAX                    28
#endif

#ifndef WARN_AMBIGUOUS
#  define WARN_AMBIGUOUS                 29
#endif

#ifndef WARN_BAREWORD
#  define WARN_BAREWORD                  30
#endif

#ifndef WARN_DIGIT
#  define WARN_DIGIT                     31
#endif

#ifndef WARN_PARENTHESIS
#  define WARN_PARENTHESIS               32
#endif

#ifndef WARN_PRECEDENCE
#  define WARN_PRECEDENCE                33
#endif

#ifndef WARN_PRINTF
#  define WARN_PRINTF                    34
#endif

#ifndef WARN_PROTOTYPE
#  define WARN_PROTOTYPE                 35
#endif

#ifndef WARN_QW
#  define WARN_QW                        36
#endif

#ifndef WARN_RESERVED
#  define WARN_RESERVED                  37
#endif

#ifndef WARN_SEMICOLON
#  define WARN_SEMICOLON                 38
#endif

#ifndef WARN_TAINT
#  define WARN_TAINT                     39
#endif

#ifndef WARN_THREADS
#  define WARN_THREADS                   40
#endif

#ifndef WARN_UNINITIALIZED
#  define WARN_UNINITIALIZED             41
#endif

#ifndef WARN_UNPACK
#  define WARN_UNPACK                    42
#endif

#ifndef WARN_UNTIE
#  define WARN_UNTIE                     43
#endif

#ifndef WARN_UTF8
#  define WARN_UTF8                      44
#endif

#ifndef WARN_VOID
#  define WARN_VOID                      45
#endif

#ifndef WARN_ASSERTIONS
#  define WARN_ASSERTIONS                46
#endif
#ifndef packWARN
#  define packWARN(a)                    (a)
#endif

#ifndef ckWARN
#  ifdef G_WARN_ON
#    define  ckWARN(a)                  (PL_dowarn & G_WARN_ON)
#  else
#    define  ckWARN(a)                  PL_dowarn
#  endif
#endif

#if (PERL_BCDVERSION >= 0x5004000) && !defined(warner)
#if defined(NEED_warner)
static void DPPP_(my_warner)(U32 err, const char *pat, ...);
static
#else
extern void DPPP_(my_warner)(U32 err, const char *pat, ...);
#endif

#define Perl_warner DPPP_(my_warner)

#if defined(NEED_warner) || defined(NEED_warner_GLOBAL)

void
DPPP_(my_warner)(U32 err, const char *pat, ...)
{
  SV *sv;
  va_list args;

  PERL_UNUSED_ARG(err);

  va_start(args, pat);
  sv = vnewSVpvf(pat, &args);
  va_end(args);
  sv_2mortal(sv);
  warn("%s", SvPV_nolen(sv));
}

#define warner  Perl_warner

#define Perl_warner_nocontext  Perl_warner

#endif
#endif

/* concatenating with "" ensures that only literal strings are accepted as argument
 * note that STR_WITH_LEN() can't be used as argument to macros or functions that
 * under some configurations might be macros
 */
#ifndef STR_WITH_LEN
#  define STR_WITH_LEN(s)                (s ""), (sizeof(s)-1)
#endif
#ifndef newSVpvs
#  define newSVpvs(str)                  newSVpvn(str "", sizeof(str) - 1)
#endif

#ifndef newSVpvs_flags
#  define newSVpvs_flags(str, flags)     newSVpvn_flags(str "", sizeof(str) - 1, flags)
#endif

#ifndef newSVpvs_share
#  define newSVpvs_share(str)            newSVpvn_share(str "", sizeof(str) - 1, 0)
#endif

#ifndef sv_catpvs
#  define sv_catpvs(sv, str)             sv_catpvn(sv, str "", sizeof(str) - 1)
#endif

#ifndef sv_setpvs
#  define sv_setpvs(sv, str)             sv_setpvn(sv, str "", sizeof(str) - 1)
#endif

#ifndef hv_fetchs
#  define hv_fetchs(hv, key, lval)       hv_fetch(hv, key "", sizeof(key) - 1, lval)
#endif

#ifndef hv_stores
#  define hv_stores(hv, key, val)        hv_store(hv, key "", sizeof(key) - 1, val, 0)
#endif
#ifndef gv_fetchpvs
#  define gv_fetchpvs(name, flags, svt)  gv_fetchpvn_flags(name "", sizeof(name) - 1, flags, svt)
#endif

#ifndef gv_stashpvs
#  define gv_stashpvs(name, flags)       gv_stashpvn(name "", sizeof(name) - 1, flags)
#endif
#ifndef get_cvs
#  define get_cvs(name, flags)           get_cvn_flags(name "", sizeof(name)-1, flags)
#endif
#ifndef SvGETMAGIC
#  define SvGETMAGIC(x)                  STMT_START { if (SvGMAGICAL(x)) mg_get(x); } STMT_END
#endif

/* Some random bits for sv_unmagicext. These should probably be pulled in for
   real and organized at some point */
#ifndef HEf_SVKEY
#  define HEf_SVKEY                      -2
#endif

#if defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN)
#  define MUTABLE_PTR(p) ({ void *_p = (p); _p; })
#else
#  define MUTABLE_PTR(p) ((void *) (p))
#endif

#define MUTABLE_SV(p)   ((SV *)MUTABLE_PTR(p))

/* end of random bits */
#ifndef PERL_MAGIC_sv
#  define PERL_MAGIC_sv                  '\0'
#endif

#ifndef PERL_MAGIC_overload
#  define PERL_MAGIC_overload            'A'
#endif

#ifndef PERL_MAGIC_overload_elem
#  define PERL_MAGIC_overload_elem       'a'
#endif

#ifndef PERL_MAGIC_overload_table
#  define PERL_MAGIC_overload_table      'c'
#endif

#ifndef PERL_MAGIC_bm
#  define PERL_MAGIC_bm                  'B'
#endif

#ifndef PERL_MAGIC_regdata
#  define PERL_MAGIC_regdata             'D'
#endif

#ifndef PERL_MAGIC_regdatum
#  define PERL_MAGIC_regdatum            'd'
#endif

#ifndef PERL_MAGIC_env
#  define PERL_MAGIC_env                 'E'
#endif

#ifndef PERL_MAGIC_envelem
#  define PERL_MAGIC_envelem             'e'
#endif

#ifndef PERL_MAGIC_fm
#  define PERL_MAGIC_fm                  'f'
#endif

#ifndef PERL_MAGIC_regex_global
#  define PERL_MAGIC_regex_global        'g'
#endif

#ifndef PERL_MAGIC_isa
#  define PERL_MAGIC_isa                 'I'
#endif

#ifndef PERL_MAGIC_isaelem
#  define PERL_MAGIC_isaelem             'i'
#endif

#ifndef PERL_MAGIC_nkeys
#  define PERL_MAGIC_nkeys               'k'
#endif

#ifndef PERL_MAGIC_dbfile
#  define PERL_MAGIC_dbfile              'L'
#endif

#ifndef PERL_MAGIC_dbline
#  define PERL_MAGIC_dbline              'l'
#endif

#ifndef PERL_MAGIC_mutex
#  define PERL_MAGIC_mutex               'm'
#endif

#ifndef PERL_MAGIC_shared
#  define PERL_MAGIC_shared              'N'
#endif

#ifndef PERL_MAGIC_shared_scalar
#  define PERL_MAGIC_shared_scalar       'n'
#endif

#ifndef PERL_MAGIC_collxfrm
#  define PERL_MAGIC_collxfrm            'o'
#endif

#ifndef PERL_MAGIC_tied
#  define PERL_MAGIC_tied                'P'
#endif

#ifndef PERL_MAGIC_tiedelem
#  define PERL_MAGIC_tiedelem            'p'
#endif

#ifndef PERL_MAGIC_tiedscalar
#  define PERL_MAGIC_tiedscalar          'q'
#endif

#ifndef PERL_MAGIC_qr
#  define PERL_MAGIC_qr                  'r'
#endif

#ifndef PERL_MAGIC_sig
#  define PERL_MAGIC_sig                 'S'
#endif

#ifndef PERL_MAGIC_sigelem
#  define PERL_MAGIC_sigelem             's'
#endif

#ifndef PERL_MAGIC_taint
#  define PERL_MAGIC_taint               't'
#endif

#ifndef PERL_MAGIC_uvar
#  define PERL_MAGIC_uvar                'U'
#endif

#ifndef PERL_MAGIC_uvar_elem
#  define PERL_MAGIC_uvar_elem           'u'
#endif

#ifndef PERL_MAGIC_vstring
#  define PERL_MAGIC_vstring             'V'
#endif

#ifndef PERL_MAGIC_vec
#  define PERL_MAGIC_vec                 'v'
#endif

#ifndef PERL_MAGIC_utf8
#  define PERL_MAGIC_utf8                'w'
#endif

#ifndef PERL_MAGIC_substr
#  define PERL_MAGIC_substr              'x'
#endif

#ifndef PERL_MAGIC_defelem
#  define PERL_MAGIC_defelem             'y'
#endif

#ifndef PERL_MAGIC_glob
#  define PERL_MAGIC_glob                '*'
#endif

#ifndef PERL_MAGIC_arylen
#  define PERL_MAGIC_arylen              '#'
#endif

#ifndef PERL_MAGIC_pos
#  define PERL_MAGIC_pos                 '.'
#endif

#ifndef PERL_MAGIC_backref
#  define PERL_MAGIC_backref             '<'
#endif

#ifndef PERL_MAGIC_ext
#  define PERL_MAGIC_ext                 '~'
#endif

/* That's the best we can do... */
#ifndef sv_catpvn_nomg
#  define sv_catpvn_nomg                 sv_catpvn
#endif

#ifndef sv_catsv_nomg
#  define sv_catsv_nomg                  sv_catsv
#endif

#ifndef sv_setsv_nomg
#  define sv_setsv_nomg                  sv_setsv
#endif

#ifndef sv_pvn_nomg
#  define sv_pvn_nomg                    sv_pvn
#endif

#ifndef SvIV_nomg
#  define SvIV_nomg                      SvIV
#endif

#ifndef SvUV_nomg
#  define SvUV_nomg                      SvUV
#endif

#ifndef sv_catpv_mg
#  define sv_catpv_mg(sv, ptr)          \
   STMT_START {                         \
     SV *TeMpSv = sv;                   \
     sv_catpv(TeMpSv,ptr);              \
     SvSETMAGIC(TeMpSv);                \
   } STMT_END
#endif

#ifndef sv_catpvn_mg
#  define sv_catpvn_mg(sv, ptr, len)    \
   STMT_START {                         \
     SV *TeMpSv = sv;                   \
     sv_catpvn(TeMpSv,ptr,len);         \
     SvSETMAGIC(TeMpSv);                \
   } STMT_END
#endif

#ifndef sv_catsv_mg
#  define sv_catsv_mg(dsv, ssv)         \
   STMT_START {                         \
     SV *TeMpSv = dsv;                  \
     sv_catsv(TeMpSv,ssv);              \
     SvSETMAGIC(TeMpSv);                \
   } STMT_END
#endif

#ifndef sv_setiv_mg
#  define sv_setiv_mg(sv, i)            \
   STMT_START {                         \
     SV *TeMpSv = sv;                   \
     sv_setiv(TeMpSv,i);                \
     SvSETMAGIC(TeMpSv);                \
   } STMT_END
#endif

#ifndef sv_setnv_mg
#  define sv_setnv_mg(sv, num)          \
   STMT_START {                         \
     SV *TeMpSv = sv;                   \
     sv_setnv(TeMpSv,num);              \
     SvSETMAGIC(TeMpSv);                \
   } STMT_END
#endif

#ifndef sv_setpv_mg
#  define sv_setpv_mg(sv, ptr)          \
   STMT_START {                         \
     SV *TeMpSv = sv;                   \
     sv_setpv(TeMpSv,ptr);              \
     SvSETMAGIC(TeMpSv);                \
   } STMT_END
#endif

#ifndef sv_setpvn_mg
#  define sv_setpvn_mg(sv, ptr, len)    \
   STMT_START {                         \
     SV *TeMpSv = sv;                   \
     sv_setpvn(TeMpSv,ptr,len);         \
     SvSETMAGIC(TeMpSv);                \
   } STMT_END
#endif

#ifndef sv_setsv_mg
#  define sv_setsv_mg(dsv, ssv)         \
   STMT_START {                         \
     SV *TeMpSv = dsv;                  \
     sv_setsv(TeMpSv,ssv);              \
     SvSETMAGIC(TeMpSv);                \
   } STMT_END
#endif

#ifndef sv_setuv_mg
#  define sv_setuv_mg(sv, i)            \
   STMT_START {                         \
     SV *TeMpSv = sv;                   \
     sv_setuv(TeMpSv,i);                \
     SvSETMAGIC(TeMpSv);                \
   } STMT_END
#endif

#ifndef sv_usepvn_mg
#  define sv_usepvn_mg(sv, ptr, len)    \
   STMT_START {                         \
     SV *TeMpSv = sv;                   \
     sv_usepvn(TeMpSv,ptr,len);         \
     SvSETMAGIC(TeMpSv);                \
   } STMT_END
#endif
#ifndef SvVSTRING_mg
#  define SvVSTRING_mg(sv)               (SvMAGICAL(sv) ? mg_find(sv, PERL_MAGIC_vstring) : NULL)
#endif

/* Hint: sv_magic_portable
 * This is a compatibility function that is only available with
 * Devel::PPPort. It is NOT in the perl core.
 * Its purpose is to mimic the 5.8.0 behaviour of sv_magic() when
 * it is being passed a name pointer with namlen == 0. In that
 * case, perl 5.8.0 and later store the pointer, not a copy of it.
 * The compatibility can be provided back to perl 5.004. With
 * earlier versions, the code will not compile.
 */

#if (PERL_BCDVERSION < 0x5004000)

  /* code that uses sv_magic_portable will not compile */

#elif (PERL_BCDVERSION < 0x5008000)

#  define sv_magic_portable(sv, obj, how, name, namlen)     \
   STMT_START {                                             \
     SV *SvMp_sv = (sv);                                    \