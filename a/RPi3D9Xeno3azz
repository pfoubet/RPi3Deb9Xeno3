# Copyright 2006 Google, Inc. All Rights Reserved.
# Licensed to PSF under a Contributor Agreement.

"""Refactoring framework.

Used as a main program, this can refactor any number of files and/or
recursively descend down directories.  Imported as a module, this
provides infrastructure to write your own refactoring tool.
"""

from __future__ import with_statement

__author__ = "Guido van Rossum <guido@python.org>"


# Python imports
import os
import sys
import logging
import operator
import collections
import StringIO
from itertools import chain

# Local imports
from .pgen2 import driver, tokenize, token
from .fixer_util import find_root
from . import pytree, pygram
from . import btm_utils as bu
from . import btm_matcher as bm


def get_all_fix_names(fixer_pkg, remove_prefix=True):
    """Return a sorted list of all available fix names in the given package."""
    pkg = __import__(fixer_pkg, [], [], ["*"])
    fixer_dir = os.path.dirname(pkg.__file__)
    fix_names = []
    for name in sorted(os.listdir(fixer_dir)):
        if name.startswith("fix_") and name.endswith(".py"):
            if remove_prefix:
                name = name[4:]
            fix_names.append(name[:-3])
    return fix_names


class _EveryNode(Exception):
    pass


def _get_head_types(pat):
    """ Accepts a pytree Pattern Node and returns a set
        of the pattern types which will match first. """

    if isinstance(pat, (pytree.NodePattern, pytree.LeafPattern)):
        # NodePatters must either have no type and no content
        #   or a type and content -- so they don't get any farther
        # Always return leafs
        if pat.type is None:
            raise _EveryNode
        return set([pat.type])

    if isinstance(pat, pytree.NegatedPattern):
        if pat.content:
            return _get_head_types(pat.content)
        raise _EveryNode # Negated Patterns don't have a type

    if isinstance(pat, pytree.WildcardPattern):
        # Recurse on each node in content
        r = set()
        for p in pat.content:
            for x in p:
                r.update(_get_head_types(x))
        return r

    raise Exception("Oh no! I don't understand pattern %s" %(pat))


def _get_headnode_dict(fixer_list):
    """ Accepts a list of fixers and returns a dictionary
        of head node type --> fixer list.  """
    head_nodes = collections.defaultdict(list)
    every = []
    for fixer in fixer_list:
        if fixer.pattern:
            try:
                heads = _get_head_types(fixer.pattern)
            except _EveryNode:
                every.append(fixer)
            else:
                for node_type in heads:
                    head_nodes[node_type].append(fixer)
        else:
            if fixer._accept_type is not None:
                head_nodes[fixer._accept_type].append(fixer)
            else:
                every.append(fixer)
    for node_type in chain(pygram.python_grammar.symbol2number.itervalues(),
                           pygram.python_grammar.tokens):
        head_nodes[node_type].extend(every)
    return dict(head_nodes)


def get_fixers_from_package(pkg_name):
    """
    Return the fully qualified names for fixers in the package pkg_name.
    """
    return [pkg_name + "." + fix_name
            for fix_name in get_all_fix_names(pkg_name, False)]

def _identity(obj):
    return obj

if sys.version_info < (3, 0):
    import codecs
    _open_with_encoding = codecs.open
    # codecs.open doesn't translate newlines sadly.
    def _from_system_newlines(input):
        return input.replace(u"\r\n", u"\n")
    def _to_system_newlines(input):
        if os.linesep != "\n":
            return input.replace(u"\n", os.linesep)
        else:
            return input
else:
    _open_with_encoding = open
    _from_system_newlines = _identity
    _to_system_newlines = _identity


def _detect_future_features(source):
    have_docstring = False
    gen = tokenize.generate_tokens(StringIO.StringIO(source).readline)
    def advance():
        tok = gen.next()
        return tok[0], tok[1]
    ignore = frozenset((token.NEWLINE, tokenize.NL, token.COMMENT))
    features = set()
    try:
        while True:
            tp, value = advance()
            if tp in ignore:
                continue
            elif tp == token.STRING:
                if have_docstring:
                    break
                have_docstring = True
            elif tp == token.NAME and value == u"from":
                tp, value = advance()
                if tp != token.NAME or value != u"__future__":
                    break
                tp, value = advance()
                if tp != token.NAME or value != u"import":
                    break
                tp, value = advance()
                if tp == token.OP and value == u"(":
                    tp, value = advance()
                while tp == token.NAME:
                    features.add(value)
                    tp, value = advance()
                    if tp != token.OP or value != u",":
                        break
                    tp, value = advance()
            else:
                break
    except StopIteration:
        pass
    return frozenset(features)


class FixerError(Exception):
    """A fixer could not be loaded."""


class RefactoringTool(object):

    _default_options = {"print_function" : False,
                        "write_unchanged_files" : False}

    CLASS_PREFIX = "Fix" # The prefix for fixer classes
    FILE_PREFIX = "fix_" # The prefix for modules with a fixer within

    def __init__(self, fixer_names, options=None, explicit=None):
        """Initializer.

        Args:
            fixer_names: a list of fixers to import
            options: a dict with configuration.
            explicit: a list of fixers to run even if they are explicit.
        """
        self.fixers = fixer_names
        self.explicit = explicit or []
        self.options = self._default_options.copy()
        if options is not None:
            self.options.update(options)
        if self.options["print_function"]:
            self.grammar = pygram.python_grammar_no_print_statement
        else:
            self.grammar = pygram.python_grammar
        # When this is True, the refactor*() methods will call write_file() for
        # files processed even if they were not changed during refactoring. If
        # and only if the refactor method's write parameter was True.
        self.write_unchanged_files = self.options.get("write_unchanged_files")
        self.errors = []
        self.logger = logging.getLogger("RefactoringTool")
        self.fixer_log = []
        self.wrote = False
        self.driver = driver.Driver(self.grammar,
                                    convert=pytree.convert,
                                    logger=self.logger)
        self.pre_order, self.post_order = self.get_fixers()


        self.files = []  # List of files that were or should be modified

        self.BM = bm.BottomMatcher()
        self.bmi_pre_order = [] # Bottom Matcher incompatible fixers
        self.bmi_post_order = []

        for fixer in chain(self.post_order, self.pre_order):
            if fixer.BM_compatible:
                self.BM.add_fixer(fixer)
                # remove fixers that will be handled by the bottom-up
                # matcher
            elif fixer in self.pre_order:
                self.bmi_pre_order.append(fixer)
            elif fixer in self.post_order:
                self.bmi_post_order.append(fixer)

        self.bmi_pre_order_heads = _get_headnode_dict(self.bmi_pre_order)
        self.bmi_post_order_heads = _get_headnode_dict(self.bmi_post_order)



    def get_fixers(self):
        """Inspects the options to load the requested patterns and handlers.

        Returns:
          (pre_order, post_order), where pre_order is the list of fixers that
          want a pre-order AST traversal, and post_order is the list that want
          post-order traversal.
        """
        pre_order_fixers = []
        post_order_fixers = []
        for fix_mod_path in self.fixers:
            mod = __import__(fix_mod_path, {}, {}, ["*"])
            fix_name = fix_mod_path.rsplit(".", 1)[-1]
            if fix_name.startswith(self.FILE_PREFIX):
                fix_name = fix_name[len(self.FILE_PREFIX):]
            parts = fix_name.split("_")
            class_name = self.CLASS_PREFIX + "".join([p.title() for p in parts])
            try:
                fix_class = getattr(mod, class_name)
            except AttributeError:
                raise FixerError("Can't find %s.%s" % (fix_name, class_name))
            fixer = fix_class(self.options, self.fixer_log)
            if fixer.explicit and self.explicit is not True and \
                    fix_mod_path not in self.explicit:
                self.log_message("Skipping optional fixer: %s", fix_name)
                continue

            self.log_debug("Adding transformation: %s", fix_name)
            if fixer.order == "pre":
                pre_order_fixers.append(fixer)
            elif fixer.order == "post":
                post_order_fixers.append(fixer)
            else:
                raise FixerError("Illegal fixer order: %r" % fixer.order)

        key_func = operator.attrgetter("run_order")
        pre_order_fixers.sort(key=key_func)
        post_order_fixers.sort(key=key_func)
        return (pre_order_fixers, post_order_fixers)

    def log_error(self, msg, *args, **kwds):
        """Called when an error occurs."""
        raise

    def log_message(self, msg, *args):
        """Hook to log a message."""
        if args:
            msg = msg % args
        self.logger.info(msg)

    def log_debug(self, msg, *args):
        if args:
            msg = msg % args
        self.logger.debug(msg)

    def print_output(self, old_text, new_text, filename, equal):
        """Called with the old version, new version, and filename of a
        refactored file."""
        pass

    def refactor(self, items, write=False, doctests_only=False):
        """Refactor a list of files and directories."""

        for dir_or_file in items:
            if os.path.isdir(dir_or_file):
                self.refactor_dir(dir_or_file, write, doctests_only)
            else:
                self.refactor_file(dir_or_file, write, doctests_only)

    def refactor_dir(self, dir_name, write=False, doctests_only=False):
        """Descends down a directory and refactor every Python file found.

        Python files are assumed to have a .py extension.

        Files and subdirectories starting with '.' are skipped.
        """
        py_ext = os.extsep + "py"
        for dirpath, dirnames, filenames in os.walk(dir_name):
            self.log_debug("Descending into %s", dirpath)
            dirnames.sort()
            filenames.sort()
            for name in filenames:
                if (not name.startswith(".") and
                    os.path.splitext(name)[1] == py_ext):
                    fullname = os.path.join(dirpath, name)
                    self.refactor_file(fullname, write, doctests_only)
            # Modify dirnames in-place to remove subdirs with leading dots
            dirnames[:] = [dn for dn in dirnames if not dn.startswith(".")]

    def _read_python_source(self, filename):
        """
        Do our best to decode a Python source file correctly.
        """
        try:
            f = open(filename, "rb")
        except IOError as err:
            self.log_error("Can't open %s: %s", filename, err)
            return None, None
        try:
            encoding = tokenize.detect_encoding(f.readline)[0]
        finally:
            f.close()
        with _open_with_encoding(filename, "r", encoding=encoding) as f:
            return _from_system_newlines(f.read()), encoding

    def refactor_file(self, filename, write=False, doctests_only=False):
        """Refactors a file."""
        input, encoding = self._read_python_source(filename)
        if input is None:
            # Reading the file failed.
            return
        input += u"\n" # Silence certain parse errors
        if doctests_only:
            self.log_debug("Refactoring doctests in %s", filename)
            output = self.refactor_docstring(input, filename)
            if self.write_unchanged_files or output != input:
                self.processed_file(output, filename, input, write, encoding)
            else:
                self.log_debug("No doctest changes in %s", filename)
        else:
            tree = self.refactor_string(input, filename)
            if self.write_unchanged_files or (tree and tree.was_changed):
                # The [:-1] is to take off the \n we added earlier
                self.processed_file(unicode(tree)[:-1], filename,
                                    write=write, encoding=encoding)
            else:
                self.log_debug("No changes in %s", filename)

    def refactor_string(self, data, name):
        """Refactor a given input string.

        Args:
            data: a string holding the code to be refactored.
            name: a human-readable name for use in error/log messages.

        Returns:
            An AST corresponding to the refactored input stream; None if
            there were errors during the parse.
        """
        features = _detect_future_features(data)
        if "print_function" in features:
            self.driver.grammar = pygram.python_grammar_no_print_statement
        try:
            tree = self.driver.parse_string(data)
        except Exception as err:
            self.log_error("Can't parse %s: %s: %s",
                           name, err.__class__.__name__, err)
            return
        finally:
            self.driver.grammar = self.grammar
        tree.future_features = features
        self.log_debug("Refactoring %s", name)
        self.refactor_tree(tree, name)
        return tree

    def refactor_stdin(self, doctests_only=False):
        input = sys.stdin.read()
        if doctests_only:
            self.log_debug("Refactoring doctests in stdin")
            output = self.refactor_docstring(input, "<stdin>")
            if self.write_unchanged_files or output != input:
                self.processed_file(output, "<stdin>", input)
            else:
                self.log_debug("No doctest changes in stdin")
        else:
            tree = self.refactor_string(input, "<stdin>")
            if self.write_unchanged_files or (tree and tree.was_changed):
                self.processed_file(unicode(tree), "<stdin>", input)
            else:
                self.log_debug("No changes in stdin")

    def refactor_tree(self, tree, name):
        """Refactors a parse tree (modifying the tree in place).

        For compatible patterns the bottom matcher module is
        used. Otherwise the tree is traversed node-to-node for
        matches.

        Args:
            tree: a pytree.Node instance representing the root of the tree
                  to be refactored.
            name: a human-readable name for this tree.

        Returns:
            True if the tree was modified, False otherwise.
        """

        for fixer in chain(self.pre_order, self.post_order):
            fixer.start_tree(tree, name)

        #use traditional matching for the incompatible fixers
        self.traverse_by(self.bmi_pre_order_heads, tree.pre_order())
        self.traverse_by(self.bmi_post_order_heads, tree.post_order())

        # obtain a set of candidate nodes
        match_set = self.BM.run(tree.leaves())

        while any(match_set.values()):
            for fixer in self.BM.fixers:
                if fixer in match_set and match_set[fixer]:
                    #sort by depth; apply fixers from bottom(of the AST) to top
                    match_set[fixer].sort(key=pytree.Base.depth, reverse=True)

                    if fixer.keep_line_order:
                        #some fixers(eg fix_imports) must be applied
                        #with the original file's line order
                        match_set[fixer].sort(key=pytree.Base.get_lineno)

                    for node in list(match_set[fixer]):
                        if node in match_set[fixer]:
                            match_set[fixer].remove(node)

                        try:
                            find_root(node)
                        except ValueError:
                            # this node has been cut off from a
                            # previous transformation ; skip
                            continue

                        if node.fixers_applied and fixer in node.fixers_applied:
                            # do not apply the same fixer again
                            continue

                        results = fixer.match(node)

                        if results:
                            new = fixer.transform(node, results)
                            if new is not None:
                                node.replace(new)
                                #new.fixers_applied.append(fixer)
                                for node in new.post_order():
                                    # do not apply the fixer again to
                                    # this or any subnode
                                    if not node.fixers_applied:
                                        node.fixers_applied = []
                                    node.fixers_applied.append(fixer)

                                # update the original match set for
                                # the added code
                                new_matches = self.BM.run(new.leaves())
                                for fxr in new_matches:
                                    if not fxr in match_set:
                                        match_set[fxr]=[]

                                    match_set[fxr].extend(new_matches[fxr])

        for fixer in chain(self.pre_order, self.post_order):
            fixer.finish_tree(tree, name)
        return tree.was_changed

    def traverse_by(self, fixers, traversal):
        """Traverse an AST, applying a set of fixers to each node.

        This is a helper method for refactor_tree().

        Args:
            fixers: a list of fixer instances.
            traversal: a generator that yields AST nodes.

        Returns:
            None
        """
        if not fixers:
            return
        for node in traversal:
            for fixer in fixers[node.type]:
                results = fixer.match(node)
                if results:
                    new = fixer.transform(node, results)
                    if new is not None:
                        node.replace(new)
                        node = new

    def processed_file(self, new_text, filename, old_text=None, write=False,
                       encoding=None):
        """
        Called when a file has been refactored and there may be changes.
        """
        self.files.append(filename)
        if old_text is None:
            old_text = self._read_python_source(filename)[0]
            if old_text is None:
                return
        equal = old_text == new_text
        self.print_output(old_text, new_text, filename, equal)
        if equal:
            self.log_debug("No changes to %s", filename)
            if not self.write_unchanged_files:
                return
        if write:
            self.write_file(new_text, filename, old_text, encoding)
        else:
            self.log_debug("Not writing changes to %s", filename)

    def write_file(self, new_text, filename, old_text, encoding=None):
        """Writes a string to a file.

        It first shows a unified diff between the old text and the new text, and
        then rewrites the file; the latter is only done if the write option is
        set.
        """
        try:
            f = _open_with_encoding(filename, "w", encoding=encoding)
        except os.error as err:
            self.log_error("Can't create %s: %s", filename, err)
            return
        try:
            f.write(_to_system_newlines(new_text))
        except os.error as err:
            self.log_error("Can't write %s: %s", filename, err)
        finally:
            f.close()
        self.log_debug("Wrote changes to %s", filename)
        self.wrote = True

    PS1 = ">>> "
    PS2 = "... "

    def refactor_docstring(self, input, filename):
        """Refactors a docstring, looking for doctests.

        This returns a modified version of the input string.  It looks
        for doctests, which start with a ">>>" prompt, and may be
        continued with "..." prompts, as long as the "..." is indented
        the same as the ">>>".

        (Unfortunately we can't use the doctest module's parser,
        since, like most parsers, it is not geared towards preserving
        the original source.)
        """
        result = []
        block = None
        block_lineno = None
        indent = None
        lineno = 0
        for line in input.splitlines(True):
            lineno += 1
            if line.lstrip().startswith(self.PS1):
                if block is not None:
                    result.extend(self.refactor_doctest(block, block_lineno,
                                                        indent, filename))
                block_lineno = lineno
                block = [line]
                i = line.find(self.PS1)
                indent = line[:i]
            elif (indent is not None and
                  (line.startswith(indent + self.PS2) or
                   line == indent + self.PS2.rstrip() + u"\n")):
                block.append(line)
            else:
                if block is not None:
                    result.extend(self.refactor_doctest(block, block_lineno,
                                                        indent, filename))
                block = None
                indent = None
                result.append(line)
        if block is not None:
            result.extend(self.refactor_doctest(block, block_lineno,
                                                indent, filename))
        return u"".join(result)

    def refactor_doctest(self, block, lineno, indent, filename):
        """Refactors one doctest.

        A doctest is given as a block of lines, the first of which starts
        with ">>>" (possibly indented), while the remaining lines start
        with "..." (identically indented).

        """
        try:
            tree = self.parse_block(block, lineno, indent)
        except Exception as err:
            if self.logger.isEnabledFor(logging.DEBUG):
                for line in block:
                    self.log_debug("Source: %s", line.rstrip(u"\n"))
            self.log_error("Can't parse docstring in %s line %s: %s: %s",
                           filename, lineno, err.__class__.__name__, err)
            return block
        if self.refactor_tree(tree, filename):
            new = unicode(tree).splitlines(True)
            # Undo the adjustment of the line numbers in wrap_toks() below.
            clipped, new = new[:lineno-1], new[lineno-1:]
            assert clipped == [u"\n"] * (lineno-1), clipped
            if not new[-1].endswith(u"\n"):
                new[-1] += u"\n"
            block = [indent + self.PS1 + new.pop(0)]
            if new:
                block += [indent + self.PS2 + line for line in new]
        return block

    def summarize(self):
        if self.wrote:
            were = "were"
        else:
            were = "need to be"
        if not self.files:
            self.log_message("No files %s modified.", were)
        else:
            self.log_message("Files that %s modified:", were)
            for file in self.files:
                self.log_message(file)
        if self.fixer_log:
            self.log_message("Warnings/messages while refactoring:")
            for message in self.fixer_log:
                self.log_message(message)
        if self.errors:
            if len(self.errors) == 1:
                self.log_message("There was 1 error:")
            else:
                self.log_message("There were %d errors:", len(self.errors))
            for msg, args, kwds in self.errors:
                self.log_message(msg, *args, **kwds)

    def parse_block(self, block, lineno, indent):
        """Parses a block into a tree.

        This is necessary to get correct line number / offset information
        in the parser diagnostics and embedded into the parse tree.
        """
        tree = self.driver.parse_tokens(self.wrap_toks(block, lineno, indent))
        tree.future_features = frozenset()
        return tree

    def wrap_toks(self, block, lineno, indent):
        """Wraps a tokenize stream to systematically modify start/end."""
        tokens = tokenize.generate_tokens(self.gen_lines(block, indent).next)
        for type, value, (line0, col0), (line1, col1), line_text in tokens:
            line0 += lineno - 1
            line1 += lineno - 1
            # Don't bother updating the columns; this is too complicated
            # since line_text would also have to be updated and it would
            # still break for tokens spanning lines.  Let the user guess
            # that the column numbers for doctests are relative to the
            # end of the prompt string (PS1 or PS2).
            yield type, value, (line0, col0), (line1, col1), line_text


    def gen_lines(self, block, indent):
        """Generates lines as expected by tokenize from a list of lines.

        This strips the first len(indent + self.PS1) characters off each line.
        """
        prefix1 = indent + self.PS1
        prefix2 = indent + self.PS2
        prefix = prefix1
        for line in block:
            if line.startswith(prefix):
                yield line[len(prefix):]
            elif line == prefix.rstrip() + u"\n":
                yield u"\n"
            else:
                raise AssertionError("line=%r, prefix=%r" % (line, prefix))
            prefix = prefix2
        while True:
            yield ""


class MultiprocessingUnsupported(Exception):
    pass


class MultiprocessRefactoringTool(RefactoringTool):

    def __init__(self, *args, **kwargs):
        super(MultiprocessRefactoringTool, self).__init__(*args, **kwargs)
        self.queue = None
        self.output_lock = None

    def refactor(self, items, write=False, doctests_only=False,
                 num_processes=1):
        if num_processes == 1:
            return super(MultiprocessRefactoringTool, self).refactor(
                items, write, doctests_only)
        try:
            import multiprocessing
        except ImportError:
            raise MultiprocessingUnsupported
        if self.queue is not None:
            raise RuntimeError("already doing multiple processes")
        self.queue = multiprocessing.JoinableQueue()
        self.output_lock = multiprocessing.Lock()
        processes = [multiprocessing.Process(target=self._child)
                     for i in xrange(num_processes)]
        try:
            for p in processes:
                p.start()
            super(MultiprocessRefactoringTool, self).refactor(items, write,
                                                              doctests_only)
        finally:
            self.queue.join()
            for i in xrange(num_processes):
                self.queue.put(None)
            for p in processes:
                if p.is_alive():
                    p.join()
            self.queue = None

    def _child(self):
        task = self.queue.get()
        while task is not None:
            args, kwargs = task
            try:
                super(MultiprocessRefactoringTool, self).refactor_file(
                    *args, **kwargs)
            finally:
                self.queue.task_done()
            task = self.queue.get()

    def refactor_file(self, *args, **kwargs):
        if self.queue is not None:
            self.queue.put((args, kwargs))
        else:
            return super(MultiprocessRefactoringTool, self).refactor_file(
                *args, **kwargs)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             Û
”´[c           @Ä  s“  d  Z  d d l m Z d Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l	 Z	 d d l
 m Z d d l m Z m Z m Z d d l m Z d d	 l m Z m Z d d
 l m Z d d l m Z e d Ñ Z d e f d Ñ  É  YZ d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z  e j! d d f k  r[d d l" Z" e" j# Z$ d Ñ  Z% d Ñ  Z& n e# Z$ e  Z% e  Z& d Ñ  Z' d e f d Ñ  É  YZ( d e) f d Ñ  É  YZ* d e f d Ñ  É  YZ+ d e* f d Ñ  É  YZ, d S(    s€   Refactoring framework.

Used as a main program, this can refactor any number of files and/or
recursively descend down directories.  Imported as a module, this
provides infrastructure to write your own refactoring tool.
iˇˇˇˇ(   t   with_statements#   Guido van Rossum <guido@python.org>N(   t   chaini   (   t   drivert   tokenizet   token(   t	   find_root(   t   pytreet   pygram(   t	   btm_utils(   t   btm_matcherc         CÄ  sú   t  |  g  g  d g É } t j j | j É } g  } xb t t j | É É D]K } | j d É rI | j d É rI | rÄ | d } n  | j	 | d  É qI qI W| S(   sE   Return a sorted list of all available fix names in the given package.t   *t   fix_s   .pyi   i˝ˇˇˇ(
   t
   __import__t   ost   patht   dirnamet   __file__t   sortedt   listdirt
   startswitht   endswitht   append(   t	   fixer_pkgt   remove_prefixt   pkgt	   fixer_dirt	   fix_namest   name(    (    s&   /usr/lib/python2.7/lib2to3/refactor.pyt   get_all_fix_names!   s    t
   _EveryNodec           BÄ  s   e  Z RS(    (   t   __name__t
   __module__(    (    (    s&   /usr/lib/python2.7/lib2to3/refactor.pyR   .   s   c         CÄ  sﬂ   t  |  t j t j f É rC |  j d k r3 t Ç n  t |  j g É St  |  t j É rt |  j	 rk t
 |  j	 É St Ç n  t  |  t j É rÀ t É  } x5 |  j	 D]* } x! | D] } | j t
 | É É q¶ Wqô W| St d |  É Ç d S(   sf    Accepts a pytree Pattern Node and returns a set
        of the pattern types which will match first. s$   Oh no! I don't understand pattern %sN(   t
   isinstanceR   t   NodePatternt   LeafPatternt   typet   NoneR   t   sett   NegatedPatternt   contentt   _get_head_typest   WildcardPatternt   updatet	   Exception(   t   patt   rt   pt   x(    (    s&   /usr/lib/python2.7/lib2to3/refactor.pyR(   2   s    				c         CÄ  s  t  j t É } g  } x£ |  D]õ } | j rÑ y t | j É } Wn t k
 r^ | j | É q∑ XxU | D] } | | j | É qf Wq | j d k	 r™ | | j j | É q | j | É q Wx: t	 t
 j j j É  t
 j j É D] } | | j | É q› Wt | É S(   s^    Accepts a list of fixers and returns a dictionary
        of head node type --> fixer list.  N(   t   collectionst   defaultdictt   listt   patternR(   R   R   t   _accept_typeR$   R   R   t   python_grammart   symbol2numbert
   itervaluest   tokenst   extendt   dict(   t
   fixer_listt
   head_nodest   everyt   fixert   headst	   node_type(    (    s&   /usr/lib/python2.7/lib2to3/refactor.pyt   _get_headnode_dictN   s"    	c         CÄ  s(   g  t  |  t É D] } |  d | ^ q S(   sN   
    Return the fully qualified names for fixers in the package pkg_name.
    t   .(   R   t   False(   t   pkg_namet   fix_name(    (    s&   /usr/lib/python2.7/lib2to3/refactor.pyt   get_fixers_from_packageg   s    c         CÄ  s   |  S(   N(    (   t   obj(    (    s&   /usr/lib/python2.7/lib2to3/refactor.pyt	   _identityn   s    i   i    c         CÄ  s   |  j  d d É S(   Nu   
u   
(   t   replace(   t   input(    (    s&   /usr/lib/python2.7/lib2to3/refactor.pyt   _from_system_newlinesu   s    c         CÄ  s*   t  j d k r" |  j d t  j É S|  Sd  S(   Ns   
u   
(   R   t   linesepRI   (   RJ   (    (    s&   /usr/lib/python2.7/lib2to3/refactor.pyt   _to_system_newlinesw   s    c         Ä  s‡  t  } t j t j |  É j É â  á  f d Ü  } t t j t j t j	 f É } t
 É  } ykxdt r¿| É  \ } } | | k rÑ q] q] | t j k r¶ | rù Pn  t } q] | t j k rº| d k rº| É  \ } } | t j k sÎ | d k rÔ Pn  | É  \ } } | t j k s| d k rPn  | É  \ } } | t j k rY| d k rY| É  \ } } n  xa | t j k r∏| j | É | É  \ } } | t j k s¢| d k r¶Pn  | É  \ } } q\Wq] Pq] WWn t k
 r’n Xt | É S(   Nc          Ä  s   à  j  É  }  |  d |  d f S(   Ni    i   (   t   next(   t   tok(   t   gen(    s&   /usr/lib/python2.7/lib2to3/refactor.pyt   advanceÖ   s    u   fromu
   __future__u   importu   (u   ,(   RC   R   t   generate_tokenst   StringIOt   readlinet	   frozensetR   t   NEWLINEt   NLt   COMMENTR%   t   Truet   STRINGt   NAMEt   OPt   addt   StopIteration(   t   sourcet   have_docstringRQ   t   ignoret   featurest   tpt   value(    (   RP   s&   /usr/lib/python2.7/lib2to3/refactor.pyt   _detect_future_featuresÇ   sD    				t
   FixerErrorc           BÄ  s   e  Z d  Z RS(   s   A fixer could not be loaded.(   R   R   t   __doc__(    (    (    s&   /usr/lib/python2.7/lib2to3/refactor.pyRf   ™   s   t   RefactoringToolc           BÄ  s!  e  Z i e d  6e d 6Z d Z d Z d d d Ñ Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d Ñ  Z d	 Ñ  Z e e d
 Ñ Z e e d Ñ Z d Ñ  Z e e d Ñ Z d Ñ  Z e d Ñ Z d Ñ  Z d Ñ  Z d e d d Ñ Z d d Ñ Z d Z d Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   t   print_functiont   write_unchanged_filest   FixR   c         CÄ  sƒ  | |  _  | p g  |  _ |  j j É  |  _ | d k	 rI |  j j | É n  |  j d re t j |  _	 n t j
 |  _	 |  j j d É |  _ g  |  _ t j d É |  _ g  |  _ t |  _ t j |  j	 d t j d |  j É|  _ |  j É  \ |  _ |  _ g  |  _ t j É  |  _ g  |  _ g  |  _  x} t! |  j |  j É D]f } | j" rT|  j j# | É q2| |  j k rv|  j j$ | É q2| |  j k r2|  j  j$ | É q2q2Wt% |  j É |  _& t% |  j  É |  _' d S(   s—   Initializer.

        Args:
            fixer_names: a list of fixers to import
            options: a dict with configuration.
            explicit: a list of fixers to run even if they are explicit.
        Ri   Rj   Rh   t   convertt   loggerN((   t   fixerst   explicitt   _default_optionst   copyt   optionsR$   R*   R   t!   python_grammar_no_print_statementt   grammarR5   t   getRj   t   errorst   loggingt	   getLoggerRm   t	   fixer_logRC   t   wroteR   t   DriverR   Rl   t
   get_fixerst	   pre_ordert
   post_ordert   filest   bmt   BottomMatchert   BMt   bmi_pre_ordert   bmi_post_orderR   t   BM_compatiblet	   add_fixerR   RA   t   bmi_pre_order_headst   bmi_post_order_heads(   t   selft   fixer_namesRr   Ro   R>   (    (    s&   /usr/lib/python2.7/lib2to3/refactor.pyt   __init__∂   s<    									c         CÄ  s›  g  } g  } xï|  j  D]ä} t | i  i  d g É } | j d d É d } | j |  j É rr | t |  j É } n  | j d É } |  j d j g  | D] } | j	 É  ^ qî É } y t
 | | É }	 Wn' t k
 rÏ t d | | f É Ç n X|	 |  j |  j É }
 |
 j r?|  j t k	 r?| |  j k r?|  j d | É q n  |  j d	 | É |
 j d
 k rn| j |
 É q |
 j d k rç| j |
 É q t d |
 j É Ç q Wt j d É } | j d | É | j d | É | | f S(   s  Inspects the options to load the requested patterns and handlers.

        Returns:
          (pre_order, post_order), where pre_order is the list of fixers that
          want a pre-order AST traversal, and post_order is the list that want
          post-order traversal.
        R
   RB   i   iˇˇˇˇt   _t    s   Can't find %s.%ss   Skipping optional fixer: %ss   Adding transformation: %st   pret   posts   Illegal fixer order: %rt	   run_ordert   key(   Rn   R   t   rsplitR   t   FILE_PREFIXt   lent   splitt   CLASS_PREFIXt   joint   titlet   getattrt   AttributeErrorRf   Rr   Ry   Ro   RY   t   log_messaget	   log_debugt   orderR   t   operatort
   attrgettert   sort(   Râ   t   pre_order_fixerst   post_order_fixerst   fix_mod_patht   modRE   t   partsR.   t
   class_namet	   fix_classR>   t   key_func(    (    s&   /usr/lib/python2.7/lib2to3/refactor.pyR|   Í   s8    /c         OÄ  s   Ç  d S(   s   Called when an error occurs.N(    (   Râ   t   msgt   argst   kwds(    (    s&   /usr/lib/python2.7/lib2to3/refactor.pyt	   log_error  s    c         GÄ  s'   | r | | } n  |  j  j | É d S(   s   Hook to log a message.N(   Rm   t   info(   Râ   R©   R™   (    (    s&   /usr/lib/python2.7/lib2to3/refactor.pyRõ     s    c         GÄ  s'   | r | | } n  |  j  j | É d  S(   N(   Rm   t   debug(   Râ   R©   R™   (    (    s&   /usr/lib/python2.7/lib2to3/refactor.pyRú     s    c         CÄ  s   d S(   sT   Called with the old version, new version, and filename of a
        refactored file.N(    (   Râ   t   old_textt   new_textt   filenamet   equal(    (    s&   /usr/lib/python2.7/lib2to3/refactor.pyt   print_output!  s    c         CÄ  sP   xI | D]A } t  j j | É r5 |  j | | | É q |  j | | | É q Wd S(   s)   Refactor a list of files and directories.N(   R   R   t   isdirt   refactor_dirt   refactor_file(   Râ   t   itemst   writet   doctests_onlyt   dir_or_file(    (    s&   /usr/lib/python2.7/lib2to3/refactor.pyt   refactor&  s    c         CÄ  sÈ   t  j d } x’ t  j | É D]ƒ \ } } } |  j d | É | j É  | j É  xe | D]] } | j d É rW t  j j | É d | k rW t  j j | | É }	 |  j	 |	 | | É qW qW Wg  | D] }
 |
 j d É sø |
 ^ qø | (q Wd S(   sƒ   Descends down a directory and refactor every Python file found.

        Python files are assumed to have a .py extension.

        Files and subdirectories starting with '.' are skipped.
        t   pys   Descending into %sRB   i   N(
   R   t   extsept   walkRú   R†   R   R   t   splitextRó   R∂   (   Râ   t   dir_nameR∏   Rπ   t   py_extt   dirpatht   dirnamest	   filenamesR   t   fullnamet   dn(    (    s&   /usr/lib/python2.7/lib2to3/refactor.pyRµ   /  s    

c         CÄ  sù   y t  | d É } Wn' t k
 r< } |  j d | | É d SXz t j | j É d } Wd | j É  Xt | d d | Éè } t	 | j
 É  É | f SWd QXd S(   sG   
        Do our best to decode a Python source file correctly.
        t   rbs   Can't open %s: %si    NR-   t   encoding(   NN(   t   opent   IOErrorR¨   R$   R   t   detect_encodingRT   t   closet   _open_with_encodingRK   t   read(   Râ   R±   t   ft   errR»   (    (    s&   /usr/lib/python2.7/lib2to3/refactor.pyt   _read_python_sourceC  s    c         CÄ  s  |  j  | É \ } } | d k r% d S| d 7} | rõ |  j d | É |  j | | É } |  j sl | | k rà |  j | | | | | É q˛ |  j d | É nc |  j | | É } |  j s≈ | rÓ | j rÓ |  j t | É d  | d | d | Én |  j d | É d S(	   s   Refactors a file.Nu   
s   Refactoring doctests in %ss   No doctest changes in %siˇˇˇˇR∏   R»   s   No changes in %s(	   R—   R$   Rú   t   refactor_docstringRj   t   processed_filet   refactor_stringt   was_changedt   unicode(   Râ   R±   R∏   Rπ   RJ   R»   t   outputt   tree(    (    s&   /usr/lib/python2.7/lib2to3/refactor.pyR∂   S  s    
c         CÄ  s∑   t  | É } d | k r* t j |  j _ n  zM y |  j j | É } Wn0 t k
 ru } |  j d | | j j	 | É d SXWd |  j |  j _ X| | _
 |  j d | É |  j | | É | S(   sF  Refactor a given input string.

        Args:
            data: a string holding the code to be refactored.
            name: a human-readable name for use in error/log messages.

        Returns:
            An AST corresponding to the refactored input stream; None if
            there were errors during the parse.
        Ri   s   Can't parse %s: %s: %sNs   Refactoring %s(   Re   R   Rs   R   Rt   t   parse_stringR+   R¨   t	   __class__R   t   future_featuresRú   t   refactor_tree(   Râ   t   dataR   Rb   Rÿ   R–   (    (    s&   /usr/lib/python2.7/lib2to3/refactor.pyR‘   j  s     			c         CÄ  s∆   t  j j É  } | ro |  j d É |  j | d É } |  j sI | | k r_ |  j | d | É q¬ |  j d É nS |  j | d É } |  j sô | rµ | j rµ |  j t	 | É d | É n |  j d É d  S(   Ns   Refactoring doctests in stdins   <stdin>s   No doctest changes in stdins   No changes in stdin(
   t   syst   stdinRŒ   Rú   R“   Rj   R”   R‘   R’   R÷   (   Râ   Rπ   RJ   R◊   Rÿ   (    (    s&   /usr/lib/python2.7/lib2to3/refactor.pyt   refactor_stdinÖ  s    c   
      CÄ  sõ  x- t  |  j |  j É D] } | j | | É q W|  j |  j | j É  É |  j |  j | j É  É |  j j | j	 É  É } xÁt
 | j É  É rcxŒ|  j j D]¿} | | k rú | | rú | | j d t j j d t É | j r˛ | | j d t j j É n  x[t | | É D]F} | | | k r9| | j | É n  y t | É Wn t k
 r]qn X| j r|| | j k r|qn  | j | É } | r| j | | É } | d k	 rU| j | É x9 | j É  D]+ } | j s‰g  | _ n  | j j | É q…W|  j j | j	 É  É } x? | D]4 }	 |	 | k r6g  | |	 <n  | |	 j | |	 É qWqUqqWqú qú Wq} Wx- t  |  j |  j É D] } | j | | É qzW| j  S(   sœ  Refactors a parse tree (modifying the tree in place).

        For compatible patterns the bottom matcher module is
        used. Otherwise the tree is traversed node-to-node for
        matches.

        Args:
            tree: a pytree.Node instance representing the root of the tree
                  to be refactored.
            name: a human-readable name for this tree.

        Returns:
            True if the tree was modified, False otherwise.
        Rë   t   reverseN(!   R   R}   R~   t
   start_treet   traverse_byRá   Rà   RÇ   t   runt   leavest   anyt   valuesRn   R†   R   t   Baset   depthRY   t   keep_line_ordert
   get_linenoR2   t   removeR   t
   ValueErrort   fixers_appliedt   matcht	   transformR$   RI   R   R9   t   finish_treeR’   (
   Râ   Rÿ   R   R>   t	   match_sett   nodet   resultst   newt   new_matchest   fxr(    (    s&   /usr/lib/python2.7/lib2to3/refactor.pyR‹   ï  sJ     		.c         CÄ  sÉ   | s
 d Sxr | D]j } xa | | j  D]R } | j | É } | r% | j | | É } | d k	 rw | j | É | } qw q% q% Wq Wd S(   s  Traverse an AST, applying a set of fixers to each node.

        This is a helper method for refactor_tree().

        Args:
            fixers: a list of fixer instances.
            traversal: a generator that yields AST nodes.

        Returns:
            None
        N(   R#   RÔ   R   R$   RI   (   Râ   Rn   t	   traversalRÛ   R>   RÙ   Rı   (    (    s&   /usr/lib/python2.7/lib2to3/refactor.pyR„   ‰  s    c         CÄ  sΩ   |  j  j | É | d k rB |  j | É d } | d k rB d Sn  | | k } |  j | | | | É | rä |  j d | É |  j sä d Sn  | r© |  j | | | | É n |  j d | É d S(   sR   
        Called when a file has been refactored and there may be changes.
        i    Ns   No changes to %ss   Not writing changes to %s(   R   R   R$   R—   R≥   Rú   Rj   t
   write_file(   Râ   R∞   R±   RØ   R∏   R»   R≤   (    (    s&   /usr/lib/python2.7/lib2to3/refactor.pyR”   ˚  s    	c         CÄ  s∏   y t  | d d | É} Wn* t j k
 rE } |  j d | | É d SXzG y | j t | É É Wn) t j k
 rã } |  j d | | É n XWd | j É  X|  j d | É t |  _	 d S(   s—   Writes a string to a file.

        It first shows a unified diff between the old text and the new text, and
        then rewrites the file; the latter is only done if the write option is
        set.
        t   wR»   s   Can't create %s: %sNs   Can't write %s: %ss   Wrote changes to %s(
   RÕ   R   t   errorR¨   R∏   RM   RÃ   Rú   RY   Rz   (   Râ   R∞   R±   RØ   R»   Rœ   R–   (    (    s&   /usr/lib/python2.7/lib2to3/refactor.pyR˘     s     s   >>> s   ... c   
      CÄ  sá  g  } d } d } d } d } x+| j t É D]} | d 7} | j É  j |  j É r≤ | d k	 rÑ | j |  j | | | | É É n  | } | g } | j |  j É }	 | |	  } q. | d k	 r| j | |  j	 É sÒ | | |  j	 j
 É  d k r| j | É q. | d k	 r/| j |  j | | | | É É n  d } d } | j | É q. W| d k	 rz| j |  j | | | | É É n  d j | É S(   sÀ  Refactors a docstring, looking for doctests.

        This returns a modified version of the input string.  It looks
        for doctests, which start with a ">>>" prompt, and may be
        continued with "..." prompts, as long as the "..." is indented
        the same as the ">>>".

        (Unfortunately we can't use the doctest module's parser,
        since, like most parsers, it is not geared towards preserving
        the original source.)
        i    i   u   
u    N(   R$   t
   splitlinesRY   t   lstripR   t   PS1R9   t   refactor_doctestt   findt   PS2t   rstripR   Ró   (
   Râ   RJ   R±   t   resultt   blockt   block_linenot   indentt   linenot   linet   i(    (    s&   /usr/lib/python2.7/lib2to3/refactor.pyR“   (  s:    
	c   
      CÄ  ss  y |  j  | | | É } Wnu t k
 rê } |  j j t j É rm x* | D] } |  j d | j d É É qG Wn  |  j d | | | j	 j
 | É | SX|  j | | É rot | É j t É } | | d  | | d }	 } |	 d g | d k s¯ t |	 É Ç | d j d É s| d c d 7<n  | |  j | j d É g } | ro| g  | D] } | |  j | ^ qK7} qon  | S(   sﬁ   Refactors one doctest.

        A doctest is given as a block of lines, the first of which starts
        with ">>>" (possibly indented), while the remaining lines start
        with "..." (identically indented).

        s
   Source: %su   
s+   Can't parse docstring in %s line %s: %s: %si   iˇˇˇˇi    (   t   parse_blockR+   Rm   t   isEnabledForRw   t   DEBUGRú   R  R¨   R⁄   R   R‹   R÷   R¸   RY   t   AssertionErrorR   R˛   t   popR  (
   Râ   R  R  R  R±   Rÿ   R–   R  Rı   t   clipped(    (    s&   /usr/lib/python2.7/lib2to3/refactor.pyRˇ   S  s&     	#.c         CÄ  s  |  j  r d } n d } |  j s4 |  j d | É n1 |  j d | É x |  j D] } |  j | É qN W|  j rü |  j d É x! |  j D] } |  j | É qÖ Wn  |  j rt |  j É d k rÕ |  j d É n |  j d t |  j É É x0 |  j D]" \ } } } |  j | | | é q Wn  d  S(	   Nt   weres
   need to bes   No files %s modified.s   Files that %s modified:s$   Warnings/messages while refactoring:i   s   There was 1 error:s   There were %d errors:(   Rz   R   Rõ   Ry   Rv   Rî   (   Râ   R  t   filet   messageR©   R™   R´   (    (    s&   /usr/lib/python2.7/lib2to3/refactor.pyt	   summarizep  s$    					c         CÄ  s1   |  j  j |  j | | | É É } t É  | _ | S(   s≥   Parses a block into a tree.

        This is necessary to get correct line number / offset information
        in the parser diagnostics and embedded into the parse tree.
        (   R   t   parse_tokenst	   wrap_toksRU   R€   (   Râ   R  R  R  Rÿ   (    (    s&   /usr/lib/python2.7/lib2to3/refactor.pyR
  á  s    !c         cÄ  sä   t  j |  j | | É j É } xe | D]] \ } } \ } } \ }	 }
 } | | d 7} |	 | d 7}	 | | | | f |	 |
 f | f Vq% Wd S(   s;   Wraps a tokenize stream to systematically modify start/end.i   N(   R   RR   t	   gen_linesRN   (   Râ   R  R  R  R8   R#   Rd   t   line0t   col0t   line1t   col1t	   line_text(    (    s&   /usr/lib/python2.7/lib2to3/refactor.pyR  ë  s
    (c         cÄ  s¢   | |  j  } | |  j } | } xi | D]a } | j | É rN | t | É Vn4 | | j É  d k rl d Vn t d | | f É Ç | } q' Wx t rù d Vqè Wd S(   sñ   Generates lines as expected by tokenize from a list of lines.

        This strips the first len(indent + self.PS1) characters off each line.
        u   
s   line=%r, prefix=%rRç   N(   R˛   R  R   Rî   R  R  RY   (   Râ   R  R  t   prefix1t   prefix2t   prefixR  (    (    s&   /usr/lib/python2.7/lib2to3/refactor.pyR  ü  s    
	N(   R   R   RC   Rp   Rñ   Rì   R$   Rã   R|   R¨   Rõ   Rú   R≥   Rª   Rµ   R—   R∂   R‘   R‡   R‹   R„   R”   R˘   R˛   R  R“   Rˇ   R  R
  R  R  (    (    (    s&   /usr/lib/python2.7/lib2to3/refactor.pyRh   Æ   s:   

4	(								O		+			
	t   MultiprocessingUnsupportedc           BÄ  s   e  Z RS(    (   R   R   (    (    (    s&   /usr/lib/python2.7/lib2to3/refactor.pyR  ≥  s   t   MultiprocessRefactoringToolc           BÄ  s5   e  Z d  Ñ  Z e e d d Ñ Z d Ñ  Z d Ñ  Z RS(   c         OÄ  s/   t  t |  É j | | é  d  |  _ d  |  _ d  S(   N(   t   superR   Rã   R$   t   queuet   output_lock(   Râ   R™   t   kwargs(    (    s&   /usr/lib/python2.7/lib2to3/refactor.pyRã   π  s    	i   c   	      CÄ  sf  | d k r( t  t |  É j | | | É Sy d d  l } Wn t k
 rQ t Ç n X|  j d  k	 rp t d É Ç n  | j	 É  |  _ | j
 É  |  _ g  t | É D] } | j d |  j É ^ qõ } z; x | D] } | j É  q∆ Wt  t |  É j | | | É Wd  |  j j É  x$ t | É D] } |  j j d  É qWx' | D] } | j É  r5| j É  q5q5Wd  |  _ Xd  S(   Ni   iˇˇˇˇs    already doing multiple processest   target(   R!  R   Rª   t   multiprocessingt   ImportErrorR  R"  R$   t   RuntimeErrort   JoinableQueuet   LockR#  t   xranget   Processt   _childt   startRó   t   putt   is_alive(	   Râ   R∑   R∏   Rπ   t   num_processesR&  R	  t	   processesR.   (    (    s&   /usr/lib/python2.7/lib2to3/refactor.pyRª   æ  s2    
+c         CÄ  so   |  j  j É  } xY | d  k	 rj | \ } } z t t |  É j | | é  Wd  |  j  j É  X|  j  j É  } q Wd  S(   N(   R"  Ru   R$   R!  R   R∂   t	   task_done(   Râ   t   taskR™   R$  (    (    s&   /usr/lib/python2.7/lib2to3/refactor.pyR-  €  s    c         OÄ  sE   |  j  d  k	 r( |  j  j | | f É n t t |  É j | | é  Sd  S(   N(   R"  R$   R/  R!  R   R∂   (   Râ   R™   R$  (    (    s&   /usr/lib/python2.7/lib2to3/refactor.pyR∂   Ê  s    (   R   R   Rã   RC   Rª   R-  R∂   (    (    (    s&   /usr/lib/python2.7/lib2to3/refactor.pyR   ∑  s
   		(-   Rg   t
   __future__R    t
   __author__R   Rﬁ   Rw   Rû   R0   RS   t	   itertoolsR   t   pgen2R   R   R   t
   fixer_utilR   Rç   R   R   R   t   buR	   RÄ   RY   R   R+   R   R(   RA   RF   RH   t   version_infot   codecsR…   RÕ   RK   RM   Re   Rf   t   objectRh   R  R   (    (    (    s&   /usr/lib/python2.7/lib2to3/refactor.pyt   <module>	   sF   							(ˇ ˇ                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               Û
”´[c           @   s   d  S(   N(    (    (    (    s,   /usr/lib/python2.7/lib2to3/fixes/__init__.pyt   <module>   s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 # Copyright 2006 Google, Inc. All Rights Reserved.
# Licensed to PSF under a Contributor Agreement.

"""Fixer for apply().

This converts apply(func, v, k) into (func)(*v, **k)."""

# Local imports
from .. import pytree
from ..pgen2 import token
from .. import fixer_base
from ..fixer_util import Call, Comma, parenthesize

class FixApply(fixer_base.BaseFix):
    BM_compatible = True

    PATTERN = """
    power< 'apply'
        trailer<
            '('
            arglist<
                (not argument<NAME '=' any>) func=any ','
                (not argument<NAME '=' any>) args=any [','
                (not argument<NAME '=' any>) kwds=any] [',']
            >
            ')'
        >
    >
    """

    def transform(self, node, results):
        syms = self.syms
        assert results
        func = results["func"]
        args = results["args"]
        kwds = results.get("kwds")
        # I feel like we should be able to express this logic in the
        # PATTERN above but I don't know how to do it so...
        if args:
            if args.type == self.syms.star_expr:
                return  # Make no change.
            if (args.type == self.syms.argument and
                args.children[0].value == '**'):
                return  # Make no change.
        if kwds and (kwds.type == self.syms.argument and
                     kwds.children[0].value == '**'):
            return  # Make no change.
        prefix = node.prefix
        func = func.clone()
        if (func.type not in (token.NAME, syms.atom) and
            (func.type != syms.power or
             func.children[-2].type == token.DOUBLESTAR)):
            # Need to parenthesize
            func = parenthesize(func)
        func.prefix = ""
        args = args.clone()
        args.prefix = ""
        if kwds is not None:
            kwds = kwds.clone()
            kwds.prefix = ""
        l_newargs = [pytree.Leaf(token.STAR, u"*"), args]
        if kwds is not None:
            l_newargs.extend([Comma(),
                              pytree.Leaf(token.DOUBLESTAR, u"**"),
                              kwds])
            l_newargs[-2].prefix = u" " # that's the ** token
        # XXX Sometimes we could be cleverer, e.g. apply(f, (x, y) + t)
        # can be translated into f(x, y, *t) instead of f(*(x, y) + t)
        #new = pytree.Node(syms.power, (func, ArgList(l_newargs)))
        return Call(func, l_newargs, prefix=prefix)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               Û
”´[c           @   so   d  Z  d d l m Z d d l m Z d d l m Z d d l m Z m Z m	 Z	 d e j
 f d Ñ  É  YZ d S(	   sI   Fixer for apply().

This converts apply(func, v, k) into (func)(*v, **k).i   (   t   pytree(   t   token(   t
   fixer_base(   t   Callt   Commat   parenthesizet   FixApplyc           B   s   e  Z e Z d  Z d Ñ  Z RS(   s.  
    power< 'apply'
        trailer<
            '('
            arglist<
                (not argument<NAME '=' any>) func=any ','
                (not argument<NAME '=' any>) args=any [','
                (not argument<NAME '=' any>) kwds=any] [',']
            >
            ')'
        >
    >
    c   	      C   s‹  |  j  } | s t Ç | d } | d } | j d É } | râ | j |  j  j k rW d  S| j |  j  j k râ | j d j d k râ d  Sn  | ræ | j |  j  j k ræ | j d j d k ræ d  S| j } | j	 É  } | j t
 j | j f k r(| j | j k s| j d j t
 j k r(t | É } n  d | _ | j	 É  } d | _ | d  k	 rj| j	 É  } d | _ n  t j t
 j d É | g } | d  k	 r…| j t É  t j t
 j d	 É | g É d
 | d _ n  t | | d | ÉS(   Nt   funct   argst   kwdsi    s   **i˛ˇˇˇt    u   *u   **u    t   prefix(   t   symst   AssertionErrort   gett   typet	   star_exprt   argumentt   childrent   valueR   t   cloneR   t   NAMEt   atomt   powert
   DOUBLESTARR   t   NoneR    t   Leaft   STARt   extendR   R   (	   t   selft   nodet   resultsR   R   R   R	   R   t	   l_newargs(    (    s-   /usr/lib/python2.7/lib2to3/fixes/fix_apply.pyt	   transform   sB    	

			
(   t   __name__t
   __module__t   Truet   BM_compatiblet   PATTERNR!   (    (    (    s-   /usr/lib/python2.7/lib2to3/fixes/fix_apply.pyR      s   N(   t   __doc__R
   R    t   pgen2R   R   t
   fixer_utilR   R   R   t   BaseFixR   (    (    (    s-   /usr/lib/python2.7/lib2to3/fixes/fix_apply.pyt   <module>   s
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     """Fixer that replaces deprecated unittest method names."""

# Author: Ezio Melotti

from ..fixer_base import BaseFix
from ..fixer_util import Name

NAMES = dict(
    assert_="assertTrue",
    assertEquals="assertEqual",
    assertNotEquals="assertNotEqual",
    assertAlmostEquals="assertAlmostEqual",
    assertNotAlmostEquals="assertNotAlmostEqual",
    assertRegexpMatches="assertRegex",
    assertRaisesRegexp="assertRaisesRegex",
    failUnlessEqual="assertEqual",
    failIfEqual="assertNotEqual",
    failUnlessAlmostEqual="assertAlmostEqual",
    failIfAlmostEqual="assertNotAlmostEqual",
    failUnless="assertTrue",
    failUnlessRaises="assertRaises",
    failIf="assertFalse",
)


class FixAsserts(BaseFix):

    PATTERN = """
              power< any+ trailer< '.' meth=(%s)> any* >
              """ % '|'.join(map(repr, NAMES))

    def transform(self, node, results):
        name = results["meth"][0]
        name.replace(Name(NAMES[str(name)], prefix=name.prefix))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        Û
”´[c           @   sù   d  Z  d d l m Z d d l m Z e d d d d d d	 d
 d d d d d d d d d d d	 d d d d d d d d d d É Z d e f d Ñ  É  YZ d S(   s5   Fixer that replaces deprecated unittest method names.i   (   t   BaseFix(   t   Namet   assert_t
   assertTruet   assertEqualst   assertEqualt   assertNotEqualst   assertNotEqualt   assertAlmostEqualst   assertAlmostEqualt   assertNotAlmostEqualst   assertNotAlmostEqualt   assertRegexpMatchest   assertRegext   assertRaisesRegexpt   assertRaisesRegext   failUnlessEqualt   failIfEqualt   failUnlessAlmostEqualt   failIfAlmostEqualt
   failUnlesst   failUnlessRaisest   assertRaisest   failIft   assertFalset
   FixAssertsc           B   s-   e  Z d  d j e e e É É Z d Ñ  Z RS(   sH   
              power< any+ trailer< '.' meth=(%s)> any* >
              t   |c         C   s8   | d d } | j  t t t | É d | j ÉÉ d  S(   Nt   methi    t   prefix(   t   replaceR   t   NAMESt   strR   (   t   selft   nodet   resultst   name(    (    s/   /usr/lib/python2.7/lib2to3/fixes/fix_asserts.pyt	   transform    s    (   t   __name__t
   __module__t   joint   mapt   reprR   t   PATTERNR$   (    (    (    s/   /usr/lib/python2.7/lib2to3/fixes/fix_asserts.pyR      s   N(   t   __doc__t
   fixer_baseR    t
   fixer_utilR   t   dictR   R   (    (    (    s/   /usr/lib/python2.7/lib2to3/fixes/fix_asserts.pyt   <module>   s$   	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             """Fixer for basestring -> str."""
# Author: Christian Heimes

# Local imports
from .. import fixer_base
from ..fixer_util import Name

class FixBasestring(fixer_base.BaseFix):
    BM_compatible = True

    PATTERN = "'basestring'"

    def transform(self, node, results):
        return Name(u"str", prefix=node.prefix)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               Û
”´[c           @   sC   d  Z  d d l m Z d d l m Z d e j f d Ñ  É  YZ d S(   s   Fixer for basestring -> str.i   (   t
   fixer_base(   t   Namet   FixBasestringc           B   s   e  Z e Z d  Z d Ñ  Z RS(   s   'basestring'c         C   s   t  d d | j ÉS(   Nu   strt   prefix(   R   R   (   t   selft   nodet   results(    (    s2   /usr/lib/python2.7/lib2to3/fixes/fix_basestring.pyt	   transform   s    (   t   __name__t
   __module__t   Truet   BM_compatiblet   PATTERNR   (    (    (    s2   /usr/lib/python2.7/lib2to3/fixes/fix_basestring.pyR      s   N(   t   __doc__t    R    t
   fixer_utilR   t   BaseFixR   (    (    (    s2   /usr/lib/python2.7/lib2to3/fixes/fix_basestring.pyt   <module>   s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  # Copyright 2007 Google, Inc. All Rights Reserved.
# Licensed to PSF under a Contributor Agreement.

"""Fixer that changes buffer(...) into memoryview(...)."""

# Local imports
from .. import fixer_base
from ..fixer_util import Name


class FixBuffer(fixer_base.BaseFix):
    BM_compatible = True

    explicit = True # The user must ask for this fixer

    PATTERN = """
              power< name='buffer' trailer< '(' [any] ')' > any* >
              """

    def transform(self, node, results):
        name = results["name"]
        name.replace(Name(u"memoryview", prefix=name.prefix))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 Û
”´[c           @   sC   d  Z  d d l m Z d d l m Z d e j f d Ñ  É  YZ d S(   s4   Fixer that changes buffer(...) into memoryview(...).i   (   t
   fixer_base(   t   Namet	   FixBufferc           B   s#   e  Z e Z e Z d  Z d Ñ  Z RS(   sR   
              power< name='buffer' trailer< '(' [any] ')' > any* >
              c         C   s*   | d } | j  t d d | j ÉÉ d  S(   Nt   nameu
   memoryviewt   prefix(   t   replaceR   R   (   t   selft   nodet   resultsR   (    (    s.   /usr/lib/python2.7/lib2to3/fixes/fix_buffer.pyt	   transform   s    
(   t   __name__t
   __module__t   Truet   BM_compatiblet   explicitt   PATTERNR	   (    (    (    s.   /usr/lib/python2.7/lib2to3/fixes/fix_buffer.pyR      s   N(   t   __doc__t    R    t
   fixer_utilR   t   BaseFixR   (    (    (    s.   /usr/lib/python2.7/lib2to3/fixes/fix_buffer.pyt   <module>   s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     # Copyright 2007 Google, Inc. All Rights Reserved.
# Licensed to PSF under a Contributor Agreement.

"""Fixer for dict methods.

d.keys() -> list(d.keys())
d.items() -> list(d.items())
d.values() -> list(d.values())

d.iterkeys() -> iter(d.keys())
d.iteritems() -> iter(d.items())
d.itervalues() -> iter(d.values())

d.viewkeys() -> d.keys()
d.viewitems() -> d.items()
d.viewvalues() -> d.values()

Except in certain very specific contexts: the iter() can be dropped
when the context is list(), sorted(), iter() or for...in; the list()
can be dropped when the context is list() or sorted() (but not iter()
or for...in!). Special contexts that apply to both: list(), sorted(), tuple()
set(), any(), all(), sum().

Note: iter(d.keys()) could be written as iter(d) but since the
original d.iterkeys() was also redundant we don't fix this.  And there
are (rare) contexts where it makes a difference (e.g. when passing it
as an argument to a function that introspects the argument).
"""

# Local imports
from .. import pytree
from .. import patcomp
from ..pgen2 import token
from .. import fixer_base
from ..fixer_util import Name, Call, LParen, RParen, ArgList, Dot
from .. import fixer_util


iter_exempt = fixer_util.consuming_calls | set(["iter"])


class FixDict(fixer_base.BaseFix):
    BM_compatible = True

    PATTERN = """
    power< head=any+
         trailer< '.' method=('keys'|'items'|'values'|
                              'iterkeys'|'iteritems'|'itervalues'|
                              'viewkeys'|'viewitems'|'viewvalues') >
         parens=trailer< '(' ')' >
         tail=any*
    >
    """

    def transform(self, node, results):
        head = results["head"]
        method = results["method"][0] # Extract node for method name
        tail = results["tail"]
        syms = self.syms
        method_name = method.value
        isiter = method_name.startswith(u"iter")
        isview = method_name.startswith(u"view")
        if isiter or isview:
            method_name = method_name[4:]
        assert method_name in (u"keys", u"items", u"values"), repr(method)
        head = [n.clone() for n in head]
        tail = [n.clone() for n in tail]
        special = not tail and self.in_special_context(node, isiter)
        args = head + [pytree.Node(syms.trailer,
                                   [Dot(),
                                    Name(method_name,
                                         prefix=method.prefix)]),
                       results["parens"].clone()]
        new = pytree.Node(syms.power, args)
        if not (special or isview):
            new.prefix = u""
            new = Call(Name(u"iter" if isiter else u"list"), [new])
        if tail:
            new = pytree.Node(syms.power, [new] + tail)
        new.prefix = node.prefix
        return new

    P1 = "power< func=NAME trailer< '(' node=any ')' > any* >"
    p1 = patcomp.compile_pattern(P1)

    P2 = """for_stmt< 'for' any 'in' node=any ':' any* >
            | comp_for< 'for' any 'in' node=any any* >
         """
    p2 = patcomp.compile_pattern(P2)

    def in_special_context(self, node, isiter):
        if node.parent is None:
            return False
        results = {}
        if (node.parent.parent is not None and
               self.p1.match(node.parent.parent, results) and
               results["node"] is node):
            if isiter:
                # iter(d.iterkeys()) -> iter(d.keys()), etc.
                return results["func"].value in iter_exempt
            else:
                # list(d.keys()) -> list(d.keys()), etc.
                return results["func"].value in fixer_util.consuming_calls
        if not isiter:
            return False
        # for ... in d.iterkeys() -> for ... in d.keys(), etc.
        return self.p2.match(node.parent, results) and results["node"] is node
                                                                                                                                                                                                                                                                                Û
”´[c           @   s∑   d  Z  d d l m Z d d l m Z d d l m Z d d l m Z d d l m Z m	 Z	 m
 Z
 m Z m Z m Z d d l m Z e j e d g É BZ d	 e j f d
 Ñ  É  YZ d S(   sj  Fixer for dict methods.

d.keys() -> list(d.keys())
d.items() -> list(d.items())
d.values() -> list(d.values())

d.iterkeys() -> iter(d.keys())
d.iteritems() -> iter(d.items())
d.itervalues() -> iter(d.values())

d.viewkeys() -> d.keys()
d.viewitems() -> d.items()
d.viewvalues() -> d.values()

Except in certain very specific contexts: the iter() can be dropped
when the context is list(), sorted(), iter() or for...in; the list()
can be dropped when the context is list() or sorted() (but not iter()
or for...in!). Special contexts that apply to both: list(), sorted(), tuple()
set(), any(), all(), sum().

Note: iter(d.keys()) could be written as iter(d) but since the
original d.iterkeys() was also redundant we don't fix this.  And there
are (rare) contexts where it makes a difference (e.g. when passing it
as an argument to a function that introspects the argument).
i   (   t   pytree(   t   patcomp(   t   token(   t
   fixer_base(   t   Namet   Callt   LParent   RParent   ArgListt   Dot(   t
   fixer_utilt   itert   FixDictc           B   sP   e  Z e Z d  Z d Ñ  Z d Z e j e É Z	 d Z
 e j e
 É Z d Ñ  Z RS(   s  
    power< head=any+
         trailer< '.' method=('keys'|'items'|'values'|
                              'iterkeys'|'iteritems'|'itervalues'|
                              'viewkeys'|'viewitems'|'viewvalues') >
         parens=trailer< '(' ')' >
         tail=any*
    >
    c         C   sß  | d } | d d } | d } |  j  } | j } | j d É } | j d É }	 | s^ |	 rk | d } n  | d k sâ t t | É É Ç g  | D] }
 |
 j É  ^ qê } g  | D] }
 |
 j É  ^ qØ } | o› |  j | | É } | t j | j	 t
 É  t | d | j Ég É | d j É  g } t j | j | É } | p?|	 srd | _ t t | r]d n d É | g É } n  | rót j | j | g | É } n  | j | _ | S(   Nt   headt   methodi    t   tailu   iteru   viewi   u   keysu   itemsu   valuest   prefixt   parensu    u   list(   u   keysu   itemsu   values(   t   symst   valuet
   startswitht   AssertionErrort   reprt   clonet   in_special_contextR    t   Nodet   trailerR	   R   R   t   powerR   (   t   selft   nodet   resultsR   R   R   R   t   method_namet   isitert   isviewt   nt   specialt   argst   new(    (    s,   /usr/lib/python2.7/lib2to3/fixes/fix_dict.pyt	   transform7   s4    

				's3   power< func=NAME trailer< '(' node=any ')' > any* >sm   for_stmt< 'for' any 'in' node=any ':' any* >
            | comp_for< 'for' any 'in' node=any any* >
         c         C   s¥   | j  d  k r t Si  } | j  j  d  k	 rÑ |  j j | j  j  | É rÑ | d | k rÑ | rm | d j t k S| d j t j k Sn  | sé t S|  j	 j | j  | É o≥ | d | k S(   NR   t   func(
   t   parentt   Nonet   Falset   p1t   matchR   t   iter_exemptR
   t   consuming_callst   p2(   R   R   R    R   (    (    s,   /usr/lib/python2.7/lib2to3/fixes/fix_dict.pyR   [   s    (   t   __name__t
   __module__t   Truet   BM_compatiblet   PATTERNR&   t   P1R   t   compile_patternR+   t   P2R/   R   (    (    (    s,   /usr/lib/python2.7/lib2to3/fixes/fix_dict.pyR   *   s   
	N(   t   __doc__t    R    R   t   pgen2R   R   R
   R   R   R   R   R   R	   R.   t   setR-   t   BaseFixR   (    (    (    s,   /usr/lib/python2.7/lib2to3/fixes/fix_dict.pyt   <module>   s   .                                                                                                                                                                                                                                                                                                                                               """Fixer for except statements with named exceptions.

The following cases will be converted:

- "except E, T:" where T is a name:

    except E as T:

- "except E, T:" where T is not a name, tuple or list:

        except E as t:
            T = t

    This is done because the target of an "except" clause must be a
    name.

- "except E, T:" where T is a tuple or list literal:

        except E as t:
            T = t.args
"""
# Author: Collin Winter

# Local imports
from .. import pytree
from ..pgen2 import token
from .. import fixer_base
from ..fixer_util import Assign, Attr, Name, is_tuple, is_list, syms

def find_excepts(nodes):
    for i, n in enumerate(nodes):
        if n.type == syms.except_clause:
            if n.children[0].value == u'except':
                yield (n, nodes[i+2])

class FixExcept(fixer_base.BaseFix):
    BM_compatible = True

    PATTERN = """
    try_stmt< 'try' ':' (simple_stmt | suite)
                  cleanup=(except_clause ':' (simple_stmt | suite))+
                  tail=(['except' ':' (simple_stmt | suite)]
                        ['else' ':' (simple_stmt | suite)]
                        ['finally' ':' (simple_stmt | suite)]) >
    """

    def transform(self, node, results):
        syms = self.syms

        tail = [n.clone() for n in results["tail"]]

        try_cleanup = [ch.clone() for ch in results["cleanup"]]
        for except_clause, e_suite in find_excepts(try_cleanup):
            if len(except_clause.children) == 4:
                (E, comma, N) = except_clause.children[1:4]
                comma.replace(Name(u"as", prefix=u" "))

                if N.type != token.NAME:
                    # Generate a new N for the except clause
                    new_N = Name(self.new_name(), prefix=u" ")
                    target = N.clone()
                    target.prefix = u""
                    N.replace(new_N)
                    new_N = new_N.clone()

                    # Insert "old_N = new_N" as the first statement in
                    #  the except body. This loop skips leading whitespace
                    #  and indents
                    #TODO(cwinter) suite-cleanup
                    suite_stmts = e_suite.children
                    for i, stmt in enumerate(suite_stmts):
                        if isinstance(stmt, pytree.Node):
                            break

                    # The assignment is different if old_N is a tuple or list
                    # In that case, the assignment is old_N = new_N.args
                    if is_tuple(N) or is_list(N):
                        assign = Assign(target, Attr(new_N, Name(u'args')))
                    else:
                        assign = Assign(target, new_N)

                    #TODO(cwinter) stopgap until children becomes a smart list
                    for child in reversed(suite_stmts[:i]):
                        e_suite.insert_child(0, child)
                    e_suite.insert_child(i, assign)
                elif N.prefix == u"":
                    # No space after a comma is legal; no space after "as",
                    # not so much.
                    N.prefix = u" "

        #TODO(cwinter) fix this when children becomes a smart list
        children = [c.clone() for c in node.children[:3]] + try_cleanup + tail
        return pytree.Node(node.type, children)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        Û
”´[c           @   sä   d  Z  d d l m Z d d l m Z d d l m Z d d l m Z m Z m	 Z	 m
 Z
 m Z m Z d Ñ  Z d e j f d Ñ  É  YZ d	 S(
   s™  Fixer for except statements with named exceptions.

The following cases will be converted:

- "except E, T:" where T is a name:

    except E as T:

- "except E, T:" where T is not a name, tuple or list:

        except E as t:
            T = t

    This is done because the target of an "except" clause must be a
    name.

- "except E, T:" where T is a tuple or list literal:

        except E as t:
            T = t.args
i   (   t   pytree(   t   token(   t
   fixer_base(   t   Assignt   Attrt   Namet   is_tuplet   is_listt   symsc         c   sb   x[ t  |  É D]M \ } } | j t j k r | j d j d k rZ | |  | d f VqZ q q Wd  S(   Ni    u   excepti   (   t	   enumeratet   typeR   t   except_clauset   childrent   value(   t   nodest   it   n(    (    s.   /usr/lib/python2.7/lib2to3/fixes/fix_except.pyt   find_excepts   s    t	   FixExceptc           B   s   e  Z e Z d  Z d Ñ  Z RS(   s1  
    try_stmt< 'try' ':' (simple_stmt | suite)
                  cleanup=(except_clause ':' (simple_stmt | suite))+
                  tail=(['except' ':' (simple_stmt | suite)]
                        ['else' ':' (simple_stmt | suite)]
                        ['finally' ':' (simple_stmt | suite)]) >
    c         C   s,  |  j  } g  | d D] } | j É  ^ q } g  | d D] } | j É  ^ q7 } xôt | É D]ã\ } }	 t | j É d k r\ | j d d !\ }
 } } | j t d d d ÉÉ | j t j	 k r…t |  j
 É  d d É} | j É  } d | _ | j | É | j É  } |	 j } x0 t | É D]" \ } } t | t j É rPqqWt | É s[t | É r|t | t | t d	 É É É } n t | | É } x( t | |  É D] } |	 j d
 | É qúW|	 j | | É qÁ| j d k rÁd | _ qÁq\ q\ Wg  | j d  D] } | j É  ^ q˘| | } t j | j | É S(   Nt   tailt   cleanupi   i   u   ast   prefixu    u    u   argsi    i   (   R   t   cloneR   t   lenR   t   replaceR   R
   R   t   NAMEt   new_nameR   R	   t
   isinstanceR    t   NodeR   R   R   R   t   reversedt   insert_child(   t   selft   nodet   resultsR   R   R   t   cht   try_cleanupR   t   e_suitet   Et   commat   Nt   new_Nt   targett   suite_stmtsR   t   stmtt   assignt   childt   cR   (    (    s.   /usr/lib/python2.7/lib2to3/fixes/fix_except.pyt	   transform/   s6    	##		!.(   t   __name__t
   __module__t   Truet   BM_compatiblet   PATTERNR/   (    (    (    s.   /usr/lib/python2.7/lib2to3/fixes/fix_except.pyR   $   s   N(   t   __doc__t    R    t   pgen2R   R   t
   fixer_utilR   R   R   R   R   R   R   t   BaseFixR   (    (    (    s.   /usr/lib/python2.7/lib2to3/fixes/fix_except.pyt   <module>   s   .	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       # Copyright 2006 Google, Inc. All Rights Reserved.
# Licensed to PSF under a Contributor Agreement.

"""Fixer for exec.

This converts usages of the exec statement into calls to a built-in
exec() function.

exec code in ns1, ns2 -> exec(code, ns1, ns2)
"""

# Local imports
from .. import pytree
from .. import fixer_base
from ..fixer_util import Comma, Name, Call


class FixExec(fixer_base.BaseFix):
    BM_compatible = True

    PATTERN = """
    exec_stmt< 'exec' a=any 'in' b=any [',' c=any] >
    |
    exec_stmt< 'exec' (not atom<'(' [any] ')'>) a=any >
    """

    def transform(self, node, results):
        assert results
        syms = self.syms
        a = results["a"]
        b = results.get("b")
        c = results.get("c")
        args = [a.clone()]
        args[0].prefix = ""
        if b is not None:
            args.extend([Comma(), b.clone()])
        if c is not None:
            args.extend([Comma(), c.clone()])

        return Call(Name(u"exec"), args, prefix=node.prefix)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      Û
”´[c           @   s_   d  Z  d d l m Z d d l m Z d d l m Z m Z m Z d e j f d Ñ  É  YZ	 d S(   sï   Fixer for exec.

This converts usages of the exec statement into calls to a built-in
exec() function.

exec code in ns1, ns2 -> exec(code, ns1, ns2)
i   (   t   pytree(   t
   fixer_base(   t   Commat   Namet   Callt   FixExecc           B   s   e  Z e Z d  Z d Ñ  Z RS(   sx   
    exec_stmt< 'exec' a=any 'in' b=any [',' c=any] >
    |
    exec_stmt< 'exec' (not atom<'(' [any] ')'>) a=any >
    c         C   sÀ   | s t  Ç |  j } | d } | j d É } | j d É } | j É  g } d | d _ | d  k	 rÑ | j t É  | j É  g É n  | d  k	 rØ | j t É  | j É  g É n  t t	 d É | d | j ÉS(   Nt   at   bt   ct    i    u   exect   prefix(
   t   AssertionErrort   symst   gett   cloneR
   t   Nonet   extendR   R   R   (   t   selft   nodet   resultsR   R   R   R   t   args(    (    s,   /usr/lib/python2.7/lib2to3/fixes/fix_exec.pyt	   transform   s    	
(   t   __name__t
   __module__t   Truet   BM_compatiblet   PATTERNR   (    (    (    s,   /usr/lib/python2.7/lib2to3/fixes/fix_exec.pyR      s   N(
   t   __doc__R	   R    R   t
   fixer_utilR   R   R   t   BaseFixR   (    (    (    s,   /usr/lib/python2.7/lib2to3/fixes/fix_exec.pyt   <module>
   s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 # Copyright 2006 Google, Inc. All Rights Reserved.
# Licensed to PSF under a Contributor Agreement.

"""Fixer for execfile.

This converts usages of the execfile function into calls to the built-in
exec() function.
"""

from .. import fixer_base
from ..fixer_util import (Comma, Name, Call, LParen, RParen, Dot, Node,
                          ArgList, String, syms)


class FixExecfile(fixer_base.BaseFix):
    BM_compatible = True

    PATTERN = """
    power< 'execfile' trailer< '(' arglist< filename=any [',' globals=any [',' locals=any ] ] > ')' > >
    |
    power< 'execfile' trailer< '(' filename=any ')' > >
    """

    def transform(self, node, results):
        assert results
        filename = results["filename"]
        globals = results.get("globals")
        locals = results.get("locals")

        # Copy over the prefix from the right parentheses end of the execfile
        # call.
        execfile_paren = node.children[-1].children[-1].clone()
        # Construct open().read().
        open_args = ArgList([filename.clone()], rparen=execfile_paren)
        open_call = Node(syms.power, [Name(u"open"), open_args])
        read = [Node(syms.trailer, [Dot(), Name(u'read')]),
                Node(syms.trailer, [LParen(), RParen()])]
        open_expr = [open_call] + read
        # Wrap the open call in a compile call. This is so the filename will be
        # preserved in the execed code.
        filename_arg = filename.clone()
        filename_arg.prefix = u" "
        exec_str = String(u"'exec'", u" ")
        compile_args = open_expr + [Comma(), filename_arg, Comma(), exec_str]
        compile_call = Call(Name(u"compile"), compile_args, u"")
        # Finally, replace the execfile call with an exec call.
        args = [compile_call]
        if globals is not None:
            args.extend([Comma(), globals.clone()])
        if locals is not None:
            args.extend([Comma(), locals.clone()])
        return Call(Name(u"exec"), args, prefix=node.prefix)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  Û
”´[c           @   sy   d  Z  d d l m Z d d l m Z m Z m Z m Z m Z m	 Z	 m
 Z
 m Z m Z m Z d e j f d Ñ  É  YZ d S(   so   Fixer for execfile.

This converts usages of the execfile function into calls to the built-in
exec() function.
i   (   t
   fixer_base(
   t   Commat   Namet   Callt   LParent   RParent   Dott   Nodet   ArgListt   Stringt   symst   FixExecfilec           B   s   e  Z e Z d  Z d Ñ  Z RS(   s´   
    power< 'execfile' trailer< '(' arglist< filename=any [',' globals=any [',' locals=any ] ] > ')' > >
    |
    power< 'execfile' trailer< '(' filename=any ')' > >
    c         C   s¶  | s t  Ç | d } | j d É } | j d É } | j d j d j É  } t | j É  g d | É} t t j t d É | g É } t t j	 t
 É  t d É g É t t j	 t É  t É  g É g }	 | g |	 }
 | j É  } d | _ t d	 d É } |
 t É  | t É  | g } t t d
 É | d É } | g } | d  k	 r_| j t É  | j É  g É n  | d  k	 rä| j t É  | j É  g É n  t t d É | d | j ÉS(   Nt   filenamet   globalst   localsiˇˇˇˇt   rparenu   openu   readu    u   'exec'u   compileu    u   exect   prefix(   t   AssertionErrort   gett   childrent   cloneR   R   R
   t   powerR   t   trailerR   R   R   R   R	   R   R   t   Nonet   extend(   t   selft   nodet   resultsR   R   R   t   execfile_parent	   open_argst	   open_callt   readt	   open_exprt   filename_argt   exec_strt   compile_argst   compile_callt   args(    (    s0   /usr/lib/python2.7/lib2to3/fixes/fix_execfile.pyt	   transform   s*    
!		(   t   __name__t
   __module__t   Truet   BM_compatiblet   PATTERNR&   (    (    (    s0   /usr/lib/python2.7/lib2to3/fixes/fix_execfile.pyR      s   N(   t   __doc__t    R    t
   fixer_utilR   R   R   R   R   R   R   R   R	   R
   t   BaseFixR   (    (    (    s0   /usr/lib/python2.7/lib2to3/fixes/fix_execfile.pyt   <module>   s   F                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             """
Convert use of sys.exitfunc to use the atexit module.
"""

# Author: Benjamin Peterson

from lib2to3 import pytree, fixer_base
from lib2to3.fixer_util import Name, Attr, Call, Comma, Newline, syms


class FixExitfunc(fixer_base.BaseFix):
    keep_line_order = True
    BM_compatible = True

    PATTERN = """
              (
                  sys_import=import_name<'import'
                      ('sys'
                      |
                      dotted_as_names< (any ',')* 'sys' (',' any)* >
                      )
                  >
              |
                  expr_stmt<
                      power< 'sys' trailer< '.' 'exitfunc' > >
                  '=' func=any >
              )
              """

    def __init__(self, *args):
        super(FixExitfunc, self).__init__(*args)

    def start_tree(self, tree, filename):
        super(FixExitfunc, self).start_tree(tree, filename)
        self.sys_import = None

    def transform(self, node, results):
        # First, find the sys import. We'll just hope it's global scope.
        if "sys_import" in results:
            if self.sys_import is None:
                self.sys_import = results["sys_import"]
            return

        func = results["func"].clone()
        func.prefix = u""
        register = pytree.Node(syms.power,
                               Attr(Name(u"atexit"), Name(u"register"))
                               )
        call = Call(register, [func], node.prefix)
        node.replace(call)

        if self.sys_import is None:
            # That's interesting.
            self.warning(node, "Can't find sys import; Please add an atexit "
                             "import at the top of your file.")
            return

        # Now add an atexit import after the sys import.
        names = self.sys_import.children[1]
        if names.type == syms.dotted_as_names:
            names.append_child(Comma())
            names.append_child(Name(u"atexit", u" "))
        else:
            containing_stmt = self.sys_import.parent
            position = containing_stmt.children.index(self.sys_import)
            stmt_container = containing_stmt.parent
            new_import = pytree.Node(syms.import_name,
                              [Name(u"import"), Name(u"atexit", u" ")]
                              )
            new = pytree.Node(syms.simple_stmt, [new_import])
            containing_stmt.insert_child(position + 1, Newline())
            containing_stmt.insert_child(position + 2, new)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         Û
”´[c           @   sg   d  Z  d d l m Z m Z d d l m Z m Z m Z m Z m	 Z	 m
 Z
 d e j f d Ñ  É  YZ d S(   s7   
Convert use of sys.exitfunc to use the atexit module.
iˇˇˇˇ(   t   pytreet
   fixer_base(   t   Namet   Attrt   Callt   Commat   Newlinet   symst   FixExitfuncc           B   s5   e  Z e Z e Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   sî  
              (
                  sys_import=import_name<'import'
                      ('sys'
                      |
                      dotted_as_names< (any ',')* 'sys' (',' any)* >
                      )
                  >
              |
                  expr_stmt<
                      power< 'sys' trailer< '.' 'exitfunc' > >
                  '=' func=any >
              )
              c         G   s   t  t |  É j | å  d  S(   N(   t   superR   t   __init__(   t   selft   args(    (    s0   /usr/lib/python2.7/lib2to3/fixes/fix_exitfunc.pyR
      s    c         C   s&   t  t |  É j | | É d  |  _ d  S(   N(   R	   R   t
   start_treet   Nonet
   sys_import(   R   t   treet   filename(    (    s0   /usr/lib/python2.7/lib2to3/fixes/fix_exitfunc.pyR   !   s    c         C   s†  d | k r/ |  j  d  k r+ | d |  _  n  d  S| d j É  } d | _ t j t j t t	 d É t	 d É É É } t
 | | g | j É } | j | É |  j  d  k r∫ |  j | d É d  S|  j  j d } | j t j k r| j t É  É | j t	 d d É É nó |  j  j } | j j |  j  É } | j }	 t j t j t	 d	 É t	 d d É g É }
 t j t j |
 g É } | j | d t É  É | j | d
 | É d  S(   NR   t   funcu    u   atexitu   registersK   Can't find sys import; Please add an atexit import at the top of your file.i   u    u   importi   (   R   R   t   clonet   prefixR    t   NodeR   t   powerR   R   R   t   replacet   warningt   childrent   typet   dotted_as_namest   append_childR   t   parentt   indext   import_namet   simple_stmtt   insert_childR   (   R   t   nodet   resultsR   t   registert   callt   namest   containing_stmtt   positiont   stmt_containert
   new_importt   new(    (    s0   /usr/lib/python2.7/lib2to3/fixes/fix_exitfunc.pyt	   transform%   s2    		(	   t   __name__t
   __module__t   Truet   keep_line_ordert   BM_compatiblet   PATTERNR
   R   R,   (    (    (    s0   /usr/lib/python2.7/lib2to3/fixes/fix_exitfunc.pyR      s   		N(   t   __doc__t   lib2to3R    R   t   lib2to3.fixer_utilR   R   R   R   R   R   t   BaseFixR   (    (    (    s0   /usr/lib/python2.7/lib2to3/fixes/fix_exitfunc.pyt   <module>   s   .                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     # Copyright 2007 Google, Inc. All Rights Reserved.
# Licensed to PSF under a Contributor Agreement.

"""Fixer that changes filter(F, X) into list(filter(F, X)).

We avoid the transformation if the filter() call is directly contained
in iter(<>), list(<>), tuple(<>), sorted(<>), ...join(<>), or
for V in <>:.

NOTE: This is still not correct if the original code was depending on
filter(F, X) to return a string if X is a string and a tuple if X is a
tuple.  That would require type inference, which we don't do.  Let
Python 2.6 figure it out.
"""

# Local imports
from ..pgen2 import token
from .. import fixer_base
from ..fixer_util import Name, Call, ListComp, in_special_context

class FixFilter(fixer_base.ConditionalFix):
    BM_compatible = True

    PATTERN = """
    filter_lambda=power<
        'filter'
        trailer<
            '('
            arglist<
                lambdef< 'lambda'
                         (fp=NAME | vfpdef< '(' fp=NAME ')'> ) ':' xp=any
                >
                ','
                it=any
            >
            ')'
        >
    >
    |
    power<
        'filter'
        trailer< '(' arglist< none='None' ',' seq=any > ')' >
    >
    |
    power<
        'filter'
        args=trailer< '(' [any] ')' >
    >
    """

    skip_on = "future_builtins.filter"

    def transform(self, node, results):
        if self.should_skip(node):
            return

        if "filter_lambda" in results:
            new = ListComp(results.get("fp").clone(),
                           results.get("fp").clone(),
                           results.get("it").clone(),
                           results.get("xp").clone())

        elif "none" in results:
            new = ListComp(Name(u"_f"),
                           Name(u"_f"),
                           results["seq"].clone(),
                           Name(u"_f"))

        else:
            if in_special_context(node):
                return None
            new = node.clone()
            new.prefix = u""
            new = Call(Name(u"list"), [new])
        new.prefix = node.prefix
        return new
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     Û
”´[c           @   se   d  Z  d d l m Z d d l m Z d d l m Z m Z m Z m	 Z	 d e j
 f d Ñ  É  YZ d S(   s∏  Fixer that changes filter(F, X) into list(filter(F, X)).

We avoid the transformation if the filter() call is directly contained
in iter(<>), list(<>), tuple(<>), sorted(<>), ...join(<>), or
for V in <>:.

NOTE: This is still not correct if the original code was depending on
filter(F, X) to return a string if X is a string and a tuple if X is a
tuple.  That would require type inference, which we don't do.  Let
Python 2.6 figure it out.
i   (   t   token(   t
   fixer_base(   t   Namet   Callt   ListCompt   in_special_contextt	   FixFilterc           B   s#   e  Z e Z d  Z d Z d Ñ  Z RS(   s  
    filter_lambda=power<
        'filter'
        trailer<
            '('
            arglist<
                lambdef< 'lambda'
                         (fp=NAME | vfpdef< '(' fp=NAME ')'> ) ':' xp=any
                >
                ','
                it=any
            >
            ')'
        >
    >
    |
    power<
        'filter'
        trailer< '(' arglist< none='None' ',' seq=any > ')' >
    >
    |
    power<
        'filter'
        args=trailer< '(' [any] ')' >
    >
    s   future_builtins.filterc         C   s   |  j  | É r d  Sd | k rs t | j d É j É  | j d É j É  | j d É j É  | j d É j É  É } n} d | k r≥ t t d É t d É | d j É  t d É É } n= t | É r√ d  S| j É  } d | _ t t d	 É | g É } | j | _ | S(
   Nt   filter_lambdat   fpt   itt   xpt   noneu   _ft   sequ    u   list(	   t   should_skipR   t   gett   cloneR   R   t   Nonet   prefixR   (   t   selft   nodet   resultst   new(    (    s.   /usr/lib/python2.7/lib2to3/fixes/fix_filter.pyt	   transform5   s&    		(   t   __name__t
   __module__t   Truet   BM_compatiblet   PATTERNt   skip_onR   (    (    (    s.   /usr/lib/python2.7/lib2to3/fixes/fix_filter.pyR      s   N(   t   __doc__t   pgen2R    t    R   t
   fixer_utilR   R   R   R   t   ConditionalFixR   (    (    (    s.   /usr/lib/python2.7/lib2to3/fixes/fix_filter.pyt   <module>   s   "                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        """Fix function attribute names (f.func_x -> f.__x__)."""
# Author: Collin Winter

# Local imports
from .. import fixer_base
from ..fixer_util import Name


class FixFuncattrs(fixer_base.BaseFix):
    BM_compatible = True

    PATTERN = """
    power< any+ trailer< '.' attr=('func_closure' | 'func_doc' | 'func_globals'
                                  | 'func_name' | 'func_defaults' | 'func_code'
                                  | 'func_dict') > any* >
    """

    def transform(self, node, results):
        attr = results["attr"][0]
        attr.replace(Name((u"__%s__" % attr.value[5:]),
                          prefix=attr.prefix))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Û
”´[c           @   sC   d  Z  d d l m Z d d l m Z d e j f d Ñ  É  YZ d S(   s3   Fix function attribute names (f.func_x -> f.__x__).i   (   t
   fixer_base(   t   Namet   FixFuncattrsc           B   s   e  Z e Z d  Z d Ñ  Z RS(   sﬂ   
    power< any+ trailer< '.' attr=('func_closure' | 'func_doc' | 'func_globals'
                                  | 'func_name' | 'func_defaults' | 'func_code'
                                  | 'func_dict') > any* >
    c         C   s9   | d d } | j  t d | j d d | j ÉÉ d  S(   Nt   attri    u   __%s__i   t   prefix(   t   replaceR   t   valueR   (   t   selft   nodet   resultsR   (    (    s1   /usr/lib/python2.7/lib2to3/fixes/fix_funcattrs.pyt	   transform   s    (   t   __name__t
   __module__t   Truet   BM_compatiblet   PATTERNR
   (    (    (    s1   /usr/lib/python2.7/lib2to3/fixes/fix_funcattrs.pyR   	   s   N(   t   __doc__t    R    t
   fixer_utilR   t   BaseFixR   (    (    (    s1   /usr/lib/python2.7/lib2to3/fixes/fix_funcattrs.pyt   <module>   s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 """Remove __future__ imports

from __future__ import foo is replaced with an empty line.
"""
# Author: Christian Heimes

# Local imports
from .. import fixer_base
from ..fixer_util import BlankLine

class FixFuture(fixer_base.BaseFix):
    BM_compatible = True

    PATTERN = """import_from< 'from' module_name="__future__" 'import' any >"""

    # This should be run last -- some things check for the import
    run_order = 10

    def transform(self, node, results):
        new = BlankLine()
        new.prefix = node.prefix
        return new
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             Û
”´[c           @   sC   d  Z  d d l m Z d d l m Z d e j f d Ñ  É  YZ d S(   sV   Remove __future__ imports

from __future__ import foo is replaced with an empty line.
i   (   t
   fixer_base(   t	   BlankLinet	   FixFuturec           B   s#   e  Z e Z d  Z d Z d Ñ  Z RS(   s;   import_from< 'from' module_name="__future__" 'import' any >i
   c         C   s   t  É  } | j | _ | S(   N(   R   t   prefix(   t   selft   nodet   resultst   new(    (    s.   /usr/lib/python2.7/lib2to3/fixes/fix_future.pyt	   transform   s    	(   t   __name__t
   __module__t   Truet   BM_compatiblet   PATTERNt	   run_orderR   (    (    (    s.   /usr/lib/python2.7/lib2to3/fixes/fix_future.pyR      s   N(   t   __doc__t    R    t
   fixer_utilR   t   BaseFixR   (    (    (    s.   /usr/lib/python2.7/lib2to3/fixes/fix_future.pyt   <module>   s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    """
Fixer that changes os.getcwdu() to os.getcwd().
"""
# Author: Victor Stinner

# Local imports
from .. import fixer_base
from ..fixer_util import Name

class FixGetcwdu(fixer_base.BaseFix):
    BM_compatible = True

    PATTERN = """
              power< 'os' trailer< dot='.' name='getcwdu' > any* >
              """

    def transform(self, node, results):
        name = results["name"]
        name.replace(Name(u"getcwd", prefix=name.prefix))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Û
”´[c           @   sC   d  Z  d d l m Z d d l m Z d e j f d Ñ  É  YZ d S(   s1   
Fixer that changes os.getcwdu() to os.getcwd().
i   (   t
   fixer_base(   t   Namet
   FixGetcwduc           B   s   e  Z e Z d  Z d Ñ  Z RS(   sR   
              power< 'os' trailer< dot='.' name='getcwdu' > any* >
              c         C   s*   | d } | j  t d d | j ÉÉ d  S(   Nt   nameu   getcwdt   prefix(   t   replaceR   R   (   t   selft   nodet   resultsR   (    (    s/   /usr/lib/python2.7/lib2to3/fixes/fix_getcwdu.pyt	   transform   s    
(   t   __name__t
   __module__t   Truet   BM_compatiblet   PATTERNR	   (    (    (    s/   /usr/lib/python2.7/lib2to3/fixes/fix_getcwdu.pyR   
   s   N(   t   __doc__t    R    t
   fixer_utilR   t   BaseFixR   (    (    (    s/   /usr/lib/python2.7/lib2to3/fixes/fix_getcwdu.pyt   <module>   s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             # Copyright 2006 Google, Inc. All Rights Reserved.
# Licensed to PSF under a Contributor Agreement.

"""Fixer for has_key().

Calls to .has_key() methods are expressed in terms of the 'in'
operator:

    d.has_key(k) -> k in d

CAVEATS:
1) While the primary target of this fixer is dict.has_key(), the
   fixer will change any has_key() method call, regardless of its
   class.

2) Cases like this will not be converted:

    m = d.has_key
    if m(k):
        ...

   Only *calls* to has_key() are converted. While it is possible to
   convert the above to something like

    m = d.__contains__
    if m(k):
        ...

   this is currently not done.
"""

# Local imports
from .. import pytree
from ..pgen2 import token
from .. import fixer_base
from ..fixer_util import Name, parenthesize


class FixHasKey(fixer_base.BaseFix):
    BM_compatible = True

    PATTERN = """
    anchor=power<
        before=any+
        trailer< '.' 'has_key' >
        trailer<
            '('
            ( not(arglist | argument<any '=' any>) arg=any
            | arglist<(not argument<any '=' any>) arg=any ','>
            )
            ')'
        >
        after=any*
    >
    |
    negation=not_test<
        'not'
        anchor=power<
            before=any+
            trailer< '.' 'has_key' >
            trailer<
                '('
                ( not(arglist | argument<any '=' any>) arg=any
                | arglist<(not argument<any '=' any>) arg=any ','>
                )
                ')'
            >
        >
    >
    """

    def transform(self, node, results):
        assert results
        syms = self.syms
        if (node.parent.type == syms.not_test and
            self.pattern.match(node.parent)):
            # Don't transform a node matching the first alternative of the
            # pattern when its parent matches the second alternative
            return None
        negation = results.get("negation")
        anchor = results["anchor"]
        prefix = node.prefix
        before = [n.clone() for n in results["before"]]
        arg = results["arg"].clone()
        after = results.get("after")
        if after:
            after = [n.clone() for n in after]
        if arg.type in (syms.comparison, syms.not_test, syms.and_test,
                        syms.or_test, syms.test, syms.lambdef, syms.argument):
            arg = parenthesize(arg)
        if len(before) == 1:
            before = before[0]
        else:
            before = pytree.Node(syms.power, before)
        before.prefix = u" "
        n_op = Name(u"in", prefix=u" ")
        if negation:
            n_not = Name(u"not", prefix=u" ")
            n_op = pytree.Node(syms.comp_op, (n_not, n_op))
        new = pytree.Node(syms.comparison, (arg, n_op, before))
        if after:
            new = parenthesize(new)
            new = pytree.Node(syms.power, (new,) + tuple(after))
        if node.parent.type in (syms.comparison, syms.expr, syms.xor_expr,
                                syms.and_expr, syms.shift_expr,
                                syms.arith_expr, syms.term,
                                syms.factor, syms.power):
            new = parenthesize(new)
        new.prefix = prefix
        return new
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     Û
”´[c           @   si   d  Z  d d l m Z d d l m Z d d l m Z d d l m Z m Z d e j	 f d Ñ  É  YZ
 d S(	   s&  Fixer for has_key().

Calls to .has_key() methods are expressed in terms of the 'in'
operator:

    d.has_key(k) -> k in d

CAVEATS:
1) While the primary target of this fixer is dict.has_key(), the
   fixer will change any has_key() method call, regardless of its
   class.

2) Cases like this will not be converted:

    m = d.has_key
    if m(k):
        ...

   Only *calls* to has_key() are converted. While it is possible to
   convert the above to something like

    m = d.__contains__
    if m(k):
        ...

   this is currently not done.
i   (   t   pytree(   t   token(   t
   fixer_base(   t   Namet   parenthesizet	   FixHasKeyc           B   s   e  Z e Z d  Z d Ñ  Z RS(   sï  
    anchor=power<
        before=any+
        trailer< '.' 'has_key' >
        trailer<
            '('
            ( not(arglist | argument<any '=' any>) arg=any
            | arglist<(not argument<any '=' any>) arg=any ','>
            )
            ')'
        >
        after=any*
    >
    |
    negation=not_test<
        'not'
        anchor=power<
            before=any+
            trailer< '.' 'has_key' >
            trailer<
                '('
                ( not(arglist | argument<any '=' any>) arg=any
                | arglist<(not argument<any '=' any>) arg=any ','>
                )
                ')'
            >
        >
    >
    c      
   C   sU  | s t  Ç |  j } | j j | j k rC |  j j | j É rC d  S| j d É } | d } | j	 } g  | d D] } | j
 É  ^ qp } | d j
 É  }	 | j d É }
 |
 rœ g  |
 D] } | j
 É  ^ q¥ }
 n  |	 j | j | j | j | j | j | j | j f k rt |	 É }	 n  t | É d k r6| d } n t j | j | É } d | _	 t d	 d
 d É} | rút d d
 d É} t j | j | | f É } n  t j | j |	 | | f É } |
 rÒt | É } t j | j | f t |
 É É } n  | j j | j | j | j | j | j | j | j | j | j f	 k rHt | É } n  | | _	 | S(   Nt   negationt   anchort   beforet   argt   afteri   i    u    u   int   prefixu   not(    t   AssertionErrort   symst   parentt   typet   not_testt   patternt   matcht   Nonet   getR   t   clonet
   comparisont   and_testt   or_testt   testt   lambdeft   argumentR   t   lenR    t   Nodet   powerR   t   comp_opt   tuplet   exprt   xor_exprt   and_exprt
   shift_exprt
   arith_exprt   termt   factor(   t   selft   nodet   resultsR   R   R   R   t   nR   R	   R
   t   n_opt   n_nott   new(    (    s/   /usr/lib/python2.7/lib2to3/fixes/fix_has_key.pyt	   transformH   sF    	
	#"!	%	(   t   __name__t
   __module__t   Truet   BM_compatiblet   PATTERNR/   (    (    (    s/   /usr/lib/python2.7/lib2to3/fixes/fix_has_key.pyR   '   s   N(   t   __doc__t    R    t   pgen2R   R   t
   fixer_utilR   R   t   BaseFixR   (    (    (    s/   /usr/lib/python2.7/lib2to3/fixes/fix_has_key.pyt   <module>   s
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           """Adjust some old Python 2 idioms to their modern counterparts.

* Change some type comparisons to isinstance() calls:
    type(x) == T -> isinstance(x, T)
    type(x) is T -> isinstance(x, T)
    type(x) != T -> not isinstance(x, T)
    type(x) is not T -> not isinstance(x, T)

* Change "while 1:" into "while True:".

* Change both

    v = list(EXPR)
    v.sort()
    foo(v)

and the more general

    v = EXPR
    v.sort()
    foo(v)

into

    v = sorted(EXPR)
    foo(v)
"""
# Author: Jacques Frechet, Collin Winter

# Local imports
from .. import fixer_base
from ..fixer_util import Call, Comma, Name, Node, BlankLine, syms

CMP = "(n='!=' | '==' | 'is' | n=comp_op< 'is' 'not' >)"
TYPE = "power< 'type' trailer< '(' x=any ')' > >"

class FixIdioms(fixer_base.BaseFix):
    explicit = True # The user must ask for this fixer

    PATTERN = r"""
        isinstance=comparison< %s %s T=any >
        |
        isinstance=comparison< T=any %s %s >
        |
        while_stmt< 'while' while='1' ':' any+ >
        |
        sorted=any<
            any*
            simple_stmt<
              expr_stmt< id1=any '='
                         power< list='list' trailer< '(' (not arglist<any+>) any ')' > >
              >
              '\n'
            >
            sort=
            simple_stmt<
              power< id2=any
                     trailer< '.' 'sort' > trailer< '(' ')' >
              >
              '\n'
            >
            next=any*
        >
        |
        sorted=any<
            any*
            simple_stmt< expr_stmt< id1=any '=' expr=any > '\n' >
            sort=
            simple_stmt<
              power< id2=any
                     trailer< '.' 'sort' > trailer< '(' ')' >
              >
              '\n'
            >
            next=any*
        >
    """ % (TYPE, CMP, CMP, TYPE)

    def match(self, node):
        r = super(FixIdioms, self).match(node)
        # If we've matched one of the sort/sorted subpatterns above, we
        # want to reject matches where the initial assignment and the
        # subsequent .sort() call involve different identifiers.
        if r and "sorted" in r:
            if r["id1"] == r["id2"]:
                return r
            return None
        return r

    def transform(self, node, results):
        if "isinstance" in results:
            return self.transform_isinstance(node, results)
        elif "while" in results:
            return self.transform_while(node, results)
        elif "sorted" in results:
            return self.transform_sort(node, results)
        else:
            raise RuntimeError("Invalid match")

    def transform_isinstance(self, node, results):
        x = results["x"].clone() # The thing inside of type()
        T = results["T"].clone() # The type being compared against
        x.prefix = u""
        T.prefix = u" "
        test = Call(Name(u"isinstance"), [x, Comma(), T])
        if "n" in results:
            test.prefix = u" "
            test = Node(syms.not_test, [Name(u"not"), test])
        test.prefix = node.prefix
        return test

    def transform_while(self, node, results):
        one = results["while"]
        one.replace(Name(u"True", prefix=one.prefix))

    def transform_sort(self, node, results):
        sort_stmt = results["sort"]
        next_stmt = results["next"]
        list_call = results.get("list")
        simple_expr = results.get("expr")

        if list_call:
            list_call.replace(Name(u"sorted", prefix=list_call.prefix))
        elif simple_expr:
            new = simple_expr.clone()
            new.prefix = u""
            simple_expr.replace(Call(Name(u"sorted"), [new],
                                     prefix=simple_expr.prefix))
        else:
            raise RuntimeError("should not have reached here")
        sort_stmt.remove()

        btwn = sort_stmt.prefix
        # Keep any prefix lines between the sort_stmt and the list_call and
        # shove them right after the sorted() call.
        if u"\n" in btwn:
            if next_stmt:
                # The new prefix should be everything from the sort_stmt's
                # prefix up to the last newline, then the old prefix after a new
                # line.
                prefix_lines = (btwn.rpartition(u"\n")[0], next_stmt[0].prefix)
                next_stmt[0].prefix = u"\n".join(prefix_lines)
            else:
                assert list_call.parent
                assert list_call.next_sibling is None
                # Put a blank line after list_call and set its prefix.
                end_line = BlankLine()
                list_call.parent.append_child(end_line)
                assert list_call.next_sibling is end_line
                # The new prefix should be everything up to the first new line
                # of sort_stmt's prefix.
                end_line.prefix = btwn.rpartition(u"\n")[0]
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Û
”´[c           @   sm   d  Z  d d l m Z d d l m Z m Z m Z m Z m Z m	 Z	 d Z
 d Z d e j f d Ñ  É  YZ d S(	   s‹  Adjust some old Python 2 idioms to their modern counterparts.

* Change some type comparisons to isinstance() calls:
    type(x) == T -> isinstance(x, T)
    type(x) is T -> isinstance(x, T)
    type(x) != T -> not isinstance(x, T)
    type(x) is not T -> not isinstance(x, T)

* Change "while 1:" into "while True:".

* Change both

    v = list(EXPR)
    v.sort()
    foo(v)

and the more general

    v = EXPR
    v.sort()
    foo(v)

into

    v = sorted(EXPR)
    foo(v)
i   (   t
   fixer_base(   t   Callt   Commat   Namet   Nodet	   BlankLinet   symss0   (n='!=' | '==' | 'is' | n=comp_op< 'is' 'not' >)s(   power< 'type' trailer< '(' x=any ')' > >t	   FixIdiomsc           B   sQ   e  Z e Z d  e e e e f Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d Ñ  Z RS(   s∫  
        isinstance=comparison< %s %s T=any >
        |
        isinstance=comparison< T=any %s %s >
        |
        while_stmt< 'while' while='1' ':' any+ >
        |
        sorted=any<
            any*
            simple_stmt<
              expr_stmt< id1=any '='
                         power< list='list' trailer< '(' (not arglist<any+>) any ')' > >
              >
              '\n'
            >
            sort=
            simple_stmt<
              power< id2=any
                     trailer< '.' 'sort' > trailer< '(' ')' >
              >
              '\n'
            >
            next=any*
        >
        |
        sorted=any<
            any*
            simple_stmt< expr_stmt< id1=any '=' expr=any > '\n' >
            sort=
            simple_stmt<
              power< id2=any
                     trailer< '.' 'sort' > trailer< '(' ')' >
              >
              '\n'
            >
            next=any*
        >
    c         C   sJ   t  t |  É j | É } | rF d | k rF | d | d k rB | Sd  S| S(   Nt   sortedt   id1t   id2(   t   superR   t   matcht   None(   t   selft   nodet   r(    (    s.   /usr/lib/python2.7/lib2to3/fixes/fix_idioms.pyR   O   s    c         C   sd   d | k r |  j  | | É Sd | k r8 |  j | | É Sd | k rT |  j | | É St d É Ç d  S(   Nt
   isinstancet   whileR   s   Invalid match(   t   transform_isinstancet   transform_whilet   transform_sortt   RuntimeError(   R   R   t   results(    (    s.   /usr/lib/python2.7/lib2to3/fixes/fix_idioms.pyt	   transformZ   s    c         C   sô   | d j  É  } | d j  É  } d | _ d | _ t t d É | t É  | g É } d | k râ d | _ t t j t d É | g É } n  | j | _ | S(   Nt   xt   Tu    u    u
   isinstancet   nu   not(   t   clonet   prefixR   R   R   R   R   t   not_test(   R   R   R   R   R   t   test(    (    s.   /usr/lib/python2.7/lib2to3/fixes/fix_idioms.pyR   d   s    		!	!c         C   s*   | d } | j  t d d | j ÉÉ d  S(   NR   u   TrueR   (   t   replaceR   R   (   R   R   R   t   one(    (    s.   /usr/lib/python2.7/lib2to3/fixes/fix_idioms.pyR   p   s    
c         C   sv  | d } | d } | j  d É } | j  d É } | rW | j t d d | j ÉÉ nR | rù | j É  } d | _ | j t t d É | g d | j ÉÉ n t d É Ç | j É  | j } d	 | k rr| r| j d	 É d
 | d
 j f }	 d	 j	 |	 É | d
 _ qr| j
 st Ç | j d  k s+t Ç t É  }
 | j
 j |
 É | j |
 k sYt Ç | j d	 É d
 |
 _ n  d  S(   Nt   sortt   nextt   listt   expru   sortedR   u    s   should not have reached hereu   
i    (   t   getR    R   R   R   R   R   t   removet
   rpartitiont   joint   parentt   AssertionErrort   next_siblingR   R   t   append_child(   R   R   R   t	   sort_stmtt	   next_stmtt	   list_callt   simple_exprt   newt   btwnt   prefix_linest   end_line(    (    s.   /usr/lib/python2.7/lib2to3/fixes/fix_idioms.pyR   t   s0    

	
	 	(   t   __name__t
   __module__t   Truet   explicitt   TYPEt   CMPt   PATTERNR   R   R   R   R   (    (    (    s.   /usr/lib/python2.7/lib2to3/fixes/fix_idioms.pyR   %   s   '		
		N(   t   __doc__t    R    t
   fixer_utilR   R   R   R   R   R   R;   R:   t   BaseFixR   (    (    (    s.   /usr/lib/python2.7/lib2to3/fixes/fix_idioms.pyt   <module>   s
   .                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     """Fixer for import statements.
If spam is being imported from the local directory, this import:
    from spam import eggs
Becomes:
    from .spam import eggs

And this import:
    import spam
Becomes:
    from . import spam
"""

# Local imports
from .. import fixer_base
from os.path import dirname, join, exists, sep
from ..fixer_util import FromImport, syms, token


def traverse_imports(names):
    """
    Walks over all the names imported in a dotted_as_names node.
    """
    pending = [names]
    while pending:
        node = pending.pop()
        if node.type == token.NAME:
            yield node.value
        elif node.type == syms.dotted_name:
            yield "".join([ch.value for ch in node.children])
        elif node.type == syms.dotted_as_name:
            pending.append(node.children[0])
        elif node.type == syms.dotted_as_names:
            pending.extend(node.children[::-2])
        else:
            raise AssertionError("unknown node type")


class FixImport(fixer_base.BaseFix):
    BM_compatible = True

    PATTERN = """
    import_from< 'from' imp=any 'import' ['('] any [')'] >
    |
    import_name< 'import' imp=any >
    """

    def start_tree(self, tree, name):
        super(FixImport, self).start_tree(tree, name)
        self.skip = "absolute_import" in tree.future_features

    def transform(self, node, results):
        if self.skip:
            return
        imp = results['imp']

        if node.type == syms.import_from:
            # Some imps are top-level (eg: 'import ham')
            # some are first level (eg: 'import ham.eggs')
            # some are third level (eg: 'import ham.eggs as spam')
            # Hence, the loop
            while not hasattr(imp, 'value'):
                imp = imp.children[0]
            if self.probably_a_local_import(imp.value):
                imp.value = u"." + imp.value
                imp.changed()
        else:
            have_local = False
            have_absolute = False
            for mod_name in traverse_imports(imp):
                if self.probably_a_local_import(mod_name):
                    have_local = True
                else:
                    have_absolute = True
            if have_absolute:
                if have_local:
                    # We won't handle both sibling and absolute imports in the
                    # same statement at the moment.
                    self.warning(node, "absolute and local imports together")
                return

            new = FromImport(u".", [imp])
            new.prefix = node.prefix
            return new

    def probably_a_local_import(self, imp_name):
        if imp_name.startswith(u"."):
            # Relative imports are certainly not local imports.
            return False
        imp_name = imp_name.split(u".", 1)[0]
        base_path = dirname(self.filename)
        base_path = join(base_path, imp_name)
        # If there is no __init__.py next to the file its not in a package
        # so can't be a relative import.
        if not exists(join(dirname(base_path), "__init__.py")):
            return False
        for ext in [".py", sep, ".pyc", ".so", ".sl", ".pyd"]:
            if exists(base_path + ext):
                return True
        return False
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Û
”´[c           @   sz   d  Z  d d l m Z d d l m Z m Z m Z m Z d d l m	 Z	 m
 Z
 m Z d Ñ  Z d e j f d Ñ  É  YZ d	 S(
   sﬁ   Fixer for import statements.
If spam is being imported from the local directory, this import:
    from spam import eggs
Becomes:
    from .spam import eggs

And this import:
    import spam
Becomes:
    from . import spam
i   (   t
   fixer_baseiˇˇˇˇ(   t   dirnamet   joint   existst   sep(   t
   FromImportt   symst   tokenc         c   sÊ   |  g } x÷ | r· | j  É  } | j t j k r; | j Vq | j t j k rw d j g  | j D] } | j ^ q] É Vq | j t j	 k r† | j
 | j d É q | j t j k r“ | j | j d d d Ö É q t d É Ç q Wd S(   sF   
    Walks over all the names imported in a dotted_as_names node.
    t    i    Ni˛ˇˇˇs   unknown node type(   t   popt   typeR   t   NAMEt   valueR   t   dotted_nameR   t   childrent   dotted_as_namet   appendt   dotted_as_namest   extendt   AssertionError(   t   namest   pendingt   nodet   ch(    (    s.   /usr/lib/python2.7/lib2to3/fixes/fix_import.pyt   traverse_imports   s    		* t	   FixImportc           B   s/   e  Z e Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   sj   
    import_from< 'from' imp=any 'import' ['('] any [')'] >
    |
    import_name< 'import' imp=any >
    c         C   s/   t  t |  É j | | É d | j k |  _ d  S(   Nt   absolute_import(   t   superR   t
   start_treet   future_featurest   skip(   t   selft   treet   name(    (    s.   /usr/lib/python2.7/lib2to3/fixes/fix_import.pyR   /   s    c         C   s  |  j  r d  S| d } | j t j k r~ x  t | d É sK | j d } q, W|  j | j É rd | j | _ | j É  qnÜ t	 } t	 } x2 t
 | É D]$ } |  j | É rµ t } qó t } qó W| r‚ | rﬁ |  j | d É n  d  St d | g É } | j | _ | Sd  S(   Nt   impR   i    u   .s#   absolute and local imports together(   R   R
   R   t   import_fromt   hasattrR   t   probably_a_local_importR   t   changedt   FalseR   t   Truet   warningR   t   prefix(   R   R   t   resultsR"   t
   have_localt   have_absolutet   mod_namet   new(    (    s.   /usr/lib/python2.7/lib2to3/fixes/fix_import.pyt	   transform3   s,    	
	
c         C   s°   | j  d É r t S| j d d É d } t |  j É } t | | É } t t t | É d É É sf t Sx4 d t d d d d	 g D] } t | | É r t Sq Wt S(
   Nu   .i   i    s   __init__.pys   .pys   .pycs   .sos   .sls   .pyd(	   t
   startswithR'   t   splitR   t   filenameR   R   R   R(   (   R   t   imp_namet	   base_patht   ext(    (    s.   /usr/lib/python2.7/lib2to3/fixes/fix_import.pyR%   U   s    (   t   __name__t
   __module__R(   t   BM_compatiblet   PATTERNR   R0   R%   (    (    (    s.   /usr/lib/python2.7/lib2to3/fixes/fix_import.pyR   &   s
   		"N(   t   __doc__R   R    t   os.pathR   R   R   R   t
   fixer_utilR   R   R   R   t   BaseFixR   (    (    (    s.   /usr/lib/python2.7/lib2to3/fixes/fix_import.pyt   <module>   s
   "	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       """Fix incompatible imports and module references."""
# Authors: Collin Winter, Nick Edds

# Local imports
from .. import fixer_base
from ..fixer_util import Name, attr_chain

MAPPING = {'StringIO':  'io',
           'cStringIO': 'io',
           'cPickle': 'pickle',
           '__builtin__' : 'builtins',
           'copy_reg': 'copyreg',
           'Queue': 'queue',
           'SocketServer': 'socketserver',
           'ConfigParser': 'configparser',
           'repr': 'reprlib',
           'FileDialog': 'tkinter.filedialog',
           'tkFileDialog': 'tkinter.filedialog',
           'SimpleDialog': 'tkinter.simpledialog',
           'tkSimpleDialog': 'tkinter.simpledialog',
           'tkColorChooser': 'tkinter.colorchooser',
           'tkCommonDialog': 'tkinter.commondialog',
           'Dialog': 'tkinter.dialog',
           'Tkdnd': 'tkinter.dnd',
           'tkFont': 'tkinter.font',
           'tkMessageBox': 'tkinter.messagebox',
           'ScrolledText': 'tkinter.scrolledtext',
           'Tkconstants': 'tkinter.constants',
           'Tix': 'tkinter.tix',
           'ttk': 'tkinter.ttk',
           'Tkinter': 'tkinter',
           'markupbase': '_markupbase',
           '_winreg': 'winreg',
           'thread': '_thread',
           'dummy_thread': '_dummy_thread',
           # anydbm and whichdb are handled by fix_imports2
           'dbhash': 'dbm.bsd',
           'dumbdbm': 'dbm.dumb',
           'dbm': 'dbm.ndbm',
           'gdbm': 'dbm.gnu',
           'xmlrpclib': 'xmlrpc.client',
           'DocXMLRPCServer': 'xmlrpc.server',
           'SimpleXMLRPCServer': 'xmlrpc.server',
           'httplib': 'http.client',
           'htmlentitydefs' : 'html.entities',
           'HTMLParser' : 'html.parser',
           'Cookie': 'http.cookies',
           'cookielib': 'http.cookiejar',
           'BaseHTTPServer': 'http.server',
           'SimpleHTTPServer': 'http.server',
           'CGIHTTPServer': 'http.server',
           #'test.test_support': 'test.support',
           'commands': 'subprocess',
           'UserString' : 'collections',
           'UserList' : 'collections',
           'urlparse' : 'urllib.parse',
           'robotparser' : 'urllib.robotparser',
}


def alternates(members):
    return "(" + "|".join(map(repr, members)) + ")"


def build_pattern(mapping=MAPPING):
    mod_list = ' | '.join(["module_name='%s'" % key for key in mapping])
    bare_names = alternates(mapping.keys())

    yield """name_import=import_name< 'import' ((%s) |
               multiple_imports=dotted_as_names< any* (%s) any* >) >
          """ % (mod_list, mod_list)
    yield """import_from< 'from' (%s) 'import' ['(']
              ( any | import_as_name< any 'as' any > |
                import_as_names< any* >)  [')'] >
          """ % mod_list
    yield """import_name< 'import' (dotted_as_name< (%s) 'as' any > |
               multiple_imports=dotted_as_names<
                 any* dotted_as_name< (%s) 'as' any > any* >) >
          """ % (mod_list, mod_list)

    # Find usages of module members in code e.g. thread.foo(bar)
    yield "power< bare_with_attr=(%s) trailer<'.' any > any* >" % bare_names


class FixImports(fixer_base.BaseFix):

    BM_compatible = True
    keep_line_order = True
    # This is overridden in fix_imports2.
    mapping = MAPPING

    # We want to run this fixer late, so fix_import doesn't try to make stdlib
    # renames into relative imports.
    run_order = 6

    def build_pattern(self):
        return "|".join(build_pattern(self.mapping))

    def compile_pattern(self):
        # We override this, so MAPPING can be pragmatically altered and the
        # changes will be reflected in PATTERN.
        self.PATTERN = self.build_pattern()
        super(FixImports, self).compile_pattern()

    # Don't match the node if it's within another match.
    def match(self, node):
        match = super(FixImports, self).match
        results = match(node)
        if results:
            # Module usage could be in the trailer of an attribute lookup, so we
            # might have nested matches when "bare_with_attr" is present.
            if "bare_with_attr" not in results and \
                    any(match(obj) for obj in attr_chain(node, "parent")):
                return False
            return results
        return False

    def start_tree(self, tree, filename):
        super(FixImports, self).start_tree(tree, filename)
        self.replace = {}

    def transform(self, node, results):
        import_mod = results.get("module_name")
        if import_mod:
            mod_name = import_mod.value
            new_name = unicode(self.mapping[mod_name])
            import_mod.replace(Name(new_name, prefix=import_mod.prefix))
            if "name_import" in results:
                # If it's not a "from x import x, y" or "import x as y" import,
                # marked its usage to be replaced.
                self.replace[mod_name] = new_name
            if "multiple_imports" in results:
                # This is a nasty hack to fix multiple imports on a line (e.g.,
                # "import StringIO, urlparse"). The problem is that I can't
                # figure out an easy way to make a pattern recognize the keys of
                # MAPPING randomly sprinkled in an import statement.
                results = self.match(node)
                if results:
                    self.transform(node, results)
        else:
            # Replace usage of the module.
            bare_name = results["bare_with_attr"][0]
            new_name = self.replace.get(bare_name.value)
            if new_name:
                bare_name.replace(Name(new_name, prefix=bare_name.prefix))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   Û
”´[c           @   s¥  d  Z  d d l m Z d d l m Z m Z i0 d d 6d d 6d d 6d	 d
 6d d 6d d 6d d 6d d 6d d 6d d 6d d 6d d 6d d 6d d 6d d 6d d  6d! d" 6d# d$ 6d% d& 6d' d( 6d) d* 6d+ d, 6d- d. 6d/ d0 6d1 d2 6d3 d4 6d5 d6 6d7 d8 6d9 d: 6d; d< 6d= d> 6d? d@ 6dA dB 6dC dD 6dC dE 6dF dG 6dH dI 6dJ dK 6dL dM 6dN dO 6dP dQ 6dP dR 6dP dS 6dT dU 6dV dW 6dV dX 6dY dZ 6d[ d\ 6Z d] Ñ  Z e d^ Ñ Z d_ e j	 f d` Ñ  É  YZ
 da S(b   s/   Fix incompatible imports and module references.i   (   t
   fixer_base(   t   Namet
   attr_chaint   iot   StringIOt	   cStringIOt   picklet   cPicklet   builtinst   __builtin__t   copyregt   copy_regt   queuet   Queuet   socketservert   SocketServert   configparsert   ConfigParsert   reprlibt   reprs   tkinter.filedialogt
   FileDialogt   tkFileDialogs   tkinter.simpledialogt   SimpleDialogt   tkSimpleDialogs   tkinter.colorchoosert   tkColorChoosers   tkinter.commondialogt   tkCommonDialogs   tkinter.dialogt   Dialogs   tkinter.dndt   Tkdnds   tkinter.fontt   tkFonts   tkinter.messageboxt   tkMessageBoxs   tkinter.scrolledtextt   ScrolledTexts   tkinter.constantst   Tkconstantss   tkinter.tixt   Tixs   tkinter.ttkt   ttkt   tkintert   Tkintert   _markupbaset
   markupbaset   winregt   _winregt   _threadt   threadt   _dummy_threadt   dummy_threads   dbm.bsdt   dbhashs   dbm.dumbt   dumbdbms   dbm.ndbmt   dbms   dbm.gnut   gdbms   xmlrpc.clientt	   xmlrpclibs   xmlrpc.servert   DocXMLRPCServert   SimpleXMLRPCServers   http.clientt   httplibs   html.entitiest   htmlentitydefss   html.parsert
   HTMLParsers   http.cookiest   Cookies   http.cookiejart	   cookielibs   http.servert   BaseHTTPServert   SimpleHTTPServert   CGIHTTPServert
   subprocesst   commandst   collectionst
   UserStringt   UserLists   urllib.parset   urlparses   urllib.robotparsert   robotparserc         C   s   d d j  t t |  É É d S(   Nt   (t   |t   )(   t   joint   mapR   (   t   members(    (    s/   /usr/lib/python2.7/lib2to3/fixes/fix_imports.pyt
   alternates=   s    c         c   sl   d j  g  |  D] } d | ^ q É } t |  j É  É } d | | f Vd | Vd | | f Vd | Vd  S(   Ns    | s   module_name='%s'sy   name_import=import_name< 'import' ((%s) |
               multiple_imports=dotted_as_names< any* (%s) any* >) >
          sõ   import_from< 'from' (%s) 'import' ['(']
              ( any | import_as_name< any 'as' any > |
                import_as_names< any* >)  [')'] >
          s¥   import_name< 'import' (dotted_as_name< (%s) 'as' any > |
               multiple_imports=dotted_as_names<
                 any* dotted_as_name< (%s) 'as' any > any* >) >
          s3   power< bare_with_attr=(%s) trailer<'.' any > any* >(   RE   RH   t   keys(   t   mappingt   keyt   mod_listt
   bare_names(    (    s/   /usr/lib/python2.7/lib2to3/fixes/fix_imports.pyt   build_patternA   s    &	t
   FixImportsc           B   sM   e  Z e Z e Z e Z d  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d Ñ  Z d Ñ  Z RS(   i   c         C   s   d j  t |  j É É S(   NRC   (   RE   RN   RJ   (   t   self(    (    s/   /usr/lib/python2.7/lib2to3/fixes/fix_imports.pyRN   `   s    c         C   s&   |  j  É  |  _ t t |  É j É  d  S(   N(   RN   t   PATTERNt   superRO   t   compile_pattern(   RP   (    (    s/   /usr/lib/python2.7/lib2to3/fixes/fix_imports.pyRS   c   s    c            sa   t  t |  É j â  à  | É } | r] d | k rY t á  f d Ü  t | d É DÉ É rY t S| St S(   Nt   bare_with_attrc         3   s   |  ] } à  | É Vq d  S(   N(    (   t   .0t   obj(   t   match(    s/   /usr/lib/python2.7/lib2to3/fixes/fix_imports.pys	   <genexpr>q   s    t   parent(   RR   RO   RW   t   anyR   t   False(   RP   t   nodet   results(    (   RW   s/   /usr/lib/python2.7/lib2to3/fixes/fix_imports.pyRW   j   s    %c         C   s&   t  t |  É j | | É i  |  _ d  S(   N(   RR   RO   t
   start_treet   replace(   RP   t   treet   filename(    (    s/   /usr/lib/python2.7/lib2to3/fixes/fix_imports.pyR]   v   s    c         C   sÔ   | j  d É } | r£ | j } t |  j | É } | j t | d | j ÉÉ d | k ri | |  j | <n  d | k rÎ |  j | É } | r† |  j | | É q† qÎ nH | d d } |  j j  | j É } | rÎ | j t | d | j ÉÉ n  d  S(   Nt   module_namet   prefixt   name_importt   multiple_importsRT   i    (	   t   gett   valuet   unicodeRJ   R^   R   Rb   RW   t	   transform(   RP   R[   R\   t
   import_modt   mod_namet   new_namet	   bare_name(    (    s/   /usr/lib/python2.7/lib2to3/fixes/fix_imports.pyRh   z   s    	(   t   __name__t
   __module__t   Truet   BM_compatiblet   keep_line_ordert   MAPPINGRJ   t	   run_orderRN   RS   RW   R]   Rh   (    (    (    s/   /usr/lib/python2.7/lib2to3/fixes/fix_imports.pyRO   U   s   				N(   t   __doc__t    R    t
   fixer_utilR   R   Rr   RH   RN   t   BaseFixRO   (    (    (    s/   /usr/lib/python2.7/lib2to3/fixes/fix_imports.pyt   <module>   sj   

	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                """Fix incompatible imports and module references that must be fixed after
fix_imports."""
from . import fix_imports


MAPPING = {
            'whichdb': 'dbm',
            'anydbm': 'dbm',
          }


class FixImports2(fix_imports.FixImports):

    run_order = 7

    mapping = MAPPING
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               Û
”´[c           @   sG   d  Z  d d l m Z i d d 6d d 6Z d e j f d Ñ  É  YZ d S(	   sT   Fix incompatible imports and module references that must be fixed after
fix_imports.i   (   t   fix_importst   dbmt   whichdbt   anydbmt   FixImports2c           B   s   e  Z d  Z e Z RS(   i   (   t   __name__t
   __module__t	   run_ordert   MAPPINGt   mapping(    (    (    s0   /usr/lib/python2.7/lib2to3/fixes/fix_imports2.pyR      s   N(   t   __doc__t    R    R   t
   FixImportsR   (    (    (    s0   /usr/lib/python2.7/lib2to3/fixes/fix_imports2.pyt   <module>   s
   
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          """Fixer that changes input(...) into eval(input(...))."""
# Author: Andre Roberge

# Local imports
from .. import fixer_base
from ..fixer_util import Call, Name
from .. import patcomp


context = patcomp.compile_pattern("power< 'eval' trailer< '(' any ')' > >")


class FixInput(fixer_base.BaseFix):
    BM_compatible = True
    PATTERN = """
              power< 'input' args=trailer< '(' [any] ')' > >
              """

    def transform(self, node, results):
        # If we're already wrapped in an eval() call, we're done.
        if context.match(node.parent.parent):
            return

        new = node.clone()
        new.prefix = u""
        return Call(Name(u"eval"), [new], prefix=node.prefix)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          Û
”´[c           @   sh   d  Z  d d l m Z d d l m Z m Z d d l m Z e j d É Z d e j	 f d Ñ  É  YZ
 d S(	   s4   Fixer that changes input(...) into eval(input(...)).i   (   t
   fixer_base(   t   Callt   Name(   t   patcomps&   power< 'eval' trailer< '(' any ')' > >t   FixInputc           B   s   e  Z e Z d  Z d Ñ  Z RS(   sL   
              power< 'input' args=trailer< '(' [any] ')' > >
              c         C   sM   t  j | j j É r d  S| j É  } d | _ t t d É | g d | j ÉS(   Nu    u   evalt   prefix(   t   contextt   matcht   parentt   cloneR   R   R   (   t   selft   nodet   resultst   new(    (    s-   /usr/lib/python2.7/lib2to3/fixes/fix_input.pyt	   transform   s
    	(   t   __name__t
   __module__t   Truet   BM_compatiblet   PATTERNR   (    (    (    s-   /usr/lib/python2.7/lib2to3/fixes/fix_input.pyR      s   N(   t   __doc__t    R    t
   fixer_utilR   R   R   t   compile_patternR   t   BaseFixR   (    (    (    s-   /usr/lib/python2.7/lib2to3/fixes/fix_input.pyt   <module>   s
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             # Copyright 2006 Georg Brandl.
# Licensed to PSF under a Contributor Agreement.

"""Fixer for intern().

intern(s) -> sys.intern(s)"""

# Local imports
from .. import pytree
from .. import fixer_base
from ..fixer_util import Name, Attr, touch_import


class FixIntern(fixer_base.BaseFix):
    BM_compatible = True
    order = "pre"

    PATTERN = """
    power< 'intern'
           trailer< lpar='('
                    ( not(arglist | argument<any '=' any>) obj=any
                      | obj=arglist<(not argument<any '=' any>) any ','> )
                    rpar=')' >
           after=any*
    >
    """

    def transform(self, node, results):
        if results:
            # I feel like we should be able to express this logic in the
            # PATTERN above but I don't know how to do it so...
            obj = results['obj']
            if obj:
                if obj.type == self.syms.star_expr:
                    return  # Make no change.
                if (obj.type == self.syms.argument and
                    obj.children[0].value == '**'):
                    return  # Make no change.
        syms = self.syms
        obj = results["obj"].clone()
        if obj.type == syms.arglist:
            newarglist = obj.clone()
        else:
            newarglist = pytree.Node(syms.arglist, [obj.clone()])
        after = results["after"]
        if after:
            after = [n.clone() for n in after]
        new = pytree.Node(syms.power,
                          Attr(Name(u"sys"), Name(u"intern")) +
                          [pytree.Node(syms.trailer,
                                       [results["lpar"].clone(),
                                        newarglist,
                                        results["rpar"].clone()])] + after)
        new.prefix = node.prefix
        touch_import(None, u'sys', node)
        return new
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      Û
”´[c           @   s_   d  Z  d d l m Z d d l m Z d d l m Z m Z m Z d e j f d Ñ  É  YZ	 d S(   s/   Fixer for intern().

intern(s) -> sys.intern(s)i   (   t   pytree(   t
   fixer_base(   t   Namet   Attrt   touch_importt	   FixInternc           B   s#   e  Z e Z d  Z d Z d Ñ  Z RS(   t   presˇ   
    power< 'intern'
           trailer< lpar='('
                    ( not(arglist | argument<any '=' any>) obj=any
                      | obj=arglist<(not argument<any '=' any>) any ','> )
                    rpar=')' >
           after=any*
    >
    c   	   	   C   so  | rd | d } | rd | j  |  j j k r/ d  S| j  |  j j k ra | j d j d k ra d  Sqd n  |  j } | d j É  } | j  | j k rû | j É  } n t j	 | j | j É  g É } | d } | rÓ g  | D] } | j É  ^ q” } n  t j	 | j
 t t d É t d É É t j	 | j | d j É  | | d j É  g É g | É } | j | _ t d  d | É | S(	   Nt   obji    s   **t   afteru   sysu   internt   lpart   rpar(   t   typet   symst	   star_exprt   argumentt   childrent   valuet   clonet   arglistR    t   Nodet   powerR   R   t   trailert   prefixR   t   None(	   t   selft   nodet   resultsR   R   t
   newarglistR   t   nt   new(    (    s.   /usr/lib/python2.7/lib2to3/fixes/fix_intern.pyt	   transform   s*    

	
"U(   t   __name__t
   __module__t   Truet   BM_compatiblet   ordert   PATTERNR   (    (    (    s.   /usr/lib/python2.7/lib2to3/fixes/fix_intern.pyR      s   
N(
   t   __doc__t    R    R   t
   fixer_utilR   R   R   t   BaseFixR   (    (    (    s.   /usr/lib/python2.7/lib2to3/fixes/fix_intern.pyt   <module>   s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    # Copyright 2008 Armin Ronacher.
# Licensed to PSF under a Contributor Agreement.

"""Fixer that cleans up a tuple argument to isinstance after the tokens
in it were fixed.  This is mainly used to remove double occurrences of
tokens as a leftover of the long -> int / unicode -> str conversion.

eg.  isinstance(x, (int, long)) -> isinstance(x, (int, int))
       -> isinstance(x, int)
"""

from .. import fixer_base
from ..fixer_util import token


class FixIsinstance(fixer_base.BaseFix):
    BM_compatible = True
    PATTERN = """
    power<
        'isinstance'
        trailer< '(' arglist< any ',' atom< '('
            args=testlist_gexp< any+ >
        ')' > > ')' >
    >
    """

    run_order = 6

    def transform(self, node, results):
        names_inserted = set()
        testlist = results["args"]
        args = testlist.children
        new_args = []
        iterator = enumerate(args)
        for idx, arg in iterator:
            if arg.type == token.NAME and arg.value in names_inserted:
                if idx < len(args) - 1 and args[idx + 1].type == token.COMMA:
                    iterator.next()
                    continue
            else:
                new_args.append(arg)
                if arg.type == token.NAME:
                    names_inserted.add(arg.value)
        if new_args and new_args[-1].type == token.COMMA:
            del new_args[-1]
        if len(new_args) == 1:
            atom = testlist.parent
            new_args[0].prefix = atom.prefix
            atom.replace(new_args[0])
        else:
            args[:] = new_args
            node.changed()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Û
”´[c           @   sC   d  Z  d d l m Z d d l m Z d e j f d Ñ  É  YZ d S(   s,  Fixer that cleans up a tuple argument to isinstance after the tokens
in it were fixed.  This is mainly used to remove double occurrences of
tokens as a leftover of the long -> int / unicode -> str conversion.

eg.  isinstance(x, (int, long)) -> isinstance(x, (int, int))
       -> isinstance(x, int)
i   (   t
   fixer_base(   t   tokent   FixIsinstancec           B   s#   e  Z e Z d  Z d Z d Ñ  Z RS(   sò   
    power<
        'isinstance'
        trailer< '(' arglist< any ',' atom< '('
            args=testlist_gexp< any+ >
        ')' > > ')' >
    >
    i   c         C   sU  t  É  } | d } | j } g  } t | É } x™ | D]¢ \ } }	 |	 j t j k r• |	 j | k r• | t | É d k  r◊ | | d j t j k r◊ | j	 É  q5 q◊ q5 | j
 |	 É |	 j t j k r5 | j |	 j É q5 q5 W| r| d j t j k r| d =n  t | É d k r@| j }
 |
 j | d _ |
 j | d É n | | (| j É  d  S(   Nt   argsi   iˇˇˇˇi    (   t   sett   childrent	   enumeratet   typeR   t   NAMEt   valuet   lent   COMMAt   nextt   appendt   addt   parentt   prefixt   replacet   changed(   t   selft   nodet   resultst   names_insertedt   testlistR   t   new_argst   iteratort   idxt   argt   atom(    (    s2   /usr/lib/python2.7/lib2to3/fixes/fix_isinstance.pyt	   transform   s*    	
	!0
	
	(   t   __name__t
   __module__t   Truet   BM_compatiblet   PATTERNt	   run_orderR   (    (    (    s2   /usr/lib/python2.7/lib2to3/fixes/fix_isinstance.pyR      s   N(   t   __doc__t    R    t
   fixer_utilR   t   BaseFixR   (    (    (    s2   /usr/lib/python2.7/lib2to3/fixes/fix_isinstance.pyt   <module>
   s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             """ Fixer for itertools.(imap|ifilter|izip) --> (map|filter|zip) and
    itertools.ifilterfalse --> itertools.filterfalse (bugs 2360-2363)

    imports from itertools are fixed in fix_itertools_import.py

    If itertools is imported as something else (ie: import itertools as it;
    it.izip(spam, eggs)) method calls will not get fixed.
    """

# Local imports
from .. import fixer_base
from ..fixer_util import Name

class FixItertools(fixer_base.BaseFix):
    BM_compatible = True
    it_funcs = "('imap'|'ifilter'|'izip'|'izip_longest'|'ifilterfalse')"
    PATTERN = """
              power< it='itertools'
                  trailer<
                     dot='.' func=%(it_funcs)s > trailer< '(' [any] ')' > >
              |
              power< func=%(it_funcs)s trailer< '(' [any] ')' > >
              """ %(locals())

    # Needs to be run after fix_(map|zip|filter)
    run_order = 6

    def transform(self, node, results):
        prefix = None
        func = results['func'][0]
        if ('it' in results and
            func.value not in (u'ifilterfalse', u'izip_longest')):
            dot, it = (results['dot'], results['it'])
            # Remove the 'itertools'
            prefix = it.prefix
            it.remove()
            # Replace the node which contains ('.', 'function') with the
            # function (to be consistent with the second part of the pattern)
            dot.remove()
            func.parent.replace(func)

        prefix = prefix or func.prefix
        func.replace(Name(func.value[1:], prefix=prefix))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  Û
”´[c           @   sC   d  Z  d d l m Z d d l m Z d e j f d Ñ  É  YZ d S(   sT   Fixer for itertools.(imap|ifilter|izip) --> (map|filter|zip) and
    itertools.ifilterfalse --> itertools.filterfalse (bugs 2360-2363)

    imports from itertools are fixed in fix_itertools_import.py

    If itertools is imported as something else (ie: import itertools as it;
    it.izip(spam, eggs)) method calls will not get fixed.
    i   (   t
   fixer_base(   t   Namet   FixItertoolsc           B   s0   e  Z e Z d  Z d e É  Z d Z d Ñ  Z RS(   s7   ('imap'|'ifilter'|'izip'|'izip_longest'|'ifilterfalse')sÏ   
              power< it='itertools'
                  trailer<
                     dot='.' func=%(it_funcs)s > trailer< '(' [any] ')' > >
              |
              power< func=%(it_funcs)s trailer< '(' [any] ')' > >
              i   c         C   sß   d  } | d d } d | k rt | j d	 k rt | d | d } } | j } | j É  | j É  | j j | É n  | pÄ | j } | j t | j d d | ÉÉ d  S(
   Nt   funci    t   itu   ifilterfalseu   izip_longestt   doti   t   prefix(   u   ifilterfalseu   izip_longest(   t   Nonet   valueR   t   removet   parentt   replaceR   (   t   selft   nodet   resultsR   R   R   R   (    (    s1   /usr/lib/python2.7/lib2to3/fixes/fix_itertools.pyt	   transform   s    	

(	   t   __name__t
   __module__t   Truet   BM_compatiblet   it_funcst   localst   PATTERNt	   run_orderR   (    (    (    s1   /usr/lib/python2.7/lib2to3/fixes/fix_itertools.pyR      s
   N(   t   __doc__t    R    t
   fixer_utilR   t   BaseFixR   (    (    (    s1   /usr/lib/python2.7/lib2to3/fixes/fix_itertools.pyt   <module>   s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            """ Fixer for imports of itertools.(imap|ifilter|izip|ifilterfalse) """

# Local imports
from lib2to3 import fixer_base
from lib2to3.fixer_util import BlankLine, syms, token


class FixItertoolsImports(fixer_base.BaseFix):
    BM_compatible = True
    PATTERN = """
              import_from< 'from' 'itertools' 'import' imports=any >
              """ %(locals())

    def transform(self, node, results):
        imports = results['imports']
        if imports.type == syms.import_as_name or not imports.children:
            children = [imports]
        else:
            children = imports.children
        for child in children[::2]:
            if child.type == token.NAME:
                member = child.value
                name_node = child
            elif child.type == token.STAR:
                # Just leave the import as is.
                return
            else:
                assert child.type == syms.import_as_name
                name_node = child.children[0]
            member_name = name_node.value
            if member_name in (u'imap', u'izip', u'ifilter'):
                child.value = None
                child.remove()
            elif member_name in (u'ifilterfalse', u'izip_longest'):
                node.changed()
                name_node.value = (u'filterfalse' if member_name[1] == u'f'
                                   else u'zip_longest')

        # Make sure the import statement is still sane
        children = imports.children[:] or [imports]
        remove_comma = True
        for child in children:
            if remove_comma and child.type == token.COMMA:
                child.remove()
            else:
                remove_comma ^= True

        while children and children[-1].type == token.COMMA:
            children.pop().remove()

        # If there are no imports left, just get rid of the entire statement
        if (not (imports.children or getattr(imports, 'value', None)) or
            imports.parent is None):
            p = node.prefix
            node = BlankLine()
            node.prefix = p
            return node
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  Û
”´[c           @   sO   d  Z  d d l m Z d d l m Z m Z m Z d e j f d Ñ  É  YZ d S(   sA    Fixer for imports of itertools.(imap|ifilter|izip|ifilterfalse) iˇˇˇˇ(   t
   fixer_base(   t	   BlankLinet   symst   tokent   FixItertoolsImportsc           B   s$   e  Z e Z d  e É  Z d Ñ  Z RS(   sT   
              import_from< 'from' 'itertools' 'import' imports=any >
              c         C   sı  | d } | j  t j k s& | j r2 | g } n	 | j } x› | d  d  d Ö D]» } | j  t j k ry | j } | } n; | j  t j k rè d  S| j  t j k sß t Ç | j d } | j } | d k rﬂ d  | _ | j
 É  qO | d k rO | j É  | d	 d
 k rd n d | _ qO qO W| j p+| g } t }	 x= | D]5 } |	 rf| j  t j k rf| j
 É  q;|	 t N}	 q;Wx0 | r¶| d j  t j k r¶| j É  j
 É  qwW| j pøt | d d  É s“| j d  k rÒ| j }
 t É  } |
 | _ | Sd  S(   Nt   importsi   i    u   imapu   izipu   ifilteru   ifilterfalseu   izip_longesti   u   fu   filterfalseu   zip_longestiˇˇˇˇt   value(   u   imapu   izipu   ifilter(   u   ifilterfalseu   izip_longest(   t   typeR   t   import_as_namet   childrenR   t   NAMER   t   STARt   AssertionErrort   Nonet   removet   changedt   Truet   COMMAt   popt   getattrt   parentt   prefixR   (   t   selft   nodet   resultsR   R	   t   childt   membert	   name_nodet   member_namet   remove_commat   p(    (    s9   /usr/lib/python2.7/lib2to3/fixes/fix_itertools_imports.pyt	   transform   sD    
					
			(   t   __name__t
   __module__R   t   BM_compatiblet   localst   PATTERNR   (    (    (    s9   /usr/lib/python2.7/lib2to3/fixes/fix_itertools_imports.pyR      s   N(	   t   __doc__t   lib2to3R    t   lib2to3.fixer_utilR   R   R   t   BaseFixR   (    (    (    s9   /usr/lib/python2.7/lib2to3/fixes/fix_itertools_imports.pyt   <module>   s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           # Copyright 2006 Google, Inc. All Rights Reserved.
# Licensed to PSF under a Contributor Agreement.

"""Fixer that turns 'long' into 'int' everywhere.
"""

# Local imports
from lib2to3 import fixer_base
from lib2to3.fixer_util import is_probably_builtin


class FixLong(fixer_base.BaseFix):
    BM_compatible = True
    PATTERN = "'long'"

    def transform(self, node, results):
        if is_probably_builtin(node):
            node.value = u"int"
            node.changed()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   Û
”´[c           @   sC   d  Z  d d l m Z d d l m Z d e j f d Ñ  É  YZ d S(   s/   Fixer that turns 'long' into 'int' everywhere.
iˇˇˇˇ(   t
   fixer_base(   t   is_probably_builtint   FixLongc           B   s   e  Z e Z d  Z d Ñ  Z RS(   s   'long'c         C   s&   t  | É r" d | _ | j É  n  d  S(   Nu   int(   R   t   valuet   changed(   t   selft   nodet   results(    (    s,   /usr/lib/python2.7/lib2to3/fixes/fix_long.pyt	   transform   s    	(   t   __name__t
   __module__t   Truet   BM_compatiblet   PATTERNR   (    (    (    s,   /usr/lib/python2.7/lib2to3/fixes/fix_long.pyR      s   N(   t   __doc__t   lib2to3R    t   lib2to3.fixer_utilR   t   BaseFixR   (    (    (    s,   /usr/lib/python2.7/lib2to3/fixes/fix_long.pyt   <module>   s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  # Copyright 2007 Google, Inc. All Rights Reserved.
# Licensed to PSF under a Contributor Agreement.

"""Fixer that changes map(F, ...) into list(map(F, ...)) unless there
exists a 'from future_builtins import map' statement in the top-level
namespace.

As a special case, map(None, X) is changed into list(X).  (This is
necessary because the semantics are changed in this case -- the new
map(None, X) is equivalent to [(x,) for x in X].)

We avoid the transformation (except for the special case mentioned
above) if the map() call is directly contained in iter(<>), list(<>),
tuple(<>), sorted(<>), ...join(<>), or for V in <>:.

NOTE: This is still not correct if the original code was depending on
map(F, X, Y, ...) to go on until the longest argument is exhausted,
substituting None for missing values -- like zip(), it now stops as
soon as the shortest argument is exhausted.
"""

# Local imports
from ..pgen2 import token
from .. import fixer_base
from ..fixer_util import Name, Call, ListComp, in_special_context
from ..pygram import python_symbols as syms

class FixMap(fixer_base.ConditionalFix):
    BM_compatible = True

    PATTERN = """
    map_none=power<
        'map'
        trailer< '(' arglist< 'None' ',' arg=any [','] > ')' >
    >
    |
    map_lambda=power<
        'map'
        trailer<
            '('
            arglist<
                lambdef< 'lambda'
                         (fp=NAME | vfpdef< '(' fp=NAME ')'> ) ':' xp=any
                >
                ','
                it=any
            >
            ')'
        >
    >
    |
    power<
        'map' trailer< '(' [arglist=any] ')' >
    >
    """

    skip_on = 'future_builtins.map'

    def transform(self, node, results):
        if self.should_skip(node):
            return

        if node.parent.type == syms.simple_stmt:
            self.warning(node, "You should use a for loop here")
            new = node.clone()
            new.prefix = u""
            new = Call(Name(u"list"), [new])
        elif "map_lambda" in results:
            new = ListComp(results["xp"].clone(),
                           results["fp"].clone(),
                           results["it"].clone())
        else:
            if "map_none" in results:
                new = results["arg"].clone()
            else:
                if "arglist" in results:
                    args = results["arglist"]
                    if args.type == syms.arglist and \
                       args.children[0].type == token.NAME and \
                       args.children[0].value == "None":
                        self.warning(node, "cannot convert map(None, ...) "
                                     "with multiple arguments because map() "
                                     "now truncates to the shortest sequence")
                        return
                if in_special_context(node):
                    return None
                new = node.clone()
            new.prefix = u""
            new = Call(Name(u"list"), [new])
        new.prefix = node.prefix
        return new
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          Û
”´[c           @   su   d  Z  d d l m Z d d l m Z d d l m Z m Z m Z m	 Z	 d d l
 m Z d e j f d Ñ  É  YZ d S(	   s  Fixer that changes map(F, ...) into list(map(F, ...)) unless there
exists a 'from future_builtins import map' statement in the top-level
namespace.

As a special case, map(None, X) is changed into list(X).  (This is
necessary because the semantics are changed in this case -- the new
map(None, X) is equivalent to [(x,) for x in X].)

We avoid the transformation (except for the special case mentioned
above) if the map() call is directly contained in iter(<>), list(<>),
tuple(<>), sorted(<>), ...join(<>), or for V in <>:.

NOTE: This is still not correct if the original code was depending on
map(F, X, Y, ...) to go on until the longest argument is exhausted,
substituting None for missing values -- like zip(), it now stops as
soon as the shortest argument is exhausted.
i   (   t   token(   t
   fixer_base(   t   Namet   Callt   ListCompt   in_special_context(   t   python_symbolst   FixMapc           B   s#   e  Z e Z d  Z d Z d Ñ  Z RS(   sÈ  
    map_none=power<
        'map'
        trailer< '(' arglist< 'None' ',' arg=any [','] > ')' >
    >
    |
    map_lambda=power<
        'map'
        trailer<
            '('
            arglist<
                lambdef< 'lambda'
                         (fp=NAME | vfpdef< '(' fp=NAME ')'> ) ':' xp=any
                >
                ','
                it=any
            >
            ')'
        >
    >
    |
    power<
        'map' trailer< '(' [arglist=any] ')' >
    >
    s   future_builtins.mapc         C   sÅ  |  j  | É r d  S| j j t j k rh |  j | d É | j É  } d | _ t t	 d É | g É } n	d | k rß t
 | d j É  | d j É  | d j É  É } n  d | k r∆ | d	 j É  } nä d
 | k r4| d
 } | j t j k r4| j d j t j k r4| j d j d k r4|  j | d É d  Sn  t | É rDd  S| j É  } d | _ t t	 d É | g É } | j | _ | S(   Ns   You should use a for loop hereu    u   listt
   map_lambdat   xpt   fpt   itt   map_nonet   argt   arglisti    t   Nonesj   cannot convert map(None, ...) with multiple arguments because map() now truncates to the shortest sequence(   t   should_skipt   parentt   typet   symst   simple_stmtt   warningt   clonet   prefixR   R   R   R   t   childrenR    t   NAMEt   valueR   R   (   t   selft   nodet   resultst   newt   args(    (    s+   /usr/lib/python2.7/lib2to3/fixes/fix_map.pyt	   transform;   s6    	
	(   t   __name__t
   __module__t   Truet   BM_compatiblet   PATTERNt   skip_onR    (    (    (    s+   /usr/lib/python2.7/lib2to3/fixes/fix_map.pyR      s   N(   t   __doc__t   pgen2R    t    R   t
   fixer_utilR   R   R   R   t   pygramR   R   t   ConditionalFixR   (    (    (    s+   /usr/lib/python2.7/lib2to3/fixes/fix_map.pyt   <module>   s
   "                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        """Fixer for __metaclass__ = X -> (metaclass=X) methods.

   The various forms of classef (inherits nothing, inherits once, inherints
   many) don't parse the same in the CST so we look at ALL classes for
   a __metaclass__ and if we find one normalize the inherits to all be
   an arglist.

   For one-liner classes ('class X: pass') there is no indent/dedent so
   we normalize those into having a suite.

   Moving the __metaclass__ into the classdef can also cause the class
   body to be empty so there is some special casing for that as well.

   This fixer also tries very hard to keep original indenting and spacing
   in all those corner cases.

"""
# Author: Jack Diederich

# Local imports
from .. import fixer_base
from ..pygram import token
from ..fixer_util import Name, syms, Node, Leaf


def has_metaclass(parent):
    """ we have to check the cls_node without changing it.
        There are two possibilities:
          1)  clsdef => suite => simple_stmt => expr_stmt => Leaf('__meta')
          2)  clsdef => simple_stmt => expr_stmt => Leaf('__meta')
    """
    for node in parent.children:
        if node.type == syms.suite:
            return has_metaclass(node)
        elif node.type == syms.simple_stmt and node.children:
            expr_node = node.children[0]
            if expr_node.type == syms.expr_stmt and expr_node.children:
                left_side = expr_node.children[0]
                if isinstance(left_side, Leaf) and \
                        left_side.value == '__metaclass__':
                    return True
    return False


def fixup_parse_tree(cls_node):
    """ one-line classes don't get a suite in the parse tree so we add
        one to normalize the tree
    """
    for node in cls_node.children:
        if node.type == syms.suite:
            # already in the preferred format, do nothing
            return

    # !%@#! oneliners have no suite node, we have to fake one up
    for i, node in enumerate(cls_node.children):
        if node.type == token.COLON:
            break
    else:
        raise ValueError("No class suite and no ':'!")

    # move everything into a suite node
    suite = Node(syms.suite, [])
    while cls_node.children[i+1:]:
        move_node = cls_node.children[i+1]
        suite.append_child(move_node.clone())
        move_node.remove()
    cls_node.append_child(suite)
    node = suite


def fixup_simple_stmt(parent, i, stmt_node):
    """ if there is a semi-colon all the parts count as part of the same
        simple_stmt.  We just want the __metaclass__ part so we move
        everything after the semi-colon into its own simple_stmt node
    """
    for semi_ind, node in enumerate(stmt_node.children):
        if node.type == token.SEMI: # *sigh*
            break
    else:
        return

    node.remove() # kill the semicolon
    new_expr = Node(syms.expr_stmt, [])
    new_stmt = Node(syms.simple_stmt, [new_expr])
    while stmt_node.children[semi_ind:]:
        move_node = stmt_node.children[semi_ind]
        new_expr.append_child(move_node.clone())
        move_node.remove()
    parent.insert_child(i, new_stmt)
    new_leaf1 = new_stmt.children[0].children[0]
    old_leaf1 = stmt_node.children[0].children[0]
    new_leaf1.prefix = old_leaf1.prefix


def remove_trailing_newline(node):
    if node.children and node.children[-1].type == token.NEWLINE:
        node.children[-1].remove()


def find_metas(cls_node):
    # find the suite node (Mmm, sweet nodes)
    for node in cls_node.children:
        if node.type == syms.suite:
            break
    else:
        raise ValueError("No class suite!")

    # look for simple_stmt[ expr_stmt[ Leaf('__metaclass__') ] ]
    for i, simple_node in list(enumerate(node.children)):
        if simple_node.type == syms.simple_stmt and simple_node.children:
            expr_node = simple_node.children[0]
            if expr_node.type == syms.expr_stmt and expr_node.children:
                # Check if the expr_node is a simple assignment.
                left_node = expr_node.children[0]
                if isinstance(left_node, Leaf) and \
                        left_node.value == u'__metaclass__':
                    # We found an assignment to __metaclass__.
                    fixup_simple_stmt(node, i, simple_node)
                    remove_trailing_newline(simple_node)
                    yield (node, i, simple_node)


def fixup_indent(suite):
    """ If an INDENT is followed by a thing with a prefix then nuke the prefix
        Otherwise we get in trouble when removing __metaclass__ at suite start
    """
    kids = suite.children[::-1]
    # find the first indent
    while kids:
        node = kids.pop()
        if node.type == token.INDENT:
            break

    # find the first Leaf
    while kids:
        node = kids.pop()
        if isinstance(node, Leaf) and node.type != token.DEDENT:
            if node.prefix:
                node.prefix = u''
            return
        else:
            kids.extend(node.children[::-1])


class FixMetaclass(fixer_base.BaseFix):
    BM_compatible = True

    PATTERN = """
    classdef<any*>
    """

    def transform(self, node, results):
        if not has_metaclass(node):
            return

        fixup_parse_tree(node)

        # find metaclasses, keep the last one
        last_metaclass = None
        for suite, i, stmt in find_metas(node):
            last_metaclass = stmt
            stmt.remove()

        text_type = node.children[0].type # always Leaf(nnn, 'class')

        # figure out what kind of classdef we have
        if len(node.children) == 7:
            # Node(classdef, ['class', 'name', '(', arglist, ')', ':', suite])
            #                 0        1       2    3        4    5    6
            if node.children[3].type == syms.arglist:
                arglist = node.children[3]
            # Node(classdef, ['class', 'name', '(', 'Parent', ')', ':', suite])
            else:
                parent = node.children[3].clone()
                arglist = Node(syms.arglist, [parent])
                node.set_child(3, arglist)
        elif len(node.children) == 6:
            # Node(classdef, ['class', 'name', '(',  ')', ':', suite])
            #                 0        1       2     3    4    5
            arglist = Node(syms.arglist, [])
            node.insert_child(3, arglist)
        elif len(node.children) == 4:
            # Node(classdef, ['class', 'name', ':', suite])
            #                 0        1       2    3
            arglist = Node(syms.arglist, [])
            node.insert_child(2, Leaf(token.RPAR, u')'))
            node.insert_child(2, arglist)
            node.insert_child(2, Leaf(token.LPAR, u'('))
        else:
            raise ValueError("Unexpected class definition")

        # now stick the metaclass in the arglist
        meta_txt = last_metaclass.children[0].children[0]
        meta_txt.value = 'metaclass'
        orig_meta_prefix = meta_txt.prefix

        if arglist.children:
            arglist.append_child(Leaf(token.COMMA, u','))
            meta_txt.prefix = u' '
        else:
            meta_txt.prefix = u''

        # compact the expression "metaclass = Meta" -> "metaclass=Meta"
        expr_stmt = last_metaclass.children[0]
        assert expr_stmt.type == syms.expr_stmt
        expr_stmt.children[1].prefix = u''
        expr_stmt.children[2].prefix = u''

        arglist.append_child(last_metaclass)

        fixup_indent(suite)

        # check for empty suite
        if not suite.children:
            # one-liner that was just __metaclass_
            suite.remove()
            pass_leaf = Leaf(text_type, u'pass')
            pass_leaf.prefix = orig_meta_prefix
            node.append_child(pass_leaf)
            node.append_child(Leaf(token.NEWLINE, u'\n'))

        elif len(suite.children) > 1 and \
                 (suite.children[-2].type == token.INDENT and
                  suite.children[-1].type == token.DEDENT):
            # there was only one line in the class body and it was __metaclass__
            pass_leaf = Leaf(text_type, u'pass')
            suite.insert_child(-1, pass_leaf)
            suite.insert_child(-1, Leaf(token.NEWLINE, u'\n'))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        """Fix bound method attributes (method.im_? -> method.__?__).
"""
# Author: Christian Heimes

# Local imports
from .. import fixer_base
from ..fixer_util import Name

MAP = {
    "im_func" : "__func__",
    "im_self" : "__self__",
    "im_class" : "__self__.__class__"
    }

class FixMethodattrs(fixer_base.BaseFix):
    BM_compatible = True
    PATTERN = """
    power< any+ trailer< '.' attr=('im_func' | 'im_self' | 'im_class') > any* >
    """

    def transform(self, node, results):
        attr = results["attr"][0]
        new = unicode(MAP[attr.value])
        attr.replace(Name(new, prefix=attr.prefix))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         Û
”´[c           @   sõ   d  Z  d d l m Z d d l m Z d d l m Z m Z m Z m	 Z	 d Ñ  Z
 d Ñ  Z d Ñ  Z d Ñ  Z d	 Ñ  Z d
 Ñ  Z d e j f d Ñ  É  YZ d S(   så  Fixer for __metaclass__ = X -> (metaclass=X) methods.

   The various forms of classef (inherits nothing, inherits once, inherints
   many) don't parse the same in the CST so we look at ALL classes for
   a __metaclass__ and if we find one normalize the inherits to all be
   an arglist.

   For one-liner classes ('class X: pass') there is no indent/dedent so
   we normalize those into having a suite.

   Moving the __metaclass__ into the classdef can also cause the class
   body to be empty so there is some special casing for that as well.

   This fixer also tries very hard to keep original indenting and spacing
   in all those corner cases.

i   (   t
   fixer_base(   t   token(   t   Namet   symst   Nodet   Leafc         C   s¨   x• |  j  D]ö } | j t j k r, t | É S| j t j k r
 | j  r
 | j  d } | j t j k r§ | j  r§ | j  d } t | t É r° | j	 d k r° t
 Sq§ q
 q
 Wt S(   sÏ    we have to check the cls_node without changing it.
        There are two possibilities:
          1)  clsdef => suite => simple_stmt => expr_stmt => Leaf('__meta')
          2)  clsdef => simple_stmt => expr_stmt => Leaf('__meta')
    i    t   __metaclass__(   t   childrent   typeR   t   suitet   has_metaclasst   simple_stmtt	   expr_stmtt
   isinstanceR   t   valuet   Truet   False(   t   parentt   nodet	   expr_nodet	   left_side(    (    s1   /usr/lib/python2.7/lib2to3/fixes/fix_metaclass.pyR
      s    
c         C   s€   x' |  j  D] } | j t j k r
 d Sq
 Wx? t |  j  É D]" \ } } | j t j k r: Pq: q: Wt d É Ç t t j g  É } xC |  j  | d r√ |  j  | d } | j	 | j
 É  É | j É  qÅ W|  j	 | É | } d S(   sf    one-line classes don't get a suite in the parse tree so we add
        one to normalize the tree
    Ns   No class suite and no ':'!i   (   R   R   R   R	   t	   enumerateR   t   COLONt
   ValueErrorR   t   append_childt   clonet   remove(   t   cls_nodeR   t   iR	   t	   move_node(    (    s1   /usr/lib/python2.7/lib2to3/fixes/fix_metaclass.pyt   fixup_parse_tree-   s    c   
      C   sÒ   x7 t  | j É D]" \ } } | j t j k r Pq q Wd S| j É  t t j g  É } t t j	 | g É } x; | j | r® | j | } | j
 | j É  É | j É  qn W|  j | | É | j d j d } | j d j d }	 |	 j | _ d S(   s—    if there is a semi-colon all the parts count as part of the same
        simple_stmt.  We just want the __metaclass__ part so we move
        everything after the semi-colon into its own simple_stmt node
    Ni    (   R   R   R   R   t   SEMIR   R   R   R   R   R   R   t   insert_childt   prefix(
   R   R   t	   stmt_nodet   semi_indR   t   new_exprt   new_stmtR   t	   new_leaf1t	   old_leaf1(    (    s1   /usr/lib/python2.7/lib2to3/fixes/fix_metaclass.pyt   fixup_simple_stmtG   s    
c         C   s:   |  j  r6 |  j  d j t j k r6 |  j  d j É  n  d  S(   Niˇˇˇˇ(   R   R   R   t   NEWLINER   (   R   (    (    s1   /usr/lib/python2.7/lib2to3/fixes/fix_metaclass.pyt   remove_trailing_newline_   s    "c         c   sˇ   x3 |  j  D] } | j t j k r
 Pq
 q
 Wt d É Ç x¬ t t | j  É É D]´ \ } } | j t j k rL | j  rL | j  d } | j t j k r˜ | j  r˜ | j  d } t	 | t
 É rÙ | j d k rÙ t | | | É t | É | | | f VqÙ q˜ qL qL Wd  S(   Ns   No class suite!i    u   __metaclass__(   R   R   R   R	   R   t   listR   R   R   R   R   R   R(   R*   (   R   R   R   t   simple_nodeR   t	   left_node(    (    s1   /usr/lib/python2.7/lib2to3/fixes/fix_metaclass.pyt
   find_metasd   s    "
c         C   sπ   |  j  d d d Ö } x, | rD | j É  } | j t j k r Pq q Wxm | r¥ | j É  } t | t É rî | j t j k rî | j rê d | _ n  d S| j	 | j  d d d Ö É qH Wd S(   sõ    If an INDENT is followed by a thing with a prefix then nuke the prefix
        Otherwise we get in trouble when removing __metaclass__ at suite start
    Niˇˇˇˇu    (
   R   t   popR   R   t   INDENTR   R   t   DEDENTR!   t   extend(   R	   t   kidsR   (    (    s1   /usr/lib/python2.7/lib2to3/fixes/fix_metaclass.pyt   fixup_indent{   s    		!	t   FixMetaclassc           B   s   e  Z e Z d  Z d Ñ  Z RS(   s   
    classdef<any*>
    c         C   s'  t  | É s d  St | É d  } x- t | É D] \ } } } | } | j É  q- W| j d j } t | j É d k rŸ | j d j t j	 k rû | j d } që| j d j
 É  }	 t t j	 |	 g É } | j d | É n∏ t | j É d k rt t j	 g  É } | j d | É n~ t | j É d k rÖt t j	 g  É } | j d t t j d É É | j d | É | j d t t j d É É n t d	 É Ç | j d j d }
 d
 |
 _ |
 j } | j rÂ| j t t j d É É d |
 _ n	 d |
 _ | j d } | j t j k st Ç d | j d _ d | j d _ | j | É t | É | j sû| j É  t | d É } | | _ | j | É | j t t j d É É nÖ t | j É d k r#| j d j t j k r#| j d j t j k r#t | d É } | j d | É | j d t t j d É É n  d  S(   Ni    i   i   i   i   i   u   )u   (s   Unexpected class definitiont	   metaclassu   ,u    u    i   u   passu   
i˛ˇˇˇiˇˇˇˇ(   R
   R   t   NoneR.   R   R   R   t   lenR   t   arglistR   R   t	   set_childR    R   R   t   RPARt   LPARR   R   R!   R   t   COMMAR   t   AssertionErrorR4   R)   R0   R1   (   t   selfR   t   resultst   last_metaclassR	   R   t   stmtt	   text_typeR9   R   t   meta_txtt   orig_meta_prefixR   t	   pass_leaf(    (    s1   /usr/lib/python2.7/lib2to3/fixes/fix_metaclass.pyt	   transformò   s`    
				
	
	(   t   __name__t
   __module__R   t   BM_compatiblet   PATTERNRG   (    (    (    s1   /usr/lib/python2.7/lib2to3/fixes/fix_metaclass.pyR5   ë   s   N(   t   __doc__t    R    t   pygramR   t
   fixer_utilR   R   R   R   R
   R   R(   R*   R.   R4   t   BaseFixR5   (    (    (    s1   /usr/lib/python2.7/lib2to3/fixes/fix_metaclass.pyt   <module>   s   "						                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     Û
”´[c           @   s^   d  Z  d d l m Z d d l m Z i d d 6d d 6d d	 6Z d
 e j f d Ñ  É  YZ d S(   s;   Fix bound method attributes (method.im_? -> method.__?__).
i   (   t
   fixer_base(   t   Namet   __func__t   im_funct   __self__t   im_selfs   __self__.__class__t   im_classt   FixMethodattrsc           B   s   e  Z e Z d  Z d Ñ  Z RS(   sU   
    power< any+ trailer< '.' attr=('im_func' | 'im_self' | 'im_class') > any* >
    c         C   sA   | d d } t  t | j É } | j t | d | j ÉÉ d  S(   Nt   attri    t   prefix(   t   unicodet   MAPt   valuet   replaceR   R	   (   t   selft   nodet   resultsR   t   new(    (    s3   /usr/lib/python2.7/lib2to3/fixes/fix_methodattrs.pyt	   transform   s    (   t   __name__t
   __module__t   Truet   BM_compatiblet   PATTERNR   (    (    (    s3   /usr/lib/python2.7/lib2to3/fixes/fix_methodattrs.pyR      s   N(   t   __doc__t    R    t
   fixer_utilR   R   t   BaseFixR   (    (    (    s3   /usr/lib/python2.7/lib2to3/fixes/fix_methodattrs.pyt   <module>   s   
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      # Copyright 2006 Google, Inc. All Rights Reserved.
# Licensed to PSF under a Contributor Agreement.

"""Fixer that turns <> into !=."""

# Local imports
from .. import pytree
from ..pgen2 import token
from .. import fixer_base


class FixNe(fixer_base.BaseFix):
    # This is so simple that we don't need the pattern compiler.

    _accept_type = token.NOTEQUAL

    def match(self, node):
        # Override
        return node.value == u"<>"

    def transform(self, node, results):
        new = pytree.Leaf(token.NOTEQUAL, u"!=", prefix=node.prefix)
        return new
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   Û
”´[c           @   sS   d  Z  d d l m Z d d l m Z d d l m Z d e j f d Ñ  É  YZ d S(   s   Fixer that turns <> into !=.i   (   t   pytree(   t   token(   t
   fixer_baset   FixNec           B   s#   e  Z e j Z d  Ñ  Z d Ñ  Z RS(   c         C   s   | j  d k S(   Nu   <>(   t   value(   t   selft   node(    (    s*   /usr/lib/python2.7/lib2to3/fixes/fix_ne.pyt   match   s    c         C   s"   t  j t j d d | j É} | S(   Nu   !=t   prefix(   R    t   LeafR   t   NOTEQUALR   (   R   R   t   resultst   new(    (    s*   /usr/lib/python2.7/lib2to3/fixes/fix_ne.pyt	   transform   s    (   t   __name__t
   __module__R   R
   t   _accept_typeR   R   (    (    (    s*   /usr/lib/python2.7/lib2to3/fixes/fix_ne.pyR      s   		N(   t   __doc__t    R    t   pgen2R   R   t   BaseFixR   (    (    (    s*   /usr/lib/python2.7/lib2to3/fixes/fix_ne.pyt   <module>   s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  """Fixer for it.next() -> next(it), per PEP 3114."""
# Author: Collin Winter

# Things that currently aren't covered:
#   - listcomp "next" names aren't warned
#   - "with" statement targets aren't checked

# Local imports
from ..pgen2 import token
from ..pygram import python_symbols as syms
from .. import fixer_base
from ..fixer_util import Name, Call, find_binding

bind_warning = "Calls to builtin next() possibly shadowed by global binding"


class FixNext(fixer_base.BaseFix):
    BM_compatible = True
    PATTERN = """
    power< base=any+ trailer< '.' attr='next' > trailer< '(' ')' > >
    |
    power< head=any+ trailer< '.' attr='next' > not trailer< '(' ')' > >
    |
    classdef< 'class' any+ ':'
              suite< any*
                     funcdef< 'def'
                              name='next'
                              parameters< '(' NAME ')' > any+ >
                     any* > >
    |
    global=global_stmt< 'global' any* 'next' any* >
    """

    order = "pre" # Pre-order tree traversal

    def start_tree(self, tree, filename):
        super(FixNext, self).start_tree(tree, filename)

        n = find_binding(u'next', tree)
        if n:
            self.warning(n, bind_warning)
            self.shadowed_next = True
        else:
            self.shadowed_next = False

    def transform(self, node, results):
        assert results

        base = results.get("base")
        attr = results.get("attr")
        name = results.get("name")

        if base:
            if self.shadowed_next:
                attr.replace(Name(u"__next__", prefix=attr.prefix))
            else:
                base = [n.clone() for n in base]
                base[0].prefix = u""
                node.replace(Call(Name(u"next", prefix=node.prefix), base))
        elif name:
            n = Name(u"__next__", prefix=name.prefix)
            name.replace(n)
        elif attr:
            # We don't do this transformation if we're assigning to "x.next".
            # Unfortunately, it doesn't seem possible to do this in PATTERN,
            #  so it's being done here.
            if is_assign_target(node):
                head = results["head"]
                if "".join([str(n) for n in head]).strip() == u'__builtin__':
                    self.warning(node, bind_warning)
                return
            attr.replace(Name(u"__next__"))
        elif "global" in results:
            self.warning(node, bind_warning)
            self.shadowed_next = True


### The following functions help test if node is part of an assignment
###  target.

def is_assign_target(node):
    assign = find_assign(node)
    if assign is None:
        return False

    for child in assign.children:
        if child.type == token.EQUAL:
            return False
        elif is_subtree(child, node):
            return True
    return False

def find_assign(node):
    if node.type == syms.expr_stmt:
        return node
    if node.type == syms.simple_stmt or node.parent is None:
        return None
    return find_assign(node.parent)

def is_subtree(root, node):
    if root == node:
        return True
    return any(is_subtree(c, node) for c in root.children)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   Û
”´[c           @   sê   d  Z  d d l m Z d d l m Z d d l m Z d d l m	 Z	 m
 Z
 m Z d Z d e j f d Ñ  É  YZ d	 Ñ  Z d
 Ñ  Z d Ñ  Z d S(   s.   Fixer for it.next() -> next(it), per PEP 3114.i   (   t   token(   t   python_symbols(   t
   fixer_base(   t   Namet   Callt   find_bindings;   Calls to builtin next() possibly shadowed by global bindingt   FixNextc           B   s,   e  Z e Z d  Z d Z d Ñ  Z d Ñ  Z RS(   sæ  
    power< base=any+ trailer< '.' attr='next' > trailer< '(' ')' > >
    |
    power< head=any+ trailer< '.' attr='next' > not trailer< '(' ')' > >
    |
    classdef< 'class' any+ ':'
              suite< any*
                     funcdef< 'def'
                              name='next'
                              parameters< '(' NAME ')' > any+ >
                     any* > >
    |
    global=global_stmt< 'global' any* 'next' any* >
    t   prec         C   sW   t  t |  É j | | É t d | É } | rJ |  j | t É t |  _ n	 t |  _ d  S(   Nu   next(	   t   superR   t
   start_treeR   t   warningt   bind_warningt   Truet   shadowed_nextt   False(   t   selft   treet   filenamet   n(    (    s,   /usr/lib/python2.7/lib2to3/fixes/fix_next.pyR	   $   s    c         C   sè  | s t  Ç | j d É } | j d É } | j d É } | rª |  j rg | j t d d | j ÉÉ qãg  | D] } | j É  ^ qn } d | d _ | j t t d d | j É| É É n– | rÊ t d d | j É} | j | É n• | rct | É rM| d	 } d
 j	 g  | D] } t
 | É ^ qÉ j É  d k rI|  j | t É n  d  S| j t d É É n( d | k rã|  j | t É t |  _ n  d  S(   Nt   baset   attrt   nameu   __next__t   prefixu    i    u   nextt   headt    u   __builtin__t   global(   t   AssertionErrort   getR   t   replaceR   R   t   cloneR   t   is_assign_targett   joint   strt   stripR
   R   R   (   R   t   nodet   resultsR   R   R   R   R   (    (    s,   /usr/lib/python2.7/lib2to3/fixes/fix_next.pyt	   transform.   s.    	(
4(   t   __name__t
   __module__R   t   BM_compatiblet   PATTERNt   orderR	   R$   (    (    (    s,   /usr/lib/python2.7/lib2to3/fixes/fix_next.pyR      s
   	
c         C   s]   t  |  É } | d  k r t Sx: | j D]/ } | j t j k rB t St | |  É r& t Sq& Wt S(   N(	   t   find_assignt   NoneR   t   childrent   typeR    t   EQUALt
   is_subtreeR   (   R"   t   assignt   child(    (    s,   /usr/lib/python2.7/lib2to3/fixes/fix_next.pyR   Q   s    c         C   sH   |  j  t j k r |  S|  j  t j k s7 |  j d  k r; d  St |  j É S(   N(   R-   t   symst	   expr_stmtt   simple_stmtt   parentR+   R*   (   R"   (    (    s,   /usr/lib/python2.7/lib2to3/fixes/fix_next.pyR*   ]   s
    !c            s-   |  à  k r t  St á  f d Ü  |  j DÉ É S(   Nc         3   s   |  ] } t  | à  É Vq d  S(   N(   R/   (   t   .0t   c(   R"   (    s,   /usr/lib/python2.7/lib2to3/fixes/fix_next.pys	   <genexpr>g   s    (   R   t   anyR,   (   t   rootR"   (    (   R"   s,   /usr/lib/python2.7/lib2to3/fixes/fix_next.pyR/   d   s    N(   t   __doc__t   pgen2R    t   pygramR   R2   R   R   t
   fixer_utilR   R   R   R   t   BaseFixR   R   R*   R/   (    (    (    s,   /usr/lib/python2.7/lib2to3/fixes/fix_next.pyt   <module>   s   @		                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             """Fixer for __nonzero__ -> __bool__ methods."""
# Author: Collin Winter

# Local imports
from .. import fixer_base
from ..fixer_util import Name, syms

class FixNonzero(fixer_base.BaseFix):
    BM_compatible = True
    PATTERN = """
    classdef< 'class' any+ ':'
              suite< any*
                     funcdef< 'def' name='__nonzero__'
                              parameters< '(' NAME ')' > any+ >
                     any* > >
    """

    def transform(self, node, results):
        name = results["name"]
        new = Name(u"__bool__", prefix=name.prefix)
        name.replace(new)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          Û
”´[c           @   sI   d  Z  d d l m Z d d l m Z m Z d e j f d Ñ  É  YZ d S(   s*   Fixer for __nonzero__ -> __bool__ methods.i   (   t
   fixer_base(   t   Namet   symst
   FixNonzeroc           B   s   e  Z e Z d  Z d Ñ  Z RS(   s”   
    classdef< 'class' any+ ':'
              suite< any*
                     funcdef< 'def' name='__nonzero__'
                              parameters< '(' NAME ')' > any+ >
                     any* > >
    c         C   s0   | d } t  d d | j É} | j | É d  S(   Nt   nameu   __bool__t   prefix(   R   R   t   replace(   t   selft   nodet   resultsR   t   new(    (    s/   /usr/lib/python2.7/lib2to3/fixes/fix_nonzero.pyt	   transform   s    
(   t   __name__t
   __module__t   Truet   BM_compatiblet   PATTERNR   (    (    (    s/   /usr/lib/python2.7/lib2to3/fixes/fix_nonzero.pyR      s   N(   t   __doc__t    R    t
   fixer_utilR   R   t   BaseFixR   (    (    (    s/   /usr/lib/python2.7/lib2to3/fixes/fix_nonzero.pyt   <module>   s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             """Fixer that turns 1L into 1, 0755 into 0o755.
"""
# Copyright 2007 Georg Brandl.
# Licensed to PSF under a Contributor Agreement.

# Local imports
from ..pgen2 import token
from .. import fixer_base
from ..fixer_util import Number


class FixNumliterals(fixer_base.BaseFix):
    # This is so simple that we don't need the pattern compiler.

    _accept_type = token.NUMBER

    def match(self, node):
        # Override
        return (node.value.startswith(u"0") or node.value[-1] in u"Ll")

    def transform(self, node, results):
        val = node.value
        if val[-1] in u'Ll':
            val = val[:-1]
        elif val.startswith(u'0') and val.isdigit() and len(set(val)) > 1:
            val = u"0o" + val[1:]

        return Number(val, prefix=node.prefix)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Û
”´[c           @   sS   d  Z  d d l m Z d d l m Z d d l m Z d e j f d Ñ  É  YZ d S(   s-   Fixer that turns 1L into 1, 0755 into 0o755.
i   (   t   token(   t
   fixer_base(   t   Numbert   FixNumliteralsc           B   s#   e  Z e j Z d  Ñ  Z d Ñ  Z RS(   c         C   s#   | j  j d É p" | j  d d k S(   Nu   0iˇˇˇˇu   Ll(   t   valuet
   startswith(   t   selft   node(    (    s3   /usr/lib/python2.7/lib2to3/fixes/fix_numliterals.pyt   match   s    c         C   s}   | j  } | d d k r& | d  } nD | j d É rj | j É  rj t t | É É d k rj d | d } n  t | d | j ÉS(   Niˇˇˇˇu   Llu   0i   u   0ot   prefix(   R   R   t   isdigitt   lent   setR   R	   (   R   R   t   resultst   val(    (    s3   /usr/lib/python2.7/lib2to3/fixes/fix_numliterals.pyt	   transform   s    	3(   t   __name__t
   __module__R    t   NUMBERt   _accept_typeR   R   (    (    (    s3   /usr/lib/python2.7/lib2to3/fixes/fix_numliterals.pyR      s   		N(	   t   __doc__t   pgen2R    t    R   t
   fixer_utilR   t   BaseFixR   (    (    (    s3   /usr/lib/python2.7/lib2to3/fixes/fix_numliterals.pyt   <module>   s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          """Fixer for operator functions.

operator.isCallable(obj)       -> hasattr(obj, '__call__')
operator.sequenceIncludes(obj) -> operator.contains(obj)
operator.isSequenceType(obj)   -> isinstance(obj, collections.Sequence)
operator.isMappingType(obj)    -> isinstance(obj, collections.Mapping)
operator.isNumberType(obj)     -> isinstance(obj, numbers.Number)
operator.repeat(obj, n)        -> operator.mul(obj, n)
operator.irepeat(obj, n)       -> operator.imul(obj, n)
"""

# Local imports
from lib2to3 import fixer_base
from lib2to3.fixer_util import Call, Name, String, touch_import


def invocation(s):
    def dec(f):
        f.invocation = s
        return f
    return dec


class FixOperator(fixer_base.BaseFix):
    BM_compatible = True
    order = "pre"

    methods = """
              method=('isCallable'|'sequenceIncludes'
                     |'isSequenceType'|'isMappingType'|'isNumberType'
                     |'repeat'|'irepeat')
              """
    obj = "'(' obj=any ')'"
    PATTERN = """
              power< module='operator'
                trailer< '.' %(methods)s > trailer< %(obj)s > >
              |
              power< %(methods)s trailer< %(obj)s > >
              """ % dict(methods=methods, obj=obj)

    def transform(self, node, results):
        method = self._check_method(node, results)
        if method is not None:
            return method(node, results)

    @invocation("operator.contains(%s)")
    def _sequenceIncludes(self, node, results):
        return self._handle_rename(node, results, u"contains")

    @invocation("hasattr(%s, '__call__')")
    def _isCallable(self, node, results):
        obj = results["obj"]
        args = [obj.clone(), String(u", "), String(u"'__call__'")]
        return Call(Name(u"hasattr"), args, prefix=node.prefix)

    @invocation("operator.mul(%s)")
    def _repeat(self, node, results):
        return self._handle_rename(node, results, u"mul")

    @invocation("operator.imul(%s)")
    def _irepeat(self, node, results):
        return self._handle_rename(node, results, u"imul")

    @invocation("isinstance(%s, collections.Sequence)")
    def _isSequenceType(self, node, results):
        return self._handle_type2abc(node, results, u"collections", u"Sequence")

    @invocation("isinstance(%s, collections.Mapping)")
    def _isMappingType(self, node, results):
        return self._handle_type2abc(node, results, u"collections", u"Mapping")

    @invocation("isinstance(%s, numbers.Number)")
    def _isNumberType(self, node, results):
        return self._handle_type2abc(node, results, u"numbers", u"Number")

    def _handle_rename(self, node, results, name):
        method = results["method"][0]
        method.value = name
        method.changed()

    def _handle_type2abc(self, node, results, module, abc):
        touch_import(None, module, node)
        obj = results["obj"]
        args = [obj.clone(), String(u", " + u".".join([module, abc]))]
        return Call(Name(u"isinstance"), args, prefix=node.prefix)

    def _check_method(self, node, results):
        method = getattr(self, "_" + results["method"][0].value.encode("ascii"))
        if callable(method):
            if "module" in results:
                return method
            else:
                sub = (unicode(results["obj"]),)
                invocation_str = unicode(method.invocation) % sub
                self.warning(node, u"You should use '%s' here." % invocation_str)
        return None
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                Û
”´[c           @   s^   d  Z  d d l m Z d d l m Z m Z m Z m Z d Ñ  Z d e j	 f d Ñ  É  YZ
 d S(   s”  Fixer for operator functions.

operator.isCallable(obj)       -> hasattr(obj, '__call__')
operator.sequenceIncludes(obj) -> operator.contains(obj)
operator.isSequenceType(obj)   -> isinstance(obj, collections.Sequence)
operator.isMappingType(obj)    -> isinstance(obj, collections.Mapping)
operator.isNumberType(obj)     -> isinstance(obj, numbers.Number)
operator.repeat(obj, n)        -> operator.mul(obj, n)
operator.irepeat(obj, n)       -> operator.imul(obj, n)
iˇˇˇˇ(   t
   fixer_base(   t   Callt   Namet   Stringt   touch_importc            s   á  f d Ü  } | S(   Nc            s   à  |  _  |  S(   N(   t
   invocation(   t   f(   t   s(    s0   /usr/lib/python2.7/lib2to3/fixes/fix_operator.pyt   dec   s    	(    (   R   R   (    (   R   s0   /usr/lib/python2.7/lib2to3/fixes/fix_operator.pyR      s    t   FixOperatorc           B   s   e  Z e Z d  Z d Z d Z d e d e d e É Z d Ñ  Z	 e
 d É d Ñ  É Z e
 d	 É d
 Ñ  É Z e
 d É d Ñ  É Z e
 d É d Ñ  É Z e
 d É d Ñ  É Z e
 d É d Ñ  É Z e
 d É d Ñ  É Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   t   presµ   
              method=('isCallable'|'sequenceIncludes'
                     |'isSequenceType'|'isMappingType'|'isNumberType'
                     |'repeat'|'irepeat')
              s   '(' obj=any ')'sº   
              power< module='operator'
                trailer< '.' %(methods)s > trailer< %(obj)s > >
              |
              power< %(methods)s trailer< %(obj)s > >
              t   methodst   objc         C   s/   |  j  | | É } | d  k	 r+ | | | É Sd  S(   N(   t   _check_methodt   None(   t   selft   nodet   resultst   method(    (    s0   /usr/lib/python2.7/lib2to3/fixes/fix_operator.pyt	   transform)   s    s   operator.contains(%s)c         C   s   |  j  | | d É S(   Nu   contains(   t   _handle_rename(   R   R   R   (    (    s0   /usr/lib/python2.7/lib2to3/fixes/fix_operator.pyt   _sequenceIncludes.   s    s   hasattr(%s, '__call__')c         C   sG   | d } | j  É  t d É t d É g } t t d É | d | j ÉS(   NR   u   , u
   '__call__'u   hasattrt   prefix(   t   cloneR   R   R   R   (   R   R   R   R   t   args(    (    s0   /usr/lib/python2.7/lib2to3/fixes/fix_operator.pyt   _isCallable2   s    
!s   operator.mul(%s)c         C   s   |  j  | | d É S(   Nu   mul(   R   (   R   R   R   (    (    s0   /usr/lib/python2.7/lib2to3/fixes/fix_operator.pyt   _repeat8   s    s   operator.imul(%s)c         C   s   |  j  | | d É S(   Nu   imul(   R   (   R   R   R   (    (    s0   /usr/lib/python2.7/lib2to3/fixes/fix_operator.pyt   _irepeat<   s    s$   isinstance(%s, collections.Sequence)c         C   s   |  j  | | d d É S(   Nu   collectionsu   Sequence(   t   _handle_type2abc(   R   R   R   (    (    s0   /usr/lib/python2.7/lib2to3/fixes/fix_operator.pyt   _isSequenceType@   s    s#   isinstance(%s, collections.Mapping)c         C   s   |  j  | | d d É S(   Nu   collectionsu   Mapping(   R   (   R   R   R   (    (    s0   /usr/lib/python2.7/lib2to3/fixes/fix_operator.pyt   _isMappingTypeD   s    s   isinstance(%s, numbers.Number)c         C   s   |  j  | | d d É S(   Nu   numbersu   Number(   R   (   R   R   R   (    (    s0   /usr/lib/python2.7/lib2to3/fixes/fix_operator.pyt   _isNumberTypeH   s    c         C   s%   | d d } | | _  | j É  d  S(   NR   i    (   t   valuet   changed(   R   R   R   t   nameR   (    (    s0   /usr/lib/python2.7/lib2to3/fixes/fix_operator.pyR   L   s    	c         C   sa   t  d  | | É | d } | j É  t d d j | | g É É g } t t d É | d | j ÉS(   NR   u   , u   .u
   isinstanceR   (   R   R   R   R   t   joinR   R   R   (   R   R   R   t   modulet   abcR   R   (    (    s0   /usr/lib/python2.7/lib2to3/fixes/fix_operator.pyR   Q   s    
+c         C   sÑ   t  |  d | d d j j d É É } t | É rÄ d | k rC | St | d É f } t | j É | } |  j | d | É n  d  S(   Nt   _R   i    t   asciiR$   R   u   You should use '%s' here.(   t   getattrR    t   encodet   callablet   unicodeR   t   warningR   (   R   R   R   R   t   subt   invocation_str(    (    s0   /usr/lib/python2.7/lib2to3/fixes/fix_operator.pyR   W   s    '(   t   __name__t
   __module__t   Truet   BM_compatiblet   orderR   R   t   dictt   PATTERNR   R   R   R   R   R   R   R   R   R   R   R   (    (    (    s0   /usr/lib/python2.7/lib2to3/fixes/fix_operator.pyR	      s    			N(   t   __doc__t   lib2to3R    t   lib2to3.fixer_utilR   R   R   R   R   t   BaseFixR	   (    (    (    s0   /usr/lib/python2.7/lib2to3/fixes/fix_operator.pyt   <module>
   s   "	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                """Fixer that addes parentheses where they are required

This converts ``[x for x in 1, 2]`` to ``[x for x in (1, 2)]``."""

# By Taek Joo Kim and Benjamin Peterson

# Local imports
from .. import fixer_base
from ..fixer_util import LParen, RParen

# XXX This doesn't support nested for loops like [x for x in 1, 2 for x in 1, 2]
class FixParen(fixer_base.BaseFix):
    BM_compatible = True

    PATTERN = """
        atom< ('[' | '(')
            (listmaker< any
                comp_for<
                    'for' NAME 'in'
                    target=testlist_safe< any (',' any)+ [',']
                     >
                    [any]
                >
            >
            |
            testlist_gexp< any
                comp_for<
                    'for' NAME 'in'
                    target=testlist_safe< any (',' any)+ [',']
                     >
                    [any]
                >
            >)
        (']' | ')') >
    """

    def transform(self, node, results):
        target = results["target"]

        lparen = LParen()
        lparen.prefix = target.prefix
        target.prefix = u"" # Make it hug the parentheses
        target.insert_child(0, lparen)
        target.append_child(RParen())
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Û
”´[c           @   sI   d  Z  d d l m Z d d l m Z m Z d e j f d Ñ  É  YZ d S(   su   Fixer that addes parentheses where they are required

This converts ``[x for x in 1, 2]`` to ``[x for x in (1, 2)]``.i   (   t
   fixer_base(   t   LParent   RParent   FixParenc           B   s   e  Z e Z d  Z d Ñ  Z RS(   s  
        atom< ('[' | '(')
            (listmaker< any
                comp_for<
                    'for' NAME 'in'
                    target=testlist_safe< any (',' any)+ [',']
                     >
                    [any]
                >
            >
            |
            testlist_gexp< any
                comp_for<
                    'for' NAME 'in'
                    target=testlist_safe< any (',' any)+ [',']
                     >
                    [any]
                >
            >)
        (']' | ')') >
    c         C   sL   | d } t  É  } | j | _ d | _ | j d | É | j t É  É d  S(   Nt   targetu    i    (   R   t   prefixt   insert_childt   append_childR   (   t   selft   nodet   resultsR   t   lparen(    (    s-   /usr/lib/python2.7/lib2to3/fixes/fix_paren.pyt	   transform%   s    
		(   t   __name__t
   __module__t   Truet   BM_compatiblet   PATTERNR   (    (    (    s-   /usr/lib/python2.7/lib2to3/fixes/fix_paren.pyR      s   N(   t   __doc__t    R    t
   fixer_utilR   R   t   BaseFixR   (    (    (    s-   /usr/lib/python2.7/lib2to3/fixes/fix_paren.pyt   <module>   s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    # Copyright 2006 Google, Inc. All Rights Reserved.
# Licensed to PSF under a Contributor Agreement.

"""Fixer for print.

Change:
    'print'          into 'print()'
    'print ...'      into 'print(...)'
    'print ... ,'    into 'print(..., end=" ")'
    'print >>x, ...' into 'print(..., file=x)'

No changes are applied if print_function is imported from __future__

"""

# Local imports
from .. import patcomp
from .. import pytree
from ..pgen2 import token
from .. import fixer_base
from ..fixer_util import Name, Call, Comma, String, is_tuple


parend_expr = patcomp.compile_pattern(
              """atom< '(' [atom|STRING|NAME] ')' >"""
              )


class FixPrint(fixer_base.BaseFix):

    BM_compatible = True

    PATTERN = """
              simple_stmt< any* bare='print' any* > | print_stmt
              """

    def transform(self, node, results):
        assert results

        bare_print = results.get("bare")

        if bare_print:
            # Special-case print all by itself
            bare_print.replace(Call(Name(u"print"), [],
                               prefix=bare_print.prefix))
            return
        assert node.children[0] == Name(u"print")
        args = node.children[1:]
        if len(args) == 1 and parend_expr.match(args[0]):
            # We don't want to keep sticking parens around an
            # already-parenthesised expression.
            return

        sep = end = file = None
        if args and args[-1] == Comma():
            args = args[:-1]
            end = " "
        if args and args[0] == pytree.Leaf(token.RIGHTSHIFT, u">>"):
            assert len(args) >= 2
            file = args[1].clone()
            args = args[3:] # Strip a possible comma after the file expression
        # Now synthesize a print(args, sep=..., end=..., file=...) node.
        l_args = [arg.clone() for arg in args]
        if l_args:
            l_args[0].prefix = u""
        if sep is not None or end is not None or file is not None:
            if sep is not None:
                self.add_kwarg(l_args, u"sep", String(repr(sep)))
            if end is not None:
                self.add_kwarg(l_args, u"end", String(repr(end)))
            if file is not None:
                self.add_kwarg(l_args, u"file", file)
        n_stmt = Call(Name(u"print"), l_args)
        n_stmt.prefix = node.prefix
        return n_stmt

    def add_kwarg(self, l_nodes, s_kwd, n_expr):
        # XXX All this prefix-setting may lose comments (though rarely)
        n_expr.prefix = u""
        n_argument = pytree.Node(self.syms.argument,
                                 (Name(s_kwd),
                                  pytree.Leaf(token.EQUAL, u"="),
                                  n_expr))
        if l_nodes:
            l_nodes.append(Comma())
            n_argument.prefix = u" "
        l_nodes.append(n_argument)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               Û
”´[c           @   sö   d  Z  d d l m Z d d l m Z d d l m Z d d l m Z d d l m Z m	 Z	 m
 Z
 m Z m Z e j d É Z d e j f d	 Ñ  É  YZ d
 S(   s  Fixer for print.

Change:
    'print'          into 'print()'
    'print ...'      into 'print(...)'
    'print ... ,'    into 'print(..., end=" ")'
    'print >>x, ...' into 'print(..., file=x)'

No changes are applied if print_function is imported from __future__

i   (   t   patcomp(   t   pytree(   t   token(   t
   fixer_base(   t   Namet   Callt   Commat   Stringt   is_tuples"   atom< '(' [atom|STRING|NAME] ')' >t   FixPrintc           B   s&   e  Z e Z d  Z d Ñ  Z d Ñ  Z RS(   sP   
              simple_stmt< any* bare='print' any* > | print_stmt
              c         C   s2  | s t  Ç | j d É } | rJ | j t t d É g  d | j ÉÉ d  S| j d t d É k si t  Ç | j d } t | É d k rü t j	 | d É rü d  Sd  } } } | rŸ | d t É  k rŸ | d  } d } n  | r3| d t j t j d É k r3t | É d	 k st  Ç | d j É  } | d
 } n  g  | D] } | j É  ^ q:}	 |	 rhd |	 d _ n  | d  k	 så| d  k	 så| d  k	 r| d  k	 r∫|  j |	 d t t | É É É n  | d  k	 rË|  j |	 d t t | É É É n  | d  k	 r|  j |	 d | É qn  t t d É |	 É }
 | j |
 _ |
 S(   Nt   bareu   printt   prefixi    i   iˇˇˇˇt    u   >>i   i   u    u   sepu   endu   file(   t   AssertionErrort   gett   replaceR   R   R   t   childrent   lent   parend_exprt   matcht   NoneR   R   t   LeafR   t
   RIGHTSHIFTt   clonet	   add_kwargR   t   repr(   t   selft   nodet   resultst
   bare_printt   argst   sept   endt   filet   argt   l_argst   n_stmt(    (    s-   /usr/lib/python2.7/lib2to3/fixes/fix_print.pyt	   transform%   s>    %
	%$""c         C   sr   d | _  t j |  j j t | É t j t j d É | f É } | ra | j	 t
 É  É d | _  n  | j	 | É d  S(   Nu    u   =u    (   R   R   t   Nodet   symst   argumentR   R   R   t   EQUALt   appendR   (   R   t   l_nodest   s_kwdt   n_exprt
   n_argument(    (    s-   /usr/lib/python2.7/lib2to3/fixes/fix_print.pyR   M   s    		(   t   __name__t
   __module__t   Truet   BM_compatiblet   PATTERNR%   R   (    (    (    s-   /usr/lib/python2.7/lib2to3/fixes/fix_print.pyR	      s   	(N(   t   __doc__t    R    R   t   pgen2R   R   t
   fixer_utilR   R   R   R   R   t   compile_patternR   t   BaseFixR	   (    (    (    s-   /usr/lib/python2.7/lib2to3/fixes/fix_print.pyt   <module>   s   (	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 """Fixer for 'raise E, V, T'

raise         -> raise
raise E       -> raise E
raise E, V    -> raise E(V)
raise E, V, T -> raise E(V).with_traceback(T)
raise E, None, T -> raise E.with_traceback(T)

raise (((E, E'), E''), E'''), V -> raise E(V)
raise "foo", V, T               -> warns about string exceptions


CAVEATS:
1) "raise E, V" will be incorrectly translated if V is an exception
   instance. The correct Python 3 idiom is

        raise E from V

   but since we can't detect instance-hood by syntax alone and since
   any client code would have to be changed as well, we don't automate
   this.
"""
# Author: Collin Winter

# Local imports
from .. import pytree
from ..pgen2 import token
from .. import fixer_base
from ..fixer_util import Name, Call, Attr, ArgList, is_tuple

class FixRaise(fixer_base.BaseFix):

    BM_compatible = True
    PATTERN = """
    raise_stmt< 'raise' exc=any [',' val=any [',' tb=any]] >
    """

    def transform(self, node, results):
        syms = self.syms

        exc = results["exc"].clone()
        if exc.type == token.STRING:
            msg = "Python 3 does not support string exceptions"
            self.cannot_convert(node, msg)
            return

        # Python 2 supports
        #  raise ((((E1, E2), E3), E4), E5), V
        # as a synonym for
        #  raise E1, V
        # Since Python 3 will not support this, we recurse down any tuple
        # literals, always taking the first element.
        if is_tuple(exc):
            while is_tuple(exc):
                # exc.children[1:-1] is the unparenthesized tuple
                # exc.children[1].children[0] is the first element of the tuple
                exc = exc.children[1].children[0].clone()
            exc.prefix = u" "

        if "val" not in results:
            # One-argument raise
            new = pytree.Node(syms.raise_stmt, [Name(u"raise"), exc])
            new.prefix = node.prefix
            return new

        val = results["val"].clone()
        if is_tuple(val):
            args = [c.clone() for c in val.children[1:-1]]
        else:
            val.prefix = u""
            args = [val]

        if "tb" in results:
            tb = results["tb"].clone()
            tb.prefix = u""

            e = exc
            # If there's a traceback and None is passed as the value, then don't
            # add a call, since the user probably just wants to add a
            # traceback. See issue #9661.
            if val.type != token.NAME or val.value != u"None":
                e = Call(exc, args)
            with_tb = Attr(e, Name(u'with_traceback')) + [ArgList([tb])]
            new = pytree.Node(syms.simple_stmt, [Name(u"raise")] + with_tb)
            new.prefix = node.prefix
            return new
        else:
            return pytree.Node(syms.raise_stmt,
                               [Name(u"raise"), Call(exc, args)],
                               prefix=node.prefix)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          Û
”´[c           @   s{   d  Z  d d l m Z d d l m Z d d l m Z d d l m Z m Z m	 Z	 m
 Z
 m Z d e j f d Ñ  É  YZ d S(	   s[  Fixer for 'raise E, V, T'

raise         -> raise
raise E       -> raise E
raise E, V    -> raise E(V)
raise E, V, T -> raise E(V).with_traceback(T)
raise E, None, T -> raise E.with_traceback(T)

raise (((E, E'), E''), E'''), V -> raise E(V)
raise "foo", V, T               -> warns about string exceptions


CAVEATS:
1) "raise E, V" will be incorrectly translated if V is an exception
   instance. The correct Python 3 idiom is

        raise E from V

   but since we can't detect instance-hood by syntax alone and since
   any client code would have to be changed as well, we don't automate
   this.
i   (   t   pytree(   t   token(   t
   fixer_base(   t   Namet   Callt   Attrt   ArgListt   is_tuplet   FixRaisec           B   s   e  Z e Z d  Z d Ñ  Z RS(   sB   
    raise_stmt< 'raise' exc=any [',' val=any [',' tb=any]] >
    c         C   s  |  j  } | d j É  } | j t j k rE d } |  j | | É d  St | É rä x* t | É r} | j d j d j É  } qT Wd | _ n  d | k r« t	 j
 | j t d É | g É } | j | _ | S| d j É  } t | É rg  | j d d !D] } | j É  ^ qÙ }	 n d	 | _ | g }	 d
 | k r÷| d
 j É  }
 d	 |
 _ | } | j t j k sm| j d k rt | |	 É } n  t | t d É É t |
 g É g } t	 j
 | j t d É g | É } | j | _ | St	 j
 | j t d É t | |	 É g d | j ÉSd  S(   Nt   excs+   Python 3 does not support string exceptionsi   i    u    t   valu   raiseiˇˇˇˇu    t   tbu   Noneu   with_tracebackt   prefix(   t   symst   clonet   typeR   t   STRINGt   cannot_convertR   t   childrenR   R    t   Nodet
   raise_stmtR   t   NAMEt   valueR   R   R   t   simple_stmt(   t   selft   nodet   resultsR   R	   t   msgt   newR
   t   ct   argsR   t   et   with_tb(    (    s-   /usr/lib/python2.7/lib2to3/fixes/fix_raise.pyt	   transform&   s@    	!,			!%"(   t   __name__t
   __module__t   Truet   BM_compatiblet   PATTERNR!   (    (    (    s-   /usr/lib/python2.7/lib2to3/fixes/fix_raise.pyR      s   N(   t   __doc__t    R    t   pgen2R   R   t
   fixer_utilR   R   R   R   R   t   BaseFixR   (    (    (    s-   /usr/lib/python2.7/lib2to3/fixes/fix_raise.pyt   <module>   s
   (                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      """Fixer that changes raw_input(...) into input(...)."""
# Author: Andre Roberge

# Local imports
from .. import fixer_base
from ..fixer_util import Name

class FixRawInput(fixer_base.BaseFix):

    BM_compatible = True
    PATTERN = """
              power< name='raw_input' trailer< '(' [any] ')' > any* >
              """

    def transform(self, node, results):
        name = results["name"]
        name.replace(Name(u"input", prefix=name.prefix))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         Û
”´[c           @   sC   d  Z  d d l m Z d d l m Z d e j f d Ñ  É  YZ d S(   s2   Fixer that changes raw_input(...) into input(...).i   (   t
   fixer_base(   t   Namet   FixRawInputc           B   s   e  Z e Z d  Z d Ñ  Z RS(   sU   
              power< name='raw_input' trailer< '(' [any] ')' > any* >
              c         C   s*   | d } | j  t d d | j ÉÉ d  S(   Nt   nameu   inputt   prefix(   t   replaceR   R   (   t   selft   nodet   resultsR   (    (    s1   /usr/lib/python2.7/lib2to3/fixes/fix_raw_input.pyt	   transform   s    
(   t   __name__t
   __module__t   Truet   BM_compatiblet   PATTERNR	   (    (    (    s1   /usr/lib/python2.7/lib2to3/fixes/fix_raw_input.pyR      s   N(   t   __doc__t    R    t
   fixer_utilR   t   BaseFixR   (    (    (    s1   /usr/lib/python2.7/lib2to3/fixes/fix_raw_input.pyt   <module>   s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   # Copyright 2008 Armin Ronacher.
# Licensed to PSF under a Contributor Agreement.

"""Fixer for reduce().

Makes sure reduce() is imported from the functools module if reduce is
used in that module.
"""

from lib2to3 import fixer_base
from lib2to3.fixer_util import touch_import



class FixReduce(fixer_base.BaseFix):

    BM_compatible = True
    order = "pre"

    PATTERN = """
    power< 'reduce'
        trailer< '('
            arglist< (
                (not(argument<any '=' any>) any ','
                 not(argument<any '=' any>) any) |
                (not(argument<any '=' any>) any ','
                 not(argument<any '=' any>) any ','
                 not(argument<any '=' any>) any)
            ) >
        ')' >
    >
    """

    def transform(self, node, results):
        touch_import(u'functools', u'reduce', node)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         Û
”´[c           @   sC   d  Z  d d l m Z d d l m Z d e j f d Ñ  É  YZ d S(   sq   Fixer for reduce().

Makes sure reduce() is imported from the functools module if reduce is
used in that module.
iˇˇˇˇ(   t
   fixer_base(   t   touch_importt	   FixReducec           B   s#   e  Z e Z d  Z d Z d Ñ  Z RS(   t   presi  
    power< 'reduce'
        trailer< '('
            arglist< (
                (not(argument<any '=' any>) any ','
                 not(argument<any '=' any>) any) |
                (not(argument<any '=' any>) any ','
                 not(argument<any '=' any>) any ','
                 not(argument<any '=' any>) any)
            ) >
        ')' >
    >
    c         C   s   t  d d | É d  S(   Nu	   functoolsu   reduce(   R   (   t   selft   nodet   results(    (    s.   /usr/lib/python2.7/lib2to3/fixes/fix_reduce.pyt	   transform"   s    (   t   __name__t
   __module__t   Truet   BM_compatiblet   ordert   PATTERNR   (    (    (    s.   /usr/lib/python2.7/lib2to3/fixes/fix_reduce.pyR      s   N(   t   __doc__t   lib2to3R    t   lib2to3.fixer_utilR   t   BaseFixR   (    (    (    s.   /usr/lib/python2.7/lib2to3/fixes/fix_reduce.pyt   <module>   s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             """Fix incompatible renames

Fixes:
  * sys.maxint -> sys.maxsize
"""
# Author: Christian Heimes
# based on Collin Winter's fix_import

# Local imports
from .. import fixer_base
from ..fixer_util import Name, attr_chain

MAPPING = {"sys":  {"maxint" : "maxsize"},
          }
LOOKUP = {}

def alternates(members):
    return "(" + "|".join(map(repr, members)) + ")"


def build_pattern():
    #bare = set()
    for module, replace in MAPPING.items():
        for old_attr, new_attr in replace.items():
            LOOKUP[(module, old_attr)] = new_attr
            #bare.add(module)
            #bare.add(old_attr)
            #yield """
            #      import_name< 'import' (module=%r
            #          | dotted_as_names< any* module=%r any* >) >
            #      """ % (module, module)
            yield """
                  import_from< 'from' module_name=%r 'import'
                      ( attr_name=%r | import_as_name< attr_name=%r 'as' any >) >
                  """ % (module, old_attr, old_attr)
            yield """
                  power< module_name=%r trailer< '.' attr_name=%r > any* >
                  """ % (module, old_attr)
    #yield """bare_name=%s""" % alternates(bare)


class FixRenames(fixer_base.BaseFix):
    BM_compatible = True
    PATTERN = "|".join(build_pattern())

    order = "pre" # Pre-order tree traversal

    # Don't match the node if it's within another match
    def match(self, node):
        match = super(FixRenames, self).match
        results = match(node)
        if results:
            if any(match(obj) for obj in attr_chain(node, "parent")):
                return False
            return results
        return False

    #def start_tree(self, tree, filename):
    #    super(FixRenames, self).start_tree(tree, filename)
    #    self.replace = {}

    def transform(self, node, results):
        mod_name = results.get("module_name")
        attr_name = results.get("attr_name")
        #bare_name = results.get("bare_name")
        #import_mod = results.get("module")

        if mod_name and attr_name:
            new_attr = unicode(LOOKUP[(mod_name.value, attr_name.value)])
            attr_name.replace(Name(new_attr, prefix=attr_name.prefix))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      Û
”´[c           @   su   d  Z  d d l m Z d d l m Z m Z i i d d 6d 6Z i  Z d Ñ  Z d Ñ  Z	 d	 e j
 f d
 Ñ  É  YZ d S(   s?   Fix incompatible renames

Fixes:
  * sys.maxint -> sys.maxsize
i   (   t
   fixer_base(   t   Namet
   attr_chaint   maxsizet   maxintt   sysc         C   s   d d j  t t |  É É d S(   Nt   (t   |t   )(   t   joint   mapt   repr(   t   members(    (    s/   /usr/lib/python2.7/lib2to3/fixes/fix_renames.pyt
   alternates   s    c          c   so   xh t  j É  D]Z \ }  } xK | j É  D]= \ } } | t |  | f <d |  | | f Vd |  | f Vq& Wq Wd  S(   Ns£   
                  import_from< 'from' module_name=%r 'import'
                      ( attr_name=%r | import_as_name< attr_name=%r 'as' any >) >
                  s^   
                  power< module_name=%r trailer< '.' attr_name=%r > any* >
                  (   t   MAPPINGt   itemst   LOOKUP(   t   modulet   replacet   old_attrt   new_attr(    (    s/   /usr/lib/python2.7/lib2to3/fixes/fix_renames.pyt   build_pattern   s
    
t
   FixRenamesc           B   s8   e  Z e Z d  j e É  É Z d Z d Ñ  Z d Ñ  Z	 RS(   R   t   prec            sU   t  t |  É j â  à  | É } | rQ t á  f d Ü  t | d É DÉ É rM t S| St S(   Nc         3   s   |  ] } à  | É Vq d  S(   N(    (   t   .0t   obj(   t   match(    s/   /usr/lib/python2.7/lib2to3/fixes/fix_renames.pys	   <genexpr>5   s    t   parent(   t   superR   R   t   anyR   t   False(   t   selft   nodet   results(    (   R   s/   /usr/lib/python2.7/lib2to3/fixes/fix_renames.pyR   1   s    %c         C   si   | j  d É } | j  d É } | re | re t t | j | j f É } | j t | d | j ÉÉ n  d  S(   Nt   module_namet	   attr_namet   prefix(   t   gett   unicodeR   t   valueR   R   R$   (   R   R    R!   t   mod_nameR#   R   (    (    s/   /usr/lib/python2.7/lib2to3/fixes/fix_renames.pyt	   transform>   s
    (
   t   __name__t
   __module__t   Truet   BM_compatibleR	   R   t   PATTERNt   orderR   R)   (    (    (    s/   /usr/lib/python2.7/lib2to3/fixes/fix_renames.pyR   *   s
   	N(   t   __doc__t    R    t
   fixer_utilR   R   R   R   R   R   t   BaseFixR   (    (    (    s/   /usr/lib/python2.7/lib2to3/fixes/fix_renames.pyt   <module>   s   		                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       # Copyright 2006 Google, Inc. All Rights Reserved.
# Licensed to PSF under a Contributor Agreement.

"""Fixer that transforms `xyzzy` into repr(xyzzy)."""

# Local imports
from .. import fixer_base
from ..fixer_util import Call, Name, parenthesize


class FixRepr(fixer_base.BaseFix):

    BM_compatible = True
    PATTERN = """
              atom < '`' expr=any '`' >
              """

    def transform(self, node, results):
        expr = results["expr"].clone()

        if expr.type == self.syms.testlist1:
            expr = parenthesize(expr)
        return Call(Name(u"repr"), [expr], prefix=node.prefix)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          Û
”´[c           @   sO   d  Z  d d l m Z d d l m Z m Z m Z d e j f d Ñ  É  YZ d S(   s/   Fixer that transforms `xyzzy` into repr(xyzzy).i   (   t
   fixer_base(   t   Callt   Namet   parenthesizet   FixReprc           B   s   e  Z e Z d  Z d Ñ  Z RS(   s7   
              atom < '`' expr=any '`' >
              c         C   sS   | d j  É  } | j |  j j k r4 t | É } n  t t d É | g d | j ÉS(   Nt   expru   reprt   prefix(   t   clonet   typet   symst	   testlist1R   R   R   R   (   t   selft   nodet   resultsR   (    (    s,   /usr/lib/python2.7/lib2to3/fixes/fix_repr.pyt	   transform   s    (   t   __name__t
   __module__t   Truet   BM_compatiblet   PATTERNR   (    (    (    s,   /usr/lib/python2.7/lib2to3/fixes/fix_repr.pyR      s   N(	   t   __doc__t    R    t
   fixer_utilR   R   R   t   BaseFixR   (    (    (    s,   /usr/lib/python2.7/lib2to3/fixes/fix_repr.pyt   <module>   s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   """
Optional fixer to transform set() calls to set literals.
"""

# Author: Benjamin Peterson

from lib2to3 import fixer_base, pytree
from lib2to3.fixer_util import token, syms



class FixSetLiteral(fixer_base.BaseFix):

    BM_compatible = True
    explicit = True

    PATTERN = """power< 'set' trailer< '('
                     (atom=atom< '[' (items=listmaker< any ((',' any)* [',']) >
                                |
                                single=any) ']' >
                     |
                     atom< '(' items=testlist_gexp< any ((',' any)* [',']) > ')' >
                     )
                     ')' > >
              """

    def transform(self, node, results):
        single = results.get("single")
        if single:
            # Make a fake listmaker
            fake = pytree.Node(syms.listmaker, [single.clone()])
            single.replace(fake)
            items = fake
        else:
            items = results["items"]

        # Build the contents of the literal
        literal = [pytree.Leaf(token.LBRACE, u"{")]
        literal.extend(n.clone() for n in items.children)
        literal.append(pytree.Leaf(token.RBRACE, u"}"))
        # Set the prefix of the right brace to that of the ')' or ']'
        literal[-1].prefix = items.next_sibling.prefix
        maker = pytree.Node(syms.dictsetmaker, literal)
        maker.prefix = node.prefix

        # If the original was a one tuple, we need to remove the extra comma.
        if len(maker.children) == 4:
            n = maker.children[2]
            n.remove()
            maker.children[-1].prefix = n.prefix

        # Finally, replace the set call with our shiny new literal.
        return maker
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             Û
”´[c           @   sO   d  Z  d d l m Z m Z d d l m Z m Z d e j f d Ñ  É  YZ d S(   s:   
Optional fixer to transform set() calls to set literals.
iˇˇˇˇ(   t
   fixer_baset   pytree(   t   tokent   symst   FixSetLiteralc           B   s#   e  Z e Z e Z d  Z d Ñ  Z RS(   sj  power< 'set' trailer< '('
                     (atom=atom< '[' (items=listmaker< any ((',' any)* [',']) >
                                |
                                single=any) ']' >
                     |
                     atom< '(' items=testlist_gexp< any ((',' any)* [',']) > ')' >
                     )
                     ')' > >
              c   	      C   s  | j  d É } | rI t j t j | j É  g É } | j | É | } n
 | d } t j t j	 d É g } | j
 d Ñ  | j DÉ É | j t j t j d É É | j j | d _ t j t j | É } | j | _ t | j É d k r| j d } | j É  | j | j d _ n  | S(	   Nt   singlet   itemsu   {c         s   s   |  ] } | j  É  Vq d  S(   N(   t   clone(   t   .0t   n(    (    s3   /usr/lib/python2.7/lib2to3/fixes/fix_set_literal.pys	   <genexpr>'   s    u   }iˇˇˇˇi   i   (   t   getR   t   NodeR   t	   listmakerR   t   replacet   LeafR   t   LBRACEt   extendt   childrent   appendt   RBRACEt   next_siblingt   prefixt   dictsetmakert   lent   remove(	   t   selft   nodet   resultsR   t   fakeR   t   literalt   makerR	   (    (    s3   /usr/lib/python2.7/lib2to3/fixes/fix_set_literal.pyt	   transform   s"    	

(   t   __name__t
   __module__t   Truet   BM_compatiblet   explicitt   PATTERNR   (    (    (    s3   /usr/lib/python2.7/lib2to3/fixes/fix_set_literal.pyR      s   
N(	   t   __doc__t   lib2to3R    R   t   lib2to3.fixer_utilR   R   t   BaseFixR   (    (    (    s3   /usr/lib/python2.7/lib2to3/fixes/fix_set_literal.pyt   <module>   s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       # Copyright 2007 Google, Inc. All Rights Reserved.
# Licensed to PSF under a Contributor Agreement.

"""Fixer for StandardError -> Exception."""

# Local imports
from .. import fixer_base
from ..fixer_util import Name


class FixStandarderror(fixer_base.BaseFix):
    BM_compatible = True
    PATTERN = """
              'StandardError'
              """

    def transform(self, node, results):
        return Name(u"Exception", prefix=node.prefix)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              Û
”´[c           @   sC   d  Z  d d l m Z d d l m Z d e j f d Ñ  É  YZ d S(   s%   Fixer for StandardError -> Exception.i   (   t
   fixer_base(   t   Namet   FixStandarderrorc           B   s   e  Z e Z d  Z d Ñ  Z RS(   s-   
              'StandardError'
              c         C   s   t  d d | j ÉS(   Nu	   Exceptiont   prefix(   R   R   (   t   selft   nodet   results(    (    s5   /usr/lib/python2.7/lib2to3/fixes/fix_standarderror.pyt	   transform   s    (   t   __name__t
   __module__t   Truet   BM_compatiblet   PATTERNR   (    (    (    s5   /usr/lib/python2.7/lib2to3/fixes/fix_standarderror.pyR      s   N(   t   __doc__t    R    t
   fixer_utilR   t   BaseFixR   (    (    (    s5   /usr/lib/python2.7/lib2to3/fixes/fix_standarderror.pyt   <module>   s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      """Fixer for sys.exc_{type, value, traceback}

sys.exc_type -> sys.exc_info()[0]
sys.exc_value -> sys.exc_info()[1]
sys.exc_traceback -> sys.exc_info()[2]
"""

# By Jeff Balogh and Benjamin Peterson

# Local imports
from .. import fixer_base
from ..fixer_util import Attr, Call, Name, Number, Subscript, Node, syms

class FixSysExc(fixer_base.BaseFix):
    # This order matches the ordering of sys.exc_info().
    exc_info = [u"exc_type", u"exc_value", u"exc_traceback"]
    BM_compatible = True
    PATTERN = """
              power< 'sys' trailer< dot='.' attribute=(%s) > >
              """ % '|'.join("'%s'" % e for e in exc_info)

    def transform(self, node, results):
        sys_attr = results["attribute"][0]
        index = Number(self.exc_info.index(sys_attr.value))

        call = Call(Name(u"exc_info"), prefix=sys_attr.prefix)
        attr = Attr(Name(u"sys"), call)
        attr[1].children[0].prefix = results["dot"].prefix
        attr.append(Subscript(index))
        return Node(syms.power, attr, prefix=node.prefix)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 Û
”´[c           @   sg   d  Z  d d l m Z d d l m Z m Z m Z m Z m Z m	 Z	 m
 Z
 d e j f d Ñ  É  YZ d S(   sò   Fixer for sys.exc_{type, value, traceback}

sys.exc_type -> sys.exc_info()[0]
sys.exc_value -> sys.exc_info()[1]
sys.exc_traceback -> sys.exc_info()[2]
i   (   t
   fixer_base(   t   Attrt   Callt   Namet   Numbert	   Subscriptt   Nodet   symst	   FixSysExcc           B   sC   e  Z d  d d g Z e Z d d j d Ñ  e DÉ É Z d Ñ  Z RS(   u   exc_typeu	   exc_valueu   exc_tracebacksN   
              power< 'sys' trailer< dot='.' attribute=(%s) > >
              t   |c         c   s   |  ] } d  | Vq d S(   s   '%s'N(    (   t   .0t   e(    (    s/   /usr/lib/python2.7/lib2to3/fixes/fix_sys_exc.pys	   <genexpr>   s    c         C   s†   | d d } t  |  j j | j É É } t t d É d | j É} t t d É | É } | d j | d j d _ | j	 t
 | É É t t j | d | j ÉS(   Nt	   attributei    u   exc_infot   prefixu   syst   doti   (   R   t   exc_infot   indext   valueR   R   R   R   t   childrent   appendR   R   R   t   power(   t   selft   nodet   resultst   sys_attrR   t   callt   attr(    (    s/   /usr/lib/python2.7/lib2to3/fixes/fix_sys_exc.pyt	   transform   s    (   t   __name__t
   __module__R   t   Truet   BM_compatiblet   joint   PATTERNR   (    (    (    s/   /usr/lib/python2.7/lib2to3/fixes/fix_sys_exc.pyR      s   N(   t   __doc__t    R    t
   fixer_utilR   R   R   R   R   R   R   t   BaseFixR   (    (    (    s/   /usr/lib/python2.7/lib2to3/fixes/fix_sys_exc.pyt   <module>   s   4                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               """Fixer for generator.throw(E, V, T).

g.throw(E)       -> g.throw(E)
g.throw(E, V)    -> g.throw(E(V))
g.throw(E, V, T) -> g.throw(E(V).with_traceback(T))

g.throw("foo"[, V[, T]]) will warn about string exceptions."""
# Author: Collin Winter

# Local imports
from .. import pytree
from ..pgen2 import token
from .. import fixer_base
from ..fixer_util import Name, Call, ArgList, Attr, is_tuple

class FixThrow(fixer_base.BaseFix):
    BM_compatible = True
    PATTERN = """
    power< any trailer< '.' 'throw' >
           trailer< '(' args=arglist< exc=any ',' val=any [',' tb=any] > ')' >
    >
    |
    power< any trailer< '.' 'throw' > trailer< '(' exc=any ')' > >
    """

    def transform(self, node, results):
        syms = self.syms

        exc = results["exc"].clone()
        if exc.type is token.STRING:
            self.cannot_convert(node, "Python 3 does not support string exceptions")
            return

        # Leave "g.throw(E)" alone
        val = results.get(u"val")
        if val is None:
            return

        val = val.clone()
        if is_tuple(val):
            args = [c.clone() for c in val.children[1:-1]]
        else:
            val.prefix = u""
            args = [val]

        throw_args = results["args"]

        if "tb" in results:
            tb = results["tb"].clone()
            tb.prefix = u""

            e = Call(exc, args)
            with_tb = Attr(e, Name(u'with_traceback')) + [ArgList([tb])]
            throw_args.replace(pytree.Node(syms.power, with_tb))
        else:
            throw_args.replace(Call(exc, args))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              Û
”´[c           @   s{   d  Z  d d l m Z d d l m Z d d l m Z d d l m Z m Z m	 Z	 m
 Z
 m Z d e j f d Ñ  É  YZ d S(	   s÷   Fixer for generator.throw(E, V, T).

g.throw(E)       -> g.throw(E)
g.throw(E, V)    -> g.throw(E(V))
g.throw(E, V, T) -> g.throw(E(V).with_traceback(T))

g.throw("foo"[, V[, T]]) will warn about string exceptions.i   (   t   pytree(   t   token(   t
   fixer_base(   t   Namet   Callt   ArgListt   Attrt   is_tuplet   FixThrowc           B   s   e  Z e Z d  Z d Ñ  Z RS(   s…   
    power< any trailer< '.' 'throw' >
           trailer< '(' args=arglist< exc=any ',' val=any [',' tb=any] > ')' >
    >
    |
    power< any trailer< '.' 'throw' > trailer< '(' exc=any ')' > >
    c         C   sP  |  j  } | d j É  } | j t j k r? |  j | d É d  S| j d É } | d  k r^ d  S| j É  } t | É r¢ g  | j	 d d !D] } | j É  ^ qá } n d | _
 | g } | d } d | k r6| d j É  }	 d |	 _
 t | | É }
 t |
 t d	 É É t |	 g É g } | j t j | j | É É n | j t | | É É d  S(
   Nt   excs+   Python 3 does not support string exceptionsu   vali   iˇˇˇˇu    t   argst   tbu   with_traceback(   t   symst   clonet   typeR   t   STRINGt   cannot_convertt   gett   NoneR   t   childrent   prefixR   R   R   R   t   replaceR    t   Nodet   power(   t   selft   nodet   resultsR   R	   t   valt   cR
   t
   throw_argsR   t   et   with_tb(    (    s-   /usr/lib/python2.7/lib2to3/fixes/fix_throw.pyt	   transform   s*    	,		
	%(   t   __name__t
   __module__t   Truet   BM_compatiblet   PATTERNR    (    (    (    s-   /usr/lib/python2.7/lib2to3/fixes/fix_throw.pyR      s   N(   t   __doc__t    R    t   pgen2R   R   t
   fixer_utilR   R   R   R   R   t   BaseFixR   (    (    (    s-   /usr/lib/python2.7/lib2to3/fixes/fix_throw.pyt   <module>   s
   (                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            """Fixer for function definitions with tuple parameters.

def func(((a, b), c), d):
    ...

    ->

def func(x, d):
    ((a, b), c) = x
    ...

It will also support lambdas:

    lambda (x, y): x + y -> lambda t: t[0] + t[1]

    # The parens are a syntax error in Python 3
    lambda (x): x + y -> lambda x: x + y
"""
# Author: Collin Winter

# Local imports
from .. import pytree
from ..pgen2 import token
from .. import fixer_base
from ..fixer_util import Assign, Name, Newline, Number, Subscript, syms

def is_docstring(stmt):
    return isinstance(stmt, pytree.Node) and \
           stmt.children[0].type == token.STRING

class FixTupleParams(fixer_base.BaseFix):
    run_order = 4 #use a lower order since lambda is part of other
                  #patterns
    BM_compatible = True

    PATTERN = """
              funcdef< 'def' any parameters< '(' args=any ')' >
                       ['->' any] ':' suite=any+ >
              |
              lambda=
              lambdef< 'lambda' args=vfpdef< '(' inner=any ')' >
                       ':' body=any
              >
              """

    def transform(self, node, results):
        if "lambda" in results:
            return self.transform_lambda(node, results)

        new_lines = []
        suite = results["suite"]
        args = results["args"]
        # This crap is so "def foo(...): x = 5; y = 7" is handled correctly.
        # TODO(cwinter): suite-cleanup
        if suite[0].children[1].type == token.INDENT:
            start = 2
            indent = suite[0].children[1].value
            end = Newline()
        else:
            start = 0
            indent = u"; "
            end = pytree.Leaf(token.INDENT, u"")

        # We need access to self for new_name(), and making this a method
        #  doesn't feel right. Closing over self and new_lines makes the
        #  code below cleaner.
        def handle_tuple(tuple_arg, add_prefix=False):
            n = Name(self.new_name())
            arg = tuple_arg.clone()
            arg.prefix = u""
            stmt = Assign(arg, n.clone())
            if add_prefix:
                n.prefix = u" "
            tuple_arg.replace(n)
            new_lines.append(pytree.Node(syms.simple_stmt,
                                         [stmt, end.clone()]))

        if args.type == syms.tfpdef:
            handle_tuple(args)
        elif args.type == syms.typedargslist:
            for i, arg in enumerate(args.children):
                if arg.type == syms.tfpdef:
                    # Without add_prefix, the emitted code is correct,
                    #  just ugly.
                    handle_tuple(arg, add_prefix=(i > 0))

        if not new_lines:
            return

        # This isn't strictly necessary, but it plays nicely with other fixers.
        # TODO(cwinter) get rid of this when children becomes a smart list
        for line in new_lines:
            line.parent = suite[0]

        # TODO(cwinter) suite-cleanup
        after = start
        if start == 0:
            new_lines[0].prefix = u" "
        elif is_docstring(suite[0].children[start]):
            new_lines[0].prefix = indent
            after = start + 1

        for line in new_lines:
            line.parent = suite[0]
        suite[0].children[after:after] = new_lines
        for i in range(after+1, after+len(new_lines)+1):
            suite[0].children[i].prefix = indent
        suite[0].changed()

    def transform_lambda(self, node, results):
        args = results["args"]
        body = results["body"]
        inner = simplify_args(results["inner"])

        # Replace lambda ((((x)))): x  with lambda x: x
        if inner.type == token.NAME:
            inner = inner.clone()
            inner.prefix = u" "
            args.replace(inner)
            return

        params = find_params(args)
        to_index = map_to_index(params)
        tup_name = self.new_name(tuple_name(params))

        new_param = Name(tup_name, prefix=u" ")
        args.replace(new_param.clone())
        for n in body.post_order():
            if n.type == token.NAME and n.value in to_index:
                subscripts = [c.clone() for c in to_index[n.value]]
                new = pytree.Node(syms.power,
                                  [new_param.clone()] + subscripts)
                new.prefix = n.prefix
                n.replace(new)


### Helper functions for transform_lambda()

def simplify_args(node):
    if node.type in (syms.vfplist, token.NAME):
        return node
    elif node.type == syms.vfpdef:
        # These look like vfpdef< '(' x ')' > where x is NAME
        # or another vfpdef instance (leading to recursion).
        while node.type == syms.vfpdef:
            node = node.children[1]
        return node
    raise RuntimeError("Received unexpected node %s" % node)

def find_params(node):
    if node.type == syms.vfpdef:
        return find_params(node.children[1])
    elif node.type == token.NAME:
        return node.value
    return [find_params(c) for c in node.children if c.type != token.COMMA]

def map_to_index(param_list, prefix=[], d=None):
    if d is None:
        d = {}
    for i, obj in enumerate(param_list):
        trailer = [Subscript(Number(unicode(i)))]
        if isinstance(obj, list):
            map_to_index(obj, trailer, d=d)
        else:
            d[obj] = prefix + trailer
    return d

def tuple_name(param_list):
    l = []
    for obj in param_list:
        if isinstance(obj, list):
            l.append(tuple_name(obj))
        else:
            l.append(obj)
    return u"_".join(l)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Û
”´[c           @   s¥   d  Z  d d l m Z d d l m Z d d l m Z d d l m Z m Z m	 Z	 m
 Z
 m Z m Z d Ñ  Z d e j f d Ñ  É  YZ d	 Ñ  Z d
 Ñ  Z g  d d Ñ Z d Ñ  Z d S(   s:  Fixer for function definitions with tuple parameters.

def func(((a, b), c), d):
    ...

    ->

def func(x, d):
    ((a, b), c) = x
    ...

It will also support lambdas:

    lambda (x, y): x + y -> lambda t: t[0] + t[1]

    # The parens are a syntax error in Python 3
    lambda (x): x + y -> lambda x: x + y
i   (   t   pytree(   t   token(   t
   fixer_base(   t   Assignt   Namet   Newlinet   Numbert	   Subscriptt   symsc         C   s)   t  |  t j É o( |  j d j t j k S(   Ni    (   t
   isinstanceR    t   Nodet   childrent   typeR   t   STRING(   t   stmt(    (    s4   /usr/lib/python2.7/lib2to3/fixes/fix_tuple_params.pyt   is_docstring   s    t   FixTupleParamsc           B   s,   e  Z d  Z e Z d Z d Ñ  Z d Ñ  Z RS(   i   s  
              funcdef< 'def' any parameters< '(' args=any ')' >
                       ['->' any] ':' suite=any+ >
              |
              lambda=
              lambdef< 'lambda' args=vfpdef< '(' inner=any ')' >
                       ':' body=any
              >
              c            s0  d | k r à j  | | É Sg  â | d } | d } | d j d j t j k ry d } | d j d j } t É  â  n! d } d } t j t j d É â  t	 á  á á f d	 Ü } | j t
 j k r— | | É n` | j t
 j k r1xK t | j É D]7 \ } }	 |	 j t
 j k rÛ | |	 d
 | d k ÉqÛ qÛ Wn  à s;d  Sx à D] }
 | d |
 _ qBW| } | d k r{d à d _ n1 t | d j | É r¨| à d _ | d } n  x à D] }
 | d |
 _ q≥Wà | d j | | +x= t | d | t à É d É D] } | | d j | _ q W| d j É  d  S(   Nt   lambdat   suitet   argsi    i   i   u   ; u    c            sá   t  à j É  É } |  j É  } d | _ t | | j É  É } | rN d | _ n  |  j | É à j t j t	 j
 | à  j É  g É É d  S(   Nu    u    (   R   t   new_namet   clonet   prefixR   t   replacet   appendR    R
   R   t   simple_stmt(   t	   tuple_argt
   add_prefixt   nt   argR   (   t   endt	   new_linest   self(    s4   /usr/lib/python2.7/lib2to3/fixes/fix_tuple_params.pyt   handle_tupleC   s    	R   u    (   t   transform_lambdaR   R   R   t   INDENTt   valueR   R    t   Leaft   FalseR   t   tfpdeft   typedargslistt	   enumeratet   parentR   R   t   ranget   lent   changed(   R    t   nodet   resultsR   R   t   startt   indentR!   t   iR   t   linet   after(    (   R   R   R    s4   /usr/lib/python2.7/lib2to3/fixes/fix_tuple_params.pyt	   transform.   sF    

 (c         C   sN  | d } | d } t  | d É } | j t j k r\ | j É  } d | _ | j | É d  St | É } t | É } |  j	 t
 | É É } t | d d É}	 | j |	 j É  É xô | j É  D]ã }
 |
 j t j k rª |
 j | k rª g  | |
 j D] } | j É  ^ q } t j t j |	 j É  g | É } |
 j | _ |
 j | É qª qª Wd  S(   NR   t   bodyt   inneru    R   (   t   simplify_argsR   R   t   NAMER   R   R   t   find_paramst   map_to_indexR   t
   tuple_nameR   t
   post_orderR$   R    R
   R   t   power(   R    R.   R/   R   R6   R7   t   paramst   to_indext   tup_namet	   new_paramR   t   ct
   subscriptst   new(    (    s4   /usr/lib/python2.7/lib2to3/fixes/fix_tuple_params.pyR"   n   s(    

	!&(   t   __name__t
   __module__t	   run_ordert   Truet   BM_compatiblet   PATTERNR5   R"   (    (    (    s4   /usr/lib/python2.7/lib2to3/fixes/fix_tuple_params.pyR      s
   
	@c         C   so   |  j  t j t j f k r |  S|  j  t j k r[ x# |  j  t j k rV |  j d }  q4 W|  St d |  É Ç d  S(   Ni   s   Received unexpected node %s(   R   R   t   vfplistR   R9   t   vfpdefR   t   RuntimeError(   R.   (    (    s4   /usr/lib/python2.7/lib2to3/fixes/fix_tuple_params.pyR8   ã   s    c         C   sn   |  j  t j k r# t |  j d É S|  j  t j k r< |  j Sg  |  j D]$ } | j  t j k rF t | É ^ qF S(   Ni   (	   R   R   RM   R:   R   R   R9   R$   t   COMMA(   R.   RC   (    (    s4   /usr/lib/python2.7/lib2to3/fixes/fix_tuple_params.pyR:   ñ   s
    c         C   sÑ   | d  k r i  } n  xh t |  É D]Z \ } } t t t | É É É g } t | t É rn t | | d | Éq" | | | | <q" W| S(   Nt   d(   t   NoneR)   R   R   t   unicodeR	   t   listR;   (   t
   param_listR   RP   R2   t   objt   trailer(    (    s4   /usr/lib/python2.7/lib2to3/fixes/fix_tuple_params.pyR;   ù   s    	c         C   sV   g  } x@ |  D]8 } t  | t É r8 | j t | É É q | j | É q Wd j | É S(   Nu   _(   R	   RS   R   R<   t   join(   RT   t   lRU   (    (    s4   /usr/lib/python2.7/lib2to3/fixes/fix_tuple_params.pyR<   ®   s    N(   t   __doc__t    R    t   pgen2R   R   t
   fixer_utilR   R   R   R   R   R   R   t   BaseFixR   R8   R:   RQ   R;   R<   (    (    (    s4   /usr/lib/python2.7/lib2to3/fixes/fix_tuple_params.pyt   <module>   s   .	l		                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  # Copyright 2007 Google, Inc. All Rights Reserved.
# Licensed to PSF under a Contributor Agreement.

"""Fixer for removing uses of the types module.

These work for only the known names in the types module.  The forms above
can include types. or not.  ie, It is assumed the module is imported either as:

    import types
    from types import ... # either * or specific types

The import statements are not modified.

There should be another fixer that handles at least the following constants:

   type([]) -> list
   type(()) -> tuple
   type('') -> str

"""

# Local imports
from ..pgen2 import token
from .. import fixer_base
from ..fixer_util import Name

_TYPE_MAPPING = {
        'BooleanType' : 'bool',
        'BufferType' : 'memoryview',
        'ClassType' : 'type',
        'ComplexType' : 'complex',
        'DictType': 'dict',
        'DictionaryType' : 'dict',
        'EllipsisType' : 'type(Ellipsis)',
        #'FileType' : 'io.IOBase',
        'FloatType': 'float',
        'IntType': 'int',
        'ListType': 'list',
        'LongType': 'int',
        'ObjectType' : 'object',
        'NoneType': 'type(None)',
        'NotImplementedType' : 'type(NotImplemented)',
        'SliceType' : 'slice',
        'StringType': 'bytes', # XXX ?
        'StringTypes' : '(str,)', # XXX ?
        'TupleType': 'tuple',
        'TypeType' : 'type',
        'UnicodeType': 'str',
        'XRangeType' : 'range',
    }

_pats = ["power< 'types' trailer< '.' name='%s' > >" % t for t in _TYPE_MAPPING]

class FixTypes(fixer_base.BaseFix):
    BM_compatible = True
    PATTERN = '|'.join(_pats)

    def transform(self, node, results):
        new_value = unicode(_TYPE_MAPPING.get(results["name"].value))
        if new_value:
            return Name(new_value, prefix=node.prefix)
        return None
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               Û
”´[c           @   s	  d  Z  d d l m Z d d l m Z d d l m Z i d d 6d d 6d	 d
 6d d 6d d 6d d 6d d 6d d 6d d 6d d 6d d 6d d 6d d 6d d 6d d  6d! d" 6d# d$ 6d% d& 6d	 d' 6d( d) 6d* d+ 6Z g  e D] Z d, e ^ q÷ Z	 d- e j
 f d. Ñ  É  YZ d/ S(0   s∆  Fixer for removing uses of the types module.

These work for only the known names in the types module.  The forms above
can include types. or not.  ie, It is assumed the module is imported either as:

    import types
    from types import ... # either * or specific types

The import statements are not modified.

There should be another fixer that handles at least the following constants:

   type([]) -> list
   type(()) -> tuple
   type('') -> str

i   (   t   token(   t
   fixer_base(   t   Namet   boolt   BooleanTypet
   memoryviewt
   BufferTypet   typet	   ClassTypet   complext   ComplexTypet   dictt   DictTypet   DictionaryTypes   type(Ellipsis)t   EllipsisTypet   floatt	   FloatTypet   intt   IntTypet   listt   ListTypet   LongTypet   objectt
   ObjectTypes
   type(None)t   NoneTypes   type(NotImplemented)t   NotImplementedTypet   slicet	   SliceTypet   bytest
   StringTypes   (str,)t   StringTypest   tuplet	   TupleTypet   TypeTypet   strt   UnicodeTypet   ranget
   XRangeTypes)   power< 'types' trailer< '.' name='%s' > >t   FixTypesc           B   s&   e  Z e Z d  j e É Z d Ñ  Z RS(   t   |c         C   s9   t  t j | d j É É } | r5 t | d | j ÉSd  S(   Nt   namet   prefix(   t   unicodet   _TYPE_MAPPINGt   gett   valueR   R)   t   None(   t   selft   nodet   resultst	   new_value(    (    s-   /usr/lib/python2.7/lib2to3/fixes/fix_types.pyt	   transform:   s    (   t   __name__t
   __module__t   Truet   BM_compatiblet   joint   _patst   PATTERNR3   (    (    (    s-   /usr/lib/python2.7/lib2to3/fixes/fix_types.pyR&   6   s   N(   t   __doc__t   pgen2R    t    R   t
   fixer_utilR   R+   t   tR9   t   BaseFixR&   (    (    (    s-   /usr/lib/python2.7/lib2to3/fixes/fix_types.pyt   <module>   s6   
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    r"""Fixer for unicode.

* Changes unicode to str and unichr to chr.

* If "...\u..." is not unicode literal change it into "...\\u...".

* Change u"..." into "...".

"""

from ..pgen2 import token
from .. import fixer_base

_mapping = {u"unichr" : u"chr", u"unicode" : u"str"}

class FixUnicode(fixer_base.BaseFix):
    BM_compatible = True
    PATTERN = "STRING | 'unicode' | 'unichr'"

    def start_tree(self, tree, filename):
        super(FixUnicode, self).start_tree(tree, filename)
        self.unicode_literals = 'unicode_literals' in tree.future_features

    def transform(self, node, results):
        if node.type == token.NAME:
            new = node.clone()
            new.value = _mapping[node.value]
            return new
        elif node.type == token.STRING:
            val = node.value
            if not self.unicode_literals and val[0] in u'\'"' and u'\\' in val:
                val = ur'\\'.join([
                    v.replace(u'\\u', ur'\\u').replace(u'\\U', ur'\\U')
                    for v in val.split(ur'\\')
                ])
            if val[0] in u'uU':
                val = val[1:]
            if val == node.value:
                return node
            new = node.clone()
            new.value = val
            return new
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Û
”´[c           @   sW   d  Z  d d l m Z d d l m Z i d d 6d d 6Z d e j f d	 Ñ  É  YZ d
 S(   s¢   Fixer for unicode.

* Changes unicode to str and unichr to chr.

* If "...\u..." is not unicode literal change it into "...\\u...".

* Change u"..." into "...".

i   (   t   token(   t
   fixer_baseu   chru   unichru   stru   unicodet
   FixUnicodec           B   s&   e  Z e Z d  Z d Ñ  Z d Ñ  Z RS(   s   STRING | 'unicode' | 'unichr'c         C   s/   t  t |  É j | | É d | j k |  _ d  S(   Nt   unicode_literals(   t   superR   t
   start_treet   future_featuresR   (   t   selft   treet   filename(    (    s/   /usr/lib/python2.7/lib2to3/fixes/fix_unicode.pyR      s    c         C   s  | j  t j k r2 | j É  } t | j | _ | S| j  t j k r| j } |  j rπ | d d k rπ d | k rπ d j g  | j	 d É D]$ } | j
 d d É j
 d d É ^ qâ É } n  | d d	 k r÷ | d
 } n  | | j k rÈ | S| j É  } | | _ | Sd  S(   Ni    u   '"u   \u   \\u   \uu   \\uu   \Uu   \\Uu   uUi   (   t   typeR    t   NAMEt   clonet   _mappingt   valuet   STRINGR   t   joint   splitt   replace(   R   t   nodet   resultst   newt   valt   v(    (    s/   /usr/lib/python2.7/lib2to3/fixes/fix_unicode.pyt	   transform   s"    	&=	(   t   __name__t
   __module__t   Truet   BM_compatiblet   PATTERNR   R   (    (    (    s/   /usr/lib/python2.7/lib2to3/fixes/fix_unicode.pyR      s   	N(   t   __doc__t   pgen2R    t    R   R   t   BaseFixR   (    (    (    s/   /usr/lib/python2.7/lib2to3/fixes/fix_unicode.pyt   <module>	   s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       """Fix changes imports of urllib which are now incompatible.
   This is rather similar to fix_imports, but because of the more
   complex nature of the fixing for urllib, it has its own fixer.
"""
# Author: Nick Edds

# Local imports
from lib2to3.fixes.fix_imports import alternates, FixImports
from lib2to3 import fixer_base
from lib2to3.fixer_util import (Name, Comma, FromImport, Newline,
                                find_indentation, Node, syms)

MAPPING = {"urllib":  [
                ("urllib.request",
                    ["URLopener", "FancyURLopener", "urlretrieve",
                     "_urlopener", "urlopen", "urlcleanup",
                     "pathname2url", "url2pathname"]),
                ("urllib.parse",
                    ["quote", "quote_plus", "unquote", "unquote_plus",
                     "urlencode", "splitattr", "splithost", "splitnport",
                     "splitpasswd", "splitport", "splitquery", "splittag",
                     "splittype", "splituser", "splitvalue", ]),
                ("urllib.error",
                    ["ContentTooShortError"])],
           "urllib2" : [
                ("urllib.request",
                    ["urlopen", "install_opener", "build_opener",
                     "Request", "OpenerDirector", "BaseHandler",
                     "HTTPDefaultErrorHandler", "HTTPRedirectHandler",
                     "HTTPCookieProcessor", "ProxyHandler",
                     "HTTPPasswordMgr",
                     "HTTPPasswordMgrWithDefaultRealm",
                     "AbstractBasicAuthHandler",
                     "HTTPBasicAuthHandler", "ProxyBasicAuthHandler",
                     "AbstractDigestAuthHandler",
                     "HTTPDigestAuthHandler", "ProxyDigestAuthHandler",
                     "HTTPHandler", "HTTPSHandler", "FileHandler",
                     "FTPHandler", "CacheFTPHandler",
                     "UnknownHandler"]),
                ("urllib.error",
                    ["URLError", "HTTPError"]),
           ]
}

# Duplicate the url parsing functions for urllib2.
MAPPING["urllib2"].append(MAPPING["urllib"][1])


def build_pattern():
    bare = set()
    for old_module, changes in MAPPING.items():
        for change in changes:
            new_module, members = change
            members = alternates(members)
            yield """import_name< 'import' (module=%r
                                  | dotted_as_names< any* module=%r any* >) >
                  """ % (old_module, old_module)
            yield """import_from< 'from' mod_member=%r 'import'
                       ( member=%s | import_as_name< member=%s 'as' any > |
                         import_as_names< members=any*  >) >
                  """ % (old_module, members, members)
            yield """import_from< 'from' module_star=%r 'import' star='*' >
                  """ % old_module
            yield """import_name< 'import'
                                  dotted_as_name< module_as=%r 'as' any > >
                  """ % old_module
            # bare_with_attr has a special significance for FixImports.match().
            yield """power< bare_with_attr=%r trailer< '.' member=%s > any* >
                  """ % (old_module, members)


class FixUrllib(FixImports):

    def build_pattern(self):
        return "|".join(build_pattern())

    def transform_import(self, node, results):
        """Transform for the basic import case. Replaces the old
           import name with a comma separated list of its
           replacements.
        """
        import_mod = results.get("module")
        pref = import_mod.prefix

        names = []

        # create a Node list of the replacement modules
        for name in MAPPING[import_mod.value][:-1]:
            names.extend([Name(name[0], prefix=pref), Comma()])
        names.append(Name(MAPPING[import_mod.value][-1][0], prefix=pref))
        import_mod.replace(names)

    def transform_member(self, node, results):
        """Transform for imports of specific module elements. Replaces
           the module to be imported from with the appropriate new
           module.
        """
        mod_member = results.get("mod_member")
        pref = mod_member.prefix
        member = results.get("member")

        # Simple case with only a single member being imported
        if member:
            # this may be a list of length one, or just a node
            if isinstance(member, list):
                member = member[0]
            new_name = None
            for change in MAPPING[mod_member.value]:
                if member.value in change[1]:
                    new_name = change[0]
                    break
            if new_name:
                mod_member.replace(Name(new_name, prefix=pref))
            else:
                self.cannot_convert(node, "This is an invalid module element")

        # Multiple members being imported
        else:
            # a dictionary for replacements, order matters
            modules = []
            mod_dict = {}
            members = results["members"]
            for member in members:
                # we only care about the actual members
                if member.type == syms.import_as_name:
                    as_name = member.children[2].value
                    member_name = member.children[0].value
                else:
                    member_name = member.value
                    as_name = None
                if member_name != u",":
                    for change in MAPPING[mod_member.value]:
                        if member_name in change[1]:
                            if change[0] not in mod_dict:
                                modules.append(change[0])
                            mod_dict.setdefault(change[0], []).append(member)

            new_nodes = []
            indentation = find_indentation(node)
            first = True
            def handle_name(name, prefix):
                if name.type == syms.import_as_name:
                    kids = [Name(name.children[0].value, prefix=prefix),
                            name.children[1].clone(),
                            name.children[2].clone()]
                    return [Node(syms.import_as_name, kids)]
                return [Name(name.value, prefix=prefix)]
            for module in modules:
                elts = mod_dict[module]
                names = []
                for elt in elts[:-1]:
                    names.extend(handle_name(elt, pref))
                    names.append(Comma())
                names.extend(handle_name(elts[-1], pref))
                new = FromImport(module, names)
                if not first or node.parent.prefix.endswith(indentation):
                    new.prefix = indentation
                new_nodes.append(new)
                first = False
            if new_nodes:
                nodes = []
                for new_node in new_nodes[:-1]:
                    nodes.extend([new_node, Newline()])
                nodes.append(new_nodes[-1])
                node.replace(nodes)
            else:
                self.cannot_convert(node, "All module elements are invalid")

    def transform_dot(self, node, results):
        """Transform for calls to module members in code."""
        module_dot = results.get("bare_with_attr")
        member = results.get("member")
        new_name = None
        if isinstance(member, list):
            member = member[0]
        for change in MAPPING[module_dot.value]:
            if member.value in change[1]:
                new_name = change[0]
                break
        if new_name:
            module_dot.replace(Name(new_name,
                                    prefix=module_dot.prefix))
        else:
            self.cannot_convert(node, "This is an invalid module element")

    def transform(self, node, results):
        if results.get("module"):
            self.transform_import(node, results)
        elif results.get("mod_member"):
            self.transform_member(node, results)
        elif results.get("bare_with_attr"):
            self.transform_dot(node, results)
        # Renaming and star imports are not supported for these modules.
        elif results.get("module_star"):
            self.cannot_convert(node, "Cannot handle star imports.")
        elif results.get("module_as"):
            self.cannot_convert(node, "This module is now multiple modules")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               """Fixer that changes 'a ,b' into 'a, b'.

This also changes '{a :b}' into '{a: b}', but does not touch other
uses of colons.  It does not touch other uses of whitespace.

"""

from .. import pytree
from ..pgen2 import token
from .. import fixer_base

class FixWsComma(fixer_base.BaseFix):

    explicit = True # The user must ask for this fixers

    PATTERN = """
    any<(not(',') any)+ ',' ((not(',') any)+ ',')* [not(',') any]>
    """

    COMMA = pytree.Leaf(token.COMMA, u",")
    COLON = pytree.Leaf(token.COLON, u":")
    SEPS = (COMMA, COLON)

    def transform(self, node, results):
        new = node.clone()
        comma = False
        for child in new.children:
            if child in self.SEPS:
                prefix = child.prefix
                if prefix.isspace() and u"\n" not in prefix:
                    child.prefix = u""
                comma = True
            else:
                if comma:
                    prefix = child.prefix
                    if not prefix:
                        child.prefix = u" "
                comma = False
        return new
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         Û
”´[c           @   ss  d  Z  d d l m Z m Z d d l m Z d d l m Z m Z m	 Z	 m
 Z
 m Z m Z m Z i d d d d d	 d
 d d d g f d d d d d d d d d d d d d d d d g f d d g f g d  6d d
 d! d" d# d$ d% d& d' d( d) d* d+ d, d- d. d/ d0 d1 d2 d3 d4 d5 d6 d7 g f d d8 d9 g f g d: 6Z e d: j e d  d; É d< Ñ  Z d= e f d> Ñ  É  YZ d? S(@   sæ   Fix changes imports of urllib which are now incompatible.
   This is rather similar to fix_imports, but because of the more
   complex nature of the fixing for urllib, it has its own fixer.
iˇˇˇˇ(   t
   alternatest
   FixImports(   t
   fixer_base(   t   Namet   Commat
   FromImportt   Newlinet   find_indentationt   Nodet   symss   urllib.requestt	   URLopenert   FancyURLopenert   urlretrievet
   _urlopenert   urlopent
   urlcleanupt   pathname2urlt   url2pathnames   urllib.parset   quotet
   quote_plust   unquotet   unquote_plust	   urlencodet	   splitattrt	   splithostt
   splitnportt   splitpasswdt	   splitportt
   splitqueryt   splittagt	   splittypet	   splitusert
   splitvalues   urllib.errort   ContentTooShortErrort   urllibt   install_openert   build_openert   Requestt   OpenerDirectort   BaseHandlert   HTTPDefaultErrorHandlert   HTTPRedirectHandlert   HTTPCookieProcessort   ProxyHandlert   HTTPPasswordMgrt   HTTPPasswordMgrWithDefaultRealmt   AbstractBasicAuthHandlert   HTTPBasicAuthHandlert   ProxyBasicAuthHandlert   AbstractDigestAuthHandlert   HTTPDigestAuthHandlert   ProxyDigestAuthHandlert   HTTPHandlert   HTTPSHandlert   FileHandlert
   FTPHandlert   CacheFTPHandlert   UnknownHandlert   URLErrort	   HTTPErrort   urllib2i   c          c   sï   t  É  }  xÖ t j É  D]w \ } } xh | D]` } | \ } } t | É } d | | f Vd | | | f Vd | Vd | Vd | | f Vq) Wq Wd  S(   NsÅ   import_name< 'import' (module=%r
                                  | dotted_as_names< any* module=%r any* >) >
                  s∆   import_from< 'from' mod_member=%r 'import'
                       ( member=%s | import_as_name< member=%s 'as' any > |
                         import_as_names< members=any*  >) >
                  sI   import_from< 'from' module_star=%r 'import' star='*' >
                  st   import_name< 'import'
                                  dotted_as_name< module_as=%r 'as' any > >
                  sK   power< bare_with_attr=%r trailer< '.' member=%s > any* >
                  (   t   sett   MAPPINGt   itemsR    (   t   baret
   old_modulet   changest   changet
   new_modulet   members(    (    s.   /usr/lib/python2.7/lib2to3/fixes/fix_urllib.pyt   build_pattern1   s    			t	   FixUrllibc           B   s5   e  Z d  Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   c         C   s   d j  t É  É S(   Nt   |(   t   joinRF   (   t   self(    (    s.   /usr/lib/python2.7/lib2to3/fixes/fix_urllib.pyRF   J   s    c         C   sô   | j  d É } | j } g  } x? t | j d  D], } | j t | d d | Ét É  g É q0 W| j t t | j d d d | ÉÉ | j | É d S(   së   Transform for the basic import case. Replaces the old
           import name with a comma separated list of its
           replacements.
        t   moduleiˇˇˇˇi    t   prefixN(	   t   getRL   R>   t   valuet   extendR   R   t   appendt   replace(   RJ   t   nodet   resultst
   import_modt   preft   namest   name(    (    s.   /usr/lib/python2.7/lib2to3/fixes/fix_urllib.pyt   transform_importM   s    	*(c         C   s  | j  d É } | j } | j  d É } | rΩ t | t É rI | d } n  d } x6 t | j D]' } | j | d k r] | d } Pq] q] W| r™ | j t | d | ÉÉ qÏ|  j	 | d É n/g  } i  }	 | d }
 xÕ |
 D]≈ } | j
 t j k r| j d j } | j d j } n | j } d } | d	 k r⁄ xl t | j D]Z } | | d k r>| d |	 k rx| j | d É n  |	 j | d g  É j | É q>q>Wq⁄ q⁄ Wg  } t | É } t } d
 Ñ  } xΩ | D]µ } |	 | } g  } x8 | d  D], } | j | | | É É | j t É  É qÏW| j | | d | É É t | | É } | sa| j j j | É rm| | _ n  | j | É t } qÀW| r‹g  } x( | d  D] } | j | t É  g É qõW| j | d É | j | É n |  j	 | d É d S(   sö   Transform for imports of specific module elements. Replaces
           the module to be imported from with the appropriate new
           module.
        t
   mod_membert   memberi    i   RL   s!   This is an invalid module elementRE   i   u   ,c         S   sz   |  j  t j k rd t |  j d j d | É|  j d j É  |  j d j É  g } t t j | É g St |  j d | Ég S(   Ni    RL   i   i   (   t   typeR	   t   import_as_nameR   t   childrenRN   t   cloneR   (   RW   RL   t   kids(    (    s.   /usr/lib/python2.7/lib2to3/fixes/fix_urllib.pyt   handle_nameç   s    iˇˇˇˇs   All module elements are invalidN(   RM   RL   t
   isinstancet   listt   NoneR>   RN   RQ   R   t   cannot_convertR[   R	   R\   R]   RP   t
   setdefaultR   t   TrueRO   R   R   t   parentt   endswitht   FalseR   (   RJ   RR   RS   RY   RU   RZ   t   new_nameRC   t   modulest   mod_dictRE   t   as_namet   member_namet	   new_nodest   indentationt   firstR`   RK   t   eltsRV   t   eltt   newt   nodest   new_node(    (    s.   /usr/lib/python2.7/lib2to3/fixes/fix_urllib.pyt   transform_member]   sh    	

	+	

c         C   s≤   | j  d É } | j  d É } d } t | t É r@ | d } n  x6 t | j D]' } | j | d k rN | d } PqN qN W| rû | j t | d | j ÉÉ n |  j	 | d É d S(   s.   Transform for calls to module members in code.t   bare_with_attrRZ   i    i   RL   s!   This is an invalid module elementN(
   RM   Rc   Ra   Rb   R>   RN   RQ   R   RL   Rd   (   RJ   RR   RS   t
   module_dotRZ   Rj   RC   (    (    s.   /usr/lib/python2.7/lib2to3/fixes/fix_urllib.pyt   transform_dot©   s    
c         C   sÆ   | j  d É r" |  j | | É nà | j  d É rD |  j | | É nf | j  d É rf |  j | | É nD | j  d É rà |  j | d É n" | j  d É r™ |  j | d É n  d  S(   NRK   RY   Rx   t   module_stars   Cannot handle star imports.t	   module_ass#   This module is now multiple modules(   RM   RX   Rw   Rz   Rd   (   RJ   RR   RS   (    (    s.   /usr/lib/python2.7/lib2to3/fixes/fix_urllib.pyt	   transform∫   s    (   t   __name__t
   __module__RF   RX   Rw   Rz   R}   (    (    (    s.   /usr/lib/python2.7/lib2to3/fixes/fix_urllib.pyRG   H   s
   			L	N(   t   __doc__t   lib2to3.fixes.fix_importsR    R   t   lib2to3R   t   lib2to3.fixer_utilR   R   R   R   R   R   R	   R>   RP   RF   RG   (    (    (    s.   /usr/lib/python2.7/lib2to3/fixes/fix_urllib.pyt   <module>   sD   4							                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          Û
”´[c           @   sS   d  Z  d d l m Z d d l m Z d d l m Z d e j f d Ñ  É  YZ d S(   s©   Fixer that changes 'a ,b' into 'a, b'.

This also changes '{a :b}' into '{a: b}', but does not touch other
uses of colons.  It does not touch other uses of whitespace.

i   (   t   pytree(   t   token(   t
   fixer_baset
   FixWsCommac           B   sS   e  Z e Z d  Z e j e j d É Z e j e j	 d É Z	 e e	 f Z
 d Ñ  Z RS(   sH   
    any<(not(',') any)+ ',' ((not(',') any)+ ',')* [not(',') any]>
    u   ,u   :c         C   sô   | j  É  } t } xÄ | j D]u } | |  j k rg | j } | j É  r^ d | k r^ d | _ n  t } q | rã | j } | sã d | _ qã n  t } q W| S(   Nu   
u    u    (   t   clonet   Falset   childrent   SEPSt   prefixt   isspacet   True(   t   selft   nodet   resultst   newt   commat   childR   (    (    s0   /usr/lib/python2.7/lib2to3/fixes/fix_ws_comma.pyt	   transform   s    			
(   t   __name__t
   __module__R
   t   explicitt   PATTERNR    t   LeafR   t   COMMAt   COLONR   R   (    (    (    s0   /usr/lib/python2.7/lib2to3/fixes/fix_ws_comma.pyR      s   N(   t   __doc__t    R    t   pgen2R   R   t   BaseFixR   (    (    (    s0   /usr/lib/python2.7/lib2to3/fixes/fix_ws_comma.pyt   <module>   s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     # Copyright 2007 Google, Inc. All Rights Reserved.
# Licensed to PSF under a Contributor Agreement.

"""Fixer that changes xrange(...) into range(...)."""

# Local imports
from .. import fixer_base
from ..fixer_util import Name, Call, consuming_calls
from .. import patcomp


class FixXrange(fixer_base.BaseFix):
    BM_compatible = True
    PATTERN = """
              power<
                 (name='range'|name='xrange') trailer< '(' args=any ')' >
              rest=any* >
              """

    def start_tree(self, tree, filename):
        super(FixXrange, self).start_tree(tree, filename)
        self.transformed_xranges = set()

    def finish_tree(self, tree, filename):
        self.transformed_xranges = None

    def transform(self, node, results):
        name = results["name"]
        if name.value == u"xrange":
            return self.transform_xrange(node, results)
        elif name.value == u"range":
            return self.transform_range(node, results)
        else:
            raise ValueError(repr(name))

    def transform_xrange(self, node, results):
        name = results["name"]
        name.replace(Name(u"range", prefix=name.prefix))
        # This prevents the new range call from being wrapped in a list later.
        self.transformed_xranges.add(id(node))

    def transform_range(self, node, results):
        if (id(node) not in self.transformed_xranges and
            not self.in_special_context(node)):
            range_call = Call(Name(u"range"), [results["args"].clone()])
            # Encase the range call in list().
            list_call = Call(Name(u"list"), [range_call],
                             prefix=node.prefix)
            # Put things that were after the range() call after the list call.
            for n in results["rest"]:
                list_call.append_child(n)
            return list_call

    P1 = "power< func=NAME trailer< '(' node=any ')' > any* >"
    p1 = patcomp.compile_pattern(P1)

    P2 = """for_stmt< 'for' any 'in' node=any ':' any* >
            | comp_for< 'for' any 'in' node=any any* >
            | comparison< any 'in' node=any any*>
         """
    p2 = patcomp.compile_pattern(P2)

    def in_special_context(self, node):
        if node.parent is None:
            return False
        results = {}
        if (node.parent.parent is not None and
               self.p1.match(node.parent.parent, results) and
               results["node"] is node):
            # list(d.keys()) -> list(d.keys()), etc.
            return results["func"].value in consuming_calls
        # for ... in d.iterkeys() -> for ... in d.keys(), etc.
        return self.p2.match(node.parent, results) and results["node"] is node
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     Û
”´[c           @   s_   d  Z  d d l m Z d d l m Z m Z m Z d d l m Z d e j f d Ñ  É  YZ	 d S(   s/   Fixer that changes xrange(...) into range(...).i   (   t
   fixer_base(   t   Namet   Callt   consuming_calls(   t   patcompt	   FixXrangec           B   st   e  Z e Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Z
 e j e
 É Z d Z e j e É Z d Ñ  Z RS(	   sà   
              power<
                 (name='range'|name='xrange') trailer< '(' args=any ')' >
              rest=any* >
              c         C   s)   t  t |  É j | | É t É  |  _ d  S(   N(   t   superR   t
   start_treet   sett   transformed_xranges(   t   selft   treet   filename(    (    s.   /usr/lib/python2.7/lib2to3/fixes/fix_xrange.pyR      s    c         C   s   d  |  _ d  S(   N(   t   NoneR	   (   R
   R   R   (    (    s.   /usr/lib/python2.7/lib2to3/fixes/fix_xrange.pyt   finish_tree   s    c         C   s^   | d } | j  d k r) |  j | | É S| j  d k rH |  j | | É St t | É É Ç d  S(   Nt   nameu   xrangeu   range(   t   valuet   transform_xranget   transform_ranget
   ValueErrort   repr(   R
   t   nodet   resultsR   (    (    s.   /usr/lib/python2.7/lib2to3/fixes/fix_xrange.pyt	   transform   s    
c         C   s@   | d } | j  t d d | j ÉÉ |  j j t | É É d  S(   NR   u   ranget   prefix(   t   replaceR   R   R	   t   addt   id(   R
   R   R   R   (    (    s.   /usr/lib/python2.7/lib2to3/fixes/fix_xrange.pyR   $   s    
c         C   sí   t  | É |  j k ré |  j | É ré t t d É | d j É  g É } t t d É | g d | j É} x | d D] } | j | É qs W| Sd  S(   Nu   ranget   argsu   listR   t   rest(   R   R	   t   in_special_contextR   R   t   cloneR   t   append_child(   R
   R   R   t
   range_callt	   list_callt   n(    (    s.   /usr/lib/python2.7/lib2to3/fixes/fix_xrange.pyR   *   s    "s3   power< func=NAME trailer< '(' node=any ')' > any* >sü   for_stmt< 'for' any 'in' node=any ':' any* >
            | comp_for< 'for' any 'in' node=any any* >
            | comparison< any 'in' node=any any*>
         c         C   sç   | j  d  k r t Si  } | j  j  d  k	 rg |  j j | j  j  | É rg | d | k rg | d j t k S|  j j | j  | É oå | d | k S(   NR   t   func(   t   parentR   t   Falset   p1t   matchR   R   t   p2(   R
   R   R   (    (    s.   /usr/lib/python2.7/lib2to3/fixes/fix_xrange.pyR   ?   s    (   t   __name__t
   __module__t   Truet   BM_compatiblet   PATTERNR   R   R   R   R   t   P1R   t   compile_patternR'   t   P2R)   R   (    (    (    s.   /usr/lib/python2.7/lib2to3/fixes/fix_xrange.pyR      s   						N(
   t   __doc__t    R    t
   fixer_utilR   R   R   R   t   BaseFixR   (    (    (    s.   /usr/lib/python2.7/lib2to3/fixes/fix_xrange.pyt   <module>   s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    """Fix "for x in f.xreadlines()" -> "for x in f".

This fixer will also convert g(f.xreadlines) into g(f.__iter__)."""
# Author: Collin Winter

# Local imports
from .. import fixer_base
from ..fixer_util import Name


class FixXreadlines(fixer_base.BaseFix):
    BM_compatible = True
    PATTERN = """
    power< call=any+ trailer< '.' 'xreadlines' > trailer< '(' ')' > >
    |
    power< any+ trailer< '.' no_call='xreadlines' > >
    """

    def transform(self, node, results):
        no_call = results.get("no_call")

        if no_call:
            no_call.replace(Name(u"__iter__", prefix=no_call.prefix))
        else:
            node.replace([x.clone() for x in results["call"]])
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              Û
”´[c           @   sC   d  Z  d d l m Z d d l m Z d e j f d Ñ  É  YZ d S(   sp   Fix "for x in f.xreadlines()" -> "for x in f".

This fixer will also convert g(f.xreadlines) into g(f.__iter__).i   (   t
   fixer_base(   t   Namet   FixXreadlinesc           B   s   e  Z e Z d  Z d Ñ  Z RS(   sá   
    power< call=any+ trailer< '.' 'xreadlines' > trailer< '(' ')' > >
    |
    power< any+ trailer< '.' no_call='xreadlines' > >
    c         C   sb   | j  d É } | r4 | j t d d | j ÉÉ n* | j g  | d D] } | j É  ^ qE É d  S(   Nt   no_callu   __iter__t   prefixt   call(   t   gett   replaceR   R   t   clone(   t   selft   nodet   resultsR   t   x(    (    s2   /usr/lib/python2.7/lib2to3/fixes/fix_xreadlines.pyt	   transform   s    (   t   __name__t
   __module__t   Truet   BM_compatiblet   PATTERNR   (    (    (    s2   /usr/lib/python2.7/lib2to3/fixes/fix_xreadlines.pyR      s   N(   t   __doc__t    R    t
   fixer_utilR   t   BaseFixR   (    (    (    s2   /usr/lib/python2.7/lib2to3/fixes/fix_xreadlines.pyt   <module>   s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           """
Fixer that changes zip(seq0, seq1, ...) into list(zip(seq0, seq1, ...)
unless there exists a 'from future_builtins import zip' statement in the
top-level namespace.

We avoid the transformation if the zip() call is directly contained in
iter(<>), list(<>), tuple(<>), sorted(<>), ...join(<>), or for V in <>:.
"""

# Local imports
from .. import fixer_base
from ..fixer_util import Name, Call, in_special_context

class FixZip(fixer_base.ConditionalFix):

    BM_compatible = True
    PATTERN = """
    power< 'zip' args=trailer< '(' [any] ')' >
    >
    """

    skip_on = "future_builtins.zip"

    def transform(self, node, results):
        if self.should_skip(node):
            return

        if in_special_context(node):
            return None

        new = node.clone()
        new.prefix = u""
        new = Call(Name(u"list"), [new])
        new.prefix = node.prefix
        return new
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        Û
”´[c           @   sO   d  Z  d d l m Z d d l m Z m Z m Z d e j f d Ñ  É  YZ d S(   s7  
Fixer that changes zip(seq0, seq1, ...) into list(zip(seq0, seq1, ...)
unless there exists a 'from future_builtins import zip' statement in the
top-level namespace.

We avoid the transformation if the zip() call is directly contained in
iter(<>), list(<>), tuple(<>), sorted(<>), ...join(<>), or for V in <>:.
i   (   t
   fixer_base(   t   Namet   Callt   in_special_contextt   FixZipc           B   s#   e  Z e Z d  Z d Z d Ñ  Z RS(   s:   
    power< 'zip' args=trailer< '(' [any] ')' >
    >
    s   future_builtins.zipc         C   s`   |  j  | É r d  St | É r# d  S| j É  } d | _ t t d É | g É } | j | _ | S(   Nu    u   list(   t   should_skipR   t   Nonet   clonet   prefixR   R   (   t   selft   nodet   resultst   new(    (    s+   /usr/lib/python2.7/lib2to3/fixes/fix_zip.pyt	   transform   s    	(   t   __name__t
   __module__t   Truet   BM_compatiblet   PATTERNt   skip_onR   (    (    (    s+   /usr/lib/python2.7/lib2to3/fixes/fix_zip.pyR      s   N(	   t   __doc__t    R    t
   fixer_utilR   R   R   t   ConditionalFixR   (    (    (    s+   /usr/lib/python2.7/lib2to3/fixes/fix_zip.pyt   <module>   s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         # Copyright 2004-2005 Elemental Security, Inc. All Rights Reserved.
# Licensed to PSF under a Contributor Agreement.

"""The pgen2 package."""
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 Û
”´[c           @   s
   d  Z  d S(   s   The pgen2 package.N(   t   __doc__(    (    (    s,   /usr/lib/python2.7/lib2to3/pgen2/__init__.pyt   <module>   s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # Copyright 2004-2005 Elemental Security, Inc. All Rights Reserved.
# Licensed to PSF under a Contributor Agreement.

"""Convert graminit.[ch] spit out by pgen to Python code.

Pgen is the Python parser generator.  It is useful to quickly create a
parser from a grammar file in Python's grammar notation.  But I don't
want my parsers to be written in C (yet), so I'm translating the
parsing tables to Python data structures and writing a Python parse
engine.

Note that the token numbers are constants determined by the standard
Python tokenizer.  The standard token module defines these numbers and
their names (the names are not used much).  The token numbers are
hardcoded into the Python tokenizer and into pgen.  A Python
implementation of the Python tokenizer is also available, in the
standard tokenize module.

On the other hand, symbol numbers (representing the grammar's
non-terminals) are assigned by pgen based on the actual grammar
input.

Note: this module is pretty much obsolete; the pgen module generates
equivalent grammar tables directly from the Grammar.txt input file
without having to invoke the Python pgen C program.

"""

# Python imports
import re

# Local imports
from pgen2 import grammar, token


class Converter(grammar.Grammar):
    """Grammar subclass that reads classic pgen output files.

    The run() method reads the tables as produced by the pgen parser
    generator, typically contained in two C files, graminit.h and
    graminit.c.  The other methods are for internal use only.

    See the base class for more documentation.

    """

    def run(self, graminit_h, graminit_c):
        """Load the grammar tables from the text files written by pgen."""
        self.parse_graminit_h(graminit_h)
        self.parse_graminit_c(graminit_c)
        self.finish_off()

    def parse_graminit_h(self, filename):
        """Parse the .h file written by pgen.  (Internal)

        This file is a sequence of #define statements defining the
        nonterminals of the grammar as numbers.  We build two tables
        mapping the numbers to names and back.

        """
        try:
            f = open(filename)
        except IOError, err:
            print "Can't open %s: %s" % (filename, err)
            return False
        self.symbol2number = {}
        self.number2symbol = {}
        lineno = 0
        for line in f:
            lineno += 1
            mo = re.match(r"^#define\s+(\w+)\s+(\d+)$", line)
            if not mo and line.strip():
                print "%s(%s): can't parse %s" % (filename, lineno,
                                                  line.strip())
            else:
                symbol, number = mo.groups()
                number = int(number)
                assert symbol not in self.symbol2number
                assert number not in self.number2symbol
                self.symbol2number[symbol] = number
                self.number2symbol[number] = symbol
        return True

    def parse_graminit_c(self, filename):
        """Parse the .c file written by pgen.  (Internal)

        The file looks as follows.  The first two lines are always this:

        #include "pgenheaders.h"
        #include "grammar.h"

        After that come four blocks:

        1) one or more state definitions
        2) a table defining dfas
        3) a table defining labels
        4) a struct defining the grammar

        A state definition has the following form:
        - one or more arc arrays, each of the form:
          static arc arcs_<n>_<m>[<k>] = {
                  {<i>, <j>},
                  ...
          };
        - followed by a state array, of the form:
          static state states_<s>[<t>] = {
                  {<k>, arcs_<n>_<m>},
                  ...
          };

        """
        try:
            f = open(filename)
        except IOError, err:
            print "Can't open %s: %s" % (filename, err)
            return False
        # The code below essentially uses f's iterator-ness!
        lineno = 0

        # Expect the two #include lines
        lineno, line = lineno+1, f.next()
        assert line == '#include "pgenheaders.h"\n', (lineno, line)
        lineno, line = lineno+1, f.next()
        assert line == '#include "grammar.h"\n', (lineno, line)

        # Parse the state definitions
        lineno, line = lineno+1, f.next()
        allarcs = {}
        states = []
        while line.startswith("static arc "):
            while line.startswith("static arc "):
                mo = re.match(r"static arc arcs_(\d+)_(\d+)\[(\d+)\] = {$",
                              line)
                assert mo, (lineno, line)
                n, m, k = map(int, mo.groups())
                arcs = []
                for _ in range(k):
                    lineno, line = lineno+1, f.next()
                    mo = re.match(r"\s+{(\d+), (\d+)},$", line)
                    assert mo, (lineno, line)
                    i, j = map(int, mo.groups())
                    arcs.append((i, j))
                lineno, line = lineno+1, f.next()
                assert line == "};\n", (lineno, line)
                allarcs[(n, m)] = arcs
                lineno, line = lineno+1, f.next()
            mo = re.match(r"static state states_(\d+)\[(\d+)\] = {$", line)
            assert mo, (lineno, line)
            s, t = map(int, mo.groups())
            assert s == len(states), (lineno, line)
            state = []
            for _ in range(t):
                lineno, line = lineno+1, f.next()
                mo = re.match(r"\s+{(\d+), arcs_(\d+)_(\d+)},$", line)
                assert mo, (lineno, line)
                k, n, m = map(int, mo.groups())
                arcs = allarcs[n, m]
                assert k == len(arcs), (lineno, line)
                state.append(arcs)
            states.append(state)
            lineno, line = lineno+1, f.next()
            assert line == "};\n", (lineno, line)
            lineno, line = lineno+1, f.next()
        self.states = states

        # Parse the dfas
        dfas = {}
        mo = re.match(r"static dfa dfas\[(\d+)\] = {$", line)
        assert mo, (lineno, line)
        ndfas = int(mo.group(1))
        for i in range(ndfas):
            lineno, line = lineno+1, f.next()
            mo = re.match(r'\s+{(\d+), "(\w+)", (\d+), (\d+), states_(\d+),$',
                          line)
            assert mo, (lineno, line)
            symbol = mo.group(2)
            number, x, y, z = map(int, mo.group(1, 3, 4, 5))
            assert self.symbol2number[symbol] == number, (lineno, line)
            assert self.number2symbol[number] == symbol, (lineno, line)
            assert x == 0, (lineno, line)
            state = states[z]
            assert y == len(state), (lineno, line)
            lineno, line = lineno+1, f.next()
            mo = re.match(r'\s+("(?:\\\d\d\d)*")},$', line)
            assert mo, (lineno, line)
            first = {}
            rawbitset = eval(mo.group(1))
            for i, c in enumerate(rawbitset):
                byte = ord(c)
                for j in range(8):
                    if byte & (1<<j):
                        first[i*8 + j] = 1
            dfas[number] = (state, first)
        lineno, line = lineno+1, f.next()
        assert line == "};\n", (lineno, line)
        self.dfas = dfas

        # Parse the labels
        labels = []
        lineno, line = lineno+1, f.next()
        mo = re.match(r"static label labels\[(\d+)\] = {$", line)
        assert mo, (lineno, line)
        nlabels = int(mo.group(1))
        for i in range(nlabels):
            lineno, line = lineno+1, f.next()
            mo = re.match(r'\s+{(\d+), (0|"\w+")},$', line)
            assert mo, (lineno, line)
            x, y = mo.groups()
            x = int(x)
            if y == "0":
                y = None
            else:
                y = eval(y)
            labels.append((x, y))
        lineno, line = lineno+1, f.next()
        assert line == "};\n", (lineno, line)
        self.labels = labels

        # Parse the grammar struct
        lineno, line = lineno+1, f.next()
        assert line == "grammar _PyParser_Grammar = {\n", (lineno, line)
        lineno, line = lineno+1, f.next()
        mo = re.match(r"\s+(\d+),$", line)
        assert mo, (lineno, line)
        ndfas = int(mo.group(1))
        assert ndfas == len(self.dfas)
        lineno, line = lineno+1, f.next()
        assert line == "\tdfas,\n", (lineno, line)
        lineno, line = lineno+1, f.next()
        mo = re.match(r"\s+{(\d+), labels},$", line)
        assert mo, (lineno, line)
        nlabels = int(mo.group(1))
        assert nlabels == len(self.labels), (lineno, line)
        lineno, line = lineno+1, f.next()
        mo = re.match(r"\s+(\d+)$", line)
        assert mo, (lineno, line)
        start = int(mo.group(1))
        assert start in self.number2symbol, (lineno, line)
        self.start = start
        lineno, line = lineno+1, f.next()
        assert line == "};\n", (lineno, line)
        try:
            lineno, line = lineno+1, f.next()
        except StopIteration:
            pass
        else:
            assert 0, (lineno, line)

    def finish_off(self):
        """Create additional useful structures.  (Internal)."""
        self.keywords = {} # map from keyword strings to arc labels
        self.tokens = {}   # map from numeric token values to arc labels
        for ilabel, (type, value) in enumerate(self.labels):
            if type == token.NAME and value is not None:
                self.keywords[value] = ilabel
            elif value is None:
                self.tokens[type] = ilabel
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     Û
”´[c           @   sE   d  Z  d d l Z d d l m Z m Z d e j f d Ñ  É  YZ d S(   s˝  Convert graminit.[ch] spit out by pgen to Python code.

Pgen is the Python parser generator.  It is useful to quickly create a
parser from a grammar file in Python's grammar notation.  But I don't
want my parsers to be written in C (yet), so I'm translating the
parsing tables to Python data structures and writing a Python parse
engine.

Note that the token numbers are constants determined by the standard
Python tokenizer.  The standard token module defines these numbers and
their names (the names are not used much).  The token numbers are
hardcoded into the Python tokenizer and into pgen.  A Python
implementation of the Python tokenizer is also available, in the
standard tokenize module.

On the other hand, symbol numbers (representing the grammar's
non-terminals) are assigned by pgen based on the actual grammar
input.

Note: this module is pretty much obsolete; the pgen module generates
equivalent grammar tables directly from the Grammar.txt input file
without having to invoke the Python pgen C program.

iˇˇˇˇN(   t   grammart   tokent	   Converterc           B   s2   e  Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   s2  Grammar subclass that reads classic pgen output files.

    The run() method reads the tables as produced by the pgen parser
    generator, typically contained in two C files, graminit.h and
    graminit.c.  The other methods are for internal use only.

    See the base class for more documentation.

    c         C   s(   |  j  | É |  j | É |  j É  d S(   s<   Load the grammar tables from the text files written by pgen.N(   t   parse_graminit_ht   parse_graminit_ct
   finish_off(   t   selft
   graminit_ht
   graminit_c(    (    s(   /usr/lib/python2.7/lib2to3/pgen2/conv.pyt   run/   s    c   	      C   s  y t  | É } Wn# t k
 r5 } d | | f GHt SXi  |  _ i  |  _ d } x∫ | D]≤ } | d 7} t j d | É } | r• | j É  r• d | | | j É  f GHqU | j É  \ } } t	 | É } | |  j k sÿ t
 Ç | |  j k sÌ t
 Ç | |  j | <| |  j | <qU Wt S(   s   Parse the .h file written by pgen.  (Internal)

        This file is a sequence of #define statements defining the
        nonterminals of the grammar as numbers.  We build two tables
        mapping the numbers to names and back.

        s   Can't open %s: %si    i   s   ^#define\s+(\w+)\s+(\d+)$s   %s(%s): can't parse %s(   t   opent   IOErrort   Falset   symbol2numbert   number2symbolt   ret   matcht   stript   groupst   intt   AssertionErrort   True(	   R   t   filenamet   ft   errt   linenot   linet   mot   symbolt   number(    (    s(   /usr/lib/python2.7/lib2to3/pgen2/conv.pyR   5   s*    		
	c   !      C   s≈	  y t  | É } Wn# t k
 r5 } d | | f GHt SXd } | d | j É  } } | d k sq t | | f É Ç | d | j É  } } | d k s¶ t | | f É Ç | d | j É  } } i  } g  } xÿ| j d É r£xC| j d É r t j d | É } | st | | f É Ç t t	 | j
 É  É \ }	 }
 } g  } xÉ t | É D]u } | d | j É  } } t j d | É } | sèt | | f É Ç t t	 | j
 É  É \ } } | j | | f É qHW| d | j É  } } | d	 k sˆt | | f É Ç | | |	 |
 f <| d | j É  } } qﬁ Wt j d
 | É } | sKt | | f É Ç t t	 | j
 É  É \ } } | t | É k sät | | f É Ç g  } x¥ t | É D]¶ } | d | j É  } } t j d | É } | s‰t | | f É Ç t t	 | j
 É  É \ } }	 }
 | |	 |
 f } | t | É k s6t | | f É Ç | j | É qùW| j | É | d | j É  } } | d	 k sât | | f É Ç | d | j É  } } qÃ W| |  _ i  } t j d | É } | s›t | | f É Ç t	 | j d É É } xˆt | É D]Ë} | d | j É  } } t j d | É } | sFt | | f É Ç | j d É } t t	 | j d d d d É É \ } } } } |  j | | k sßt | | f É Ç |  j | | k sÃt | | f É Ç | d k sÍt | | f É Ç | | } | t | É k st | | f É Ç | d | j É  } } t j d | É } | sYt | | f É Ç i  } t | j d É É } x` t | É D]R \ } } t | É } x7 t d É D]) } | d | >@r¶d | | d | <q¶q¶WqÅW| | f | | <qˇW| d | j É  } } | d	 k s t | | f É Ç | |  _ g  } | d | j É  } } t j d | É } | spt | | f É Ç t	 | j d É É } xß t | É D]ô } | d | j É  } } t j d | É } | sŸt | | f É Ç | j
 É  \ } } t	 | É } | d k rd } n t | É } | j | | f É qíW| d | j É  } } | d	 k sdt | | f É Ç | |  _ | d | j É  } } | d k s¢t | | f É Ç | d | j É  } } t j d | É } | s„t | | f É Ç t	 | j d É É } | t |  j É k st Ç | d | j É  } } | d k sHt | | f É Ç | d | j É  } } t j d | É } | sât | | f É Ç t	 | j d É É } | t |  j É k s≈t | | f É Ç | d | j É  } } t j d | É } | s	t | | f É Ç t	 | j d É É }  |  |  j k s<	t | | f É Ç |  |  _ | d | j É  } } | d	 k sz	t | | f É Ç y | d | j É  } } Wn t k
 r®	n Xd s¡	t | | f É Ç d S(   s˘  Parse the .c file written by pgen.  (Internal)

        The file looks as follows.  The first two lines are always this:

        #include "pgenheaders.h"
        #include "grammar.h"

        After that come four blocks:

        1) one or more state definitions
        2) a table defining dfas
        3) a table defining labels
        4) a struct defining the grammar

        A state definition has the following form:
        - one or more arc arrays, each of the form:
          static arc arcs_<n>_<m>[<k>] = {
                  {<i>, <j>},
                  ...
          };
        - followed by a state array, of the form:
          static state states_<s>[<t>] = {
                  {<k>, arcs_<n>_<m>},
                  ...
          };

        s   Can't open %s: %si    i   s   #include "pgenheaders.h"
s   #include "grammar.h"
s   static arc s)   static arc arcs_(\d+)_(\d+)\[(\d+)\] = {$s   \s+{(\d+), (\d+)},$s   };
s'   static state states_(\d+)\[(\d+)\] = {$s   \s+{(\d+), arcs_(\d+)_(\d+)},$s   static dfa dfas\[(\d+)\] = {$s0   \s+{(\d+), "(\w+)", (\d+), (\d+), states_(\d+),$i   i   i   i   s   \s+("(?:\\\d\d\d)*")},$i   s!   static label labels\[(\d+)\] = {$s   \s+{(\d+), (0|"\w+")},$t   0s   grammar _PyParser_Grammar = {
s
   \s+(\d+),$s   	dfas,
s   \s+{(\d+), labels},$s	   \s+(\d+)$N(   R
   R   R   t   nextR   t
   startswithR   R   t   mapR   R   t   ranget   appendt   lent   statest   groupR   R   t   evalt	   enumeratet   ordt   dfast   Nonet   labelst   startt   StopIteration(!   R   R   R   R   R   R   t   allarcsR%   R   t   nt   mt   kt   arcst   _t   it   jt   st   tt   stateR*   t   ndfasR   R   t   xt   yt   zt   firstt	   rawbitsett   ct   byteR,   t   nlabelsR-   (    (    s(   /usr/lib/python2.7/lib2to3/pgen2/conv.pyR   T   sˆ    		$$			-%%
$			'!	c         C   sÉ   i  |  _  i  |  _ xj t |  j É D]Y \ } \ } } | t j k r_ | d k	 r_ | |  j  | <q" | d k r" | |  j | <q" q" Wd S(   s1   Create additional useful structures.  (Internal).N(   t   keywordst   tokensR(   R,   R   t   NAMER+   (   R   t   ilabelt   typet   value(    (    s(   /usr/lib/python2.7/lib2to3/pgen2/conv.pyR   ˘   s    		"(   t   __name__t
   __module__t   __doc__R	   R   R   R   (    (    (    s(   /usr/lib/python2.7/lib2to3/pgen2/conv.pyR   $   s
   				•(   RK   R   t   pgen2R    R   t   GrammarR   (    (    (    s(   /usr/lib/python2.7/lib2to3/pgen2/conv.pyt   <module>   s                  # Copyright 2004-2005 Elemental Security, Inc. All Rights Reserved.
# Licensed to PSF under a Contributor Agreement.

# Modifications:
# Copyright 2006 Google, Inc. All Rights Reserved.
# Licensed to PSF under a Contributor Agreement.

"""Parser driver.

This provides a high-level interface to parse a file into a syntax tree.

"""

__author__ = "Guido van Rossum <guido@python.org>"

__all__ = ["Driver", "load_grammar"]

# Python imports
import codecs
import os
import logging
import StringIO
import sys

# Pgen imports
from . import grammar, parse, token, tokenize, pgen


class Driver(object):

    def __init__(self, grammar, convert=None, logger=None):
        self.grammar = grammar
        if logger is None:
            logger = logging.getLogger()
        self.logger = logger
        self.convert = convert

    def parse_tokens(self, tokens, debug=False):
        """Parse a series of tokens and return the syntax tree."""
        # XXX Move the prefix computation into a wrapper around tokenize.
        p = parse.Parser(self.grammar, self.convert)
        p.setup()
        lineno = 1
        column = 0
        type = value = start = end = line_text = None
        prefix = u""
        for quintuple in tokens:
            type, value, start, end, line_text = quintuple
            if start != (lineno, column):
                assert (lineno, column) <= start, ((lineno, column), start)
                s_lineno, s_column = start
                if lineno < s_lineno:
                    prefix += "\n" * (s_lineno - lineno)
                    lineno = s_lineno
                    column = 0
                if column < s_column:
                    prefix += line_text[column:s_column]
                    column = s_column
            if type in (tokenize.COMMENT, tokenize.NL):
                prefix += value
                lineno, column = end
                if value.endswith("\n"):
                    lineno += 1
                    column = 0
                continue
            if type == token.OP:
                type = grammar.opmap[value]
            if debug:
                self.logger.debug("%s %r (prefix=%r)",
                                  token.tok_name[type], value, prefix)
            if p.addtoken(type, value, (prefix, start)):
                if debug:
                    self.logger.debug("Stop.")
                break
            prefix = ""
            lineno, column = end
            if value.endswith("\n"):
                lineno += 1
                column = 0
        else:
            # We never broke out -- EOF is too soon (how can this happen???)
            raise parse.ParseError("incomplete input",
                                   type, value, (prefix, start))
        return p.rootnode

    def parse_stream_raw(self, stream, debug=False):
        """Parse a stream and return the syntax tree."""
        tokens = tokenize.generate_tokens(stream.readline)
        return self.parse_tokens(tokens, debug)

    def parse_stream(self, stream, debug=False):
        """Parse a stream and return the syntax tree."""
        return self.parse_stream_raw(stream, debug)

    def parse_file(self, filename, encoding=None, debug=False):
        """Parse a file and return the syntax tree."""
        stream = codecs.open(filename, "r", encoding)
        try:
            return self.parse_stream(stream, debug)
        finally:
            stream.close()

    def parse_string(self, text, debug=False):
        """Parse a string and return the syntax tree."""
        tokens = tokenize.generate_tokens(StringIO.StringIO(text).readline)
        return self.parse_tokens(tokens, debug)


def _generate_pickle_name(gt):
    head, tail = os.path.splitext(gt)
    if tail == ".txt":
        tail = ""
    return head + tail + ".".join(map(str, sys.version_info)) + ".pickle"


def load_grammar(gt="Grammar.txt", gp=None,
                 save=True, force=False, logger=None):
    """Load the grammar (maybe from a pickle)."""
    if logger is None:
        logger = logging.getLogger()
    gp = _generate_pickle_name(gt) if gp is None else gp
    if force or not _newer(gp, gt):
        logger.info("Generating grammar tables from %s", gt)
        g = pgen.generate_grammar(gt)
        # the pickle files mismatch, when built on different architectures.
        # don't save these for now. An alternative solution might be to
        # include the multiarch triplet into the file name
        if False:
            logger.info("Writing grammar tables to %s", gp)
            try:
                g.dump(gp)
            except IOError as e:
                logger.info("Writing failed: %s", e)
    else:
        g = grammar.Grammar()
        g.load(gp)
    return g


def _newer(a, b):
    """Inquire whether file a was written since file b."""
    if not os.path.exists(a):
        return False
    if not os.path.exists(b):
        return True
    return os.path.getmtime(a) >= os.path.getmtime(b)


def main(*args):
    """Main program, when run as a script: produce grammar pickle files.

    Calls load_grammar for each argument, a path to a grammar text file.
    """
    if not args:
        args = sys.argv[1:]
    logging.basicConfig(level=logging.INFO, stream=sys.stdout,
                        format='%(message)s')
    for gt in args:
        load_grammar(gt, save=True, force=True)
    return True

if __name__ == "__main__":
    sys.exit(int(not main()))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          Û
”´[c           @   sÔ   d  Z  d Z d d g Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l m	 Z	 m
 Z
 m Z m Z m Z d e f d Ñ  É  YZ d	 Ñ  Z d
 d e e d d Ñ Z d Ñ  Z d Ñ  Z e d k rÎ e j e e É  É É n  d S(   sZ   Parser driver.

This provides a high-level interface to parse a file into a syntax tree.

s#   Guido van Rossum <guido@python.org>t   Drivert   load_grammariˇˇˇˇNi   (   t   grammart   parset   tokent   tokenizet   pgenc           B   sV   e  Z d d d  Ñ Z e d Ñ Z e d Ñ Z e d Ñ Z d e d Ñ Z e d Ñ Z	 RS(   c         C   s:   | |  _  | d  k r$ t j É  } n  | |  _ | |  _ d  S(   N(   R   t   Nonet   loggingt	   getLoggert   loggert   convert(   t   selfR   R   R
   (    (    s*   /usr/lib/python2.7/lib2to3/pgen2/driver.pyt   __init__   s
    		c         C   s=  t  j |  j |  j É } | j É  d } d } d	 } } } }	 }
 d } xÈ| D]√} | \ } } } }	 }
 | | | f k r
| | f | k s® t | | f | f É Ç | \ } } | | k  r· | d | | 7} | } d } n  | | k  r
| |
 | | !7} | } q
n  | t j t j	 f k r`| | 7} |	 \ } } | j
 d É rQ | d 7} d } qQ qQ n  | t j k rt j | } n  | r®|  j j d t j | | | É n  | j | | | | f É r‡| r‹|  j j d É n  Pn  d } |	 \ } } | j
 d É rQ | d 7} d } qQ qQ Wt  j d | | | | f É Ç | j S(
   s4   Parse a series of tokens and return the syntax tree.i   i    u    s   
s   %s %r (prefix=%r)s   Stop.t    s   incomplete inputN(   R   t   ParserR   R   t   setupR   t   AssertionErrorR   t   COMMENTt   NLt   endswithR   t   OPt   opmapR
   t   debugt   tok_namet   addtokent
   ParseErrort   rootnode(   R   t   tokensR   t   pt   linenot   columnt   typet   valuet   startt   endt	   line_textt   prefixt	   quintuplet   s_linenot   s_column(    (    s*   /usr/lib/python2.7/lib2to3/pgen2/driver.pyt   parse_tokens&   sT    
*	

	
	c         C   s"   t  j | j É } |  j | | É S(   s*   Parse a stream and return the syntax tree.(   R   t   generate_tokenst   readlineR)   (   R   t   streamR   R   (    (    s*   /usr/lib/python2.7/lib2to3/pgen2/driver.pyt   parse_stream_rawV   s    c         C   s   |  j  | | É S(   s*   Parse a stream and return the syntax tree.(   R-   (   R   R,   R   (    (    s*   /usr/lib/python2.7/lib2to3/pgen2/driver.pyt   parse_stream[   s    c         C   s;   t  j | d | É } z |  j | | É SWd | j É  Xd S(   s(   Parse a file and return the syntax tree.t   rN(   t   codecst   openR.   t   close(   R   t   filenamet   encodingR   R,   (    (    s*   /usr/lib/python2.7/lib2to3/pgen2/driver.pyt
   parse_file_   s    c         C   s+   t  j t j | É j É } |  j | | É S(   s*   Parse a string and return the syntax tree.(   R   R*   t   StringIOR+   R)   (   R   t   textR   R   (    (    s*   /usr/lib/python2.7/lib2to3/pgen2/driver.pyt   parse_stringg   s    N(
   t   __name__t
   __module__R   R   t   FalseR)   R-   R.   R5   R8   (    (    (    s*   /usr/lib/python2.7/lib2to3/pgen2/driver.pyR       s   0c         C   sR   t  j j |  É \ } } | d k r- d } n  | | d j t t t j É É d S(   Ns   .txtR   t   .s   .pickle(   t   ost   patht   splitextt   joint   mapt   strt   syst   version_info(   t   gtt   headt   tail(    (    s*   /usr/lib/python2.7/lib2to3/pgen2/driver.pyt   _generate_pickle_namem   s    	s   Grammar.txtc         C   sﬁ   | d k r t j É  } n  | d k r3 t |  É n | } | sO t | |  É r¡ | j d |  É t j |  É } t r⁄ | j d | É y | j	 | É Wqæ t
 k
 r∫ } | j d | É qæ Xq⁄ n t j É  } | j | É | S(   s'   Load the grammar (maybe from a pickle).s!   Generating grammar tables from %ss   Writing grammar tables to %ss   Writing failed: %sN(   R   R   R	   RH   t   _newert   infoR   t   generate_grammarR;   t   dumpt   IOErrorR   t   Grammart   load(   RE   t   gpt   savet   forceR
   t   gt   e(    (    s*   /usr/lib/python2.7/lib2to3/pgen2/driver.pyR   t   s    c         C   sN   t  j j |  É s t St  j j | É s, t St  j j |  É t  j j | É k S(   s0   Inquire whether file a was written since file b.(   R=   R>   t   existsR;   t   Truet   getmtime(   t   at   b(    (    s*   /usr/lib/python2.7/lib2to3/pgen2/driver.pyRI   å   s
    c          G   sc   |  s t  j d }  n  t j d t j d t  j d d É x$ |  D] } t | d t d t Éq? Wt S(   sê   Main program, when run as a script: produce grammar pickle files.

    Calls load_grammar for each argument, a path to a grammar text file.
    i   t   levelR,   t   formats   %(message)sRQ   RR   (   RC   t   argvR   t   basicConfigt   INFOt   stdoutR   RV   (   t   argsRE   (    (    s*   /usr/lib/python2.7/lib2to3/pgen2/driver.pyt   mainï   s    t   __main__(   t   __doc__t
   __author__t   __all__R0   R=   R   R6   RC   R   R   R   R   R   R   t   objectR    RH   R   RV   R;   R   RI   Ra   R9   t   exitt   int(    (    (    s*   /usr/lib/python2.7/lib2to3/pgen2/driver.pyt   <module>   s    (P				                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                # Copyright 2004-2005 Elemental Security, Inc. All Rights Reserved.
# Licensed to PSF under a Contributor Agreement.

"""This module defines the data structures used to represent a grammar.

These are a bit arcane because they are derived from the data
structures used by Python's 'pgen' parser generator.

There's also a table here mapping operators to their names in the
token module; the Python tokenize module reports all operators as the
fallback token code OP, but the parser needs the actual token code.

"""

# Python imports
import collections
import pickle

# Local imports
from . import token, tokenize


class Grammar(object):
    """Pgen parsing tables conversion class.

    Once initialized, this class supplies the grammar tables for the
    parsing engine implemented by parse.py.  The parsing engine
    accesses the instance variables directly.  The class here does not
    provide initialization of the tables; several subclasses exist to
    do this (see the conv and pgen modules).

    The load() method reads the tables from a pickle file, which is
    much faster than the other ways offered by subclasses.  The pickle
    file is written by calling dump() (after loading the grammar
    tables using a subclass).  The report() method prints a readable
    representation of the tables to stdout, for debugging.

    The instance variables are as follows:

    symbol2number -- a dict mapping symbol names to numbers.  Symbol
                     numbers are always 256 or higher, to distinguish
                     them from token numbers, which are between 0 and
                     255 (inclusive).

    number2symbol -- a dict mapping numbers to symbol names;
                     these two are each other's inverse.

    states        -- a list of DFAs, where each DFA is a list of
                     states, each state is a list of arcs, and each
                     arc is a (i, j) pair where i is a label and j is
                     a state number.  The DFA number is the index into
                     this list.  (This name is slightly confusing.)
                     Final states are represented by a special arc of
                     the form (0, j) where j is its own state number.

    dfas          -- a dict mapping symbol numbers to (DFA, first)
                     pairs, where DFA is an item from the states list
                     above, and first is a set of tokens that can
                     begin this grammar rule (represented by a dict
                     whose values are always 1).

    labels        -- a list of (x, y) pairs where x is either a token
                     number or a symbol number, and y is either None
                     or a string; the strings are keywords.  The label
                     number is the index in this list; label numbers
                     are used to mark state transitions (arcs) in the
                     DFAs.

    start         -- the number of the grammar's start symbol.

    keywords      -- a dict mapping keyword strings to arc labels.

    tokens        -- a dict mapping token numbers to arc labels.

    """

    def __init__(self):
        self.symbol2number = {}
        self.number2symbol = {}
        self.states = []
        self.dfas = {}
        self.labels = [(0, "EMPTY")]
        self.keywords = {}
        self.tokens = {}
        self.symbol2label = {}
        self.start = 256

    def dump(self, filename):
        """Dump the grammar tables to a pickle file.

        dump() recursively changes all dict to OrderedDict, so the pickled file
        is not exactly the same as what was passed in to dump(). load() uses the
        pickled file to create the tables, but  only changes OrderedDict to dict
        at the top level; it does not recursively change OrderedDict to dict.
        So, the loaded tables are different from the original tables that were
        passed to load() in that some of the OrderedDict (from the pickled file)
        are not changed back to dict. For parsing, this has no effect on
        performance because OrderedDict uses dict's __getitem__ with nothing in
        between.
        """
        with open(filename, "wb") as f:
            d = _make_deterministic(self.__dict__)
            pickle.dump(d, f, 2)

    def load(self, filename):
        """Load the grammar tables from a pickle file."""
        f = open(filename, "rb")
        d = pickle.load(f)
        f.close()
        self.__dict__.update(d)

    def copy(self):
        """
        Copy the grammar.
        """
        new = self.__class__()
        for dict_attr in ("symbol2number", "number2symbol", "dfas", "keywords",
                          "tokens", "symbol2label"):
            setattr(new, dict_attr, getattr(self, dict_attr).copy())
        new.labels = self.labels[:]
        new.states = self.states[:]
        new.start = self.start
        return new

    def report(self):
        """Dump the grammar tables to standard output, for debugging."""
        from pprint import pprint
        print "s2n"
        pprint(self.symbol2number)
        print "n2s"
        pprint(self.number2symbol)
        print "states"
        pprint(self.states)
        print "dfas"
        pprint(self.dfas)
        print "labels"
        pprint(self.labels)
        print "start", self.start


def _make_deterministic(top):
    if isinstance(top, dict):
        return collections.OrderedDict(
            sorted(((k, _make_deterministic(v)) for k, v in top.iteritems())))
    if isinstance(top, list):
        return [_make_deterministic(e) for e in top]
    if isinstance(top, tuple):
        return tuple(_make_deterministic(e) for e in top)
    return top


# Map from operator to number (since tokenize doesn't do this)

opmap_raw = """
( LPAR
) RPAR
[ LSQB
] RSQB
: COLON
, COMMA
; SEMI
+ PLUS
- MINUS
* STAR
/ SLASH
| VBAR
& AMPER
< LESS
> GREATER
= EQUAL
. DOT
% PERCENT
` BACKQUOTE
{ LBRACE
} RBRACE
@ AT
@= ATEQUAL
== EQEQUAL
!= NOTEQUAL
<> NOTEQUAL
<= LESSEQUAL
>= GREATEREQUAL
~ TILDE
^ CIRCUMFLEX
<< LEFTSHIFT
>> RIGHTSHIFT
** DOUBLESTAR
+= PLUSEQUAL
-= MINEQUAL
*= STAREQUAL
/= SLASHEQUAL
%= PERCENTEQUAL
&= AMPEREQUAL
|= VBAREQUAL
^= CIRCUMFLEXEQUAL
<<= LEFTSHIFTEQUAL
>>= RIGHTSHIFTEQUAL
**= DOUBLESTAREQUAL
// DOUBLESLASH
//= DOUBLESLASHEQUAL
-> RARROW
"""

opmap = {}
for line in opmap_raw.splitlines():
    if line:
        op, name = line.split()
        opmap[op] = getattr(token, name)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Û
”´[c           @   s®   d  Z  d d l Z d d l Z d d l m Z m Z d e f d Ñ  É  YZ d Ñ  Z d Z	 i  Z
 xB e	 j É  D]4 Z e rl e j É  \ Z Z e e e É e
 e <ql ql Wd S(	   sá  This module defines the data structures used to represent a grammar.

These are a bit arcane because they are derived from the data
structures used by Python's 'pgen' parser generator.

There's also a table here mapping operators to their names in the
token module; the Python tokenize module reports all operators as the
fallback token code OP, but the parser needs the actual token code.

iˇˇˇˇNi   (   t   tokent   tokenizet   Grammarc           B   s;   e  Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   s∂	  Pgen parsing tables conversion class.

    Once initialized, this class supplies the grammar tables for the
    parsing engine implemented by parse.py.  The parsing engine
    accesses the instance variables directly.  The class here does not
    provide initialization of the tables; several subclasses exist to
    do this (see the conv and pgen modules).

    The load() method reads the tables from a pickle file, which is
    much faster than the other ways offered by subclasses.  The pickle
    file is written by calling dump() (after loading the grammar
    tables using a subclass).  The report() method prints a readable
    representation of the tables to stdout, for debugging.

    The instance variables are as follows:

    symbol2number -- a dict mapping symbol names to numbers.  Symbol
                     numbers are always 256 or higher, to distinguish
                     them from token numbers, which are between 0 and
                     255 (inclusive).

    number2symbol -- a dict mapping numbers to symbol names;
                     these two are each other's inverse.

    states        -- a list of DFAs, where each DFA is a list of
                     states, each state is a list of arcs, and each
                     arc is a (i, j) pair where i is a label and j is
                     a state number.  The DFA number is the index into
                     this list.  (This name is slightly confusing.)
                     Final states are represented by a special arc of
                     the form (0, j) where j is its own state number.

    dfas          -- a dict mapping symbol numbers to (DFA, first)
                     pairs, where DFA is an item from the states list
                     above, and first is a set of tokens that can
                     begin this grammar rule (represented by a dict
                     whose values are always 1).

    labels        -- a list of (x, y) pairs where x is either a token
                     number or a symbol number, and y is either None
                     or a string; the strings are keywords.  The label
                     number is the index in this list; label numbers
                     are used to mark state transitions (arcs) in the
                     DFAs.

    start         -- the number of the grammar's start symbol.

    keywords      -- a dict mapping keyword strings to arc labels.

    tokens        -- a dict mapping token numbers to arc labels.

    c         C   sX   i  |  _  i  |  _ g  |  _ i  |  _ d g |  _ i  |  _ i  |  _ i  |  _ d |  _ d  S(   Ni    t   EMPTYi   (   i    R   (	   t   symbol2numbert   number2symbolt   statest   dfast   labelst   keywordst   tokenst   symbol2labelt   start(   t   self(    (    s+   /usr/lib/python2.7/lib2to3/pgen2/grammar.pyt   __init__M   s    							c         C   s>   t  | d É è) } t |  j É } t j | | d É Wd QXd S(   sΩ  Dump the grammar tables to a pickle file.

        dump() recursively changes all dict to OrderedDict, so the pickled file
        is not exactly the same as what was passed in to dump(). load() uses the
        pickled file to create the tables, but  only changes OrderedDict to dict
        at the top level; it does not recursively change OrderedDict to dict.
        So, the loaded tables are different from the original tables that were
        passed to load() in that some of the OrderedDict (from the pickled file)
        are not changed back to dict. For parsing, this has no effect on
        performance because OrderedDict uses dict's __getitem__ with nothing in
        between.
        t   wbi   N(   t   opent   _make_deterministict   __dict__t   picklet   dump(   R   t   filenamet   ft   d(    (    s+   /usr/lib/python2.7/lib2to3/pgen2/grammar.pyR   X   s    c         C   s<   t  | d É } t j | É } | j É  |  j j | É d S(   s+   Load the grammar tables from a pickle file.t   rbN(   R   R   t   loadt   closeR   t   update(   R   R   R   R   (    (    s+   /usr/lib/python2.7/lib2to3/pgen2/grammar.pyR   i   s    
c         C   sf   |  j  É  } x- d D]% } t | | t |  | É j É  É q W|  j | _ |  j | _ |  j | _ | S(   s#   
        Copy the grammar.
        R   R   R   R	   R
   R   (   R   R   R   R	   R
   R   (   t	   __class__t   setattrt   getattrt   copyR   R   R   (   R   t   newt	   dict_attr(    (    s+   /usr/lib/python2.7/lib2to3/pgen2/grammar.pyR   p   s    
#c         C   sz   d d l  m  } d GH| |  j É d GH| |  j É d GH| |  j É d GH| |  j É d GH| |  j É d G|  j GHd	 S(
   s:   Dump the grammar tables to standard output, for debugging.iˇˇˇˇ(   t   pprintt   s2nt   n2sR   R   R   R   N(   R"   R   R   R   R   R   R   (   R   R"   (    (    s+   /usr/lib/python2.7/lib2to3/pgen2/grammar.pyt   report}   s    (   t   __name__t
   __module__t   __doc__R   R   R   R   R%   (    (    (    s+   /usr/lib/python2.7/lib2to3/pgen2/grammar.pyR      s   4				c         C   sÖ   t  |  t É r2 t j t d Ñ  |  j É  DÉ É É St  |  t É r^ g  |  D] } t | É ^ qH St  |  t É rÅ t d Ñ  |  DÉ É S|  S(   Nc         s   s'   |  ] \ } } | t  | É f Vq d  S(   N(   R   (   t   .0t   kt   v(    (    s+   /usr/lib/python2.7/lib2to3/pgen2/grammar.pys	   <genexpr>ê   s    c         s   s   |  ] } t  | É Vq d  S(   N(   R   (   R)   t   e(    (    s+   /usr/lib/python2.7/lib2to3/pgen2/grammar.pys	   <genexpr>î   s    (	   t
   isinstancet   dictt   collectionst   OrderedDictt   sortedt	   iteritemst   listR   t   tuple(   t   topR,   (    (    s+   /usr/lib/python2.7/lib2to3/pgen2/grammar.pyR   ç   s    s  
( LPAR
) RPAR
[ LSQB
] RSQB
: COLON
, COMMA
; SEMI
+ PLUS
- MINUS
* STAR
/ SLASH
| VBAR
& AMPER
< LESS
> GREATER
= EQUAL
. DOT
% PERCENT
` BACKQUOTE
{ LBRACE
} RBRACE
@ AT
@= ATEQUAL
== EQEQUAL
!= NOTEQUAL
<> NOTEQUAL
<= LESSEQUAL
>= GREATEREQUAL
~ TILDE
^ CIRCUMFLEX
<< LEFTSHIFT
>> RIGHTSHIFT
** DOUBLESTAR
+= PLUSEQUAL
-= MINEQUAL
*= STAREQUAL
/= SLASHEQUAL
%= PERCENTEQUAL
&= AMPEREQUAL
|= VBAREQUAL
^= CIRCUMFLEXEQUAL
<<= LEFTSHIFTEQUAL
>>= RIGHTSHIFTEQUAL
**= DOUBLESTAREQUAL
// DOUBLESLASH
//= DOUBLESLASHEQUAL
-> RARROW
(   R(   R/   R   t    R    R   t   objectR   R   t	   opmap_rawt   opmapt
   splitlinest   linet   splitt   opt   nameR   (    (    (    s+   /usr/lib/python2.7/lib2to3/pgen2/grammar.pyt   <module>   s   v	=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             # Copyright 2004-2005 Elemental Security, Inc. All Rights Reserved.
# Licensed to PSF under a Contributor Agreement.

"""Safely evaluate Python string literals without using eval()."""

import re

simple_escapes = {"a": "\a",
                  "b": "\b",
                  "f": "\f",
                  "n": "\n",
                  "r": "\r",
                  "t": "\t",
                  "v": "\v",
                  "'": "'",
                  '"': '"',
                  "\\": "\\"}

def escape(m):
    all, tail = m.group(0, 1)
    assert all.startswith("\\")
    esc = simple_escapes.get(tail)
    if esc is not None:
        return esc
    if tail.startswith("x"):
        hexes = tail[1:]
        if len(hexes) < 2:
            raise ValueError("invalid hex string escape ('\\%s')" % tail)
        try:
            i = int(hexes, 16)
        except ValueError:
            raise ValueError("invalid hex string escape ('\\%s')" % tail)
    else:
        try:
            i = int(tail, 8)
        except ValueError:
            raise ValueError("invalid octal string escape ('\\%s')" % tail)
    return chr(i)

def evalString(s):
    assert s.startswith("'") or s.startswith('"'), repr(s[:1])
    q = s[0]
    if s[:3] == q*3:
        q = q*3
    assert s.endswith(q), repr(s[-len(q):])
    assert len(s) >= 2*len(q)
    s = s[len(q):-len(q)]
    return re.sub(r"\\(\'|\"|\\|[abfnrtv]|x.{0,2}|[0-7]{1,3})", escape, s)

def test():
    for i in range(256):
        c = chr(i)
        s = repr(c)
        e = evalString(s)
        if e != c:
            print i, c, s, e


if __name__ == "__main__":
    test()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  Û
”´[c           @   sì   d  Z  d d l Z i
 d d 6d d 6d d 6d	 d
 6d d 6d d 6d d 6d d 6d d 6d d 6Z d Ñ  Z d Ñ  Z d Ñ  Z e d k rè e É  n  d S(   s<   Safely evaluate Python string literals without using eval().iˇˇˇˇNs   t   as   t   bs   t   fs   
t   ns   t   rs   	t   ts   t   vt   't   "s   \c         C   s  |  j  d d É \ } } | j d É s- t Ç t j | É } | d  k	 rL | S| j d É rƒ | d } t | É d k  rä t d | É Ç n  y t | d É } Wq˚ t k
 r¿ t d | É Ç q˚ Xn7 y t | d É } Wn! t k
 r˙ t d	 | É Ç n Xt	 | É S(
   Ni    i   s   \t   xi   s!   invalid hex string escape ('\%s')i   i   s#   invalid octal string escape ('\%s')(
   t   groupt
   startswitht   AssertionErrort   simple_escapest   gett   Nonet   lent
   ValueErrort   intt   chr(   t   mt   allt   tailt   esct   hexest   i(    (    s,   /usr/lib/python2.7/lib2to3/pgen2/literals.pyt   escape   s$    
c         C   s⁄   |  j  d É s4 |  j  d É s4 t t |  d  É É Ç |  d } |  d  | d k r_ | d } n  |  j | É sã t t |  t | É É É Ç t |  É d t | É k s≠ t Ç |  t | É t | É !}  t j d t |  É S(   NR   R   i   i    i   i   s)   \\(\'|\"|\\|[abfnrtv]|x.{0,2}|[0-7]{1,3})(   R   R   t   reprt   endswithR   t   ret   subR   (   t   st   q(    (    s,   /usr/lib/python2.7/lib2to3/pgen2/literals.pyt
   evalString(   s    4
,"c          C   s_   xX t  d É D]J }  t |  É } t | É } t | É } | | k r |  G| G| G| GHq q Wd  S(   Ni   (   t   rangeR   R   R!   (   R   t   cR   t   e(    (    s,   /usr/lib/python2.7/lib2to3/pgen2/literals.pyt   test2   s    t   __main__(   t   __doc__R   R   R   R!   R%   t   __name__(    (    (    s,   /usr/lib/python2.7/lib2to3/pgen2/literals.pyt   <module>   s    

		
		                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      # Copyright 2004-2005 Elemental Security, Inc. All Rights Reserved.
# Licensed to PSF under a Contributor Agreement.

"""Parser engine for the grammar tables generated by pgen.

The grammar table must be loaded first.

See Parser/parser.c in the Python distribution for additional info on
how this parsing engine works.

"""

# Local imports
from . import token

class ParseError(Exception):
    """Exception to signal the parser is stuck."""

    def __init__(self, msg, type, value, context):
        Exception.__init__(self, "%s: type=%r, value=%r, context=%r" %
                           (msg, type, value, context))
        self.msg = msg
        self.type = type
        self.value = value
        self.context = context

class Parser(object):
    """Parser engine.

    The proper usage sequence is:

    p = Parser(grammar, [converter])  # create instance
    p.setup([start])                  # prepare for parsing
    <for each input token>:
        if p.addtoken(...):           # parse a token; may raise ParseError
            break
    root = p.rootnode                 # root of abstract syntax tree

    A Parser instance may be reused by calling setup() repeatedly.

    A Parser instance contains state pertaining to the current token
    sequence, and should not be used concurrently by different threads
    to parse separate token sequences.

    See driver.py for how to get input tokens by tokenizing a file or
    string.

    Parsing is complete when addtoken() returns True; the root of the
    abstract syntax tree can then be retrieved from the rootnode
    instance variable.  When a syntax error occurs, addtoken() raises
    the ParseError exception.  There is no error recovery; the parser
    cannot be used after a syntax error was reported (but it can be
    reinitialized by calling setup()).

    """

    def __init__(self, grammar, convert=None):
        """Constructor.

        The grammar argument is a grammar.Grammar instance; see the
        grammar module for more information.

        The parser is not ready yet for parsing; you must call the
        setup() method to get it started.

        The optional convert argument is a function mapping concrete
        syntax tree nodes to abstract syntax tree nodes.  If not
        given, no conversion is done and the syntax tree produced is
        the concrete syntax tree.  If given, it must be a function of
        two arguments, the first being the grammar (a grammar.Grammar
        instance), and the second being the concrete syntax tree node
        to be converted.  The syntax tree is converted from the bottom
        up.

        A concrete syntax tree node is a (type, value, context, nodes)
        tuple, where type is the node type (a token or symbol number),
        value is None for symbols and a string for tokens, context is
        None or an opaque value used for error reporting (typically a
        (lineno, offset) pair), and nodes is a list of children for
        symbols, and None for tokens.

        An abstract syntax tree node may be anything; this is entirely
        up to the converter function.

        """
        self.grammar = grammar
        self.convert = convert or (lambda grammar, node: node)

    def setup(self, start=None):
        """Prepare for parsing.

        This *must* be called before starting to parse.

        The optional argument is an alternative start symbol; it
        defaults to the grammar's start symbol.

        You can use a Parser instance to parse any number of programs;
        each time you call setup() the parser is reset to an initial
        state determined by the (implicit or explicit) start symbol.

        """
        if start is None:
            start = self.grammar.start
        # Each stack entry is a tuple: (dfa, state, node).
        # A node is a tuple: (type, value, context, children),
        # where children is a list of nodes or None, and context may be None.
        newnode = (start, None, None, [])
        stackentry = (self.grammar.dfas[start], 0, newnode)
        self.stack = [stackentry]
        self.rootnode = None
        self.used_names = set() # Aliased to self.rootnode.used_names in pop()

    def addtoken(self, type, value, context):
        """Add a token; return True iff this is the end of the program."""
        # Map from token to label
        ilabel = self.classify(type, value, context)
        # Loop until the token is shifted; may raise exceptions
        while True:
            dfa, state, node = self.stack[-1]
            states, first = dfa
            arcs = states[state]
            # Look for a state with this label
            for i, newstate in arcs:
                t, v = self.grammar.labels[i]
                if ilabel == i:
                    # Look it up in the list of labels
                    assert t < 256
                    # Shift a token; we're done with it
                    self.shift(type, value, newstate, context)
                    # Pop while we are in an accept-only state
                    state = newstate
                    while states[state] == [(0, state)]:
                        self.pop()
                        if not self.stack:
                            # Done parsing!
                            return True
                        dfa, state, node = self.stack[-1]
                        states, first = dfa
                    # Done with this token
                    return False
                elif t >= 256:
                    # See if it's a symbol and if we're in its first set
                    itsdfa = self.grammar.dfas[t]
                    itsstates, itsfirst = itsdfa
                    if ilabel in itsfirst:
                        # Push a symbol
                        self.push(t, self.grammar.dfas[t], newstate, context)
                        break # To continue the outer while loop
            else:
                if (0, state) in arcs:
                    # An accepting state, pop it and try something else
                    self.pop()
                    if not self.stack:
                        # Done parsing, but another token is input
                        raise ParseError("too much input",
                                         type, value, context)
                else:
                    # No success finding a transition
                    raise ParseError("bad input", type, value, context)

    def classify(self, type, value, context):
        """Turn a token into a label.  (Internal)"""
        if type == token.NAME:
            # Keep a listing of all used names
            self.used_names.add(value)
            # Check for reserved words
            ilabel = self.grammar.keywords.get(value)
            if ilabel is not None:
                return ilabel
        ilabel = self.grammar.tokens.get(type)
        if ilabel is None:
            raise ParseError("bad token", type, value, context)
        return ilabel

    def shift(self, type, value, newstate, context):
        """Shift a token.  (Internal)"""
        dfa, state, node = self.stack[-1]
        newnode = (type, value, context, None)
        newnode = self.convert(self.grammar, newnode)
        if newnode is not None:
            node[-1].append(newnode)
        self.stack[-1] = (dfa, newstate, node)

    def push(self, type, newdfa, newstate, context):
        """Push a nonterminal.  (Internal)"""
        dfa, state, node = self.stack[-1]
        newnode = (type, None, context, [])
        self.stack[-1] = (dfa, newstate, node)
        self.stack.append((newdfa, 0, newnode))

    def pop(self):
        """Pop a nonterminal.  (Internal)"""
        popdfa, popstate, popnode = self.stack.pop()
        newnode = self.convert(self.grammar, popnode)
        if newnode is not None:
            if self.stack:
                dfa, state, node = self.stack[-1]
                node[-1].append(newnode)
            else:
                self.rootnode = newnode
                self.rootnode.used_names = self.used_names
                                                                                                                                           Û
”´[c           @   sF   d  Z  d d l m Z d e f d Ñ  É  YZ d e f d Ñ  É  YZ d S(   s»   Parser engine for the grammar tables generated by pgen.

The grammar table must be loaded first.

See Parser/parser.c in the Python distribution for additional info on
how this parsing engine works.

i   (   t   tokent
   ParseErrorc           B   s   e  Z d  Z d Ñ  Z RS(   s(   Exception to signal the parser is stuck.c         C   sH   t  j |  d | | | | f É | |  _ | |  _ | |  _ | |  _ d  S(   Ns!   %s: type=%r, value=%r, context=%r(   t	   Exceptiont   __init__t   msgt   typet   valuet   context(   t   selfR   R   R   R   (    (    s)   /usr/lib/python2.7/lib2to3/pgen2/parse.pyR      s    			(   t   __name__t
   __module__t   __doc__R   (    (    (    s)   /usr/lib/python2.7/lib2to3/pgen2/parse.pyR      s   t   Parserc           B   sS   e  Z d  Z d d Ñ Z d d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 RS(	   s5  Parser engine.

    The proper usage sequence is:

    p = Parser(grammar, [converter])  # create instance
    p.setup([start])                  # prepare for parsing
    <for each input token>:
        if p.addtoken(...):           # parse a token; may raise ParseError
            break
    root = p.rootnode                 # root of abstract syntax tree

    A Parser instance may be reused by calling setup() repeatedly.

    A Parser instance contains state pertaining to the current token
    sequence, and should not be used concurrently by different threads
    to parse separate token sequences.

    See driver.py for how to get input tokens by tokenizing a file or
    string.

    Parsing is complete when addtoken() returns True; the root of the
    abstract syntax tree can then be retrieved from the rootnode
    instance variable.  When a syntax error occurs, addtoken() raises
    the ParseError exception.  There is no error recovery; the parser
    cannot be used after a syntax error was reported (but it can be
    reinitialized by calling setup()).

    c         C   s   | |  _  | p d Ñ  |  _ d S(   s⁄  Constructor.

        The grammar argument is a grammar.Grammar instance; see the
        grammar module for more information.

        The parser is not ready yet for parsing; you must call the
        setup() method to get it started.

        The optional convert argument is a function mapping concrete
        syntax tree nodes to abstract syntax tree nodes.  If not
        given, no conversion is done and the syntax tree produced is
        the concrete syntax tree.  If given, it must be a function of
        two arguments, the first being the grammar (a grammar.Grammar
        instance), and the second being the concrete syntax tree node
        to be converted.  The syntax tree is converted from the bottom
        up.

        A concrete syntax tree node is a (type, value, context, nodes)
        tuple, where type is the node type (a token or symbol number),
        value is None for symbols and a string for tokens, context is
        None or an opaque value used for error reporting (typically a
        (lineno, offset) pair), and nodes is a list of children for
        symbols, and None for tokens.

        An abstract syntax tree node may be anything; this is entirely
        up to the converter function.

        c         S   s   | S(   N(    (   t   grammart   node(    (    s)   /usr/lib/python2.7/lib2to3/pgen2/parse.pyt   <lambda>W   s    N(   R   t   convert(   R   R   R   (    (    s)   /usr/lib/python2.7/lib2to3/pgen2/parse.pyR   9   s    	c         C   sk   | d k r |  j j } n  | d d g  f } |  j j | d | f } | g |  _ d |  _ t É  |  _ d S(   sõ  Prepare for parsing.

        This *must* be called before starting to parse.

        The optional argument is an alternative start symbol; it
        defaults to the grammar's start symbol.

        You can use a Parser instance to parse any number of programs;
        each time you call setup() the parser is reset to an initial
        state determined by the (implicit or explicit) start symbol.

        i    N(   t   NoneR   t   startt   dfast   stackt   rootnodet   sett
   used_names(   R   R   t   newnodet
   stackentry(    (    s)   /usr/lib/python2.7/lib2to3/pgen2/parse.pyt   setupY   s    	c         C   s∆  |  j  | | | É } x™t r¡|  j d \ } } } | \ } }	 | | }
 xq|
 D]\ } } |  j j | \ } } | | k r
| d k  së t Ç |  j | | | | É | } xV | | d | f g k r|  j É  |  j s‡ t S|  j d \ } } } | \ } }	 q∞ Wt S| d k rQ |  j j	 | } | \ } } | | k re|  j
 | |  j j	 | | | É PqeqQ qQ Wd | f |
 k r©|  j É  |  j sæt d | | | É Ç qæq t d | | | É Ç q Wd S(   s<   Add a token; return True iff this is the end of the program.iˇˇˇˇi   i    s   too much inputs	   bad inputN(   t   classifyt   TrueR   R   t   labelst   AssertionErrort   shiftt   popt   FalseR   t   pushR   (   R   R   R   R   t   ilabelt   dfat   stateR   t   statest   firstt   arcst   it   newstatet   tt   vt   itsdfat	   itsstatest   itsfirst(    (    s)   /usr/lib/python2.7/lib2to3/pgen2/parse.pyt   addtokenq   s<    	

	 
	c         C   sÑ   | t  j k rG |  j j | É |  j j j | É } | d k	 rG | Sn  |  j j j | É } | d k rÄ t	 d | | | É Ç n  | S(   s&   Turn a token into a label.  (Internal)s	   bad tokenN(
   R    t   NAMER   t   addR   t   keywordst   getR   t   tokensR   (   R   R   R   R   R#   (    (    s)   /usr/lib/python2.7/lib2to3/pgen2/parse.pyR   °   s    c   	      C   sw   |  j  d \ } } } | | | d f } |  j |  j | É } | d k	 r] | d j | É n  | | | f |  j  d <d S(   s   Shift a token.  (Internal)iˇˇˇˇN(   R   R   R   R   t   append(	   R   R   R   R*   R   R$   R%   R   R   (    (    s)   /usr/lib/python2.7/lib2to3/pgen2/parse.pyR   Ø   s    c   	      C   s[   |  j  d \ } } } | d | g  f } | | | f |  j  d <|  j  j | d | f É d S(   s   Push a nonterminal.  (Internal)iˇˇˇˇi    N(   R   R   R6   (	   R   R   t   newdfaR*   R   R$   R%   R   R   (    (    s)   /usr/lib/python2.7/lib2to3/pgen2/parse.pyR"   ∏   s    c         C   sã   |  j  j É  \ } } } |  j |  j | É } | d k	 rá |  j  rl |  j  d \ } } } | d j | É qá | |  _ |  j |  j _ n  d S(   s   Pop a nonterminal.  (Internal)iˇˇˇˇN(   R   R    R   R   R   R6   R   R   (   R   t   popdfat   popstatet   popnodeR   R$   R%   R   (    (    s)   /usr/lib/python2.7/lib2to3/pgen2/parse.pyR    ø   s    		N(   R	   R
   R   R   R   R   R0   R   R   R"   R    (    (    (    s)   /usr/lib/python2.7/lib2to3/pgen2/parse.pyR      s    	0				N(   R   t    R    R   R   t   objectR   (    (    (    s)   /usr/lib/python2.7/lib2to3/pgen2/parse.pyt   <module>   s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Û
”´[c           @   s“  d  Z  d Z d Z d Z d Z d Z d Z d Z d Z d	 Z	 d
 Z
 d Z d Z d Z d Z d Z d Z d Z d Z d Z d Z d Z d Z d Z d Z d Z d Z d Z d Z d Z d Z d Z d  Z  d! Z! d" Z" d# Z# d$ Z$ d% Z% d& Z& d' Z' d( Z( d) Z) d* Z* d+ Z+ d, Z, d- Z- d. Z. d/ Z/ d0 Z0 d1 Z1 d2 Z2 d3 Z3 d4 Z4 d5 Z5 d6 Z6 d7 Z7 d8 Z8 d9 Z9 d: Z: d; Z; i  Z< xB e= É  j> É  D]1 \ Z? Z@ eA e@ É eA d É k r~e? e< e@ <q~q~Wd< Ñ  ZB d= Ñ  ZC d> Ñ  ZD d? S(@   s!   Token constants (from "token.h").i    i   i   i   i   i   i   i   i   i	   i
   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i    i!   i"   i#   i$   i%   i&   i'   i(   i)   i*   i+   i,   i-   i.   i/   i0   i1   i2   i3   i4   i5   i6   i7   i8   i9   i   c         C   s
   |  t  k  S(   N(   t	   NT_OFFSET(   t   x(    (    s)   /usr/lib/python2.7/lib2to3/pgen2/token.pyt
   ISTERMINALL   s    c         C   s
   |  t  k S(   N(   R    (   R   (    (    s)   /usr/lib/python2.7/lib2to3/pgen2/token.pyt   ISNONTERMINALO   s    c         C   s
   |  t  k S(   N(   t	   ENDMARKER(   R   (    (    s)   /usr/lib/python2.7/lib2to3/pgen2/token.pyt   ISEOFR   s    N(E   t   __doc__R   t   NAMEt   NUMBERt   STRINGt   NEWLINEt   INDENTt   DEDENTt   LPARt   RPARt   LSQBt   RSQBt   COLONt   COMMAt   SEMIt   PLUSt   MINUSt   STARt   SLASHt   VBARt   AMPERt   LESSt   GREATERt   EQUALt   DOTt   PERCENTt	   BACKQUOTEt   LBRACEt   RBRACEt   EQEQUALt   NOTEQUALt	   LESSEQUALt   GREATEREQUALt   TILDEt
   CIRCUMFLEXt	   LEFTSHIFTt
   RIGHTSHIFTt
   DOUBLESTARt	   PLUSEQUALt   MINEQUALt	   STAREQUALt
   SLASHEQUALt   PERCENTEQUALt
   AMPEREQUALt	   VBAREQUALt   CIRCUMFLEXEQUALt   LEFTSHIFTEQUALt   RIGHTSHIFTEQUALt   DOUBLESTAREQUALt   DOUBLESLASHt   DOUBLESLASHEQUALt   ATt   ATEQUALt   OPt   COMMENTt   NLt   RARROWt
   ERRORTOKENt   N_TOKENSR    t   tok_namet   globalst   itemst   _namet   _valuet   typeR   R   R   (    (    (    s)   /usr/lib/python2.7/lib2to3/pgen2/token.pyt   <module>   sÑ   		                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         #
# Analogue of `multiprocessing.connection` which uses queues instead of sockets
#
# multiprocessing/dummy/connection.py
#
# Copyright (c) 2006-2008, R Oudkerk
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 3. Neither the name of author nor the names of any contributors may be
#    used to endorse or promote products derived from this software
#    without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
#

__all__ = [ 'Client', 'Listener', 'Pipe' ]

from Queue import Queue


families = [None]


class Listener(object):

    def __init__(self, address=None, family=None, backlog=1):
        self._backlog_queue = Queue(backlog)

    def accept(self):
        return Connection(*self._backlog_queue.get())

    def close(self):
        self._backlog_queue = None

    address = property(lambda self: self._backlog_queue)


def Client(address):
    _in, _out = Queue(), Queue()
    address.put((_out, _in))
    return Connection(_in, _out)


def Pipe(duplex=True):
    a, b = Queue(), Queue()
    return Connection(a, b), Connection(b, a)


class Connection(object):

    def __init__(self, _in, _out):
        self._out = _out
        self._in = _in
        self.send = self.send_bytes = _out.put
        self.recv = self.recv_bytes = _in.get

    def poll(self, timeout=0.0):
        if self._in.qsize() > 0:
            return True
        if timeout <= 0.0:
            return False
        self._in.not_empty.acquire()
        self._in.not_empty.wait(timeout)
        self._in.not_empty.release()
        return self._in.qsize() > 0

    def close(self):
        pass
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         # Copyright 2004-2005 Elemental Security, Inc. All Rights Reserved.
# Licensed to PSF under a Contributor Agreement.

# Pgen imports
from . import grammar, token, tokenize

class PgenGrammar(grammar.Grammar):
    pass

class ParserGenerator(object):

    def __init__(self, filename, stream=None):
        close_stream = None
        if stream is None:
            stream = open(filename)
            close_stream = stream.close
        self.filename = filename
        self.stream = stream
        self.generator = tokenize.generate_tokens(stream.readline)
        self.gettoken() # Initialize lookahead
        self.dfas, self.startsymbol = self.parse()
        if close_stream is not None:
            close_stream()
        self.first = {} # map from symbol name to set of tokens
        self.addfirstsets()

    def make_grammar(self):
        c = PgenGrammar()
        names = self.dfas.keys()
        names.sort()
        names.remove(self.startsymbol)
        names.insert(0, self.startsymbol)
        for name in names:
            i = 256 + len(c.symbol2number)
            c.symbol2number[name] = i
            c.number2symbol[i] = name
        for name in names:
            dfa = self.dfas[name]
            states = []
            for state in dfa:
                arcs = []
                for label, next in sorted(state.arcs.iteritems()):
                    arcs.append((self.make_label(c, label), dfa.index(next)))
                if state.isfinal:
                    arcs.append((0, dfa.index(state)))
                states.append(arcs)
            c.states.append(states)
            c.dfas[c.symbol2number[name]] = (states, self.make_first(c, name))
        c.start = c.symbol2number[self.startsymbol]
        return c

    def make_first(self, c, name):
        rawfirst = self.first[name]
        first = {}
        for label in sorted(rawfirst):
            ilabel = self.make_label(c, label)
            ##assert ilabel not in first # XXX failed on <> ... !=
            first[ilabel] = 1
        return first

    def make_label(self, c, label):
        # XXX Maybe this should be a method on a subclass of converter?
        ilabel = len(c.labels)
        if label[0].isalpha():
            # Either a symbol name or a named token
            if label in c.symbol2number:
                # A symbol name (a non-terminal)
                if label in c.symbol2label:
                    return c.symbol2label[label]
                else:
                    c.labels.append((c.symbol2number[label], None))
                    c.symbol2label[label] = ilabel
                    return ilabel
            else:
                # A named token (NAME, NUMBER, STRING)
                itoken = getattr(token, label, None)
                assert isinstance(itoken, int), label
                assert itoken in token.tok_name, label
                if itoken in c.tokens:
                    return c.tokens[itoken]
                else:
                    c.labels.append((itoken, None))
                    c.tokens[itoken] = ilabel
                    return ilabel
        else:
            # Either a keyword or an operator
            assert label[0] in ('"', "'"), label
            value = eval(label)
            if value[0].isalpha():
                # A keyword
                if value in c.keywords:
                    return c.keywords[value]
                else:
                    c.labels.append((token.NAME, value))
                    c.keywords[value] = ilabel
                    return ilabel
            else:
                # An operator (any non-numeric token)
                itoken = grammar.opmap[value] # Fails if unknown token
                if itoken in c.tokens:
                    return c.tokens[itoken]
                else:
                    c.labels.append((itoken, None))
                    c.tokens[itoken] = ilabel
                    return ilabel

    def addfirstsets(self):
        names = self.dfas.keys()
        names.sort()
        for name in names:
            if name not in self.first:
                self.calcfirst(name)
            #print name, self.first[name].keys()

    def calcfirst(self, name):
        dfa = self.dfas[name]
        self.first[name] = None # dummy to detect left recursion
        state = dfa[0]
        totalset = {}
        overlapcheck = {}
        for label, next in state.arcs.iteritems():
            if label in self.dfas:
                if label in self.first:
                    fset = self.first[label]
                    if fset is None:
                        raise ValueError("recursion for rule %r" % name)
                else:
                    self.calcfirst(label)
                    fset = self.first[label]
                totalset.update(fset)
                overlapcheck[label] = fset
            else:
                totalset[label] = 1
                overlapcheck[label] = {label: 1}
        inverse = {}
        for label, itsfirst in overlapcheck.iteritems():
            for symbol in itsfirst:
                if symbol in inverse:
                    raise ValueError("rule %s is ambiguous; %s is in the"
                                     " first sets of %s as well as %s" %
                                     (name, symbol, label, inverse[symbol]))
                inverse[symbol] = label
        self.first[name] = totalset

    def parse(self):
        dfas = {}
        startsymbol = None
        # MSTART: (NEWLINE | RULE)* ENDMARKER
        while self.type != token.ENDMARKER:
            while self.type == token.NEWLINE:
                self.gettoken()
            # RULE: NAME ':' RHS NEWLINE
            name = self.expect(token.NAME)
            self.expect(token.OP, ":")
            a, z = self.parse_rhs()
            self.expect(token.NEWLINE)
            #self.dump_nfa(name, a, z)
            dfa = self.make_dfa(a, z)
            #self.dump_dfa(name, dfa)
            oldlen = len(dfa)
            self.simplify_dfa(dfa)
            newlen = len(dfa)
            dfas[name] = dfa
            #print name, oldlen, newlen
            if startsymbol is None:
                startsymbol = name
        return dfas, startsymbol

    def make_dfa(self, start, finish):
        # To turn an NFA into a DFA, we define the states of the DFA
        # to correspond to *sets* of states of the NFA.  Then do some
        # state reduction.  Let's represent sets as dicts with 1 for
        # values.
        assert isinstance(start, NFAState)
        assert isinstance(finish, NFAState)
        def closure(state):
            base = {}
            addclosure(state, base)
            return base
        def addclosure(state, base):
            assert isinstance(state, NFAState)
            if state in base:
                return
            base[state] = 1
            for label, next in state.arcs:
                if label is None:
                    addclosure(next, base)
        states = [DFAState(closure(start), finish)]
        for state in states: # NB states grows while we're iterating
            arcs = {}
            for nfastate in state.nfaset:
                for label, next in nfastate.arcs:
                    if label is not None:
                        addclosure(next, arcs.setdefault(label, {}))
            for label, nfaset in sorted(arcs.iteritems()):
                for st in states:
                    if st.nfaset == nfaset:
                        break
                else:
                    st = DFAState(nfaset, finish)
                    states.append(st)
                state.addarc(st, label)
        return states # List of DFAState instances; first one is start

    def dump_nfa(self, name, start, finish):
        print "Dump of NFA for", name
        todo = [start]
        for i, state in enumerate(todo):
            print "  State", i, state is finish and "(final)" or ""
            for label, next in state.arcs:
                if next in todo:
                    j = todo.index(next)
                else:
                    j = len(todo)
                    todo.append(next)
                if label is None:
                    print "    -> %d" % j
                else:
                    print "    %s -> %d" % (label, j)

    def dump_dfa(self, name, dfa):
        print "Dump of DFA for", name
        for i, state in enumerate(dfa):
            print "  State", i, state.isfinal and "(final)" or ""
            for label, next in sorted(state.arcs.iteritems()):
                print "    %s -> %d" % (label, dfa.index(next))

    def simplify_dfa(self, dfa):
        # This is not theoretically optimal, but works well enough.
        # Algorithm: repeatedly look for two states that have the same
        # set of arcs (same labels pointing to the same nodes) and
        # unify them, until things stop changing.

        # dfa is a list of DFAState instances
        changes = True
        while changes:
            changes = False
            for i, state_i in enumerate(dfa):
                for j in range(i+1, len(dfa)):
                    state_j = dfa[j]
                    if state_i == state_j:
                        #print "  unify", i, j
                        del dfa[j]
                        for state in dfa:
                            state.unifystate(state_j, state_i)
                        changes = True
                        break

    def parse_rhs(self):
        # RHS: ALT ('|' ALT)*
        a, z = self.parse_alt()
        if self.value != "|":
            return a, z
        else:
            aa = NFAState()
            zz = NFAState()
            aa.addarc(a)
            z.addarc(zz)
            while self.value == "|":
                self.gettoken()
                a, z = self.parse_alt()
                aa.addarc(a)
                z.addarc(zz)
            return aa, zz

    def parse_alt(self):
        # ALT: ITEM+
        a, b = self.parse_item()
        while (self.value in ("(", "[") or
               self.type in (token.NAME, token.STRING)):
            c, d = self.parse_item()
            b.addarc(c)
            b = d
        return a, b

    def parse_item(self):
        # ITEM: '[' RHS ']' | ATOM ['+' | '*']
        if self.value == "[":
            self.gettoken()
            a, z = self.parse_rhs()
            self.expect(token.OP, "]")
            a.addarc(z)
            return a, z
        else:
            a, z = self.parse_atom()
            value = self.value
            if value not in ("+", "*"):
                return a, z
            self.gettoken()
            z.addarc(a)
            if value == "+":
                return a, z
            else:
                return a, a

    def parse_atom(self):
        # ATOM: '(' RHS ')' | NAME | STRING
        if self.value == "(":
            self.gettoken()
            a, z = self.parse_rhs()
            self.expect(token.OP, ")")
            return a, z
        elif self.type in (token.NAME, token.STRING):
            a = NFAState()
            z = NFAState()
            a.addarc(z, self.value)
            self.gettoken()
            return a, z
        else:
            self.raise_error("expected (...) or NAME or STRING, got %s/%s",
                             self.type, self.value)

    def expect(self, type, value=None):
        if self.type != type or (value is not None and self.value != value):
            self.raise_error("expected %s/%s, got %s/%s",
                             type, value, self.type, self.value)
        value = self.value
        self.gettoken()
        return value

    def gettoken(self):
        tup = self.generator.next()
        while tup[0] in (tokenize.COMMENT, tokenize.NL):
            tup = self.generator.next()
        self.type, self.value, self.begin, self.end, self.line = tup
        #print token.tok_name[self.type], repr(self.value)

    def raise_error(self, msg, *args):
        if args:
            try:
                msg = msg % args
            except:
                msg = " ".join([msg] + map(str, args))
        raise SyntaxError(msg, (self.filename, self.end[0],
                                self.end[1], self.line))

class NFAState(object):

    def __init__(self):
        self.arcs = [] # list of (label, NFAState) pairs

    def addarc(self, next, label=None):
        assert label is None or isinstance(label, str)
        assert isinstance(next, NFAState)
        self.arcs.append((label, next))

class DFAState(object):

    def __init__(self, nfaset, final):
        assert isinstance(nfaset, dict)
        assert isinstance(iter(nfaset).next(), NFAState)
        assert isinstance(final, NFAState)
        self.nfaset = nfaset
        self.isfinal = final in nfaset
        self.arcs = {} # map from label to DFAState

    def addarc(self, next, label):
        assert isinstance(label, str)
        assert label not in self.arcs
        assert isinstance(next, DFAState)
        self.arcs[label] = next

    def unifystate(self, old, new):
        for label, next in self.arcs.iteritems():
            if next is old:
                self.arcs[label] = new

    def __eq__(self, other):
        # Equality test -- ignore the nfaset instance variable
        assert isinstance(other, DFAState)
        if self.isfinal != other.isfinal:
            return False
        # Can't just return self.arcs == other.arcs, because that
        # would invoke this method recursively, with cycles...
        if len(self.arcs) != len(other.arcs):
            return False
        for label, next in self.arcs.iteritems():
            if next is not other.arcs.get(label):
                return False
        return True

    __hash__ = None # For Py3 compatibility.

def generate_grammar(filename="Grammar.txt"):
    p = ParserGenerator(filename)
    return p.make_grammar()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      Û
”´[c           @   sá   d  d l  m Z m Z m Z d e j f d Ñ  É  YZ d e f d Ñ  É  YZ d e f d Ñ  É  YZ d e f d	 Ñ  É  YZ	 d
 d Ñ Z
 d S(   i   (   t   grammart   tokent   tokenizet   PgenGrammarc           B   s   e  Z RS(    (   t   __name__t
   __module__(    (    (    s(   /usr/lib/python2.7/lib2to3/pgen2/pgen.pyR      s   t   ParserGeneratorc           B   s∞   e  Z d d  Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d Ñ  Z d	 Ñ  Z d
 Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d d Ñ Z d Ñ  Z d Ñ  Z RS(   c         C   s†   d  } | d  k r* t | É } | j } n  | |  _ | |  _ t j | j É |  _ |  j	 É  |  j
 É  \ |  _ |  _ | d  k	 râ | É  n  i  |  _ |  j É  d  S(   N(   t   Nonet   opent   closet   filenamet   streamR   t   generate_tokenst   readlinet	   generatort   gettokent   parset   dfast   startsymbolt   firstt   addfirstsets(   t   selfR
   R   t   close_stream(    (    s(   /usr/lib/python2.7/lib2to3/pgen2/pgen.pyt   __init__   s    		

	c         C   sé  t  É  } |  j j É  } | j É  | j |  j É | j d |  j É x; | D]3 } d t | j É } | | j | <| | j	 | <qL WxÒ | D]È } |  j | } g  } xó | D]è } g  } xK t
 | j j É  É D]4 \ }	 }
 | j |  j | |	 É | j |
 É f É qÃ W| j r,| j d | j | É f É n  | j | É q™ W| j j | É | |  j | | É f | j | j | <qä W| j |  j | _ | S(   Ni    i   (   R   R   t   keyst   sortt   removeR   t   insertt   lent   symbol2numbert   number2symbolt   sortedt   arcst	   iteritemst   appendt
   make_labelt   indext   isfinalt   statest
   make_firstt   start(   R   t   ct   namest   namet   it   dfaR&   t   stateR    t   labelt   next(    (    s(   /usr/lib/python2.7/lib2to3/pgen2/pgen.pyt   make_grammar   s.    	
",	*c         C   sJ   |  j  | } i  } x0 t | É D]" } |  j | | É } d | | <q  W| S(   Ni   (   R   R   R#   (   R   R)   R+   t   rawfirstR   R/   t   ilabel(    (    s(   /usr/lib/python2.7/lib2to3/pgen2/pgen.pyR'   4   s    c         C   s÷  t  | j É } | d j É  r| | j k ry | | j k rH | j | S| j j | j | d  f É | | j | <| Sq“t t | d  É } t	 | t
 É s¶ t | É Ç | t j k s¡ t | É Ç | | j k r€ | j | S| j j | d  f É | | j | <| SnÕ | d d k s!t | É Ç t | É } | d j É  rÑ| | j k rW| j | S| j j t j | f É | | j | <| SnN t j | } | | j k r´| j | S| j j | d  f É | | j | <| Sd  S(   Ni    t   "t   '(   R4   R5   (   R   t   labelst   isalphaR   t   symbol2labelR"   R   t   getattrR   t
   isinstancet   intt   AssertionErrort   tok_namet   tokenst   evalt   keywordst   NAMER    t   opmap(   R   R)   R/   R3   t   itokent   value(    (    s(   /usr/lib/python2.7/lib2to3/pgen2/pgen.pyR#   =   s<    c         C   sM   |  j  j É  } | j É  x- | D]% } | |  j k r  |  j | É q  q  Wd  S(   N(   R   R   R   R   t	   calcfirst(   R   R*   R+   (    (    s(   /usr/lib/python2.7/lib2to3/pgen2/pgen.pyR   k   s
    
c      	   C   sj  |  j  | } d  |  j | <| d } i  } i  } xπ | j j É  D]® \ } } | |  j  k rÕ | |  j k rô |  j | } | d  k r≥ t d | É Ç q≥ n |  j | É |  j | } | j | É | | | <q@ d | | <i d | 6| | <q@ Wi  }	 xd | j É  D]V \ } }
 xG |
 D]? } | |	 k rGt d | | | |	 | f É Ç n  | |	 | <qWqˇ W| |  j | <d  S(   Ni    s   recursion for rule %ri   sA   rule %s is ambiguous; %s is in the first sets of %s as well as %s(   R   R   R   R    R!   t
   ValueErrorRE   t   update(   R   R+   R-   R.   t   totalsett   overlapcheckR/   R0   t   fsett   inverset   itsfirstt   symbol(    (    s(   /usr/lib/python2.7/lib2to3/pgen2/pgen.pyRE   s   s2    

c   	      C   sÔ   i  } d  } x÷ |  j t j k r‰ x  |  j t j k rC |  j É  q$ W|  j t j É } |  j t j d É |  j	 É  \ } } |  j t j É |  j
 | | É } t | É } |  j | É t | É } | | | <| d  k r | } q q W| | f S(   Nt   :(   R   t   typeR   t	   ENDMARKERt   NEWLINER   t   expectRA   t   OPt	   parse_rhst   make_dfaR   t   simplify_dfa(	   R   R   R   R+   t   at   zR-   t   oldlent   newlen(    (    s(   /usr/lib/python2.7/lib2to3/pgen2/pgen.pyR   ë   s"    
c            sD  t  | t É s t Ç t  | t É s* t Ç á  f d Ü  } á  f d Ü  â  t | | É | É g } x› | D]’ } i  } xS | j D]H } x? | j D]4 \ } }	 | d  k	 rç à  |	 | j | i  É É qç qç Wq} Wxp t | j	 É  É D]\ \ } }
 x= | D] } | j |
 k rÔ PqÔ qÔ Wt |
 | É } | j
 | É | j | | É q‹ Wqg W| S(   Nc            s   i  } à  |  | É | S(   N(    (   R.   t   base(   t
   addclosure(    s(   /usr/lib/python2.7/lib2to3/pgen2/pgen.pyt   closure∞   s    c            si   t  |  t É s t Ç |  | k r% d  Sd | |  <x3 |  j D]( \ } } | d  k r9 à  | | É q9 q9 Wd  S(   Ni   (   R:   t   NFAStateR<   R    R   (   R.   R[   R/   R0   (   R\   (    s(   /usr/lib/python2.7/lib2to3/pgen2/pgen.pyR\   ¥   s    
(   R:   R^   R<   t   DFAStatet   nfasetR    R   t
   setdefaultR   R!   R"   t   addarc(   R   R(   t   finishR]   R&   R.   R    t   nfastateR/   R0   R`   t   st(    (   R\   s(   /usr/lib/python2.7/lib2to3/pgen2/pgen.pyRU   ©   s&    $c   
      C   s    d G| GH| g } x± t  | É D]£ \ } } d G| G| | k rE d pH d GHxu | j D]j \ } } | | k r~ | j | É }	 n t | É }	 | j | É | d  k rØ d |	 GHqT d | |	 f GHqT Wq Wd  S(   Ns   Dump of NFA fors     States   (final)t    s	       -> %ds       %s -> %d(   t	   enumerateR    R$   R   R"   R   (
   R   R+   R(   Rc   t   todoR,   R.   R/   R0   t   j(    (    s(   /usr/lib/python2.7/lib2to3/pgen2/pgen.pyt   dump_nfaÕ   s    		c         C   sÑ   d G| GHxt t  | É D]f \ } } d G| G| j r9 d p< d GHx; t | j j É  É D]$ \ } } d | | j | É f GHqT Wq Wd  S(   Ns   Dump of DFA fors     States   (final)Rf   s       %s -> %d(   Rg   R%   R   R    R!   R$   (   R   R+   R-   R,   R.   R/   R0   (    (    s(   /usr/lib/python2.7/lib2to3/pgen2/pgen.pyt   dump_dfa›   s
    	"c         C   s¶   t  } xô | r° t } xÜ t | É D]x \ } } xi t | d t | É É D]N } | | } | | k rH | | =x | D] } | j | | É qr Wt  } PqH qH Wq" Wq	 Wd  S(   Ni   (   t   Truet   FalseRg   t   rangeR   t
   unifystate(   R   R-   t   changesR,   t   state_iRi   t   state_jR.   (    (    s(   /usr/lib/python2.7/lib2to3/pgen2/pgen.pyRV   ‰   s    	 
c         C   s±   |  j  É  \ } } |  j d k r+ | | f St É  } t É  } | j | É | j | É xI |  j d k r¢ |  j É  |  j  É  \ } } | j | É | j | É qZ W| | f Sd  S(   Nt   |(   t	   parse_altRD   R^   Rb   R   (   R   RW   RX   t   aat   zz(    (    s(   /usr/lib/python2.7/lib2to3/pgen2/pgen.pyRT   ˘   s    
		
c         C   sr   |  j  É  \ } } xS |  j d k s? |  j t j t j f k rg |  j  É  \ } } | j | É | } q W| | f S(   Nt   (t   [(   Rw   Rx   (   t
   parse_itemRD   RO   R   RA   t   STRINGRb   (   R   RW   t   bR)   t   d(    (    s(   /usr/lib/python2.7/lib2to3/pgen2/pgen.pyRt   
  s    
c         C   s¡   |  j  d k rU |  j É  |  j É  \ } } |  j t j d É | j | É | | f S|  j É  \ } } |  j  } | d k rÜ | | f S|  j É  | j | É | d k r≥ | | f S| | f Sd  S(   NRx   t   ]t   +t   *(   R~   R   (   RD   R   RT   RR   R   RS   Rb   t
   parse_atom(   R   RW   RX   RD   (    (    s(   /usr/lib/python2.7/lib2to3/pgen2/pgen.pyRy     s    

	


c         C   sπ   |  j  d k rH |  j É  |  j É  \ } } |  j t j d É | | f S|  j t j t j f k rú t	 É  } t	 É  } | j
 | |  j  É |  j É  | | f S|  j d |  j |  j  É d  S(   NRw   t   )s+   expected (...) or NAME or STRING, got %s/%s(   RD   R   RT   RR   R   RS   RO   RA   Rz   R^   Rb   t   raise_error(   R   RW   RX   (    (    s(   /usr/lib/python2.7/lib2to3/pgen2/pgen.pyRÄ   (  s    

		

	c         C   sc   |  j  | k s* | d  k	 rL |  j | k rL |  j d | | |  j  |  j É n  |  j } |  j É  | S(   Ns   expected %s/%s, got %s/%s(   RO   R   RD   RÇ   R   (   R   RO   RD   (    (    s(   /usr/lib/python2.7/lib2to3/pgen2/pgen.pyRR   9  s    *		
c         C   si   |  j  j É  } x/ | d t j t j f k r@ |  j  j É  } q W| \ |  _ |  _ |  _ |  _ |  _	 d  S(   Ni    (
   R   R0   R   t   COMMENTt   NLRO   RD   t   begint   endt   line(   R   t   tup(    (    s(   /usr/lib/python2.7/lib2to3/pgen2/pgen.pyR   A  s    c         G   ss   | r@ y | | } Wq@ d j  | g t t | É É } q@ Xn  t | |  j |  j d |  j d |  j f É Ç d  S(   Nt    i    i   (   t   joint   mapt   strt   SyntaxErrorR
   RÜ   Rá   (   R   t   msgt   args(    (    s(   /usr/lib/python2.7/lib2to3/pgen2/pgen.pyRÇ   H  s    &N(   R   R   R   R   R1   R'   R#   R   RE   R   RU   Rj   Rk   RV   RT   Rt   Ry   RÄ   RR   R   RÇ   (    (    (    s(   /usr/lib/python2.7/lib2to3/pgen2/pgen.pyR   
   s$   				.				$					
			R^   c           B   s   e  Z d  Ñ  Z d d Ñ Z RS(   c         C   s   g  |  _  d  S(   N(   R    (   R   (    (    s(   /usr/lib/python2.7/lib2to3/pgen2/pgen.pyR   S  s    c         C   sP   | d  k s! t | t É s! t Ç t | t É s6 t Ç |  j j | | f É d  S(   N(   R   R:   Rå   R<   R^   R    R"   (   R   R0   R/   (    (    s(   /usr/lib/python2.7/lib2to3/pgen2/pgen.pyRb   V  s    !N(   R   R   R   R   Rb   (    (    (    s(   /usr/lib/python2.7/lib2to3/pgen2/pgen.pyR^   Q  s   	R_   c           B   s2   e  Z d  Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Z RS(   c         C   sp   t  | t É s t Ç t  t | É j É  t É s6 t Ç t  | t É sK t Ç | |  _ | | k |  _ i  |  _ d  S(   N(	   R:   t   dictR<   t   iterR0   R^   R`   R%   R    (   R   R`   t   final(    (    s(   /usr/lib/python2.7/lib2to3/pgen2/pgen.pyR   ]  s    !	c         C   sP   t  | t É s t Ç | |  j k s* t Ç t  | t É s? t Ç | |  j | <d  S(   N(   R:   Rå   R<   R    R_   (   R   R0   R/   (    (    s(   /usr/lib/python2.7/lib2to3/pgen2/pgen.pyRb   e  s    c         C   s@   x9 |  j  j É  D]( \ } } | | k r | |  j  | <q q Wd  S(   N(   R    R!   (   R   t   oldt   newR/   R0   (    (    s(   /usr/lib/python2.7/lib2to3/pgen2/pgen.pyRo   k  s    c         C   sç   t  | t É s t Ç |  j | j k r+ t St |  j É t | j É k rM t Sx9 |  j j É  D]( \ } } | | j j | É k	 r] t Sq] Wt	 S(   N(
   R:   R_   R<   R%   Rm   R   R    R!   t   getRl   (   R   t   otherR/   R0   (    (    s(   /usr/lib/python2.7/lib2to3/pgen2/pgen.pyt   __eq__p  s    N(   R   R   R   Rb   Ro   Ró   R   t   __hash__(    (    (    s(   /usr/lib/python2.7/lib2to3/pgen2/pgen.pyR_   [  s
   				s   Grammar.txtc         C   s   t  |  É } | j É  S(   N(   R   R1   (   R
   t   p(    (    s(   /usr/lib/python2.7/lib2to3/pgen2/pgen.pyt   generate_grammarÄ  s    N(   Rf   R    R   R   t   GrammarR   t   objectR   R^   R_   Rö   (    (    (    s(   /usr/lib/python2.7/lib2to3/pgen2/pgen.pyt   <module>   s   ˇ H
%                                                                                                                                 #! /usr/bin/python2.7

"""Token constants (from "token.h")."""

#  Taken from Python (r53757) and modified to include some tokens
#   originally monkeypatched in by pgen2.tokenize

#--start constants--
ENDMARKER = 0
NAME = 1
NUMBER = 2
STRING = 3
NEWLINE = 4
INDENT = 5
DEDENT = 6
LPAR = 7
RPAR = 8
LSQB = 9
RSQB = 10
COLON = 11
COMMA = 12
SEMI = 13
PLUS = 14
MINUS = 15
STAR = 16
SLASH = 17
VBAR = 18
AMPER = 19
LESS = 20
GREATER = 21
EQUAL = 22
DOT = 23
PERCENT = 24
BACKQUOTE = 25
LBRACE = 26
RBRACE = 27
EQEQUAL = 28
NOTEQUAL = 29
LESSEQUAL = 30
GREATEREQUAL = 31
TILDE = 32
CIRCUMFLEX = 33
LEFTSHIFT = 34
RIGHTSHIFT = 35
DOUBLESTAR = 36
PLUSEQUAL = 37
MINEQUAL = 38
STAREQUAL = 39
SLASHEQUAL = 40
PERCENTEQUAL = 41
AMPEREQUAL = 42
VBAREQUAL = 43
CIRCUMFLEXEQUAL = 44
LEFTSHIFTEQUAL = 45
RIGHTSHIFTEQUAL = 46
DOUBLESTAREQUAL = 47
DOUBLESLASH = 48
DOUBLESLASHEQUAL = 49
AT = 50
ATEQUAL = 51
OP = 52
COMMENT = 53
NL = 54
RARROW = 55
ERRORTOKEN = 56
N_TOKENS = 57
NT_OFFSET = 256
#--end constants--

tok_name = {}
for _name, _value in globals().items():
    if type(_value) is type(0):
        tok_name[_value] = _name


def ISTERMINAL(x):
    return x < NT_OFFSET

def ISNONTERMINAL(x):
    return x >= NT_OFFSET

def ISEOF(x):
    return x == ENDMARKER
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # Copyright (c) 2001, 2002, 2003, 2004, 2005, 2006 Python Software Foundation.
# All rights reserved.

"""Tokenization help for Python programs.

generate_tokens(readline) is a generator that breaks a stream of
text into Python tokens.  It accepts a readline-like method which is called
repeatedly to get the next line of input (or "" for EOF).  It generates
5-tuples with these members:

    the token type (see token.py)
    the token (a string)
    the starting (row, column) indices of the token (a 2-tuple of ints)
    the ending (row, column) indices of the token (a 2-tuple of ints)
    the original line (string)

It is designed to match the working of the Python tokenizer exactly, except
that it produces COMMENT tokens for comments and gives type OP for all
operators

Older entry points
    tokenize_loop(readline, tokeneater)
    tokenize(readline, tokeneater=printtoken)
are the same, except instead of generating tokens, tokeneater is a callback
function to which the 5 fields described above are passed as 5 arguments,
each time a new token is found."""

__author__ = 'Ka-Ping Yee <ping@lfw.org>'
__credits__ = \
    'GvR, ESR, Tim Peters, Thomas Wouters, Fred Drake, Skip Montanaro'

import string, re
from codecs import BOM_UTF8, lookup
from lib2to3.pgen2.token import *

from . import token
__all__ = [x for x in dir(token) if x[0] != '_'] + ["tokenize",
           "generate_tokens", "untokenize"]
del token

try:
    bytes
except NameError:
    # Support bytes type in Python <= 2.5, so 2to3 turns itself into
    # valid Python 3 code.
    bytes = str

def group(*choices): return '(' + '|'.join(choices) + ')'
def any(*choices): return group(*choices) + '*'
def maybe(*choices): return group(*choices) + '?'

Whitespace = r'[ \f\t]*'
Comment = r'#[^\r\n]*'
Ignore = Whitespace + any(r'\\\r?\n' + Whitespace) + maybe(Comment)
Name = r'[a-zA-Z_]\w*'

Binnumber = r'0[bB][01]*'
Hexnumber = r'0[xX][\da-fA-F]*[lL]?'
Octnumber = r'0[oO]?[0-7]*[lL]?'
Decnumber = r'[1-9]\d*[lL]?'
Intnumber = group(Binnumber, Hexnumber, Octnumber, Decnumber)
Exponent = r'[eE][-+]?\d+'
Pointfloat = group(r'\d+\.\d*', r'\.\d+') + maybe(Exponent)
Expfloat = r'\d+' + Exponent
Floatnumber = group(Pointfloat, Expfloat)
Imagnumber = group(r'\d+[jJ]', Floatnumber + r'[jJ]')
Number = group(Imagnumber, Floatnumber, Intnumber)

# Tail end of ' string.
Single = r"[^'\\]*(?:\\.[^'\\]*)*'"
# Tail end of " string.
Double = r'[^"\\]*(?:\\.[^"\\]*)*"'
# Tail end of ''' string.
Single3 = r"[^'\\]*(?:(?:\\.|'(?!''))[^'\\]*)*'''"
# Tail end of """ string.
Double3 = r'[^"\\]*(?:(?:\\.|"(?!""))[^"\\]*)*"""'
Triple = group("[ubUB]?[rR]?'''", '[ubUB]?[rR]?"""')
# Single-line ' or " string.
String = group(r"[uU]?[rR]?'[^\n'\\]*(?:\\.[^\n'\\]*)*'",
               r'[uU]?[rR]?"[^\n"\\]*(?:\\.[^\n"\\]*)*"')

# Because of leftmost-then-longest match semantics, be sure to put the
# longest operators first (e.g., if = came before ==, == would get
# recognized as two instances of =).
Operator = group(r"\*\*=?", r">>=?", r"<<=?", r"<>", r"!=",
                 r"//=?", r"->",
                 r"[+\-*/%&@|^=<>]=?",
                 r"~")

Bracket = '[][(){}]'
Special = group(r'\r?\n', r'[:;.,`@]')
Funny = group(Operator, Bracket, Special)

PlainToken = group(Number, Funny, String, Name)
Token = Ignore + PlainToken

# First (or only) line of ' or " string.
ContStr = group(r"[uUbB]?[rR]?'[^\n'\\]*(?:\\.[^\n'\\]*)*" +
                group("'", r'\\\r?\n'),
                r'[uUbB]?[rR]?"[^\n"\\]*(?:\\.[^\n"\\]*)*' +
                group('"', r'\\\r?\n'))
PseudoExtras = group(r'\\\r?\n', Comment, Triple)
PseudoToken = Whitespace + group(PseudoExtras, Number, Funny, ContStr, Name)

tokenprog, pseudoprog, single3prog, double3prog = map(
    re.compile, (Token, PseudoToken, Single3, Double3))
endprogs = {"'": re.compile(Single), '"': re.compile(Double),
            "'''": single3prog, '"""': double3prog,
            "r'''": single3prog, 'r"""': double3prog,
            "u'''": single3prog, 'u"""': double3prog,
            "b'''": single3prog, 'b"""': double3prog,
            "ur'''": single3prog, 'ur"""': double3prog,
            "br'''": single3prog, 'br"""': double3prog,
            "R'''": single3prog, 'R"""': double3prog,
            "U'''": single3prog, 'U"""': double3prog,
            "B'''": single3prog, 'B"""': double3prog,
            "uR'''": single3prog, 'uR"""': double3prog,
            "Ur'''": single3prog, 'Ur"""': double3prog,
            "UR'''": single3prog, 'UR"""': double3prog,
            "bR'''": single3prog, 'bR"""': double3prog,
            "Br'''": single3prog, 'Br"""': double3prog,
            "BR'''": single3prog, 'BR"""': double3prog,
            'r': None, 'R': None,
            'u': None, 'U': None,
            'b': None, 'B': None}

triple_quoted = {}
for t in ("'''", '"""',
          "r'''", 'r"""', "R'''", 'R"""',
          "u'''", 'u"""', "U'''", 'U"""',
          "b'''", 'b"""', "B'''", 'B"""',
          "ur'''", 'ur"""', "Ur'''", 'Ur"""',
          "uR'''", 'uR"""', "UR'''", 'UR"""',
          "br'''", 'br"""', "Br'''", 'Br"""',
          "bR'''", 'bR"""', "BR'''", 'BR"""',):
    triple_quoted[t] = t
single_quoted = {}
for t in ("'", '"',
          "r'", 'r"', "R'", 'R"',
          "u'", 'u"', "U'", 'U"',
          "b'", 'b"', "B'", 'B"',
          "ur'", 'ur"', "Ur'", 'Ur"',
          "uR'", 'uR"', "UR'", 'UR"',
          "br'", 'br"', "Br'", 'Br"',
          "bR'", 'bR"', "BR'", 'BR"', ):
    single_quoted[t] = t

tabsize = 8

class TokenError(Exception): pass

class StopTokenizing(Exception): pass

def printtoken(type, token, start, end, line): # for testing
    (srow, scol) = start
    (erow, ecol) = end
    print "%d,%d-%d,%d:\t%s\t%s" % \
        (srow, scol, erow, ecol, tok_name[type], repr(token))

def tokenize(readline, tokeneater=printtoken):
    """
    The tokenize() function accepts two parameters: one representing the
    input stream, and one providing an output mechanism for tokenize().

    The first parameter, readline, must be a callable object which provides
    the same interface as the readline() method of built-in file objects.
    Each call to the function should return one line of input as a string.

    The second parameter, tokeneater, must also be a callable object. It is
    called once for each token, with five arguments, corresponding to the
    tuples generated by generate_tokens().
    """
    try:
        tokenize_loop(readline, tokeneater)
    except StopTokenizing:
        pass

# backwards compatible interface
def tokenize_loop(readline, tokeneater):
    for token_info in generate_tokens(readline):
        tokeneater(*token_info)

class Untokenizer:

    def __init__(self):
        self.tokens = []
        self.prev_row = 1
        self.prev_col = 0

    def add_whitespace(self, start):
        row, col = start
        assert row <= self.prev_row
        col_offset = col - self.prev_col
        if col_offset:
            self.tokens.append(" " * col_offset)

    def untokenize(self, iterable):
        for t in iterable:
            if len(t) == 2:
                self.compat(t, iterable)
                break
            tok_type, token, start, end, line = t
            self.add_whitespace(start)
            self.tokens.append(token)
            self.prev_row, self.prev_col = end
            if tok_type in (NEWLINE, NL):
                self.prev_row += 1
                self.prev_col = 0
        return "".join(self.tokens)

    def compat(self, token, iterable):
        startline = False
        indents = []
        toks_append = self.tokens.append
        toknum, tokval = token
        if toknum in (NAME, NUMBER):
            tokval += ' '
        if toknum in (NEWLINE, NL):
            startline = True
        for tok in iterable:
            toknum, tokval = tok[:2]

            if toknum in (NAME, NUMBER):
                tokval += ' '

            if toknum == INDENT:
                indents.append(tokval)
                continue
            elif toknum == DEDENT:
                indents.pop()
                continue
            elif toknum in (NEWLINE, NL):
                startline = True
            elif startline and indents:
                toks_append(indents[-1])
                startline = False
            toks_append(tokval)

cookie_re = re.compile(r'^[ \t\f]*#.*?coding[:=][ \t]*([-\w.]+)')
blank_re = re.compile(r'^[ \t\f]*(?:[#\r\n]|$)')

def _get_normal_name(orig_enc):
    """Imitates get_normal_name in tokenizer.c."""
    # Only care about the first 12 characters.
    enc = orig_enc[:12].lower().replace("_", "-")
    if enc == "utf-8" or enc.startswith("utf-8-"):
        return "utf-8"
    if enc in ("latin-1", "iso-8859-1", "iso-latin-1") or \
       enc.startswith(("latin-1-", "iso-8859-1-", "iso-latin-1-")):
        return "iso-8859-1"
    return orig_enc

def detect_encoding(readline):
    """
    The detect_encoding() function is used to detect the encoding that should
    be used to decode a Python source file. It requires one argument, readline,
    in the same way as the tokenize() generator.

    It will call readline a maximum of twice, and return the encoding used
    (as a string) and a list of any lines (left as bytes) it has read
    in.

    It detects the encoding from the presence of a utf-8 bom or an encoding
    cookie as specified in pep-0263. If both a bom and a cookie are present, but
    disagree, a SyntaxError will be raised. If the encoding cookie is an invalid
    charset, raise a SyntaxError.  Note that if a utf-8 bom is found,
    'utf-8-sig' is returned.

    If no encoding is specified, then the default of 'utf-8' will be returned.
    """
    bom_found = False
    encoding = None
    default = 'utf-8'
    def read_or_stop():
        try:
            return readline()
        except StopIteration:
            return bytes()

    def find_cookie(line):
        try:
            line_string = line.decode('ascii')
        except UnicodeDecodeError:
            return None
        match = cookie_re.match(line_string)
        if not match:
            return None
        encoding = _get_normal_name(match.group(1))
        try:
            codec = lookup(encoding)
        except LookupError:
            # This behaviour mimics the Python interpreter
            raise SyntaxError("unknown encoding: " + encoding)

        if bom_found:
            if codec.name != 'utf-8':
                # This behaviour mimics the Python interpreter
                raise SyntaxError('encoding problem: utf-8')
            encoding += '-sig'
        return encoding

    first = read_or_stop()
    if first.startswith(BOM_UTF8):
        bom_found = True
        first = first[3:]
        default = 'utf-8-sig'
    if not first:
        return default, []

    encoding = find_cookie(first)
    if encoding:
        return encoding, [first]
    if not blank_re.match(first):
        return default, [first]

    second = read_or_stop()
    if not second:
        return default, [first]

    encoding = find_cookie(second)
    if encoding:
        return encoding, [first, second]

    return default, [first, second]

def untokenize(iterable):
    """Transform tokens back into Python source code.

    Each element returned by the iterable must be a token sequence
    with at least two elements, a token number and token value.  If
    only two tokens are passed, the resulting output is poor.

    Round-trip invariant for full input:
        Untokenized source will match input source exactly

    Round-trip invariant for limited intput:
        # Output text will tokenize the back to the input
        t1 = [tok[:2] for tok in generate_tokens(f.readline)]
        newcode = untokenize(t1)
        readline = iter(newcode.splitlines(1)).next
        t2 = [tok[:2] for tokin generate_tokens(readline)]
        assert t1 == t2
    """
    ut = Untokenizer()
    return ut.untokenize(iterable)

def generate_tokens(readline):
    """
    The generate_tokens() generator requires one argument, readline, which
    must be a callable object which provides the same interface as the
    readline() method of built-in file objects. Each call to the function
    should return one line of input as a string.  Alternately, readline
    can be a callable function terminating with StopIteration:
        readline = open(myfile).next    # Example of alternate readline

    The generator produces 5-tuples with these members: the token type; the
    token string; a 2-tuple (srow, scol) of ints specifying the row and
    column where the token begins in the source; a 2-tuple (erow, ecol) of
    ints specifying the row and column where the token ends in the source;
    and the line on which the token was found. The line passed is the
    logical line; continuation lines are included.
    """
    lnum = parenlev = continued = 0
    namechars, numchars = string.ascii_letters + '_', '0123456789'
    contstr, needcont = '', 0
    contline = None
    indents = [0]

    while 1:                                   # loop over lines in stream
        try:
            line = readline()
        except StopIteration:
            line = ''
        lnum = lnum + 1
        pos, max = 0, len(line)

        if contstr:                            # continued string
            if not line:
                raise TokenError, ("EOF in multi-line string", strstart)
            endmatch = endprog.match(line)
            if endmatch:
                pos = end = endmatch.end(0)
                yield (STRING, contstr + line[:end],
                       strstart, (lnum, end), contline + line)
                contstr, needcont = '', 0
                contline = None
            elif needcont and line[-2:] != '\\\n' and line[-3:] != '\\\r\n':
                yield (ERRORTOKEN, contstr + line,
                           strstart, (lnum, len(line)), contline)
                contstr = ''
                contline = None
                continue
            else:
                contstr = contstr + line
                contline = contline + line
                continue

        elif parenlev == 0 and not continued:  # new statement
            if not line: break
            column = 0
            while pos < max:                   # measure leading whitespace
                if line[pos] == ' ': column = column + 1
                elif line[pos] == '\t': column = (column//tabsize + 1)*tabsize
                elif line[pos] == '\f': column = 0
                else: break
                pos = pos + 1
            if pos == max: break

            if line[pos] in '#\r\n':           # skip comments or blank lines
                if line[pos] == '#':
                    comment_token = line[pos:].rstrip('\r\n')
                    nl_pos = pos + len(comment_token)
                    yield (COMMENT, comment_token,
                           (lnum, pos), (lnum, pos + len(comment_token)), line)
                    yield (NL, line[nl_pos:],
                           (lnum, nl_pos), (lnum, len(line)), line)
                else:
                    yield ((NL, COMMENT)[line[pos] == '#'], line[pos:],
                           (lnum, pos), (lnum, len(line)), line)
                continue

            if column > indents[-1]:           # count indents or dedents
                indents.append(column)
                yield (INDENT, line[:pos], (lnum, 0), (lnum, pos), line)
            while column < indents[-1]:
                if column not in indents:
                    raise IndentationError(
                        "unindent does not match any outer indentation level",
                        ("<tokenize>", lnum, pos, line))
                indents = indents[:-1]
                yield (DEDENT, '', (lnum, pos), (lnum, pos), line)

        else:                                  # continued statement
            if not line:
                raise TokenError, ("EOF in multi-line statement", (lnum, 0))
            continued = 0

        while pos < max:
            pseudomatch = pseudoprog.match(line, pos)
            if pseudomatch:                                # scan for tokens
                start, end = pseudomatch.span(1)
                spos, epos, pos = (lnum, start), (lnum, end), end
                token, initial = line[start:end], line[start]

                if initial in numchars or \
                   (initial == '.' and token != '.'):      # ordinary number
                    yield (NUMBER, token, spos, epos, line)
                elif initial in '\r\n':
                    newline = NEWLINE
                    if parenlev > 0:
                        newline = NL
                    yield (newline, token, spos, epos, line)
                elif initial == '#':
                    assert not token.endswith("\n")
                    yield (COMMENT, token, spos, epos, line)
                elif token in triple_quoted:
                    endprog = endprogs[token]
                    endmatch = endprog.match(line, pos)
                    if endmatch:                           # all on one line
                        pos = endmatch.end(0)
                        token = line[start:pos]
                        yield (STRING, token, spos, (lnum, pos), line)
                    else:
                        strstart = (lnum, start)           # multiple lines
                        contstr = line[start:]
                        contline = line
                        break
                elif initial in single_quoted or \
                    token[:2] in single_quoted or \
                    token[:3] in single_quoted:
                    if token[-1] == '\n':                  # continued string
                        strstart = (lnum, start)
                        endprog = (endprogs[initial] or endprogs[token[1]] or
                                   endprogs[token[2]])
                        contstr, needcont = line[start:], 1
                        contline = line
                        break
                    else:                                  # ordinary string
                        yield (STRING, token, spos, epos, line)
                elif initial in namechars:                 # ordinary name
                    yield (NAME, token, spos, epos, line)
                elif initial == '\\':                      # continued stmt
                    # This yield is new; needed for better idempotency:
                    yield (NL, token, spos, (lnum, pos), line)
                    continued = 1
                else:
                    if initial in '([{': parenlev = parenlev + 1
                    elif initial in ')]}': parenlev = parenlev - 1
                    yield (OP, token, spos, epos, line)
            else:
                yield (ERRORTOKEN, line[pos],
                           (lnum, pos), (lnum, pos+1), line)
                pos = pos + 1

    for indent in indents[1:]:                 # pop remaining indent levels
        yield (DEDENT, '', (lnum, 0), (lnum, 0), '')
    yield (ENDMARKER, '', (lnum, 0), (lnum, 0), '')

if __name__ == '__main__':                     # testing
    import sys
    if len(sys.argv) > 1: tokenize(open(sys.argv[1]).readline)
    else: tokenize(sys.stdin.readline)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Û
”´[c           @   s  d  Z  d Z d Z d d l Z d d l Z d d l m Z m Z d d l Td d l	 m
 Z
 g  e e
 É D] Z e d	 d
 k rg e ^ qg d d d g Z [
 y e Wn e k
 r∫ e Z n Xd Ñ  Z d Ñ  Z d Ñ  Z d Z d Z e e d e É e e É Z d Z d Z d Z d Z d Z e e e e e É Z d Z e d d É e e É Z d e Z e e e É Z  e d e  d É Z! e e! e  e É Z" d Z# d  Z$ d! Z% d" Z& e d# d$ É Z' e d% d& É Z( e d' d( d) d* d+ d, d- d. d/ É	 Z) d0 Z* e d1 d2 É Z+ e e) e* e+ É Z, e e" e, e( e É Z- e e- Z. e d3 e d4 d É d5 e d6 d É É Z/ e d e e' É Z0 e e e0 e" e, e/ e É Z1 e2 e j3 e. e1 e% e& f É \ Z4 Z5 Z6 Z7 i& e j3 e# É d4 6e j3 e$ É d6 6e6 d7 6e7 d8 6e6 d9 6e7 d: 6e6 d; 6e7 d< 6e6 d= 6e7 d> 6e6 d? 6e7 d@ 6e6 dA 6e7 dB 6e6 dC 6e7 dD 6e6 dE 6e7 dF 6e6 dG 6e7 dH 6e6 dI 6e7 dJ 6e6 dK 6e7 dL 6e6 dM 6e7 dN 6e6 dO 6e7 dP 6e6 dQ 6e7 dR 6e6 dS 6e7 dT 6d dU 6d dV 6d dW 6d dX 6d dY 6d dZ 6Z9 i  Z: x dà D] Z; e; e: e; <q‡Wi  Z< x dâ D] Z; e; e< e; <qWdw Z= dx e> f dy Ñ  É  YZ? dz e> f d{ Ñ  É  YZ@ d| Ñ  ZA eA d} Ñ ZB d~ Ñ  ZC d dä dÄ Ñ  É  YZD e j3 dÅ É ZE e j3 dÇ É ZF dÉ Ñ  ZG dÑ Ñ  ZH dÖ Ñ  ZI dÜ Ñ  ZJ eK dá k rd d lL ZL eM eL jN É d k reB eO eL jN d É jP É qeB eL jQ jP É n  d S(ã   s¿  Tokenization help for Python programs.

generate_tokens(readline) is a generator that breaks a stream of
text into Python tokens.  It accepts a readline-like method which is called
repeatedly to get the next line of input (or "" for EOF).  It generates
5-tuples with these members:

    the token type (see token.py)
    the token (a string)
    the starting (row, column) indices of the token (a 2-tuple of ints)
    the ending (row, column) indices of the token (a 2-tuple of ints)
    the original line (string)

It is designed to match the working of the Python tokenizer exactly, except
that it produces COMMENT tokens for comments and gives type OP for all
operators

Older entry points
    tokenize_loop(readline, tokeneater)
    tokenize(readline, tokeneater=printtoken)
are the same, except instead of generating tokens, tokeneater is a callback
function to which the 5 fields described above are passed as 5 arguments,
each time a new token is found.s   Ka-Ping Yee <ping@lfw.org>s@   GvR, ESR, Tim Peters, Thomas Wouters, Fred Drake, Skip MontanaroiˇˇˇˇN(   t   BOM_UTF8t   lookup(   t   *i   (   t   tokeni    t   _t   tokenizet   generate_tokenst
   untokenizec          G   s   d d j  |  É d S(   Nt   (t   |t   )(   t   join(   t   choices(    (    s,   /usr/lib/python2.7/lib2to3/pgen2/tokenize.pyt   group0   s    c          G   s   t  |  å  d S(   NR   (   R   (   R   (    (    s,   /usr/lib/python2.7/lib2to3/pgen2/tokenize.pyt   any1   s    c          G   s   t  |  å  d S(   Nt   ?(   R   (   R   (    (    s,   /usr/lib/python2.7/lib2to3/pgen2/tokenize.pyt   maybe2   s    s   [ \f\t]*s	   #[^\r\n]*s   \\\r?\ns   [a-zA-Z_]\w*s
   0[bB][01]*s   0[xX][\da-fA-F]*[lL]?s   0[oO]?[0-7]*[lL]?s   [1-9]\d*[lL]?s   [eE][-+]?\d+s   \d+\.\d*s   \.\d+s   \d+s   \d+[jJ]s   [jJ]s   [^'\\]*(?:\\.[^'\\]*)*'s   [^"\\]*(?:\\.[^"\\]*)*"s%   [^'\\]*(?:(?:\\.|'(?!''))[^'\\]*)*'''s%   [^"\\]*(?:(?:\\.|"(?!""))[^"\\]*)*"""s   [ubUB]?[rR]?'''s   [ubUB]?[rR]?"""s&   [uU]?[rR]?'[^\n'\\]*(?:\\.[^\n'\\]*)*'s&   [uU]?[rR]?"[^\n"\\]*(?:\\.[^\n"\\]*)*"s   \*\*=?s   >>=?s   <<=?s   <>s   !=s   //=?s   ->s   [+\-*/%&@|^=<>]=?t   ~s   [][(){}]s   \r?\ns   [:;.,`@]s'   [uUbB]?[rR]?'[^\n'\\]*(?:\\.[^\n'\\]*)*t   's'   [uUbB]?[rR]?"[^\n"\\]*(?:\\.[^\n"\\]*)*t   "s   '''s   """s   r'''s   r"""s   u'''s   u"""s   b'''s   b"""s   ur'''s   ur"""s   br'''s   br"""s   R'''s   R"""s   U'''s   U"""s   B'''s   B"""s   uR'''s   uR"""s   Ur'''s   Ur"""s   UR'''s   UR"""s   bR'''s   bR"""s   Br'''s   Br"""s   BR'''s   BR"""t   rt   Rt   ut   Ut   bt   Bs   r's   r"s   R's   R"s   u's   u"s   U's   U"s   b's   b"s   B's   B"s   ur's   ur"s   Ur's   Ur"s   uR's   uR"s   UR's   UR"s   br's   br"s   Br's   Br"s   bR's   bR"s   BR's   BR"i   t
   TokenErrorc           B   s   e  Z RS(    (   t   __name__t
   __module__(    (    (    s,   /usr/lib/python2.7/lib2to3/pgen2/tokenize.pyR   ñ   s    t   StopTokenizingc           B   s   e  Z RS(    (   R   R   (    (    (    s,   /usr/lib/python2.7/lib2to3/pgen2/tokenize.pyR   ò   s    c   	      C   sA   | \ } } | \ } } d | | | | t  |  t | É f GHd  S(   Ns   %d,%d-%d,%d:	%s	%s(   t   tok_namet   repr(	   t   typeR   t   startt   endt   linet   srowt   scolt   erowt   ecol(    (    s,   /usr/lib/python2.7/lib2to3/pgen2/tokenize.pyt
   printtokenö   s    c         C   s)   y t  |  | É Wn t k
 r$ n Xd S(   s:  
    The tokenize() function accepts two parameters: one representing the
    input stream, and one providing an output mechanism for tokenize().

    The first parameter, readline, must be a callable object which provides
    the same interface as the readline() method of built-in file objects.
    Each call to the function should return one line of input as a string.

    The second parameter, tokeneater, must also be a callable object. It is
    called once for each token, with five arguments, corresponding to the
    tuples generated by generate_tokens().
    N(   t   tokenize_loopR   (   t   readlinet
   tokeneater(    (    s,   /usr/lib/python2.7/lib2to3/pgen2/tokenize.pyR   †   s    c         C   s%   x t  |  É D] } | | å  q Wd  S(   N(   R   (   R*   R+   t
   token_info(    (    s,   /usr/lib/python2.7/lib2to3/pgen2/tokenize.pyR)   ≥   s    t   Untokenizerc           B   s,   e  Z d  Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   c         C   s   g  |  _  d |  _ d |  _ d  S(   Ni   i    (   t   tokenst   prev_rowt   prev_col(   t   self(    (    s,   /usr/lib/python2.7/lib2to3/pgen2/tokenize.pyt   __init__π   s    		c         C   sO   | \ } } | |  j  k s! t Ç | |  j } | rK |  j j d | É n  d  S(   Nt    (   R/   t   AssertionErrorR0   R.   t   append(   R1   R!   t   rowt   colt
   col_offset(    (    s,   /usr/lib/python2.7/lib2to3/pgen2/tokenize.pyt   add_whitespaceæ   s
    c         C   s∏   x• | D]ù } t  | É d k r3 |  j | | É Pn  | \ } } } } } |  j | É |  j j | É | \ |  _ |  _ | t t f k r |  j d 7_ d |  _ q q Wd j	 |  j É S(   Ni   i   i    t    (
   t   lent   compatR9   R.   R5   R/   R0   t   NEWLINEt   NLR   (   R1   t   iterablet   tt   tok_typeR   R!   R"   R#   (    (    s,   /usr/lib/python2.7/lib2to3/pgen2/tokenize.pyR   ≈   s    c   	      C   s%  t  } g  } |  j j } | \ } } | t t f k rC | d 7} n  | t t f k r^ t } n  x¿ | D]∏ } | d  \ } } | t t f k rö | d 7} n  | t k rπ | j | É qe nZ | t	 k r’ | j
 É  qe n> | t t f k r t } n# | r| r| | d É t  } n  | | É qe Wd  S(   NR3   i   iˇˇˇˇ(   t   FalseR.   R5   t   NAMEt   NUMBERR=   R>   t   Truet   INDENTt   DEDENTt   pop(	   R1   R   R?   t	   startlinet   indentst   toks_appendt   toknumt   tokvalt   tok(    (    s,   /usr/lib/python2.7/lib2to3/pgen2/tokenize.pyR<   ”   s0    	
		(   R   R   R2   R9   R   R<   (    (    (    s,   /usr/lib/python2.7/lib2to3/pgen2/tokenize.pyR-   ∑   s   			s&   ^[ \t\f]*#.*?coding[:=][ \t]*([-\w.]+)s   ^[ \t\f]*(?:[#\r\n]|$)c         C   s^   |  d  j  É  j d d É } | d k s7 | j d É r; d S| d k sV | j d É rZ d S|  S(   s(   Imitates get_normal_name in tokenizer.c.i   R   t   -s   utf-8s   utf-8-s   latin-1s
   iso-8859-1s   iso-latin-1s   latin-1-s   iso-8859-1-s   iso-latin-1-(   s   latin-1s
   iso-8859-1s   iso-latin-1(   s   latin-1-s   iso-8859-1-s   iso-latin-1-(   t   lowert   replacet
   startswith(   t   orig_enct   enc(    (    s,   /usr/lib/python2.7/lib2to3/pgen2/tokenize.pyt   _get_normal_nameÚ   s    c            s˙   t  â  d } d } á f d Ü  } á  f d Ü  } | É  } | j t É ra t â  | d } d } n  | sq | g  f S| | É } | rê | | g f St j | É s¨ | | g f S| É  } | s» | | g f S| | É } | rÍ | | | g f S| | | g f S(   s  
    The detect_encoding() function is used to detect the encoding that should
    be used to decode a Python source file. It requires one argument, readline,
    in the same way as the tokenize() generator.

    It will call readline a maximum of twice, and return the encoding used
    (as a string) and a list of any lines (left as bytes) it has read
    in.

    It detects the encoding from the presence of a utf-8 bom or an encoding
    cookie as specified in pep-0263. If both a bom and a cookie are present, but
    disagree, a SyntaxError will be raised. If the encoding cookie is an invalid
    charset, raise a SyntaxError.  Note that if a utf-8 bom is found,
    'utf-8-sig' is returned.

    If no encoding is specified, then the default of 'utf-8' will be returned.
    s   utf-8c              s'   y à  É  SWn t  k
 r" t É  SXd  S(   N(   t   StopIterationt   bytes(    (   R*   (    s,   /usr/lib/python2.7/lib2to3/pgen2/tokenize.pyt   read_or_stop  s    c            sø   y |  j  d É } Wn t k
 r' d  SXt j | É } | sA d  St | j d É É } y t | É } Wn! t k
 râ t	 d | É Ç n Xà  rª | j
 d k rÆ t	 d É Ç n  | d 7} n  | S(   Nt   asciii   s   unknown encoding: s   utf-8s   encoding problem: utf-8s   -sig(   t   decodet   UnicodeDecodeErrort   Nonet	   cookie_ret   matchRU   R   R   t   LookupErrort   SyntaxErrort   name(   R#   t   line_stringR^   t   encodingt   codec(   t	   bom_found(    s,   /usr/lib/python2.7/lib2to3/pgen2/tokenize.pyt   find_cookie  s"    i   s	   utf-8-sigN(   RB   R\   RR   R    RE   t   blank_reR^   (   R*   Rc   t   defaultRX   Rf   t   firstt   second(    (   Re   R*   s,   /usr/lib/python2.7/lib2to3/pgen2/tokenize.pyt   detect_encoding˝   s0    	
	
	c         C   s   t  É  } | j |  É S(   s¨  Transform tokens back into Python source code.

    Each element returned by the iterable must be a token sequence
    with at least two elements, a token number and token value.  If
    only two tokens are passed, the resulting output is poor.

    Round-trip invariant for full input:
        Untokenized source will match input source exactly

    Round-trip invariant for limited intput:
        # Output text will tokenize the back to the input
        t1 = [tok[:2] for tok in generate_tokens(f.readline)]
        newcode = untokenize(t1)
        readline = iter(newcode.splitlines(1)).next
        t2 = [tok[:2] for tokin generate_tokens(readline)]
        assert t1 == t2
    (   R-   R   (   R?   t   ut(    (    s,   /usr/lib/python2.7/lib2to3/pgen2/tokenize.pyR   F  s    	c         c   sV  d } } } t  j d d } } d \ } } d } d g }	 xΩy |  É  }
 Wn t k
 rf d }
 n X| d } d t |
 É } } | r{|
 s¢ t d | f Ç n  | j |
 É } | r| j d É } } t | |
 |  | | | f | |
 f Vd \ } } d } q€| ra|
 d d k ra|
 d	 d
 k rat	 | |
 | | t |
 É f | f Vd } d } q@ q€| |
 } | |
 } q@ n`| d k r∑| r∑|
 sòPn  d } xv | | k  r|
 | d k r | d } n? |
 | d k rÔ| t
 d t
 } n |
 | d k rd } n P| d } q°W| | k r'Pn  |
 | d k r|
 | d k r¡|
 | j d É } | t | É } t | | | f | | t | É f |
 f Vt |
 | | | f | t |
 É f |
 f Vq@ t t f |
 | d k |
 | | | f | t |
 É f |
 f Vq@ n  | |	 d k rI|	 j | É t |
 |  | d f | | f |
 f Vn  xè | |	 d k  r≥| |	 k rÜt d d | | |
 f É Ç n  |	 d  }	 t d | | f | | f |
 f VqLWn$ |
 s’t d | d f f Ç n  d } x| | k  r¯t j |
 | É } | r√| j d É \ } } | | f | | f | } } } |
 | | !|
 | } } | | k ss| d k rä| d k rät | | | |
 f Vqı| d k r»t } | d k r±t } n  | | | | |
 f Vqı| d k r| j d É sÍt Ç t | | | |
 f Vqı| t k ràt | } | j |
 | É } | rh| j d É } |
 | | !} t | | | | f |
 f Vq¿| | f } |
 | } |
 } Pqı| t k s¥| d  t k s¥| d  t k r(| d d k r| | f } t | pÛt | d pÛt | d } |
 | d } } |
 } Pq¿t | | | |
 f Vqı| | k rKt | | | |
 f Vqı| d k rzt | | | | f |
 f Vd } qı| d k rì| d } n | d k r¨| d } n  t | | | |
 f Vqﬁt	 |
 | | | f | | d f |
 f V| d } qﬁWq@ Wx2 |	 d D]& } t d | d f | d f d f VqWt d | d f | d f d f Vd S(   sT  
    The generate_tokens() generator requires one argument, readline, which
    must be a callable object which provides the same interface as the
    readline() method of built-in file objects. Each call to the function
    should return one line of input as a string.  Alternately, readline
    can be a callable function terminating with StopIteration:
        readline = open(myfile).next    # Example of alternate readline

    The generator produces 5-tuples with these members: the token type; the
    token string; a 2-tuple (srow, scol) of ints specifying the row and
    column where the token begins in the source; a 2-tuple (erow, ecol) of
    ints specifying the row and column where the token ends in the source;
    and the line on which the token was found. The line passed is the
    logical line; continuation lines are included.
    i    R   t
   0123456789R:   i   s   EOF in multi-line stringi˛ˇˇˇs   \
i˝ˇˇˇs   \
R3   s   	s   s   #
t   #s   
iˇˇˇˇs3   unindent does not match any outer indentation levels
   <tokenize>s   EOF in multi-line statementt   .s   
i   i   s   \s   ([{s   )]}N(   R:   i    (   R:   i    (   t   stringt   ascii_lettersR\   RV   R;   R   R^   R"   t   STRINGt
   ERRORTOKENt   tabsizet   rstript   COMMENTR>   R5   RF   t   IndentationErrorRG   t
   pseudoprogt   spanRD   R=   t   endswithR4   t   triple_quotedt   endprogst   single_quotedRC   t   OPt	   ENDMARKER(   R*   t   lnumt   parenlevt	   continuedt	   namecharst   numcharst   contstrt   needcontt   contlineRJ   R#   t   post   maxt   strstartt   endprogt   endmatchR"   t   columnt   comment_tokent   nl_post   pseudomatchR!   t   spost   eposR   t   initialt   newlinet   indent(    (    s,   /usr/lib/python2.7/lib2to3/pgen2/tokenize.pyR   [  s˙    	

	&


    	 $
# '
' 	

	  
$t   __main__(   s   '''s   """s   r'''s   r"""s   R'''s   R"""s   u'''s   u"""s   U'''s   U"""s   b'''s   b"""s   B'''s   B"""s   ur'''s   ur"""s   Ur'''s   Ur"""s   uR'''s   uR"""s   UR'''s   UR"""s   br'''s   br"""s   Br'''s   Br"""s   bR'''s   bR"""s   BR'''s   BR"""(   R   R   s   r's   r"s   R's   R"s   u's   u"s   U's   U"s   b's   b"s   B's   B"s   ur's   ur"s   Ur's   Ur"s   uR's   uR"s   UR's   UR"s   br's   br"s   Br's   Br"s   bR's   bR"s   BR's   BR"(    (R   t   __doc__t
   __author__t   __credits__Rp   t   ret   codecsR    R   t   lib2to3.pgen2.tokenR:   R   t   dirt   xt   __all__RW   t	   NameErrort   strR   R   R   t
   Whitespacet   Commentt   Ignoret   Namet	   Binnumbert	   Hexnumbert	   Octnumbert	   Decnumbert	   Intnumbert   Exponentt
   Pointfloatt   Expfloatt   Floatnumbert
   Imagnumbert   Numbert   Singlet   Doublet   Single3t   Double3t   Triplet   Stringt   Operatort   Brackett   Specialt   Funnyt
   PlainTokent   Tokent   ContStrt   PseudoExtrast   PseudoTokent   mapt   compilet	   tokenprogRx   t   single3progt   double3progR\   R|   R{   R@   R}   Rt   t	   ExceptionR   R   R(   R   R)   R-   R]   Rg   RU   Rk   R   R   R   t   sysR;   t   argvt   openR*   t   stdin(    (    (    s,   /usr/lib/python2.7/lib2to3/pgen2/tokenize.pyt   <module>   s‡   
/
			
		
'#      
      
		8		I		ò                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              # Copyright 2001-2014 by Vinay Sajip. All Rights Reserved.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose and without fee is hereby granted,
# provided that the above copyright notice appear in all copies and that
# both that copyright notice and this permission notice appear in
# supporting documentation, and that the name of Vinay Sajip
# not be used in advertising or publicity pertaining to distribution
# of the software without specific, written prior permission.
# VINAY SAJIP DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
# ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL
# VINAY SAJIP BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
# ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

"""
Logging package for Python. Based on PEP 282 and comments thereto in
comp.lang.python.

Copyright (C) 2001-2014 Vinay Sajip. All Rights Reserved.

To use, simply 'import logging' and log away!
"""

import sys, os, time, cStringIO, traceback, warnings, weakref, collections

__all__ = ['BASIC_FORMAT', 'BufferingFormatter', 'CRITICAL', 'DEBUG', 'ERROR',
           'FATAL', 'FileHandler', 'Filter', 'Formatter', 'Handler', 'INFO',
           'LogRecord', 'Logger', 'LoggerAdapter', 'NOTSET', 'NullHandler',
           'StreamHandler', 'WARN', 'WARNING', 'addLevelName', 'basicConfig',
           'captureWarnings', 'critical', 'debug', 'disable', 'error',
           'exception', 'fatal', 'getLevelName', 'getLogger', 'getLoggerClass',
           'info', 'log', 'makeLogRecord', 'setLoggerClass', 'warn', 'warning']

try:
    import codecs
except ImportError:
    codecs = None

try:
    import thread
    import threading
except ImportError:
    thread = None

__author__  = "Vinay Sajip <vinay_sajip@red-dove.com>"
__status__  = "production"
# Note: the attributes below are no longer maintained.
__version__ = "0.5.1.2"
__date__    = "07 February 2010"

#---------------------------------------------------------------------------
#   Miscellaneous module data
#---------------------------------------------------------------------------
try:
    unicode
    _unicode = True
except NameError:
    _unicode = False

# next bit filched from 1.5.2's inspect.py
def currentframe():
    """Return the frame object for the caller's stack frame."""
    try:
        raise Exception
    except:
        return sys.exc_info()[2].tb_frame.f_back

if hasattr(sys, '_getframe'): currentframe = lambda: sys._getframe(3)
# done filching

#
# _srcfile is used when walking the stack to check when we've got the first
# caller stack frame.
#
_srcfile = os.path.normcase(currentframe.__code__.co_filename)

# _srcfile is only used in conjunction with sys._getframe().
# To provide compatibility with older versions of Python, set _srcfile
# to None if _getframe() is not available; this value will prevent
# findCaller() from being called.
#if not hasattr(sys, "_getframe"):
#    _srcfile = None

#
#_startTime is used as the base when calculating the relative time of events
#
_startTime = time.time()

#
#raiseExceptions is used to see if exceptions during handling should be
#propagated
#
raiseExceptions = 1

#
# If you don't want threading information in the log, set this to zero
#
logThreads = 1

#
# If you don't want multiprocessing information in the log, set this to zero
#
logMultiprocessing = 1

#
# If you don't want process information in the log, set this to zero
#
logProcesses = 1

#---------------------------------------------------------------------------
#   Level related stuff
#---------------------------------------------------------------------------
#
# Default levels and level names, these can be replaced with any positive set
# of values having corresponding names. There is a pseudo-level, NOTSET, which
# is only really there as a lower limit for user-defined levels. Handlers and
# loggers are initialized with NOTSET so that they will log all messages, even
# at user-defined levels.
#

CRITICAL = 50
FATAL = CRITICAL
ERROR = 40
WARNING = 30
WARN = WARNING
INFO = 20
DEBUG = 10
NOTSET = 0

_levelNames = {
    CRITICAL : 'CRITICAL',
    ERROR : 'ERROR',
    WARNING : 'WARNING',
    INFO : 'INFO',
    DEBUG : 'DEBUG',
    NOTSET : 'NOTSET',
    'CRITICAL' : CRITICAL,
    'ERROR' : ERROR,
    'WARN' : WARNING,
    'WARNING' : WARNING,
    'INFO' : INFO,
    'DEBUG' : DEBUG,
    'NOTSET' : NOTSET,
}

def getLevelName(level):
    """
    Return the textual representation of logging level 'level'.

    If the level is one of the predefined levels (CRITICAL, ERROR, WARNING,
    INFO, DEBUG) then you get the corresponding string. If you have
    associated levels with names using addLevelName then the name you have
    associated with 'level' is returned.

    If a numeric value corresponding to one of the defined levels is passed
    in, the corresponding string representation is returned.

    Otherwise, the string "Level %s" % level is returned.
    """
    return _levelNames.get(level, ("Level %s" % level))

def addLevelName(level, levelName):
    """
    Associate 'levelName' with 'level'.

    This is used when converting levels to text during message formatting.
    """
    _acquireLock()
    try:    #unlikely to cause an exception, but you never know...
        _levelNames[level] = levelName
        _levelNames[levelName] = level
    finally:
        _releaseLock()

def _checkLevel(level):
    if isinstance(level, (int, long)):
        rv = level
    elif str(level) == level:
        if level not in _levelNames:
            raise ValueError("Unknown level: %r" % level)
        rv = _levelNames[level]
    else:
        raise TypeError("Level not an integer or a valid string: %r" % level)
    return rv

#---------------------------------------------------------------------------
#   Thread-related stuff
#---------------------------------------------------------------------------

#
#_lock is used to serialize access to shared data structures in this module.
#This needs to be an RLock because fileConfig() creates and configures
#Handlers, and so might arbitrary user threads. Since Handler code updates the
#shared dictionary _handlers, it needs to acquire the lock. But if configuring,
#the lock would already have been acquired - so we need an RLock.
#The same argument applies to Loggers and Manager.loggerDict.
#
if thread:
    _lock = threading.RLock()
else:
    _lock = None

def _acquireLock():
    """
    Acquire the module-level lock for serializing access to shared data.

    This should be released with _releaseLock().
    """
    if _lock:
        _lock.acquire()

def _releaseLock():
    """
    Release the module-level lock acquired by calling _acquireLock().
    """
    if _lock:
        _lock.release()

#---------------------------------------------------------------------------
#   The logging record
#---------------------------------------------------------------------------

class LogRecord(object):
    """
    A LogRecord instance represents an event being logged.

    LogRecord instances are created every time something is logged. They
    contain all the information pertinent to the event being logged. The
    main information passed in is in msg and args, which are combined
    using str(msg) % args to create the message field of the record. The
    record also includes information such as when the record was created,
    the source line where the logging call was made, and any exception
    information to be logged.
    """
    def __init__(self, name, level, pathname, lineno,
                 msg, args, exc_info, func=None):
        """
        Initialize a logging record with interesting information.
        """
        ct = time.time()
        self.name = name
        self.msg = msg
        #
        # The following statement allows passing of a dictionary as a sole
        # argument, so that you can do something like
        #  logging.debug("a %(a)d b %(b)s", {'a':1, 'b':2})
        # Suggested by Stefan Behnel.
        # Note that without the test for args[0], we get a problem because
        # during formatting, we test to see if the arg is present using
        # 'if self.args:'. If the event being logged is e.g. 'Value is %d'
        # and if the passed arg fails 'if self.args:' then no formatting
        # is done. For example, logger.warn('Value is %d', 0) would log
        # 'Value is %d' instead of 'Value is 0'.
        # For the use case of passing a dictionary, this should not be a
        # problem.
        # Issue #21172: a request was made to relax the isinstance check
        # to hasattr(args[0], '__getitem__'). However, the docs on string
        # formatting still seem to suggest a mapping object is required.
        # Thus, while not removing the isinstance check, it does now look
        # for collections.Mapping rather than, as before, dict.
        if (args and len(args) == 1 and isinstance(args[0], collections.Mapping)
            and args[0]):
            args = args[0]
        self.args = args
        self.levelname = getLevelName(level)
        self.levelno = level
        self.pathname = pathname
        try:
            self.filename = os.path.basename(pathname)
            self.module = os.path.splitext(self.filename)[0]
        except (TypeError, ValueError, AttributeError):
            self.filename = pathname
            self.module = "Unknown module"
        self.exc_info = exc_info
        self.exc_text = None      # used to cache the traceback text
        self.lineno = lineno
        self.funcName = func
        self.created = ct
        self.msecs = (ct - long(ct)) * 1000
        self.relativeCreated = (self.created - _startTime) * 1000
        if logThreads and thread:
            self.thread = thread.get_ident()
            self.threadName = threading.current_thread().name
        else:
            self.thread = None
            self.threadName = None
        if not logMultiprocessing:
            self.processName = None
        else:
            self.processName = 'MainProcess'
            mp = sys.modules.get('multiprocessing')
            if mp is not None:
                # Errors may occur if multiprocessing has not finished loading
                # yet - e.g. if a custom import hook causes third-party code
                # to run when multiprocessing calls import. See issue 8200
                # for an example
                try:
                    self.processName = mp.current_process().name
                except StandardError:
                    pass
        if logProcesses and hasattr(os, 'getpid'):
            self.process = os.getpid()
        else:
            self.process = None

    def __str__(self):
        return '<LogRecord: %s, %s, %s, %s, "%s">'%(self.name, self.levelno,
            self.pathname, self.lineno, self.msg)

    def getMessage(self):
        """
        Return the message for this LogRecord.

        Return the message for this LogRecord after merging any user-supplied
        arguments with the message.
        """
        if not _unicode: #if no unicode support...
            msg = str(self.msg)
        else:
            msg = self.msg
            if not isinstance(msg, basestring):
                try:
                    msg = str(self.msg)
                except UnicodeError:
                    msg = self.msg      #Defer encoding till later
        if self.args:
            msg = msg % self.args
        return msg

def makeLogRecord(dict):
    """
    Make a LogRecord whose attributes are defined by the specified dictionary,
    This function is useful for converting a logging event received over
    a socket connection (which is sent as a dictionary) into a LogRecord
    instance.
    """
    rv = LogRecord(None, None, "", 0, "", (), None, None)
    rv.__dict__.update(dict)
    return rv

#---------------------------------------------------------------------------
#   Formatter classes and functions
#---------------------------------------------------------------------------

class Formatter(object):
    """
    Formatter instances are used to convert a LogRecord to text.

    Formatters need to know how a LogRecord is constructed. They are
    responsible for converting a LogRecord to (usually) a string which can
    be interpreted by either a human or an external system. The base Formatter
    allows a formatting string to be specified. If none is supplied, the
    default value of "%s(message)\\n" is used.

    The Formatter can be initialized with a format string which makes use of
    knowledge of the LogRecord attributes - e.g. the default value mentioned
    above makes use of the fact that the user's message and arguments are pre-
    formatted into a LogRecord's message attribute. Currently, the useful
    attributes in a LogRecord are described by:

    %(name)s            Name of the logger (logging channel)
    %(levelno)s         Numeric logging level for the message (DEBUG, INFO,
                        WARNING, ERROR, CRITICAL)
    %(levelname)s       Text logging level for the message ("DEBUG", "INFO",
                        "WARNING", "ERROR", "CRITICAL")
    %(pathname)s        Full pathname of the source file where the logging
                        call was issued (if available)
    %(filename)s        Filename portion of pathname
    %(module)s          Module (name portion of filename)
    %(lineno)d          Source line number where the logging call was issued
                        (if available)
    %(funcName)s        Function name
    %(created)f         Time when the LogRecord was created (time.time()
                        return value)
    %(asctime)s         Textual time when the LogRecord was created
    %(msecs)d           Millisecond portion of the creation time
    %(relativeCreated)d Time in milliseconds when the LogRecord was created,
                        relative to the time the logging module was loaded
                        (typically at application startup time)
    %(thread)d          Thread ID (if available)
    %(threadName)s      Thread name (if available)
    %(process)d         Process ID (if available)
    %(message)s         The result of record.getMessage(), computed just as
                        the record is emitted
    """

    converter = time.localtime

    def __init__(self, fmt=None, datefmt=None):
        """
        Initialize the formatter with specified format strings.

        Initialize the formatter either with the specified format string, or a
        default as described above. Allow for specialized date formatting with
        the optional datefmt argument (if omitted, you get the ISO8601 format).
        """
        if fmt:
            self._fmt = fmt
        else:
            self._fmt = "%(message)s"
        self.datefmt = datefmt

    def formatTime(self, record, datefmt=None):
        """
        Return the creation time of the specified LogRecord as formatted text.

        This method should be called from format() by a formatter which
        wants to make use of a formatted time. This method can be overridden
        in formatters to provide for any specific requirement, but the
        basic behaviour is as follows: if datefmt (a string) is specified,
        it is used with time.strftime() to format the creation time of the
        record. Otherwise, the ISO8601 format is used. The resulting
        string is returned. This function uses a user-configurable function
        to convert the creation time to a tuple. By default, time.localtime()
        is used; to change this for a particular formatter instance, set the
        'converter' attribute to a function with the same signature as
        time.localtime() or time.gmtime(). To change it for all formatters,
        for example if you want all logging times to be shown in GMT,
        set the 'converter' attribute in the Formatter class.
        """
        ct = self.converter(record.created)
        if datefmt:
            s = time.strftime(datefmt, ct)
        else:
            t = time.strftime("%Y-%m-%d %H:%M:%S", ct)
            s = "%s,%03d" % (t, record.msecs)
        return s

    def formatException(self, ei):
        """
        Format and return the specified exception information as a string.

        This default implementation just uses
        traceback.print_exception()
        """
        sio = cStringIO.StringIO()
        traceback.print_exception(ei[0], ei[1], ei[2], None, sio)
        s = sio.getvalue()
        sio.close()
        if s[-1:] == "\n":
            s = s[:-1]
        return s

    def usesTime(self):
        """
        Check if the format uses the creation time of the record.
        """
        return self._fmt.find("%(asctime)") >= 0

    def format(self, record):
        """
        Format the specified record as text.

        The record's attribute dictionary is used as the operand to a
        string formatting operation which yields the returned string.
        Before formatting the dictionary, a couple of preparatory steps
        are carried out. The message attribute of the record is computed
        using LogRecord.getMessage(). If the formatting string uses the
        time (as determined by a call to usesTime(), formatTime() is
        called to format the event time. If there is exception information,
        it is formatted using formatException() and appended to the message.
        """
        record.message = record.getMessage()
        if self.usesTime():
            record.asctime = self.formatTime(record, self.datefmt)
        try:
            s = self._fmt % record.__dict__
        except UnicodeDecodeError as e:
            # Issue 25664. The logger name may be Unicode. Try again ...
            try:
                record.name = record.name.decode('utf-8')
                s = self._fmt % record.__dict__
            except UnicodeDecodeError:
                raise e
        if record.exc_info:
            # Cache the traceback text to avoid converting it multiple times
            # (it's constant anyway)
            if not record.exc_text:
                record.exc_text = self.formatException(record.exc_info)
        if record.exc_text:
            if s[-1:] != "\n":
                s = s + "\n"
            try:
                s = s + record.exc_text
            except UnicodeError:
                # Sometimes filenames have non-ASCII chars, which can lead
                # to errors when s is Unicode and record.exc_text is str
                # See issue 8924.
                # We also use replace for when there are multiple
                # encodings, e.g. UTF-8 for the filesystem and latin-1
                # for a script. See issue 13232.
                s = s + record.exc_text.decode(sys.getfilesystemencoding(),
                                               'replace')
        return s

#
#   The default formatter to use when no other is specified
#
_defaultFormatter = Formatter()

class BufferingFormatter(object):
    """
    A formatter suitable for formatting a number of records.
    """
    def __init__(self, linefmt=None):
        """
        Optionally specify a formatter which will be used to format each
        individual record.
        """
        if linefmt:
            self.linefmt = linefmt
        else:
            self.linefmt = _defaultFormatter

    def formatHeader(self, records):
        """
        Return the header string for the specified records.
        """
        return ""

    def formatFooter(self, records):
        """
        Return the footer string for the specified records.
        """
        return ""

    def format(self, records):
        """
        Format the specified records and return the result as a string.
        """
        rv = ""
        if len(records) > 0:
            rv = rv + self.formatHeader(records)
            for record in records:
                rv = rv + self.linefmt.format(record)
            rv = rv + self.formatFooter(records)
        return rv

#---------------------------------------------------------------------------
#   Filter classes and functions
#---------------------------------------------------------------------------

class Filter(object):
    """
    Filter instances are used to perform arbitrary filtering of LogRecords.

    Loggers and Handlers can optionally use Filter instances to filter
    records as desired. The base filter class only allows events which are
    below a certain point in the logger hierarchy. For example, a filter
    initialized with "A.B" will allow events logged by loggers "A.B",
    "A.B.C", "A.B.C.D", "A.B.D" etc. but not "A.BB", "B.A.B" etc. If
    initialized with the empty string, all events are passed.
    """
    def __init__(self, name=''):
        """
        Initialize a filter.

        Initialize with the name of the logger which, together with its
        children, will have its events allowed through the filter. If no
        name is specified, allow every event.
        """
        self.name = name
        self.nlen = len(name)

    def filter(self, record):
        """
        Determine if the specified record is to be logged.

        Is the specified record to be logged? Returns 0 for no, nonzero for
        yes. If deemed appropriate, the record may be modified in-place.
        """
        if self.nlen == 0:
            return 1
        elif self.name == record.name:
            return 1
        elif record.name.find(self.name, 0, self.nlen) != 0:
            return 0
        return (record.name[self.nlen] == ".")

class Filterer(object):
    """
    A base class for loggers and handlers which allows them to share
    common code.
    """
    def __init__(self):
        """
        Initialize the list of filters to be an empty list.
        """
        self.filters = []

    def addFilter(self, filter):
        """
        Add the specified filter to this handler.
        """
        if not (filter in self.filters):
            self.filters.append(filter)

    def removeFilter(self, filter):
        """
        Remove the specified filter from this handler.
        """
        if filter in self.filters:
            self.filters.remove(filter)

    def filter(self, record):
        """
        Determine if a record is loggable by consulting all the filters.

        The default is to allow the record to be logged; any filter can veto
        this and the record is then dropped. Returns a zero value if a record
        is to be dropped, else non-zero.
        """
        rv = 1
        for f in self.filters:
            if not f.filter(record):
                rv = 0
                break
        return rv

#---------------------------------------------------------------------------
#   Handler classes and functions
#---------------------------------------------------------------------------

_handlers = weakref.WeakValueDictionary()  #map of handler names to handlers
_handlerList = [] # added to allow handlers to be removed in reverse of order initialized

def _removeHandlerRef(wr):
    """
    Remove a handler reference from the internal cleanup list.
    """
    # This function can be called during module teardown, when globals are
    # set to None. It can also be called from another thread. So we need to
    # pre-emptively grab the necessary globals and check if they're None,
    # to prevent race conditions and failures during interpreter shutdown.
    acquire, release, handlers = _acquireLock, _releaseLock, _handlerList
    if acquire and release and handlers:
        acquire()
        try:
            if wr in handlers:
                handlers.remove(wr)
        finally:
            release()

def _addHandlerRef(handler):
    """
    Add a handler to the internal cleanup list using a weak reference.
    """
    _acquireLock()
    try:
        _handlerList.append(weakref.ref(handler, _removeHandlerRef))
    finally:
        _releaseLock()

class Handler(Filterer):
    """
    Handler instances dispatch logging events to specific destinations.

    The base handler class. Acts as a placeholder which defines the Handler
    interface. Handlers can optionally use Formatter instances to format
    records as desired. By default, no formatter is specified; in this case,
    the 'raw' message as determined by record.message is logged.
    """
    def __init__(self, level=NOTSET):
        """
        Initializes the instance - basically setting the formatter to None
        and the filter list to empty.
        """
        Filterer.__init__(self)
        self._name = None
        self.level = _checkLevel(level)
        self.formatter = None
        # Add the handler to the global _handlerList (for cleanup on shutdown)
        _addHandlerRef(self)
        self.createLock()

    def get_name(self):
        return self._name

    def set_name(self, name):
        _acquireLock()
        try:
            if self._name in _handlers:
                del _handlers[self._name]
            self._name = name
            if name:
                _handlers[name] = self
        finally:
            _releaseLock()

    name = property(get_name, set_name)

    def createLock(self):
        """
        Acquire a thread lock for serializing access to the underlying I/O.
        """
        if thread:
            self.lock = threading.RLock()
        else:
            self.lock = None

    def acquire(self):
        """
        Acquire the I/O thread lock.
        """
        if self.lock:
            self.lock.acquire()

    def release(self):
        """
        Release the I/O thread lock.
        """
        if self.lock:
            self.lock.release()

    def setLevel(self, level):
        """
        Set the logging level of this handler.
        """
        self.level = _checkLevel(level)

    def format(self, record):
        """
        Format the specified record.

        If a formatter is set, use it. Otherwise, use the default formatter
        for the module.
        """
        if self.formatter:
            fmt = self.formatter
        else:
            fmt = _defaultFormatter
        return fmt.format(record)

    def emit(self, record):
        """
        Do whatever it takes to actually log the specified logging record.

        This version is intended to be implemented by subclasses and so
        raises a NotImplementedError.
        """
        raise NotImplementedError('emit must be implemented '
                                  'by Handler subclasses')

    def handle(self, record):
        """
        Conditionally emit the specified logging record.

        Emission depends on filters which may have been added to the handler.
        Wrap the actual emission of the record with acquisition/release of
        the I/O thread lock. Returns whether the filter passed the record for
        emission.
        """
        rv = self.filter(record)
        if rv:
            self.acquire()
            try:
                self.emit(record)
            finally:
                self.release()
        return rv

    def setFormatter(self, fmt):
        """
        Set the formatter for this handler.
        """
        self.formatter = fmt

    def flush(self):
        """
        Ensure all logging output has been flushed.

        This version does nothing and is intended to be implemented by
        subclasses.
        """
        pass

    def close(self):
        """
        Tidy up any resources used by the handler.

        This version removes the handler from an internal map of handlers,
        _handlers, which is used for handler lookup by name. Subclasses
        should ensure that this gets called from overridden close()
        methods.
        """
        #get the module data lock, as we're updating a shared structure.
        _acquireLock()
        try:    #unlikely to raise an exception, but you never know...
            if self._name and self._name in _handlers:
                del _handlers[self._name]
        finally:
            _releaseLock()

    def handleError(self, record):
        """
        Handle errors which occur during an emit() call.

        This method should be called from handlers when an exception is
        encountered during an emit() call. If raiseExceptions is false,
        exceptions get silently ignored. This is what is mostly wanted
        for a logging system - most users will not care about errors in
        the logging system, they are more interested in application errors.
        You could, however, replace this with a custom handler if you wish.
        The record which was being processed is passed in to this method.
        """
        if raiseExceptions and sys.stderr:  # see issue 13807
            ei = sys.exc_info()
            try:
                traceback.print_exception(ei[0], ei[1], ei[2],
                                          None, sys.stderr)
                sys.stderr.write('Logged from file %s, line %s\n' % (
                                 record.filename, record.lineno))
            except IOError:
                pass    # see issue 5971
            finally:
                del ei

class StreamHandler(Handler):
    """
    A handler class which writes logging records, appropriately formatted,
    to a stream. Note that this class does not close the stream, as
    sys.stdout or sys.stderr may be used.
    """

    def __init__(self, stream=None):
        """
        Initialize the handler.

        If stream is not specified, sys.stderr is used.
        """
        Handler.__init__(self)
        if stream is None:
            stream = sys.stderr
        self.stream = stream

    def flush(self):
        """
        Flushes the stream.
        """
        self.acquire()
        try:
            if self.stream and hasattr(self.stream, "flush"):
                self.stream.flush()
        finally:
            self.release()

    def emit(self, record):
        """
        Emit a record.

        If a formatter is specified, it is used to format the record.
        The record is then written to the stream with a trailing newline.  If
        exception information is present, it is formatted using
        traceback.print_exception and appended to the stream.  If the stream
        has an 'encoding' attribute, it is used to determine how to do the
        output to the stream.
        """
        try:
            msg = self.format(record)
            stream = self.stream
            fs = "%s\n"
            if not _unicode: #if no unicode support...
                stream.write(fs % msg)
            else:
                try:
                    if (isinstance(msg, unicode) and
                        getattr(stream, 'encoding', None)):
                        ufs = u'%s\n'
                        try:
                            stream.write(ufs % msg)
                        except UnicodeEncodeError:
                            #Printing to terminals sometimes fails. For example,
                            #with an encoding of 'cp1251', the above write will
                            #work if written to a stream opened or wrapped by
                            #the codecs module, but fail when writing to a
                            #terminal even when the codepage is set to cp1251.
                            #An extra encoding step seems to be needed.
                            stream.write((ufs % msg).encode(stream.encoding))
                    else:
                        stream.write(fs % msg)
                except UnicodeError:
                    stream.write(fs % msg.encode("UTF-8"))
            self.flush()
        except (KeyboardInterrupt, SystemExit):
            raise
        except:
            self.handleError(record)

class FileHandler(StreamHandler):
    """
    A handler class which writes formatted logging records to disk files.
    """
    def __init__(self, filename, mode='a', encoding=None, delay=0):
        """
        Open the specified file and use it as the stream for logging.
        """
        #keep the absolute path, otherwise derived classes which use this
        #may come a cropper when the current directory changes
        if codecs is None:
            encoding = None
        self.baseFilename = os.path.abspath(filename)
        self.mode = mode
        self.encoding = encoding
        self.delay = delay
        if delay:
            #We don't open the stream, but we still need to call the
            #Handler constructor to set level, formatter, lock etc.
            Handler.__init__(self)
            self.stream = None
        else:
            StreamHandler.__init__(self, self._open())

    def close(self):
        """
        Closes the stream.
        """
        self.acquire()
        try:
            try:
                if self.stream:
                    try:
                        self.flush()
                    finally:
                        stream = self.stream
                        self.stream = None
                        if hasattr(stream, "close"):
                            stream.close()
            finally:
                # Issue #19523: call unconditionally to
                # prevent a handler leak when delay is set
                StreamHandler.close(self)
        finally:
            self.release()

    def _open(self):
        """
        Open the current base file with the (original) mode and encoding.
        Return the resulting stream.
        """
        if self.encoding is None:
            stream = open(self.baseFilename, self.mode)
        else:
            stream = codecs.open(self.baseFilename, self.mode, self.encoding)
        return stream

    def emit(self, record):
        """
        Emit a record.

        If the stream was not opened because 'delay' was specified in the
        constructor, open it before calling the superclass's emit.
        """
        if self.stream is None:
            self.stream = self._open()
        StreamHandler.emit(self, record)

#---------------------------------------------------------------------------
#   Manager classes and functions
#---------------------------------------------------------------------------

class PlaceHolder(object):
    """
    PlaceHolder instances are used in the Manager logger hierarchy to take
    the place of nodes for which no loggers have been defined. This class is
    intended for internal use only and not as part of the public API.
    """
    def __init__(self, alogger):
        """
        Initialize with the specified logger being a child of this placeholder.
        """
        #self.loggers = [alogger]
        self.loggerMap = { alogger : None }

    def append(self, alogger):
        """
        Add the specified logger as a child of this placeholder.
        """
        #if alogger not in self.loggers:
        if alogger not in self.loggerMap:
            #self.loggers.append(alogger)
            self.loggerMap[alogger] = None

#
#   Determine which class to use when instantiating loggers.
#
_loggerClass = None

def setLoggerClass(klass):
    """
    Set the class to be used when instantiating a logger. The class should
    define __init__() such that only a name argument is required, and the
    __init__() should call Logger.__init__()
    """
    if klass != Logger:
        if not issubclass(klass, Logger):
            raise TypeError("logger not derived from logging.Logger: "
                            + klass.__name__)
    global _loggerClass
    _loggerClass = klass

def getLoggerClass():
    """
    Return the class to be used when instantiating a logger.
    """

    return _loggerClass

class Manager(object):
    """
    There is [under normal circumstances] just one Manager instance, which
    holds the hierarchy of loggers.
    """
    def __init__(self, rootnode):
        """
        Initialize the manager with the root node of the logger hierarchy.
        """
        self.root = rootnode
        self.disable = 0
        self.emittedNoHandlerWarning = 0
        self.loggerDict = {}
        self.loggerClass = None

    def getLogger(self, name):
        """
        Get a logger with the specified name (channel name), creating it
        if it doesn't yet exist. This name is a dot-separated hierarchical
        name, such as "a", "a.b", "a.b.c" or similar.

        If a PlaceHolder existed for the specified name [i.e. the logger
        didn't exist but a child of it did], replace it with the created
        logger and fix up the parent/child references which pointed to the
        placeholder to now point to the logger.
        """
        rv = None
        if not isinstance(name, basestring):
            raise TypeError('A logger name must be string or Unicode')
        if isinstance(name, unicode):
            name = name.encode('utf-8')
        _acquireLock()
        try:
            if name in self.loggerDict:
                rv = self.loggerDict[name]
                if isinstance(rv, PlaceHolder):
                    ph = rv
                    rv = (self.loggerClass or _loggerClass)(name)
                    rv.manager = self
                    self.loggerDict[name] = rv
                    self._fixupChildren(ph, rv)
                    self._fixupParents(rv)
            else:
                rv = (self.loggerClass or _loggerClass)(name)
                rv.manager = self
                self.loggerDict[name] = rv
                self._fixupParents(rv)
        finally:
            _releaseLock()
        return rv

    def setLoggerClass(self, klass):
        """
        Set the class to be used when instantiating a logger with this Manager.
        """
        if klass != Logger:
            if not issubclass(klass, Logger):
                raise TypeError("logger not derived from logging.Logger: "
                                + klass.__name__)
        self.loggerClass = klass

    def _fixupParents(self, alogger):
        """
        Ensure that there are either loggers or placeholders all the way
        from the specified logger to the root of the logger hierarchy.
        """
        name = alogger.name
        i = name.rfind(".")
        rv = None
        while (i > 0) and not rv:
            substr = name[:i]
            if substr not in self.loggerDict:
                self.loggerDict[substr] = PlaceHolder(alogger)
            else:
                obj = self.loggerDict[substr]
                if isinstance(obj, Logger):
                    rv = obj
                else:
                    assert isinstance(obj, PlaceHolder)
                    obj.append(alogger)
            i = name.rfind(".", 0, i - 1)
        if not rv:
            rv = self.root
        alogger.parent = rv

    def _fixupChildren(self, ph, alogger):
        """
        Ensure that children of the placeholder ph are connected to the
        specified logger.
        """
        name = alogger.name
        namelen = len(name)
        for c in ph.loggerMap.keys():
            #The if means ... if not c.parent.name.startswith(nm)
            if c.parent.name[:namelen] != name:
                alogger.parent = c.parent
                c.parent = alogger

#---------------------------------------------------------------------------
#   Logger classes and functions
#---------------------------------------------------------------------------

class Logger(Filterer):
    """
    Instances of the Logger class represent a single logging channel. A
    "logging channel" indicates an area of an application. Exactly how an
    "area" is defined is up to the application developer. Since an
    application can have any number of areas, logging channels are identified
    by a unique string. Application areas can be nested (e.g. an area
    of "input processing" might include sub-areas "read CSV files", "read
    XLS files" and "read Gnumeric files"). To cater for this natural nesting,
    channel names are organized into a namespace hierarchy where levels are
    separated by periods, much like the Java or Python package namespace. So
    in the instance given above, channel names might be "input" for the upper
    level, and "input.csv", "input.xls" and "input.gnu" for the sub-levels.
    There is no arbitrary limit to the depth of nesting.
    """
    def __init__(self, name, level=NOTSET):
        """
        Initialize the logger with a name and an optional level.
        """
        Filterer.__init__(self)
        self.name = name
        self.level = _checkLevel(level)
        self.parent = None
        self.propagate = 1
        self.handlers = []
        self.disabled = 0

    def setLevel(self, level):
        """
        Set the logging level of this logger.
        """
        self.level = _checkLevel(level)

    def debug(self, msg, *args, **kwargs):
        """
        Log 'msg % args' with severity 'DEBUG'.

        To pass exception information, use the keyword argument exc_info with
        a true value, e.g.

        logger.debug("Houston, we have a %s", "thorny problem", exc_info=1)
        """
        if self.isEnabledFor(DEBUG):
            self._log(DEBUG, msg, args, **kwargs)

    def info(self, msg, *args, **kwargs):
        """
        Log 'msg % args' with severity 'INFO'.

        To pass exception information, use the keyword argument exc_info with
        a true value, e.g.

        logger.info("Houston, we have a %s", "interesting problem", exc_info=1)
        """
        if self.isEnabledFor(INFO):
            self._log(INFO, msg, args, **kwargs)

    def warning(self, msg, *args, **kwargs):
        """
        Log 'msg % args' with severity 'WARNING'.

        To pass exception information, use the keyword argument exc_info with
        a true value, e.g.

        logger.warning("Houston, we have a %s", "bit of a problem", exc_info=1)
        """
        if self.isEnabledFor(WARNING):
            self._log(WARNING, msg, args, **kwargs)

    warn = warning

    def error(self, msg, *args, **kwargs):
        """
        Log 'msg % args' with severity 'ERROR'.

        To pass exception information, use the keyword argument exc_info with
        a true value, e.g.

        logger.error("Houston, we have a %s", "major problem", exc_info=1)
        """
        if self.isEnabledFor(ERROR):
            self._log(ERROR, msg, args, **kwargs)

    def exception(self, msg, *args, **kwargs):
        """
        Convenience method for logging an ERROR with exception information.
        """
        kwargs['exc_info'] = 1
        self.error(msg, *args, **kwargs)

    def critical(self, msg, *args, **kwargs):
        """
        Log 'msg % args' with severity 'CRITICAL'.

        To pass exception information, use the keyword argument exc_info with
        a true value, e.g.

        logger.critical("Houston, we have a %s", "major disaster", exc_info=1)
        """
        if self.isEnabledFor(CRITICAL):
            self._log(CRITICAL, msg, args, **kwargs)

    fatal = critical

    def log(self, level, msg, *args, **kwargs):
        """
        Log 'msg % args' with the integer severity 'level'.

        To pass exception information, use the keyword argument exc_info with
        a true value, e.g.

        logger.log(level, "We have a %s", "mysterious problem", exc_info=1)
        """
        if not isinstance(level, int):
            if raiseExceptions:
                raise TypeError("level must be an integer")
            else:
                return
        if self.isEnabledFor(level):
            self._log(level, msg, args, **kwargs)

    def findCaller(self):
        """
        Find the stack frame of the caller so that we can note the source
        file name, line number and function name.
        """
        f = currentframe()
        #On some versions of IronPython, currentframe() returns None if
        #IronPython isn't run with -X:Frames.
        if f is not None:
            f = f.f_back
        rv = "(unknown file)", 0, "(unknown function)"
        while hasattr(f, "f_code"):
            co = f.f_code
            filename = os.path.normcase(co.co_filename)
            if filename == _srcfile:
                f = f.f_back
                continue
            rv = (co.co_filename, f.f_lineno, co.co_name)
            break
        return rv

    def makeRecord(self, name, level, fn, lno, msg, args, exc_info, func=None, extra=None):
        """
        A factory method which can be overridden in subclasses to create
        specialized LogRecords.
        """
        rv = LogRecord(name, level, fn, lno, msg, args, exc_info, func)
        if extra is not None:
            for key in extra:
                if (key in ["message", "asctime"]) or (key in rv.__dict__):
                    raise KeyError("Attempt to overwrite %r in LogRecord" % key)
                rv.__dict__[key] = extra[key]
        return rv

    def _log(self, level, msg, args, exc_info=None, extra=None):
        """
        Low-level logging routine which creates a LogRecord and then calls
        all the handlers of this logger to handle the record.
        """
        if _srcfile:
            #IronPython doesn't track Python frames, so findCaller raises an
            #exception on some versions of IronPython. We trap it here so that
            #IronPython can use logging.
            try:
                fn, lno, func = self.findCaller()
            except ValueError:
                fn, lno, func = "(unknown file)", 0, "(unknown function)"
        else:
            fn, lno, func = "(unknown file)", 0, "(unknown function)"
        if exc_info:
            if not isinstance(exc_info, tuple):
                exc_info = sys.exc_info()
        record = self.makeRecord(self.name, level, fn, lno, msg, args, exc_info, func, extra)
        self.handle(record)

    def handle(self, record):
        """
        Call the handlers for the specified record.

        This method is used for unpickled records received from a socket, as
        well as those created locally. Logger-level filtering is applied.
        """
        if (not self.disabled) and self.filter(record):
            self.callHandlers(record)

    def addHandler(self, hdlr):
        """
        Add the specified handler to this logger.
        """
        _acquireLock()
        try:
            if not (hdlr in self.handlers):
                self.handlers.append(hdlr)
        finally:
            _releaseLock()

    def removeHandler(self, hdlr):
        """
        Remove the specified handler from this logger.
        """
        _acquireLock()
        try:
            if hdlr in self.handlers:
                self.handlers.remove(hdlr)
        finally:
            _releaseLock()

    def callHandlers(self, record):
        """
        Pass a record to all relevant handlers.

        Loop through all handlers for this logger and its parents in the
        logger hierarchy. If no handler was found, output a one-off error
        message to sys.stderr. Stop searching up the hierarchy whenever a
        logger with the "propagate" attribute set to zero is found - that
        will be the last logger whose handlers are called.
        """
        c = self
        found = 0
        while c:
            for hdlr in c.handlers:
                found = found + 1
                if record.levelno >= hdlr.level:
                    hdlr.handle(record)
            if not c.propagate:
                c = None    #break out
            else:
                c = c.parent
        if (found == 0) and raiseExceptions and not self.manager.emittedNoHandlerWarning:
            sys.stderr.write("No handlers could be found for logger"
                             " \"%s\"\n" % self.name)
            self.manager.emittedNoHandlerWarning = 1

    def getEffectiveLevel(self):
        """
        Get the effective level for this logger.

        Loop through this logger and its parents in the logger hierarchy,
        looking for a non-zero logging level. Return the first one found.
        """
        logger = self
        while logger:
            if logger.level:
                return logger.level
            logger = logger.parent
        return NOTSET

    def isEnabledFor(self, level):
        """
        Is this logger enabled for level 'level'?
        """
        if self.manager.disable >= level:
            return 0
        return level >= self.getEffectiveLevel()

    def getChild(self, suffix):
        """
        Get a logger which is a descendant to this one.

        This is a convenience method, such that

        logging.getLogger('abc').getChild('def.ghi')

        is the same as

        logging.getLogger('abc.def.ghi')

        It's useful, for example, when the parent logger is named using
        __name__ rather than a literal string.
        """
        if self.root is not self:
            suffix = '.'.join((self.name, suffix))
        return self.manager.getLogger(suffix)

class RootLogger(Logger):
    """
    A root logger is not that different to any other logger, except that
    it must have a logging level and there is only one instance of it in
    the hierarchy.
    """
    def __init__(self, level):
        """
        Initialize the logger with the name "root".
        """
        Logger.__init__(self, "root", level)

_loggerClass = Logger

class LoggerAdapter(object):
    """
    An adapter for loggers which makes it easier to specify contextual
    information in logging output.
    """

    def __init__(self, logger, extra):
        """
        Initialize the adapter with a logger and a dict-like object which
        provides contextual information. This constructor signature allows
        easy stacking of LoggerAdapters, if so desired.

        You can effectively pass keyword arguments as shown in the
        following example:

        adapter = LoggerAdapter(someLogger, dict(p1=v1, p2="v2"))
        """
        self.logger = logger
        self.extra = extra

    def process(self, msg, kwargs):
        """
        Process the logging message and keyword arguments passed in to
        a logging call to insert contextual information. You can either
        manipulate the message itself, the keyword args or both. Return
        the message and kwargs modified (or not) to suit your needs.

        Normally, you'll only need to override this one method in a
        LoggerAdapter subclass for your specific needs.
        """
        kwargs["extra"] = self.extra
        return msg, kwargs

    def debug(self, msg, *args, **kwargs):
        """
        Delegate a debug call to the underlying logger, after adding
        contextual information from this adapter instance.
        """
        msg, kwargs = self.process(msg, kwargs)
        self.logger.debug(msg, *args, **kwargs)

    def info(self, msg, *args, **kwargs):
        """
        Delegate an info call to the underlying logger, after adding
        contextual information from this adapter instance.
        """
        msg, kwargs = self.process(msg, kwargs)
        self.logger.info(msg, *args, **kwargs)

    def warning(self, msg, *args, **kwargs):
        """
        Delegate a warning call to the underlying logger, after adding
        contextual information from this adapter instance.
        """
        msg, kwargs = self.process(msg, kwargs)
        self.logger.warning(msg, *args, **kwargs)

    def error(self, msg, *args, **kwargs):
        """
        Delegate an error call to the underlying logger, after adding
        contextual information from this adapter instance.
        """
        msg, kwargs = self.process(msg, kwargs)
        self.logger.error(msg, *args, **kwargs)

    def exception(self, msg, *args, **kwargs):
        """
        Delegate an exception call to the underlying logger, after adding
        contextual information from this adapter instance.
        """
        msg, kwargs = self.process(msg, kwargs)
        kwargs["exc_info"] = 1
        self.logger.error(msg, *args, **kwargs)

    def critical(self, msg, *args, **kwargs):
        """
        Delegate a critical call to the underlying logger, after adding
        contextual information from this adapter instance.
        """
        msg, kwargs = self.process(msg, kwargs)
        self.logger.critical(msg, *args, **kwargs)

    def log(self, level, msg, *args, **kwargs):
        """
        Delegate a log call to the underlying logger, after adding
        contextual information from this adapter instance.
        """
        msg, kwargs = self.process(msg, kwargs)
        self.logger.log(level, msg, *args, **kwargs)

    def isEnabledFor(self, level):
        """
        See if the underlying logger is enabled for the specified level.
        """
        return self.logger.isEnabledFor(level)

root = RootLogger(WARNING)
Logger.root = root
Logger.manager = Manager(Logger.root)

#---------------------------------------------------------------------------
# Configuration classes and functions
#---------------------------------------------------------------------------

BASIC_FORMAT = "%(levelname)s:%(name)s:%(message)s"

def basicConfig(**kwargs):
    """
    Do basic configuration for the logging system.

    This function does nothing if the root logger already has handlers
    configured. It is a convenience method intended for use by simple scripts
    to do one-shot configuration of the logging package.

    The default behaviour is to create a StreamHandler which writes to
    sys.stderr, set a formatter using the BASIC_FORMAT format string, and
    add the handler to the root logger.

    A number of optional keyword arguments may be specified, which can alter
    the default behaviour.

    filename  Specifies that a FileHandler be created, using the specified
              filename, rather than a StreamHandler.
    filemode  Specifies the mode to open the file, if filename is specified
              (if filemode is unspecified, it defaults to 'a').
    format    Use the specified format string for the handler.
    datefmt   Use the specified date/time format.
    level     Set the root logger level to the specified level.
    stream    Use the specified stream to initialize the StreamHandler. Note
              that this argument is incompatible with 'filename' - if both
              are present, 'stream' is ignored.

    Note that you could specify a stream created using open(filename, mode)
    rather than passing the filename and mode in. However, it should be
    remembered that StreamHandler does not close its stream (since it may be
    using sys.stdout or sys.stderr), whereas FileHandler closes its stream
    when the handler is closed.
    """
    # Add thread safety in case someone mistakenly calls
    # basicConfig() from multiple threads
    _acquireLock()
    try:
        if len(root.handlers) == 0:
            filename = kwargs.get("filename")
            if filename:
                mode = kwargs.get("filemode", 'a')
                hdlr = FileHandler(filename, mode)
            else:
                stream = kwargs.get("stream")
                hdlr = StreamHandler(stream)
            fs = kwargs.get("format", BASIC_FORMAT)
            dfs = kwargs.get("datefmt", None)
            fmt = Formatter(fs, dfs)
            hdlr.setFormatter(fmt)
            root.addHandler(hdlr)
            level = kwargs.get("level")
            if level is not None:
                root.setLevel(level)
    finally:
        _releaseLock()

#---------------------------------------------------------------------------
# Utility functions at module level.
# Basically delegate everything to the root logger.
#---------------------------------------------------------------------------

def getLogger(name=None):
    """
    Return a logger with the specified name, creating it if necessary.

    If no name is specified, return the root logger.
    """
    if name:
        return Logger.manager.getLogger(name)
    else:
        return root

#def getRootLogger():
#    """
#    Return the root logger.
#
#    Note that getLogger('') now does the same thing, so this function is
#    deprecated and may disappear in the future.
#    """
#    return root

def critical(msg, *args, **kwargs):
    """
    Log a message with severity 'CRITICAL' on the root logger.
    """
    if len(root.handlers) == 0:
        basicConfig()
    root.critical(msg, *args, **kwargs)

fatal = critical

def error(msg, *args, **kwargs):
    """
    Log a message with severity 'ERROR' on the root logger.
    """
    if len(root.handlers) == 0:
        basicConfig()
    root.error(msg, *args, **kwargs)

def exception(msg, *args, **kwargs):
    """
    Log a message with severity 'ERROR' on the root logger,
    with exception information.
    """
    kwargs['exc_info'] = 1
    error(msg, *args, **kwargs)

def warning(msg, *args, **kwargs):
    """
    Log a message with severity 'WARNING' on the root logger.
    """
    if len(root.handlers) == 0:
        basicConfig()
    root.warning(msg, *args, **kwargs)

warn = warning

def info(msg, *args, **kwargs):
    """
    Log a message with severity 'INFO' on the root logger.
    """
    if len(root.handlers) == 0:
        basicConfig()
    root.info(msg, *args, **kwargs)

def debug(msg, *args, **kwargs):
    """
    Log a message with severity 'DEBUG' on the root logger.
    """
    if len(root.handlers) == 0:
        basicConfig()
    root.debug(msg, *args, **kwargs)

def log(level, msg, *args, **kwargs):
    """
    Log 'msg % args' with the integer severity 'level' on the root logger.
    """
    if len(root.handlers) == 0:
        basicConfig()
    root.log(level, msg, *args, **kwargs)

def disable(level):
    """
    Disable all logging calls of severity 'level' and below.
    """
    root.manager.disable = level

def shutdown(handlerList=_handlerList):
    """
    Perform any cleanup actions in the logging system (e.g. flushing
    buffers).

    Should be called at application exit.
    """
    for wr in reversed(handlerList[:]):
        #errors might occur, for example, if files are locked
        #we just ignore them if raiseExceptions is not set
        try:
            h = wr()
            if h:
                try:
                    h.acquire()
                    h.flush()
                    h.close()
                except (IOError, ValueError):
                    # Ignore errors which might be caused
                    # because handlers have been closed but
                    # references to them are still around at
                    # application exit.
                    pass
                finally:
                    h.release()
        except:
            if raiseExceptions:
                raise
            #else, swallow

#Let's try and shutdown automatically on application exit...
import atexit
atexit.register(shutdown)

# Null handler

class NullHandler(Handler):
    """
    This handler does nothing. It's intended to be used to avoid the
    "No handlers could be found for logger XXX" one-off warning. This is
    important for library code, which may contain code to log events. If a user
    of the library does not configure logging, the one-off warning might be
    produced; to avoid this, the library developer simply needs to instantiate
    a NullHandler and add it to the top-level logger of the library module or
    package.
    """
    def handle(self, record):
        pass

    def emit(self, record):
        pass

    def createLock(self):
        self.lock = None

# Warnings integration

_warnings_showwarning = None

def _showwarning(message, category, filename, lineno, file=None, line=None):
    """
    Implementation of showwarnings which redirects to logging, which will first
    check to see if the file parameter is None. If a file is specified, it will
    delegate to the original warnings implementation of showwarning. Otherwise,
    it will call warnings.formatwarning and will log the resulting string to a
    warnings logger named "py.warnings" with level logging.WARNING.
    """
    if file is not None:
        if _warnings_showwarning is not None:
            _warnings_showwarning(message, category, filename, lineno, file, line)
    else:
        s = warnings.formatwarning(message, category, filename, lineno, line)
        logger = getLogger("py.warnings")
        if not logger.handlers:
            logger.addHandler(NullHandler())
        logger.warning("%s", s)

def captureWarnings(capture):
    """
    If capture is true, redirect all warnings to the logging package.
    If capture is False, ensure that warnings are not redirected to logging
    but to their original destinations.
    """
    global _warnings_showwarning
    if capture:
        if _warnings_showwarning is None:
            _warnings_showwarning = warnings.showwarning
            warnings.showwarning = _showwarning
    else:
        if _warnings_showwarning is not None:
            warnings.showwarning = _warnings_showwarning
            _warnings_showwarning = None
                                                                                                                                                                                Û
”´[c        %   @   s  d  Z  d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z d d d d d d d	 d
 d d d d d d d d d d d d d d d d d d d d d d  d! d" d# d$ d% d& d' g% Z	 y d d l
 Z
 Wn e k
 re Z
 n Xy d d l Z d d l Z Wn e k
 r:e Z n Xd( Z d) Z d* Z d+ Z y e e Z Wn e k
 rze Z n Xd, Ñ  Z e e d- É rüd. Ñ  Z n  e j j e j j É Z e j É  Z d/ Z  d/ Z! d/ Z" d/ Z# d0 Z$ e$ Z% d1 Z& d2 Z' e' Z( d3 Z) d4 Z* d5 Z+ i d e$ 6d e& 6d e' 6d e) 6d e* 6d e+ 6e$ d 6e& d 6e' d 6e' d 6e) d 6e* d 6e+ d 6Z, d6 Ñ  Z- d7 Ñ  Z. d8 Ñ  Z/ e rúe j0 É  Z1 n e Z1 d9 Ñ  Z2 d: Ñ  Z3 d e4 f d; Ñ  É  YZ5 d< Ñ  Z6 d e4 f d= Ñ  É  YZ7 e7 É  Z8 d e4 f d> Ñ  É  YZ9 d
 e4 f d? Ñ  É  YZ: d@ e4 f dA Ñ  É  YZ; e j< É  Z= g  Z> dB Ñ  Z? dC Ñ  Z@ d e; f dD Ñ  É  YZA d eA f dE Ñ  É  YZB d	 eB f dF Ñ  É  YZC dG e4 f dH Ñ  É  YZD e aE dI Ñ  ZF dJ Ñ  ZG dK e4 f dL Ñ  É  YZH d e; f dM Ñ  É  YZI dN eI f dO Ñ  É  YZJ eI aE d e4 f dP Ñ  É  YZK eJ e' É ZL eL eI _L eH eI jL É eI _M dQ ZN dR Ñ  ZO e dS Ñ ZP dT Ñ  ZQ eQ ZR dU Ñ  ZS dV Ñ  ZT dW Ñ  ZU eU ZV dX Ñ  ZW dY Ñ  ZX dZ Ñ  ZY d[ Ñ  ZZ e> d\ Ñ Z[ d d l\ Z\ e\ j] e[ É d eA f d] Ñ  É  YZ^ e a_ e e d^ Ñ Z` d_ Ñ  Za d S(`   s¬   
Logging package for Python. Based on PEP 282 and comments thereto in
comp.lang.python.

Copyright (C) 2001-2014 Vinay Sajip. All Rights Reserved.

To use, simply 'import logging' and log away!
iˇˇˇˇNt   BASIC_FORMATt   BufferingFormattert   CRITICALt   DEBUGt   ERRORt   FATALt   FileHandlert   Filtert	   Formattert   Handlert   INFOt	   LogRecordt   Loggert   LoggerAdaptert   NOTSETt   NullHandlert   StreamHandlert   WARNt   WARNINGt   addLevelNamet   basicConfigt   captureWarningst   criticalt   debugt   disablet   errort	   exceptiont   fatalt   getLevelNamet	   getLoggert   getLoggerClasst   infot   logt   makeLogRecordt   setLoggerClasst   warnt   warnings&   Vinay Sajip <vinay_sajip@red-dove.com>t
   productions   0.5.1.2s   07 February 2010c           C   s)   y
 t  Ç Wn t j É  d j j SXd S(   s5   Return the frame object for the caller's stack frame.i   N(   t	   Exceptiont   syst   exc_infot   tb_framet   f_back(    (    (    s&   /usr/lib/python2.7/logging/__init__.pyt   currentframe?   s    
t	   _getframec           C   s   t  j d É S(   Ni   (   R'   R,   (    (    (    s&   /usr/lib/python2.7/logging/__init__.pyt   <lambda>F   s    i   i2   i(   i   i   i
   i    c         C   s   t  j |  d |  É S(   s  
    Return the textual representation of logging level 'level'.

    If the level is one of the predefined levels (CRITICAL, ERROR, WARNING,
    INFO, DEBUG) then you get the corresponding string. If you have
    associated levels with names using addLevelName then the name you have
    associated with 'level' is returned.

    If a numeric value corresponding to one of the defined levels is passed
    in, the corresponding string representation is returned.

    Otherwise, the string "Level %s" % level is returned.
    s   Level %s(   t   _levelNamest   get(   t   level(    (    s&   /usr/lib/python2.7/logging/__init__.pyR   î   s    c         C   s.   t  É  z | t |  <|  t | <Wd t É  Xd S(   sy   
    Associate 'levelName' with 'level'.

    This is used when converting levels to text during message formatting.
    N(   t   _acquireLockR.   t   _releaseLock(   R0   t	   levelName(    (    s&   /usr/lib/python2.7/logging/__init__.pyR   §   s
    
c         C   sp   t  |  t t f É r |  } nN t |  É |  k r\ |  t k rO t d |  É Ç n  t |  } n t d |  É Ç | S(   Ns   Unknown level: %rs*   Level not an integer or a valid string: %r(   t
   isinstancet   intt   longt   strR.   t
   ValueErrort	   TypeError(   R0   t   rv(    (    s&   /usr/lib/python2.7/logging/__init__.pyt   _checkLevel±   s    	c           C   s   t  r t  j É  n  d S(   sÄ   
    Acquire the module-level lock for serializing access to shared data.

    This should be released with _releaseLock().
    N(   t   _lockt   acquire(    (    (    s&   /usr/lib/python2.7/logging/__init__.pyR1   Õ   s    c           C   s   t  r t  j É  n  d S(   sK   
    Release the module-level lock acquired by calling _acquireLock().
    N(   R<   t   release(    (    (    s&   /usr/lib/python2.7/logging/__init__.pyR2   ÷   s    c           B   s,   e  Z d  Z d d Ñ Z d Ñ  Z d Ñ  Z RS(   s  
    A LogRecord instance represents an event being logged.

    LogRecord instances are created every time something is logged. They
    contain all the information pertinent to the event being logged. The
    main information passed in is in msg and args, which are combined
    using str(msg) % args to create the message field of the record. The
    record also includes information such as when the record was created,
    the source line where the logging call was made, and any exception
    information to be logged.
    c	         C   s%  t  j  É  }	 | |  _ | |  _ | rc t | É d k rc t | d t j É rc | d rc | d } n  | |  _ t | É |  _	 | |  _
 | |  _ y5 t j j | É |  _ t j j |  j É d |  _ Wn, t t t f k
 r | |  _ d |  _ n X| |  _ d |  _ | |  _ | |  _ |	 |  _ |	 t |	 É d |  _ |  j t d |  _ t ryt  ryt  j! É  |  _  t" j# É  j |  _$ n d |  _  d |  _$ t% sùd |  _& nT d |  _& t' j( j) d É }
 |
 d k	 rÒy |
 j* É  j |  _& WqÒt+ k
 rÌqÒXn  t, rt- t d É rt j. É  |  _/ n	 d |  _/ d S(	   sK   
        Initialize a logging record with interesting information.
        i   i    s   Unknown moduleiË  t   MainProcesst   multiprocessingt   getpidN(0   t   timet   namet   msgt   lenR4   t   collectionst   Mappingt   argsR   t	   levelnamet   levelnot   pathnamet   ost   patht   basenamet   filenamet   splitextt   moduleR9   R8   t   AttributeErrorR(   t   Nonet   exc_textt   linenot   funcNamet   createdR6   t   msecst
   _startTimet   relativeCreatedt
   logThreadst   threadt	   get_identt	   threadingt   current_threadt
   threadNamet   logMultiprocessingt   processNameR'   t   modulesR/   t   current_processt   StandardErrort   logProcessest   hasattrRA   t   process(   t   selfRC   R0   RK   RU   RD   RH   R(   t   funct   ctt   mp(    (    s&   /usr/lib/python2.7/logging/__init__.pyt   __init__Ì   sP    		.
			 									c         C   s&   d |  j  |  j |  j |  j |  j f S(   Ns!   <LogRecord: %s, %s, %s, %s, "%s">(   RC   RJ   RK   RU   RD   (   Ri   (    (    s&   /usr/lib/python2.7/logging/__init__.pyt   __str__4  s    c         C   sÄ   t  s t |  j É } nK |  j } t | t É sc y t |  j É } Wqc t k
 r_ |  j } qc Xn  |  j r| | |  j } n  | S(   s´   
        Return the message for this LogRecord.

        Return the message for this LogRecord after merging any user-supplied
        arguments with the message.
        (   t   _unicodeR7   RD   R4   t
   basestringt   UnicodeErrorRH   (   Ri   RD   (    (    s&   /usr/lib/python2.7/logging/__init__.pyt
   getMessage8  s    		N(   t   __name__t
   __module__t   __doc__RS   Rm   Rn   Rr   (    (    (    s&   /usr/lib/python2.7/logging/__init__.pyR   ·   s   F	c      	   C   s5   t  d d d d d d d d É } | j j |  É | S(   sÙ   
    Make a LogRecord whose attributes are defined by the specified dictionary,
    This function is useful for converting a logging event received over
    a socket connection (which is sent as a dictionary) into a LogRecord
    instance.
    t    i    N(    (   R   RS   t   __dict__t   update(   t   dictR:   (    (    s&   /usr/lib/python2.7/logging/__init__.pyR!   L  s    !c           B   sM   e  Z d  Z e j Z d d d Ñ Z d d Ñ Z d Ñ  Z	 d Ñ  Z
 d Ñ  Z RS(   s©  
    Formatter instances are used to convert a LogRecord to text.

    Formatters need to know how a LogRecord is constructed. They are
    responsible for converting a LogRecord to (usually) a string which can
    be interpreted by either a human or an external system. The base Formatter
    allows a formatting string to be specified. If none is supplied, the
    default value of "%s(message)\n" is used.

    The Formatter can be initialized with a format string which makes use of
    knowledge of the LogRecord attributes - e.g. the default value mentioned
    above makes use of the fact that the user's message and arguments are pre-
    formatted into a LogRecord's message attribute. Currently, the useful
    attributes in a LogRecord are described by:

    %(name)s            Name of the logger (logging channel)
    %(levelno)s         Numeric logging level for the message (DEBUG, INFO,
                        WARNING, ERROR, CRITICAL)
    %(levelname)s       Text logging level for the message ("DEBUG", "INFO",
                        "WARNING", "ERROR", "CRITICAL")
    %(pathname)s        Full pathname of the source file where the logging
                        call was issued (if available)
    %(filename)s        Filename portion of pathname
    %(module)s          Module (name portion of filename)
    %(lineno)d          Source line number where the logging call was issued
                        (if available)
    %(funcName)s        Function name
    %(created)f         Time when the LogRecord was created (time.time()
                        return value)
    %(asctime)s         Textual time when the LogRecord was created
    %(msecs)d           Millisecond portion of the creation time
    %(relativeCreated)d Time in milliseconds when the LogRecord was created,
                        relative to the time the logging module was loaded
                        (typically at application startup time)
    %(thread)d          Thread ID (if available)
    %(threadName)s      Thread name (if available)
    %(process)d         Process ID (if available)
    %(message)s         The result of record.getMessage(), computed just as
                        the record is emitted
    c         C   s(   | r | |  _  n	 d |  _  | |  _ d S(   s8  
        Initialize the formatter with specified format strings.

        Initialize the formatter either with the specified format string, or a
        default as described above. Allow for specialized date formatting with
        the optional datefmt argument (if omitted, you get the ISO8601 format).
        s   %(message)sN(   t   _fmtt   datefmt(   Ri   t   fmtR{   (    (    s&   /usr/lib/python2.7/logging/__init__.pyRm   á  s    	c         C   sV   |  j  | j É } | r- t j | | É } n% t j d | É } d | | j f } | S(   s  
        Return the creation time of the specified LogRecord as formatted text.

        This method should be called from format() by a formatter which
        wants to make use of a formatted time. This method can be overridden
        in formatters to provide for any specific requirement, but the
        basic behaviour is as follows: if datefmt (a string) is specified,
        it is used with time.strftime() to format the creation time of the
        record. Otherwise, the ISO8601 format is used. The resulting
        string is returned. This function uses a user-configurable function
        to convert the creation time to a tuple. By default, time.localtime()
        is used; to change this for a particular formatter instance, set the
        'converter' attribute to a function with the same signature as
        time.localtime() or time.gmtime(). To change it for all formatters,
        for example if you want all logging times to be shown in GMT,
        set the 'converter' attribute in the Formatter class.
        s   %Y-%m-%d %H:%M:%Ss   %s,%03d(   t	   converterRW   RB   t   strftimeRX   (   Ri   t   recordR{   Rk   t   st   t(    (    s&   /usr/lib/python2.7/logging/__init__.pyt
   formatTimeï  s    c         C   sh   t  j É  } t j | d | d | d d | É | j É  } | j É  | d d k rd | d  } n  | S(   sß   
        Format and return the specified exception information as a string.

        This default implementation just uses
        traceback.print_exception()
        i    i   i   iˇˇˇˇs   
N(   t	   cStringIOt   StringIOt	   tracebackt   print_exceptionRS   t   getvaluet   close(   Ri   t   eit   sioRÄ   (    (    s&   /usr/lib/python2.7/logging/__init__.pyt   formatExceptionØ  s    %
c         C   s   |  j  j d É d k S(   sK   
        Check if the format uses the creation time of the record.
        s
   %(asctime)i    (   Rz   t   find(   Ri   (    (    s&   /usr/lib/python2.7/logging/__init__.pyt   usesTimeæ  s    c         C   sA  | j  É  | _ |  j É  r6 |  j | |  j É | _ n  y |  j | j } WnV t k
 r¢ } y) | j	 j
 d É | _	 |  j | j } Wq£ t k
 rû | Ç q£ Xn X| j r– | j s– |  j | j É | _ q– n  | j r=| d d k rˆ | d } n  y | | j } Wq=t k
 r9| | j j
 t j É  d É } q=Xn  | S(   sz  
        Format the specified record as text.

        The record's attribute dictionary is used as the operand to a
        string formatting operation which yields the returned string.
        Before formatting the dictionary, a couple of preparatory steps
        are carried out. The message attribute of the record is computed
        using LogRecord.getMessage(). If the formatting string uses the
        time (as determined by a call to usesTime(), formatTime() is
        called to format the event time. If there is exception information,
        it is formatted using formatException() and appended to the message.
        s   utf-8iˇˇˇˇs   
t   replace(   Rr   t   messageRç   RÇ   R{   t   asctimeRz   Rw   t   UnicodeDecodeErrorRC   t   decodeR(   RT   Rã   Rq   R'   t   getfilesystemencoding(   Ri   R   RÄ   t   e(    (    s&   /usr/lib/python2.7/logging/__init__.pyt   formatƒ  s.    			N(   Rs   Rt   Ru   RB   t	   localtimeR}   RS   Rm   RÇ   Rã   Rç   Rï   (    (    (    s&   /usr/lib/python2.7/logging/__init__.pyR   [  s   (			c           B   s5   e  Z d  Z d d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   sB   
    A formatter suitable for formatting a number of records.
    c         C   s   | r | |  _  n	 t |  _  d S(   sm   
        Optionally specify a formatter which will be used to format each
        individual record.
        N(   t   linefmtt   _defaultFormatter(   Ri   Ró   (    (    s&   /usr/lib/python2.7/logging/__init__.pyRm   ˚  s    c         C   s   d S(   sE   
        Return the header string for the specified records.
        Rv   (    (   Ri   t   records(    (    s&   /usr/lib/python2.7/logging/__init__.pyt   formatHeader  s    c         C   s   d S(   sE   
        Return the footer string for the specified records.
        Rv   (    (   Ri   Rô   (    (    s&   /usr/lib/python2.7/logging/__init__.pyt   formatFooter  s    c         C   sl   d } t  | É d k rh | |  j | É } x$ | D] } | |  j j | É } q2 W| |  j | É } n  | S(   sQ   
        Format the specified records and return the result as a string.
        Rv   i    (   RE   Rö   Ró   Rï   Rõ   (   Ri   Rô   R:   R   (    (    s&   /usr/lib/python2.7/logging/__init__.pyRï     s    N(   Rs   Rt   Ru   RS   Rm   Rö   Rõ   Rï   (    (    (    s&   /usr/lib/python2.7/logging/__init__.pyR   ˜  s
   
		c           B   s#   e  Z d  Z d d Ñ Z d Ñ  Z RS(   sˆ  
    Filter instances are used to perform arbitrary filtering of LogRecords.

    Loggers and Handlers can optionally use Filter instances to filter
    records as desired. The base filter class only allows events which are
    below a certain point in the logger hierarchy. For example, a filter
    initialized with "A.B" will allow events logged by loggers "A.B",
    "A.B.C", "A.B.C.D", "A.B.D" etc. but not "A.BB", "B.A.B" etc. If
    initialized with the empty string, all events are passed.
    Rv   c         C   s   | |  _  t | É |  _ d S(   sÊ   
        Initialize a filter.

        Initialize with the name of the logger which, together with its
        children, will have its events allowed through the filter. If no
        name is specified, allow every event.
        N(   RC   RE   t   nlen(   Ri   RC   (    (    s&   /usr/lib/python2.7/logging/__init__.pyRm   ,  s    	c         C   se   |  j  d k r d S|  j | j k r) d S| j j |  j d |  j  É d k rQ d S| j |  j  d k S(   s⁄   
        Determine if the specified record is to be logged.

        Is the specified record to be logged? Returns 0 for no, nonzero for
        yes. If deemed appropriate, the record may be modified in-place.
        i    i   t   .(   Rú   RC   Rå   (   Ri   R   (    (    s&   /usr/lib/python2.7/logging/__init__.pyt   filter7  s    $(   Rs   Rt   Ru   Rm   Rû   (    (    (    s&   /usr/lib/python2.7/logging/__init__.pyR   !  s   
t   Filtererc           B   s2   e  Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   s[   
    A base class for loggers and handlers which allows them to share
    common code.
    c         C   s   g  |  _  d S(   sE   
        Initialize the list of filters to be an empty list.
        N(   t   filters(   Ri   (    (    s&   /usr/lib/python2.7/logging/__init__.pyRm   K  s    c         C   s&   | |  j  k r" |  j  j | É n  d S(   s;   
        Add the specified filter to this handler.
        N(   R†   t   append(   Ri   Rû   (    (    s&   /usr/lib/python2.7/logging/__init__.pyt	   addFilterQ  s    c         C   s&   | |  j  k r" |  j  j | É n  d S(   s@   
        Remove the specified filter from this handler.
        N(   R†   t   remove(   Ri   Rû   (    (    s&   /usr/lib/python2.7/logging/__init__.pyt   removeFilterX  s    c         C   s7   d } x* |  j  D] } | j | É s d } Pq q W| S(   s  
        Determine if a record is loggable by consulting all the filters.

        The default is to allow the record to be logged; any filter can veto
        this and the record is then dropped. Returns a zero value if a record
        is to be dropped, else non-zero.
        i   i    (   R†   Rû   (   Ri   R   R:   t   f(    (    s&   /usr/lib/python2.7/logging/__init__.pyRû   _  s    (   Rs   Rt   Ru   Rm   R¢   R§   Rû   (    (    (    s&   /usr/lib/python2.7/logging/__init__.pyRü   F  s
   			c         C   s_   t  t t } } } | r[ | r[ | r[ | É  z  |  | k rL | j |  É n  Wd | É  Xn  d S(   sD   
    Remove a handler reference from the internal cleanup list.
    N(   R1   R2   t   _handlerListR£   (   t   wrR=   R>   t   handlers(    (    s&   /usr/lib/python2.7/logging/__init__.pyt   _removeHandlerRefu  s    c         C   s3   t  É  z t j t j |  t É É Wd t É  Xd S(   sL   
    Add a handler to the internal cleanup list using a weak reference.
    N(   R1   R¶   R°   t   weakreft   refR©   R2   (   t   handler(    (    s&   /usr/lib/python2.7/logging/__init__.pyt   _addHandlerRefÜ  s    c           B   sû   e  Z d  Z e d Ñ Z d Ñ  Z d Ñ  Z e e e É Z d Ñ  Z	 d Ñ  Z
 d Ñ  Z d Ñ  Z d Ñ  Z d	 Ñ  Z d
 Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   sq  
    Handler instances dispatch logging events to specific destinations.

    The base handler class. Acts as a placeholder which defines the Handler
    interface. Handlers can optionally use Formatter instances to format
    records as desired. By default, no formatter is specified; in this case,
    the 'raw' message as determined by record.message is logged.
    c         C   sF   t  j |  É d |  _ t | É |  _ d |  _ t |  É |  j É  d S(   sz   
        Initializes the instance - basically setting the formatter to None
        and the filter list to empty.
        N(	   Rü   Rm   RS   t   _nameR;   R0   t	   formatterR≠   t
   createLock(   Ri   R0   (    (    s&   /usr/lib/python2.7/logging/__init__.pyRm   ô  s    		
c         C   s   |  j  S(   N(   RÆ   (   Ri   (    (    s&   /usr/lib/python2.7/logging/__init__.pyt   get_name¶  s    c         C   sR   t  É  z< |  j t k r& t |  j =n  | |  _ | rB |  t | <n  Wd  t É  Xd  S(   N(   R1   RÆ   t	   _handlersR2   (   Ri   RC   (    (    s&   /usr/lib/python2.7/logging/__init__.pyt   set_name©  s    	c         C   s%   t  r t j É  |  _ n	 d |  _ d S(   sU   
        Acquire a thread lock for serializing access to the underlying I/O.
        N(   R\   R^   t   RLockt   lockRS   (   Ri   (    (    s&   /usr/lib/python2.7/logging/__init__.pyR∞   ∂  s    c         C   s   |  j  r |  j  j É  n  d S(   s.   
        Acquire the I/O thread lock.
        N(   Rµ   R=   (   Ri   (    (    s&   /usr/lib/python2.7/logging/__init__.pyR=   ø  s    	c         C   s   |  j  r |  j  j É  n  d S(   s.   
        Release the I/O thread lock.
        N(   Rµ   R>   (   Ri   (    (    s&   /usr/lib/python2.7/logging/__init__.pyR>   ∆  s    	c         C   s   t  | É |  _ d S(   s8   
        Set the logging level of this handler.
        N(   R;   R0   (   Ri   R0   (    (    s&   /usr/lib/python2.7/logging/__init__.pyt   setLevelÕ  s    c         C   s(   |  j  r |  j  } n t } | j | É S(   sì   
        Format the specified record.

        If a formatter is set, use it. Otherwise, use the default formatter
        for the module.
        (   RØ   Rò   Rï   (   Ri   R   R|   (    (    s&   /usr/lib/python2.7/logging/__init__.pyRï   ”  s    	c         C   s   t  d É Ç d S(   s√   
        Do whatever it takes to actually log the specified logging record.

        This version is intended to be implemented by subclasses and so
        raises a NotImplementedError.
        s.   emit must be implemented by Handler subclassesN(   t   NotImplementedError(   Ri   R   (    (    s&   /usr/lib/python2.7/logging/__init__.pyt   emit‡  s    c         C   sE   |  j  | É } | rA |  j É  z |  j | É Wd |  j É  Xn  | S(   s<  
        Conditionally emit the specified logging record.

        Emission depends on filters which may have been added to the handler.
        Wrap the actual emission of the record with acquisition/release of
        the I/O thread lock. Returns whether the filter passed the record for
        emission.
        N(   Rû   R=   R∏   R>   (   Ri   R   R:   (    (    s&   /usr/lib/python2.7/logging/__init__.pyt   handleÍ  s    	
c         C   s   | |  _  d S(   s5   
        Set the formatter for this handler.
        N(   RØ   (   Ri   R|   (    (    s&   /usr/lib/python2.7/logging/__init__.pyt   setFormatter¸  s    c         C   s   d S(   sô   
        Ensure all logging output has been flushed.

        This version does nothing and is intended to be implemented by
        subclasses.
        N(    (   Ri   (    (    s&   /usr/lib/python2.7/logging/__init__.pyt   flush  s    c         C   s?   t  É  z) |  j r/ |  j t k r/ t |  j =n  Wd t É  Xd S(   s%  
        Tidy up any resources used by the handler.

        This version removes the handler from an internal map of handlers,
        _handlers, which is used for handler lookup by name. Subclasses
        should ensure that this gets called from overridden close()
        methods.
        N(   R1   RÆ   R≤   R2   (   Ri   (    (    s&   /usr/lib/python2.7/logging/__init__.pyRà     s
    
c         C   sç   t  râ t j râ t j É  } zd yL t j | d | d | d d t j É t j j d | j | j	 f É Wn t
 k
 r} n XWd ~ Xn  d S(   sD  
        Handle errors which occur during an emit() call.

        This method should be called from handlers when an exception is
        encountered during an emit() call. If raiseExceptions is false,
        exceptions get silently ignored. This is what is mostly wanted
        for a logging system - most users will not care about errors in
        the logging system, they are more interested in application errors.
        You could, however, replace this with a custom handler if you wish.
        The record which was being processed is passed in to this method.
        i    i   i   s   Logged from file %s, line %s
N(   t   raiseExceptionsR'   t   stderrR(   RÖ   RÜ   RS   t   writeRO   RU   t   IOError(   Ri   R   Râ   (    (    s&   /usr/lib/python2.7/logging/__init__.pyt   handleError  s     (   Rs   Rt   Ru   R   Rm   R±   R≥   t   propertyRC   R∞   R=   R>   R∂   Rï   R∏   Rπ   R∫   Rª   Rà   R¿   (    (    (    s&   /usr/lib/python2.7/logging/__init__.pyR	   ê  s    									
					c           B   s,   e  Z d  Z d d Ñ Z d Ñ  Z d Ñ  Z RS(   sæ   
    A handler class which writes logging records, appropriately formatted,
    to a stream. Note that this class does not close the stream, as
    sys.stdout or sys.stderr may be used.
    c         C   s2   t  j |  É | d k r% t j } n  | |  _ d S(   sb   
        Initialize the handler.

        If stream is not specified, sys.stderr is used.
        N(   R	   Rm   RS   R'   RΩ   t   stream(   Ri   R¬   (    (    s&   /usr/lib/python2.7/logging/__init__.pyRm   ;  s    c         C   sK   |  j  É  z/ |  j r8 t |  j d É r8 |  j j É  n  Wd |  j É  Xd S(   s%   
        Flushes the stream.
        Rª   N(   R=   R¬   Rg   Rª   R>   (   Ri   (    (    s&   /usr/lib/python2.7/logging/__init__.pyRª   F  s
    
c         C   s-  y˘ |  j  | É } |  j } d } t s; | j | | É n≥ yÖ t | t É rÆ t | d d É rÆ d } y | j | | É Wqø t k
 r™ | j | | j	 | j
 É É qø Xn | j | | É Wn+ t k
 rÌ | j | | j	 d É É n X|  j É  Wn- t t f k
 rÇ  n |  j | É n Xd S(   s´  
        Emit a record.

        If a formatter is specified, it is used to format the record.
        The record is then written to the stream with a trailing newline.  If
        exception information is present, it is formatted using
        traceback.print_exception and appended to the stream.  If the stream
        has an 'encoding' attribute, it is used to determine how to do the
        output to the stream.
        s   %s
t   encodingu   %s
s   UTF-8N(   Rï   R¬   Ro   Ræ   R4   t   unicodet   getattrRS   t   UnicodeEncodeErrort   encodeR√   Rq   Rª   t   KeyboardInterruptt
   SystemExitR¿   (   Ri   R   RD   R¬   t   fst   ufs(    (    s&   /usr/lib/python2.7/logging/__init__.pyR∏   Q  s,    	$N(   Rs   Rt   Ru   RS   Rm   Rª   R∏   (    (    (    s&   /usr/lib/python2.7/logging/__init__.pyR   4  s   	c           B   s;   e  Z d  Z d d d d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   sO   
    A handler class which writes formatted logging records to disk files.
    t   ai    c         C   s~   t  d k r d } n  t j j | É |  _ | |  _ | |  _ | |  _ | rd t	 j
 |  É d |  _ n t j
 |  |  j É  É d S(   sO   
        Open the specified file and use it as the stream for logging.
        N(   t   codecsRS   RL   RM   t   abspatht   baseFilenamet   modeR√   t   delayR	   Rm   R¬   R   t   _open(   Ri   RO   R–   R√   R—   (    (    s&   /usr/lib/python2.7/logging/__init__.pyRm     s    				c         C   sÅ   |  j  É  ze zP |  j r\ z |  j É  Wd |  j } d |  _ t | d É rX | j É  n  Xn  Wd t j |  É XWd |  j É  Xd S(   s$   
        Closes the stream.
        NRà   (   R=   R¬   Rª   RS   Rg   Rà   R   R>   (   Ri   R¬   (    (    s&   /usr/lib/python2.7/logging/__init__.pyRà   ì  s    
			c         C   sI   |  j  d k r' t |  j |  j É } n t j |  j |  j |  j  É } | S(   sx   
        Open the current base file with the (original) mode and encoding.
        Return the resulting stream.
        N(   R√   RS   t   openRœ   R–   RÕ   (   Ri   R¬   (    (    s&   /usr/lib/python2.7/logging/__init__.pyR“   ©  s    c         C   s5   |  j  d k r! |  j É  |  _  n  t j |  | É d S(   sÆ   
        Emit a record.

        If the stream was not opened because 'delay' was specified in the
        constructor, open it before calling the superclass's emit.
        N(   R¬   RS   R“   R   R∏   (   Ri   R   (    (    s&   /usr/lib/python2.7/logging/__init__.pyR∏   ¥  s    N(   Rs   Rt   Ru   RS   Rm   Rà   R“   R∏   (    (    (    s&   /usr/lib/python2.7/logging/__init__.pyR   {  s
   		t   PlaceHolderc           B   s    e  Z d  Z d Ñ  Z d Ñ  Z RS(   s„   
    PlaceHolder instances are used in the Manager logger hierarchy to take
    the place of nodes for which no loggers have been defined. This class is
    intended for internal use only and not as part of the public API.
    c         C   s   i d | 6|  _ d S(   sY   
        Initialize with the specified logger being a child of this placeholder.
        N(   RS   t	   loggerMap(   Ri   t   alogger(    (    s&   /usr/lib/python2.7/logging/__init__.pyRm   …  s    c         C   s#   | |  j  k r d |  j  | <n  d S(   sJ   
        Add the specified logger as a child of this placeholder.
        N(   R’   RS   (   Ri   R÷   (    (    s&   /usr/lib/python2.7/logging/__init__.pyR°   –  s    (   Rs   Rt   Ru   Rm   R°   (    (    (    s&   /usr/lib/python2.7/logging/__init__.pyR‘   √  s   	c         C   s>   |  t  k r4 t |  t  É s4 t d |  j É Ç q4 n  |  a d S(   s«   
    Set the class to be used when instantiating a logger. The class should
    define __init__() such that only a name argument is required, and the
    __init__() should call Logger.__init__()
    s(   logger not derived from logging.Logger: N(   R   t
   issubclassR9   Rs   t   _loggerClass(   t   klass(    (    s&   /usr/lib/python2.7/logging/__init__.pyR"   ﬁ  s
    c           C   s   t  S(   sB   
    Return the class to be used when instantiating a logger.
    (   Rÿ   (    (    (    s&   /usr/lib/python2.7/logging/__init__.pyR   Î  s    t   Managerc           B   s;   e  Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   st   
    There is [under normal circumstances] just one Manager instance, which
    holds the hierarchy of loggers.
    c         C   s1   | |  _  d |  _ d |  _ i  |  _ d |  _ d S(   sT   
        Initialize the manager with the root node of the logger hierarchy.
        i    N(   t   rootR   t   emittedNoHandlerWarningt
   loggerDictRS   t   loggerClass(   Ri   t   rootnode(    (    s&   /usr/lib/python2.7/logging/__init__.pyRm   ˜  s
    				c         C   s  d } t | t É s$ t d É Ç n  t | t É rE | j d É } n  t É  zª | |  j k rŒ |  j | } t | t É r| } |  j	 på t
 | É } |  | _ | |  j | <|  j | | É |  j | É qn8 |  j	 p⁄ t
 | É } |  | _ | |  j | <|  j | É Wd t É  X| S(   s·  
        Get a logger with the specified name (channel name), creating it
        if it doesn't yet exist. This name is a dot-separated hierarchical
        name, such as "a", "a.b", "a.b.c" or similar.

        If a PlaceHolder existed for the specified name [i.e. the logger
        didn't exist but a child of it did], replace it with the created
        logger and fix up the parent/child references which pointed to the
        placeholder to now point to the logger.
        s'   A logger name must be string or Unicodes   utf-8N(   RS   R4   Rp   R9   Rƒ   R«   R1   R›   R‘   Rﬁ   Rÿ   t   managert   _fixupChildrent   _fixupParentsR2   (   Ri   RC   R:   t   ph(    (    s&   /usr/lib/python2.7/logging/__init__.pyR     s,    		c         C   sA   | t  k r4 t | t  É s4 t d | j É Ç q4 n  | |  _ d S(   sY   
        Set the class to be used when instantiating a logger with this Manager.
        s(   logger not derived from logging.Logger: N(   R   R◊   R9   Rs   Rﬁ   (   Ri   RŸ   (    (    s&   /usr/lib/python2.7/logging/__init__.pyR"   %  s
    c         C   sÊ   | j  } | j d É } d } x¶ | d k r∆ | r∆ | |  } | |  j k rc t | É |  j | <nG |  j | } t | t É rà | } n" t | t É sù t Ç | j | É | j d d | d É } q! W| sŸ |  j	 } n  | | _
 d S(   sô   
        Ensure that there are either loggers or placeholders all the way
        from the specified logger to the root of the logger hierarchy.
        Rù   i    i   N(   RC   t   rfindRS   R›   R‘   R4   R   t   AssertionErrorR°   R€   t   parent(   Ri   R÷   RC   t   iR:   t   substrt   obj(    (    s&   /usr/lib/python2.7/logging/__init__.pyR‚   /  s     	
	c         C   sa   | j  } t | É } xE | j j É  D]4 } | j j  |  | k r% | j | _ | | _ q% q% Wd S(   sk   
        Ensure that children of the placeholder ph are connected to the
        specified logger.
        N(   RC   RE   R’   t   keysRÊ   (   Ri   R„   R÷   RC   t   namelent   c(    (    s&   /usr/lib/python2.7/logging/__init__.pyR·   G  s    	(   Rs   Rt   Ru   Rm   R   R"   R‚   R·   (    (    (    s&   /usr/lib/python2.7/logging/__init__.pyR⁄   Ú  s   	
	$	
	c           B   s‘   e  Z d  Z e d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z e Z	 d Ñ  Z
 d Ñ  Z d Ñ  Z e Z d	 Ñ  Z d
 Ñ  Z d d d Ñ Z d d d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   sr  
    Instances of the Logger class represent a single logging channel. A
    "logging channel" indicates an area of an application. Exactly how an
    "area" is defined is up to the application developer. Since an
    application can have any number of areas, logging channels are identified
    by a unique string. Application areas can be nested (e.g. an area
    of "input processing" might include sub-areas "read CSV files", "read
    XLS files" and "read Gnumeric files"). To cater for this natural nesting,
    channel names are organized into a namespace hierarchy where levels are
    separated by periods, much like the Java or Python package namespace. So
    in the instance given above, channel names might be "input" for the upper
    level, and "input.csv", "input.xls" and "input.gnu" for the sub-levels.
    There is no arbitrary limit to the depth of nesting.
    c         C   sM   t  j |  É | |  _ t | É |  _ d |  _ d |  _ g  |  _ d |  _	 d S(   sJ   
        Initialize the logger with a name and an optional level.
        i   i    N(
   Rü   Rm   RC   R;   R0   RS   RÊ   t	   propagateR®   t   disabled(   Ri   RC   R0   (    (    s&   /usr/lib/python2.7/logging/__init__.pyRm   g  s    				c         C   s   t  | É |  _ d S(   s7   
        Set the logging level of this logger.
        N(   R;   R0   (   Ri   R0   (    (    s&   /usr/lib/python2.7/logging/__init__.pyR∂   s  s    c         O   s,   |  j  t É r( |  j t | | | ç n  d S(   s   
        Log 'msg % args' with severity 'DEBUG'.

        To pass exception information, use the keyword argument exc_info with
        a true value, e.g.

        logger.debug("Houston, we have a %s", "thorny problem", exc_info=1)
        N(   t   isEnabledForR   t   _log(   Ri   RD   RH   t   kwargs(    (    s&   /usr/lib/python2.7/logging/__init__.pyR   y  s    	c         O   s,   |  j  t É r( |  j t | | | ç n  d S(   sÛ   
        Log 'msg % args' with severity 'INFO'.

        To pass exception information, use the keyword argument exc_info with
        a true value, e.g.

        logger.info("Houston, we have a %s", "interesting problem", exc_info=1)
        N(   RÔ   R
   R   (   Ri   RD   RH   RÒ   (    (    s&   /usr/lib/python2.7/logging/__init__.pyR   Ö  s    	c         O   s,   |  j  t É r( |  j t | | | ç n  d S(   sˆ   
        Log 'msg % args' with severity 'WARNING'.

        To pass exception information, use the keyword argument exc_info with
        a true value, e.g.

        logger.warning("Houston, we have a %s", "bit of a problem", exc_info=1)
        N(   RÔ   R   R   (   Ri   RD   RH   RÒ   (    (    s&   /usr/lib/python2.7/logging/__init__.pyR$   ë  s    	c         O   s,   |  j  t É r( |  j t | | | ç n  d S(   sÔ   
        Log 'msg % args' with severity 'ERROR'.

        To pass exception information, use the keyword argument exc_info with
        a true value, e.g.

        logger.error("Houston, we have a %s", "major problem", exc_info=1)
        N(   RÔ   R   R   (   Ri   RD   RH   RÒ   (    (    s&   /usr/lib/python2.7/logging/__init__.pyR   ü  s    	c         O   s!   d | d <|  j  | | | é d S(   sU   
        Convenience method for logging an ERROR with exception information.
        i   R(   N(   R   (   Ri   RD   RH   RÒ   (    (    s&   /usr/lib/python2.7/logging/__init__.pyR   ´  s    
c         O   s,   |  j  t É r( |  j t | | | ç n  d S(   sˆ   
        Log 'msg % args' with severity 'CRITICAL'.

        To pass exception information, use the keyword argument exc_info with
        a true value, e.g.

        logger.critical("Houston, we have a %s", "major disaster", exc_info=1)
        N(   RÔ   R   R   (   Ri   RD   RH   RÒ   (    (    s&   /usr/lib/python2.7/logging/__init__.pyR   ≤  s    	c         O   sW   t  | t É s+ t r$ t d É Ç q+ d Sn  |  j | É rS |  j | | | | ç n  d S(   s¸   
        Log 'msg % args' with the integer severity 'level'.

        To pass exception information, use the keyword argument exc_info with
        a true value, e.g.

        logger.log(level, "We have a %s", "mysterious problem", exc_info=1)
        s   level must be an integerN(   R4   R5   Rº   R9   RÔ   R   (   Ri   R0   RD   RH   RÒ   (    (    s&   /usr/lib/python2.7/logging/__init__.pyR    ¿  s    	c         C   sì   t  É  } | d k	 r! | j } n  d } xe t | d É ré | j } t j j | j É } | t	 k rr | j } q* n  | j | j
 | j f } Pq* W| S(   sÖ   
        Find the stack frame of the caller so that we can note the source
        file name, line number and function name.
        s   (unknown file)i    s   (unknown function)t   f_codeN(   s   (unknown file)i    s   (unknown function)(   R+   RS   R*   Rg   RÚ   RL   RM   t   normcaset   co_filenamet   _srcfilet   f_linenot   co_name(   Ri   R•   R:   t   coRO   (    (    s&   /usr/lib/python2.7/logging/__init__.pyt
   findCaller—  s    			c
      	   C   sÑ   t  | | | | | | | | É }
 |	 d k	 rÄ xP |	 D]E } | d k sU | |
 j k rh t d | É Ç n  |	 | |
 j | <q4 Wn  |
 S(   sr   
        A factory method which can be overridden in subclasses to create
        specialized LogRecords.
        Rè   Rê   s$   Attempt to overwrite %r in LogRecordN(   Rè   Rê   (   R   RS   Rw   t   KeyError(   Ri   RC   R0   t   fnt   lnoRD   RH   R(   Rj   t   extraR:   t   key(    (    s&   /usr/lib/python2.7/logging/__init__.pyt
   makeRecordÊ  s    !c   
   
   C   s∂   t  rE y |  j É  \ } } } WqT t k
 rA d \ } } } qT Xn d \ } } } | r{ t | t É s{ t j É  } q{ n  |  j |  j | | | | | | | | É	 }	 |  j	 |	 É d S(   sí   
        Low-level logging routine which creates a LogRecord and then calls
        all the handlers of this logger to handle the record.
        s   (unknown file)i    s   (unknown function)N(   s   (unknown file)i    s   (unknown function)(   s   (unknown file)i    s   (unknown function)(
   Rı   R˘   R8   R4   t   tupleR'   R(   Rˇ   RC   Rπ   (
   Ri   R0   RD   RH   R(   R˝   R˚   R¸   Rj   R   (    (    s&   /usr/lib/python2.7/logging/__init__.pyR   Û  s    *c         C   s-   |  j  r) |  j | É r) |  j | É n  d S(   s’   
        Call the handlers for the specified record.

        This method is used for unpickled records received from a socket, as
        well as those created locally. Logger-level filtering is applied.
        N(   RÓ   Rû   t   callHandlers(   Ri   R   (    (    s&   /usr/lib/python2.7/logging/__init__.pyRπ     s    c         C   s<   t  É  z& | |  j k r, |  j j | É n  Wd t É  Xd S(   s;   
        Add the specified handler to this logger.
        N(   R1   R®   R°   R2   (   Ri   t   hdlr(    (    s&   /usr/lib/python2.7/logging/__init__.pyt
   addHandler  s
    c         C   s<   t  É  z& | |  j k r, |  j j | É n  Wd t É  Xd S(   s@   
        Remove the specified handler from this logger.
        N(   R1   R®   R£   R2   (   Ri   R  (    (    s&   /usr/lib/python2.7/logging/__init__.pyt   removeHandler  s
    c         C   sΩ   |  } d } xe | rs x= | j  D]2 } | d } | j | j k r | j | É q q W| j sg d } q | j } q W| d k rπ t rπ |  j j	 rπ t
 j j d |  j É d |  j _	 n  d S(   sú  
        Pass a record to all relevant handlers.

        Loop through all handlers for this logger and its parents in the
        logger hierarchy. If no handler was found, output a one-off error
        message to sys.stderr. Stop searching up the hierarchy whenever a
        logger with the "propagate" attribute set to zero is found - that
        will be the last logger whose handlers are called.
        i    i   s+   No handlers could be found for logger "%s"
N(   R®   RJ   R0   Rπ   RÌ   RS   RÊ   Rº   R‡   R‹   R'   RΩ   Ræ   RC   (   Ri   R   RÏ   t   foundR  (    (    s&   /usr/lib/python2.7/logging/__init__.pyR  (  s    
	
		c         C   s0   |  } x# | r+ | j  r | j  S| j } q	 Wt S(   sœ   
        Get the effective level for this logger.

        Loop through this logger and its parents in the logger hierarchy,
        looking for a non-zero logging level. Return the first one found.
        (   R0   RÊ   R   (   Ri   t   logger(    (    s&   /usr/lib/python2.7/logging/__init__.pyt   getEffectiveLevelB  s    		c         C   s&   |  j  j | k r d S| |  j É  k S(   s;   
        Is this logger enabled for level 'level'?
        i    (   R‡   R   R  (   Ri   R0   (    (    s&   /usr/lib/python2.7/logging/__init__.pyRÔ   P  s    c         C   s:   |  j  |  k	 r* d j |  j | f É } n  |  j j | É S(   sb  
        Get a logger which is a descendant to this one.

        This is a convenience method, such that

        logging.getLogger('abc').getChild('def.ghi')

        is the same as

        logging.getLogger('abc.def.ghi')

        It's useful, for example, when the parent logger is named using
        __name__ rather than a literal string.
        Rù   (   R€   t   joinRC   R‡   R   (   Ri   t   suffix(    (    s&   /usr/lib/python2.7/logging/__init__.pyt   getChildX  s    N(   Rs   Rt   Ru   R   Rm   R∂   R   R   R$   R#   R   R   R   R   R    R˘   RS   Rˇ   R   Rπ   R  R  R  R  RÔ   R
  (    (    (    s&   /usr/lib/python2.7/logging/__init__.pyR   X  s,   										
					t
   RootLoggerc           B   s   e  Z d  Z d Ñ  Z RS(   s™   
    A root logger is not that different to any other logger, except that
    it must have a logging level and there is only one instance of it in
    the hierarchy.
    c         C   s   t  j |  d | É d S(   s=   
        Initialize the logger with the name "root".
        R€   N(   R   Rm   (   Ri   R0   (    (    s&   /usr/lib/python2.7/logging/__init__.pyRm   q  s    (   Rs   Rt   Ru   Rm   (    (    (    s&   /usr/lib/python2.7/logging/__init__.pyR  k  s   c           B   sh   e  Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d	 Ñ  Z d
 Ñ  Z RS(   so   
    An adapter for loggers which makes it easier to specify contextual
    information in logging output.
    c         C   s   | |  _  | |  _ d S(   sx  
        Initialize the adapter with a logger and a dict-like object which
        provides contextual information. This constructor signature allows
        easy stacking of LoggerAdapters, if so desired.

        You can effectively pass keyword arguments as shown in the
        following example:

        adapter = LoggerAdapter(someLogger, dict(p1=v1, p2="v2"))
        N(   R  R˝   (   Ri   R  R˝   (    (    s&   /usr/lib/python2.7/logging/__init__.pyRm     s    	c         C   s   |  j  | d <| | f S(   s¢  
        Process the logging message and keyword arguments passed in to
        a logging call to insert contextual information. You can either
        manipulate the message itself, the keyword args or both. Return
        the message and kwargs modified (or not) to suit your needs.

        Normally, you'll only need to override this one method in a
        LoggerAdapter subclass for your specific needs.
        R˝   (   R˝   (   Ri   RD   RÒ   (    (    s&   /usr/lib/python2.7/logging/__init__.pyRh   ç  s    
c         O   s2   |  j  | | É \ } } |  j j | | | é d S(   sâ   
        Delegate a debug call to the underlying logger, after adding
        contextual information from this adapter instance.
        N(   Rh   R  R   (   Ri   RD   RH   RÒ   (    (    s&   /usr/lib/python2.7/logging/__init__.pyR   ö  s    c         O   s2   |  j  | | É \ } } |  j j | | | é d S(   sâ   
        Delegate an info call to the underlying logger, after adding
        contextual information from this adapter instance.
        N(   Rh   R  R   (   Ri   RD   RH   RÒ   (    (    s&   /usr/lib/python2.7/logging/__init__.pyR   ¢  s    c         O   s2   |  j  | | É \ } } |  j j | | | é d S(   sã   
        Delegate a warning call to the underlying logger, after adding
        contextual information from this adapter instance.
        N(   Rh   R  R$   (   Ri   RD   RH   RÒ   (    (    s&   /usr/lib/python2.7/logging/__init__.pyR$   ™  s    c         O   s2   |  j  | | É \ } } |  j j | | | é d S(   sä   
        Delegate an error call to the underlying logger, after adding
        contextual information from this adapter instance.
        N(   Rh   R  R   (   Ri   RD   RH   RÒ   (    (    s&   /usr/lib/python2.7/logging/__init__.pyR   ≤  s    c         O   s<   |  j  | | É \ } } d | d <|  j j | | | é d S(   sé   
        Delegate an exception call to the underlying logger, after adding
        contextual information from this adapter instance.
        i   R(   N(   Rh   R  R   (   Ri   RD   RH   RÒ   (    (    s&   /usr/lib/python2.7/logging/__init__.pyR   ∫  s    
c         O   s2   |  j  | | É \ } } |  j j | | | é d S(   så   
        Delegate a critical call to the underlying logger, after adding
        contextual information from this adapter instance.
        N(   Rh   R  R   (   Ri   RD   RH   RÒ   (    (    s&   /usr/lib/python2.7/logging/__init__.pyR   √  s    c         O   s5   |  j  | | É \ } } |  j j | | | | é d S(   sá   
        Delegate a log call to the underlying logger, after adding
        contextual information from this adapter instance.
        N(   Rh   R  R    (   Ri   R0   RD   RH   RÒ   (    (    s&   /usr/lib/python2.7/logging/__init__.pyR    À  s    c         C   s   |  j  j | É S(   sR   
        See if the underlying logger is enabled for the specified level.
        (   R  RÔ   (   Ri   R0   (    (    s&   /usr/lib/python2.7/logging/__init__.pyRÔ   ”  s    (   Rs   Rt   Ru   Rm   Rh   R   R   R$   R   R   R   R    RÔ   (    (    (    s&   /usr/lib/python2.7/logging/__init__.pyR   y  s   										s"   %(levelname)s:%(name)s:%(message)sc    	      K   s˛   t  É  zË t t j É d k rÓ |  j d É } | rX |  j d d É } t | | É } n |  j d É } t | É } |  j d t É } |  j d d	 É } t	 | | É } | j
 | É t j | É |  j d É } | d	 k	 rÓ t j | É qÓ n  Wd	 t É  Xd	 S(
   s˝  
    Do basic configuration for the logging system.

    This function does nothing if the root logger already has handlers
    configured. It is a convenience method intended for use by simple scripts
    to do one-shot configuration of the logging package.

    The default behaviour is to create a StreamHandler which writes to
    sys.stderr, set a formatter using the BASIC_FORMAT format string, and
    add the handler to the root logger.

    A number of optional keyword arguments may be specified, which can alter
    the default behaviour.

    filename  Specifies that a FileHandler be created, using the specified
              filename, rather than a StreamHandler.
    filemode  Specifies the mode to open the file, if filename is specified
              (if filemode is unspecified, it defaults to 'a').
    format    Use the specified format string for the handler.
    datefmt   Use the specified date/time format.
    level     Set the root logger level to the specified level.
    stream    Use the specified stream to initialize the StreamHandler. Note
              that this argument is incompatible with 'filename' - if both
              are present, 'stream' is ignored.

    Note that you could specify a stream created using open(filename, mode)
    rather than passing the filename and mode in. However, it should be
    remembered that StreamHandler does not close its stream (since it may be
    using sys.stdout or sys.stderr), whereas FileHandler closes its stream
    when the handler is closed.
    i    RO   t   filemodeRÃ   R¬   Rï   R{   R0   N(   R1   RE   R€   R®   R/   R   R   R    RS   R   R∫   R  R∂   R2   (	   RÒ   RO   R–   R  R¬   R    t   dfsR|   R0   (    (    s&   /usr/lib/python2.7/logging/__init__.pyR   „  s$    "c         C   s   |  r t  j j |  É St Sd S(   sÇ   
    Return a logger with the specified name, creating it if necessary.

    If no name is specified, return the root logger.
    N(   R   R‡   R   R€   (   RC   (    (    s&   /usr/lib/python2.7/logging/__init__.pyR     s    c         O   s6   t  t j É d k r t É  n  t j |  | | é d S(   sD   
    Log a message with severity 'CRITICAL' on the root logger.
    i    N(   RE   R€   R®   R   R   (   RD   RH   RÒ   (    (    s&   /usr/lib/python2.7/logging/__init__.pyR   3  s    
c         O   s6   t  t j É d k r t É  n  t j |  | | é d S(   sA   
    Log a message with severity 'ERROR' on the root logger.
    i    N(   RE   R€   R®   R   R   (   RD   RH   RÒ   (    (    s&   /usr/lib/python2.7/logging/__init__.pyR   =  s    
c         O   s   d | d <t  |  | | é d S(   sa   
    Log a message with severity 'ERROR' on the root logger,
    with exception information.
    i   R(   N(   R   (   RD   RH   RÒ   (    (    s&   /usr/lib/python2.7/logging/__init__.pyR   E  s    
c         O   s6   t  t j É d k r t É  n  t j |  | | é d S(   sC   
    Log a message with severity 'WARNING' on the root logger.
    i    N(   RE   R€   R®   R   R$   (   RD   RH   RÒ   (    (    s&   /usr/lib/python2.7/logging/__init__.pyR$   M  s    
c         O   s6   t  t j É d k r t É  n  t j |  | | é d S(   s@   
    Log a message with severity 'INFO' on the root logger.
    i    N(   RE   R€   R®   R   R   (   RD   RH   RÒ   (    (    s&   /usr/lib/python2.7/logging/__init__.pyR   W  s    
c         O   s6   t  t j É d k r t É  n  t j |  | | é d S(   sA   
    Log a message with severity 'DEBUG' on the root logger.
    i    N(   RE   R€   R®   R   R   (   RD   RH   RÒ   (    (    s&   /usr/lib/python2.7/logging/__init__.pyR   _  s    
c         O   s9   t  t j É d k r t É  n  t j |  | | | é d S(   sP   
    Log 'msg % args' with the integer severity 'level' on the root logger.
    i    N(   RE   R€   R®   R   R    (   R0   RD   RH   RÒ   (    (    s&   /usr/lib/python2.7/logging/__init__.pyR    g  s    
c         C   s   |  t  j _ d S(   sB   
    Disable all logging calls of severity 'level' and below.
    N(   R€   R‡   R   (   R0   (    (    s&   /usr/lib/python2.7/logging/__init__.pyR   o  s    c         C   sñ   xè t  |  É D]Ä } yd | É  } | rw z@ y" | j É  | j É  | j É  Wn t t f k
 rd n XWd | j É  Xn  Wq t ré Ç  qé q Xq Wd S(   sÉ   
    Perform any cleanup actions in the logging system (e.g. flushing
    buffers).

    Should be called at application exit.
    N(   t   reversedR=   Rª   Rà   Rø   R8   R>   Rº   (   t   handlerListRß   t   h(    (    s&   /usr/lib/python2.7/logging/__init__.pyt   shutdownu  s    	 

c           B   s)   e  Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   sŸ  
    This handler does nothing. It's intended to be used to avoid the
    "No handlers could be found for logger XXX" one-off warning. This is
    important for library code, which may contain code to log events. If a user
    of the library does not configure logging, the one-off warning might be
    produced; to avoid this, the library developer simply needs to instantiate
    a NullHandler and add it to the top-level logger of the library module or
    package.
    c         C   s   d  S(   N(    (   Ri   R   (    (    s&   /usr/lib/python2.7/logging/__init__.pyRπ   £  s    c         C   s   d  S(   N(    (   Ri   R   (    (    s&   /usr/lib/python2.7/logging/__init__.pyR∏   ¶  s    c         C   s   d  |  _ d  S(   N(   RS   Rµ   (   Ri   (    (    s&   /usr/lib/python2.7/logging/__init__.pyR∞   ©  s    (   Rs   Rt   Ru   Rπ   R∏   R∞   (    (    (    s&   /usr/lib/python2.7/logging/__init__.pyR   ô  s   			c         C   sé   | d k	 r7 t d k	 rä t |  | | | | | É qä nS t j |  | | | | É } t d É } | j sz | j t É  É n  | j d | É d S(   sà  
    Implementation of showwarnings which redirects to logging, which will first
    check to see if the file parameter is None. If a file is specified, it will
    delegate to the original warnings implementation of showwarning. Otherwise,
    it will call warnings.formatwarning and will log the resulting string to a
    warnings logger named "py.warnings" with level logging.WARNING.
    s   py.warningss   %sN(	   RS   t   _warnings_showwarningt   warningst   formatwarningR   R®   R  R   R$   (   Rè   t   categoryRO   RU   t   filet   lineRÄ   R  (    (    s&   /usr/lib/python2.7/logging/__init__.pyt   _showwarning∞  s    	c         C   sL   |  r* t  d k rH t j a  t t _ qH n t  d k	 rH t  t _ d a  n  d S(   sø   
    If capture is true, redirect all warnings to the logging package.
    If capture is False, ensure that warnings are not redirected to logging
    but to their original destinations.
    N(   R  RS   R  t   showwarningR  (   t   capture(    (    s&   /usr/lib/python2.7/logging/__init__.pyR   ¬  s    		(b   Ru   R'   RL   RB   RÉ   RÖ   R  R™   RF   t   __all__RÕ   t   ImportErrorRS   R\   R^   t
   __author__t
   __status__t   __version__t   __date__Rƒ   t   TrueRo   t	   NameErrort   FalseR+   Rg   RM   RÛ   t   __code__RÙ   Rı   RY   Rº   R[   Ra   Rf   R   R   R   R   R   R
   R   R   R.   R   R   R;   R¥   R<   R1   R2   t   objectR   R!   R   Rò   R   R   Rü   t   WeakValueDictionaryR≤   R¶   R©   R≠   R	   R   R   R‘   Rÿ   R"   R   R⁄   R   R  R   R€   R‡   R    R   R   R   R   R   R   R$   R#   R   R   R    R   R  t   atexitt   registerR   R  R  R   (    (    (    s&   /usr/lib/python2.7/logging/__init__.pyt   <module>   s‡   `



	 
						k	ö	*%,		
§GH		fˇ `		<								                                                  # Copyright 2001-2014 by Vinay Sajip. All Rights Reserved.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose and without fee is hereby granted,
# provided that the above copyright notice appear in all copies and that
# both that copyright notice and this permission notice appear in
# supporting documentation, and that the name of Vinay Sajip
# not be used in advertising or publicity pertaining to distribution
# of the software without specific, written prior permission.
# VINAY SAJIP DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
# ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL
# VINAY SAJIP BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
# ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

"""
Configuration functions for the logging package for Python. The core package
is based on PEP 282 and comments thereto in comp.lang.python, and influenced
by Apache's log4j system.

Copyright (C) 2001-2014 Vinay Sajip. All Rights Reserved.

To use, simply 'import logging' and log away!
"""

import cStringIO
import errno
import io
import logging
import logging.handlers
import os
import re
import socket
import struct
import sys
import traceback
import types

try:
    import thread
    import threading
except ImportError:
    thread = None

from SocketServer import ThreadingTCPServer, StreamRequestHandler


DEFAULT_LOGGING_CONFIG_PORT = 9030

RESET_ERROR = errno.ECONNRESET

#
#   The following code implements a socket listener for on-the-fly
#   reconfiguration of logging.
#
#   _listener holds the server object doing the listening
_listener = None

def fileConfig(fname, defaults=None, disable_existing_loggers=True):
    """
    Read the logging configuration from a ConfigParser-format file.

    This can be called several times from an application, allowing an end user
    the ability to select from various pre-canned configurations (if the
    developer provides a mechanism to present the choices and load the chosen
    configuration).
    """
    import ConfigParser

    cp = ConfigParser.ConfigParser(defaults)
    if hasattr(fname, 'readline'):
        cp.readfp(fname)
    else:
        cp.read(fname)

    formatters = _create_formatters(cp)

    # critical section
    logging._acquireLock()
    try:
        logging._handlers.clear()
        del logging._handlerList[:]
        # Handlers add themselves to logging._handlers
        handlers = _install_handlers(cp, formatters)
        _install_loggers(cp, handlers, disable_existing_loggers)
    finally:
        logging._releaseLock()


def _resolve(name):
    """Resolve a dotted name to a global object."""
    name = name.split('.')
    used = name.pop(0)
    found = __import__(used)
    for n in name:
        used = used + '.' + n
        try:
            found = getattr(found, n)
        except AttributeError:
            __import__(used)
            found = getattr(found, n)
    return found

def _strip_spaces(alist):
    return map(lambda x: x.strip(), alist)

def _encoded(s):
    return s if isinstance(s, str) else s.encode('utf-8')

def _create_formatters(cp):
    """Create and return formatters"""
    flist = cp.get("formatters", "keys")
    if not len(flist):
        return {}
    flist = flist.split(",")
    flist = _strip_spaces(flist)
    formatters = {}
    for form in flist:
        sectname = "formatter_%s" % form
        opts = cp.options(sectname)
        if "format" in opts:
            fs = cp.get(sectname, "format", 1)
        else:
            fs = None
        if "datefmt" in opts:
            dfs = cp.get(sectname, "datefmt", 1)
        else:
            dfs = None
        c = logging.Formatter
        if "class" in opts:
            class_name = cp.get(sectname, "class")
            if class_name:
                c = _resolve(class_name)
        f = c(fs, dfs)
        formatters[form] = f
    return formatters


def _install_handlers(cp, formatters):
    """Install and return handlers"""
    hlist = cp.get("handlers", "keys")
    if not len(hlist):
        return {}
    hlist = hlist.split(",")
    hlist = _strip_spaces(hlist)
    handlers = {}
    fixups = [] #for inter-handler references
    for hand in hlist:
        sectname = "handler_%s" % hand
        klass = cp.get(sectname, "class")
        opts = cp.options(sectname)
        if "formatter" in opts:
            fmt = cp.get(sectname, "formatter")
        else:
            fmt = ""
        try:
            klass = eval(klass, vars(logging))
        except (AttributeError, NameError):
            klass = _resolve(klass)
        args = cp.get(sectname, "args")
        args = eval(args, vars(logging))
        h = klass(*args)
        if "level" in opts:
            level = cp.get(sectname, "level")
            h.setLevel(logging._levelNames[level])
        if len(fmt):
            h.setFormatter(formatters[fmt])
        if issubclass(klass, logging.handlers.MemoryHandler):
            if "target" in opts:
                target = cp.get(sectname,"target")
            else:
                target = ""
            if len(target): #the target handler may not be loaded yet, so keep for later...
                fixups.append((h, target))
        handlers[hand] = h
    #now all handlers are loaded, fixup inter-handler references...
    for h, t in fixups:
        h.setTarget(handlers[t])
    return handlers


def _install_loggers(cp, handlers, disable_existing_loggers):
    """Create and install loggers"""

    # configure the root first
    llist = cp.get("loggers", "keys")
    llist = llist.split(",")
    llist = list(map(lambda x: x.strip(), llist))
    llist.remove("root")
    sectname = "logger_root"
    root = logging.root
    log = root
    opts = cp.options(sectname)
    if "level" in opts:
        level = cp.get(sectname, "level")
        log.setLevel(logging._levelNames[level])
    for h in root.handlers[:]:
        root.removeHandler(h)
    hlist = cp.get(sectname, "handlers")
    if len(hlist):
        hlist = hlist.split(",")
        hlist = _strip_spaces(hlist)
        for hand in hlist:
            log.addHandler(handlers[hand])

    #and now the others...
    #we don't want to lose the existing loggers,
    #since other threads may have pointers to them.
    #existing is set to contain all existing loggers,
    #and as we go through the new configuration we
    #remove any which are configured. At the end,
    #what's left in existing is the set of loggers
    #which were in the previous configuration but
    #which are not in the new configuration.
    existing = list(root.manager.loggerDict.keys())
    #The list needs to be sorted so that we can
    #avoid disabling child loggers of explicitly
    #named loggers. With a sorted list it is easier
    #to find the child loggers.
    existing.sort()
    #We'll keep the list of existing loggers
    #which are children of named loggers here...
    child_loggers = []
    #now set up the new ones...
    for log in llist:
        sectname = "logger_%s" % log
        qn = cp.get(sectname, "qualname")
        opts = cp.options(sectname)
        if "propagate" in opts:
            propagate = cp.getint(sectname, "propagate")
        else:
            propagate = 1
        logger = logging.getLogger(qn)
        if qn in existing:
            i = existing.index(qn) + 1 # start with the entry after qn
            prefixed = qn + "."
            pflen = len(prefixed)
            num_existing = len(existing)
            while i < num_existing:
                if existing[i][:pflen] == prefixed:
                    child_loggers.append(existing[i])
                i += 1
            existing.remove(qn)
        if "level" in opts:
            level = cp.get(sectname, "level")
            logger.setLevel(logging._levelNames[level])
        for h in logger.handlers[:]:
            logger.removeHandler(h)
        logger.propagate = propagate
        logger.disabled = 0
        hlist = cp.get(sectname, "handlers")
        if len(hlist):
            hlist = hlist.split(",")
            hlist = _strip_spaces(hlist)
            for hand in hlist:
                logger.addHandler(handlers[hand])

    #Disable any old loggers. There's no point deleting
    #them as other threads may continue to hold references
    #and by disabling them, you stop them doing any logging.
    #However, don't disable children of named loggers, as that's
    #probably not what was intended by the user.
    for log in existing:
        logger = root.manager.loggerDict[log]
        if log in child_loggers:
            logger.level = logging.NOTSET
            logger.handlers = []
            logger.propagate = 1
        else:
            logger.disabled = disable_existing_loggers



IDENTIFIER = re.compile('^[a-z_][a-z0-9_]*$', re.I)


def valid_ident(s):
    m = IDENTIFIER.match(s)
    if not m:
        raise ValueError('Not a valid Python identifier: %r' % s)
    return True


class ConvertingMixin(object):
    """For ConvertingXXX's, this mixin class provides common functions"""

    def convert_with_key(self, key, value, replace=True):
        result = self.configurator.convert(value)
        #If the converted value is different, save for next time
        if value is not result:
            if replace:
                self[key] = result
            if type(result) in (ConvertingDict, ConvertingList,
                               ConvertingTuple):
                result.parent = self
                result.key = key
        return result

    def convert(self, value):
        result = self.configurator.convert(value)
        if value is not result:
            if type(result) in (ConvertingDict, ConvertingList,
                               ConvertingTuple):
                result.parent = self
        return result


# The ConvertingXXX classes are wrappers around standard Python containers,
# and they serve to convert any suitable values in the container. The
# conversion converts base dicts, lists and tuples to their wrapped
# equivalents, whereas strings which match a conversion format are converted
# appropriately.
#
# Each wrapper should have a configurator attribute holding the actual
# configurator to use for conversion.

class ConvertingDict(dict, ConvertingMixin):
    """A converting dictionary wrapper."""

    def __getitem__(self, key):
        value = dict.__getitem__(self, key)
        return self.convert_with_key(key, value)

    def get(self, key, default=None):
        value = dict.get(self, key, default)
        return self.convert_with_key(key, value)

    def pop(self, key, default=None):
        value = dict.pop(self, key, default)
        return self.convert_with_key(key, value, replace=False)

class ConvertingList(list, ConvertingMixin):
    """A converting list wrapper."""
    def __getitem__(self, key):
        value = list.__getitem__(self, key)
        return self.convert_with_key(key, value)

    def pop(self, idx=-1):
        value = list.pop(self, idx)
        return self.convert(value)

class ConvertingTuple(tuple, ConvertingMixin):
    """A converting tuple wrapper."""
    def __getitem__(self, key):
        value = tuple.__getitem__(self, key)
        # Can't replace a tuple entry.
        return self.convert_with_key(key, value, replace=False)

class BaseConfigurator(object):
    """
    The configurator base class which defines some useful defaults.
    """

    CONVERT_PATTERN = re.compile(r'^(?P<prefix>[a-z]+)://(?P<suffix>.*)$')

    WORD_PATTERN = re.compile(r'^\s*(\w+)\s*')
    DOT_PATTERN = re.compile(r'^\.\s*(\w+)\s*')
    INDEX_PATTERN = re.compile(r'^\[\s*(\w+)\s*\]\s*')
    DIGIT_PATTERN = re.compile(r'^\d+$')

    value_converters = {
        'ext' : 'ext_convert',
        'cfg' : 'cfg_convert',
    }

    # We might want to use a different one, e.g. importlib
    importer = __import__

    def __init__(self, config):
        self.config = ConvertingDict(config)
        self.config.configurator = self
        # Issue 12718: winpdb replaces __import__ with a Python function, which
        # ends up being treated as a bound method. To avoid problems, we
        # set the importer on the instance, but leave it defined in the class
        # so existing code doesn't break
        if type(__import__) == types.FunctionType:
            self.importer = __import__

    def resolve(self, s):
        """
        Resolve strings to objects using standard import and attribute
        syntax.
        """
        name = s.split('.')
        used = name.pop(0)
        try:
            found = self.importer(used)
            for frag in name:
                used += '.' + frag
                try:
                    found = getattr(found, frag)
                except AttributeError:
                    self.importer(used)
                    found = getattr(found, frag)
            return found
        except ImportError:
            e, tb = sys.exc_info()[1:]
            v = ValueError('Cannot resolve %r: %s' % (s, e))
            v.__cause__, v.__traceback__ = e, tb
            raise v

    def ext_convert(self, value):
        """Default converter for the ext:// protocol."""
        return self.resolve(value)

    def cfg_convert(self, value):
        """Default converter for the cfg:// protocol."""
        rest = value
        m = self.WORD_PATTERN.match(rest)
        if m is None:
            raise ValueError("Unable to convert %r" % value)
        else:
            rest = rest[m.end():]
            d = self.config[m.groups()[0]]
            #print d, rest
            while rest:
                m = self.DOT_PATTERN.match(rest)
                if m:
                    d = d[m.groups()[0]]
                else:
                    m = self.INDEX_PATTERN.match(rest)
                    if m:
                        idx = m.groups()[0]
                        if not self.DIGIT_PATTERN.match(idx):
                            d = d[idx]
                        else:
                            try:
                                n = int(idx) # try as number first (most likely)
                                d = d[n]
                            except TypeError:
                                d = d[idx]
                if m:
                    rest = rest[m.end():]
                else:
                    raise ValueError('Unable to convert '
                                     '%r at %r' % (value, rest))
        #rest should be empty
        return d

    def convert(self, value):
        """
        Convert values to an appropriate type. dicts, lists and tuples are
        replaced by their converting alternatives. Strings are checked to
        see if they have a conversion format and are converted if they do.
        """
        if not isinstance(value, ConvertingDict) and isinstance(value, dict):
            value = ConvertingDict(value)
            value.configurator = self
        elif not isinstance(value, ConvertingList) and isinstance(value, list):
            value = ConvertingList(value)
            value.configurator = self
        elif not isinstance(value, ConvertingTuple) and\
                 isinstance(value, tuple):
            value = ConvertingTuple(value)
            value.configurator = self
        elif isinstance(value, basestring): # str for py3k
            m = self.CONVERT_PATTERN.match(value)
            if m:
                d = m.groupdict()
                prefix = d['prefix']
                converter = self.value_converters.get(prefix, None)
                if converter:
                    suffix = d['suffix']
                    converter = getattr(self, converter)
                    value = converter(suffix)
        return value

    def configure_custom(self, config):
        """Configure an object with a user-supplied factory."""
        c = config.pop('()')
        if not hasattr(c, '__call__') and hasattr(types, 'ClassType') and type(c) != types.ClassType:
            c = self.resolve(c)
        props = config.pop('.', None)
        # Check for valid identifiers
        kwargs = dict([(k, config[k]) for k in config if valid_ident(k)])
        result = c(**kwargs)
        if props:
            for name, value in props.items():
                setattr(result, name, value)
        return result

    def as_tuple(self, value):
        """Utility function which converts lists to tuples."""
        if isinstance(value, list):
            value = tuple(value)
        return value

class DictConfigurator(BaseConfigurator):
    """
    Configure logging using a dictionary-like object to describe the
    configuration.
    """

    def configure(self):
        """Do the configuration."""

        config = self.config
        if 'version' not in config:
            raise ValueError("dictionary doesn't specify a version")
        if config['version'] != 1:
            raise ValueError("Unsupported version: %s" % config['version'])
        incremental = config.pop('incremental', False)
        EMPTY_DICT = {}
        logging._acquireLock()
        try:
            if incremental:
                handlers = config.get('handlers', EMPTY_DICT)
                for name in handlers:
                    if name not in logging._handlers:
                        raise ValueError('No handler found with '
                                         'name %r'  % name)
                    else:
                        try:
                            handler = logging._handlers[name]
                            handler_config = handlers[name]
                            level = handler_config.get('level', None)
                            if level:
                                handler.setLevel(logging._checkLevel(level))
                        except StandardError as e:
                            raise ValueError('Unable to configure handler '
                                             '%r: %s' % (name, e))
                loggers = config.get('loggers', EMPTY_DICT)
                for name in loggers:
                    try:
                        self.configure_logger(name, loggers[name], True)
                    except StandardError as e:
                        raise ValueError('Unable to configure logger '
                                         '%r: %s' % (name, e))
                root = config.get('root', None)
                if root:
                    try:
                        self.configure_root(root, True)
                    except StandardError as e:
                        raise ValueError('Unable to configure root '
                                         'logger: %s' % e)
            else:
                disable_existing = config.pop('disable_existing_loggers', True)

                logging._handlers.clear()
                del logging._handlerList[:]

                # Do formatters first - they don't refer to anything else
                formatters = config.get('formatters', EMPTY_DICT)
                for name in formatters:
                    try:
                        formatters[name] = self.configure_formatter(
                                                            formatters[name])
                    except StandardError as e:
                        raise ValueError('Unable to configure '
                                         'formatter %r: %s' % (name, e))
                # Next, do filters - they don't refer to anything else, either
                filters = config.get('filters', EMPTY_DICT)
                for name in filters:
                    try:
                        filters[name] = self.configure_filter(filters[name])
                    except StandardError as e:
                        raise ValueError('Unable to configure '
                                         'filter %r: %s' % (name, e))

                # Next, do handlers - they refer to formatters and filters
                # As handlers can refer to other handlers, sort the keys
                # to allow a deterministic order of configuration
                handlers = config.get('handlers', EMPTY_DICT)
                deferred = []
                for name in sorted(handlers):
                    try:
                        handler = self.configure_handler(handlers[name])
                        handler.name = name
                        handlers[name] = handler
                    except StandardError as e:
                        if 'target not configured yet' in str(e):
                            deferred.append(name)
                        else:
                            raise ValueError('Unable to configure handler '
                                             '%r: %s' % (name, e))

                # Now do any that were deferred
                for name in deferred:
                    try:
                        handler = self.configure_handler(handlers[name])
                        handler.name = name
                        handlers[name] = handler
                    except StandardError as e:
                        raise ValueError('Unable to configure handler '
                                         '%r: %s' % (name, e))

                # Next, do loggers - they refer to handlers and filters

                #we don't want to lose the existing loggers,
                #since other threads may have pointers to them.
                #existing is set to contain all existing loggers,
                #and as we go through the new configuration we
                #remove any which are configured. At the end,
                #what's left in existing is the set of loggers
                #which were in the previous configuration but
                #which are not in the new configuration.
                root = logging.root
                existing = root.manager.loggerDict.keys()
                #The list needs to be sorted so that we can
                #avoid disabling child loggers of explicitly
                #named loggers. With a sorted list it is easier
                #to find the child loggers.
                existing.sort()
                #We'll keep the list of existing loggers
                #which are children of named loggers here...
                child_loggers = []
                #now set up the new ones...
                loggers = config.get('loggers', EMPTY_DICT)
                for name in loggers:
                    name = _encoded(name)
                    if name in existing:
                        i = existing.index(name)
                        prefixed = name + "."
                        pflen = len(prefixed)
                        num_existing = len(existing)
                        i = i + 1 # look at the entry after name
                        while (i < num_existing) and\
                              (existing[i][:pflen] == prefixed):
                            child_loggers.append(existing[i])
                            i = i + 1
                        existing.remove(name)
                    try:
                        self.configure_logger(name, loggers[name])
                    except StandardError as e:
                        raise ValueError('Unable to configure logger '
                                         '%r: %s' % (name, e))

                #Disable any old loggers. There's no point deleting
                #them as other threads may continue to hold references
                #and by disabling them, you stop them doing any logging.
                #However, don't disable children of named loggers, as that's
                #probably not what was intended by the user.
                for log in existing:
                    logger = root.manager.loggerDict[log]
                    if log in child_loggers:
                        logger.level = logging.NOTSET
                        logger.handlers = []
                        logger.propagate = True
                    elif disable_existing:
                        logger.disabled = True

                # And finally, do the root logger
                root = config.get('root', None)
                if root:
                    try:
                        self.configure_root(root)
                    except StandardError as e:
                        raise ValueError('Unable to configure root '
                                         'logger: %s' % e)
        finally:
            logging._releaseLock()

    def configure_formatter(self, config):
        """Configure a formatter from a dictionary."""
        if '()' in config:
            factory = config['()'] # for use in exception handler
            try:
                result = self.configure_custom(config)
            except TypeError as te:
                if "'format'" not in str(te):
                    raise
                #Name of parameter changed from fmt to format.
                #Retry with old name.
                #This is so that code can be used with older Python versions
                #(e.g. by Django)
                config['fmt'] = config.pop('format')
                config['()'] = factory
                result = self.configure_custom(config)
        else:
            fmt = config.get('format', None)
            dfmt = config.get('datefmt', None)
            result = logging.Formatter(fmt, dfmt)
        return result

    def configure_filter(self, config):
        """Configure a filter from a dictionary."""
        if '()' in config:
            result = self.configure_custom(config)
        else:
            name = config.get('name', '')
            result = logging.Filter(name)
        return result

    def add_filters(self, filterer, filters):
        """Add filters to a filterer from a list of names."""
        for f in filters:
            try:
                filterer.addFilter(self.config['filters'][f])
            except StandardError as e:
                raise ValueError('Unable to add filter %r: %s' % (f, e))

    def configure_handler(self, config):
        """Configure a handler from a dictionary."""
        formatter = config.pop('formatter', None)
        if formatter:
            try:
                formatter = self.config['formatters'][formatter]
            except StandardError as e:
                raise ValueError('Unable to set formatter '
                                 '%r: %s' % (formatter, e))
        level = config.pop('level', None)
        filters = config.pop('filters', None)
        if '()' in config:
            c = config.pop('()')
            if not hasattr(c, '__call__') and hasattr(types, 'ClassType') and type(c) != types.ClassType:
                c = self.resolve(c)
            factory = c
        else:
            cname = config.pop('class')
            klass = self.resolve(cname)
            #Special case for handler which refers to another handler
            if issubclass(klass, logging.handlers.MemoryHandler) and\
                'target' in config:
                try:
                    th = self.config['handlers'][config['target']]
                    if not isinstance(th, logging.Handler):
                        config['class'] = cname # restore for deferred configuration
                        raise StandardError('target not configured yet')
                    config['target'] = th
                except StandardError as e:
                    raise ValueError('Unable to set target handler '
                                     '%r: %s' % (config['target'], e))
            elif issubclass(klass, logging.handlers.SMTPHandler) and\
                'mailhost' in config:
                config['mailhost'] = self.as_tuple(config['mailhost'])
            elif issubclass(klass, logging.handlers.SysLogHandler) and\
                'address' in config:
                config['address'] = self.as_tuple(config['address'])
            factory = klass
        kwargs = dict([(k, config[k]) for k in config if valid_ident(k)])
        try:
            result = factory(**kwargs)
        except TypeError as te:
            if "'stream'" not in str(te):
                raise
            #The argument name changed from strm to stream
            #Retry with old name.
            #This is so that code can be used with older Python versions
            #(e.g. by Django)
            kwargs['strm'] = kwargs.pop('stream')
            result = factory(**kwargs)
        if formatter:
            result.setFormatter(formatter)
        if level is not None:
            result.setLevel(logging._checkLevel(level))
        if filters:
            self.add_filters(result, filters)
        return result

    def add_handlers(self, logger, handlers):
        """Add handlers to a logger from a list of names."""
        for h in handlers:
            try:
                logger.addHandler(self.config['handlers'][h])
            except StandardError as e:
                raise ValueError('Unable to add handler %r: %s' % (h, e))

    def common_logger_config(self, logger, config, incremental=False):
        """
        Perform configuration which is common to root and non-root loggers.
        """
        level = config.get('level', None)
        if level is not None:
            logger.setLevel(logging._checkLevel(level))
        if not incremental:
            #Remove any existing handlers
            for h in logger.handlers[:]:
                logger.removeHandler(h)
            handlers = config.get('handlers', None)
            if handlers:
                self.add_handlers(logger, handlers)
            filters = config.get('filters', None)
            if filters:
                self.add_filters(logger, filters)

    def configure_logger(self, name, config, incremental=False):
        """Configure a non-root logger from a dictionary."""
        logger = logging.getLogger(name)
        self.common_logger_config(logger, config, incremental)
        propagate = config.get('propagate', None)
        if propagate is not None:
            logger.propagate = propagate

    def configure_root(self, config, incremental=False):
        """Configure a root logger from a dictionary."""
        root = logging.getLogger()
        self.common_logger_config(root, config, incremental)

dictConfigClass = DictConfigurator

def dictConfig(config):
    """Configure logging using a dictionary."""
    dictConfigClass(config).configure()


def listen(port=DEFAULT_LOGGING_CONFIG_PORT):
    """
    Start up a socket server on the specified port, and listen for new
    configurations.

    These will be sent as a file suitable for processing by fileConfig().
    Returns a Thread object on which you can call start() to start the server,
    and which you can join() when appropriate. To stop the server, call
    stopListening().
    """
    if not thread:
        raise NotImplementedError("listen() needs threading to work")

    class ConfigStreamHandler(StreamRequestHandler):
        """
        Handler for a logging configuration request.

        It expects a completely new logging configuration and uses fileConfig
        to install it.
        """
        def handle(self):
            """
            Handle a request.

            Each request is expected to be a 4-byte length, packed using
            struct.pack(">L", n), followed by the config file.
            Uses fileConfig() to do the grunt work.
            """
            import tempfile
            try:
                conn = self.connection
                chunk = conn.recv(4)
                if len(chunk) == 4:
                    slen = struct.unpack(">L", chunk)[0]
                    chunk = self.connection.recv(slen)
                    while len(chunk) < slen:
                        chunk = chunk + conn.recv(slen - len(chunk))
                    try:
                        import json
                        d =json.loads(chunk)
                        assert isinstance(d, dict)
                        dictConfig(d)
                    except:
                        #Apply new configuration.

                        file = cStringIO.StringIO(chunk)
                        try:
                            fileConfig(file)
                        except (KeyboardInterrupt, SystemExit):
                            raise
                        except:
                            traceback.print_exc()
                    if self.server.ready:
                        self.server.ready.set()
            except socket.error as e:
                if e.errno != RESET_ERROR:
                    raise

    class ConfigSocketReceiver(ThreadingTCPServer):
        """
        A simple TCP socket-based logging config receiver.
        """

        allow_reuse_address = 1

        def __init__(self, host='localhost', port=DEFAULT_LOGGING_CONFIG_PORT,
                     handler=None, ready=None):
            ThreadingTCPServer.__init__(self, (host, port), handler)
            logging._acquireLock()
            self.abort = 0
            logging._releaseLock()
            self.timeout = 1
            self.ready = ready

        def serve_until_stopped(self):
            import select
            abort = 0
            while not abort:
                rd, wr, ex = select.select([self.socket.fileno()],
                                           [], [],
                                           self.timeout)
                if rd:
                    self.handle_request()
                logging._acquireLock()
                abort = self.abort
                logging._releaseLock()
            self.socket.close()

    class Server(threading.Thread):

        def __init__(self, rcvr, hdlr, port):
            super(Server, self).__init__()
            self.rcvr = rcvr
            self.hdlr = hdlr
            self.port = port
            self.ready = threading.Event()

        def run(self):
            server = self.rcvr(port=self.port, handler=self.hdlr,
                               ready=self.ready)
            if self.port == 0:
                self.port = server.server_address[1]
            self.ready.set()
            global _listener
            logging._acquireLock()
            _listener = server
            logging._releaseLock()
            server.serve_until_stopped()

    return Server(ConfigSocketReceiver, ConfigStreamHandler, port)

def stopListening():
    """
    Stop the listening server which was created with a call to listen().
    """
    global _listener
    logging._acquireLock()
    try:
        if _listener:
            _listener.abort = 1
            _listener = None
    finally:
        logging._releaseLock()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Û
”´[c           @   s  d  Z  d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l	 Z	 d d l
 Z
 d d l Z d d l Z y d d l Z d d l Z Wn e k
 rÀ e Z n Xd d l m Z m Z d Z e j Z e a e e d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d	 Ñ  Z d
 Ñ  Z d Ñ  Z e j  d e j! É Z" d Ñ  Z# d e$ f d Ñ  É  YZ% d e& e% f d Ñ  É  YZ' d e( e% f d Ñ  É  YZ) d e* e% f d Ñ  É  YZ+ d e$ f d Ñ  É  YZ, d e, f d Ñ  É  YZ- e- Z. d Ñ  Z/ e d Ñ Z0 d Ñ  Z1 d S(   s  
Configuration functions for the logging package for Python. The core package
is based on PEP 282 and comments thereto in comp.lang.python, and influenced
by Apache's log4j system.

Copyright (C) 2001-2014 Vinay Sajip. All Rights Reserved.

To use, simply 'import logging' and log away!
iˇˇˇˇN(   t   ThreadingTCPServert   StreamRequestHandleriF#  c         C   s¶   d d l  } | j  | É } t |  d É r: | j |  É n | j |  É t | É } t j É  z7 t j j É  t j	 2t
 | | É } t | | | É Wd t j É  Xd S(   sD  
    Read the logging configuration from a ConfigParser-format file.

    This can be called several times from an application, allowing an end user
    the ability to select from various pre-canned configurations (if the
    developer provides a mechanism to present the choices and load the chosen
    configuration).
    iˇˇˇˇNt   readline(   t   ConfigParsert   hasattrt   readfpt   readt   _create_formatterst   loggingt   _acquireLockt	   _handlerst   cleart   _handlerListt   _install_handlerst   _install_loggerst   _releaseLock(   t   fnamet   defaultst   disable_existing_loggersR   t   cpt
   formatterst   handlers(    (    s$   /usr/lib/python2.7/logging/config.pyt
   fileConfig<   s    	
c         C   sç   |  j  d É }  |  j d É } t | É } x\ |  D]T } | d | } y t | | É } Wq1 t k
 rÑ t | É t | | É } q1 Xq1 W| S(   s)   Resolve a dotted name to a global object.t   .i    (   t   splitt   popt
   __import__t   getattrt   AttributeError(   t   namet   usedt   foundt   n(    (    s$   /usr/lib/python2.7/logging/config.pyt   _resolve[   s    
c         C   s   t  d Ñ  |  É S(   Nc         S   s
   |  j  É  S(   N(   t   strip(   t   x(    (    s$   /usr/lib/python2.7/logging/config.pyt   <lambda>j   s    (   t   map(   t   alist(    (    s$   /usr/lib/python2.7/logging/config.pyt   _strip_spacesi   s    c         C   s    t  |  t É r |  S|  j d É S(   Ns   utf-8(   t
   isinstancet   strt   encode(   t   s(    (    s$   /usr/lib/python2.7/logging/config.pyt   _encodedl   s    c         C   s  |  j  d d É } t | É s" i  S| j d É } t | É } i  } x” | D]À } d | } |  j | É } d | k rç |  j  | d d É } n d	 } d | k r∑ |  j  | d d É } n d	 } t j } d | k r¸ |  j  | d É }	 |	 r¸ t |	 É } q¸ n  | | | É }
 |
 | | <qJ W| S(
   s   Create and return formattersR   t   keyst   ,s   formatter_%st   formati   t   datefmtt   classN(	   t   gett   lenR   R'   t   optionst   NoneR   t	   FormatterR!   (   R   t   flistR   t   formt   sectnamet   optst   fst   dfst   ct
   class_namet   f(    (    s$   /usr/lib/python2.7/logging/config.pyR   o   s.    
	c         C   s
  |  j  d d É } t | É s" i  S| j d É } t | É } i  } g  } xí| D]ä} d | } |  j  | d É } |  j | É } d | k r¢ |  j  | d É }	 n d }	 y t | t t É É } Wn# t t	 f k
 rÊ t
 | É } n X|  j  | d É }
 t |
 t t É É }
 | |
 å  } d	 | k rO|  j  | d	 É } | j t j | É n  t |	 É ro| j | |	 É n  t | t j j É r–d
 | k r•|  j  | d
 É } n d } t | É r–| j | | f É q–n  | | | <qP Wx% | D] \ } } | j | | É qÂW| S(   s   Install and return handlersR   R-   R.   s
   handler_%sR1   t	   formattert    t   argst   levelt   target(   R2   R3   R   R'   R4   t   evalt   varsR   R   t	   NameErrorR!   t   setLevelt   _levelNamest   setFormattert
   issubclassR   t   MemoryHandlert   appendt	   setTarget(   R   R   t   hlistR   t   fixupst   handR9   t   klassR:   t   fmtRB   t   hRC   RD   t   t(    (    s$   /usr/lib/python2.7/logging/config.pyR   å   sH    
c         C   sq  |  j  d d É } | j d É } t t d Ñ  | É É } | j d É d } t j } | } |  j | É } d | k rü |  j  | d É } | j t j	 | É n  x | j
 D] }	 | j |	 É q™ W|  j  | d É }
 t |
 É r|
 j d É }
 t |
 É }
 x" |
 D] } | j | | É qWn  t | j j j É  É } | j É  g  } xÃ| D]ƒ} d	 | } |  j  | d
 É } |  j | É } d | k r†|  j | d É } n d } t j | É } | | k rK| j | É d } | d } t | É } t | É } xB | | k  r:| | |  | k r-| j | | É n  | d 7} q˘W| j | É n  d | k rÄ|  j  | d É } | j t j	 | É n  x | j
 D] }	 | j |	 É qãW| | _ d | _ |  j  | d É }
 t |
 É rN|
 j d É }
 t |
 É }
 x" |
 D] } | j | | É qÙWqNqNWxT | D]L } | j j | } | | k r`t j | _ g  | _
 d | _ q| | _ qWd S(   s   Create and install loggerst   loggersR-   R.   c         S   s
   |  j  É  S(   N(   R"   (   R#   (    (    s$   /usr/lib/python2.7/logging/config.pyR$   Ω   s    t   roott   logger_rootRC   R   s	   logger_%st   qualnamet	   propagatei   R   i    N(   R2   R   t   listR%   t   removeR   RW   R4   RH   RI   R   t   removeHandlerR3   R'   t
   addHandlert   managert
   loggerDictR-   t   sortt   getintt	   getLoggert   indexRM   RZ   t   disabledt   NOTSETRC   (   R   R   R   t   llistR9   RW   t   logR:   RC   RT   RO   RQ   t   existingt   child_loggerst   qnRZ   t   loggert   it   prefixedt   pflent   num_existing(    (    s$   /usr/lib/python2.7/logging/config.pyR   ∑   sx    	


			s   ^[a-z_][a-z0-9_]*$c         C   s,   t  j |  É } | s( t d |  É Ç n  t S(   Ns!   Not a valid Python identifier: %r(   t
   IDENTIFIERt   matcht
   ValueErrort   True(   R+   t   m(    (    s$   /usr/lib/python2.7/logging/config.pyt   valid_ident  s    t   ConvertingMixinc           B   s#   e  Z d  Z e d Ñ Z d Ñ  Z RS(   s?   For ConvertingXXX's, this mixin class provides common functionsc         C   sh   |  j  j | É } | | k	 rd | r1 | |  | <n  t | É t t t f k rd |  | _ | | _ qd n  | S(   N(   t   configuratort   convertt   typet   ConvertingDictt   ConvertingListt   ConvertingTuplet   parentt   key(   t   selfR   t   valuet   replacet   result(    (    s$   /usr/lib/python2.7/logging/config.pyt   convert_with_key   s    	c         C   sL   |  j  j | É } | | k	 rH t | É t t t f k rH |  | _ qH n  | S(   N(   Rx   Ry   Rz   R{   R|   R}   R~   (   RÄ   RÅ   RÉ   (    (    s$   /usr/lib/python2.7/logging/config.pyRy   ,  s    (   t   __name__t
   __module__t   __doc__Rt   RÑ   Ry   (    (    (    s$   /usr/lib/python2.7/logging/config.pyRw     s   R{   c           B   s/   e  Z d  Z d Ñ  Z d d Ñ Z d d Ñ Z RS(   s    A converting dictionary wrapper.c         C   s"   t  j |  | É } |  j | | É S(   N(   t   dictt   __getitem__RÑ   (   RÄ   R   RÅ   (    (    s$   /usr/lib/python2.7/logging/config.pyRâ   A  s    c         C   s%   t  j |  | | É } |  j | | É S(   N(   Rà   R2   RÑ   (   RÄ   R   t   defaultRÅ   (    (    s$   /usr/lib/python2.7/logging/config.pyR2   E  s    c         C   s+   t  j |  | | É } |  j | | d t ÉS(   NRÇ   (   Rà   R   RÑ   t   False(   RÄ   R   Rä   RÅ   (    (    s$   /usr/lib/python2.7/logging/config.pyR   I  s    N(   RÖ   RÜ   Rá   Râ   R5   R2   R   (    (    (    s$   /usr/lib/python2.7/logging/config.pyR{   >  s   	R|   c           B   s#   e  Z d  Z d Ñ  Z d d Ñ Z RS(   s   A converting list wrapper.c         C   s"   t  j |  | É } |  j | | É S(   N(   R[   Râ   RÑ   (   RÄ   R   RÅ   (    (    s$   /usr/lib/python2.7/logging/config.pyRâ   O  s    iˇˇˇˇc         C   s   t  j |  | É } |  j | É S(   N(   R[   R   Ry   (   RÄ   t   idxRÅ   (    (    s$   /usr/lib/python2.7/logging/config.pyR   S  s    (   RÖ   RÜ   Rá   Râ   R   (    (    (    s$   /usr/lib/python2.7/logging/config.pyR|   M  s   	R}   c           B   s   e  Z d  Z d Ñ  Z RS(   s   A converting tuple wrapper.c         C   s(   t  j |  | É } |  j | | d t ÉS(   NRÇ   (   t   tupleRâ   RÑ   Rã   (   RÄ   R   RÅ   (    (    s$   /usr/lib/python2.7/logging/config.pyRâ   Y  s    (   RÖ   RÜ   Rá   Râ   (    (    (    s$   /usr/lib/python2.7/logging/config.pyR}   W  s   t   BaseConfiguratorc           B   s≤   e  Z d  Z e j d É Z e j d É Z e j d É Z e j d É Z e j d É Z	 i d d 6d d	 6Z
 e Z d
 Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   sI   
    The configurator base class which defines some useful defaults.
    s%   ^(?P<prefix>[a-z]+)://(?P<suffix>.*)$s   ^\s*(\w+)\s*s   ^\.\s*(\w+)\s*s   ^\[\s*(\w+)\s*\]\s*s   ^\d+$t   ext_convertt   extt   cfg_convertt   cfgc         C   s@   t  | É |  _ |  |  j _ t t É t j k r< t |  _ n  d  S(   N(   R{   t   configRx   Rz   R   t   typest   FunctionTypet   importer(   RÄ   Rì   (    (    s$   /usr/lib/python2.7/logging/config.pyt   __init__r  s    c   	      C   sÙ   | j  d É } | j d É } yy |  j | É } x_ | D]W } | d | 7} y t | | É } Wq7 t k
 rç |  j | É t | | É } q7 Xq7 W| SWnV t k
 rÔ t j É  d \ } } t d | | f É } | | | _	 | _
 | Ç n Xd S(   s`   
        Resolve strings to objects using standard import and attribute
        syntax.
        R   i    i   s   Cannot resolve %r: %sN(   R   R   Rñ   R   R   t   ImportErrort   syst   exc_infoRs   t	   __cause__t   __traceback__(	   RÄ   R+   R   R   R   t   fragt   et   tbt   v(    (    s$   /usr/lib/python2.7/logging/config.pyt   resolve|  s"    c         C   s   |  j  | É S(   s*   Default converter for the ext:// protocol.(   R°   (   RÄ   RÅ   (    (    s$   /usr/lib/python2.7/logging/config.pyRè   ì  s    c         C   sO  | } |  j  j | É } | d k r7 t d | É Ç n| | j É  } |  j | j É  d } xÍ | rJ|  j j | É } | rñ | | j É  d } nÇ |  j j | É } | r| j É  d } |  j	 j | É s› | | } qy t
 | É } | | } Wqt k
 r| | } qXn  | r1| | j É  } qa t d | | f É Ç qa W| S(   s*   Default converter for the cfg:// protocol.s   Unable to convert %ri    s   Unable to convert %r at %rN(   t   WORD_PATTERNRr   R5   Rs   t   endRì   t   groupst   DOT_PATTERNt   INDEX_PATTERNt   DIGIT_PATTERNt   intt	   TypeError(   RÄ   RÅ   t   restRu   t   dRå   R    (    (    s$   /usr/lib/python2.7/logging/config.pyRë   ó  s2    	c         C   s/  t  | t É r7 t  | t É r7 t | É } |  | _ nÙ t  | t É rn t  | t É rn t | É } |  | _ nΩ t  | t É r• t  | t É r• t | É } |  | _ nÜ t  | t É r+|  j	 j
 | É } | r+| j É  } | d } |  j j | d É } | r(| d } t |  | É } | | É } q(q+n  | S(   sÈ   
        Convert values to an appropriate type. dicts, lists and tuples are
        replaced by their converting alternatives. Strings are checked to
        see if they have a conversion format and are converted if they do.
        t   prefixt   suffixN(   R(   R{   Rà   Rx   R|   R[   R}   Rç   t
   basestringt   CONVERT_PATTERNRr   t	   groupdictt   value_convertersR2   R5   R   (   RÄ   RÅ   Ru   R´   R¨   t	   converterR≠   (    (    s$   /usr/lib/python2.7/logging/config.pyRy   π  s*    

c   	      C   s‚   | j  d É } t | d É rU t t d É rU t | É t j k rU |  j | É } n  | j  d d É } t g  | D]" } t | É rq | | | f ^ qq É } | | ç  } | rﬁ x- | j	 É  D] \ } } t
 | | | É qª Wn  | S(   s1   Configure an object with a user-supplied factory.s   ()t   __call__t	   ClassTypeR   N(   R   R   Rî   Rz   R¥   R°   R5   Rà   Rv   t   itemst   setattr(	   RÄ   Rì   R=   t   propst   kt   kwargsRÉ   R   RÅ   (    (    s$   /usr/lib/python2.7/logging/config.pyt   configure_custom’  s    45c         C   s"   t  | t É r t | É } n  | S(   s0   Utility function which converts lists to tuples.(   R(   R[   Rç   (   RÄ   RÅ   (    (    s$   /usr/lib/python2.7/logging/config.pyt   as_tuple„  s    (   RÖ   RÜ   Rá   t   ret   compileRØ   R¢   R•   R¶   Rß   R±   R   Rñ   Ró   R°   Rè   Rë   Ry   R∫   Rª   (    (    (    s$   /usr/lib/python2.7/logging/config.pyRé   ^  s"   
	
			"		t   DictConfiguratorc           B   sh   e  Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z e	 d Ñ Z
 e	 d Ñ Z e	 d	 Ñ Z RS(
   s]   
    Configure logging using a dictionary-like object to describe the
    configuration.
    c         C   s˘  |  j  } d | k r$ t d É Ç n  | d d k rK t d | d É Ç n  | j d t É } i  } t j É  zz| rı| j d | É } x® | D]† } | t j k r∑ t d | É Ç qè yL t j | } | | } | j d d É } | r| j	 t j
 | É É n  Wqè t k
 r.}	 t d	 | |	 f É Ç qè Xqè W| j d
 | É }
 xU |
 D]M } y |  j | |
 | t É WqLt k
 rò}	 t d | |	 f É Ç qLXqLW| j d d É } | rÊy |  j | t É WqÚt k
 rÓ}	 t d |	 É Ç qÚXqÊnÒ| j d t É } t j j É  t j 2| j d | É } xU | D]M } y |  j | | É | | <Wq4t k
 rÄ}	 t d | |	 f É Ç q4Xq4W| j d | É } xU | D]M } y |  j | | É | | <Wqût k
 rÍ}	 t d | |	 f É Ç qûXqûW| j d | É } g  } xå t | É D]~ } y* |  j | | É } | | _ | | | <Wqt k
 rë}	 d t |	 É k rx| j | É qít d	 | |	 f É Ç qXqWxd | D]\ } y* |  j | | É } | | _ | | | <Wqùt k
 r¯}	 t d	 | |	 f É Ç qùXqùWt j } | j j j É  } | j É  g  } | j d
 | É }
 x˜ |
 D]Ô } t | É } | | k rÏ| j | É } | d } t | É } t | É } | d } x? | | k  r€| | |  | k r€| j | | É | d } qùW| j  | É n  y |  j | |
 | É WqAt k
 r/}	 t d | |	 f É Ç qAXqAWx] | D]U } | j j | } | | k r~t j! | _" g  | _# t | _$ q;| r;t | _% q;q;W| j d d É } | rÊy |  j | É WqÊt k
 r‚}	 t d |	 É Ç qÊXn  Wd t j& É  Xd S(   s   Do the configuration.t   versions$   dictionary doesn't specify a versioni   s   Unsupported version: %st   incrementalR   s   No handler found with name %rRC   s"   Unable to configure handler %r: %sRV   s!   Unable to configure logger %r: %sRW   s#   Unable to configure root logger: %sR   R   s$   Unable to configure formatter %r: %st   filterss!   Unable to configure filter %r: %ss   target not configured yetR   N('   Rì   Rs   R   Rã   R   R	   R2   R
   R5   RH   t   _checkLevelt   StandardErrort   configure_loggerRt   t   configure_rootR   R   t   configure_formattert   configure_filtert   sortedt   configure_handlerR   R)   RM   RW   R_   R`   R-   Ra   R,   Rd   R3   R\   Rf   RC   R   RZ   Re   R   (   RÄ   Rì   R¿   t
   EMPTY_DICTR   R   t   handlert   handler_configRC   Rû   RV   RW   t   disable_existingR   R¡   t   deferredRi   Rj   Rm   Rn   Ro   Rp   Rh   Rl   (    (    s$   /usr/lib/python2.7/logging/config.pyt	   configureÔ  sÊ    	

			


	c         C   s¿   d | k rÜ | d } y |  j  | É } Wqº t k
 rÇ } d t | É k rS Ç  n  | j d É | d <| | d <|  j  | É } qº Xn6 | j d d É } | j d d É } t j | | É } | S(   s(   Configure a formatter from a dictionary.s   ()s   'format'R/   RS   R0   N(   R∫   R©   R)   R   R2   R5   R   R6   (   RÄ   Rì   t   factoryRÉ   t   teRS   t   dfmt(    (    s$   /usr/lib/python2.7/logging/config.pyR∆   é  s    

c         C   sC   d | k r |  j  | É } n! | j d d É } t j | É } | S(   s%   Configure a filter from a dictionary.s   ()R   RA   (   R∫   R2   R   t   Filter(   RÄ   Rì   RÉ   R   (    (    s$   /usr/lib/python2.7/logging/config.pyR«   §  s
    c         C   s]   xV | D]N } y | j  |  j d | É Wq t k
 rT } t d | | f É Ç q Xq Wd S(   s/   Add filters to a filterer from a list of names.R¡   s   Unable to add filter %r: %sN(   t	   addFilterRì   R√   Rs   (   RÄ   t   filtererR¡   R?   Rû   (    (    s$   /usr/lib/python2.7/logging/config.pyt   add_filters≠  s
    c         C   s  | j  d d É } | r\ y |  j d | } Wq\ t k
 rX } t d | | f É Ç q\ Xn  | j  d d É } | j  d d É } d | k rÍ | j  d É } t | d É r· t t d É r· t | É t j k r· |  j	 | É } n  | } n<| j  d	 É } |  j	 | É }	 t
 |	 t j j É r™d
 | k r™yN |  j d | d
 }
 t |
 t j É sl| | d	 <t d É Ç n  |
 | d
 <Wq t k
 r¶} t d | d
 | f É Ç q Xnv t
 |	 t j j É rÂd | k rÂ|  j | d É | d <n; t
 |	 t j j É r d | k r |  j | d É | d <n  |	 } t g  | D]" } t | É r0| | | f ^ q0É } y | | ç  } WnJ t k
 r∑} d t | É k rïÇ  n  | j  d É | d <| | ç  } n X| rŒ| j | É n  | d k	 rÛ| j t j | É É n  | r|  j | | É n  | S(   s&   Configure a handler from a dictionary.R@   R   s   Unable to set formatter %r: %sRC   R¡   s   ()R≥   R¥   R1   RD   R   s   target not configured yets#   Unable to set target handler %r: %st   mailhostt   addresss   'stream't   streamt   strmN(   R   R5   Rì   R√   Rs   R   Rî   Rz   R¥   R°   RK   R   R   RL   R(   t   Handlert   SMTPHandlerRª   t   SysLogHandlerRà   Rv   R©   R)   RJ   RH   R¬   R÷   (   RÄ   Rì   R@   Rû   RC   R¡   R=   R–   t   cnameRR   t   thR∏   Rπ   RÉ   R—   (    (    s$   /usr/lib/python2.7/logging/config.pyR…   µ  sb    4	
5c         C   s]   xV | D]N } y | j  |  j d | É Wq t k
 rT } t d | | f É Ç q Xq Wd S(   s.   Add handlers to a logger from a list of names.R   s   Unable to add handler %r: %sN(   R^   Rì   R√   Rs   (   RÄ   Rl   R   RT   Rû   (    (    s$   /usr/lib/python2.7/logging/config.pyt   add_handlersÔ  s
    c         C   sº   | j  d d É } | d k	 r7 | j t j | É É n  | s∏ x | j D] } | j | É qH W| j  d d É } | rä |  j | | É n  | j  d d É } | r∏ |  j | | É q∏ n  d S(   sU   
        Perform configuration which is common to root and non-root loggers.
        RC   R   R¡   N(	   R2   R5   RH   R   R¬   R   R]   R‡   R÷   (   RÄ   Rl   Rì   R¿   RC   RT   R   R¡   (    (    s$   /usr/lib/python2.7/logging/config.pyt   common_logger_config˜  s    c         C   sP   t  j | É } |  j | | | É | j d d É } | d k	 rL | | _ n  d S(   s.   Configure a non-root logger from a dictionary.RZ   N(   R   Rc   R·   R2   R5   RZ   (   RÄ   R   Rì   R¿   Rl   RZ   (    (    s$   /usr/lib/python2.7/logging/config.pyRƒ   	  s
    c         C   s#   t  j É  } |  j | | | É d S(   s*   Configure a root logger from a dictionary.N(   R   Rc   R·   (   RÄ   Rì   R¿   RW   (    (    s$   /usr/lib/python2.7/logging/config.pyR≈     s    (   RÖ   RÜ   Rá   Rœ   R∆   R«   R÷   R…   R‡   Rã   R·   Rƒ   R≈   (    (    (    s$   /usr/lib/python2.7/logging/config.pyRæ   È  s   	ü					:	c         C   s   t  |  É j É  d S(   s%   Configure logging using a dictionary.N(   t   dictConfigClassRœ   (   Rì   (    (    s$   /usr/lib/python2.7/logging/config.pyt
   dictConfig  s    c            sp   t  s t d É Ç n  d t f d Ñ  É  Y} d t f d Ñ  É  Y} d t j f á  f d Ü  É  Yâ  à  | | |  É S(   sW  
    Start up a socket server on the specified port, and listen for new
    configurations.

    These will be sent as a file suitable for processing by fileConfig().
    Returns a Thread object on which you can call start() to start the server,
    and which you can join() when appropriate. To stop the server, call
    stopListening().
    s    listen() needs threading to workt   ConfigStreamHandlerc           B   s   e  Z d  Z d Ñ  Z RS(   s§   
        Handler for a logging configuration request.

        It expects a completely new logging configuration and uses fileConfig
        to install it.
        c   	      S   s~  d d l  } y@|  j } | j d É } t | É d k rKt j d | É d } |  j j | É } x3 t | É | k  rñ | | j | t | É É } qd Wy> d d l } | j | É } t | t	 É s  t
 Ç t | É WnQ t j | É } y t | É Wq)t t f k
 rÇ  q)t j É  q)Xn X|  j j rK|  j j j É  qKn  Wn+ t j k
 ry} | j t k rzÇ  qzn Xd S(   sË   
            Handle a request.

            Each request is expected to be a 4-byte length, packed using
            struct.pack(">L", n), followed by the config file.
            Uses fileConfig() to do the grunt work.
            iˇˇˇˇNi   s   >Li    (   t   tempfilet
   connectiont   recvR3   t   structt   unpackt   jsont   loadsR(   Rà   t   AssertionErrorR„   t	   cStringIOt   StringIOR   t   KeyboardInterruptt
   SystemExitt	   tracebackt	   print_exct   servert   readyt   sett   sockett   errort   errnot   RESET_ERROR(	   RÄ   RÂ   t   connt   chunkt   slenRÍ   R´   t   fileRû   (    (    s$   /usr/lib/python2.7/logging/config.pyt   handle1  s6    	!(   RÖ   RÜ   Rá   R˛   (    (    (    s$   /usr/lib/python2.7/logging/config.pyR‰   *  s   t   ConfigSocketReceiverc           B   s2   e  Z d  Z d Z d e d d d Ñ Z d Ñ  Z RS(   sD   
        A simple TCP socket-based logging config receiver.
        i   t	   localhostc         S   sL   t  j |  | | f | É t j É  d |  _ t j É  d |  _ | |  _ d  S(   Ni    i   (   R    Ró   R   R	   t   abortR   t   timeoutRÙ   (   RÄ   t   hostt   portRÀ   RÙ   (    (    s$   /usr/lib/python2.7/logging/config.pyRó   ^  s    
	
	c         S   sê   d d  l  } d } xj | s~ | j  |  j j É  g g  g  |  j É \ } } } | r^ |  j É  n  t j É  |  j } t j É  q W|  j j	 É  d  S(   Niˇˇˇˇi    (
   t   selectRˆ   t   filenoR  t   handle_requestR   R	   R  R   t   close(   RÄ   R  R  t   rdt   wrt   ex(    (    s$   /usr/lib/python2.7/logging/config.pyt   serve_until_stoppedg  s    	
	N(   RÖ   RÜ   Rá   t   allow_reuse_addresst   DEFAULT_LOGGING_CONFIG_PORTR5   Ró   R  (    (    (    s$   /usr/lib/python2.7/logging/config.pyRˇ   W  s
   t   Serverc              s    e  Z á  f d  Ü  Z d Ñ  Z RS(   c            sA   t  à  |  É j É  | |  _ | |  _ | |  _ t j É  |  _ d  S(   N(   t   superRó   t   rcvrt   hdlrR  t	   threadingt   EventRÙ   (   RÄ   R  R  R  (   R  (    s$   /usr/lib/python2.7/logging/config.pyRó   w  s
    			c         S   s~   |  j  d |  j d |  j d |  j É } |  j d k rI | j d |  _ n  |  j j É  t j É  | a t j	 É  | j
 É  d  S(   NR  RÀ   RÙ   i    i   (   R  R  R  RÙ   t   server_addressRı   R   R	   t	   _listenerR   R  (   RÄ   RÛ   (    (    s$   /usr/lib/python2.7/logging/config.pyt   run~  s    

(   RÖ   RÜ   Ró   R  (    (   R  (    s$   /usr/lib/python2.7/logging/config.pyR  u  s   (   t   threadt   NotImplementedErrorR   R    R  t   Thread(   R  R‰   Rˇ   (    (   R  s$   /usr/lib/python2.7/logging/config.pyt   listen  s    
-c           C   s8   t  j É  z t r% d t _ d a n  Wd t  j É  Xd S(   sN   
    Stop the listening server which was created with a call to listen().
    i   N(   R   R	   R  R  R5   R   (    (    (    s$   /usr/lib/python2.7/logging/config.pyt   stopListeningå  s    
	(2   Rá   RÌ   R¯   t   ioR   t   logging.handlerst   osRº   Rˆ   RË   Rô   RÒ   Rî   R  R  Rò   R5   t   SocketServerR    R   R  t
   ECONNRESETR˘   R  Rt   R   R!   R'   R,   R   R   R   RΩ   t   IRq   Rv   t   objectRw   Rà   R{   R[   R|   Rç   R}   Ré   Ræ   R‚   R„   R  R  (    (    (    s$   /usr/lib/python2.7/logging/config.pyt   <module>   sR   
						+	\	!
ãˇ .	o                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              # Copyright 2001-2013 by Vinay Sajip. All Rights Reserved.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose and without fee is hereby granted,
# provided that the above copyright notice appear in all copies and that
# both that copyright notice and this permission notice appear in
# supporting documentation, and that the name of Vinay Sajip
# not be used in advertising or publicity pertaining to distribution
# of the software without specific, written prior permission.
# VINAY SAJIP DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
# ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL
# VINAY SAJIP BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
# ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

"""
Additional handlers for the logging package for Python. The core package is
based on PEP 282 and comments thereto in comp.lang.python.

Copyright (C) 2001-2013 Vinay Sajip. All Rights Reserved.

To use, simply 'import logging.handlers' and log away!
"""

import errno, logging, socket, os, cPickle, struct, time, re
from stat import ST_DEV, ST_INO, ST_MTIME

try:
    import codecs
except ImportError:
    codecs = None
try:
    unicode
    _unicode = True
except NameError:
    _unicode = False

#
# Some constants...
#

DEFAULT_TCP_LOGGING_PORT    = 9020
DEFAULT_UDP_LOGGING_PORT    = 9021
DEFAULT_HTTP_LOGGING_PORT   = 9022
DEFAULT_SOAP_LOGGING_PORT   = 9023
SYSLOG_UDP_PORT             = 514
SYSLOG_TCP_PORT             = 514

_MIDNIGHT = 24 * 60 * 60  # number of seconds in a day

class BaseRotatingHandler(logging.FileHandler):
    """
    Base class for handlers that rotate log files at a certain point.
    Not meant to be instantiated directly.  Instead, use RotatingFileHandler
    or TimedRotatingFileHandler.
    """
    def __init__(self, filename, mode, encoding=None, delay=0):
        """
        Use the specified filename for streamed logging
        """
        if codecs is None:
            encoding = None
        logging.FileHandler.__init__(self, filename, mode, encoding, delay)
        self.mode = mode
        self.encoding = encoding

    def emit(self, record):
        """
        Emit a record.

        Output the record to the file, catering for rollover as described
        in doRollover().
        """
        try:
            if self.shouldRollover(record):
                self.doRollover()
            logging.FileHandler.emit(self, record)
        except (KeyboardInterrupt, SystemExit):
            raise
        except:
            self.handleError(record)

class RotatingFileHandler(BaseRotatingHandler):
    """
    Handler for logging to a set of files, which switches from one file
    to the next when the current file reaches a certain size.
    """
    def __init__(self, filename, mode='a', maxBytes=0, backupCount=0, encoding=None, delay=0):
        """
        Open the specified file and use it as the stream for logging.

        By default, the file grows indefinitely. You can specify particular
        values of maxBytes and backupCount to allow the file to rollover at
        a predetermined size.

        Rollover occurs whenever the current log file is nearly maxBytes in
        length. If backupCount is >= 1, the system will successively create
        new files with the same pathname as the base file, but with extensions
        ".1", ".2" etc. appended to it. For example, with a backupCount of 5
        and a base file name of "app.log", you would get "app.log",
        "app.log.1", "app.log.2", ... through to "app.log.5". The file being
        written to is always "app.log" - when it gets filled up, it is closed
        and renamed to "app.log.1", and if files "app.log.1", "app.log.2" etc.
        exist, then they are renamed to "app.log.2", "app.log.3" etc.
        respectively.

        If maxBytes is zero, rollover never occurs.
        """
        # If rotation/rollover is wanted, it doesn't make sense to use another
        # mode. If for example 'w' were specified, then if there were multiple
        # runs of the calling application, the logs from previous runs would be
        # lost if the 'w' is respected, because the log file would be truncated
        # on each run.
        if maxBytes > 0:
            mode = 'a'
        BaseRotatingHandler.__init__(self, filename, mode, encoding, delay)
        self.maxBytes = maxBytes
        self.backupCount = backupCount

    def doRollover(self):
        """
        Do a rollover, as described in __init__().
        """
        if self.stream:
            self.stream.close()
            self.stream = None
        if self.backupCount > 0:
            for i in range(self.backupCount - 1, 0, -1):
                sfn = "%s.%d" % (self.baseFilename, i)
                dfn = "%s.%d" % (self.baseFilename, i + 1)
                if os.path.exists(sfn):
                    #print "%s -> %s" % (sfn, dfn)
                    if os.path.exists(dfn):
                        os.remove(dfn)
                    os.rename(sfn, dfn)
            dfn = self.baseFilename + ".1"
            if os.path.exists(dfn):
                os.remove(dfn)
            # Issue 18940: A file may not have been created if delay is True.
            if os.path.exists(self.baseFilename):
                os.rename(self.baseFilename, dfn)
        if not self.delay:
            self.stream = self._open()

    def shouldRollover(self, record):
        """
        Determine if rollover should occur.

        Basically, see if the supplied record would cause the file to exceed
        the size limit we have.
        """
        if self.stream is None:                 # delay was set...
            self.stream = self._open()
        if self.maxBytes > 0:                   # are we rolling over?
            msg = "%s\n" % self.format(record)
            self.stream.seek(0, 2)  #due to non-posix-compliant Windows feature
            if self.stream.tell() + len(msg) >= self.maxBytes:
                return 1
        return 0

class TimedRotatingFileHandler(BaseRotatingHandler):
    """
    Handler for logging to a file, rotating the log file at certain timed
    intervals.

    If backupCount is > 0, when rollover is done, no more than backupCount
    files are kept - the oldest ones are deleted.
    """
    def __init__(self, filename, when='h', interval=1, backupCount=0, encoding=None, delay=False, utc=False):
        BaseRotatingHandler.__init__(self, filename, 'a', encoding, delay)
        self.when = when.upper()
        self.backupCount = backupCount
        self.utc = utc
        # Calculate the real rollover interval, which is just the number of
        # seconds between rollovers.  Also set the filename suffix used when
        # a rollover occurs.  Current 'when' events supported:
        # S - Seconds
        # M - Minutes
        # H - Hours
        # D - Days
        # midnight - roll over at midnight
        # W{0-6} - roll over on a certain day; 0 - Monday
        #
        # Case of the 'when' specifier is not important; lower or upper case
        # will work.
        if self.when == 'S':
            self.interval = 1 # one second
            self.suffix = "%Y-%m-%d_%H-%M-%S"
            self.extMatch = r"^\d{4}-\d{2}-\d{2}_\d{2}-\d{2}-\d{2}$"
        elif self.when == 'M':
            self.interval = 60 # one minute
            self.suffix = "%Y-%m-%d_%H-%M"
            self.extMatch = r"^\d{4}-\d{2}-\d{2}_\d{2}-\d{2}$"
        elif self.when == 'H':
            self.interval = 60 * 60 # one hour
            self.suffix = "%Y-%m-%d_%H"
            self.extMatch = r"^\d{4}-\d{2}-\d{2}_\d{2}$"
        elif self.when == 'D' or self.when == 'MIDNIGHT':
            self.interval = 60 * 60 * 24 # one day
            self.suffix = "%Y-%m-%d"
            self.extMatch = r"^\d{4}-\d{2}-\d{2}$"
        elif self.when.startswith('W'):
            self.interval = 60 * 60 * 24 * 7 # one week
            if len(self.when) != 2:
                raise ValueError("You must specify a day for weekly rollover from 0 to 6 (0 is Monday): %s" % self.when)
            if self.when[1] < '0' or self.when[1] > '6':
                raise ValueError("Invalid day specified for weekly rollover: %s" % self.when)
            self.dayOfWeek = int(self.when[1])
            self.suffix = "%Y-%m-%d"
            self.extMatch = r"^\d{4}-\d{2}-\d{2}$"
        else:
            raise ValueError("Invalid rollover interval specified: %s" % self.when)

        self.extMatch = re.compile(self.extMatch)
        self.interval = self.interval * interval # multiply by units requested
        if os.path.exists(filename):
            t = os.stat(filename)[ST_MTIME]
        else:
            t = int(time.time())
        self.rolloverAt = self.computeRollover(t)

    def computeRollover(self, currentTime):
        """
        Work out the rollover time based on the specified time.
        """
        result = currentTime + self.interval
        # If we are rolling over at midnight or weekly, then the interval is already known.
        # What we need to figure out is WHEN the next interval is.  In other words,
        # if you are rolling over at midnight, then your base interval is 1 day,
        # but you want to start that one day clock at midnight, not now.  So, we
        # have to fudge the rolloverAt value in order to trigger the first rollover
        # at the right time.  After that, the regular interval will take care of
        # the rest.  Note that this code doesn't care about leap seconds. :)
        if self.when == 'MIDNIGHT' or self.when.startswith('W'):
            # This could be done with less code, but I wanted it to be clear
            if self.utc:
                t = time.gmtime(currentTime)
            else:
                t = time.localtime(currentTime)
            currentHour = t[3]
            currentMinute = t[4]
            currentSecond = t[5]
            # r is the number of seconds left between now and midnight
            r = _MIDNIGHT - ((currentHour * 60 + currentMinute) * 60 +
                    currentSecond)
            result = currentTime + r
            # If we are rolling over on a certain day, add in the number of days until
            # the next rollover, but offset by 1 since we just calculated the time
            # until the next day starts.  There are three cases:
            # Case 1) The day to rollover is today; in this case, do nothing
            # Case 2) The day to rollover is further in the interval (i.e., today is
            #         day 2 (Wednesday) and rollover is on day 6 (Sunday).  Days to
            #         next rollover is simply 6 - 2 - 1, or 3.
            # Case 3) The day to rollover is behind us in the interval (i.e., today
            #         is day 5 (Saturday) and rollover is on day 3 (Thursday).
            #         Days to rollover is 6 - 5 + 3, or 4.  In this case, it's the
            #         number of days left in the current week (1) plus the number
            #         of days in the next week until the rollover day (3).
            # The calculations described in 2) and 3) above need to have a day added.
            # This is because the above time calculation takes us to midnight on this
            # day, i.e. the start of the next day.
            if self.when.startswith('W'):
                day = t[6] # 0 is Monday
                if day != self.dayOfWeek:
                    if day < self.dayOfWeek:
                        daysToWait = self.dayOfWeek - day
                    else:
                        daysToWait = 6 - day + self.dayOfWeek + 1
                    newRolloverAt = result + (daysToWait * (60 * 60 * 24))
                    if not self.utc:
                        dstNow = t[-1]
                        dstAtRollover = time.localtime(newRolloverAt)[-1]
                        if dstNow != dstAtRollover:
                            if not dstNow:  # DST kicks in before next rollover, so we need to deduct an hour
                                addend = -3600
                            else:           # DST bows out before next rollover, so we need to add an hour
                                addend = 3600
                            newRolloverAt += addend
                    result = newRolloverAt
        return result

    def shouldRollover(self, record):
        """
        Determine if rollover should occur.

        record is not used, as we are just comparing times, but it is needed so
        the method signatures are the same
        """
        t = int(time.time())
        if t >= self.rolloverAt:
            return 1
        #print "No need to rollover: %d, %d" % (t, self.rolloverAt)
        return 0

    def getFilesToDelete(self):
        """
        Determine the files to delete when rolling over.

        More specific than the earlier method, which just used glob.glob().
        """
        dirName, baseName = os.path.split(self.baseFilename)
        fileNames = os.listdir(dirName)
        result = []
        prefix = baseName + "."
        plen = len(prefix)
        for fileName in fileNames:
            if fileName[:plen] == prefix:
                suffix = fileName[plen:]
                if self.extMatch.match(suffix):
                    result.append(os.path.join(dirName, fileName))
        result.sort()
        if len(result) < self.backupCount:
            result = []
        else:
            result = result[:len(result) - self.backupCount]
        return result

    def doRollover(self):
        """
        do a rollover; in this case, a date/time stamp is appended to the filename
        when the rollover happens.  However, you want the file to be named for the
        start of the interval, not the current time.  If there is a backup count,
        then we have to get a list of matching filenames, sort them and remove
        the one with the oldest suffix.
        """
        if self.stream:
            self.stream.close()
            self.stream = None
        # get the time that this sequence started at and make it a TimeTuple
        currentTime = int(time.time())
        dstNow = time.localtime(currentTime)[-1]
        t = self.rolloverAt - self.interval
        if self.utc:
            timeTuple = time.gmtime(t)
        else:
            timeTuple = time.localtime(t)
            dstThen = timeTuple[-1]
            if dstNow != dstThen:
                if dstNow:
                    addend = 3600
                else:
                    addend = -3600
                timeTuple = time.localtime(t + addend)
        dfn = self.baseFilename + "." + time.strftime(self.suffix, timeTuple)
        if os.path.exists(dfn):
            os.remove(dfn)
        # Issue 18940: A file may not have been created if delay is True.
        if os.path.exists(self.baseFilename):
            os.rename(self.baseFilename, dfn)
        if self.backupCount > 0:
            for s in self.getFilesToDelete():
                os.remove(s)
        if not self.delay:
            self.stream = self._open()
        newRolloverAt = self.computeRollover(currentTime)
        while newRolloverAt <= currentTime:
            newRolloverAt = newRolloverAt + self.interval
        #If DST changes and midnight or weekly rollover, adjust for this.
        if (self.when == 'MIDNIGHT' or self.when.startswith('W')) and not self.utc:
            dstAtRollover = time.localtime(newRolloverAt)[-1]
            if dstNow != dstAtRollover:
                if not dstNow:  # DST kicks in before next rollover, so we need to deduct an hour
                    addend = -3600
                else:           # DST bows out before next rollover, so we need to add an hour
                    addend = 3600
                newRolloverAt += addend
        self.rolloverAt = newRolloverAt

class WatchedFileHandler(logging.FileHandler):
    """
    A handler for logging to a file, which watches the file
    to see if it has changed while in use. This can happen because of
    usage of programs such as newsyslog and logrotate which perform
    log file rotation. This handler, intended for use under Unix,
    watches the file to see if it has changed since the last emit.
    (A file has changed if its device or inode have changed.)
    If it has changed, the old file stream is closed, and the file
    opened to get a new stream.

    This handler is not appropriate for use under Windows, because
    under Windows open files cannot be moved or renamed - logging
    opens the files with exclusive locks - and so there is no need
    for such a handler. Furthermore, ST_INO is not supported under
    Windows; stat always returns zero for this value.

    This handler is based on a suggestion and patch by Chad J.
    Schroeder.
    """
    def __init__(self, filename, mode='a', encoding=None, delay=0):
        logging.FileHandler.__init__(self, filename, mode, encoding, delay)
        self.dev, self.ino = -1, -1
        self._statstream()

    def _statstream(self):
        if self.stream:
            sres = os.fstat(self.stream.fileno())
            self.dev, self.ino = sres[ST_DEV], sres[ST_INO]

    def emit(self, record):
        """
        Emit a record.

        First check if the underlying file has changed, and if it
        has, close the old stream and reopen the file to get the
        current stream.
        """
        # Reduce the chance of race conditions by stat'ing by path only
        # once and then fstat'ing our new fd if we opened a new log stream.
        # See issue #14632: Thanks to John Mulligan for the problem report
        # and patch.
        try:
            # stat the file by path, checking for existence
            sres = os.stat(self.baseFilename)
        except OSError as err:
            if err.errno == errno.ENOENT:
                sres = None
            else:
                raise
        # compare file system stat with that of our stream file handle
        if not sres or sres[ST_DEV] != self.dev or sres[ST_INO] != self.ino:
            if self.stream is not None:
                # we have an open file handle, clean it up
                self.stream.flush()
                self.stream.close()
                self.stream = None  # See Issue #21742: _open () might fail.
                # open a new file handle and get new stat info from that fd
                self.stream = self._open()
                self._statstream()
        logging.FileHandler.emit(self, record)

class SocketHandler(logging.Handler):
    """
    A handler class which writes logging records, in pickle format, to
    a streaming socket. The socket is kept open across logging calls.
    If the peer resets it, an attempt is made to reconnect on the next call.
    The pickle which is sent is that of the LogRecord's attribute dictionary
    (__dict__), so that the receiver does not need to have the logging module
    installed in order to process the logging event.

    To unpickle the record at the receiving end into a LogRecord, use the
    makeLogRecord function.
    """

    def __init__(self, host, port):
        """
        Initializes the handler with a specific host address and port.

        The attribute 'closeOnError' is set to 1 - which means that if
        a socket error occurs, the socket is silently closed and then
        reopened on the next logging call.
        """
        logging.Handler.__init__(self)
        self.host = host
        self.port = port
        self.sock = None
        self.closeOnError = 0
        self.retryTime = None
        #
        # Exponential backoff parameters.
        #
        self.retryStart = 1.0
        self.retryMax = 30.0
        self.retryFactor = 2.0

    def makeSocket(self, timeout=1):
        """
        A factory method which allows subclasses to define the precise
        type of socket they want.
        """
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        if hasattr(s, 'settimeout'):
            s.settimeout(timeout)
        s.connect((self.host, self.port))
        return s

    def createSocket(self):
        """
        Try to create a socket, using an exponential backoff with
        a max retry time. Thanks to Robert Olson for the original patch
        (SF #815911) which has been slightly refactored.
        """
        now = time.time()
        # Either retryTime is None, in which case this
        # is the first time back after a disconnect, or
        # we've waited long enough.
        if self.retryTime is None:
            attempt = 1
        else:
            attempt = (now >= self.retryTime)
        if attempt:
            try:
                self.sock = self.makeSocket()
                self.retryTime = None # next time, no delay before trying
            except socket.error:
                #Creation failed, so set the retry time and return.
                if self.retryTime is None:
                    self.retryPeriod = self.retryStart
                else:
                    self.retryPeriod = self.retryPeriod * self.retryFactor
                    if self.retryPeriod > self.retryMax:
                        self.retryPeriod = self.retryMax
                self.retryTime = now + self.retryPeriod

    def send(self, s):
        """
        Send a pickled string to the socket.

        This function allows for partial sends which can happen when the
        network is busy.
        """
        if self.sock is None:
            self.createSocket()
        #self.sock can be None either because we haven't reached the retry
        #time yet, or because we have reached the retry time and retried,
        #but are still unable to connect.
        if self.sock:
            try:
                if hasattr(self.sock, "sendall"):
                    self.sock.sendall(s)
                else:
                    sentsofar = 0
                    left = len(s)
                    while left > 0:
                        sent = self.sock.send(s[sentsofar:])
                        sentsofar = sentsofar + sent
                        left = left - sent
            except socket.error:
                self.sock.close()
                self.sock = None  # so we can call createSocket next time

    def makePickle(self, record):
        """
        Pickles the record in binary format with a length prefix, and
        returns it ready for transmission across the socket.
        """
        ei = record.exc_info
        if ei:
            # just to get traceback text into record.exc_text ...
            dummy = self.format(record)
            record.exc_info = None  # to avoid Unpickleable error
        # See issue #14436: If msg or args are objects, they may not be
        # available on the receiving end. So we convert the msg % args
        # to a string, save it as msg and zap the args.
        d = dict(record.__dict__)
        d['msg'] = record.getMessage()
        d['args'] = None
        s = cPickle.dumps(d, 1)
        if ei:
            record.exc_info = ei  # for next handler
        slen = struct.pack(">L", len(s))
        return slen + s

    def handleError(self, record):
        """
        Handle an error during logging.

        An error has occurred during logging. Most likely cause -
        connection lost. Close the socket so that we can retry on the
        next event.
        """
        if self.closeOnError and self.sock:
            self.sock.close()
            self.sock = None        #try to reconnect next time
        else:
            logging.Handler.handleError(self, record)

    def emit(self, record):
        """
        Emit a record.

        Pickles the record and writes it to the socket in binary format.
        If there is an error with the socket, silently drop the packet.
        If there was a problem with the socket, re-establishes the
        socket.
        """
        try:
            s = self.makePickle(record)
            self.send(s)
        except (KeyboardInterrupt, SystemExit):
            raise
        except:
            self.handleError(record)

    def close(self):
        """
        Closes the socket.
        """
        self.acquire()
        try:
            sock = self.sock
            if sock:
                self.sock = None
                sock.close()
        finally:
            self.release()
        logging.Handler.close(self)

class DatagramHandler(SocketHandler):
    """
    A handler class which writes logging records, in pickle format, to
    a datagram socket.  The pickle which is sent is that of the LogRecord's
    attribute dictionary (__dict__), so that the receiver does not need to
    have the logging module installed in order to process the logging event.

    To unpickle the record at the receiving end into a LogRecord, use the
    makeLogRecord function.

    """
    def __init__(self, host, port):
        """
        Initializes the handler with a specific host address and port.
        """
        SocketHandler.__init__(self, host, port)
        self.closeOnError = 0

    def makeSocket(self):
        """
        The factory method of SocketHandler is here overridden to create
        a UDP socket (SOCK_DGRAM).
        """
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        return s

    def send(self, s):
        """
        Send a pickled string to a socket.

        This function no longer allows for partial sends which can happen
        when the network is busy - UDP does not guarantee delivery and
        can deliver packets out of sequence.
        """
        if self.sock is None:
            self.createSocket()
        self.sock.sendto(s, (self.host, self.port))

class SysLogHandler(logging.Handler):
    """
    A handler class which sends formatted logging records to a syslog
    server. Based on Sam Rushing's syslog module:
    http://www.nightmare.com/squirl/python-ext/misc/syslog.py
    Contributed by Nicolas Untz (after which minor refactoring changes
    have been made).
    """

    # from <linux/sys/syslog.h>:
    # ======================================================================
    # priorities/facilities are encoded into a single 32-bit quantity, where
    # the bottom 3 bits are the priority (0-7) and the top 28 bits are the
    # facility (0-big number). Both the priorities and the facilities map
    # roughly one-to-one to strings in the syslogd(8) source code.  This
    # mapping is included in this file.
    #
    # priorities (these are ordered)

    LOG_EMERG     = 0       #  system is unusable
    LOG_ALERT     = 1       #  action must be taken immediately
    LOG_CRIT      = 2       #  critical conditions
    LOG_ERR       = 3       #  error conditions
    LOG_WARNING   = 4       #  warning conditions
    LOG_NOTICE    = 5       #  normal but significant condition
    LOG_INFO      = 6       #  informational
    LOG_DEBUG     = 7       #  debug-level messages

    #  facility codes
    LOG_KERN      = 0       #  kernel messages
    LOG_USER      = 1       #  random user-level messages
    LOG_MAIL      = 2       #  mail system
    LOG_DAEMON    = 3       #  system daemons
    LOG_AUTH      = 4       #  security/authorization messages
    LOG_SYSLOG    = 5       #  messages generated internally by syslogd
    LOG_LPR       = 6       #  line printer subsystem
    LOG_NEWS      = 7       #  network news subsystem
    LOG_UUCP      = 8       #  UUCP subsystem
    LOG_CRON      = 9       #  clock daemon
    LOG_AUTHPRIV  = 10      #  security/authorization messages (private)
    LOG_FTP       = 11      #  FTP daemon

    #  other codes through 15 reserved for system use
    LOG_LOCAL0    = 16      #  reserved for local use
    LOG_LOCAL1    = 17      #  reserved for local use
    LOG_LOCAL2    = 18      #  reserved for local use
    LOG_LOCAL3    = 19      #  reserved for local use
    LOG_LOCAL4    = 20      #  reserved for local use
    LOG_LOCAL5    = 21      #  reserved for local use
    LOG_LOCAL6    = 22      #  reserved for local use
    LOG_LOCAL7    = 23      #  reserved for local use

    priority_names = {
        "alert":    LOG_ALERT,
        "crit":     LOG_CRIT,
        "critical": LOG_CRIT,
        "debug":    LOG_DEBUG,
        "emerg":    LOG_EMERG,
        "err":      LOG_ERR,
        "error":    LOG_ERR,        #  DEPRECATED
        "info":     LOG_INFO,
        "notice":   LOG_NOTICE,
        "panic":    LOG_EMERG,      #  DEPRECATED
        "warn":     LOG_WARNING,    #  DEPRECATED
        "warning":  LOG_WARNING,
        }

    facility_names = {
        "auth":     LOG_AUTH,
        "authpriv": LOG_AUTHPRIV,
        "cron":     LOG_CRON,
        "daemon":   LOG_DAEMON,
        "ftp":      LOG_FTP,
        "kern":     LOG_KERN,
        "lpr":      LOG_LPR,
        "mail":     LOG_MAIL,
        "news":     LOG_NEWS,
        "security": LOG_AUTH,       #  DEPRECATED
        "syslog":   LOG_SYSLOG,
        "user":     LOG_USER,
        "uucp":     LOG_UUCP,
        "local0":   LOG_LOCAL0,
        "local1":   LOG_LOCAL1,
        "local2":   LOG_LOCAL2,
        "local3":   LOG_LOCAL3,
        "local4":   LOG_LOCAL4,
        "local5":   LOG_LOCAL5,
        "local6":   LOG_LOCAL6,
        "local7":   LOG_LOCAL7,
        }

    #The map below appears to be trivially lowercasing the key. However,
    #there's more to it than meets the eye - in some locales, lowercasing
    #gives unexpected results. See SF #1524081: in the Turkish locale,
    #"INFO".lower() != "info"
    priority_map = {
        "DEBUG" : "debug",
        "INFO" : "info",
        "WARNING" : "warning",
        "ERROR" : "error",
        "CRITICAL" : "critical"
    }

    def __init__(self, address=('localhost', SYSLOG_UDP_PORT),
                 facility=LOG_USER, socktype=None):
        """
        Initialize a handler.

        If address is specified as a string, a UNIX socket is used. To log to a
        local syslogd, "SysLogHandler(address="/dev/log")" can be used.
        If facility is not specified, LOG_USER is used. If socktype is
        specified as socket.SOCK_DGRAM or socket.SOCK_STREAM, that specific
        socket type will be used. For Unix sockets, you can also specify a
        socktype of None, in which case socket.SOCK_DGRAM will be used, falling
        back to socket.SOCK_STREAM.
        """
        logging.Handler.__init__(self)

        self.address = address
        self.facility = facility
        self.socktype = socktype

        if isinstance(address, basestring):
            self.unixsocket = 1
            self._connect_unixsocket(address)
        else:
            self.unixsocket = 0
            if socktype is None:
                socktype = socket.SOCK_DGRAM
            self.socket = socket.socket(socket.AF_INET, socktype)
            if socktype == socket.SOCK_STREAM:
                self.socket.connect(address)
            self.socktype = socktype
        self.formatter = None

    def _connect_unixsocket(self, address):
        use_socktype = self.socktype
        if use_socktype is None:
            use_socktype = socket.SOCK_DGRAM
        self.socket = socket.socket(socket.AF_UNIX, use_socktype)
        try:
            self.socket.connect(address)
            # it worked, so set self.socktype to the used type
            self.socktype = use_socktype
        except socket.error:
            self.socket.close()
            if self.socktype is not None:
                # user didn't specify falling back, so fail
                raise
            use_socktype = socket.SOCK_STREAM
            self.socket = socket.socket(socket.AF_UNIX, use_socktype)
            try:
                self.socket.connect(address)
                # it worked, so set self.socktype to the used type
                self.socktype = use_socktype
            except socket.error:
                self.socket.close()
                raise

    # curious: when talking to the unix-domain '/dev/log' socket, a
    #   zero-terminator seems to be required.  this string is placed
    #   into a class variable so that it can be overridden if
    #   necessary.
    log_format_string = '<%d>%s\000'

    def encodePriority(self, facility, priority):
        """
        Encode the facility and priority. You can pass in strings or
        integers - if strings are passed, the facility_names and
        priority_names mapping dictionaries are used to convert them to
        integers.
        """
        if isinstance(facility, basestring):
            facility = self.facility_names[facility]
        if isinstance(priority, basestring):
            priority = self.priority_names[priority]
        return (facility << 3) | priority

    def close (self):
        """
        Closes the socket.
        """
        self.acquire()
        try:
            if self.unixsocket:
                self.socket.close()
        finally:
            self.release()
        logging.Handler.close(self)

    def mapPriority(self, levelName):
        """
        Map a logging level name to a key in the priority_names map.
        This is useful in two scenarios: when custom levels are being
        used, and in the case where you can't do a straightforward
        mapping by lowercasing the logging level name because of locale-
        specific issues (see SF #1524081).
        """
        return self.priority_map.get(levelName, "warning")

    def emit(self, record):
        """
        Emit a record.

        The record is formatted, and then sent to the syslog server. If
        exception information is present, it is NOT sent to the server.
        """
        try:
            msg = self.format(record) + '\000'
            """
            We need to convert record level to lowercase, maybe this will
            change in the future.
            """
            prio = '<%d>' % self.encodePriority(self.facility,
                                                self.mapPriority(record.levelname))
            # Message is a string. Convert to bytes as required by RFC 5424
            if type(msg) is unicode:
                msg = msg.encode('utf-8')
            msg = prio + msg
            if self.unixsocket:
                try:
                    self.socket.send(msg)
                except socket.error:
                    self.socket.close() # See issue 17981
                    self._connect_unixsocket(self.address)
                    self.socket.send(msg)
            elif self.socktype == socket.SOCK_DGRAM:
                self.socket.sendto(msg, self.address)
            else:
                self.socket.sendall(msg)
        except (KeyboardInterrupt, SystemExit):
            raise
        except:
            self.handleError(record)

class SMTPHandler(logging.Handler):
    """
    A handler class which sends an SMTP email for each logging event.
    """
    def __init__(self, mailhost, fromaddr, toaddrs, subject,
                 credentials=None, secure=None):
        """
        Initialize the handler.

        Initialize the instance with the from and to addresses and subject
        line of the email. To specify a non-standard SMTP port, use the
        (host, port) tuple format for the mailhost argument. To specify
        authentication credentials, supply a (username, password) tuple
        for the credentials argument. To specify the use of a secure
        protocol (TLS), pass in a tuple for the secure argument. This will
        only be used when authentication credentials are supplied. The tuple
        will be either an empty tuple, or a single-value tuple with the name
        of a keyfile, or a 2-value tuple with the names of the keyfile and
        certificate file. (This tuple is passed to the `starttls` method).
        """
        logging.Handler.__init__(self)
        if isinstance(mailhost, (list, tuple)):
            self.mailhost, self.mailport = mailhost
        else:
            self.mailhost, self.mailport = mailhost, None
        if isinstance(credentials, (list, tuple)):
            self.username, self.password = credentials
        else:
            self.username = None
        self.fromaddr = fromaddr
        if isinstance(toaddrs, basestring):
            toaddrs = [toaddrs]
        self.toaddrs = toaddrs
        self.subject = subject
        self.secure = secure
        self._timeout = 5.0

    def getSubject(self, record):
        """
        Determine the subject for the email.

        If you want to specify a subject line which is record-dependent,
        override this method.
        """
        return self.subject

    def emit(self, record):
        """
        Emit a record.

        Format the record and send it to the specified addressees.
        """
        try:
            import smtplib
            from email.utils import formatdate
            port = self.mailport
            if not port:
                port = smtplib.SMTP_PORT
            smtp = smtplib.SMTP(self.mailhost, port, timeout=self._timeout)
            msg = self.format(record)
            msg = "From: %s\r\nTo: %s\r\nSubject: %s\r\nDate: %s\r\n\r\n%s" % (
                            self.fromaddr,
                            ",".join(self.toaddrs),
                            self.getSubject(record),
                            formatdate(), msg)
            if self.username:
                if self.secure is not None:
                    smtp.ehlo()
                    smtp.starttls(*self.secure)
                    smtp.ehlo()
                smtp.login(self.username, self.password)
            smtp.sendmail(self.fromaddr, self.toaddrs, msg)
            smtp.quit()
        except (KeyboardInterrupt, SystemExit):
            raise
        except:
            self.handleError(record)

class NTEventLogHandler(logging.Handler):
    """
    A handler class which sends events to the NT Event Log. Adds a
    registry entry for the specified application name. If no dllname is
    provided, win32service.pyd (which contains some basic message
    placeholders) is used. Note that use of these placeholders will make
    your event logs big, as the entire message source is held in the log.
    If you want slimmer logs, you have to pass in the name of your own DLL
    which contains the message definitions you want to use in the event log.
    """
    def __init__(self, appname, dllname=None, logtype="Application"):
        logging.Handler.__init__(self)
        try:
            import win32evtlogutil, win32evtlog
            self.appname = appname
            self._welu = win32evtlogutil
            if not dllname:
                dllname = os.path.split(self._welu.__file__)
                dllname = os.path.split(dllname[0])
                dllname = os.path.join(dllname[0], r'win32service.pyd')
            self.dllname = dllname
            self.logtype = logtype
            self._welu.AddSourceToRegistry(appname, dllname, logtype)
            self.deftype = win32evtlog.EVENTLOG_ERROR_TYPE
            self.typemap = {
                logging.DEBUG   : win32evtlog.EVENTLOG_INFORMATION_TYPE,
                logging.INFO    : win32evtlog.EVENTLOG_INFORMATION_TYPE,
                logging.WARNING : win32evtlog.EVENTLOG_WARNING_TYPE,
                logging.ERROR   : win32evtlog.EVENTLOG_ERROR_TYPE,
                logging.CRITICAL: win32evtlog.EVENTLOG_ERROR_TYPE,
         }
        except ImportError:
            print("The Python Win32 extensions for NT (service, event "\
                        "logging) appear not to be available.")
            self._welu = None

    def getMessageID(self, record):
        """
        Return the message ID for the event record. If you are using your
        own messages, you could do this by having the msg passed to the
        logger being an ID rather than a formatting string. Then, in here,
        you could use a dictionary lookup to get the message ID. This
        version returns 1, which is the base message ID in win32service.pyd.
        """
        return 1

    def getEventCategory(self, record):
        """
        Return the event category for the record.

        Override this if you want to specify your own categories. This version
        returns 0.
        """
        return 0

    def getEventType(self, record):
        """
        Return the event type for the record.

        Override this if you want to specify your own types. This version does
        a mapping using the handler's typemap attribute, which is set up in
        __init__() to a dictionary which contains mappings for DEBUG, INFO,
        WARNING, ERROR and CRITICAL. If you are using your own levels you will
        either need to override this method or place a suitable dictionary in
        the handler's typemap attribute.
        """
        return self.typemap.get(record.levelno, self.deftype)

    def emit(self, record):
        """
        Emit a record.

        Determine the message ID, event category and event type. Then
        log the message in the NT event log.
        """
        if self._welu:
            try:
                id = self.getMessageID(record)
                cat = self.getEventCategory(record)
                type = self.getEventType(record)
                msg = self.format(record)
                self._welu.ReportEvent(self.appname, id, cat, type, [msg])
            except (KeyboardInterrupt, SystemExit):
                raise
            except:
                self.handleError(record)

    def close(self):
        """
        Clean up this handler.

        You can remove the application name from the registry as a
        source of event log entries. However, if you do this, you will
        not be able to see the events as you intended in the Event Log
        Viewer - it needs to be able to access the registry to get the
        DLL name.
        """
        #self._welu.RemoveSourceFromRegistry(self.appname, self.logtype)
        logging.Handler.close(self)

class HTTPHandler(logging.Handler):
    """
    A class which sends records to a Web server, using either GET or
    POST semantics.
    """
    def __init__(self, host, url, method="GET"):
        """
        Initialize the instance with the host, the request URL, and the method
        ("GET" or "POST")
        """
        logging.Handler.__init__(self)
        method = method.upper()
        if method not in ["GET", "POST"]:
            raise ValueError("method must be GET or POST")
        self.host = host
        self.url = url
        self.method = method

    def mapLogRecord(self, record):
        """
        Default implementation of mapping the log record into a dict
        that is sent as the CGI data. Overwrite in your class.
        Contributed by Franz Glasner.
        """
        return record.__dict__

    def emit(self, record):
        """
        Emit a record.

        Send the record to the Web server as a percent-encoded dictionary
        """
        try:
            import httplib, urllib
            host = self.host
            h = httplib.HTTP(host)
            url = self.url
            data = urllib.urlencode(self.mapLogRecord(record))
            if self.method == "GET":
                if (url.find('?') >= 0):
                    sep = '&'
                else:
                    sep = '?'
                url = url + "%c%s" % (sep, data)
            h.putrequest(self.method, url)
            # support multiple hosts on one IP address...
            # need to strip optional :port from host, if present
            i = host.find(":")
            if i >= 0:
                host = host[:i]
            h.putheader("Host", host)
            if self.method == "POST":
                h.putheader("Content-type",
                            "application/x-www-form-urlencoded")
                h.putheader("Content-length", str(len(data)))
            h.endheaders(data if self.method == "POST" else None)
            h.getreply()    #can't do anything with the result
        except (KeyboardInterrupt, SystemExit):
            raise
        except:
            self.handleError(record)

class BufferingHandler(logging.Handler):
    """
  A handler class which buffers logging records in memory. Whenever each
  record is added to the buffer, a check is made to see if the buffer should
  be flushed. If it should, then flush() is expected to do what's needed.
    """
    def __init__(self, capacity):
        """
        Initialize the handler with the buffer size.
        """
        logging.Handler.__init__(self)
        self.capacity = capacity
        self.buffer = []

    def shouldFlush(self, record):
        """
        Should the handler flush its buffer?

        Returns true if the buffer is up to capacity. This method can be
        overridden to implement custom flushing strategies.
        """
        return (len(self.buffer) >= self.capacity)

    def emit(self, record):
        """
        Emit a record.

        Append the record. If shouldFlush() tells us to, call flush() to process
        the buffer.
        """
        self.buffer.append(record)
        if self.shouldFlush(record):
            self.flush()

    def flush(self):
        """
        Override to implement custom flushing behaviour.

        This version just zaps the buffer to empty.
        """
        self.acquire()
        try:
            self.buffer = []
        finally:
            self.release()

    def close(self):
        """
        Close the handler.

        This version just flushes and chains to the parent class' close().
        """
        try:
            self.flush()
        finally:
            logging.Handler.close(self)

class MemoryHandler(BufferingHandler):
    """
    A handler class which buffers logging records in memory, periodically
    flushing them to a target handler. Flushing occurs whenever the buffer
    is full, or when an event of a certain severity or greater is seen.
    """
    def __init__(self, capacity, flushLevel=logging.ERROR, target=None):
        """
        Initialize the handler with the buffer size, the level at which
        flushing should occur and an optional target.

        Note that without a target being set either here or via setTarget(),
        a MemoryHandler is no use to anyone!
        """
        BufferingHandler.__init__(self, capacity)
        self.flushLevel = flushLevel
        self.target = target

    def shouldFlush(self, record):
        """
        Check for buffer full or a record at the flushLevel or higher.
        """
        return (len(self.buffer) >= self.capacity) or \
                (record.levelno >= self.flushLevel)

    def setTarget(self, target):
        """
        Set the target handler for this handler.
        """
        self.target = target

    def flush(self):
        """
        For a MemoryHandler, flushing means just sending the buffered
        records to the target, if there is one. Override if you want
        different behaviour.
        """
        self.acquire()
        try:
            if self.target:
                for record in self.buffer:
                    self.target.handle(record)
                self.buffer = []
        finally:
            self.release()

    def close(self):
        """
        Flush, set the target to None and lose the buffer.
        """
        try:
            self.flush()
        finally:
            self.acquire()
            try:
                self.target = None
                BufferingHandler.close(self)
            finally:
                self.release()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             Û
”´[c           @   s"  d  Z  d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l	 m
 Z
 m Z m Z y d d l Z Wn e k
 r´ d Z n Xy e e Z Wn e k
 r” e Z n Xd Z d Z d Z d Z d Z d Z d$ Z d e j f d Ñ  É  YZ d e f d Ñ  É  YZ d e f d Ñ  É  YZ d e j f d Ñ  É  YZ  d e j! f d Ñ  É  YZ" d e" f d Ñ  É  YZ# d e j! f d Ñ  É  YZ$ d e j! f d Ñ  É  YZ% d e j! f d Ñ  É  YZ& d e j! f d Ñ  É  YZ' d e j! f d  Ñ  É  YZ( d! e( f d" Ñ  É  YZ) d S(%   s˚   
Additional handlers for the logging package for Python. The core package is
based on PEP 282 and comments thereto in comp.lang.python.

Copyright (C) 2001-2013 Vinay Sajip. All Rights Reserved.

To use, simply 'import logging.handlers' and log away!
iˇˇˇˇN(   t   ST_DEVt   ST_INOt   ST_MTIMEi<#  i=#  i>#  i?#  i  i   i<   t   BaseRotatingHandlerc           B   s&   e  Z d  Z d d d Ñ Z d Ñ  Z RS(   sπ   
    Base class for handlers that rotate log files at a certain point.
    Not meant to be instantiated directly.  Instead, use RotatingFileHandler
    or TimedRotatingFileHandler.
    i    c         C   sG   t  d k r d } n  t j j |  | | | | É | |  _ | |  _ d S(   sA   
        Use the specified filename for streamed logging
        N(   t   codecst   Nonet   loggingt   FileHandlert   __init__t   modet   encoding(   t   selft   filenameR	   R
   t   delay(    (    s&   /usr/lib/python2.7/logging/handlers.pyR   :   s
    		c         C   sg   y3 |  j  | É r |  j É  n  t j j |  | É Wn- t t f k
 rO Ç  n |  j | É n Xd S(   sÑ   
        Emit a record.

        Output the record to the file, catering for rollover as described
        in doRollover().
        N(   t   shouldRollovert
   doRolloverR   R   t   emitt   KeyboardInterruptt
   SystemExitt   handleError(   R   t   record(    (    s&   /usr/lib/python2.7/logging/handlers.pyR   D   s    N(   t   __name__t
   __module__t   __doc__R   R   R   (    (    (    s&   /usr/lib/python2.7/logging/handlers.pyR   4   s   
t   RotatingFileHandlerc           B   s8   e  Z d  Z d d d d d d Ñ Z d Ñ  Z d Ñ  Z RS(   sã   
    Handler for logging to a set of files, which switches from one file
    to the next when the current file reaches a certain size.
    t   ai    c         C   sD   | d k r d } n  t  j |  | | | | É | |  _ | |  _ d S(   s˙  
        Open the specified file and use it as the stream for logging.

        By default, the file grows indefinitely. You can specify particular
        values of maxBytes and backupCount to allow the file to rollover at
        a predetermined size.

        Rollover occurs whenever the current log file is nearly maxBytes in
        length. If backupCount is >= 1, the system will successively create
        new files with the same pathname as the base file, but with extensions
        ".1", ".2" etc. appended to it. For example, with a backupCount of 5
        and a base file name of "app.log", you would get "app.log",
        "app.log.1", "app.log.2", ... through to "app.log.5". The file being
        written to is always "app.log" - when it gets filled up, it is closed
        and renamed to "app.log.1", and if files "app.log.1", "app.log.2" etc.
        exist, then they are renamed to "app.log.2", "app.log.3" etc.
        respectively.

        If maxBytes is zero, rollover never occurs.
        i    R   N(   R   R   t   maxBytest   backupCount(   R   R   R	   R   R   R
   R   (    (    s&   /usr/lib/python2.7/logging/handlers.pyR   Y   s
    		c         C   sB  |  j  r" |  j  j É  d |  _  n  |  j d k r#xí t |  j d d d É D]w } d |  j | f } d |  j | d f } t j j | É rK t j j | É rØ t j	 | É n  t j
 | | É qK qK W|  j d } t j j | É rı t j	 | É n  t j j |  j É r#t j
 |  j | É q#n  |  j s>|  j É  |  _  n  d S(   s<   
        Do a rollover, as described in __init__().
        i    i   iˇˇˇˇs   %s.%ds   .1N(   t   streamt   closeR   R   t   ranget   baseFilenamet   ost   patht   existst   removet   renameR   t   _open(   R   t   it   sfnt   dfn(    (    s&   /usr/lib/python2.7/logging/handlers.pyR   y   s$    	 	c         C   sÉ   |  j  d k r! |  j É  |  _  n  |  j d k r d |  j | É } |  j  j d d É |  j  j É  t | É |  j k r d Sn  d S(   s£   
        Determine if rollover should occur.

        Basically, see if the supplied record would cause the file to exceed
        the size limit we have.
        i    s   %s
i   i   N(   R   R   R%   R   t   formatt   seekt   tellt   len(   R   R   t   msg(    (    s&   /usr/lib/python2.7/logging/handlers.pyR   í   s    "N(   R   R   R   R   R   R   R   (    (    (    s&   /usr/lib/python2.7/logging/handlers.pyR   T   s    	t   TimedRotatingFileHandlerc           B   sM   e  Z d  Z d d d d	 e e d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 RS(
   s‹   
    Handler for logging to a file, rotating the log file at certain timed
    intervals.

    If backupCount is > 0, when rollover is done, no more than backupCount
    files are kept - the oldest ones are deleted.
    t   hi   i    c   	      C   s2  t  j |  | d | | É | j É  |  _ | |  _ | |  _ |  j d k rg d |  _ d |  _ d |  _ nV|  j d k rî d |  _ d |  _ d	 |  _ n)|  j d
 k r¡ d |  _ d |  _ d |  _ n¸ |  j d k sﬂ |  j d k r˝ d |  _ d |  _ d |  _ n¿ |  j j	 d É r™d |  _ t
 |  j É d k rCt d |  j É Ç n  |  j d d k  si|  j d d k rt d |  j É Ç n  t |  j d É |  _ d |  _ d |  _ n t d |  j É Ç t j |  j É |  _ |  j | |  _ t j j | É r
t j | É t } n t t j É  É } |  j | É |  _ d  S(    NR   t   Si   s   %Y-%m-%d_%H-%M-%Ss%   ^\d{4}-\d{2}-\d{2}_\d{2}-\d{2}-\d{2}$t   Mi<   s   %Y-%m-%d_%H-%Ms   ^\d{4}-\d{2}-\d{2}_\d{2}-\d{2}$t   Hs   %Y-%m-%d_%Hs   ^\d{4}-\d{2}-\d{2}_\d{2}$t   Dt   MIDNIGHTi   s   %Y-%m-%ds   ^\d{4}-\d{2}-\d{2}$t   Wi   i   sH   You must specify a day for weekly rollover from 0 to 6 (0 is Monday): %st   0t   6s-   Invalid day specified for weekly rollover: %ss'   Invalid rollover interval specified: %si  i  iÄQ i  iÄQ iÄ:	 (   R   R   t   uppert   whenR   t   utct   intervalt   suffixt   extMatcht
   startswithR,   t
   ValueErrort   intt	   dayOfWeekt   ret   compileR    R!   R"   t   statR   t   timet   computeRollovert
   rolloverAt(	   R   R   R9   R;   R   R
   R   R:   t   t(    (    s&   /usr/lib/python2.7/logging/handlers.pyR   ™   sH    											&	c         C   sq  | |  j  } |  j d k s. |  j j d É rm|  j rI t j | É } n t j | É } | d } | d } | d } t | d | d | } | | } |  j j d É rm| d } | |  j k rj| |  j k  r‰ |  j | }	 n d | |  j d }	 | |	 d }
 |  j s^| d
 } t j |
 É d
 } | | k r^| sHd } n d } |
 | 7}
 q^n  |
 } qjqmn  | S(   sI   
        Work out the rollover time based on the specified time.
        R4   R5   i   i   i   i<   i   i   i   iˇˇˇˇiÒˇˇi  i  iÄQ (	   R;   R9   R>   R:   RE   t   gmtimet	   localtimet	   _MIDNIGHTRA   (   R   t   currentTimet   resultRH   t   currentHourt   currentMinutet   currentSecondt   rt   dayt
   daysToWaitt   newRolloverAtt   dstNowt   dstAtRollovert   addend(    (    s&   /usr/lib/python2.7/logging/handlers.pyRF   ﬂ   s8    !	




	
	c         C   s)   t  t j É  É } | |  j k r% d Sd S(   s±   
        Determine if rollover should occur.

        record is not used, as we are just comparing times, but it is needed so
        the method signatures are the same
        i   i    (   R@   RE   RG   (   R   R   RH   (    (    s&   /usr/lib/python2.7/logging/handlers.pyR     s    c   	      C   sË   t  j j |  j É \ } } t  j | É } g  } | d } t | É } x\ | D]T } | |  | k rM | | } |  j j | É r° | j t  j j	 | | É É q° qM qM W| j
 É  t | É |  j k  rÕ g  } n | t | É |  j  } | S(   sè   
        Determine the files to delete when rolling over.

        More specific than the earlier method, which just used glob.glob().
        t   .(   R    R!   t   splitR   t   listdirR,   R=   t   matcht   appendt   joint   sortR   (	   R   t   dirNamet   baseNamet	   fileNamesRM   t   prefixt   plent   fileNameR<   (    (    s&   /usr/lib/python2.7/logging/handlers.pyt   getFilesToDelete(  s    

&
	c         C   s+  |  j  r" |  j  j É  d |  _  n  t t j É  É } t j | É d } |  j |  j } |  j rr t j	 | É } nP t j | É } | d } | | k r¬ | r¶ d } n d } t j | | É } n  |  j
 d t j |  j | É } t j j | É rt j | É n  t j j |  j
 É r/t j |  j
 | É n  |  j d k rex$ |  j É  D] } t j | É qKWn  |  j sÄ|  j É  |  _  n  |  j | É }	 x |	 | k rÆ|	 |  j }	 qíW|  j d k s–|  j j d É r|  j rt j |	 É d }
 | |
 k r| sd } n d } |	 | 7}	 qn  |	 |  _ d S(	   sx  
        do a rollover; in this case, a date/time stamp is appended to the filename
        when the rollover happens.  However, you want the file to be named for the
        start of the interval, not the current time.  If there is a backup count,
        then we have to get a list of matching filenames, sort them and remove
        the one with the oldest suffix.
        iˇˇˇˇi  iÒˇˇRX   i    R4   R5   N(   R   R   R   R@   RE   RJ   RG   R;   R:   RI   R   t   strftimeR<   R    R!   R"   R#   R$   R   Re   R   R%   RF   R9   R>   (   R   RL   RU   RH   t	   timeTuplet   dstThenRW   R(   t   sRT   RV   (    (    s&   /usr/lib/python2.7/logging/handlers.pyR   ?  sH    		
	 	+	N(
   R   R   R   R   t   FalseR   RF   R   Re   R   (    (    (    s&   /usr/lib/python2.7/logging/handlers.pyR.   ¢   s   5	<		t   WatchedFileHandlerc           B   s2   e  Z d  Z d d d d Ñ Z d Ñ  Z d Ñ  Z RS(   sÇ  
    A handler for logging to a file, which watches the file
    to see if it has changed while in use. This can happen because of
    usage of programs such as newsyslog and logrotate which perform
    log file rotation. This handler, intended for use under Unix,
    watches the file to see if it has changed since the last emit.
    (A file has changed if its device or inode have changed.)
    If it has changed, the old file stream is closed, and the file
    opened to get a new stream.

    This handler is not appropriate for use under Windows, because
    under Windows open files cannot be moved or renamed - logging
    opens the files with exclusive locks - and so there is no need
    for such a handler. Furthermore, ST_INO is not supported under
    Windows; stat always returns zero for this value.

    This handler is based on a suggestion and patch by Chad J.
    Schroeder.
    R   i    c         C   s<   t  j j |  | | | | É d \ |  _ |  _ |  j É  d  S(   Niˇˇˇˇ(   iˇˇˇˇiˇˇˇˇ(   R   R   R   t   devt   inot   _statstream(   R   R   R	   R
   R   (    (    s&   /usr/lib/python2.7/logging/handlers.pyR   Ü  s    c         C   sC   |  j  r? t j |  j  j É  É } | t | t |  _ |  _ n  d  S(   N(   R   R    t   fstatt   filenoR    R   Rl   Rm   (   R   t   sres(    (    s&   /usr/lib/python2.7/logging/handlers.pyRn   ã  s    	c         C   sﬂ   y t  j |  j É } Wn1 t k
 rI } | j t j k rC d } qJ Ç  n X| sw | t |  j k sw | t	 |  j
 k r» |  j d k	 r» |  j j É  |  j j É  d |  _ |  j É  |  _ |  j É  q» n  t j j |  | É d S(   sº   
        Emit a record.

        First check if the underlying file has changed, and if it
        has, close the old stream and reopen the file to get the
        current stream.
        N(   R    RD   R   t   OSErrort   errnot   ENOENTR   R    Rl   R   Rm   R   t   flushR   R%   Rn   R   R   R   (   R   R   Rq   t   err(    (    s&   /usr/lib/python2.7/logging/handlers.pyR   ê  s    	-	N(   R   R   R   R   R   Rn   R   (    (    (    s&   /usr/lib/python2.7/logging/handlers.pyRk   r  s   	t   SocketHandlerc           B   sY   e  Z d  Z d Ñ  Z d d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d	 Ñ  Z
 RS(
   s  
    A handler class which writes logging records, in pickle format, to
    a streaming socket. The socket is kept open across logging calls.
    If the peer resets it, an attempt is made to reconnect on the next call.
    The pickle which is sent is that of the LogRecord's attribute dictionary
    (__dict__), so that the receiver does not need to have the logging module
    installed in order to process the logging event.

    To unpickle the record at the receiving end into a LogRecord, use the
    makeLogRecord function.
    c         C   s\   t  j j |  É | |  _ | |  _ d |  _ d |  _ d |  _ d |  _	 d |  _
 d |  _ d S(   s	  
        Initializes the handler with a specific host address and port.

        The attribute 'closeOnError' is set to 1 - which means that if
        a socket error occurs, the socket is silently closed and then
        reopened on the next logging call.
        i    g      ?g      >@g       @N(   R   t   HandlerR   t   hostt   portR   t   sockt   closeOnErrort	   retryTimet
   retryStartt   retryMaxt   retryFactor(   R   Ry   Rz   (    (    s&   /usr/lib/python2.7/logging/handlers.pyR   Ω  s    							i   c         C   sT   t  j  t  j t  j É } t | d É r7 | j | É n  | j |  j |  j f É | S(   sr   
        A factory method which allows subclasses to define the precise
        type of socket they want.
        t
   settimeout(   t   sockett   AF_INETt   SOCK_STREAMt   hasattrRÅ   t   connectRy   Rz   (   R   t   timeoutRi   (    (    s&   /usr/lib/python2.7/logging/handlers.pyt
   makeSocket“  s
    c         C   s’   t  j  É  } |  j d k r$ d } n | |  j k } | r— y |  j É  |  _ d |  _ Wq— t j k
 rÕ |  j d k rÜ |  j |  _ n4 |  j |  j	 |  _ |  j |  j
 k r∫ |  j
 |  _ n  | |  j |  _ q— Xn  d S(   sÃ   
        Try to create a socket, using an exponential backoff with
        a max retry time. Thanks to Robert Olson for the original patch
        (SF #815911) which has been slightly refactored.
        i   N(   RE   R}   R   Rà   R{   RÇ   t   errorR~   t   retryPeriodRÄ   R   (   R   t   nowt   attempt(    (    s&   /usr/lib/python2.7/logging/handlers.pyt   createSocket›  s    	c         C   s—   |  j  d k r |  j É  n  |  j  rÕ yx t |  j  d É rM |  j  j | É nO d } t | É } x: | d k rõ |  j  j | | É } | | } | | } qb WWqÕ t j k
 r… |  j  j	 É  d |  _  qÕ Xn  d S(   sô   
        Send a pickled string to the socket.

        This function allows for partial sends which can happen when the
        network is busy.
        t   sendalli    N(
   R{   R   Rç   RÖ   Ré   R,   t   sendRÇ   Râ   R   (   R   Ri   t	   sentsofart   leftt   sent(    (    s&   /usr/lib/python2.7/logging/handlers.pyRè   ˘  s    	
c         C   só   | j  } | r* |  j | É } d | _  n  t | j É } | j É  | d <d | d <t j | d É } | rw | | _  n  t j	 d t
 | É É } | | S(   så   
        Pickles the record in binary format with a length prefix, and
        returns it ready for transmission across the socket.
        R-   t   argsi   s   >LN(   t   exc_infoR)   R   t   dictt   __dict__t
   getMessaget   cPicklet   dumpst   structt   packR,   (   R   R   t   eit   dummyt   dRi   t   slen(    (    s&   /usr/lib/python2.7/logging/handlers.pyt
   makePickle  s    	
c         C   sB   |  j  r+ |  j r+ |  j j É  d |  _ n t j j |  | É d S(   sŒ   
        Handle an error during logging.

        An error has occurred during logging. Most likely cause -
        connection lost. Close the socket so that we can retry on the
        next event.
        N(   R|   R{   R   R   R   Rx   R   (   R   R   (    (    s&   /usr/lib/python2.7/logging/handlers.pyR   *  s    c         C   sT   y  |  j  | É } |  j | É Wn- t t f k
 r< Ç  n |  j | É n Xd S(   s  
        Emit a record.

        Pickles the record and writes it to the socket in binary format.
        If there is an error with the socket, silently drop the packet.
        If there was a problem with the socket, re-establishes the
        socket.
        N(   R†   Rè   R   R   R   (   R   R   Ri   (    (    s&   /usr/lib/python2.7/logging/handlers.pyR   8  s    	c         C   sU   |  j  É  z) |  j } | r2 d |  _ | j É  n  Wd |  j É  Xt j j |  É d S(   s$   
        Closes the socket.
        N(   t   acquireR{   R   R   t   releaseR   Rx   (   R   R{   (    (    s&   /usr/lib/python2.7/logging/handlers.pyR   I  s    
		(   R   R   R   R   Rà   Rç   Rè   R†   R   R   R   (    (    (    s&   /usr/lib/python2.7/logging/handlers.pyRw   ∞  s   						t   DatagramHandlerc           B   s)   e  Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   sò  
    A handler class which writes logging records, in pickle format, to
    a datagram socket.  The pickle which is sent is that of the LogRecord's
    attribute dictionary (__dict__), so that the receiver does not need to
    have the logging module installed in order to process the logging event.

    To unpickle the record at the receiving end into a LogRecord, use the
    makeLogRecord function.

    c         C   s    t  j |  | | É d |  _ d S(   sP   
        Initializes the handler with a specific host address and port.
        i    N(   Rw   R   R|   (   R   Ry   Rz   (    (    s&   /usr/lib/python2.7/logging/handlers.pyR   b  s    c         C   s   t  j  t  j t  j É } | S(   su   
        The factory method of SocketHandler is here overridden to create
        a UDP socket (SOCK_DGRAM).
        (   RÇ   RÉ   t
   SOCK_DGRAM(   R   Ri   (    (    s&   /usr/lib/python2.7/logging/handlers.pyRà   i  s    c         C   s?   |  j  d k r |  j É  n  |  j  j | |  j |  j f É d S(   sÛ   
        Send a pickled string to a socket.

        This function no longer allows for partial sends which can happen
        when the network is busy - UDP does not guarantee delivery and
        can deliver packets out of sequence.
        N(   R{   R   Rç   t   sendtoRy   Rz   (   R   Ri   (    (    s&   /usr/lib/python2.7/logging/handlers.pyRè   q  s    (   R   R   R   R   Rà   Rè   (    (    (    s&   /usr/lib/python2.7/logging/handlers.pyR£   W  s   
		t   SysLogHandlerc           B   s  e  Z d  Z d Z d Z d Z d Z d Z d Z d Z	 d Z
 d Z d Z d Z d Z d Z d Z d Z d Z d	 Z d
 Z d Z d Z d Z d Z d Z d Z d Z d Z d Z d Z i e d 6e d 6e d 6e
 d 6e d 6e d 6e d 6e	 d 6e d 6e d 6e d 6e d  6Z i e d! 6e d" 6e d# 6e d$ 6e d% 6e d& 6e d' 6e d( 6e d) 6e d* 6e d+ 6e d, 6e d- 6e d. 6e d/ 6e d0 6e d1 6e d2 6e d3 6e d4 6e d5 6Z  i d d6 6d d7 6d  d8 6d d9 6d d: 6Z! d; e" f e dC d< Ñ Z$ d= Ñ  Z% d> Z& d? Ñ  Z' d@ Ñ  Z( dA Ñ  Z) dB Ñ  Z* RS(D   s  
    A handler class which sends formatted logging records to a syslog
    server. Based on Sam Rushing's syslog module:
    http://www.nightmare.com/squirl/python-ext/misc/syslog.py
    Contributed by Nicolas Untz (after which minor refactoring changes
    have been made).
    i    i   i   i   i   i   i   i   i   i	   i
   i   i   i   i   i   i   i   i   i   t   alertt   critt   criticalt   debugt   emergRv   Râ   t   infot   noticet   panict   warnt   warningt   autht   authprivt   cront   daemont   ftpt   kernt   lprt   mailt   newst   securityt   syslogt   usert   uucpt   local0t   local1t   local2t   local3t   local4t   local5t   local6t   local7t   DEBUGt   INFOt   WARNINGt   ERRORt   CRITICALt	   localhostc         C   sƒ   t  j j |  É | |  _ | |  _ | |  _ t | t É rS d |  _ |  j	 | É nd d |  _ | d k rt t j } n  t j t j | É |  _ | t j k rÆ |  j j | É n  | |  _ d |  _ d S(   s  
        Initialize a handler.

        If address is specified as a string, a UNIX socket is used. To log to a
        local syslogd, "SysLogHandler(address="/dev/log")" can be used.
        If facility is not specified, LOG_USER is used. If socktype is
        specified as socket.SOCK_DGRAM or socket.SOCK_STREAM, that specific
        socket type will be used. For Unix sockets, you can also specify a
        socktype of None, in which case socket.SOCK_DGRAM will be used, falling
        back to socket.SOCK_STREAM.
        i   i    N(   R   Rx   R   t   addresst   facilityt   socktypet
   isinstancet
   basestringt
   unixsockett   _connect_unixsocketR   RÇ   R§   RÉ   RÑ   RÜ   t	   formatter(   R   RÃ   RÕ   RŒ   (    (    s&   /usr/lib/python2.7/logging/handlers.pyR   ‰  s    						c         C   s¯   |  j  } | d  k r! t j } n  t j t j | É |  _ y |  j j | É | |  _  Wnõ t j k
 rÛ |  j j É  |  j  d  k	 rã Ç  n  t j } t j t j | É |  _ y |  j j | É | |  _  WqÙ t j k
 rÔ |  j j É  Ç  qÙ Xn Xd  S(   N(	   RŒ   R   RÇ   R§   t   AF_UNIXRÜ   Râ   R   RÑ   (   R   RÃ   t   use_socktype(    (    s&   /usr/lib/python2.7/logging/handlers.pyR“     s&    		s   <%d>%s c         C   sJ   t  | t É r |  j | } n  t  | t É r> |  j | } n  | d >| BS(   sÈ   
        Encode the facility and priority. You can pass in strings or
        integers - if strings are passed, the facility_names and
        priority_names mapping dictionaries are used to convert them to
        integers.
        i   (   Rœ   R–   t   facility_namest   priority_names(   R   RÕ   t   priority(    (    s&   /usr/lib/python2.7/logging/handlers.pyt   encodePriority"  s
    c         C   sI   |  j  É  z |  j r& |  j j É  n  Wd |  j É  Xt j j |  É d S(   s$   
        Closes the socket.
        N(   R°   R—   RÇ   R   R¢   R   Rx   (   R   (    (    s&   /usr/lib/python2.7/logging/handlers.pyR   /  s    
	c         C   s   |  j  j | d É S(   sK  
        Map a logging level name to a key in the priority_names map.
        This is useful in two scenarios: when custom levels are being
        used, and in the case where you can't do a straightforward
        mapping by lowercasing the logging level name because of locale-
        specific issues (see SF #1524081).
        R∞   (   t   priority_mapt   get(   R   t	   levelName(    (    s&   /usr/lib/python2.7/logging/handlers.pyt   mapPriority;  s    c         C   s=  y	|  j  | É d } d |  j |  j |  j | j É É } t | É t k r_ | j d É } n  | | } |  j rÕ y |  j	 j
 | É Wqt	 j k
 r… |  j	 j É  |  j |  j É |  j	 j
 | É qXn; |  j t	 j k r¯ |  j	 j | |  j É n |  j	 j | É Wn- t t f k
 r%Ç  n |  j | É n Xd S(   s±   
        Emit a record.

        The record is formatted, and then sent to the syslog server. If
        exception information is present, it is NOT sent to the server.
        s    s   <%d>s   utf-8N(   R)   RŸ   RÕ   R›   t	   levelnamet   typet   unicodet   encodeR—   RÇ   Rè   Râ   R   R“   RÃ   RŒ   R§   R•   Ré   R   R   R   (   R   R   R-   t   prio(    (    s&   /usr/lib/python2.7/logging/handlers.pyR   E  s*    
	N(+   R   R   R   t	   LOG_EMERGt	   LOG_ALERTt   LOG_CRITt   LOG_ERRt   LOG_WARNINGt
   LOG_NOTICEt   LOG_INFOt	   LOG_DEBUGt   LOG_KERNt   LOG_USERt   LOG_MAILt
   LOG_DAEMONt   LOG_AUTHt
   LOG_SYSLOGt   LOG_LPRt   LOG_NEWSt   LOG_UUCPt   LOG_CRONt   LOG_AUTHPRIVt   LOG_FTPt
   LOG_LOCAL0t
   LOG_LOCAL1t
   LOG_LOCAL2t
   LOG_LOCAL3t
   LOG_LOCAL4t
   LOG_LOCAL5t
   LOG_LOCAL6t
   LOG_LOCAL7R◊   R÷   R⁄   t   SYSLOG_UDP_PORTR   R   R“   t   log_format_stringRŸ   R   R›   R   (    (    (    s&   /usr/lib/python2.7/logging/handlers.pyR¶   }  sú   


					
t   SMTPHandlerc           B   s/   e  Z d  Z d d d Ñ Z d Ñ  Z d Ñ  Z RS(   sK   
    A handler class which sends an SMTP email for each logging event.
    c         C   sÃ   t  j j |  É t | t t f É r: | \ |  _ |  _ n | d |  _ |  _ t | t t f É rw | \ |  _	 |  _
 n	 d |  _	 | |  _ t | t É r§ | g } n  | |  _ | |  _ | |  _ d |  _ d S(   s  
        Initialize the handler.

        Initialize the instance with the from and to addresses and subject
        line of the email. To specify a non-standard SMTP port, use the
        (host, port) tuple format for the mailhost argument. To specify
        authentication credentials, supply a (username, password) tuple
        for the credentials argument. To specify the use of a secure
        protocol (TLS), pass in a tuple for the secure argument. This will
        only be used when authentication credentials are supplied. The tuple
        will be either an empty tuple, or a single-value tuple with the name
        of a keyfile, or a 2-value tuple with the names of the keyfile and
        certificate file. (This tuple is passed to the `starttls` method).
        g      @N(   R   Rx   R   Rœ   t   listt   tuplet   mailhostt   mailportR   t   usernamet   passwordt   fromaddrR–   t   toaddrst   subjectt   securet   _timeout(   R   R  R  R	  R
  t   credentialsR  (    (    s&   /usr/lib/python2.7/logging/handlers.pyR   l  s    					c         C   s   |  j  S(   sû   
        Determine the subject for the email.

        If you want to specify a subject line which is record-dependent,
        override this method.
        (   R
  (   R   R   (    (    s&   /usr/lib/python2.7/logging/handlers.pyt
   getSubjectç  s    c         C   sK  yd d l  } d d l m } |  j } | s: | j } n  | j |  j | d |  j É} |  j | É } d |  j	 d j
 |  j É |  j | É | É  | f } |  j rÛ |  j d k	 r⁄ | j É  | j |  j å  | j É  n  | j |  j |  j É n  | j |  j	 |  j | É | j É  Wn- t t f k
 r3Ç  n |  j | É n Xd S(   sd   
        Emit a record.

        Format the record and send it to the specified addressees.
        iˇˇˇˇN(   t
   formatdateRá   s-   From: %s
To: %s
Subject: %s
Date: %s

%st   ,(   t   smtplibt   email.utilsR  R  t	   SMTP_PORTt   SMTPR  R  R)   R  R]   R	  R  R  R  R   t   ehlot   starttlst   loginR  t   sendmailt   quitR   R   R   (   R   R   R  R  Rz   t   smtpR-   (    (    s&   /usr/lib/python2.7/logging/handlers.pyR   ñ  s2    		
N(   R   R   R   R   R   R  R   (    (    (    s&   /usr/lib/python2.7/logging/handlers.pyR  h  s    		t   NTEventLogHandlerc           B   sJ   e  Z d  Z d d d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 RS(	   s˝  
    A handler class which sends events to the NT Event Log. Adds a
    registry entry for the specified application name. If no dllname is
    provided, win32service.pyd (which contains some basic message
    placeholders) is used. Note that use of these placeholders will make
    your event logs big, as the entire message source is held in the log.
    If you want slimmer logs, you have to pass in the name of your own DLL
    which contains the message definitions you want to use in the event log.
    t   Applicationc         C   s2  t  j j |  É y¸ d d  l } d d  l } | |  _ | |  _ | sç t j j	 |  j j
 É } t j j	 | d É } t j j | d d É } n  | |  _ | |  _ |  j j | | | É | j |  _ i | j t  j 6| j t  j 6| j t  j 6| j t  j 6| j t  j 6|  _ Wn t k
 r-d GHd  |  _ n Xd  S(   Niˇˇˇˇi    s   win32service.pydsW   The Python Win32 extensions for NT (service, event logging) appear not to be available.(   R   Rx   R   t   win32evtlogutilt   win32evtlogt   appnamet   _weluR    R!   RY   t   __file__R]   t   dllnamet   logtypet   AddSourceToRegistryt   EVENTLOG_ERROR_TYPEt   deftypet   EVENTLOG_INFORMATION_TYPER∆   R«   t   EVENTLOG_WARNING_TYPER»   R…   R    t   typemapt   ImportErrorR   (   R   R  R"  R#  R  R  (    (    s&   /usr/lib/python2.7/logging/handlers.pyR   ¿  s,    				c         C   s   d S(   sy  
        Return the message ID for the event record. If you are using your
        own messages, you could do this by having the msg passed to the
        logger being an ID rather than a formatting string. Then, in here,
        you could use a dictionary lookup to get the message ID. This
        version returns 1, which is the base message ID in win32service.pyd.
        i   (    (   R   R   (    (    s&   /usr/lib/python2.7/logging/handlers.pyt   getMessageID⁄  s    c         C   s   d S(   sû   
        Return the event category for the record.

        Override this if you want to specify your own categories. This version
        returns 0.
        i    (    (   R   R   (    (    s&   /usr/lib/python2.7/logging/handlers.pyt   getEventCategory‰  s    c         C   s   |  j  j | j |  j É S(   sÂ  
        Return the event type for the record.

        Override this if you want to specify your own types. This version does
        a mapping using the handler's typemap attribute, which is set up in
        __init__() to a dictionary which contains mappings for DEBUG, INFO,
        WARNING, ERROR and CRITICAL. If you are using your own levels you will
        either need to override this method or place a suitable dictionary in
        the handler's typemap attribute.
        (   R)  R€   t   levelnoR&  (   R   R   (    (    s&   /usr/lib/python2.7/logging/handlers.pyt   getEventTypeÌ  s    c         C   s¢   |  j  rû yb |  j | É } |  j | É } |  j | É } |  j | É } |  j  j |  j | | | | g É Wqû t t f k
 rá Ç  qû |  j	 | É qû Xn  d S(   sî   
        Emit a record.

        Determine the message ID, event category and event type. Then
        log the message in the NT event log.
        N(
   R   R+  R,  R.  R)   t   ReportEventR  R   R   R   (   R   R   t   idt   catRﬂ   R-   (    (    s&   /usr/lib/python2.7/logging/handlers.pyR   ˙  s    	&c         C   s   t  j j |  É d S(   sS  
        Clean up this handler.

        You can remove the application name from the registry as a
        source of event log entries. However, if you do this, you will
        not be able to see the events as you intended in the Event Log
        Viewer - it needs to be able to access the registry to get the
        DLL name.
        N(   R   Rx   R   (   R   (    (    s&   /usr/lib/python2.7/logging/handlers.pyR     s    N(
   R   R   R   R   R   R+  R,  R.  R   R   (    (    (    s&   /usr/lib/python2.7/logging/handlers.pyR  ∂  s   		
				t   HTTPHandlerc           B   s,   e  Z d  Z d d Ñ Z d Ñ  Z d Ñ  Z RS(   s^   
    A class which sends records to a Web server, using either GET or
    POST semantics.
    t   GETc         C   sV   t  j j |  É | j É  } | d k r7 t d É Ç n  | |  _ | |  _ | |  _ d S(   sr   
        Initialize the instance with the host, the request URL, and the method
        ("GET" or "POST")
        R3  t   POSTs   method must be GET or POSTN(   R3  R4  (   R   Rx   R   R8   R?   Ry   t   urlt   method(   R   Ry   R5  R6  (    (    s&   /usr/lib/python2.7/logging/handlers.pyR     s    		c         C   s   | j  S(   s≥   
        Default implementation of mapping the log record into a dict
        that is sent as the CGI data. Overwrite in your class.
        Contributed by Franz Glasner.
        (   Rñ   (   R   R   (    (    s&   /usr/lib/python2.7/logging/handlers.pyt   mapLogRecord,  s    c   
      C   sà  yTd d l  } d d l } |  j } | j | É } |  j } | j |  j | É É } |  j d k rû | j d É d k rÅ d } n d } | d | | f } n  | j	 |  j | É | j d É }	 |	 d k rŸ | |	  } n  | j
 d	 | É |  j d
 k r'| j
 d d É | j
 d t t | É É É n  | j |  j d
 k rB| n d É | j É  Wn- t t f k
 rpÇ  n |  j | É n Xd S(   sk   
        Emit a record.

        Send the record to the Web server as a percent-encoded dictionary
        iˇˇˇˇNR3  t   ?i    t   &s   %c%st   :t   HostR4  s   Content-types!   application/x-www-form-urlencodeds   Content-length(   t   httplibt   urllibRy   t   HTTPR5  t	   urlencodeR7  R6  t   findt
   putrequestt	   putheadert   strR,   t
   endheadersR   t   getreplyR   R   R   (
   R   R   R<  R=  Ry   R/   R5  t   datat   sepR&   (    (    s&   /usr/lib/python2.7/logging/handlers.pyR   4  s4    				"(   R   R   R   R   R7  R   (    (    (    s&   /usr/lib/python2.7/logging/handlers.pyR2    s   	t   BufferingHandlerc           B   s;   e  Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   sÂ   
  A handler class which buffers logging records in memory. Whenever each
  record is added to the buffer, a check is made to see if the buffer should
  be flushed. If it should, then flush() is expected to do what's needed.
    c         C   s&   t  j j |  É | |  _ g  |  _ d S(   s>   
        Initialize the handler with the buffer size.
        N(   R   Rx   R   t   capacityt   buffer(   R   RI  (    (    s&   /usr/lib/python2.7/logging/handlers.pyR   ^  s    	c         C   s   t  |  j É |  j k S(   sº   
        Should the handler flush its buffer?

        Returns true if the buffer is up to capacity. This method can be
        overridden to implement custom flushing strategies.
        (   R,   RJ  RI  (   R   R   (    (    s&   /usr/lib/python2.7/logging/handlers.pyt   shouldFlushf  s    c         C   s0   |  j  j | É |  j | É r, |  j É  n  d S(   sÜ   
        Emit a record.

        Append the record. If shouldFlush() tells us to, call flush() to process
        the buffer.
        N(   RJ  R\   RK  Ru   (   R   R   (    (    s&   /usr/lib/python2.7/logging/handlers.pyR   o  s    c         C   s)   |  j  É  z g  |  _ Wd |  j É  Xd S(   sw   
        Override to implement custom flushing behaviour.

        This version just zaps the buffer to empty.
        N(   R°   RJ  R¢   (   R   (    (    s&   /usr/lib/python2.7/logging/handlers.pyRu   z  s    
c         C   s&   z |  j  É  Wd t j j |  É Xd S(   sp   
        Close the handler.

        This version just flushes and chains to the parent class' close().
        N(   Ru   R   Rx   R   (   R   (    (    s&   /usr/lib/python2.7/logging/handlers.pyR   Ü  s    (   R   R   R   R   RK  R   Ru   R   (    (    (    s&   /usr/lib/python2.7/logging/handlers.pyRH  X  s   					t   MemoryHandlerc           B   sD   e  Z d  Z e j d d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 RS(   s‚   
    A handler class which buffers logging records in memory, periodically
    flushing them to a target handler. Flushing occurs whenever the buffer
    is full, or when an event of a certain severity or greater is seen.
    c         C   s&   t  j |  | É | |  _ | |  _ d S(   s  
        Initialize the handler with the buffer size, the level at which
        flushing should occur and an optional target.

        Note that without a target being set either here or via setTarget(),
        a MemoryHandler is no use to anyone!
        N(   RH  R   t
   flushLevelt   target(   R   RI  RM  RN  (    (    s&   /usr/lib/python2.7/logging/handlers.pyR   ó  s    	c         C   s(   t  |  j É |  j k p' | j |  j k S(   sP   
        Check for buffer full or a record at the flushLevel or higher.
        (   R,   RJ  RI  R-  RM  (   R   R   (    (    s&   /usr/lib/python2.7/logging/handlers.pyRK  £  s    c         C   s   | |  _  d S(   s:   
        Set the target handler for this handler.
        N(   RN  (   R   RN  (    (    s&   /usr/lib/python2.7/logging/handlers.pyt	   setTarget™  s    c         C   sY   |  j  É  z= |  j rF x! |  j D] } |  j j | É q  Wg  |  _ n  Wd |  j É  Xd S(   s±   
        For a MemoryHandler, flushing means just sending the buffered
        records to the target, if there is one. Override if you want
        different behaviour.
        N(   R°   RN  RJ  t   handleR¢   (   R   R   (    (    s&   /usr/lib/python2.7/logging/handlers.pyRu   ∞  s    
	c         C   sH   z |  j  É  Wd |  j É  z d |  _ t j |  É Wd |  j É  XXd S(   sD   
        Flush, set the target to None and lose the buffer.
        N(   Ru   R°   R   RN  RH  R   R¢   (   R   (    (    s&   /usr/lib/python2.7/logging/handlers.pyR   ø  s    
	N(   R   R   R   R   R…   R   R   RK  RO  Ru   R   (    (    (    s&   /usr/lib/python2.7/logging/handlers.pyRL  ë  s   			i†  iÄQ (*   R   Rs   R   RÇ   R    Rò   Rö   RE   RB   RD   R    R   R   R   R*  R   R‡   t   Truet   _unicodet	   NameErrorRj   t   DEFAULT_TCP_LOGGING_PORTt   DEFAULT_UDP_LOGGING_PORTt   DEFAULT_HTTP_LOGGING_PORTt   DEFAULT_SOAP_LOGGING_PORTRˇ   t   SYSLOG_TCP_PORTRK   R   R   R   R.   Rk   Rx   Rw   R£   R¶   R  R  R2  RH  RL  (    (    (    s&   /usr/lib/python2.7/logging/handlers.pyt   <module>   s<   `


 N–>ß&ÎNd>9                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Û
”´[c           @   sm   d  d d g Z  d d l m Z d
 g Z d e f d Ñ  É  YZ d Ñ  Z e d Ñ Z d e f d	 Ñ  É  YZ	 d
 S(   t   Clientt   Listenert   Pipeiˇˇˇˇ(   t   Queuec           B   s;   e  Z d d d  d Ñ Z d Ñ  Z d Ñ  Z e d Ñ  É Z RS(   i   c         C   s   t  | É |  _ d  S(   N(   R   t   _backlog_queue(   t   selft   addresst   familyt   backlog(    (    s6   /usr/lib/python2.7/multiprocessing/dummy/connection.pyt   __init__-   s    c         C   s   t  |  j j É  å  S(   N(   t
   ConnectionR   t   get(   R   (    (    s6   /usr/lib/python2.7/multiprocessing/dummy/connection.pyt   accept0   s    c         C   s   d  |  _ d  S(   N(   t   NoneR   (   R   (    (    s6   /usr/lib/python2.7/multiprocessing/dummy/connection.pyt   close3   s    c         C   s   |  j  S(   N(   R   (   R   (    (    s6   /usr/lib/python2.7/multiprocessing/dummy/connection.pyt   <lambda>6   s    N(   t   __name__t
   __module__R   R	   R   R   t   propertyR   (    (    (    s6   /usr/lib/python2.7/multiprocessing/dummy/connection.pyR   +   s   		c         C   s3   t  É  t  É  } } |  j | | f É t | | É S(   N(   R   t   putR
   (   R   t   _int   _out(    (    s6   /usr/lib/python2.7/multiprocessing/dummy/connection.pyR    9   s    c         C   s/   t  É  t  É  } } t | | É t | | É f S(   N(   R   R
   (   t   duplext   at   b(    (    s6   /usr/lib/python2.7/multiprocessing/dummy/connection.pyR   ?   s    R
   c           B   s&   e  Z d  Ñ  Z d d Ñ Z d Ñ  Z RS(   c         C   s<   | |  _  | |  _ | j |  _ |  _ | j |  _ |  _ d  S(   N(   R   R   R   t   sendt
   send_bytesR   t   recvt
   recv_bytes(   R   R   R   (    (    s6   /usr/lib/python2.7/multiprocessing/dummy/connection.pyR	   F   s    		g        c         C   so   |  j  j É  d k r t S| d k r) t S|  j  j j É  |  j  j j | É |  j  j j É  |  j  j É  d k S(   Ni    g        (   R   t   qsizet   Truet   Falset	   not_emptyt   acquiret   waitt   release(   R   t   timeout(    (    s6   /usr/lib/python2.7/multiprocessing/dummy/connection.pyt   pollL   s    c         C   s   d  S(   N(    (   R   (    (    s6   /usr/lib/python2.7/multiprocessing/dummy/connection.pyR   V   s    (   R   R   R	   R%   R   (    (    (    s6   /usr/lib/python2.7/multiprocessing/dummy/connection.pyR
   D   s   	
N(
   t   __all__R   R   t   familiest   objectR   R    R   R   R
   (    (    (    s6   /usr/lib/python2.7/multiprocessing/dummy/connection.pyt   <module>#   s   		                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            #
# Package analogous to 'threading.py' but using processes
#
# multiprocessing/__init__.py
#
# This package is intended to duplicate the functionality (and much of
# the API) of threading.py but uses processes instead of threads.  A
# subpackage 'multiprocessing.dummy' has the same API but is a simple
# wrapper for 'threading'.
#
# Try calling `multiprocessing.doc.main()` to read the html
# documentation in a webbrowser.
#
#
# Copyright (c) 2006-2008, R Oudkerk
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 3. Neither the name of author nor the names of any contributors may be
#    used to endorse or promote products derived from this software
#    without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
#

__version__ = '0.70a1'

__all__ = [
    'Process', 'current_process', 'active_children', 'freeze_support',
    'Manager', 'Pipe', 'cpu_count', 'log_to_stderr', 'get_logger',
    'allow_connection_pickling', 'BufferTooShort', 'TimeoutError',
    'Lock', 'RLock', 'Semaphore', 'BoundedSemaphore', 'Condition',
    'Event', 'Queue', 'JoinableQueue', 'Pool', 'Value', 'Array',
    'RawValue', 'RawArray', 'SUBDEBUG', 'SUBWARNING',
    ]

__author__ = 'R. Oudkerk (r.m.oudkerk@gmail.com)'

#
# Imports
#

import os
import sys

from multiprocessing.process import Process, current_process, active_children
from multiprocessing.util import SUBDEBUG, SUBWARNING

#
# Exceptions
#

class ProcessError(Exception):
    pass

class BufferTooShort(ProcessError):
    pass

class TimeoutError(ProcessError):
    pass

class AuthenticationError(ProcessError):
    pass

# This is down here because _multiprocessing uses BufferTooShort
import _multiprocessing

#
# Definitions not depending on native semaphores
#

def Manager():
    '''
    Returns a manager associated with a running server process

    The managers methods such as `Lock()`, `Condition()` and `Queue()`
    can be used to create shared objects.
    '''
    from multiprocessing.managers import SyncManager
    m = SyncManager()
    m.start()
    return m

def Pipe(duplex=True):
    '''
    Returns two connection object connected by a pipe
    '''
    from multiprocessing.connection import Pipe
    return Pipe(duplex)

def cpu_count():
    '''
    Returns the number of CPUs in the system
    '''
    if sys.platform == 'win32':
        try:
            num = int(os.environ['NUMBER_OF_PROCESSORS'])
        except (ValueError, KeyError):
            num = 0
    elif 'bsd' in sys.platform or sys.platform == 'darwin':
        comm = '/sbin/sysctl -n hw.ncpu'
        if sys.platform == 'darwin':
            comm = '/usr' + comm
        try:
            with os.popen(comm) as p:
                num = int(p.read())
        except ValueError:
            num = 0
    else:
        try:
            num = os.sysconf('SC_NPROCESSORS_ONLN')
        except (ValueError, OSError, AttributeError):
            num = 0

    if num >= 1:
        return num
    else:
        raise NotImplementedError('cannot determine number of cpus')

def freeze_support():
    '''
    Check whether this is a fake forked process in a frozen executable.
    If so then run code specified by commandline and exit.
    '''
    if sys.platform == 'win32' and getattr(sys, 'frozen', False):
        from multiprocessing.forking import freeze_support
        freeze_support()

def get_logger():
    '''
    Return package logger -- if it does not already exist then it is created
    '''
    from multiprocessing.util import get_logger
    return get_logger()

def log_to_stderr(level=None):
    '''
    Turn on logging and add a handler which prints to stderr
    '''
    from multiprocessing.util import log_to_stderr
    return log_to_stderr(level)

def allow_connection_pickling():
    '''
    Install support for sending connections and sockets between processes
    '''
    from multiprocessing import reduction

#
# Definitions depending on native semaphores
#

def Lock():
    '''
    Returns a non-recursive lock object
    '''
    from multiprocessing.synchronize import Lock
    return Lock()

def RLock():
    '''
    Returns a recursive lock object
    '''
    from multiprocessing.synchronize import RLock
    return RLock()

def Condition(lock=None):
    '''
    Returns a condition object
    '''
    from multiprocessing.synchronize import Condition
    return Condition(lock)

def Semaphore(value=1):
    '''
    Returns a semaphore object
    '''
    from multiprocessing.synchronize import Semaphore
    return Semaphore(value)

def BoundedSemaphore(value=1):
    '''
    Returns a bounded semaphore object
    '''
    from multiprocessing.synchronize import BoundedSemaphore
    return BoundedSemaphore(value)

def Event():
    '''
    Returns an event object
    '''
    from multiprocessing.synchronize import Event
    return Event()

def Queue(maxsize=0):
    '''
    Returns a queue object
    '''
    from multiprocessing.queues import Queue
    return Queue(maxsize)

def JoinableQueue(maxsize=0):
    '''
    Returns a queue object
    '''
    from multiprocessing.queues import JoinableQueue
    return JoinableQueue(maxsize)

def Pool(processes=None, initializer=None, initargs=(), maxtasksperchild=None):
    '''
    Returns a process pool object
    '''
    from multiprocessing.pool import Pool
    return Pool(processes, initializer, initargs, maxtasksperchild)

def RawValue(typecode_or_type, *args):
    '''
    Returns a shared object
    '''
    from multiprocessing.sharedctypes import RawValue
    return RawValue(typecode_or_type, *args)

def RawArray(typecode_or_type, size_or_initializer):
    '''
    Returns a shared array
    '''
    from multiprocessing.sharedctypes import RawArray
    return RawArray(typecode_or_type, size_or_initializer)

def Value(typecode_or_type, *args, **kwds):
    '''
    Returns a synchronized shared object
    '''
    from multiprocessing.sharedctypes import Value
    return Value(typecode_or_type, *args, **kwds)

def Array(typecode_or_type, size_or_initializer, **kwds):
    '''
    Returns a synchronized shared array
    '''
    from multiprocessing.sharedctypes import Array
    return Array(typecode_or_type, size_or_initializer, **kwds)

#
#
#

if sys.platform == 'win32':

    def set_executable(executable):
        '''
        Sets the path to a python.exe or pythonw.exe binary used to run
        child processes on Windows instead of sys.executable.
        Useful for people embedding Python.
        '''
        from multiprocessing.forking import set_executable
        set_executable(executable)

    __all__ += ['set_executable']
                                                                                                                                                                                                                                                                                                                                                                                                   Û
”´[c           @   s  d  Z  d d d d d d d d d	 d
 d d d d d d d d d d d d d d d d d g Z d Z d d l Z d d l Z d d l m Z m Z m Z d d  l	 m
 Z
 m Z d! e f d" Ñ  É  YZ d e f d# Ñ  É  YZ d e f d$ Ñ  É  YZ d% e f d& Ñ  É  YZ d d l Z d' Ñ  Z e d( Ñ Z d) Ñ  Z d* Ñ  Z d+ Ñ  Z d d, Ñ Z d- Ñ  Z d. Ñ  Z d/ Ñ  Z d d0 Ñ Z d1 d2 Ñ Z d1 d3 Ñ Z d4 Ñ  Z  d5 d6 Ñ Z! d5 d7 Ñ Z" d d d@ d d8 Ñ Z# d9 Ñ  Z$ d: Ñ  Z% d; Ñ  Z& d< Ñ  Z' e j( d= k rd> Ñ  Z) e d? g 7Z n  d S(A   s   0.70a1t   Processt   current_processt   active_childrent   freeze_supportt   Managert   Pipet	   cpu_countt   log_to_stderrt
   get_loggert   allow_connection_picklingt   BufferTooShortt   TimeoutErrort   Lockt   RLockt	   Semaphoret   BoundedSemaphoret	   Conditiont   Eventt   Queuet   JoinableQueuet   Poolt   Valuet   Arrayt   RawValuet   RawArrayt   SUBDEBUGt
   SUBWARNINGs"   R. Oudkerk (r.m.oudkerk@gmail.com)iˇˇˇˇN(   R    R   R   (   R   R   t   ProcessErrorc           B   s   e  Z RS(    (   t   __name__t
   __module__(    (    (    s.   /usr/lib/python2.7/multiprocessing/__init__.pyR   G   s   c           B   s   e  Z RS(    (   R   R   (    (    (    s.   /usr/lib/python2.7/multiprocessing/__init__.pyR
   J   s   c           B   s   e  Z RS(    (   R   R   (    (    (    s.   /usr/lib/python2.7/multiprocessing/__init__.pyR   M   s   t   AuthenticationErrorc           B   s   e  Z RS(    (   R   R   (    (    (    s.   /usr/lib/python2.7/multiprocessing/__init__.pyR   P   s   c          C   s'   d d l  m }  |  É  } | j É  | S(   s∂   
    Returns a manager associated with a running server process

    The managers methods such as `Lock()`, `Condition()` and `Queue()`
    can be used to create shared objects.
    iˇˇˇˇ(   t   SyncManager(   t   multiprocessing.managersR   t   start(   R   t   m(    (    s.   /usr/lib/python2.7/multiprocessing/__init__.pyR   Z   s    	
c         C   s   d d l  m } | |  É S(   s;   
    Returns two connection object connected by a pipe
    iˇˇˇˇ(   R   (   t   multiprocessing.connectionR   (   t   duplexR   (    (    s.   /usr/lib/python2.7/multiprocessing/__init__.pyR   f   s    c          C   s*  t  j d k rI y t t j d É }  Wq
t t f k
 rE d }  q
Xn¡ d t  j k sg t  j d k r‘ d } t  j d k râ d | } n  y. t j | É è } t | j É  É }  Wd QXWq
t k
 r– d }  q
Xn6 y t j	 d	 É }  Wn  t t
 t f k
 r	d }  n X|  d
 k r|  St d É Ç d S(   s2   
    Returns the number of CPUs in the system
    t   win32t   NUMBER_OF_PROCESSORSi    t   bsdt   darwins   /sbin/sysctl -n hw.ncpus   /usrNt   SC_NPROCESSORS_ONLNi   s   cannot determine number of cpus(   t   syst   platformt   intt   ost   environt
   ValueErrort   KeyErrort   popent   readt   sysconft   OSErrort   AttributeErrort   NotImplementedError(   t   numt   commt   p(    (    s.   /usr/lib/python2.7/multiprocessing/__init__.pyR   m   s*    
c          C   s?   t  j d k r; t t  d t É r; d d l m }  |  É  n  d S(   sà   
    Check whether this is a fake forked process in a frozen executable.
    If so then run code specified by commandline and exit.
    R%   t   frozeniˇˇˇˇ(   R   N(   R*   R+   t   getattrt   Falset   multiprocessing.forkingR   (   R   (    (    s.   /usr/lib/python2.7/multiprocessing/__init__.pyR   ä   s    !c          C   s   d d l  m }  |  É  S(   sR   
    Return package logger -- if it does not already exist then it is created
    iˇˇˇˇ(   R   (   t   multiprocessing.utilR   (   R   (    (    s.   /usr/lib/python2.7/multiprocessing/__init__.pyR   ì   s    c         C   s   d d l  m } | |  É S(   sB   
    Turn on logging and add a handler which prints to stderr
    iˇˇˇˇ(   R   (   R>   R   (   t   levelR   (    (    s.   /usr/lib/python2.7/multiprocessing/__init__.pyR   ö   s    c          C   s   d d l  m }  d S(   sO   
    Install support for sending connections and sockets between processes
    iˇˇˇˇ(   t	   reductionN(   t   multiprocessingR@   (   R@   (    (    s.   /usr/lib/python2.7/multiprocessing/__init__.pyR	   °   s    c          C   s   d d l  m }  |  É  S(   s-   
    Returns a non-recursive lock object
    iˇˇˇˇ(   R   (   t   multiprocessing.synchronizeR   (   R   (    (    s.   /usr/lib/python2.7/multiprocessing/__init__.pyR   ´   s    c          C   s   d d l  m }  |  É  S(   s)   
    Returns a recursive lock object
    iˇˇˇˇ(   R   (   RB   R   (   R   (    (    s.   /usr/lib/python2.7/multiprocessing/__init__.pyR   ≤   s    c         C   s   d d l  m } | |  É S(   s$   
    Returns a condition object
    iˇˇˇˇ(   R   (   RB   R   (   t   lockR   (    (    s.   /usr/lib/python2.7/multiprocessing/__init__.pyR   π   s    i   c         C   s   d d l  m } | |  É S(   s$   
    Returns a semaphore object
    iˇˇˇˇ(   R   (   RB   R   (   t   valueR   (    (    s.   /usr/lib/python2.7/multiprocessing/__init__.pyR   ¿   s    c         C   s   d d l  m } | |  É S(   s,   
    Returns a bounded semaphore object
    iˇˇˇˇ(   R   (   RB   R   (   RD   R   (    (    s.   /usr/lib/python2.7/multiprocessing/__init__.pyR   «   s    c          C   s   d d l  m }  |  É  S(   s!   
    Returns an event object
    iˇˇˇˇ(   R   (   RB   R   (   R   (    (    s.   /usr/lib/python2.7/multiprocessing/__init__.pyR   Œ   s    i    c         C   s   d d l  m } | |  É S(   s    
    Returns a queue object
    iˇˇˇˇ(   R   (   t   multiprocessing.queuesR   (   t   maxsizeR   (    (    s.   /usr/lib/python2.7/multiprocessing/__init__.pyR   ’   s    c         C   s   d d l  m } | |  É S(   s    
    Returns a queue object
    iˇˇˇˇ(   R   (   RE   R   (   RF   R   (    (    s.   /usr/lib/python2.7/multiprocessing/__init__.pyR   ‹   s    c         C   s#   d d l  m } | |  | | | É S(   s'   
    Returns a process pool object
    iˇˇˇˇ(   R   (   t   multiprocessing.poolR   (   t	   processest   initializert   initargst   maxtasksperchildR   (    (    s.   /usr/lib/python2.7/multiprocessing/__init__.pyR   „   s    c         G   s   d d l  m } | |  | å S(   s!   
    Returns a shared object
    iˇˇˇˇ(   R   (   t   multiprocessing.sharedctypesR   (   t   typecode_or_typet   argsR   (    (    s.   /usr/lib/python2.7/multiprocessing/__init__.pyR   Í   s    c         C   s   d d l  m } | |  | É S(   s    
    Returns a shared array
    iˇˇˇˇ(   R   (   RL   R   (   RM   t   size_or_initializerR   (    (    s.   /usr/lib/python2.7/multiprocessing/__init__.pyR   Ò   s    c         O   s    d d l  m } | |  | | é S(   s.   
    Returns a synchronized shared object
    iˇˇˇˇ(   R   (   RL   R   (   RM   RN   t   kwdsR   (    (    s.   /usr/lib/python2.7/multiprocessing/__init__.pyR   ¯   s    c         K   s    d d l  m } | |  | | ç S(   s-   
    Returns a synchronized shared array
    iˇˇˇˇ(   R   (   RL   R   (   RM   RO   RP   R   (    (    s.   /usr/lib/python2.7/multiprocessing/__init__.pyR   ˇ   s    R%   c         C   s   d d l  m } | |  É d S(   sª   
        Sets the path to a python.exe or pythonw.exe binary used to run
        child processes on Windows instead of sys.executable.
        Useful for people embedding Python.
        iˇˇˇˇ(   t   set_executableN(   R=   RQ   (   t
   executableRQ   (    (    s.   /usr/lib/python2.7/multiprocessing/__init__.pyRQ     s    RQ   (    (*   t   __version__t   __all__t
   __author__R-   R*   t   multiprocessing.processR    R   R   R>   R   R   t	   ExceptionR   R
   R   R   t   _multiprocessingR   t   TrueR   R   R   R   t   NoneR   R	   R   R   R   R   R   R   R   R   R   R   R   R   R   R+   RQ   (    (    (    s.   /usr/lib/python2.7/multiprocessing/__init__.pyt   <module>,   sN   							
									                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   # Generated by h2py from /usr/include/dlfcn.h
_DLFCN_H = 1

# Included from features.h
_FEATURES_H = 1
__USE_ANSI = 1
__FAVOR_BSD = 1
_ISOC99_SOURCE = 1
_POSIX_SOURCE = 1
_POSIX_C_SOURCE = 199506L
_XOPEN_SOURCE = 600
_XOPEN_SOURCE_EXTENDED = 1
_LARGEFILE64_SOURCE = 1
_BSD_SOURCE = 1
_SVID_SOURCE = 1
_BSD_SOURCE = 1
_SVID_SOURCE = 1
__USE_ISOC99 = 1
_POSIX_SOURCE = 1
_POSIX_C_SOURCE = 2
_POSIX_C_SOURCE = 199506L
__USE_POSIX = 1
__USE_POSIX2 = 1
__USE_POSIX199309 = 1
__USE_POSIX199506 = 1
__USE_XOPEN = 1
__USE_XOPEN_EXTENDED = 1
__USE_UNIX98 = 1
_LARGEFILE_SOURCE = 1
__USE_XOPEN2K = 1
__USE_ISOC99 = 1
__USE_XOPEN_EXTENDED = 1
__USE_LARGEFILE = 1
__USE_LARGEFILE64 = 1
__USE_FILE_OFFSET64 = 1
__USE_MISC = 1
__USE_BSD = 1
__USE_SVID = 1
__USE_GNU = 1
__USE_REENTRANT = 1
__STDC_IEC_559__ = 1
__STDC_IEC_559_COMPLEX__ = 1
__STDC_ISO_10646__ = 200009L
__GNU_LIBRARY__ = 6
__GLIBC__ = 2
__GLIBC_MINOR__ = 2

# Included from sys/cdefs.h
_SYS_CDEFS_H = 1
def __PMT(args): return args

def __P(args): return args

def __PMT(args): return args

def __STRING(x): return #x

__flexarr = []
__flexarr = [0]
__flexarr = []
__flexarr = [1]
def __ASMNAME(cname): return __ASMNAME2 (__USER_LABEL_PREFIX__, cname)

def __attribute__(xyz): return

def __attribute_format_arg__(x): return __attribute__ ((__format_arg__ (x)))

def __attribute_format_arg__(x): return

__USE_LARGEFILE = 1
__USE_LARGEFILE64 = 1
__USE_EXTERN_INLINES = 1

# Included from gnu/stubs.h

# Included from bits/dlfcn.h
RTLD_LAZY = 0x00001
RTLD_NOW = 0x00002
RTLD_BINDING_MASK = 0x3
RTLD_NOLOAD = 0x00004
RTLD_GLOBAL = 0x00100
RTLD_LOCAL = 0
RTLD_NODELETE = 0x01000
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    #
# A higher level module for using sockets (or Windows named pipes)
#
# multiprocessing/connection.py
#
# Copyright (c) 2006-2008, R Oudkerk
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 3. Neither the name of author nor the names of any contributors may be
#    used to endorse or promote products derived from this software
#    without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
#

__all__ = [ 'Client', 'Listener', 'Pipe' ]

import os
import sys
import socket
import errno
import time
import tempfile
import itertools

import _multiprocessing
from multiprocessing import current_process, AuthenticationError
from multiprocessing.util import get_temp_dir, Finalize, sub_debug, debug
from multiprocessing.forking import duplicate, close


#
#
#

BUFSIZE = 8192
# A very generous timeout when it comes to local connections...
CONNECTION_TIMEOUT = 20.

_mmap_counter = itertools.count()

default_family = 'AF_INET'
families = ['AF_INET']

if hasattr(socket, 'AF_UNIX'):
    default_family = 'AF_UNIX'
    families += ['AF_UNIX']

if sys.platform == 'win32':
    default_family = 'AF_PIPE'
    families += ['AF_PIPE']


def _init_timeout(timeout=CONNECTION_TIMEOUT):
    return time.time() + timeout

def _check_timeout(t):
    return time.time() > t

#
#
#

def arbitrary_address(family):
    '''
    Return an arbitrary free address for the given family
    '''
    if family == 'AF_INET':
        return ('localhost', 0)
    elif family == 'AF_UNIX':
        return tempfile.mktemp(prefix='listener-', dir=get_temp_dir())
    elif family == 'AF_PIPE':
        return tempfile.mktemp(prefix=r'\\.\pipe\pyc-%d-%d-' %
                               (os.getpid(), _mmap_counter.next()), dir="")
    else:
        raise ValueError('unrecognized family')


def address_type(address):
    '''
    Return the types of the address

    This can be 'AF_INET', 'AF_UNIX', or 'AF_PIPE'
    '''
    if type(address) == tuple:
        return 'AF_INET'
    elif type(address) is str and address.startswith('\\\\'):
        return 'AF_PIPE'
    elif type(address) is str:
        return 'AF_UNIX'
    else:
        raise ValueError('address type of %r unrecognized' % address)

#
# Public functions
#

class Listener(object):
    '''
    Returns a listener object.

    This is a wrapper for a bound socket which is 'listening' for
    connections, or for a Windows named pipe.
    '''
    def __init__(self, address=None, family=None, backlog=1, authkey=None):
        family = family or (address and address_type(address)) \
                 or default_family
        address = address or arbitrary_address(family)

        if family == 'AF_PIPE':
            self._listener = PipeListener(address, backlog)
        else:
            self._listener = SocketListener(address, family, backlog)

        if authkey is not None and not isinstance(authkey, bytes):
            raise TypeError, 'authkey should be a byte string'

        self._authkey = authkey

    def accept(self):
        '''
        Accept a connection on the bound socket or named pipe of `self`.

        Returns a `Connection` object.
        '''
        c = self._listener.accept()
        if self._authkey:
            deliver_challenge(c, self._authkey)
            answer_challenge(c, self._authkey)
        return c

    def close(self):
        '''
        Close the bound socket or named pipe of `self`.
        '''
        return self._listener.close()

    address = property(lambda self: self._listener._address)
    last_accepted = property(lambda self: self._listener._last_accepted)


def Client(address, family=None, authkey=None):
    '''
    Returns a connection to the address of a `Listener`
    '''
    family = family or address_type(address)
    if family == 'AF_PIPE':
        c = PipeClient(address)
    else:
        c = SocketClient(address)

    if authkey is not None and not isinstance(authkey, bytes):
        raise TypeError, 'authkey should be a byte string'

    if authkey is not None:
        answer_challenge(c, authkey)
        deliver_challenge(c, authkey)

    return c


if sys.platform != 'win32':

    def Pipe(duplex=True):
        '''
        Returns pair of connection objects at either end of a pipe
        '''
        if duplex:
            s1, s2 = socket.socketpair()
            s1.setblocking(True)
            s2.setblocking(True)
            c1 = _multiprocessing.Connection(os.dup(s1.fileno()))
            c2 = _multiprocessing.Connection(os.dup(s2.fileno()))
            s1.close()
            s2.close()
        else:
            fd1, fd2 = os.pipe()
            c1 = _multiprocessing.Connection(fd1, writable=False)
            c2 = _multiprocessing.Connection(fd2, readable=False)

        return c1, c2

else:
    from _multiprocessing import win32

    def Pipe(duplex=True):
        '''
        Returns pair of connection objects at either end of a pipe
        '''
        address = arbitrary_address('AF_PIPE')
        if duplex:
            openmode = win32.PIPE_ACCESS_DUPLEX
            access = win32.GENERIC_READ | win32.GENERIC_WRITE
            obsize, ibsize = BUFSIZE, BUFSIZE
        else:
            openmode = win32.PIPE_ACCESS_INBOUND
            access = win32.GENERIC_WRITE
            obsize, ibsize = 0, BUFSIZE

        h1 = win32.CreateNamedPipe(
            address, openmode,
            win32.PIPE_TYPE_MESSAGE | win32.PIPE_READMODE_MESSAGE |
            win32.PIPE_WAIT,
            1, obsize, ibsize, win32.NMPWAIT_WAIT_FOREVER, win32.NULL
            )
        h2 = win32.CreateFile(
            address, access, 0, win32.NULL, win32.OPEN_EXISTING, 0, win32.NULL
            )
        win32.SetNamedPipeHandleState(
            h2, win32.PIPE_READMODE_MESSAGE, None, None
            )

        try:
            win32.ConnectNamedPipe(h1, win32.NULL)
        except WindowsError, e:
            if e.args[0] != win32.ERROR_PIPE_CONNECTED:
                raise

        c1 = _multiprocessing.PipeConnection(h1, writable=duplex)
        c2 = _multiprocessing.PipeConnection(h2, readable=duplex)

        return c1, c2

#
# Definitions for connections based on sockets
#

class SocketListener(object):
    '''
    Representation of a socket which is bound to an address and listening
    '''
    def __init__(self, address, family, backlog=1):
        self._socket = socket.socket(getattr(socket, family))
        try:
            self._socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            self._socket.setblocking(True)
            self._socket.bind(address)
            self._socket.listen(backlog)
            self._address = self._socket.getsockname()
        except socket.error:
            self._socket.close()
            raise
        self._family = family
        self._last_accepted = None

        if family == 'AF_UNIX':
            self._unlink = Finalize(
                self, os.unlink, args=(address,), exitpriority=0
                )
        else:
            self._unlink = None

    def accept(self):
        while True:
            try:
                s, self._last_accepted = self._socket.accept()
            except socket.error as e:
                if e.args[0] != errno.EINTR:
                    raise
            else:
                break
        s.setblocking(True)
        fd = duplicate(s.fileno())
        conn = _multiprocessing.Connection(fd)
        s.close()
        return conn

    def close(self):
        try:
            self._socket.close()
        finally:
            unlink = self._unlink
            if unlink is not None:
                self._unlink = None
                unlink()


def SocketClient(address):
    '''
    Return a connection object connected to the socket given by `address`
    '''
    family = getattr(socket, address_type(address))
    t = _init_timeout()

    while 1:
        s = socket.socket(family)
        s.setblocking(True)
        try:
            s.connect(address)
        except socket.error, e:
            s.close()
            if e.args[0] != errno.ECONNREFUSED or _check_timeout(t):
                debug('failed to connect to address %s', address)
                raise
            time.sleep(0.01)
        else:
            break
    else:
        raise

    fd = duplicate(s.fileno())
    conn = _multiprocessing.Connection(fd)
    s.close()
    return conn

#
# Definitions for connections based on named pipes
#

if sys.platform == 'win32':

    class PipeListener(object):
        '''
        Representation of a named pipe
        '''
        def __init__(self, address, backlog=None):
            self._address = address
            handle = win32.CreateNamedPipe(
                address, win32.PIPE_ACCESS_DUPLEX,
                win32.PIPE_TYPE_MESSAGE | win32.PIPE_READMODE_MESSAGE |
                win32.PIPE_WAIT,
                win32.PIPE_UNLIMITED_INSTANCES, BUFSIZE, BUFSIZE,
                win32.NMPWAIT_WAIT_FOREVER, win32.NULL
                )
            self._handle_queue = [handle]
            self._last_accepted = None

            sub_debug('listener created with address=%r', self._address)

            self.close = Finalize(
                self, PipeListener._finalize_pipe_listener,
                args=(self._handle_queue, self._address), exitpriority=0
                )

        def accept(self):
            newhandle = win32.CreateNamedPipe(
                self._address, win32.PIPE_ACCESS_DUPLEX,
                win32.PIPE_TYPE_MESSAGE | win32.PIPE_READMODE_MESSAGE |
                win32.PIPE_WAIT,
                win32.PIPE_UNLIMITED_INSTANCES, BUFSIZE, BUFSIZE,
                win32.NMPWAIT_WAIT_FOREVER, win32.NULL
                )
            self._handle_queue.append(newhandle)
            handle = self._handle_queue.pop(0)
            try:
                win32.ConnectNamedPipe(handle, win32.NULL)
            except WindowsError, e:
                # ERROR_NO_DATA can occur if a client has already connected,
                # written data and then disconnected -- see Issue 14725.
                if e.args[0] not in (win32.ERROR_PIPE_CONNECTED,
                                     win32.ERROR_NO_DATA):
                    raise
            return _multiprocessing.PipeConnection(handle)

        @staticmethod
        def _finalize_pipe_listener(queue, address):
            sub_debug('closing listener with address=%r', address)
            for handle in queue:
                close(handle)

    def PipeClient(address):
        '''
        Return a connection object connected to the pipe given by `address`
        '''
        t = _init_timeout()
        while 1:
            try:
                win32.WaitNamedPipe(address, 1000)
                h = win32.CreateFile(
                    address, win32.GENERIC_READ | win32.GENERIC_WRITE,
                    0, win32.NULL, win32.OPEN_EXISTING, 0, win32.NULL
                    )
            except WindowsError, e:
                if e.args[0] not in (win32.ERROR_SEM_TIMEOUT,
                                     win32.ERROR_PIPE_BUSY) or _check_timeout(t):
                    raise
            else:
                break
        else:
            raise

        win32.SetNamedPipeHandleState(
            h, win32.PIPE_READMODE_MESSAGE, None, None
            )
        return _multiprocessing.PipeConnection(h)

#
# Authentication stuff
#

MESSAGE_LENGTH = 20

CHALLENGE = b'#CHALLENGE#'
WELCOME = b'#WELCOME#'
FAILURE = b'#FAILURE#'

def deliver_challenge(connection, authkey):
    import hmac
    assert isinstance(authkey, bytes)
    message = os.urandom(MESSAGE_LENGTH)
    connection.send_bytes(CHALLENGE + message)
    digest = hmac.new(authkey, message).digest()
    response = connection.recv_bytes(256)        # reject large message
    if response == digest:
        connection.send_bytes(WELCOME)
    else:
        connection.send_bytes(FAILURE)
        raise AuthenticationError('digest received was wrong')

def answer_challenge(connection, authkey):
    import hmac
    assert isinstance(authkey, bytes)
    message = connection.recv_bytes(256)         # reject large message
    assert message[:len(CHALLENGE)] == CHALLENGE, 'message = %r' % message
    message = message[len(CHALLENGE):]
    digest = hmac.new(authkey, message).digest()
    connection.send_bytes(digest)
    response = connection.recv_bytes(256)        # reject large message
    if response != WELCOME:
        raise AuthenticationError('digest sent was rejected')

#
# Support for using xmlrpclib for serialization
#

class ConnectionWrapper(object):
    def __init__(self, conn, dumps, loads):
        self._conn = conn
        self._dumps = dumps
        self._loads = loads
        for attr in ('fileno', 'close', 'poll', 'recv_bytes', 'send_bytes'):
            obj = getattr(conn, attr)
            setattr(self, attr, obj)
    def send(self, obj):
        s = self._dumps(obj)
        self._conn.send_bytes(s)
    def recv(self):
        s = self._conn.recv_bytes()
        return self._loads(s)

def _xml_dumps(obj):
    return xmlrpclib.dumps((obj,), None, None, None, 1)

def _xml_loads(s):
    (obj,), method = xmlrpclib.loads(s)
    return obj

class XmlListener(Listener):
    def accept(self):
        global xmlrpclib
        import xmlrpclib
        obj = Listener.accept(self)
        return ConnectionWrapper(obj, _xml_dumps, _xml_loads)

def XmlClient(*args, **kwds):
    global xmlrpclib
    import xmlrpclib
    return ConnectionWrapper(Client(*args, **kwds), _xml_dumps, _xml_loads)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          Û
”´[c           @   sy  d  d d g Z  d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l	 m
 Z
 m Z d d l m Z m Z m Z m Z d d l m Z m Z d Z d	 Z e j É  Z d
 Z d
 g Z e e d É r	d Z e d g 7Z n  e j d k r.d Z e d g 7Z n  e d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d e  f d Ñ  É  YZ! d d d Ñ Z# e j d k ròe$ d Ñ Z% n d d l m& Z& e$ d Ñ Z% d e  f d Ñ  É  YZ' d Ñ  Z( e j d k rd e  f d Ñ  É  YZ) d Ñ  Z* n  d Z+ d Z, d Z- d  Z. d! Ñ  Z/ d" Ñ  Z0 d# e  f d$ Ñ  É  YZ1 d% Ñ  Z2 d& Ñ  Z3 d' e! f d( Ñ  É  YZ4 d) Ñ  Z5 d S(*   t   Clientt   Listenert   PipeiˇˇˇˇN(   t   current_processt   AuthenticationError(   t   get_temp_dirt   Finalizet	   sub_debugt   debug(   t	   duplicatet   closei    g      4@t   AF_INETt   AF_UNIXt   win32t   AF_PIPEc         C   s   t  j  É  |  S(   N(   t   time(   t   timeout(    (    s0   /usr/lib/python2.7/multiprocessing/connection.pyt   _init_timeoutI   s    c         C   s   t  j  É  |  k S(   N(   R   (   t   t(    (    s0   /usr/lib/python2.7/multiprocessing/connection.pyt   _check_timeoutL   s    c         C   s}   |  d k r d S|  d k r5 t  j d d d t É  É S|  d k rm t  j d d	 t j É  t j É  f d d
 É St d É Ç d S(   s?   
    Return an arbitrary free address for the given family
    R   t	   localhosti    R   t   prefixs	   listener-t   dirR   s   \\.\pipe\pyc-%d-%d-t    s   unrecognized familyN(   R   i    (   t   tempfilet   mktempR   t   ost   getpidt   _mmap_countert   nextt
   ValueError(   t   family(    (    s0   /usr/lib/python2.7/multiprocessing/connection.pyt   arbitrary_addressS   s     c         C   se   t  |  É t k r d St  |  É t k r; |  j d É r; d St  |  É t k rQ d St d |  É Ç d S(   s]   
    Return the types of the address

    This can be 'AF_INET', 'AF_UNIX', or 'AF_PIPE'
    R   s   \\R   R   s   address type of %r unrecognizedN(   t   typet   tuplet   strt
   startswithR   (   t   address(    (    s0   /usr/lib/python2.7/multiprocessing/connection.pyt   address_typeb   s    !c           B   sS   e  Z d  Z d d d d d Ñ Z d Ñ  Z d Ñ  Z e d Ñ  É Z e d Ñ  É Z	 RS(   sï   
    Returns a listener object.

    This is a wrapper for a bound socket which is 'listening' for
    connections, or for a Windows named pipe.
    i   c         C   sõ   | p | r t  | É p t } | p- t | É } | d k rQ t | | É |  _ n t | | | É |  _ | d  k	 ré t | t É ré t	 d Ç n  | |  _
 d  S(   NR   s   authkey should be a byte string(   R&   t   default_familyR    t   PipeListenert	   _listenert   SocketListenert   Nonet
   isinstancet   bytest	   TypeErrort   _authkey(   t   selfR%   R   t   backlogt   authkey(    (    s0   /usr/lib/python2.7/multiprocessing/connection.pyt   __init__|   s    c         C   s?   |  j  j É  } |  j r; t | |  j É t | |  j É n  | S(   sz   
        Accept a connection on the bound socket or named pipe of `self`.

        Returns a `Connection` object.
        (   R)   t   acceptR/   t   deliver_challenget   answer_challenge(   R0   t   c(    (    s0   /usr/lib/python2.7/multiprocessing/connection.pyR4   ã   s
    	c         C   s   |  j  j É  S(   sA   
        Close the bound socket or named pipe of `self`.
        (   R)   R
   (   R0   (    (    s0   /usr/lib/python2.7/multiprocessing/connection.pyR
   ó   s    c         C   s
   |  j  j S(   N(   R)   t   _address(   R0   (    (    s0   /usr/lib/python2.7/multiprocessing/connection.pyt   <lambda>ù   s    c         C   s
   |  j  j S(   N(   R)   t   _last_accepted(   R0   (    (    s0   /usr/lib/python2.7/multiprocessing/connection.pyR9   û   s    N(
   t   __name__t
   __module__t   __doc__R+   R3   R4   R
   t   propertyR%   t   last_accepted(    (    (    s0   /usr/lib/python2.7/multiprocessing/connection.pyR   u   s   		c         C   sé   | p t  |  É } | d k r- t |  É } n t |  É } | d k	 ra t | t É ra t d Ç n  | d k	 rä t | | É t | | É n  | S(   s=   
    Returns a connection to the address of a `Listener`
    R   s   authkey should be a byte stringN(	   R&   t
   PipeClientt   SocketClientR+   R,   R-   R.   R6   R5   (   R%   R   R2   R7   (    (    s0   /usr/lib/python2.7/multiprocessing/connection.pyR    °   s    c         C   sÀ   |  rÖ t  j É  \ } } | j t É | j t É t j t j | j É  É É } t j t j | j É  É É } | j	 É  | j	 É  n< t j
 É  \ } } t j | d t É} t j | d t É} | | f S(   sL   
        Returns pair of connection objects at either end of a pipe
        t   writablet   readable(   t   sockett
   socketpairt   setblockingt   Truet   _multiprocessingt
   ConnectionR   t   dupt   filenoR
   t   pipet   False(   t   duplext   s1t   s2t   c1t   c2t   fd1t   fd2(    (    s0   /usr/lib/python2.7/multiprocessing/connection.pyR   ∑   s    
(   R   c      	   C   sU  t  d É } |  r; t j } t j t j B} t t } } n t j } t j } d t } } t j | | t j t j	 Bt j
 Bd | | t j t j É } t j | | d t j t j d t j É } t j | t j	 d d É y t j | t j É Wn/ t k
 r } | j d t j k r!Ç  q!n Xt j | d |  É}	 t j | d |  É}
 |	 |
 f S(   sL   
        Returns pair of connection objects at either end of a pipe
        R   i    i   RB   RC   N(   R    R   t   PIPE_ACCESS_DUPLEXt   GENERIC_READt   GENERIC_WRITEt   BUFSIZEt   PIPE_ACCESS_INBOUNDt   CreateNamedPipet   PIPE_TYPE_MESSAGEt   PIPE_READMODE_MESSAGEt	   PIPE_WAITt   NMPWAIT_WAIT_FOREVERt   NULLt
   CreateFilet   OPEN_EXISTINGt   SetNamedPipeHandleStateR+   t   ConnectNamedPipet   WindowsErrort   argst   ERROR_PIPE_CONNECTEDRH   t   PipeConnection(   RN   R%   t   openmodet   accesst   obsizet   ibsizet   h1t   h2t   eRQ   RR   (    (    s0   /usr/lib/python2.7/multiprocessing/connection.pyR   Õ   s2    			$
R*   c           B   s,   e  Z d  Z d d Ñ Z d Ñ  Z d Ñ  Z RS(   sO   
    Representation of a socket which is bound to an address and listening
    i   c         C   sˆ   t  j  t t  | É É |  _ yb |  j j t  j t  j d É |  j j t É |  j j | É |  j j	 | É |  j j
 É  |  _ Wn$ t  j k
 r£ |  j j É  Ç  n X| |  _ d  |  _ | d k rÈ t |  t j d | f d d É|  _ n	 d  |  _ d  S(   Ni   R   Re   t   exitpriorityi    (   RD   t   getattrt   _sockett
   setsockoptt
   SOL_SOCKETt   SO_REUSEADDRRF   RG   t   bindt   listent   getsocknameR8   t   errorR
   t   _familyR+   R:   R   R   t   unlinkt   _unlink(   R0   R%   R   R1   (    (    s0   /usr/lib/python2.7/multiprocessing/connection.pyR3   ˚   s     		$c         C   sõ   x\ t  r^ y |  j j É  \ } |  _ Wn2 t j k
 rY } | j d t j k r[ Ç  q[ q XPq W| j	 t  É t
 | j É  É } t j | É } | j É  | S(   Ni    (   RG   Rq   R4   R:   RD   Rx   Re   t   errnot   EINTRRF   R	   RK   RH   RI   R
   (   R0   t   sRn   t   fdt   conn(    (    s0   /usr/lib/python2.7/multiprocessing/connection.pyR4     s    	

c         C   sA   z |  j  j É  Wd  |  j } | d  k	 r< d  |  _ | É  n  Xd  S(   N(   Rq   R
   R{   R+   (   R0   Rz   (    (    s0   /usr/lib/python2.7/multiprocessing/connection.pyR
     s    		(   R;   R<   R=   R3   R4   R
   (    (    (    s0   /usr/lib/python2.7/multiprocessing/connection.pyR*   ˜   s   	c         C   sÍ   t  t t |  É É } t É  } xö t j | É } | j t É y | j |  É Wnb t j k
 r≤ } | j É  | j	 d t
 j k sè t | É r¢ t d |  É Ç  n  t j d É q! XPq! WÇ  t | j É  É } t j | É } | j É  | S(   sO   
    Return a connection object connected to the socket given by `address`
    i    s   failed to connect to address %sg{ÆG·zÑ?(   Rp   RD   R&   R   RF   RG   t   connectRx   R
   Re   R|   t   ECONNREFUSEDR   R   R   t   sleepR	   RK   RH   RI   (   R%   R   R   R~   Rn   R   RÄ   (    (    s0   /usr/lib/python2.7/multiprocessing/connection.pyRA   )  s&    	
"
R(   c           B   s2   e  Z d  Z d d Ñ Z d Ñ  Z e d Ñ  É Z RS(   s0   
        Representation of a named pipe
        c      	   C   s†   | |  _  t j | t j t j t j Bt j Bt j t t t j	 t j
 É } | g |  _ d  |  _ t d |  j  É t |  t j d |  j |  j  f d d É|  _ d  S(   Ns    listener created with address=%rRe   Ro   i    (   R8   R   RZ   RU   R[   R\   R]   t   PIPE_UNLIMITED_INSTANCESRX   R^   R_   t   _handle_queueR+   R:   R   R   R(   t   _finalize_pipe_listenerR
   (   R0   R%   R1   t   handle(    (    s0   /usr/lib/python2.7/multiprocessing/connection.pyR3   O  s    			c      	   C   s≈   t  j |  j t  j t  j t  j Bt  j Bt  j t t t  j	 t  j
 É } |  j j | É |  j j d É } y t  j | t  j
 É Wn8 t k
 r∑ } | j d t  j t  j f k r∏ Ç  q∏ n Xt j | É S(   Ni    (   R   RZ   R8   RU   R[   R\   R]   RÑ   RX   R^   R_   RÖ   t   appendt   popRc   Rd   Re   Rf   t   ERROR_NO_DATARH   Rg   (   R0   t	   newhandleRá   Rn   (    (    s0   /usr/lib/python2.7/multiprocessing/connection.pyR4   b  s    
c         C   s,   t  d | É x |  D] } t | É q Wd  S(   Ns    closing listener with address=%r(   R   R
   (   t   queueR%   Rá   (    (    s0   /usr/lib/python2.7/multiprocessing/connection.pyRÜ   v  s    N(   R;   R<   R=   R+   R3   R4   t   staticmethodRÜ   (    (    (    s0   /usr/lib/python2.7/multiprocessing/connection.pyR(   K  s   	c         C   s…   t  É  } xó yH t j |  d É t j |  t j t j Bd t j t j d t j É } WnD t k
 rö } | j	 d t j
 t j f k së t | É rú Ç  qú q XPq WÇ  t j | t j d d É t j | É S(   sU   
        Return a connection object connected to the pipe given by `address`
        iË  i    N(   R   R   t   WaitNamedPipeR`   RV   RW   R_   Ra   Rd   Re   t   ERROR_SEM_TIMEOUTt   ERROR_PIPE_BUSYR   Rb   R\   R+   RH   Rg   (   R%   R   t   hRn   (    (    s0   /usr/lib/python2.7/multiprocessing/connection.pyR@   |  s     	"
i   s   #CHALLENGE#s	   #WELCOME#s	   #FAILURE#c         C   s°   d d  l  } t | t É s! t Ç t j t É } |  j t | É | j	 | | É j
 É  } |  j d É } | | k rÑ |  j t É n |  j t É t d É Ç d  S(   Niˇˇˇˇi   s   digest received was wrong(   t   hmacR,   R-   t   AssertionErrorR   t   urandomt   MESSAGE_LENGTHt
   send_bytest	   CHALLENGEt   newt   digestt
   recv_bytest   WELCOMEt   FAILURER   (   t
   connectionR2   Rí   t   messageRô   t   response(    (    s0   /usr/lib/python2.7/multiprocessing/connection.pyR5   †  s    c         C   sπ   d d  l  } t | t É s! t Ç |  j d É } | t t É  t k sV t d | É Ç | t t É } | j | | É j É  } |  j	 | É |  j d É } | t
 k rµ t d É Ç n  d  S(   Niˇˇˇˇi   s   message = %rs   digest sent was rejected(   Rí   R,   R-   Rì   Rö   t   lenRó   Rò   Rô   Rñ   Rõ   R   (   Rù   R2   Rí   Rû   Rô   Rü   (    (    s0   /usr/lib/python2.7/multiprocessing/connection.pyR6   ≠  s    &t   ConnectionWrapperc           B   s#   e  Z d  Ñ  Z d Ñ  Z d Ñ  Z RS(   c         C   sO   | |  _  | |  _ | |  _ x- d D]% } t | | É } t |  | | É q" Wd  S(   NRK   R
   t   pollRö   Rñ   (   RK   R
   R¢   Rö   Rñ   (   t   _connt   _dumpst   _loadsRp   t   setattr(   R0   RÄ   t   dumpst   loadst   attrt   obj(    (    s0   /usr/lib/python2.7/multiprocessing/connection.pyR3   æ  s    			c         C   s#   |  j  | É } |  j j | É d  S(   N(   R§   R£   Rñ   (   R0   R™   R~   (    (    s0   /usr/lib/python2.7/multiprocessing/connection.pyt   send≈  s    c         C   s   |  j  j É  } |  j | É S(   N(   R£   Rö   R•   (   R0   R~   (    (    s0   /usr/lib/python2.7/multiprocessing/connection.pyt   recv»  s    (   R;   R<   R3   R´   R¨   (    (    (    s0   /usr/lib/python2.7/multiprocessing/connection.pyR°   Ω  s   		c         C   s   t  j |  f d  d  d  d É S(   Ni   (   t	   xmlrpclibRß   R+   (   R™   (    (    s0   /usr/lib/python2.7/multiprocessing/connection.pyt
   _xml_dumpsÃ  s    c         C   s   t  j |  É \ \ } } | S(   N(   R≠   R®   (   R~   R™   t   method(    (    s0   /usr/lib/python2.7/multiprocessing/connection.pyt
   _xml_loadsœ  s    t   XmlListenerc           B   s   e  Z d  Ñ  Z RS(   c         C   s+   d d  l  a  t j |  É } t | t t É S(   Niˇˇˇˇ(   R≠   R   R4   R°   RÆ   R∞   (   R0   R™   (    (    s0   /usr/lib/python2.7/multiprocessing/connection.pyR4   ‘  s    (   R;   R<   R4   (    (    (    s0   /usr/lib/python2.7/multiprocessing/connection.pyR±   ”  s   c          O   s%   d d  l  a  t t |  | é  t t É S(   Niˇˇˇˇ(   R≠   R°   R    RÆ   R∞   (   Re   t   kwds(    (    s0   /usr/lib/python2.7/multiprocessing/connection.pyt	   XmlClient⁄  s    (6   t   __all__R   t   sysRD   R|   R   R   t	   itertoolsRH   t   multiprocessingR   R   t   multiprocessing.utilR   R   R   R   t   multiprocessing.forkingR	   R
   RX   t   CONNECTION_TIMEOUTt   countR   R'   t   familiest   hasattrt   platformR   R   R    R&   t   objectR   R+   R    RG   R   R   R*   RA   R(   R@   Rï   Ró   Rõ   Rú   R5   R6   R°   RÆ   R∞   R±   R≥   (    (    (    s0   /usr/lib/python2.7/multiprocessing/connection.pyt   <module>#   s`   "				,*2	 1				                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  #
# Module for starting a process object using os.fork() or CreateProcess()
#
# multiprocessing/forking.py
#
# Copyright (c) 2006-2008, R Oudkerk
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 3. Neither the name of author nor the names of any contributors may be
#    used to endorse or promote products derived from this software
#    without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
#

import os
import sys
import signal
import errno

from multiprocessing import util, process

__all__ = ['Popen', 'assert_spawning', 'exit', 'duplicate', 'close', 'ForkingPickler']

#
# Check that the current thread is spawning a child process
#

def assert_spawning(self):
    if not Popen.thread_is_spawning():
        raise RuntimeError(
            '%s objects should only be shared between processes'
            ' through inheritance' % type(self).__name__
            )

#
# Try making some callable types picklable
#

from pickle import Pickler
class ForkingPickler(Pickler):
    dispatch = Pickler.dispatch.copy()

    @classmethod
    def register(cls, type, reduce):
        def dispatcher(self, obj):
            rv = reduce(obj)
            self.save_reduce(obj=obj, *rv)
        cls.dispatch[type] = dispatcher

def _reduce_method(m):
    if m.im_self is None:
        return getattr, (m.im_class, m.im_func.func_name)
    else:
        return getattr, (m.im_self, m.im_func.func_name)
ForkingPickler.register(type(ForkingPickler.save), _reduce_method)

def _reduce_method_descriptor(m):
    return getattr, (m.__objclass__, m.__name__)
ForkingPickler.register(type(list.append), _reduce_method_descriptor)
ForkingPickler.register(type(int.__add__), _reduce_method_descriptor)

#def _reduce_builtin_function_or_method(m):
#    return getattr, (m.__self__, m.__name__)
#ForkingPickler.register(type(list().append), _reduce_builtin_function_or_method)
#ForkingPickler.register(type(int().__add__), _reduce_builtin_function_or_method)

try:
    from functools import partial
except ImportError:
    pass
else:
    def _reduce_partial(p):
        return _rebuild_partial, (p.func, p.args, p.keywords or {})
    def _rebuild_partial(func, args, keywords):
        return partial(func, *args, **keywords)
    ForkingPickler.register(partial, _reduce_partial)

#
# Unix
#

if sys.platform != 'win32':
    import time

    exit = os._exit
    duplicate = os.dup
    close = os.close

    #
    # We define a Popen class similar to the one from subprocess, but
    # whose constructor takes a process object as its argument.
    #

    class Popen(object):

        def __init__(self, process_obj):
            sys.stdout.flush()
            sys.stderr.flush()
            self.returncode = None

            self.pid = os.fork()
            if self.pid == 0:
                if 'random' in sys.modules:
                    import random
                    random.seed()
                code = process_obj._bootstrap()
                sys.stdout.flush()
                sys.stderr.flush()
                os._exit(code)

        def poll(self, flag=os.WNOHANG):
            if self.returncode is None:
                while True:
                    try:
                        pid, sts = os.waitpid(self.pid, flag)
                    except os.error as e:
                        if e.errno == errno.EINTR:
                            continue
                        # Child process not yet created. See #1731717
                        # e.errno == errno.ECHILD == 10
                        return None
                    else:
                        break
                if pid == self.pid:
                    if os.WIFSIGNALED(sts):
                        self.returncode = -os.WTERMSIG(sts)
                    else:
                        assert os.WIFEXITED(sts)
                        self.returncode = os.WEXITSTATUS(sts)
            return self.returncode

        def wait(self, timeout=None):
            if timeout is None:
                return self.poll(0)
            deadline = time.time() + timeout
            delay = 0.0005
            while 1:
                res = self.poll()
                if res is not None:
                    break
                remaining = deadline - time.time()
                if remaining <= 0:
                    break
                delay = min(delay * 2, remaining, 0.05)
                time.sleep(delay)
            return res

        def terminate(self):
            if self.returncode is None:
                try:
                    os.kill(self.pid, signal.SIGTERM)
                except OSError, e:
                    if self.wait(timeout=0.1) is None:
                        raise

        @staticmethod
        def thread_is_spawning():
            return False

#
# Windows
#

else:
    import thread
    import msvcrt
    import _subprocess
    import time

    from _multiprocessing import win32, Connection, PipeConnection
    from .util import Finalize

    #try:
    #    from cPickle import dump, load, HIGHEST_PROTOCOL
    #except ImportError:
    from pickle import load, HIGHEST_PROTOCOL

    def dump(obj, file, protocol=None):
        ForkingPickler(file, protocol).dump(obj)

    #
    #
    #

    TERMINATE = 0x10000
    WINEXE = (sys.platform == 'win32' and getattr(sys, 'frozen', False))
    WINSERVICE = sys.executable.lower().endswith("pythonservice.exe")

    exit = win32.ExitProcess
    close = win32.CloseHandle

    #
    # _python_exe is the assumed path to the python executable.
    # People embedding Python want to modify it.
    #

    if WINSERVICE:
        _python_exe = os.path.join(sys.exec_prefix, 'python.exe')
    else:
        _python_exe = sys.executable

    def set_executable(exe):
        global _python_exe
        _python_exe = exe

    #
    #
    #

    def duplicate(handle, target_process=None, inheritable=False):
        if target_process is None:
            target_process = _subprocess.GetCurrentProcess()
        return _subprocess.DuplicateHandle(
            _subprocess.GetCurrentProcess(), handle, target_process,
            0, inheritable, _subprocess.DUPLICATE_SAME_ACCESS
            ).Detach()

    #
    # We define a Popen class similar to the one from subprocess, but
    # whose constructor takes a process object as its argument.
    #

    class Popen(object):
        '''
        Start a subprocess to run the code of a process object
        '''
        _tls = thread._local()

        def __init__(self, process_obj):
            # create pipe for communication with child
            rfd, wfd = os.pipe()

            # get handle for read end of the pipe and make it inheritable
            rhandle = duplicate(msvcrt.get_osfhandle(rfd), inheritable=True)
            os.close(rfd)

            # start process
            cmd = get_command_line() + [rhandle]
            cmd = ' '.join('"%s"' % x for x in cmd)
            hp, ht, pid, tid = _subprocess.CreateProcess(
                _python_exe, cmd, None, None, 1, 0, None, None, None
                )
            ht.Close()
            close(rhandle)

            # set attributes of self
            self.pid = pid
            self.returncode = None
            self._handle = hp

            # send information to child
            prep_data = get_preparation_data(process_obj._name)
            to_child = os.fdopen(wfd, 'wb')
            Popen._tls.process_handle = int(hp)
            try:
                dump(prep_data, to_child, HIGHEST_PROTOCOL)
                dump(process_obj, to_child, HIGHEST_PROTOCOL)
            finally:
                del Popen._tls.process_handle
                to_child.close()

        @staticmethod
        def thread_is_spawning():
            return getattr(Popen._tls, 'process_handle', None) is not None

        @staticmethod
        def duplicate_for_child(handle):
            return duplicate(handle, Popen._tls.process_handle)

        def wait(self, timeout=None):
            if self.returncode is None:
                if timeout is None:
                    msecs = _subprocess.INFINITE
                else:
                    msecs = max(0, int(timeout * 1000 + 0.5))

                res = _subprocess.WaitForSingleObject(int(self._handle), msecs)
                if res == _subprocess.WAIT_OBJECT_0:
                    code = _subprocess.GetExitCodeProcess(self._handle)
                    if code == TERMINATE:
                        code = -signal.SIGTERM
                    self.returncode = code

            return self.returncode

        def poll(self):
            return self.wait(timeout=0)

        def terminate(self):
            if self.returncode is None:
                try:
                    _subprocess.TerminateProcess(int(self._handle), TERMINATE)
                except WindowsError:
                    if self.wait(timeout=0.1) is None:
                        raise

    #
    #
    #

    def is_forking(argv):
        '''
        Return whether commandline indicates we are forking
        '''
        if len(argv) >= 2 and argv[1] == '--multiprocessing-fork':
            assert len(argv) == 3
            return True
        else:
            return False


    def freeze_support():
        '''
        Run code for process object if this in not the main process
        '''
        if is_forking(sys.argv):
            main()
            sys.exit()


    def get_command_line():
        '''
        Returns prefix of command line used for spawning a child process
        '''
        if getattr(process.current_process(), '_inheriting', False):
            raise RuntimeError('''
            Attempt to start a new process before the current process
            has finished its bootstrapping phase.

            This probably means that you are on Windows and you have
            forgotten to use the proper idiom in the main module:

                if __name__ == '__main__':
                    freeze_support()
                    ...

            The "freeze_support()" line can be omitted if the program
            is not going to be frozen to produce a Windows executable.''')

        if getattr(sys, 'frozen', False):
            return [sys.executable, '--multiprocessing-fork']
        else:
            prog = 'from multiprocessing.forking import main; main()'
            opts = util._args_from_interpreter_flags()
            return [_python_exe] + opts + ['-c', prog, '--multiprocessing-fork']


    def main():
        '''
        Run code specified by data received over pipe
        '''
        assert is_forking(sys.argv)

        handle = int(sys.argv[-1])
        fd = msvcrt.open_osfhandle(handle, os.O_RDONLY)
        from_parent = os.fdopen(fd, 'rb')

        process.current_process()._inheriting = True
        preparation_data = load(from_parent)
        prepare(preparation_data)
        self = load(from_parent)
        process.current_process()._inheriting = False

        from_parent.close()

        exitcode = self._bootstrap()
        exit(exitcode)


    def get_preparation_data(name):
        '''
        Return info about parent needed by child to unpickle process object
        '''
        from .util import _logger, _log_to_stderr

        d = dict(
            name=name,
            sys_path=sys.path,
            sys_argv=sys.argv,
            log_to_stderr=_log_to_stderr,
            orig_dir=process.ORIGINAL_DIR,
            authkey=process.current_process().authkey,
            )

        if _logger is not None:
            d['log_level'] = _logger.getEffectiveLevel()

        if not WINEXE and not WINSERVICE:
            main_path = getattr(sys.modules['__main__'], '__file__', None)
            if not main_path and sys.argv[0] not in ('', '-c'):
                main_path = sys.argv[0]
            if main_path is not None:
                if not os.path.isabs(main_path) and \
                                          process.ORIGINAL_DIR is not None:
                    main_path = os.path.join(process.ORIGINAL_DIR, main_path)
                d['main_path'] = os.path.normpath(main_path)

        return d

    #
    # Make (Pipe)Connection picklable
    #

    def reduce_connection(conn):
        if not Popen.thread_is_spawning():
            raise RuntimeError(
                'By default %s objects can only be shared between processes\n'
                'using inheritance' % type(conn).__name__
                )
        return type(conn), (Popen.duplicate_for_child(conn.fileno()),
                            conn.readable, conn.writable)

    ForkingPickler.register(Connection, reduce_connection)
    ForkingPickler.register(PipeConnection, reduce_connection)

#
# Prepare current process
#

old_main_modules = []

def prepare(data):
    '''
    Try to get current process ready to unpickle process object
    '''
    old_main_modules.append(sys.modules['__main__'])

    if 'name' in data:
        process.current_process().name = data['name']

    if 'authkey' in data:
        process.current_process()._authkey = data['authkey']

    if 'log_to_stderr' in data and data['log_to_stderr']:
        util.log_to_stderr()

    if 'log_level' in data:
        util.get_logger().setLevel(data['log_level'])

    if 'sys_path' in data:
        sys.path = data['sys_path']

    if 'sys_argv' in data:
        sys.argv = data['sys_argv']

    if 'dir' in data:
        os.chdir(data['dir'])

    if 'orig_dir' in data:
        process.ORIGINAL_DIR = data['orig_dir']

    if 'main_path' in data:
        # XXX (ncoghlan): The following code makes several bogus
        # assumptions regarding the relationship between __file__
        # and a module's real name. See PEP 302 and issue #10845
        # The problem is resolved properly in Python 3.4+, as
        # described in issue #19946

        main_path = data['main_path']
        main_name = os.path.splitext(os.path.basename(main_path))[0]
        if main_name == '__init__':
            main_name = os.path.basename(os.path.dirname(main_path))

        if main_name == '__main__':
            # For directory and zipfile execution, we assume an implicit
            # "if __name__ == '__main__':" around the module, and don't
            # rerun the main module code in spawned processes
            main_module = sys.modules['__main__']
            main_module.__file__ = main_path
        elif main_name != 'ipython':
            # Main modules not actually called __main__.py may
            # contain additional code that should still be executed
            import imp

            if main_path is None:
                dirs = None
            elif os.path.basename(main_path).startswith('__init__.py'):
                dirs = [os.path.dirname(os.path.dirname(main_path))]
            else:
                dirs = [os.path.dirname(main_path)]

            assert main_name not in sys.modules, main_name
            file, path_name, etc = imp.find_module(main_name, dirs)
            try:
                # We would like to do "imp.load_module('__main__', ...)"
                # here.  However, that would cause 'if __name__ ==
                # "__main__"' clauses to be executed.
                main_modul