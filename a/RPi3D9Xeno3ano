/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// OpenMAX IL - Broadcom specific types

#ifndef OMX_Broadcom_h
#define OMX_Broadcom_h

#include "OMX_Component.h"

// for use in buffer headers - marks the contained data
// as being a codec header
#define OMX_BUFFERFLAG_TIME_UNKNOWN 0x00000100

//for use in buffer headers - marks the buffer as being the
//snapshot preview image from a still capture.
//Mainly to be used with the DisplayFunction callback from camera.
#define OMX_BUFFERFLAG_CAPTURE_PREVIEW 0x00000200

/* Mark the end of a NAL unit produced by a video encoder.
 */
#define OMX_BUFFERFLAG_ENDOFNAL    0x00000400

/* Marks pBuffer in OMX_BUFFERHEADERTYPE as containing a fragment list instead of the actual buffer
 */
#define OMX_BUFFERFLAG_FRAGMENTLIST 0x00000800

/* Marks the start of a new sequence of data following any kind of seek operation.
 */
#define OMX_BUFFERFLAG_DISCONTINUITY 0x00001000

/** Codec side information Flag:
* OMX_BUFFERFLAG_CODECSIDEINFO is an optional flag that is set by an
* output port when all bytes in the buffer form part or all of a set of
* codec specific side information. For example, distortion information
* estimated by H.264 encoder can be sent using this flag to signal
* the decoder quality
*/
#define OMX_BUFFERFLAG_CODECSIDEINFO 0x00002000

// for use in buffer headers - indicated the timestamp is a DTS rather than PTS
#define OMX_BUFFERFLAG_TIME_IS_DTS 0x00004000

// for use in buffer headers - signals that a video picture is interlaced
#define OMX_BUFFERFLAG_INTERLACED 0x00010000

// Signals that the top field of the current interlaced frame should be displayed first
#define OMX_BUFFERFLAG_TOP_FIELD_FIRST 0x00020000

// User flags that can be set by the application and will be passed by most
// components as an alternative to buffer marks.
#define OMX_BUFFERFLAG_USR0      0x10000000
#define OMX_BUFFERFLAG_USR1      0x20000000
#define OMX_BUFFERFLAG_USR2      0x40000000
#define OMX_BUFFERFLAG_USR3      0x80000000
#define OMX_BUFFERFLAG_USR_FLAGS 0xF0000000

/**
 * Macros to convert to <code>OMX_TICKS</code> from a signed 64 bit value and
 * vice-versa. These macros don't actually do anything unless <code>OMX_TICKS</code>
 * is defined as a two-part structure (instead of a native signed 64-bit type).
 **/
#ifndef OMX_SKIP64BIT
   #define omx_ticks_from_s64(s) (s)
   #define omx_ticks_to_s64(t) (t)
#else
   static inline OMX_TICKS omx_ticks_from_s64(signed long long s) { OMX_TICKS t; t.nLowPart = (OMX_U32)s; t.nHighPart = (OMX_U32)(s>>32); return t; }
   #define omx_ticks_to_s64(t) ((t).nLowPart | ((uint64_t)((t).nHighPart) << 32))
#endif /* OMX_SKIP64BIT */

/* Buffer fragment descriptor */
typedef struct OMX_BUFFERFRAGMENTTYPE {
   OMX_PTR pBuffer; /**< Pointer to actual block of memory that is acting as the fragment buffer */
   OMX_U32 nLen;    /**< number of bytes in the buffer */
} OMX_BUFFERFRAGMENTTYPE;

/* OMX_IndexParamBrcmEnableIJGTableScaling: JPEG Quality Table Setting. */
typedef struct OMX_PARAM_IJGSCALINGTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_BOOL bEnabled;
} OMX_PARAM_IJGSCALINGTYPE;
/*
The boolean \code{bEnabled} value determines whether the component uses
the standard IJG quality tables when encoding images.
*/


/* OMX_IndexConfigTimeInvalidStartTime: Invalid Start Times */
/*
This allows clock clients to supply a start time notification to the
clock whilst indicating that this time is invalid.
*/

/* OMX_IndexParamBrcmMaxFrameSkips: Frame timestamp jumps */
/*
This number represents the number of times a jump in frame timestamps
has been observed that is greater than expected.
*/

/* OMX_IndexConfigAsynchronousFailureURI: Asynchronous Failure Filename */
/*
This allows the client to query for the filename that cause an asynchronous
output error.
*/

/* OMX_IndexParamAsynchronousOutput: Asynchronous Output */
/*
The allows the client to specify to a component that is writing files
that this writing may happen asynchronously, including opening and closing
of files.
*/

/* OMX_IndexConfigClockAdjustment: Clock Adjustment */
/*
This allows the client to read from the clock the total time
adjustment made to the clock whilst running by the reference clock.
If the reference clock sends a time that causes the media time to jump
this difference is added to the total, which can be reported via this
index.  When the stream restarts by setting the clock state to
\code{OMX_TIME_ClockStateRunning} or
\code{OMX_TIME_ClockStateWaitingForStartTime} this adjustment total is
set to zero.
*/

/* OMX_IndexParamBrcmDataUnit: Data Unit */
/*
The data unit is an indication to components connected to this
component of the type of data delivery available.
\code{OMX_DataUnitCodedPicture} indicates that we are able to give
framing information, using the \code{OMX_BUFFERFLAG_ENDOFFRAME} flag to
indicate that the data contained finishes a complete
frame. \code{OMX_DataUnitArbitraryStreamSection} indicates that no
end-of-frame markers will be present, and the decoder should perform
the steps necessary to decode the stream. The other enum values are
not used.
*/

/* OMX_IndexConfigPresentationOffset: Presentation Offset */
/*
The value of \code{nTimestamp} is added to the offset requested for
each new input frame. Takes effect for all new input frames, and has
no effect on the offset used for currently-queued frames. A positive
value will make the requested port earlier relative to other streams,
a negative value will make the requested port later relative to other
streams.
*/

/* OMX_IndexConfigSingleStep: Single Step */
/*
When setting this config on a paused clock, where the \code{nU32}
value is non-zero and \code{nPortIndex} is OMX_ALL, the media clock
will advance through the next \code{nU32} next requested media
times. A paused clock is in running state but has a time scale of
0. This will trigger the display of some video frames, so allowing
single-stepping functionality. This config can be set multiple times,
and will buffer up stepping requests until we have media requests to
fulfil, or the clock is stopped or un-paused.

This config can also be used on some video output ports and, if
\code{nU32} is non-zero, requests that the output port forwards the
next \code{nU32} frames appending an EOS marker on the last frame, and
then ceases to forward data on this port.  If \code{nU32} is zero, any
previous request to forward a limited number of frames is cancelled
and the default behaviour of this port will resume.
*/

/* OMX_IndexParamCameraCamplusId: Camera Subsystem Identification */
/*
This parameter allows the configuration of the identifier to be used
to initialise the Broadcom Camplus subsystem that sits beneath the
camera component. If only one instance of the camera component is
used, the default value can be used. If more than one instance is
required, they must each have their own unique values for this
parameter. It is also used to tie the component to the image pool
created with \code{OMX_Set upCamPools}.
*/

/* OMX_IndexConfigAudioRenderingLatency: Audio Rendering Latency */
/*
This config allows the client to query the current latency of audio
rendering.  The latency is returned as the number of samples that
an audio rendering component has received but have not been played.
*/

/* OMX_IndexConfigBrcmPoolMemAllocSize: Pool memory usage values */
/*
This config allows the client to query how much memory is being used by
the component for any image pools. 
*/

/* OMX_IndexConfigDisplayRegion: Display Region */
typedef enum OMX_DISPLAYTRANSFORMTYPE{
   OMX_DISPLAY_ROT0 = 0,
   OMX_DISPLAY_MIRROR_ROT0 = 1,
   OMX_DISPLAY_MIRROR_ROT180 = 2,
   OMX_DISPLAY_ROT180 = 3,
   OMX_DISPLAY_MIRROR_ROT90 = 4,
   OMX_DISPLAY_ROT270 = 5,
   OMX_DISPLAY_ROT90 = 6,
   OMX_DISPLAY_MIRROR_ROT270 = 7,
   OMX_DISPLAY_DUMMY = 0x7FFFFFFF
} OMX_DISPLAYTRANSFORMTYPE;

typedef struct OMX_DISPLAYRECTTYPE {
   OMX_S16 x_offset;
   OMX_S16 y_offset;
   OMX_S16 width;
   OMX_S16 height;
} OMX_DISPLAYRECTTYPE;

typedef enum OMX_DISPLAYMODETYPE {
   OMX_DISPLAY_MODE_FILL = 0,
   OMX_DISPLAY_MODE_LETTERBOX = 1,
   // these allow a left eye source->dest to be specified and the right eye mapping will be inferred by symmetry
   OMX_DISPLAY_MODE_STEREO_LEFT_TO_LEFT = 2,
   OMX_DISPLAY_MODE_STEREO_TOP_TO_TOP = 3,
   OMX_DISPLAY_MODE_STEREO_LEFT_TO_TOP = 4,
   OMX_DISPLAY_MODE_STEREO_TOP_TO_LEFT = 5,
   OMX_DISPLAY_MODE_DUMMY = 0x7FFFFFFF
} OMX_DISPLAYMODETYPE;

typedef enum OMX_DISPLAYSETTYPE {
   OMX_DISPLAY_SET_NONE = 0,
   OMX_DISPLAY_SET_NUM = 1,
   OMX_DISPLAY_SET_FULLSCREEN = 2,
   OMX_DISPLAY_SET_TRANSFORM = 4,
   OMX_DISPLAY_SET_DEST_RECT = 8,
   OMX_DISPLAY_SET_SRC_RECT = 0x10,
   OMX_DISPLAY_SET_MODE = 0x20,
   OMX_DISPLAY_SET_PIXEL = 0x40,
   OMX_DISPLAY_SET_NOASPECT = 0x80,
   OMX_DISPLAY_SET_LAYER = 0x100,
   OMX_DISPLAY_SET_COPYPROTECT = 0x200,
   OMX_DISPLAY_SET_ALPHA = 0x400,
   OMX_DISPLAY_SET_DUMMY = 0x7FFFFFFF
} OMX_DISPLAYSETTYPE;

typedef enum OMX_DISPLAYASPECTFLAGSTYPE {
  OMX_DISPLAY_ALPHA_FLAGS_NONE = 0,
  // All layers below and including this one will be ignored (used for screen
  // blanking in full screen rendering)
  OMX_DISPLAY_ALPHA_FLAGS_DISCARD_LOWER_LAYERS = 1<<29,
  // Alpha values are already premultiplied
  OMX_DISPLAY_ALPHA_FLAGS_PREMULT = 1<<30,
  // Mix the per pixel alpha (if present) and the per plane alpha.
  OMX_DISPLAY_ALPHA_FLAGS_MIX = 1<<31,
} OMX_DISPLAYASPECTFLAGSTYPE;

typedef struct OMX_CONFIG_DISPLAYREGIONTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_DISPLAYSETTYPE set;
   OMX_U32 num;
   OMX_BOOL fullscreen;
   OMX_DISPLAYTRANSFORMTYPE transform;
   OMX_DISPLAYRECTTYPE dest_rect;
   OMX_DISPLAYRECTTYPE src_rect;
   OMX_BOOL noaspect;
   OMX_DISPLAYMODETYPE mode;
   OMX_U32 pixel_x;
   OMX_U32 pixel_y;
   OMX_S32 layer;
   OMX_BOOL copyprotect_required;
   OMX_U32 alpha;
   OMX_U32 wfc_context_width;
   OMX_U32 wfc_context_height;
} OMX_CONFIG_DISPLAYREGIONTYPE;
/*
This config sets the output display device, as well as the region used
on the output display, any display transformation, and some flags to
indicate how to scale the image.

The structure uses a bitfield, \code{set}, to indicate which fields are set
and should be used. All other fields will maintain their current
value.

\code{num} describes the display output device, with 0 typically being
a directly connected LCD display.

\code{fullscreen} indicates that we are using the full device screen
area, rather than a window of the display.  If fullscreen is false,
then dest_rect is used to specify a region of the display to use.

\code{transform} indicates any rotation or flipping used to map frames
onto the natural display orientation.

The \code{src_rect} indicates which area of the frame to display. If
all values are zero, the whole frame will be used.

The \code{noaspect} flag, if set, indicates that any display scaling
should disregard the aspect ratio of the frame region being displayed.

\code{mode} indicates how the image should be scaled to fit the
display. \code{OMX_DISPLAY_MODE_FILL} indicates that the image should
fill the screen by potentially cropping the frames.  Setting
\code{mode} to \code{OMX_DISPLAY_MODE_LETTERBOX} indicates that all
the source region should be displayed and black bars added if
necessary.

The \code{pixel_x} and \code{pixel_y} values, if non-zero, are used to
describe the size of a source pixel. If values are zero, then pixels
default to being square.

Set the \code{layer} that the image will appear on with the
\code{layer} field.
*/



/* OMX_IndexParamSource: Source Image Configuration */
typedef enum OMX_SOURCETYPE {
   OMX_SOURCE_WHITE = 0,    // all white images
   OMX_SOURCE_BLACK = 1,    // all black images
   OMX_SOURCE_DIAGONAL = 2, // greyscale diagonal stripes
   OMX_SOURCE_NOISE = 3,    // random pixel values
   OMX_SOURCE_RANDOM = 4,   // a shaded random pattern of colours
   OMX_SOURCE_COLOUR = 5,   // a solid colour determined by nParam
   OMX_SOURCE_BLOCKS = 6,   // random coloured blocks of 16x16 size
   OMX_SOURCE_SWIRLY,       // a swirly pattern used for encode testing
   OMX_SOURCE_DUMMY = 0x7FFFFFFF
} OMX_SOURCETYPE;

typedef struct OMX_PARAM_SOURCETYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_SOURCETYPE eType;
   OMX_U32 nParam;
   OMX_U32 nFrameCount;
   OMX_U32 xFrameRate;
} OMX_PARAM_SOURCETYPE;
/*
The source type determines the kind of image that is produced. Not all
combinations of source type and image type are supported.  The
\code{OMX_SOURCE_SWIRLY} setting can only be used with YUV420 packed
planar image formats.  When producing RGB565 image format, the
\code{OMX_SOURCE_DIAGONAL} and \code{OMX_SOURCE_RANDOM} modes are
treated as \code{OMX_SOURCE_NOISE}.

The \code{nParam} field is used to specify the colour for the source
colour mode, and the offset of the diagonal pattern for diagonal mode.
For the blocks mode, \code{nParam} is used as the seed for the random
colour generator.

The \code{nFrameCount} parameter determines how many frames to send.
If it is zero, then frames are sent continuously. For any other value,
it counts down until it has sent that many frames, and then stops,
sending out an EOS. The \code{xFrameRate} setting is used to determine
the timestamp for each frame produced, or can be set to zero if
timestamps should all remain at zero.
*/

/* OMX_IndexParamSourceSeed: Source Random Seed */
typedef struct OMX_PARAM_SOURCESEEDTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_U16 nData[16];
} OMX_PARAM_SOURCESEEDTYPE;
/*
This structure sets the current state of the random number generator
used for \code{OMX_SOURCE_RANDOM} source type, allowing repeatable
random image creation.
*/

/* OMX_IndexParamResize: Resize Control */
typedef enum OMX_RESIZEMODETYPE {
   OMX_RESIZE_NONE,
   OMX_RESIZE_CROP,
   OMX_RESIZE_BOX,
   OMX_RESIZE_BYTES,
   OMX_RESIZE_DUMMY = 0x7FFFFFFF
} OMX_RESIZEMODETYPE;

typedef struct OMX_PARAM_RESIZETYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_RESIZEMODETYPE eMode;
   OMX_U32 nMaxWidth;
   OMX_U32 nMaxHeight;
   OMX_U32 nMaxBytes;
   OMX_BOOL bPreserveAspectRatio;
   OMX_BOOL bAllowUpscaling;
} OMX_PARAM_RESIZETYPE;
/*
The mode determines the kind of resize. \code{OMX_RESIZE_BOX} allow
the \code{nMaxWidth} and \code{nMaxHeight} to set a bounding box into
which the output must fit. \code{OMX_RESIZE_BYTES} allows
\code{nMaxBytes} to set the maximum number of bytes into which the
full output frame must fit.  Two flags aid the setting of the output
size. \code{bPreseveAspectRatio} sets whether the resize should
preserve the aspect ratio of the incoming
image. \code{bAllowUpscaling} sets whether the resize is allowed to
increase the size of the output image compared to the size of the
input image.
*/

typedef struct OMX_PARAM_TESTINTERFACETYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_BOOL bTest;
   OMX_BOOL bSetExtra;
   OMX_U32 nExtra;
   OMX_BOOL bSetError;
   OMX_BOOL stateError[2];
} OMX_PARAM_TESTINTERFACETYPE;

/* OMX_IndexConfigVisualisation: Visualisation Mode */
typedef struct OMX_CONFIG_VISUALISATIONTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_U8 name[16];
   OMX_U8 property[64];
} OMX_CONFIG_VISUALISATIONTYPE;

/*
\code{name} is a string of characters specifying the type of
visualization. The component appends \code{"_vis.vll"} to the name
provided, and attempts to load a visualisation library contained in
this VLL.  \code{property} contains configuration parameters and
values, which is interpreted by the visualisation library. Typically
all visualisations will accept a property string containing
\code{'mode=<number>'}, where \code{<number>} may be a random 32 bit
integer in decimal format. If provided, this may select a random mode
from that visualisation library.
*/

/*
This parameter is used when creating proprietary communication with
the display component, and provides the display function for passing
images to be displayed, together with a function used to flush all
pending image updates and release all images.
*/

/* OMX_IndexConfigBrcmAudioDestination: Audio Destination */
typedef struct OMX_CONFIG_BRCMAUDIODESTINATIONTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U8 sName[16];
} OMX_CONFIG_BRCMAUDIODESTINATIONTYPE;
/*
This config sets the platform-specific audio destination or output
device for audio sink components (e.g. audio_render).

\code{sName} describes the audio destination, with \code{"local"}
typically being directly connected to headphones.
*/

/* OMX_IndexConfigBrcmAudioSource: Audio Source */
typedef struct OMX_CONFIG_BRCMAUDIOSOURCETYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U8 sName[16];
} OMX_CONFIG_BRCMAUDIOSOURCETYPE;
/*
This config sets the platform-specific audio source or input device
for audio source components (e.g. audio_capture).

\code{sName} describes the audio source, with \code{"local"}
typically being directly connected to microphone.
*/

/* OMX_IndexConfigBrcmAudioDownmixCoefficients: Audio Downmix Coefficients */
typedef struct OMX_CONFIG_BRCMAUDIODOWNMIXCOEFFICIENTS {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_U32 coeff[16];
} OMX_CONFIG_BRCMAUDIODOWNMIXCOEFFICIENTS;
/*
This config sets the platform-specific audio downmixing coefficients for the 
audio mixer component. The coefficients are 16.16 fixed point.
The even coefficients contribute to the left channel. 
The odd coefficients contribute to the right channel. 
L' = coeff[0] * sample[N] + coeff[2] * sample[N+1] + coeff[4] * sample[N+2] + coeff[6] * sample[N+3] 
   + coeff[8] * sample[N+4] + coeff[10] * sample[N+5] + coeff[12] * sample[N+6] + coeff[14] * sample[N+7]
R' = coeff[1] * sample[N] + coeff[3] * sample[N+1] + coeff[5] * sample[N+2] + coeff[7] * sample[N+3] 
   + coeff[9] * sample[N+4] + coeff[11] * sample[N+5] + coeff[13] * sample[N+6] + coeff[15] * sample[N+7]

\code{coeff} describes the downmixing coefficients
*/

/* OMX_IndexConfigBrcmAudioDownmixCoefficients8x8: Audio Downmix Coefficient matrix */
typedef struct OMX_CONFIG_BRCMAUDIODOWNMIXCOEFFICIENTS8x8 {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_U32 coeff[64];
} OMX_CONFIG_BRCMAUDIODOWNMIXCOEFFICIENTS8x8;
/*
This config sets the platform-specific audio downmixing coefficients for the 
audio mixer component. The coefficients are 16.16 fixed point.
The coefficients are a 8*8 mixing matrix from 8 input channels to 8 outputs channels

\code{coeff} describes the downmixing coefficients
*/

/* OMX_IndexConfigBrcmAudioMaxSample: Maximum sample seen */
typedef struct OMX_CONFIG_BRCMAUDIOMAXSAMPLE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_U32 nMaxSample;
   OMX_TICKS nTimeStamp;
} OMX_CONFIG_BRCMAUDIOMAXSAMPLE;
/*
This gets the largest sample produced (after downmixing with OMX_CONFIG_BRCMAUDIODOWNMIXCOEFFICIENTS8x8) 
since this config was last read. The nTimestamp is the earliest timestamp processed. 
This can be used for DRC schemes 

\code{coeff} maximum sample seen in current block
*/

/* OMX_IndexConfigPlayMode: Play Mode */
typedef enum OMX_PLAYMODETYPE {
   OMX_PLAYMODE_NORMAL,
   OMX_PLAYMODE_FF,
   OMX_PLAYMODE_REW,
   OMX_PLAYMODE_DUMMY = 0x7FFFFFFF
} OMX_PLAYMODETYPE;

typedef struct OMX_CONFIG_PLAYMODETYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_PLAYMODETYPE eMode;
} OMX_CONFIG_PLAYMODETYPE;
/*
The playmode affects which frames are extracted from the media file
and passed on the output ports. \code{OMX_PLAYMODE_NORMAL} will
extract all frames, \code{OMX_PLAYMODE_FF} extracts only IDR frames
when video is present, or only occasional packets of audio if no video
is present. \code{OMX_PLAYMODE_REW} is similar to
\code{OMX_PLAYMODE_FF} but extracts packets in reverse time
order.
*/

typedef enum OMX_DELIVERYFORMATTYPE {
   OMX_DELIVERYFORMAT_STREAM,         // no framing information is known
   OMX_DELIVERYFORMAT_SINGLE_PACKET,  // packetised, at most one frame per buffer
   OMX_DELIVERYFORMAT_DUMMY = 0x7FFFFFFF
} OMX_DELIVERYFORMATTYPE;

typedef struct OMX_PARAM_DELIVERYFORMATTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_DELIVERYFORMATTYPE eFormat;
} OMX_PARAM_DELIVERYFORMATTYPE;

/* OMX_IndexParamCodecConfig: Codec Configuration */

typedef struct OMX_PARAM_CODECCONFIGTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_U32 bCodecConfigIsComplete;
   OMX_U8 nData[1];
} OMX_PARAM_CODECCONFIGTYPE;

/*
This parameter contains opaque data in a format specified by Broadcom
and allows out-of-band information such as cropping rectangles, aspect
ratio information, codec-specific header bytes, and other essential
information to be passed between connected components.

\code{bCodecConfigIsCompete} specifies if the codec config is fully
contained in here and there is no need to wait for OMX_BUFFERFLAG_CODECCONFIG
buffers
*/

typedef struct OMX_PARAM_STILLSFUNCTIONTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_BOOL bBuffer;
   OMX_PTR (*pOpenFunc)(void);
   OMX_PTR (*pCloseFunc)(void);
   OMX_PTR (*pReadFunc)(void);
   OMX_PTR (*pSeekFunc)(void);
   OMX_PTR (*pWriteFunc)(void);
} OMX_PARAM_STILLSFUNCTIONTYPE;

typedef void* OMX_BUFFERADDRESSHANDLETYPE;

typedef struct OMX_PARAM_BUFFERADDRESSTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_U32 nAllocLen;
   OMX_BUFFERADDRESSHANDLETYPE handle;
} OMX_PARAM_BUFFERADDRESSTYPE;

typedef struct OMX_PARAM_TUNNELSETUPTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_TUNNELSETUPTYPE sSetup;
} OMX_PARAM_TUNNELSETUPTYPE;

/* OMX_IndexParamBrcmPortEGL: Used for querying whether a port is an EGL port or not. */
typedef struct OMX_PARAM_BRCMPORTEGLTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_BOOL bPortIsEGL;
} OMX_PARAM_BRCMPORTEGLTYPE;
/*
*/

#define OMX_CONFIG_IMAGEFILTERPARAMS_MAXPARAMS 6
/* OMX_IndexConfigCommonImageFilterParameters: Parameterized Image Filter */
typedef struct OMX_CONFIG_IMAGEFILTERPARAMSTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_IMAGEFILTERTYPE eImageFilter;
   OMX_U32 nNumParams;
   OMX_U32 nParams[OMX_CONFIG_IMAGEFILTERPARAMS_MAXPARAMS];
} OMX_CONFIG_IMAGEFILTERPARAMSTYPE;
/*
This structure contains optional parameters for some image
filters. The following table lists all image filters that support
parameters.

<table border="1" cellspacing="0" cellpadding="2">
<tr><td>Filter<td>Parameters<td>Notes

<tr><td>\code{OMX_ImageFilterSolarize}
<td>\code{[x0 y0 y1 y2]}
<td>Linear mapping of \code{[0,x0]} to \code{[0,y0>]}
and \code{[x0,255]} to \code{[y1,y2]}.
Default is \code{"128 128 128 0"}.

<tr><td>\code{OMX_ImageFilterSharpen}
<td>\code{[sz [str [th]]}
<td>\code{sz} size of filter, either 1 or 2.
\code{str} strength of filter.
\code{th} threshold of filter.
Default is \code{"1 40 20"}.

<tr><td>\code{OMX_ImageFilterFilm}
<td>\code{[[str] [u v]]}
<td>\code{str} strength of effect.
\code{u} sets u to constant value.
\code{v} sets v to constant value.
Default is \code{"24"}.

<tr><td>\code{OMX_ImageFilterBlur}
<td>\code{[sz]}
<td>\code{sz} size of filter, either 1 or 2.
Default is \code{"2"}.

<tr><td>\code{OMX_ImageFilterSaturation}
<td>\code{[str]}
<td>\code{str} strength of effect, in 8.8 fixed point format. u/v value
differences from 128 are multiplied by \code{str}.
Default is \code{"272"}.
</table>
*/


/* OMX_IndexConfigTransitionControl: Transition Control */
typedef struct OMX_CONFIG_TRANSITIONCONTROLTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_U32 nPosStart;
   OMX_U32 nPosEnd;
   OMX_S32 nPosIncrement;
   OMX_TICKS nFrameIncrement;
   OMX_BOOL bSwapInputs;
   OMX_U8 name[16];
   OMX_U8 property[64];
} OMX_CONFIG_TRANSITIONCONTROLTYPE;
/*
This structure represents the internal configuration of the
transition. Transitions are generated by a loadable plug-in described
by the \code{name} field. The component appends \code{"_tran.vll"} to
the name provided, and attempts to load a transition library contained
in this VLL.  The exact type of transition is configured in a
plug-in-dependent manner with the \code{property} field. All plug-ins
should accept a \code{property} field equal to
\code{"flags=<number>"}, where \code{<number>} can be a random 32 bit
number.  If \code{bSwapInputs} is false, then the start image is on
port 210, the stop image on port 211. These are reversed if
\code{bSwapInputs} is true.

Transition frames are generated from the plug-in by referencing a
frame position in [0,65536], where position 0 is the start image,
position 65536 is the stop image. The first frame position generated
is \code{nPosStart}. The last frame position generated is
\code{nPosEnd}. Each frame will increment the position by
\code{nPosIncrement}. The timestamp attached to each frame will
increment by \code{nFrameIncrement}.
*/


/*
This parameter is used to provide a callback function pointer for
release events. It is used for internal clients on VideoCore.
*/


/* OMX_IndexConfigAudioMonoTrackControl: Dual Mono Control */
typedef enum OMX_AUDIOMONOTRACKOPERATIONSTYPE {
   OMX_AUDIOMONOTRACKOPERATIONS_NOP,
   OMX_AUDIOMONOTRACKOPERATIONS_L_TO_R,
   OMX_AUDIOMONOTRACKOPERATIONS_R_TO_L,
   OMX_AUDIOMONOTRACKOPERATIONS_DUMMY = 0x7FFFFFFF
} OMX_AUDIOMONOTRACKOPERATIONSTYPE ;

typedef struct OMX_CONFIG_AUDIOMONOTRACKCONTROLTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_AUDIOMONOTRACKOPERATIONSTYPE eMode;
} OMX_CONFIG_AUDIOMONOTRACKCONTROLTYPE;
/*
This config controls the options to support dual mono audio
streams. The output can be unchanged, or the left channel copied over
the right channel, or the right channel copied over the left
channel. This config can be applied at any time with stereo
16-bit-per-sample data. Since audio output is typically buffered, any
change will not be audible until that buffering has been played out.
*/

/* OMX_IndexParamCameraImagePool: Camera Image Pools */
typedef enum OMX_CAMERAIMAGEPOOLINPUTMODETYPE {
   OMX_CAMERAIMAGEPOOLINPUTMODE_ONEPOOL,     /*All input images are allocated from one pool
                                               Works for simple stills capture use cases
                                               Can not be used with parallel stills capture
                                               and video encode, as the pool will be sized for
                                               capture or viewfinder, not both simultaneously.
                                               The pool wouldn't divide sensibly in this mode
                                               anyway.
                                             */
   OMX_CAMERAIMAGEPOOLINPUTMODE_TWOPOOLS,    /*All stills & video input images are allocated
                                               from two separate pools.
                                               This ensures that parallel capture can work, but
                                               would consume more memory if used on a simple
                                               stills capture use case.
                                             */
} OMX_CAMERAIMAGEPOOLINPUTMODETYPE;

typedef struct OMX_PARAM_CAMERAIMAGEPOOLTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nNumHiResVideoFrames;
   OMX_U32 nHiResVideoWidth;
   OMX_U32 nHiResVideoHeight;
   OMX_COLOR_FORMATTYPE eHiResVideoType;
   OMX_U32 nNumHiResStillsFrames;
   OMX_U32 nHiResStillsWidth;
   OMX_U32 nHiResStillsHeight;
   OMX_COLOR_FORMATTYPE eHiResStillsType;
   OMX_U32 nNumLoResFrames;
   OMX_U32 nLoResWidth;
   OMX_U32 nLoResHeight;
   OMX_COLOR_FORMATTYPE eLoResType;
   OMX_U32 nNumSnapshotFrames;
   OMX_COLOR_FORMATTYPE eSnapshotType;
   OMX_CAMERAIMAGEPOOLINPUTMODETYPE eInputPoolMode;
   OMX_U32 nNumInputVideoFrames;
   OMX_U32 nInputVideoWidth;
   OMX_U32 nInputVideoHeight;
   OMX_COLOR_FORMATTYPE eInputVideoType;
   OMX_U32 nNumInputStillsFrames;
   OMX_U32 nInputStillsWidth;
   OMX_U32 nInputStillsHeight;
   OMX_COLOR_FORMATTYPE eInputStillsType;
} OMX_PARAM_CAMERAIMAGEPOOLTYPE;
/*
\sloppy This parameter specifies the size, type, and number, of images to
allow in the images pools required by Camplus. Supported types are
\code{OMX_COLOR_FormatYUV420PackedPlanar},
\code{OMX_COLOR_FormatYUV422PackedPlanar},
\code{OMX_COLOR_FormatRawBayer8bit},
\code{OMX_COLOR_FormatRawBayer10bit},
\code{OMX_COLOR_FormatRawBayer8bitcompressed}, and 0 (reserved for the
Broadcom-specific format required by the video encoder). The input
pool width, height, and type can be set as 0 to make the component
query Camplus for the sensor mode that would correspond to the largest
of the viewfinder port definition, the capture port definition, or the
high resolution image pool.
*/

/* OMX_IndexParamImagePoolSize: Specifying Image Pool Properties */
typedef struct OMX_PARAM_IMAGEPOOLSIZETYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 width;
   OMX_U32 height;
   OMX_U32 num_pages;
} OMX_PARAM_IMAGEPOOLSIZETYPE;
/*
This parameter is used to control the size of pool that the component
will allocate in the absence of setting an external pool.  The default
can be reset by setting this parameter with all three fields set to
zero.
*/


/* OMX_IndexParamImagePoolExternal: Client Allocated Image Pools */
struct opaque_vc_pool_s;
typedef struct opaque_vc_pool_s OMX_BRCM_POOL_T;

typedef struct OMX_PARAM_IMAGEPOOLEXTERNALTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_BRCM_POOL_T *image_pool;
   OMX_BRCM_POOL_T *image_pool2;
   OMX_BRCM_POOL_T *image_pool3;
   OMX_BRCM_POOL_T *image_pool4;
   OMX_BRCM_POOL_T *image_pool5;
} OMX_PARAM_IMAGEPOOLEXTERNALTYPE;
/*
This config allows the client to pass in handles to pre-allocated
image pools for use within the component.
*/


struct _IL_FIFO_T;
typedef struct OMX_PARAM_RUTILFIFOINFOTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   struct _IL_FIFO_T *pILFifo;
} OMX_PARAM_RUTILFIFOINFOTYPE;

/* OMX_IndexParamILFifoConfig: Allows configuration of the FIFO settings. */
typedef struct OMX_PARAM_ILFIFOCONFIG {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_U32 nDataSize;         /**< The size of the FIFO's data area */
   OMX_U32 nHeaderCount;      /**< The number of headers allocated */
} OMX_PARAM_ILFIFOCONFIG;
/**
 * Allows configuring the size of the ILFIFO used in a component.
 */

/* OMX_IndexConfigCameraSensorModes: Camera Sensor Mode */
typedef struct OMX_CONFIG_CAMERASENSORMODETYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_U32 nModeIndex;
   OMX_U32 nNumModes;
   OMX_U32 nWidth;
   OMX_U32 nHeight;
   OMX_U32 nPaddingRight;
   OMX_U32 nPaddingDown;
   OMX_COLOR_FORMATTYPE eColorFormat;
   OMX_U32 nFrameRateMax;
   OMX_U32 nFrameRateMin;
} OMX_CONFIG_CAMERASENSORMODETYPE;
/*
This parameter is used by clients to determine the sensor mode, and
hence the memory usage, of the camera module. This is primarily used
for determining the size of the input image pool.

It can be used in two ways dependent on \code{nPortIndex}. If
\code{nPortIndex} is \code{OMX_ALL}, it returns the sensor mode
corresponding to \code{nModeIndex}, and the number of modes in
\code{nNumModes}. If \code{nModeIndex} is greater than or equal to
\code{nNumModes} only \code{nNumModes} is returned. If
\code{nPortIndex} is equal to a camera video output port index, it
returns the sensor mode that would be selected for the values
currently in \code{OMX_IndexParamPortDefinition} for that port.

The \code{nPaddingRight} and \code{nPaddingDown} values determine the
extra padding the sensor adds to the image. These values must be added
to \code{nWidth} and \code{nHeight} respectively if the client is
specifying the input image pool size.
*/

typedef struct OMX_BRCMBUFFERSTATSTYPE {
   OMX_U32 nOrdinal;
   OMX_TICKS nTimeStamp;
   OMX_U32 nFilledLen;
   OMX_U32 nFlags;
   union
   {
      OMX_U32 nU32;
      struct
      {
         OMX_U32 nYpart;
         OMX_U32 nUVpart;
      } image;
   } crc;
} OMX_BRCMBUFFERSTATSTYPE;

/*
Ports that gather statistics for debugging and diagnostics
might also collect information about buffer header fields
and data.

Note that:

The \code{nOrdinal} field increases monotonically whenever
a new buffer is received or emitted and shall not be reset
upon a port flush.

The \code{nFilledLen} might indicate the size of a data area
larger than the data area that actually contributed to the
checksums (e.g. when image data is provided with cropping
information).
*/

/* OMX_IndexConfigBrcmPortBufferStats: Query port buffer stats history */
typedef struct OMX_CONFIG_BRCMPORTBUFFERSTATSTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_U32 nCount;
   OMX_BRCMBUFFERSTATSTYPE sData[1];
} OMX_CONFIG_BRCMPORTBUFFERSTATSTYPE;
/*
Ports that gather statistics for debugging and diagnostics
might also collect information about buffer header fields
and data.

The \code{sStatsData} field is a variable length array and
the number of items is denoted by \code{nStatsCount}.
*/

/* OMX_IndexConfigBrcmPortStats: Query port statistics */
typedef struct OMX_CONFIG_BRCMPORTSTATSTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_U32 nImageCount;
   OMX_U32 nBufferCount;
   OMX_U32 nFrameCount;
   OMX_U32 nFrameSkips;
   OMX_U32 nDiscards;
   OMX_U32 nEOS;
   OMX_U32 nMaxFrameSize;

   OMX_TICKS nByteCount;
   OMX_TICKS nMaxTimeDelta;
   OMX_U32 nCorruptMBs;   /**< Number of corrupt macroblocks in the stream */
} OMX_CONFIG_BRCMPORTSTATSTYPE;
/*
Some ports gather various statistics that can be used by clients for
debugging purposes.  This structure is the set of all statistics that
are gathered.

The \code{nFrameSkips} field indicates the number of frames that did
not have an expected PTS value based on the port frame rate.

The \code{nByteCount} field is a 64 bit value, that will either use a
64 bit type or two 32 bit types, similarly to \code{OMX_TICKS}.
*/

/* OMX_IndexConfigBrcmClockMissCount: Missed clock request accounting */
/*
For each port on the clock component, requests for media times may be
made.  These are typically done one per video frame to allow for
scheduling the display of that frame at the correct time.  If a
request is made after the time has occurred, then that frame will be
displayed late, and the clock component keeps a per-port record of the
number of times this occurs.  This record can be read using this
index.
*/

typedef struct OMX_CONFIG_BRCMCAMERASTATSTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nOutFrameCount;
   OMX_U32 nDroppedFrameCount;
} OMX_CONFIG_BRCMCAMERASTATSTYPE;

// for backward compatibility
typedef struct OMX_CONFIG_BRCMCAMERASTATSTYPE OMX_CONFIG_BRCMCAMERASTATS;


#define OMX_BRCM_MAXIOPERFBANDS 10
typedef struct {
   OMX_U32 count[OMX_BRCM_MAXIOPERFBANDS];
   OMX_U32 num[OMX_BRCM_MAXIOPERFBANDS];
} OMX_BRCM_PERFSTATS;

/* OMX_IndexConfigBrcmIOPerfStats: Query I/O performance statistics */
typedef struct OMX_CONFIG_BRCMIOPERFSTATSTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_BOOL bEnabled;                              /**< Enable/disable I/O performance statistics */
   OMX_BRCM_PERFSTATS write; /**< count:bytes     num:microseconds */
   OMX_BRCM_PERFSTATS flush; /**< count:frequency num:microseconds waiting to flush data */
   OMX_BRCM_PERFSTATS wait;  /**< count:frequency num:microseconds waiting in calling function */
} OMX_CONFIG_BRCMIOPERFSTATSTYPE;
/*
A sink component can gather various statistics about I/O (eg. file media) performance that can be used by
clients for debugging purposes.  The \code{bEnabled} field is used to turn the gathering of statistics
on/off.
*/

typedef struct OMX_CONFIG_SHARPNESSTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_S32 nSharpness;
} OMX_CONFIG_SHARPNESSTYPE;

/* OMX_IndexConfigCommonFlickerCancellation: Flicker cancellation */
typedef enum OMX_COMMONFLICKERCANCELTYPE {
   OMX_COMMONFLICKERCANCEL_OFF,
   OMX_COMMONFLICKERCANCEL_AUTO,
   OMX_COMMONFLICKERCANCEL_50,
   OMX_COMMONFLICKERCANCEL_60,
   OMX_COMMONFLICKERCANCEL_DUMMY = 0x7FFFFFFF
} OMX_COMMONFLICKERCANCELTYPE;

typedef struct OMX_CONFIG_FLICKERCANCELTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_COMMONFLICKERCANCELTYPE eFlickerCancel;
} OMX_CONFIG_FLICKERCANCELTYPE;
/*
Query / set the flicker cancellation frequency. Values are defined for Off,
50Hz, 60Hz, or auto. The method for auto detecting the flicker frequency is
not defined, and currently results in the feature being turned off.
*/

/* OMX_IndexConfigCommonRedEyeRemoval: Red eye removal/reduction */
typedef enum OMX_REDEYEREMOVALTYPE {
   OMX_RedEyeRemovalNone,                           /**< No red eye removal */
   OMX_RedEyeRemovalOn,                             /**< Red eye removal on */
   OMX_RedEyeRemovalAuto,                           /**< Red eye removal will be done automatically when detected */
   OMX_RedEyeRemovalKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
   OMX_RedEyeRemovalVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
   OMX_RedEyeRemovalSimple,                         /**< Use simple red eye reduction mechanism if supported by algorithm */
   OMX_RedEyeRemovalMax = 0x7FFFFFFF
} OMX_REDEYEREMOVALTYPE;

typedef struct OMX_CONFIG_REDEYEREMOVALTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_REDEYEREMOVALTYPE eMode;
} OMX_CONFIG_REDEYEREMOVALTYPE;
/*
   Configures the red eye reduction algorithm in the camera processing
   pipeline. The stage is only enabled if the flash mode is not FlashOff.
   The OMX_RedEyeRemovalSimple mode requests that the algorithm uses a
   reduced complexity algorithm to reduce the processing time.
*/


typedef enum OMX_FACEDETECTIONCONTROLTYPE {
   OMX_FaceDetectionControlNone,                           /**< Disables face detection */
   OMX_FaceDetectionControlOn,                             /**< Enables face detection */
   OMX_FaceDetectionControlKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
   OMX_FaceDetectionControlVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
   OMX_FaceDetectionControlMax = 0x7FFFFFFF
} OMX_FACEDETECTIONCONTROLTYPE;

typedef struct OMX_CONFIG_FACEDETECTIONCONTROLTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_FACEDETECTIONCONTROLTYPE eMode;
   OMX_U32 nFrames;      /**< number of frames to apply this setting for,
                              0 for unlimited */
   OMX_U32 nMaxRegions;  /**< maximum number of regions to detect, 0 for unlimited */
   OMX_U32 nQuality;     /**< hint for algorithmic complexity, range is 0-100.
                              0 for simplest algorithm, 100 for best quality */
} OMX_CONFIG_FACEDETECTIONCONTROLTYPE;

typedef enum OMX_FACEREGIONFLAGSTYPE {
   OMX_FaceRegionFlagsNone    = 0,
   OMX_FaceRegionFlagsBlink   = 1,
   OMX_FaceRegionFlagsSmile   = 2,
   OMX_FaceRegionFlagsKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
   OMX_FaceRegionFlagsVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
   OMX_FaceRegionFlagsMax = 0x7FFFFFFF
} OMX_FACEREGIONFLAGSTYPE;

typedef struct OMX_FACEREGIONTYPE {
   OMX_S16 nLeft;              /**< X Coordinate of the top left corner of the rectangle */
   OMX_S16 nTop;               /**< Y Coordinate of the top left corner of the rectangle */
   OMX_U16 nWidth;             /**< Width of the rectangle */
   OMX_U16 nHeight;            /**< Height of the rectangle */
   OMX_FACEREGIONFLAGSTYPE nFlags;  /**< Flags for the region */
#ifndef OMX_SKIP64BIT
   OMX_U64 nFaceRecognitionId; /**< ID returned by face recognition for this face */
#else
   struct
   {
      OMX_U32 nLowPart;   /**< low bits of the signed 64 bit value */
      OMX_U32 nHighPart;  /**< high bits of the signed 64 bit value */
   } nFaceRecognitionId;
#endif
} OMX_FACEREGIONTYPE;

typedef struct OMX_CONFIG_FACEDETECTIONREGIONTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;            /**< index of port with face detection enabled */
   OMX_U32 nIndex;                /**< first requested region number, allowing retrieval of many regions
                                       over several requests */
   OMX_U32 nDetectedRegions;      /**< total number of detected regions */
   OMX_S32 nValidRegions;         /**< number of valid regions in sRegion array
                                       When getting, the client sets this to the number of regions available.
                                       The component writes region data and updates this field with how many
                                       regions have been written to. */
   OMX_U32 nImageWidth;           /**< Width of the image, hence reference for the face coordinates */
   OMX_U32 nImageHeight;          /**< Height of the image, hence reference for the face coordinates */
   OMX_FACEREGIONTYPE sRegion[1]; /**< variable length array of face regions */
} OMX_CONFIG_FACEDETECTIONREGIONTYPE;

typedef enum OMX_INTERLACETYPE {
   OMX_InterlaceProgressive,                    /**< The data is not interlaced, it is progressive scan */
   OMX_InterlaceFieldSingleUpperFirst,          /**< The data is interlaced, fields sent
                                                     separately in temporal order, with upper field first */
   OMX_InterlaceFieldSingleLowerFirst,          /**< The data is interlaced, fields sent
                                                     separately in temporal order, with lower field first */
   OMX_InterlaceFieldsInterleavedUpperFirst,    /**< The data is interlaced, two fields sent together line
                                                     interleaved, with the upper field temporally earlier */
   OMX_InterlaceFieldsInterleavedLowerFirst,    /**< The data is interlaced, two fields sent together line
                                                     interleaved, with the lower field temporally earlier */
   OMX_InterlaceMixed,                          /**< The stream may contain a mixture of progressive
                                                     and interlaced frames */
   OMX_InterlaceKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
   OMX_InterlaceVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
   OMX_InterlaceMax = 0x7FFFFFFF
} OMX_INTERLACETYPE;

typedef struct OMX_CONFIG_INTERLACETYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;            /**< index of port emitting or accepting the content */
   OMX_INTERLACETYPE eMode;       /**< The interlace type of the content */
   OMX_BOOL bRepeatFirstField;    /**< Whether to repeat the first field */
} OMX_CONFIG_INTERLACETYPE;

/* OMX_IndexParamIspTuner: Custom ISP tuner */
typedef struct OMX_PARAM_CAMERAISPTUNERTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U8 tuner_name[64];
} OMX_PARAM_CAMERAISPTUNERTYPE;
/*
This parameter allows a custom ISP tuner to be loaded instead of
the default one specified for the camera module. Setting an empty
string uses the default value.
*/

/* OMX_IndexConfigCameraInputFrame: Pointer to the raw input image */
typedef struct OMX_CONFIG_IMAGEPTRTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_PTR pImage;
} OMX_CONFIG_IMAGEPTRTYPE;
/*
This parameter parameter allows the return of a pointer to a
VideoCore image resource.
*/

/* OMX_IndexConfigAFAssistLight: Autofocus assist light mode selection */
typedef enum OMX_AFASSISTTYPE {
   OMX_AFAssistAuto,
   OMX_AFAssistOn,
   OMX_AFAssistOff,
   OMX_AFAssistTorch,
   OMX_AFAssistKhronosExtensions = 0x6F000000,
   OMX_AFAssistVendorStartUnused = 0x7F000000,
   OMX_AFAssistMax = 0x7FFFFFFF
} OMX_AFASSISTTYPE;

typedef struct OMX_CONFIG_AFASSISTTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_AFASSISTTYPE eMode;
} OMX_CONFIG_AFASSISTTYPE;
/*
Set the mode to adopt for the autofocus assist light.
\code{OMX_AFAssistTorch} will turn the AF assist light on permanently, allowing
it to be used as a torch.
*/

/* OMX_IndexConfigInputCropPercentage: Specify input crop as a percentage */
typedef struct OMX_CONFIG_INPUTCROPTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_U32 xLeft;     /**< Fraction of the width for the top left corner of the rectangle */
   OMX_U32 xTop;      /**< Fraction of the height for the top left corner of the rectangle */
   OMX_U32 xWidth;    /**< Fraction of the image width desired */
   OMX_U32 xHeight;   /**< Fraction of the image height desired */
} OMX_CONFIG_INPUTCROPTYPE;
/*
This parameter allows the input cropping to be specified as a
percentage of the current width/height.  Required for the camera
component where the output resolution varies dependent on the port.
All percentage values are as 16p16 fixed point numbers (0x10000 =
100\%)
*/

/* OMX_IndexParamCodecRequirements: Advanced codec requirements */
typedef struct OMX_PARAM_CODECREQUIREMENTSTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nCallbackID;
   OMX_BOOL bTryHWCodec;
} OMX_PARAM_CODECREQUIREMENTSTYPE;
/*
This parameter allows internal users of RIL components controlling
video codecs to request that the component loads the component and
queries for requirements.  The component will perform a callback with
the given nCallbackID value passing a pointer to the requirements
structure as the data field.
*/

/* OMX_IndexConfigBrcmEGLImageMemHandle: Mapping from an EGLImage to a VideoCore mem handle */
typedef struct OMX_CONFIG_BRCMEGLIMAGEMEMHANDLETYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_PTR eglImage;
   OMX_PTR memHandle;
} OMX_CONFIG_BRCMEGLIMAGEMEMHANDLETYPE;
/*
This config allows the EGL server to notify a RIL component that an
EGLImage is available for rendering into and to provide a mapping from
an EGLImage to a mem handle.
*/

/* OMX_IndexConfigPrivacyIndicator: Privacy indicator control */
typedef enum OMX_PRIVACYINDICATORTYPE {
   OMX_PrivacyIndicatorOff,
   OMX_PrivacyIndicatorOn,
   OMX_PrivacyIndicatorForceOn,
   OMX_PrivacyIndicatorKhronosExtensions = 0x6F000000,
   OMX_PrivacyIndicatorVendorStartUnused = 0x7F000000,
   OMX_PrivacyIndicatorMax = 0x7FFFFFFF
} OMX_PRIVACYINDICATORTYPE;

typedef struct OMX_CONFIG_PRIVACYINDICATORTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_PRIVACYINDICATORTYPE ePrivacyIndicatorMode;
} OMX_CONFIG_PRIVACYINDICATORTYPE;
/*
This config allows control over the privacy indicator light.  This
light indicates when a capture is in progress.

\code{OMX_PrivacyIndicatorOff} indicator is disabled.

\code{OMX_PrivacyIndicatorOn} indicator will be
turned on whenever an image is being captured as determined by the
capturing bit. Minimum on duration of approx 200ms.

\code{OMX_PrivacyIndicatorForceOn} results in turning the indicator on
immediately, whether an image is being captured or not. The mode will
automatically revert to \code{OMX_PrivacyIndicatorOff} once the
indicator has been turned on, so \code{OMX_PrivacyIndicatorForceOn}
must be requested at least every 200ms if the indicator is to remain
on.
*/


/* OMX_IndexParamCameraFlashType: Select flash type */
typedef enum OMX_CAMERAFLASHTYPE {
   OMX_CameraFlashDefault,
   OMX_CameraFlashXenon,
   OMX_CameraFlashLED,
   OMX_CameraFlashNone,
   OMX_CameraFlashKhronosExtensions = 0x6F000000,
   OMX_CameraFlashVendorStartUnused = 0x7F000000,
   OMX_CameraFlashMax = 0x7FFFFFFF
} OMX_CAMERAFLASHTYPE;

typedef struct OMX_PARAM_CAMERAFLASHTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_CAMERAFLASHTYPE eFlashType;
   OMX_BOOL bRedEyeUsesTorchMode;
} OMX_PARAM_CAMERAFLASHTYPE;
/*
This parameter allows the selection of xenon or LED flash devices
to be used with the currently selected camera. If that device is not
available, then the component will revert back to whatever flash
device is available for that camera.
\code{bRedEyeUsesTorchMode} allows the blinking for red eye reduction to
be switched between using the indicator mode, and the torch mode for the
flash driver.
*/

/* OMX_IndexConfigCameraFlashConfig: Flash cycle configuration */
typedef enum OMX_CAMERAFLASHCONFIGSYNCTYPE {
   OMX_CameraFlashConfigSyncFrontSlow,
   OMX_CameraFlashConfigSyncRearSlow,
   OMX_CameraFlashConfigSyncFrontFast,
   OMX_CameraFlashConfigSyncKhronosExtensions = 0x6F000000,
   OMX_CameraFlashConfigSyncVendorStartUnused = 0x7F000000,
   OMX_CameraFlashConfigSyncMax = 0x7FFFFFFF
} OMX_CAMERAFLASHCONFIGSYNCTYPE;

typedef struct OMX_CONFIG_CAMERAFLASHCONFIGTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_BOOL bUsePreFlash;
   OMX_BOOL bUseFocusDistanceInfo;
   OMX_CAMERAFLASHCONFIGSYNCTYPE eFlashSync;
   OMX_BOOL bIgnoreChargeState;
} OMX_CONFIG_CAMERAFLASHCONFIGTYPE;
/*
This parameter allows the configuration of various parameters relating to
the flash cycle. Some of the options are only applicable to xenon flash.

\code{bUsePreFlash} uses a low intensity pre-flash to determine flash intensity. This setting
is recommended for almost all flash situations.

\code{bUseFocusDistanceInfo} uses the distance of the subject, as measured by the AF algorithm
to set the intensity of the flash.

\code{eFlashSync} configures which edge of the shutter is used to synchronise the flash, and
the duration of the exposure.

\code{eIgnoreChargeState} will make the flash fire, even if it is not fully charged.
*/

/* OMX_IndexConfigBrcmAudioTrackGaplessPlayback: Encoder/decoder delay and padding information for gapless playback. */
typedef struct OMX_CONFIG_BRCMAUDIOTRACKGAPLESSPLAYBACKTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_U32 nDelay;   /**< number of samples delay added by the codec */
   OMX_U32 nPadding; /**< number of silent samples added to the end */
} OMX_CONFIG_BRCMAUDIOTRACKGAPLESSPLAYBACKTYPE;
/*
This config allows communication between components to facilitate gapless playback.
*/


/* OMX_IndexConfigBrcmAudioTrackChangeControl: Configure gapless/crossfaded audio track change. */
typedef struct OMX_CONFIG_BRCMAUDIOTRACKCHANGECONTROLTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nSrcPortIndex;
   OMX_U32 nDstPortIndex;
   OMX_U32 nXFade;
} OMX_CONFIG_BRCMAUDIOTRACKCHANGECONTROLTYPE;
/*
This config allows the client to specify the gapless or crossfade
parameters to be used on a track change.  If \code{nXFade} is 0, then
a normal or gapless track change will result, otherwise a crossfade of
\code{nXFade} ms is used.
*/

/* OMX_IndexParamBrcmPixelValueRange: Describing the pixel value range */
typedef enum OMX_BRCMPIXELVALUERANGETYPE
{
   OMX_PixelValueRangeUnspecified = 0,
   OMX_PixelValueRangeITU_R_BT601,
   OMX_PixelValueRangeFull8Bit,
   OMX_PixelValueRangeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
   OMX_PixelValueRangeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
   OMX_PixelValueRangeMax = 0x7FFFFFFF
} OMX_BRCMPIXELVALUERANGETYPE;

typedef struct OMX_PARAM_BRCMPIXELVALUERANGETYPE
{
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_BRCMPIXELVALUERANGETYPE ePixelValueRange;
} OMX_PARAM_BRCMPIXELVALUERANGETYPE;
/*
This structure allows a description of the range that pixel values may
have.  This is typically useful since some standards use the full 8
bit range, whereas others introduce pedastals which reduce the range
at the top and bottom end.
*/

/* OMX_IndexParamCameraDisableAlgorithm: Disabling camera processing stages. */
typedef enum OMX_CAMERADISABLEALGORITHMTYPE {
      OMX_CameraDisableAlgorithmFacetracking,
      OMX_CameraDisableAlgorithmRedEyeReduction,
      OMX_CameraDisableAlgorithmVideoStabilisation,
      OMX_CameraDisableAlgorithmWriteRaw,
      OMX_CameraDisableAlgorithmVideoDenoise,
      OMX_CameraDisableAlgorithmStillsDenoise,
      OMX_CameraDisableAlgorithmAntiShake,
      OMX_CameraDisableAlgorithmImageEffects,
      OMX_CameraDisableAlgorithmDarkSubtract,
      OMX_CameraDisableAlgorithmDynamicRangeExpansion,
      OMX_CameraDisableAlgorithmFaceRecognition,
      OMX_CameraDisableAlgorithmFaceBeautification,
      OMX_CameraDisableAlgorithmSceneDetection,
      OMX_CameraDisableAlgorithmHighDynamicRange,
   OMX_CameraDisableAlgorithmKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
   OMX_CameraDisableAlgorithmVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
   OMX_CameraDisableAlgorithmMax = 0x7FFFFFFF
} OMX_CAMERADISABLEALGORITHMTYPE;

typedef struct OMX_PARAM_CAMERADISABLEALGORITHMTYPE
{
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_CAMERADISABLEALGORITHMTYPE eAlgorithm;
   OMX_BOOL bDisabled;
} OMX_PARAM_CAMERADISABLEALGORITHMTYPE;
/*
Allows plugin algorithms to be disabled to save memory
within the camera component
*/

/* OMX_IndexConfigBrcmAudioEffectControl: Audio Effect Control */
typedef struct OMX_CONFIG_BRCMAUDIOEFFECTCONTROLTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_BOOL bEnable;
   OMX_U8 name[16];
   OMX_U8 property[256];
} OMX_CONFIG_BRCMAUDIOEFFECTCONTROLTYPE;
/*
This structure represents the internal configuration of an audio effect.
The audio effect is provided by a loadable plug-in described
in the \code{name} field and is configured in a plug-in-dependent
manner with the \code{property} field. The \code{bEnable} field is used to
turn the effect on/off.
*/

/* OMX_IndexConfigBrcmMinimumProcessingLatency: Processing Latency Bound */
typedef struct OMX_CONFIG_BRCMMINIMUMPROCESSINGLATENCY {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_TICKS nOffset;
} OMX_CONFIG_BRCMMINIMUMPROCESSINGLATENCY;
/*
Query/set the difference between the actual media time and when the
component receives request fulfillments for media time requests. This
can be used with e.g. splitter/mixer components to control when the
component stops waiting for input or output packets from active
streams and continues with processing (to maintain a constant
processing rate).
*/

/** Enable or disable Supplemental Enhancment Information (SEI) messages to be inserted in
  * the H.264 bitstream.
  */
typedef struct OMX_PARAM_BRCMVIDEOAVCSEIENABLETYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_BOOL bEnable;
} OMX_PARAM_BRCMVIDEOAVCSEIENABLETYPE;

/* OMX_IndexParamBrcmAllowMemChange: Allowing changing memory allocation on state transition */
typedef struct OMX_PARAM_BRCMALLOWMEMCHANGETYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_BOOL bEnable;
} OMX_PARAM_BRCMALLOWMEMCHANGETYPE;
/*
Let the component change the amount of memory it has allocated when
going from LOADED to IDLE. By default this is enabled, but if it is
disabled the component will fail to transition to IDLE if the
component requires more memory than has already been allocated.  This
might occur if (for example) the component was configured, taken to
IDLE, then taken back to LOADED, the profile increased and the
component taken back to IDLE.
*/

typedef enum OMX_CONFIG_CAMERAUSECASE {
   OMX_CameraUseCaseAuto,
   OMX_CameraUseCaseVideo,
   OMX_CameraUseCaseStills,
   OMX_CameraUseCaseKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
   OMX_CameraUseCaseVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
   OMX_CameraUseCaseMax = 0x7FFFFFFF
} OMX_CONFIG_CAMERAUSECASE;

typedef struct OMX_CONFIG_CAMERAUSECASETYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_CONFIG_CAMERAUSECASE eUseCase;
} OMX_CONFIG_CAMERAUSECASETYPE;

/* OMX_IndexParamBrcmDisableProprietaryTunnels: Disabling proprietary tunnelling */
typedef struct OMX_PARAM_BRCMDISABLEPROPRIETARYTUNNELSTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_BOOL bUseBuffers;
}  OMX_PARAM_BRCMDISABLEPROPRIETARYTUNNELSTYPE;
/*
Tell a source component to refuse to support proprietary tunnelling. Buffers will be used instead.
*/


//
// Control for memory allocation and component-internal buffering
//

/* OMX_IndexParamBrcmRetainMemory: Controlling memory use on state transition */
typedef struct OMX_PARAM_BRCMRETAINMEMORYTYPE
{
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_BOOL bEnable;
} OMX_PARAM_BRCMRETAINMEMORYTYPE;
/*
Ask a component to retain its memory when going from IDLE to LOADED, if possible.
This has the benefit that you are then guaranteed that the transition to IDLE cannot
fail due to lack of memory, but has the disadvantage that you cannot leave the component
lying around in LOADED, unused, since it is using significant amounts of memory.
*/

/** Tell write media how large the output buffer should be. This is a hint, and
  * may be ignored. A good size is bandwidth*<SDcard-delay>, which works out at
  * around 1Mbyte for up to 16Mbit/s. Sizes may (and probably will) be rounded down
  * to the nearest power of 2.
  */
typedef struct OMX_PARAM_BRCMOUTPUTBUFFERSIZETYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nBufferSize;
} OMX_PARAM_BRCMOUTPUTBUFFERSIZETYPE;

/* OMX_IndexConfigCameraInfo: Camera device driver information */
#define OMX_CONFIG_CAMERAINFOTYPE_NAME_LEN 16
typedef struct OMX_CONFIG_LENSCALIBRATIONVALUETYPE
{
   OMX_U16  nShutterDelayTime;
   OMX_U16  nNdTransparency;
   OMX_U16  nPwmPulseNearEnd;  /**< Num pulses to move lens 1um at near end */
   OMX_U16  nPwmPulseFarEnd;   /**< Num pulses to move lens 1um at far end */
   OMX_U16  nVoltagePIOutNearEnd[3];
   OMX_U16  nVoltagePIOut10cm[3];
   OMX_U16  nVoltagePIOutInfinity[3];
   OMX_U16  nVoltagePIOutFarEnd[3];
   OMX_U32  nAdcConversionNearEnd;
   OMX_U32  nAdcConversionFarEnd;
} OMX_CONFIG_LENSCALIBRATIONVALUETYPE;
/*
Ask the camera component for the driver info on the current camera device
*/

#define OMX_CONFIG_CAMERAINFOTYPE_NAME_LEN 16
#define OMX_CONFIG_CAMERAINFOTYPE_SERIALNUM_LEN 20
#define OMX_CONFIG_CAMERAINFOTYPE_EPROMVER_LEN 8
typedef struct OMX_CONFIG_CAMERAINFOTYPE
{
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U8 cameraname[OMX_CONFIG_CAMERAINFOTYPE_NAME_LEN];
   OMX_U8 lensname[OMX_CONFIG_CAMERAINFOTYPE_NAME_LEN];
   OMX_U16 nModelId;
   OMX_U8 nManufacturerId;
   OMX_U8 nRevNum;
   OMX_U8 sSerialNumber[OMX_CONFIG_CAMERAINFOTYPE_SERIALNUM_LEN];
   OMX_U8 sEpromVersion[OMX_CONFIG_CAMERAINFOTYPE_EPROMVER_LEN];
   OMX_CONFIG_LENSCALIBRATIONVALUETYPE sLensCalibration;
   OMX_U32 xFNumber;
   OMX_U32 xFocalLength;
} OMX_CONFIG_CAMERAINFOTYPE;


typedef enum OMX_CONFIG_CAMERAFEATURESSHUTTER {
   OMX_CameraFeaturesShutterUnknown,
   OMX_CameraFeaturesShutterNotPresent,
   OMX_CameraFeaturesShutterPresent,
   OMX_CameraFeaturesShutterKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
   OMX_CameraFeaturesShutterVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
   OMX_CameraFeaturesShutterMax = 0x7FFFFFFF
} OMX_CONFIG_CAMERAFEATURESSHUTTER;

typedef struct OMX_CONFIG_CAMERAFEATURESTYPE
{
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_CONFIG_CAMERAFEATURESSHUTTER eHasMechanicalShutter;
   OMX_BOOL bHasLens;
} OMX_CONFIG_CAMERAFEATURESTYPE;


//Should be added to the spec as part of IL416c
/* OMX_IndexConfigRequestCallback: Enable config change notifications. */
typedef struct OMX_CONFIG_REQUESTCALLBACKTYPE
{
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_INDEXTYPE nIndex;
   OMX_BOOL bEnable;
} OMX_CONFIG_REQUESTCALLBACKTYPE;
/*
This config implements IL416c to allow clients to request notification
of when a config or parameter is changed. When the parameter specified
in \code{nIndex} for port \code{nPortIndex} changes, an
\code{OMX_EventParamOrConfigChanged} event is generated for the client.
*/

/* OMX_IndexConfigCommonFocusRegionXY: Define focus regions */
typedef enum OMX_FOCUSREGIONTYPE {
   OMX_FocusRegionNormal,
   OMX_FocusRegionFace,
   OMX_FocusRegionMax
} OMX_FOCUSREGIONTYPE;

typedef struct OMX_FOCUSREGIONXY {
   OMX_U32 xLeft;
   OMX_U32 xTop;
   OMX_U32 xWidth;
   OMX_U32 xHeight;
   OMX_U32 nWeight;
   OMX_U32 nMask;
   OMX_FOCUSREGIONTYPE eType;
} OMX_FOCUSREGIONXY;

typedef struct OMX_CONFIG_FOCUSREGIONXYTYPE
{
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_U32 nIndex;
   OMX_U32 nTotalRegions;
   OMX_S32 nValidRegions;
   OMX_BOOL bLockToFaces;
   OMX_U32 xFaceTolerance;
   OMX_FOCUSREGIONXY sRegion[1];
} OMX_CONFIG_FOCUSREGIONXYTYPE;
/*
Query / set the focus regions to use as a set of x/y/width/height boxes relative
to the overall image.

\code{nIndex} - first region number being set/read, allowing retrieval/setting
of many regions over several requests.

\code{nTotalRegions} - total number of regions currently defined.

\code{nValidRegions} - number of valid regions in the \code{sRegion} array.
When getting, the client sets this to the number of regions available.
The component writes region data and updates this field with how many
regions have been written to.
When setting, this is the number of regions defined with this structure

\code{bLockToFaces} - compare the region(s) given to the latest face tracking results.
If a face is found within xFaceTolerance of the defined region, then amend the
region to correspond to the face.

\code{xFaceTolerance} - 0p16 value to define the max difference between the region centre
and face tracking result centre to take the FT results

\code{sRegions} - variable length array of focus regions.
*/

typedef struct OMX_CONFIG_U8TYPE {
    OMX_U32 nSize;                    /**< Size of this structure, in Bytes */
    OMX_VERSIONTYPE nVersion;         /**< OMX specification version information */
    OMX_U32 nPortIndex;               /**< port that this structure applies to */
    OMX_U8  nU8;                     /**< U8 value */
} OMX_PARAM_U8TYPE;

typedef struct OMX_CONFIG_CAMERASETTINGSTYPE {
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_U32 nPortIndex;               /**< port that this structure applies to */
    OMX_U32 nExposure;
    OMX_U32 nAnalogGain;
    OMX_U32 nDigitalGain;
    OMX_U32 nLux;
    OMX_U32 nRedGain;
    OMX_U32 nBlueGain;
    OMX_U32 nFocusPosition;
} OMX_CONFIG_CAMERASETTINGSTYPE;

/* OMX_IndexConfigDrawBoxLineParams: Face box style parameters. */
typedef struct OMX_YUVCOLOUR {
   OMX_U8 nY;
   OMX_U8 nU;
   OMX_U8 nV;
} OMX_YUVCOLOUR;

typedef struct OMX_CONFIG_DRAWBOXLINEPARAMS {
    OMX_U32 nSize;                           /**< Size of this structure, in Bytes */
    OMX_VERSIONTYPE nVersion;                /**< OMX specification version information */
    OMX_U32 nPortIndex;                      /**< Port to which this config applies */
    OMX_U32 xCornerSize;                     /**< Size of the corners as a fraction of the complete side */
    OMX_U32 nPrimaryFaceLineWidth;           /**< Width of the box line for the primary face in pixels */
    OMX_U32 nOtherFaceLineWidth;             /**< Width of the box line for other faces in pixels */
    OMX_U32 nFocusRegionLineWidth;           /**< Width of the box line for focus regions in pixels */
    OMX_YUVCOLOUR sPrimaryFaceColour;        /**< YUV colour for the primary face */
    OMX_YUVCOLOUR sPrimaryFaceSmileColour;   /**< YUV colour for the primary face if smiling */
    OMX_YUVCOLOUR sPrimaryFaceBlinkColour;   /**< YUV colour for the primary face if blinking */
    OMX_YUVCOLOUR sOtherFaceColour;          /**< YUV colour for the all other faces */
    OMX_YUVCOLOUR sOtherFaceSmileColour;     /**< YUV colour for the all other faces if smiling */
    OMX_YUVCOLOUR sOtherFaceBlinkColour;     /**< YUV colour for the all other faces if blinking */
    OMX_BOOL bShowFocusRegionsWhenIdle;      /**< Are focus regions displayed when just in viewfinder/AF idle */
    OMX_YUVCOLOUR sFocusRegionColour;        /**< YUV colour for focus regions */
    OMX_BOOL bShowAfState;                   /**< Change to the colours specified below if AF cycle has run */
    OMX_BOOL bShowOnlyPrimaryAfState;        /**< Only show the primary face when displaying the AF status */
    OMX_BOOL bCombineNonFaceRegions;         /**< Combine all regions not defined as faces into one single box covering them all */
    OMX_YUVCOLOUR sAfLockPrimaryFaceColour;  /**< YUV colour for the primary face */
    OMX_YUVCOLOUR sAfLockOtherFaceColour;    /**< YUV colour for the all other faces */
    OMX_YUVCOLOUR sAfLockFocusRegionColour;  /**< YUV colour for focus regions */
    OMX_YUVCOLOUR sAfFailPrimaryFaceColour;  /**< YUV colour for the primary face */
    OMX_YUVCOLOUR sAfFailOtherFaceColour;    /**< YUV colour for the all other faces */
    OMX_YUVCOLOUR sAfFailFocusRegionColour;  /**< YUV colour for focus regions */
 } OMX_CONFIG_DRAWBOXLINEPARAMS;
/*
Query / set the parameters for the box to be drawn around faces/focus regions.
*/

 #define OMX_PARAM_CAMERARMITYPE_RMINAME_LEN 16
 //OMX_IndexParamCameraRmiControl
 typedef struct OMX_PARAM_CAMERARMITYPE {
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_BOOL bEnabled;
    OMX_U8 sRmiName[OMX_PARAM_CAMERARMITYPE_RMINAME_LEN];
    OMX_U32 nInputBufferHeight;
    OMX_U32 nRmiBufferSize;
    OMX_BRCM_POOL_T *pImagePool;
 } OMX_PARAM_CAMERARMITYPE;

/* OMX_IndexConfigBrcmSyncOutput: Forcing a write sync */
typedef struct OMX_CONFIG_BRCMSYNCOUTPUTTYPE {
    OMX_U32 nSize;                           /**< Size of this structure, in Bytes */
    OMX_VERSIONTYPE nVersion;                /**< OMX specification version information */
}  OMX_CONFIG_BRCMSYNCOUTPUTTYPE;
/*
Setting this config forces a sync of data to the filesystem.
*/

/* OMX_IndexConfigDrmView: View information for DRM rental files */
typedef struct OMX_CONFIG_DRMVIEWTYPE {
   OMX_U32 nSize;             /**< Size of this structure, in Bytes */
   OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
   OMX_U32 nCurrentView;      /**< Current view count */
   OMX_U32 nMaxView;          /**< Max. no. of view allowed */
} OMX_CONFIG_DRMVIEWTYPE;
/*
This structure contains information about the number of available
views in the selected DRM rental file, which typically have a given
maximum view count.  It allows the user to explicitly agree to playing
the file, which will increment the number of current views the file
has had.
*/

typedef struct OMX_PARAM_BRCMU64TYPE {
    OMX_U32 nSize;                    /**< Size of this structure, in Bytes */
    OMX_VERSIONTYPE nVersion;         /**< OMX specification version information */
    OMX_U32 nPortIndex;               /**< port that this structure applies to */
    OMX_U32 nLowPart;                 /**< low bits of the unsigned 64 bit value */
    OMX_U32 nHighPart;                /**< high bits of the unsigned 64 bit value */
} OMX_PARAM_BRCMU64TYPE;

/* OMX_IndexParamBrcmDisableEXIF: Disable generation of EXIF data */
/*
This parameter is used by clients to control the generation of exif
data in JPEG images.
*/

/* OMX_IndexParamBrcmThumbnail: Control generation of thumbnail */
typedef struct OMX_PARAM_BRCMTHUMBNAILTYPE {
    OMX_U32 nSize;                    /**< Size of this structure, in Bytes */
    OMX_VERSIONTYPE nVersion;         /**< OMX specification version information */
    OMX_BOOL bEnable;                 /**< Enable generation of thumbnails during still capture */
    OMX_BOOL bUsePreview;             /**< Use the preview image (as is) as thumbnail */
    OMX_U32 nWidth;                   /**< Desired width of the thumbnail */
    OMX_U32 nHeight;                  /**< Desired height of the thumbnail */
} OMX_PARAM_BRCMTHUMBNAILTYPE;
/*
This parameter is used by clients to control how thumbnails are
generated when creating still images.

Thumbnail generation will be turned on or off depending on the
\code{bEnable} field.

The \code{bUsePreview} field will let the component know whether it
should use the low resolution preview image (if the component has one
available) as is for the thumbnail. When this is set to true, it should
make the generation of thumbnails faster (if a preview image is available)
and should use less memory as well.

The \code{nWidth} and \code{nHeight} fields allow the client to
specify the dimensions of the thumbnail.  If both \code{nWidth} and
\code{nHeight} are 0, we will calculate a sensible size for the
thumbnail.
*/

typedef struct OMX_PARAM_BRCMASPECTRATIOTYPE {
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_U32 nPortIndex;
    OMX_U32 nWidth;
    OMX_U32 nHeight;
} OMX_PARAM_BRCMASPECTRATIOTYPE;

/* OMX_IndexParamBrcmVideoDecodeErrorConcealment: Control error concealment for video decode */
typedef struct OMX_PARAM_BRCMVIDEODECODEERRORCONCEALMENTTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_BOOL bStartWithValidFrame; /**< Decoder will only start emitting frames from a non-corrupted frame */
} OMX_PARAM_BRCMVIDEODECODEERRORCONCEALMENTTYPE;
/*
 This parameter is used by clients to control the type of error concealment
 that will be done by the video decoder.
 */

#define OMX_CONFIG_FLASHINFOTYPE_NAME_LEN 16
typedef struct OMX_CONFIG_FLASHINFOTYPE
{
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U8 sFlashName[OMX_CONFIG_FLASHINFOTYPE_NAME_LEN];
   OMX_CAMERAFLASHTYPE eFlashType;
   OMX_U8 nDeviceId;
   OMX_U8 nDeviceVersion;
} OMX_CONFIG_FLASHINFOTYPE;

/* OMX_IndexParamBrcmInterpolateMissingTimestamps: Configure component to interpolate missing timestamps */
/*
Configures a component so that it tries to timestamp all the buffers it outputs.
If the timestamp information is missing from the original buffer, the
component will try its best to interpolate a value for the missing timestamp.
 */

/* OMX_IndexParamBrcmSetCodecPerformanceMonitoring: Configure component to output performance statistics */
/*
Configures a codec component so that it outputs performance statistics to
the given DECODE_PROGRESS_REPORT_T structure (passed as a pointer).
This structure can then be read by the client to find out where the codec is
at in its processing.
 */

/* OMX_IndexConfigDynamicRangeExpansion: Configure image dynamic range expansion processing */
typedef enum OMX_DYNAMICRANGEEXPANSIONMODETYPE {
   OMX_DynRangeExpOff,
   OMX_DynRangeExpLow,
   OMX_DynRangeExpMedium,
   OMX_DynRangeExpHigh,
   OMX_DynRangeExpKhronosExtensions = 0x6F000000,
   OMX_DynRangeExpVendorStartUnused = 0x7F000000,
   OMX_DynRangeExpMax = 0x7FFFFFFF
} OMX_DYNAMICRANGEEXPANSIONMODETYPE;

typedef struct OMX_CONFIG_DYNAMICRANGEEXPANSIONTYPE
{
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_DYNAMICRANGEEXPANSIONMODETYPE eMode;
} OMX_CONFIG_DYNAMICRANGEEXPANSIONTYPE;
/*
Configures the intensity of an image dynamic range expansion processing stage
*/

/* OMX_IndexParamBrcmTransposeBufferCount: Configure the number of pre-allocated transpose buffers  */
/*
This config allows the client to explicitly set the number of destination buffers pre-allocated for
ports that support 90/270 degree rotation (e.g. in video_render). The buffers will be pre-allocated during
a state transition from LOADED to IDLE (the transition will fail if there is not enough memory available
for the buffers).
.
*/


/* OMX_IndexParamBrcmThreadAffinity: Control the CPU affinity of component thread(s) */
typedef enum OMX_BRCMTHREADAFFINITYTYPE {
   OMX_BrcmThreadAffinityCPU0,
   OMX_BrcmThreadAffinityCPU1,
   OMX_BrcmThreadAffinityMax = 0x7FFFFFFF
} OMX_BRCMTHREADAFFINITYTYPE;

typedef struct OMX_PARAM_BRCMTHREADAFFINITYTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_BRCMTHREADAFFINITYTYPE eAffinity;  /**< Thread CPU affinity */
} OMX_PARAM_BRCMTHREADAFFINITYTYPE;
/*
 This parameter is used by clients to hint the CPU that a component thread should run on.
 */

 /* OMX_IndexConfigCommonSceneDetected: Reports the scene type detected by a scene detection algorithm. */
typedef enum OMX_SCENEDETECTTYPE {
   OMX_SceneDetectUnknown,
   OMX_SceneDetectLandscape,
   OMX_SceneDetectPortrait,
   OMX_SceneDetectMacro,
   OMX_SceneDetectNight,
   OMX_SceneDetectPortraitNight,
   OMX_SceneDetectBacklit,
   OMX_SceneDetectPortraitBacklit,
   OMX_SceneDetectSunset,
   OMX_SceneDetectBeach,
   OMX_SceneDetectSnow,
   OMX_SceneDetectFireworks,
   OMX_SceneDetectMax = 0x7FFFFFFF
} OMX_SCENEDETECTTYPE;

/* OMX_IndexConfigCommonSceneDetected: Reports the scene type detected by a scene detection algorithm. */
typedef struct OMX_CONFIG_SCENEDETECTTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_SCENEDETECTTYPE eScene;  /**< Scene type detected */
} OMX_CONFIG_SCENEDETECTTYPE;
/*
 This config is used to report to clients the scene type that has been detected.
 */

/* OMX_IndexParamNalStreamFormat: Control the NAL unit packaging. This is a Khronos extension. */
typedef enum OMX_INDEXEXTTYPE {
    /* Video parameters and configurations */
    OMX_IndexExtVideoStartUnused = OMX_IndexKhronosExtensions + 0x00600000,
    OMX_IndexParamNalStreamFormatSupported,         /**< reference: OMX_NALSTREAMFORMATTYPE */
    OMX_IndexParamNalStreamFormat,                  /**< reference: OMX_NALSTREAMFORMATTYPE */
    OMX_IndexParamNalStreamFormatSelect,            /**< reference: OMX_NALSTREAMFORMATTYPE */

    OMX_IndexExtMax = 0x7FFFFFFF
} OMX_INDEXEXTTYPE;

/* OMX_IndexParamNalStreamFormat: Control the NAL unit packaging. This is a Khronos extension. */
typedef enum OMX_NALUFORMATSTYPE {
    OMX_NaluFormatStartCodes = 1,
    OMX_NaluFormatOneNaluPerBuffer = 2,
    OMX_NaluFormatOneByteInterleaveLength = 4,
    OMX_NaluFormatTwoByteInterleaveLength = 8,
    OMX_NaluFormatFourByteInterleaveLength = 16,
    OMX_NaluFormatCodingMax = 0x7FFFFFFF
} OMX_NALUFORMATSTYPE;

/* OMX_IndexParamNalStreamFormat: Control the NAL unit packaging. This is a Khronos extension. */
typedef struct OMX_NALSTREAMFORMATTYPE{
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_U32 nPortIndex;
    OMX_NALUFORMATSTYPE eNaluFormat;
} OMX_NALSTREAMFORMATTYPE;
/*
 This parameter is used to control the NAL unit packaging of an H264 video port.
 */

/* OMX_IndexParamVideoMvc: MVC codec parameters */
typedef  struct OMX_VIDEO_PARAM_AVCTYPE  OMX_VIDEO_PARAM_MVCTYPE;
/*
This parameter is currently identical to the AVC parameter type.
*/

 /* OMX_IndexConfigBrcmDrawStaticBox: Define static box to be drawn */
typedef enum OMX_STATICBOXTYPE {
   OMX_StaticBoxNormal,
   OMX_StaticBoxPrimaryFaceAfIdle,
   OMX_StaticBoxNonPrimaryFaceAfIdle,
   OMX_StaticBoxFocusRegionAfIdle,
   OMX_StaticBoxPrimaryFaceAfSuccess,
   OMX_StaticBoxNonPrimaryFaceAfSuccess,
   OMX_StaticBoxFocusRegionAfSuccess,
   OMX_StaticBoxPrimaryFaceAfFail,
   OMX_StaticBoxNonPrimaryFaceAfFail,
   OMX_StaticBoxFocusRegionAfFail,
   OMX_StaticBoxMax
} OMX_STATICBOXTYPE;

typedef struct OMX_STATICBOX {
   OMX_U32 xLeft;
   OMX_U32 xTop;
   OMX_U32 xWidth;
   OMX_U32 xHeight;
   OMX_STATICBOXTYPE eType;
} OMX_STATICBOX;

typedef struct OMX_CONFIG_STATICBOXTYPE
{
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_U32 nIndex;
   OMX_U32 nTotalBoxes;
   OMX_S32 nValidBoxes;
   OMX_BOOL bDrawOtherBoxes;
   OMX_STATICBOX sBoxes[1];
} OMX_CONFIG_STATICBOXTYPE;
/*
Query / set the parameters for a box to always be drawn on viewfinder images
The x/y/width/height values for the boxes are relative to the overall image.

\code{nIndex} - first box number being set/read, allowing retrieval/setting
of many boxes over several requests.

\code{nValidBoxes} - total number of boxes currently defined.

\code{nValidBoxes} - number of valid boxes in the \code{sBoxes} array.
When getting, the client sets this to the number of boxes available.
The component writes box data and updates this field with how many
boxes have been written to.
When setting, this is the number of boxes defined with this structure

\code{sBoxes} - variable length array of static boxes.
*/

/* OMX_IndexConfigPortCapturing: Per-port capturing state */
typedef struct OMX_CONFIG_PORTBOOLEANTYPE{
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_U32 nPortIndex;
    OMX_BOOL bEnabled;
} OMX_CONFIG_PORTBOOLEANTYPE;
/*
This is proposed in IL533f for controlling
which ports of a multi-port camera component are capturing frames.
*/

/* OMX_IndexConfigCaptureMode: Capturing mode type */
typedef enum OMX_CAMERACAPTUREMODETYPE {
   OMX_CameraCaptureModeWaitForCaptureEnd,
   OMX_CameraCaptureModeWaitForCaptureEndAndUsePreviousInputImage,
   OMX_CameraCaptureModeResumeViewfinderImmediately,
   OMX_CameraCaptureModeMax,
} OMX_CAMERACAPTUREMODETYPE;

typedef struct OMX_PARAM_CAMERACAPTUREMODETYPE{
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_U32 nPortIndex;
    OMX_CAMERACAPTUREMODETYPE eMode;
} OMX_PARAM_CAMERACAPTUREMODETYPE;
/*
This controls the mode of operation for
still image capture in the camera component.
*/

/* OMX_IndexParamBrcmDrmEncryption: Set DRM encryption scheme */
typedef enum OMX_BRCMDRMENCRYPTIONTYPE
{
   OMX_DrmEncryptionNone = 0,
   OMX_DrmEncryptionHdcp2,
   OMX_DrmEncryptionKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
   OMX_DrmEncryptionVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
   OMX_DrmEncryptionRangeMax = 0x7FFFFFFF
} OMX_BRCMDRMENCRYPTIONTYPE;

typedef struct OMX_PARAM_BRCMDRMENCRYPTIONTYPE
{
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_BRCMDRMENCRYPTIONTYPE eEncryption;
   OMX_U32 nConfigDataLen;
   OMX_U8 configData[1];
} OMX_PARAM_BRCMDRMENCRYPTIONTYPE;
/*
Query/set the DRM encryption scheme used by a port writing out data.
*/


/* OMX_IndexConfigBufferStall: Advertise buffer stall state */
typedef struct OMX_CONFIG_BUFFERSTALLTYPE
{
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_BOOL bStalled;      /**< Whether we are stalled */
   OMX_U32 nDelay;         /**< Delay in real time (us) from last buffer to current time */
} OMX_CONFIG_BUFFERSTALLTYPE;
/*
Query/set the buffer stall threashold.  When set the \code{nDelay}
parameter specifies a time to class whether buffer output is stalled.
When get, the \code{nDelay} parameter indicates the current buffer
delay, and the {bStalled} parameter indicates whether this time is
over a previously set threashold.  When
\code{OMX_IndexConfigRequestCallback} is used with this index, a
notification is given when \code{bStalled} changes.
*/

/* OMX_IndexConfigLatencyTarget: Maintain target latency by adjusting clock speed */
typedef struct OMX_CONFIG_LATENCYTARGETTYPE
{
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_BOOL bEnabled; /**< whether this mode is enabled */
   OMX_U32 nFilter; /**< number of latency samples to filter on, good value: 1 */
   OMX_U32 nTarget; /**< target latency, us */
   OMX_U32 nShift;  /**< shift for storing latency values, good value: 7 */
   OMX_S32 nSpeedFactor; /**< multiplier for speed changes, in 24.8 format, good value: 256-512 */
   OMX_S32 nInterFactor; /**< divider for comparing latency versus gradiant, good value: 300 */
   OMX_S32 nAdjCap; /**< limit for speed change before nSpeedFactor is applied, good value: 100 */
} OMX_CONFIG_LATENCYTARGETTYPE;
/*
Query/set parameters used when adjusting clock speed to match the
measured latency to a specified value.
*/

/* OMX_IndexConfigBrcmUseProprietaryCallback: Force use of proprietary callback */
typedef struct OMX_CONFIG_BRCMUSEPROPRIETARYCALLBACKTYPE
{
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_BOOL bEnable;
} OMX_CONFIG_BRCMUSEPROPRIETARYCALLBACKTYPE;
/*
Disable/enable the use of proprietary callbacks rather than OpenMAX IL buffer handling.
*/

/* OMX_IndexParamCommonUseStcTimestamps: Select timestamp mode */
typedef enum OMX_TIMESTAMPMODETYPE
{
   OMX_TimestampModeZero = 0,       /**< Use a timestamp of 0 */
   OMX_TimestampModeRawStc,         /**< Use the raw STC as the timestamp */
   OMX_TimestampModeResetStc,       /**< Store the STC when video capture port goes active, and subtract that from STC for the timestamp */
   OMX_TimestampModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
   OMX_TimestampModeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
   OMX_TimestampModeMax = 0x7FFFFFFF
} OMX_TIMESTAMPMODETYPE;

typedef struct OMX_PARAM_TIMESTAMPMODETYPE
{
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_TIMESTAMPMODETYPE eTimestampMode;
} OMX_PARAM_TIMESTAMPMODETYPE;
/*
 Specifies what to use as timestamps in the absence of a clock component.
*/

/* EGL image buffer for passing to video port.
 * Used when port color format is OMX_COLOR_FormatBRCMEGL.
 */
typedef struct OMX_BRCMVEGLIMAGETYPE
{
   /* Passed between ARM + VC; use fixed width types. */
   OMX_U32 nWidth;
   OMX_U32 nHeight;
   OMX_U32 nStride;
   OMX_U32 nUmemHandle;
   OMX_U32 nUmemOffset;
   OMX_U32 nFlipped;    /* Non-zero -> vertically flipped image */
} OMX_BRCMVEGLIMAGETYPE;

/* Provides field of view 
 */
typedef struct OMX_CONFIG_BRCMFOVTYPE
{
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_U32 xFieldOfViewHorizontal;  /**< Horizontal field of view in degrees. 16p16 value */
   OMX_U32 xFieldOfViewVertical;    /**< Vertical field of view in degrees. 16p16 value */
} OMX_CONFIG_BRCMFOVTYPE;

/* OMX_IndexConfigBrcmDecoderPassThrough: Enabling Audio Passthrough */
/*
This allows an audio decoder to disable decoding the stream and pass through correctly framed
data to enable playback of compressed audio to supported output devices.
*/

/* OMX_IndexConfigBrcmClockReferenceSource: Select Clock Reference Source */
/*
This control allows communicating directly to an audio renderer component whether it should
act as a clock reference source or act as a slave.
*/

/* OMX_IndexConfigEncLevelExtension: AVC Override encode capabilities */
typedef struct OMX_VIDEO_CONFIG_LEVEL_EXTEND {
   OMX_U32 nSize; 
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_U32 nCustomMaxMBPS;     /**< Specifies maximum macro-blocks per second */
   OMX_U32 nCustomMaxFS;       /**< Specifies maximum frame size (macro-blocks per frame) */
   OMX_U32 nCustomMaxBRandCPB; /**< Specifies maximum bitrate in units of 1000 bits/s and Codec Picture Buffer (CPB derived from bitrate) */
} OMX_VIDEO_CONFIG_LEVEL_EXTEND;
/*
This allows finer control of the H264 encode internal parameters.
*/

/* OMX_IndexParamBrcmEEDEEnable: Enable/Disable end to end distortion estimator */
typedef struct OMX_VIDEO_EEDE_ENABLE {
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_U32 nPortIndex;
    OMX_U32 enable;
} OMX_VIDEO_EEDE_ENABLE;
/*
This enables or disables the use of end to end distortion estimation.
*/

/* OMX_IndexParamBrcmEEDELossRate: Loss rate configuration for end to end distortion */
typedef struct OMX_VIDEO_EEDE_LOSSRATE {
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_U32 nPortIndex;
   OMX_U32 loss_rate; /**< loss rate, 5 means 5% */
} OMX_VIDEO_EEDE_LOSSRATE;
/*
Set the packet loss rate used by the end to end distortion estimator.
*/

/* OMX_IndexParamColorSpace: Colour space information */
typedef enum OMX_COLORSPACETYPE
{
   OMX_COLORSPACE_UNKNOWN,
   OMX_COLORSPACE_JPEG_JFIF,
   OMX_COLORSPACE_ITU_R_BT601,
   OMX_COLORSPACE_ITU_R_BT709,
   OMX_COLORSPACE_FCC,
   OMX_COLORSPACE_SMPTE240M,
   OMX_COLORSPACE_BT470_2_M,
   OMX_COLORSPACE_BT470_2_BG,
   OMX_COLORSPACE_JFIF_Y16_255,
   OMX_COLORSPACE_MAX = 0x7FFFFFFF
} OMX_COLORSPACETYPE;

typedef struct OMX_PARAM_COLORSPACETYPE
{
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_COLORSPACETYPE eColorSpace;
} OMX_PARAM_COLORSPACETYPE;
/*
Sets the colourspace with which pixel buffers should be generated / interpreted.
*/

typedef enum OMX_CAPTURESTATETYPE
{
   OMX_NotCapturing,
   OMX_CaptureStarted,
   OMX_CaptureComplete,
   OMX_CaptureMax = 0x7FFFFFFF
} OMX_CAPTURESTATETYPE;

typedef struct OMX_PARAM_CAPTURESTATETYPE
{
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_CAPTURESTATETYPE eCaptureState;
} OMX_PARAM_CAPTURESTATETYPE;

/*
Provides information on the colour space that's in use during image/video processing.
*/

/* OMX_IndexConfigMinimiseFragmentation: Minimising Fragmentation */
/*
This control can be supported to enable the client to request that the component works
to minimise fragmentation of output buffers.
*/

/* OMX_IndexConfigBrcmBufferFlagFilter: Filter buffers based on flags */
/*
This control can be set to request that buffers are conditionally forwarded on 
output ports based on matching flags set on that buffer.
*/

/* OMX_IndexParamPortMaxFrameSize: Specifying maximum frame size */
/*
This control can be used to control the maximum frame size allowed on an output port.
*/

/* OMX_IndexConfigBrcmCameraRnDPreprocess: Enable use of development ISP software stage */
/*
This control can be used to enable a developmental software stage to be inserted into
the preprocessor stage of the ISP.
*/

/* OMX_IndexConfigBrcmCameraRnDPostprocess: Enable use of development ISP software stage */
/*
This control can be used to enable a developmental software stage to be inserted into
the postprocessor stage of the ISP.
*/

/* OMX_IndexParamDisableVllPool: Controlling use of memory for loadable modules */
/*
This control can be used to control whether loadable modules used a dedicated memory
pool or use heap allocated memory.
*/

/* OMX_IndexParamBrcmVideoPrecodeForQP: Pre-code 1st frame for QP.*/
/*
This control selects a pre-encode of the first frame to set up a better initial QP value.
*/

/* OMX_IndexParamBrcmVideoTimestampFifo: Video timestamp FIFO mode. */
/*
When enabled, the timestamp fifo mode will change the way
incoming timestamps are associated with output images so the incoming timestamps
get used without re-ordering on output images.
*/

/* OMX_IndexParamCameraCustomSensorConfig: Custom camera sensor configuration. */
/*
This parameter is passed down to the camera sensor driver to be interpreted as a
request for a different configuration to normal. How the configuration varies is
sensor specific.
*/

/* OMX_IndexParamCameraDeviceNumber: Camera device selection .*/
/*
Controls which camera driver, or camera peripheral, to use.
*/

/* OMX_IndexParamBrcmMaxNumCallbacks: Codec callback limit. */
/*
The codec can queue up a significant number of frames internally if the sink is
not consuming the output fast enough. This control limits the number of frames
that can be queued up.
*/

typedef struct OMX_PARAM_BRCMCONFIGFILETYPE {
   OMX_U32 nSize;                      /**< size of the structure in bytes, including
                                            actual URI name */
   OMX_VERSIONTYPE nVersion;           /**< OMX specification version information */
   OMX_U32 fileSize;                   /**< Size of complete file data */
} OMX_PARAM_BRCMCONFIGFILETYPE;

typedef struct OMX_PARAM_BRCMCONFIGFILECHUNKTYPE {
   OMX_U32 nSize;                      /**< size of the structure in bytes, including
                                            actual chunk data */
   OMX_VERSIONTYPE nVersion;           /**< OMX specification version information */
   OMX_U32 size;                       /**< Number of bytes being transferred in this chunk */
   OMX_U32 offset;                     /**< Offset of this chunk in the file */
   OMX_U8 data[1];                     /**< Chunk data */
} OMX_PARAM_BRCMCONFIGFILECHUNKTYPE;

typedef struct OMX_PARAM_BRCMFRAMERATERANGETYPE {
   OMX_U32 nSize;                      /**< size of the structure in bytes, including
                                            actual chunk data */
   OMX_VERSIONTYPE nVersion;           /**< OMX specification version information */
   OMX_U32 nPortIndex;
   OMX_U32 xFramerateLow;              /**< Low end of framerate range. Q16 format */
   OMX_U32 xFramerateHigh;             /**< High end of framerate range. Q16 format */
} OMX_PARAM_BRCMFRAMERATERANGETYPE;

typedef struct OMX_PARAM_S32TYPE {
    OMX_U32 nSize;                    /**< Size of this structure, in Bytes */
    OMX_VERSIONTYPE nVersion;         /**< OMX specification version information */
    OMX_U32 nPortIndex;               /**< port that this structure applies to */
    OMX_S32 nS32;                     /**< S32 value */
} OMX_PARAM_S32TYPE;

typedef struct OMX_PARAM_BRCMVIDEODRMPROTECTBUFFERTYPE
{
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;

   OMX_U32 size_wanted;     /**< Input. Zero size means internal video decoder buffer,
                                 mem_handle and phys_addr not returned in this case */
   OMX_U32 protect;         /**< Input. 1 = protect, 0 = unprotect */

   OMX_U32 mem_handle;      /**< Output. Handle for protected buffer */
   OMX_PTR phys_addr;       /**< Output. Physical memory address of protected buffer */
} OMX_PARAM_BRCMVIDEODRMPROTECTBUFFERTYPE;

typedef struct OMX_CONFIG_ZEROSHUTTERLAGTYPE
{
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;

   OMX_U32 bZeroShutterMode;        /**< Select ZSL mode from the camera. */
   OMX_U32 bConcurrentCapture;      /**< Perform concurrent captures for full ZSL. */

} OMX_CONFIG_ZEROSHUTTERLAGTYPE;

/* OMX_IndexParamBrcmVideoDecodeConfigVD3: VDec3 configuration. */
typedef struct OMX_PARAM_BRCMVIDEODECODECONFIGVD3TYPE {
   OMX_U32 nSize;                      /**< size of the structure in bytes, including
                                            configuration data */
   OMX_VERSIONTYPE nVersion;           /**< OMX specification version information */
   OMX_U8 config[1];                   /**< Configuration data (a VD3_CONFIGURE_T) */
} OMX_PARAM_BRCMVIDEODECODECONFIGVD3TYPE;
/*
Codec specific configuration block to set up internal state in a non-standard manner.
*/

/* OMX_IndexConfigCustomAwbGains: Manual AWB Gains. */
typedef struct OMX_CONFIG_CUSTOMAWBGAINSTYPE {
   OMX_U32 nSize;                      /**< size of the structure in bytes, including
                                            configuration data */
   OMX_VERSIONTYPE nVersion;           /**< OMX specification version information */
   OMX_U32 xGainR;                     /**< Red gain - 16p16 */
   OMX_U32 xGainB;                     /**< Blue gain - 16p16 */
} OMX_CONFIG_CUSTOMAWBGAINSTYPE;

/* OMX_IndexConfigCustomAwbGains: Manual AWB Gains. */

/* OMX_IndexConfigBrcmRenderStats: Render port statistics */
typedef struct OMX_CONFIG_BRCMRENDERSTATSTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_BOOL nValid;
   OMX_U32 nMatch;
   OMX_U32 nPeriod;
   OMX_U32 nPhase;
   OMX_U32 nPixelClockNominal;
   OMX_U32 nPixelClock;
   OMX_U32 nHvsStatus;
   OMX_U32 dummy0[2];
} OMX_CONFIG_BRCMRENDERSTATSTYPE;
/*
This provides statistics from the renderer to allow more accurate synchronisation
between the scheduler and display VSYNC.
*/

typedef enum OMX_BRCMANNOTATEJUSTIFYTYPE {
   OMX_ANNOTATE_CENTRE = 0,
   OMX_ANNOTATE_LEFT = 1,
   OMX_ANNOTATE_RIGHT = 2,
   OMX_ANNOTATE_MAX = 0x7FFFFFFF,
} OMX_BRCMANNOTATEJUSTIFYTYPE;

#define OMX_BRCM_MAXANNOTATETEXTLEN 256
typedef struct OMX_CONFIG_BRCMANNOTATETYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_BOOL bEnable;
   OMX_BOOL bShowShutter;
   OMX_BOOL bShowAnalogGain;
   OMX_BOOL bShowLens;
   OMX_BOOL bShowCaf;
   OMX_BOOL bShowMotion;
   OMX_BOOL bShowFrameNum;
   OMX_BOOL bEnableBackground;
   OMX_BOOL bCustomBackgroundColour;
   OMX_U8 nBackgroundY;
   OMX_U8 nBackgroundU;
   OMX_U8 nBackgroundV;
   OMX_U8 dummy1;
   OMX_BOOL bCustomTextColour;
   OMX_U8 nTextY;
   OMX_U8 nTextU;
   OMX_U8 nTextV;
   OMX_U8 nTextSize;   /**< Text size: 6-150 pixels */
   OMX_U8 sText[OMX_BRCM_MAXANNOTATETEXTLEN];
   OMX_BRCMANNOTATEJUSTIFYTYPE eJustify;
   OMX_U32 nXOffset;
   OMX_U32 nYOffset;
} OMX_CONFIG_BRCMANNOTATETYPE;

/* OMX_IndexParamBrcmStereoscopicMode: Stereoscopic camera support */
typedef enum OMX_BRCMSTEREOSCOPICMODETYPE {
   OMX_STEREOSCOPIC_NONE = 0,
   OMX_STEREOSCOPIC_SIDEBYSIDE = 1,
   OMX_STEREOSCOPIC_TOPBOTTOM = 2,
   OMX_STEREOSCOPIC_MAX = 0x7FFFFFFF,
} OMX_BRCMSTEREOSCOPICMODETYPE;

typedef struct OMX_CONFIG_BRCMSTEREOSCOPICMODETYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;

   OMX_U32 nPortIndex;                    /**< port that this structure applies to */
   OMX_BRCMSTEREOSCOPICMODETYPE eMode;    /**< Packing mode */
   OMX_BOOL bDecimate;                    /**< Half/half mode
                                          (pixel aspect ratio = 1:2 or 2:1 if set. 1:1 if not set) */
   OMX_BOOL bSwapEyes;                    /**< False = left eye first. True = right eye first. */
} OMX_CONFIG_BRCMSTEREOSCOPICMODETYPE;
/*
This control sets up how stereoscopic images should be generated.
*/

/* OMX_IndexParamCameraInterface: Camera interface type. */
typedef enum OMX_CAMERAINTERFACETYPE {
   OMX_CAMERAINTERFACE_CSI = 0,
   OMX_CAMERAINTERFACE_CCP2 = 1,
   OMX_CAMERAINTERFACE_CPI = 2,
   OMX_CAMERAINTERFACE_MAX = 0x7FFFFFFF,
} OMX_CAMERAINTERFACETYPE;

typedef struct OMX_PARAM_CAMERAINTERFACETYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;

   OMX_U32 nPortIndex;                    /**< port that this structure applies to */
   OMX_CAMERAINTERFACETYPE eMode;         /**< Interface mode */
} OMX_PARAM_CAMERAINTERFACETYPE;
/*
This configures the physical camera interface type.
*/

typedef enum OMX_CAMERACLOCKINGMODETYPE {
   OMX_CAMERACLOCKINGMODE_STROBE = 0,
   OMX_CAMERACLOCKINGMODE_CLOCK = 1,
   OMX_CAMERACLOCKINGMODE_MAX = 0x7FFFFFFF,
} OMX_CAMERACLOCKINGMODETYPE;

typedef struct OMX_PARAM_CAMERACLOCKINGMODETYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;

   OMX_U32 nPortIndex;                    /**< port that this structure applies to */
   OMX_CAMERACLOCKINGMODETYPE eMode;      /**< Clocking mode */
} OMX_PARAM_CAMERACLOCKINGMODETYPE;

/* OMX_IndexParamCameraRxConfig: Camera receiver configuration */
typedef enum OMX_CAMERARXDECODETYPE {
   OMX_CAMERARXDECODE_NONE = 0,
   OMX_CAMERARXDECODE_DPCM8TO10 = 1,
   OMX_CAMERARXDECODE_DPCM7TO10 = 2,
   OMX_CAMERARXDECODE_DPCM6TO10 = 3,
   OMX_CAMERARXDECODE_DPCM8TO12 = 4,
   OMX_CAMERARXDECODE_DPCM7TO12 = 5,
   OMX_CAMERARXDECODE_DPCM6TO12 = 6,
   OMX_CAMERARXDECODE_DPCM10TO14 = 7,
   OMX_CAMERARXDECODE_DPCM8TO14 = 8,
   OMX_CAMERARXDECODE_DPCM12TO16 = 9,
   OMX_CAMERARXDECODE_DPCM10TO16 = 10,
   OMX_CAMERARXDECODE_DPCM8TO16 = 11,
   OMX_CAMERARXDECODE_MAX = 0x7FFFFFFF
} OMX_CAMERARXDECODETYPE;

typedef enum OMX_CAMERARXENCODETYPE {
   OMX_CAMERARXENCODE_NONE = 0,
   OMX_CAMERARXENCODE_DPCM10TO8 = 1,
   OMX_CAMERARXENCODE_DPCM12TO8 = 2,
   OMX_CAMERARXENCODE_DPCM14TO8 = 3,
   OMX_CAMERARXENCODE_MAX = 0x7FFFFFFF
} OMX_CAMERARXENCODETYPE;

typedef enum OMX_CAMERARXUNPACKTYPE {
   OMX_CAMERARXUNPACK_NONE = 0,
   OMX_CAMERARXUNPACK_6 = 1,
   OMX_CAMERARXUNPACK_7 = 2,
   OMX_CAMERARXUNPACK_8 = 3,
   OMX_CAMERARXUNPACK_10 = 4,
   OMX_CAMERARXUNPACK_12 = 5,
   OMX_CAMERARXUNPACK_14 = 6,
   OMX_CAMERARXUNPACK_16 = 7,
   OMX_CAMERARXUNPACK_MAX = 0x7FFFFFFF
} OMX_CAMERARXUNPACKYPE;

typedef enum OMX_CAMERARXPACKTYPE {
   OMX_CAMERARXPACK_NONE = 0,
   OMX_CAMERARXPACK_8 = 1,
   OMX_CAMERARXPACK_10 = 2,
   OMX_CAMERARXPACK_12 = 3,
   OMX_CAMERARXPACK_14 = 4,
   OMX_CAMERARXPACK_16 = 5,
   OMX_CAMERARXPACK_RAW10 = 6,
   OMX_CAMERARXPACK_RAW12 = 7,
   OMX_CAMERARXPACK_MAX = 0x7FFFFFFF
} OMX_CAMERARXPACKTYPE;

typedef struct OMX_PARAM_CAMERARXCONFIG_TYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;

   OMX_U32 nPortIndex;                    /**< port that this structure applies to */
   OMX_CAMERARXDECODETYPE eDecode;
   OMX_CAMERARXENCODETYPE eEncode;
   OMX_CAMERARXUNPACKYPE eUnpack;
   OMX_CAMERARXPACKTYPE ePack;
   OMX_U32 nDataLanes;
   OMX_U32 nEncodeBlockLength;
   OMX_U32 nEmbeddedDataLines;
   OMX_U32 nImageId;
} OMX_PARAM_CAMERARXCONFIG_TYPE;
/*
Configures the setup and processing options of the camera receiver peripheral.
*/

typedef struct OMX_PARAM_CAMERARXTIMING_TYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;

   OMX_U32 nPortIndex;                    /**< port that this structure applies to */
   OMX_U32 nTiming1;
   OMX_U32 nTiming2;
   OMX_U32 nTiming3;
   OMX_U32 nTiming4;
   OMX_U32 nTiming5;
   OMX_U32 nTerm1;
   OMX_U32 nTerm2;
   OMX_U32 nCpiTiming1;
   OMX_U32 nCpiTiming2;
} OMX_PARAM_CAMERARXTIMING_TYPE;


/* OMX_IndexParamBrcmBayerOrder: Bayer order */
typedef enum OMX_BAYERORDERTYPE {
   OMX_BayerOrderRGGB = 0,
   OMX_BayerOrderGBRG = 1,
   OMX_BayerOrderBGGR = 2,
   OMX_BayerOrderGRBG = 3,

   OMX_BayerOrderMax = 0x7FFFFFFF
} OMX_BAYERORDERTYPE;

typedef struct OMX_PARAM_BAYERORDERTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;

   OMX_U32 nPortIndex;                    /**< port that this structure applies to */
   OMX_BAYERORDERTYPE eBayerOrder;
} OMX_PARAM_BAYERORDERTYPE;
/*
The IL standard does not support a way to specify the Bayer order of Bayer images.
This control adds that missing functionality.
*/

/* OMX_IndexParamBrcmLensShadingOverride: Override or set a lens shading table.*/
/*
Allows the lens shading grid to be set.
Configuration is based on a similar system to the OMAP3 ISP.
A grid of gains is required for each of the 4 Bayer channels, with each value covering
a nGridCellSize square of pixels.
nWidth and nHeight should be equal or greater than the sensor resolution. In the
case of the camera component, the firmware will crop the table based on the preconfigured
mode set. nStride allows additional horizontal padding to be including in the table.
nMemHandleTable needs to be set to a MEM_HANDLE_T, allocated via VC-SM or similar allocator.
nRefTransform should be set to the transform in force when the reference table was
captured. This allows correct compensation when the sensor is subsequently used with
an alternate transform.
*/
typedef struct OMX_PARAM_LENSSHADINGOVERRIDETYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;

   OMX_BOOL bEnabled;                     /**< Enable the override grid */
   OMX_U32 nGridCellSize;                 /**< size of each grid element. Assumes square grid */
   OMX_U32 nWidth;                        /**< grid width */
   OMX_U32 nStride;                       /**< grid stride (allows for padding) */
   OMX_U32 nHeight;                       /**< grid height */
   OMX_U32 nMemHandleTable;               /**< Handle for grid */
   OMX_U32 nRefTransform;                 /**< Reference transform taken from raw header */
} OMX_PARAM_LENSSHADINGOVERRIDETYPE;

/* OMX_IndexConfigBrcmPowerMonitor: Deprecated.*/
/*
Deprecated. Do not use.
*/

/* OMX_IndexParamBrcmZeroCopy: Deprecated */
/*
Deprecated. Do not use.
*/

/* OMX_IndexParamBrcmSupportsSlices: Sliced processing support */
/*
Mainly used by the MMAL framework.
Some components support an nSliceHeight value of 16, to allow images
to be passed in multiple chunks. All will support an nSliceHeight >=
nFrameHeight (with some extra constraints).
If a component supports nSliceHeight of 16, then it will respond to
OMX_GetParameter on this index with no error and bEnabled set to OMX_TRUE.
*/

/* OMX_IndexParamBrcmSupportsUnalignedSliceheight: Unaligned nSliceHeight support */
/*
Most components require an nSliceHeight value which is a multiple of 16, but
some components accepting any value >= nFrameHeight. Those ports/components will
respond to OMX_GetParameter on this index with no error and bEnabled set to OMX_TRUE.
*/

typedef struct OMX_CCMTYPE {
   OMX_S32 sCcm[3][3];
   OMX_S32 soffsets[3];
} OMX_PARAM_CCMTYPE;

typedef struct OMX_PARAM_CUSTOMCCMTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;

   OMX_BOOL bEnabled;          /**< Enable the custom CCM. */
   OMX_S32 xColorMatrix[3][3]; /**< Stored in signed Q16 format */
   OMX_S32 nColorOffset[3];    /**< CCM offsets */
} OMX_PARAM_CUSTOMCCMTYPE;

/* OMX_IndexConfigCameraDigitalGain: Manual digital gain. */
/*
Configures the digital gain within the ISP pipeline.
*/
typedef struct OMX_CONFIG_CAMERAGAINTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;

   OMX_U32 xGain;             /**< Gain to be applied, stored as Q16 format */
   OMX_BOOL bAutoGain;        /**< Whether gain is set automatically */
} OMX_CONFIG_CAMERAGAINTYPE;

/* OMX_IndexParamMinimumAlignment: Query component alignment requirements. */
/*
Allows the component to be queried for the minimum alignment (in bytes) required
on a port for a given color format.
Used by the MMAL framework to allow a reduction in the padding.
*/

typedef struct OMX_PARAM_MINALIGNTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;

   OMX_COLOR_FORMATTYPE eColorFormat;  /**< Format being queried */
   OMX_U32 nMinHorizontalAlign;  /**< Minimum horizontal alignment required in bytes */
   OMX_U32 nMinVerticalAlign;    /**< Minimum vertical alignment required in bytes */
} OMX_PARAM_MINALIGNTYPE;

/* OMX_IndexParamRemoveImagePadding: Query component padding requirements */
/*
Queries whether the component can remove all padding from images, or can
accept images with no padding.
Used by the MMAL framework predominantly.
Superceded by OMX_IndexParamMinimumAlignment.
*/

#endif
/* File EOF */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                /*
 * Copyright (c) 2008 The Khronos Group Inc. 
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject
 * to the following conditions: 
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software. 
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
 *
 */

/** OMX_Component.h - OpenMax IL version 1.1.2
 *  The OMX_Component header file contains the definitions used to define
 *  the public interface of a component.  This header file is intended to
 *  be used by both the application and the component.
 */

#ifndef OMX_Component_h
#define OMX_Component_h

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */



/* Each OMX header must include all required header files to allow the
 *  header to compile without errors.  The includes below are required
 *  for this header file to compile successfully 
 */

#include "OMX_Audio.h"
#include "OMX_Video.h"
#include "OMX_Image.h"
#include "OMX_Other.h"

/** @ingroup comp */
typedef enum OMX_PORTDOMAINTYPE { 
    OMX_PortDomainAudio, 
    OMX_PortDomainVideo, 
    OMX_PortDomainImage, 
    OMX_PortDomainOther,
    OMX_PortDomainKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_PortDomainVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_PortDomainMax = 0x7ffffff
} OMX_PORTDOMAINTYPE;

/** @ingroup comp */
typedef struct OMX_PARAM_PORTDEFINITIONTYPE {
    OMX_U32 nSize;                 /**< Size of the structure in bytes */
    OMX_VERSIONTYPE nVersion;      /**< OMX specification version information */
    OMX_U32 nPortIndex;            /**< Port number the structure applies to */
    OMX_DIRTYPE eDir;              /**< Direction (input or output) of this port */
    OMX_U32 nBufferCountActual;    /**< The actual number of buffers allocated on this port */
    OMX_U32 nBufferCountMin;       /**< The minimum number of buffers this port requires */
    OMX_U32 nBufferSize;           /**< Size, in bytes, for buffers to be used for this channel */
    OMX_BOOL bEnabled;             /**< Ports default to enabled and are enabled/disabled by
                                        OMX_CommandPortEnable/OMX_CommandPortDisable.
                                        When disabled a port is unpopulated. A disabled port
                                        is not populated with buffers on a transition to IDLE. */
    OMX_BOOL bPopulated;           /**< Port is populated with all of its buffers as indicated by
                                        nBufferCountActual. A disabled port is always unpopulated. 
                                        An enabled port is populated on a transition to OMX_StateIdle
                                        and unpopulated on a transition to loaded. */
    OMX_PORTDOMAINTYPE eDomain;    /**< Domain of the port. Determines the contents of metadata below. */
    union {
        OMX_AUDIO_PORTDEFINITIONTYPE audio;
        OMX_VIDEO_PORTDEFINITIONTYPE video;
        OMX_IMAGE_PORTDEFINITIONTYPE image;
        OMX_OTHER_PORTDEFINITIONTYPE other;
    } format;
    OMX_BOOL bBuffersContiguous;
    OMX_U32 nBufferAlignment;
} OMX_PARAM_PORTDEFINITIONTYPE;

/** @ingroup comp */
typedef struct OMX_PARAM_U32TYPE { 
    OMX_U32 nSize;                    /**< Size of this structure, in Bytes */ 
    OMX_VERSIONTYPE nVersion;         /**< OMX specification version information */ 
    OMX_U32 nPortIndex;               /**< port that this structure applies to */ 
    OMX_U32 nU32;                     /**< U32 value */
} OMX_PARAM_U32TYPE;

/** @ingroup rpm */
typedef enum OMX_SUSPENSIONPOLICYTYPE {
    OMX_SuspensionDisabled, /**< No suspension; v1.0 behavior */
    OMX_SuspensionEnabled,  /**< Suspension allowed */   
    OMX_SuspensionPolicyKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_SuspensionPolicyStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_SuspensionPolicyMax = 0x7fffffff
} OMX_SUSPENSIONPOLICYTYPE;

/** @ingroup rpm */
typedef struct OMX_PARAM_SUSPENSIONPOLICYTYPE {
    OMX_U32 nSize;                  
    OMX_VERSIONTYPE nVersion;        
    OMX_SUSPENSIONPOLICYTYPE ePolicy;
} OMX_PARAM_SUSPENSIONPOLICYTYPE;

/** @ingroup rpm */
typedef enum OMX_SUSPENSIONTYPE {
    OMX_NotSuspended, /**< component is not suspended */
    OMX_Suspended,    /**< component is suspended */
    OMX_SuspensionKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_SuspensionVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_SuspendMax = 0x7FFFFFFF
} OMX_SUSPENSIONTYPE;

/** @ingroup rpm */
typedef struct OMX_PARAM_SUSPENSIONTYPE {
    OMX_U32 nSize;                  
    OMX_VERSIONTYPE nVersion;       
    OMX_SUSPENSIONTYPE eType;             
} OMX_PARAM_SUSPENSIONTYPE ;

typedef struct OMX_CONFIG_BOOLEANTYPE {
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_BOOL bEnabled;    
} OMX_CONFIG_BOOLEANTYPE;

/* Parameter specifying the content uri to use. */
/** @ingroup cp */
typedef struct OMX_PARAM_CONTENTURITYPE
{
    OMX_U32 nSize;                      /**< size of the structure in bytes, including
                                             actual URI name */
    OMX_VERSIONTYPE nVersion;           /**< OMX specification version information */
    OMX_U8 contentURI[1];               /**< The URI name */
} OMX_PARAM_CONTENTURITYPE;

/* Parameter specifying the pipe to use. */
/** @ingroup cp */
typedef struct OMX_PARAM_CONTENTPIPETYPE
{
    OMX_U32 nSize;              /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
    OMX_HANDLETYPE hPipe;       /**< The pipe handle*/
} OMX_PARAM_CONTENTPIPETYPE;

/** @ingroup rpm */
typedef struct OMX_RESOURCECONCEALMENTTYPE {
    OMX_U32 nSize;             /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
    OMX_BOOL bResourceConcealmentForbidden; /**< disallow the use of resource concealment 
                                            methods (like degrading algorithm quality to 
                                            lower resource consumption or functional bypass) 
                                            on a component as a resolution to resource conflicts. */
} OMX_RESOURCECONCEALMENTTYPE;


/** @ingroup metadata */
typedef enum OMX_METADATACHARSETTYPE {
    OMX_MetadataCharsetUnknown = 0,
    OMX_MetadataCharsetASCII,
    OMX_MetadataCharsetBinary,
    OMX_MetadataCharsetCodePage1252,
    OMX_MetadataCharsetUTF8,
    OMX_MetadataCharsetJavaConformantUTF8,
    OMX_MetadataCharsetUTF7,
    OMX_MetadataCharsetImapUTF7,
    OMX_MetadataCharsetUTF16LE, 
    OMX_MetadataCharsetUTF16BE,
    OMX_MetadataCharsetGB12345,
    OMX_MetadataCharsetHZGB2312,
    OMX_MetadataCharsetGB2312,
    OMX_MetadataCharsetGB18030,
    OMX_MetadataCharsetGBK,
    OMX_MetadataCharsetBig5,
    OMX_MetadataCharsetISO88591,
    OMX_MetadataCharsetISO88592,
    OMX_MetadataCharsetISO88593,
    OMX_MetadataCharsetISO88594,
    OMX_MetadataCharsetISO88595,
    OMX_MetadataCharsetISO88596,
    OMX_MetadataCharsetISO88597,
    OMX_MetadataCharsetISO88598,
    OMX_MetadataCharsetISO88599,
    OMX_MetadataCharsetISO885910,
    OMX_MetadataCharsetISO885913,
    OMX_MetadataCharsetISO885914,
    OMX_MetadataCharsetISO885915,
    OMX_MetadataCharsetShiftJIS,
    OMX_MetadataCharsetISO2022JP,
    OMX_MetadataCharsetISO2022JP1,
    OMX_MetadataCharsetISOEUCJP,
    OMX_MetadataCharsetSMS7Bit,
    OMX_MetadataCharsetKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_MetadataCharsetVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_MetadataCharsetTypeMax= 0x7FFFFFFF
} OMX_METADATACHARSETTYPE;

/** @ingroup metadata */
typedef enum OMX_METADATASCOPETYPE
{
    OMX_MetadataScopeAllLevels,
    OMX_MetadataScopeTopLevel,
    OMX_MetadataScopePortLevel,
    OMX_MetadataScopeNodeLevel,
    OMX_MetadataScopeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_MetadataScopeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_MetadataScopeTypeMax = 0x7fffffff
} OMX_METADATASCOPETYPE;

/** @ingroup metadata */
typedef enum OMX_METADATASEARCHMODETYPE
{
    OMX_MetadataSearchValueSizeByIndex,
    OMX_MetadataSearchItemByIndex,
    OMX_MetadataSearchNextItemByKey,
    OMX_MetadataSearchKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_MetadataSearchVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_MetadataSearchTypeMax = 0x7fffffff
} OMX_METADATASEARCHMODETYPE;
/** @ingroup metadata */
typedef struct OMX_CONFIG_METADATAITEMCOUNTTYPE
{
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_METADATASCOPETYPE eScopeMode;
    OMX_U32 nScopeSpecifier;
    OMX_U32 nMetadataItemCount;
} OMX_CONFIG_METADATAITEMCOUNTTYPE;

/** @ingroup metadata */
typedef struct OMX_CONFIG_METADATAITEMTYPE
{
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_METADATASCOPETYPE eScopeMode;
    OMX_U32 nScopeSpecifier;
    OMX_U32 nMetadataItemIndex;  
    OMX_METADATASEARCHMODETYPE eSearchMode;
    OMX_METADATACHARSETTYPE eKeyCharset;
    OMX_U8 nKeySizeUsed;
    OMX_U8 nKey[128];
    OMX_METADATACHARSETTYPE eValueCharset;
    OMX_STRING sLanguageCountry;
    OMX_U32 nValueMaxSize;
    OMX_U32 nValueSizeUsed;
    OMX_U8 nValue[1];
} OMX_CONFIG_METADATAITEMTYPE;

/* @ingroup metadata */
typedef struct OMX_CONFIG_CONTAINERNODECOUNTTYPE
{
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_BOOL bAllKeys;
    OMX_U32 nParentNodeID;
    OMX_U32 nNumNodes;
} OMX_CONFIG_CONTAINERNODECOUNTTYPE;

/** @ingroup metadata */
typedef struct OMX_CONFIG_CONTAINERNODEIDTYPE
{
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_BOOL bAllKeys;
    OMX_U32 nParentNodeID;
    OMX_U32 nNodeIndex; 
    OMX_U32 nNodeID; 
    OMX_STRING cNodeName;
    OMX_BOOL bIsLeafType;
} OMX_CONFIG_CONTAINERNODEIDTYPE;

/** @ingroup metadata */
typedef struct OMX_PARAM_METADATAFILTERTYPE 
{ 
    OMX_U32 nSize; 
    OMX_VERSIONTYPE nVersion; 
    OMX_BOOL bAllKeys;	/* if true then this structure refers to all keys and 
                         * the three key fields below are ignored */
    OMX_METADATACHARSETTYPE eKeyCharset;
    OMX_U32 nKeySizeUsed; 
    OMX_U8   nKey [128]; 
    OMX_U32 nLanguageCountrySizeUsed;
    OMX_U8 nLanguageCountry[128];
    OMX_BOOL bEnabled;	/* if true then key is part of filter (e.g. 
                         * retained for query later). If false then
                         * key is not part of filter */
} OMX_PARAM_METADATAFILTERTYPE; 

/** The OMX_HANDLETYPE structure defines the component handle.  The component 
 *  handle is used to access all of the component's public methods and also
 *  contains pointers to the component's private data area.  The component
 *  handle is initialized by the OMX core (with help from the component)
 *  during the process of loading the component.  After the component is
 *  successfully loaded, the application can safely access any of the
 *  component's public functions (although some may return an error because
 *  the state is inappropriate for the access).
 * 
 *  @ingroup comp
 */
typedef struct OMX_COMPONENTTYPE
{
    /** The size of this structure, in bytes.  It is the responsibility
        of the allocator of this structure to fill in this value.  Since
        this structure is allocated by the GetHandle function, this
        function will fill in this value. */
    OMX_U32 nSize;

    /** nVersion is the version of the OMX specification that the structure 
        is built against.  It is the responsibility of the creator of this 
        structure to initialize this value and every user of this structure 
        should verify that it knows how to use the exact version of 
        this structure found herein. */
    OMX_VERSIONTYPE nVersion;

    /** pComponentPrivate is a pointer to the component private data area.  
        This member is allocated and initialized by the component when the 
        component is first loaded.  The application should not access this 
        data area. */
    OMX_PTR pComponentPrivate;

    /** pApplicationPrivate is a pointer that is a parameter to the 
        OMX_GetHandle method, and contains an application private value 
        provided by the IL client.  This application private data is 
        returned to the IL Client by OMX in all callbacks */
    OMX_PTR pApplicationPrivate;

    /** refer to OMX_GetComponentVersion in OMX_core.h or the OMX IL 
        specification for details on the GetComponentVersion method.
     */
    OMX_ERRORTYPE (*GetComponentVersion)(
            OMX_IN  OMX_HANDLETYPE hComponent,
            OMX_OUT OMX_STRING pComponentName,
            OMX_OUT OMX_VERSIONTYPE* pComponentVersion,
            OMX_OUT OMX_VERSIONTYPE* pSpecVersion,
            OMX_OUT OMX_UUIDTYPE* pComponentUUID);

    /** refer to OMX_SendCommand in OMX_core.h or the OMX IL 
        specification for details on the SendCommand method.
     */
    OMX_ERRORTYPE (*SendCommand)(
            OMX_IN  OMX_HANDLETYPE hComponent,
            OMX_IN  OMX_COMMANDTYPE Cmd,
            OMX_IN  OMX_U32 nParam1,
            OMX_IN  OMX_PTR pCmdData);

    /** refer to OMX_GetParameter in OMX_core.h or the OMX IL 
        specification for details on the GetParameter method.
     */
    OMX_ERRORTYPE (*GetParameter)(
            OMX_IN  OMX_HANDLETYPE hComponent, 
            OMX_IN  OMX_INDEXTYPE nParamIndex,  
            OMX_INOUT OMX_PTR pComponentParameterStructure);


    /** refer to OMX_SetParameter in OMX_core.h or the OMX IL 
        specification for details on the SetParameter method.
     */
    OMX_ERRORTYPE (*SetParameter)(
            OMX_IN  OMX_HANDLETYPE hComponent, 
            OMX_IN  OMX_INDEXTYPE nIndex,
            OMX_IN  OMX_PTR pComponentParameterStructure);


    /** refer to OMX_GetConfig in OMX_core.h or the OMX IL 
        specification for details on the GetConfig method.
     */
    OMX_ERRORTYPE (*GetConfig)(
            OMX_IN  OMX_HANDLETYPE hComponent,
            OMX_IN  OMX_INDEXTYPE nIndex, 
            OMX_INOUT OMX_PTR pComponentConfigStructure);


    /** refer to OMX_SetConfig in OMX_core.h or the OMX IL 
        specification for details on the SetConfig method.
     */
    OMX_ERRORTYPE (*SetConfig)(
            OMX_IN  OMX_HANDLETYPE hComponent,
            OMX_IN  OMX_INDEXTYPE nIndex, 
            OMX_IN  OMX_PTR pComponentConfigStructure);


    /** refer to OMX_GetExtensionIndex in OMX_core.h or the OMX IL 
        specification for details on the GetExtensionIndex method.
     */
    OMX_ERRORTYPE (*GetExtensionIndex)(
            OMX_IN  OMX_HANDLETYPE hComponent,
            OMX_IN  OMX_STRING cParameterName,
            OMX_OUT OMX_INDEXTYPE* pIndexType);


    /** refer to OMX_GetState in OMX_core.h or the OMX IL 
        specification for details on the GetState method.
     */
    OMX_ERRORTYPE (*GetState)(
            OMX_IN  OMX_HANDLETYPE hComponent,
            OMX_OUT OMX_STATETYPE* pState);

    
    /** The ComponentTunnelRequest method will interact with another OMX
        component to determine if tunneling is possible and to setup the
        tunneling.  The return codes for this method can be used to 
        determine if tunneling is not possible, or if tunneling is not
        supported.  
        
        Base profile components (i.e. non-interop) do not support this
        method and should return OMX_ErrorNotImplemented 

        The interop profile component MUST support tunneling to another 
        interop profile component with a compatible port parameters.  
        A component may also support proprietary communication.
        
        If proprietary communication is supported the negotiation of 
        proprietary communication is done outside of OMX in a vendor 
        specific way. It is only required that the proper result be 
        returned and the details of how the setup is done is left 
        to the component implementation.  
    
        When this method is invoked when nPort in an output port, the
        component will:
        1.  Populate the pTunnelSetup structure with the output port's 
            requirements and constraints for the tunnel.

        When this method is invoked when nPort in an input port, the
        component will:
        1.  Query the necessary parameters from the output port to 
            determine if the ports are compatible for tunneling
        2.  If the ports are compatible, the component should store
            the tunnel step provided by the output port
        3.  Determine which port (either input or output) is the buffer
            supplier, and call OMX_SetParameter on the output port to
            indicate this selection.
        
        The component will return from this call within 5 msec.
    
        @param [in] hComp
            Handle of the component to be accessed.  This is the component
            handle returned by the call to the OMX_GetHandle method.
        @param [in] nPort
            nPort is used to select the port on the component to be used
            for tunneling.
        @param [in] hTunneledComp
            Handle of the component to tunnel with.  This is the component 
            handle returned by the call to the OMX_GetHandle method.  When
            this parameter is 0x0 the component should setup the port for
            communication with the application / IL Client.
        @param [in] nPortOutput
            nPortOutput is used indicate the port the component should
            tunnel with.
        @param [in] pTunnelSetup
            Pointer to the tunnel setup structure.  When nPort is an output port
            the component should populate the fields of this structure.  When
            When nPort is an input port the component should review the setup
            provided by the component with the output port.
        @return OMX_ERRORTYPE
            If the command successfully executes, the return code will be
            OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
        @ingroup tun
    */

    OMX_ERRORTYPE (*ComponentTunnelRequest)(
        OMX_IN  OMX_HANDLETYPE hComp,
        OMX_IN  OMX_U32 nPort,
        OMX_IN  OMX_HANDLETYPE hTunneledComp,
        OMX_IN  OMX_U32 nTunneledPort,
        OMX_INOUT  OMX_TUNNELSETUPTYPE* pTunnelSetup); 

    /** refer to OMX_UseBuffer in OMX_core.h or the OMX IL 
        specification for details on the UseBuffer method.
        @ingroup buf
     */
    OMX_ERRORTYPE (*UseBuffer)(
            OMX_IN OMX_HANDLETYPE hComponent,
            OMX_INOUT OMX_BUFFERHEADERTYPE** ppBufferHdr,
            OMX_IN OMX_U32 nPortIndex,
            OMX_IN OMX_PTR pAppPrivate,
            OMX_IN OMX_U32 nSizeBytes,
            OMX_IN OMX_U8* pBuffer);

    /** refer to OMX_AllocateBuffer in OMX_core.h or the OMX IL 
        specification for details on the AllocateBuffer method.
        @ingroup buf
     */
    OMX_ERRORTYPE (*AllocateBuffer)(
            OMX_IN OMX_HANDLETYPE hComponent,
            OMX_INOUT OMX_BUFFERHEADERTYPE** ppBuffer,
            OMX_IN OMX_U32 nPortIndex,
            OMX_IN OMX_PTR pAppPrivate,
            OMX_IN OMX_U32 nSizeBytes);

    /** refer to OMX_FreeBuffer in OMX_core.h or the OMX IL 
        specification for details on the FreeBuffer method.
        @ingroup buf
     */
    OMX_ERRORTYPE (*FreeBuffer)(
            OMX_IN  OMX_HANDLETYPE hComponent,
            OMX_IN  OMX_U32 nPortIndex,
            OMX_IN  OMX_BUFFERHEADERTYPE* pBuffer);

    /** refer to OMX_EmptyThisBuffer in OMX_core.h or the OMX IL 
        specification for details on the EmptyThisBuffer method.
        @ingroup buf
     */
    OMX_ERRORTYPE (*EmptyThisBuffer)(
            OMX_IN  OMX_HANDLETYPE hComponent,
            OMX_IN  OMX_BUFFERHEADERTYPE* pBuffer);

    /** refer to OMX_FillThisBuffer in OMX_core.h or the OMX IL 
        specification for details on the FillThisBuffer method.
        @ingroup buf
     */
    OMX_ERRORTYPE (*FillThisBuffer)(
            OMX_IN  OMX_HANDLETYPE hComponent,
            OMX_IN  OMX_BUFFERHEADERTYPE* pBuffer);

    /** The SetCallbacks method is used by the core to specify the callback
        structure from the application to the component.  This is a blocking
        call.  The component will return from this call within 5 msec.
        @param [in] hComponent
            Handle of the component to be accessed.  This is the component
            handle returned by the call to the GetHandle function.
        @param [in] pCallbacks
            pointer to an OMX_CALLBACKTYPE structure used to provide the 
            callback information to the component
        @param [in] pAppData
            pointer to an application defined value.  It is anticipated that 
            the application will pass a pointer to a data structure or a "this
            pointer" in this area to allow the callback (in the application)
            to determine the context of the call
        @return OMX_ERRORTYPE
            If the command successfully executes, the return code will be
            OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
     */
    OMX_ERRORTYPE (*SetCallbacks)(
            OMX_IN  OMX_HANDLETYPE hComponent,
            OMX_IN  OMX_CALLBACKTYPE* pCallbacks, 
            OMX_IN  OMX_PTR pAppData);

    /** ComponentDeInit method is used to deinitialize the component
        providing a means to free any resources allocated at component
        initialization.  NOTE:  After this call the component handle is
        not valid for further use.
        @param [in] hComponent
            Handle of the component to be accessed.  This is the component
            handle returned by the call to the GetHandle function.
        @return OMX_ERRORTYPE
            If the command successfully executes, the return code will be
            OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
     */
    OMX_ERRORTYPE (*ComponentDeInit)(
            OMX_IN  OMX_HANDLETYPE hComponent);

    /** @ingroup buf */
    OMX_ERRORTYPE (*UseEGLImage)(
            OMX_IN OMX_HANDLETYPE hComponent,
            OMX_INOUT OMX_BUFFERHEADERTYPE** ppBufferHdr,
            OMX_IN OMX_U32 nPortIndex,
            OMX_IN OMX_PTR pAppPrivate,
            OMX_IN void* eglImage);

    OMX_ERRORTYPE (*ComponentRoleEnum)(
        OMX_IN OMX_HANDLETYPE hComponent,
		OMX_OUT OMX_U8 *cRole,
		OMX_IN OMX_U32 nIndex);

} OMX_COMPONENTTYPE;

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif
/* File EOF */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   /*
 * Copyright (c) 2008 The Khronos Group Inc. 
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject
 * to the following conditions: 
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software. 
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
 *
 */

/** OMX_Core.h - OpenMax IL version 1.1.2
 *  The OMX_Core header file contains the definitions used by both the
 *  application and the component to access common items.
 */

#ifndef OMX_Core_h
#define OMX_Core_h

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#if !defined(OMX_SKIP64BIT) && !defined(_VIDEOCORE)
  /* The Videocore compiler doesn't enforce 64 bit alignment on 64 bit variables,
   * which is almost equivalent to OMX_SKIP64BIT.
   * Annoyingly struct OMX_BUFFERHEADERTYPE doesn't do the sensible thing
   * and add padding fields or similar to make it the same for all compilers,
   * so all clients need to define this.
   * Warn if this isn't set, as the GPU will not interpret your buffers correctly,
   * or vice versa.
   */
  #warning OMX_SKIP64BIT is not defined - this will be incompatible with the VC GPU code.
#endif

/* Each OMX header shall include all required header files to allow the
 *  header to compile without errors.  The includes below are required
 *  for this header file to compile successfully 
 */

#include "OMX_Index.h"


/** The OMX_COMMANDTYPE enumeration is used to specify the action in the
 *  OMX_SendCommand macro.  
 *  @ingroup core
 */
typedef enum OMX_COMMANDTYPE
{
    OMX_CommandStateSet,    /**< Change the component state */
    OMX_CommandFlush,       /**< Flush the data queue(s) of a component */
    OMX_CommandPortDisable, /**< Disable a port on a component. */
    OMX_CommandPortEnable,  /**< Enable a port on a component. */
    OMX_CommandMarkBuffer,  /**< Mark a component/buffer for observation */
    OMX_CommandKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_CommandVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_CommandMax = 0X7FFFFFFF
} OMX_COMMANDTYPE;



/** The OMX_STATETYPE enumeration is used to indicate or change the component
 *  state.  This enumeration reflects the current state of the component when
 *  used with the OMX_GetState macro or becomes the parameter in a state change
 *  command when used with the OMX_SendCommand macro.
 *
 *  The component will be in the Loaded state after the component is initially
 *  loaded into memory.  In the Loaded state, the component is not allowed to
 *  allocate or hold resources other than to build it's internal parameter
 *  and configuration tables.  The application will send one or more
 *  SetParameters/GetParameters and SetConfig/GetConfig commands to the
 *  component and the component will record each of these parameter and
 *  configuration changes for use later.  When the application sends the
 *  Idle command, the component will acquire the resources needed for the
 *  specified configuration and will transition to the idle state if the
 *  allocation is successful.  If the component cannot successfully
 *  transition to the idle state for any reason, the state of the component
 *  shall be fully rolled back to the Loaded state (e.g. all allocated 
 *  resources shall be released).  When the component receives the command
 *  to go to the Executing state, it shall begin processing buffers by
 *  sending all input buffers it holds to the application.  While
 *  the component is in the Idle state, the application may also send the
 *  Pause command.  If the component receives the pause command while in the
 *  Idle state, the component shall send all input buffers it holds to the 
 *  application, but shall not begin processing buffers.  This will allow the
 *  application to prefill buffers.
 * 
 *  @ingroup comp
 */

typedef enum OMX_STATETYPE
{
    OMX_StateInvalid,      /**< component has detected that it's internal data 
                                structures are corrupted to the point that
                                it cannot determine it's state properly */
    OMX_StateLoaded,      /**< component has been loaded but has not completed
                                initialization.  The OMX_SetParameter macro
                                and the OMX_GetParameter macro are the only 
                                valid macros allowed to be sent to the 
                                component in this state. */
    OMX_StateIdle,        /**< component initialization has been completed
                                successfully and the component is ready to
                                to start. */
    OMX_StateExecuting,   /**< component has accepted the start command and
                                is processing data (if data is available) */
    OMX_StatePause,       /**< component has received pause command */
    OMX_StateWaitForResources, /**< component is waiting for resources, either after 
                                preemption or before it gets the resources requested.
                                See specification for complete details. */
    OMX_StateKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_StateVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_StateMax = 0X7FFFFFFF
} OMX_STATETYPE;

/** The OMX_ERRORTYPE enumeration defines the standard OMX Errors.  These 
 *  errors should cover most of the common failure cases.  However, 
 *  vendors are free to add additional error messages of their own as 
 *  long as they follow these rules:
 *  1.  Vendor error messages shall be in the range of 0x90000000 to
 *      0x9000FFFF.
 *  2.  Vendor error messages shall be defined in a header file provided
 *      with the component.  No error messages are allowed that are
 *      not defined.
 */
typedef enum OMX_ERRORTYPE
{
  OMX_ErrorNone = 0,

  /** There were insufficient resources to perform the requested operation */
  OMX_ErrorInsufficientResources = (OMX_S32) 0x80001000,

  /** There was an error, but the cause of the error could not be determined */
  OMX_ErrorUndefined = (OMX_S32) 0x80001001,

  /** The component name string was not valid */
  OMX_ErrorInvalidComponentName = (OMX_S32) 0x80001002,

  /** No component with the specified name string was found */
  OMX_ErrorComponentNotFound = (OMX_S32) 0x80001003,

  /** The component specified did not have a "OMX_ComponentInit" or
      "OMX_ComponentDeInit entry point */
  OMX_ErrorInvalidComponent = (OMX_S32) 0x80001004,

  /** One or more parameters were not valid */
  OMX_ErrorBadParameter = (OMX_S32) 0x80001005,

  /** The requested function is not implemented */
  OMX_ErrorNotImplemented = (OMX_S32) 0x80001006,

  /** The buffer was emptied before the next buffer was ready */
  OMX_ErrorUnderflow = (OMX_S32) 0x80001007,

  /** The buffer was not available when it was needed */
  OMX_ErrorOverflow = (OMX_S32) 0x80001008,

  /** The hardware failed to respond as expected */
  OMX_ErrorHardware = (OMX_S32) 0x80001009,

  /** The component is in the state OMX_StateInvalid */
  OMX_ErrorInvalidState = (OMX_S32) 0x8000100A,

  /** Stream is found to be corrupt */
  OMX_ErrorStreamCorrupt = (OMX_S32) 0x8000100B,

  /** Ports being connected are not compatible */
  OMX_ErrorPortsNotCompatible = (OMX_S32) 0x8000100C,

  /** Resources allocated to an idle component have been
      lost resulting in the component returning to the loaded state */
  OMX_ErrorResourcesLost = (OMX_S32) 0x8000100D,

  /** No more indicies can be enumerated */
  OMX_ErrorNoMore = (OMX_S32) 0x8000100E,

  /** The component detected a version mismatch */
  OMX_ErrorVersionMismatch = (OMX_S32) 0x8000100F,

  /** The component is not ready to return data at this time */
  OMX_ErrorNotReady = (OMX_S32) 0x80001010,

  /** There was a timeout that occurred */
  OMX_ErrorTimeout = (OMX_S32) 0x80001011,

  /** This error occurs when trying to transition into the state you are already in */
  OMX_ErrorSameState = (OMX_S32) 0x80001012,

  /** Resources allocated to an executing or paused component have been 
      preempted, causing the component to return to the idle state */
  OMX_ErrorResourcesPreempted = (OMX_S32) 0x80001013, 

  /** A non-supplier port sends this error to the IL client (via the EventHandler callback) 
      during the allocation of buffers (on a transition from the LOADED to the IDLE state or
      on a port restart) when it deems that it has waited an unusually long time for the supplier 
      to send it an allocated buffer via a UseBuffer call. */
  OMX_ErrorPortUnresponsiveDuringAllocation = (OMX_S32) 0x80001014,

  /** A non-supplier port sends this error to the IL client (via the EventHandler callback) 
      during the deallocation of buffers (on a transition from the IDLE to LOADED state or 
      on a port stop) when it deems that it has waited an unusually long time for the supplier 
      to request the deallocation of a buffer header via a FreeBuffer call. */
  OMX_ErrorPortUnresponsiveDuringDeallocation = (OMX_S32) 0x80001015,

  /** A supplier port sends this error to the IL client (via the EventHandler callback) 
      during the stopping of a port (either on a transition from the IDLE to LOADED 
      state or a port stop) when it deems that it has waited an unusually long time for 
      the non-supplier to return a buffer via an EmptyThisBuffer or FillThisBuffer call. */
  OMX_ErrorPortUnresponsiveDuringStop = (OMX_S32) 0x80001016,

  /** Attempting a state transtion that is not allowed */
  OMX_ErrorIncorrectStateTransition = (OMX_S32) 0x80001017,

  /* Attempting a command that is not allowed during the present state. */
  OMX_ErrorIncorrectStateOperation = (OMX_S32) 0x80001018, 

  /** The values encapsulated in the parameter or config structure are not supported. */
  OMX_ErrorUnsupportedSetting = (OMX_S32) 0x80001019,

  /** The parameter or config indicated by the given index is not supported. */
  OMX_ErrorUnsupportedIndex = (OMX_S32) 0x8000101A,

  /** The port index supplied is incorrect. */
  OMX_ErrorBadPortIndex = (OMX_S32) 0x8000101B,

  /** The port has lost one or more of its buffers and it thus unpopulated. */
  OMX_ErrorPortUnpopulated = (OMX_S32) 0x8000101C,

  /** Component suspended due to temporary loss of resources */
  OMX_ErrorComponentSuspended = (OMX_S32) 0x8000101D,

  /** Component suspended due to an inability to acquire dynamic resources */
  OMX_ErrorDynamicResourcesUnavailable = (OMX_S32) 0x8000101E,

  /** When the macroblock error reporting is enabled the component returns new error 
  for every frame that has errors */
  OMX_ErrorMbErrorsInFrame = (OMX_S32) 0x8000101F,

  /** A component reports this error when it cannot parse or determine the format of an input stream. */
  OMX_ErrorFormatNotDetected = (OMX_S32) 0x80001020, 

  /** The content open operation failed. */
  OMX_ErrorContentPipeOpenFailed = (OMX_S32) 0x80001021,

  /** The content creation operation failed. */
  OMX_ErrorContentPipeCreationFailed = (OMX_S32) 0x80001022,

  /** Separate table information is being used */
  OMX_ErrorSeperateTablesUsed = (OMX_S32) 0x80001023,

  /** Tunneling is unsupported by the component*/
  OMX_ErrorTunnelingUnsupported = (OMX_S32) 0x80001024,

  OMX_ErrorKhronosExtensions = (OMX_S32)0x8F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
  OMX_ErrorVendorStartUnused = (OMX_S32)0x90000000, /**< Reserved region for introducing Vendor Extensions */

  /** Disk Full error */
  OMX_ErrorDiskFull = (OMX_S32) 0x90000001,
 
  /** Max file size is reached */
  OMX_ErrorMaxFileSize = (OMX_S32) 0x90000002,

  /** Unauthorised to play a DRM protected file */
  OMX_ErrorDrmUnauthorised = (OMX_S32) 0x90000003,

  /** The DRM protected file has expired */
  OMX_ErrorDrmExpired = (OMX_S32) 0x90000004,

  /** Some other DRM library error */
  OMX_ErrorDrmGeneral = (OMX_S32) 0x90000005,

  OMX_ErrorMax = 0x7FFFFFFF
} OMX_ERRORTYPE;

/** @ingroup core */
typedef OMX_ERRORTYPE (* OMX_COMPONENTINITTYPE)(OMX_IN  OMX_HANDLETYPE hComponent);

/** @ingroup core */
typedef struct OMX_COMPONENTREGISTERTYPE
{
  const char          * pName;       /* Component name, 128 byte limit (including '\0') applies */
  OMX_COMPONENTINITTYPE pInitialize; /* Component instance initialization function */
} OMX_COMPONENTREGISTERTYPE;

/** @ingroup core */
extern OMX_COMPONENTREGISTERTYPE OMX_ComponentRegistered[];

/** @ingroup rpm */
typedef struct OMX_PRIORITYMGMTTYPE {
 OMX_U32 nSize;             /**< size of the structure in bytes */
 OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
 OMX_U32 nGroupPriority;            /**< Priority of the component group */
 OMX_U32 nGroupID;                  /**< ID of the component group */
} OMX_PRIORITYMGMTTYPE;

/* Component name and Role names are limited to 128 characters including the terminating '\0'. */
#define OMX_MAX_STRINGNAME_SIZE 128

/** @ingroup comp */
typedef struct OMX_PARAM_COMPONENTROLETYPE {
    OMX_U32 nSize;              /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
    OMX_U8 cRole[OMX_MAX_STRINGNAME_SIZE];  /**< name of standard component which defines component role */
} OMX_PARAM_COMPONENTROLETYPE;

/** End of Stream Buffer Flag: 
  *
  * A component sets EOS when it has no more data to emit on a particular 
  * output port. Thus an output port shall set EOS on the last buffer it 
  * emits. A component's determination of when an output port should 
  * cease sending data is implemenation specific.
  * @ingroup buf
  */

#define OMX_BUFFERFLAG_EOS 0x00000001 

/** Start Time Buffer Flag: 
 *
 * The source of a stream (e.g. a demux component) sets the STARTTIME
 * flag on the buffer that contains the starting timestamp for the
 * stream. The starting timestamp corresponds to the first data that
 * should be displayed at startup or after a seek.
 * The first timestamp of the stream is not necessarily the start time.
 * For instance, in the case of a seek to a particular video frame, 
 * the target frame may be an interframe. Thus the first buffer of 
 * the stream will be the intra-frame preceding the target frame and
 * the starttime will occur with the target frame (with any other
 * required frames required to reconstruct the target intervening).
 *
 * The STARTTIME flag is directly associated with the buffer's 
 * timestamp ' thus its association to buffer data and its 
 * propagation is identical to the timestamp's.
 *
 * When a Sync Component client receives a buffer with the 
 * STARTTIME flag it shall perform a SetConfig on its sync port 
 * using OMX_ConfigTimeClientStartTime and passing the buffer's
 * timestamp.
 * 
 * @ingroup buf
 */

#define OMX_BUFFERFLAG_STARTTIME 0x00000002

 

/** Decode Only Buffer Flag: 
 *
 * The source of a stream (e.g. a demux component) sets the DECODEONLY
 * flag on any buffer that should shall be decoded but should not be
 * displayed. This flag is used, for instance, when a source seeks to 
 * a target interframe that requires the decode of frames preceding the 
 * target to facilitate the target's reconstruction. In this case the 
 * source would emit the frames preceding the target downstream 
 * but mark them as decode only.
 *
 * The DECODEONLY is associated with buffer data and propagated in a 
 * manner identical to the buffer timestamp.
 *
 * A component that renders data should ignore all buffers with 
 * the DECODEONLY flag set.
 * 
 * @ingroup buf
 */

#define OMX_BUFFERFLAG_DECODEONLY 0x00000004


/* Data Corrupt Flag: This flag is set when the IL client believes the data in the associated buffer is corrupt 
 * @ingroup buf
 */

#define OMX_BUFFERFLAG_DATACORRUPT 0x00000008

/* End of Frame: The buffer contains exactly one end of frame and no data
 *  occurs after the end of frame. This flag is an optional hint. The absence
 *  of this flag does not imply the absence of an end of frame within the buffer. 
 * @ingroup buf
*/
#define OMX_BUFFERFLAG_ENDOFFRAME 0x00000010

/* Sync Frame Flag: This flag is set when the buffer content contains a coded sync frame ' 
 *  a frame that has no dependency on any other frame information 
 *  @ingroup buf
 */
#define OMX_BUFFERFLAG_SYNCFRAME 0x00000020

/* Extra data present flag: there is extra data appended to the data stream
 * residing in the buffer 
 * @ingroup buf  
 */
#define OMX_BUFFERFLAG_EXTRADATA 0x00000040

/** Codec Config Buffer Flag: 
* OMX_BUFFERFLAG_CODECCONFIG is an optional flag that is set by an
* output port when all bytes in the buffer form part or all of a set of
* codec specific configuration data.  Examples include SPS/PPS nal units
* for OMX_VIDEO_CodingAVC or AudioSpecificConfig data for
* OMX_AUDIO_CodingAAC.  Any component that for a given stream sets 
* OMX_BUFFERFLAG_CODECCONFIG shall not mix codec configuration bytes
* with frame data in the same buffer, and shall send all buffers
* containing codec configuration bytes before any buffers containing
* frame data that those configurations bytes describe.
* If the stream format for a particular codec has a frame specific
* header at the start of each frame, for example OMX_AUDIO_CodingMP3 or
* OMX_AUDIO_CodingAAC in ADTS mode, then these shall be presented as
* normal without setting OMX_BUFFERFLAG_CODECCONFIG.
 * @ingroup buf
 */
#define OMX_BUFFERFLAG_CODECCONFIG 0x00000080



/** @ingroup buf */
typedef struct OMX_BUFFERHEADERTYPE
{
    OMX_U32 nSize;              /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
    OMX_U8* pBuffer;            /**< Pointer to actual block of memory 
                                     that is acting as the buffer */
    OMX_U32 nAllocLen;          /**< size of the buffer allocated, in bytes */
    OMX_U32 nFilledLen;         /**< number of bytes currently in the 
                                     buffer */
    OMX_U32 nOffset;            /**< start offset of valid data in bytes from
                                     the start of the buffer */
    OMX_PTR pAppPrivate;        /**< pointer to any data the application
                                     wants to associate with this buffer */
    OMX_PTR pPlatformPrivate;   /**< pointer to any data the platform
                                     wants to associate with this buffer */ 
    OMX_PTR pInputPortPrivate;  /**< pointer to any data the input port
                                     wants to associate with this buffer */
    OMX_PTR pOutputPortPrivate; /**< pointer to any data the output port
                                     wants to associate with this buffer */
    OMX_HANDLETYPE hMarkTargetComponent; /**< The component that will generate a 
                                              mark event upon processing this buffer. */
    OMX_PTR pMarkData;          /**< Application specific data associated with 
                                     the mark sent on a mark event to disambiguate 
                                     this mark from others. */
    OMX_U32 nTickCount;         /**< Optional entry that the component and
                                     application can update with a tick count
                                     when they access the component.  This
                                     value should be in microseconds.  Since
                                     this is a value relative to an arbitrary
                                     starting point, this value cannot be used 
                                     to determine absolute time.  This is an
                                     optional entry and not all components
                                     will update it.*/
 OMX_TICKS nTimeStamp;          /**< Timestamp corresponding to the sample 
                                     starting at the first logical sample 
                                     boundary in the buffer. Timestamps of 
                                     successive samples within the buffer may
                                     be inferred by adding the duration of the 
                                     of the preceding buffer to the timestamp
                                     of the preceding buffer.*/
  OMX_U32     nFlags;           /**< buffer specific flags */
  OMX_U32 nOutputPortIndex;     /**< The index of the output port (if any) using 
                                     this buffer */
  OMX_U32 nInputPortIndex;      /**< The index of the input port (if any) using
                                     this buffer */
} OMX_BUFFERHEADERTYPE;

/** The OMX_EXTRADATATYPE enumeration is used to define the 
 * possible extra data payload types.
 * NB: this enum is binary backwards compatible with the previous
 * OMX_EXTRADATA_QUANT define.  This should be replaced with
 * OMX_ExtraDataQuantization.
 */
typedef enum OMX_EXTRADATATYPE
{
   OMX_ExtraDataNone = 0,                       /**< Indicates that no more extra data sections follow */        
   OMX_ExtraDataQuantization,                   /**< The data payload contains quantization data */
   OMX_ExtraDataKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
   OMX_ExtraDataVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */

   OMX_ExtraDataSequenceGap,                    /**< Indicates a gap in sequence numbers, data is uint32_t 
                                                     saying how many frames were lost */
   OMX_ExtraDataDecodeOnlyUntil,                /**< Indicates a timestamp until which all data should be
                                                     decoded only, and the first packets after should generate
                                                     a client start time flag.  data is int32_t of seek time
                                                     in milliseconds */

   OMX_ExtraDataMax = 0x7FFFFFFF
} OMX_EXTRADATATYPE;


typedef struct OMX_OTHER_EXTRADATATYPE  {
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;               
    OMX_U32 nPortIndex;
    OMX_EXTRADATATYPE eType;       /* Extra Data type */
    OMX_U32 nDataSize;   /* Size of the supporting data to follow */
    OMX_U8  data[1];     /* Supporting data hint  */
} OMX_OTHER_EXTRADATATYPE;

/** @ingroup comp */
typedef struct OMX_PORT_PARAM_TYPE {
    OMX_U32 nSize;              /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
    OMX_U32 nPorts;             /**< The number of ports for this component */
    OMX_U32 nStartPortNumber;   /** first port number for this type of port */
} OMX_PORT_PARAM_TYPE; 

/** @ingroup comp */
typedef enum OMX_EVENTTYPE
{
    OMX_EventCmdComplete,         /**< component has sucessfully completed a command */
    OMX_EventError,               /**< component has detected an error condition */
    OMX_EventMark,                /**< component has detected a buffer mark */
    OMX_EventPortSettingsChanged, /**< component is reported a port settings change */
    OMX_EventBufferFlag,          /**< component has detected an EOS */ 
    OMX_EventResourcesAcquired,   /**< component has been granted resources and is
                                       automatically starting the state change from
                                       OMX_StateWaitForResources to OMX_StateIdle. */
   OMX_EventComponentResumed,     /**< Component resumed due to reacquisition of resources */
   OMX_EventDynamicResourcesAvailable, /**< Component has acquired previously unavailable dynamic resources */
   OMX_EventPortFormatDetected,      /**< Component has detected a supported format. */
   OMX_EventKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
   OMX_EventVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
   OMX_EventParamOrConfigChanged,   /* Should be added to the main spec as part of IL416c */
   OMX_EventMax = 0x7FFFFFFF
} OMX_EVENTTYPE;

typedef struct OMX_CALLBACKTYPE
{
    /** The EventHandler method is used to notify the application when an
        event of interest occurs.  Events are defined in the OMX_EVENTTYPE
        enumeration.  Please see that enumeration for details of what will
        be returned for each type of event. Callbacks should not return
        an error to the component, so if an error occurs, the application 
        shall handle it internally.  This is a blocking call.

        The application should return from this call within 5 msec to avoid
        blocking the component for an excessively long period of time.

        @param hComponent
            handle of the component to access.  This is the component
            handle returned by the call to the GetHandle function.
        @param pAppData
            pointer to an application defined value that was provided in the 
            pAppData parameter to the OMX_GetHandle method for the component.
            This application defined value is provided so that the application 
            can have a component specific context when receiving the callback.
        @param eEvent
            Event that the component wants to notify the application about.
        @param nData1
            nData will be the OMX_ERRORTYPE for an error event and will be 
            an OMX_COMMANDTYPE for a command complete event and OMX_INDEXTYPE for a OMX_PortSettingsChanged event.
         @param nData2
            nData2 will hold further information related to the event. Can be OMX_STATETYPE for
            a OMX_CommandStateSet command or port index for a OMX_PortSettingsChanged event.
            Default value is 0 if not used. )
        @param pEventData
            Pointer to additional event-specific data (see spec for meaning).
      */

   OMX_ERRORTYPE (*EventHandler)(
        OMX_IN OMX_HANDLETYPE hComponent,
        OMX_IN OMX_PTR pAppData,
        OMX_IN OMX_EVENTTYPE eEvent,
        OMX_IN OMX_U32 nData1,
        OMX_IN OMX_U32 nData2,
        OMX_IN OMX_PTR pEventData);

    /** The EmptyBufferDone method is used to return emptied buffers from an
        input port back to the application for reuse.  This is a blocking call 
        so the application should not attempt to refill the buffers during this
        call, but should queue them and refill them in another thread.  There
        is no error return, so the application shall handle any errors generated
        internally.  
        
        The application should return from this call within 5 msec.
        
        @param hComponent
            handle of the component to access.  This is the component
            handle returned by the call to the GetHandle function.
        @param pAppData
            pointer to an application defined value that was provided in the 
            pAppData parameter to the OMX_GetHandle method for the component.
            This application defined value is provided so that the application 
            can have a component specific context when receiving the callback.
        @param pBuffer
            pointer to an OMX_BUFFERHEADERTYPE structure allocated with UseBuffer
            or AllocateBuffer indicating the buffer that was emptied.
        @ingroup buf
     */
    OMX_ERRORTYPE (*EmptyBufferDone)(
        OMX_IN OMX_HANDLETYPE hComponent,
        OMX_IN OMX_PTR pAppData,
        OMX_IN OMX_BUFFERHEADERTYPE* pBuffer);

    /** The FillBufferDone method is used to return filled buffers from an
        output port back to the application for emptying and then reuse.  
        This is a blocking call so the application should not attempt to 
        empty the buffers during this call, but should queue the buffers 
        and empty them in another thread.  There is no error return, so 
        the application shall handle any errors generated internally.  The 
        application shall also update the buffer header to indicate the
        number of bytes placed into the buffer.  

        The application should return from this call within 5 msec.
        
        @param hComponent
            handle of the component to access.  This is the component
            handle returned by the call to the GetHandle function.
        @param pAppData
            pointer to an application defined value that was provided in the 
            pAppData parameter to the OMX_GetHandle method for the component.
            This application defined value is provided so that the application 
            can have a component specific context when receiving the callback.
        @param pBuffer
            pointer to an OMX_BUFFERHEADERTYPE structure allocated with UseBuffer
            or AllocateBuffer indicating the buffer that was filled.
        @ingroup buf
     */
    OMX_ERRORTYPE (*FillBufferDone)(
        OMX_OUT OMX_HANDLETYPE hComponent,
        OMX_OUT OMX_PTR pAppData,
        OMX_OUT OMX_BUFFERHEADERTYPE* pBuffer);

} OMX_CALLBACKTYPE;

/** The OMX_BUFFERSUPPLIERTYPE enumeration is used to dictate port supplier
    preference when tunneling between two ports.
    @ingroup tun buf
*/
typedef enum OMX_BUFFERSUPPLIERTYPE
{
    OMX_BufferSupplyUnspecified = 0x0, /**< port supplying the buffers is unspecified,
                                              or don't care */
    OMX_BufferSupplyInput,             /**< input port supplies the buffers */
    OMX_BufferSupplyOutput,            /**< output port supplies the buffers */
    OMX_BufferSupplyKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_BufferSupplyVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_BufferSupplyMax = 0x7FFFFFFF
} OMX_BUFFERSUPPLIERTYPE;


/** buffer supplier parameter 
 * @ingroup tun
 */
typedef struct OMX_PARAM_BUFFERSUPPLIERTYPE {
    OMX_U32 nSize; /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
    OMX_U32 nPortIndex; /**< port that this structure applies to */
    OMX_BUFFERSUPPLIERTYPE eBufferSupplier; /**< buffer supplier */
} OMX_PARAM_BUFFERSUPPLIERTYPE;


/**< indicates that buffers received by an input port of a tunnel 
     may not modify the data in the buffers 
     @ingroup tun
 */
#define OMX_PORTTUNNELFLAG_READONLY 0x00000001 


/** The OMX_TUNNELSETUPTYPE structure is used to pass data from an output
    port to an input port as part the two ComponentTunnelRequest calls
    resulting from a OMX_SetupTunnel call from the IL Client. 
    @ingroup tun
 */   
typedef struct OMX_TUNNELSETUPTYPE
{
    OMX_U32 nTunnelFlags;             /**< bit flags for tunneling */
    OMX_BUFFERSUPPLIERTYPE eSupplier; /**< supplier preference */
} OMX_TUNNELSETUPTYPE; 

/* OMX Component headers is included to enable the core to use
   macros for functions into the component for OMX release 1.0.  
   Developers should not access any structures or data from within
   the component header directly */
/* TO BE REMOVED - #include <OMX_Component.h> */

/** GetComponentVersion will return information about the component.  
    This is a blocking call.  This macro will go directly from the
    application to the component (via a core macro).  The
    component will return from this call within 5 msec.
    @param [in] hComponent
        handle of component to execute the command
    @param [out] pComponentName
        pointer to an empty string of length 128 bytes.  The component 
        will write its name into this string.  The name will be 
        terminated by a single zero byte.  The name of a component will 
        be 127 bytes or less to leave room for the trailing zero byte.  
        An example of a valid component name is "OMX.ABC.ChannelMixer\0".
    @param [out] pComponentVersion
        pointer to an OMX Version structure that the component will fill 
        in.  The component will fill in a value that indicates the 
        component version.  NOTE: the component version is NOT the same 
        as the OMX Specification version (found in all structures).  The 
        component version is defined by the vendor of the component and 
        its value is entirely up to the component vendor.
    @param [out] pSpecVersion
        pointer to an OMX Version structure that the component will fill 
        in.  The SpecVersion is the version of the specification that the 
        component was built against.  Please note that this value may or 
        may not match the structure's version.  For example, if the 
        component was built against the 2.0 specification, but the 
        application (which creates the structure is built against the 
        1.0 specification the versions would be different.
    @param [out] pComponentUUID
        pointer to the UUID of the component which will be filled in by 
        the component.  The UUID is a unique identifier that is set at 
        RUN time for the component and is unique to each instantion of 
        the component.
    @return OMX_ERRORTYPE
        If the command successfully executes, the return code will be
        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
    @ingroup comp
 */
#define OMX_GetComponentVersion(                            \
        hComponent,                                         \
        pComponentName,                                     \
        pComponentVersion,                                  \
        pSpecVersion,                                       \
        pComponentUUID)                                     \
    ((OMX_COMPONENTTYPE*)hComponent)->GetComponentVersion(  \
        hComponent,                                         \
        pComponentName,                                     \
        pComponentVersion,                                  \
        pSpecVersion,                                       \
        pComponentUUID)                 /* Macro End */


/** Send a command to the component.  This call is a non-blocking call.
    The component should check the parameters and then queue the command
    to the component thread to be executed.  The component thread shall 
    send the EventHandler() callback at the conclusion of the command. 
    This macro will go directly from the application to the component (via
    a core macro).  The component will return from this call within 5 msec.
    
    When the command is "OMX_CommandStateSet" the component will queue a
    state transition to the new state idenfied in nParam.
    
    When the command is "OMX_CommandFlush", to flush a port's buffer queues,
    the command will force the component to return all buffers NOT CURRENTLY 
    BEING PROCESSED to the application, in the order in which the buffers 
    were received.
    
    When the command is "OMX_CommandPortDisable" or 
    "OMX_CommandPortEnable", the component's port (given by the value of
    nParam) will be stopped or restarted. 
    
    When the command "OMX_CommandMarkBuffer" is used to mark a buffer, the
    pCmdData will point to a OMX_MARKTYPE structure containing the component
    handle of the component to examine the buffer chain for the mark.  nParam1
    contains the index of the port on which the buffer mark is applied.

    Specification text for more details. 
    
    @param [in] hComponent
        handle of component to execute the command
    @param [in] Cmd
        Command for the component to execute
    @param [in] nParam
        Parameter for the command to be executed.  When Cmd has the value 
        OMX_CommandStateSet, value is a member of OMX_STATETYPE.  When Cmd has 
        the value OMX_CommandFlush, value of nParam indicates which port(s) 
        to flush. -1 is used to flush all ports a single port index will 
        only flush that port.  When Cmd has the value "OMX_CommandPortDisable"
        or "OMX_CommandPortEnable", the component's port is given by 
        the value of nParam.  When Cmd has the value "OMX_CommandMarkBuffer"
        the components pot is given by the value of nParam.
    @param [in] pCmdData
        Parameter pointing to the OMX_MARKTYPE structure when Cmd has the value
        "OMX_CommandMarkBuffer".     
    @return OMX_ERRORTYPE
        If the command successfully executes, the return code will be
        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
    @ingroup comp
 */
#define OMX_SendCommand(                                    \
         hComponent,                                        \
         Cmd,                                               \
         nParam,                                            \
         pCmdData)                                          \
     ((OMX_COMPONENTTYPE*)hComponent)->SendCommand(         \
         hComponent,                                        \
         Cmd,                                               \
         nParam,                                            \
         pCmdData)                          /* Macro End */


/** The OMX_GetParameter macro will get one of the current parameter 
    settings from the component.  This macro cannot only be invoked when 
    the component is in the OMX_StateInvalid state.  The nParamIndex
    parameter is used to indicate which structure is being requested from
    the component.  The application shall allocate the correct structure 
    and shall fill in the structure size and version information before 
    invoking this macro.  When the parameter applies to a port, the
    caller shall fill in the appropriate nPortIndex value indicating the
    port on which the parameter applies. If the component has not had 
    any settings changed, then the component should return a set of 
    valid DEFAULT  parameters for the component.  This is a blocking 
    call.  
    
    The component should return from this call within 20 msec.
    
    @param [in] hComponent
        Handle of the component to be accessed.  This is the component
        handle returned by the call to the OMX_GetHandle function.
    @param [in] nParamIndex
        Index of the structure to be filled.  This value is from the
        OMX_INDEXTYPE enumeration.
    @param [in,out] pComponentParameterStructure
        Pointer to application allocated structure to be filled by the 
        component.
    @return OMX_ERRORTYPE
        If the command successfully executes, the return code will be
        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
    @ingroup comp
 */
#define OMX_GetParameter(                                   \
        hComponent,                                         \
        nParamIndex,                                        \
        pComponentParameterStructure)                        \
    ((OMX_COMPONENTTYPE*)hComponent)->GetParameter(         \
        hComponent,                                         \
        nParamIndex,                                        \
        pComponentParameterStructure)    /* Macro End */


/** The OMX_SetParameter macro will send an initialization parameter
    structure to a component.  Each structure shall be sent one at a time,
    in a separate invocation of the macro.  This macro can only be
    invoked when the component is in the OMX_StateLoaded state, or the
    port is disabled (when the parameter applies to a port). The 
    nParamIndex parameter is used to indicate which structure is being
    passed to the component.  The application shall allocate the 
    correct structure and shall fill in the structure size and version 
    information (as well as the actual data) before invoking this macro.
    The application is free to dispose of this structure after the call
    as the component is required to copy any data it shall retain.  This 
    is a blocking call.  
    
    The component should return from this call within 20 msec.
    
    @param [in] hComponent
        Handle of the component to be accessed.  This is the component
        handle returned by the call to the OMX_GetHandle function.
    @param [in] nIndex
        Index of the structure to be sent.  This value is from the
        OMX_INDEXTYPE enumeration.
    @param [in] pComponentParameterStructure
        pointer to application allocated structure to be used for
        initialization by the component.
    @return OMX_ERRORTYPE
        If the command successfully executes, the return code will be
        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
    @ingroup comp
 */
#define OMX_SetParameter(                                   \
        hComponent,                                         \
        nParamIndex,                                        \
        pComponentParameterStructure)                        \
    ((OMX_COMPONENTTYPE*)hComponent)->SetParameter(         \
        hComponent,                                         \
        nParamIndex,                                        \
        pComponentParameterStructure)    /* Macro End */


/** The OMX_GetConfig macro will get one of the configuration structures 
    from a component.  This macro can be invoked anytime after the 
    component has been loaded.  The nParamIndex call parameter is used to 
    indicate which structure is being requested from the component.  The 
    application shall allocate the correct structure and shall fill in the 
    structure size and version information before invoking this macro.  
    If the component has not had this configuration parameter sent before, 
    then the component should return a set of valid DEFAULT values for the 
    component.  This is a blocking call.  
    
    The component should return from this call within 5 msec.
    
    @param [in] hComponent
        Handle of the component to be accessed.  This is the component
        handle returned by the call to the OMX_GetHandle function.
    @param [in] nIndex
        Index of the structure to be filled.  This value is from the
        OMX_INDEXTYPE enumeration.
    @param [in,out] pComponentConfigStructure
        pointer to application allocated structure to be filled by the 
        component.
    @return OMX_ERRORTYPE
        If the command successfully executes, the return code will be
        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
    @ingroup comp
*/        
#define OMX_GetConfig(                                      \
        hComponent,                                         \
        nConfigIndex,                                       \
        pComponentConfigStructure)                           \
    ((OMX_COMPONENTTYPE*)hComponent)->GetConfig(            \
        hComponent,                                         \
        nConfigIndex,                                       \
        pComponentConfigStructure)       /* Macro End */


/** The OMX_SetConfig macro will send one of the configuration 
    structures to a component.  Each structure shall be sent one at a time,
    each in a separate invocation of the macro.  This macro can be invoked 
    anytime after the component has been loaded.  The application shall 
    allocate the correct structure and shall fill in the structure size 
    and version information (as well as the actual data) before invoking 
    this macro.  The application is free to dispose of this structure after 
    the call as the component is required to copy any data it shall retain.  
    This is a blocking call.  
    
    The component should return from this call within 5 msec.
    
    @param [in] hComponent
        Handle of the component to be accessed.  This is the component
        handle returned by the call to the OMX_GetHandle function.
    @param [in] nConfigIndex
        Index of the structure to be sent.  This value is from the
        OMX_INDEXTYPE enumeration above.
    @param [in] pComponentConfigStructure
        pointer to application allocated structure to be used for
        initialization by the component.
    @return OMX_ERRORTYPE
        If the command successfully executes, the return code will be
        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
    @ingroup comp
 */
#define OMX_SetConfig(                                      \
        hComponent,                                         \
        nConfigIndex,                                       \
        pComponentConfigStructure)                           \
    ((OMX_COMPONENTTYPE*)hComponent)->SetConfig(            \
        hComponent,                                         \
        nConfigIndex,                                       \
        pComponentConfigStructure)       /* Macro End */


/** The OMX_GetExtensionIndex macro will invoke a component to translate 
    a vendor specific configuration or parameter string into an OMX 
    structure index.  There is no requirement for the vendor to support 
    this command for the indexes already found in the OMX_INDEXTYPE 
    enumeration (this is done to save space in small components).  The 
    component shall support all vendor supplied extension indexes not found
    in the master OMX_INDEXTYPE enumeration.  This is a blocking call.  
    
    The component should return from this call within 5 msec.
    
    @param [in] hComponent
        Handle of the component to be accessed.  This is the component
        handle returned by the call to the GetHandle function.
    @param [in] cParameterName
        OMX_STRING that shall be less than 128 characters long including
        the trailing null byte.  This is the string that will get 
        translated by the component into a configuration index.
    @param [out] pIndexType
        a pointer to a OMX_INDEXTYPE to receive the index value.
    @return OMX_ERRORTYPE
        If the command successfully executes, the return code will be
        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
    @ingroup comp
 */
#define OMX_GetExtensionIndex(                              \
        hComponent,                                         \
        cParameterName,                                     \
        pIndexType)                                         \
    ((OMX_COMPONENTTYPE*)hComponent)->GetExtensionIndex(    \
        hComponent,                                         \
        cParameterName,                                     \
        pIndexType)                     /* Macro End */


/** The OMX_GetState macro will invoke the component to get the current 
    state of the component and place the state value into the location
    pointed to by pState.  
    
    The component should return from this call within 5 msec.
    
    @param [in] hComponent
        Handle of the component to be accessed.  This is the component
        handle returned by the call to the OMX_GetHandle function.
    @param [out] pState
        pointer to the location to receive the state.  The value returned
        is one of the OMX_STATETYPE members 
    @return OMX_ERRORTYPE
        If the command successfully executes, the return code will be
        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
    @ingroup comp
 */
#define OMX_GetState(                                       \
        hComponent,                                         \
        pState)                                             \
    ((OMX_COMPONENTTYPE*)hComponent)->GetState(             \
        hComponent,                                         \
        pState)                         /* Macro End */


/** The OMX_UseBuffer macro will request that the component use
    a buffer (and allocate its own buffer header) already allocated 
    by another component, or by the IL Client. This is a blocking 
    call.
    
    The component should return from this call within 20 msec.
    
    @param [in] hComponent
        Handle of the component to be accessed.  This is the component
        handle returned by the call to the OMX_GetHandle function.
    @param [out] ppBuffer
        pointer to an OMX_BUFFERHEADERTYPE structure used to receive the 
        pointer to the buffer header
    @return OMX_ERRORTYPE
        If the command successfully executes, the return code will be
        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
    @ingroup comp buf
 */

#define OMX_UseBuffer(                                      \
           hComponent,                                      \
           ppBufferHdr,                                     \
           nPortIndex,                                      \
           pAppPrivate,                                     \
           nSizeBytes,                                      \
           pBuffer)                                         \
    ((OMX_COMPONENTTYPE*)hComponent)->UseBuffer(            \
           hComponent,                                      \
           ppBufferHdr,                                     \
           nPortIndex,                                      \
           pAppPrivate,                                     \
           nSizeBytes,                                      \
           pBuffer)


/** The OMX_AllocateBuffer macro will request that the component allocate 
    a new buffer and buffer header.  The component will allocate the 
    buffer and the buffer header and return a pointer to the buffer 
    header.  This is a blocking call.
    
    The component should return from this call within 5 msec.
    
    @param [in] hComponent
        Handle of the component to be accessed.  This is the component
        handle returned by the call to the OMX_GetHandle function.
    @param [out] ppBuffer
        pointer to an OMX_BUFFERHEADERTYPE structure used to receive 
        the pointer to the buffer header
    @param [in] nPortIndex
        nPortIndex is used to select the port on the component the buffer will
        be used with.  The port can be found by using the nPortIndex
        value as an index into the Port Definition array of the component.
    @param [in] pAppPrivate
        pAppPrivate is used to initialize the pAppPrivate member of the 
        buffer header structure.
    @param [in] nSizeBytes
        size of the buffer to allocate.  Used when bAllocateNew is true.
    @return OMX_ERRORTYPE
        If the command successfully executes, the return code will be
        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
    @ingroup comp buf
 */    
#define OMX_AllocateBuffer(                                 \
        hComponent,                                         \
        ppBuffer,                                           \
        nPortIndex,                                         \
        pAppPrivate,                                        \
        nSizeBytes)                                         \
    ((OMX_COMPONENTTYPE*)hComponent)->AllocateBuffer(       \
        hComponent,                                         \
        ppBuffer,                                           \
        nPortIndex,                                         \
        pAppPrivate,                                        \
        nSizeBytes)                     /* Macro End */


/** The OMX_FreeBuffer macro will release a buffer header from the component
    which was allocated using either OMX_AllocateBuffer or OMX_UseBuffer. If  
    the component allocated the buffer (see the OMX_UseBuffer macro) then 
    the component shall free the buffer and buffer header. This is a 
    blocking call. 
    
    The component should return from this call within 20 msec.
    
    @param [in] hComponent
        Handle of the component to be accessed.  This is the component
        handle returned by the call to the OMX_GetHandle function.
    @param [in] nPortIndex
        nPortIndex is used to select the port on the component the buffer will
        be used with.
    @param [in] pBuffer
        pointer to an OMX_BUFFERHEADERTYPE structure allocated with UseBuffer
        or AllocateBuffer.
    @return OMX_ERRORTYPE
        If the command successfully executes, the return code will be
        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
    @ingroup comp buf
 */
#define OMX_FreeBuffer(                                     \
        hComponent,                                         \
        nPortIndex,                                         \
        pBuffer)                                            \
    ((OMX_COMPONENTTYPE*)hComponent)->FreeBuffer(           \
        hComponent,                                         \
        nPortIndex,                                         \
        pBuffer)                        /* Macro End */


/** The OMX_EmptyThisBuffer macro will send a buffer full of data to an 
    input port of a component.  The buffer will be emptied by the component
    and returned to the application via the EmptyBufferDone call back.
    This is a non-blocking call in that the component will record the buffer
    and return immediately and then empty the buffer, later, at the proper 
    time.  As expected, this macro may be invoked only while the component 
    is in the OMX_StateExecuting.  If nPortIndex does not specify an input
    port, the component shall return an error.  
    
    The component should return from this call within 5 msec.
    
    @param [in] hComponent
        Handle of the component to be accessed.  This is the component
        handle returned by the call to the OMX_GetHandle function.
    @param [in] pBuffer
        pointer to an OMX_BUFFERHEADERTYPE structure allocated with UseBuffer
        or AllocateBuffer.
    @return OMX_ERRORTYPE
        If the command successfully executes, the return code will be
        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
    @ingroup comp buf
 */
#define OMX_EmptyThisBuffer(                                \
        hComponent,                                         \
        pBuffer)                                            \
    ((OMX_COMPONENTTYPE*)hComponent)->EmptyThisBuffer(      \
        hComponent,                                         \
        pBuffer)                        /* Macro End */


/** The OMX_FillThisBuffer macro will send an empty buffer to an 
    output port of a component.  The buffer will be filled by the component
    and returned to the application via the FillBufferDone call back.
    This is a non-blocking call in that the component will record the buffer
    and return immediately and then fill the buffer, later, at the proper 
    time.  As expected, this macro may be invoked only while the component 
    is in the OMX_ExecutingState.  If nPortIndex does not specify an output
    port, the component shall return an error.  
    
    The component should return from this call within 5 msec.
    
    @param [in] hComponent
        Handle of the component to be accessed.  This is the component
        handle returned by the call to the OMX_GetHandle function.
    @param [in] pBuffer
        pointer to an OMX_BUFFERHEADERTYPE structure allocated with UseBuffer
        or AllocateBuffer.
    @return OMX_ERRORTYPE
        If the command successfully executes, the return code will be
        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
    @ingroup comp buf
 */
#define OMX_FillThisBuffer(                                 \
        hComponent,                                         \
        pBuffer)                                            \
    ((OMX_COMPONENTTYPE*)hComponent)->FillThisBuffer(       \
        hComponent,                                         \
        pBuffer)                        /* Macro End */



/** The OMX_UseEGLImage macro will request that the component use
    a EGLImage provided by EGL (and allocate its own buffer header)
    This is a blocking call.
    
    The component should return from this call within 20 msec.
    
    @param [in] hComponent
        Handle of the component to be accessed.  This is the component
        handle returned by the call to the OMX_GetHandle function.
    @param [out] ppBuffer
        pointer to an OMX_BUFFERHEADERTYPE structure used to receive the 
        pointer to the buffer header.  Note that the memory location used
        for this buffer is NOT visible to the IL Client.
    @param [in] nPortIndex
        nPortIndex is used to select the port on the component the buffer will
        be used with.  The port can be found by using the nPortIndex
        value as an index into the Port Definition array of the component.
    @param [in] pAppPrivate
        pAppPrivate is used to initialize the pAppPrivate member of the 
        buffer header structure.
    @param [in] eglImage
        eglImage contains the handle of the EGLImage to use as a buffer on the
        specified port.  The component is expected to validate properties of 
        the EGLImage against the configuration of the port to ensure the component
        can use the EGLImage as a buffer.          
    @return OMX_ERRORTYPE
        If the command successfully executes, the return code will be
        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
    @ingroup comp buf
 */
#define OMX_UseEGLImage(                                    \
           hComponent,                                      \
           ppBufferHdr,                                     \
           nPortIndex,                                      \
           pAppPrivate,                                     \
           eglImage)                                        \
    ((OMX_COMPONENTTYPE*)hComponent)->UseEGLImage(          \
           hComponent,                                      \
           ppBufferHdr,                                     \
           nPortIndex,                                      \
           pAppPrivate,                                     \
           eglImage)

/** The OMX_Init method is used to initialize the OMX core.  It shall be the
    first call made into OMX and it should only be executed one time without
    an interviening OMX_Deinit call.  
    
    The core should return from this call within 20 msec.

    @return OMX_ERRORTYPE
        If the command successfully executes, the return code will be
        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
    @ingroup core
 */
OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_Init(void);


/** The OMX_Deinit method is used to deinitialize the OMX core.  It shall be 
    the last call made into OMX. In the event that the core determines that 
    thare are components loaded when this call is made, the core may return 
    with an error rather than try to unload the components.
        
    The core should return from this call within 20 msec.
    
    @return OMX_ERRORTYPE
        If the command successfully executes, the return code will be
        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
    @ingroup core
 */
OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_Deinit(void);


/** The OMX_ComponentNameEnum method will enumerate through all the names of
    recognised valid components in the system. This function is provided
    as a means to detect all the components in the system run-time. There is
    no strict ordering to the enumeration order of component names, although
    each name will only be enumerated once.  If the OMX core supports run-time
    installation of new components, it is only requried to detect newly
    installed components when the first call to enumerate component names
    is made (i.e. when nIndex is 0x0).
    
    The core should return from this call in 20 msec.
    
    @param [out] cComponentName
        pointer to a null terminated string with the component name.  The
        names of the components are strings less than 127 bytes in length
        plus the trailing null for a maximum size of 128 bytes.  An example 
        of a valid component name is "OMX.TI.AUDIO.DSP.MIXER\0".  Names are 
        assigned by the vendor, but shall start with "OMX." and then have 
        the Vendor designation next.
    @param [in] nNameLength
        number of characters in the cComponentName string.  With all 
        component name strings restricted to less than 128 characters 
        (including the trailing null) it is recomended that the caller
        provide a input string for the cComponentName of 128 characters.
    @param [in] nIndex
        number containing the enumeration index for the component. 
        Multiple calls to OMX_ComponentNameEnum with increasing values
        of nIndex will enumerate through the component names in the
        system until OMX_ErrorNoMore is returned.  The value of nIndex
        is 0 to (N-1), where N is the number of valid installed components
        in the system.
    @return OMX_ERRORTYPE
        If the command successfully executes, the return code will be
        OMX_ErrorNone.  When the value of nIndex exceeds the number of 
        components in the system minus 1, OMX_ErrorNoMore will be
        returned. Otherwise the appropriate OMX error will be returned.
    @ingroup core
 */
OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_ComponentNameEnum(
    OMX_OUT OMX_STRING cComponentName,
    OMX_IN  OMX_U32 nNameLength,
    OMX_IN  OMX_U32 nIndex);


/** The OMX_GetHandle method will locate the component specified by the
    component name given, load that component into memory and then invoke
    the component's methods to create an instance of the component.  
    
    The core should return from this call within 20 msec.
    
    @param [out] pHandle
        pointer to an OMX_HANDLETYPE pointer to be filled in by this method.
    @param [in] cComponentName
        pointer to a null terminated string with the component name.  The
        names of the components are strings less than 127 bytes in length
        plus the trailing null for a maximum size of 128 bytes.  An example 
        of a valid component name is "OMX.TI.AUDIO.DSP.MIXER\0".  Names are 
        assigned by the vendor, but shall start with "OMX." and then have 
        the Vendor designation next.
    @param [in] pAppData
        pointer to an application defined value that will be returned
        during callbacks so that the application can identify the source
        of the callback.
    @param [in] pCallBacks
        pointer to a OMX_CALLBACKTYPE structure that will be passed to the
        component to initialize it with.  
    @return OMX_ERRORTYPE
        If the command successfully executes, the return code will be
        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
    @ingroup core
 */
OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_GetHandle(
    OMX_OUT OMX_HANDLETYPE* pHandle, 
    OMX_IN  OMX_STRING cComponentName,
    OMX_IN  OMX_PTR pAppData,
    OMX_IN  OMX_CALLBACKTYPE* pCallBacks);


/** The OMX_FreeHandle method will free a handle allocated by the OMX_GetHandle 
    method.  If the component reference count goes to zero, the component will
    be unloaded from memory.  
    
    The core should return from this call within 20 msec when the component is 
    in the OMX_StateLoaded state.

    @param [in] hComponent
        Handle of the component to be accessed.  This is the component
        handle returned by the call to the GetHandle function.
    @return OMX_ERRORTYPE
        If the command successfully executes, the return code will be
        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
    @ingroup core
 */
OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_FreeHandle(
    OMX_IN  OMX_HANDLETYPE hComponent);



/** The OMX_SetupTunnel method will handle the necessary calls to the components
    to setup the specified tunnel the two components.  NOTE: This is
    an actual method (not a #define macro).  This method will make calls into
    the component ComponentTunnelRequest method to do the actual tunnel 
    connection.  

    The ComponentTunnelRequest method on both components will be called. 
    This method shall not be called unless the component is in the 
    OMX_StateLoaded state except when the ports used for the tunnel are
    disabled. In this case, the component may be in the OMX_StateExecuting,
    OMX_StatePause, or OMX_StateIdle states. 

    The core should return from this call within 20 msec.
    
    @param [in] hOutput
        Handle of the component to be accessed.  Also this is the handle
        of the component whose port, specified in the nPortOutput parameter
        will be used the source for the tunnel. This is the component handle
        returned by the call to the OMX_GetHandle function.  There is a 
        requirement that hOutput be the source for the data when
        tunelling (i.e. nPortOutput is an output port).  If 0x0, the component
        specified in hInput will have it's port specified in nPortInput
        setup for communication with the application / IL client.
    @param [in] nPortOutput
        nPortOutput is used to select the source port on component to be
        used in the tunnel. 
    @param [in] hInput
        This is the component to setup the tunnel with. This is the handle
        of the component whose port, specified in the nPortInput parameter
        will be used the destination for the tunnel. This is the component handle
        returned by the call to the OMX_GetHandle function.  There is a 
        requirement that hInput be the destination for the data when
        tunelling (i.e. nPortInut is an input port).   If 0x0, the component
        specified in hOutput will have it's port specified in nPortPOutput
        setup for communication with the application / IL client.
    @param [in] nPortInput
        nPortInput is used to select the destination port on component to be
        used in the tunnel.
    @return OMX_ERRORTYPE
        If the command successfully executes, the return code will be
        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
        When OMX_ErrorNotImplemented is returned, one or both components is 
        a non-interop component and does not support tunneling.
        
        On failure, the ports of both components are setup for communication
        with the application / IL Client.
    @ingroup core tun
 */
OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_SetupTunnel(
    OMX_IN  OMX_HANDLETYPE hOutput,
    OMX_IN  OMX_U32 nPortOutput,
    OMX_IN  OMX_HANDLETYPE hInput,
    OMX_IN  OMX_U32 nPortInput);
    
/** @ingroup cp */
OMX_API OMX_ERRORTYPE   OMX_GetContentPipe(
    OMX_OUT OMX_HANDLETYPE *hPipe,
    OMX_IN OMX_STRING szURI);

/** The OMX_GetComponentsOfRole method will return the number of components that support the given
    role and (if the compNames field is non-NULL) the names of those components. The call will fail if 
    an insufficiently sized array of names is supplied. To ensure the array is sufficiently sized the
    client should:
        * first call this function with the compNames field NULL to determine the number of component names
        * second call this function with the compNames field pointing to an array of names allocated 
          according to the number returned by the first call.

    The core should return from this call within 5 msec.
    
    @param [in] role
        This is generic standard component name consisting only of component class 
        name and the type within that class (e.g. 'audio_decoder.aac').
    @param [inout] pNumComps
        This is used both as input and output. 
 
        If compNames is NULL, the input is ignored and the output specifies how many components support
        the given role.
     
        If compNames is not NULL, on input it bounds the size of the input structure and 
        on output, it specifies the number of components string names listed within the compNames parameter.
    @param [inout] compNames
        If NULL this field is ignored. If non-NULL this points to an array of 128-byte strings which accepts 
        a list of the names of all physical components that implement the specified standard component name. 
        Each name is NULL terminated. numComps indicates the number of names.
    @ingroup core
 */
OMX_API OMX_ERRORTYPE OMX_GetComponentsOfRole ( 
	OMX_IN      OMX_STRING role,
    OMX_INOUT   OMX_U32 *pNumComps,
    OMX_INOUT   OMX_U8  **compNames);

/** The OMX_GetRolesOfComponent method will return the number of roles supported by the given
    component and (if the roles field is non-NULL) the names of those roles. The call will fail if 
    an insufficiently sized array of names is supplied. To ensure the array is sufficiently sized the
    client should:
        * first call this function with the roles field NULL to determine the number of role names
        * second call this function with the roles field pointing to an array of names allocated 
          according to the number returned by the first call.

    The core should return from this call within 5 msec.

    @param [in] compName
        This is the name of the component being queried about.
    @param [inout] pNumRoles
        This is used both as input and output. 
 
        If roles is NULL, the input is ignored and the output specifies how many roles the component supports.
     
        If compNames is not NULL, on input it bounds the size of the input structure and 
        on output, it specifies the number of roles string names listed within the roles parameter.
    @param [out] roles
        If NULL this field is ignored. If non-NULL this points to an array of 128-byte strings 
        which accepts a list of the names of all standard components roles implemented on the 
        specified component name. numComps indicates the number of names.
    @ingroup core
 */
OMX_API OMX_ERRORTYPE OMX_GetRolesOfComponent ( 
	OMX_IN      OMX_STRING compName, 
    OMX_INOUT   OMX_U32 *pNumRoles,
    OMX_OUT     OMX_U8 **roles);

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif
/* File EOF */

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            /* $Revision: 6810 $ on $Date:: 2008-10-29 14:31:37 +0000 #$ */

/*------------------------------------------------------------------------
 *
 * VGU 1.1 Reference Implementation
 * -------------------------------------
 *
 * Copyright (c) 2008 The Khronos Group Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and /or associated documentation files
 * (the "Materials "), to deal in the Materials without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Materials,
 * and to permit persons to whom the Materials are furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Materials.
 *
 * THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE MATERIALS OR
 * THE USE OR OTHER DEALINGS IN THE MATERIALS.
 *
 *//**
 * \file
 * \brief	VGU 1.1 API.
 *//*-------------------------------------------------------------------*/

#ifndef _VGU_H
#define _VGU_H

#ifdef __cplusplus
extern "C" {
#endif

#include "openvg.h"

#define VGU_VERSION_1_0 1
#define VGU_VERSION_1_1 2

#ifndef VGU_API_CALL
#	error VGU_API_CALL must be defined
#endif

#ifndef VGU_API_ENTRY
#   error VGU_API_ENTRY must be defined
#endif

#ifndef VGU_API_EXIT
#   error VGU_API_EXIT must be defined
#endif


typedef enum {
  VGU_NO_ERROR                                 = 0,
  VGU_BAD_HANDLE_ERROR                         = 0xF000,
  VGU_ILLEGAL_ARGUMENT_ERROR                   = 0xF001,
  VGU_OUT_OF_MEMORY_ERROR                      = 0xF002,
  VGU_PATH_CAPABILITY_ERROR                    = 0xF003,
  VGU_BAD_WARP_ERROR                           = 0xF004,

  VGU_ERROR_CODE_FORCE_SIZE                    = VG_MAX_ENUM
} VGUErrorCode;

typedef enum {
  VGU_ARC_OPEN                                 = 0xF100,
  VGU_ARC_CHORD                                = 0xF101,
  VGU_ARC_PIE                                  = 0xF102,

  VGU_ARC_TYPE_FORCE_SIZE                      = VG_MAX_ENUM
} VGUArcType;

VGU_API_CALL VGUErrorCode VGU_API_ENTRY vguLine(VGPath path,
                                  VGfloat x0, VGfloat y0,
                                  VGfloat x1, VGfloat y1) VGU_API_EXIT;

VGU_API_CALL VGUErrorCode VGU_API_ENTRY vguPolygon(VGPath path,
                                     const VGfloat * points, VGint count,
                                     VGboolean closed) VGU_API_EXIT;

VGU_API_CALL VGUErrorCode VGU_API_ENTRY vguRect(VGPath path,
                                  VGfloat x, VGfloat y,
                                  VGfloat width, VGfloat height) VGU_API_EXIT;

VGU_API_CALL VGUErrorCode VGU_API_ENTRY vguRoundRect(VGPath path,
                                       VGfloat x, VGfloat y,
                                       VGfloat width, VGfloat height,
                                       VGfloat arcWidth, VGfloat arcHeight) VGU_API_EXIT;

VGU_API_CALL VGUErrorCode VGU_API_ENTRY vguEllipse(VGPath path,
                                     VGfloat cx, VGfloat cy,
                                     VGfloat width, VGfloat height) VGU_API_EXIT;

VGU_API_CALL VGUErrorCode VGU_API_ENTRY vguArc(VGPath path,
                                 VGfloat x, VGfloat y,
                                 VGfloat width, VGfloat height,
                                 VGfloat startAngle, VGfloat angleExtent,
                                 VGUArcType arcType) VGU_API_EXIT;

VGU_API_CALL VGUErrorCode VGU_API_ENTRY vguComputeWarpQuadToSquare(VGfloat sx0, VGfloat sy0,
                                                     VGfloat sx1, VGfloat sy1,
                                                     VGfloat sx2, VGfloat sy2,
                                                     VGfloat sx3, VGfloat sy3,
                                                     VGfloat * matrix) VGU_API_EXIT;

VGU_API_CALL VGUErrorCode VGU_API_ENTRY vguComputeWarpSquareToQuad(VGfloat dx0, VGfloat dy0,
                                                     VGfloat dx1, VGfloat dy1,
                                                     VGfloat dx2, VGfloat dy2,
                                                     VGfloat dx3, VGfloat dy3,
                                                     VGfloat * matrix) VGU_API_EXIT;

VGU_API_CALL VGUErrorCode VGU_API_ENTRY vguComputeWarpQuadToQuad(VGfloat dx0, VGfloat dy0,
                                                   VGfloat dx1, VGfloat dy1,
                                                   VGfloat dx2, VGfloat dy2,
                                                   VGfloat dx3, VGfloat dy3,
                                                   VGfloat sx0, VGfloat sy0,
                                                   VGfloat sx1, VGfloat sy1,
                                                   VGfloat sx2, VGfloat sy2,
                                                   VGfloat sx3, VGfloat sy3,
                                                   VGfloat * matrix) VGU_API_EXIT;

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* #ifndef _VGU_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /**
 * Copyright (c) 2008 The Khronos Group Inc. 
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject
 * to the following conditions: 
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software. 
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
 */

/** 
 * @file OMX_Image.h - OpenMax IL version 1.1.2
 * The structures needed by Image components to exchange parameters and 
 * configuration data with the components.
 */
#ifndef OMX_Image_h
#define OMX_Image_h

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */


/**
 * Each OMX header must include all required header files to allow the 
 * header to compile without errors.  The includes below are required  
 * for this header file to compile successfully 
 */

#include "OMX_IVCommon.h"

/** @defgroup imaging OpenMAX IL Imaging Domain
 * @ingroup iv
 * Structures for OpenMAX IL Imaging domain
 * @{
 */

/** 
 * Enumeration used to define the possible image compression coding. 
 */
typedef enum OMX_IMAGE_CODINGTYPE {
    OMX_IMAGE_CodingUnused,      /**< Value when format is N/A */
    OMX_IMAGE_CodingAutoDetect,  /**< Auto detection of image format */
    OMX_IMAGE_CodingJPEG,        /**< JPEG/JFIF image format */
    OMX_IMAGE_CodingJPEG2K,      /**< JPEG 2000 image format */
    OMX_IMAGE_CodingEXIF,        /**< EXIF image format */
    OMX_IMAGE_CodingTIFF,        /**< TIFF image format */
    OMX_IMAGE_CodingGIF,         /**< Graphics image format */
    OMX_IMAGE_CodingPNG,         /**< PNG image format */
    OMX_IMAGE_CodingLZW,         /**< LZW image format */
    OMX_IMAGE_CodingBMP,         /**< Windows Bitmap format */
    OMX_IMAGE_CodingKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_IMAGE_CodingVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */

    OMX_IMAGE_CodingTGA,
    OMX_IMAGE_CodingPPM,

    OMX_IMAGE_CodingMax = 0x7FFFFFFF
} OMX_IMAGE_CODINGTYPE;


/**
 * Data structure used to define an image path. The number of image paths 
 * for input and output will vary by type of the image component.  
 * 
 *  Input (aka Source) : Zero Inputs, one Output,
 *  Splitter           : One Input, 2 or more Outputs,
 *  Processing Element : One Input, one output,
 *  Mixer              : 2 or more inputs, one output,
 *  Output (aka Sink)  : One Input, zero outputs.
 * 
 * The PortDefinition structure is used to define all of the parameters 
 * necessary for the compliant component to setup an input or an output  
 * image path.  If additional vendor specific data is required, it should  
 * be transmitted to the component using the CustomCommand function.   
 * Compliant components will prepopulate this structure with optimal  
 * values during the OMX_GetParameter() command.
 *
 * STRUCT MEMBERS:
 *  cMIMEType             : MIME type of data for the port
 *  pNativeRender         : Platform specific reference for a display if a 
 *                          sync, otherwise this field is 0
 *  nFrameWidth           : Width of frame to be used on port if 
 *                          uncompressed format is used.  Use 0 for 
 *                          unknown, don't care or variable
 *  nFrameHeight          : Height of frame to be used on port if 
 *                          uncompressed format is used. Use 0 for 
 *                          unknown, don't care or variable
 *  nStride               : Number of bytes per span of an image (i.e. 
 *                          indicates the number of bytes to get from
 *                          span N to span N+1, where negative stride 
 *                          indicates the image is bottom up
 *  nSliceHeight          : Height used when encoding in slices
 *  bFlagErrorConcealment : Turns on error concealment if it is supported by 
 *                          the OMX component
 *  eCompressionFormat    : Compression format used in this instance of  
 *                          the component. When OMX_IMAGE_CodingUnused is 
 *                          specified, eColorFormat is valid
 *  eColorFormat          : Decompressed format used by this component
 *  pNativeWindow         : Platform specific reference for a window object if a 
 *                          display sink , otherwise this field is 0x0. 
 */
typedef struct OMX_IMAGE_PORTDEFINITIONTYPE {
    OMX_STRING cMIMEType;
    OMX_NATIVE_DEVICETYPE pNativeRender;
    OMX_U32 nFrameWidth; 
    OMX_U32 nFrameHeight;
    OMX_S32 nStride;     
    OMX_U32 nSliceHeight;
    OMX_BOOL bFlagErrorConcealment;
    OMX_IMAGE_CODINGTYPE eCompressionFormat;
    OMX_COLOR_FORMATTYPE eColorFormat;
    OMX_NATIVE_WINDOWTYPE pNativeWindow;
} OMX_IMAGE_PORTDEFINITIONTYPE;


/**  
 * Port format parameter.  This structure is used to enumerate the various 
 * data input/output format supported by the port.
 * 
 * STRUCT MEMBERS:
 *  nSize              : Size of the structure in bytes
 *  nVersion           : OMX specification version information
 *  nPortIndex         : Indicates which port to set
 *  nIndex             : Indicates the enumeration index for the format from 
 *                       0x0 to N-1
 *  eCompressionFormat : Compression format used in this instance of the 
 *                       component. When OMX_IMAGE_CodingUnused is specified, 
 *                       eColorFormat is valid
 *  eColorFormat       : Decompressed format used by this component
 */
typedef struct OMX_IMAGE_PARAM_PORTFORMATTYPE {
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_U32 nPortIndex;
    OMX_U32 nIndex;
    OMX_IMAGE_CODINGTYPE eCompressionFormat;
    OMX_COLOR_FORMATTYPE eColorFormat;
} OMX_IMAGE_PARAM_PORTFORMATTYPE;


/** 
 * Flash control type 
 *
 * ENUMS
 *  Torch : Flash forced constantly on
 */
typedef enum OMX_IMAGE_FLASHCONTROLTYPE {
    OMX_IMAGE_FlashControlOn = 0,
    OMX_IMAGE_FlashControlOff,
    OMX_IMAGE_FlashControlAuto,
    OMX_IMAGE_FlashControlRedEyeReduction,
    OMX_IMAGE_FlashControlFillin,
    OMX_IMAGE_FlashControlTorch,
    OMX_IMAGE_FlashControlKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_IMAGE_FlashControlVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_IMAGE_FlashControlMax = 0x7FFFFFFF
} OMX_IMAGE_FLASHCONTROLTYPE;


/** 
 * Flash control configuration 
 *
 * STRUCT MEMBERS:
 *  nSize         : Size of the structure in bytes
 *  nVersion      : OMX specification version information
 *  nPortIndex    : Port that this structure applies to
 *  eFlashControl : Flash control type
 */
typedef struct OMX_IMAGE_PARAM_FLASHCONTROLTYPE {
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_U32 nPortIndex;
    OMX_IMAGE_FLASHCONTROLTYPE eFlashControl;
} OMX_IMAGE_PARAM_FLASHCONTROLTYPE;


/** 
 * Focus control type 
 */
typedef enum OMX_IMAGE_FOCUSCONTROLTYPE {
    OMX_IMAGE_FocusControlOn = 0,
    OMX_IMAGE_FocusControlOff,
    OMX_IMAGE_FocusControlAuto,
    OMX_IMAGE_FocusControlAutoLock,
    OMX_IMAGE_FocusControlKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_IMAGE_FocusControlVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_IMAGE_FocusControlHyperfocal,         /* Focus at the hyperfocal point of the lens. */
    OMX_IMAGE_FocusControlAutoMacro,          /* CF over a macro range (eg 0-50cm) */
    OMX_IMAGE_FocusControlAutoInfinity,       /* CF over distant range (eg 50cm to infinity) */
    OMX_IMAGE_FocusControlAutoLockMacro,      /* AF over a macro range (eg 0-50cm) */
    OMX_IMAGE_FocusControlAutoLockInfinity,   /* AF over distant range (eg 50cm to infinity) */
    OMX_IMAGE_FocusControlNearFixed,          /* Focus at a fixed near focus point - (50cm-1m) */
    OMX_IMAGE_FocusControlAutoNear,           /* CF over a near range (eg 0-200cm) */
    OMX_IMAGE_FocusControlAutoLockNear,       /* AF over a near range (eg 0-200cm) */
    OMX_IMAGE_FocusControlInfinityFixed,      /* Focus at infinity */
    OMX_IMAGE_FocusControlMacroFixed,         /* Focus at a macro distance */
    OMX_IMAGE_FocusControlAutoFast,           /* CF over a full range with fast response */
    OMX_IMAGE_FocusControlAutoMacroFast,      /* CF over a macro range (eg 0-50cm) with fast response */
    OMX_IMAGE_FocusControlAutoNearFast,       /* CF over a near range (eg 0-200cm) */
    OMX_IMAGE_FocusControlAutoInfinityFast,   /* CF over distant range (eg 50cm to infinity) with fast response */
    OMX_IMAGE_FocusControlCurrentFixed,       /* Stop the lens at the current position */
    OMX_IMAGE_FocusControlMax = 0x7FFFFFFF
} OMX_IMAGE_FOCUSCONTROLTYPE;

 
/** 
 * Focus control configuration 
 *
 * STRUCT MEMBERS:
 *  nSize           : Size of the structure in bytes
 *  nVersion        : OMX specification version information
 *  nPortIndex      : Port that this structure applies to
 *  eFocusControl   : Focus control
 *  nFocusSteps     : Focus can take on values from 0 mm to infinity. 
 *                    Interest is only in number of steps over this range.
 *  nFocusStepIndex : Current focus step index
 */
typedef struct OMX_IMAGE_CONFIG_FOCUSCONTROLTYPE {
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_U32 nPortIndex;
    OMX_IMAGE_FOCUSCONTROLTYPE eFocusControl;
    OMX_U32 nFocusSteps;
    OMX_U32 nFocusStepIndex;
} OMX_IMAGE_CONFIG_FOCUSCONTROLTYPE;


/** 
 * Q Factor for JPEG compression, which controls the tradeoff between image
 * quality and size.  Q Factor provides a more simple means of controlling
 * JPEG compression quality, without directly programming Quantization
 * tables for chroma and luma 
 *
 * STRUCT MEMBERS:
 *  nSize      : Size of the structure in bytes         
 *  nVersion   : OMX specification version information 
 *  nPortIndex : Port that this structure applies to 
 *  nQFactor   : JPEG Q factor value in the range of 1-100. A factor of 1 
 *               produces the smallest, worst quality images, and a factor 
 *               of 100 produces the largest, best quality images.  A 
 *               typical default is 75 for small good quality images               
 */
typedef struct OMX_IMAGE_PARAM_QFACTORTYPE {
    OMX_U32 nSize;            
    OMX_VERSIONTYPE nVersion; 
    OMX_U32 nPortIndex;       
    OMX_U32 nQFactor;                                        
} OMX_IMAGE_PARAM_QFACTORTYPE;

/** 
 * Quantization table type 
 */

typedef enum OMX_IMAGE_QUANTIZATIONTABLETYPE {
    OMX_IMAGE_QuantizationTableLuma = 0,
    OMX_IMAGE_QuantizationTableChroma,
    OMX_IMAGE_QuantizationTableChromaCb,
    OMX_IMAGE_QuantizationTableChromaCr,
    OMX_IMAGE_QuantizationTableKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_IMAGE_QuantizationTableVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_IMAGE_QuantizationTableMax = 0x7FFFFFFF
} OMX_IMAGE_QUANTIZATIONTABLETYPE;

/** 
 * JPEG quantization tables are used to determine DCT compression for
 * YUV data, as an alternative to specifying Q factor, providing exact 
 * control of compression 
 *
 * STRUCT MEMBERS:
 *  nSize                   : Size of the structure in bytes
 *  nVersion                : OMX specification version information 
 *  nPortIndex              : Port that this structure applies to
 *  eQuantizationTable      : Quantization table type
 *  nQuantizationMatrix[64] : JPEG quantization table of coefficients stored 
 *                            in increasing columns then by rows of data (i.e. 
 *                            row 1, ... row 8). Quantization values are in 
 *                            the range 0-255 and stored in linear order
 *                            (i.e. the component will zig-zag the 
 *                            quantization table data if required internally) 
 */
typedef struct OMX_IMAGE_PARAM_QUANTIZATIONTABLETYPE {
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_U32 nPortIndex;
    OMX_IMAGE_QUANTIZATIONTABLETYPE eQuantizationTable;
    OMX_U8 nQuantizationMatrix[64];
} OMX_IMAGE_PARAM_QUANTIZATIONTABLETYPE;


/** 
 * Huffman table type, the same Huffman table is applied for chroma and 
 * luma component 
 */
typedef enum OMX_IMAGE_HUFFMANTABLETYPE {
    OMX_IMAGE_HuffmanTableAC = 0,
    OMX_IMAGE_HuffmanTableDC,
    OMX_IMAGE_HuffmanTableACLuma,
    OMX_IMAGE_HuffmanTableACChroma,
    OMX_IMAGE_HuffmanTableDCLuma,
    OMX_IMAGE_HuffmanTableDCChroma,
    OMX_IMAGE_HuffmanTableKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_IMAGE_HuffmanTableVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_IMAGE_HuffmanTableMax = 0x7FFFFFFF
} OMX_IMAGE_HUFFMANTABLETYPE;

/** 
 * JPEG Huffman table 
 *
 * STRUCT MEMBERS:
 *  nSize                            : Size of the structure in bytes
 *  nVersion                         : OMX specification version information
 *  nPortIndex                       : Port that this structure applies to
 *  eHuffmanTable                    : Huffman table type
 *  nNumberOfHuffmanCodeOfLength[16] : 0-16, number of Huffman codes of each 
 *                                     possible length
 *  nHuffmanTable[256]               : 0-255, the size used for AC and DC 
 *                                     HuffmanTable are 16 and 162 
 */
typedef struct OMX_IMAGE_PARAM_HUFFMANTTABLETYPE {
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_U32 nPortIndex;
    OMX_IMAGE_HUFFMANTABLETYPE eHuffmanTable;
    OMX_U8 nNumberOfHuffmanCodeOfLength[16];
    OMX_U8 nHuffmanTable[256];
}OMX_IMAGE_PARAM_HUFFMANTTABLETYPE;

/** @} */
#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif
/* File EOF */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    /*
 * Copyright (c) 2008 The Khronos Group Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject
 * to the following conditions:
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

/** @file OMX_Index.h - OpenMax IL version 1.1.2
 *  The OMX_Index header file contains the definitions for both applications
 *  and components .
 */


#ifndef OMX_Index_h
#define OMX_Index_h

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */


/* Each OMX header must include all required header files to allow the
 *  header to compile without errors.  The includes below are required
 *  for this header file to compile successfully
 */
#include "OMX_Types.h"


/** The OMX_INDEXTYPE enumeration is used to select a structure when either
 *  getting or setting parameters and/or configuration data.  Each entry in
 *  this enumeration maps to an OMX specified structure.  When the
 *  OMX_GetParameter, OMX_SetParameter, OMX_GetConfig or OMX_SetConfig methods
 *  are used, the second parameter will always be an entry from this enumeration
 *  and the third entry will be the structure shown in the comments for the entry.
 *  For example, if the application is initializing a cropping function, the
 *  OMX_SetConfig command would have OMX_IndexConfigCommonInputCrop as the second parameter
 *  and would send a pointer to an initialized OMX_RECTTYPE structure as the
 *  third parameter.
 *
 *  The enumeration entries named with the OMX_Config prefix are sent using
 *  the OMX_SetConfig command and the enumeration entries named with the
 *  OMX_PARAM_ prefix are sent using the OMX_SetParameter command.
 */
typedef enum OMX_INDEXTYPE {

    OMX_IndexComponentStartUnused = 0x01000000,
    OMX_IndexParamPriorityMgmt,             /**< reference: OMX_PRIORITYMGMTTYPE */
    OMX_IndexParamAudioInit,                /**< reference: OMX_PORT_PARAM_TYPE */
    OMX_IndexParamImageInit,                /**< reference: OMX_PORT_PARAM_TYPE */
    OMX_IndexParamVideoInit,                /**< reference: OMX_PORT_PARAM_TYPE */
    OMX_IndexParamOtherInit,                /**< reference: OMX_PORT_PARAM_TYPE */
    OMX_IndexParamNumAvailableStreams,      /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexParamActiveStream,             /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexParamSuspensionPolicy,         /**< reference: OMX_PARAM_SUSPENSIONPOLICYTYPE */
    OMX_IndexParamComponentSuspended,       /**< reference: OMX_PARAM_SUSPENSIONTYPE */
    OMX_IndexConfigCapturing,               /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexConfigCaptureMode,             /**< reference: OMX_CONFIG_CAPTUREMODETYPE */
    OMX_IndexAutoPauseAfterCapture,         /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexParamContentURI,               /**< reference: OMX_PARAM_CONTENTURITYPE */
    OMX_IndexParamCustomContentPipe,        /**< reference: OMX_PARAM_CONTENTPIPETYPE */
    OMX_IndexParamDisableResourceConcealment, /**< reference: OMX_RESOURCECONCEALMENTTYPE */
    OMX_IndexConfigMetadataItemCount,       /**< reference: OMX_CONFIG_METADATAITEMCOUNTTYPE */
    OMX_IndexConfigContainerNodeCount,      /**< reference: OMX_CONFIG_CONTAINERNODECOUNTTYPE */
    OMX_IndexConfigMetadataItem,            /**< reference: OMX_CONFIG_METADATAITEMTYPE */
    OMX_IndexConfigCounterNodeID,           /**< reference: OMX_CONFIG_CONTAINERNODEIDTYPE */
    OMX_IndexParamMetadataFilterType,       /**< reference: OMX_PARAM_METADATAFILTERTYPE */
    OMX_IndexParamMetadataKeyFilter,        /**< reference: OMX_PARAM_METADATAFILTERTYPE */
    OMX_IndexConfigPriorityMgmt,            /**< reference: OMX_PRIORITYMGMTTYPE */
    OMX_IndexParamStandardComponentRole,    /**< reference: OMX_PARAM_COMPONENTROLETYPE */

    OMX_IndexPortStartUnused = 0x02000000,
    OMX_IndexParamPortDefinition,           /**< reference: OMX_PARAM_PORTDEFINITIONTYPE */
    OMX_IndexParamCompBufferSupplier,       /**< reference: OMX_PARAM_BUFFERSUPPLIERTYPE */
    OMX_IndexReservedStartUnused = 0x03000000,

    /* Audio parameters and configurations */
    OMX_IndexAudioStartUnused = 0x04000000,
    OMX_IndexParamAudioPortFormat,          /**< reference: OMX_AUDIO_PARAM_PORTFORMATTYPE */
    OMX_IndexParamAudioPcm,                 /**< reference: OMX_AUDIO_PARAM_PCMMODETYPE */
    OMX_IndexParamAudioAac,                 /**< reference: OMX_AUDIO_PARAM_AACPROFILETYPE */
    OMX_IndexParamAudioRa,                  /**< reference: OMX_AUDIO_PARAM_RATYPE */
    OMX_IndexParamAudioMp3,                 /**< reference: OMX_AUDIO_PARAM_MP3TYPE */
    OMX_IndexParamAudioAdpcm,               /**< reference: OMX_AUDIO_PARAM_ADPCMTYPE */
    OMX_IndexParamAudioG723,                /**< reference: OMX_AUDIO_PARAM_G723TYPE */
    OMX_IndexParamAudioG729,                /**< reference: OMX_AUDIO_PARAM_G729TYPE */
    OMX_IndexParamAudioAmr,                 /**< reference: OMX_AUDIO_PARAM_AMRTYPE */
    OMX_IndexParamAudioWma,                 /**< reference: OMX_AUDIO_PARAM_WMATYPE */
    OMX_IndexParamAudioSbc,                 /**< reference: OMX_AUDIO_PARAM_SBCTYPE */
    OMX_IndexParamAudioMidi,                /**< reference: OMX_AUDIO_PARAM_MIDITYPE */
    OMX_IndexParamAudioGsm_FR,              /**< reference: OMX_AUDIO_PARAM_GSMFRTYPE */
    OMX_IndexParamAudioMidiLoadUserSound,   /**< reference: OMX_AUDIO_PARAM_MIDILOADUSERSOUNDTYPE */
    OMX_IndexParamAudioG726,                /**< reference: OMX_AUDIO_PARAM_G726TYPE */
    OMX_IndexParamAudioGsm_EFR,             /**< reference: OMX_AUDIO_PARAM_GSMEFRTYPE */
    OMX_IndexParamAudioGsm_HR,              /**< reference: OMX_AUDIO_PARAM_GSMHRTYPE */
    OMX_IndexParamAudioPdc_FR,              /**< reference: OMX_AUDIO_PARAM_PDCFRTYPE */
    OMX_IndexParamAudioPdc_EFR,             /**< reference: OMX_AUDIO_PARAM_PDCEFRTYPE */
    OMX_IndexParamAudioPdc_HR,              /**< reference: OMX_AUDIO_PARAM_PDCHRTYPE */
    OMX_IndexParamAudioTdma_FR,             /**< reference: OMX_AUDIO_PARAM_TDMAFRTYPE */
    OMX_IndexParamAudioTdma_EFR,            /**< reference: OMX_AUDIO_PARAM_TDMAEFRTYPE */
    OMX_IndexParamAudioQcelp8,              /**< reference: OMX_AUDIO_PARAM_QCELP8TYPE */
    OMX_IndexParamAudioQcelp13,             /**< reference: OMX_AUDIO_PARAM_QCELP13TYPE */
    OMX_IndexParamAudioEvrc,                /**< reference: OMX_AUDIO_PARAM_EVRCTYPE */
    OMX_IndexParamAudioSmv,                 /**< reference: OMX_AUDIO_PARAM_SMVTYPE */
    OMX_IndexParamAudioVorbis,              /**< reference: OMX_AUDIO_PARAM_VORBISTYPE */

    OMX_IndexConfigAudioMidiImmediateEvent, /**< reference: OMX_AUDIO_CONFIG_MIDIIMMEDIATEEVENTTYPE */
    OMX_IndexConfigAudioMidiControl,        /**< reference: OMX_AUDIO_CONFIG_MIDICONTROLTYPE */
    OMX_IndexConfigAudioMidiSoundBankProgram, /**< reference: OMX_AUDIO_CONFIG_MIDISOUNDBANKPROGRAMTYPE */
    OMX_IndexConfigAudioMidiStatus,         /**< reference: OMX_AUDIO_CONFIG_MIDISTATUSTYPE */
    OMX_IndexConfigAudioMidiMetaEvent,      /**< reference: OMX_AUDIO_CONFIG_MIDIMETAEVENTTYPE */
    OMX_IndexConfigAudioMidiMetaEventData,  /**< reference: OMX_AUDIO_CONFIG_MIDIMETAEVENTDATATYPE */
    OMX_IndexConfigAudioVolume,             /**< reference: OMX_AUDIO_CONFIG_VOLUMETYPE */
    OMX_IndexConfigAudioBalance,            /**< reference: OMX_AUDIO_CONFIG_BALANCETYPE */
    OMX_IndexConfigAudioChannelMute,        /**< reference: OMX_AUDIO_CONFIG_CHANNELMUTETYPE */
    OMX_IndexConfigAudioMute,               /**< reference: OMX_AUDIO_CONFIG_MUTETYPE */
    OMX_IndexConfigAudioLoudness,           /**< reference: OMX_AUDIO_CONFIG_LOUDNESSTYPE */
    OMX_IndexConfigAudioEchoCancelation,    /**< reference: OMX_AUDIO_CONFIG_ECHOCANCELATIONTYPE */
    OMX_IndexConfigAudioNoiseReduction,     /**< reference: OMX_AUDIO_CONFIG_NOISEREDUCTIONTYPE */
    OMX_IndexConfigAudioBass,               /**< reference: OMX_AUDIO_CONFIG_BASSTYPE */
    OMX_IndexConfigAudioTreble,             /**< reference: OMX_AUDIO_CONFIG_TREBLETYPE */
    OMX_IndexConfigAudioStereoWidening,     /**< reference: OMX_AUDIO_CONFIG_STEREOWIDENINGTYPE */
    OMX_IndexConfigAudioChorus,             /**< reference: OMX_AUDIO_CONFIG_CHORUSTYPE */
    OMX_IndexConfigAudioEqualizer,          /**< reference: OMX_AUDIO_CONFIG_EQUALIZERTYPE */
    OMX_IndexConfigAudioReverberation,      /**< reference: OMX_AUDIO_CONFIG_REVERBERATIONTYPE */
    OMX_IndexConfigAudioChannelVolume,      /**< reference: OMX_AUDIO_CONFIG_CHANNELVOLUMETYPE */

    /* Image specific parameters and configurations */
    OMX_IndexImageStartUnused = 0x05000000,
    OMX_IndexParamImagePortFormat,          /**< reference: OMX_IMAGE_PARAM_PORTFORMATTYPE */
    OMX_IndexParamFlashControl,             /**< reference: OMX_IMAGE_PARAM_FLASHCONTROLTYPE */
    OMX_IndexConfigFocusControl,            /**< reference: OMX_IMAGE_CONFIG_FOCUSCONTROLTYPE */
    OMX_IndexParamQFactor,                  /**< reference: OMX_IMAGE_PARAM_QFACTORTYPE */
    OMX_IndexParamQuantizationTable,        /**< reference: OMX_IMAGE_PARAM_QUANTIZATIONTABLETYPE */
    OMX_IndexParamHuffmanTable,             /**< reference: OMX_IMAGE_PARAM_HUFFMANTTABLETYPE */
    OMX_IndexConfigFlashControl,            /**< reference: OMX_IMAGE_PARAM_FLASHCONTROLTYPE */

    /* Video specific parameters and configurations */
    OMX_IndexVideoStartUnused = 0x06000000,
    OMX_IndexParamVideoPortFormat,          /**< reference: OMX_VIDEO_PARAM_PORTFORMATTYPE */
    OMX_IndexParamVideoQuantization,        /**< reference: OMX_VIDEO_PARAM_QUANTIZATIONTYPE */
    OMX_IndexParamVideoFastUpdate,          /**< reference: OMX_VIDEO_PARAM_VIDEOFASTUPDATETYPE */
    OMX_IndexParamVideoBitrate,             /**< reference: OMX_VIDEO_PARAM_BITRATETYPE */
    OMX_IndexParamVideoMotionVector,        /**< reference: OMX_VIDEO_PARAM_MOTIONVECTORTYPE */
    OMX_IndexParamVideoIntraRefresh,        /**< reference: OMX_VIDEO_PARAM_INTRAREFRESHTYPE */
    OMX_IndexParamVideoErrorCorrection,     /**< reference: OMX_VIDEO_PARAM_ERRORCORRECTIONTYPE */
    OMX_IndexParamVideoVBSMC,               /**< reference: OMX_VIDEO_PARAM_VBSMCTYPE */
    OMX_IndexParamVideoMpeg2,               /**< reference: OMX_VIDEO_PARAM_MPEG2TYPE */
    OMX_IndexParamVideoMpeg4,               /**< reference: OMX_VIDEO_PARAM_MPEG4TYPE */
    OMX_IndexParamVideoWmv,                 /**< reference: OMX_VIDEO_PARAM_WMVTYPE */
    OMX_IndexParamVideoRv,                  /**< reference: OMX_VIDEO_PARAM_RVTYPE */
    OMX_IndexParamVideoAvc,                 /**< reference: OMX_VIDEO_PARAM_AVCTYPE */
    OMX_IndexParamVideoH263,                /**< reference: OMX_VIDEO_PARAM_H263TYPE */
    OMX_IndexParamVideoProfileLevelQuerySupported, /**< reference: OMX_VIDEO_PARAM_PROFILELEVELTYPE */
    OMX_IndexParamVideoProfileLevelCurrent, /**< reference: OMX_VIDEO_PARAM_PROFILELEVELTYPE */
    OMX_IndexConfigVideoBitrate,            /**< reference: OMX_VIDEO_CONFIG_BITRATETYPE */
    OMX_IndexConfigVideoFramerate,          /**< reference: OMX_CONFIG_FRAMERATETYPE */
    OMX_IndexConfigVideoIntraVOPRefresh,    /**< reference: OMX_CONFIG_INTRAREFRESHVOPTYPE */
    OMX_IndexConfigVideoIntraMBRefresh,     /**< reference: OMX_CONFIG_MACROBLOCKERRORMAPTYPE */
    OMX_IndexConfigVideoMBErrorReporting,   /**< reference: OMX_CONFIG_MBERRORREPORTINGTYPE */
    OMX_IndexParamVideoMacroblocksPerFrame, /**< reference: OMX_PARAM_MACROBLOCKSTYPE */
    OMX_IndexConfigVideoMacroBlockErrorMap, /**< reference: OMX_CONFIG_MACROBLOCKERRORMAPTYPE */
    OMX_IndexParamVideoSliceFMO,            /**< reference: OMX_VIDEO_PARAM_AVCSLICEFMO */
    OMX_IndexConfigVideoAVCIntraPeriod,     /**< reference: OMX_VIDEO_CONFIG_AVCINTRAPERIOD */
    OMX_IndexConfigVideoNalSize,            /**< reference: OMX_VIDEO_CONFIG_NALSIZE */

    /* Image & Video common Configurations */
    OMX_IndexCommonStartUnused = 0x07000000,
    OMX_IndexParamCommonDeblocking,         /**< reference: OMX_PARAM_DEBLOCKINGTYPE */
    OMX_IndexParamCommonSensorMode,         /**< reference: OMX_PARAM_SENSORMODETYPE */
    OMX_IndexParamCommonInterleave,         /**< reference: OMX_PARAM_INTERLEAVETYPE */
    OMX_IndexConfigCommonColorFormatConversion, /**< reference: OMX_CONFIG_COLORCONVERSIONTYPE */
    OMX_IndexConfigCommonScale,             /**< reference: OMX_CONFIG_SCALEFACTORTYPE */
    OMX_IndexConfigCommonImageFilter,       /**< reference: OMX_CONFIG_IMAGEFILTERTYPE */
    OMX_IndexConfigCommonColorEnhancement,  /**< reference: OMX_CONFIG_COLORENHANCEMENTTYPE */
    OMX_IndexConfigCommonColorKey,          /**< reference: OMX_CONFIG_COLORKEYTYPE */
    OMX_IndexConfigCommonColorBlend,        /**< reference: OMX_CONFIG_COLORBLENDTYPE */
    OMX_IndexConfigCommonFrameStabilisation,/**< reference: OMX_CONFIG_FRAMESTABTYPE */
    OMX_IndexConfigCommonRotate,            /**< reference: OMX_CONFIG_ROTATIONTYPE */
    OMX_IndexConfigCommonMirror,            /**< reference: OMX_CONFIG_MIRRORTYPE */
    OMX_IndexConfigCommonOutputPosition,    /**< reference: OMX_CONFIG_POINTTYPE */
    OMX_IndexConfigCommonInputCrop,         /**< reference: OMX_CONFIG_RECTTYPE */
    OMX_IndexConfigCommonOutputCrop,        /**< reference: OMX_CONFIG_RECTTYPE */
    OMX_IndexConfigCommonDigitalZoom,       /**< reference: OMX_CONFIG_SCALEFACTORTYPE */
    OMX_IndexConfigCommonOpticalZoom,       /**< reference: OMX_CONFIG_SCALEFACTORTYPE*/
    OMX_IndexConfigCommonWhiteBalance,      /**< reference: OMX_CONFIG_WHITEBALCONTROLTYPE */
    OMX_IndexConfigCommonExposure,          /**< reference: OMX_CONFIG_EXPOSURECONTROLTYPE */
    OMX_IndexConfigCommonContrast,          /**< reference: OMX_CONFIG_CONTRASTTYPE */
    OMX_IndexConfigCommonBrightness,        /**< reference: OMX_CONFIG_BRIGHTNESSTYPE */
    OMX_IndexConfigCommonBacklight,         /**< reference: OMX_CONFIG_BACKLIGHTTYPE */
    OMX_IndexConfigCommonGamma,             /**< reference: OMX_CONFIG_GAMMATYPE */
    OMX_IndexConfigCommonSaturation,        /**< reference: OMX_CONFIG_SATURATIONTYPE */
    OMX_IndexConfigCommonLightness,         /**< reference: OMX_CONFIG_LIGHTNESSTYPE */
    OMX_IndexConfigCommonExclusionRect,     /**< reference: OMX_CONFIG_RECTTYPE */
    OMX_IndexConfigCommonDithering,         /**< reference: OMX_CONFIG_DITHERTYPE */
    OMX_IndexConfigCommonPlaneBlend,        /**< reference: OMX_CONFIG_PLANEBLENDTYPE */
    OMX_IndexConfigCommonExposureValue,     /**< reference: OMX_CONFIG_EXPOSUREVALUETYPE */
    OMX_IndexConfigCommonOutputSize,        /**< reference: OMX_FRAMESIZETYPE */
    OMX_IndexParamCommonExtraQuantData,     /**< reference: OMX_OTHER_EXTRADATATYPE */
    OMX_IndexConfigCommonFocusRegion,       /**< reference: OMX_CONFIG_FOCUSREGIONTYPE */
    OMX_IndexConfigCommonFocusStatus,       /**< reference: OMX_PARAM_FOCUSSTATUSTYPE */
    OMX_IndexConfigCommonTransitionEffect,  /**< reference: OMX_CONFIG_TRANSITIONEFFECTTYPE */

    /* Reserved Configuration range */
    OMX_IndexOtherStartUnused = 0x08000000,
    OMX_IndexParamOtherPortFormat,          /**< reference: OMX_OTHER_PARAM_PORTFORMATTYPE */
    OMX_IndexConfigOtherPower,              /**< reference: OMX_OTHER_CONFIG_POWERTYPE */
    OMX_IndexConfigOtherStats,              /**< reference: OMX_OTHER_CONFIG_STATSTYPE */


    /* Reserved Time range */
    OMX_IndexTimeStartUnused = 0x09000000,
    OMX_IndexConfigTimeScale,               /**< reference: OMX_TIME_CONFIG_SCALETYPE */
    OMX_IndexConfigTimeClockState,          /**< reference: OMX_TIME_CONFIG_CLOCKSTATETYPE */
    OMX_IndexConfigTimeActiveRefClock,      /**< reference: OMX_TIME_CONFIG_ACTIVEREFCLOCKTYPE */
    OMX_IndexConfigTimeCurrentMediaTime,    /**< reference: OMX_TIME_CONFIG_TIMESTAMPTYPE (read only) */
    OMX_IndexConfigTimeCurrentWallTime,     /**< reference: OMX_TIME_CONFIG_TIMESTAMPTYPE (read only) */
    OMX_IndexConfigTimeCurrentAudioReference, /**< reference: OMX_TIME_CONFIG_TIMESTAMPTYPE (write only) */
    OMX_IndexConfigTimeCurrentVideoReference, /**< reference: OMX_TIME_CONFIG_TIMESTAMPTYPE (write only) */
    OMX_IndexConfigTimeMediaTimeRequest,    /**< reference: OMX_TIME_CONFIG_MEDIATIMEREQUESTTYPE (write only) */
    OMX_IndexConfigTimeClientStartTime,     /**<reference:  OMX_TIME_CONFIG_TIMESTAMPTYPE (write only) */
    OMX_IndexConfigTimePosition,            /**< reference: OMX_TIME_CONFIG_TIMESTAMPTYPE */
    OMX_IndexConfigTimeSeekMode,            /**< reference: OMX_TIME_CONFIG_SEEKMODETYPE */


    OMX_IndexKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
    /* Vendor specific area */
    OMX_IndexVendorStartUnused = 0x7F000000,
    /* Vendor specific structures should be in the range of 0x7F000000
       to 0x7FFFFFFE.  This range is not broken out by vendor, so
       private indexes are not guaranteed unique and therefore should
       only be sent to the appropriate component. */

    /* used for ilcs-top communication */
    OMX_IndexParamMarkComparison,           /**< reference: OMX_PARAM_MARKCOMPARISONTYPE */
    OMX_IndexParamPortSummary,              /**< reference: OMX_PARAM_PORTSUMMARYTYPE */
    OMX_IndexParamTunnelStatus,             /**< reference : OMX_PARAM_TUNNELSTATUSTYPE */
    OMX_IndexParamBrcmRecursionUnsafe,      /**< reference: OMX_PARAM_BRCMRECURSIONUNSAFETYPE */

    /* used for top-ril communication */
    OMX_IndexParamBufferAddress,            /**< reference : OMX_PARAM_BUFFERADDRESSTYPE */
    OMX_IndexParamTunnelSetup,              /**< reference : OMX_PARAM_TUNNELSETUPTYPE */
    OMX_IndexParamBrcmPortEGL,              /**< reference : OMX_PARAM_BRCMPORTEGLTYPE */
    OMX_IndexParamIdleResourceCount,        /**< reference : OMX_PARAM_U32TYPE */

    /* used for ril-ril communication */
    OMX_IndexParamImagePoolDisplayFunction, /**<reference : OMX_PARAM_IMAGEDISPLAYFUNCTIONTYPE */
    OMX_IndexParamBrcmDataUnit,             /**<reference: OMX_PARAM_DATAUNITTYPE */
    OMX_IndexParamCodecConfig,              /**<reference: OMX_PARAM_CODECCONFIGTYPE */
    OMX_IndexParamCameraPoolToEncoderFunction, /**<reference : OMX_PARAM_CAMERAPOOLTOENCODERFUNCTIONTYPE */
    OMX_IndexParamCameraStripeFunction,     /**<reference : OMX_PARAM_CAMERASTRIPEFUNCTIONTYPE */
    OMX_IndexParamCameraCaptureEventFunction, /**<reference : OMX_PARAM_CAMERACAPTUREEVENTFUNCTIONTYPE */

    /* used for client-ril communication */
    OMX_IndexParamTestInterface,            /**< reference : OMX_PARAM_TESTINTERFACETYPE */

    // 0x7f000010
    OMX_IndexConfigDisplayRegion,           /**< reference : OMX_CONFIG_DISPLAYREGIONTYPE */
    OMX_IndexParamSource,                   /**< reference : OMX_PARAM_SOURCETYPE */
    OMX_IndexParamSourceSeed,               /**< reference : OMX_PARAM_SOURCESEEDTYPE */
    OMX_IndexParamResize,                   /**< reference : OMX_PARAM_RESIZETYPE */
    OMX_IndexConfigVisualisation,           /**< reference : OMX_CONFIG_VISUALISATIONTYPE */
    OMX_IndexConfigSingleStep,              /**<reference : OMX_PARAM_U32TYPE */
    OMX_IndexConfigPlayMode,                /**<reference: OMX_CONFIG_PLAYMODETYPE */
    OMX_IndexParamCameraCamplusId,          /**<reference : OMX_PARAM_U32TYPE */
    OMX_IndexConfigCommonImageFilterParameters,  /**<reference : OMX_CONFIG_IMAGEFILTERPARAMSTYPE */
    OMX_IndexConfigTransitionControl,       /**<reference : OMX_CONFIG_TRANSITIONCONTROLTYPE */
    OMX_IndexConfigPresentationOffset,      /**<reference: OMX_TIME_CONFIG_TIMESTAMPTYPE */
    OMX_IndexParamSourceFunctions,          /**<reference: OMX_PARAM_STILLSFUNCTIONTYPE */
    OMX_IndexConfigAudioMonoTrackControl,   /**<reference : OMX_CONFIG_AUDIOMONOTRACKCONTROLTYPE */
    OMX_IndexParamCameraImagePool,          /**<reference : OMX_PARAM_CAMERAIMAGEPOOLTYPE */
    OMX_IndexConfigCameraISPOutputPoolHeight,/**<reference : OMX_PARAM_U32TYPE */
    OMX_IndexParamImagePoolSize,            /**<reference: OMX_PARAM_IMAGEPOOLSIZETYPE */

    // 0x7f000020
    OMX_IndexParamImagePoolExternal,        /**<reference: OMX_PARAM_IMAGEPOOLEXTERNALTYPE */
    OMX_IndexParamRUTILFifoInfo,            /**<reference: OMX_PARAM_RUTILFIFOINFOTYPE*/
    OMX_IndexParamILFifoConfig,             /**<reference: OMX_PARAM_ILFIFOCONFIG */
    OMX_IndexConfigCameraSensorModes,       /**<reference : OMX_CONFIG_CAMERASENSORMODETYPE */
    OMX_IndexConfigBrcmPortStats,           /**<reference : OMX_CONFIG_BRCMPORTSTATSTYPE */
    OMX_IndexConfigBrcmPortBufferStats,     /**<reference : OMX_CONFIG_BRCMPORTBUFFERSTATSTYPE */
    OMX_IndexConfigBrcmCameraStats,         /**<reference : OMX_CONFIG_BRCMCAMERASTATSTYPE */
    OMX_IndexConfigBrcmIOPerfStats,         /**<reference : OMX_CONFIG_BRCMIOPERFSTATSTYPE */
    OMX_IndexConfigCommonSharpness,         /**<reference : OMX_CONFIG_SHARPNESSTYPE */
    OMX_IndexConfigCommonFlickerCancellation,   /**reference : OMX_CONFIG_FLICKERCANCELTYPE */
    OMX_IndexParamCameraSwapImagePools,     /**<reference : OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexParamCameraSingleBufferCaptureInput,  /**<reference : OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexConfigCommonRedEyeRemoval,   /**<reference : OMX_CONFIG_REDEYEREMOVALTYPE  */
    OMX_IndexConfigCommonFaceDetectionControl,  /**<reference : OMX_CONFIG_FACEDETECTIONCONTROLTYPE */
    OMX_IndexConfigCommonFaceDetectionRegion,   /**<reference : OMX_CONFIG_FACEDETECTIONREGIONTYPE */
    OMX_IndexConfigCommonInterlace,         /**<reference: OMX_CONFIG_INTERLACETYPE */

    // 0x7f000030
    OMX_IndexParamISPTunerName,             /**<reference: OMX_PARAM_CAMERAISPTUNERTYPE */
    OMX_IndexParamCameraDeviceNumber,       /**<reference: OMX_PARAM_U32TYPE */
    OMX_IndexParamCameraDevicesPresent,     /**<reference: OMX_PARAM_U32TYPE */
    OMX_IndexConfigCameraInputFrame,        /**<reference: OMX_CONFIG_IMAGEPTRTYPE */
    OMX_IndexConfigStillColourDenoiseEnable,    /**<reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexConfigVideoColourDenoiseEnable,    /**<reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexConfigAFAssistLight,           /**<reference: OMX_CONFIG_AFASSISTTYPE */
    OMX_IndexConfigSmartShakeReductionEnable, /**<reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexConfigInputCropPercentages,    /**<reference: OMX_CONFIG_INPUTCROPTYPE */
    OMX_IndexConfigStillsAntiShakeEnable,   /**<reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexConfigWaitForFocusBeforeCapture,/**<reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexConfigAudioRenderingLatency,   /**<reference: OMX_PARAM_U32TYPE */
    OMX_IndexConfigDrawBoxAroundFaces,      /**<reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexParamCodecRequirements,        /**<reference: OMX_PARAM_CODECREQUIREMENTSTYPE */
    OMX_IndexConfigBrcmEGLImageMemHandle,   /**<reference: OMX_CONFIG_BRCMEGLIMAGEMEMHANDLETYPE */
    OMX_IndexConfigPrivacyIndicator,        /**<reference: OMX_CONFIG_PRIVACYINDICATORTYPE */

    // 0x7f000040
    OMX_IndexParamCameraFlashType,          /**<reference: OMX_PARAM_CAMERAFLASHTYPE */
    OMX_IndexConfigCameraEnableStatsPass,   /**<reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexConfigCameraFlashConfig,       /**<reference: OMX_CONFIG_CAMERAFLASHCONFIGTYPE */
    OMX_IndexConfigCaptureRawImageURI,      /**<reference: OMX_PARAM_CONTENTURITYPE */
    OMX_IndexConfigCameraStripeFuncMinLines, /**<reference: OMX_PARAM_U32TYPE */
    OMX_IndexConfigCameraAlgorithmVersionDeprecated,   /**<reference: OMX_PARAM_U32TYPE */
    OMX_IndexConfigCameraIsoReferenceValue,  /**<reference: OMX_PARAM_U32TYPE */
    OMX_IndexConfigCameraCaptureAbortsAutoFocus, /**<reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexConfigBrcmClockMissCount,      /**<reference: OMX_PARAM_U32TYPE */
    OMX_IndexConfigFlashChargeLevel,         /**<reference: OMX_PARAM_U32TYPE */
    OMX_IndexConfigBrcmVideoEncodedSliceSize, /**<reference: OMX_PARAM_U32TYPE */
    OMX_IndexConfigBrcmAudioTrackGaplessPlayback,  /**< reference: OMX_CONFIG_BRCMAUDIOTRACKGAPLESSPLAYBACKTYPE */
    OMX_IndexConfigBrcmAudioTrackChangeControl,    /**< reference: OMX_CONFIG_BRCMAUDIOTRACKCHANGECONTROLTYPE */
    OMX_IndexParamBrcmPixelAspectRatio,     /**< reference: OMX_CONFIG_POINTTYPE */
    OMX_IndexParamBrcmPixelValueRange,      /**< reference: OMX_PARAM_BRCMPIXELVALUERANGETYPE */
    OMX_IndexParamCameraDisableAlgorithm,   /**< reference: OMX_PARAM_CAMERADISABLEALGORITHMTYPE */

    // 0x7f000050
    OMX_IndexConfigBrcmVideoIntraPeriodTime, /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexConfigBrcmVideoIntraPeriod,     /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexConfigBrcmAudioEffectControl, /**< reference: OMX_CONFIG_BRCMAUDIOEFFECTCONTROLTYPE */
    OMX_IndexConfigBrcmMinimumProcessingLatency, /**< reference: OMX_CONFIG_BRCMMINIMUMPROCESSINGLATENCY */
    OMX_IndexParamBrcmVideoAVCSEIEnable,    /**< reference: OMX_PARAM_BRCMVIDEOAVCSEIENABLETYPE */
    OMX_IndexParamBrcmAllowMemChange,   /**< reference: OMX_PARAM_BRCMALLOWMEMCHANGETYPE */
    OMX_IndexConfigBrcmVideoEncoderMBRowsPerSlice, /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexParamCameraAFAssistDeviceNumber_Deprecated,   /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexParamCameraPrivacyIndicatorDeviceNumber_Deprecated,   /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexConfigCameraUseCase,               /**< reference: OMX_CONFIG_CAMERAUSECASETYPE */
    OMX_IndexParamBrcmDisableProprietaryTunnels,   /**< reference: OMX_PARAM_BRCMDISABLEPROPRIETARYTUNNELSTYPE */
    OMX_IndexParamBrcmOutputBufferSize,         /**<  reference: OMX_PARAM_BRCMOUTPUTBUFFERSIZETYPE */
    OMX_IndexParamBrcmRetainMemory,             /**< reference: OMX_PARAM_BRCMRETAINMEMORYTYPE */
    OMX_IndexConfigCanFocus_Deprecated,                    /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexParamBrcmImmutableInput,           /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexParamDynamicParameterFile,        /**< reference: OMX_PARAM_CONTENTURITYPE */

    // 0x7f000060
    OMX_IndexParamUseDynamicParameterFile,     /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexConfigCameraInfo,                 /**< reference: OMX_CONFIG_CAMERAINFOTYPE */
    OMX_IndexConfigCameraFeatures,             /**< reference: OMX_CONFIG_CAMERAFEATURESTYPE */
    OMX_IndexConfigRequestCallback,            /**< reference: OMX_CONFIG_REQUESTCALLBACKTYPE */ //Should be added to the spec as part of IL416c
    OMX_IndexConfigBrcmOutputBufferFullCount,  /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexConfigCommonFocusRegionXY,        /**< reference: OMX_CONFIG_FOCUSREGIONXYTYPE */
    OMX_IndexParamBrcmDisableEXIF,             /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexConfigUserSettingsId,             /**< reference: OMX_CONFIG_U8TYPE */
    OMX_IndexConfigCameraSettings,             /**< reference: OMX_CONFIG_CAMERASETTINGSTYPE */
    OMX_IndexConfigDrawBoxLineParams,          /**< reference: OMX_CONFIG_DRAWBOXLINEPARAMS */
    OMX_IndexParamCameraRmiControl_Deprecated,            /**< reference: OMX_PARAM_CAMERARMITYPE */
    OMX_IndexConfigBurstCapture,               /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexParamBrcmEnableIJGTableScaling,   /**< reference: OMX_PARAM_IJGSCALINGTYPE */
    OMX_IndexConfigPowerDown,                  /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexConfigBrcmSyncOutput,             /**< reference: OMX_CONFIG_BRCMSYNCOUTPUTTYPE */
    OMX_IndexParamBrcmFlushCallback,           /**< reference: OMX_PARAM_BRCMFLUSHCALLBACK */

    // 0x7f000070
    OMX_IndexConfigBrcmVideoRequestIFrame,     /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexParamBrcmNALSSeparate,            /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexConfigConfirmView,                /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexConfigDrmView,                    /**< reference: OMX_CONFIG_DRMVIEWTYPE */
    OMX_IndexConfigBrcmVideoIntraRefresh,      /**< reference: OMX_VIDEO_PARAM_INTRAREFRESHTYPE */
    OMX_IndexParamBrcmMaxFileSize,             /**< reference: OMX_PARAM_BRCMU64TYPE */
    OMX_IndexParamBrcmCRCEnable,               /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexParamBrcmCRC,                     /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexConfigCameraRmiInUse_Deprecated,             /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexConfigBrcmAudioSource,            /**<reference: OMX_CONFIG_BRCMAUDIOSOURCETYPE */
    OMX_IndexConfigBrcmAudioDestination,       /**< reference: OMX_CONFIG_BRCMAUDIODESTINATIONTYPE */
    OMX_IndexParamAudioDdp,                    /**< reference: OMX_AUDIO_PARAM_DDPTYPE */
    OMX_IndexParamBrcmThumbnail,               /**< reference: OMX_PARAM_BRCMTHUMBNAILTYPE */
    OMX_IndexParamBrcmDisableLegacyBlocks_Deprecated,     /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexParamBrcmCameraInputAspectRatio,  /**< reference: OMX_PARAM_BRCMASPECTRATIOTYPE */
    OMX_IndexParamDynamicParameterFileFailFatal,/**< reference: OMX_CONFIG_BOOLEANTYPE */

    // 0x7f000080
    OMX_IndexParamBrcmVideoDecodeErrorConcealment, /**< reference: OMX_PARAM_BRCMVIDEODECODEERRORCONCEALMENTTYPE */
    OMX_IndexParamBrcmInterpolateMissingTimestamps, /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexParamBrcmSetCodecPerformanceMonitoring, /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexConfigFlashInfo,                  /**< reference: OMX_CONFIG_FLASHINFOTYPE */
    OMX_IndexParamBrcmMaxFrameSkips,           /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexConfigDynamicRangeExpansion,      /**< reference: OMX_CONFIG_DYNAMICRANGEEXPANSIONTYPE */
    OMX_IndexParamBrcmFlushCallbackId,         /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexParamBrcmTransposeBufferCount,    /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexConfigFaceRecognitionControl,     /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexConfigFaceRecognitionSaveFace,    /**< reference: OMX_PARAM_BRCMU64TYPE */
    OMX_IndexConfigFaceRecognitionDatabaseUri, /**< reference: OMX_PARAM_CONTENTURITYPE */
    OMX_IndexConfigClockAdjustment,            /**< reference: OMX_TIME_CONFIG_TIMESTAMPTYPE */
    OMX_IndexParamBrcmThreadAffinity,          /**< reference: OMX_PARAM_BRCMTHREADAFFINITYTYPE */
    OMX_IndexParamAsynchronousOutput,          /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexConfigAsynchronousFailureURI,     /**< reference: OMX_PARAM_CONTENTURITYPE */
    OMX_IndexConfigCommonFaceBeautification,   /**< reference: OMX_CONFIG_BOOLEANTYPE */

    // 0x7f000090
    OMX_IndexConfigCommonSceneDetectionControl,/**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexConfigCommonSceneDetected,        /**< reference: OMX_CONFIG_SCENEDETECTTYPE */
    OMX_IndexParamDisableVllPool,              /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexParamVideoMvc,                    /**< reference: OMX_VIDEO_PARAM_MVCTYPE */
    OMX_IndexConfigBrcmDrawStaticBox,          /**< reference: OMX_CONFIG_STATICBOXTYPE */
    OMX_IndexConfigBrcmClockReferenceSource,   /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexParamPassBufferMarks,             /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexConfigPortCapturing,              /**< reference: OMX_CONFIG_PORTBOOLEANTYPE */
    OMX_IndexConfigBrcmDecoderPassThrough,     /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexParamBrcmDecoderPassThrough=OMX_IndexConfigBrcmDecoderPassThrough,  /* deprecated */
    OMX_IndexParamBrcmMaxCorruptMBs,           /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexConfigBrcmGlobalAudioMute,        /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexParamCameraCaptureMode,           /**< reference: OMX_PARAM_CAMERACAPTUREMODETYPE */
    OMX_IndexParamBrcmDrmEncryption,           /**< reference: OMX_PARAM_BRCMDRMENCRYPTIONTYPE */
    OMX_IndexConfigBrcmCameraRnDPreprocess,    /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexConfigBrcmCameraRnDPostprocess,   /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexConfigBrcmAudioTrackChangeCount,  /**< reference: OMX_PARAM_U32TYPE */

    // 0x7f0000a0
    OMX_IndexParamCommonUseStcTimestamps,      /**< reference: OMX_PARAM_TIMESTAMPMODETYPE */
    OMX_IndexConfigBufferStall,                /**< reference: OMX_CONFIG_BUFFERSTALLTYPE */
    OMX_IndexConfigRefreshCodec,               /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexParamCaptureStatus,               /**< reference: OMX_PARAM_CAPTURESTATETYPE */
    OMX_IndexConfigTimeInvalidStartTime,       /**< reference: OMX_TIME_CONFIG_TIMESTAMPTYPE */
    OMX_IndexConfigLatencyTarget,              /**< reference: OMX_CONFIG_LATENCYTARGETTYPE */
    OMX_IndexConfigMinimiseFragmentation,      /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexConfigBrcmUseProprietaryCallback, /**< reference: OMX_CONFIG_BRCMUSEPROPRIETARYTUNNELTYPE */
    OMX_IndexParamPortMaxFrameSize,            /**< reference: OMX_FRAMESIZETYPE */
    OMX_IndexParamComponentName,               /**< reference: OMX_PARAM_COMPONENTROLETYPE */
    OMX_IndexConfigEncLevelExtension,          /**< reference: OMX_VIDEO_CONFIG_LEVEL_EXTEND */
    OMX_IndexConfigTemporalDenoiseEnable,      /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexParamBrcmLazyImagePoolDestroy,    /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexParamBrcmEEDEEnable,              /**< reference: OMX_VIDEO_EEDE_ENABLE */
    OMX_IndexParamBrcmEEDELossRate,            /**< reference: OMX_VIDEO_EEDE_LOSSRATE */
    OMX_IndexParamAudioDts,                    /**< reference: OMX_AUDIO_PARAM_DTSTYPE */

    // 0x7f0000b0
    OMX_IndexParamNumOutputChannels,           /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexConfigBrcmHighDynamicRange,       /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexConfigBrcmPoolMemAllocSize,       /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexConfigBrcmBufferFlagFilter,       /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexParamBrcmVideoEncodeMinQuant,     /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexParamBrcmVideoEncodeMaxQuant,     /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexParamRateControlModel,            /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexParamBrcmExtraBuffers,            /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexConfigFieldOfView,                /**< reference: OMX_CONFIG_BRCMFOVTYPE */
    OMX_IndexParamBrcmAlignHoriz,              /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexParamBrcmAlignVert,               /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexParamColorSpace,                  /**< reference: OMX_PARAM_COLORSPACETYPE */
    OMX_IndexParamBrcmDroppablePFrames,        /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexParamBrcmVideoInitialQuant,       /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexParamBrcmVideoEncodeQpP,          /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexParamBrcmVideoRCSliceDQuant,      /**< reference: OMX_PARAM_U32TYPE */

    // 0x7f0000c0
    OMX_IndexParamBrcmVideoFrameLimitBits,     /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexParamBrcmVideoPeakRate,           /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexConfigBrcmVideoH264DisableCABAC,  /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexConfigBrcmVideoH264LowLatency,    /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexConfigBrcmVideoH264AUDelimiters,  /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexConfigBrcmVideoH264DeblockIDC,    /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexConfigBrcmVideoH264IntraMBMode,   /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexConfigContrastEnhance,            /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexParamCameraCustomSensorConfig,    /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexParamBrcmHeaderOnOpen,            /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexConfigBrcmUseRegisterFile,        /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexConfigBrcmRegisterFileFailFatal,  /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexParamBrcmConfigFileRegisters,     /**< reference: OMX_PARAM_BRCMCONFIGFILETYPE */
    OMX_IndexParamBrcmConfigFileChunkRegisters,/**< reference: OMX_PARAM_BRCMCONFIGFILECHUNKTYPE */
    OMX_IndexParamBrcmAttachLog,               /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexParamCameraZeroShutterLag,        /**< reference: OMX_CONFIG_ZEROSHUTTERLAGTYPE */

    // 0x7f0000d0
    OMX_IndexParamBrcmFpsRange,                /**< reference: OMX_PARAM_BRCMFRAMERATERANGETYPE */
    OMX_IndexParamCaptureExposureCompensation, /**< reference: OMX_PARAM_S32TYPE */
    OMX_IndexParamBrcmVideoPrecodeForQP,       /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexParamBrcmVideoTimestampFifo,      /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexParamSWSharpenDisable,            /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexConfigBrcmFlashRequired,          /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexParamBrcmVideoDrmProtectBuffer,   /**< reference: OMX_PARAM_BRCMVIDEODRMPROTECTBUFFERTYPE */
    OMX_IndexParamSWSaturationDisable,         /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexParamBrcmVideoDecodeConfigVD3,    /**< reference: OMX_PARAM_BRCMVIDEODECODECONFIGVD3TYPE */
    OMX_IndexConfigBrcmPowerMonitor,           /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexParamBrcmZeroCopy,                /**< reference: OMX_CONFIG_PORTBOOLEANTYPE */
    OMX_IndexParamBrcmVideoEGLRenderDiscardMode,   /**< reference: OMX_CONFIG_PORTBOOLEANTYPE */
    OMX_IndexParamBrcmVideoAVC_VCLHRDEnable,    /**< reference: OMX_CONFIG_PORTBOOLEANTYPE*/
    OMX_IndexParamBrcmVideoAVC_LowDelayHRDEnable, /**< reference: OMX_CONFIG_PORTBOOLEANTYPE*/
    OMX_IndexParamBrcmVideoCroppingDisable,    /**< reference: OMX_CONFIG_PORTBOOLEANTYPE*/
    OMX_IndexParamBrcmVideoAVCInlineHeaderEnable, /**< reference: OMX_CONFIG_PORTBOOLEANTYPE*/

    // 0x7f0000f0
    OMX_IndexConfigBrcmAudioDownmixCoefficients = 0x7f0000f0, /**< reference: OMX_CONFIG_BRCMAUDIODOWNMIXCOEFFICIENTS */
    OMX_IndexConfigBrcmAudioDownmixCoefficients8x8,           /**< reference: OMX_CONFIG_BRCMAUDIODOWNMIXCOEFFICIENTS8x8 */
    OMX_IndexConfigBrcmAudioMaxSample,                        /**< reference: OMX_CONFIG_BRCMAUDIOMAXSAMPLE */
    OMX_IndexConfigCustomAwbGains,                            /**< reference: OMX_CONFIG_CUSTOMAWBGAINSTYPE */
    OMX_IndexParamRemoveImagePadding,                         /**< reference: OMX_CONFIG_PORTBOOLEANTYPE*/
    OMX_IndexParamBrcmVideoAVCInlineVectorsEnable,            /**< reference: OMX_CONFIG_PORTBOOLEANTYPE */
    OMX_IndexConfigBrcmRenderStats,                           /**< reference: OMX_CONFIG_BRCMRENDERSTATSTYPE */
    OMX_IndexConfigBrcmCameraAnnotate,                        /**< reference: OMX_CONFIG_BRCMANNOTATETYPE */
    OMX_IndexParamBrcmStereoscopicMode,                       /**< reference :OMX_CONFIG_BRCMSTEREOSCOPICMODETYPE */
    OMX_IndexParamBrcmLockStepEnable,                         /**< reference: OMX_CONFIG_PORTBOOLEANTYPE */
    OMX_IndexParamBrcmTimeScale,                              /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexParamCameraInterface,                            /**< reference: OMX_PARAM_CAMERAINTERFACETYPE */
    OMX_IndexParamCameraClockingMode,                         /**< reference: OMX_PARAM_CAMERACLOCKINGMODETYPE */
    OMX_IndexParamCameraRxConfig,                             /**< reference: OMX_PARAM_CAMERARXCONFIG_TYPE */
    OMX_IndexParamCameraRxTiming,                             /**< reference: OMX_PARAM_CAMERARXTIMING_TYPE */
    OMX_IndexParamDynamicParameterConfig,                     /**< reference: OMX_PARAM_U32TYPE */

    // 0x7f000100
    OMX_IndexParamBrcmVideoAVCSPSTimingEnable,                /** reference: OMX_CONFIG_PORTBOOLEANTYPE */
    OMX_IndexParamBrcmBayerOrder,                             /** reference: OMX_PARAM_BAYERORDERTYPE */
    OMX_IndexParamBrcmMaxNumCallbacks,                        /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexParamBrcmJpegRestartInterval,                    /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexParamBrcmSupportsSlices,                         /**< reference: OMX_CONFIG_PORTBOOLEANTYPE */
    OMX_IndexParamBrcmIspBlockOverride,                       /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexParamBrcmSupportsUnalignedSliceheight,           /**< reference: OMX_CONFIG_PORTBOOLEANTYPE */
    OMX_IndexParamBrcmLensShadingOverride,                    /**< reference: OMX_PARAM_LENSSHADINGOVERRIDETYPE */
    OMX_IndexParamBrcmBlackLevel,                             /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexParamOutputShift,                                /**< reference: OMX_PARAM_S32TYPE */
    OMX_IndexParamCcmShift,                                   /**< reference: OMX_PARAM_S32TYPE */
    OMX_IndexParamCustomCcm,                                  /**< reference: OMX_PARAM_CUSTOMCCMTYPE */
    OMX_IndexConfigCameraAnalogGain,                          /**< reference: OMX_CONFIG_CAMERAGAINTYPE */
    OMX_IndexConfigCameraDigitalGain,                         /**< reference: OMX_CONFIG_CAMERAGAINTYPE */
    OMX_IndexConfigBrcmDroppableRunLength,                    /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexParamMinimumAlignment,                           /**< reference: OMX_PARAM_MINALIGNTYPE */
    OMX_IndexMax = 0x7FFFFFFF
} OMX_INDEXTYPE;

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif
/* File EOF */

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          /*
 * Copyright (c) 2008 The Khronos Group Inc. 
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject
 * to the following conditions: 
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software. 
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
 *
 */

/** @file OMX_Other.h - OpenMax IL version 1.1.2
 *  The structures needed by Other components to exchange
 *  parameters and configuration data with the components.
 */

#ifndef OMX_Other_h
#define OMX_Other_h

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */


/* Each OMX header must include all required header files to allow the
 *  header to compile without errors.  The includes below are required
 *  for this header file to compile successfully 
 */

#include "OMX_Core.h"


/** 
 * Enumeration of possible data types which match to multiple domains or no
 * domain at all.  For types which are vendor specific, a value above
 * OMX_OTHER_VENDORTSTART should be used.
 */
typedef enum OMX_OTHER_FORMATTYPE {
    OMX_OTHER_FormatTime = 0, /**< Transmission of various timestamps, elapsed time, 
                                   time deltas, etc */
    OMX_OTHER_FormatPower,    /**< Perhaps used for enabling/disabling power 
                                   management, setting clocks? */
    OMX_OTHER_FormatStats,    /**< Could be things such as frame rate, frames 
                                   dropped, etc */
    OMX_OTHER_FormatBinary,   /**< Arbitrary binary data */
    OMX_OTHER_FormatVendorReserved = 1000, /**< Starting value for vendor specific 
                                                formats */

    OMX_OTHER_FormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_OTHER_FormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */

    OMX_OTHER_FormatText,
    OMX_OTHER_FormatTextSKM2,
    OMX_OTHER_FormatText3GP5,

    OMX_OTHER_FormatMax = 0x7FFFFFFF
} OMX_OTHER_FORMATTYPE;

/** 
 * Enumeration of seek modes.
 */
typedef enum OMX_TIME_SEEKMODETYPE {
    OMX_TIME_SeekModeFast = 0, /**< Prefer seeking to an approximation
                                * of the requested seek position over   
                                * the actual seek position if it
                                * results in a faster seek. */
    OMX_TIME_SeekModeAccurate, /**< Prefer seeking to the actual seek 
                                * position over an approximation
                                * of the requested seek position even
                                * if it results in a slower seek. */
    OMX_TIME_SeekModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_TIME_SeekModeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */

    OMX_TIME_SeekModeDirectional, /**< Similar to Fast, but if seeking backwards will
                                   * try and seek to a previous sync position from the
                                   * current media time. */

    OMX_TIME_SeekModeMax = 0x7FFFFFFF
} OMX_TIME_SEEKMODETYPE;

/* Structure representing the seekmode of the component */
typedef struct OMX_TIME_CONFIG_SEEKMODETYPE {
    OMX_U32 nSize;                  /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion;       /**< OMX specification version information */
    OMX_TIME_SEEKMODETYPE eType;    /**< The seek mode */
} OMX_TIME_CONFIG_SEEKMODETYPE;

/** Structure representing a time stamp used with the following configs 
 * on the Clock Component (CC):
 * 
 * OMX_IndexConfigTimeCurrentWallTime: query of the CCs current wall  
 *     time
 * OMX_IndexConfigTimeCurrentMediaTime: query of the CCs current media
 *     time
 * OMX_IndexConfigTimeCurrentAudioReference and  
 * OMX_IndexConfigTimeCurrentVideoReference: audio/video reference 
 *     clock sending SC its reference time
 * OMX_IndexConfigTimeClientStartTime: a Clock Component client sends 
 *     this structure to the Clock Component via a SetConfig on its 
 *     client port when it receives a buffer with
 *     OMX_BUFFERFLAG_STARTTIME set. It must use the timestamp
 *     specified by that buffer for nStartTimestamp. 
 *
 * Its also used with the following config on components in general:
 *
 * OMX_IndexConfigTimePosition: IL client querying component position 
 * (GetConfig) or commanding a component to seek to the given location
 * (SetConfig)
 */	
typedef struct OMX_TIME_CONFIG_TIMESTAMPTYPE {
    OMX_U32 nSize;               /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion;    /**< OMX specification version
                                  *   information */
    OMX_U32 nPortIndex;     /**< port that this structure applies to */
    OMX_TICKS nTimestamp;  	     /**< timestamp .*/ 
} OMX_TIME_CONFIG_TIMESTAMPTYPE;  

/** Enumeration of possible reference clocks to the media time. */
typedef enum OMX_TIME_UPDATETYPE {
      OMX_TIME_UpdateRequestFulfillment,    /**< Update is the fulfillment of a media time request. */
      OMX_TIME_UpdateScaleChanged,	        /**< Update was generated because the scale chagned. */
      OMX_TIME_UpdateClockStateChanged,     /**< Update was generated because the clock state changed. */
      OMX_TIME_UpdateKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
      OMX_TIME_UpdateVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
      OMX_TIME_UpdateMax = 0x7FFFFFFF
} OMX_TIME_UPDATETYPE;

/** Enumeration of possible reference clocks to the media time. */
typedef enum OMX_TIME_REFCLOCKTYPE {
      OMX_TIME_RefClockNone,    /**< Use no references. */
      OMX_TIME_RefClockAudio,	/**< Use references sent through OMX_IndexConfigTimeCurrentAudioReference */
      OMX_TIME_RefClockVideo,   /**< Use references sent through OMX_IndexConfigTimeCurrentVideoReference */
      OMX_TIME_RefClockKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
      OMX_TIME_RefClockVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
      OMX_TIME_RefClockMax = 0x7FFFFFFF
} OMX_TIME_REFCLOCKTYPE;

/** Enumeration of clock states. */
typedef enum OMX_TIME_CLOCKSTATE {
      OMX_TIME_ClockStateRunning,             /**< Clock running. */
      OMX_TIME_ClockStateWaitingForStartTime, /**< Clock waiting until the 
                                               *   prescribed clients emit their
                                               *   start time. */
      OMX_TIME_ClockStateStopped,             /**< Clock stopped. */
      OMX_TIME_ClockStateKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
      OMX_TIME_ClockStateVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
      OMX_TIME_ClockStateMax = 0x7FFFFFFF
} OMX_TIME_CLOCKSTATE;

/** Structure representing a media time request to the clock component.
 *
 *  A client component sends this structure to the Clock Component via a SetConfig
 *  on its client port to specify a media timestamp the Clock Component
 *  should emit.  The Clock Component should fulfill the request by sending a
 *  OMX_TIME_MEDIATIMETYPE when its media clock matches the requested 
 *  timestamp.
 *
 *  The client may require a media time request be fulfilled slightly
 *  earlier than the media time specified. In this case the client specifies 
 *  an offset which is equal to the difference between wall time corresponding 
 *  to the requested media time and the wall time when it will be 
 *  fulfilled. 
 *
 *  A client component may uses these requests and the OMX_TIME_MEDIATIMETYPE to
 *  time events according to timestamps. If a client must perform an operation O at
 *  a time T (e.g. deliver a video frame at its corresponding timestamp), it makes a 
 *  media time request at T (perhaps specifying an offset to ensure the request fulfillment
 *  is a little early). When the clock component passes the resulting OMX_TIME_MEDIATIMETYPE
 *  structure back to the client component, the client may perform operation O (perhaps having
 *  to wait a slight amount more time itself as specified by the return values).
 */

typedef struct OMX_TIME_CONFIG_MEDIATIMEREQUESTTYPE {
    OMX_U32 nSize;              /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
    OMX_U32 nPortIndex;         /**< port that this structure applies to */
    OMX_PTR pClientPrivate;     /**< Client private data to disabiguate this media time 
                                 *   from others (e.g. the number of the frame to deliver). 
                                 *   Duplicated in the media time structure that fulfills 
                                 *   this request. A value of zero is reserved for time scale 
                                 *   updates. */
    OMX_TICKS nMediaTimestamp;  /**< Media timestamp requested.*/ 
    OMX_TICKS nOffset;          /**< Amount of wall clock time by which this
                                 *   request should be fulfilled early */
} OMX_TIME_CONFIG_MEDIATIMEREQUESTTYPE;

/**< Structure sent from the clock component client either when fulfilling 
 *   a media time request or when the time scale has changed. 
 *
 *   In the former case the Clock Component fills this structure and times its emission 
 *   to a client component (via the client port) according to the corresponding media 
 *   time request sent by the client. The Clock Component should time the emission to occur
 *   when the requested timestamp matches the Clock Component's media time but also the 
 *   prescribed offset early. 
 *
 *   Upon scale changes the clock component clears the nClientPrivate data, sends the current
 *   media time and sets the nScale to the new scale via the client port. It emits a 
 *   OMX_TIME_MEDIATIMETYPE to all clients independent of any requests. This allows clients to 
 *   alter processing to accomodate scaling. For instance a video component might skip inter-frames 
 *   in the case of extreme fastforward. Likewise an audio component might add or remove samples 
 *   from an audio frame to scale audio data. 
 *
 *   It is expected that some clock components may not be able to fulfill requests
 *   at exactly the prescribed time. This is acceptable so long as the request is 
 *   fulfilled at least as early as described and not later. This structure provides 
 *   fields the client may use to wait for the remaining time.
 *
 *   The client may use either the nOffset or nWallTimeAtMedia fields to determine the 
 *   wall time until the nMediaTimestamp actually occurs. In the latter case the
 *   client can get a more accurate value for offset by getting the current wall
 *   from the cloc component and subtracting it from nWallTimeAtMedia. 
 */

typedef struct OMX_TIME_MEDIATIMETYPE {
    OMX_U32 nSize;                  /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion;       /**< OMX specification version information */
    OMX_U32 nClientPrivate;         /**< Client private data to disabiguate this media time 
                                     *   from others. Copied from the media time request. 
                                     *   A value of zero is reserved for time scale updates. */
    OMX_TIME_UPDATETYPE eUpdateType; /**< Reason for the update */
    OMX_TICKS nMediaTimestamp;      /**< Media time requested. If no media time was 
                                     *   requested then this is the current media time. */ 
    OMX_TICKS nOffset;              /**< Amount of wall clock time by which this
                                     *   request was actually fulfilled early */

    OMX_TICKS nWallTimeAtMediaTime; /**< Wall time corresponding to nMediaTimeStamp.
                                     *   A client may compare this value to current
                                     *   media time obtained from the Clock Component to determine
                                     *   the wall time until the media timestamp is really
                                     *   current. */
    OMX_S32 xScale;                 /**< Current media time scale in Q16 format. */
    OMX_TIME_CLOCKSTATE eState;     /* Seeking Change. Added 7/12.*/
                                    /**< State of the media time. */
} OMX_TIME_MEDIATIMETYPE;  

/** Structure representing the current media time scale factor. Applicable only to clock 
 *  component, other components see scale changes via OMX_TIME_MEDIATIMETYPE buffers sent via
 *  the clock component client ports. Upon recieving this config the clock component changes 
 *  the rate by which the media time increases or decreases effectively implementing trick modes. 
 */ 
typedef struct OMX_TIME_CONFIG_SCALETYPE {
    OMX_U32 nSize;                  /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion;       /**< OMX specification version information */
    OMX_S32 xScale;                 /**< This is a value in Q16 format which is used for
                                     * scaling the media time */
} OMX_TIME_CONFIG_SCALETYPE;
 
/** Bits used to identify a clock port. Used in OMX_TIME_CONFIG_CLOCKSTATETYPEs nWaitMask field */
#define OMX_CLOCKPORT0 0x00000001
#define OMX_CLOCKPORT1 0x00000002
#define OMX_CLOCKPORT2 0x00000004
#define OMX_CLOCKPORT3 0x00000008
#define OMX_CLOCKPORT4 0x00000010
#define OMX_CLOCKPORT5 0x00000020
#define OMX_CLOCKPORT6 0x00000040
#define OMX_CLOCKPORT7 0x00000080

/** Structure representing the current mode of the media clock. 
 *  IL Client uses this config to change or query the mode of the 
 *  media clock of the clock component. Applicable only to clock
 *  component. 
 *  
 *  On a SetConfig if eState is OMX_TIME_ClockStateRunning media time
 *  starts immediately at the prescribed start time. If
 *  OMX_TIME_ClockStateWaitingForStartTime the Clock Component ignores
 *  the given nStartTime and waits for all clients specified in the 
 *  nWaitMask to send starttimes (via 
 *  OMX_IndexConfigTimeClientStartTime). The Clock Component then starts 
 *  the media clock using the earliest start time supplied. */    
typedef struct OMX_TIME_CONFIG_CLOCKSTATETYPE {
    OMX_U32 nSize;              /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion;   /**< OMX specification version 
                                 *   information */
    OMX_TIME_CLOCKSTATE eState; /**< State of the media time. */
    OMX_TICKS nStartTime;       /**< Start time of the media time. */
    OMX_TICKS nOffset;          /**< Time to offset the media time by 
                                 * (e.g. preroll). Media time will be
                                 * reported to be nOffset ticks earlier.     
                                 */
    OMX_U32 nWaitMask;          /**< Mask of OMX_CLOCKPORT values. */
} OMX_TIME_CONFIG_CLOCKSTATETYPE;

/** Structure representing the reference clock currently being used to
 *  compute media time. IL client uses this config to change or query the 
 *  clock component's active reference clock */
typedef struct OMX_TIME_CONFIG_ACTIVEREFCLOCKTYPE {
    OMX_U32 nSize;                  /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion;       /**< OMX specification version information */
    OMX_TIME_REFCLOCKTYPE eClock;   /**< Reference clock used to compute media time */                        
} OMX_TIME_CONFIG_ACTIVEREFCLOCKTYPE;

/** Descriptor for setting specifics of power type.
 *  Note: this structure is listed for backwards compatibility. */
typedef struct OMX_OTHER_CONFIG_POWERTYPE {
    OMX_U32 nSize;            /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
    OMX_BOOL bEnablePM;       /**< Flag to enable Power Management */
} OMX_OTHER_CONFIG_POWERTYPE;


/** Descriptor for setting specifics of stats type.
 *  Note: this structure is listed for backwards compatibility. */
typedef struct OMX_OTHER_CONFIG_STATSTYPE {
    OMX_U32 nSize;            /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
    /* what goes here */
} OMX_OTHER_CONFIG_STATSTYPE;


/**
 * The PortDefinition structure is used to define all of the parameters 
 * necessary for the compliant component to setup an input or an output other 
 * path.
 */
typedef struct OMX_OTHER_PORTDEFINITIONTYPE {
    OMX_OTHER_FORMATTYPE eFormat;  /**< Type of data expected for this channel */
} OMX_OTHER_PORTDEFINITIONTYPE;

/**  Port format parameter.  This structure is used to enumerate
  *  the various data input/output format supported by the port.
  */
typedef struct OMX_OTHER_PARAM_PORTFORMATTYPE {
    OMX_U32 nSize; /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
    OMX_U32 nPortIndex; /**< Indicates which port to set */
    OMX_U32 nIndex; /**< Indicates the enumeration index for the format from 0x0 to N-1 */
    OMX_OTHER_FORMATTYPE eFormat; /**< Type of data expected for this channel */
} OMX_OTHER_PARAM_PORTFORMATTYPE; 

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif
/* File EOF */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /*
 * Copyright (c) 2008 The Khronos Group Inc. 
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject
 * to the following conditions: 
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software. 
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
 *
 */

/** OMX_Types.h - OpenMax IL version 1.1.2
 *  The OMX_Types header file contains the primitive type definitions used by 
 *  the core, the application and the component.  This file may need to be
 *  modified to be used on systems that do not have "char" set to 8 bits, 
 *  "short" set to 16 bits and "long" set to 32 bits.
 */

#ifndef OMX_Types_h
#define OMX_Types_h

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

/** The OMX_API and OMX_APIENTRY are platform specific definitions used
 *  to declare OMX function prototypes.  They are modified to meet the
 *  requirements for a particular platform */
#ifdef __SYMBIAN32__   
#   ifdef __OMX_EXPORTS
#       define OMX_API __declspec(dllexport)
#   else
#       ifdef _WIN32
#           define OMX_API __declspec(dllexport) 
#       else
#           define OMX_API __declspec(dllimport)
#       endif
#   endif
#else
#   if defined(_WIN32) && !defined(__MINGW32__)
#      ifdef __OMX_EXPORTS
#          define OMX_API __declspec(dllexport)
#      else
#          define OMX_API __declspec(dllimport)
#      endif
#   else
#      ifdef __OMX_EXPORTS
#          define OMX_API
#      else
#          define OMX_API extern
#      endif
#   endif
#endif

#ifndef OMX_APIENTRY
#define OMX_APIENTRY 
#endif 

/** OMX_IN is used to identify inputs to an OMX function.  This designation 
    will also be used in the case of a pointer that points to a parameter 
    that is used as an output. */
#ifndef OMX_IN
#define OMX_IN
#endif

/** OMX_OUT is used to identify outputs from an OMX function.  This 
    designation will also be used in the case of a pointer that points 
    to a parameter that is used as an input. */
#ifndef OMX_OUT
#define OMX_OUT
#endif


/** OMX_INOUT is used to identify parameters that may be either inputs or
    outputs from an OMX function at the same time.  This designation will 
    also be used in the case of a pointer that  points to a parameter that 
    is used both as an input and an output. */
#ifndef OMX_INOUT
#define OMX_INOUT
#endif

/** OMX_ALL is used to as a wildcard to select all entities of the same type
 *  when specifying the index, or referring to a object by an index.  (i.e.
 *  use OMX_ALL to indicate all N channels). When used as a port index
 *  for a config or parameter this OMX_ALL denotes that the config or
 *  parameter applies to the entire component not just one port. */
#define OMX_ALL 0xFFFFFFFF

/** In the following we define groups that help building doxygen documentation */

/** @defgroup core OpenMAX IL core
 * Functions and structure related to the OMX IL core
 */
 
 /** @defgroup comp OpenMAX IL component
 * Functions and structure related to the OMX IL component
 */
 
/** @defgroup rpm Resource and Policy Management 
 * Structures for resource and policy management of components
 */

/** @defgroup buf Buffer Management
 * Buffer handling functions and structures
 */
  
/** @defgroup tun Tunneling
 * @ingroup core comp
 * Structures and functions to manage tunnels among component ports
 */
 
/** @defgroup cp Content Pipes
 *  @ingroup core
 */
 
 /** @defgroup metadata Metadata handling
  * 
  */ 

#if defined(__GNUC__)
#include <stdint.h>
#define STDINT_H_AVAILABLE
#endif

/** OMX_U8 is an 8 bit unsigned quantity that is byte aligned */
typedef unsigned char OMX_U8;

/** OMX_S8 is an 8 bit signed quantity that is byte aligned */
typedef signed char OMX_S8;

/** OMX_U16 is a 16 bit unsigned quantity that is 16 bit word aligned */
typedef unsigned short OMX_U16;

/** OMX_S16 is a 16 bit signed quantity that is 16 bit word aligned */
typedef signed short OMX_S16;

/** OMX_U32 is a 32 bit unsigned quantity that is 32 bit word aligned */
#ifdef STDINT_H_AVAILABLE
typedef uint32_t OMX_U32;
#else
typedef unsigned long OMX_U32;
#endif

/** OMX_S32 is a 32 bit signed quantity that is 32 bit word aligned */
#ifdef STDINT_H_AVAILABLE
typedef int32_t OMX_S32;
#else
typedef signed long OMX_S32;
#endif


/* Users with compilers that cannot accept the "long long" designation should
   define the OMX_SKIP64BIT macro.  It should be noted that this may cause 
   some components to fail to compile if the component was written to require
   64 bit integral types.  However, these components would NOT compile anyway
   since the compiler does not support the way the component was written.
*/
#ifndef OMX_SKIP64BIT
#ifdef __SYMBIAN32__
/** OMX_U64 is a 64 bit unsigned quantity that is 64 bit word aligned */
typedef unsigned long long OMX_U64;

/** OMX_S64 is a 64 bit signed quantity that is 64 bit word aligned */
typedef signed long long OMX_S64;

#elif defined(WIN32)

/** OMX_U64 is a 64 bit unsigned quantity that is 64 bit word aligned */   
typedef unsigned __int64  OMX_U64;

/** OMX_S64 is a 64 bit signed quantity that is 64 bit word aligned */
typedef signed   __int64  OMX_S64;

#else /* WIN32 */

/** OMX_U64 is a 64 bit unsigned quantity that is 64 bit word aligned */
typedef unsigned long long OMX_U64;

/** OMX_S64 is a 64 bit signed quantity that is 64 bit word aligned */
typedef signed long long OMX_S64;

#endif /* WIN32 */
#endif


/** The OMX_BOOL type is intended to be used to represent a true or a false 
    value when passing parameters to and from the OMX core and components.  The
    OMX_BOOL is a 32 bit quantity and is aligned on a 32 bit word boundary.
 */
typedef enum OMX_BOOL {
    OMX_FALSE = 0,
    OMX_TRUE = !OMX_FALSE,
    OMX_BOOL_MAX = 0x7FFFFFFF
} OMX_BOOL; 
 
/** The OMX_PTR type is intended to be used to pass pointers between the OMX
    applications and the OMX Core and components.  This is a 32 bit pointer and
    is aligned on a 32 bit boundary.
 */
typedef void* OMX_PTR;

/** The OMX_STRING type is intended to be used to pass "C" type strings between
    the application and the core and component.  The OMX_STRING type is a 32 
    bit pointer to a zero terminated string.  The  pointer is word aligned and 
    the string is byte aligned.  
 */
typedef char* OMX_STRING;

/** The OMX_BYTE type is intended to be used to pass arrays of bytes such as
    buffers between the application and the component and core.  The OMX_BYTE 
    type is a 32 bit pointer to a zero terminated string.  The  pointer is word
    aligned and the string is byte aligned.
 */
typedef unsigned char* OMX_BYTE;

/** OMX_UUIDTYPE is a very long unique identifier to uniquely identify
    at runtime.  This identifier should be generated by a component in a way
    that guarantees that every instance of the identifier running on the system
    is unique. */
typedef unsigned char OMX_UUIDTYPE[128];

/** The OMX_DIRTYPE enumeration is used to indicate if a port is an input or
    an output port.  This enumeration is common across all component types.    
 */
typedef enum OMX_DIRTYPE
{
    OMX_DirInput,              /**< Port is an input port */
    OMX_DirOutput,             /**< Port is an output port */
    OMX_DirMax = 0x7FFFFFFF
} OMX_DIRTYPE;

/** The OMX_ENDIANTYPE enumeration is used to indicate the bit ordering 
    for numerical data (i.e. big endian, or little endian).    
 */
typedef enum OMX_ENDIANTYPE
{
    OMX_EndianBig, /**< big endian */
    OMX_EndianLittle, /**< little endian */
    OMX_EndianMax = 0x7FFFFFFF
} OMX_ENDIANTYPE;


/** The OMX_NUMERICALDATATYPE enumeration is used to indicate if data 
    is signed or unsigned
 */
typedef enum OMX_NUMERICALDATATYPE
{
    OMX_NumericalDataSigned, /**< signed data */
    OMX_NumericalDataUnsigned, /**< unsigned data */
    OMX_NumercialDataMax = 0x7FFFFFFF
} OMX_NUMERICALDATATYPE;


/** Unsigned bounded value type */
typedef struct OMX_BU32 {
    OMX_U32 nValue; /**< actual value */
    OMX_U32 nMin;   /**< minimum for value (i.e. nValue >= nMin) */
    OMX_U32 nMax;   /**< maximum for value (i.e. nValue <= nMax) */
} OMX_BU32;


/** Signed bounded value type */
typedef struct OMX_BS32 {
    OMX_S32 nValue; /**< actual value */
    OMX_S32 nMin;   /**< minimum for value (i.e. nValue >= nMin) */
    OMX_S32 nMax;   /**< maximum for value (i.e. nValue <= nMax) */
} OMX_BS32;


/** Structure representing some time or duration in microseconds. This structure
  *  must be interpreted as a signed 64 bit value. The quantity is signed to accommodate 
  *  negative deltas and preroll scenarios. The quantity is represented in microseconds 
  *  to accomodate high resolution timestamps (e.g. DVD presentation timestamps based
  *  on a 90kHz clock) and to allow more accurate and synchronized delivery (e.g. 
  *  individual audio samples delivered at 192 kHz). The quantity is 64 bit to 
  *  accommodate a large dynamic range (signed 32 bit values would allow only for plus
  *  or minus 35 minutes).
  *
  *  Implementations with limited precision may convert the signed 64 bit value to 
  *  a signed 32 bit value internally but risk loss of precision.  
  */
#ifndef OMX_SKIP64BIT
typedef OMX_S64 OMX_TICKS;
#else
typedef struct OMX_TICKS
{
    OMX_U32 nLowPart;    /** low bits of the signed 64 bit tick value */
    OMX_U32 nHighPart;   /** high bits of the signed 64 bit tick value */
} OMX_TICKS;
#endif
#define OMX_TICKS_PER_SECOND 1000000

/** Define the public interface for the OMX Handle.  The core will not use
    this value internally, but the application should only use this value.
 */
typedef void* OMX_HANDLETYPE;

typedef struct OMX_MARKTYPE
{
    OMX_HANDLETYPE hMarkTargetComponent;   /**< The component that will 
                                                generate a mark event upon 
                                                processing the mark. */
    OMX_PTR pMarkData;   /**< Application specific data associated with 
                              the mark sent on a mark event to disambiguate 
                              this mark from others. */
} OMX_MARKTYPE;


/** OMX_NATIVE_DEVICETYPE is used to map a OMX video port to the
 *  platform & operating specific object used to reference the display 
 *  or can be used by a audio port for native audio rendering */
typedef void* OMX_NATIVE_DEVICETYPE;

/** OMX_NATIVE_WINDOWTYPE is used to map a OMX video port to the
 *  platform & operating specific object used to reference the window */
typedef void* OMX_NATIVE_WINDOWTYPE;


/** Define the OMX IL version that corresponds to this set of header files.
 *  We also define a combined version that can be used to write or compare
 *  values of the 32bit nVersion field, assuming a little endian architecture */
#define OMX_VERSION_MAJOR 1
#define OMX_VERSION_MINOR 1
#define OMX_VERSION_REVISION 2
#define OMX_VERSION_STEP 0

#define OMX_VERSION ((OMX_VERSION_STEP<<24) | (OMX_VERSION_REVISION<<16) | (OMX_VERSION_MINOR<<8) | OMX_VERSION_MAJOR)


/** The OMX_VERSIONTYPE union is used to specify the version for
    a structure or component.  For a component, the version is entirely
    specified by the component vendor.  Components doing the same function
    from different vendors may or may not have the same version.  For 
    structures, the version shall be set by the entity that allocates the
    structure.  For structures specified in the OMX 1.1 specification, the
    value of the version shall be set to 1.1.0.0 in all cases.  Access to the
    OMX_VERSIONTYPE can be by a single 32 bit access (e.g. by nVersion) or
    by accessing one of the structure elements to, for example, check only
    the Major revision.
 */
typedef union OMX_VERSIONTYPE
{
    struct
    {
        OMX_U8 nVersionMajor;   /**< Major version accessor element */
        OMX_U8 nVersionMinor;   /**< Minor version accessor element */
        OMX_U8 nRevision;       /**< Revision version accessor element */
        OMX_U8 nStep;           /**< Step version accessor element */
    } s;
    OMX_U32 nVersion;           /**< 32 bit value to make accessing the
                                    version easily done in a single word
                                    size copy/compare operation */
} OMX_VERSIONTYPE;

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif
/* File EOF */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      /**
 * Copyright (c) 2008 The Khronos Group Inc. 
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject
 * to the following conditions: 
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software. 
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
 *
 */

/** 
 *  @file OMX_Video.h - OpenMax IL version 1.1.2
 *  The structures is needed by Video components to exchange parameters 
 *  and configuration data with OMX components.
 */
#ifndef OMX_Video_h
#define OMX_Video_h

/** @defgroup video OpenMAX IL Video Domain
 * @ingroup iv
 * Structures for OpenMAX IL Video domain
 * @{
 */

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */


/**
 * Each OMX header must include all required header files to allow the
 * header to compile without errors.  The includes below are required
 * for this header file to compile successfully 
 */

#include "OMX_IVCommon.h"


/**
 * Enumeration used to define the possible video compression codings.  
 * NOTE:  This essentially refers to file extensions. If the coding is 
 *        being used to specify the ENCODE type, then additional work 
 *        must be done to configure the exact flavor of the compression 
 *        to be used.  For decode cases where the user application can 
 *        not differentiate between MPEG-4 and H.264 bit streams, it is 
 *        up to the codec to handle this.
 */
typedef enum OMX_VIDEO_CODINGTYPE {
    OMX_VIDEO_CodingUnused,     /**< Value when coding is N/A */
    OMX_VIDEO_CodingAutoDetect, /**< Autodetection of coding type */
    OMX_VIDEO_CodingMPEG2,      /**< AKA: H.262 */
    OMX_VIDEO_CodingH263,       /**< H.263 */
    OMX_VIDEO_CodingMPEG4,      /**< MPEG-4 */
    OMX_VIDEO_CodingWMV,        /**< all versions of Windows Media Video */
    OMX_VIDEO_CodingRV,         /**< all versions of Real Video */
    OMX_VIDEO_CodingAVC,        /**< H.264/AVC */
    OMX_VIDEO_CodingMJPEG,      /**< Motion JPEG */
    OMX_VIDEO_CodingKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_VIDEO_CodingVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */

#define OMX_AUDIO_CodingVP6_Supported 1
    OMX_VIDEO_CodingVP6,        /**< On2 VP6 */
#define OMX_AUDIO_CodingVP7_Supported 1
    OMX_VIDEO_CodingVP7,        /**< On2 VP7 */
#define OMX_AUDIO_CodingVP8_Supported 1
    OMX_VIDEO_CodingVP8,        /**< On2 VP8 */
#define OMX_AUDIO_CodingYUV_Supported 1
    OMX_VIDEO_CodingYUV,        /* raw YUV video */
#define OMX_AUDIO_CodingSorenson_Supported 1
    OMX_VIDEO_CodingSorenson,   /**< Sorenson */
#define OMX_AUDIO_CodingTheora_Supported 1
    OMX_VIDEO_CodingTheora,     /**< Theora */
#define OMX_AUDIO_CodingMVC_Supported 1
    OMX_VIDEO_CodingMVC,        /**< H.264/MVC */ 	
    
    OMX_VIDEO_CodingMax = 0x7FFFFFFF
} OMX_VIDEO_CODINGTYPE;


/**
 * Data structure used to define a video path.  The number of Video paths for 
 * input and output will vary by type of the Video component.  
 * 
 *    Input (aka Source) : zero Inputs, one Output,
 *    Splitter           : one Input, 2 or more Outputs,
 *    Processing Element : one Input, one output,
 *    Mixer              : 2 or more inputs, one output,
 *    Output (aka Sink)  : one Input, zero outputs.
 * 
 * The PortDefinition structure is used to define all of the parameters 
 * necessary for the compliant component to setup an input or an output video 
 * path.  If additional vendor specific data is required, it should be 
 * transmitted to the component using the CustomCommand function.  Compliant 
 * components will prepopulate this structure with optimal values during the 
 * GetDefaultInitParams command.
 *
 * STRUCT MEMBERS:
 *  cMIMEType             : MIME type of data for the port
 *  pNativeRender         : Platform specific reference for a display if a 
 *                          sync, otherwise this field is 0
 *  nFrameWidth           : Width of frame to be used on channel if 
 *                          uncompressed format is used.  Use 0 for unknown,
 *                          don't care or variable
 *  nFrameHeight          : Height of frame to be used on channel if 
 *                          uncompressed format is used. Use 0 for unknown,
 *                          don't care or variable
 *  nStride               : Number of bytes per span of an image 
 *                          (i.e. indicates the number of bytes to get
 *                          from span N to span N+1, where negative stride
 *                          indicates the image is bottom up
 *  nSliceHeight          : Height used when encoding in slices
 *  nBitrate              : Bit rate of frame to be used on channel if 
 *                          compressed format is used. Use 0 for unknown, 
 *                          don't care or variable
 *  xFramerate            : Frame rate to be used on channel if uncompressed 
 *                          format is used. Use 0 for unknown, don't care or 
 *                          variable.  Units are Q16 frames per second.
 *  bFlagErrorConcealment : Turns on error concealment if it is supported by 
 *                          the OMX component
 *  eCompressionFormat    : Compression format used in this instance of the 
 *                          component. When OMX_VIDEO_CodingUnused is 
 *                          specified, eColorFormat is used
 *  eColorFormat : Decompressed format used by this component
 *  pNativeWindow : Platform specific reference for a window object if a 
 *                          display sink , otherwise this field is 0x0. 
 */
typedef struct OMX_VIDEO_PORTDEFINITIONTYPE {
    OMX_STRING cMIMEType;
    OMX_NATIVE_DEVICETYPE pNativeRender;
    OMX_U32 nFrameWidth;
    OMX_U32 nFrameHeight;
    OMX_S32 nStride;
    OMX_U32 nSliceHeight;
    OMX_U32 nBitrate;
    OMX_U32 xFramerate;
    OMX_BOOL bFlagErrorConcealment;
    OMX_VIDEO_CODINGTYPE eCompressionFormat;
    OMX_COLOR_FORMATTYPE eColorFormat;
    OMX_NATIVE_WINDOWTYPE pNativeWindow;
} OMX_VIDEO_PORTDEFINITIONTYPE;

/**  
 * Port format parameter.  This structure is used to enumerate the various 
 * data input/output format supported by the port.
 * 
 * STRUCT MEMBERS:
 *  nSize              : Size of the structure in bytes
 *  nVersion           : OMX specification version information
 *  nPortIndex         : Indicates which port to set
 *  nIndex             : Indicates the enumeration index for the format from 
 *                       0x0 to N-1
 *  eCompressionFormat : Compression format used in this instance of the 
 *                       component. When OMX_VIDEO_CodingUnused is specified, 
 *                       eColorFormat is used 
 *  eColorFormat       : Decompressed format used by this component
 *  xFrameRate         : Indicates the video frame rate in Q16 format
 */
typedef struct OMX_VIDEO_PARAM_PORTFORMATTYPE {
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_U32 nPortIndex;
    OMX_U32 nIndex;
    OMX_VIDEO_CODINGTYPE eCompressionFormat; 
    OMX_COLOR_FORMATTYPE eColorFormat;
    OMX_U32 xFramerate;
} OMX_VIDEO_PARAM_PORTFORMATTYPE;


/**
 * This is a structure for configuring video compression quantization 
 * parameter values.  Codecs may support different QP values for different
 * frame types.
 *
 * STRUCT MEMBERS:
 *  nSize      : Size of the structure in bytes
 *  nVersion   : OMX specification version info
 *  nPortIndex : Port that this structure applies to
 *  nQpI       : QP value to use for index frames
 *  nQpP       : QP value to use for P frames
 *  nQpB       : QP values to use for bidirectional frames 
 */
typedef struct OMX_VIDEO_PARAM_QUANTIZATIONTYPE {
    OMX_U32 nSize;            
    OMX_VERSIONTYPE nVersion;
    OMX_U32 nPortIndex;
    OMX_U32 nQpI;
    OMX_U32 nQpP;
    OMX_U32 nQpB;
} OMX_VIDEO_PARAM_QUANTIZATIONTYPE;


/** 
 * Structure for configuration of video fast update parameters. 
 *  
 * STRUCT MEMBERS:
 *  nSize      : Size of the structure in bytes
 *  nVersion   : OMX specification version info 
 *  nPortIndex : Port that this structure applies to
 *  bEnableVFU : Enable/Disable video fast update
 *  nFirstGOB  : Specifies the number of the first macroblock row
 *  nFirstMB   : specifies the first MB relative to the specified first GOB
 *  nNumMBs    : Specifies the number of MBs to be refreshed from nFirstGOB 
 *               and nFirstMB
 */
typedef struct OMX_VIDEO_PARAM_VIDEOFASTUPDATETYPE {
    OMX_U32 nSize;            
    OMX_VERSIONTYPE nVersion; 
    OMX_U32 nPortIndex;       
    OMX_BOOL bEnableVFU;      
    OMX_U32 nFirstGOB;                            
    OMX_U32 nFirstMB;                            
    OMX_U32 nNumMBs;                                  
} OMX_VIDEO_PARAM_VIDEOFASTUPDATETYPE;


/** 
 * Enumeration of possible bitrate control types 
 */
typedef enum OMX_VIDEO_CONTROLRATETYPE {
    OMX_Video_ControlRateDisable,
    OMX_Video_ControlRateVariable,
    OMX_Video_ControlRateConstant,
    OMX_Video_ControlRateVariableSkipFrames,
    OMX_Video_ControlRateConstantSkipFrames,
    OMX_Video_ControlRateKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_Video_ControlRateVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_Video_ControlRateMax = 0x7FFFFFFF
} OMX_VIDEO_CONTROLRATETYPE;


/** 
 * Structure for configuring bitrate mode of a codec. 
 *
 * STRUCT MEMBERS:
 *  nSize          : Size of the struct in bytes
 *  nVersion       : OMX spec version info
 *  nPortIndex     : Port that this struct applies to
 *  eControlRate   : Control rate type enum
 *  nTargetBitrate : Target bitrate to encode with
 */
typedef struct OMX_VIDEO_PARAM_BITRATETYPE {
    OMX_U32 nSize;                          
    OMX_VERSIONTYPE nVersion;               
    OMX_U32 nPortIndex;                     
    OMX_VIDEO_CONTROLRATETYPE eControlRate; 
    OMX_U32 nTargetBitrate;                 
} OMX_VIDEO_PARAM_BITRATETYPE;


/** 
 * Enumeration of possible motion vector (MV) types 
 */
typedef enum OMX_VIDEO_MOTIONVECTORTYPE {
    OMX_Video_MotionVectorPixel,
    OMX_Video_MotionVectorHalfPel,
    OMX_Video_MotionVectorQuarterPel,
    OMX_Video_MotionVectorEighthPel,
    OMX_Video_MotionVectorKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_Video_MotionVectorVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_Video_MotionVectorMax = 0x7FFFFFFF
} OMX_VIDEO_MOTIONVECTORTYPE;


/**
 * Structure for configuring the number of motion vectors used as well
 * as their accuracy.
 * 
 * STRUCT MEMBERS:
 *  nSize            : Size of the struct in bytes
 *  nVersion         : OMX spec version info
 *  nPortIndex       : port that this structure applies to
 *  eAccuracy        : Enumerated MV accuracy
 *  bUnrestrictedMVs : Allow unrestricted MVs
 *  bFourMV          : Allow use of 4 MVs
 *  sXSearchRange    : Search range in horizontal direction for MVs
 *  sYSearchRange    : Search range in vertical direction for MVs
 */
typedef struct OMX_VIDEO_PARAM_MOTIONVECTORTYPE {
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_U32 nPortIndex;
    OMX_VIDEO_MOTIONVECTORTYPE eAccuracy;
    OMX_BOOL bUnrestrictedMVs;
    OMX_BOOL bFourMV;
    OMX_S32 sXSearchRange;
    OMX_S32 sYSearchRange;
} OMX_VIDEO_PARAM_MOTIONVECTORTYPE;


/** 
 * Enumeration of possible methods to use for Intra Refresh 
 */
typedef enum OMX_VIDEO_INTRAREFRESHTYPE {
    OMX_VIDEO_IntraRefreshCyclic,                         /**< Cyclic intra refresh, bit 0 is set*/
    OMX_VIDEO_IntraRefreshAdaptive,                       /**< Adaptive intra refresh, bit 1 is set*/
    OMX_VIDEO_IntraRefreshBoth,                           /**< Cyclic + Adaptive intra refresh (no mrows since bit 2 is off)*/
    OMX_VIDEO_IntraRefreshKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_VIDEO_IntraRefreshVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_VIDEO_IntraRefreshCyclicMrows,                    /**< Cyclic intra refresh, multiple rows at a time bits 0 and 2 are set*/
    OMX_VIDEO_IntraRefreshPseudoRand,                     /**< Pseudo random intra refresh, uses bit 3*/
    OMX_VIDEO_IntraRefreshMax = 0x7FFFFFFF
} OMX_VIDEO_INTRAREFRESHTYPE;


/**
 * Structure for configuring intra refresh mode 
 * 
 * STRUCT MEMBERS:
 *  nSize        : Size of the structure in bytes
 *  nVersion     : OMX specification version information
 *  nPortIndex   : Port that this structure applies to
 *  eRefreshMode : Cyclic, Adaptive, or Both
 *  nAirMBs      : Number of intra macroblocks to refresh in a frame when 
 *                 AIR is enabled
 *  nAirRef      : Number of times a motion marked macroblock has to be  
 *                 intra coded
 *  nCirMBs      : Number of consecutive macroblocks to be coded as "intra"  
 *                 when CIR is enabled
 */
typedef struct OMX_VIDEO_PARAM_INTRAREFRESHTYPE {
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_U32 nPortIndex;
    OMX_VIDEO_INTRAREFRESHTYPE eRefreshMode;
    OMX_U32 nAirMBs;
    OMX_U32 nAirRef;
    OMX_U32 nCirMBs;
    OMX_U32 nPirMBs;
} OMX_VIDEO_PARAM_INTRAREFRESHTYPE;


/**
 * Structure for enabling various error correction methods for video 
 * compression.
 *
 * STRUCT MEMBERS:
 *  nSize                   : Size of the structure in bytes
 *  nVersion                : OMX specification version information 
 *  nPortIndex              : Port that this structure applies to 
 *  bEnableHEC              : Enable/disable header extension codes (HEC)
 *  bEnableResync           : Enable/disable resynchronization markers
 *  nResynchMarkerSpacing   : Resynch markers interval (in bits) to be 
 *                            applied in the stream 
 *  bEnableDataPartitioning : Enable/disable data partitioning 
 *  bEnableRVLC             : Enable/disable reversible variable length 
 *                            coding
 */
typedef struct OMX_VIDEO_PARAM_ERRORCORRECTIONTYPE {
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_U32 nPortIndex;
    OMX_BOOL bEnableHEC;
    OMX_BOOL bEnableResync;
    OMX_U32  nResynchMarkerSpacing;
    OMX_BOOL bEnableDataPartitioning;
    OMX_BOOL bEnableRVLC;
} OMX_VIDEO_PARAM_ERRORCORRECTIONTYPE;


/** 
 * Configuration of variable block-size motion compensation (VBSMC) 
 * 
 * STRUCT MEMBERS:
 *  nSize      : Size of the structure in bytes
 *  nVersion   : OMX specification version information 
 *  nPortIndex : Port that this structure applies to
 *  b16x16     : Enable inter block search 16x16
 *  b16x8      : Enable inter block search 16x8
 *  b8x16      : Enable inter block search 8x16
 *  b8x8       : Enable inter block search 8x8
 *  b8x4       : Enable inter block search 8x4
 *  b4x8       : Enable inter block search 4x8
 *  b4x4       : Enable inter block search 4x4
 */
typedef struct OMX_VIDEO_PARAM_VBSMCTYPE {
    OMX_U32 nSize; 
    OMX_VERSIONTYPE nVersion; 
    OMX_U32 nPortIndex;       
    OMX_BOOL b16x16; 
    OMX_BOOL b16x8; 
    OMX_BOOL b8x16;
    OMX_BOOL b8x8;
    OMX_BOOL b8x4;
    OMX_BOOL b4x8;
    OMX_BOOL b4x4;
} OMX_VIDEO_PARAM_VBSMCTYPE;


/** 
 * H.263 profile types, each profile indicates support for various 
 * performance bounds and different annexes.
 *
 * ENUMS:
 *  Baseline           : Baseline Profile: H.263 (V1), no optional modes                                                    
 *  H320 Coding        : H.320 Coding Efficiency Backward Compatibility 
 *                       Profile: H.263+ (V2), includes annexes I, J, L.4
 *                       and T
 *  BackwardCompatible : Backward Compatibility Profile: H.263 (V1), 
 *                       includes annex F                                    
 *  ISWV2              : Interactive Streaming Wireless Profile: H.263+ 
 *                       (V2), includes annexes I, J, K and T                 
 *  ISWV3              : Interactive Streaming Wireless Profile: H.263++  
 *                       (V3), includes profile 3 and annexes V and W.6.3.8   
 *  HighCompression    : Conversational High Compression Profile: H.263++  
 *                       (V3), includes profiles 1 & 2 and annexes D and U   
 *  Internet           : Conversational Internet Profile: H.263++ (V3),  
 *                       includes profile 5 and annex K                       
 *  Interlace          : Conversational Interlace Profile: H.263++ (V3),  
 *                       includes profile 5 and annex W.6.3.11               
 *  HighLatency        : High Latency Profile: H.263++ (V3), includes  
 *                       profile 6 and annexes O.1 and P.5                       
 */
typedef enum OMX_VIDEO_H263PROFILETYPE {
    OMX_VIDEO_H263ProfileBaseline            = 0x01,        
    OMX_VIDEO_H263ProfileH320Coding          = 0x02,          
    OMX_VIDEO_H263ProfileBackwardCompatible  = 0x04,  
    OMX_VIDEO_H263ProfileISWV2               = 0x08,               
    OMX_VIDEO_H263ProfileISWV3               = 0x10,               
    OMX_VIDEO_H263ProfileHighCompression     = 0x20,     
    OMX_VIDEO_H263ProfileInternet            = 0x40,            
    OMX_VIDEO_H263ProfileInterlace           = 0x80,           
    OMX_VIDEO_H263ProfileHighLatency         = 0x100,         
    OMX_VIDEO_H263ProfileKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_VIDEO_H263ProfileVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_VIDEO_H263ProfileMax                 = 0x7FFFFFFF  
} OMX_VIDEO_H263PROFILETYPE;


/** 
 * H.263 level types, each level indicates support for various frame sizes, 
 * bit rates, decoder frame rates.
 */
typedef enum OMX_VIDEO_H263LEVELTYPE {
    OMX_VIDEO_H263Level10  = 0x01,  
    OMX_VIDEO_H263Level20  = 0x02,      
    OMX_VIDEO_H263Level30  = 0x04,      
    OMX_VIDEO_H263Level40  = 0x08,      
    OMX_VIDEO_H263Level45  = 0x10,      
    OMX_VIDEO_H263Level50  = 0x20,      
    OMX_VIDEO_H263Level60  = 0x40,      
    OMX_VIDEO_H263Level70  = 0x80, 
    OMX_VIDEO_H263LevelKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_VIDEO_H263LevelVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_VIDEO_H263LevelMax = 0x7FFFFFFF  
} OMX_VIDEO_H263LEVELTYPE;


/** 
 * Specifies the picture type. These values should be OR'd to signal all 
 * pictures types which are allowed.
 *
 * ENUMS:
 *  Generic Picture Types:          I, P and B
 *  H.263 Specific Picture Types:   SI and SP
 *  H.264 Specific Picture Types:   EI and EP
 *  MPEG-4 Specific Picture Types:  S
 */
typedef enum OMX_VIDEO_PICTURETYPE {
    OMX_VIDEO_PictureTypeI   = 0x01,
    OMX_VIDEO_PictureTypeP   = 0x02,
    OMX_VIDEO_PictureTypeB   = 0x04,
    OMX_VIDEO_PictureTypeSI  = 0x08,
    OMX_VIDEO_PictureTypeSP  = 0x10,
    OMX_VIDEO_PictureTypeEI  = 0x11,
    OMX_VIDEO_PictureTypeEP  = 0x12,
    OMX_VIDEO_PictureTypeS   = 0x14,
    OMX_VIDEO_PictureTypeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_VIDEO_PictureTypeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_VIDEO_PictureTypeMax = 0x7FFFFFFF
} OMX_VIDEO_PICTURETYPE;


/** 
 * H.263 Params 
 *
 * STRUCT MEMBERS:
 *  nSize                    : Size of the structure in bytes
 *  nVersion                 : OMX specification version information 
 *  nPortIndex               : Port that this structure applies to
 *  nPFrames                 : Number of P frames between each I frame
 *  nBFrames                 : Number of B frames between each I frame
 *  eProfile                 : H.263 profile(s) to use
 *  eLevel                   : H.263 level(s) to use
 *  bPLUSPTYPEAllowed        : Indicating that it is allowed to use PLUSPTYPE 
 *                             (specified in the 1998 version of H.263) to 
 *                             indicate custom picture sizes or clock 
 *                             frequencies 
 *  nAllowedPictureTypes     : Specifies the picture types allowed in the 
 *                             bitstream
 *  bForceRoundingTypeToZero : value of the RTYPE bit (bit 6 of MPPTYPE) is 
 *                             not constrained. It is recommended to change 
 *                             the value of the RTYPE bit for each reference 
 *                             picture in error-free communication
 *  nPictureHeaderRepetition : Specifies the frequency of picture header 
 *                             repetition
 *  nGOBHeaderInterval       : Specifies the interval of non-empty GOB  
 *                             headers in units of GOBs
 */
typedef struct OMX_VIDEO_PARAM_H263TYPE {
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_U32 nPortIndex;
    OMX_U32 nPFrames;
    OMX_U32 nBFrames;
    OMX_VIDEO_H263PROFILETYPE eProfile;
	OMX_VIDEO_H263LEVELTYPE eLevel;
    OMX_BOOL bPLUSPTYPEAllowed;
    OMX_U32 nAllowedPictureTypes;
    OMX_BOOL bForceRoundingTypeToZero;
    OMX_U32 nPictureHeaderRepetition;
    OMX_U32 nGOBHeaderInterval;
} OMX_VIDEO_PARAM_H263TYPE;


/** 
 * MPEG-2 profile types, each profile indicates support for various 
 * performance bounds and different annexes.
 */
typedef enum OMX_VIDEO_MPEG2PROFILETYPE {
    OMX_VIDEO_MPEG2ProfileSimple = 0,  /**< Simple Profile */
    OMX_VIDEO_MPEG2ProfileMain,        /**< Main Profile */
    OMX_VIDEO_MPEG2Profile422,         /**< 4:2:2 Profile */
    OMX_VIDEO_MPEG2ProfileSNR,         /**< SNR Profile */
    OMX_VIDEO_MPEG2ProfileSpatial,     /**< Spatial Profile */
    OMX_VIDEO_MPEG2ProfileHigh,        /**< High Profile */
    OMX_VIDEO_MPEG2ProfileKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_VIDEO_MPEG2ProfileVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_VIDEO_MPEG2ProfileMax = 0x7FFFFFFF  
} OMX_VIDEO_MPEG2PROFILETYPE;


/** 
 * MPEG-2 level types, each level indicates support for various frame 
 * sizes, bit rates, decoder frame rates.  No need 
 */
typedef enum OMX_VIDEO_MPEG2LEVELTYPE {
    OMX_VIDEO_MPEG2LevelLL = 0,  /**< Low Level */ 
    OMX_VIDEO_MPEG2LevelML,      /**< Main Level */ 
    OMX_VIDEO_MPEG2LevelH14,     /**< High 1440 */ 
    OMX_VIDEO_MPEG2LevelHL,      /**< High Level */   
    OMX_VIDEO_MPEG2LevelKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_VIDEO_MPEG2LevelVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_VIDEO_MPEG2LevelMax = 0x7FFFFFFF  
} OMX_VIDEO_MPEG2LEVELTYPE;


/** 
 * MPEG-2 params 
 *
 * STRUCT MEMBERS:
 *  nSize      : Size of the structure in bytes
 *  nVersion   : OMX specification version information
 *  nPortIndex : Port that this structure applies to
 *  nPFrames   : Number of P frames between each I frame
 *  nBFrames   : Number of B frames between each I frame
 *  eProfile   : MPEG-2 profile(s) to use
 *  eLevel     : MPEG-2 levels(s) to use
 */
typedef struct OMX_VIDEO_PARAM_MPEG2TYPE {
    OMX_U32 nSize;           
    OMX_VERSIONTYPE nVersion;
    OMX_U32 nPortIndex;      
    OMX_U32 nPFrames;        
    OMX_U32 nBFrames;        
    OMX_VIDEO_MPEG2PROFILETYPE eProfile;
	OMX_VIDEO_MPEG2LEVELTYPE eLevel;   
} OMX_VIDEO_PARAM_MPEG2TYPE;


/** 
 * MPEG-4 profile types, each profile indicates support for various 
 * performance bounds and different annexes.
 * 
 * ENUMS:
 *  - Simple Profile, Levels 1-3
 *  - Simple Scalable Profile, Levels 1-2
 *  - Core Profile, Levels 1-2
 *  - Main Profile, Levels 2-4
 *  - N-bit Profile, Level 2
 *  - Scalable Texture Profile, Level 1
 *  - Simple Face Animation Profile, Levels 1-2
 *  - Simple Face and Body Animation (FBA) Profile, Levels 1-2
 *  - Basic Animated Texture Profile, Levels 1-2
 *  - Hybrid Profile, Levels 1-2
 *  - Advanced Real Time Simple Profiles, Levels 1-4
 *  - Core Scalable Profile, Levels 1-3
 *  - Advanced Coding Efficiency Profile, Levels 1-4
 *  - Advanced Core Profile, Levels 1-2
 *  - Advanced Scalable Texture, Levels 2-3
 */
typedef enum OMX_VIDEO_MPEG4PROFILETYPE {
    OMX_VIDEO_MPEG4ProfileSimple           = 0x01,        
    OMX_VIDEO_MPEG4ProfileSimpleScalable   = 0x02,    
    OMX_VIDEO_MPEG4ProfileCore             = 0x04,              
    OMX_VIDEO_MPEG4ProfileMain             = 0x08,             
    OMX_VIDEO_MPEG4ProfileNbit             = 0x10,              
    OMX_VIDEO_MPEG4ProfileScalableTexture  = 0x20,   
    OMX_VIDEO_MPEG4ProfileSimpleFace       = 0x40,        
    OMX_VIDEO_MPEG4ProfileSimpleFBA        = 0x80,         
    OMX_VIDEO_MPEG4ProfileBasicAnimated    = 0x100,     
    OMX_VIDEO_MPEG4ProfileHybrid           = 0x200,            
    OMX_VIDEO_MPEG4ProfileAdvancedRealTime = 0x400,  
    OMX_VIDEO_MPEG4ProfileCoreScalable     = 0x800,      
    OMX_VIDEO_MPEG4ProfileAdvancedCoding   = 0x1000,    
    OMX_VIDEO_MPEG4ProfileAdvancedCore     = 0x2000,      
    OMX_VIDEO_MPEG4ProfileAdvancedScalable = 0x4000,
    OMX_VIDEO_MPEG4ProfileAdvancedSimple   = 0x8000,
    OMX_VIDEO_MPEG4ProfileKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_VIDEO_MPEG4ProfileVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_VIDEO_MPEG4ProfileMax              = 0x7FFFFFFF  
} OMX_VIDEO_MPEG4PROFILETYPE;


/** 
 * MPEG-4 level types, each level indicates support for various frame 
 * sizes, bit rates, decoder frame rates.  No need 
 */
typedef enum OMX_VIDEO_MPEG4LEVELTYPE {
    OMX_VIDEO_MPEG4Level0  = 0x01,   /**< Level 0 */   
    OMX_VIDEO_MPEG4Level0b = 0x02,   /**< Level 0b */   
    OMX_VIDEO_MPEG4Level1  = 0x04,   /**< Level 1 */ 
    OMX_VIDEO_MPEG4Level2  = 0x08,   /**< Level 2 */ 
    OMX_VIDEO_MPEG4Level3  = 0x10,   /**< Level 3 */ 
    OMX_VIDEO_MPEG4Level4  = 0x20,   /**< Level 4 */  
    OMX_VIDEO_MPEG4Level4a = 0x40,   /**< Level 4a */  
    OMX_VIDEO_MPEG4Level5  = 0x80,   /**< Level 5 */  
    OMX_VIDEO_MPEG4Level6  = 0x100,  /**< Level 5 */  
    OMX_VIDEO_MPEG4LevelKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_VIDEO_MPEG4LevelVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_VIDEO_MPEG4LevelMax = 0x7FFFFFFF  
} OMX_VIDEO_MPEG4LEVELTYPE;


/** 
 * MPEG-4 configuration.  This structure handles configuration options
 * which are specific to MPEG4 algorithms
 *
 * STRUCT MEMBERS:
 *  nSize                : Size of the structure in bytes
 *  nVersion             : OMX specification version information
 *  nPortIndex           : Port that this structure applies to
 *  nSliceHeaderSpacing  : Number of macroblocks between slice header (H263+ 
 *                         Annex K). Put zero if not used
 *  bSVH                 : Enable Short Video Header mode
 *  bGov                 : Flag to enable GOV
 *  nPFrames             : Number of P frames between each I frame (also called 
 *                         GOV period)
 *  nBFrames             : Number of B frames between each I frame
 *  nIDCVLCThreshold     : Value of intra DC VLC threshold
 *  bACPred              : Flag to use ac prediction
 *  nMaxPacketSize       : Maximum size of packet in bytes.
 *  nTimeIncRes          : Used to pass VOP time increment resolution for MPEG4. 
 *                         Interpreted as described in MPEG4 standard.
 *  eProfile             : MPEG-4 profile(s) to use.
 *  eLevel               : MPEG-4 level(s) to use.
 *  nAllowedPictureTypes : Specifies the picture types allowed in the bitstream
 *  nHeaderExtension     : Specifies the number of consecutive video packet
 *                         headers within a VOP
 *  bReversibleVLC       : Specifies whether reversible variable length coding 
 *                         is in use
 */
typedef struct OMX_VIDEO_PARAM_MPEG4TYPE {
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_U32 nPortIndex;
    OMX_U32 nSliceHeaderSpacing;
    OMX_BOOL bSVH;
    OMX_BOOL bGov;
    OMX_U32 nPFrames;
    OMX_U32 nBFrames;
    OMX_U32 nIDCVLCThreshold;
    OMX_BOOL bACPred;
    OMX_U32 nMaxPacketSize;
    OMX_U32 nTimeIncRes;
    OMX_VIDEO_MPEG4PROFILETYPE eProfile;
    OMX_VIDEO_MPEG4LEVELTYPE eLevel;
    OMX_U32 nAllowedPictureTypes;
    OMX_U32 nHeaderExtension;
    OMX_BOOL bReversibleVLC;
} OMX_VIDEO_PARAM_MPEG4TYPE;


/** 
 * WMV Versions 
 */
typedef enum OMX_VIDEO_WMVFORMATTYPE {
    OMX_VIDEO_WMVFormatUnused = 0x01,   /**< Format unused or unknown */
    OMX_VIDEO_WMVFormat7      = 0x02,   /**< Windows Media Video format 7 */
    OMX_VIDEO_WMVFormat8      = 0x04,   /**< Windows Media Video format 8 */
    OMX_VIDEO_WMVFormat9      = 0x08,   /**< Windows Media Video format 9 */
    OMX_VIDEO_WMFFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_VIDEO_WMFFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_VIDEO_WMVFormatMax    = 0x7FFFFFFF
} OMX_VIDEO_WMVFORMATTYPE;


/** 
 * WMV Params 
 *
 * STRUCT MEMBERS:
 *  nSize      : Size of the structure in bytes
 *  nVersion   : OMX specification version information
 *  nPortIndex : Port that this structure applies to
 *  eFormat    : Version of WMV stream / data
 */
typedef struct OMX_VIDEO_PARAM_WMVTYPE {
    OMX_U32 nSize; 
    OMX_VERSIONTYPE nVersion;
    OMX_U32 nPortIndex;
    OMX_VIDEO_WMVFORMATTYPE eFormat;
} OMX_VIDEO_PARAM_WMVTYPE;


/** 
 * Real Video Version 
 */
typedef enum OMX_VIDEO_RVFORMATTYPE {
    OMX_VIDEO_RVFormatUnused = 0, /**< Format unused or unknown */
    OMX_VIDEO_RVFormat8,          /**< Real Video format 8 */
    OMX_VIDEO_RVFormat9,          /**< Real Video format 9 */
    OMX_VIDEO_RVFormatG2,         /**< Real Video Format G2 */
    OMX_VIDEO_RVFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_VIDEO_RVFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_VIDEO_RVFormatMax = 0x7FFFFFFF
} OMX_VIDEO_RVFORMATTYPE;


/** 
 * Real Video Params 
 *
 * STUCT MEMBERS:
 *  nSize              : Size of the structure in bytes
 *  nVersion           : OMX specification version information 
 *  nPortIndex         : Port that this structure applies to
 *  eFormat            : Version of RV stream / data
 *  nBitsPerPixel      : Bits per pixel coded in the frame
 *  nPaddedWidth       : Padded width in pixel of a video frame
 *  nPaddedHeight      : Padded Height in pixels of a video frame
 *  nFrameRate         : Rate of video in frames per second
 *  nBitstreamFlags    : Flags which internal information about the bitstream
 *  nBitstreamVersion  : Bitstream version
 *  nMaxEncodeFrameSize: Max encoded frame size
 *  bEnablePostFilter  : Turn on/off post filter
 *  bEnableTemporalInterpolation : Turn on/off temporal interpolation
 *  bEnableLatencyMode : When enabled, the decoder does not display a decoded 
 *                       frame until it has detected that no enhancement layer 
 *  					 frames or dependent B frames will be coming. This 
 *  					 detection usually occurs when a subsequent non-B 
 *  					 frame is encountered 
 */
typedef struct OMX_VIDEO_PARAM_RVTYPE {
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_U32 nPortIndex;
    OMX_VIDEO_RVFORMATTYPE eFormat;
    OMX_U16 nBitsPerPixel;
    OMX_U16 nPaddedWidth;
    OMX_U16 nPaddedHeight;
    OMX_U32 nFrameRate;
    OMX_U32 nBitstreamFlags;
    OMX_U32 nBitstreamVersion;
    OMX_U32 nMaxEncodeFrameSize;
    OMX_BOOL bEnablePostFilter;
    OMX_BOOL bEnableTemporalInterpolation;
    OMX_BOOL bEnableLatencyMode;
} OMX_VIDEO_PARAM_RVTYPE;


/** 
 * AVC profile types, each profile indicates support for various 
 * performance bounds and different annexes.
 */
typedef enum OMX_VIDEO_AVCPROFILETYPE {
    OMX_VIDEO_AVCProfileBaseline = 0x01,   /**< Baseline profile */
    OMX_VIDEO_AVCProfileMain     = 0x02,   /**< Main profile */
    OMX_VIDEO_AVCProfileExtended = 0x04,   /**< Extended profile */
    OMX_VIDEO_AVCProfileHigh     = 0x08,   /**< High profile */
    OMX_VIDEO_AVCProfileHigh10   = 0x10,   /**< High 10 profile */
    OMX_VIDEO_AVCProfileHigh422  = 0x20,   /**< High 4:2:2 profile */
    OMX_VIDEO_AVCProfileHigh444  = 0x40,   /**< High 4:4:4 profile */
    OMX_VIDEO_AVCProfileConstrainedBaseline = 0x80, /**< Constrained Baseline Profile   */
    OMX_VIDEO_AVCProfileKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_VIDEO_AVCProfileVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_VIDEO_AVCProfileMax      = 0x7FFFFFFF  
} OMX_VIDEO_AVCPROFILETYPE;


/** 
 * AVC level types, each level indicates support for various frame sizes, 
 * bit rates, decoder frame rates.  No need 
 */
typedef enum OMX_VIDEO_AVCLEVELTYPE {
    OMX_VIDEO_AVCLevel1   = 0x01,     /**< Level 1 */
    OMX_VIDEO_AVCLevel1b  = 0x02,     /**< Level 1b */
    OMX_VIDEO_AVCLevel11  = 0x04,     /**< Level 1.1 */
    OMX_VIDEO_AVCLevel12  = 0x08,     /**< Level 1.2 */
    OMX_VIDEO_AVCLevel13  = 0x10,     /**< Level 1.3 */
    OMX_VIDEO_AVCLevel2   = 0x20,     /**< Level 2 */
    OMX_VIDEO_AVCLevel21  = 0x40,     /**< Level 2.1 */
    OMX_VIDEO_AVCLevel22  = 0x80,     /**< Level 2.2 */
    OMX_VIDEO_AVCLevel3   = 0x100,    /**< Level 3 */
    OMX_VIDEO_AVCLevel31  = 0x200,    /**< Level 3.1 */
    OMX_VIDEO_AVCLevel32  = 0x400,    /**< Level 3.2 */
    OMX_VIDEO_AVCLevel4   = 0x800,    /**< Level 4 */
    OMX_VIDEO_AVCLevel41  = 0x1000,   /**< Level 4.1 */
    OMX_VIDEO_AVCLevel42  = 0x2000,   /**< Level 4.2 */
    OMX_VIDEO_AVCLevel5   = 0x4000,   /**< Level 5 */
    OMX_VIDEO_AVCLevel51  = 0x8000,   /**< Level 5.1 */
    OMX_VIDEO_AVCLevelKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_VIDEO_AVCLevelVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_VIDEO_AVCLevelMax = 0x7FFFFFFF  
} OMX_VIDEO_AVCLEVELTYPE;


/** 
 * AVC loop filter modes 
 *
 * OMX_VIDEO_AVCLoopFilterEnable               : Enable
 * OMX_VIDEO_AVCLoopFilterDisable              : Disable
 * OMX_VIDEO_AVCLoopFilterDisableSliceBoundary : Disabled on slice boundaries
 */
typedef enum OMX_VIDEO_AVCLOOPFILTERTYPE {
    OMX_VIDEO_AVCLoopFilterEnable = 0,
    OMX_VIDEO_AVCLoopFilterDisable,
    OMX_VIDEO_AVCLoopFilterDisableSliceBoundary,
    OMX_VIDEO_AVCLoopFilterKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_VIDEO_AVCLoopFilterVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_VIDEO_AVCLoopFilterMax = 0x7FFFFFFF
} OMX_VIDEO_AVCLOOPFILTERTYPE;


/** 
 * AVC params 
 *
 * STRUCT MEMBERS:
 *  nSize                     : Size of the structure in bytes
 *  nVersion                  : OMX specification version information
 *  nPortIndex                : Port that this structure applies to
 *  nSliceHeaderSpacing       : Number of macroblocks between slice header, put  
 *                              zero if not used
 *  nPFrames                  : Number of P frames between each I frame
 *  nBFrames                  : Number of B frames between each I frame
 *  bUseHadamard              : Enable/disable Hadamard transform
 *  nRefFrames                : Max number of reference frames to use for inter
 *                              motion search (1-16)
 *  nRefIdxTrailing           : Pic param set ref frame index (index into ref
 *                              frame buffer of trailing frames list), B frame
 *                              support
 *  nRefIdxForward            : Pic param set ref frame index (index into ref
 *                              frame buffer of forward frames list), B frame
 *                              support
 *  bEnableUEP                : Enable/disable unequal error protection. This 
 *                              is only valid of data partitioning is enabled.
 *  bEnableFMO                : Enable/disable flexible macroblock ordering
 *  bEnableASO                : Enable/disable arbitrary slice ordering
 *  bEnableRS                 : Enable/disable sending of redundant slices
 *  eProfile                  : AVC profile(s) to use
 *  eLevel                    : AVC level(s) to use
 *  nAllowedPictureTypes      : Specifies the picture types allowed in the 
 *                              bitstream
 *  bFrameMBsOnly             : specifies that every coded picture of the 
 *                              coded video sequence is a coded frame 
 *                              containing only frame macroblocks
 *  bMBAFF                    : Enable/disable switching between frame and 
 *                              field macroblocks within a picture
 *  bEntropyCodingCABAC       : Entropy decoding method to be applied for the 
 *                              syntax elements for which two descriptors appear 
 *                              in the syntax tables
 *  bWeightedPPrediction      : Enable/disable weighted prediction shall not 
 *                              be applied to P and SP slices
 *  nWeightedBipredicitonMode : Default weighted prediction is applied to B 
 *                              slices 
 *  bconstIpred               : Enable/disable intra prediction
 *  bDirect8x8Inference       : Specifies the method used in the derivation 
 *                              process for luma motion vectors for B_Skip, 
 *                              B_Direct_16x16 and B_Direct_8x8 as specified 
 *                              in subclause 8.4.1.2 of the AVC spec 
 *  bDirectSpatialTemporal    : Flag indicating spatial or temporal direct
 *                              mode used in B slice coding (related to 
 *                              bDirect8x8Inference) . Spatial direct mode is 
 *                              more common and should be the default.
 *  nCabacInitIdx             : Index used to init CABAC contexts
 *  eLoopFilterMode           : Enable/disable loop filter
 */
typedef struct OMX_VIDEO_PARAM_AVCTYPE {
    OMX_U32 nSize;                 
    OMX_VERSIONTYPE nVersion;      
    OMX_U32 nPortIndex;            
    OMX_U32 nSliceHeaderSpacing;  
    OMX_U32 nPFrames;     
    OMX_U32 nBFrames;     
    OMX_BOOL bUseHadamard;
    OMX_U32 nRefFrames;  
	OMX_U32 nRefIdx10ActiveMinus1;
	OMX_U32 nRefIdx11ActiveMinus1;
    OMX_BOOL bEnableUEP;  
    OMX_BOOL bEnableFMO;  
    OMX_BOOL bEnableASO;  
    OMX_BOOL bEnableRS;   
    OMX_VIDEO_AVCPROFILETYPE eProfile;
	OMX_VIDEO_AVCLEVELTYPE eLevel; 
    OMX_U32 nAllowedPictureTypes;  
	OMX_BOOL bFrameMBsOnly;        									
    OMX_BOOL bMBAFF;               
    OMX_BOOL bEntropyCodingCABAC;  
    OMX_BOOL bWeightedPPrediction; 
    OMX_U32 nWeightedBipredicitonMode; 
    OMX_BOOL bconstIpred ;
    OMX_BOOL bDirect8x8Inference;  
	OMX_BOOL bDirectSpatialTemporal;
	OMX_U32 nCabacInitIdc;
	OMX_VIDEO_AVCLOOPFILTERTYPE eLoopFilterMode;
} OMX_VIDEO_PARAM_AVCTYPE;

typedef struct OMX_VIDEO_PARAM_PROFILELEVELTYPE {
   OMX_U32 nSize;                 
   OMX_VERSIONTYPE nVersion;      
   OMX_U32 nPortIndex;            
   OMX_U32 eProfile;      /**< type is OMX_VIDEO_AVCPROFILETYPE, OMX_VIDEO_H263PROFILETYPE, 
                                 or OMX_VIDEO_MPEG4PROFILETYPE depending on context */
   OMX_U32 eLevel;        /**< type is OMX_VIDEO_AVCLEVELTYPE, OMX_VIDEO_H263LEVELTYPE, 
                                 or OMX_VIDEO_MPEG4PROFILETYPE depending on context */
   OMX_U32 nProfileIndex; /**< Used to query for individual profile support information,
                               This parameter is valid only for 
                               OMX_IndexParamVideoProfileLevelQuerySupported index,
                               For all other indices this parameter is to be ignored. */
} OMX_VIDEO_PARAM_PROFILELEVELTYPE;

/** 
 * Structure for dynamically configuring bitrate mode of a codec. 
 *
 * STRUCT MEMBERS:
 *  nSize          : Size of the struct in bytes
 *  nVersion       : OMX spec version info
 *  nPortIndex     : Port that this struct applies to
 *  nEncodeBitrate : Target average bitrate to be generated in bps
 */
typedef struct OMX_VIDEO_CONFIG_BITRATETYPE {
    OMX_U32 nSize;                          
    OMX_VERSIONTYPE nVersion;               
    OMX_U32 nPortIndex;                     
    OMX_U32 nEncodeBitrate;                 
} OMX_VIDEO_CONFIG_BITRATETYPE;

/** 
 * Defines Encoder Frame Rate setting
 *
 * STRUCT MEMBERS:
 *  nSize            : Size of the structure in bytes
 *  nVersion         : OMX specification version information 
 *  nPortIndex       : Port that this structure applies to
 *  xEncodeFramerate : Encoding framerate represented in Q16 format
 */
typedef struct OMX_CONFIG_FRAMERATETYPE {
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_U32 nPortIndex;
    OMX_U32 xEncodeFramerate; /* Q16 format */
} OMX_CONFIG_FRAMERATETYPE;

typedef struct OMX_CONFIG_INTRAREFRESHVOPTYPE {
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_U32 nPortIndex;
    OMX_BOOL IntraRefreshVOP;
} OMX_CONFIG_INTRAREFRESHVOPTYPE;

typedef struct OMX_CONFIG_MACROBLOCKERRORMAPTYPE {
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_U32 nPortIndex;
    OMX_U32 nErrMapSize;           /* Size of the Error Map in bytes */
    OMX_U8  ErrMap[1];             /* Error map hint */
} OMX_CONFIG_MACROBLOCKERRORMAPTYPE;

typedef struct OMX_CONFIG_MBERRORREPORTINGTYPE {
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_U32 nPortIndex;
    OMX_BOOL bEnabled;
} OMX_CONFIG_MBERRORREPORTINGTYPE;

typedef struct OMX_PARAM_MACROBLOCKSTYPE {
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_U32 nPortIndex;
    OMX_U32 nMacroblocks;
} OMX_PARAM_MACROBLOCKSTYPE;

/** 
 * AVC Slice Mode modes 
 *
 * OMX_VIDEO_SLICEMODE_AVCDefault   : Normal frame encoding, one slice per frame
 * OMX_VIDEO_SLICEMODE_AVCMBSlice   : NAL mode, number of MBs per frame
 * OMX_VIDEO_SLICEMODE_AVCByteSlice : NAL mode, number of bytes per frame
 */
typedef enum OMX_VIDEO_AVCSLICEMODETYPE {
    OMX_VIDEO_SLICEMODE_AVCDefault = 0,
    OMX_VIDEO_SLICEMODE_AVCMBSlice,
    OMX_VIDEO_SLICEMODE_AVCByteSlice,
    OMX_VIDEO_SLICEMODE_AVCKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_VIDEO_SLICEMODE_AVCVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_VIDEO_SLICEMODE_AVCLevelMax = 0x7FFFFFFF
} OMX_VIDEO_AVCSLICEMODETYPE;

/** 
 * AVC FMO Slice Mode Params 
 *
 * STRUCT MEMBERS:
 *  nSize      : Size of the structure in bytes
 *  nVersion   : OMX specification version information
 *  nPortIndex : Port that this structure applies to
 *  nNumSliceGroups : Specifies the number of slice groups
 *  nSliceGroupMapType : Specifies the type of slice groups
 *  eSliceMode : Specifies the type of slice
 */
typedef struct OMX_VIDEO_PARAM_AVCSLICEFMO {
    OMX_U32 nSize; 
    OMX_VERSIONTYPE nVersion;
    OMX_U32 nPortIndex;
    OMX_U8 nNumSliceGroups;
    OMX_U8 nSliceGroupMapType;
    OMX_VIDEO_AVCSLICEMODETYPE eSliceMode;
} OMX_VIDEO_PARAM_AVCSLICEFMO;

/** 
 * AVC IDR Period Configs
 *
 * STRUCT MEMBERS:
 *  nSize      : Size of the structure in bytes
 *  nVersion   : OMX specification version information
 *  nPortIndex : Port that this structure applies to
 *  nIDRPeriod : Specifies periodicity of IDR frames
 *  nPFrames : Specifies internal of coding Intra frames
 */
typedef struct OMX_VIDEO_CONFIG_AVCINTRAPERIOD {
    OMX_U32 nSize; 
    OMX_VERSIONTYPE nVersion;
    OMX_U32 nPortIndex;
    OMX_U32 nIDRPeriod;
    OMX_U32 nPFrames;
} OMX_VIDEO_CONFIG_AVCINTRAPERIOD;

/** 
 * AVC NAL Size Configs
 *
 * STRUCT MEMBERS:
 *  nSize      : Size of the structure in bytes
 *  nVersion   : OMX specification version information
 *  nPortIndex : Port that this structure applies to
 *  nNaluBytes : Specifies the NAL unit size
 */
typedef struct OMX_VIDEO_CONFIG_NALSIZE {
    OMX_U32 nSize; 
    OMX_VERSIONTYPE nVersion;
    OMX_U32 nPortIndex;
    OMX_U32 nNaluBytes;
} OMX_VIDEO_CONFIG_NALSIZE;


/** @} */

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif
/* File EOF */

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              #ifndef __khrplatform_h_
#define __khrplatform_h_

/*
** Copyright (c) 2008-2009 The Khronos Group Inc.
**
** Permission is hereby granted, free of charge, to any person obtaining a
** copy of this software and/or associated documentation files (the
** "Materials"), to deal in the Materials without restriction, including
** without limitation the rights to use, copy, modify, merge, publish,
** distribute, sublicense, and/or sell copies of the Materials, and to
** permit persons to whom the Materials are furnished to do so, subject to
** the following conditions:
**
** The above copyright notice and this permission notice shall be included
** in all copies or substantial portions of the Materials.
**
** THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
** MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.
*/

/* Khronos platform-specific types and definitions.
 *
 * $Revision: 23298 $ on $Date: 2013-09-30 17:07:13 -0700 (Mon, 30 Sep 2013) $
 *
 * Adopters may modify this file to suit their platform. Adopters are
 * encouraged to submit platform specific modifications to the Khronos
 * group so that they can be included in future versions of this file.
 * Please submit changes by sending them to the public Khronos Bugzilla
 * (http://khronos.org/bugzilla) by filing a bug against product
 * "Khronos (general)" component "Registry".
 *
 * A predefined template which fills in some of the bug fields can be
 * reached using http://tinyurl.com/khrplatform-h-bugreport, but you
 * must create a Bugzilla login first.
 *
 *
 * See the Implementer's Guidelines for information about where this file
 * should be located on your system and for more details of its use:
 *    http://www.khronos.org/registry/implementers_guide.pdf
 *
 * This file should be included as
 *        #include <KHR/khrplatform.h>
 * by Khronos client API header files that use its types and defines.
 *
 * The types in khrplatform.h should only be used to define API-specific types.
 *
 * Types defined in khrplatform.h:
 *    khronos_int8_t              signed   8  bit
 *    khronos_uint8_t             unsigned 8  bit
 *    khronos_int16_t             signed   16 bit
 *    khronos_uint16_t            unsigned 16 bit
 *    khronos_int32_t             signed   32 bit
 *    khronos_uint32_t            unsigned 32 bit
 *    khronos_int64_t             signed   64 bit
 *    khronos_uint64_t            unsigned 64 bit
 *    khronos_intptr_t            signed   same number of bits as a pointer
 *    khronos_uintptr_t           unsigned same number of bits as a pointer
 *    khronos_ssize_t             signed   size
 *    khronos_usize_t             unsigned size
 *    khronos_float_t             signed   32 bit floating point
 *    khronos_time_ns_t           unsigned 64 bit time in nanoseconds
 *    khronos_utime_nanoseconds_t unsigned time interval or absolute time in
 *                                         nanoseconds
 *    khronos_stime_nanoseconds_t signed time interval in nanoseconds
 *    khronos_boolean_enum_t      enumerated boolean type. This should
 *      only be used as a base type when a client API's boolean type is
 *      an enum. Client APIs which use an integer or other type for
 *      booleans cannot use this as the base type for their boolean.
 *
 * Tokens defined in khrplatform.h:
 *
 *    KHRONOS_FALSE, KHRONOS_TRUE Enumerated boolean false/true values.
 *
 *    KHRONOS_SUPPORT_INT64 is 1 if 64 bit integers are supported; otherwise 0.
 *    KHRONOS_SUPPORT_FLOAT is 1 if floats are supported; otherwise 0.
 *
 * Calling convention macros defined in this file:
 *    KHRONOS_APICALL
 *    KHRONOS_APIENTRY
 *    KHRONOS_APIATTRIBUTES
 *
 * These may be used in function prototypes as:
 *
 *      KHRONOS_APICALL void KHRONOS_APIENTRY funcname(
 *                                  int arg1,
 *                                  int arg2) KHRONOS_APIATTRIBUTES;
 */

/*-------------------------------------------------------------------------
 * Definition of KHRONOS_APICALL
 *-------------------------------------------------------------------------
 * This precedes the return type of the function in the function prototype.
 */
#if defined(_WIN32) && !defined(__SCITECH_SNAP__)
#   define KHRONOS_APICALL __declspec(dllimport)
#elif defined (__SYMBIAN32__)
#   define KHRONOS_APICALL IMPORT_C
#else
#   define KHRONOS_APICALL
#endif

/*-------------------------------------------------------------------------
 * Definition of KHRONOS_APIENTRY
 *-------------------------------------------------------------------------
 * This follows the return type of the function  and precedes the function
 * name in the function prototype.
 */
#if defined(_WIN32) && !defined(_WIN32_WCE) && !defined(__SCITECH_SNAP__)
    /* Win32 but not WinCE */
#   define KHRONOS_APIENTRY __stdcall
#else
#   define KHRONOS_APIENTRY
#endif

/*-------------------------------------------------------------------------
 * Definition of KHRONOS_APIATTRIBUTES
 *-------------------------------------------------------------------------
 * This follows the closing parenthesis of the function prototype arguments.
 */
#if defined (__ARMCC_2__)
#define KHRONOS_APIATTRIBUTES __softfp
#else
#define KHRONOS_APIATTRIBUTES
#endif

/*-------------------------------------------------------------------------
 * basic type definitions
 *-----------------------------------------------------------------------*/
#if (defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L) || defined(__GNUC__) || defined(__SCO__) || defined(__USLC__)


/*
 * Using <stdint.h>
 */
#include <stdint.h>
typedef int32_t                 khronos_int32_t;
typedef uint32_t                khronos_uint32_t;
typedef int64_t                 khronos_int64_t;
typedef uint64_t                khronos_uint64_t;
#define KHRONOS_SUPPORT_INT64   1
#define KHRONOS_SUPPORT_FLOAT   1

#elif defined(__VMS ) || defined(__sgi)

/*
 * Using <inttypes.h>
 */
#include <inttypes.h>
typedef int32_t                 khronos_int32_t;
typedef uint32_t                khronos_uint32_t;
typedef int64_t                 khronos_int64_t;
typedef uint64_t                khronos_uint64_t;
#define KHRONOS_SUPPORT_INT64   1
#define KHRONOS_SUPPORT_FLOAT   1

#elif defined(_WIN32) && !defined(__SCITECH_SNAP__)

/*
 * Win32
 */
typedef __int32                 khronos_int32_t;
typedef unsigned __int32        khronos_uint32_t;
typedef __int64                 khronos_int64_t;
typedef unsigned __int64        khronos_uint64_t;
#define KHRONOS_SUPPORT_INT64   1
#define KHRONOS_SUPPORT_FLOAT   1

#elif defined(__sun__) || defined(__digital__)

/*
 * Sun or Digital
 */
typedef int                     khronos_int32_t;
typedef unsigned int            khronos_uint32_t;
#if defined(__arch64__) || defined(_LP64)
typedef long int                khronos_int64_t;
typedef unsigned long int       khronos_uint64_t;
#else
typedef long long int           khronos_int64_t;
typedef unsigned long long int  khronos_uint64_t;
#endif /* __arch64__ */
#define KHRONOS_SUPPORT_INT64   1
#define KHRONOS_SUPPORT_FLOAT   1

#elif defined(_VIDEOCORE)

/*
 * VideoCore with Metaware compiler
 */
#include <vcinclude/common.h>
typedef int32_t                 khronos_int32_t;
typedef uint32_t                khronos_uint32_t;
typedef int64_t                 khronos_int64_t;
typedef uint64_t                khronos_uint64_t;
#define KHRONOS_SUPPORT_INT64   1
#define KHRONOS_SUPPORT_FLOAT   1

#elif 0

/*
 * Hypothetical platform with no float or int64 support
 */
typedef int                     khronos_int32_t;
typedef unsigned int            khronos_uint32_t;
#define KHRONOS_SUPPORT_INT64   0
#define KHRONOS_SUPPORT_FLOAT   0

#else

/*
 * Generic fallback
 */
#include <stdint.h>
typedef int32_t                 khronos_int32_t;
typedef uint32_t                khronos_uint32_t;
typedef int64_t                 khronos_int64_t;
typedef uint64_t                khronos_uint64_t;
#define KHRONOS_SUPPORT_INT64   1
#define KHRONOS_SUPPORT_FLOAT   1

#endif


/*
 * Types that are (so far) the same on all platforms
 */
typedef signed   char          khronos_int8_t;
typedef unsigned char          khronos_uint8_t;
typedef signed   short int     khronos_int16_t;
typedef unsigned short int     khronos_uint16_t;

/*
 * Types that differ between LLP64 and LP64 architectures - in LLP64, 
 * pointers are 64 bits, but 'long' is still 32 bits. Win64 appears
 * to be the only LLP64 architecture in current use.
 */
#ifdef _WIN64
typedef signed   long long int khronos_intptr_t;
typedef unsigned long long int khronos_uintptr_t;
typedef signed   long long int khronos_ssize_t;
typedef unsigned long long int khronos_usize_t;
#else
typedef signed   long  int     khronos_intptr_t;
typedef unsigned long  int     khronos_uintptr_t;
typedef signed   long  int     khronos_ssize_t;
typedef unsigned long  int     khronos_usize_t;
#endif

#if KHRONOS_SUPPORT_FLOAT
/*
 * Float type
 */
typedef          float         khronos_float_t;
#endif

#if KHRONOS_SUPPORT_INT64
/* Time types
 *
 * These types can be used to represent a time interval in nanoseconds or
 * an absolute Unadjusted System Time.  Unadjusted System Time is the number
 * of nanoseconds since some arbitrary system event (e.g. since the last
 * time the system booted).  The Unadjusted System Time is an unsigned
 * 64 bit value that wraps back to 0 every 584 years.  Time intervals
 * may be either signed or unsigned.
 */
typedef khronos_uint64_t       khronos_utime_nanoseconds_t;
typedef khronos_int64_t        khronos_stime_nanoseconds_t;
#endif

/*
 * Dummy value used to pad enum types to 32 bits.
 */
#ifndef KHRONOS_MAX_ENUM
#define KHRONOS_MAX_ENUM 0x7FFFFFFF
#endif

/*
 * Enumerated boolean type
 *
 * Values other than zero should be considered to be true.  Therefore
 * comparisons should not be made against KHRONOS_TRUE.
 */
typedef enum {
    KHRONOS_FALSE = 0,
    KHRONOS_TRUE  = 1,
    KHRONOS_BOOLEAN_ENUM_FORCE_SIZE = KHRONOS_MAX_ENUM
} khronos_boolean_enum_t;

#endif /* __khrplatform_h_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /* $Revision: 6838 $ on $Date:: 2008-11-04 11:46:08 +0000 #$ */

/*------------------------------------------------------------------------
 *
 * OpenVG 1.1 Reference Implementation
 * -------------------------------------
 *
 * Copyright (c) 2008 The Khronos Group Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and /or associated documentation files
 * (the "Materials "), to deal in the Materials without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Materials,
 * and to permit persons to whom the Materials are furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Materials.
 *
 * THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE MATERIALS OR
 * THE USE OR OTHER DEALINGS IN THE MATERIALS.
 *
 *//**
 * \file
 * \brief	OpenVG 1.1 API.
 *//*-------------------------------------------------------------------*/

#ifndef _OPENVG_H
#define _OPENVG_H

#include "vgplatform.h"

#ifdef __cplusplus
extern "C" {
#endif

#define OPENVG_VERSION_1_0		1
#define OPENVG_VERSION_1_0_1	1
#define OPENVG_VERSION_1_1		2

#ifndef VG_MAXSHORT
#define VG_MAXSHORT 0x7FFF
#endif

#ifndef VG_MAXINT
#define VG_MAXINT 0x7FFFFFFF
#endif

#ifndef VG_MAX_ENUM
#define VG_MAX_ENUM 0x7FFFFFFF
#endif

typedef VGuint VGHandle;

typedef VGHandle VGPath;
typedef VGHandle VGImage;
typedef VGHandle VGMaskLayer;
typedef VGHandle VGFont;
typedef VGHandle VGPaint;

#define VG_INVALID_HANDLE ((VGHandle)0)

typedef VGuint VGboolean;
#define VG_FALSE 0
#define VG_TRUE  1

typedef enum {
  VG_NO_ERROR                                 = 0,
  VG_BAD_HANDLE_ERROR                         = 0x1000,
  VG_ILLEGAL_ARGUMENT_ERROR                   = 0x1001,
  VG_OUT_OF_MEMORY_ERROR                      = 0x1002,
  VG_PATH_CAPABILITY_ERROR                    = 0x1003,
  VG_UNSUPPORTED_IMAGE_FORMAT_ERROR           = 0x1004,
  VG_UNSUPPORTED_PATH_FORMAT_ERROR            = 0x1005,
  VG_IMAGE_IN_USE_ERROR                       = 0x1006,
  VG_NO_CONTEXT_ERROR                         = 0x1007,

  VG_ERROR_CODE_FORCE_SIZE                    = VG_MAX_ENUM
} VGErrorCode;

typedef enum {
  /* Mode settings */
  VG_MATRIX_MODE                              = 0x1100,
  VG_FILL_RULE                                = 0x1101,
  VG_IMAGE_QUALITY                            = 0x1102,
  VG_RENDERING_QUALITY                        = 0x1103,
  VG_BLEND_MODE                               = 0x1104,
  VG_IMAGE_MODE                               = 0x1105,

  /* Scissoring rectangles */
  VG_SCISSOR_RECTS                            = 0x1106,

  /* Color Transformation */
  VG_COLOR_TRANSFORM                          = 0x1170,
  VG_COLOR_TRANSFORM_VALUES                   = 0x1171,

  /* Stroke parameters */
  VG_STROKE_LINE_WIDTH                        = 0x1110,
  VG_STROKE_CAP_STYLE                         = 0x1111,
  VG_STROKE_JOIN_STYLE                        = 0x1112,
  VG_STROKE_MITER_LIMIT                       = 0x1113,
  VG_STROKE_DASH_PATTERN                      = 0x1114,
  VG_STROKE_DASH_PHASE                        = 0x1115,
  VG_STROKE_DASH_PHASE_RESET                  = 0x1116,

  /* Edge fill color for VG_TILE_FILL tiling mode */
  VG_TILE_FILL_COLOR                          = 0x1120,

  /* Color for vgClear */
  VG_CLEAR_COLOR                              = 0x1121,

  /* Glyph origin */
  VG_GLYPH_ORIGIN                             = 0x1122,

  /* Enable/disable alpha masking and scissoring */
  VG_MASKING                                  = 0x1130,
  VG_SCISSORING                               = 0x1131,

  /* Pixel layout information */
  VG_PIXEL_LAYOUT                             = 0x1140,
  VG_SCREEN_LAYOUT                            = 0x1141,

  /* Source format selection for image filters */
  VG_FILTER_FORMAT_LINEAR                     = 0x1150,
  VG_FILTER_FORMAT_PREMULTIPLIED              = 0x1151,

  /* Destination write enable mask for image filters */
  VG_FILTER_CHANNEL_MASK                      = 0x1152,

  /* Implementation limits (read-only) */
  VG_MAX_SCISSOR_RECTS                        = 0x1160,
  VG_MAX_DASH_COUNT                           = 0x1161,
  VG_MAX_KERNEL_SIZE                          = 0x1162,
  VG_MAX_SEPARABLE_KERNEL_SIZE                = 0x1163,
  VG_MAX_COLOR_RAMP_STOPS                     = 0x1164,
  VG_MAX_IMAGE_WIDTH                          = 0x1165,
  VG_MAX_IMAGE_HEIGHT                         = 0x1166,
  VG_MAX_IMAGE_PIXELS                         = 0x1167,
  VG_MAX_IMAGE_BYTES                          = 0x1168,
  VG_MAX_FLOAT                                = 0x1169,
  VG_MAX_GAUSSIAN_STD_DEVIATION               = 0x116A,

  VG_PARAM_TYPE_FORCE_SIZE                    = VG_MAX_ENUM
} VGParamType;

typedef enum {
  VG_RENDERING_QUALITY_NONANTIALIASED         = 0x1200,
  VG_RENDERING_QUALITY_FASTER                 = 0x1201,
  VG_RENDERING_QUALITY_BETTER                 = 0x1202, /* Default */

  VG_RENDERING_QUALITY_FORCE_SIZE             = VG_MAX_ENUM
} VGRenderingQuality;

typedef enum {
  VG_PIXEL_LAYOUT_UNKNOWN                     = 0x1300,
  VG_PIXEL_LAYOUT_RGB_VERTICAL                = 0x1301,
  VG_PIXEL_LAYOUT_BGR_VERTICAL                = 0x1302,
  VG_PIXEL_LAYOUT_RGB_HORIZONTAL              = 0x1303,
  VG_PIXEL_LAYOUT_BGR_HORIZONTAL              = 0x1304,

  VG_PIXEL_LAYOUT_FORCE_SIZE                  = VG_MAX_ENUM
} VGPixelLayout;

typedef enum {
  VG_MATRIX_PATH_USER_TO_SURFACE              = 0x1400,
  VG_MATRIX_IMAGE_USER_TO_SURFACE             = 0x1401,
  VG_MATRIX_FILL_PAINT_TO_USER                = 0x1402,
  VG_MATRIX_STROKE_PAINT_TO_USER              = 0x1403,
  VG_MATRIX_GLYPH_USER_TO_SURFACE             = 0x1404,

  VG_MATRIX_MODE_FORCE_SIZE                   = VG_MAX_ENUM
} VGMatrixMode;

typedef enum {
  VG_CLEAR_MASK                               = 0x1500,
  VG_FILL_MASK                                = 0x1501,
  VG_SET_MASK                                 = 0x1502,
  VG_UNION_MASK                               = 0x1503,
  VG_INTERSECT_MASK                           = 0x1504,
  VG_SUBTRACT_MASK                            = 0x1505,

  VG_MASK_OPERATION_FORCE_SIZE                = VG_MAX_ENUM
} VGMaskOperation;

#define VG_PATH_FORMAT_STANDARD 0

typedef enum {
  VG_PATH_DATATYPE_S_8                        =  0,
  VG_PATH_DATATYPE_S_16                       =  1,
  VG_PATH_DATATYPE_S_32                       =  2,
  VG_PATH_DATATYPE_F                          =  3,

  VG_PATH_DATATYPE_FORCE_SIZE                 = VG_MAX_ENUM
} VGPathDatatype;

typedef enum {
  VG_ABSOLUTE                                 = 0,
  VG_RELATIVE                                 = 1,

  VG_PATH_ABS_REL_FORCE_SIZE                  = VG_MAX_ENUM
} VGPathAbsRel;

typedef enum {
  VG_CLOSE_PATH                               = ( 0 << 1),
  VG_MOVE_TO                                  = ( 1 << 1),
  VG_LINE_TO                                  = ( 2 << 1),
  VG_HLINE_TO                                 = ( 3 << 1),
  VG_VLINE_TO                                 = ( 4 << 1),
  VG_QUAD_TO                                  = ( 5 << 1),
  VG_CUBIC_TO                                 = ( 6 << 1),
  VG_SQUAD_TO                                 = ( 7 << 1),
  VG_SCUBIC_TO                                = ( 8 << 1),
  VG_SCCWARC_TO                               = ( 9 << 1),
  VG_SCWARC_TO                                = (10 << 1),
  VG_LCCWARC_TO                               = (11 << 1),
  VG_LCWARC_TO                                = (12 << 1),

  VG_SEGMENT_MASK                             = 0xf << 1,

  VG_PATH_SEGMENT_FORCE_SIZE                  = VG_MAX_ENUM
} VGPathSegment;

typedef enum {
  VG_MOVE_TO_ABS                              = VG_MOVE_TO    | VG_ABSOLUTE,
  VG_MOVE_TO_REL                              = VG_MOVE_TO    | VG_RELATIVE,
  VG_LINE_TO_ABS                              = VG_LINE_TO    | VG_ABSOLUTE,
  VG_LINE_TO_REL                              = VG_LINE_TO    | VG_RELATIVE,
  VG_HLINE_TO_ABS                             = VG_HLINE_TO   | VG_ABSOLUTE,
  VG_HLINE_TO_REL                             = VG_HLINE_TO   | VG_RELATIVE,
  VG_VLINE_TO_ABS                             = VG_VLINE_TO   | VG_ABSOLUTE,
  VG_VLINE_TO_REL                             = VG_VLINE_TO   | VG_RELATIVE,
  VG_QUAD_TO_ABS                              = VG_QUAD_TO    | VG_ABSOLUTE,
  VG_QUAD_TO_REL                              = VG_QUAD_TO    | VG_RELATIVE,
  VG_CUBIC_TO_ABS                             = VG_CUBIC_TO   | VG_ABSOLUTE,
  VG_CUBIC_TO_REL                             = VG_CUBIC_TO   | VG_RELATIVE,
  VG_SQUAD_TO_ABS                             = VG_SQUAD_TO   | VG_ABSOLUTE,
  VG_SQUAD_TO_REL                             = VG_SQUAD_TO   | VG_RELATIVE,
  VG_SCUBIC_TO_ABS                            = VG_SCUBIC_TO  | VG_ABSOLUTE,
  VG_SCUBIC_TO_REL                            = VG_SCUBIC_TO  | VG_RELATIVE,
  VG_SCCWARC_TO_ABS                           = VG_SCCWARC_TO | VG_ABSOLUTE,
  VG_SCCWARC_TO_REL                           = VG_SCCWARC_TO | VG_RELATIVE,
  VG_SCWARC_TO_ABS                            = VG_SCWARC_TO  | VG_ABSOLUTE,
  VG_SCWARC_TO_REL                            = VG_SCWARC_TO  | VG_RELATIVE,
  VG_LCCWARC_TO_ABS                           = VG_LCCWARC_TO | VG_ABSOLUTE,
  VG_LCCWARC_TO_REL                           = VG_LCCWARC_TO | VG_RELATIVE,
  VG_LCWARC_TO_ABS                            = VG_LCWARC_TO  | VG_ABSOLUTE,
  VG_LCWARC_TO_REL                            = VG_LCWARC_TO  | VG_RELATIVE,

  VG_PATH_COMMAND_FORCE_SIZE                  = VG_MAX_ENUM
} VGPathCommand;

typedef enum {
  VG_PATH_CAPABILITY_APPEND_FROM              = (1 <<  0),
  VG_PATH_CAPABILITY_APPEND_TO                = (1 <<  1),
  VG_PATH_CAPABILITY_MODIFY                   = (1 <<  2),
  VG_PATH_CAPABILITY_TRANSFORM_FROM           = (1 <<  3),
  VG_PATH_CAPABILITY_TRANSFORM_TO             = (1 <<  4),
  VG_PATH_CAPABILITY_INTERPOLATE_FROM         = (1 <<  5),
  VG_PATH_CAPABILITY_INTERPOLATE_TO           = (1 <<  6),
  VG_PATH_CAPABILITY_PATH_LENGTH              = (1 <<  7),
  VG_PATH_CAPABILITY_POINT_ALONG_PATH         = (1 <<  8),
  VG_PATH_CAPABILITY_TANGENT_ALONG_PATH       = (1 <<  9),
  VG_PATH_CAPABILITY_PATH_BOUNDS              = (1 << 10),
  VG_PATH_CAPABILITY_PATH_TRANSFORMED_BOUNDS  = (1 << 11),
  VG_PATH_CAPABILITY_ALL                      = (1 << 12) - 1,

  VG_PATH_CAPABILITIES_FORCE_SIZE             = VG_MAX_ENUM
} VGPathCapabilities;

typedef enum {
  VG_PATH_FORMAT                              = 0x1600,
  VG_PATH_DATATYPE                            = 0x1601,
  VG_PATH_SCALE                               = 0x1602,
  VG_PATH_BIAS                                = 0x1603,
  VG_PATH_NUM_SEGMENTS                        = 0x1604,
  VG_PATH_NUM_COORDS                          = 0x1605,

  VG_PATH_PARAM_TYPE_FORCE_SIZE               = VG_MAX_ENUM
} VGPathParamType;

typedef enum {
  VG_CAP_BUTT                                 = 0x1700,
  VG_CAP_ROUND                                = 0x1701,
  VG_CAP_SQUARE                               = 0x1702,

  VG_CAP_STYLE_FORCE_SIZE                     = VG_MAX_ENUM
} VGCapStyle;

typedef enum {
  VG_JOIN_MITER                               = 0x1800,
  VG_JOIN_ROUND                               = 0x1801,
  VG_JOIN_BEVEL                               = 0x1802,

  VG_JOIN_STYLE_FORCE_SIZE                    = VG_MAX_ENUM
} VGJoinStyle;

typedef enum {
  VG_EVEN_ODD                                 = 0x1900,
  VG_NON_ZERO                                 = 0x1901,

  VG_FILL_RULE_FORCE_SIZE                     = VG_MAX_ENUM
} VGFillRule;

typedef enum {
  VG_STROKE_PATH                              = (1 << 0),
  VG_FILL_PATH                                = (1 << 1),

  VG_PAINT_MODE_FORCE_SIZE                    = VG_MAX_ENUM
} VGPaintMode;

typedef enum {
  /* Color paint parameters */
  VG_PAINT_TYPE                               = 0x1A00,
  VG_PAINT_COLOR                              = 0x1A01,
  VG_PAINT_COLOR_RAMP_SPREAD_MODE             = 0x1A02,
  VG_PAINT_COLOR_RAMP_PREMULTIPLIED           = 0x1A07,
  VG_PAINT_COLOR_RAMP_STOPS                   = 0x1A03,

  /* Linear gradient paint parameters */
  VG_PAINT_LINEAR_GRADIENT                    = 0x1A04,

  /* Radial gradient paint parameters */
  VG_PAINT_RADIAL_GRADIENT                    = 0x1A05,

  /* Pattern paint parameters */
  VG_PAINT_PATTERN_TILING_MODE                = 0x1A06,

  VG_PAINT_PARAM_TYPE_FORCE_SIZE              = VG_MAX_ENUM
} VGPaintParamType;

typedef enum {
  VG_PAINT_TYPE_COLOR                         = 0x1B00,
  VG_PAINT_TYPE_LINEAR_GRADIENT               = 0x1B01,
  VG_PAINT_TYPE_RADIAL_GRADIENT               = 0x1B02,
  VG_PAINT_TYPE_PATTERN                       = 0x1B03,

  VG_PAINT_TYPE_FORCE_SIZE                    = VG_MAX_ENUM
} VGPaintType;

typedef enum {
  VG_COLOR_RAMP_SPREAD_PAD                    = 0x1C00,
  VG_COLOR_RAMP_SPREAD_REPEAT                 = 0x1C01,
  VG_COLOR_RAMP_SPREAD_REFLECT                = 0x1C02,

  VG_COLOR_RAMP_SPREAD_MODE_FORCE_SIZE        = VG_MAX_ENUM
} VGColorRampSpreadMode;

typedef enum {
  VG_TILE_FILL                                = 0x1D00,
  VG_TILE_PAD                                 = 0x1D01,
  VG_TILE_REPEAT                              = 0x1D02,
  VG_TILE_REFLECT                             = 0x1D03,

  VG_TILING_MODE_FORCE_SIZE                   = VG_MAX_ENUM
} VGTilingMode;

typedef enum {
  /* RGB{A,X} channel ordering */
  VG_sRGBX_8888                               =  0,
  VG_sRGBA_8888                               =  1,
  VG_sRGBA_8888_PRE                           =  2,
  VG_sRGB_565                                 =  3,
  VG_sRGBA_5551                               =  4,
  VG_sRGBA_4444                               =  5,
  VG_sL_8                                     =  6,
  VG_lRGBX_8888                               =  7,
  VG_lRGBA_8888                               =  8,
  VG_lRGBA_8888_PRE                           =  9,
  VG_lL_8                                     = 10,
  VG_A_8                                      = 11,
  VG_BW_1                                     = 12,
  VG_A_1                                      = 13,
  VG_A_4                                      = 14,

  /* {A,X}RGB channel ordering */
  VG_sXRGB_8888                               =  0 | (1 << 6),
  VG_sARGB_8888                               =  1 | (1 << 6),
  VG_sARGB_8888_PRE                           =  2 | (1 << 6),
  VG_sARGB_1555                               =  4 | (1 << 6),
  VG_sARGB_4444                               =  5 | (1 << 6),
  VG_lXRGB_8888                               =  7 | (1 << 6),
  VG_lARGB_8888                               =  8 | (1 << 6),
  VG_lARGB_8888_PRE                           =  9 | (1 << 6),

  /* BGR{A,X} channel ordering */
  VG_sBGRX_8888                               =  0 | (1 << 7),
  VG_sBGRA_8888                               =  1 | (1 << 7),
  VG_sBGRA_8888_PRE                           =  2 | (1 << 7),
  VG_sBGR_565                                 =  3 | (1 << 7),
  VG_sBGRA_5551                               =  4 | (1 << 7),
  VG_sBGRA_4444                               =  5 | (1 << 7),
  VG_lBGRX_8888                               =  7 | (1 << 7),
  VG_lBGRA_8888                               =  8 | (1 << 7),
  VG_lBGRA_8888_PRE                           =  9 | (1 << 7),

  /* {A,X}BGR channel ordering */
  VG_sXBGR_8888                               =  0 | (1 << 6) | (1 << 7),
  VG_sABGR_8888                               =  1 | (1 << 6) | (1 << 7),
  VG_sABGR_8888_PRE                           =  2 | (1 << 6) | (1 << 7),
  VG_sABGR_1555                               =  4 | (1 << 6) | (1 << 7),
  VG_sABGR_4444                               =  5 | (1 << 6) | (1 << 7),
  VG_lXBGR_8888                               =  7 | (1 << 6) | (1 << 7),
  VG_lABGR_8888                               =  8 | (1 << 6) | (1 << 7),
  VG_lABGR_8888_PRE                           =  9 | (1 << 6) | (1 << 7),

  VG_IMAGE_FORMAT_FORCE_SIZE                  = VG_MAX_ENUM
} VGImageFormat;

typedef enum {
  VG_IMAGE_QUALITY_NONANTIALIASED             = (1 << 0),
  VG_IMAGE_QUALITY_FASTER                     = (1 << 1),
  VG_IMAGE_QUALITY_BETTER                     = (1 << 2),

  VG_IMAGE_QUALITY_FORCE_SIZE                 = VG_MAX_ENUM
} VGImageQuality;

typedef enum {
  VG_IMAGE_FORMAT                             = 0x1E00,
  VG_IMAGE_WIDTH                              = 0x1E01,
  VG_IMAGE_HEIGHT                             = 0x1E02,

  VG_IMAGE_PARAM_TYPE_FORCE_SIZE              = VG_MAX_ENUM
} VGImageParamType;

typedef enum {
  VG_DRAW_IMAGE_NORMAL                        = 0x1F00,
  VG_DRAW_IMAGE_MULTIPLY                      = 0x1F01,
  VG_DRAW_IMAGE_STENCIL                       = 0x1F02,

  VG_IMAGE_MODE_FORCE_SIZE                    = VG_MAX_ENUM
} VGImageMode;

typedef enum {
  VG_RED                                      = (1 << 3),
  VG_GREEN                                    = (1 << 2),
  VG_BLUE                                     = (1 << 1),
  VG_ALPHA                                    = (1 << 0),

  VG_IMAGE_CHANNEL_FORCE_SIZE                 = VG_MAX_ENUM
} VGImageChannel;

typedef enum {
  VG_BLEND_SRC                                = 0x2000,
  VG_BLEND_SRC_OVER                           = 0x2001,
  VG_BLEND_DST_OVER                           = 0x2002,
  VG_BLEND_SRC_IN                             = 0x2003,
  VG_BLEND_DST_IN                             = 0x2004,
  VG_BLEND_MULTIPLY                           = 0x2005,
  VG_BLEND_SCREEN                             = 0x2006,
  VG_BLEND_DARKEN                             = 0x2007,
  VG_BLEND_LIGHTEN                            = 0x2008,
  VG_BLEND_ADDITIVE                           = 0x2009,

  VG_BLEND_MODE_FORCE_SIZE                    = VG_MAX_ENUM
} VGBlendMode;

typedef enum {
  VG_FONT_NUM_GLYPHS                          = 0x2F00,

  VG_FONT_PARAM_TYPE_FORCE_SIZE               = VG_MAX_ENUM
} VGFontParamType;

typedef enum {
  VG_IMAGE_FORMAT_QUERY                       = 0x2100,
  VG_PATH_DATATYPE_QUERY                      = 0x2101,

  VG_HARDWARE_QUERY_TYPE_FORCE_SIZE           = VG_MAX_ENUM
} VGHardwareQueryType;

typedef enum {
  VG_HARDWARE_ACCELERATED                     = 0x2200,
  VG_HARDWARE_UNACCELERATED                   = 0x2201,

  VG_HARDWARE_QUERY_RESULT_FORCE_SIZE         = VG_MAX_ENUM
} VGHardwareQueryResult;

typedef enum {
  VG_VENDOR                                   = 0x2300,
  VG_RENDERER                                 = 0x2301,
  VG_VERSION                                  = 0x2302,
  VG_EXTENSIONS                               = 0x2303,

  VG_STRING_ID_FORCE_SIZE                     = VG_MAX_ENUM
} VGStringID;

/* Function Prototypes */

#ifndef VG_API_CALL
#	error VG_API_CALL must be defined
#endif

#ifndef VG_API_ENTRY
#   error VG_API_ENTRY must be defined
#endif

#ifndef VG_API_EXIT
#   error VG_API_EXIT must be defined
#endif

VG_API_CALL VGErrorCode VG_API_ENTRY vgGetError(void) VG_API_EXIT;

VG_API_CALL void VG_API_ENTRY vgFlush(void) VG_API_EXIT;
VG_API_CALL void VG_API_ENTRY vgFinish(void) VG_API_EXIT;

/* Getters and Setters */
VG_API_CALL void VG_API_ENTRY vgSetf (VGParamType type, VGfloat value) VG_API_EXIT;
VG_API_CALL void VG_API_ENTRY vgSeti (VGParamType type, VGint value) VG_API_EXIT;
VG_API_CALL void VG_API_ENTRY vgSetfv(VGParamType type, VGint count,
                         const VGfloat * values) VG_API_EXIT;
VG_API_CALL void VG_API_ENTRY vgSetiv(VGParamType type, VGint count,
                         const VGint * values) VG_API_EXIT;

VG_API_CALL VGfloat VG_API_ENTRY vgGetf(VGParamType type) VG_API_EXIT;
VG_API_CALL VGint VG_API_ENTRY vgGeti(VGParamType type) VG_API_EXIT;
VG_API_CALL VGint VG_API_ENTRY vgGetVectorSize(VGParamType type) VG_API_EXIT;
VG_API_CALL void VG_API_ENTRY vgGetfv(VGParamType type, VGint count, VGfloat * values) VG_API_EXIT;
VG_API_CALL void VG_API_ENTRY vgGetiv(VGParamType type, VGint count, VGint * values) VG_API_EXIT;

VG_API_CALL void VG_API_ENTRY vgSetParameterf(VGHandle object,
                                 VGint paramType,
                                 VGfloat value) VG_API_EXIT;
VG_API_CALL void VG_API_ENTRY vgSetParameteri(VGHandle object,
                                 VGint paramType,
                                 VGint value) VG_API_EXIT;
VG_API_CALL void VG_API_ENTRY vgSetParameterfv(VGHandle object,
                                  VGint paramType,
                                  VGint count, const VGfloat * values) VG_API_EXIT;
VG_API_CALL void VG_API_ENTRY vgSetParameteriv(VGHandle object,
                                  VGint paramType,
                                  VGint count, const VGint * values) VG_API_EXIT;

VG_API_CALL VGfloat VG_API_ENTRY vgGetParameterf(VGHandle object,
                                    VGint paramType) VG_API_EXIT;
VG_API_CALL VGint VG_API_ENTRY vgGetParameteri(VGHandle object,
                                  VGint paramType);
VG_API_CALL VGint VG_API_ENTRY vgGetParameterVectorSize(VGHandle object,
                                           VGint paramType) VG_API_EXIT;
VG_API_CALL void VG_API_ENTRY vgGetParameterfv(VGHandle object,
                                  VGint paramType,
                                  VGint count, VGfloat * values) VG_API_EXIT;
VG_API_CALL void VG_API_ENTRY vgGetParameteriv(VGHandle object,
                                  VGint paramType,
                                  VGint count, VGint * values) VG_API_EXIT;

/* Matrix Manipulation */
VG_API_CALL void VG_API_ENTRY vgLoadIdentity(void) VG_API_EXIT;
VG_API_CALL void VG_API_ENTRY vgLoadMatrix(const VGfloat * m) VG_API_EXIT;
VG_API_CALL void VG_API_ENTRY vgGetMatrix(VGfloat * m) VG_API_EXIT;
VG_API_CALL void VG_API_ENTRY vgMultMatrix(const VGfloat * m) VG_API_EXIT;
VG_API_CALL void VG_API_ENTRY vgTranslate(VGfloat tx, VGfloat ty) VG_API_EXIT;
VG_API_CALL void VG_API_ENTRY vgScale(VGfloat sx, VGfloat sy) VG_API_EXIT;
VG_API_CALL void VG_API_ENTRY vgShear(VGfloat shx, VGfloat shy) VG_API_EXIT;
VG_API_CALL void VG_API_ENTRY vgRotate(VGfloat angle) VG_API_EXIT;

/* Masking and Clearing */
VG_API_CALL void VG_API_ENTRY vgMask(VGHandle mask, VGMaskOperation operation,
                                     VGint x, VGint y,
                                     VGint width, VGint height) VG_API_EXIT;
VG_API_CALL void VG_API_ENTRY vgRenderToMask(VGPath path,
                                            VGbitfield paintModes,
                                            VGMaskOperation operation) VG_API_EXIT;
VG_API_CALL VGMaskLayer VG_API_ENTRY vgCreateMaskLayer(VGint width, VGint height) VG_API_EXIT;
VG_API_CALL void VG_API_ENTRY vgDestroyMaskLayer(VGMaskLayer maskLayer) VG_API_EXIT;
VG_API_CALL void VG_API_ENTRY vgFillMaskLayer(VGMaskLayer maskLayer,
                                             VGint x, VGint y,
                                             VGint width, VGint height,
                                             VGfloat value) VG_API_EXIT;
VG_API_CALL void VG_API_ENTRY vgCopyMask(VGMaskLayer maskLayer,
                                        VGint dx, VGint dy,
                                        VGint sx, VGint sy,
                                        VGint width, VGint height) VG_API_EXIT;
VG_API_CALL void VG_API_ENTRY vgClear(VGint x, VGint y, VGint width, VGint height) VG_API_EXIT;

/* Paths */
VG_API_CALL VGPath VG_API_ENTRY vgCreatePath(VGint pathFormat,
                                VGPathDatatype datatype,
                                VGfloat scale, VGfloat bias,
                                VGint segmentCapacityHint,
                                VGint coordCapacityHint,
                                VGbitfield capabilities) VG_API_EXIT;
VG_API_CALL void VG_API_ENTRY vgClearPath(VGPath path, VGbitfield capabilities) VG_API_EXIT;
VG_API_CALL void VG_API_ENTRY vgDestroyPath(VGPath path) VG_API_EXIT;
VG_API_CALL void VG_API_ENTRY vgRemovePathCapabilities(VGPath path,
                                          VGbitfield capabilities) VG_API_EXIT;
VG_API_CALL VGbitfield VG_API_ENTRY vgGetPathCapabilities(VGPath path) VG_API_EXIT;
VG_API_CALL void VG_API_ENTRY vgAppendPath(VGPath dstPath, VGPath srcPath) VG_API_EXIT;
VG_API_CALL void VG_API_ENTRY vgAppendPathData(VGPath dstPath,
                                  VGint numSegments,
                                  const VGubyte * pathSegments,
                                  const void * pathData) VG_API_EXIT;
VG_API_CALL void VG_API_ENTRY vgModifyPathCoords(VGPath dstPath, VGint startIndex,
                                    VGint numSegments,
                                    const void * pathData) VG_API_EXIT;
VG_API_CALL void VG_API_ENTRY vgTransformPath(VGPath dstPath, VGPath srcPath) VG_API_EXIT;
VG_API_CALL VGboolean VG_API_ENTRY vgInterpolatePath(VGPath dstPath,
                                        VGPath startPath,
                                        VGPath endPath,
                                        VGfloat amount) VG_API_EXIT;
VG_API_CALL VGfloat VG_API_ENTRY vgPathLength(VGPath path,
                                 VGint startSegment, VGint numSegments) VG_API_EXIT;
VG_API_CALL void VG_API_ENTRY vgPointAlongPath(VGPath path,
                                  VGint startSegment, VGint numSegments,
                                  VGfloat distance,
                                  VGfloat * x, VGfloat * y,
                                  VGfloat * tangentX, VGfloat * tangentY) VG_API_EXIT;
VG_API_CALL void VG_API_ENTRY vgPathBounds(VGPath path,
                              VGfloat * minX, VGfloat * minY,
                              VGfloat * width, VGfloat * height) VG_API_EXIT;
VG_API_CALL void VG_API_ENTRY vgPathTransformedBounds(VGPath path,
                                         VGfloat * minX, VGfloat * minY,
                                         VGfloat * width, VGfloat * height) VG_API_EXIT;
VG_API_CALL void VG_API_ENTRY vgDrawPath(VGPath path, VGbitfield paintModes) VG_API_EXIT;

/* Paint */
VG_API_CALL VGPaint VG_API_ENTRY vgCreatePaint(void) VG_API_EXIT;
VG_API_CALL void VG_API_ENTRY vgDestroyPaint(VGPaint paint) VG_API_EXIT;
VG_API_CALL void VG_API_ENTRY vgSetPaint(VGPaint paint, VGbitfield paintModes) VG_API_EXIT;
VG_API_CALL VGPaint VG_API_ENTRY vgGetPaint(VGPaintMode paintMode) VG_API_EXIT;
VG_API_CALL void VG_API_ENTRY vgSetColor(VGPaint paint, VGuint rgba) VG_API_EXIT;
VG_API_CALL VGuint VG_API_ENTRY vgGetColor(VGPaint paint) VG_API_EXIT;
VG_API_CALL void VG_API_ENTRY vgPaintPattern(VGPaint paint, VGImage pattern) VG_API_EXIT;

/* Images */
VG_API_CALL VGImage VG_API_ENTRY vgCreateImage(VGImageFormat format,
                                  VGint width, VGint height,
                                  VGbitfield allowedQuality) VG_API_EXIT;
VG_API_CALL void VG_API_ENTRY vgDestroyImage(VGImage image) VG_API_EXIT;
VG_API_CALL void VG_API_ENTRY vgClearImage(VGImage image,
                              VGint x, VGint y, VGint width, VGint height) VG_API_EXIT;
VG_API_CALL void VG_API_ENTRY vgImageSubData(VGImage image,
                                const void * data, VGint dataStride,
                                VGImageFormat dataFormat,
                                VGint x, VGint y, VGint width, VGint height) VG_API_EXIT;
VG_API_CALL void VG_API_ENTRY vgGetImageSubData(VGImage image,
                                   void * data, VGint dataStride,
                                   VGImageFormat dataFormat,
                                   VGint x, VGint y,
                                   VGint width, VGint height) VG_API_EXIT;
VG_API_CALL VGImage VG_API_ENTRY vgChildImage(VGImage parent,
                                 VGint x, VGint y, VGint width, VGint height) VG_API_EXIT;
VG_API_CALL VGImage VG_API_ENTRY vgGetParent(VGImage image) VG_API_EXIT;
VG_API_CALL void VG_API_ENTRY vgCopyImage(VGImage dst, VGint dx, VGint dy,
                             VGImage src, VGint sx, VGint sy,
                             VGint width, VGint height,
                             VGboolean dither) VG_API_EXIT;
VG_API_CALL void VG_API_ENTRY vgDrawImage(VGImage image) VG_API_EXIT;
VG_API_CALL void VG_API_ENTRY vgSetPixels(VGint dx, VGint dy,
                             VGImage src, VGint sx, VGint sy,
                             VGint width, VGint height) VG_API_EXIT;
VG_API_CALL void VG_API_ENTRY vgWritePixels(const void * data, VGint dataStride,
                               VGImageFormat dataFormat,
                               VGint dx, VGint dy,
                               VGint width, VGint height) VG_API_EXIT;
VG_API_CALL void VG_API_ENTRY vgGetPixels(VGImage dst, VGint dx, VGint dy,
                             VGint sx, VGint sy,
                             VGint width, VGint height) VG_API_EXIT;
VG_API_CALL void VG_API_ENTRY vgReadPixels(void * data, VGint dataStride,
                              VGImageFormat dataFormat,
                              VGint sx, VGint sy,
                              VGint width, VGint height) VG_API_EXIT;
VG_API_CALL void VG_API_ENTRY vgCopyPixels(VGint dx, VGint dy,
                              VGint sx, VGint sy,
                              VGint width, VGint height) VG_API_EXIT;

/* Text */
VG_API_CALL VGFont VG_API_ENTRY vgCreateFont(VGint glyphCapacityHint) VG_API_EXIT;
VG_API_CALL void VG_API_ENTRY vgDestroyFont(VGFont font) VG_API_EXIT;
VG_API_CALL void VG_API_ENTRY vgSetGlyphToPath(VGFont font,
                                              VGuint glyphIndex,
                                              VGPath path,
                                              VGboolean isHinted,
                                              VGfloat glyphOrigin [2],
                                              VGfloat escapement[2]) VG_API_EXIT;
VG_API_CALL void VG_API_ENTRY vgSetGlyphToImage(VGFont font,
                                               VGuint glyphIndex,
                                               VGImage image,
                                               VGfloat glyphOrigin [2],
                                               VGfloat escapement[2]) VG_API_EXIT;
VG_API_CALL void VG_API_ENTRY vgClearGlyph(VGFont font,VGuint glyphIndex) VG_API_EXIT;
VG_API_CALL void VG_API_ENTRY vgDrawGlyph(VGFont font,
                                         VGuint glyphIndex,
                                         VGbitfield paintModes,
                                         VGboolean allowAutoHinting) VG_API_EXIT;
VG_API_CALL void VG_API_ENTRY vgDrawGlyphs(VGFont font,
                                          VGint glyphCount,
                                          const VGuint *glyphIndices,
                                          const VGfloat *adjustments_x,
                                          const VGfloat *adjustments_y,
                                          VGbitfield paintModes,
                                          VGboolean allowAutoHinting) VG_API_EXIT;

/* Image Filters */
VG_API_CALL void VG_API_ENTRY vgColorMatrix(VGImage dst, VGImage src,
                               const VGfloat * matrix) VG_API_EXIT;
VG_API_CALL void VG_API_ENTRY vgConvolve(VGImage dst, VGImage src,
                            VGint kernelWidth, VGint kernelHeight,
                            VGint shiftX, VGint shiftY,
                            const VGshort * kernel,
                            VGfloat scale,
                            VGfloat bias,
                            VGTilingMode tilingMode) VG_API_EXIT;
VG_API_CALL void VG_API_ENTRY vgSeparableConvolve(VGImage dst, VGImage src,
                                     VGint kernelWidth,
                                     VGint kernelHeight,
                                     VGint shiftX, VGint shiftY,
                                     const VGshort * kernelX,
                                     const VGshort * kernelY,
                                     VGfloat scale,
                                     VGfloat bias,
                                     VGTilingMode tilingMode) VG_API_EXIT;
VG_API_CALL void VG_API_ENTRY vgGaussianBlur(VGImage dst, VGImage src,
                                VGfloat stdDeviationX,
                                VGfloat stdDeviationY,
                                VGTilingMode tilingMode) VG_API_EXIT;
VG_API_CALL void VG_API_ENTRY vgLookup(VGImage dst, VGImage src,
                          const VGubyte * redLUT,
                          const VGubyte * greenLUT,
                          const VGubyte * blueLUT,
                          const VGubyte * alphaLUT,
                          VGboolean outputLinear,
                          VGboolean outputPremultiplied) VG_API_EXIT;
VG_API_CALL void VG_API_ENTRY vgLookupSingle(VGImage dst, VGImage src,
                                const VGuint * lookupTable,
                                VGImageChannel sourceChannel,
                                VGboolean outputLinear,
                                VGboolean outputPremultiplied) VG_API_EXIT;

/* Hardware Queries */
VG_API_CALL VGHardwareQueryResult VG_API_ENTRY vgHardwareQuery(VGHardwareQueryType key,
                                                  VGint setting) VG_API_EXIT;

/* Renderer and Extension Information */
VG_API_CALL const VGubyte * VG_API_ENTRY vgGetString(VGStringID name) VG_API_EXIT;

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _OPENVG_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /* $Revision: 6810 $ on $Date:: 2008-10-29 14:31:37 +0000 #$ */

/*------------------------------------------------------------------------
 *
 * VG extensions Reference Implementation
 * -------------------------------------
 *
 * Copyright (c) 2008 The Khronos Group Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and /or associated documentation files
 * (the "Materials "), to deal in the Materials without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Materials,
 * and to permit persons to whom the Materials are furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Materials.
 *
 * THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE MATERIALS OR
 * THE USE OR OTHER DEALINGS IN THE MATERIALS.
 *
 *//**
 * \file
 * \brief	VG extensions
 *//*-------------------------------------------------------------------*/



#ifndef _VGEXT_H
#define _VGEXT_H

#ifdef __cplusplus
extern "C" {
#endif

#include "openvg.h"
#include "vgu.h"

#ifndef VG_API_ENTRYP
#   define VG_API_ENTRYP VG_API_ENTRY*
#endif

#ifndef VGU_API_ENTRYP
#   define VGU_API_ENTRYP VGU_API_ENTRY*
#endif

/*-------------------------------------------------------------------------------
 * KHR extensions
 *------------------------------------------------------------------------------*/

typedef enum  {

#ifndef VG_KHR_iterative_average_blur
  VG_MAX_AVERAGE_BLUR_DIMENSION_KHR        = 0x116B,
  VG_AVERAGE_BLUR_DIMENSION_RESOLUTION_KHR = 0x116C,
  VG_MAX_AVERAGE_BLUR_ITERATIONS_KHR       = 0x116D,
#endif

  VG_PARAM_TYPE_KHR_FORCE_SIZE             = VG_MAX_ENUM
} VGParamTypeKHR;

#ifndef VG_KHR_EGL_image
#define VG_KHR_EGL_image 1
/* VGEGLImageKHR is an opaque handle to an EGLImage */
typedef void* VGeglImageKHR;

#ifdef VG_VGEXT_PROTOTYPES
VG_API_CALL VGImage VG_API_ENTRY vgCreateEGLImageTargetKHR(VGeglImageKHR image);
#endif
typedef VGImage (VG_API_ENTRYP PFNVGCREATEEGLIMAGETARGETKHRPROC) (VGeglImageKHR image);

#endif


#ifndef VG_KHR_iterative_average_blur
#define VG_KHR_iterative_average_blur 1

#ifdef VG_VGEXT_PROTOTYPES
VG_API_CALL void vgIterativeAverageBlurKHR(VGImage dst,VGImage src,VGfloat dimX,VGfloat dimY,VGuint iterative,VGTilingMode tilingMode);
#endif
typedef void (VG_API_ENTRYP PFNVGITERATIVEAVERAGEBLURKHRPROC) (VGImage dst,VGImage src,VGfloat dimX,VGfloat dimY,VGuint iterative,VGTilingMode tilingMode);

#endif


#ifndef VG_KHR_advanced_blending
#define VG_KHR_advanced_blending 1

typedef enum {
  VG_BLEND_OVERLAY_KHR        = 0x2010,
  VG_BLEND_HARDLIGHT_KHR      = 0x2011,
  VG_BLEND_SOFTLIGHT_SVG_KHR  = 0x2012,
  VG_BLEND_SOFTLIGHT_KHR      = 0x2013,
  VG_BLEND_COLORDODGE_KHR     = 0x2014,
  VG_BLEND_COLORBURN_KHR      = 0x2015,
  VG_BLEND_DIFFERENCE_KHR     = 0x2016,
  VG_BLEND_SUBTRACT_KHR       = 0x2017,
  VG_BLEND_INVERT_KHR         = 0x2018,
  VG_BLEND_EXCLUSION_KHR      = 0x2019,
  VG_BLEND_LINEARDODGE_KHR    = 0x201a,
  VG_BLEND_LINEARBURN_KHR     = 0x201b,
  VG_BLEND_VIVIDLIGHT_KHR     = 0x201c,
  VG_BLEND_LINEARLIGHT_KHR    = 0x201d,
  VG_BLEND_PINLIGHT_KHR       = 0x201e,
  VG_BLEND_HARDMIX_KHR        = 0x201f,
  VG_BLEND_CLEAR_KHR          = 0x2020,
  VG_BLEND_DST_KHR            = 0x2021,
  VG_BLEND_SRC_OUT_KHR        = 0x2022,
  VG_BLEND_DST_OUT_KHR        = 0x2023,
  VG_BLEND_SRC_ATOP_KHR       = 0x2024,
  VG_BLEND_DST_ATOP_KHR       = 0x2025,
  VG_BLEND_XOR_KHR            = 0x2026,

  VG_BLEND_MODE_KHR_FORCE_SIZE= VG_MAX_ENUM
} VGBlendModeKHR;
#endif

#ifndef VG_KHR_parametric_filter
#define VG_KHR_parametric_filter 1

typedef enum {
  VG_PF_OBJECT_VISIBLE_FLAG_KHR = (1 << 0),
  VG_PF_KNOCKOUT_FLAG_KHR       = (1 << 1),
  VG_PF_OUTER_FLAG_KHR          = (1 << 2),
  VG_PF_INNER_FLAG_KHR          = (1 << 3),

  VG_PF_TYPE_KHR_FORCE_SIZE     = VG_MAX_ENUM
} VGPfTypeKHR;

typedef enum {
  VGU_IMAGE_IN_USE_ERROR           = 0xF010,

  VGU_ERROR_CODE_KHR_FORCE_SIZE    = VG_MAX_ENUM
} VGUErrorCodeKHR;

#ifdef VG_VGEXT_PROTOTYPES
VG_API_CALL void VG_API_ENTRY vgParametricFilterKHR(VGImage dst,VGImage src,VGImage blur,VGfloat strength,VGfloat offsetX,VGfloat offsetY,VGbitfield filterFlags,VGPaint highlightPaint,VGPaint shadowPaint);
VGU_API_CALL VGUErrorCode VGU_API_ENTRY vguDropShadowKHR(VGImage dst,VGImage src,VGfloat dimX,VGfloat dimY,VGuint iterative,VGfloat strength,VGfloat distance,VGfloat angle,VGbitfield filterFlags,VGbitfield allowedQuality,VGuint shadowColorRGBA);
VGU_API_CALL VGUErrorCode VGU_API_ENTRY vguGlowKHR(VGImage dst,VGImage src,VGfloat dimX,VGfloat dimY,VGuint iterative,VGfloat strength,VGbitfield filterFlags,VGbitfield allowedQuality,VGuint glowColorRGBA) ;
VGU_API_CALL VGUErrorCode VGU_API_ENTRY vguBevelKHR(VGImage dst,VGImage src,VGfloat dimX,VGfloat dimY,VGuint iterative,VGfloat strength,VGfloat distance,VGfloat angle,VGbitfield filterFlags,VGbitfield allowedQuality,VGuint highlightColorRGBA,VGuint shadowColorRGBA);
VGU_API_CALL VGUErrorCode VGU_API_ENTRY vguGradientGlowKHR(VGImage dst,VGImage src,VGfloat dimX,VGfloat dimY,VGuint iterative,VGfloat strength,VGfloat distance,VGfloat angle,VGbitfield filterFlags,VGbitfield allowedQuality,VGuint stopsCount,const VGfloat* glowColorRampStops);
VGU_API_CALL VGUErrorCode VGU_API_ENTRY vguGradientBevelKHR(VGImage dst,VGImage src,VGfloat dimX,VGfloat dimY,VGuint iterative,VGfloat strength,VGfloat distance,VGfloat angle,VGbitfield filterFlags,VGbitfield allowedQuality,VGuint stopsCount,const VGfloat* bevelColorRampStops);
#endif
typedef void (VG_API_ENTRYP PFNVGPARAMETRICFILTERKHRPROC) (VGImage dst,VGImage src,VGImage blur,VGfloat strength,VGfloat offsetX,VGfloat offsetY,VGbitfield filterFlags,VGPaint highlightPaint,VGPaint shadowPaint);
typedef VGUErrorCode (VGU_API_ENTRYP PFNVGUDROPSHADOWKHRPROC) (VGImage dst,VGImage src,VGfloat dimX,VGfloat dimY,VGuint iterative,VGfloat strength,VGfloat distance,VGfloat angle,VGbitfield filterFlags,VGbitfield allowedQuality,VGuint shadowColorRGBA);
typedef VGUErrorCode (VGU_API_ENTRYP PFNVGUGLOWKHRPROC) (VGImage dst,VGImage src,VGfloat dimX,VGfloat dimY,VGuint iterative,VGfloat strength,VGbitfield filterFlags,VGbitfield allowedQuality,VGuint glowColorRGBA);
typedef VGUErrorCode (VGU_API_ENTRYP PFNVGUBEVELKHRPROC) (VGImage dst,VGImage src,VGfloat dimX,VGfloat dimY,VGuint iterative,VGfloat strength,VGfloat distance,VGfloat angle,VGbitfield filterFlags,VGbitfield allowedQuality,VGuint highlightColorRGBA,VGuint shadowColorRGBA);
typedef VGUErrorCode (VGU_API_ENTRYP PFNVGUGRADIENTGLOWKHRPROC) (VGImage dst,VGImage src,VGfloat dimX,VGfloat dimY,VGuint iterative,VGfloat strength,VGfloat distance,VGfloat angle,VGbitfield filterFlags,VGbitfield allowedQuality,VGuint stopsCount,const VGfloat* glowColorRampStops);
typedef VGUErrorCode (VGU_API_ENTRYP PFNVGUGRADIENTBEVELKHRPROC) (VGImage dst,VGImage src,VGfloat dimX,VGfloat dimY,VGuint iterative,VGfloat strength,VGfloat distance,VGfloat angle,VGbitfield filterFlags,VGbitfield allowedQuality,VGuint stopsCount,const VGfloat* bevelColorRampStops);

#endif


/*-------------------------------------------------------------------------------
 * NDS extensions
 *------------------------------------------------------------------------------*/

#ifndef VG_NDS_paint_generation
#define VG_NDS_paint_generation 1

typedef enum {
  VG_PAINT_COLOR_RAMP_LINEAR_NDS            = 0x1A10,
  VG_COLOR_MATRIX_NDS                       = 0x1A11,
  VG_PAINT_COLOR_TRANSFORM_LINEAR_NDS       = 0x1A12,

  VG_PAINT_PARAM_TYPE_NDS_FORCE_SIZE        = VG_MAX_ENUM
} VGPaintParamTypeNds;

typedef enum {
  VG_DRAW_IMAGE_COLOR_MATRIX_NDS            = 0x1F10,

  VG_IMAGE_MODE_NDS_FORCE_SIZE              = VG_MAX_ENUM
} VGImageModeNds;
#endif


#ifndef VG_NDS_projective_geometry
#define VG_NDS_projective_geometry 1

typedef enum {
  VG_CLIP_MODE_NDS                          = 0x1180,
  VG_CLIP_LINES_NDS                         = 0x1181,
  VG_MAX_CLIP_LINES_NDS                     = 0x1182,

  VG_PARAM_TYPE_NDS_FORCE_SIZE        = VG_MAX_ENUM
} VGParamTypeNds;

typedef enum {
  VG_CLIPMODE_NONE_NDS                      = 0x3000,
  VG_CLIPMODE_CLIP_CLOSED_NDS               = 0x3001,
  VG_CLIPMODE_CLIP_OPEN_NDS                 = 0x3002,
  VG_CLIPMODE_CULL_NDS                      = 0x3003,

  VG_CLIPMODE_NDS_FORCE_SIZE = VG_MAX_ENUM
} VGClipModeNds;

typedef enum {
  VG_RQUAD_TO_NDS              = ( 13 << 1 ),
  VG_RCUBIC_TO_NDS             = ( 14 << 1 ),

  VG_PATH_SEGMENT_NDS_FORCE_SIZE = VG_MAX_ENUM
} VGPathSegmentNds;

typedef enum {
  VG_RQUAD_TO_ABS_NDS            = (VG_RQUAD_TO_NDS  | VG_ABSOLUTE),
  VG_RQUAD_TO_REL_NDS            = (VG_RQUAD_TO_NDS  | VG_RELATIVE),
  VG_RCUBIC_TO_ABS_NDS           = (VG_RCUBIC_TO_NDS | VG_ABSOLUTE),
  VG_RCUBIC_TO_REL_NDS           = (VG_RCUBIC_TO_NDS | VG_RELATIVE),

  VG_PATH_COMMAND_NDS_FORCE_SIZE = VG_MAX_ENUM
} VGPathCommandNds;

#ifdef VG_VGEXT_PROTOTYPES
VG_API_CALL void VG_API_ENTRY vgProjectiveMatrixNDS(VGboolean enable) ;
VGU_API_CALL VGUErrorCode VGU_API_ENTRY vguTransformClipLineNDS(const VGfloat Ain,const VGfloat Bin,const VGfloat Cin,const VGfloat* matrix,const VGboolean inverse,VGfloat* Aout,VGfloat* Bout,VGfloat* Cout);
#endif
typedef void (VG_API_ENTRYP PFNVGPROJECTIVEMATRIXNDSPROC) (VGboolean enable) ;
typedef VGUErrorCode (VGU_API_ENTRYP PFNVGUTRANSFORMCLIPLINENDSPROC) (const VGfloat Ain,const VGfloat Bin,const VGfloat Cin,const VGfloat* matrix,const VGboolean inverse,VGfloat* Aout,VGfloat* Bout,VGfloat* Cout);

#endif

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _VGEXT_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                /* $Revision: 6810 $ on $Date:: 2008-10-29 14:31:37 +0000 #$ */

/*------------------------------------------------------------------------
 *
 * VG platform specific header Reference Implementation
 * ----------------------------------------------------
 *
 * Copyright (c) 2008 The Khronos Group Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and /or associated documentation files
 * (the "Materials "), to deal in the Materials without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Materials,
 * and to permit persons to whom the Materials are furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Materials.
 *
 * THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE MATERIALS OR
 * THE USE OR OTHER DEALINGS IN THE MATERIALS.
 *
 *//**
 * \file
 * \brief VG platform specific header
 *//*-------------------------------------------------------------------*/

#ifndef _VGPLATFORM_H
#define _VGPLATFORM_H

#ifdef __cplusplus
extern "C" {
#endif

#ifndef VG_API_CALL
   #ifdef KHAPI
      #define VG_API_CALL KHAPI
   #else
      #define VG_API_CALL extern
   #endif
#endif

#ifndef VGU_API_CALL
   #define VGU_API_CALL VG_API_CALL
#endif

#ifndef VG_API_ENTRY
#define VG_API_ENTRY
#endif

#ifndef VG_API_EXIT
#define VG_API_EXIT
#endif

#ifndef VGU_API_ENTRY
#define VGU_API_ENTRY
#endif

#ifndef VGU_API_EXIT
#define VGU_API_EXIT
#endif

#include "../KHR/khrplatform.h"
typedef khronos_float_t  VGfloat;
typedef khronos_int8_t   VGbyte;
typedef khronos_uint8_t  VGubyte;
typedef khronos_int16_t  VGshort;
typedef khronos_int32_t  VGint;
typedef khronos_uint32_t VGuint;
typedef khronos_uint32_t VGbitfield;

#ifndef VG_VGEXT_PROTOTYPES
#define VG_VGEXT_PROTOTYPES
#endif

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _VGPLATFORM_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  /*********************************************************************
 *                                                                   *
 * Sample implementation of wfc.h, version 1.0, draft 19             *
 *                                                                   *
 * Copyright (c) 2007-2009 The Khronos Group                           *
 *                                                                   *
 *********************************************************************/

#ifndef _WFC_H_
#define _WFC_H_

#include "wfcplatform.h"

#ifdef __cplusplus
extern "C" {
#endif

#define OPENWFC_VERSION_1_0       (1)

#define WFC_NONE                  (0)

#define WFC_INVALID_HANDLE        ((WFCHandle)0)

#define WFC_DEFAULT_DEVICE_ID     (0)

#define WFC_MAX_INT               ((WFCint)16777216)
#define WFC_MAX_FLOAT             ((WFCfloat)16777216)

typedef WFCHandle WFCDevice;
typedef WFCHandle WFCContext;
typedef WFCHandle WFCSource;
typedef WFCHandle WFCMask;
typedef WFCHandle WFCElement;

typedef enum {
    WFC_ERROR_NONE                          = 0,
    WFC_ERROR_OUT_OF_MEMORY                 = 0x7001,
    WFC_ERROR_ILLEGAL_ARGUMENT              = 0x7002,
    WFC_ERROR_UNSUPPORTED                   = 0x7003,
    WFC_ERROR_BAD_ATTRIBUTE                 = 0x7004,
    WFC_ERROR_IN_USE                        = 0x7005,
    WFC_ERROR_BUSY                          = 0x7006,
    WFC_ERROR_BAD_DEVICE                    = 0x7007,
    WFC_ERROR_BAD_HANDLE                    = 0x7008,
    WFC_ERROR_INCONSISTENCY                 = 0x7009,
    WFC_ERROR_FORCE_32BIT                   = 0x7FFFFFFF
} WFCErrorCode;

typedef enum {
    WFC_DEVICE_FILTER_SCREEN_NUMBER         = 0x7020,
    WFC_DEVICE_FILTER_FORCE_32BIT           = 0x7FFFFFFF
} WFCDeviceFilter;

typedef enum {
    /* Read-only */
    WFC_DEVICE_CLASS                        = 0x7030,
    WFC_DEVICE_ID                           = 0x7031,
    WFC_DEVICE_FORCE_32BIT                  = 0x7FFFFFFF
} WFCDeviceAttrib;

typedef enum {
    WFC_DEVICE_CLASS_FULLY_CAPABLE          = 0x7040,
    WFC_DEVICE_CLASS_OFF_SCREEN_ONLY        = 0x7041,
    WFC_DEVICE_CLASS_FORCE_32BIT            = 0x7FFFFFFF
} WFCDeviceClass;

typedef enum {
    /* Read-only */
    WFC_CONTEXT_TYPE                        = 0x7051,
    WFC_CONTEXT_TARGET_HEIGHT               = 0x7052,
    WFC_CONTEXT_TARGET_WIDTH                = 0x7053,
    WFC_CONTEXT_LOWEST_ELEMENT              = 0x7054,

    /* Read-write */
    WFC_CONTEXT_ROTATION                    = 0x7061,
    WFC_CONTEXT_BG_COLOR                    = 0x7062,
    WFC_CONTEXT_FORCE_32BIT                 = 0x7FFFFFFF
} WFCContextAttrib;

typedef enum {
    WFC_CONTEXT_TYPE_ON_SCREEN              = 0x7071,
    WFC_CONTEXT_TYPE_OFF_SCREEN             = 0x7072,
    WFC_CONTEXT_TYPE_FORCE_32BIT            = 0x7FFFFFFF
} WFCContextType;

typedef enum {
    /* Clockwise rotation */
    WFC_ROTATION_0                          = 0x7081,  /* default */
    WFC_ROTATION_90                         = 0x7082,
    WFC_ROTATION_180                        = 0x7083,
    WFC_ROTATION_270                        = 0x7084,
    WFC_ROTATION_FORCE_32BIT                = 0x7FFFFFFF
} WFCRotation;

typedef enum {
    WFC_ELEMENT_DESTINATION_RECTANGLE       = 0x7101,
    WFC_ELEMENT_SOURCE                      = 0x7102,
    WFC_ELEMENT_SOURCE_RECTANGLE            = 0x7103,
    WFC_ELEMENT_SOURCE_FLIP                 = 0x7104,
    WFC_ELEMENT_SOURCE_ROTATION             = 0x7105,
    WFC_ELEMENT_SOURCE_SCALE_FILTER         = 0x7106,
    WFC_ELEMENT_TRANSPARENCY_TYPES          = 0x7107,
    WFC_ELEMENT_GLOBAL_ALPHA                = 0x7108,
    WFC_ELEMENT_MASK                        = 0x7109,
    WFC_ELEMENT_FORCE_32BIT                 = 0x7FFFFFFF
} WFCElementAttrib;

typedef enum {
    WFC_SCALE_FILTER_NONE                   = 0x7151,  /* default */
    WFC_SCALE_FILTER_FASTER                 = 0x7152,
    WFC_SCALE_FILTER_BETTER                 = 0x7153,
    WFC_SCALE_FILTER_FORCE_32BIT            = 0x7FFFFFFF
} WFCScaleFilter;

typedef enum {
    WFC_TRANSPARENCY_NONE                   = 0,       /* default */
    WFC_TRANSPARENCY_ELEMENT_GLOBAL_ALPHA   = (1 << 0),
    WFC_TRANSPARENCY_SOURCE                 = (1 << 1),
    WFC_TRANSPARENCY_MASK                   = (1 << 2),
    WFC_TRANSPARENCY_FORCE_32BIT            = 0x7FFFFFFF
} WFCTransparencyType;

typedef enum {
    WFC_VENDOR                              = 0x7200,
    WFC_RENDERER                            = 0x7201,
    WFC_VERSION                             = 0x7202,
    WFC_EXTENSIONS                          = 0x7203,
    WFC_STRINGID_FORCE_32BIT                = 0x7FFFFFFF
} WFCStringID;


/* Function Prototypes */

/* Device */
WFC_API_CALL WFCint WFC_APIENTRY
    wfcEnumerateDevices(WFCint *deviceIds, WFCint deviceIdsCount,
        const WFCint *filterList) WFC_APIEXIT;
WFC_API_CALL WFCDevice WFC_APIENTRY
    wfcCreateDevice(WFCint deviceId, const WFCint *attribList) WFC_APIEXIT;
WFC_API_CALL WFCErrorCode WFC_APIENTRY
    wfcGetError(WFCDevice dev) WFC_APIEXIT;
WFC_API_CALL WFCint WFC_APIENTRY
    wfcGetDeviceAttribi(WFCDevice dev, WFCDeviceAttrib attrib) WFC_APIEXIT;
WFC_API_CALL WFCErrorCode WFC_APIENTRY
    wfcDestroyDevice(WFCDevice dev) WFC_APIEXIT;

/* Context */
WFC_API_CALL WFCContext WFC_APIENTRY
    wfcCreateOnScreenContext(WFCDevice dev,
        WFCint screenNumber,
        const WFCint *attribList) WFC_APIEXIT;
WFC_API_CALL WFCContext WFC_APIENTRY
    wfcCreateOffScreenContext(WFCDevice dev,
        WFCNativeStreamType stream,
        const WFCint *attribList) WFC_APIEXIT;
WFC_API_CALL void WFC_APIENTRY
    wfcCommit(WFCDevice dev, WFCContext ctx, WFCboolean wait) WFC_APIEXIT;
WFC_API_CALL WFCint WFC_APIENTRY
    wfcGetContextAttribi(WFCDevice dev, WFCContext ctx,
        WFCContextAttrib attrib) WFC_APIEXIT;
WFC_API_CALL void WFC_APIENTRY
    wfcGetContextAttribfv(WFCDevice dev, WFCContext ctx,
        WFCContextAttrib attrib, WFCint count, WFCfloat *values) WFC_APIEXIT;
WFC_API_CALL void WFC_APIENTRY
    wfcSetContextAttribi(WFCDevice dev, WFCContext ctx,
        WFCContextAttrib attrib, WFCint value) WFC_APIEXIT;
WFC_API_CALL void WFC_APIENTRY
    wfcSetContextAttribfv(WFCDevice dev, WFCContext ctx,
        WFCContextAttrib attrib,
        WFCint count, const WFCfloat *values) WFC_APIEXIT;
WFC_API_CALL void WFC_APIENTRY
    wfcDestroyContext(WFCDevice dev, WFCContext ctx) WFC_APIEXIT;

/* Source */
WFC_API_CALL WFCSource WFC_APIENTRY
    wfcCreateSourceFromStream(WFCDevice dev, WFCContext ctx,
        WFCNativeStreamType stream,
        const WFCint *attribList) WFC_APIEXIT;
WFC_API_CALL void WFC_APIENTRY
    wfcDestroySource(WFCDevice dev, WFCSource src) WFC_APIEXIT;

/* Mask */
WFC_API_CALL WFCMask WFC_APIENTRY
    wfcCreateMaskFromStream(WFCDevice dev, WFCContext ctx,
        WFCNativeStreamType stream,
        const WFCint *attribList) WFC_APIEXIT;
WFC_API_CALL void WFC_APIENTRY
    wfcDestroyMask(WFCDevice dev, WFCMask mask) WFC_APIEXIT;

/* Element */
WFC_API_CALL WFCElement WFC_APIENTRY
    wfcCreateElement(WFCDevice dev, WFCContext ctx,
        const WFCint *attribList) WFC_APIEXIT;
WFC_API_CALL WFCint WFC_APIENTRY
    wfcGetElementAttribi(WFCDevice dev, WFCElement element,
        WFCElementAttrib attrib) WFC_APIEXIT;
WFC_API_CALL WFCfloat WFC_APIENTRY
    wfcGetElementAttribf(WFCDevice dev, WFCElement element,
        WFCElementAttrib attrib) WFC_APIEXIT;
WFC_API_CALL void WFC_APIENTRY
    wfcGetElementAttribiv(WFCDevice dev, WFCElement element,
        WFCElementAttrib attrib, WFCint count, WFCint *values) WFC_APIEXIT;
WFC_API_CALL void WFC_APIENTRY
    wfcGetElementAttribfv(WFCDevice dev, WFCElement element,
        WFCElementAttrib attrib, WFCint count, WFCfloat *values) WFC_APIEXIT;
WFC_API_CALL void WFC_APIENTRY
    wfcSetElementAttribi(WFCDevice dev, WFCElement element,
        WFCElementAttrib attrib, WFCint value) WFC_APIEXIT;
WFC_API_CALL void WFC_APIENTRY
    wfcSetElementAttribf(WFCDevice dev, WFCElement element,
        WFCElementAttrib attrib, WFCfloat value) WFC_APIEXIT;
WFC_API_CALL void WFC_APIENTRY
    wfcSetElementAttribiv(WFCDevice dev, WFCElement element,
        WFCElementAttrib attrib,
        WFCint count, const WFCint *values) WFC_APIEXIT;
WFC_API_CALL void WFC_APIENTRY
    wfcSetElementAttribfv(WFCDevice dev, WFCElement element,
        WFCElementAttrib attrib,
        WFCint count, const WFCfloat *values) WFC_APIEXIT;
WFC_API_CALL void WFC_APIENTRY
    wfcInsertElement(WFCDevice dev, WFCElement element,
        WFCElement subordinate) WFC_APIEXIT;
WFC_API_CALL void WFC_APIENTRY
    wfcRemoveElement(WFCDevice dev, WFCElement element) WFC_APIEXIT;
WFC_API_CALL WFCElement WFC_APIENTRY
    wfcGetElementAbove(WFCDevice dev, WFCElement element) WFC_APIEXIT;
WFC_API_CALL WFCElement WFC_APIENTRY
    wfcGetElementBelow(WFCDevice dev, WFCElement element) WFC_APIEXIT;
WFC_API_CALL void WFC_APIENTRY
    wfcDestroyElement(WFCDevice dev, WFCElement element) WFC_APIEXIT;

/* Rendering */
WFC_API_CALL void WFC_APIENTRY
    wfcActivate(WFCDevice dev, WFCContext ctx) WFC_APIEXIT;
WFC_API_CALL void WFC_APIENTRY
    wfcDeactivate(WFCDevice dev, WFCContext ctx) WFC_APIEXIT;
WFC_API_CALL void WFC_APIENTRY
    wfcCompose(WFCDevice dev, WFCContext ctx, WFCboolean wait) WFC_APIEXIT;
WFC_API_CALL void WFC_APIENTRY
    wfcFence(WFCDevice dev, WFCContext ctx, WFCEGLDisplay dpy,
        WFCEGLSync sync) WFC_APIEXIT;

/* Renderer and extension information */
WFC_API_CALL WFCint WFC_APIENTRY
    wfcGetStrings(WFCDevice dev,
        WFCStringID name,
        const char **strings,
        WFCint stringsCount) WFC_APIEXIT;
WFC_API_CALL WFCboolean WFC_APIENTRY
    wfcIsExtensionSupported(WFCDevice dev, const char *string) WFC_APIEXIT;

#ifdef __cplusplus
}
#endif

#endif /* _WFC_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /*********************************************************************
 *                                                                   *
 * Sample implementation of wfcplatform.h, version 1.0, draft 19     *
 *                                                                   *
 * Copyright (c) 2007-2009 The Khronos Group                           *
 *                                                                   *
 *********************************************************************/

#ifndef _WFCPLATFORM_H_
#define _WFCPLATFORM_H_

#include "../KHR/khrplatform.h"
#include "../EGL/egl.h"

#ifdef __cplusplus
extern "C" {
#endif

#ifndef WFC_API_CALL
#define WFC_API_CALL KHRONOS_APICALL
#endif
#ifndef WFC_APIENTRY
#define WFC_APIENTRY KHRONOS_APIENTRY
#endif
#ifndef WFC_APIEXIT
#define WFC_APIEXIT KHRONOS_APIATTRIBUTES
#endif

#ifndef WFC_DEFAULT_SCREEN_NUMBER
#define WFC_DEFAULT_SCREEN_NUMBER (0)
#endif

typedef enum {
    WFC_FALSE               = 0,
    WFC_TRUE                = 1,
    WFC_BOOLEAN_FORCE_32BIT = 0x7FFFFFFF
} WFCboolean;

typedef khronos_int32_t   WFCint;
typedef khronos_float_t   WFCfloat;
typedef khronos_uint32_t  WFCbitfield;
typedef khronos_uint32_t  WFCHandle;

typedef EGLDisplay   WFCEGLDisplay;
typedef void         *WFCEGLSync;   /* An opaque handle to an EGLSyncKHR */
typedef WFCHandle    WFCNativeStreamType;

#ifdef __cplusplus
}
#endif

#endif /* _WFCPLATFORM_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/** \file
 * Multi-Media Abstraction Layer API
 */

#ifndef MMAL_H
#define MMAL_H

/**
  *
  * \mainpage Multi-Media Abstraction Layer (MMAL). Draft Version 0.1.
  *
  * \par Contents
  * - \ref intro_sec
  * - \ref features
  * - \ref concepts
  * - \ref comp
  * - \ref create
  * - \ref port
  * - \ref buf
  * - \ref queue
  * - \ref pool
  * - \ref param
  * - \ref events
  * - \ref version
  * - \ref example
  *
  * \section intro_sec Introduction
  *
  * MMAL (Multi-Media Abstraction Layer) is a framework which is used to provide a host-side,
  * simple and relatively low-level interface to multimedia components running on VideoCore.
  * It also provides a component interface so that new components can be easily created and
  * integrated into the framework.
  *
  * There is no requirement that all the components be running on VideoCore as MMAL doesn't
  * put any restriction on where components live. The current implementation for instance
  * provides some components which can be run on both host-side or VideoCore (e.g. the splitter
  * component).
  *
  * \section features Features
  *
  * The MMAL API has been designed to support all the following features:
  * - Sufficiently generic to support different kinds of multimedia component.
  * - Simple to use from client side (mostly synchronous except where it matters).
  * - Straightforward API for designing components (e.g. avoids multiple data paths, as found in RIL).
  * - Allows for fully-optimised implementation of components (e.g. zero-copy buffer passing).
  * - Portability (API is self-contained).
  * - Supports multiple instances (e.g. of VideoCore).
  * - Extensible without breaking source or binary backward compatibility.
  *
  * \section concepts API concepts
  *
  * The MMAL API is based on the concept of components, ports and buffer headers.
  * Clients create MMAL components which expose ports for each individual
  * elementary stream of data they support (e.g. audio/video). Components expose
  * input ports to receive data from the client, and expose output ports
  * to return data to the client.
  *
  * Data sent to or received from the component needs to be attached to a buffer header.
  * Buffer headers are necessary because they contain buffer specific ancillary data which is
  * necessary for the component and client to do their processing (e.g timestamps).
  *
  * \section comp Components
  *
  * MMAL lets clients create multi-media components (video encoders,
  * video decoders, camera, and so-on) using a common API. Clients exchange
  * data with components using buffer headers. A buffer header
  * has a pointer to the payload data.
  * Buffer headers are sent to and received from ports that are provided by components.
  *
  * A typical decoder component would have a single input port and a
  * single output port, but the same architecture could also be used
  * for components with different layouts (e.g. a camera with a
  * capture and preview port, or a debugging component with just an input port).
  *
  * \subsection create Component Creation
  *
  * Each component is identified by a unique name. To create a specific component
  * the client needs to call \ref mmal_component_create with the desired component's
  * name as an argument.
  * This call will return a context (\ref MMAL_COMPONENT_T) to the component. This
  * context will expose the input and output ports (\ref MMAL_PORT_T) supported
  * by this specific component.
  *
  * \note All VideoCore components have a name starting with the "vc." prefix (this prefix
  * is used to distinguish when a creation request needs to be forwarded to VideoCore).
  *
  * \section port Component Ports
  *
  * A port (\ref MMAL_PORT_T) is the entity which exposes an elementary stream
  * (\ref MMAL_ES_FORMAT_T) on a component. It is also the entity to which buffer headers
  * (\ref MMAL_BUFFER_HEADER_T) are sent or from which they are received.
  *
  * Clients do not need to create ports. They are created automatically by
  * the component when this one is created but the format of a port might need to
  * be set by the client depending on the type of component the client is using.
  *
  * For example, for a video decoding component, one input port and one output port
  * will be available. The format of the input port must be set by the
  * client (using \ref mmal_port_format_commit) while the format of the output port
  * will be automatically set by the component once the component has enough information
  * to find out what its format should be.
  *
  * If the input port format contains enough information for the component to determine
  * the format of the output port straight away, then the output port will be set to the proper
  * format when \ref mmal_port_format_commit returns. Otherwise the output format will be set to
  * \ref MMAL_ENCODING_UNKNOWN until the component is fed enough data to determine the format
  * of the output port.
  * When this happens, the client will receive an event on the output port, signalling
  * that its format has changed.
  *
  * \section buf Buffer Headers
  *
  * Buffer headers (\ref MMAL_BUFFER_HEADER_T) are used to exchange data with components.
  * They do not contain the data directly but instead contain a pointer to the data being
  * transferred.
  *
  * Separating the buffer headers from the payload means that the memory for the data can
  * be allocated outside of MMAL (e.g. if it is supplied by an external library) while still
  * providing a consistent way to exchange data between clients and components.
  *
  * Buffer headers are allocated from pools and are reference counted. The refcount
  * will drop when \ref mmal_buffer_header_release is called and the buffer header
  * will be recycled to its pool when it reaches zero.
  * The client can be notified when the buffer header is recycled so that it can recycle the
  * associated payload memory as well.
  *
  * A pool of buffer headers should be created after committing the format of the port. When
  * the format is changed, the minimum and recommended size and number of buffers may change.
  *
  * \note The current number of buffers and their size (\ref MMAL_PORT_T::buffer_num and \ref
  * MMAL_PORT_T::buffer_size) are not modified by MMAL, and must be updated by the client as
  * required after changes to a port's format.
  *
  * \subsection queue Queues of Buffer Headers
  *
  * Queues (\ref MMAL_QUEUE_T) are a facility that allows thread-safe processing of buffer headers
  * from the client. Callbacks triggered by a MMAL component when it sends a buffer header to the
  * client can simply put the buffer in a queue and let the main processing thread of the client
  * get its data from the queue.
  *
  * \subsection pool Pools of Buffer Headers
  *
  * Pools (\ref MMAL_POOL_T) let clients allocate a fixed number of buffer headers, and 
  * a queue (\ref MMAL_QUEUE_T). They are used for buffer header allocation.
  * Optionally a pool can also allocate the payload memory for the client.
  *
  * Pools can also be resized after creation, for example, if the port format is changed leading
  * to a new number or size of buffers being required.
  *
  * \section param Port Parameters
  *
  * Components support setting and getting component specific parameters using
  * \ref mmal_port_parameter_set and \ref mmal_port_parameter_get. Parameters
  * are identified using an integer index; parameter data is binary. See the \ref MMAL_PARAMETER_IDS
  * "Pre-defined MMAL parameter IDs" page for more information on the pre-defined parameters.
  *
  * \section events Port Events
  *
  * Components can generate events on their ports. Events are sent to clients
  * as buffer headers and thus when the client receives a buffer header on one
  * of the component's port it should check if the buffer header is an event
  * and in which case process it and then release it (\ref mmal_buffer_header_release).
  * The reason for transmitting events in-band with the actual data is that it
  * is often very valuable to know exactly when the event happens relative to the
  * the actual data (e.g. with a focus event, from which video frame are we in focus).\n
  * Buffer headers used to transmit events are allocated internally by the framework
  * so it is important to release the buffer headers with \ref mmal_buffer_header_release
  * so the buffer headers make it back to their actual owner.
  *
  * Event buffer headers are allocated when the component is created, based on the
  * minimum number and size of control port buffers set by the component. Component
  * wide events (not port specific) are sent to the control port callback when that
  * port is enabled. Port events are sent to the port callback, the same as data
  * buffers, but the 'cmd' field is non-zero.
  *
  * \section version Versioning
  *
  * The API requires that the MMAL core be the same or more recent version
  * as the components and clients. Clients and components can be older and
  * the API will still work both at compile-time and run-time.
  *
  * \section example Example Code
  *
  * The following code is a simple example on how to do video decoding using MMAL. Note that
  * the code is intended to be clear and illustrate how to use MMAL at its most fundamental
  * level, not necessarily the most efficient way to achieve the same result. Use of opaque
  * images, tunneling and zero-copy inter-processor buffers can all improve the performance
  * or reduce the load.
  *
  * The \ref MmalConnectionUtility "Port Connection Utility" functions can also be used to
  * replace much of the common "boilerplate" code, especially when a pipeline of several
  * components needs to be processed.
  *
  * \code
  * #include <mmal.h>
  * ...
  * static void input_callback(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
  * {
  *    // The decoder is done with the data, just recycle the buffer header into its pool
  *    mmal_buffer_header_release(buffer);
  * }
  * static void output_callback(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
  * {
  *    MMAL_QUEUE_T *queue = (MMAL_QUEUE_T *)port->userdata;
  *    mmal_queue_put(queue, buffer); // Queue the decoded video frame
  * }
  * ...
  *
  * MMAL_COMPONENT_T *decoder = 0;
  * MMAL_STATUS_T status;
  *
  * // Create the video decoder component on VideoCore
  * status = mmal_component_create("vc.ril.video_decoder", &decoder);
  * ABORT_IF_ERROR(status);
  *
  * // Set format of video decoder input port
  * MMAL_ES_FORMAT_T *format_in = decoder->input[0]->format;
  * format_in->type = MMAL_ES_TYPE_VIDEO;
  * format_in->encoding = MMAL_ENCODING_H264;
  * format_in->es->video.width = 1280;
  * format_in->es->video.height = 720;
  * format_in->es->video.frame_rate.num = 30;
  * format_in->es->video.frame_rate.den = 1;
  * format_in->es->video.par.num = 1;
  * format_in->es->video.par.den = 1;
  * format_in->flags = MMAL_ES_FORMAT_FLAG_FRAMED;
  * status = mmal_format_extradata_alloc(format_in, YOUR_H264_CODEC_HEADER_BYTES_SIZE);
  * ABORT_IF_ERROR(status);
  * format_in->extradata_size = YOUR_H264_CODEC_HEADER_BYTES_SIZE;
  * memcpy(format_in->extradata, YOUR_H264_CODEC_HEADER_BYTES, format_in->extradata_size);
  *
  * status = mmal_port_format_commit(decoder->input[0]);
  * ABORT_IF_ERROR(status);
  *
  * // Once the call to mmal_port_format_commit() on the input port returns, the decoder will
  * // have set the format of the output port.
  * // If the decoder still doesn t have enough information to determine the format of the
  * // output port, the encoding will be set to unknown. As soon as the decoder receives
  * // enough stream data to determine the format of the output port it will send an event
  * // to the client to signal that the format of the port has changed.
  * // However, for the sake of simplicity this example assumes that the decoder was given
  * // all the necessary information right at the start (i.e. video format and codec header bytes)
  * MMAL_FORMAT_T *format_out = decoder->output[0]->format;
  * if (format_out->encoding == MMAL_ENCODING_UNKNOWN)
  *    ABORT();
  *
  * // Now we know the format of both ports and the requirements of the decoder, we can create
  * // our buffer headers and their associated memory buffers. We use the buffer pool API for this.
  * decoder->input[0]->buffer_num = decoder->input[0]->buffer_num_min;
  * decoder->input[0]->buffer_size = decoder->input[0]->buffer_size_min;
  * MMAL_POOL_T *pool_in = mmal_pool_create(decoder->input[0]->buffer_num,
  *                                         decoder->input[0]->buffer_size);
  * decoder->output[0]->buffer_num = decoder->output[0]->buffer_num_min;
  * decoder->output[0]->buffer_size = decoder->output[0]->buffer_size_min;
  * MMAL_POOL_T *pool_out = mmal_pool_create(decoder->output[0]->buffer_num,
  *                                          decoder->output[0]->buffer_size);
  *
  * // Create a queue to store our decoded video frames. The callback we will get when
  * // a frame has been decoded will put the frame into this queue.
  * MMAL_QUEUE_T *queue_decoded_frames = mmal_queue_create();
  * decoder->output[0]->userdata = (void)queue_decoded_frames;
  *
  * // Enable all the input port and the output port.
  * // The callback specified here is the function which will be called when the buffer header
  * // we sent to the component has been processed.
  * status = mmal_port_enable(decoder->input[0], input_callback);
  * ABORT_IF_ERROR(status);
  * status = mmal_port_enable(decoder->output[0], output_callback);
  * ABORT_IF_ERROR(status);
  *
  * // Enable the component. Components will only process data when they are enabled.
  * status = mmal_component_enable(decoder);
  * ABORT_IF_ERROR(status);
  *
  * // Data processing loop
  * while (1)
  * {
  *    MMAL_BUFFER_HEADER_T *buffer;
  *
  *    // The client needs to implement its own blocking code.
  *    // (e.g. a semaphore which is posted when a buffer header is put in one of the queues)
  *    WAIT_FOR_QUEUES_TO_HAVE_BUFFERS();
  *
  *    // Send empty buffers to the output port of the decoder to allow the decoder to start
  *    // producing frames as soon as it gets input data
  *    while ((buffer = mmal_queue_get(pool_out->queue)) != NULL)
  *    {
  *       status = mmal_port_send_buffer(decoder->output[0], buffer);
  *       ABORT_IF_ERROR(status);
  *    }
  *
  *    // Send data to decode to the input port of the video decoder
  *    if ((buffer = mmal_queue_get(pool_in->queue)) != NULL)
  *    {
  *       READ_DATA_INTO_BUFFER(buffer);
  *
  *       status = mmal_port_send_buffer(decoder->input[0], buffer);
  *       ABORT_IF_ERROR(status);
  *    }
  *
  *    // Get our decoded frames. We also need to cope with events
  *    // generated from the component here.
  *    while ((buffer = mmal_queue_get(queue_decoded_frames)) != NULL)
  *    {
  *       if (buffer->cmd)
  *       {
  *          // This is an event. Do something with it and release the buffer.
  *          mmal_buffer_header_release(buffer);
  *          continue;
  *       }
  *
  *       // We have a frame, do something with it (why not display it for instance?).
  *       // Once we're done with it, we release it. It will magically go back
  *       // to its original pool so it can be reused for a new video frame.
  *       mmal_buffer_header_release(buffer);
  *    }
  * }
  *
  * // Cleanup everything
  * mmal_component_destroy(decoder);
  * mmal_pool_destroy(pool_in);
  * mmal_pool_destroy(pool_out);
  * mmal_queue_destroy(queue_decode_frames);
  *
  * \endcode
  */

#include "mmal_common.h"
#include "mmal_types.h"
#include "mmal_port.h"
#include "mmal_component.h"
#include "mmal_parameters.h"
#include "mmal_queue.h"
#include "mmal_pool.h"
#include "mmal_events.h"

/**/
/** \name API Version
 * The following define the version number of the API */
/* @{ */
/** Major version number.
 * This changes when the API breaks in a way which is not backward compatible. */
#define MMAL_VERSION_MAJOR 0
/** Minor version number.
 * This changes each time the API is extended in a way which is still source and
 * binary compatible. */
#define MMAL_VERSION_MINOR 1

#define MMAL_VERSION (MMAL_VERSION_MAJOR << 16 | MMAL_VERSION_MINOR)
#define MMAL_VERSION_TO_MAJOR(a) (a >> 16)
#define MMAL_VERSION_TO_MINOR(a) (a & 0xFFFF)
/* @} */

#endif /* MMAL_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/** \file mmal_common.h
 * Multi-Media Abstraction Layer - Common definitions
 */

#ifndef MMAL_COMMON_H
#define MMAL_COMMON_H

#include <stdlib.h>
#include <string.h>
#include <stddef.h>
#include <assert.h>

#include <interface/vcos/vcos.h>

/* C99 64bits integers */
#ifndef INT64_C
# define INT64_C(value) value##LL
# define UINT64_C(value) value##ULL
#endif

#define MMAL_TSRING(s) #s
#define MMAL_TO_STRING(s) MMAL_TSRING(s)

#define MMAL_COUNTOF(x) (sizeof((x))/sizeof((x)[0]))
#define MMAL_MIN(a,b) ((a)<(b)?(a):(b))
#define MMAL_MAX(a,b) ((a)<(b)?(b):(a))

/* FIXME: should be different for big endian */
#define MMAL_FOURCC(a,b,c,d) ((a) | (b << 8) | (c << 16) | (d << 24))
#define MMAL_PARAM_UNUSED(a) (void)(a)
#define MMAL_MAGIC MMAL_FOURCC('m','m','a','l')

typedef int32_t MMAL_BOOL_T;
#define MMAL_FALSE   0
#define MMAL_TRUE    1

typedef struct MMAL_CORE_STATISTICS_T
{
   uint32_t buffer_count;        /**< Total buffer count on this port */
   uint32_t first_buffer_time;   /**< Time (us) of first buffer seen on this port */
   uint32_t last_buffer_time;    /**< Time (us) of most recently buffer on this port */
   uint32_t max_delay;           /**< Max delay (us) between buffers, ignoring first few frames */
} MMAL_CORE_STATISTICS_T;

/** Statistics collected by the core on all ports, if enabled in the build.
 */
typedef struct MMAL_CORE_PORT_STATISTICS_T
{
   MMAL_CORE_STATISTICS_T rx;
   MMAL_CORE_STATISTICS_T tx;
} MMAL_CORE_PORT_STATISTICS_T;

/** Unsigned 16.16 fixed point value, also known as Q16.16 */
typedef uint32_t MMAL_FIXED_16_16_T;

#endif /* MMAL_COMMON_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#ifndef MMAL_CLOCK_H
#define MMAL_CLOCK_H

#include "interface/vcos/vcos.h"
#include "mmal_types.h"
#include "mmal_common.h"

/** \defgroup MmalClock Clock Framework
 * The MMAL clock framework provides scheduling facilities to the rest of
 * MMAL.
 *
 * The framework consists mainly of clock ports and a clock module. Client
 * applications and components interact directly with clock ports, while
 * the clock module is only used internally by clock ports.
 *
 * Clock ports ensure that the local media-time for each component is
 * synchronised across all components. This is done by passing buffers between
 * clock ports which contain clock-specific data.
 *
 * One clock port will normally act as the reference clock for the rest of the
 * system. This is usually chosen to be the clock port of the audio render
 * component, but is configurable by the client and could potentially be any
 * other clock port (or even the client application itself).
 *
 * Components that are responsible for timed delivery of frames, do so by
 * registering callback requests for a particular time-stamp with the clock
 * port. These requests are scheduled using the clock module which maintains
 * an internal media-time.
 *
 * The clock framework also provides the ability to perform playback at different
 * speeds. This is achieved with a clock scale factor which determines the speed
 * at which the media-time advances relative to real-time, with:
 *   scale = 1.0 -> normal playback speed
 *   scale = 0   -> playback paused
 *   scale > 1.0 -> fast-forward
 *   scale < 1.0 -> slow motion
 */

/** Clock event magic */
#define MMAL_CLOCK_EVENT_MAGIC               MMAL_FOURCC('C','K','L','M')

/** Clock reference update */
#define MMAL_CLOCK_EVENT_REFERENCE           MMAL_FOURCC('C','R','E','F')

/** Clock state update */
#define MMAL_CLOCK_EVENT_ACTIVE              MMAL_FOURCC('C','A','C','T')

/** Clock scale update */
#define MMAL_CLOCK_EVENT_SCALE               MMAL_FOURCC('C','S','C','A')

/** Clock media-time update */
#define MMAL_CLOCK_EVENT_TIME                MMAL_FOURCC('C','T','I','M')

/** Clock update threshold */
#define MMAL_CLOCK_EVENT_UPDATE_THRESHOLD    MMAL_FOURCC('C','U','T','H')

/** Clock discontinuity threshold */
#define MMAL_CLOCK_EVENT_DISCONT_THRESHOLD   MMAL_FOURCC('C','D','T','H')

/** Clock request threshold */
#define MMAL_CLOCK_EVENT_REQUEST_THRESHOLD   MMAL_FOURCC('C','R','T','H')

/** Buffer statistics */
#define MMAL_CLOCK_EVENT_INPUT_BUFFER_INFO   MMAL_FOURCC('C','I','B','I')
#define MMAL_CLOCK_EVENT_OUTPUT_BUFFER_INFO  MMAL_FOURCC('C','O','B','I')

/** Clock latency setting */
#define MMAL_CLOCK_EVENT_LATENCY             MMAL_FOURCC('C','L','A','T')

/** Clock event not valid */
#define MMAL_CLOCK_EVENT_INVALID   0


/** Thresholds used when updating a clock's media-time */
typedef struct MMAL_CLOCK_UPDATE_THRESHOLD_T
{
   /** Time differences below this threshold are ignored (microseconds) */
   int64_t threshold_lower;

   /** Time differences above this threshold reset media-time (microseconds) */
   int64_t threshold_upper;
} MMAL_CLOCK_UPDATE_THRESHOLD_T;

/** Threshold for detecting a discontinuity in media-time */
typedef struct MMAL_CLOCK_DISCONT_THRESHOLD_T
{
   /** Threshold after which backward jumps in media-time are treated as a
    * discontinuity (microseconds) */
   int64_t threshold;

   /** Duration in microseconds for which a discontinuity applies (wall-time) */
   int64_t duration;
} MMAL_CLOCK_DISCONT_THRESHOLD_T;

/** Threshold applied to client callback requests */
typedef struct MMAL_CLOCK_REQUEST_THRESHOLD_T
{
   /** Frames with a media-time difference (compared to current media-time)
    * above this threshold are dropped (microseconds) */
   int64_t threshold;

   /** Enable/disable the request threshold */
   MMAL_BOOL_T threshold_enable;
} MMAL_CLOCK_REQUEST_THRESHOLD_T;

/** Structure for passing buffer information to a clock port */
typedef struct MMAL_CLOCK_BUFFER_INFO_T
{
   int64_t time_stamp;
   uint32_t arrival_time;
} MMAL_CLOCK_BUFFER_INFO_T;

/** Clock latency settings used by the clock component */
typedef struct MMAL_CLOCK_LATENCY_T
{
   int64_t target;            /**< target latency (microseconds) */
   int64_t attack_period;     /**< duration of one attack period (microseconds) */
   int64_t attack_rate;       /**< amount by which media-time will be adjusted
                                   every attack_period (microseconds) */
} MMAL_CLOCK_LATENCY_T;

/** Clock event used to pass data between clock ports and a client. */
typedef struct MMAL_CLOCK_EVENT_T
{
   /** 4cc event id */
   uint32_t id;

   /** 4cc event magic */
   uint32_t magic;

   /** buffer associated with this event (can be NULL) */
   struct MMAL_BUFFER_HEADER_T *buffer;

   /** pad to 64-bit boundary */
   uint32_t padding0;

   /** additional event data (type-specific) */
   union
   {
      /** used either for clock reference or clock state */
      MMAL_BOOL_T enable;

      /** new clock scale */
      MMAL_RATIONAL_T scale;

      /** new media-time */
      int64_t media_time;

      /** media-time update threshold */
      MMAL_CLOCK_UPDATE_THRESHOLD_T update_threshold;

      /** media-time discontinuity threshold */
      MMAL_CLOCK_DISCONT_THRESHOLD_T discont_threshold;

      /** client callback request threshold */
      MMAL_CLOCK_REQUEST_THRESHOLD_T request_threshold;

      /** input/output buffer information */
      MMAL_CLOCK_BUFFER_INFO_T buffer;

      /** clock latency setting */
      MMAL_CLOCK_LATENCY_T latency;
   } data;

   /** pad to 64-bit boundary */
   uint64_t padding1;
} MMAL_CLOCK_EVENT_T;

/* Make sure MMAL_CLOCK_EVENT_T will preserve 64-bit alignment */
vcos_static_assert(!(sizeof(MMAL_CLOCK_EVENT_T) & 0x7));

#define MMAL_CLOCK_EVENT_INIT(id) { id, MMAL_CLOCK_EVENT_MAGIC, NULL, 0, {0}, 0 }

#endif /* MMAL_CLOCK_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_BUFFER_H
#define MMAL_BUFFER_H

#ifdef __cplusplus
extern "C" {
#endif

/** \defgroup MmalBufferHeader Buffer headers
 * Definition of a buffer header and its associated API.
 * Buffer headers are the basic element used to pass data and information between different
 * parts of the system. They are passed to components via ports and sent back to the client
 * using a callback mechanism.
 */
/* @{ */

/** Specific data associated with video frames */
typedef struct {
   uint32_t planes;     /**< Number of planes composing the video frame */
   uint32_t offset[4];  /**< Offsets to the different planes. These must point within the
                             payload buffer */
   uint32_t pitch[4];   /**< Pitch (size in bytes of a line of a plane) of the different
                             planes */
   uint32_t flags;      /**< Flags describing video specific properties of a buffer header
                             (see \ref videobufferheaderflags "Video buffer header flags") */
   /* TBD stereoscopic support */
} MMAL_BUFFER_HEADER_VIDEO_SPECIFIC_T;

/** Type specific data that's associated with a payload buffer */
typedef union
{
   /** Specific data associated with video frames */
   MMAL_BUFFER_HEADER_VIDEO_SPECIFIC_T video;

} MMAL_BUFFER_HEADER_TYPE_SPECIFIC_T;

/** Definition of the buffer header structure.
 * A buffer header does not directly carry the data to be passed to a component but instead
 * it references the actual data using a pointer (and an associated length).
 * It also contains an internal area which can be used to store command to be associated
 * with the external data.
 */
typedef struct MMAL_BUFFER_HEADER_T
{
   struct MMAL_BUFFER_HEADER_T *next; /**< Used to link several buffer headers together */

   struct MMAL_BUFFER_HEADER_PRIVATE_T *priv; /**< Data private to the framework */

   uint32_t cmd;              /**< Defines what the buffer header contains. This is a FourCC
                                   with 0 as a special value meaning stream data */

   uint8_t  *data;            /**< Pointer to the start of the payload buffer (should not be
                                   changed by component) */
   uint32_t alloc_size;       /**< Allocated size in bytes of payload buffer */
   uint32_t length;           /**< Number of bytes currently used in the payload buffer (starting
                                   from offset) */
   uint32_t offset;           /**< Offset in bytes to the start of valid data in the payload buffer */

   uint32_t flags;            /**< Flags describing properties of a buffer header (see
                                   \ref bufferheaderflags "Buffer header flags") */

   int64_t  pts;              /**< Presentation timestamp in microseconds. \ref MMAL_TIME_UNKNOWN
                                   is used when the pts is unknown. */
   int64_t  dts;              /**< Decode timestamp in microseconds (dts = pts, except in the case
                                   of video streams with B frames). \ref MMAL_TIME_UNKNOWN
                                   is used when the dts is unknown. */

   /** Type specific data that's associated with a payload buffer */
   MMAL_BUFFER_HEADER_TYPE_SPECIFIC_T *type;

   void *user_data;           /**< Field reserved for use by the client */

} MMAL_BUFFER_HEADER_T;

/** \name Buffer header flags
 * \anchor bufferheaderflags
 * The following flags describe properties of a buffer header */
/* @{ */
/** Signals that the current payload is the end of the stream of data */
#define MMAL_BUFFER_HEADER_FLAG_EOS                    (1<<0)
/** Signals that the start of the current payload starts a frame */
#define MMAL_BUFFER_HEADER_FLAG_FRAME_START            (1<<1)
/** Signals that the end of the current payload ends a frame */
#define MMAL_BUFFER_HEADER_FLAG_FRAME_END              (1<<2)
/** Signals that the current payload contains only complete frames (1 or more) */
#define MMAL_BUFFER_HEADER_FLAG_FRAME                  (MMAL_BUFFER_HEADER_FLAG_FRAME_START|MMAL_BUFFER_HEADER_FLAG_FRAME_END)
/** Signals that the current payload is a keyframe (i.e. self decodable) */
#define MMAL_BUFFER_HEADER_FLAG_KEYFRAME               (1<<3)
/** Signals a discontinuity in the stream of data (e.g. after a seek).
 * Can be used for instance by a decoder to reset its state */
#define MMAL_BUFFER_HEADER_FLAG_DISCONTINUITY          (1<<4)
/** Signals a buffer containing some kind of config data for the component
 * (e.g. codec config data) */
#define MMAL_BUFFER_HEADER_FLAG_CONFIG                 (1<<5)
/** Signals an encrypted payload */
#define MMAL_BUFFER_HEADER_FLAG_ENCRYPTED              (1<<6)
/** Signals a buffer containing side information */
#define MMAL_BUFFER_HEADER_FLAG_CODECSIDEINFO          (1<<7)
/** Signals a buffer which is the snapshot/postview image from a stills capture */
#define MMAL_BUFFER_HEADER_FLAGS_SNAPSHOT              (1<<8)
/** Signals a buffer which contains data known to be corrupted */
#define MMAL_BUFFER_HEADER_FLAG_CORRUPTED              (1<<9)
/** Signals that a buffer failed to be transmitted */
#define MMAL_BUFFER_HEADER_FLAG_TRANSMISSION_FAILED    (1<<10)
/** Signals the output buffer won't be used, just update reference frames */
#define MMAL_BUFFER_HEADER_FLAG_DECODEONLY             (1<<11)
/** Signals that the end of the current payload ends a NAL */
#define MMAL_BUFFER_HEADER_FLAG_NAL_END                (1<<12)
/** User flags - can be passed in and will get returned */
#define MMAL_BUFFER_HEADER_FLAG_USER0                  (1<<28)
#define MMAL_BUFFER_HEADER_FLAG_USER1                  (1<<29)
#define MMAL_BUFFER_HEADER_FLAG_USER2                  (1<<30)
#define MMAL_BUFFER_HEADER_FLAG_USER3                  (1<<31)
/* @} */

/** \name Video buffer header flags
 * \anchor videobufferheaderflags
 * The following flags describe properties of a video buffer header.
 * As there is no collision with the MMAL_BUFFER_HEADER_FLAGS_ defines, these
 * flags will also be present in the MMAL_BUFFER_HEADER_T flags field.
 */
#define MMAL_BUFFER_HEADER_FLAG_FORMAT_SPECIFIC_START_BIT 16
#define MMAL_BUFFER_HEADER_FLAG_FORMAT_SPECIFIC_START (1<<MMAL_BUFFER_HEADER_FLAG_FORMAT_SPECIFIC_START_BIT)
/* @{ */
/** 16: Signals an interlaced video frame */
#define MMAL_BUFFER_HEADER_VIDEO_FLAG_INTERLACED       (MMAL_BUFFER_HEADER_FLAG_FORMAT_SPECIFIC_START<<0)
/** 17: Signals that the top field of the current interlaced frame should be displayed first */
#define MMAL_BUFFER_HEADER_VIDEO_FLAG_TOP_FIELD_FIRST  (MMAL_BUFFER_HEADER_FLAG_FORMAT_SPECIFIC_START<<1)
/** 19: Signals that the buffer should be displayed on external display if attached. */
#define MMAL_BUFFER_HEADER_VIDEO_FLAG_DISPLAY_EXTERNAL (MMAL_BUFFER_HEADER_FLAG_FORMAT_SPECIFIC_START<<3)
/** 20: Signals that contents of the buffer requires copy protection. */
#define MMAL_BUFFER_HEADER_VIDEO_FLAG_PROTECTED        (MMAL_BUFFER_HEADER_FLAG_FORMAT_SPECIFIC_START<<4)
/** 27-24: If non-zero it signals the video frame is encoded in column mode,
 * with a column width equal to 2^<masked value>.
 * Zero is raster order. */
#define MMAL_BUFFER_HEADER_VIDEO_FLAG_COLUMN_LOG2_SHIFT (MMAL_BUFFER_HEADER_FLAG_FORMAT_SPECIFIC_START_BIT+8)
#define MMAL_BUFFER_HEADER_VIDEO_FLAG_COLUMN_LOG2_MASK (0xF<<MMAL_BUFFER_HEADER_VIDEO_FLAG_COLUMN_LOG2_SHIFT)
/* @} */

/** Acquire a buffer header.
 * Acquiring a buffer header increases a reference counter on it and makes sure that the
 * buffer header won't be recycled until all the references to it are gone.
 * This is useful for instance if a component needs to return a buffer header but still needs
 * access to it for some internal processing (e.g. reference frames in video codecs).
 *
 * @param header buffer header to acquire
 */
void mmal_buffer_header_acquire(MMAL_BUFFER_HEADER_T *header);

/** Reset a buffer header.
 * Resets all header variables to default values.
 *
 * @param header buffer header to reset
 */
void mmal_buffer_header_reset(MMAL_BUFFER_HEADER_T *header);

/** Release a buffer header.
 * Releasing a buffer header will decrease its reference counter and when no more references
 * are left, the buffer header will be recycled by calling its 'release' callback function.
 *
 * If a pre-release callback is set (\ref MMAL_BH_PRE_RELEASE_CB_T), this will be invoked
 * before calling the buffer's release callback and potentially postpone buffer recycling.
 * Once pre-release is complete the buffer header is recycled with
 * \ref mmal_buffer_header_release_continue.
 *
 * @param header buffer header to release
 */
void mmal_buffer_header_release(MMAL_BUFFER_HEADER_T *header);

/** Continue the buffer header release process.
 * This should be called to complete buffer header recycling once all pre-release activity
 * has been completed.
 *
 * @param header buffer header to release
 */
void mmal_buffer_header_release_continue(MMAL_BUFFER_HEADER_T *header);

/** Buffer header pre-release callback.
 * The callback is invoked just before a buffer is released back into a
 * pool. This is used by clients who need to trigger additional actions
 * before the buffer can finally be released (e.g. wait for a bulk transfer
 * to complete).
 *
 * The callback should return TRUE if the buffer release need to be post-poned.
 *
 * @param header   buffer header about to be released
 * @param userdata user-specific data
 *
 * @return TRUE if the buffer should not be released
 */
typedef MMAL_BOOL_T (*MMAL_BH_PRE_RELEASE_CB_T)(MMAL_BUFFER_HEADER_T *header, void *userdata);

/** Set a buffer header pre-release callback.
 * If the callback is NULL, the buffer will be released back into the pool
 * immediately as usual.
 *
 * @param header   buffer header to associate callback with
 * @param cb       pre-release callback to invoke
 * @param userdata user-specific data
 */
void mmal_buffer_header_pre_release_cb_set(MMAL_BUFFER_HEADER_T *header, MMAL_BH_PRE_RELEASE_CB_T cb, void *userdata);

/** Replicate a buffer header into another one.
 * Replicating a buffer header will not only do an exact copy of all the public fields of the
 * buffer header (including data and alloc_size), but it will also acquire a reference to the
 * source buffer header which will only be released once the replicate has been released.
 *
 * @param dest buffer header into which to replicate
 * @param src buffer header to use as the source for the replication
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_buffer_header_replicate(MMAL_BUFFER_HEADER_T *dest, MMAL_BUFFER_HEADER_T *src);

/** Lock the data buffer contained in the buffer header in memory.
 * This call does nothing on all platforms except VideoCore where it is needed to pin a
 * buffer in memory before any access to it.
 *
 * @param header buffer header to lock
 */
MMAL_STATUS_T mmal_buffer_header_mem_lock(MMAL_BUFFER_HEADER_T *header);

/** Unlock the data buffer contained in the buffer header.
 * This call does nothing on all platforms except VideoCore where it is needed to un-pin a
 * buffer in memory after any access to it.
 *
 * @param header buffer header to unlock
 */
void mmal_buffer_header_mem_unlock(MMAL_BUFFER_HEADER_T *header);

/* @} */

#ifdef __cplusplus
}
#endif

#endif /* MMAL_BUFFER_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_COMPONENT_H
#define MMAL_COMPONENT_H

#ifdef __cplusplus
extern "C" {
#endif

/** \defgroup MmalComponent Components
 * Definition of a MMAL component and its associated API. A component will always expose ports
 * which it uses to send and receive data in the form of buffer headers
 * (\ref MMAL_BUFFER_HEADER_T) */
/* @{ */

#include "mmal_types.h"
#include "mmal_port.h"

struct MMAL_COMPONENT_PRIVATE_T;
typedef struct MMAL_COMPONENT_PRIVATE_T MMAL_COMPONENT_PRIVATE_T;

/** Definition of a component. */
typedef struct MMAL_COMPONENT_T
{
   /** Pointer to the private data of the module in use */
   struct MMAL_COMPONENT_PRIVATE_T *priv;

   /** Pointer to private data of the client */
   struct MMAL_COMPONENT_USERDATA_T *userdata;

   /** Component name */
   const char *name;

   /** Specifies whether the component is enabled or not */
   uint32_t is_enabled;

   /** All components expose a control port.
    * The control port is used by clients to set / get parameters that are global to the
    * component. It is also used to receive events, which again are global to the component.
    * To be able to receive events, the client needs to enable and register a callback on the
    * control port. */
   MMAL_PORT_T *control;

   uint32_t    input_num;   /**< Number of input ports */
   MMAL_PORT_T **input;     /**< Array of input ports */

   uint32_t    output_num;  /**< Number of output ports */
   MMAL_PORT_T **output;    /**< Array of output ports */

   uint32_t    clock_num;   /**< Number of clock ports */
   MMAL_PORT_T **clock;     /**< Array of clock ports */

   uint32_t    port_num;    /**< Total number of ports */
   MMAL_PORT_T **port;      /**< Array of all the ports (control/input/output/clock) */

   /** Uniquely identifies the component's instance within the MMAL
    * context / process. For debugging. */
   uint32_t id;

} MMAL_COMPONENT_T;

/** Create an instance of a component.
 * The newly created component will expose ports to the client. All the exposed ports are
 * disabled by default.
 * Note that components are reference counted and creating a component automatically
 * acquires a reference to it (released when \ref mmal_component_destroy is called).
 *
 * @param name name of the component to create, e.g. "video_decode"
 * @param component returned component
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_component_create(const char *name,
                                    MMAL_COMPONENT_T **component);

/** Acquire a reference on a component.
 * Acquiring a reference on a component will prevent a component from being destroyed until
 * the acquired reference is released (by a call to \ref mmal_component_destroy).
 * References are internally counted so all acquired references need a matching call to
 * release them.
 *
 * @param component component to acquire
 */
void mmal_component_acquire(MMAL_COMPONENT_T *component);

/** Release a reference on a component
 * Release an acquired reference on a component. Triggers the destruction of the component when
 * the last reference is being released.
 * \note This is in fact an alias of \ref mmal_component_destroy which is added to make client
 * code clearer.
 *
 * @param component component to release
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_component_release(MMAL_COMPONENT_T *component);

/** Destroy a previously created component
 * Release an acquired reference on a component. Only actually destroys the component when
 * the last reference is being released.
 *
 * @param component component to destroy
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_component_destroy(MMAL_COMPONENT_T *component);

/** Enable processing on a component
 * @param component component to enable
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_component_enable(MMAL_COMPONENT_T *component);

/** Disable processing on a component
 * @param component component to disable
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_component_disable(MMAL_COMPONENT_T *component);

/* @} */

#ifdef __cplusplus
}
#endif

#endif /* MMAL_COMPONENT_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_EVENTS_H
#define MMAL_EVENTS_H

#ifdef __cplusplus
extern "C" {
#endif

#include "mmal_common.h"
#include "mmal_parameters.h"
#include "mmal_port.h"

/** \defgroup MmalEvents List of pre-defined event types
 * This defines a list of standard event types. Components can still define proprietary
 * event types by using their own FourCC and defining their own event structures. */
/* @{ */

/** \name Pre-defined event FourCCs */
/* @{ */

/** Error event. Data contains a \ref MMAL_STATUS_T */
#define MMAL_EVENT_ERROR                     MMAL_FOURCC('E','R','R','O')

/** End-of-stream event. Data contains a \ref MMAL_EVENT_END_OF_STREAM_T */
#define MMAL_EVENT_EOS                       MMAL_FOURCC('E','E','O','S')

/** Format changed event. Data contains a \ref MMAL_EVENT_FORMAT_CHANGED_T */
#define MMAL_EVENT_FORMAT_CHANGED            MMAL_FOURCC('E','F','C','H')

/** Parameter changed event. Data contains the new parameter value, see
 * \ref MMAL_EVENT_PARAMETER_CHANGED_T
 */
#define MMAL_EVENT_PARAMETER_CHANGED         MMAL_FOURCC('E','P','C','H')

/* @} */


/** End-of-stream event. */
typedef struct MMAL_EVENT_END_OF_STREAM_T
{
   MMAL_PORT_TYPE_T port_type;   /**< Type of port that received the end of stream */
   uint32_t port_index;          /**< Index of port that received the end of stream */
} MMAL_EVENT_END_OF_STREAM_T;

/** Format changed event data. */
typedef struct MMAL_EVENT_FORMAT_CHANGED_T
{
   uint32_t buffer_size_min;         /**< Minimum size of buffers the port requires */
   uint32_t buffer_num_min;          /**< Minimum number of buffers the port requires */
   uint32_t buffer_size_recommended; /**< Size of buffers the port recommends for optimal performance.
                                          A value of zero means no special recommendation. */
   uint32_t buffer_num_recommended;  /**< Number of buffers the port recommends for optimal
                                          performance. A value of zero means no special recommendation. */

   MMAL_ES_FORMAT_T *format;         /**< New elementary stream format */
} MMAL_EVENT_FORMAT_CHANGED_T;

/** Parameter changed event data.
 * This is a variable sized event. The full parameter is included in the event
 * data, not just the header. Use the \ref MMAL_PARAMETER_HEADER_T::id field to determine how to
 * cast the structure. The \ref MMAL_PARAMETER_HEADER_T::size field can be used to check validity.
 */
typedef struct MMAL_EVENT_PARAMETER_CHANGED_T
{
   MMAL_PARAMETER_HEADER_T hdr;
} MMAL_EVENT_PARAMETER_CHANGED_T;

/** Get a pointer to the \ref MMAL_EVENT_FORMAT_CHANGED_T structure contained in the buffer header.
 * Note that the pointer will point inside the data contained in the buffer header
 * so doesn't need to be freed explicitly.
 *
 * @param buffer buffer header containing the MMAL_EVENT_FORMAT_CHANGED event.
 * @return pointer to a MMAL_EVENT_FORMAT_CHANGED_T structure.
 */
MMAL_EVENT_FORMAT_CHANGED_T *mmal_event_format_changed_get(MMAL_BUFFER_HEADER_T *buffer);

/* @} */

#ifdef __cplusplus
}
#endif

#endif /* MMAL_EVENTS_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_ENCODINGS_H
#define MMAL_ENCODINGS_H

#include "mmal_common.h"

/** \defgroup MmalEncodings List of pre-defined encodings
 * This defines a list of common encodings. This list isn't exhaustive and is only
 * provided as a convenience to avoid clients having to use FourCC codes directly.
 * However components are allowed to define and use their own FourCC codes. */
/* @{ */

/** \name Pre-defined video encodings */
/* @{ */
#define MMAL_ENCODING_H264             MMAL_FOURCC('H','2','6','4')
#define MMAL_ENCODING_MVC              MMAL_FOURCC('M','V','C',' ')
#define MMAL_ENCODING_H263             MMAL_FOURCC('H','2','6','3')
#define MMAL_ENCODING_MP4V             MMAL_FOURCC('M','P','4','V')
#define MMAL_ENCODING_MP2V             MMAL_FOURCC('M','P','2','V')
#define MMAL_ENCODING_MP1V             MMAL_FOURCC('M','P','1','V')
#define MMAL_ENCODING_WMV3             MMAL_FOURCC('W','M','V','3')
#define MMAL_ENCODING_WMV2             MMAL_FOURCC('W','M','V','2')
#define MMAL_ENCODING_WMV1             MMAL_FOURCC('W','M','V','1')
#define MMAL_ENCODING_WVC1             MMAL_FOURCC('W','V','C','1')
#define MMAL_ENCODING_VP8              MMAL_FOURCC('V','P','8',' ')
#define MMAL_ENCODING_VP7              MMAL_FOURCC('V','P','7',' ')
#define MMAL_ENCODING_VP6              MMAL_FOURCC('V','P','6',' ')
#define MMAL_ENCODING_THEORA           MMAL_FOURCC('T','H','E','O')
#define MMAL_ENCODING_SPARK            MMAL_FOURCC('S','P','R','K')
#define MMAL_ENCODING_MJPEG            MMAL_FOURCC('M','J','P','G')

#define MMAL_ENCODING_JPEG             MMAL_FOURCC('J','P','E','G')
#define MMAL_ENCODING_GIF              MMAL_FOURCC('G','I','F',' ')
#define MMAL_ENCODING_PNG              MMAL_FOURCC('P','N','G',' ')
#define MMAL_ENCODING_PPM              MMAL_FOURCC('P','P','M',' ')
#define MMAL_ENCODING_TGA              MMAL_FOURCC('T','G','A',' ')
#define MMAL_ENCODING_BMP              MMAL_FOURCC('B','M','P',' ')

#define MMAL_ENCODING_I420             MMAL_FOURCC('I','4','2','0')
#define MMAL_ENCODING_I420_SLICE       MMAL_FOURCC('S','4','2','0')
#define MMAL_ENCODING_YV12             MMAL_FOURCC('Y','V','1','2')
#define MMAL_ENCODING_I422             MMAL_FOURCC('I','4','2','2')
#define MMAL_ENCODING_I422_SLICE       MMAL_FOURCC('S','4','2','2')
#define MMAL_ENCODING_YUYV             MMAL_FOURCC('Y','U','Y','V')
#define MMAL_ENCODING_YVYU             MMAL_FOURCC('Y','V','Y','U')
#define MMAL_ENCODING_UYVY             MMAL_FOURCC('U','Y','V','Y')
#define MMAL_ENCODING_VYUY             MMAL_FOURCC('V','Y','U','Y')
#define MMAL_ENCODING_NV12             MMAL_FOURCC('N','V','1','2')
#define MMAL_ENCODING_NV21             MMAL_FOURCC('N','V','2','1')
#define MMAL_ENCODING_ARGB             MMAL_FOURCC('A','R','G','B')
#define MMAL_ENCODING_ARGB_SLICE       MMAL_FOURCC('a','r','g','b')
#define MMAL_ENCODING_RGBA             MMAL_FOURCC('R','G','B','A')
#define MMAL_ENCODING_RGBA_SLICE       MMAL_FOURCC('r','g','b','a')
#define MMAL_ENCODING_ABGR             MMAL_FOURCC('A','B','G','R')
#define MMAL_ENCODING_ABGR_SLICE       MMAL_FOURCC('a','b','g','r')
#define MMAL_ENCODING_BGRA             MMAL_FOURCC('B','G','R','A')
#define MMAL_ENCODING_BGRA_SLICE       MMAL_FOURCC('b','g','r','a')
#define MMAL_ENCODING_RGB16            MMAL_FOURCC('R','G','B','2')
#define MMAL_ENCODING_RGB16_SLICE      MMAL_FOURCC('r','g','b','2')
#define MMAL_ENCODING_RGB24            MMAL_FOURCC('R','G','B','3')
#define MMAL_ENCODING_RGB24_SLICE      MMAL_FOURCC('r','g','b','3')
#define MMAL_ENCODING_RGB32            MMAL_FOURCC('R','G','B','4')
#define MMAL_ENCODING_RGB32_SLICE      MMAL_FOURCC('r','g','b','4')
#define MMAL_ENCODING_BGR16            MMAL_FOURCC('B','G','R','2')
#define MMAL_ENCODING_BGR16_SLICE      MMAL_FOURCC('b','g','r','2')
#define MMAL_ENCODING_BGR24            MMAL_FOURCC('B','G','R','3')
#define MMAL_ENCODING_BGR24_SLICE      MMAL_FOURCC('b','g','r','3')
#define MMAL_ENCODING_BGR32            MMAL_FOURCC('B','G','R','4')
#define MMAL_ENCODING_BGR32_SLICE      MMAL_FOURCC('b','g','r','4')

/** YUV 4:2:0 planar, 16bit/component.
*/
#define MMAL_ENCODING_I420_16          MMAL_FOURCC('i','4','2','0')
/** YUV 4:2:0 planar, 10bit/component as least sig 10bits of 16 bit words.
*/
#define MMAL_ENCODING_I420_10          MMAL_FOURCC('i','4','1','0')

/** YUV 4:2:0 planar but with U and V in side-by-side format
 *   So U and V have same pitch as Y, but V = U + pitch/2
*/
#define MMAL_ENCODING_I420_S           MMAL_FOURCC('I','4','2','S')

//Bayer formats
//FourCC values copied from V4L2 where defined.
//10 bit per pixel packed Bayer formats.
#define MMAL_ENCODING_BAYER_SBGGR10P   MMAL_FOURCC('p','B','A','A')  //BGGR
#define MMAL_ENCODING_BAYER_SGRBG10P   MMAL_FOURCC('p','g','A','A')  //GRBG
#define MMAL_ENCODING_BAYER_SGBRG10P   MMAL_FOURCC('p','G','A','A')  //GBRG
#define MMAL_ENCODING_BAYER_SRGGB10P   MMAL_FOURCC('p','R','A','A')  //RGGB

//8 bit per pixel Bayer formats.
#define MMAL_ENCODING_BAYER_SBGGR8     MMAL_FOURCC('B','A','8','1')  //BGGR
#define MMAL_ENCODING_BAYER_SGBRG8     MMAL_FOURCC('G','B','R','G')  //GBRG
#define MMAL_ENCODING_BAYER_SGRBG8     MMAL_FOURCC('G','R','B','G')  //GRBG
#define MMAL_ENCODING_BAYER_SRGGB8     MMAL_FOURCC('R','G','G','B')  //RGGB

//12 bit per pixel Bayer formats - not defined in V4L2, only 12bit expanded to 16.
//Copy 10bpp packed 4CC pattern
#define MMAL_ENCODING_BAYER_SBGGR12P   MMAL_FOURCC('p','B','1','2')  //BGGR
#define MMAL_ENCODING_BAYER_SGRBG12P   MMAL_FOURCC('p','g','1','2')  //GRBG
#define MMAL_ENCODING_BAYER_SGBRG12P   MMAL_FOURCC('p','G','1','2')  //GBRG
#define MMAL_ENCODING_BAYER_SRGGB12P   MMAL_FOURCC('p','R','1','2')  //RGGB

//16 bit per pixel Bayer formats.
#define MMAL_ENCODING_BAYER_SBGGR16    MMAL_FOURCC('B','G','1','6')  //BGGR
#define MMAL_ENCODING_BAYER_SGBRG16    MMAL_FOURCC('G','B','1','6')  //GBRG
#define MMAL_ENCODING_BAYER_SGRBG16    MMAL_FOURCC('G','R','1','6')  //GRBG
#define MMAL_ENCODING_BAYER_SRGGB16    MMAL_FOURCC('R','G','1','6')  //RGGB

//10 bit per pixel DPCM compressed to 8bits Bayer formats.
#define MMAL_ENCODING_BAYER_SBGGR10DPCM8 MMAL_FOURCC('b','B','A','8')  //BGGR
#define MMAL_ENCODING_BAYER_SGBRG10DPCM8 MMAL_FOURCC('b','G','A','8')  //GBRG
#define MMAL_ENCODING_BAYER_SGRBG10DPCM8 MMAL_FOURCC('B','D','1','0')  //GRBG
#define MMAL_ENCODING_BAYER_SRGGB10DPCM8 MMAL_FOURCC('b','R','A','8')  //RGGB

/** SAND Video (YUVUV128) format, native format understood by VideoCore.
 * This format is *not* opaque - if requested you will receive full frames
 * of YUV_UV video.
 */
#define MMAL_ENCODING_YUVUV128         MMAL_FOURCC('S','A','N','D')
/** 16 bit SAND Video (YUVUV64_16) format.
 * This format is *not* opaque - if requested you will receive full frames
 * of YUV_UV_16 video.
 */
#define MMAL_ENCODING_YUVUV64_16      MMAL_FOURCC('S','A','1','6')
/** 10 bit SAND Video format, packed as least sig 10 bits of 16 bit words.
 */
#define MMAL_ENCODING_YUVUV64_10      MMAL_FOURCC('S','A','1','0')

/** VideoCore opaque image format, image handles are returned to
 * the host but not the actual image data.
 */
#define MMAL_ENCODING_OPAQUE           MMAL_FOURCC('O','P','Q','V')

/** An EGL image handle
 */
#define MMAL_ENCODING_EGL_IMAGE        MMAL_FOURCC('E','G','L','I')

/* }@ */

/** \name Pre-defined audio encodings */
/* @{ */
#define MMAL_ENCODING_PCM_UNSIGNED_BE  MMAL_FOURCC('P','C','M','U')
#define MMAL_ENCODING_PCM_UNSIGNED_LE  MMAL_FOURCC('p','c','m','u')
#define MMAL_ENCODING_PCM_SIGNED_BE    MMAL_FOURCC('P','C','M','S')
#define MMAL_ENCODING_PCM_SIGNED_LE    MMAL_FOURCC('p','c','m','s')
#define MMAL_ENCODING_PCM_FLOAT_BE     MMAL_FOURCC('P','C','M','F')
#define MMAL_ENCODING_PCM_FLOAT_LE     MMAL_FOURCC('p','c','m','f')
/* Defines for native endianness */
#ifdef MMAL_IS_BIG_ENDIAN
#define MMAL_ENCODING_PCM_UNSIGNED     MMAL_ENCODING_PCM_UNSIGNED_BE
#define MMAL_ENCODING_PCM_SIGNED       MMAL_ENCODING_PCM_SIGNED_BE
#define MMAL_ENCODING_PCM_FLOAT        MMAL_ENCODING_PCM_FLOAT_BE
#else
#define MMAL_ENCODING_PCM_UNSIGNED     MMAL_ENCODING_PCM_UNSIGNED_LE
#define MMAL_ENCODING_PCM_SIGNED       MMAL_ENCODING_PCM_SIGNED_LE
#define MMAL_ENCODING_PCM_FLOAT        MMAL_ENCODING_PCM_FLOAT_LE
#endif

#define MMAL_ENCODING_MP4A             MMAL_FOURCC('M','P','4','A')
#define MMAL_ENCODING_MPGA             MMAL_FOURCC('M','P','G','A')
#define MMAL_ENCODING_ALAW             MMAL_FOURCC('A','L','A','W')
#define MMAL_ENCODING_MULAW            MMAL_FOURCC('U','L','A','W')
#define MMAL_ENCODING_ADPCM_MS         MMAL_FOURCC('M','S',0x0,0x2)
#define MMAL_ENCODING_ADPCM_IMA_MS     MMAL_FOURCC('M','S',0x0,0x1)
#define MMAL_ENCODING_ADPCM_SWF        MMAL_FOURCC('A','S','W','F')
#define MMAL_ENCODING_WMA1             MMAL_FOURCC('W','M','A','1')
#define MMAL_ENCODING_WMA2             MMAL_FOURCC('W','M','A','2')
#define MMAL_ENCODING_WMAP             MMAL_FOURCC('W','M','A','P')
#define MMAL_ENCODING_WMAL             MMAL_FOURCC('W','M','A','L')
#define MMAL_ENCODING_WMAV             MMAL_FOURCC('W','M','A','V')
#define MMAL_ENCODING_AMRNB            MMAL_FOURCC('A','M','R','N')
#define MMAL_ENCODING_AMRWB            MMAL_FOURCC('A','M','R','W')
#define MMAL_ENCODING_AMRWBP           MMAL_FOURCC('A','M','R','P')
#define MMAL_ENCODING_AC3              MMAL_FOURCC('A','C','3',' ')
#define MMAL_ENCODING_EAC3             MMAL_FOURCC('E','A','C','3')
#define MMAL_ENCODING_DTS              MMAL_FOURCC('D','T','S',' ')
#define MMAL_ENCODING_MLP              MMAL_FOURCC('M','L','P',' ')
#define MMAL_ENCODING_FLAC             MMAL_FOURCC('F','L','A','C')
#define MMAL_ENCODING_VORBIS           MMAL_FOURCC('V','O','R','B')
#define MMAL_ENCODING_SPEEX            MMAL_FOURCC('S','P','X',' ')
#define MMAL_ENCODING_ATRAC3           MMAL_FOURCC('A','T','R','3')
#define MMAL_ENCODING_ATRACX           MMAL_FOURCC('A','T','R','X')
#define MMAL_ENCODING_ATRACL           MMAL_FOURCC('A','T','R','L')
#define MMAL_ENCODING_MIDI             MMAL_FOURCC('M','I','D','I')
#define MMAL_ENCODING_EVRC             MMAL_FOURCC('E','V','R','C')
#define MMAL_ENCODING_NELLYMOSER       MMAL_FOURCC('N','E','L','Y')
#define MMAL_ENCODING_QCELP            MMAL_FOURCC('Q','C','E','L')
#define MMAL_ENCODING_MP4V_DIVX_DRM    MMAL_FOURCC('M','4','V','D')
/* @} */

/* @} MmalEncodings List */

/** \defgroup MmalEncodingVariants List of pre-defined encoding variants
 * This defines a list of common encoding variants. This list isn't exhaustive and is only
 * provided as a convenience to avoid clients having to use FourCC codes directly.
 * However components are allowed to define and use their own FourCC codes. */
/* @{ */

/** \name Pre-defined H264 encoding variants */
/* @{ */
/** ISO 14496-10 Annex B byte stream format */
#define MMAL_ENCODING_VARIANT_H264_DEFAULT   0
/** ISO 14496-15 AVC stream format */
#define MMAL_ENCODING_VARIANT_H264_AVC1      MMAL_FOURCC('A','V','C','1')
/** Implicitly delineated NAL units without emulation prevention */
#define MMAL_ENCODING_VARIANT_H264_RAW       MMAL_FOURCC('R','A','W',' ')
/* @} */

/** \name Pre-defined MPEG4 audio encoding variants */
/* @{ */
/** Raw stream format */
#define MMAL_ENCODING_VARIANT_MP4A_DEFAULT   0
/** ADTS stream format */
#define MMAL_ENCODING_VARIANT_MP4A_ADTS      MMAL_FOURCC('A','D','T','S')
/* @} */

/* @} MmalEncodingVariants List */

/** \defgroup MmalColorSpace List of pre-defined video color spaces
 * This defines a list of common color spaces. This list isn't exhaustive and is only
 * provided as a convenience to avoid clients having to use FourCC codes directly.
 * However components are allowed to define and use their own FourCC codes. */
/* @{ */

/** Unknown color space */
#define MMAL_COLOR_SPACE_UNKNOWN       0
/** ITU-R BT.601-5 [SDTV] */
#define MMAL_COLOR_SPACE_ITUR_BT601    MMAL_FOURCC('Y','6','0','1')
/** ITU-R BT.709-3 [HDTV] */
#define MMAL_COLOR_SPACE_ITUR_BT709    MMAL_FOURCC('Y','7','0','9')
/** JPEG JFIF */
#define MMAL_COLOR_SPACE_JPEG_JFIF     MMAL_FOURCC('Y','J','F','I')
/** Title 47 Code of Federal Regulations (2003) 73.682 (a) (20) */
#define MMAL_COLOR_SPACE_FCC           MMAL_FOURCC('Y','F','C','C')
/** Society of Motion Picture and Television Engineers 240M (1999) */
#define MMAL_COLOR_SPACE_SMPTE240M     MMAL_FOURCC('Y','2','4','0')
/** ITU-R BT.470-2 System M */
#define MMAL_COLOR_SPACE_BT470_2_M     MMAL_FOURCC('Y','_','_','M')
/** ITU-R BT.470-2 System BG */
#define MMAL_COLOR_SPACE_BT470_2_BG    MMAL_FOURCC('Y','_','B','G')
/** JPEG JFIF, but with 16..255 luma */
#define MMAL_COLOR_SPACE_JFIF_Y16_255  MMAL_FOURCC('Y','Y','1','6')
/* @} MmalColorSpace List */

#endif /* MMAL_ENCODINGS_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_FORMAT_H
#define MMAL_FORMAT_H

#ifdef __cplusplus
extern "C" {
#endif

/** \defgroup MmalFormat Elementary stream format
 * Definition of an elementary stream format and its associated API */
/* @{ */

#include "mmal_types.h"
#include "mmal_encodings.h"

/** Enumeration of the different types of elementary streams.
 * This divides elementary streams into 4 big categories, plus an invalid type. */
typedef enum {
   MMAL_ES_TYPE_UNKNOWN,     /**< Unknown elementary stream type */
   MMAL_ES_TYPE_CONTROL,     /**< Elementary stream of control commands */
   MMAL_ES_TYPE_AUDIO,       /**< Audio elementary stream */
   MMAL_ES_TYPE_VIDEO,       /**< Video elementary stream */
   MMAL_ES_TYPE_SUBPICTURE   /**< Sub-picture elementary stream (e.g. subtitles, overlays) */
} MMAL_ES_TYPE_T;

/** Definition of a video format.
 * This describes the properties specific to a video stream */
typedef struct
{
   uint32_t        width;        /**< Width of frame in pixels */
   uint32_t        height;       /**< Height of frame in rows of pixels */
   MMAL_RECT_T     crop;         /**< Visible region of the frame */
   MMAL_RATIONAL_T frame_rate;   /**< Frame rate */
   MMAL_RATIONAL_T par;          /**< Pixel aspect ratio */

   MMAL_FOURCC_T   color_space;  /**< FourCC specifying the color space of the
                                   * video stream. See the \ref MmalColorSpace
                                   * "pre-defined color spaces" for some examples.
                                   */

} MMAL_VIDEO_FORMAT_T;

/** Definition of an audio format.
 * This describes the properties specific to an audio stream */
typedef struct MMAL_AUDIO_FORMAT_T
{
   uint32_t channels;           /**< Number of audio channels */
   uint32_t sample_rate;        /**< Sample rate */

   uint32_t bits_per_sample;    /**< Bits per sample */
   uint32_t block_align;        /**< Size of a block of data */

   /** \todo add channel mapping, gapless and replay-gain support */

} MMAL_AUDIO_FORMAT_T;

/** Definition of a subpicture format.
 * This describes the properties specific to a subpicture stream */
typedef struct
{
   uint32_t x_offset;        /**< Width offset to the start of the subpicture */
   uint32_t y_offset;        /**< Height offset to the start of the subpicture */

   /** \todo surely more things are needed here */

} MMAL_SUBPICTURE_FORMAT_T;

/** Definition of the type specific format.
 * This describes the type specific information of the elementary stream. */
typedef union
{
   MMAL_AUDIO_FORMAT_T      audio;      /**< Audio specific information */
   MMAL_VIDEO_FORMAT_T      video;      /**< Video specific information */
   MMAL_SUBPICTURE_FORMAT_T subpicture; /**< Subpicture specific information */
} MMAL_ES_SPECIFIC_FORMAT_T;

/** \name Elementary stream flags
 * \anchor elementarystreamflags
 * The following flags describe properties of an elementary stream */
/* @{ */
#define MMAL_ES_FORMAT_FLAG_FRAMED       0x1 /**< The elementary stream will already be framed */
/* @} */

/** \name Undefined encoding value.
 * This value indicates an unknown encoding
 */
/* @{ */
#define MMAL_ENCODING_UNKNOWN            0
/* @} */

/** \name Default encoding variant value.
 * This value indicates the default encoding variant is used
 */
/* @{ */
#define MMAL_ENCODING_VARIANT_DEFAULT    0
/* @} */

/** Definition of an elementary stream format */
typedef struct MMAL_ES_FORMAT_T
{
   MMAL_ES_TYPE_T type;           /**< Type of the elementary stream */

   MMAL_FOURCC_T encoding;        /**< FourCC specifying the encoding of the elementary stream.
                                    * See the \ref MmalEncodings "pre-defined encodings" for some
                                    * examples.
                                    */
   MMAL_FOURCC_T encoding_variant;/**< FourCC specifying the specific encoding variant of
                                    * the elementary stream. See the \ref MmalEncodingVariants
                                    * "pre-defined encoding variants" for some examples.
                                    */

   MMAL_ES_SPECIFIC_FORMAT_T *es; /**< Type specific information for the elementary stream */

   uint32_t bitrate;              /**< Bitrate in bits per second */
   uint32_t flags;                /**< Flags describing properties of the elementary stream.
                                    * See \ref elementarystreamflags "Elementary stream flags".
                                    */

   uint32_t extradata_size;       /**< Size of the codec specific data */
   uint8_t  *extradata;           /**< Codec specific data */

} MMAL_ES_FORMAT_T;

/** Allocate and initialise a \ref MMAL_ES_FORMAT_T structure.
 *
 * @return a \ref MMAL_ES_FORMAT_T structure
 */
MMAL_ES_FORMAT_T *mmal_format_alloc(void);

/** Free a \ref MMAL_ES_FORMAT_T structure allocated by \ref mmal_format_alloc.
 *
 * @param format the \ref MMAL_ES_FORMAT_T structure to free
 */
void mmal_format_free(MMAL_ES_FORMAT_T *format);

/** Allocate the extradata buffer in \ref MMAL_ES_FORMAT_T.
 * This buffer will be freed automatically when the format is destroyed or
 * another allocation is done.
 *
 * @param format format structure for which the extradata buffer will be allocated
 * @param size size of the extradata buffer to allocate
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_format_extradata_alloc(MMAL_ES_FORMAT_T *format, unsigned int size);

/** Shallow copy a format structure.
 * It is worth noting that the extradata buffer will not be copied in the new format.
 *
 * @param format_dest destination \ref MMAL_ES_FORMAT_T for the copy
 * @param format_src source \ref MMAL_ES_FORMAT_T for the copy
 */
void mmal_format_copy(MMAL_ES_FORMAT_T *format_dest, MMAL_ES_FORMAT_T *format_src);

/** Fully copy a format structure, including the extradata buffer.
 *
 * @param format_dest destination \ref MMAL_ES_FORMAT_T for the copy
 * @param format_src source \ref MMAL_ES_FORMAT_T for the copy
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_format_full_copy(MMAL_ES_FORMAT_T *format_dest, MMAL_ES_FORMAT_T *format_src);

/** \name Comparison flags
 * \anchor comparisonflags
 * The following flags describe the differences between 2 format structures */
/* @{ */
#define MMAL_ES_FORMAT_COMPARE_FLAG_TYPE              0x01 /**< The type is different */
#define MMAL_ES_FORMAT_COMPARE_FLAG_ENCODING          0x02 /**< The encoding is different */
#define MMAL_ES_FORMAT_COMPARE_FLAG_BITRATE           0x04 /**< The bitrate is different */
#define MMAL_ES_FORMAT_COMPARE_FLAG_FLAGS             0x08 /**< The flags are different */
#define MMAL_ES_FORMAT_COMPARE_FLAG_EXTRADATA         0x10 /**< The extradata is different */

#define MMAL_ES_FORMAT_COMPARE_FLAG_VIDEO_RESOLUTION   0x0100 /**< The video resolution is different */
#define MMAL_ES_FORMAT_COMPARE_FLAG_VIDEO_CROPPING     0x0200 /**< The video cropping is different */
#define MMAL_ES_FORMAT_COMPARE_FLAG_VIDEO_FRAME_RATE   0x0400 /**< The video frame rate is different */
#define MMAL_ES_FORMAT_COMPARE_FLAG_VIDEO_ASPECT_RATIO 0x0800 /**< The video aspect ratio is different */
#define MMAL_ES_FORMAT_COMPARE_FLAG_VIDEO_COLOR_SPACE  0x1000 /**< The video color space is different */

#define MMAL_ES_FORMAT_COMPARE_FLAG_ES_OTHER  0x10000000 /**< Other ES specific parameters are different */
/* @} */

/** Compare 2 format structures and returns a set of flags describing the differences.
 * The result will be zero if the structures are the same, or a combination of
 * one or more of the \ref comparisonflags "Comparison flags" if different.
 *
 * @param format_1 first \ref MMAL_ES_FORMAT_T to compare
 * @param format_2 second \ref MMAL_ES_FORMAT_T to compare
 * @return set of flags describing the differences
 */
uint32_t mmal_format_compare(MMAL_ES_FORMAT_T *format_1, MMAL_ES_FORMAT_T *format_2);

/* @} */

#ifdef __cplusplus
}
#endif

#endif /* MMAL_FORMAT_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_LOGGING_H
#define MMAL_LOGGING_H

#include "mmal_common.h"
#include "interface/vcos/vcos_logging.h"

#ifndef VCOS_LOG_CATEGORY
#define VCOS_LOG_CATEGORY (&mmal_log_category)
extern VCOS_LOG_CAT_T mmal_log_category;
#endif

#if defined(__GNUC__) && (( __GNUC__ > 2 ) || (( __GNUC__ == 2 ) && ( __GNUC_MINOR__ >= 3 )))
#define mmal_log_error(s, ...) vcos_log_error("%s: " s, VCOS_FUNCTION, ## __VA_ARGS__)
#define mmal_log_info(s, ...) vcos_log_info("%s: " s, VCOS_FUNCTION, ## __VA_ARGS__)
#define mmal_log_warn(s, ...) vcos_log_warn("%s: " s, VCOS_FUNCTION, ## __VA_ARGS__)
#define mmal_log_debug(s, ...) vcos_log_info("%s: " s, VCOS_FUNCTION, ## __VA_ARGS__)
#define mmal_log_trace(s, ...) vcos_log_trace("%s: " s, VCOS_FUNCTION, ## __VA_ARGS__)
#elif defined(_MSC_VER)
#define mmal_log_error(s, ...) vcos_log_error("%s: " s, VCOS_FUNCTION, __VA_ARGS__)
#define mmal_log_info(s, ...) vcos_log_info("%s: " s, VCOS_FUNCTION, __VA_ARGS__)
#define mmal_log_warn(s, ...) vcos_log_warn("%s: " s, VCOS_FUNCTION, __VA_ARGS__)
#define mmal_log_debug(s, ...) vcos_log_info("%s: " s, VCOS_FUNCTION, __VA_ARGS__)
#define mmal_log_trace(s, ...) vcos_log_trace("%s: " s, VCOS_FUNCTION, __VA_ARGS__)
#else
#define mmal_log_error_fun(s, ...) vcos_log_error("%s: " s, VCOS_FUNCTION, __VA_ARGS__)
#define mmal_log_info_fun(s, ...) vcos_log_info("%s: " s, VCOS_FUNCTION, __VA_ARGS__)
#define mmal_log_warn_fun(s, ...) vcos_log_warn("%s: " s, VCOS_FUNCTION, __VA_ARGS__)
#define mmal_log_debug_fun(s, ...) vcos_log_info("%s: " s, VCOS_FUNCTION, __VA_ARGS__)
#define mmal_log_trace_fun(s, ...) vcos_log_trace("%s: " s, VCOS_FUNCTION, __VA_ARGS__)

#define mmal_log_error(s...) mmal_log_error_fun(s, 0)
#define mmal_log_info(s...) mmal_log_info_fun(s, 0)
#define mmal_log_warn(s...)  mmal_log_warn_fun(s, 0)
#define mmal_log_debug(s...)  mmal_log_debug_fun(s, 0)
#define mmal_log_trace(s...) mmal_log_trace_fun(s, 0)
#endif

#define LOG_ERROR mmal_log_error
#define LOG_INFO mmal_log_info
#define LOG_WARN mmal_log_warn
#define LOG_DEBUG mmal_log_debug
#define LOG_TRACE mmal_log_trace

#endif /* MMAL_LOGGING_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                        /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_PARAMETERS_H
#define MMAL_PARAMETERS_H

#include "mmal_common.h"
#include "mmal_parameters_camera.h"
#include "mmal_parameters_video.h"
#include "mmal_parameters_audio.h"
#include "mmal_parameters_clock.h"

/** \defgroup MmalParameters List of pre-defined parameters
 * This defines a list of standard parameters. Components can define proprietary
 * parameters by creating a new group and defining their own structures. */
/* @{ */

/** Generic unsigned 64-bit integer parameter type. */
typedef struct MMAL_PARAMETER_UINT64_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   uint64_t value; /**< Parameter value */
} MMAL_PARAMETER_UINT64_T;

/** Generic signed 64-bit integer parameter type. */
typedef struct MMAL_PARAMETER_INT64_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   int64_t value; /**< Parameter value */
} MMAL_PARAMETER_INT64_T;

/** Generic unsigned 32-bit integer parameter type. */
typedef struct MMAL_PARAMETER_UINT32_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   uint32_t value; /**< Parameter value */
} MMAL_PARAMETER_UINT32_T;

/** Generic signed 32-bit integer parameter type. */
typedef struct MMAL_PARAMETER_INT32_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   int32_t value; /**< Parameter value */
} MMAL_PARAMETER_INT32_T;

/** Generic rational parameter type. */
typedef struct MMAL_PARAMETER_RATIONAL_T {
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_RATIONAL_T value; /**< Parameter value */
} MMAL_PARAMETER_RATIONAL_T;

/** Generic boolean parameter type. */
typedef struct MMAL_PARAMETER_BOOLEAN_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_BOOL_T enable; /**< Parameter value */
} MMAL_PARAMETER_BOOLEAN_T;

/** Generic string parameter type. */
typedef struct MMAL_PARAMETER_STRING_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   char str[1];        /**< Null-terminated string */
} MMAL_PARAMETER_STRING_T;

/** Generic array of bytes parameter type. */
typedef struct MMAL_PARAMETER_BYTES_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   uint8_t data[1];   /**< Array of bytes */
} MMAL_PARAMETER_BYTES_T;

/** The value 1 in 16.16 fixed point form */
#define MMAL_FIXED_16_16_ONE  (1 << 16)

/** Generic two-dimensional scaling factor type. */
typedef struct MMAL_PARAMETER_SCALEFACTOR_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_FIXED_16_16_T scale_x;  /**< Scaling factor in X-axis */
   MMAL_FIXED_16_16_T scale_y;  /**< Scaling factor in Y-axis */
} MMAL_PARAMETER_SCALEFACTOR_T;

/** Valid mirror modes */
typedef enum MMAL_PARAM_MIRROR_T
{
   MMAL_PARAM_MIRROR_NONE,
   MMAL_PARAM_MIRROR_VERTICAL,
   MMAL_PARAM_MIRROR_HORIZONTAL,
   MMAL_PARAM_MIRROR_BOTH,
} MMAL_PARAM_MIRROR_T;

/** Generic mirror parameter type */
typedef struct MMAL_PARAMETER_MIRROR_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_PARAM_MIRROR_T value;   /**< Mirror mode */
} MMAL_PARAMETER_MIRROR_T;

/** URI parameter type.
 * The parameter may hold an arbitrary length, nul-terminated string as long
 * as the size is set appropriately.
 */
typedef struct MMAL_PARAMETER_URI_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   char uri[1];    /**< URI string (null-terminated) */
} MMAL_PARAMETER_URI_T;

/** Generic encoding parameter type.
 * The parameter may hold more than one encoding by overriding the size to
 * include a bigger array.
 */
typedef struct MMAL_PARAMETER_ENCODING_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   uint32_t encoding[1];   /**< Array of FourCC encodings, see \ref MmalEncodings */
} MMAL_PARAMETER_ENCODING_T;

/** Generic frame-rate parameter type.
 * Frame rates are specified as a rational number, using a pair of integers.
 * Since there can be many valid pairs for the same ratio, a frame-rate may
 * not contain exactly the same pairs of values when read back as it was
 * when set.
 */
typedef struct MMAL_PARAMETER_FRAME_RATE_T {
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_RATIONAL_T frame_rate;   /**< Frame-rate value */
} MMAL_PARAMETER_FRAME_RATE_T;

/** Generic configuration-file setup type.
 * Configuration files are transferred in small chunks. The component can
 * save all the chunks into a buffer, then process the entire file later.
 * This parameter initialises a config file to have the given size.
 */
typedef struct MMAL_PARAMETER_CONFIGFILE_T {
   MMAL_PARAMETER_HEADER_T hdr;

   uint32_t file_size;           /**< Size of complete file data */
} MMAL_PARAMETER_CONFIGFILE_T;

/** Generic configuration-file chunk data type.
 * Once a config file has been initialised, this parameter can be used to
 * write an arbitrary chunk of the file data (limited by the maximum MMAL
 * message size).
 */
typedef struct MMAL_PARAMETER_CONFIGFILE_CHUNK_T {
   MMAL_PARAMETER_HEADER_T hdr;

   uint32_t size;                /**< Number of bytes being transferred in this chunk */
   uint32_t offset;              /**< Offset of this chunk in the file */
   char data[1];                 /**< Chunk data */
} MMAL_PARAMETER_CONFIGFILE_CHUNK_T;

/* @} */

#endif /* MMAL_PARAMETERS_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_PARAMETERS_AUDIO_H
#define MMAL_PARAMETERS_AUDIO_H

#include "mmal_parameters_common.h"

/*************************************************
 * ALWAYS ADD NEW ENUMS AT THE END OF THIS LIST! *
 ************************************************/

/** Audio-specific MMAL parameter IDs.
 * @ingroup MMAL_PARAMETER_IDS
 */
enum
{
   MMAL_PARAMETER_AUDIO_DESTINATION      /**< Takes a MMAL_PARAMETER_STRING_T */
         = MMAL_PARAMETER_GROUP_AUDIO,
   MMAL_PARAMETER_AUDIO_LATENCY_TARGET,  /**< Takes a MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T */
   MMAL_PARAMETER_AUDIO_SOURCE,
   MMAL_PARAMETER_AUDIO_PASSTHROUGH,     /**< Takes a MMAL_PARAMETER_BOOLEAN_T */
};

/** Audio latency target to maintain.
 * These settings are used to adjust the clock speed in order
 * to match the measured audio latency to a specified value. */
typedef struct MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_BOOL_T enable;   /**< whether this mode is enabled */
   uint32_t filter;      /**< number of latency samples to filter on, good value: 1 */
   uint32_t target;      /**< target latency (microseconds) */
   uint32_t shift;       /**< shift for storing latency values, good value: 7 */
   int32_t speed_factor; /**< multiplier for speed changes, in 24.8 format, good value: 256-512 */
   int32_t inter_factor; /**< divider for comparing latency versus gradiant, good value: 300 */
   int32_t adj_cap;      /**< limit for speed change before nSpeedFactor is applied, good value: 100 */
} MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T;

#endif /* MMAL_PARAMETERS_AUDIO_H */

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
Copyright (c) 2011 Broadcom Europe Limited.
All rights reserved.
=============================================================================*/
/** \file
 * Multi-Media Abstraction Layer - Definition of some standard parameters.
 */

#ifndef MMAL_PARAMETERS_CAMERA_H
#define MMAL_PARAMETERS_CAMERA_H

#include "mmal_parameters_common.h"

/*************************************************
 * ALWAYS ADD NEW ENUMS AT THE END OF THIS LIST! *
 ************************************************/

/** Camera-specific MMAL parameter IDs.
 * @ingroup MMAL_PARAMETER_IDS
 */
enum {
   /* 0 */
   MMAL_PARAMETER_THUMBNAIL_CONFIGURATION    /**< Takes a @ref MMAL_PARAMETER_THUMBNAIL_CONFIG_T */
         = MMAL_PARAMETER_GROUP_CAMERA,
   MMAL_PARAMETER_CAPTURE_QUALITY,           /**< Unused? */
   MMAL_PARAMETER_ROTATION,                  /**< Takes a @ref MMAL_PARAMETER_INT32_T */
   MMAL_PARAMETER_EXIF_DISABLE,              /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */
   MMAL_PARAMETER_EXIF,                      /**< Takes a @ref MMAL_PARAMETER_EXIF_T */
   MMAL_PARAMETER_AWB_MODE,                  /**< Takes a @ref MMAL_PARAM_AWBMODE_T */
   MMAL_PARAMETER_IMAGE_EFFECT,              /**< Takes a @ref MMAL_PARAMETER_IMAGEFX_T */
   MMAL_PARAMETER_COLOUR_EFFECT,             /**< Takes a @ref MMAL_PARAMETER_COLOURFX_T */
   MMAL_PARAMETER_FLICKER_AVOID,             /**< Takes a @ref MMAL_PARAMETER_FLICKERAVOID_T */
   MMAL_PARAMETER_FLASH,                     /**< Takes a @ref MMAL_PARAMETER_FLASH_T */
   MMAL_PARAMETER_REDEYE,                    /**< Takes a @ref MMAL_PARAMETER_REDEYE_T */
   MMAL_PARAMETER_FOCUS,                     /**< Takes a @ref MMAL_PARAMETER_FOCUS_T */
   MMAL_PARAMETER_FOCAL_LENGTHS,             /**< Unused? */
   MMAL_PARAMETER_EXPOSURE_COMP,             /**< Takes a @ref MMAL_PARAMETER_INT32_T or MMAL_PARAMETER_RATIONAL_T */
   MMAL_PARAMETER_ZOOM,                      /**< Takes a @ref MMAL_PARAMETER_SCALEFACTOR_T */
   MMAL_PARAMETER_MIRROR,                    /**< Takes a @ref MMAL_PARAMETER_MIRROR_T */

   /* 0x10 */
   MMAL_PARAMETER_CAMERA_NUM,                /**< Takes a @ref MMAL_PARAMETER_UINT32_T */
   MMAL_PARAMETER_CAPTURE,                   /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */
   MMAL_PARAMETER_EXPOSURE_MODE,             /**< Takes a @ref MMAL_PARAMETER_EXPOSUREMODE_T */
   MMAL_PARAMETER_EXP_METERING_MODE,         /**< Takes a @ref MMAL_PARAMETER_EXPOSUREMETERINGMODE_T */
   MMAL_PARAMETER_FOCUS_STATUS,              /**< Takes a @ref MMAL_PARAMETER_FOCUS_STATUS_T */
   MMAL_PARAMETER_CAMERA_CONFIG,             /**< Takes a @ref MMAL_PARAMETER_CAMERA_CONFIG_T */
   MMAL_PARAMETER_CAPTURE_STATUS,            /**< Takes a @ref MMAL_PARAMETER_CAPTURE_STATUS_T */
   MMAL_PARAMETER_FACE_TRACK,                /**< Takes a @ref MMAL_PARAMETER_FACE_TRACK_T */
   MMAL_PARAMETER_DRAW_BOX_FACES_AND_FOCUS,  /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */
   MMAL_PARAMETER_JPEG_Q_FACTOR,             /**< Takes a @ref MMAL_PARAMETER_UINT32_T */
   MMAL_PARAMETER_FRAME_RATE,                /**< Takes a @ref MMAL_PARAMETER_FRAME_RATE_T */
   MMAL_PARAMETER_USE_STC,                   /**< Takes a @ref MMAL_PARAMETER_CAMERA_STC_MODE_T */
   MMAL_PARAMETER_CAMERA_INFO,               /**< Takes a @ref MMAL_PARAMETER_CAMERA_INFO_T */
   MMAL_PARAMETER_VIDEO_STABILISATION,       /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */
   MMAL_PARAMETER_FACE_TRACK_RESULTS,        /**< Takes a @ref MMAL_PARAMETER_FACE_TRACK_RESULTS_T */
   MMAL_PARAMETER_ENABLE_RAW_CAPTURE,        /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */

   /* 0x20 */
   MMAL_PARAMETER_DPF_FILE,                  /**< Takes a @ref MMAL_PARAMETER_URI_T */
   MMAL_PARAMETER_ENABLE_DPF_FILE,           /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */
   MMAL_PARAMETER_DPF_FAIL_IS_FATAL,         /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */
   MMAL_PARAMETER_CAPTURE_MODE,              /**< Takes a @ref MMAL_PARAMETER_CAPTUREMODE_T */
   MMAL_PARAMETER_FOCUS_REGIONS,             /**< Takes a @ref MMAL_PARAMETER_FOCUS_REGIONS_T */
   MMAL_PARAMETER_INPUT_CROP,                /**< Takes a @ref MMAL_PARAMETER_INPUT_CROP_T */
   MMAL_PARAMETER_SENSOR_INFORMATION,        /**< Takes a @ref MMAL_PARAMETER_SENSOR_INFORMATION_T */
   MMAL_PARAMETER_FLASH_SELECT,              /**< Takes a @ref MMAL_PARAMETER_FLASH_SELECT_T */
   MMAL_PARAMETER_FIELD_OF_VIEW,             /**< Takes a @ref MMAL_PARAMETER_FIELD_OF_VIEW_T */
   MMAL_PARAMETER_HIGH_DYNAMIC_RANGE,        /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */
   MMAL_PARAMETER_DYNAMIC_RANGE_COMPRESSION, /**< Takes a @ref MMAL_PARAMETER_DRC_T */
   MMAL_PARAMETER_ALGORITHM_CONTROL,         /**< Takes a @ref MMAL_PARAMETER_ALGORITHM_CONTROL_T */
   MMAL_PARAMETER_SHARPNESS,                 /**< Takes a @ref MMAL_PARAMETER_RATIONAL_T */
   MMAL_PARAMETER_CONTRAST,                  /**< Takes a @ref MMAL_PARAMETER_RATIONAL_T */
   MMAL_PARAMETER_BRIGHTNESS,                /**< Takes a @ref MMAL_PARAMETER_RATIONAL_T */
   MMAL_PARAMETER_SATURATION,                /**< Takes a @ref MMAL_PARAMETER_RATIONAL_T */

   /* 0x30 */
   MMAL_PARAMETER_ISO,                       /**< Takes a @ref MMAL_PARAMETER_UINT32_T */
   MMAL_PARAMETER_ANTISHAKE,                 /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */
   MMAL_PARAMETER_IMAGE_EFFECT_PARAMETERS,   /**< Takes a @ref MMAL_PARAMETER_IMAGEFX_PARAMETERS_T */
   MMAL_PARAMETER_CAMERA_BURST_CAPTURE,      /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */
   MMAL_PARAMETER_CAMERA_MIN_ISO,            /**< Takes a @ref MMAL_PARAMETER_UINT32_T */
   MMAL_PARAMETER_CAMERA_USE_CASE,           /**< Takes a @ref MMAL_PARAMETER_CAMERA_USE_CASE_T */
   MMAL_PARAMETER_CAPTURE_STATS_PASS,        /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */
   MMAL_PARAMETER_CAMERA_CUSTOM_SENSOR_CONFIG, /**< Takes a @ref MMAL_PARAMETER_UINT32_T */
   MMAL_PARAMETER_ENABLE_REGISTER_FILE,      /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */
   MMAL_PARAMETER_REGISTER_FAIL_IS_FATAL,    /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */
   MMAL_PARAMETER_CONFIGFILE_REGISTERS,      /**< Takes a @ref MMAL_PARAMETER_CONFIGFILE_T */
   MMAL_PARAMETER_CONFIGFILE_CHUNK_REGISTERS,/**< Takes a @ref MMAL_PARAMETER_CONFIGFILE_CHUNK_T */
   MMAL_PARAMETER_JPEG_ATTACH_LOG,           /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */
   MMAL_PARAMETER_ZERO_SHUTTER_LAG,          /**< Takes a @ref MMAL_PARAMETER_ZEROSHUTTERLAG_T */
   MMAL_PARAMETER_FPS_RANGE,                 /**< Takes a @ref MMAL_PARAMETER_FPS_RANGE_T */
   MMAL_PARAMETER_CAPTURE_EXPOSURE_COMP,     /**< Takes a @ref MMAL_PARAMETER_INT32_T */

   /* 0x40 */
   MMAL_PARAMETER_SW_SHARPEN_DISABLE,        /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */
   MMAL_PARAMETER_FLASH_REQUIRED,            /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */
   MMAL_PARAMETER_SW_SATURATION_DISABLE,     /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */
   MMAL_PARAMETER_SHUTTER_SPEED,             /**< Takes a @ref MMAL_PARAMETER_UINT32_T */
   MMAL_PARAMETER_CUSTOM_AWB_GAINS,          /**< Takes a @ref MMAL_PARAMETER_AWB_GAINS_T */
   MMAL_PARAMETER_CAMERA_SETTINGS,           /**< Takes a @ref MMAL_PARAMETER_CAMERA_SETTINGS_T */
   MMAL_PARAMETER_PRIVACY_INDICATOR,         /**< Takes a @ref MMAL_PARAMETER_PRIVACY_INDICATOR_T */
   MMAL_PARAMETER_VIDEO_DENOISE,             /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */
   MMAL_PARAMETER_STILLS_DENOISE,            /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */
   MMAL_PARAMETER_ANNOTATE,                  /**< Takes a @ref MMAL_PARAMETER_CAMERA_ANNOTATE_T */
   MMAL_PARAMETER_STEREOSCOPIC_MODE,         /**< Takes a @ref MMAL_PARAMETER_STEREOSCOPIC_MODE_T */
   MMAL_PARAMETER_CAMERA_INTERFACE,          /**< Takes a @ref MMAL_PARAMETER_CAMERA_INTERFACE_T */
   MMAL_PARAMETER_CAMERA_CLOCKING_MODE,      /**< Takes a @ref MMAL_PARAMETER_CAMERA_CLOCKING_MODE_T */
   MMAL_PARAMETER_CAMERA_RX_CONFIG,          /**< Takes a @ref MMAL_PARAMETER_CAMERA_RX_CONFIG_T */
   MMAL_PARAMETER_CAMERA_RX_TIMING,          /**< Takes a @ref MMAL_PARAMETER_CAMERA_RX_TIMING_T */
   MMAL_PARAMETER_DPF_CONFIG,                /**< Takes a @ref MMAL_PARAMETER_UINT32_T */

   /* 0x50 */
   MMAL_PARAMETER_JPEG_RESTART_INTERVAL,     /**< Takes a @ref MMAL_PARAMETER_UINT32_T */
   MMAL_PARAMETER_CAMERA_ISP_BLOCK_OVERRIDE, /**< Takes a @ref MMAL_PARAMETER_UINT32_T */
   MMAL_PARAMETER_LENS_SHADING_OVERRIDE,     /**< Takes a @ref MMAL_PARAMETER_LENS_SHADING_T */
   MMAL_PARAMETER_BLACK_LEVEL,               /**< Takes a @ref MMAL_PARAMETER_UINT32_T */
   MMAL_PARAMETER_RESIZE_PARAMS,             /**< Takes a @ref MMAL_PARAMETER_RESIZE_T */
   MMAL_PARAMETER_CROP,                      /**< Takes a @ref MMAL_PARAMETER_CROP_T */
   MMAL_PARAMETER_OUTPUT_SHIFT,              /**< Takes a @ref MMAL_PARAMETER_INT32_T */
   MMAL_PARAMETER_CCM_SHIFT,                 /**< Takes a @ref MMAL_PARAMETER_INT32_T */
   MMAL_PARAMETER_CUSTOM_CCM,                /**< Takes a @ref MMAL_PARAMETER_CUSTOM_CCM_T */
   MMAL_PARAMETER_ANALOG_GAIN,               /**< Takes a @ref MMAL_PARAMETER_RATIONAL_T */
   MMAL_PARAMETER_DIGITAL_GAIN,              /**< Takes a @ref MMAL_PARAMETER_RATIONAL_T */
};

/** Thumbnail configuration parameter type */
typedef struct MMAL_PARAMETER_THUMBNAIL_CONFIG_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   uint32_t enable;                  /**< Enable generation of thumbnails during still capture */
   uint32_t width;                   /**< Desired width of the thumbnail */
   uint32_t height;                  /**< Desired height of the thumbnail */
   uint32_t quality;                 /**< Desired compression quality of the thumbnail */
} MMAL_PARAMETER_THUMBNAIL_CONFIG_T;

/** EXIF parameter type. */
typedef struct MMAL_PARAMETER_EXIF_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   uint32_t keylen;                            /**< If 0, assume key is terminated by '=', otherwise length of key and treat data as binary */
   uint32_t value_offset;                      /**< Offset within data buffer of the start of the value. If 0, look for a "key=value" string */
   uint32_t valuelen;                          /**< If 0, assume value is null-terminated, otherwise length of value and treat data as binary */
   uint8_t data[1];                            /**< EXIF key/value string. Variable length */
} MMAL_PARAMETER_EXIF_T;

/** Exposure modes. */
typedef enum
{
   MMAL_PARAM_EXPOSUREMODE_OFF,
   MMAL_PARAM_EXPOSUREMODE_AUTO,
   MMAL_PARAM_EXPOSUREMODE_NIGHT,
   MMAL_PARAM_EXPOSUREMODE_NIGHTPREVIEW,
   MMAL_PARAM_EXPOSUREMODE_BACKLIGHT,
   MMAL_PARAM_EXPOSUREMODE_SPOTLIGHT,
   MMAL_PARAM_EXPOSUREMODE_SPORTS,
   MMAL_PARAM_EXPOSUREMODE_SNOW,
   MMAL_PARAM_EXPOSUREMODE_BEACH,
   MMAL_PARAM_EXPOSUREMODE_VERYLONG,
   MMAL_PARAM_EXPOSUREMODE_FIXEDFPS,
   MMAL_PARAM_EXPOSUREMODE_ANTISHAKE,
   MMAL_PARAM_EXPOSUREMODE_FIREWORKS,
   MMAL_PARAM_EXPOSUREMODE_MAX = 0x7fffffff
} MMAL_PARAM_EXPOSUREMODE_T;

typedef struct MMAL_PARAMETER_EXPOSUREMODE_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_PARAM_EXPOSUREMODE_T value;   /**< exposure mode */
} MMAL_PARAMETER_EXPOSUREMODE_T;

typedef enum
{
   MMAL_PARAM_EXPOSUREMETERINGMODE_AVERAGE,
   MMAL_PARAM_EXPOSUREMETERINGMODE_SPOT,
   MMAL_PARAM_EXPOSUREMETERINGMODE_BACKLIT,
   MMAL_PARAM_EXPOSUREMETERINGMODE_MATRIX,
   MMAL_PARAM_EXPOSUREMETERINGMODE_MAX = 0x7fffffff
} MMAL_PARAM_EXPOSUREMETERINGMODE_T;

typedef struct MMAL_PARAMETER_EXPOSUREMETERINGMODE_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_PARAM_EXPOSUREMETERINGMODE_T value;   /**< metering mode */
} MMAL_PARAMETER_EXPOSUREMETERINGMODE_T;

/** AWB parameter modes. */
typedef enum MMAL_PARAM_AWBMODE_T
{
   MMAL_PARAM_AWBMODE_OFF,
   MMAL_PARAM_AWBMODE_AUTO,
   MMAL_PARAM_AWBMODE_SUNLIGHT,
   MMAL_PARAM_AWBMODE_CLOUDY,
   MMAL_PARAM_AWBMODE_SHADE,
   MMAL_PARAM_AWBMODE_TUNGSTEN,
   MMAL_PARAM_AWBMODE_FLUORESCENT,
   MMAL_PARAM_AWBMODE_INCANDESCENT,
   MMAL_PARAM_AWBMODE_FLASH,
   MMAL_PARAM_AWBMODE_HORIZON,
   MMAL_PARAM_AWBMODE_MAX = 0x7fffffff
} MMAL_PARAM_AWBMODE_T;

/** AWB parameter type. */
typedef struct MMAL_PARAMETER_AWBMODE_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_PARAM_AWBMODE_T value;   /**< AWB mode */
} MMAL_PARAMETER_AWBMODE_T;

/** Image effect */
typedef enum MMAL_PARAM_IMAGEFX_T
{
   MMAL_PARAM_IMAGEFX_NONE,
   MMAL_PARAM_IMAGEFX_NEGATIVE,
   MMAL_PARAM_IMAGEFX_SOLARIZE,
   MMAL_PARAM_IMAGEFX_POSTERIZE,
   MMAL_PARAM_IMAGEFX_WHITEBOARD,
   MMAL_PARAM_IMAGEFX_BLACKBOARD,
   MMAL_PARAM_IMAGEFX_SKETCH,
   MMAL_PARAM_IMAGEFX_DENOISE,
   MMAL_PARAM_IMAGEFX_EMBOSS,
   MMAL_PARAM_IMAGEFX_OILPAINT,
   MMAL_PARAM_IMAGEFX_HATCH,
   MMAL_PARAM_IMAGEFX_GPEN,
   MMAL_PARAM_IMAGEFX_PASTEL,
   MMAL_PARAM_IMAGEFX_WATERCOLOUR,
   MMAL_PARAM_IMAGEFX_FILM,
   MMAL_PARAM_IMAGEFX_BLUR,
   MMAL_PARAM_IMAGEFX_SATURATION,
   MMAL_PARAM_IMAGEFX_COLOURSWAP,
   MMAL_PARAM_IMAGEFX_WASHEDOUT,
   MMAL_PARAM_IMAGEFX_POSTERISE,
   MMAL_PARAM_IMAGEFX_COLOURPOINT,
   MMAL_PARAM_IMAGEFX_COLOURBALANCE,
   MMAL_PARAM_IMAGEFX_CARTOON,
   MMAL_PARAM_IMAGEFX_DEINTERLACE_DOUBLE,
   MMAL_PARAM_IMAGEFX_DEINTERLACE_ADV,
   MMAL_PARAM_IMAGEFX_DEINTERLACE_FAST,
   MMAL_PARAM_IMAGEFX_MAX = 0x7fffffff
} MMAL_PARAM_IMAGEFX_T;

typedef struct MMAL_PARAMETER_IMAGEFX_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_PARAM_IMAGEFX_T value;   /**< Image effect mode */
} MMAL_PARAMETER_IMAGEFX_T;

#define MMAL_MAX_IMAGEFX_PARAMETERS 6  /* Image effects library currently uses a maximum of 5 parameters per effect */

typedef struct MMAL_PARAMETER_IMAGEFX_PARAMETERS_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_PARAM_IMAGEFX_T effect;   /**< Image effect mode */
   uint32_t num_effect_params;     /**< Number of used elements in */
   uint32_t effect_parameter[MMAL_MAX_IMAGEFX_PARAMETERS]; /**< Array of parameters */
} MMAL_PARAMETER_IMAGEFX_PARAMETERS_T;

/** Colour effect parameter type*/
typedef struct MMAL_PARAMETER_COLOURFX_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   int32_t enable;
   uint32_t u;
   uint32_t v;
} MMAL_PARAMETER_COLOURFX_T;

typedef enum MMAL_CAMERA_STC_MODE_T
{
   MMAL_PARAM_STC_MODE_OFF,         /**< Frames do not have STCs, as needed in OpenMAX/IL */
   MMAL_PARAM_STC_MODE_RAW,         /**< Use raw clock STC, needed for true pause/resume support */
   MMAL_PARAM_STC_MODE_COOKED,      /**< Start the STC from the start of capture, only for quick demo code */
   MMAL_PARAM_STC_MODE_MAX = 0x7fffffff
} MMAL_CAMERA_STC_MODE_T;

typedef struct MMAL_PARAMETER_CAMERA_STC_MODE_T
{
   MMAL_PARAMETER_HEADER_T hdr;
   MMAL_CAMERA_STC_MODE_T value;
} MMAL_PARAMETER_CAMERA_STC_MODE_T;

typedef enum MMAL_PARAM_FLICKERAVOID_T
{
   MMAL_PARAM_FLICKERAVOID_OFF,
   MMAL_PARAM_FLICKERAVOID_AUTO,
   MMAL_PARAM_FLICKERAVOID_50HZ,
   MMAL_PARAM_FLICKERAVOID_60HZ,
   MMAL_PARAM_FLICKERAVOID_MAX = 0x7FFFFFFF
} MMAL_PARAM_FLICKERAVOID_T;

typedef struct MMAL_PARAMETER_FLICKERAVOID_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_PARAM_FLICKERAVOID_T value;   /**< Flicker avoidance mode */
} MMAL_PARAMETER_FLICKERAVOID_T;

typedef enum MMAL_PARAM_FLASH_T
{
   MMAL_PARAM_FLASH_OFF,
   MMAL_PARAM_FLASH_AUTO,
   MMAL_PARAM_FLASH_ON,
   MMAL_PARAM_FLASH_REDEYE,
   MMAL_PARAM_FLASH_FILLIN,
   MMAL_PARAM_FLASH_TORCH,
   MMAL_PARAM_FLASH_MAX = 0x7FFFFFFF
} MMAL_PARAM_FLASH_T;

typedef struct MMAL_PARAMETER_FLASH_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_PARAM_FLASH_T value;   /**< Flash mode */
} MMAL_PARAMETER_FLASH_T;

typedef enum MMAL_PARAM_REDEYE_T
{
   MMAL_PARAM_REDEYE_OFF,
   MMAL_PARAM_REDEYE_ON,
   MMAL_PARAM_REDEYE_SIMPLE,
   MMAL_PARAM_REDEYE_MAX = 0x7FFFFFFF
} MMAL_PARAM_REDEYE_T;

typedef struct MMAL_PARAMETER_REDEYE_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_PARAM_REDEYE_T value;   /**< Red eye reduction mode */
} MMAL_PARAMETER_REDEYE_T;

typedef enum MMAL_PARAM_FOCUS_T
{
   MMAL_PARAM_FOCUS_AUTO,
   MMAL_PARAM_FOCUS_AUTO_NEAR,
   MMAL_PARAM_FOCUS_AUTO_MACRO,
   MMAL_PARAM_FOCUS_CAF,
   MMAL_PARAM_FOCUS_CAF_NEAR,
   MMAL_PARAM_FOCUS_FIXED_INFINITY,
   MMAL_PARAM_FOCUS_FIXED_HYPERFOCAL,
   MMAL_PARAM_FOCUS_FIXED_NEAR,
   MMAL_PARAM_FOCUS_FIXED_MACRO,
   MMAL_PARAM_FOCUS_EDOF,
   MMAL_PARAM_FOCUS_CAF_MACRO,
   MMAL_PARAM_FOCUS_CAF_FAST,
   MMAL_PARAM_FOCUS_CAF_NEAR_FAST,
   MMAL_PARAM_FOCUS_CAF_MACRO_FAST,
   MMAL_PARAM_FOCUS_FIXED_CURRENT,
   MMAL_PARAM_FOCUS_MAX = 0x7FFFFFFF
} MMAL_PARAM_FOCUS_T;

typedef struct MMAL_PARAMETER_FOCUS_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_PARAM_FOCUS_T value;   /**< Focus mode */
} MMAL_PARAMETER_FOCUS_T;

typedef enum MMAL_PARAM_CAPTURE_STATUS_T
{
   MMAL_PARAM_CAPTURE_STATUS_NOT_CAPTURING,
   MMAL_PARAM_CAPTURE_STATUS_CAPTURE_STARTED,
   MMAL_PARAM_CAPTURE_STATUS_CAPTURE_ENDED,

   MMAL_PARAM_CAPTURE_STATUS_MAX = 0x7FFFFFFF
} MMAL_PARAM_CAPTURE_STATUS_T;

typedef struct MMAL_PARAMETER_CAPTURE_STATUS_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_PARAM_CAPTURE_STATUS_T status;   /**< Capture status */
} MMAL_PARAMETER_CAPTURE_STATUS_T;

typedef enum MMAL_PARAM_FOCUS_STATUS_T
{
   MMAL_PARAM_FOCUS_STATUS_OFF,
   MMAL_PARAM_FOCUS_STATUS_REQUEST,
   MMAL_PARAM_FOCUS_STATUS_REACHED,
   MMAL_PARAM_FOCUS_STATUS_UNABLE_TO_REACH,
   MMAL_PARAM_FOCUS_STATUS_LOST,
   MMAL_PARAM_FOCUS_STATUS_CAF_MOVING,
   MMAL_PARAM_FOCUS_STATUS_CAF_SUCCESS,
   MMAL_PARAM_FOCUS_STATUS_CAF_FAILED,
   MMAL_PARAM_FOCUS_STATUS_MANUAL_MOVING,
   MMAL_PARAM_FOCUS_STATUS_MANUAL_REACHED,
   MMAL_PARAM_FOCUS_STATUS_CAF_WATCHING,
   MMAL_PARAM_FOCUS_STATUS_CAF_SCENE_CHANGED,

   MMAL_PARAM_FOCUS_STATUS_MAX = 0x7FFFFFFF
} MMAL_PARAM_FOCUS_STATUS_T;

typedef struct MMAL_PARAMETER_FOCUS_STATUS_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_PARAM_FOCUS_STATUS_T status;   /**< Focus status */
} MMAL_PARAMETER_FOCUS_STATUS_T;

typedef enum MMAL_PARAM_FACE_TRACK_MODE_T
{
   MMAL_PARAM_FACE_DETECT_NONE,                           /**< Disables face detection */
   MMAL_PARAM_FACE_DETECT_ON,                             /**< Enables face detection */
   MMAL_PARAM_FACE_DETECT_MAX = 0x7FFFFFFF
} MMAL_PARAM_FACE_TRACK_MODE_T;

typedef struct MMAL_PARAMETER_FACE_TRACK_T /* face tracking control */
{
   MMAL_PARAMETER_HEADER_T hdr;
   MMAL_PARAM_FACE_TRACK_MODE_T mode;
   uint32_t maxRegions;
   uint32_t frames;
   uint32_t quality;
} MMAL_PARAMETER_FACE_TRACK_T;

typedef struct MMAL_PARAMETER_FACE_TRACK_FACE_T /* face tracking face information */
{
   int32_t     face_id;             /**< Face ID. Should remain the same whilst the face is detected to remain in the scene */
   int32_t     score;               /**< Confidence of the face detection. Range 1-100 (1=unsure, 100=positive). */
   MMAL_RECT_T face_rect;           /**< Rectangle around the whole face */

   MMAL_RECT_T eye_rect[2];         /**< Rectangle around the eyes ([0] = left eye, [1] = right eye) */
   MMAL_RECT_T mouth_rect;          /**< Rectangle around the mouth */
} MMAL_PARAMETER_FACE_TRACK_FACE_T;

typedef struct MMAL_PARAMETER_FACE_TRACK_RESULTS_T /* face tracking results */
{
   MMAL_PARAMETER_HEADER_T hdr;

   uint32_t num_faces;        /**< Number of faces detected */
   uint32_t frame_width;      /**< Width of the frame on which the faces were detected (allows scaling) */
   uint32_t frame_height;     /**< Height of the frame on which the faces were detected (allows scaling) */

   MMAL_PARAMETER_FACE_TRACK_FACE_T faces[1];   /**< Face information (variable length array */
} MMAL_PARAMETER_FACE_TRACK_RESULTS_T;

typedef enum MMAL_PARAMETER_CAMERA_CONFIG_TIMESTAMP_MODE_T
{
   MMAL_PARAM_TIMESTAMP_MODE_ZERO,           /**< Always timestamp frames as 0 */
   MMAL_PARAM_TIMESTAMP_MODE_RAW_STC,        /**< Use the raw STC value for the frame timestamp */
   MMAL_PARAM_TIMESTAMP_MODE_RESET_STC,      /**< Use the STC timestamp but subtract the timestamp
                                              * of the first frame sent to give a zero based timestamp.
                                              */
   MMAL_PARAM_TIMESTAMP_MODE_MAX = 0x7FFFFFFF
} MMAL_PARAMETER_CAMERA_CONFIG_TIMESTAMP_MODE_T;

typedef struct MMAL_PARAMETER_CAMERA_CONFIG_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   /* Parameters for setting up the image pools */
   uint32_t max_stills_w;        /**< Max size of stills capture */
   uint32_t max_stills_h;
   uint32_t stills_yuv422;       /**< Allow YUV422 stills capture */
   uint32_t one_shot_stills;     /**< Continuous or one shot stills captures. */

   uint32_t max_preview_video_w; /**< Max size of the preview or video capture frames */
   uint32_t max_preview_video_h;
   uint32_t num_preview_video_frames;

   uint32_t stills_capture_circular_buffer_height; /**< Sets the height of the circular buffer for stills capture. */

   uint32_t fast_preview_resume;    /**< Allows preview/encode to resume as fast as possible after the stills input frame
                                     * has been received, and then processes the still frame in the background
                                     * whilst preview/encode has resumed.
                                     * Actual mode is controlled by MMAL_PARAMETER_CAPTURE_MODE.
                                     */

   MMAL_PARAMETER_CAMERA_CONFIG_TIMESTAMP_MODE_T use_stc_timestamp;
                                    /**< Selects algorithm for timestamping frames if there is no clock component connected.
                                      */


} MMAL_PARAMETER_CAMERA_CONFIG_T;

#define MMAL_PARAMETER_CAMERA_INFO_MAX_CAMERAS 4
#define MMAL_PARAMETER_CAMERA_INFO_MAX_FLASHES 2
#define MMAL_PARAMETER_CAMERA_INFO_MAX_STR_LEN 16

typedef struct MMAL_PARAMETER_CAMERA_INFO_CAMERA_T
{
   uint32_t    port_id;
   uint32_t    max_width;
   uint32_t    max_height;
   MMAL_BOOL_T lens_present;
   char        camera_name[MMAL_PARAMETER_CAMERA_INFO_MAX_STR_LEN];
} MMAL_PARAMETER_CAMERA_INFO_CAMERA_T;

typedef enum MMAL_PARAMETER_CAMERA_INFO_FLASH_TYPE_T
{
   MMAL_PARAMETER_CAMERA_INFO_FLASH_TYPE_XENON = 0, /* Make values explicit */
   MMAL_PARAMETER_CAMERA_INFO_FLASH_TYPE_LED   = 1, /* to ensure they match */
   MMAL_PARAMETER_CAMERA_INFO_FLASH_TYPE_OTHER = 2, /* values in config ini */
   MMAL_PARAMETER_CAMERA_INFO_FLASH_TYPE_MAX = 0x7FFFFFFF
} MMAL_PARAMETER_CAMERA_INFO_FLASH_TYPE_T;

typedef struct MMAL_PARAMETER_CAMERA_INFO_FLASH_T
{
   MMAL_PARAMETER_CAMERA_INFO_FLASH_TYPE_T flash_type;
} MMAL_PARAMETER_CAMERA_INFO_FLASH_T;

typedef struct MMAL_PARAMETER_CAMERA_INFO_T
{
   MMAL_PARAMETER_HEADER_T             hdr;
   uint32_t                            num_cameras;
   uint32_t                            num_flashes;
   MMAL_PARAMETER_CAMERA_INFO_CAMERA_T cameras[MMAL_PARAMETER_CAMERA_INFO_MAX_CAMERAS];
   MMAL_PARAMETER_CAMERA_INFO_FLASH_T  flashes[MMAL_PARAMETER_CAMERA_INFO_MAX_FLASHES];
} MMAL_PARAMETER_CAMERA_INFO_T;

typedef enum MMAL_PARAMETER_CAPTUREMODE_MODE_T
{
   MMAL_PARAM_CAPTUREMODE_WAIT_FOR_END,            /**< Resumes preview once capture is completed. */
   MMAL_PARAM_CAPTUREMODE_WAIT_FOR_END_AND_HOLD,   /**< Resumes preview once capture is completed, and hold the image for subsequent reprocessing. */
   MMAL_PARAM_CAPTUREMODE_RESUME_VF_IMMEDIATELY,   /**< Resumes preview as soon as possible once capture frame is received from the sensor.
                                                    *   Requires fast_preview_resume to be set via MMAL_PARAMETER_CAMERA_CONFIG.
                                                    */
} MMAL_PARAMETER_CAPTUREMODE_MODE_T;

/** Stills capture mode control. */
typedef struct MMAL_PARAMETER_CAPTUREMODE_T
{
   MMAL_PARAMETER_HEADER_T hdr;
   MMAL_PARAMETER_CAPTUREMODE_MODE_T mode;
} MMAL_PARAMETER_CAPTUREMODE_T;

typedef enum MMAL_PARAMETER_FOCUS_REGION_TYPE_T
{
   MMAL_PARAMETER_FOCUS_REGION_TYPE_NORMAL,     /**< Region defines a generic region */
   MMAL_PARAMETER_FOCUS_REGION_TYPE_FACE,       /**< Region defines a face */
   MMAL_PARAMETER_FOCUS_REGION_TYPE_MAX
} MMAL_PARAMETER_FOCUS_REGION_TYPE_T;

typedef struct MMAL_PARAMETER_FOCUS_REGION_T
{
   MMAL_RECT_T rect;    /**< Focus rectangle as 0P16 fixed point values. */
   uint32_t weight;     /**< Region weighting. */
   uint32_t mask;       /**< Mask for multi-stage regions */
   MMAL_PARAMETER_FOCUS_REGION_TYPE_T type;  /**< Region type */
} MMAL_PARAMETER_FOCUS_REGION_T;

typedef struct MMAL_PARAMETER_FOCUS_REGIONS_T
{
   MMAL_PARAMETER_HEADER_T          hdr;
   uint32_t                         num_regions;      /**< Number of regions defined */
   MMAL_BOOL_T                      lock_to_faces;    /**< If region is within tolerance of a face, adopt face rect instead of defined region */
   MMAL_PARAMETER_FOCUS_REGION_T    regions[1];       /**< Variable number of regions */
} MMAL_PARAMETER_FOCUS_REGIONS_T;

typedef struct MMAL_PARAMETER_INPUT_CROP_T
{
   MMAL_PARAMETER_HEADER_T hdr;
   MMAL_RECT_T             rect;    /**< Crop rectangle as 16P16 fixed point values */
} MMAL_PARAMETER_INPUT_CROP_T;

typedef struct MMAL_PARAMETER_SENSOR_INFORMATION_T
{
   MMAL_PARAMETER_HEADER_T          hdr;
   MMAL_RATIONAL_T                  f_number;         /**< Lens f-number */
   MMAL_RATIONAL_T                  focal_length;     /**< Lens focal length */
   uint32_t                         model_id;         /**< Sensor reported model id */
   uint32_t                         manufacturer_id;  /**< Sensor reported manufacturer id */
   uint32_t                         revision;         /**< Sensor reported revision */
} MMAL_PARAMETER_SENSOR_INFORMATION_T;

typedef struct MMAL_PARAMETER_FLASH_SELECT_T
{
   MMAL_PARAMETER_HEADER_T          hdr;
   MMAL_PARAMETER_CAMERA_INFO_FLASH_TYPE_T flash_type;   /**< Flash type to use */
} MMAL_PARAMETER_FLASH_SELECT_T;

typedef struct MMAL_PARAMETER_FIELD_OF_VIEW_T
{
   MMAL_PARAMETER_HEADER_T          hdr;
   MMAL_RATIONAL_T                  fov_h;         /**< Horizontal field of view */
   MMAL_RATIONAL_T                  fov_v;         /**< Vertical field of view */
} MMAL_PARAMETER_FIELD_OF_VIEW_T;

typedef enum MMAL_PARAMETER_DRC_STRENGTH_T
{
   MMAL_PARAMETER_DRC_STRENGTH_OFF,
   MMAL_PARAMETER_DRC_STRENGTH_LOW,
   MMAL_PARAMETER_DRC_STRENGTH_MEDIUM,
   MMAL_PARAMETER_DRC_STRENGTH_HIGH,
   MMAL_PARAMETER_DRC_STRENGTH_MAX = 0x7fffffff
} MMAL_PARAMETER_DRC_STRENGTH_T;

typedef struct MMAL_PARAMETER_DRC_T
{
   MMAL_PARAMETER_HEADER_T          hdr;
   MMAL_PARAMETER_DRC_STRENGTH_T    strength;      /**< DRC strength */
} MMAL_PARAMETER_DRC_T;

typedef enum MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T
{
   MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_FACETRACKING,
   MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_REDEYE_REDUCTION,
   MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_VIDEO_STABILISATION,
   MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_WRITE_RAW,
   MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_VIDEO_DENOISE,
   MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_STILLS_DENOISE,
   MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_TEMPORAL_DENOISE,
   MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_ANTISHAKE,
   MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_IMAGE_EFFECTS,
   MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_DYNAMIC_RANGE_COMPRESSION,
   MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_FACE_RECOGNITION,
   MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_FACE_BEAUTIFICATION,
   MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_SCENE_DETECTION,
   MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_HIGH_DYNAMIC_RANGE,
   MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_MAX = 0x7fffffff
} MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T;

typedef struct MMAL_PARAMETER_ALGORITHM_CONTROL_T
{
   MMAL_PARAMETER_HEADER_T          hdr;
   MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T algorithm;
   MMAL_BOOL_T                      enabled;
} MMAL_PARAMETER_ALGORITHM_CONTROL_T;


typedef enum MMAL_PARAM_CAMERA_USE_CASE_T
{
   MMAL_PARAM_CAMERA_USE_CASE_UNKNOWN,             /**< Compromise on behaviour as use case totally unknown */
   MMAL_PARAM_CAMERA_USE_CASE_STILLS_CAPTURE,      /**< Stills capture use case */
   MMAL_PARAM_CAMERA_USE_CASE_VIDEO_CAPTURE,       /**< Video encode (camcorder) use case */

   MMAL_PARAM_CAMERA_USE_CASE_MAX = 0x7fffffff
} MMAL_PARAM_CAMERA_USE_CASE_T;

typedef struct MMAL_PARAMETER_CAMERA_USE_CASE_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_PARAM_CAMERA_USE_CASE_T use_case;   /**< Use case */
} MMAL_PARAMETER_CAMERA_USE_CASE_T;

typedef struct MMAL_PARAMETER_FPS_RANGE_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_RATIONAL_T   fps_low;                /**< Low end of the permitted framerate range */
   MMAL_RATIONAL_T   fps_high;               /**< High end of the permitted framerate range */
} MMAL_PARAMETER_FPS_RANGE_T;

typedef struct MMAL_PARAMETER_ZEROSHUTTERLAG_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_BOOL_T zero_shutter_lag_mode;        /**< Select zero shutter lag mode from sensor */
   MMAL_BOOL_T concurrent_capture;           /**< Activate full zero shutter lag mode and
                                              *  use the last preview raw image for the stills capture
                                              */
} MMAL_PARAMETER_ZEROSHUTTERLAG_T;

typedef struct MMAL_PARAMETER_AWB_GAINS_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_RATIONAL_T r_gain;                   /**< Red gain */
   MMAL_RATIONAL_T b_gain;                   /**< Blue gain */
} MMAL_PARAMETER_AWB_GAINS_T;

typedef struct MMAL_PARAMETER_CAMERA_SETTINGS_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   uint32_t exposure;
   MMAL_RATIONAL_T analog_gain;
   MMAL_RATIONAL_T digital_gain;
   MMAL_RATIONAL_T awb_red_gain;
   MMAL_RATIONAL_T awb_blue_gain;
   uint32_t focus_position;
} MMAL_PARAMETER_CAMERA_SETTINGS_T;

typedef enum MMAL_PARAM_PRIVACY_INDICATOR_T
{
   MMAL_PARAMETER_PRIVACY_INDICATOR_OFF,        /**< Indicator will be off. */
   MMAL_PARAMETER_PRIVACY_INDICATOR_ON,         /**< Indicator will come on just after a stills capture and
                                                 *   and remain on for 2seconds, or will be on whilst output[1]
                                                 *   is actively producing images.
                                                 */
   MMAL_PARAMETER_PRIVACY_INDICATOR_FORCE_ON,   /**< Turns indicator of for 2s independent of capture status.
                                                 *   Set this mode repeatedly to keep the indicator on for a
                                                 *   longer period.
                                                 */
   MMAL_PARAMETER_PRIVACY_INDICATOR_MAX = 0x7fffffff
} MMAL_PARAM_PRIVACY_INDICATOR_T;

typedef struct MMAL_PARAMETER_PRIVACY_INDICATOR_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_PARAM_PRIVACY_INDICATOR_T mode;
} MMAL_PARAMETER_PRIVACY_INDICATOR_T;

#define MMAL_CAMERA_ANNOTATE_MAX_TEXT_LEN 32
typedef struct MMAL_PARAMETER_CAMERA_ANNOTATE_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_BOOL_T enable;
   char text[MMAL_CAMERA_ANNOTATE_MAX_TEXT_LEN];
   MMAL_BOOL_T show_shutter;
   MMAL_BOOL_T show_analog_gain;
   MMAL_BOOL_T show_lens;
   MMAL_BOOL_T show_caf;
   MMAL_BOOL_T show_motion;
} MMAL_PARAMETER_CAMERA_ANNOTATE_T;

#define MMAL_CAMERA_ANNOTATE_MAX_TEXT_LEN_V2 256
typedef struct MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_BOOL_T enable;
   MMAL_BOOL_T show_shutter;
   MMAL_BOOL_T show_analog_gain;
   MMAL_BOOL_T show_lens;
   MMAL_BOOL_T show_caf;
   MMAL_BOOL_T show_motion;
   MMAL_BOOL_T show_frame_num;
   MMAL_BOOL_T black_text_background;
   char text[MMAL_CAMERA_ANNOTATE_MAX_TEXT_LEN_V2];
} MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T;

#define MMAL_CAMERA_ANNOTATE_MAX_TEXT_LEN_V3 256
typedef struct MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_BOOL_T enable;
   MMAL_BOOL_T show_shutter;
   MMAL_BOOL_T show_analog_gain;
   MMAL_BOOL_T show_lens;
   MMAL_BOOL_T show_caf;
   MMAL_BOOL_T show_motion;
   MMAL_BOOL_T show_frame_num;
   MMAL_BOOL_T enable_text_background;
   MMAL_BOOL_T custom_background_colour;
   uint8_t     custom_background_Y;
   uint8_t     custom_background_U;
   uint8_t     custom_background_V;
   uint8_t     dummy1;
   MMAL_BOOL_T custom_text_colour;
   uint8_t     custom_text_Y;
   uint8_t     custom_text_U;
   uint8_t     custom_text_V;
   uint8_t     text_size;
   char text[MMAL_CAMERA_ANNOTATE_MAX_TEXT_LEN_V3];
} MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T;

#define MMAL_CAMERA_ANNOTATE_MAX_TEXT_LEN_V4 256
typedef struct MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_BOOL_T enable;
   MMAL_BOOL_T show_shutter;
   MMAL_BOOL_T show_analog_gain;
   MMAL_BOOL_T show_lens;
   MMAL_BOOL_T show_caf;
   MMAL_BOOL_T show_motion;
   MMAL_BOOL_T show_frame_num;
   MMAL_BOOL_T enable_text_background;
   MMAL_BOOL_T custom_background_colour;
   uint8_t     custom_background_Y;
   uint8_t     custom_background_U;
   uint8_t     custom_background_V;
   uint8_t     dummy1;
   MMAL_BOOL_T custom_text_colour;
   uint8_t     custom_text_Y;
   uint8_t     custom_text_U;
   uint8_t     custom_text_V;
   uint8_t     text_size;
   char text[MMAL_CAMERA_ANNOTATE_MAX_TEXT_LEN_V3];
   uint32_t    justify; //0=centre, 1=left, 2=right
   uint32_t    x_offset; //Offset from the justification edge
   uint32_t    y_offset;
} MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T;

typedef enum MMAL_STEREOSCOPIC_MODE_T {
   MMAL_STEREOSCOPIC_MODE_NONE = 0,
   MMAL_STEREOSCOPIC_MODE_SIDE_BY_SIDE = 1,
   MMAL_STEREOSCOPIC_MODE_TOP_BOTTOM = 2,
   MMAL_STEREOSCOPIC_MODE_MAX = 0x7FFFFFFF,
} MMAL_STEREOSCOPIC_MODE_T;

typedef struct MMAL_PARAMETER_STEREOSCOPIC_MODE_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_STEREOSCOPIC_MODE_T mode;
   MMAL_BOOL_T decimate;
   MMAL_BOOL_T swap_eyes;
} MMAL_PARAMETER_STEREOSCOPIC_MODE_T;

typedef enum MMAL_CAMERA_INTERFACE_T {
   MMAL_CAMERA_INTERFACE_CSI2 = 0,
   MMAL_CAMERA_INTERFACE_CCP2 = 1,
   MMAL_CAMERA_INTERFACE_CPI = 2,
   MMAL_CAMERA_INTERFACE_MAX = 0x7FFFFFFF,
} MMAL_CAMERA_INTERFACE_T;

typedef struct MMAL_PARAMETER_CAMERA_INTERFACE_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_CAMERA_INTERFACE_T mode;
} MMAL_PARAMETER_CAMERA_INTERFACE_T;

typedef enum MMAL_CAMERA_CLOCKING_MODE_T {
   MMAL_CAMERA_CLOCKING_MODE_STROBE = 0,
   MMAL_CAMERA_CLOCKING_MODE_CLOCK = 1,
   MMAL_CAMERA_CLOCKING_MODE_MAX = 0x7FFFFFFF,
} MMAL_CAMERA_CLOCKING_MODE_T;

typedef struct MMAL_PARAMETER_CAMERA_CLOCKING_MODE_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_CAMERA_CLOCKING_MODE_T mode;
} MMAL_PARAMETER_CAMERA_CLOCKING_MODE_T;

typedef enum MMAL_CAMERA_RX_CONFIG_DECODE {
   MMAL_CAMERA_RX_CONFIG_DECODE_NONE = 0,
   MMAL_CAMERA_RX_CONFIG_DECODE_DPCM8TO10 = 1,
   MMAL_CAMERA_RX_CONFIG_DECODE_DPCM7TO10 = 2,
   MMAL_CAMERA_RX_CONFIG_DECODE_DPCM6TO10 = 3,
   MMAL_CAMERA_RX_CONFIG_DECODE_DPCM8TO12 = 4,
   MMAL_CAMERA_RX_CONFIG_DECODE_DPCM7TO12 = 5,
   MMAL_CAMERA_RX_CONFIG_DECODE_DPCM6TO12 = 6,
   MMAL_CAMERA_RX_CONFIG_DECODE_DPCM10TO14 = 7,
   MMAL_CAMERA_RX_CONFIG_DECODE_DPCM8TO14 = 8,
   MMAL_CAMERA_RX_CONFIG_DECODE_DPCM12TO16 = 9,
   MMAL_CAMERA_RX_CONFIG_DECODE_DPCM10TO16 = 10,
   MMAL_CAMERA_RX_CONFIG_DECODE_DPCM8TO16 = 11,
   MMAL_CAMERA_RX_CONFIG_DECODE_MAX = 0x7FFFFFFF
} MMAL_CAMERA_RX_CONFIG_DECODE;

typedef enum MMAL_CAMERA_RX_CONFIG_ENCODE {
   MMAL_CAMERA_RX_CONFIG_ENCODE_NONE = 0,
   MMAL_CAMERA_RX_CONFIG_ENCODE_DPCM10TO8 = 1,
   MMAL_CAMERA_RX_CONFIG_ENCODE_DPCM12TO8 = 2,
   MMAL_CAMERA_RX_CONFIG_ENCODE_DPCM14TO8 = 3,
   MMAL_CAMERA_RX_CONFIG_ENCODE_MAX = 0x7FFFFFFF
} MMAL_CAMERA_RX_CONFIG_ENCODE;

typedef enum MMAL_CAMERA_RX_CONFIG_UNPACK {
   MMAL_CAMERA_RX_CONFIG_UNPACK_NONE = 0,
   MMAL_CAMERA_RX_CONFIG_UNPACK_6 = 1,
   MMAL_CAMERA_RX_CONFIG_UNPACK_7 = 2,
   MMAL_CAMERA_RX_CONFIG_UNPACK_8 = 3,
   MMAL_CAMERA_RX_CONFIG_UNPACK_10 = 4,
   MMAL_CAMERA_RX_CONFIG_UNPACK_12 = 5,
   MMAL_CAMERA_RX_CONFIG_UNPACK_14 = 6,
   MMAL_CAMERA_RX_CONFIG_UNPACK_16 = 7,
   MMAL_CAMERA_RX_CONFIG_UNPACK_MAX = 0x7FFFFFFF
} MMAL_CAMERA_RX_CONFIG_UNPACK;

typedef enum MMAL_CAMERA_RX_CONFIG_PACK {
   MMAL_CAMERA_RX_CONFIG_PACK_NONE = 0,
   MMAL_CAMERA_RX_CONFIG_PACK_8 = 1,
   MMAL_CAMERA_RX_CONFIG_PACK_10 = 2,
   MMAL_CAMERA_RX_CONFIG_PACK_12 = 3,
   MMAL_CAMERA_RX_CONFIG_PACK_14 = 4,
   MMAL_CAMERA_RX_CONFIG_PACK_16 = 5,
   MMAL_CAMERA_RX_CONFIG_PACK_RAW10 = 6,
   MMAL_CAMERA_RX_CONFIG_PACK_RAW12 = 7,
   MMAL_CAMERA_RX_CONFIG_PACK_MAX = 0x7FFFFFFF
} MMAL_CAMERA_RX_CONFIG_PACK;

typedef struct MMAL_PARAMETER_CAMERA_RX_CONFIG_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_CAMERA_RX_CONFIG_DECODE decode;
   MMAL_CAMERA_RX_CONFIG_ENCODE encode;
   MMAL_CAMERA_RX_CONFIG_UNPACK unpack;
   MMAL_CAMERA_RX_CONFIG_PACK pack;
   uint32_t data_lanes;
   uint32_t encode_block_length;
   uint32_t embedded_data_lines;
   uint32_t image_id;
} MMAL_PARAMETER_CAMERA_RX_CONFIG_T;

typedef struct MMAL_PARAMETER_CAMERA_RX_TIMING_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   uint32_t timing1;
   uint32_t timing2;
   uint32_t timing3;
   uint32_t timing4;
   uint32_t timing5;
   uint32_t term1;
   uint32_t term2;
   uint32_t cpi_timing1;
   uint32_t cpi_timing2;
} MMAL_PARAMETER_CAMERA_RX_TIMING_T;

typedef struct MMAL_PARAMETER_LENS_SHADING_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_BOOL_T enabled;
   uint32_t grid_cell_size;
   uint32_t grid_width;
   uint32_t grid_stride;
   uint32_t grid_height;
   uint32_t mem_handle_table;
   uint32_t ref_transform;
} MMAL_PARAMETER_LENS_SHADING_T;

/*
The mode determines the kind of resize.
MMAL_RESIZE_BOX allow the max_width and max_height to set a bounding box into
which the output must fit.
MMAL_RESIZE_BYTES allows max_bytes to set the maximum number of bytes into which the
full output frame must fit.  Two flags aid the setting of the output
size. preserve_aspect_ratio sets whether the resize should
preserve the aspect ratio of the incoming
image. allow_upscaling sets whether the resize is allowed to
increase the size of the output image compared to the size of the
input image.
*/
typedef enum MMAL_RESIZEMODE_T {
   MMAL_RESIZE_NONE,
   MMAL_RESIZE_CROP,
   MMAL_RESIZE_BOX,
   MMAL_RESIZE_BYTES,
   MMAL_RESIZE_DUMMY = 0x7FFFFFFF
} MMAL_RESIZEMODE_T;

typedef struct MMAL_PARAMETER_RESIZE_T {
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_RESIZEMODE_T mode;
   uint32_t max_width;
   uint32_t max_height;
   uint32_t max_bytes;
   MMAL_BOOL_T preserve_aspect_ratio;
   MMAL_BOOL_T allow_upscaling;
} MMAL_PARAMETER_RESIZE_T;

typedef struct MMAL_PARAMETER_CROP_T {
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_RECT_T rect;
} MMAL_PARAMETER_CROP_T;

typedef struct MMAL_PARAMETER_CCM_T {
   MMAL_RATIONAL_T ccm[3][3];
   int32_t offsets[3];
} MMAL_PARAMETER_CCM_T;

typedef struct MMAL_PARAMETER_CUSTOM_CCM_T {
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_BOOL_T enable;           /**< Enable the custom CCM. */
   MMAL_PARAMETER_CCM_T ccm;     /**< CCM to be used. */
} MMAL_PARAMETER_CUSTOM_CCM_T;

#endif  /* MMAL_PARAMETERS_CAMERA_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_PARAMETERS_CLOCK_H
#define MMAL_PARAMETERS_CLOCK_H

#include "mmal_clock.h"
#include "mmal_parameters_common.h"

/*************************************************
 * ALWAYS ADD NEW ENUMS AT THE END OF THIS LIST! *
 ************************************************/

/** Clock-specific MMAL parameter IDs.
 * @ingroup MMAL_PARAMETER_IDS
 */
enum
{
   MMAL_PARAMETER_CLOCK_REFERENCE           /**< Takes a MMAL_PARAMETER_BOOLEAN_T */
      = MMAL_PARAMETER_GROUP_CLOCK,
   MMAL_PARAMETER_CLOCK_ACTIVE,             /**< Takes a MMAL_PARAMETER_BOOLEAN_T */
   MMAL_PARAMETER_CLOCK_SCALE,              /**< Takes a MMAL_PARAMETER_RATIONAL_T */
   MMAL_PARAMETER_CLOCK_TIME,               /**< Takes a MMAL_PARAMETER_INT64_T */
   MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD,   /**< Takes a MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD_T */
   MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD,  /**< Takes a MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD_T */
   MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD,  /**< Takes a MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD_T */
   MMAL_PARAMETER_CLOCK_ENABLE_BUFFER_INFO, /**< Takes a MMAL_PARAMETER_BOOLEAN_T */
   MMAL_PARAMETER_CLOCK_FRAME_RATE,         /**< Takes a MMAL_PARAMETER_RATIONAL_T */
   MMAL_PARAMETER_CLOCK_LATENCY,            /**< Takes a MMAL_PARAMETER_CLOCK_LATENCY_T */
};

/** Media-time update thresholds */
typedef struct MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_CLOCK_UPDATE_THRESHOLD_T value;
} MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD_T;

/** Media-time discontinuity settings */
typedef struct MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_CLOCK_DISCONT_THRESHOLD_T value;
} MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD_T;

/** Media-time future frame drop settings */
typedef struct MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_CLOCK_REQUEST_THRESHOLD_T value;
} MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD_T;

/** Clock latency parameter */
typedef struct MMAL_PARAMETER_CLOCK_LATENCY_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_CLOCK_LATENCY_T value;
} MMAL_PARAMETER_CLOCK_LATENCY_T;

#endif /* MMAL_PARAMETERS_CLOCK_H */
                                                                                                                                                                                                                                                                                                                                                                                                          /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_PARAMETERS_COMMON_H
#define MMAL_PARAMETERS_COMMON_H

/** @defgroup MMAL_PARAMETER_IDS Pre-defined MMAL parameter IDs
 * @ingroup MmalParameters
 * @{
 */

/** @name Parameter groups
 * Parameters are divided into groups, and then allocated sequentially within
 * a group using an enum.
 * @{
 */

/** Common parameter ID group, used with many types of component. */
#define MMAL_PARAMETER_GROUP_COMMON            (0<<16)
/** Camera-specific parameter ID group. */
#define MMAL_PARAMETER_GROUP_CAMERA            (1<<16)
/** Video-specific parameter ID group. */
#define MMAL_PARAMETER_GROUP_VIDEO             (2<<16)
/** Audio-specific parameter ID group. */
#define MMAL_PARAMETER_GROUP_AUDIO             (3<<16)
/** Clock-specific parameter ID group. */
#define MMAL_PARAMETER_GROUP_CLOCK             (4<<16)
/** Miracast-specific parameter ID group. */
#define MMAL_PARAMETER_GROUP_MIRACAST       (5<<16)


/**@}*/

/** Common MMAL parameter IDs.
 */
enum {
   MMAL_PARAMETER_UNUSED                  /**< Never a valid parameter ID */
         = MMAL_PARAMETER_GROUP_COMMON,
   MMAL_PARAMETER_SUPPORTED_ENCODINGS,    /**< Takes a MMAL_PARAMETER_ENCODING_T */
   MMAL_PARAMETER_URI,                    /**< Takes a MMAL_PARAMETER_URI_T */
   MMAL_PARAMETER_CHANGE_EVENT_REQUEST,   /**< Takes a MMAL_PARAMETER_CHANGE_EVENT_REQUEST_T */
   MMAL_PARAMETER_ZERO_COPY,              /**< Takes a MMAL_PARAMETER_BOOLEAN_T */
   MMAL_PARAMETER_BUFFER_REQUIREMENTS,    /**< Takes a MMAL_PARAMETER_BUFFER_REQUIREMENTS_T */
   MMAL_PARAMETER_STATISTICS,             /**< Takes a MMAL_PARAMETER_STATISTICS_T */
   MMAL_PARAMETER_CORE_STATISTICS,        /**< Takes a MMAL_PARAMETER_CORE_STATISTICS_T */
   MMAL_PARAMETER_MEM_USAGE,              /**< Takes a MMAL_PARAMETER_MEM_USAGE_T */
   MMAL_PARAMETER_BUFFER_FLAG_FILTER,     /**< Takes a MMAL_PARAMETER_UINT32_T */
   MMAL_PARAMETER_SEEK,                   /**< Takes a MMAL_PARAMETER_SEEK_T */
   MMAL_PARAMETER_POWERMON_ENABLE,        /**< Takes a MMAL_PARAMETER_BOOLEAN_T */
   MMAL_PARAMETER_LOGGING,                /**< Takes a MMAL_PARAMETER_LOGGING_T */
   MMAL_PARAMETER_SYSTEM_TIME,            /**< Takes a MMAL_PARAMETER_UINT64_T */
   MMAL_PARAMETER_NO_IMAGE_PADDING,       /**< Takes a MMAL_PARAMETER_BOOLEAN_T */
   MMAL_PARAMETER_LOCKSTEP_ENABLE         /**< Takes a MMAL_PARAMETER_BOOLEAN_T */
};

/**@}*/

/** Parameter header type. All parameter structures need to begin with this type.
 * The \ref id field must be set to a parameter ID, such as one of those listed on
 * the \ref MMAL_PARAMETER_IDS "Pre-defined MMAL parameter IDs" page.
 */
typedef struct MMAL_PARAMETER_HEADER_T
{
   uint32_t id;      /**< Parameter ID. */
   uint32_t size;    /**< Size in bytes of the parameter (including the header) */
} MMAL_PARAMETER_HEADER_T;

/** Change event request parameter type.
 * This is used to control whether a \ref MMAL_EVENT_PARAMETER_CHANGED_T event
 * is issued should a given parameter change.
 */
typedef struct MMAL_PARAMETER_CHANGE_EVENT_REQUEST_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   uint32_t change_id;  /**< ID of parameter that may change, see \ref MMAL_PARAMETER_IDS */
   MMAL_BOOL_T enable;  /**< True if the event is enabled, false if disabled */
} MMAL_PARAMETER_CHANGE_EVENT_REQUEST_T;

/** Buffer requirements parameter.
 * This is mainly used to increase the requirements of a component. */
typedef struct MMAL_PARAMETER_BUFFER_REQUIREMENTS_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   uint32_t buffer_num_min;          /**< Minimum number of buffers the port requires */
   uint32_t buffer_size_min;         /**< Minimum size of buffers the port requires */
   uint32_t buffer_alignment_min;    /**< Minimum alignment requirement for the buffers.
                                          A value of zero means no special alignment requirements. */
   uint32_t buffer_num_recommended;  /**< Number of buffers the port recommends for optimal performance.
                                          A value of zero means no special recommendation. */
   uint32_t buffer_size_recommended; /**< Size of buffers the port recommends for optimal performance.
                                          A value of zero means no special recommendation. */
} MMAL_PARAMETER_BUFFER_REQUIREMENTS_T;

/** Seek request parameter type.
 * This is used to issue a seek request to a source component.
 */
typedef struct MMAL_PARAMETER_SEEK_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   int64_t offset;  /**< Offset (in microseconds) to seek to */
   uint32_t flags;  /**< Seeking flags */

#define MMAL_PARAM_SEEK_FLAG_PRECISE 0x1 /**< Choose precise seeking even if slower */
#define MMAL_PARAM_SEEK_FLAG_FORWARD 0x2 /**< Seek to the next keyframe following the specified offset */

} MMAL_PARAMETER_SEEK_T;

/** Port statistics for debugging/test purposes.
 * Ports may support query of this parameter to return statistics for debugging or
 * test purposes. Not all values may be relevant for a given port.
 */
typedef struct MMAL_PARAMETER_STATISTICS_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   uint32_t buffer_count;           /**< Total number of buffers processed */
   uint32_t frame_count;            /**< Total number of frames processed */
   uint32_t frames_skipped;         /**< Number of frames without expected PTS based on frame rate */
   uint32_t frames_discarded;       /**< Number of frames discarded */
   uint32_t eos_seen;               /**< Set if the end of stream has been reached */
   uint32_t maximum_frame_bytes;    /**< Maximum frame size in bytes */
   int64_t  total_bytes;            /**< Total number of bytes processed */
   uint32_t corrupt_macroblocks;    /**< Number of corrupt macroblocks in the stream */
} MMAL_PARAMETER_STATISTICS_T;

typedef enum
{
   MMAL_CORE_STATS_RX,
   MMAL_CORE_STATS_TX,
   MMAL_CORE_STATS_MAX = 0x7fffffff /* Force 32 bit size for this enum */
} MMAL_CORE_STATS_DIR;

/** MMAL core statistics. These are collected by the core itself.
 */
typedef struct MMAL_PARAMETER_CORE_STATISTICS_T
{
   MMAL_PARAMETER_HEADER_T hdr;
   MMAL_CORE_STATS_DIR dir;
   MMAL_BOOL_T reset;               /**< Reset to zero after reading */
   MMAL_CORE_STATISTICS_T stats;    /**< The statistics */
} MMAL_PARAMETER_CORE_STATISTICS_T;

/**
 * Component memory usage statistics.
 */
typedef struct MMAL_PARAMETER_MEM_USAGE_T
{
   MMAL_PARAMETER_HEADER_T hdr;
   /**< The amount of memory allocated in image pools by the component */
   uint32_t pool_mem_alloc_size;
} MMAL_PARAMETER_MEM_USAGE_T;

/**
 * Logging control.
 */
typedef struct MMAL_PARAMETER_LOGGING_T
{
   MMAL_PARAMETER_HEADER_T hdr;
   uint32_t set;     /**< Logging bits to set */
   uint32_t clear;   /**< Logging bits to clear */
} MMAL_PARAMETER_LOGGING_T;

#endif /* MMAL_PARAMETERS_COMMON_H */

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_PARAMETERS_VIDEO_H
#define MMAL_PARAMETERS_VIDEO_H

#include "mmal_parameters_common.h"

/*************************************************
 * ALWAYS ADD NEW ENUMS AT THE END OF THIS LIST! *
 ************************************************/

/** Video-specific MMAL parameter IDs.
 * @ingroup MMAL_PARAMETER_IDS
 */
enum {
   MMAL_PARAMETER_DISPLAYREGION           /**< Takes a @ref MMAL_DISPLAYREGION_T */
         = MMAL_PARAMETER_GROUP_VIDEO,
   MMAL_PARAMETER_SUPPORTED_PROFILES,     /**< Takes a @ref MMAL_PARAMETER_VIDEO_PROFILE_T */
   MMAL_PARAMETER_PROFILE,                /**< Takes a @ref MMAL_PARAMETER_VIDEO_PROFILE_T */
   MMAL_PARAMETER_INTRAPERIOD,            /**< Takes a @ref MMAL_PARAMETER_UINT32_T */
   MMAL_PARAMETER_RATECONTROL,            /**< Takes a @ref MMAL_PARAMETER_VIDEO_RATECONTROL_T */
   MMAL_PARAMETER_NALUNITFORMAT,          /**< Takes a @ref MMAL_PARAMETER_VIDEO_NALUNITFORMAT_T */
   MMAL_PARAMETER_MINIMISE_FRAGMENTATION, /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */
   MMAL_PARAMETER_MB_ROWS_PER_SLICE,      /**< Takes a @ref MMAL_PARAMETER_UINT32_T.
                                           * Setting the value to zero resets to the default (one slice per frame). */
   MMAL_PARAMETER_VIDEO_LEVEL_EXTENSION,  /**< Takes a @ref MMAL_PARAMETER_VIDEO_LEVEL_EXTENSION_T */
   MMAL_PARAMETER_VIDEO_EEDE_ENABLE,      /**< Takes a @ref MMAL_PARAMETER_VIDEO_EEDE_ENABLE_T */
   MMAL_PARAMETER_VIDEO_EEDE_LOSSRATE,    /**< Takes a @ref MMAL_PARAMETER_VIDEO_EEDE_LOSSRATE_T */
   MMAL_PARAMETER_VIDEO_REQUEST_I_FRAME,  /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T.
                                           * Request an I-frame. */
   MMAL_PARAMETER_VIDEO_INTRA_REFRESH,    /**< Takes a @ref MMAL_PARAMETER_VIDEO_INTRA_REFRESH_T */
   MMAL_PARAMETER_VIDEO_IMMUTABLE_INPUT,  /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T. */
   MMAL_PARAMETER_VIDEO_BIT_RATE,         /**< Takes a @ref MMAL_PARAMETER_UINT32_T.
                                           * Run-time bit rate control */
   MMAL_PARAMETER_VIDEO_FRAME_RATE,       /**< Takes a @ref MMAL_PARAMETER_FRAME_RATE_T */
   MMAL_PARAMETER_VIDEO_ENCODE_MIN_QUANT, /**< Takes a @ref MMAL_PARAMETER_UINT32_T. */
   MMAL_PARAMETER_VIDEO_ENCODE_MAX_QUANT, /**< Takes a @ref MMAL_PARAMETER_UINT32_T. */
   MMAL_PARAMETER_VIDEO_ENCODE_RC_MODEL,  /**< Takes a @ref MMAL_PARAMETER_VIDEO_ENCODE_RC_MODEL_T. */
   MMAL_PARAMETER_EXTRA_BUFFERS,          /**< Takes a @ref MMAL_PARAMETER_UINT32_T. */
   MMAL_PARAMETER_VIDEO_ALIGN_HORIZ,      /**< Takes a @ref MMAL_PARAMETER_UINT32_T.
                                               Changing this paramater from the default can reduce frame rate
                                               because image buffers need to be re-pitched.*/
   MMAL_PARAMETER_VIDEO_ALIGN_VERT,        /**< Takes a @ref MMAL_PARAMETER_UINT32_T.
                                               Changing this paramater from the default can reduce frame rate
                                               because image buffers need to be re-pitched.*/
   MMAL_PARAMETER_VIDEO_DROPPABLE_PFRAMES,      /**< Take a @ref MMAL_PARAMETER_BOOLEAN_T. */
   MMAL_PARAMETER_VIDEO_ENCODE_INITIAL_QUANT,   /**< Takes a @ref MMAL_PARAMETER_UINT32_T. */
   MMAL_PARAMETER_VIDEO_ENCODE_QP_P,            /**< Takes a @ref MMAL_PARAMETER_UINT32_T. */
   MMAL_PARAMETER_VIDEO_ENCODE_RC_SLICE_DQUANT, /**< Takes a @ref MMAL_PARAMETER_UINT32_T. */
   MMAL_PARAMETER_VIDEO_ENCODE_FRAME_LIMIT_BITS,    /**< Takes a @ref MMAL_PARAMETER_UINT32_T */
   MMAL_PARAMETER_VIDEO_ENCODE_PEAK_RATE,       /**< Takes a @ref MMAL_PARAMETER_UINT32_T. */       

   /*H264 specific parameters*/
   MMAL_PARAMETER_VIDEO_ENCODE_H264_DISABLE_CABAC,      /**< Take a @ref MMAL_PARAMETER_BOOLEAN_T. */
   MMAL_PARAMETER_VIDEO_ENCODE_H264_LOW_LATENCY,        /**< Take a @ref MMAL_PARAMETER_BOOLEAN_T. */
   MMAL_PARAMETER_VIDEO_ENCODE_H264_AU_DELIMITERS,      /**< Take a @ref MMAL_PARAMETER_BOOLEAN_T. */
   MMAL_PARAMETER_VIDEO_ENCODE_H264_DEBLOCK_IDC,        /**< Takes a @ref MMAL_PARAMETER_UINT32_T. */
   MMAL_PARAMETER_VIDEO_ENCODE_H264_MB_INTRA_MODE,      /**< Takes a @ref MMAL_PARAMETER_VIDEO_ENCODER_H264_MB_INTRA_MODES_T. */

   MMAL_PARAMETER_VIDEO_ENCODE_HEADER_ON_OPEN,  /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */
   MMAL_PARAMETER_VIDEO_ENCODE_PRECODE_FOR_QP,  /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */

   MMAL_PARAMETER_VIDEO_DRM_INIT_INFO,          /**< Takes a @ref MMAL_PARAMETER_VIDEO_DRM_INIT_INFO_T. */
   MMAL_PARAMETER_VIDEO_TIMESTAMP_FIFO,         /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */
   MMAL_PARAMETER_VIDEO_DECODE_ERROR_CONCEALMENT,        /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */
   MMAL_PARAMETER_VIDEO_DRM_PROTECT_BUFFER,              /**< Takes a @ref MMAL_PARAMETER_VIDEO_DRM_PROTECT_BUFFER_T. */

   MMAL_PARAMETER_VIDEO_DECODE_CONFIG_VD3,       /**< Takes a @ref MMAL_PARAMETER_BYTES_T */
   MMAL_PARAMETER_VIDEO_ENCODE_H264_VCL_HRD_PARAMETERS, /**< Take a @ref MMAL_PARAMETER_BOOLEAN_T. */
   MMAL_PARAMETER_VIDEO_ENCODE_H264_LOW_DELAY_HRD_FLAG, /**< Take a @ref MMAL_PARAMETER_BOOLEAN_T. */
   MMAL_PARAMETER_VIDEO_ENCODE_INLINE_HEADER,            /**< Take a @ref MMAL_PARAMETER_BOOLEAN_T. */
   MMAL_PARAMETER_VIDEO_ENCODE_SEI_ENABLE,               /**< Take a @ref MMAL_PARAMETER_BOOLEAN_T. */
   MMAL_PARAMETER_VIDEO_ENCODE_INLINE_VECTORS,           /**< Take a @ref MMAL_PARAMETER_BOOLEAN_T. */
   MMAL_PARAMETER_VIDEO_RENDER_STATS,           /**< Take a @ref MMAL_PARAMETER_VIDEO_RENDER_STATS_T. */
   MMAL_PARAMETER_VIDEO_INTERLACE_TYPE,           /**< Take a @ref MMAL_PARAMETER_VIDEO_INTERLACE_TYPE_T. */
   MMAL_PARAMETER_VIDEO_INTERPOLATE_TIMESTAMPS,         /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */
   MMAL_PARAMETER_VIDEO_ENCODE_SPS_TIMING,         /**< Take a @ref MMAL_PARAMETER_BOOLEAN_T */
   MMAL_PARAMETER_VIDEO_MAX_NUM_CALLBACKS,         /**< Take a @ref MMAL_PARAMETER_UINT32_T */
   MMAL_PARAMETER_VIDEO_SOURCE_PATTERN,         /**< Take a @ref MMAL_PARAMETER_SOURCE_PATTERN_T */
   MMAL_PARAMETER_VIDEO_ENCODE_SEPARATE_NAL_BUFS,  /**< Take a @ref MMAL_PARAMETER_BOOLEAN_T */
   MMAL_PARAMETER_VIDEO_DROPPABLE_PFRAME_LENGTH,   /**< Take a @ref MMAL_PARAMETER_UINT32_T */
};

/** Display transformations.
 * Although an enumeration, the values correspond to combinations of:
 * \li 1 Reflect in a vertical axis
 * \li 2 180 degree rotation
 * \li 4 Reflect in the leading diagonal
 */
typedef enum MMAL_DISPLAYTRANSFORM_T {
   MMAL_DISPLAY_ROT0 = 0,
   MMAL_DISPLAY_MIRROR_ROT0 = 1,
   MMAL_DISPLAY_MIRROR_ROT180 = 2,
   MMAL_DISPLAY_ROT180 = 3,
   MMAL_DISPLAY_MIRROR_ROT90 = 4,
   MMAL_DISPLAY_ROT270 = 5,
   MMAL_DISPLAY_ROT90 = 6,
   MMAL_DISPLAY_MIRROR_ROT270 = 7,
   MMAL_DISPLAY_DUMMY = 0x7FFFFFFF
} MMAL_DISPLAYTRANSFORM_T;

/** Display modes. */
typedef enum MMAL_DISPLAYMODE_T {
   MMAL_DISPLAY_MODE_FILL = 0,
   MMAL_DISPLAY_MODE_LETTERBOX = 1,
   // these allow a left eye source->dest to be specified and the right eye mapping will be inferred by symmetry
   MMAL_DISPLAY_MODE_STEREO_LEFT_TO_LEFT = 2,
   MMAL_DISPLAY_MODE_STEREO_TOP_TO_TOP = 3,
   MMAL_DISPLAY_MODE_STEREO_LEFT_TO_TOP = 4,
   MMAL_DISPLAY_MODE_STEREO_TOP_TO_LEFT = 5,
   MMAL_DISPLAY_MODE_DUMMY = 0x7FFFFFFF
} MMAL_DISPLAYMODE_T;

/** Values used to indicate which fields are used when setting the
 * display configuration */
typedef enum MMAL_DISPLAYSET_T {
   MMAL_DISPLAY_SET_NONE = 0,
   MMAL_DISPLAY_SET_NUM = 1,
   MMAL_DISPLAY_SET_FULLSCREEN = 2,
   MMAL_DISPLAY_SET_TRANSFORM = 4,
   MMAL_DISPLAY_SET_DEST_RECT = 8,
   MMAL_DISPLAY_SET_SRC_RECT = 0x10,
   MMAL_DISPLAY_SET_MODE = 0x20,
   MMAL_DISPLAY_SET_PIXEL = 0x40,
   MMAL_DISPLAY_SET_NOASPECT = 0x80,
   MMAL_DISPLAY_SET_LAYER = 0x100,
   MMAL_DISPLAY_SET_COPYPROTECT = 0x200,
   MMAL_DISPLAY_SET_ALPHA = 0x400,
   MMAL_DISPLAY_SET_DUMMY = 0x7FFFFFFF
} MMAL_DISPLAYSET_T;

typedef enum MMAL_DISPLAYALPHAFLAGS_T {
  MMAL_DISPLAY_ALPHA_FLAGS_NONE = 0,
  /**< Discard all lower layers as if this layer were fullscreen and completely
   * opaque. This flag removes the lower layers from the display list, therefore
   * avoiding using resources in wasted effort.
   */
  MMAL_DISPLAY_ALPHA_FLAGS_DISCARD_LOWER_LAYERS = 1<<29,
  /**< Alpha values are already premultiplied */
  MMAL_DISPLAY_ALPHA_FLAGS_PREMULT = 1<<30,
  /**< Mix the per pixel alpha (if present) and the per plane alpha. */
  MMAL_DISPLAY_ALPHA_FLAGS_MIX = 1<<31,
} MMAL_DISPLAYALPHAFLAGS_T;

/**
This config sets the output display device, as well as the region used
on the output display, any display transformation, and some flags to
indicate how to scale the image.
*/

typedef struct MMAL_DISPLAYREGION_T {
   MMAL_PARAMETER_HEADER_T hdr;
   /** Bitfield that indicates which fields are set and should be used. All
    * other fields will maintain their current value.
    * \ref MMAL_DISPLAYSET_T defines the bits that can be combined.
    */
   uint32_t set;
   /** Describes the display output device, with 0 typically being a directly
    * connected LCD display.  The actual values will depend on the hardware.
    * Code using hard-wired numbers (e.g. 2) is certain to fail.
    */
   uint32_t display_num;
   /** Indicates that we are using the full device screen area, rather than
    * a window of the display.  If zero, then dest_rect is used to specify a
    * region of the display to use.
    */
   MMAL_BOOL_T fullscreen;
   /** Indicates any rotation or flipping used to map frames onto the natural
    * display orientation.
    */
   MMAL_DISPLAYTRANSFORM_T transform;
   /** Where to display the frame within the screen, if fullscreen is zero.
    */
   MMAL_RECT_T dest_rect;
   /** Indicates which area of the frame to display. If all values are zero,
    * the whole frame will be used.
    */
   MMAL_RECT_T src_rect;
   /** If set to non-zero, indicates that any display scaling should disregard
    * the aspect ratio of the frame region being displayed.
    */
   MMAL_BOOL_T noaspect;
   /** Indicates how the image should be scaled to fit the display. \code
    * MMAL_DISPLAY_MODE_FILL \endcode indicates that the image should fill the
    * screen by potentially cropping the frames.  Setting \code mode \endcode
    * to \code MMAL_DISPLAY_MODE_LETTERBOX \endcode indicates that all the source
    * region should be displayed and black bars added if necessary.
    */
   MMAL_DISPLAYMODE_T mode;
   /** If non-zero, defines the width of a source pixel relative to \code pixel_y
    * \endcode.  If zero, then pixels default to being square.
    */
   uint32_t pixel_x;
   /** If non-zero, defines the height of a source pixel relative to \code pixel_x
    * \endcode.  If zero, then pixels default to being square.
    */
   uint32_t pixel_y;
   /** Sets the relative depth of the images, with greater values being in front
    * of smaller values.
    */
   int32_t layer;
   /** Set to non-zero to ensure copy protection is used on output.
    */
   MMAL_BOOL_T copyprotect_required;
   /** Bits 7-0: Level of opacity of the layer, where zero is fully transparent and
    * 255 is fully opaque.
    * Bits 31-8: Flags from \code MMAL_DISPLAYALPHAFLAGS_T for alpha mode selection.
    */
   uint32_t alpha;
} MMAL_DISPLAYREGION_T;

/** Video profiles.
 * Only certain combinations of profile and level will be valid.
 * @ref MMAL_VIDEO_LEVEL_T
 */
typedef enum MMAL_VIDEO_PROFILE_T {
    MMAL_VIDEO_PROFILE_H263_BASELINE,
    MMAL_VIDEO_PROFILE_H263_H320CODING,
    MMAL_VIDEO_PROFILE_H263_BACKWARDCOMPATIBLE,
    MMAL_VIDEO_PROFILE_H263_ISWV2,
    MMAL_VIDEO_PROFILE_H263_ISWV3,
    MMAL_VIDEO_PROFILE_H263_HIGHCOMPRESSION,
    MMAL_VIDEO_PROFILE_H263_INTERNET,
    MMAL_VIDEO_PROFILE_H263_INTERLACE,
    MMAL_VIDEO_PROFILE_H263_HIGHLATENCY,
    MMAL_VIDEO_PROFILE_MP4V_SIMPLE,
    MMAL_VIDEO_PROFILE_MP4V_SIMPLESCALABLE,
    MMAL_VIDEO_PROFILE_MP4V_CORE,
    MMAL_VIDEO_PROFILE_MP4V_MAIN,
    MMAL_VIDEO_PROFILE_MP4V_NBIT,
    MMAL_VIDEO_PROFILE_MP4V_SCALABLETEXTURE,
    MMAL_VIDEO_PROFILE_MP4V_SIMPLEFACE,
    MMAL_VIDEO_PROFILE_MP4V_SIMPLEFBA,
    MMAL_VIDEO_PROFILE_MP4V_BASICANIMATED,
    MMAL_VIDEO_PROFILE_MP4V_HYBRID,
    MMAL_VIDEO_PROFILE_MP4V_ADVANCEDREALTIME,
    MMAL_VIDEO_PROFILE_MP4V_CORESCALABLE,
    MMAL_VIDEO_PROFILE_MP4V_ADVANCEDCODING,
    MMAL_VIDEO_PROFILE_MP4V_ADVANCEDCORE,
    MMAL_VIDEO_PROFILE_MP4V_ADVANCEDSCALABLE,
    MMAL_VIDEO_PROFILE_MP4V_ADVANCEDSIMPLE,
    MMAL_VIDEO_PROFILE_H264_BASELINE,
    MMAL_VIDEO_PROFILE_H264_MAIN,
    MMAL_VIDEO_PROFILE_H264_EXTENDED,
    MMAL_VIDEO_PROFILE_H264_HIGH,
    MMAL_VIDEO_PROFILE_H264_HIGH10,
    MMAL_VIDEO_PROFILE_H264_HIGH422,
    MMAL_VIDEO_PROFILE_H264_HIGH444,
    MMAL_VIDEO_PROFILE_H264_CONSTRAINED_BASELINE,
    MMAL_VIDEO_PROFILE_DUMMY = 0x7FFFFFFF
} MMAL_VIDEO_PROFILE_T;

/** Video levels.
 * Only certain combinations of profile and level will be valid.
 * @ref MMAL_VIDEO_PROFILE_T
 */
typedef enum MMAL_VIDEO_LEVEL_T {
    MMAL_VIDEO_LEVEL_H263_10,
    MMAL_VIDEO_LEVEL_H263_20,
    MMAL_VIDEO_LEVEL_H263_30,
    MMAL_VIDEO_LEVEL_H263_40,
    MMAL_VIDEO_LEVEL_H263_45,
    MMAL_VIDEO_LEVEL_H263_50,
    MMAL_VIDEO_LEVEL_H263_60,
    MMAL_VIDEO_LEVEL_H263_70,
    MMAL_VIDEO_LEVEL_MP4V_0,
    MMAL_VIDEO_LEVEL_MP4V_0b,
    MMAL_VIDEO_LEVEL_MP4V_1,
    MMAL_VIDEO_LEVEL_MP4V_2,
    MMAL_VIDEO_LEVEL_MP4V_3,
    MMAL_VIDEO_LEVEL_MP4V_4,
    MMAL_VIDEO_LEVEL_MP4V_4a,
    MMAL_VIDEO_LEVEL_MP4V_5,
    MMAL_VIDEO_LEVEL_MP4V_6,
    MMAL_VIDEO_LEVEL_H264_1,
    MMAL_VIDEO_LEVEL_H264_1b,
    MMAL_VIDEO_LEVEL_H264_11,
    MMAL_VIDEO_LEVEL_H264_12,
    MMAL_VIDEO_LEVEL_H264_13,
    MMAL_VIDEO_LEVEL_H264_2,
    MMAL_VIDEO_LEVEL_H264_21,
    MMAL_VIDEO_LEVEL_H264_22,
    MMAL_VIDEO_LEVEL_H264_3,
    MMAL_VIDEO_LEVEL_H264_31,
    MMAL_VIDEO_LEVEL_H264_32,
    MMAL_VIDEO_LEVEL_H264_4,
    MMAL_VIDEO_LEVEL_H264_41,
    MMAL_VIDEO_LEVEL_H264_42,
    MMAL_VIDEO_LEVEL_H264_5,
    MMAL_VIDEO_LEVEL_H264_51,
    MMAL_VIDEO_LEVEL_DUMMY = 0x7FFFFFFF
} MMAL_VIDEO_LEVEL_T;

/** Video profile and level setting.
 * This is a variable length structure when querying the supported profiles and
 * levels. To get more than one, pass a structure with more profile/level pairs.
 */
typedef struct MMAL_PARAMETER_VIDEO_PROFILE_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   struct
   {
      MMAL_VIDEO_PROFILE_T profile;
      MMAL_VIDEO_LEVEL_T level;
   } profile[1];
} MMAL_PARAMETER_VIDEO_PROFILE_T;

/** Manner of video rate control */
typedef enum MMAL_VIDEO_RATECONTROL_T {
    MMAL_VIDEO_RATECONTROL_DEFAULT,
    MMAL_VIDEO_RATECONTROL_VARIABLE,
    MMAL_VIDEO_RATECONTROL_CONSTANT,
    MMAL_VIDEO_RATECONTROL_VARIABLE_SKIP_FRAMES,
    MMAL_VIDEO_RATECONTROL_CONSTANT_SKIP_FRAMES,
    MMAL_VIDEO_RATECONTROL_DUMMY = 0x7fffffff
} MMAL_VIDEO_RATECONTROL_T;

/** Intra refresh modes */
typedef enum MMAL_VIDEO_INTRA_REFRESH_T {
    MMAL_VIDEO_INTRA_REFRESH_CYCLIC,
    MMAL_VIDEO_INTRA_REFRESH_ADAPTIVE,
    MMAL_VIDEO_INTRA_REFRESH_BOTH,
    MMAL_VIDEO_INTRA_REFRESH_KHRONOSEXTENSIONS = 0x6F000000,
    MMAL_VIDEO_INTRA_REFRESH_VENDORSTARTUNUSED = 0x7F000000,
    MMAL_VIDEO_INTRA_REFRESH_CYCLIC_MROWS,
    MMAL_VIDEO_INTRA_REFRESH_PSEUDO_RAND,
    MMAL_VIDEO_INTRA_REFRESH_MAX,
    MMAL_VIDEO_INTRA_REFRESH_DUMMY         = 0x7FFFFFFF
} MMAL_VIDEO_INTRA_REFRESH_T;

/*Encode RC Models Supported*/
typedef enum MMAL_VIDEO_ENCODE_RC_MODEL_T {
    MMAL_VIDEO_ENCODER_RC_MODEL_DEFAULT    = 0,
    MMAL_VIDEO_ENCODER_RC_MODEL_JVT = MMAL_VIDEO_ENCODER_RC_MODEL_DEFAULT,
    MMAL_VIDEO_ENCODER_RC_MODEL_VOWIFI,
    MMAL_VIDEO_ENCODER_RC_MODEL_CBR,
    MMAL_VIDEO_ENCODER_RC_MODEL_LAST,
    MMAL_VIDEO_ENCODER_RC_MODEL_DUMMY      = 0x7FFFFFFF
} MMAL_VIDEO_ENCODE_RC_MODEL_T;

typedef struct MMAL_PARAMETER_VIDEO_ENCODE_RC_MODEL_T {
    MMAL_PARAMETER_HEADER_T hdr;
    MMAL_VIDEO_ENCODE_RC_MODEL_T rc_model;
}MMAL_PARAMETER_VIDEO_ENCODE_RC_MODEL_T;

/** Video rate control setting */
typedef struct MMAL_PARAMETER_VIDEO_RATECONTROL_T {
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_VIDEO_RATECONTROL_T control;
} MMAL_PARAMETER_VIDEO_RATECONTROL_T;

/*H264 INTRA MB MODES*/
typedef enum MMAL_VIDEO_ENCODE_H264_MB_INTRA_MODES_T {
    MMAL_VIDEO_ENCODER_H264_MB_4x4_INTRA = 1,
    MMAL_VIDEO_ENCODER_H264_MB_8x8_INTRA = 2,
    MMAL_VIDEO_ENCODER_H264_MB_16x16_INTRA = 4,
    MMAL_VIDEO_ENCODER_H264_MB_INTRA_DUMMY = 0x7fffffff
} MMAL_VIDEO_ENCODE_H264_MB_INTRA_MODES_T;

typedef struct MMAL_PARAMETER_VIDEO_ENCODER_H264_MB_INTRA_MODES_T {
    MMAL_PARAMETER_HEADER_T hdr;
    MMAL_VIDEO_ENCODE_H264_MB_INTRA_MODES_T mb_mode;
}MMAL_PARAMETER_VIDEO_ENCODER_H264_MB_INTRA_MODES_T;

/** NAL unit formats */
typedef enum MMAL_VIDEO_NALUNITFORMAT_T {
    MMAL_VIDEO_NALUNITFORMAT_STARTCODES = 1,
    MMAL_VIDEO_NALUNITFORMAT_NALUNITPERBUFFER = 2,
    MMAL_VIDEO_NALUNITFORMAT_ONEBYTEINTERLEAVELENGTH = 4,
    MMAL_VIDEO_NALUNITFORMAT_TWOBYTEINTERLEAVELENGTH = 8,
    MMAL_VIDEO_NALUNITFORMAT_FOURBYTEINTERLEAVELENGTH = 16,
    MMAL_VIDEO_NALUNITFORMAT_DUMMY = 0x7fffffff
} MMAL_VIDEO_NALUNITFORMAT_T;

/** NAL unit format setting */
typedef struct MMAL_PARAMETER_VIDEO_NALUNITFORMAT_T {
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_VIDEO_NALUNITFORMAT_T format;
} MMAL_PARAMETER_VIDEO_NALUNITFORMAT_T;

/** H264 Only: Overrides for max macro-blocks per second, max framesize, 
 * and max bitrates. This overrides the default maximums for the configured level.
 */
typedef struct MMAL_PARAMETER_VIDEO_LEVEL_EXTENSION_T {
   MMAL_PARAMETER_HEADER_T hdr;

   uint32_t custom_max_mbps;
   uint32_t custom_max_fs;
   uint32_t custom_max_br_and_cpb;
} MMAL_PARAMETER_VIDEO_LEVEL_EXTENSION_T;

/** H264 Only: Overrides for max macro-blocks per second, max framesize,
 * and max bitrates. This overrides the default maximums for the configured level.
 */
typedef struct MMAL_PARAMETER_VIDEO_INTRA_REFRESH_T {
   MMAL_PARAMETER_HEADER_T hdr;

    MMAL_VIDEO_INTRA_REFRESH_T refresh_mode;
    uint32_t air_mbs;
    uint32_t air_ref;
    uint32_t cir_mbs;
    uint32_t pir_mbs;
} MMAL_PARAMETER_VIDEO_INTRA_REFRESH_T;

/** Structure for enabling EEDE, we keep it like this for now, there could be extra fields in the future */
typedef struct MMAL_PARAMETER_VIDEO_EEDE_ENABLE_T {
   MMAL_PARAMETER_HEADER_T hdr;

   uint32_t enable;
} MMAL_PARAMETER_VIDEO_EEDE_ENABLE_T;

/** Structure for setting lossrate for EEDE, we keep it like this for now, there could be extra fields in the future */
typedef struct MMAL_PARAMETER_VIDEO_EEDE_LOSSRATE_T {
   MMAL_PARAMETER_HEADER_T hdr;

   uint32_t loss_rate;
} MMAL_PARAMETER_VIDEO_EEDE_LOSSRATE_T;

/** Structure for setting initial DRM parameters */
typedef struct MMAL_PARAMETER_VIDEO_DRM_INIT_INFO_T {
   MMAL_PARAMETER_HEADER_T hdr;

   uint32_t current_time;
   uint32_t ticks_per_sec;
   uint8_t  lhs[32];
} MMAL_PARAMETER_VIDEO_DRM_INIT_INFO_T;

/** Structure for requesting a hardware-protected memory buffer **/
typedef struct MMAL_PARAMETER_VIDEO_DRM_PROTECT_BUFFER_T {
   MMAL_PARAMETER_HEADER_T hdr;

   uint32_t size_wanted;     /**< Input. Zero size means internal video decoder buffer,
                                 mem_handle and phys_addr not returned in this case */
   uint32_t protect;         /**< Input. 1 = protect, 0 = unprotect */

   uint32_t mem_handle;      /**< Output. Handle for protected buffer */
   void *   phys_addr;       /**< Output. Physical memory address of protected buffer */

} MMAL_PARAMETER_VIDEO_DRM_PROTECT_BUFFER_T;

typedef struct MMAL_PARAMETER_VIDEO_RENDER_STATS_T {
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_BOOL_T valid;
   uint32_t match;
   uint32_t period;
   uint32_t phase;
   uint32_t pixel_clock_nominal;
   uint32_t pixel_clock;
   uint32_t hvs_status;
   uint32_t dummy[2];
} MMAL_PARAMETER_VIDEO_RENDER_STATS_T;

typedef enum MMAL_INTERLACETYPE_T {
   MMAL_InterlaceProgressive,                    /**< The data is not interlaced, it is progressive scan */
   MMAL_InterlaceFieldSingleUpperFirst,          /**< The data is interlaced, fields sent
                                                     separately in temporal order, with upper field first */
   MMAL_InterlaceFieldSingleLowerFirst,          /**< The data is interlaced, fields sent
                                                     separately in temporal order, with lower field first */
   MMAL_InterlaceFieldsInterleavedUpperFirst,    /**< The data is interlaced, two fields sent together line
                                                     interleaved, with the upper field temporally earlier */
   MMAL_InterlaceFieldsInterleavedLowerFirst,    /**< The data is interlaced, two fields sent together line
                                                     interleaved, with the lower field temporally earlier */
   MMAL_InterlaceMixed,                          /**< The stream may contain a mixture of progressive
                                                     and interlaced frames */
   MMAL_InterlaceKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
   MMAL_InterlaceVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
   MMAL_InterlaceMax = 0x7FFFFFFF
} MMAL_INTERLACETYPE_T;

typedef struct MMAL_PARAMETER_VIDEO_INTERLACE_TYPE_T {
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_INTERLACETYPE_T eMode;       /**< The interlace type of the content */
   MMAL_BOOL_T bRepeatFirstField;    /**< Whether to repeat the first field */
} MMAL_PARAMETER_VIDEO_INTERLACE_TYPE_T;

typedef enum MMAL_SOURCE_PATTERN_T {
   MMAL_VIDEO_SOURCE_PATTERN_WHITE,
   MMAL_VIDEO_SOURCE_PATTERN_BLACK,
   MMAL_VIDEO_SOURCE_PATTERN_DIAGONAL,
   MMAL_VIDEO_SOURCE_PATTERN_NOISE,
   MMAL_VIDEO_SOURCE_PATTERN_RANDOM,
   MMAL_VIDEO_SOURCE_PATTERN_COLOUR,
   MMAL_VIDEO_SOURCE_PATTERN_BLOCKS,
   MMAL_VIDEO_SOURCE_PATTERN_SWIRLY,
   MMAL_VIDEO_SOURCE_PATTERN_DUMMY = 0x7fffffff
} MMAL_SOURCE_PATTERN_T;

typedef struct MMAL_PARAMETER_VIDEO_SOURCE_PATTERN_T {
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_SOURCE_PATTERN_T pattern;
   uint32_t param;                              /**< Colour for PATTERN_COLOUR mode */
   uint32_t framecount;                         /**< Number of frames to produce. 0 for continuous. */
   MMAL_RATIONAL_T framerate;                   /**< Framerate used when determining buffer timestamps */
} MMAL_PARAMETER_VIDEO_SOURCE_PATTERN_T;


#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_TYPES_H
#define MMAL_TYPES_H

#ifdef __cplusplus
extern "C" {
#endif

/** \defgroup MmalTypes Common types
 * Definition for common types */
/* @{ */

#include "mmal_common.h"

/** Status return codes from the API.
 *
 * \internal Please try to keep this similar to the standard POSIX codes
 * rather than making up new ones!
 */
typedef enum
{
   MMAL_SUCCESS = 0,                 /**< Success */
   MMAL_ENOMEM,                      /**< Out of memory */
   MMAL_ENOSPC,                      /**< Out of resources (other than memory) */
   MMAL_EINVAL,                      /**< Argument is invalid */
   MMAL_ENOSYS,                      /**< Function not implemented */
   MMAL_ENOENT,                      /**< No such file or directory */
   MMAL_ENXIO,                       /**< No such device or address */
   MMAL_EIO,                         /**< I/O error */
   MMAL_ESPIPE,                      /**< Illegal seek */
   MMAL_ECORRUPT,                    /**< Data is corrupt \attention FIXME: not POSIX */
   MMAL_ENOTREADY,                   /**< Component is not ready \attention FIXME: not POSIX */
   MMAL_ECONFIG,                     /**< Component is not configured \attention FIXME: not POSIX */
   MMAL_EISCONN,                     /**< Port is already connected */
   MMAL_ENOTCONN,                    /**< Port is disconnected */
   MMAL_EAGAIN,                      /**< Resource temporarily unavailable. Try again later*/
   MMAL_EFAULT,                      /**< Bad address */
   /* Do not add new codes here unless they match something from POSIX */
   MMAL_STATUS_MAX = 0x7FFFFFFF      /**< Force to 32 bit */
} MMAL_STATUS_T;

/** Describes a rectangle */
typedef struct
{
   int32_t x;      /**< x coordinate (from left) */
   int32_t y;      /**< y coordinate (from top) */
   int32_t width;  /**< width */
   int32_t height; /**< height */
} MMAL_RECT_T;

/** Describes a rational number */
typedef struct
{
   int32_t num;    /**< Numerator */
   int32_t den;    /**< Denominator */
} MMAL_RATIONAL_T;

/** \name Special Unknown Time Value
 * Timestamps in MMAL are defined as signed 64 bits integer values representing microseconds.
 * However a pre-defined special value is used to signal that a timestamp is not known. */
/* @{ */
#define MMAL_TIME_UNKNOWN (INT64_C(1)<<63)  /**< Special value signalling that time is not known */
/* @} */

/** Four Character Code type */
typedef uint32_t MMAL_FOURCC_T;

/* @} */

#ifdef __cplusplus
}
#endif

#endif /* MMAL_TYPES_H */
                                           /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_POOL_H
#define MMAL_POOL_H

#ifdef __cplusplus
extern "C" {
#endif

/** \defgroup MmalPool Pools of buffer headers
 * A pool of buffer headers is composed of a queue (\ref MMAL_QUEUE_T) and a user
 * specified number of buffer headers (\ref MMAL_BUFFER_HEADER_T). */
/* @{ */

#include "mmal_queue.h"

/** Definition of a pool */
typedef struct MMAL_POOL_T
{
   MMAL_QUEUE_T *queue;             /**< Queue used by the pool */
   uint32_t headers_num;            /**< Number of buffer headers in the pool */
   MMAL_BUFFER_HEADER_T **header;   /**< Array of buffer headers belonging to the pool */
} MMAL_POOL_T;

/** Allocator alloc prototype
 *
 * @param context The context pointer passed in on pool creation.
 * @param size    The size of the allocation required, in bytes.
 * @return The pointer to the newly allocated memory, or NULL on failure.
 */
typedef void *(*mmal_pool_allocator_alloc_t)(void *context, uint32_t size);
/** Allocator free prototype
 *
 * @param context The context pointer passed in on pool creation.
 * @param mem     The pointer to the memory to be released.
 */
typedef void (*mmal_pool_allocator_free_t)(void *context, void *mem);

/** Create a pool of MMAL_BUFFER_HEADER_T.
 * After allocation, all allocated buffer headers will have been added to the queue.
 *
 * It is valid to create a pool with no buffer headers, or with zero size payload buffers.
 * The mmal_pool_resize() function can be used to increase or decrease the number of buffer
 * headers, or the size of the payload buffers, after creation of the pool.
 *
 * The payload buffers may also be allocated independently by the client, and assigned
 * to the buffer headers, but it will be the responsibility of the client to deal with
 * resizing and releasing the memory. It is recommended that mmal_pool_create_with_allocator()
 * is used in this case, supplying allocator function pointers that will be used as
 * necessary by MMAL.
 *
 * @param headers      Number of buffer headers to be allocated with the pool.
 * @param payload_size Size of the payload buffer that will be allocated in 
 *                     each of the buffer headers.
 * @return Pointer to the newly created pool or NULL on failure.
 */
MMAL_POOL_T *mmal_pool_create(unsigned int headers, uint32_t payload_size);

/** Create a pool of MMAL_BUFFER_HEADER_T.
 * After allocation, all allocated buffer headers will have been added to the queue.
 *
 * It is valid to create a pool with no buffer headers, or with zero size payload buffers.
 * The mmal_pool_resize() function can be used to increase or decrease the number of buffer
 * headers, or the size of the payload buffers, after creation of the pool. The allocators
 * passed during creation shall be used when resizing the payload buffers.
 *
 * @param headers      Number of buffer headers to be allocated with the pool.
 * @param payload_size Size of the payload buffer that will be allocated in
 *                     each of the buffer headers.
 * @param allocator_context Pointer to the context of the allocator.
 * @param allocator_alloc   Function pointer for the alloc call of the allocator.
 * @param allocator_free    Function pointer for the free call of the allocator.
 *
 * @return Pointer to the newly created pool or NULL on failure.
 */
MMAL_POOL_T *mmal_pool_create_with_allocator(unsigned int headers, uint32_t payload_size,
                              void *allocator_context, mmal_pool_allocator_alloc_t allocator_alloc,
                              mmal_pool_allocator_free_t allocator_free);

/** Destroy a pool of MMAL_BUFFER_HEADER_T.
 * This will also deallocate all of the memory which was allocated when creating or
 * resizing the pool.
 *
 * If payload buffers have been allocated independently by the client, they should be
 * released prior to calling this function. If the client provided allocator functions,
 * the allocator_free function shall be called for each payload buffer.
 *
 * @param pool  Pointer to a pool
 */
void mmal_pool_destroy(MMAL_POOL_T *pool);

/** Resize a pool of MMAL_BUFFER_HEADER_T.
 * This allows modifying either the number of allocated buffers, the payload size or both at the
 * same time.
 *
 * @param pool         Pointer to the pool
 * @param headers      New number of buffer headers to be allocated in the pool.
 *                     It is not valid to pass zero for the number of buffers.
 * @param payload_size Size of the payload buffer that will be allocated in
 *                     each of the buffer headers.
 *                     If this is set to 0, all payload buffers shall be released.
 * @return MMAL_SUCCESS or an error on failure.
 */
MMAL_STATUS_T mmal_pool_resize(MMAL_POOL_T *pool, unsigned int headers, uint32_t payload_size);

/** Definition of the callback used by a pool to signal back to the user that a buffer header
 * has been released back to the pool.
 *
 * @param pool       Pointer to the pool
 * @param buffer     Buffer header just released
 * @param userdata   User specific data passed in when setting the callback
 * @return True to have the buffer header put back in the pool's queue, false if the buffer
 *          header has been taken within the callback.
 */
typedef MMAL_BOOL_T (*MMAL_POOL_BH_CB_T)(MMAL_POOL_T *pool, MMAL_BUFFER_HEADER_T *buffer, void *userdata);

/** Set a buffer header release callback to the pool.
 * Each time a buffer header is released to the pool, the callback will be triggered.
 *
 * @param pool     Pointer to a pool
 * @param cb       Callback function
 * @param userdata User specific data which will be passed with each callback
 */
void mmal_pool_callback_set(MMAL_POOL_T *pool, MMAL_POOL_BH_CB_T cb, void *userdata);

/** Set a pre-release callback for all buffer headers in the pool.
 * Each time a buffer header is about to be released to the pool, the callback
 * will be triggered.
 *
 * @param pool     Pointer to the pool
 * @param cb       Pre-release callback function
 * @param userdata User-specific data passed back with each callback
 */
void mmal_pool_pre_release_callback_set(MMAL_POOL_T *pool, MMAL_BH_PRE_RELEASE_CB_T cb, void *userdata);

/* @} */

#ifdef __cplusplus
}
#endif

#endif /* MMAL_POOL_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_QUEUE_H
#define MMAL_QUEUE_H

#ifdef __cplusplus
extern "C" {
#endif

/** \defgroup MmalQueue Queues of buffer headers
 * This provides a thread-safe implementation of a queue of buffer headers
 * (\ref MMAL_BUFFER_HEADER_T). The queue works in a first-in, first-out basis
 * so the buffer headers will be dequeued in the order they have been queued. */
/* @{ */

#include "mmal_buffer.h"

typedef struct MMAL_QUEUE_T MMAL_QUEUE_T;

/** Create a queue of MMAL_BUFFER_HEADER_T
 *
 * @return Pointer to the newly created queue or NULL on failure.
 */
MMAL_QUEUE_T *mmal_queue_create(void);

/** Put a MMAL_BUFFER_HEADER_T into a queue
 *
 * @param queue  Pointer to a queue
 * @param buffer Pointer to the MMAL_BUFFER_HEADER_T to add to the queue
 */
void mmal_queue_put(MMAL_QUEUE_T *queue, MMAL_BUFFER_HEADER_T *buffer);

/** Put a MMAL_BUFFER_HEADER_T back at the start of a queue.
 * This is used when a buffer header was removed from the queue but not
 * fully processed and needs to be put back where it was originally taken.
 *
 * @param queue  Pointer to a queue
 * @param buffer Pointer to the MMAL_BUFFER_HEADER_T to add to the queue
 */
void mmal_queue_put_back(MMAL_QUEUE_T *queue, MMAL_BUFFER_HEADER_T *buffer);

/** Get a MMAL_BUFFER_HEADER_T from a queue
 *
 * @param queue  Pointer to a queue
 *
 * @return pointer to the next MMAL_BUFFER_HEADER_T or NULL if the queue is empty.
 */
MMAL_BUFFER_HEADER_T *mmal_queue_get(MMAL_QUEUE_T *queue);

/** Wait for a MMAL_BUFFER_HEADER_T from a queue.
 * This is the same as a get except that this will block until a buffer header is
 * available.
 *
 * @param queue  Pointer to a queue
 *
 * @return pointer to the next MMAL_BUFFER_HEADER_T.
 */
MMAL_BUFFER_HEADER_T *mmal_queue_wait(MMAL_QUEUE_T *queue);

/** Wait for a MMAL_BUFFER_HEADER_T from a queue, up to a given timeout.
 * This is the same as a wait, except that it will abort in case of timeout.
 *
 * @param queue  Pointer to a queue
 * @param timeout Number of milliseconds to wait before
 *                returning if the semaphore can't be acquired.
 *
 * @return pointer to the next MMAL_BUFFER_HEADER_T.
 */
MMAL_BUFFER_HEADER_T *mmal_queue_timedwait(MMAL_QUEUE_T *queue, VCOS_UNSIGNED timeout);

/** Get the number of MMAL_BUFFER_HEADER_T currently in a queue.
 *
 * @param queue  Pointer to a queue
 *
 * @return length (in elements) of the queue.
 */
unsigned int mmal_queue_length(MMAL_QUEUE_T *queue);

/** Destroy a queue of MMAL_BUFFER_HEADER_T.
 *
 * @param queue  Pointer to a queue
 */
void mmal_queue_destroy(MMAL_QUEUE_T *queue);

/* @} */

#ifdef __cplusplus
}
#endif

#endif /* MMAL_QUEUE_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_PORT_H
#define MMAL_PORT_H

#ifdef __cplusplus
extern "C" {
#endif

/** \defgroup MmalPort Ports
 * Definition of a MMAL port and its associated API */
/* @{ */

#include "mmal_types.h"
#include "mmal_format.h"
#include "mmal_buffer.h"
#include "mmal_parameters.h"

/** List of port types */
typedef enum
{
   MMAL_PORT_TYPE_UNKNOWN = 0,          /**< Unknown port type */
   MMAL_PORT_TYPE_CONTROL,              /**< Control port */
   MMAL_PORT_TYPE_INPUT,                /**< Input port */
   MMAL_PORT_TYPE_OUTPUT,               /**< Output port */
   MMAL_PORT_TYPE_CLOCK,                /**< Clock port */
   MMAL_PORT_TYPE_INVALID = 0xffffffff  /**< Dummy value to force 32bit enum */

} MMAL_PORT_TYPE_T;

/** \name Port capabilities
 * \anchor portcapabilities
 * The following flags describe the capabilities advertised by a port */
/* @{ */
/** The port is pass-through and doesn't need buffer headers allocated */
#define MMAL_PORT_CAPABILITY_PASSTHROUGH                       0x01
/** The port wants to allocate the buffer payloads. This signals a preference that
 * payload allocation should be done on this port for efficiency reasons. */
#define MMAL_PORT_CAPABILITY_ALLOCATION                        0x02
/** The port supports format change events. This applies to input ports and is used
 * to let the client know whether the port supports being reconfigured via a format
 * change event (i.e. without having to disable the port). */
#define MMAL_PORT_CAPABILITY_SUPPORTS_EVENT_FORMAT_CHANGE      0x04
/* @} */

/** Definition of a port.
 * A port is the entity that is exposed by components to receive or transmit
 * buffer headers (\ref MMAL_BUFFER_HEADER_T). A port is defined by its
 * \ref MMAL_ES_FORMAT_T.
 *
 * It may be possible to override the buffer requirements of a port by using
 * the MMAL_PARAMETER_BUFFER_REQUIREMENTS parameter.
 */
typedef struct MMAL_PORT_T
{
   struct MMAL_PORT_PRIVATE_T *priv; /**< Private member used by the framework */
   const char *name;                 /**< Port name. Used for debugging purposes (Read Only) */

   MMAL_PORT_TYPE_T type;            /**< Type of the port (Read Only) */
   uint16_t index;                   /**< Index of the port in its type list (Read Only) */
   uint16_t index_all;               /**< Index of the port in the list of all ports (Read Only) */

   uint32_t is_enabled;              /**< Indicates whether the port is enabled or not (Read Only) */
   MMAL_ES_FORMAT_T *format;         /**< Format of the elementary stream */

   uint32_t buffer_num_min;          /**< Minimum number of buffers the port requires (Read Only).
                                          This is set by the component. */
   uint32_t buffer_size_min;         /**< Minimum size of buffers the port requires (Read Only).
                                          This is set by the component. */
   uint32_t buffer_alignment_min;    /**< Minimum alignment requirement for the buffers (Read Only).
                                          A value of zero means no special alignment requirements.
                                          This is set by the component. */
   uint32_t buffer_num_recommended;  /**< Number of buffers the port recommends for optimal performance (Read Only).
                                          A value of zero means no special recommendation.
                                          This is set by the component. */
   uint32_t buffer_size_recommended; /**< Size of buffers the port recommends for optimal performance (Read Only).
                                          A value of zero means no special recommendation.
                                          This is set by the component. */
   uint32_t buffer_num;              /**< Actual number of buffers the port will use.
                                          This is set by the client. */
   uint32_t buffer_size;             /**< Actual maximum size of the buffers that will be sent
                                          to the port. This is set by the client. */

   struct MMAL_COMPONENT_T *component;    /**< Component this port belongs to (Read Only) */
   struct MMAL_PORT_USERDATA_T *userdata; /**< Field reserved for use by the client */

   uint32_t capabilities;            /**< Flags describing the capabilities of a port (Read Only).
                                       * Bitwise combination of \ref portcapabilities "Port capabilities"
                                       * values.
                                       */

} MMAL_PORT_T;

/** Commit format changes on a port.
 *
 * @param port The port for which format changes are to be committed.
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_port_format_commit(MMAL_PORT_T *port);

/** Definition of the callback used by a port to send a \ref MMAL_BUFFER_HEADER_T
 * back to the user.
 *
 * @param port The port sending the buffer header.
 * @param buffer The buffer header being sent.
 */
typedef void (*MMAL_PORT_BH_CB_T)(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer);

/** Enable processing on a port
 *
 * If this port is connected to another, the given callback must be NULL, while for a
 * disconnected port, the callback must be non-NULL.
 *
 * If this is a connected output port and is successfully enabled:
 * <ul>
 * <li>The port shall be populated with a pool of buffers, allocated as required, according
 * to the buffer_num and buffer_size values.
 * <li>The input port to which it is connected shall be set to the same buffer
 * configuration and then be enabled. Should that fail, the original port shall be
 * disabled.
 * </ul>
 *
 * @param port port to enable
 * @param cb callback use by the port to send a \ref MMAL_BUFFER_HEADER_T back
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_port_enable(MMAL_PORT_T *port, MMAL_PORT_BH_CB_T cb);

/** Disable processing on a port
 *
 * Disabling a port will stop all processing on this port and return all (non-processed)
 * buffer headers to the client.
 *
 * If this is a connected output port, the input port to which it is connected shall
 * also be disabled. Any buffer pool shall be released.
 *
 * @param port port to disable
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_port_disable(MMAL_PORT_T *port);

/** Ask a port to release all the buffer headers it currently has.
 *
 * Flushing a port will ask the port to send all the buffer headers it currently has
 * to the client. Flushing is an asynchronous request and the flush call will
 * return before all the buffer headers are returned to the client.
 * It is up to the client to keep a count on the buffer headers to know when the
 * flush operation has completed.
 * It is also important to note that flushing will also reset the state of the port
 * and any processing which was buffered by the port will be lost.
 *
 * \attention Flushing a connected port behaviour TBD.
 *
 * @param port The port to flush.
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_port_flush(MMAL_PORT_T *port);

/** Set a parameter on a port.
 *
 * @param port The port to which the request is sent.
 * @param param The pointer to the header of the parameter to set.
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_port_parameter_set(MMAL_PORT_T *port,
   const MMAL_PARAMETER_HEADER_T *param);

/** Get a parameter from a port.
 * The size field must be set on input to the maximum size of the parameter
 * (including the header) and will be set on output to the actual size of the
 * parameter retrieved.
 *
 * \note If MMAL_ENOSPC is returned, the parameter is larger than the size
 * given. The given parameter will have been filled up to its size and then
 * the size field set to the full parameter's size. This can be used to
 * resize the parameter buffer so that a second call should succeed.
 *
 * @param port The port to which the request is sent.
 * @param param The pointer to the header of the parameter to get.
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_port_parameter_get(MMAL_PORT_T *port,
   MMAL_PARAMETER_HEADER_T *param);

/** Send a buffer header to a port.
 *
 * @param port The port to which the buffer header is to be sent.
 * @param buffer The buffer header to send.
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_port_send_buffer(MMAL_PORT_T *port,
   MMAL_BUFFER_HEADER_T *buffer);

/** Connect an output port to an input port.
 *
 * When connected and enabled, buffers will automatically progress from the
 * output port to the input port when they become available, and released back
 * to the output port when no longer required by the input port.
 *
 * Ports can be given either way around, but one must be an output port and
 * the other must be an input port. Neither can be connected or enabled
 * already. The format of the output port will be applied to the input port
 * on connection.
 *
 * @param port One of the ports to connect.
 * @param other_port The other port to connect.
 * @return MMAL_SUCCESS on success.
 */
MMAL_STATUS_T mmal_port_connect(MMAL_PORT_T *port, MMAL_PORT_T *other_port);

/** Disconnect a connected port.
 *
 * If the port is not connected, an error will be returned. Otherwise, if the
 * ports are enabled, they will be disabled and any buffer pool created will be
 * freed.
 *
 * @param port The ports to disconnect.
 * @return MMAL_SUCCESS on success.
 */
MMAL_STATUS_T mmal_port_disconnect(MMAL_PORT_T *port);

/** Allocate a payload buffer.
 * This allows a client to allocate memory for a payload buffer based on the preferences
 * of a port. This for instance will allow the port to allocate memory which can be shared
 * between the host processor and videocore.
 *
 * See \ref mmal_pool_create_with_allocator().
 *
 * @param port         Port responsible for allocating the memory.
 * @param payload_size Size of the payload buffer which will be allocated.
 *
 * @return Pointer to the allocated memory.
 */
uint8_t *mmal_port_payload_alloc(MMAL_PORT_T *port, uint32_t payload_size);

/** Free a payload buffer.
 * This allows a client to free memory allocated by a previous call to \ref mmal_port_payload_alloc.
 *
 * See \ref mmal_pool_create_with_allocator().
 *
 * @param port         Port responsible for allocating the memory.
 * @param payload      Pointer to the memory to free.
 */
void mmal_port_payload_free(MMAL_PORT_T *port, uint8_t *payload);

/** Get an empty event buffer header from a port
 *
 * @param port The port from which to get the event buffer header.
 * @param buffer The address of a buffer header pointer, which will be set on return.
 * @param event The specific event FourCC required. See the \ref MmalEvents "pre-defined events".
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_port_event_get(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T **buffer, uint32_t event);

/* @} */

#ifdef __cplusplus
}
#endif

#endif /* MMAL_PORT_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_BUFFER_PRIVATE_H
#define MMAL_BUFFER_PRIVATE_H

/** Typedef for the private area the framework reserves for the driver / communication layer */
typedef struct MMAL_DRIVER_BUFFER_T MMAL_DRIVER_BUFFER_T;

/** Size of the private area the framework reserves for the driver / communication layer */
#define MMAL_DRIVER_BUFFER_SIZE 32

/** Typedef for the framework's private area in the buffer header */
typedef struct MMAL_BUFFER_HEADER_PRIVATE_T
{
   /** Callback invoked just prior to actually releasing the buffer header. Returns TRUE if
    * release should be delayed. */
   MMAL_BH_PRE_RELEASE_CB_T pf_pre_release;
   void *pre_release_userdata;

   /** Callback used to release / recycle the buffer header. This needs to be set by
    * whoever allocates the buffer header. */
   void (*pf_release)(struct MMAL_BUFFER_HEADER_T *header);
   void *owner;               /**< Context set by the allocator of the buffer header and passed
                                   during the release callback */

   int32_t refcount;          /**< Reference count of the buffer header. When it reaches 0,
                                   the release callback will be called. */

   MMAL_BUFFER_HEADER_T *reference; /**< Reference to another acquired buffer header. */

   /** Callback used to free the payload associated with this buffer header. This is only
    * used if the buffer header was created by MMAL with a payload associated with it. */
   void   (*pf_payload_free)(void *payload_context, void *payload);
   void    *payload;          /**< Pointer / handle to the allocated payload buffer */
   void    *payload_context;  /**< Pointer to the context of the payload allocator */
   uint32_t payload_size;     /**< Allocated size in bytes of payload buffer */

   void *component_data;      /**< Field reserved for use by the component */
   void *payload_handle;      /**< Field reserved for mmal_buffer_header_mem_lock */

   uint8_t driver_area[MMAL_DRIVER_BUFFER_SIZE];

} MMAL_BUFFER_HEADER_PRIVATE_T;

/** Get the size in bytes of a fully initialised MMAL_BUFFER_HEADER_T */
unsigned int mmal_buffer_header_size(MMAL_BUFFER_HEADER_T *header);

/** Initialise a MMAL_BUFFER_HEADER_T */
MMAL_BUFFER_HEADER_T *mmal_buffer_header_initialise(void *mem, unsigned int length);

/** Return a pointer to the area reserved for the driver.
  */
MMAL_DRIVER_BUFFER_T *mmal_buffer_header_driver_data(MMAL_BUFFER_HEADER_T *);

/** Return a pointer to a referenced buffer header.
 * It is the caller's responsibility to ensure that the reference is still
 * valid when using it.
 */
MMAL_BUFFER_HEADER_T *mmal_buffer_header_reference(MMAL_BUFFER_HEADER_T *header);

#endif /* MMAL_BUFFER_PRIVATE_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_CLOCK_PRIVATE_H
#define MMAL_CLOCK_PRIVATE_H

#include "interface/mmal/mmal.h"
#include "interface/mmal/mmal_clock.h"

#ifdef __cplusplus
extern "C" {
#endif


/** Handle to a clock. */
typedef struct MMAL_CLOCK_T
{
   void *user_data;   /**< Client-supplied data (not used by the clock). */
} MMAL_CLOCK_T;

/** Create a new instance of a clock.
 *
 * @param clock Returned clock
 *
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_clock_create(MMAL_CLOCK_T **clock);

/** Destroy a previously created clock.
 *
 * @param clock The clock to destroy
 *
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_clock_destroy(MMAL_CLOCK_T *clock);

/** Definition of a clock request callback.
 * This is invoked when the media-time requested by the client is reached.
 *
 * @param clock      The clock which serviced the request
 * @param media_time The current media-time
 * @param cb_data    Client-supplied data
 * @param priv       Function pointer used by the framework
 */
typedef void (*MMAL_CLOCK_VOID_FP)(void);
typedef void (*MMAL_CLOCK_REQUEST_CB)(MMAL_CLOCK_T *clock, int64_t media_time, void *cb_data, MMAL_CLOCK_VOID_FP priv);

/** Register a request with the clock.
 * When the specified media-time is reached, the clock will invoke the supplied callback.
 *
 * @param clock      The clock
 * @param media_time The media-time at which the callback should be invoked (microseconds)
 * @param cb         Callback to invoke
 * @param cb_data    Client-supplied callback data
 * @param priv       Function pointer used by the framework
 *
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_clock_request_add(MMAL_CLOCK_T *clock, int64_t media_time,
                                     MMAL_CLOCK_REQUEST_CB cb, void *cb_data, MMAL_CLOCK_VOID_FP priv);

/** Remove all previously registered clock requests.
 *
 * @param clock      The clock
 *
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_clock_request_flush(MMAL_CLOCK_T *clock);

/** Update the clock's media-time.
 *
 * @param clock      The clock to update
 * @param media_time New media-time to be applied (microseconds)
 *
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_clock_media_time_set(MMAL_CLOCK_T *clock, int64_t media_time);

/** Set the clock's scale.
 *
 * @param clock      The clock
 * @param scale      Scale factor
 *
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_clock_scale_set(MMAL_CLOCK_T *clock, MMAL_RATIONAL_T scale);

/** Set the clock state.
 *
 * @param clock      The clock
 * @param active     TRUE -> clock is active and media-time is advancing
 *
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_clock_active_set(MMAL_CLOCK_T *clock, MMAL_BOOL_T active);

/** Get the clock's scale.
 *
 * @param clock      The clock
 *
 * @return Current clock scale
 */
MMAL_RATIONAL_T mmal_clock_scale_get(MMAL_CLOCK_T *clock);

/** Get the clock's current media-time.
 * This takes the clock scale and media-time offset into account.
 *
 * @param clock      The clock to query
 *
 * @return Current media-time in microseconds
 */
int64_t mmal_clock_media_time_get(MMAL_CLOCK_T *clock);

/** Get the clock's state.
 *
 * @param clock      The clock to query
 *
 * @return TRUE if clock is running (i.e. local media-time is advancing)
 */
MMAL_BOOL_T mmal_clock_is_active(MMAL_CLOCK_T *clock);

/** Get the clock's media-time update threshold values.
 *
 * @param clock             The clock
 * @param update_threshold  Pointer to clock update threshold values to fill
 *
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_clock_update_threshold_get(MMAL_CLOCK_T *clock, MMAL_CLOCK_UPDATE_THRESHOLD_T *update_threshold);

/** Set the clock's media-time update threshold values.
 *
 * @param clock             The clock
 * @param update_threshold  Pointer to new clock update threshold values
 *
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_clock_update_threshold_set(MMAL_CLOCK_T *clock, const MMAL_CLOCK_UPDATE_THRESHOLD_T *update_threshold);

/** Get the clock's discontinuity threshold values.
 *
 * @param clock      The clock
 * @param discont    Pointer to clock discontinuity threshold values to fill
 *
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_clock_discont_threshold_get(MMAL_CLOCK_T *clock, MMAL_CLOCK_DISCONT_THRESHOLD_T *discont);

/** Set the clock's discontinuity threshold values.
 *
 * @param clock      The clock
 * @param discont    Pointer to new clock discontinuity threshold values
 *
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_clock_discont_threshold_set(MMAL_CLOCK_T *clock, const MMAL_CLOCK_DISCONT_THRESHOLD_T *discont);

/** Get the clock's request threshold values.
 *
 * @param clock      The clock
 * @param future     Pointer to clock request threshold values to fill
 *
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_clock_request_threshold_get(MMAL_CLOCK_T *clock, MMAL_CLOCK_REQUEST_THRESHOLD_T *req);

/** Set the clock's request threshold values.
 *
 * @param clock      The clock
 * @param discont    Pointer to new clock request threshold values
 *
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_clock_request_threshold_set(MMAL_CLOCK_T *clock, const MMAL_CLOCK_REQUEST_THRESHOLD_T *req);

#ifdef __cplusplus
}
#endif

#endif /* MMAL_CLOCK_PRIVATE_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_COMPONENT_PRIVATE_H
#define MMAL_COMPONENT_PRIVATE_H

#ifdef __cplusplus
extern "C" {
#endif

#define MMAL_VIDEO_DECODE  "video_decode"
#define MMAL_VIDEO_ENCODE  "video_encode"
#define MMAL_VIDEO_RENDER  "video_render"
#define MMAL_AUDIO_DECODE  "audio_decode"
#define MMAL_AUDIO_ENCODE  "audio_encode"
#define MMAL_AUDIO_RENDER  "audio_render"
#define MMAL_CAMERA        "camera"

#if defined(__GNUC__) && (__GNUC__ > 2)
# define MMAL_CONSTRUCTOR(func) void __attribute__((constructor,used)) func(void)
# define MMAL_DESTRUCTOR(func) void __attribute__((destructor,used)) func(void)
#else
# define MMAL_CONSTRUCTOR(func) void func(void)
# define MMAL_DESTRUCTOR(func) void func(void)
#endif

#include "mmal.h"
#include "mmal_component.h"

/** Definition of a component. */
struct MMAL_COMPONENT_PRIVATE_T
{
   /** Pointer to the private data of the component module in use */
   struct MMAL_COMPONENT_MODULE_T *module;

   MMAL_STATUS_T (*pf_enable)(MMAL_COMPONENT_T *component);
   MMAL_STATUS_T (*pf_disable)(MMAL_COMPONENT_T *component);
   MMAL_STATUS_T (*pf_destroy)(MMAL_COMPONENT_T *component);

   /** Pool of event buffer headers, for sending events from component to client. */
   MMAL_POOL_T *event_pool;

   /** Reference counting of the component */
   int refcount;
   /** Reference counting of the ports. Component won't be destroyed until this
    * goes to 0 */
   int refcount_ports;

   /** Priority associated with the 'action thread' for this component, when
    * such action thread is applicable. */
   int priority;
};

/** Set a generic component control parameter.
  *
  * @param control_port control port of component on which to set the parameter.
  * @param param        parameter to be set.
  * @return MMAL_SUCCESS or another status on error.
  */
MMAL_STATUS_T mmal_component_parameter_set(MMAL_PORT_T *control_port,
                                           const MMAL_PARAMETER_HEADER_T *param);

/** Get a generic component control parameter.
  *
  * @param contorl_port control port of component from which to get the parameter.
  * @param param        parameter to be retrieved.
  * @return MMAL_SUCCESS or another status on error.
  */
MMAL_STATUS_T mmal_component_parameter_get(MMAL_PORT_T *control_port,
                                           MMAL_PARAMETER_HEADER_T *param);

/** Registers an action with the core.
  * The MMAL core allows components to register an action which will be run
  * from a separate thread context when the action is explicitly triggered by
  * the component.
  *
  * @param component    component registering the action.
  * @param action       action to register.
  * @return MMAL_SUCCESS or another status on error.
  */
MMAL_STATUS_T mmal_component_action_register(MMAL_COMPONENT_T *component,
                                             void (*pf_action)(MMAL_COMPONENT_T *));

/** De-registers the current action registered with the core.
  *
  * @param component    component de-registering the action.
  * @return MMAL_SUCCESS or another status on error.
  */
MMAL_STATUS_T mmal_component_action_deregister(MMAL_COMPONENT_T *component);

/** Triggers a registered action.
  * Explicitly triggers an action registered by a component.
  *
  * @param component    component on which to trigger the action.
  * @return MMAL_SUCCESS or another status on error.
  */
MMAL_STATUS_T mmal_component_action_trigger(MMAL_COMPONENT_T *component);

/** Lock an action to prevent it from running.
  * Allows a component to make sure no action is running while the lock is taken.
  *
  * @param component    component.
  * @return MMAL_SUCCESS or another status on error.
  */
MMAL_STATUS_T mmal_component_action_lock(MMAL_COMPONENT_T *component);

/** Unlock an action to allow it to run again.
  *
  * @param component    component.
  * @return MMAL_SUCCESS or another status on error.
  */
MMAL_STATUS_T mmal_component_action_unlock(MMAL_COMPONENT_T *component);

/** Prototype used by components to register themselves to the supplier. */
typedef MMAL_STATUS_T (*MMAL_COMPONENT_SUPPLIER_FUNCTION_T)(const char *name,
                                                            MMAL_COMPONENT_T *component);

/** Create an instance of a component given a constructor for the component.
 * This allows the creation of client-side components which haven't been registered with the core.
 * See \ref mmal_component_create for the public interface used to create components.
 *
 * @param name name assigned to the component by the client
 * @param constructor constructor function for the component
 * @param constructor_private private data for the constructor
 * @param component returned component
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_component_create_with_constructor(const char *name,
   MMAL_STATUS_T (*constructor)(const char *name, MMAL_COMPONENT_T *),
   struct MMAL_COMPONENT_MODULE_T *constructor_private,
   MMAL_COMPONENT_T **component);

/** Register a component with the mmal component supplier.
  *
  * @param prefix     prefix for this supplier, e.g. "VC"
  * @param create_fn  function which will instantiate a component given a name.
  */
void mmal_component_supplier_register(const char *prefix,
                                      MMAL_COMPONENT_SUPPLIER_FUNCTION_T create_fn);

#ifdef __cplusplus
}
#endif

#endif /* MMAL_COMPONENT_PRIVATE_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_CORE_PRIVATE_H
#define MMAL_CORE_PRIVATE_H

/** Initialise the logging system.
  */
void mmal_logging_init(void);

/** Deinitialise the logging system.
  */
void mmal_logging_deinit(void);

#endif /* MMAL_CORE_PRIVATE_H */

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_EVENTS_PRIVATE_H
#define MMAL_EVENTS_PRIVATE_H

#ifdef __cplusplus
extern "C" {
#endif

#include "mmal_events.h"

/** Send an error event through the component's control port.
 * The error event data will be the MMAL_STATUS_T passed in.
 *
 * @param component component to receive the error event.
 * @param status the error status to be sent.
 * @return MMAL_SUCCESS or an error if the event could not be sent.
 */
MMAL_STATUS_T mmal_event_error_send(MMAL_COMPONENT_T *component, MMAL_STATUS_T status);

/** Send an eos event through a specific port.
 *
 * @param port port to receive the error event.
 * @return MMAL_SUCCESS or an error if the event could not be sent.
 */
MMAL_STATUS_T mmal_event_eos_send(MMAL_PORT_T *port);

/** Forward an event onto an output port.
 * This will allocate a new event buffer on the output port, make a copy
 * of the event buffer which will then be forwarded.
 *
 * @event event to forward.
 * @param port port to forward event to.
 * @return MMAL_SUCCESS or an error if the event could not be forwarded.
 */
MMAL_STATUS_T mmal_event_forward(MMAL_BUFFER_HEADER_T *event, MMAL_PORT_T *port);

#ifdef __cplusplus
}
#endif

#endif /* MMAL_EVENTS_PRIVATE_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_PORT_PRIVATE_H
#define MMAL_PORT_PRIVATE_H

#include "interface/mmal/mmal.h"
#include "interface/mmal/mmal_clock.h"
#include "interface/mmal/core/mmal_events_private.h"

#ifdef __cplusplus
extern "C" {
#endif

/** Definition of a port. */
typedef struct MMAL_PORT_PRIVATE_T
{
   /** Pointer to the private data of the core */
   struct MMAL_PORT_PRIVATE_CORE_T *core;
   /** Pointer to the private data of the module in use */
   struct MMAL_PORT_MODULE_T *module;
   /** Pointer to the private data used by clock ports */
   struct MMAL_PORT_CLOCK_T *clock;

   MMAL_STATUS_T (*pf_set_format)(MMAL_PORT_T *port);
   MMAL_STATUS_T (*pf_enable)(MMAL_PORT_T *port, MMAL_PORT_BH_CB_T);
   MMAL_STATUS_T (*pf_disable)(MMAL_PORT_T *port);
   MMAL_STATUS_T (*pf_send)(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *);
   MMAL_STATUS_T (*pf_flush)(MMAL_PORT_T *port);
   MMAL_STATUS_T (*pf_parameter_set)(MMAL_PORT_T *port, const MMAL_PARAMETER_HEADER_T *param);
   MMAL_STATUS_T (*pf_parameter_get)(MMAL_PORT_T *port, MMAL_PARAMETER_HEADER_T *param);
   MMAL_STATUS_T (*pf_connect)(MMAL_PORT_T *port, MMAL_PORT_T *other_port);

   uint8_t *(*pf_payload_alloc)(MMAL_PORT_T *port, uint32_t payload_size);
   void     (*pf_payload_free)(MMAL_PORT_T *port, uint8_t *payload);

} MMAL_PORT_PRIVATE_T;

/** Callback called by components when a \ref MMAL_BUFFER_HEADER_T needs to be sent back to the
 * user */
void mmal_port_buffer_header_callback(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer);

/** Callback called by components when an event \ref MMAL_BUFFER_HEADER_T needs to be sent to the
 * user. Events differ from ordinary buffer headers because they originate from the component
 * and do not return data from the client to the component. */
void mmal_port_event_send(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer);

/** Allocate a port structure */
MMAL_PORT_T *mmal_port_alloc(MMAL_COMPONENT_T *, MMAL_PORT_TYPE_T type, unsigned int extra_size);
/** Free a port structure */
void mmal_port_free(MMAL_PORT_T *port);
/** Allocate an array of ports */
MMAL_PORT_T **mmal_ports_alloc(MMAL_COMPONENT_T *, unsigned int ports_num, MMAL_PORT_TYPE_T type,
                               unsigned int extra_size);
/** Free an array of ports */
void mmal_ports_free(MMAL_PORT_T **ports, unsigned int ports_num);

/** Acquire a reference on a port */
void mmal_port_acquire(MMAL_PORT_T *port);

/** Release a reference on a port */
MMAL_STATUS_T mmal_port_release(MMAL_PORT_T *port);

/** Pause processing on a port */
MMAL_STATUS_T mmal_port_pause(MMAL_PORT_T *port, MMAL_BOOL_T pause);

/** Returns whether a port is connected or not */
MMAL_BOOL_T mmal_port_is_connected(MMAL_PORT_T *port);

/*****************************************************************************
 * Clock Port API
 *****************************************************************************/
/** Definition of a clock port event callback.
 * Used to inform the client of a clock event that has occurred.
 *
 * @param port       The clock port where the event occurred
 * @param event      The event that has occurred
 */
typedef void (*MMAL_PORT_CLOCK_EVENT_CB)(MMAL_PORT_T *port, const MMAL_CLOCK_EVENT_T *event);

/** Allocate a clock port.
 *
 * @param component  The component requesting the alloc
 * @param extra_size Size of the port module
 * @param event_cb   Clock event callback
 *
 * @return Pointer to new clock port or NULL on failure.
 */
MMAL_PORT_T* mmal_port_clock_alloc(MMAL_COMPONENT_T *component, unsigned int extra_size,
                                   MMAL_PORT_CLOCK_EVENT_CB event_cb);

/** Free a clock port.
 *
 * @param port       The clock port to free
 */
void mmal_port_clock_free(MMAL_PORT_T *port);

/** Allocate an array of clock ports.
 *
 * @param component  The component requesting the alloc
 * @param ports_num  Number of ports to allocate
 * @param extra_size Size of the port module
 * @param event_cb   Clock event callback
 *
 * @return Pointer to a new array of clock ports or NULL on failure.
 */
MMAL_PORT_T **mmal_ports_clock_alloc(MMAL_COMPONENT_T *component, unsigned int ports_num,
                                     unsigned int extra_size, MMAL_PORT_CLOCK_EVENT_CB event_cb);

/** Free an array of clock ports.
 *
 * @param ports      The clock ports to free
 * @param ports_num  Number of ports to free
 */
void mmal_ports_clock_free(MMAL_PORT_T **ports, unsigned int ports_num);

/** Definition of a clock port request callback.
 * This is invoked when the media-time requested by the client is reached.
 *
 * @param port       The clock port which serviced the request
 * @param media_time The current media-time
 * @param cb_data    Client-supplied data
 */
typedef void (*MMAL_PORT_CLOCK_REQUEST_CB)(MMAL_PORT_T *port, int64_t media_time, void *cb_data);

/** Register a request with the clock port.
 * When the specified media-time is reached, the clock port will invoke the supplied callback.
 *
 * @param port       The clock port
 * @param media_time The media-time at which the callback should be invoked (microseconds)
 * @param cb         Callback to invoke
 * @param cb_data    Client-supplied callback data
 *
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_port_clock_request_add(MMAL_PORT_T *port, int64_t media_time,
                                          MMAL_PORT_CLOCK_REQUEST_CB cb, void *cb_data);

/** Remove all previously registered clock port requests.
 *
 * @param port       The clock port
 *
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_port_clock_request_flush(MMAL_PORT_T *port);

/** Get/set the clock port's reference state */
MMAL_STATUS_T mmal_port_clock_reference_set(MMAL_PORT_T *port, MMAL_BOOL_T reference);
MMAL_BOOL_T mmal_port_clock_reference_get(MMAL_PORT_T *port);

/** Get/set the clock port's active state */
MMAL_STATUS_T mmal_port_clock_active_set(MMAL_PORT_T *port, MMAL_BOOL_T active);
MMAL_BOOL_T mmal_port_clock_active_get(MMAL_PORT_T *port);

/** Get/set the clock port's scale */
MMAL_STATUS_T mmal_port_clock_scale_set(MMAL_PORT_T *port, MMAL_RATIONAL_T scale);
MMAL_RATIONAL_T mmal_port_clock_scale_get(MMAL_PORT_T *port);

/** Get/set the clock port's media-time */
MMAL_STATUS_T mmal_port_clock_media_time_set(MMAL_PORT_T *port, int64_t media_time);
int64_t mmal_port_clock_media_time_get(MMAL_PORT_T *port);

/** Get/set the clock port's update threshold */
MMAL_STATUS_T mmal_port_clock_update_threshold_set(MMAL_PORT_T *port,
                                                   const MMAL_CLOCK_UPDATE_THRESHOLD_T *threshold);
MMAL_STATUS_T mmal_port_clock_update_threshold_get(MMAL_PORT_T *port,
                                                   MMAL_CLOCK_UPDATE_THRESHOLD_T *threshold);

/** Get/set the clock port's discontinuity threshold */
MMAL_STATUS_T mmal_port_clock_discont_threshold_set(MMAL_PORT_T *port,
                                                    const MMAL_CLOCK_DISCONT_THRESHOLD_T *threshold);
MMAL_STATUS_T mmal_port_clock_discont_threshold_get(MMAL_PORT_T *port,
                                                    MMAL_CLOCK_DISCONT_THRESHOLD_T *threshold);

/** Get/set the clock port's request threshold */
MMAL_STATUS_T mmal_port_clock_request_threshold_set(MMAL_PORT_T *port,
                                                    const MMAL_CLOCK_REQUEST_THRESHOLD_T *threshold);
MMAL_STATUS_T mmal_port_clock_request_threshold_get(MMAL_PORT_T *port,
                                                    MMAL_CLOCK_REQUEST_THRESHOLD_T *threshold);

/** Provide information regarding a buffer received on the component's input/output port */
void mmal_port_clock_input_buffer_info(MMAL_PORT_T *port, const MMAL_CLOCK_BUFFER_INFO_T *info);
void mmal_port_clock_output_buffer_info(MMAL_PORT_T *port, const MMAL_CLOCK_BUFFER_INFO_T *info);

#ifdef __cplusplus
}
#endif

#endif /* MMAL_PORT_PRIVATE_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/** \file
 * Support for setting/getting parameters as string values.
 */

#ifndef MMAL_PARAM_CONVERT_H
#define MMAL_PARAM_CONVERT_H

#include "interface/mmal/mmal.h"

#ifdef __cplusplus
extern "C" {
#endif

/** Parse a video size. e.g. "1080p" gives 1920x1080.
 *
 * @param w width result
 * @param h height result
 * @param str string to convert
 * @return MMAL_SUCCESS or error code
 */
MMAL_STATUS_T mmal_parse_video_size(uint32_t *w, uint32_t *h, const char *str);

/** Parse a rational number. e.g. "30000/1001", "30", etc.
 * @param dest filled in with result
 * @param str string to convert
 * @return MMAL_SUCCESS or error code
 */
MMAL_STATUS_T mmal_parse_rational(MMAL_RATIONAL_T *dest, const char *str);

/** Parse an integer, e.g. -10, 0x1A, etc.
 * @param dest filled in with result
 * @param str string to convert
 * @return MMAL_SUCCESS or error code
 */
MMAL_STATUS_T mmal_parse_int(int *dest, const char *str);

/** Parse an unsigned integer, e.g. 10, 0x1A, etc.
 * @param dest filled in with result
 * @param str string to convert
 * @return MMAL_SUCCESS or error code
 */
MMAL_STATUS_T mmal_parse_uint(unsigned int *dest, const char *str);

/** Parse a geometry for a rectangle
 *
 * e.g. 100*100+50+75
 * or   200*150
 * @param dest filled in with result
 * @param str string to convert
 * @return MMAL_SUCCESS or error code
 */
MMAL_STATUS_T mmal_parse_geometry(MMAL_RECT_T *dest, const char *str);

/** Parse a video codec name (something that can be encoded/decoded)
 * @param str string to convert
 * @param dest filled in with result
 * @return MMAL_SUCCESS or error code
 */
MMAL_STATUS_T mmal_parse_video_codec(uint32_t *dest, const char *str);

#ifdef __cplusplus
}
#endif

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_WRAPPER_H
#define MMAL_WRAPPER_H

/** \defgroup MmalComponentWrapper utility
 * \ingroup MmalUtilities
 * The component wrapper utility functions can be used in place of common sequences
 * of calls to the MMAL API in order to control a standalone component. It hides some
 * of the complexity in using standalone components behind a fully synchronous
 * interface.
 * @{
 */

#ifdef __cplusplus
extern "C" {
#endif

/** Forward type definition for a wrapper */
typedef struct MMAL_WRAPPER_T MMAL_WRAPPER_T;

/** Definition of the callback used by a wrapper to signal back to the client
 * that a buffer header is available either in the pool or in the output queue.
 *
 * @param wrapper Pointer to the wrapper
 */
typedef void (*MMAL_WRAPPER_CALLBACK_T)(MMAL_WRAPPER_T *wrapper);

/** Structure describing a wrapper around a component */
struct MMAL_WRAPPER_T {

   void *user_data;           /**< Field reserved for use by the client. */
   MMAL_WRAPPER_CALLBACK_T callback; /**< Callback set by the client. */
   MMAL_COMPONENT_T *component;
   MMAL_STATUS_T status;

   MMAL_PORT_T *control;        /**< Control port (Read Only). */

   uint32_t    input_num;       /**< Number of input ports (Read Only). */
   MMAL_PORT_T **input;         /**< Array of input ports (Read Only). */
   MMAL_POOL_T **input_pool;    /**< Array of input pools (Read Only). */

   uint32_t    output_num;      /**< Number of output ports (Read Only). */
   MMAL_PORT_T **output;        /**< Array of output ports (Read Only). */
   MMAL_POOL_T **output_pool;   /**< Array of output pools (Read Only). */
   MMAL_QUEUE_T **output_queue; /**< Array of output queues (Read Only). */

   /* Used for debug / statistics */
   int64_t time_setup;          /**< Time in microseconds taken to setup the connection. */
   int64_t time_enable;         /**< Time in microseconds taken to enable the connection. */
   int64_t time_disable;        /**< Time in microseconds taken to disable the connection. */

};

/** Create a wrapper around a component.
 * The wrapper shall include a pool of buffer headers for each port. The pools will be suitable
 * for the current format of its associated port.
 *
 * @param wrapper    The address of a wrapper pointer that will be set to point to the created
 *                   wrapper.
 * @param name       The name of the component to create.
 * @return MMAL_SUCCESS on success.
 */
MMAL_STATUS_T mmal_wrapper_create(MMAL_WRAPPER_T **wrapper, const char *name);

/** \name MMAL wrapper flags
 * \anchor wrapperflags
 */
/* @{ */
/** The operation should be blocking */
#define MMAL_WRAPPER_FLAG_WAIT 1
/** The pool for the port should allocate memory for the payloads */
#define MMAL_WRAPPER_FLAG_PAYLOAD_ALLOCATE 2
/** The port will use shared memory payloads */
#define MMAL_WRAPPER_FLAG_PAYLOAD_USE_SHARED_MEMORY 4
/* @} */

/** Enable a port on a component wrapper.
 *
 * @param port port to enable
 * @param flags used to specify payload allocation flags for the pool
 * @return MMAL_SUCCESS on success.
 */
MMAL_STATUS_T mmal_wrapper_port_enable(MMAL_PORT_T *port, uint32_t flags);

/** Disable a port on a component wrapper.
 *
 * @param port port to disable
 * @return MMAL_SUCCESS on success.
 */
MMAL_STATUS_T mmal_wrapper_port_disable(MMAL_PORT_T *port);

/** Wait for an empty buffer to be available on a port.
 *
 * @param port port to get an empty buffer from
 * @param buffer points to the retreived buffer on return
 * @param flags specify MMAL_WRAPPER_FLAG_WAIT for a blocking operation
 * @return MMAL_SUCCESS on success.
 */
MMAL_STATUS_T mmal_wrapper_buffer_get_empty(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T **buffer, uint32_t flags);

/** Wait for a full buffer to be available on a port.
 *
 * @param port port to get a full buffer from
 * @param buffer points to the retreived buffer on return
 * @param flags specify MMAL_WRAPPER_FLAG_WAIT for a blocking operation
 * @return MMAL_SUCCESS on success.
 */
MMAL_STATUS_T mmal_wrapper_buffer_get_full(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T **buffer, uint32_t flags);

/** Cancel any ongoing blocking operation on a component wrapper.
 *
 * @param wrapper The wrapper on which to cancel operations.
 * @return MMAL_SUCCESS on success.
 */
MMAL_STATUS_T mmal_wrapper_cancel(MMAL_WRAPPER_T *wrapper);

/** Destroy a wrapper.
 * Destroys a component wrapper and any resources it owns.
 *
 * @param wrapper The wrapper to be destroyed.
 * @return MMAL_SUCCESS on success.
 */
MMAL_STATUS_T mmal_wrapper_destroy(MMAL_WRAPPER_T *wrapper);

#ifdef __cplusplus
}
#endif

/** @} */

#endif /* MMAL_WRAPPER_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_CONNECTION_H
#define MMAL_CONNECTION_H

/** \defgroup MmalConnectionUtility Port connection utility
 * \ingroup MmalUtilities
 * The port connection utility functions can be used in place of common sequences
 * of calls to the MMAL API in order to process buffers being passed between two
 * ports.
 *
 * \section ProcessingConnectionBufferHeaders Processing connection buffer headers
 * Either in response to the client callback function being called, or simply on a
 * timer, the client will need to process the buffer headers of the connection
 * (unless tunneling is used).
 *
 * Buffer headers that are in the pool queue will need to be sent to the output port,
 * while buffer headers in the connection queue are sent to the input port. The
 * buffer headers in the connection queue may contain pixel data (the cmd field is
 * zero) or an event (the cmd field is non-zero). In general, pixel data buffer
 * headers need to be passed on, while event buffer headers are released. In the
 * case of the format changed event, mmal_connection_event_format_changed() can be
 * called before the event is released.
 *
 * Other, specialized use cases may also be implemented, such as getting and
 * immediately releasing buffer headers from the connection queue in order to
 * prevent their propagation. This could be used to drop out video, for example.
 *
 * \section TunnellingConnections Tunnelling connections
 * If the \ref MMAL_CONNECTION_FLAG_TUNNELLING flag is set when the connection is
 * created, MMAL tunneling will be used. This automates the passing of the buffer
 * headers between the output port and input port, and back again. It will also do
 * this as efficiently as possible, avoiding trips between the ARM and the VideoCore
 * if both components are implemented on the VideoCore. The consequence of this is
 * that there is no client callback made as buffer headers get transferred.
 *
 * The client can still monitor the control port of a component (usually a sink
 * component, such as video_render) for the end of stream, in order to know when to
 * dismantle the connection.
 *
 * \section ConnectionClientCallback Client callback
 * When not using tunnelling, the client callback function is called each time a
 * buffer arrives from a port (either input or output).
 *
 * \note The callback is made on a different thread from the one used by the
 * client to set up the connection, so care must be taken with thread safety.
 * One option is to raise a signal to the main client thread that queue processing
 * needs to be done, another is for the callback to perform the queue processing
 * itself.
 *
 * The client can also store an opaque pointer in the connection object, which is
 * never used by the MMAL code and is only meaningful to the client.
 *
 * @{
 */

#ifdef __cplusplus
extern "C" {
#endif

/** \name Connection flags
 * \anchor connectionflags
 * The following flags describe the properties of the connection. */
/* @{ */
/** The connection is tunnelled. Buffer headers do not transit via the client but
 * directly from the output port to the input port. */
#define MMAL_CONNECTION_FLAG_TUNNELLING 0x1
/** Force the pool of buffer headers used by the connection to be allocated on the input port. */
#define MMAL_CONNECTION_FLAG_ALLOCATION_ON_INPUT 0x2
/** Force the pool of buffer headers used by the connection to be allocated on the output port. */
#define MMAL_CONNECTION_FLAG_ALLOCATION_ON_OUTPUT 0x4
/** Specify that the connection should not modify the buffer requirements. */
#define MMAL_CONNECTION_FLAG_KEEP_BUFFER_REQUIREMENTS 0x8
/** The connection is flagged as direct. This doesn't change the behaviour of
 * the connection itself but is used by the the graph utility to specify that
 * the buffer should be sent to the input port from with the port callback. */
#define MMAL_CONNECTION_FLAG_DIRECT 0x10
/** Specify that the connection should not modify the port formats. */
#define MMAL_CONNECTION_FLAG_KEEP_PORT_FORMATS 0x20
/* @} */

/** Forward type definition for a connection */
typedef struct MMAL_CONNECTION_T MMAL_CONNECTION_T;

/** Definition of the callback used by a connection to signal back to the client
 * that a buffer header is available either in the pool or in the output queue.
 *
 * @param connection Pointer to the connection
 */
typedef void (*MMAL_CONNECTION_CALLBACK_T)(MMAL_CONNECTION_T *connection);

/** Structure describing a connection between 2 ports (1 output and 1 input port) */
struct MMAL_CONNECTION_T {

   void *user_data;           /**< Field reserved for use by the client. */
   MMAL_CONNECTION_CALLBACK_T callback; /**< Callback set by the client. */

   uint32_t is_enabled;       /**< Specifies whether the connection is enabled or not (Read Only). */

   uint32_t flags;            /**< Flags passed during the create call (Read Only). A bitwise
                               * combination of \ref connectionflags "Connection flags" values.
                               */
   MMAL_PORT_T *in;           /**< Input port used for the connection (Read Only). */
   MMAL_PORT_T *out;          /**< Output port used for the connection (Read Only). */

   MMAL_POOL_T *pool;         /**< Pool of buffer headers used by the output port (Read Only). */
   MMAL_QUEUE_T *queue;       /**< Queue for the buffer headers produced by the output port (Read Only). */

   const char *name;          /**< Connection name (Read Only). Used for debugging purposes. */

   /* Used for debug / statistics */
   int64_t time_setup;        /**< Time in microseconds taken to setup the connection. */
   int64_t time_enable;       /**< Time in microseconds taken to enable the connection. */
   int64_t time_disable;      /**< Time in microseconds taken to disable the connection. */
};

/** Create a connection between two ports.
 * The connection shall include a pool of buffer headers suitable for the current format of
 * the output port. The format of the input port shall have been set to the same as that of
 * the input port.
 * Note that connections are reference counted and creating a connection automatically
 * acquires a reference to it (released when \ref mmal_connection_destroy is called).
 *
 * @param connection The address of a connection pointer that will be set to point to the created
 * connection.
 * @param out        The output port to use for the connection.
 * @param in         The input port to use for the connection.
 * @param flags      The flags specifying which type of connection should be created.
 *    A bitwise combination of \ref connectionflags "Connection flags" values.
 * @return MMAL_SUCCESS on success.
 */
MMAL_STATUS_T mmal_connection_create(MMAL_CONNECTION_T **connection,
   MMAL_PORT_T *out, MMAL_PORT_T *in, uint32_t flags);

/** Acquire a reference on a connection.
 * Acquiring a reference on a connection will prevent a connection from being destroyed until
 * the acquired reference is released (by a call to \ref mmal_connection_destroy).
 * References are internally counted so all acquired references need a matching call to
 * release them.
 *
 * @param connection connection to acquire
 */
void mmal_connection_acquire(MMAL_CONNECTION_T *connection);

/** Release a reference on a connection
 * Release an acquired reference on a connection. Triggers the destruction of the connection when
 * the last reference is being released.
 * \note This is in fact an alias of \ref mmal_connection_destroy which is added to make client
 * code clearer.
 *
 * @param connection connection to release
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_connection_release(MMAL_CONNECTION_T *connection);

/** Destroy a connection.
 * Release an acquired reference on a connection. Only actually destroys the connection when
 * the last reference is being released.
 * The actual destruction of the connection will start by disabling it, if necessary.
 * Any pool, queue, and so on owned by the connection shall then be destroyed.
 *
 * @param connection The connection to be destroyed.
 * @return MMAL_SUCCESS on success.
 */
MMAL_STATUS_T mmal_connection_destroy(MMAL_CONNECTION_T *connection);

/** Enable a connection.
 * The format of the two ports must have been committed before calling this function,
 * although note that on creation, the connection automatically copies and commits the
 * output port's format to the input port.
 *
 * The MMAL_CONNECTION_T::callback field must have been set if the \ref MMAL_CONNECTION_FLAG_TUNNELLING
 * flag was not specified on creation. The client may also set the MMAL_CONNECTION_T::user_data
 * in order to get a pointer passed, via the connection, to the callback.
 *
 * @param connection The connection to be enabled.
 * @return MMAL_SUCCESS on success.
 */
MMAL_STATUS_T mmal_connection_enable(MMAL_CONNECTION_T *connection);

/** Disable a connection.
 *
 * @param connection The connection to be disabled.
 * @return MMAL_SUCCESS on success.
 */
MMAL_STATUS_T mmal_connection_disable(MMAL_CONNECTION_T *connection);

/** Apply a format changed event to the connection.
 * This function can be used when the client is processing buffer headers and receives
 * a format changed event (\ref MMAL_EVENT_FORMAT_CHANGED). The connection is
 * reconfigured, changing the format of the ports, the number of buffer headers and
 * the size of the payload buffers as necessary.
 *
 * @param connection The connection to which the event shall be applied.
 * @param buffer The buffer containing a format changed event.
 * @return MMAL_SUCCESS on success.
 */
MMAL_STATUS_T mmal_connection_event_format_changed(MMAL_CONNECTION_T *connection,
   MMAL_BUFFER_HEADER_T *buffer);

#ifdef __cplusplus
}
#endif

/** @} */

#endif /* MMAL_CONNECTION_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_UTIL_RATIONAL_H
#define MMAL_UTIL_RATIONAL_H

#include "interface/mmal/mmal_types.h"

/** \defgroup MmalRationalUtilities Rational Utility Functions
 * \ingroup MmalUtilities
 * The rational utility functions allow easy manipulation of rational numbers.
 *
 * @{
 */

#ifdef __cplusplus
extern "C" {
#endif

/** Add 2 rational numbers.
 * It is assumed that both input rational numbers are in
 * their simplest form.
 *
 * @param a First operand
 * @param b Second operand
 *
 * @return a + b
 */
MMAL_RATIONAL_T mmal_rational_add(MMAL_RATIONAL_T a, MMAL_RATIONAL_T b);

/** Subtract 2 rational numbers.
 * It is assumed that both input rational numbers are in
 * their simplest form.
 *
 * @param a        First operand
 * @param b        Second operand
 *
 * @return a - b
 */
MMAL_RATIONAL_T mmal_rational_subtract(MMAL_RATIONAL_T a, MMAL_RATIONAL_T b);

/** Multiply 2 rational numbers.
 * It is assumed that both input rational numbers are in
 * their simplest form.
 *
 * @param a        First operand
 * @param b        Second operand
 *
 * @return a * b
 */
MMAL_RATIONAL_T mmal_rational_multiply(MMAL_RATIONAL_T a, MMAL_RATIONAL_T b);

/** Divide 2 rational numbers.
 * It is assumed that both input rational numbers are in
 * their simplest form.
 *
 * @param a        First operand
 * @param b        Second operand
 *
 * @return a / b
 */
MMAL_RATIONAL_T mmal_rational_divide(MMAL_RATIONAL_T a, MMAL_RATIONAL_T b);

/** Convert a rational number to a 32-bit signed Q16 number.
 * Saturation will occur for rational numbers with an absolute
 * value greater than 32768.
 *
 * @param rational Rational number to convert
 *
 * @return 32-bit signed Q16 number
 */
int32_t mmal_rational_to_fixed_16_16(MMAL_RATIONAL_T rational);

/** Convert a signed 32-bit Q16 number to a rational number.
 *
 * @param fixed    Signed 32-bit Q16 number to convert
 *
 * @return Rational number
 */
MMAL_RATIONAL_T mmal_rational_from_fixed_16_16(int32_t fixed);

/** Reduce a rational number to it's simplest form.
 *
 * @param rational Rational number to simplify
 */
void mmal_rational_simplify(MMAL_RATIONAL_T *rational);

/** Test 2 rational numbers for equality.
 *
 * @param a        First operand
 * @param b        Second operand
 *
 * @return true if equal
 */
MMAL_BOOL_T mmal_rational_equal(MMAL_RATIONAL_T a, MMAL_RATIONAL_T b);

#ifdef __cplusplus
}
#endif

/** @} */

#endif
                                                                                                                                                                         /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_DEFAULT_COMPONENTS_H
#define MMAL_DEFAULT_COMPONENTS_H

/** \defgroup MmalDefaultComponents List of default components
 * This provides a list of default components on a per platform basis.
 * @{
 */

#define MMAL_COMPONENT_DEFAULT_CONTAINER_READER "container_reader"
#define MMAL_COMPONENT_DEFAULT_CONTAINER_WRITER "container_writer"

#if defined(ENABLE_MMAL_STANDALONE)
# define MMAL_COMPONENT_DEFAULT_VIDEO_DECODER    "avcodec.video_decode"
# define MMAL_COMPONENT_DEFAULT_VIDEO_ENCODER    "avcodec.video_encode"
# define MMAL_COMPONENT_DEFAULT_VIDEO_RENDERER   "sdl.video_render"
# define MMAL_COMPONENT_DEFAULT_IMAGE_DECODER    "avcodec.video_decode"
# define MMAL_COMPONENT_DEFAULT_IMAGE_ENCODER    "avcodec.video_encode"
# define MMAL_COMPONENT_DEFAULT_CAMERA           "artificial_camera"
# define MMAL_COMPONENT_DEFAULT_VIDEO_CONVERTER  "avcodec.video_convert"
# define MMAL_COMPONENT_DEFAULT_SPLITTER         "splitter"
# define MMAL_COMPONENT_DEFAULT_SCHEDULER        "scheduler"
# define MMAL_COMPONENT_DEFAULT_VIDEO_INJECTER   "video_inject"
# define MMAL_COMPONENT_DEFAULT_AUDIO_DECODER    "avcodec.audio_decode"
# define MMAL_COMPONENT_DEFAULT_AUDIO_RENDERER   "sdl.audio_render"
# define MMAL_COMPONENT_DEFAULT_MIRACAST         "miracast"
# define MMAL_COMPONENT_DEFAULT_CLOCK            "clock"
#elif defined(__VIDEOCORE__)
# define MMAL_COMPONENT_DEFAULT_VIDEO_DECODER    "ril.video_decode"
# define MMAL_COMPONENT_DEFAULT_VIDEO_ENCODER    "ril.video_encode"
# define MMAL_COMPONENT_DEFAULT_VIDEO_RENDERER   "ril.video_render"
# define MMAL_COMPONENT_DEFAULT_IMAGE_DECODER    "ril.image_decode"
# define MMAL_COMPONENT_DEFAULT_IMAGE_ENCODER    "ril.image_encode"
# define MMAL_COMPONENT_DEFAULT_CAMERA           "ril.camera"
# define MMAL_COMPONENT_DEFAULT_VIDEO_CONVERTER  "video_convert"
# define MMAL_COMPONENT_DEFAULT_SPLITTER         "splitter"
# define MMAL_COMPONENT_DEFAULT_SCHEDULER        "scheduler"
# define MMAL_COMPONENT_DEFAULT_VIDEO_INJECTER   "video_inject"
# define MMAL_COMPONENT_DEFAULT_VIDEO_SPLITTER   "ril.video_splitter"
# define MMAL_COMPONENT_DEFAULT_AUDIO_DECODER    "none"
# define MMAL_COMPONENT_DEFAULT_AUDIO_RENDERER   "ril.audio_render"
# define MMAL_COMPONENT_DEFAULT_MIRACAST         "miracast"
# define MMAL_COMPONENT_DEFAULT_CLOCK            "clock"
# define MMAL_COMPONENT_DEFAULT_CAMERA_INFO      "camera_info"
#else
# define MMAL_COMPONENT_DEFAULT_VIDEO_DECODER    "vc.ril.video_decode"
# define MMAL_COMPONENT_DEFAULT_VIDEO_ENCODER    "vc.ril.video_encode"
# define MMAL_COMPONENT_DEFAULT_VIDEO_RENDERER   "vc.ril.video_render"
# define MMAL_COMPONENT_DEFAULT_IMAGE_DECODER    "vc.ril.image_decode"
# define MMAL_COMPONENT_DEFAULT_IMAGE_ENCODER    "vc.ril.image_encode"
# define MMAL_COMPONENT_DEFAULT_CAMERA           "vc.ril.camera"
# define MMAL_COMPONENT_DEFAULT_VIDEO_CONVERTER  "vc.video_convert"
# define MMAL_COMPONENT_DEFAULT_SPLITTER         "vc.splitter"
# define MMAL_COMPONENT_DEFAULT_SCHEDULER        "vc.scheduler"
# define MMAL_COMPONENT_DEFAULT_VIDEO_INJECTER   "vc.video_inject"
# define MMAL_COMPONENT_DEFAULT_VIDEO_SPLITTER   "vc.ril.video_splitter"
# define MMAL_COMPONENT_DEFAULT_AUDIO_DECODER    "none"
# define MMAL_COMPONENT_DEFAULT_AUDIO_RENDERER   "vc.ril.audio_render"
# define MMAL_COMPONENT_DEFAULT_MIRACAST         "vc.miracast"
# define MMAL_COMPONENT_DEFAULT_CLOCK            "vc.clock"
# define MMAL_COMPONENT_DEFAULT_CAMERA_INFO      "vc.camera_info"
#endif

/** @} */

#endif /* MMAL_DEFAULT_COMPONENTS_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_GRAPH_H
#define MMAL_GRAPH_H

#include "util/mmal_connection.h"

/** \defgroup MmalGraphUtility Graph Utility
 * \ingroup MmalUtilities
 * The graph utility functions allows one to easily create graphs of MMAL components.
 *
 * @{
 */

#ifdef __cplusplus
extern "C" {
#endif

/** List of topology types */
typedef enum
{
   MMAL_GRAPH_TOPOLOGY_ALL = 0,    /**< All input ports and output ports are linked */
   MMAL_GRAPH_TOPOLOGY_STRAIGHT,   /**< Input ports and output ports of the same index are linked */
   MMAL_GRAPH_TOPOLOGY_CUSTOM,     /**< Custom defined topology */
   MMAL_GRAPH_TOPOLOGY_MAX

} MMAL_GRAPH_TOPOLOGY_T;

/** Structure describing a graph */
typedef struct MMAL_GRAPH_T
{
   /** Pointer to private data of the client */
   struct MMAL_GRAPH_USERDATA_T *userdata;

   /** Optional callback that the client can set to get notified when the graph is going to be destroyed */
   void (*pf_destroy)(struct MMAL_GRAPH_T *);

   /** Optional callback that the client can set to intercept parameter requests on ports exposed by the graph */
   MMAL_STATUS_T (*pf_parameter_set)(struct MMAL_GRAPH_T *, MMAL_PORT_T *port, const MMAL_PARAMETER_HEADER_T *param);
   /** Optional callback that the client can set to intercept parameter requests on ports exposed by the graph */
   MMAL_STATUS_T (*pf_parameter_get)(struct MMAL_GRAPH_T *, MMAL_PORT_T *port, MMAL_PARAMETER_HEADER_T *param);
   /** Optional callback that the client can set to intercept format commit calls on ports exposed by the graph */
   MMAL_STATUS_T (*pf_format_commit)(struct MMAL_GRAPH_T *, MMAL_PORT_T *port);
   /** Optional callback that the client can set to intercept send buffer calls on ports exposed by the graph */
   MMAL_STATUS_T (*pf_send_buffer)(struct MMAL_GRAPH_T *, MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer);
   /** Optional callback that the client can set to intercept buffer callbacks on ports exposed by the graph */
   MMAL_STATUS_T (*pf_return_buffer)(struct MMAL_GRAPH_T *, MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer);
   /** Optional callback that the client can set to intercept payload alloc calls on ports exposed by the graph */
   MMAL_STATUS_T (*pf_payload_alloc)(struct MMAL_GRAPH_T *, MMAL_PORT_T *port, uint32_t payload_size, uint8_t **);
   /** Optional callback that the client can set to intercept payload free calls on ports exposed by the graph */
   MMAL_STATUS_T (*pf_payload_free)(struct MMAL_GRAPH_T *, MMAL_PORT_T *port, uint8_t *payload);
   /** Optional callback that the client can set to intercept flush calls on ports exposed by the graph */
   MMAL_STATUS_T (*pf_flush)(struct MMAL_GRAPH_T *, MMAL_PORT_T *port);
   /** Optional callback that the client can set to control callbacks from the internal components of the graph */
   /** Optional callback that the client can set to intercept enable calls on ports exposed by the graph */
   MMAL_STATUS_T (*pf_enable)(struct MMAL_GRAPH_T *, MMAL_PORT_T *port);
   /** Optional callback that the client can set to intercept disable calls on ports exposed by the graph */
   MMAL_STATUS_T (*pf_disable)(struct MMAL_GRAPH_T *, MMAL_PORT_T *port);
   /** Optional callback that the client can set to control callbacks from the internal components of the graph */
   MMAL_STATUS_T (*pf_control_callback)(struct MMAL_GRAPH_T *, MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer);
   /** Optional callback that the client can set to intercept component_enable/disable calls made to the graph */
   MMAL_STATUS_T (*pf_graph_enable)(struct MMAL_GRAPH_T *, MMAL_BOOL_T enable);
   /** Optional callback that the client can set to intercept buffers going through internal connections.
    * This will only be triggered if the connection is not tunnelled */
   MMAL_STATUS_T (*pf_connection_buffer)(struct MMAL_GRAPH_T *, MMAL_CONNECTION_T *connection, MMAL_BUFFER_HEADER_T *buffer);

} MMAL_GRAPH_T;

/** Create an instance of a graph.
 * The newly created graph will need to be populated by the client.
 *
 * @param graph returned graph
 * @param userdata_size size to be allocated for the userdata field
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_graph_create(MMAL_GRAPH_T **graph, unsigned int userdata_size);

/** Add a component to a graph.
 * Allows the client to add a component to the graph.
 *
 * @param graph instance of the graph
 * @param component component to add to a graph
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_graph_add_component(MMAL_GRAPH_T *graph, MMAL_COMPONENT_T *component);

/** Describe the topology of the ports of a component.
 * Allows the client to describe the topology of a component. This information
 * is used by the graph to choose which action to perform when
 * enabling / disabling / committing / flushing a port exposed by the graph.
 * Note that by default the topology of a component is set to MMAL_GRAPH_TOPOLOGY_ALL.
 *
 * @param graph instance of the graph
 * @param component component to describe
 * @param topology type of topology used by this component
 * @param input output index (or -1 if sink) linked to each input port
 * @param input_num number of indexes in the input list
 * @param output input index (or -1 if source) linked to each output port
 * @param output_num number of indexes in the output list
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_graph_component_topology(MMAL_GRAPH_T *graph, MMAL_COMPONENT_T *component,
    MMAL_GRAPH_TOPOLOGY_T topology, int8_t *input, unsigned int input_num,
    int8_t *output, unsigned int output_num);

/** Add a port to a graph.
 * Allows the client to add an input or output port to a graph. The given port
 * will effectively become an end point for the graph.
 *
 * @param graph instance of the graph
 * @param port port to add to the graph
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_graph_add_port(MMAL_GRAPH_T *graph, MMAL_PORT_T *port);

/** Add a connection to a graph.
 * Allows the client to add an internal connection to a graph.
 *
 * @param graph instance of the graph
 * @param connection connection to add to the graph
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_graph_add_connection(MMAL_GRAPH_T *graph, MMAL_CONNECTION_T *connection);

/** Create a new component and add it to a graph.
 * Allows the client to create and add a component to the graph.
 *
 * @param graph instance of the graph
 * @param name name of the component to create
 * @param component if not NULL, will contain a pointer to the created component
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_graph_new_component(MMAL_GRAPH_T *graph, const char *name,
   MMAL_COMPONENT_T **component);

/** Create and add a connection to a graph.
 * Allows the client to create and add an internal connection to a graph.
 *
 * @param graph      instance of the graph
 * @param out        the output port to use for the connection
 * @param in         the input port to use for the connection
 * @param flags      the flags specifying which type of connection should be created
 * @param connection if not NULL, will contain a pointer to the created connection
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_graph_new_connection(MMAL_GRAPH_T *graph, MMAL_PORT_T *out, MMAL_PORT_T *in,
   uint32_t flags, MMAL_CONNECTION_T **connection);

/** Definition of the callback used by a graph to send events to the client.
 *
 * @param graph   the graph sending the event
 * @param port    the port which generated the event
 * @param buffer  the buffer header containing the event data
 * @param cb_data data passed back to the client when the callback is invoked
 */
typedef void (*MMAL_GRAPH_EVENT_CB)(MMAL_GRAPH_T *graph, MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer,
   void *cb_data);

/** Enable the graph and start processing.
 *
 * @param graph   the graph to enable
 * @param cb      the callback to invoke when an event occurs on any of the internal control ports
 * @param cb_data data passed back to the client when the callback is invoked
 *
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_graph_enable(MMAL_GRAPH_T *graph, MMAL_GRAPH_EVENT_CB cb, void *cb_data);

MMAL_STATUS_T mmal_graph_disable(MMAL_GRAPH_T *graph);

/** Find a port in the graph.
 *
 * @param graph graph instance
 * @param name  name of the component of interest
 * @param type  type of port (in/out)
 * @param index which port index within the component
 *
 * @return port, or NULL if not found
 */
MMAL_PORT_T *mmal_graph_find_port(MMAL_GRAPH_T *graph,
                                  const char *name,
                                  MMAL_PORT_TYPE_T type,
                                  unsigned index);

/** Create an instance of a component from a graph.
 * The newly created component will expose input and output ports to the client.
 * Not that all the exposed ports will be in a disabled state by default.
 *
 * @param graph graph to create the component from
 * @param name name of the component to create
 * @param component returned component
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_graph_build(MMAL_GRAPH_T *ctx,
   const char *name, MMAL_COMPONENT_T **component);

/** Component constructor for a graph.
 * FIXME: private function
 *
 * @param name name of the component to create
 * @param component component
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_graph_component_constructor(const char *name, MMAL_COMPONENT_T *component);

/** Destroy a previously created graph
 * @param graph graph to destroy
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_graph_destroy(MMAL_GRAPH_T *ctx);

#ifdef __cplusplus
}
#endif

/** @} */

#endif /* MMAL_GRAPH_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_IL_H
#define MMAL_IL_H

/** \defgroup MmalILUtility MMAL to OMX IL conversion utilities
 * \ingroup MmalUtilities
 *
 * @{
 */

#ifdef __cplusplus
extern "C" {
#endif

#include "interface/vmcs_host/khronos/IL/OMX_Core.h"
#include "interface/vmcs_host/khronos/IL/OMX_Component.h"
#include "interface/vmcs_host/khronos/IL/OMX_Video.h"
#include "interface/vmcs_host/khronos/IL/OMX_Audio.h"
#include "interface/vmcs_host/khronos/IL/OMX_Broadcom.h"

/** Convert MMAL status codes into OMX error codes.
 *
 * @param status MMAL status code.
 * @return OMX error code.
 */
OMX_ERRORTYPE mmalil_error_to_omx(MMAL_STATUS_T status);

/** Convert OMX error codes into MMAL status codes.
 *
 * @param error OMX error code.
 * @return MMAL status code.
 */
MMAL_STATUS_T mmalil_error_to_mmal(OMX_ERRORTYPE error);

/** Convert MMAL buffer header flags into OMX buffer header flags.
 *
 * @param flags OMX buffer header flags.
 * @return MMAL buffer header flags.
 */
uint32_t mmalil_buffer_flags_to_mmal(OMX_U32 flags);

/** Convert OMX buffer header flags into MMAL buffer header flags.
 *
 * @param flags MMAL buffer header flags.
 * @return OMX buffer header flags.
 */
OMX_U32 mmalil_buffer_flags_to_omx(uint32_t flags);

/** Convert MMAL buffer header type video specific flags into OMX buffer header
 * flags.
 *
 * @param flags OMX buffer header flags.
 * @return MMAL buffer header video specific flags.
 */
uint32_t mmalil_video_buffer_flags_to_mmal(OMX_U32 flags);

/** Convert OMX buffer header flags into MMAL buffer header type video specific
 * flags.
 *
 * @param flags MMAL buffer header video specific flags.
 * @return OMX buffer header flags.
 */
OMX_U32 mmalil_video_buffer_flags_to_omx(uint32_t flags);

/** Convert a MMAL buffer header into an OMX buffer header.
 * Note that only the fields which have a direct mapping between OMX and MMAL are converted.
 *
 * @param omx  Pointer to the destination OMX buffer header.
 * @param mmal Pointer to the source MMAL buffer header.
 */
void mmalil_buffer_header_to_omx(OMX_BUFFERHEADERTYPE *omx, MMAL_BUFFER_HEADER_T *mmal);

/** Convert an OMX buffer header into a MMAL buffer header.
 *
 * @param mmal Pointer to the destination MMAL buffer header.
 * @param omx  Pointer to the source OMX buffer header.
 */
void mmalil_buffer_header_to_mmal(MMAL_BUFFER_HEADER_T *mmal, OMX_BUFFERHEADERTYPE *omx);

OMX_PORTDOMAINTYPE mmalil_es_type_to_omx_domain(MMAL_ES_TYPE_T type);
MMAL_ES_TYPE_T mmalil_omx_domain_to_es_type(OMX_PORTDOMAINTYPE domain);
uint32_t mmalil_omx_audio_coding_to_encoding(OMX_AUDIO_CODINGTYPE coding);
OMX_AUDIO_CODINGTYPE mmalil_encoding_to_omx_audio_coding(uint32_t encoding);
uint32_t mmalil_omx_video_coding_to_encoding(OMX_VIDEO_CODINGTYPE coding);
OMX_VIDEO_CODINGTYPE mmalil_encoding_to_omx_video_coding(uint32_t encoding);
uint32_t mmalil_omx_image_coding_to_encoding(OMX_IMAGE_CODINGTYPE coding);
OMX_IMAGE_CODINGTYPE mmalil_encoding_to_omx_image_coding(uint32_t encoding);
uint32_t mmalil_omx_coding_to_encoding(uint32_t encoding, OMX_PORTDOMAINTYPE domain);
uint32_t mmalil_omx_color_format_to_encoding(OMX_COLOR_FORMATTYPE coding);
OMX_COLOR_FORMATTYPE mmalil_encoding_to_omx_color_format(uint32_t encoding);
uint32_t mmalil_omx_bayer_format_order_to_encoding(OMX_BAYERORDERTYPE bayer_order, OMX_COLOR_FORMATTYPE color_format);
OMX_BAYERORDERTYPE mmalil_encoding_to_omx_bayer_order(uint32_t encoding);
uint32_t mmalil_omx_color_space_to_mmal(OMX_COLORSPACETYPE coding);
OMX_COLORSPACETYPE mmalil_color_space_to_omx(uint32_t coding);
uint32_t mmalil_omx_video_profile_to_mmal(OMX_U32 level, OMX_VIDEO_CODINGTYPE coding);
OMX_U32 mmalil_video_profile_to_omx(uint32_t profile);
uint32_t mmalil_omx_video_level_to_mmal(OMX_U32 level, OMX_VIDEO_CODINGTYPE coding);
OMX_U32 mmalil_video_level_to_omx(uint32_t level);
MMAL_VIDEO_RATECONTROL_T mmalil_omx_video_ratecontrol_to_mmal(OMX_VIDEO_CONTROLRATETYPE omx);
OMX_VIDEO_CONTROLRATETYPE mmalil_video_ratecontrol_to_omx(MMAL_VIDEO_RATECONTROL_T mmal);
MMAL_VIDEO_INTRA_REFRESH_T mmalil_omx_video_intrarefresh_to_mmal(OMX_VIDEO_INTRAREFRESHTYPE omx);

/** Union of all the OMX_VIDEO/AUDIO_PARAM types */
typedef union OMX_FORMAT_PARAM_TYPE {
   OMX_PARAM_U32TYPE common;

   /* Video */
   OMX_VIDEO_PARAM_AVCTYPE avc;
   OMX_VIDEO_PARAM_H263TYPE h263;
   OMX_VIDEO_PARAM_MPEG2TYPE mpeg2;
   OMX_VIDEO_PARAM_MPEG4TYPE mpeg4;
   OMX_VIDEO_PARAM_WMVTYPE wmv;
   OMX_VIDEO_PARAM_RVTYPE rv;

   /* Audio */
   OMX_AUDIO_PARAM_PCMMODETYPE pcm;
   OMX_AUDIO_PARAM_MP3TYPE mp3;
   OMX_AUDIO_PARAM_AACPROFILETYPE aac;
   OMX_AUDIO_PARAM_VORBISTYPE vorbis;
   OMX_AUDIO_PARAM_WMATYPE wma;
   OMX_AUDIO_PARAM_RATYPE ra;
   OMX_AUDIO_PARAM_SBCTYPE sbc;
   OMX_AUDIO_PARAM_ADPCMTYPE adpcm;
   OMX_AUDIO_PARAM_G723TYPE g723;
   OMX_AUDIO_PARAM_G726TYPE g726;
   OMX_AUDIO_PARAM_G729TYPE g729;
   OMX_AUDIO_PARAM_AMRTYPE amr;
   OMX_AUDIO_PARAM_GSMFRTYPE gsmfr;
   OMX_AUDIO_PARAM_GSMHRTYPE gsmhr;
   OMX_AUDIO_PARAM_GSMEFRTYPE gsmefr;
   OMX_AUDIO_PARAM_TDMAFRTYPE tdmafr;
   OMX_AUDIO_PARAM_TDMAEFRTYPE tdmaefr;
   OMX_AUDIO_PARAM_PDCFRTYPE pdcfr;
   OMX_AUDIO_PARAM_PDCEFRTYPE pdcefr;
   OMX_AUDIO_PARAM_PDCHRTYPE pdchr;
   OMX_AUDIO_PARAM_QCELP8TYPE qcelp8;
   OMX_AUDIO_PARAM_QCELP13TYPE qcelp13;
   OMX_AUDIO_PARAM_EVRCTYPE evrc;
   OMX_AUDIO_PARAM_SMVTYPE smv;
   OMX_AUDIO_PARAM_MIDITYPE midi;
#ifdef OMX_AUDIO_CodingDDP_Supported
   OMX_AUDIO_PARAM_DDPTYPE ddp;
#endif
#ifdef OMX_AUDIO_CodingDTS_Supported
   OMX_AUDIO_PARAM_DTSTYPE dts;
#endif

} OMX_FORMAT_PARAM_TYPE;

/** Get the OMX_IndexParamAudio index corresponding to a specified audio coding type.
 *
 * @param coding Audio coding type.
 * @param size  Pointer used to return the size of the parameter.
 *
 * @return OMX index or 0 if no match was found.
 */
OMX_INDEXTYPE mmalil_omx_audio_param_index(OMX_AUDIO_CODINGTYPE coding, OMX_U32 *size);

/** Get the audio coding corresponding to a specified OMX_IndexParamAudio index.
 *
 * @param index Audio coding type.
 *
 * @return Audio coding type.
 */
OMX_AUDIO_CODINGTYPE mmalil_omx_audio_param_index_to_coding(OMX_INDEXTYPE index);

/** Setup a default channel mapping based on the number of channels
 * @param channel_mapping The output channel mapping
 * @param nchannels Number of channels
 *
 * @return MMAL_SUCCESS if we managed to produce a channel mapping
 */
MMAL_STATUS_T mmalil_omx_default_channel_mapping(OMX_AUDIO_CHANNELTYPE *channel_mapping, unsigned int nchannels);

/** Convert an OMX_IndexParamAudio into a MMAL elementary stream format.
 *
 * @param format Format structure to update.
 * @param coding Audio coding type.
 * @param param  Source OMX_IndexParamAudio structure.
 *
 * @return The MMAL encoding if a match was found or MMAL_ENCODING_UNKNOWN otherwise.
 */
MMAL_FOURCC_T mmalil_omx_audio_param_to_format(MMAL_ES_FORMAT_T *format,
   OMX_AUDIO_CODINGTYPE coding, OMX_FORMAT_PARAM_TYPE *param);

/** Convert a MMAL elementary stream format into a OMX_IndexParamAudio structure.
 *
 * @param param  OMX_IndexParamAudio structure to update.
 * @param param_index returns the OMX_IndexParamAudio index corresponding to the format.
 * @param format Source format structure.
 *
 * @return The OMX aduio coding type if a match was found or OMX_AUDIO_CodingUnused otherwise.
 */
OMX_AUDIO_CODINGTYPE mmalil_format_to_omx_audio_param(OMX_FORMAT_PARAM_TYPE *param,
   OMX_INDEXTYPE *param_index, MMAL_ES_FORMAT_T *format);

#ifdef __cplusplus
}
#endif

/** @} */

#endif /* MMAL_IL_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_LIST_H
#define MMAL_LIST_H

#ifdef __cplusplus
extern "C" {
#endif

/** \defgroup MmalList Generic Linked List
 * This provides a thread-safe implementation of a linked list which can be used
 * with any data type. */
/* @{ */

/** Single element in the list */
typedef struct MMAL_LIST_ELEMENT_T
{
   struct MMAL_LIST_ELEMENT_T *next;
   struct MMAL_LIST_ELEMENT_T *prev;
} MMAL_LIST_ELEMENT_T;

/** Linked list type.
 * Clients shouldn't modify this directly. Use the provided API functions to
 * add new elements. The public members are only for debug purposes.
 * */
typedef struct MMAL_LIST_T
{
   unsigned int length;         /**< Number of elements in the list (read-only) */
   MMAL_LIST_ELEMENT_T *first;  /**< First element in the list (read-only) */
   MMAL_LIST_ELEMENT_T *last;   /**< Last element in the list (read-only) */
} MMAL_LIST_T;

/** Create a new linked list.
 *
 * @return Pointer to new queue (NULL on failure).
 */
MMAL_LIST_T* mmal_list_create(void);

/** Destroy a linked list.
 *
 * @param list List to destroy
 */
void mmal_list_destroy(MMAL_LIST_T *list);

/** Remove the last element in the list.
 *
 * @param list    List to remove from
 *
 * @return Pointer to the last element (or NULL if empty)
 */
MMAL_LIST_ELEMENT_T* mmal_list_pop_back(MMAL_LIST_T *list);

/** Remove the first element in the list.
 *
 * @param list    List to remove from
 *
 * @return Pointer to the first element (or NULL if empty)
 */
MMAL_LIST_ELEMENT_T* mmal_list_pop_front(MMAL_LIST_T *list);

/** Add an element to the front of the list.
 *
 * @param list    List to add to
 * @param element The element to add
 */
void mmal_list_push_front(MMAL_LIST_T *list, MMAL_LIST_ELEMENT_T *element);

/** Add an element to the back of the list.
 *
 * @param list    List to add to
 * @param element The element to add
 */
void mmal_list_push_back(MMAL_LIST_T *list, MMAL_LIST_ELEMENT_T *element);

/** List comparison function.
 * This is supplied by a client when inserting an element in
 * the middle of the list. The list will always insert a smaller
 * element in front of a larger element.
 *
 * @return TRUE:  lhs <  rhs
 *         FALSE: lhs >= rhs
 */
typedef int (*MMAL_LIST_COMPARE_T)(MMAL_LIST_ELEMENT_T *lhs, MMAL_LIST_ELEMENT_T *rhs);

/** Insert an element into the list.
 * The location where the element is inserted is determined using
 * the supplied comparison function. Smaller elements are inserted
 * in front of larger elements.
 *
 * @param list    List to add to
 * @param element The element to insert
 * @param compare Comparison function supplied by the client
 */
void mmal_list_insert(MMAL_LIST_T *list, MMAL_LIST_ELEMENT_T *element, MMAL_LIST_COMPARE_T compare);

/* @} */

#ifdef __cplusplus
}
#endif

#endif /* MMAL_LIST_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_UTIL_H
#define MMAL_UTIL_H

#include "interface/mmal/mmal.h"

/** \defgroup MmalUtilities Utility functions
 * The utility functions provide helpers for common functionality that is not part
 * of the core MMAL API.
 * @{
 */

/** Offset in bytes of FIELD in TYPE. */
#define MMAL_OFFSET(TYPE, FIELD) ((size_t)((uint8_t *)&((TYPE*)0)->FIELD - (uint8_t *)0))

#ifdef __cplusplus
extern "C" {
#endif

/** Convert a status to a statically-allocated string.
 *
 * @param status The MMAL status code.
 * @return A C string describing the status code.
 */
const char *mmal_status_to_string(MMAL_STATUS_T status);

/** Convert stride to pixel width for a given pixel encoding.
 *
 * @param encoding The pixel encoding (such as one of the \ref MmalEncodings "pre-defined encodings")
 * @param stride The stride in bytes.
 * @return The width in pixels.
 */
uint32_t mmal_encoding_stride_to_width(uint32_t encoding, uint32_t stride);

/** Convert pixel width to stride for a given pixel encoding
 *
 * @param encoding The pixel encoding (such as one of the \ref MmalEncodings "pre-defined encodings")
 * @param width The width in pixels.
 * @return The stride in bytes.
 */
uint32_t mmal_encoding_width_to_stride(uint32_t encoding, uint32_t width);

/** Return the 16 line high sliced version of a given pixel encoding
 *
 * @param encoding The pixel encoding (such as one of the \ref MmalEncodings "pre-defined encodings")
 * @return The sliced equivalent, or MMAL_ENCODING_UNKNOWN if not supported.
 */
uint32_t mmal_encoding_get_slice_variant(uint32_t encoding);

/** Convert a port type to a string.
 *
 * @param type The MMAL port type.
 * @return A NULL-terminated string describing the port type.
 */
const char* mmal_port_type_to_string(MMAL_PORT_TYPE_T type);

/** Get a parameter from a port allocating the required amount of memory
 * for the parameter (i.e. for variable length parameters like URI or arrays).
 * The size field will be set on output to the actual size of the
 * parameter allocated and retrieved.
 *
 * The pointer returned must be released by a call to \ref mmal_port_parameter_free().
 *
 * @param port port to send request to
 * @param id parameter id
 * @param size initial size hint for allocation (can be 0)
 * @param status status of the parameter get operation (can be 0)
 * @return pointer to the header of the parameter or NULL on failure.
 */
MMAL_PARAMETER_HEADER_T *mmal_port_parameter_alloc_get(MMAL_PORT_T *port,
   uint32_t id, uint32_t size, MMAL_STATUS_T *status);

/** Free a parameter structure previously allocated via
 * \ref mmal_port_parameter_alloc_get().
 *
 * @param param pointer to header of the parameter
 */
void mmal_port_parameter_free(MMAL_PARAMETER_HEADER_T *param);

/** Copy buffer header metadata from source to destination.
 *
 * @param dest The destination buffer header.
 * @param src  The source buffer header.
 */
void mmal_buffer_header_copy_header(MMAL_BUFFER_HEADER_T *dest, const MMAL_BUFFER_HEADER_T *src);

/** Create a pool of MMAL_BUFFER_HEADER_T associated with a specific port.
 * This allows a client to allocate memory for the payload buffers based on the preferences
 * of a port. This for instance will allow the port to allocate memory which can be shared
 * between the host processor and videocore.
 * After allocation, all allocated buffer headers will have been added to the queue.
 *
 * It is valid to create a pool with no buffer headers, or with zero size payload buffers.
 * The mmal_pool_resize() function can be used to increase or decrease the number of buffer
 * headers, or the size of the payload buffers, after creation of the pool.
 *
 * @param port         Port responsible for creating the pool.
 * @param headers      Number of buffers which will be allocated with the pool.
 * @param payload_size Size of the payload buffer which will be allocated in
 *                     each of the buffer headers.
 * @return Pointer to the newly created pool or NULL on failure.
 */
MMAL_POOL_T *mmal_port_pool_create(MMAL_PORT_T *port,
   unsigned int headers, uint32_t payload_size);

/** Destroy a pool of MMAL_BUFFER_HEADER_T associated with a specific port.
 * This will also deallocate all of the memory which was allocated when creating or
 * resizing the pool.
 *
 * @param port  Pointer to the port responsible for creating the pool.
 * @param pool  Pointer to the pool to be destroyed.
 */
void mmal_port_pool_destroy(MMAL_PORT_T *port, MMAL_POOL_T *pool);

/** Log the content of a \ref MMAL_PORT_T structure.
 *
 * @param port  Pointer to the port to dump.
 */
void mmal_log_dump_port(MMAL_PORT_T *port);

/** Log the content of a \ref MMAL_ES_FORMAT_T structure.
 *
 * @param format  Pointer to the format to dump.
 */
void mmal_log_dump_format(MMAL_ES_FORMAT_T *format);

/** Return the nth port.
 *
 * @param comp   component to query
 * @param index  port index
 * @param type   port type
 *
 * @return port or NULL if not found
 */
MMAL_PORT_T *mmal_util_get_port(MMAL_COMPONENT_T *comp, MMAL_PORT_TYPE_T type, unsigned index);

/** Convert a 4cc into a string.
 *
 * @param buf    Destination for result
 * @param len    Size of result buffer
 * @param fourcc 4cc to be converted
 * @return converted string (buf)
 *
 */
char *mmal_4cc_to_string(char *buf, size_t len, uint32_t fourcc);


/** On FW prior to June 2016, camera and video_splitter
 *  had BGR24 and RGB24 support reversed.
 *  This is now fixed, and this function will return whether the
 *  FW has the fix or not.
 *
 * @param port   MMAL port to check (on camera or video_splitter)
 * @return 0 if old firmware, 1 if new.
 *
 */
int mmal_util_rgb_order_fixed(MMAL_PORT_T *port);

#ifdef __cplusplus
}
#endif

/** @} */

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_UTIL_PARAMS_H
#define MMAL_UTIL_PARAMS_H

#include "interface/mmal/mmal.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @file
 * Utility functions to set some common parameters.
 */

/** Helper function to set the value of a boolean parameter.
 * @param port   port on which to set the parameter
 * @param id     parameter id
 * @param value  value to set the parameter to
 *
 * @return MMAL_SUCCESS or error
 */
MMAL_STATUS_T mmal_port_parameter_set_boolean(MMAL_PORT_T *port, uint32_t id, MMAL_BOOL_T value);

/** Helper function to get the value of a boolean parameter.
 * @param port   port on which to get the parameter
 * @param id     parameter id
 * @param value  pointer to where the value will be returned
 *
 * @return MMAL_SUCCESS or error
 */
MMAL_STATUS_T mmal_port_parameter_get_boolean(MMAL_PORT_T *port, uint32_t id, MMAL_BOOL_T *value);

/** Helper function to set the value of a 64 bits unsigned integer parameter.
 * @param port   port on which to set the parameter
 * @param id     parameter id
 * @param value  value to set the parameter to
 *
 * @return MMAL_SUCCESS or error
 */
MMAL_STATUS_T mmal_port_parameter_set_uint64(MMAL_PORT_T *port, uint32_t id, uint64_t value);

/** Helper function to get the value of a 64 bits unsigned integer parameter.
 * @param port   port on which to get the parameter
 * @param id     parameter id
 * @param value  pointer to where the value will be returned
 *
 * @return MMAL_SUCCESS or error
 */
MMAL_STATUS_T mmal_port_parameter_get_uint64(MMAL_PORT_T *port, uint32_t id, uint64_t *value);

/** Helper function to set the value of a 64 bits signed integer parameter.
 * @param port   port on which to set the parameter
 * @param id     parameter id
 * @param value  value to set the parameter to
 *
 * @return MMAL_SUCCESS or error
 */
MMAL_STATUS_T mmal_port_parameter_set_int64(MMAL_PORT_T *port, uint32_t id, int64_t value);

/** Helper function to get the value of a 64 bits signed integer parameter.
 * @param port   port on which to get the parameter
 * @param id     parameter id
 * @param value  pointer to where the value will be returned
 *
 * @return MMAL_SUCCESS or error
 */
MMAL_STATUS_T mmal_port_parameter_get_int64(MMAL_PORT_T *port, uint32_t id, int64_t *value);

/** Helper function to set the value of a 32 bits unsigned integer parameter.
 * @param port   port on which to set the parameter
 * @param id     parameter id
 * @param value  value to set the parameter to
 *
 * @return MMAL_SUCCESS or error
 */
MMAL_STATUS_T mmal_port_parameter_set_uint32(MMAL_PORT_T *port, uint32_t id, uint32_t value);

/** Helper function to get the value of a 32 bits unsigned integer parameter.
 * @param port   port on which to get the parameter
 * @param id     parameter id
 * @param value  pointer to where the value will be returned
 *
 * @return MMAL_SUCCESS or error
 */
MMAL_STATUS_T mmal_port_parameter_get_uint32(MMAL_PORT_T *port, uint32_t id, uint32_t *value);

/** Helper function to set the value of a 32 bits signed integer parameter.
 * @param port   port on which to set the parameter
 * @param id     parameter id
 * @param value  value to set the parameter to
 *
 * @return MMAL_SUCCESS or error
 */
MMAL_STATUS_T mmal_port_parameter_set_int32(MMAL_PORT_T *port, uint32_t id, int32_t value);

/** Helper function to get the value of a 32 bits signed integer parameter.
 * @param port   port on which to get the parameter
 * @param id     parameter id
 * @param value  pointer to where the value will be returned
 *
 * @return MMAL_SUCCESS or error
 */
MMAL_STATUS_T mmal_port_parameter_get_int32(MMAL_PORT_T *port, uint32_t id, int32_t *value);

/** Helper function to set the value of a rational parameter.
 * @param port   port on which to set the parameter
 * @param id     parameter id
 * @param value  value to set the parameter to
 *
 * @return MMAL_SUCCESS or error
 */
MMAL_STATUS_T mmal_port_parameter_set_rational(MMAL_PORT_T *port, uint32_t id, MMAL_RATIONAL_T value);

/** Helper function to get the value of a rational parameter.
 * @param port   port on which to get the parameter
 * @param id     parameter id
 * @param value  pointer to where the value will be returned
 *
 * @return MMAL_SUCCESS or error
 */
MMAL_STATUS_T mmal_port_parameter_get_rational(MMAL_PORT_T *port, uint32_t id, MMAL_RATIONAL_T *value);

/** Helper function to set the value of a string parameter.
 * @param port   port on which to set the parameter
 * @param id     parameter id
 * @param value  null-terminated string value
 *
 * @return MMAL_SUCCESS or error
 */
MMAL_STATUS_T mmal_port_parameter_set_string(MMAL_PORT_T *port, uint32_t id, const char *value);

/** Helper function to set the value of an array of bytes parameter.
 * @param port   port on which to set the parameter
 * @param id     parameter id
 * @param data   pointer to the array of bytes
 * @param size   size of the array of bytes
 *
 * @return MMAL_SUCCESS or error
 */
MMAL_STATUS_T mmal_port_parameter_set_bytes(MMAL_PORT_T *port, uint32_t id,
   const uint8_t *data, unsigned int size);

/** Helper function to set a MMAL_PARAMETER_URI_T parameter on a port.
 * @param port   port on which to set the parameter
 * @param uri    URI string
 *
 * @return MMAL_SUCCESS or error
 */
MMAL_STATUS_T mmal_util_port_set_uri(MMAL_PORT_T *port, const char *uri);

/** Set the display region.
 * @param port   port to configure
 * @param region region
 *
 * @return MMAL_SUCCESS or error
 */
MMAL_STATUS_T mmal_util_set_display_region(MMAL_PORT_T *port,
                                           MMAL_DISPLAYREGION_T *region);

/** Tell the camera to use the STC for timestamps rather than the clock.
 *
 * @param port   port to configure
 * @param mode   STC mode to use
 * @return MMAL_SUCCESS or error
 */
MMAL_STATUS_T mmal_util_camera_use_stc_timestamp(MMAL_PORT_T *port, MMAL_CAMERA_STC_MODE_T mode);

/** Get the MMAL core statistics for a given port.
 *
 * @param port  port to query
 * @param dir   port direction
 * @param reset reset the stats as well
 * @param stats filled in with results
 * @return MMAL_SUCCESS or error
 */
MMAL_STATUS_T mmal_util_get_core_port_stats(MMAL_PORT_T *port, MMAL_CORE_STATS_DIR dir, MMAL_BOOL_T reset,
                                            MMAL_CORE_STATISTICS_T *stats);

#ifdef __cplusplus
}
#endif

#endif
                                                                                                                                                                                                                                                                                                                                            /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_VC_API_H
#define MMAL_VC_API_H

/** @file
  *
  * Public API for MMAL VC client. Most functionality is exposed
  * via MMAL itself.
  */

#include "interface/mmal/mmal_types.h"
#include "interface/mmal/mmal_parameters.h"
#include "interface/mmal/mmal_port.h"

#ifdef __cplusplus
extern "C" {
#endif

/** State of components created by the VC adaptation layer, used for
 * statistics reporting.
 */
typedef enum {
   MMAL_STATS_COMP_IDLE,
   MMAL_STATS_COMP_CREATED,
   MMAL_STATS_COMP_DESTROYING,
   MMAL_STATS_COMP_DESTROYED,
   MMAL_STATS_COMP_UNUSED = 0xffffffff /* force 32bit */
} MMAL_STATS_COMP_STATE_T;

/** Per-component statistics collected by the VC adaptation layer.
 */
struct MMAL_VC_COMP_STATS_T {
   struct MMAL_DRIVER_COMPONENT_T *comp;
   MMAL_STATS_COMP_STATE_T state;
   uint32_t pid;
   uint32_t pool_mem_alloc_size;
   char name[20];
};

/** VC adaptation layer statistics.
 */
struct MMAL_VC_STATS_T
{
   struct
   {
      uint32_t rx;               /**< Count of data buffers received */
      uint32_t rx_zero_copy;     /**< Count of zero-copy data buffers received */
      uint32_t rx_empty;         /**< Empty data buffers (to be filled) */
      uint32_t rx_fails;         /**< Gave up partway through */
      uint32_t tx;               /**< Count of data buffers sent */
      uint32_t tx_zero_copy;     /**< Count of zero-copy data buffers sent */
      uint32_t tx_empty;         /**< Count of empty data buffers sent */
      uint32_t tx_fails;         /**< Gave up partway through */
      uint32_t tx_short_msg;     /**< Messages sent directly in the control message */
      uint32_t rx_short_msg;     /**< Messages received directly in the control message */
   } buffers;
   struct service
   {
      uint32_t created;          /**< How many services created */
      uint32_t pending_destroy;  /**< How many destroyed */
      uint32_t destroyed;        /**< How many destroyed */
      uint32_t failures;         /**< Failures to create a service */
   } service;
   struct commands
   {
      uint32_t bad_messages;
      uint32_t executed;
      uint32_t failed;
      uint32_t replies;
      uint32_t reply_fails;
   } commands;
   struct
   {
      uint32_t tx;               /**< Count of events sent */
      uint32_t tx_fails;         /**< Count of events not fully sent */
   } events;
   struct
   {
      uint32_t created;
      uint32_t destroyed;
      uint32_t destroying;
      uint32_t failed;
      uint32_t list_size;
      struct MMAL_VC_COMP_STATS_T component_list[8];
   } components;
   struct
   {
      uint32_t enqueued_messages;
      uint32_t dequeued_messages;
      uint32_t max_parameter_set_delay;
      uint32_t max_messages_waiting;
   } worker;

};
typedef struct MMAL_VC_STATS_T MMAL_VC_STATS_T;

/* Simple circular text buffer used to store 'interesting' data
 * from MMAL clients. e.g. settings for each picture taken */
struct MMAL_VC_HOST_LOG_T
{
   /** Simple circular buffer of plain text log messages separated by NUL */
   char buffer[16 << 10];
   /** For VCDBG validation and to help detect buffer overflow */
   uint32_t magic;
   /** Write offset into buffer */
   int32_t offset;
   /** Counter of host messages logged since boot */
   unsigned count;
};
typedef struct MMAL_VC_HOST_LOG_T MMAL_VC_HOST_LOG_T;

/** Status from querying MMAL core statistics.
 */
typedef enum
{
   MMAL_STATS_FOUND,
   MMAL_STATS_COMPONENT_NOT_FOUND,
   MMAL_STATS_PORT_NOT_FOUND,
   MMAL_STATS_INVALID = 0x7fffffff
} MMAL_STATS_RESULT_T;

/* If opening dev_vchiq outside mmal/vchiq this is the file path and mode */
#define MMAL_DEV_VCHIQ_PATH "/dev/vchiq"
#define MMAL_DEV_VCHIQ_MODE O_RDWR

MMAL_STATUS_T mmal_vc_init(void);
MMAL_STATUS_T mmal_vc_init_fd(int dev_vchiq_fd);
void mmal_vc_deinit(void);

MMAL_STATUS_T mmal_vc_use(void);
MMAL_STATUS_T mmal_vc_release(void);

MMAL_STATUS_T mmal_vc_get_version(uint32_t *major, uint32_t *minor, uint32_t *minimum);
MMAL_STATUS_T mmal_vc_get_stats(MMAL_VC_STATS_T *stats, int reset);

/** Return the MMAL core statistics for a given component/port.
 *
 * @param stats         Updated with given port statistics
 * @param result        Whether the port/component was found
 * @param name          Filled in with the name of the port
 * @param namelen       Length of name
 * @param component     Which component (indexed from zero)
 * @param port_type     Which type of port
 * @param port          Which port (index from zero)
 * @param reset         Reset the stats.
 */
MMAL_STATUS_T mmal_vc_get_core_stats(MMAL_CORE_STATISTICS_T *stats,
                                     MMAL_STATS_RESULT_T *result,
                                     char *name,
                                     size_t namelen,
                                     MMAL_PORT_TYPE_T type,
                                     unsigned component,
                                     unsigned port,
                                     MMAL_CORE_STATS_DIR dir,
                                     MMAL_BOOL_T reset);
/**
 * Stores an arbitrary text message in a circular buffer inside the MMAL VC server.
 * The purpose of this message is to log high level events from the host in order
 * to diagnose problems that require multiple actions to reproduce. e.g. taking
 * multiple pictures with different settings.
 *
 * @param   msg  The message text.
 * @return  MMAL_SUCCESS if the message was logged or MMAL_ENOSYS if the API
 *          if not supported.
 */
MMAL_STATUS_T mmal_vc_host_log(const char *msg);

/* For backwards compatibility in builds */
#define MMAL_VC_API_HAVE_HOST_LOG

/* VC DEBUG ONLY ************************************************************/
/** Consumes memory in the relocatable heap.
 *
 * The existing reserved memory is freed first then the new chunk is allocated.
 * If zero is specified for the size then the previously reserved memory
 * is freed and no allocation occurs.
 *
 * At startup no memory is reserved.
 *
 * @param size    Size of memory to consume in bytes.
 * @param handle  Set to the mem handle for the reserved memory or zero
 *                if no memory was allocated.
 * @return        MMAL_SUCCESS if memory was reserved (or size zero requested),
 *                MMAL_ENOSPC if the allocation failed or MMAL_ENOSYS if the
 *                API is not supported e.g in release mode VC images.
 * @internal
 */
MMAL_STATUS_T mmal_vc_consume_mem(size_t size, uint32_t *handle);

typedef enum
{
   MMAL_VC_COMPACT_NONE       = 0,
   MMAL_VC_COMPACT_NORMAL     = 1,
   MMAL_VC_COMPACT_DISCARD    = 2,
   MMAL_VC_COMPACT_AGGRESSIVE = 4,
   MMAL_VC_COMPACT_SHUFFLE    = 0x80,
   MMAL_VC_COMPACT_ALL        = MMAL_VC_COMPACT_NORMAL | MMAL_VC_COMPACT_DISCARD | MMAL_VC_COMPACT_AGGRESSIVE,
} MMAL_VC_COMPACT_MODE_T;

/** Trigger relocatable heap compaction.
 * @internal
 */
MMAL_STATUS_T mmal_vc_compact(MMAL_VC_COMPACT_MODE_T mode, uint32_t *duration);

/** Trigger LMK action from VC, for diagnostics.
 * @internal
 */
MMAL_STATUS_T mmal_vc_lmk(uint32_t alloc_size);

#ifdef __cplusplus
}
#endif
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
#ifndef MMAL_VC_API_DRM_H
#define MMAL_VC_API_DRM_H

/** @file
  *
  * Public API for MMAL VC client. (Divx DRM part)
  */


#ifdef __cplusplus
extern "C" {
#endif

// Reads the current clock (in microseconds) into the "time" variable.
// Returns zero on success, nonszero on failure
int mmal_vc_drm_get_time(unsigned int * time);

// Reads the local hardware secret into the "into" variable (needs to be 32 bytes of space for this)
// Returns 0 on success, nonzero on failure
// Usage:
//   unsigned char buffer[32];
//   success = mmal_vc_divx_drm_get_lhs(buffer);
int mmal_vc_drm_get_lhs32(unsigned char * into);


#ifdef __cplusplus
}
#endif
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_VC_CLIENT_H
#define MMAL_VC_CLIENT_H

/** @file mmal_vc_client_priv.h
  *
  * Internal API for vchiq_arm MMAL client.
  */

struct MMAL_CLIENT_T;
typedef struct MMAL_CLIENT_T MMAL_CLIENT_T;

void mmal_vc_client_init(void);

/** Hold the context required when sending a buffer to the copro.
 */
typedef struct MMAL_VC_CLIENT_BUFFER_CONTEXT_T
{
   uint32_t magic;

   /** Called when VC is done with the buffer */
   void (*callback)(struct mmal_worker_buffer_from_host *);

   /** Called when VC sends an event */
   void (*callback_event)(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *event);

   /** The port this buffer was sent to */
   MMAL_PORT_T *port;

   /** The original buffer from the host. */
   MMAL_BUFFER_HEADER_T *buffer;

   /** The actual message sent to the host */
   struct mmal_worker_buffer_from_host msg;
} MMAL_VC_CLIENT_BUFFER_CONTEXT_T;


MMAL_CLIENT_T *mmal_vc_get_client(void);

MMAL_STATUS_T mmal_vc_sendwait_message(MMAL_CLIENT_T *client,
                                       mmal_worker_msg_header *header,
                                       size_t size,
                                       uint32_t msgid,
                                       void *dest,
                                       size_t *destlen,
                                       MMAL_BOOL_T send_dummy_bulk);

MMAL_STATUS_T mmal_vc_send_message(MMAL_CLIENT_T *client,
                                   mmal_worker_msg_header *header, size_t size,
                                   uint8_t *data, size_t data_size,
                                   uint32_t msgid);

#endif

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_VC_MSGNAMES_H
#define MMAL_VC_MSGNAMES_H

#include "interface/vcos/vcos.h"

/** Convert a message id to a name.
  */
const char *mmal_msgname(uint32_t id);

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_VC_MSGS_H
#define MMAL_VC_MSGS_H

/** @file mmal_vc_msgs.h
  *
  * Private message definitions, defining the message API between
  * the host and VideoCore.
  */
#include "interface/vcos/vcos.h"
#include "interface/mmal/mmal.h"
#include "mmal_vc_api.h"

#define MMAL_CONTROL_FOURCC() VCHIQ_MAKE_FOURCC('m','m','a','l')

/* Major version indicates binary backwards compatibility */
#define WORKER_VER_MAJOR   16
#define WORKER_VER_MINIMUM 10
/* Minor version is not used normally.
 */
#define WORKER_VER_MINOR   1
#ifndef WORKER_VER_MINIMUM
#endif

#define VIDEOCORE_PREFIX "vc"

#define MMAL_MAX_PORTS     8                 /**< Max ports per component */

#define MMAL_WORKER_MAX_MSG_LEN  512
#define MMAL_VC_CORE_STATS_NAME_MAX      32  /**< Length of the name in the core stats message */

/** A MMAL_CONTROL_SERVICE_T gets space for a single message. This
  * is the space allocated for these messages.
  */
#define MMAL_WORKER_MSG_LEN  28

/** Maximum size of the format extradata.
 * FIXME: should probably be made bigger and maybe be passed separately from the info.
 */
#define MMAL_FORMAT_EXTRADATA_MAX_SIZE 128

/** Size of space reserved in a buffer message for short messages.
 */
#define MMAL_VC_SHORT_DATA 128

/** Message ids sent to worker thread.
  */

/* Please update the array in mmal_vc_msgnames.c if this is updated.
 */
typedef enum {
   MMAL_WORKER_QUIT = 1,
   MMAL_WORKER_SERVICE_CLOSED,
   MMAL_WORKER_GET_VERSION,
   MMAL_WORKER_COMPONENT_CREATE,
   MMAL_WORKER_COMPONENT_DESTROY,
   MMAL_WORKER_COMPONENT_ENABLE,
   MMAL_WORKER_COMPONENT_DISABLE,
   MMAL_WORKER_PORT_INFO_GET,
   MMAL_WORKER_PORT_INFO_SET,
   MMAL_WORKER_PORT_ACTION,
   MMAL_WORKER_BUFFER_FROM_HOST,
   MMAL_WORKER_BUFFER_TO_HOST,
   MMAL_WORKER_GET_STATS,
   MMAL_WORKER_PORT_PARAMETER_SET,
   MMAL_WORKER_PORT_PARAMETER_GET,
   MMAL_WORKER_EVENT_TO_HOST,
   MMAL_WORKER_GET_CORE_STATS_FOR_PORT,
   MMAL_WORKER_OPAQUE_ALLOCATOR,
   /* VC debug mode only - due to security, denial of service implications */
   MMAL_WORKER_CONSUME_MEM,
   MMAL_WORKER_LMK,
   MMAL_WORKER_OPAQUE_ALLOCATOR_DESC,
   MMAL_WORKER_DRM_GET_LHS32,
   MMAL_WORKER_DRM_GET_TIME,
   MMAL_WORKER_BUFFER_FROM_HOST_ZEROLEN,
   MMAL_WORKER_PORT_FLUSH,
   MMAL_WORKER_HOST_LOG,
   MMAL_WORKER_COMPACT,
   MMAL_WORKER_MSG_LAST
} MMAL_WORKER_CMD_T;

/** Every message has one of these at the start.
  */
typedef struct
{
   uint32_t magic;
   uint32_t msgid;
   struct MMAL_CONTROL_SERVICE_T *control_service;       /** Handle to the control service */

   union {
      struct MMAL_WAITER_T *waiter;    /** User-land wait structure, passed back */
   } u;

   MMAL_STATUS_T status;            /** Result code, passed back */
   /* Make sure this structure is 64 bit aligned */
   uint32_t dummy;
} mmal_worker_msg_header;

/* Make sure mmal_worker_msg_header will preserve 64 bits alignment */
vcos_static_assert(!(sizeof(mmal_worker_msg_header) & 0x7));

/* Message structures sent to worker thread.
 */

/** Tell the worker a service has closed. It should start to delete
  * the associated components.
  */
typedef struct
{
   mmal_worker_msg_header header;
} mmal_worker_service_closed;
vcos_static_assert(sizeof(mmal_worker_service_closed) <= MMAL_WORKER_MSG_LEN);

/** Send from VC to host to report our version */
typedef struct
{
   mmal_worker_msg_header header;
   uint32_t flags;
   uint32_t major;
   uint32_t minor;
   uint32_t minimum;
} mmal_worker_version;

/** Request component creation */
typedef struct
{
   mmal_worker_msg_header header;
   void *client_component;             /** Client component */
   char name[128];
   uint32_t pid;                       /**< For debug */
} mmal_worker_component_create;

/** Reply to component-creation message. Reports back
  * the number of ports.
  */
typedef struct
{
   mmal_worker_msg_header header;
   MMAL_STATUS_T status;
   uint32_t component_handle;          /** Handle on VideoCore for component */
   uint32_t input_num;                 /**< Number of input ports */
   uint32_t output_num;                /**< Number of output ports */
   uint32_t clock_num;                 /**< Number of clock ports */
} mmal_worker_component_create_reply;
vcos_static_assert(sizeof(mmal_worker_component_create_reply) <= MMAL_WORKER_MAX_MSG_LEN);

/** Destroys a component
  */
typedef struct
{
   mmal_worker_msg_header header;
   uint32_t component_handle;          /**< which component */
} mmal_worker_component_destroy;

/** Enables a component
  */
typedef struct
{
   mmal_worker_msg_header header;
   uint32_t component_handle;          /**< which component */
} mmal_worker_component_enable;

/** Disable a component
  */
typedef struct
{
   mmal_worker_msg_header header;
   uint32_t component_handle;          /**< Which component */
} mmal_worker_component_disable;

/** Component port info. Used to get port info.
  */
typedef struct
{
   mmal_worker_msg_header header;
   uint32_t component_handle;          /**< Which component */
   MMAL_PORT_TYPE_T port_type;         /**< Type of port */
   uint32_t index;                     /**< Which port of given type to get */
} mmal_worker_port_info_get;
vcos_static_assert(sizeof(mmal_worker_port_info_get) <= MMAL_WORKER_MAX_MSG_LEN);

/** Component port info. Used to set port info.
  */
typedef struct
{
   mmal_worker_msg_header header;
   uint32_t component_handle;          /**< Which component */
   MMAL_PORT_TYPE_T port_type;         /**< Type of port */
   uint32_t index;                     /**< Which port of given type to get */
   MMAL_PORT_T port;
   MMAL_ES_FORMAT_T format;
   MMAL_ES_SPECIFIC_FORMAT_T es;
   uint8_t  extradata[MMAL_FORMAT_EXTRADATA_MAX_SIZE];
} mmal_worker_port_info_set;
vcos_static_assert(sizeof(mmal_worker_port_info_set) <= MMAL_WORKER_MAX_MSG_LEN);

/** Report port info back in response to a get / set. */
typedef struct
{
   mmal_worker_msg_header header;
   MMAL_STATUS_T status;               /**< Result of query */
   uint32_t component_handle;          /**< Which component */
   MMAL_PORT_TYPE_T port_type;         /**< Type of port */
   uint32_t index;                     /**< Which port of given type to get */
   int32_t found;                      /**< Did we find anything? */
   uint32_t port_handle;               /**< Handle to use for this port */
   MMAL_PORT_T port;
   MMAL_ES_FORMAT_T format;
   MMAL_ES_SPECIFIC_FORMAT_T es;
   uint8_t  extradata[MMAL_FORMAT_EXTRADATA_MAX_SIZE];
} mmal_worker_port_info;
vcos_static_assert(sizeof(mmal_worker_port_info) <= MMAL_WORKER_MAX_MSG_LEN);

typedef struct
{
   mmal_worker_msg_header header;
   MMAL_STATUS_T status;
} mmal_worker_reply;

typedef struct
{
   mmal_worker_msg_header header;
   MMAL_STATUS_T status;
   uint8_t secret[32];
} mmal_worker_drm_get_lhs32_reply;
vcos_static_assert(sizeof(mmal_worker_drm_get_lhs32_reply) <= MMAL_WORKER_MAX_MSG_LEN);

typedef struct
{
   mmal_worker_msg_header header;
   MMAL_STATUS_T status;
   uint32_t time;
} mmal_worker_drm_get_time_reply;
vcos_static_assert(sizeof(mmal_worker_drm_get_time_reply) <= MMAL_WORKER_MAX_MSG_LEN);

/** List of actions for a port */
enum MMAL_WORKER_PORT_ACTIONS
{
   MMAL_WORKER_PORT_ACTION_UNKNOWN = 0,        /**< Unknown action */
   MMAL_WORKER_PORT_ACTION_ENABLE,             /**< Enable a port */
   MMAL_WORKER_PORT_ACTION_DISABLE,            /**< Disable a port */
   MMAL_WORKER_PORT_ACTION_FLUSH,              /**< Flush a port */
   MMAL_WORKER_PORT_ACTION_CONNECT,            /**< Connect 2 ports together */
   MMAL_WORKER_PORT_ACTION_DISCONNECT,         /**< Disconnect 2 ports connected together */
   MMAL_WORKER_PORT_ACTION_SET_REQUIREMENTS,   /**< Set buffer requirements  */
   MMAL_WORKER_PORT_ACTION_MAX = 0x7fffffff    /**< Make the enum 32bits */
};

/** Trigger an action on a port.
  */
typedef struct
{
   mmal_worker_msg_header header;
   uint32_t component_handle;
   uint32_t port_handle;
   enum MMAL_WORKER_PORT_ACTIONS action;

   /** Action parameter */
   union {
      struct {
         MMAL_PORT_T port;
      } enable;
      struct {
         uint32_t component_handle;
         uint32_t port_handle;
      } connect;
   } param;

} mmal_worker_port_action;
vcos_static_assert(sizeof(mmal_worker_port_action) <= MMAL_WORKER_MAX_MSG_LEN);

#define MMAL_WORKER_PORT_PARAMETER_SPACE      96

#define MMAL_WORKER_PORT_PARAMETER_SET_MAX \
   (MMAL_WORKER_PORT_PARAMETER_SPACE*sizeof(uint32_t)+sizeof(MMAL_PARAMETER_HEADER_T))

#define MMAL_WORKER_PORT_PARAMETER_GET_MAX   MMAL_WORKER_PORT_PARAMETER_SET_MAX

/** Component port parameter set. Doesn't include space for the parameter data.
  */
typedef struct
{
   mmal_worker_msg_header header;
   uint32_t component_handle;          /**< Which component */
   uint32_t port_handle;               /**< Which port */
   MMAL_PARAMETER_HEADER_T param;      /**< Parameter ID and size */
   uint32_t space[MMAL_WORKER_PORT_PARAMETER_SPACE];
} mmal_worker_port_param_set;
vcos_static_assert(sizeof(mmal_worker_port_param_set) <= MMAL_WORKER_MAX_MSG_LEN);

/** Component port parameter get.
  */
typedef struct
{
   mmal_worker_msg_header header;
   uint32_t component_handle;          /**< Which component */
   uint32_t port_handle;               /**< Which port */
   MMAL_PARAMETER_HEADER_T param;      /**< Parameter ID and size */
   uint32_t space[MMAL_WORKER_PORT_PARAMETER_SPACE];
} mmal_worker_port_param_get;
vcos_static_assert(sizeof(mmal_worker_port_param_get) <= MMAL_WORKER_MAX_MSG_LEN);

typedef struct
{
   mmal_worker_msg_header header;
   uint32_t component_handle;          /**< Which component */
   uint32_t port_handle;               /**< Which port */
   MMAL_PARAMETER_HEADER_T param;      /**< Parameter ID and size */
} mmal_worker_port_param_get_old;

/** Component port parameter get reply. Doesn't include space for the parameter data.
  */
typedef struct
{
   mmal_worker_msg_header header;
   MMAL_STATUS_T status;               /**< Status of mmal_port_parameter_get call */
   MMAL_PARAMETER_HEADER_T param;      /**< Parameter ID and size */
   uint32_t space[MMAL_WORKER_PORT_PARAMETER_SPACE];
} mmal_worker_port_param_get_reply;
vcos_static_assert(sizeof(mmal_worker_port_param_get_reply) <= MMAL_WORKER_MAX_MSG_LEN);

/** Buffer header driver area structure. In the private area
  * of a buffer header there is a driver area where we can
  * put values. This structure defines the layout of that.
  */
struct MMAL_DRIVER_BUFFER_T
{
   uint32_t magic;
   uint32_t component_handle;    /**< The component this buffer is from */
   uint32_t port_handle;         /**< Index into array of ports for this component */

   /** Client side uses this to get back to its context structure. */
   struct MMAL_VC_CLIENT_BUFFER_CONTEXT_T *client_context;
};

/** Receive a buffer from the host.
  *
  * @sa mmal_port_send_buffer()
  */

typedef struct mmal_worker_buffer_from_host
{
   mmal_worker_msg_header header;

   /** Our control data, copied from the buffer header "driver area"
    * @sa mmal_buffer_header_driver_data().
    */
   struct MMAL_DRIVER_BUFFER_T drvbuf;

   /** Referenced buffer control data.
    * This is set if the buffer is referencing another
    * buffer as is the case with passthrough ports where
    * buffers on the output port reference buffers on the
    * input port. */
   struct MMAL_DRIVER_BUFFER_T drvbuf_ref;

   /** the buffer header itself */
   MMAL_BUFFER_HEADER_T buffer_header;
   MMAL_BUFFER_HEADER_TYPE_SPECIFIC_T buffer_header_type_specific;

   MMAL_BOOL_T is_zero_copy;
   MMAL_BOOL_T has_reference;

   /** If the data is short enough, then send it in the control message rather
    * than using a separate VCHIQ bulk transfer.
    */
   uint32_t payload_in_message;
   uint8_t short_data[MMAL_VC_SHORT_DATA];

} mmal_worker_buffer_from_host;
vcos_static_assert(sizeof(mmal_worker_buffer_from_host) <= MMAL_WORKER_MAX_MSG_LEN);

/** Maximum number of event data bytes that can be passed in the message.
 * More than this and the data is passed in a bulk message.
 */
#define MMAL_WORKER_EVENT_SPACE 256

/** Send an event buffer from the host.
  *
  * @sa mmal_port_send_event()
  */

typedef struct mmal_worker_event_to_host
{
   mmal_worker_msg_header header;

   struct MMAL_COMPONENT_T *client_component;
   uint32_t port_type;
   uint32_t port_num;

   uint32_t cmd;
   uint32_t length;
   uint8_t data[MMAL_WORKER_EVENT_SPACE];
   MMAL_BUFFER_HEADER_T *delayed_buffer;  /* Only used to remember buffer for bulk rx */
} mmal_worker_event_to_host;
vcos_static_assert(sizeof(mmal_worker_event_to_host) <= MMAL_WORKER_MAX_MSG_LEN);

typedef struct
{
   mmal_worker_msg_header header;
   MMAL_VC_STATS_T stats;
   uint32_t reset;
} mmal_worker_stats;
vcos_static_assert(sizeof(mmal_worker_stats) <= MMAL_WORKER_MAX_MSG_LEN);

typedef enum {
   MMAL_WORKER_OPAQUE_MEM_ALLOC,
   MMAL_WORKER_OPAQUE_MEM_RELEASE,
   MMAL_WORKER_OPAQUE_MEM_ACQUIRE,
   MMAL_WORKER_OPAQUE_MEM_MAX = 0x7fffffff,
} MMAL_WORKER_OPAQUE_MEM_OP;

typedef struct
{
   mmal_worker_msg_header header;
   MMAL_WORKER_OPAQUE_MEM_OP op;
   uint32_t handle;
   MMAL_STATUS_T status;
   char description[32];
} mmal_worker_opaque_allocator;

/*
 * Per-port core statistics
 */
typedef struct
{
   mmal_worker_msg_header header;
   uint32_t component_index;
   uint32_t port_index;
   MMAL_PORT_TYPE_T type;
   MMAL_CORE_STATS_DIR dir;
   MMAL_BOOL_T reset;
} mmal_worker_get_core_stats_for_port;

typedef struct
{
   mmal_worker_msg_header header;
   MMAL_STATUS_T status;
   MMAL_STATS_RESULT_T result;
   MMAL_CORE_STATISTICS_T stats;
   char component_name[MMAL_VC_CORE_STATS_NAME_MAX];
} mmal_worker_get_core_stats_for_port_reply;

typedef struct
{
   mmal_worker_msg_header header;
   MMAL_STATUS_T status;
   /* The amount of memory to reserve */
   uint32_t size;
   /* Handle to newly allocated memory or MEM_HANDLE_INVALD on failure */
   uint32_t handle;
} mmal_worker_consume_mem;
vcos_static_assert(sizeof(mmal_worker_consume_mem) <= MMAL_WORKER_MAX_MSG_LEN);

typedef struct
{
   mmal_worker_msg_header header;
   MMAL_STATUS_T status;
   uint32_t mode;
   uint32_t duration;
} mmal_worker_compact;
vcos_static_assert(sizeof(mmal_worker_compact) <= MMAL_WORKER_MAX_MSG_LEN);

typedef struct
{
   mmal_worker_msg_header header;
   /* Message text to add to the circular buffer */
   char msg[MMAL_WORKER_MAX_MSG_LEN - sizeof(mmal_worker_msg_header)];
} mmal_worker_host_log;
vcos_static_assert(sizeof(mmal_worker_host_log) <= MMAL_WORKER_MAX_MSG_LEN);

typedef struct
{
   mmal_worker_msg_header header;
   /* The memory allocation size to pass to lmk, as if in a response to an
    * allocation for this amount of memory. */
   uint32_t alloc_size;
} mmal_worker_lmk;
vcos_static_assert(sizeof(mmal_worker_lmk) <= MMAL_WORKER_MAX_MSG_LEN);

static inline void mmal_vc_buffer_header_to_msg(mmal_worker_buffer_from_host *msg,
                                                MMAL_BUFFER_HEADER_T *header)
{
   msg->buffer_header.cmd           = header->cmd;
   msg->buffer_header.offset        = header->offset;
   msg->buffer_header.length        = header->length;
   msg->buffer_header.flags         = header->flags;
   msg->buffer_header.pts           = header->pts;
   msg->buffer_header.dts           = header->dts;
   msg->buffer_header.alloc_size    = header->alloc_size;
   msg->buffer_header.data          = header->data;
   msg->buffer_header_type_specific = *header->type;
}

static inline void mmal_vc_msg_to_buffer_header(MMAL_BUFFER_HEADER_T *header,
                                                mmal_worker_buffer_from_host *msg)
{
   header->cmd    = msg->buffer_header.cmd;
   header->offset = msg->buffer_header.offset;
   header->length = msg->buffer_header.length;
   header->flags  = msg->buffer_header.flags;
   header->pts    = msg->buffer_header.pts;
   header->dts    = msg->buffer_header.dts;
   *header->type  = msg->buffer_header_type_specific;
}

#endif

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_VC_OPAQUE_ALLOC_H
#define MMAL_VC_OPAQUE_ALLOC_H


#include <stdint.h>
#include "interface/mmal/mmal.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef uint32_t MMAL_OPAQUE_IMAGE_HANDLE_T;

/** Allocate an opaque image on VideoCore.
 *
 * @return allocated handle, or zero if allocation failed.
 */
MMAL_OPAQUE_IMAGE_HANDLE_T mmal_vc_opaque_alloc(void);

/** Allocate an opaque image on VideoCore, providing a description.
 * @return allocated handle, or zero if allocation failed.
 */
MMAL_OPAQUE_IMAGE_HANDLE_T mmal_vc_opaque_alloc_desc(const char *description);

/** Release an opaque image.
 *
 * @param handle  handle allocated earlier
 * @return MMAL_SUCCESS or error code if handle not found
 */
MMAL_STATUS_T mmal_vc_opaque_release(MMAL_OPAQUE_IMAGE_HANDLE_T h);

/** Acquire an additional reference to an opaque image.
 *
 * @param handle  handle allocated earlier
 * @return MMAL_SUCCESS or error code if handle not found
 */
MMAL_STATUS_T mmal_vc_opaque_acquire(MMAL_OPAQUE_IMAGE_HANDLE_T h);


#ifdef __cplusplus
}
#endif


#endif

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
#ifndef MMAL_VC_SHM_H
#define MMAL_VC_SHM_H

/** @file
  *
  * Abstraction layer for MMAL VC shared memory.
  * This API is only used by the MMAL VC component.
  */

#include "mmal_types.h"

#ifdef __cplusplus
extern "C" {
#endif

/** Initialise the shared memory system */
MMAL_STATUS_T mmal_vc_shm_init(void);

/** Allocate a shared memory buffer */
uint8_t *mmal_vc_shm_alloc(uint32_t size);

/** Free a shared memory buffer */
MMAL_STATUS_T mmal_vc_shm_free(uint8_t *mem);

/** Lock a shared memory buffer */
uint8_t *mmal_vc_shm_lock(uint8_t *mem, uint32_t workaround);

/** Unlock a shared memory buffer */
uint8_t *mmal_vc_shm_unlock(uint8_t *mem, uint32_t *length, uint32_t workaround);


#ifdef __cplusplus
}
#endif

#endif /* MMAL_VC_SHM_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
#ifndef VC_VCHI_DISPMANX_COMMON_H
#define VC_VCHI_DISPMANX_COMMON_H

typedef enum  {
   // IMPORTANT - DO NOT ALTER THE ORDER OF COMMANDS IN THIS ENUMERATION
   // NEW FUNCTIONS SHOULD BE ADDED TO THE END, AND MUST ALSO BE ADDED TO
   // THE HOST SIDE FUNCTION TABLE IN display_server.c.
   
   // No function configured - do not use
   EDispmanNoFunction = 0,
   
   // Dispman pre-configure functions
   EDispmanGetDevices,
   EDispmanGetModes,
   
   // Dispman resource-related functions
   EDispmanResourceCreate,
   EDispmanResourceCreateFromImage,
   EDispmanResourceDelete,
   EDispmanResourceGetData,
   EDispmanResourceGetImage,
   
   // Dispman display-related functions
   EDispmanDisplayOpen,
   EDispmanDisplayOpenMode,
   EDispmanDisplayOpenOffscreen,
   EDispmanDisplayReconfigure,
   EDispmanDisplaySetDestination,
   EDispmanDisplaySetBackground,
   EDispmanDisplayGetInfo,
   EDispmanDisplayClose,
   
   // Dispman update-related functions
   EDispmanUpdateStart,
   EDispmanUpdateSubmit,
   EDispmanUpdateSubmitSync,
   
   // Dispman element-related functions
   EDispmanElementAdd,
   EDispmanElementModified,
   EDispmanElementRemove,
   EDispmanElementChangeSource,
   EDispmanElementChangeLayer,
   EDispmanElementChangeAttributes,

   //More commands go here...
   EDispmanResourceFill,    //Comes from uideck
   EDispmanQueryImageFormats,
   EDispmanBulkWrite,
   EDispmanBulkRead,
   EDispmanDisplayOrientation,
   EDispmanSnapshot,
   EDispmanSetPalette,
   EDispmanVsyncCallback,

   EDispmanMaxFunction
} DISPMANX_COMMAND_T;

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      /*
Copyright (c) 2012-2014, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// Contains the protypes for the vchi functions.

#ifndef VCHI_H_
#define VCHI_H_

#include "interface/vcos/vcos.h"
#include "interface/vchi/vchi_cfg.h"
#include "interface/vchi/vchi_common.h"
#include "interface/vchi/connections/connection.h"
#include "vchi_mh.h"


/******************************************************************************
 Global defs
 *****************************************************************************/

#define VCHI_SERVICE_HANDLE_INVALID 0

#define VCHI_BULK_ROUND_UP(x)     ((((unsigned long)(x))+VCHI_BULK_ALIGN-1) & ~(VCHI_BULK_ALIGN-1))
#define VCHI_BULK_ROUND_DOWN(x)   (((unsigned long)(x)) & ~(VCHI_BULK_ALIGN-1))
#define VCHI_BULK_ALIGN_NBYTES(x) (VCHI_BULK_ALIGNED(x) ? 0 : (VCHI_BULK_ALIGN - ((unsigned long)(x) & (VCHI_BULK_ALIGN-1))))

#ifdef USE_VCHIQ_ARM
#define VCHI_BULK_ALIGNED(x)      1
#else
#define VCHI_BULK_ALIGNED(x)      (((unsigned long)(x) & (VCHI_BULK_ALIGN-1)) == 0)
#endif

typedef struct 
{
   uint32_t version;
   uint32_t version_min;
} VCHI_VERSION_T;
#define VCHI_VERSION(v_) { v_, v_ }
#define VCHI_VERSION_EX(v_,m_) { v_, m_ }

typedef enum
{
   VCHI_VEC_POINTER,
   VCHI_VEC_HANDLE,
   VCHI_VEC_LIST
} VCHI_MSG_VECTOR_TYPE_T;

typedef struct vchi_msg_vector_ex {

   VCHI_MSG_VECTOR_TYPE_T type;
   union
   {
      // a memory handle
      struct
      {
         VCHI_MEM_HANDLE_T handle;
         uint32_t offset;
         int32_t vec_len;
      } handle;

      // an ordinary data pointer
      struct
      {
         const void *vec_base;
         int32_t vec_len;
      } ptr;

      // a nested vector list
      struct
      {
         struct vchi_msg_vector_ex *vec;
         uint32_t vec_len;
      } list;
   } u;
} VCHI_MSG_VECTOR_EX_T;


// Construct an entry in a msg vector for a pointer (p) of length (l)
#define VCHI_VEC_POINTER(p,l)  VCHI_VEC_POINTER, { { (VCHI_MEM_HANDLE_T)(p), (l) } }

// Construct an entry in a msg vector for a message handle (h), starting at offset (o) of length (l)
#define VCHI_VEC_HANDLE(h,o,l) VCHI_VEC_HANDLE,  { { (h), (o), (l) } }

// Macros to manipulate fourcc_t values
#define MAKE_FOURCC(x) ((fourcc_t)( (x[0] << 24) | (x[1] << 16) | (x[2] << 8) | x[3] ))
#define FOURCC_TO_CHAR(x) (x >> 24) & 0xFF,(x >> 16) & 0xFF,(x >> 8) & 0xFF, x & 0xFF


// Opaque service information
struct opaque_vchi_service_t;

// Descriptor for a held message. Allocated by client, initialised by vchi_msg_hold,
// vchi_msg_iter_hold or vchi_msg_iter_hold_next. Fields are for internal VCHI use only.
typedef struct
{
   struct opaque_vchi_service_t *service;
   void *message;
} VCHI_HELD_MSG_T;



// structure used to provide the information needed to open a server or a client
typedef struct {
   VCHI_VERSION_T version;
   vcos_fourcc_t service_id;
   VCHI_CONNECTION_T *connection;
   uint32_t rx_fifo_size;
   uint32_t tx_fifo_size;
   VCHI_CALLBACK_T callback;
   void *callback_param;
   vcos_bool_t want_unaligned_bulk_rx;    // client intends to receive bulk transfers of odd lengths or into unaligned buffers
   vcos_bool_t want_unaligned_bulk_tx;    // client intends to transmit bulk transfers of odd lengths or out of unaligned buffers
   vcos_bool_t want_crc;                  // client wants to check CRCs on (bulk) transfers. Only needs to be set at 1 end - will do both directions.
} SERVICE_CREATION_T;

// Opaque handle for a VCHI instance
typedef struct opaque_vchi_instance_handle_t *VCHI_INSTANCE_T;

// Opaque handle for a server or client
typedef unsigned int VCHI_SERVICE_HANDLE_T;

// Service registration & startup
typedef void (*VCHI_SERVICE_INIT)(VCHI_INSTANCE_T initialise_instance, VCHI_CONNECTION_T **connections, uint32_t num_connections);

typedef struct service_info_tag {
   const char * const vll_filename; /* VLL to load to start this service. This is an empty string if VLL is "static" */
   VCHI_SERVICE_INIT init;          /* Service initialisation function */
   void *vll_handle;                /* VLL handle; NULL when unloaded or a "static VLL" in build */
} SERVICE_INFO_T;

// Pagelist structure for copy callback
struct pagelist_struct;

/******************************************************************************
 Global funcs - implementation is specific to which side you are on (local / remote)
 *****************************************************************************/

#ifdef __cplusplus
extern "C" {
#endif

extern /*@observer@*/ VCHI_CONNECTION_T * vchi_create_connection( const VCHI_CONNECTION_API_T * function_table,
                                                   const VCHI_MESSAGE_DRIVER_T * low_level);


// Routine used to initialise the vchi on both local + remote connections
extern int32_t vchi_initialise( VCHI_INSTANCE_T *instance_handle );

extern int32_t vchi_connect( VCHI_CONNECTION_T **connections,
                             const uint32_t num_connections,
                             VCHI_INSTANCE_T instance_handle );

//When this is called, ensure that all services have no data pending.
//Bulk transfers can remain 'queued'
extern int32_t vchi_disconnect( VCHI_INSTANCE_T instance_handle );

// Global control over bulk CRC checking
extern int32_t vchi_crc_control( VCHI_CONNECTION_T *connection,
                                 VCHI_CRC_CONTROL_T control );

// helper functions
extern void * vchi_allocate_buffer(VCHI_SERVICE_HANDLE_T handle, uint32_t *length);
extern void vchi_free_buffer(VCHI_SERVICE_HANDLE_T handle, void *address);
extern uint32_t vchi_current_time(VCHI_INSTANCE_T instance_handle);


/******************************************************************************
 Global service API
 *****************************************************************************/
// Routine to create a named service
extern int32_t vchi_service_create( VCHI_INSTANCE_T instance_handle,
                                    SERVICE_CREATION_T *setup,
                                    VCHI_SERVICE_HANDLE_T *handle );

// Routine to destroy a service
extern int32_t vchi_service_destroy( const VCHI_SERVICE_HANDLE_T handle );

// Routine to open a named service
extern int32_t vchi_service_open( VCHI_INSTANCE_T instance_handle,
                                  SERVICE_CREATION_T *setup,
                                  VCHI_SERVICE_HANDLE_T *handle);

extern int32_t vchi_get_peer_version( const VCHI_SERVICE_HANDLE_T handle,
                                      short *peer_version );

// Routine to close a named service
extern int32_t vchi_service_close( const VCHI_SERVICE_HANDLE_T handle );

// Routine to increment ref count on a named service
extern int32_t vchi_service_use( const VCHI_SERVICE_HANDLE_T handle );

// Routine to decrement ref count on a named service
extern int32_t vchi_service_release( const VCHI_SERVICE_HANDLE_T handle );

// Routine to set a control option for a named service
extern int32_t vchi_service_set_option( const VCHI_SERVICE_HANDLE_T handle,
                                        VCHI_SERVICE_OPTION_T option,
                                        int value);

// Routine to send a message across a service
extern int32_t vchi_msg_queue( VCHI_SERVICE_HANDLE_T handle,
                               const void *data,
                               uint32_t data_size,
                               VCHI_FLAGS_T flags,
                               void *msg_handle );

// scatter-gather (vector) and send message
int32_t vchi_msg_queuev_ex( VCHI_SERVICE_HANDLE_T handle,
                            VCHI_MSG_VECTOR_EX_T *vector,
                            uint32_t count,
                            VCHI_FLAGS_T flags,
                            void *msg_handle );

// legacy scatter-gather (vector) and send message, only handles pointers
int32_t vchi_msg_queuev( VCHI_SERVICE_HANDLE_T handle,
                         VCHI_MSG_VECTOR_T *vector,
                         uint32_t count,
                         VCHI_FLAGS_T flags,
                         void *msg_handle );

// Routine to receive a msg from a service
// Dequeue is equivalent to hold, copy into client buffer, release
extern int32_t vchi_msg_dequeue( VCHI_SERVICE_HANDLE_T handle,
                                 void *data,
                                 uint32_t max_data_size_to_read,
                                 uint32_t *actual_msg_size,
                                 VCHI_FLAGS_T flags );

// Routine to look at a message in place.
// The message is not dequeued, so a subsequent call to peek or dequeue
// will return the same message.
extern int32_t vchi_msg_peek( VCHI_SERVICE_HANDLE_T handle,
                              void **data,
                              uint32_t *msg_size,
                              VCHI_FLAGS_T flags );

// Routine to remove a message after it has been read in place with peek
// The first message on the queue is dequeued.
extern int32_t vchi_msg_remove( VCHI_SERVICE_HANDLE_T handle );

// Routine to look at a message in place.
// The message is dequeued, so the caller is left holding it; the descriptor is
// filled in and must be released when the user has finished with the message.
extern int32_t vchi_msg_hold( VCHI_SERVICE_HANDLE_T handle,
                              void **data,        // } may be NULL, as info can be
                              uint32_t *msg_size, // } obtained from HELD_MSG_T
                              VCHI_FLAGS_T flags,
                              VCHI_HELD_MSG_T *message_descriptor );

// Initialise an iterator to look through messages in place
extern int32_t vchi_msg_look_ahead( VCHI_SERVICE_HANDLE_T handle,
                                    VCHI_MSG_ITER_T *iter,
                                    VCHI_FLAGS_T flags );

/******************************************************************************
 Global service support API - operations on held messages and message iterators
 *****************************************************************************/

// Routine to get the address of a held message
extern void *vchi_held_msg_ptr( const VCHI_HELD_MSG_T *message );

// Routine to get the size of a held message
extern int32_t vchi_held_msg_size( const VCHI_HELD_MSG_T *message );

// Routine to get the transmit timestamp as written into the header by the peer
extern uint32_t vchi_held_msg_tx_timestamp( const VCHI_HELD_MSG_T *message );

// Routine to get the reception timestamp, written as we parsed the header
extern uint32_t vchi_held_msg_rx_timestamp( const VCHI_HELD_MSG_T *message );

// Routine to release a held message after it has been processed
extern int32_t vchi_held_msg_release( VCHI_HELD_MSG_T *message );

// Indicates whether the iterator has a next message.
extern vcos_bool_t vchi_msg_iter_has_next( const VCHI_MSG_ITER_T *iter );

// Return the pointer and length for the next message and advance the iterator.
extern int32_t vchi_msg_iter_next( VCHI_MSG_ITER_T *iter,
                                   void **data,
                                   uint32_t *msg_size );

// Remove the last message returned by vchi_msg_iter_next.
// Can only be called once after each call to vchi_msg_iter_next.
extern int32_t vchi_msg_iter_remove( VCHI_MSG_ITER_T *iter );

// Hold the last message returned by vchi_msg_iter_next.
// Can only be called once after each call to vchi_msg_iter_next.
extern int32_t vchi_msg_iter_hold( VCHI_MSG_ITER_T *iter,
                                   VCHI_HELD_MSG_T *message );

// Return information for the next message, and hold it, advancing the iterator.
extern int32_t vchi_msg_iter_hold_next( VCHI_MSG_ITER_T *iter,
                                        void **data,        // } may be NULL
                                        uint32_t *msg_size, // }
                                        VCHI_HELD_MSG_T *message );


/******************************************************************************
 Global bulk API
 *****************************************************************************/

// Routine to prepare interface for a transfer from the other side
extern int32_t vchi_bulk_queue_receive( VCHI_SERVICE_HANDLE_T handle,
                                        void *data_dst,
                                        uint32_t data_size,
                                        VCHI_FLAGS_T flags,
                                        void *transfer_handle );


// Prepare interface for a transfer from the other side into relocatable memory.
int32_t vchi_bulk_queue_receive_reloc( const VCHI_SERVICE_HANDLE_T handle,
                                       VCHI_MEM_HANDLE_T h_dst,
                                       uint32_t offset,
                                       uint32_t data_size,
                                       const VCHI_FLAGS_T flags,
                                       void * const bulk_handle );

// Prepare interface for a transfer from the other side into relocatable memory.
int32_t vchi_bulk_queue_receive_reloc_func( const VCHI_SERVICE_HANDLE_T handle,
                                       VCHI_MEM_HANDLE_T h_dst,
                                       uint32_t offset,
                                       uint32_t data_size,
                                       const VCHI_FLAGS_T flags,
                                       void * const bulk_handle,
                                       int copy_pagelist(char *vcptr, const struct pagelist_struct *pagelist));

// Routine to queue up data ready for transfer to the other (once they have signalled they are ready)
extern int32_t vchi_bulk_queue_transmit( VCHI_SERVICE_HANDLE_T handle,
                                         const void *data_src,
                                         uint32_t data_size,
                                         VCHI_FLAGS_T flags,
                                         void *transfer_handle );


/******************************************************************************
 Configuration plumbing
 *****************************************************************************/

// function prototypes for the different mid layers (the state info gives the different physical connections)
extern const VCHI_CONNECTION_API_T *single_get_func_table( void );
//extern const VCHI_CONNECTION_API_T *local_server_get_func_table( void );
//extern const VCHI_CONNECTION_API_T *local_client_get_func_table( void );

// declare all message drivers here
const VCHI_MESSAGE_DRIVER_T *vchi_mphi_message_driver_func_table( void );

#ifdef __cplusplus
}
#endif

extern int32_t vchi_bulk_queue_transmit_reloc( VCHI_SERVICE_HANDLE_T handle,
                                               VCHI_MEM_HANDLE_T h_src,
                                               uint32_t offset,
                                               uint32_t data_size,
                                               VCHI_FLAGS_T flags,
                                               void *transfer_handle );
#endif /* VCHI_H_ */

/****************************** End of file **********************************/
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// Contains the #defines for the number of servers / clients etc, these can be
// over-ridden from the platform makefile if needed


#ifndef VCHI_CFG_H_
#define VCHI_CFG_H_

/****************************************************************************************
 * Defines in this first section are part of the VCHI API and may be examined by VCHI
 * services.
 ***************************************************************************************/

/* Required alignment of base addresses for bulk transfer, if unaligned transfers are not enabled */
/* Really determined by the message driver, and should be available from a run-time call. */
#ifndef VCHI_BULK_ALIGN
#   if __VCCOREVER__ >= 0x04000000
#       define VCHI_BULK_ALIGN 32 // Allows for the need to do cache cleans
#   else
#       define VCHI_BULK_ALIGN 16
#   endif
#endif

/* Required length multiple for bulk transfers, if unaligned transfers are not enabled */
/* May be less than or greater than VCHI_BULK_ALIGN */
/* Really determined by the message driver, and should be available from a run-time call. */
#ifndef VCHI_BULK_GRANULARITY
#   if __VCCOREVER__ >= 0x04000000
#       define VCHI_BULK_GRANULARITY 32 // Allows for the need to do cache cleans
#   else
#       define VCHI_BULK_GRANULARITY 16
#   endif
#endif

/* The largest possible message to be queued with vchi_msg_queue. */
#ifndef VCHI_MAX_MSG_SIZE
#   if defined VCHI_LOCAL_HOST_PORT
#       define VCHI_MAX_MSG_SIZE     16384         // makes file transfers fast, but should they be using bulk?
#   else
#       define VCHI_MAX_MSG_SIZE      4096 // NOTE: THIS MUST BE LARGER THAN OR EQUAL TO THE SIZE OF THE KHRONOS MERGE BUFFER!!
#   endif
#endif

/******************************************************************************************
 * Defines below are system configuration options, and should not be used by VCHI services.
 *****************************************************************************************/

/* How many connections can we support? A localhost implementation uses 2 connections,
 * 1 for host-app, 1 for VMCS, and these are hooked together by a loopback MPHI VCFW
 * driver. */
#ifndef VCHI_MAX_NUM_CONNECTIONS
#   define VCHI_MAX_NUM_CONNECTIONS 3
#endif

/* How many services can we open per connection? Extending this doesn't cost processing time, just a small
 * amount of static memory. */
#ifndef VCHI_MAX_SERVICES_PER_CONNECTION
#  define VCHI_MAX_SERVICES_PER_CONNECTION 36
#endif

/* Adjust if using a message driver that supports more logical TX channels */
#ifndef VCHI_MAX_BULK_TX_CHANNELS_PER_CONNECTION
#   define VCHI_MAX_BULK_TX_CHANNELS_PER_CONNECTION 9 // 1 MPHI + 8 CCP2 logical channels
#endif

/* Adjust if using a message driver that supports more logical RX channels */
#ifndef VCHI_MAX_BULK_RX_CHANNELS_PER_CONNECTION
#   define VCHI_MAX_BULK_RX_CHANNELS_PER_CONNECTION 1 // 1 MPHI
#endif

/* How many receive slots do we use. This times VCHI_MAX_MSG_SIZE gives the effective
 * receive queue space, less message headers. */
#ifndef VCHI_NUM_READ_SLOTS
#  if defined(VCHI_LOCAL_HOST_PORT)
#     define VCHI_NUM_READ_SLOTS 4
#  else
#     define VCHI_NUM_READ_SLOTS 48
#  endif
#endif

/* Do we utilise overrun facility for receive message slots? Can aid peer transmit
 * performance. Only define on VideoCore end, talking to host.
 */
//#define VCHI_MSG_RX_OVERRUN

/* How many transmit slots do we use. Generally don't need many, as the hardware driver
 * underneath VCHI will usually have its own buffering. */
#ifndef VCHI_NUM_WRITE_SLOTS
#  define VCHI_NUM_WRITE_SLOTS 4
#endif

/* If a service has held or queued received messages in VCHI_XOFF_THRESHOLD or more slots,
 * then it's taking up too much buffer space, and the peer service will be told to stop
 * transmitting with an XOFF message. For this to be effective, the VCHI_NUM_READ_SLOTS
 * needs to be considerably bigger than VCHI_NUM_WRITE_SLOTS, or the transmit latency
 * is too high. */
#ifndef VCHI_XOFF_THRESHOLD
#  define VCHI_XOFF_THRESHOLD (VCHI_NUM_READ_SLOTS / 2)
#endif

/* After we've sent an XOFF, the peer will be told to resume transmission once the local
 * service has dequeued/released enough messages that it's now occupying
 * VCHI_XON_THRESHOLD slots or fewer. */
#ifndef VCHI_XON_THRESHOLD
#  define VCHI_XON_THRESHOLD (VCHI_NUM_READ_SLOTS / 4)
#endif

/* A size below which a bulk transfer omits the handshake completely and always goes
 * via the message channel, if bulk auxiliary is being sent on that service. (The user
 * can guarantee this by enabling unaligned transmits).
 * Not API. */
#ifndef VCHI_MIN_BULK_SIZE
#  define VCHI_MIN_BULK_SIZE    ( VCHI_MAX_MSG_SIZE / 2 < 4096 ? VCHI_MAX_MSG_SIZE / 2 : 4096 )
#endif

/* Maximum size of bulk transmission chunks, for each interface type. A trade-off between
 * speed and latency; the smaller the chunk size the better change of messages and other
 * bulk transmissions getting in when big bulk transfers are happening. Set to 0 to not
 * break transmissions into chunks.
 */
#ifndef VCHI_MAX_BULK_CHUNK_SIZE_MPHI
#  define VCHI_MAX_BULK_CHUNK_SIZE_MPHI (16 * 1024)
#endif

/* NB Chunked CCP2 transmissions violate the letter of the CCP2 spec by using "JPEG8" mode
 * with multiple-line frames. Only use if the receiver can cope. */
#ifndef VCHI_MAX_BULK_CHUNK_SIZE_CCP2
#  define VCHI_MAX_BULK_CHUNK_SIZE_CCP2 0
#endif

/* How many TX messages can we have pending in our transmit slots. Once exhausted,
 * vchi_msg_queue will be blocked. */
#ifndef VCHI_TX_MSG_QUEUE_SIZE
#  define VCHI_TX_MSG_QUEUE_SIZE           256
#endif

/* How many RX messages can we have parsed in the receive slots. Once exhausted, parsing
 * will be suspended until older messages are dequeued/released. */
#ifndef VCHI_RX_MSG_QUEUE_SIZE
#  define VCHI_RX_MSG_QUEUE_SIZE           256
#endif

/* Really should be able to cope if we run out of received message descriptors, by
 * suspending parsing as the comment above says, but we don't. This sweeps the issue
 * under the carpet. */
#if VCHI_RX_MSG_QUEUE_SIZE < (VCHI_MAX_MSG_SIZE/16 + 1) * VCHI_NUM_READ_SLOTS
#  undef VCHI_RX_MSG_QUEUE_SIZE
#  define VCHI_RX_MSG_QUEUE_SIZE (VCHI_MAX_MSG_SIZE/16 + 1) * VCHI_NUM_READ_SLOTS
#endif

/* How many bulk transmits can we have pending. Once exhausted, vchi_bulk_queue_transmit
 * will be blocked. */
#ifndef VCHI_TX_BULK_QUEUE_SIZE
#  define VCHI_TX_BULK_QUEUE_SIZE           64
#endif

/* How many bulk receives can we have pending. Once exhausted, vchi_bulk_queue_receive
 * will be blocked. */
#ifndef VCHI_RX_BULK_QUEUE_SIZE
#  define VCHI_RX_BULK_QUEUE_SIZE           64
#endif

/* A limit on how many outstanding bulk requests we expect the peer to give us. If
 * the peer asks for more than this, VCHI will fail and assert. The number is determined
 * by the peer's hardware - it's the number of outstanding requests that can be queued
 * on all bulk channels. VC3's MPHI peripheral allows 16. */
#ifndef VCHI_MAX_PEER_BULK_REQUESTS
#  define VCHI_MAX_PEER_BULK_REQUESTS       32
#endif

/* Define VCHI_CCP2TX_MANUAL_POWER if the host tells us when to turn the CCP2
 * transmitter on and off.
 */
/*#define VCHI_CCP2TX_MANUAL_POWER*/

#ifndef VCHI_CCP2TX_MANUAL_POWER

/* Timeout (in milliseconds) for putting the CCP2TX interface into IDLE state. Set
 * negative for no IDLE.
 */
#  ifndef VCHI_CCP2TX_IDLE_TIMEOUT
#    define VCHI_CCP2TX_IDLE_TIMEOUT        5
#  endif

/* Timeout (in milliseconds) for putting the CCP2TX interface into OFF state. Set
 * negative for no OFF.
 */
#  ifndef VCHI_CCP2TX_OFF_TIMEOUT
#    define VCHI_CCP2TX_OFF_TIMEOUT         1000
#  endif

#endif /* VCHI_CCP2TX_MANUAL_POWER */

#endif /* VCHI_CFG_H_ */

/****************************** End of file **********************************/
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef VCHI_CFG_INTERNAL_H_
#define VCHI_CFG_INTERNAL_H_

/****************************************************************************************
 * Control optimisation attempts.
 ***************************************************************************************/

// Don't use lots of short-term locks - use great long ones, reducing the overall locks-per-second
#define VCHI_COARSE_LOCKING

// Avoid lock then unlock on exit from blocking queue operations (msg tx, bulk rx/tx)
// (only relevant if VCHI_COARSE_LOCKING)
#define VCHI_ELIDE_BLOCK_EXIT_LOCK

// Avoid lock on non-blocking peek
// (only relevant if VCHI_COARSE_LOCKING)
#define VCHI_AVOID_PEEK_LOCK

// Use one slot-handler thread per connection, rather than 1 thread dealing with all connections in rotation.
#define VCHI_MULTIPLE_HANDLER_THREADS

// Put free descriptors onto the head of the free queue, rather than the tail, so that we don't thrash
// our way through the pool of descriptors.
#define VCHI_PUSH_FREE_DESCRIPTORS_ONTO_HEAD

// Don't issue a MSG_AVAILABLE callback for every single message. Possibly only safe if VCHI_COARSE_LOCKING.
#define VCHI_FEWER_MSG_AVAILABLE_CALLBACKS

// Don't use message descriptors for TX messages that don't need them
#define VCHI_MINIMISE_TX_MSG_DESCRIPTORS

// Nano-locks for multiqueue
//#define VCHI_MQUEUE_NANOLOCKS

// Lock-free(er) dequeuing
//#define VCHI_RX_NANOLOCKS

#endif /*VCHI_CFG_INTERNAL_H_*/
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef VCHI_MH_H_
#define VCHI_MH_H_

#include <interface/vcos/vcos.h>

typedef int32_t VCHI_MEM_HANDLE_T;
#define VCHI_MEM_HANDLE_INVALID 0

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             /*
Copyright (c) 2012-2014, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// Contains global defs used by submodules within vchi

#ifndef VCHI_COMMON_H_
#define VCHI_COMMON_H_


//flags used when sending messages (must be bitmapped)
typedef enum
{
   VCHI_FLAGS_NONE                      = 0x0,
   VCHI_FLAGS_BLOCK_UNTIL_OP_COMPLETE   = 0x1,   // waits for message to be received, or sent (NB. not the same as being seen on other side)
   VCHI_FLAGS_CALLBACK_WHEN_OP_COMPLETE = 0x2,   // run a callback when message sent
   VCHI_FLAGS_BLOCK_UNTIL_QUEUED        = 0x4,   // return once the transfer is in a queue ready to go
   VCHI_FLAGS_ALLOW_PARTIAL             = 0x8,
   VCHI_FLAGS_BLOCK_UNTIL_DATA_READ     = 0x10,
   VCHI_FLAGS_CALLBACK_WHEN_DATA_READ   = 0x20,

   VCHI_FLAGS_ALIGN_SLOT            = 0x000080,  // internal use only
   VCHI_FLAGS_BULK_AUX_QUEUED       = 0x010000,  // internal use only
   VCHI_FLAGS_BULK_AUX_COMPLETE     = 0x020000,  // internal use only
   VCHI_FLAGS_BULK_DATA_QUEUED      = 0x040000,  // internal use only
   VCHI_FLAGS_BULK_DATA_COMPLETE    = 0x080000,  // internal use only
   VCHI_FLAGS_INTERNAL              = 0xFF0000
} VCHI_FLAGS_T;

// constants for vchi_crc_control()
typedef enum {
   VCHI_CRC_NOTHING = -1,
   VCHI_CRC_PER_SERVICE = 0,
   VCHI_CRC_EVERYTHING = 1,
} VCHI_CRC_CONTROL_T;

//callback reasons when an event occurs on a service
typedef enum
{
   VCHI_CALLBACK_REASON_MIN,

   //This indicates that there is data available
   //handle is the msg id that was transmitted with the data
   //    When a message is received and there was no FULL message available previously, send callback
   //    Tasks get kicked by the callback, reset their event and try and read from the fifo until it fails
   VCHI_CALLBACK_MSG_AVAILABLE,
   VCHI_CALLBACK_MSG_SENT,
   VCHI_CALLBACK_MSG_SPACE_AVAILABLE, // XXX not yet implemented

   // This indicates that a transfer from the other side has completed
   VCHI_CALLBACK_BULK_RECEIVED,
   //This indicates that data queued up to be sent has now gone
   //handle is the msg id that was used when sending the data
   VCHI_CALLBACK_BULK_SENT,
   VCHI_CALLBACK_BULK_RX_SPACE_AVAILABLE, // XXX not yet implemented
   VCHI_CALLBACK_BULK_TX_SPACE_AVAILABLE, // XXX not yet implemented

   VCHI_CALLBACK_SERVICE_CLOSED,

   // this side has sent XOFF to peer due to lack of data consumption by service
   // (suggests the service may need to take some recovery action if it has
   // been deliberately holding off consuming data)
   VCHI_CALLBACK_SENT_XOFF,
   VCHI_CALLBACK_SENT_XON,

   // indicates that a bulk transfer has finished reading the source buffer
   VCHI_CALLBACK_BULK_DATA_READ,

   // power notification events (currently host side only)
   VCHI_CALLBACK_PEER_OFF,
   VCHI_CALLBACK_PEER_SUSPENDED,
   VCHI_CALLBACK_PEER_ON,
   VCHI_CALLBACK_PEER_RESUMED,
   VCHI_CALLBACK_FORCED_POWER_OFF,

#ifdef USE_VCHIQ_ARM
   // some extra notifications provided by vchiq_arm
   VCHI_CALLBACK_SERVICE_OPENED,
   VCHI_CALLBACK_BULK_RECEIVE_ABORTED,
   VCHI_CALLBACK_BULK_TRANSMIT_ABORTED,
#endif

   VCHI_CALLBACK_REASON_MAX
} VCHI_CALLBACK_REASON_T;

// service control options
typedef enum
{
   VCHI_SERVICE_OPTION_MIN,

   VCHI_SERVICE_OPTION_TRACE,
   VCHI_SERVICE_OPTION_SYNCHRONOUS,

   VCHI_SERVICE_OPTION_MAX
} VCHI_SERVICE_OPTION_T;

//Callback used by all services / bulk transfers
typedef void (*VCHI_CALLBACK_T)( void *callback_param, //my service local param
                                 VCHI_CALLBACK_REASON_T reason,
                                 void *handle ); //for transmitting msg's only



/*
 * Define vector struct for scatter-gather (vector) operations
 * Vectors can be nested - if a vector element has negative length, then
 * the data pointer is treated as pointing to another vector array, with
 * '-vec_len' elements. Thus to append a header onto an existing vector,
 * you can do this:
 *
 * void foo(const VCHI_MSG_VECTOR_T *v, int n)
 * {
 *    VCHI_MSG_VECTOR_T nv[2];
 *    nv[0].vec_base = my_header;
 *    nv[0].vec_len = sizeof my_header;
 *    nv[1].vec_base = v;
 *    nv[1].vec_len = -n;
 *    ...
 *
 */
typedef struct vchi_msg_vector {
   const void *vec_base;
   int32_t vec_len;
} VCHI_MSG_VECTOR_T;

// Opaque type for a connection API
typedef struct opaque_vchi_connection_api_t VCHI_CONNECTION_API_T;

// Opaque type for a message driver
typedef struct opaque_vchi_message_driver_t VCHI_MESSAGE_DRIVER_T;


// Iterator structure for reading ahead through received message queue. Allocated by client,
// initialised by vchi_msg_look_ahead. Fields are for internal VCHI use only.
// Iterates over messages in queue at the instant of the call to vchi_msg_lookahead -
// will not proceed to messages received since. Behaviour is undefined if an iterator
// is used again after messages for that service are removed/dequeued by any
// means other than vchi_msg_iter_... calls on the iterator itself.
typedef struct {
   struct opaque_vchi_service_t *service;
   void *last;
   void *next;
   void *remove;
} VCHI_MSG_ITER_T;


#endif // VCHI_COMMON_H_
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef _VCHI_ENDIAN_H_
#define _VCHI_ENDIAN_H_

#include "interface/vcos/vcos.h"

int16_t  vchi_readbuf_int16 ( const void *ptr );
uint16_t vchi_readbuf_uint16( const void *ptr );
uint32_t vchi_readbuf_uint32( const void *ptr );
vcos_fourcc_t vchi_readbuf_fourcc( const void *ptr );

void vchi_writebuf_uint16( void *ptr, uint16_t value );
void vchi_writebuf_uint32( void *ptr, uint32_t value );
void vchi_writebuf_fourcc( void *ptr, vcos_fourcc_t value );

#endif /* _VCHI_ENDIAN_H_ */

/********************************** End of file ******************************************/
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef VCHIQ_VCHIQ_H
#define VCHIQ_VCHIQ_H

#include "vchiq_if.h"
#include "vchiq_util.h"
#include "interface/vcos/vcos.h"

#endif

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
 * \file
 *
 * \brief Contains the protypes for the interface functions.
*/

#ifndef CONNECTION_H_
#define CONNECTION_H_

#include "interface/vchi/vchi_cfg_internal.h"
#include "interface/vchi/vchi_common.h"
#include "interface/vchi/message_drivers/message.h"

/******************************************************************************
 Global defs
 *****************************************************************************/

// Opaque handle for a connection / service pair
typedef struct opaque_vchi_connection_connected_service_handle_t *VCHI_CONNECTION_SERVICE_HANDLE_T;

// opaque handle to the connection state information
typedef struct opaque_vchi_connection_info_t VCHI_CONNECTION_STATE_T;

typedef struct vchi_connection_t VCHI_CONNECTION_T;


/******************************************************************************
 API
 *****************************************************************************/

// Routine to init a connection with a particular low level driver
typedef VCHI_CONNECTION_STATE_T * (*VCHI_CONNECTION_INIT_T)( struct vchi_connection_t * connection,
                                                             const VCHI_MESSAGE_DRIVER_T * driver );

// Routine to control CRC enabling at a connection level
typedef int32_t (*VCHI_CONNECTION_CRC_CONTROL_T)( VCHI_CONNECTION_STATE_T *state_handle,
                                                  VCHI_CRC_CONTROL_T control );

// Routine to create a service
typedef int32_t (*VCHI_CONNECTION_SERVICE_CONNECT_T)( VCHI_CONNECTION_STATE_T *state_handle,
                                                      vcos_fourcc_t service_id,
                                                      uint32_t rx_fifo_size,
                                                      uint32_t tx_fifo_size,
                                                      int server,
                                                      VCHI_CALLBACK_T callback,
                                                      void *callback_param,
                                                      vcos_bool_t want_crc,
                                                      vcos_bool_t want_unaligned_bulk_rx,
                                                      vcos_bool_t want_unaligned_bulk_tx,
                                                      VCHI_CONNECTION_SERVICE_HANDLE_T *service_handle );

// Routine to close a service
typedef int32_t (*VCHI_CONNECTION_SERVICE_DISCONNECT_T)( VCHI_CONNECTION_SERVICE_HANDLE_T service_handle );

// Routine to queue a message
typedef int32_t (*VCHI_CONNECTION_SERVICE_QUEUE_MESSAGE_T)( VCHI_CONNECTION_SERVICE_HANDLE_T service_handle,
                                                            const void *data,
                                                            uint32_t data_size,
                                                            VCHI_FLAGS_T flags,
                                                            void *msg_handle );

// scatter-gather (vector) message queueing
typedef int32_t (*VCHI_CONNECTION_SERVICE_QUEUE_MESSAGEV_T)( VCHI_CONNECTION_SERVICE_HANDLE_T service_handle,
                                                             VCHI_MSG_VECTOR_T *vector,
                                                             uint32_t count,
                                                             VCHI_FLAGS_T flags,
                                                             void *msg_handle );

// Routine to dequeue a message
typedef int32_t (*VCHI_CONNECTION_SERVICE_DEQUEUE_MESSAGE_T)( VCHI_CONNECTION_SERVICE_HANDLE_T service_handle,
                                                              void *data,
                                                              uint32_t max_data_size_to_read,
                                                              uint32_t *actual_msg_size,
                                                              VCHI_FLAGS_T flags );

// Routine to peek at a message
typedef int32_t (*VCHI_CONNECTION_SERVICE_PEEK_MESSAGE_T)( VCHI_CONNECTION_SERVICE_HANDLE_T service_handle,
                                                           void **data,
                                                           uint32_t *msg_size,
                                                           VCHI_FLAGS_T flags );

// Routine to hold a message
typedef int32_t (*VCHI_CONNECTION_SERVICE_HOLD_MESSAGE_T)( VCHI_CONNECTION_SERVICE_HANDLE_T service_handle,
                                                           void **data,
                                                           uint32_t *msg_size,
                                                           VCHI_FLAGS_T flags,
                                                           void **message_handle );

// Routine to initialise a received message iterator
typedef int32_t (*VCHI_CONNECTION_SERVICE_LOOKAHEAD_MESSAGE_T)( VCHI_CONNECTION_SERVICE_HANDLE_T service_handle,
                                                                VCHI_MSG_ITER_T *iter,
                                                                VCHI_FLAGS_T flags );

// Routine to release a held message
typedef int32_t (*VCHI_CONNECTION_HELD_MSG_RELEASE_T)( VCHI_CONNECTION_SERVICE_HANDLE_T service_handle,
                                                       void *message_handle );

// Routine to get info on a held message
typedef int32_t (*VCHI_CONNECTION_HELD_MSG_INFO_T)( VCHI_CONNECTION_SERVICE_HANDLE_T service_handle,
                                                    void *message_handle,
                                                    void **data,
                                                    int32_t *msg_size,
                                                    uint32_t *tx_timestamp,
                                                    uint32_t *rx_timestamp );

// Routine to check whether the iterator has a next message
typedef vcos_bool_t (*VCHI_CONNECTION_MSG_ITER_HAS_NEXT_T)( VCHI_CONNECTION_SERVICE_HANDLE_T service,
                                                       const VCHI_MSG_ITER_T *iter );

// Routine to advance the iterator
typedef int32_t (*VCHI_CONNECTION_MSG_ITER_NEXT_T)( VCHI_CONNECTION_SERVICE_HANDLE_T service,
                                                    VCHI_MSG_ITER_T *iter,
                                                    void **data,
                                                    uint32_t *msg_size );

// Routine to remove the last message returned by the iterator
typedef int32_t (*VCHI_CONNECTION_MSG_ITER_REMOVE_T)( VCHI_CONNECTION_SERVICE_HANDLE_T service,
                                                      VCHI_MSG_ITER_T *iter );

// Routine to hold the last message returned by the iterator
typedef int32_t (*VCHI_CONNECTION_MSG_ITER_HOLD_T)( VCHI_CONNECTION_SERVICE_HANDLE_T service,
                                                    VCHI_MSG_ITER_T *iter,
                                                    void **msg_handle );

// Routine to transmit bulk data
typedef int32_t (*VCHI_CONNECTION_BULK_QUEUE_TRANSMIT_T)( VCHI_CONNECTION_SERVICE_HANDLE_T service_handle,
                                                          const void *data_src,
                                                          uint32_t data_size,
                                                          VCHI_FLAGS_T flags,
                                                          void *bulk_handle );

// Routine to receive data
typedef int32_t (*VCHI_CONNECTION_BULK_QUEUE_RECEIVE_T)( VCHI_CONNECTION_SERVICE_HANDLE_T service_handle,
                                                         void *data_dst,
                                                         uint32_t data_size,
                                                         VCHI_FLAGS_T flags,
                                                         void *bulk_handle );

// Routine to report if a server is available
typedef int32_t (*VCHI_CONNECTION_SERVER_PRESENT)( VCHI_CONNECTION_STATE_T *state, vcos_fourcc_t service_id, int32_t peer_flags );

// Routine to report the number of RX slots available
typedef int (*VCHI_CONNECTION_RX_SLOTS_AVAILABLE)( const VCHI_CONNECTION_STATE_T *state );

// Routine to report the RX slot size
typedef uint32_t (*VCHI_CONNECTION_RX_SLOT_SIZE)( const VCHI_CONNECTION_STATE_T *state );

// Callback to indicate that the other side has added a buffer to the rx bulk DMA FIFO
typedef void (*VCHI_CONNECTION_RX_BULK_BUFFER_ADDED)(VCHI_CONNECTION_STATE_T *state,
                                                     vcos_fourcc_t service,
                                                     uint32_t length,
                                                     MESSAGE_TX_CHANNEL_T channel,
                                                     uint32_t channel_params,
                                                     uint32_t data_length,
                                                     uint32_t data_offset);

// Callback to inform a service that a Xon or Xoff message has been received
typedef void (*VCHI_CONNECTION_FLOW_CONTROL)(VCHI_CONNECTION_STATE_T *state, vcos_fourcc_t service_id, int32_t xoff);

// Callback to inform a service that a server available reply message has been received
typedef void (*VCHI_CONNECTION_SERVER_AVAILABLE_REPLY)(VCHI_CONNECTION_STATE_T *state, vcos_fourcc_t service_id, uint32_t flags);

// Callback to indicate that bulk auxiliary messages have arrived
typedef void (*VCHI_CONNECTION_BULK_AUX_RECEIVED)(VCHI_CONNECTION_STATE_T *state);

// Callback to indicate that bulk auxiliary messages have arrived
typedef void (*VCHI_CONNECTION_BULK_AUX_TRANSMITTED)(VCHI_CONNECTION_STATE_T *state, void *handle);

// Callback with all the connection info you require
typedef void (*VCHI_CONNECTION_INFO)(VCHI_CONNECTION_STATE_T *state, uint32_t protocol_version, uint32_t slot_size, uint32_t num_slots, uint32_t min_bulk_size);

// Callback to inform of a disconnect
typedef void (*VCHI_CONNECTION_DISCONNECT)(VCHI_CONNECTION_STATE_T *state, uint32_t flags);

// Callback to inform of a power control request
typedef void (*VCHI_CONNECTION_POWER_CONTROL)(VCHI_CONNECTION_STATE_T *state, MESSAGE_TX_CHANNEL_T channel, vcos_bool_t enable);

// allocate memory suitably aligned for this connection
typedef void * (*VCHI_BUFFER_ALLOCATE)(VCHI_CONNECTION_SERVICE_HANDLE_T service_handle, uint32_t * length);

// free memory allocated by buffer_allocate
typedef void   (*VCHI_BUFFER_FREE)(VCHI_CONNECTION_SERVICE_HANDLE_T service_handle, void * address);


/******************************************************************************
 System driver struct
 *****************************************************************************/

struct opaque_vchi_connection_api_t
{
   // Routine to init the connection
   VCHI_CONNECTION_INIT_T                      init;

   // Connection-level CRC control
   VCHI_CONNECTION_CRC_CONTROL_T               crc_control;

   // Routine to connect to or create service
   VCHI_CONNECTION_SERVICE_CONNECT_T           service_connect;

   // Routine to disconnect from a service
   VCHI_CONNECTION_SERVICE_DISCONNECT_T        service_disconnect;

   // Routine to queue a message
   VCHI_CONNECTION_SERVICE_QUEUE_MESSAGE_T     service_queue_msg;

   // scatter-gather (vector) message queue
   VCHI_CONNECTION_SERVICE_QUEUE_MESSAGEV_T    service_queue_msgv;

   // Routine to dequeue a message
   VCHI_CONNECTION_SERVICE_DEQUEUE_MESSAGE_T   service_dequeue_msg;

   // Routine to peek at a message
   VCHI_CONNECTION_SERVICE_PEEK_MESSAGE_T      service_peek_msg;

   // Routine to hold a message
   VCHI_CONNECTION_SERVICE_HOLD_MESSAGE_T      service_hold_msg;

   // Routine to initialise a received message iterator
   VCHI_CONNECTION_SERVICE_LOOKAHEAD_MESSAGE_T service_look_ahead_msg;

   // Routine to release a message
   VCHI_CONNECTION_HELD_MSG_RELEASE_T          held_msg_release;

   // Routine to get information on a held message
   VCHI_CONNECTION_HELD_MSG_INFO_T             held_msg_info;

   // Routine to check for next message on iterator
   VCHI_CONNECTION_MSG_ITER_HAS_NEXT_T         msg_iter_has_next;

   // Routine to get next message on iterator
   VCHI_CONNECTION_MSG_ITER_NEXT_T             msg_iter_next;

   // Routine to remove the last message returned by iterator
   VCHI_CONNECTION_MSG_ITER_REMOVE_T           msg_iter_remove;

   // Routine to hold the last message returned by iterator
   VCHI_CONNECTION_MSG_ITER_HOLD_T             msg_iter_hold;

   // Routine to transmit bulk data
   VCHI_CONNECTION_BULK_QUEUE_TRANSMIT_T       bulk_queue_transmit;

   // Routine to receive data
   VCHI_CONNECTION_BULK_QUEUE_RECEIVE_T        bulk_queue_receive;

   // Routine to report the available servers
   VCHI_CONNECTION_SERVER_PRESENT              server_present;

   // Routine to report the number of RX slots available
   VCHI_CONNECTION_RX_SLOTS_AVAILABLE          connection_rx_slots_available;

   // Routine to report the RX slot size
   VCHI_CONNECTION_RX_SLOT_SIZE                connection_rx_slot_size;

   // Callback to indicate that the other side has added a buffer to the rx bulk DMA FIFO
   VCHI_CONNECTION_RX_BULK_BUFFER_ADDED        rx_bulk_buffer_added;

   // Callback to inform a service that a Xon or Xoff message has been received
   VCHI_CONNECTION_FLOW_CONTROL                flow_control;

   // Callback to inform a service that a server available reply message has been received
   VCHI_CONNECTION_SERVER_AVAILABLE_REPLY      server_available_reply;

   // Callback to indicate that bulk auxiliary messages have arrived
   VCHI_CONNECTION_BULK_AUX_RECEIVED           bulk_aux_received;

   // Callback to indicate that a bulk auxiliary message has been transmitted
   VCHI_CONNECTION_BULK_AUX_TRANSMITTED        bulk_aux_transmitted;

   // Callback to provide information about the connection
   VCHI_CONNECTION_INFO                        connection_info;

   // Callback to notify that peer has requested disconnect
   VCHI_CONNECTION_DISCONNECT                  disconnect;

   // Callback to notify that peer has requested power change
   VCHI_CONNECTION_POWER_CONTROL               power_control;

   // allocate memory suitably aligned for this connection
   VCHI_BUFFER_ALLOCATE                        buffer_allocate;

   // free memory allocated by buffer_allocate
   VCHI_BUFFER_FREE                            buffer_free;

};

struct vchi_connection_t {
   const VCHI_CONNECTION_API_T *api;
   VCHI_CONNECTION_STATE_T     *state;
#ifdef VCHI_COARSE_LOCKING
   VCOS_SEMAPHORE_T             sem;
#endif
};


#endif /* CONNECTION_H_ */

/****************************** End of file **********************************/
                                                                                                                                                                         /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// MPHI videocore message driver

#ifndef _VCHI_MESSAGE_H_
#define _VCHI_MESSAGE_H_

#include "interface/vchi/vchi_cfg_internal.h"
#include "interface/vcos/vcos.h"
#include "interface/vchi/vchi_common.h"


typedef enum message_event_type {
   MESSAGE_EVENT_NONE,
   MESSAGE_EVENT_NOP,
   MESSAGE_EVENT_MESSAGE,
   MESSAGE_EVENT_SLOT_COMPLETE,
   MESSAGE_EVENT_RX_BULK_PAUSED,
   MESSAGE_EVENT_RX_BULK_COMPLETE,
   MESSAGE_EVENT_TX_COMPLETE,
   MESSAGE_EVENT_MSG_DISCARDED
} MESSAGE_EVENT_TYPE_T;

typedef enum vchi_msg_flags
{
   VCHI_MSG_FLAGS_NONE                  = 0x0,
   VCHI_MSG_FLAGS_TERMINATE_DMA         = 0x1
} VCHI_MSG_FLAGS_T;

typedef enum message_tx_channel
{
   MESSAGE_TX_CHANNEL_MESSAGE           = 0,
   MESSAGE_TX_CHANNEL_BULK              = 1 // drivers may provide multiple bulk channels, from 1 upwards
} MESSAGE_TX_CHANNEL_T;

// Macros used for cycling through bulk channels
#define MESSAGE_TX_CHANNEL_BULK_PREV(c) (MESSAGE_TX_CHANNEL_BULK+((c)-MESSAGE_TX_CHANNEL_BULK+VCHI_MAX_BULK_TX_CHANNELS_PER_CONNECTION-1)%VCHI_MAX_BULK_TX_CHANNELS_PER_CONNECTION)
#define MESSAGE_TX_CHANNEL_BULK_NEXT(c) (MESSAGE_TX_CHANNEL_BULK+((c)-MESSAGE_TX_CHANNEL_BULK+1)%VCHI_MAX_BULK_TX_CHANNELS_PER_CONNECTION)

typedef enum message_rx_channel
{
   MESSAGE_RX_CHANNEL_MESSAGE           = 0,
   MESSAGE_RX_CHANNEL_BULK              = 1 // drivers may provide multiple bulk channels, from 1 upwards
} MESSAGE_RX_CHANNEL_T;

// Message receive slot information
typedef struct rx_msg_slot_info {

   struct rx_msg_slot_info *next;
   //struct slot_info *prev;
#if !defined VCHI_COARSE_LOCKING
   VCOS_SEMAPHORE_T   sem;
#endif

   uint8_t           *addr;               // base address of slot
   uint32_t           len;                // length of slot in bytes

   uint32_t           write_ptr;          // hardware causes this to advance
   uint32_t           read_ptr;           // this module does the reading
   int                active;             // is this slot in the hardware dma fifo?
   uint32_t           msgs_parsed;        // count how many messages are in this slot
   uint32_t           msgs_released;      // how many messages have been released
   void              *state;              // connection state information
   uint8_t            ref_count[VCHI_MAX_SERVICES_PER_CONNECTION];          // reference count for slots held by services
} RX_MSG_SLOTINFO_T;

// The message driver no longer needs to know about the fields of RX_BULK_SLOTINFO_T - sort this out.
// In particular, it mustn't use addr and len - they're the client buffer, but the message
// driver will be tasked with sending the aligned core section.
typedef struct rx_bulk_slotinfo_t {
   struct rx_bulk_slotinfo_t *next;

   VCOS_SEMAPHORE_T *blocking;

   // needed by DMA
   void        *addr;
   uint32_t     len;

   // needed for the callback
   void        *service;
   void        *handle;
   VCHI_FLAGS_T flags;
} RX_BULK_SLOTINFO_T;


/* ----------------------------------------------------------------------
 * each connection driver will have a pool of the following struct.
 *
 * the pool will be managed by vchi_qman_*
 * this means there will be multiple queues (single linked lists)
 * a given struct message_info will be on exactly one of these queues
 * at any one time
 * -------------------------------------------------------------------- */
typedef struct rx_message_info {

   struct message_info *next;
   //struct message_info *prev;

   uint8_t    *addr;
   uint32_t   len;
   RX_MSG_SLOTINFO_T *slot; // points to whichever slot contains this message
   uint32_t   tx_timestamp;
   uint32_t   rx_timestamp;

} RX_MESSAGE_INFO_T;

typedef struct {
   MESSAGE_EVENT_TYPE_T type;

   struct {
      // for messages
      void    *addr;           // address of message
      uint16_t slot_delta;     // whether this message indicated slot delta
      uint32_t len;            // length of message
      RX_MSG_SLOTINFO_T *slot; // slot this message is in
      vcos_fourcc_t service;   // service id this message is destined for
      uint32_t tx_timestamp;   // timestamp from the header
      uint32_t rx_timestamp;   // timestamp when we parsed it
   } message;

   // FIXME: cleanup slot reporting...
   RX_MSG_SLOTINFO_T *rx_msg;
   RX_BULK_SLOTINFO_T *rx_bulk;
   void *tx_handle;
   MESSAGE_TX_CHANNEL_T tx_channel;

} MESSAGE_EVENT_T;


// callbacks
typedef void VCHI_MESSAGE_DRIVER_EVENT_CALLBACK_T( void *state );

typedef struct {
   VCHI_MESSAGE_DRIVER_EVENT_CALLBACK_T *event_callback;
} VCHI_MESSAGE_DRIVER_OPEN_T;


// handle to this instance of message driver (as returned by ->open)
typedef struct opaque_mhandle_t *VCHI_MDRIVER_HANDLE_T;

struct opaque_vchi_message_driver_t {
   VCHI_MDRIVER_HANDLE_T *(*open)( VCHI_MESSAGE_DRIVER_OPEN_T *params, void *state );
   int32_t (*suspending)( VCHI_MDRIVER_HANDLE_T *handle );
   int32_t (*resumed)( VCHI_MDRIVER_HANDLE_T *handle );
   int32_t (*power_control)( VCHI_MDRIVER_HANDLE_T *handle, MESSAGE_TX_CHANNEL_T, vcos_bool_t enable );
   int32_t (*add_msg_rx_slot)( VCHI_MDRIVER_HANDLE_T *handle, RX_MSG_SLOTINFO_T *slot );      // rx message
   int32_t (*add_bulk_rx)( VCHI_MDRIVER_HANDLE_T *handle, void *data, uint32_t len, RX_BULK_SLOTINFO_T *slot );  // rx data (bulk)
   int32_t (*send)( VCHI_MDRIVER_HANDLE_T *handle, MESSAGE_TX_CHANNEL_T channel, const void *data, uint32_t len, VCHI_MSG_FLAGS_T flags, void *send_handle );      // tx (message & bulk)
   void    (*next_event)( VCHI_MDRIVER_HANDLE_T *handle, MESSAGE_EVENT_T *event );     // get the next event from message_driver
   int32_t (*enable)( VCHI_MDRIVER_HANDLE_T *handle );
   int32_t (*form_message)( VCHI_MDRIVER_HANDLE_T *handle, vcos_fourcc_t service_id, VCHI_MSG_VECTOR_T *vector, uint32_t count, void
                            *address, uint32_t length_avail, uint32_t max_total_length, vcos_bool_t pad_to_fill, vcos_bool_t allow_partial );

   int32_t (*update_message)( VCHI_MDRIVER_HANDLE_T *handle, void *dest, int16_t *slot_count );
   int32_t (*buffer_aligned)( VCHI_MDRIVER_HANDLE_T *handle, int tx, int uncached, const void *address, const uint32_t length );
   void *  (*allocate_buffer)( VCHI_MDRIVER_HANDLE_T *handle, uint32_t *length );
   void    (*free_buffer)( VCHI_MDRIVER_HANDLE_T *handle, void *address );
   int     (*rx_slot_size)( VCHI_MDRIVER_HANDLE_T *handle, int msg_size );
   int     (*tx_slot_size)( VCHI_MDRIVER_HANDLE_T *handle, int msg_size );

   vcos_bool_t  (*tx_supports_terminate)( const VCHI_MDRIVER_HANDLE_T *handle, MESSAGE_TX_CHANNEL_T channel );
   uint32_t (*tx_bulk_chunk_size)( const VCHI_MDRIVER_HANDLE_T *handle, MESSAGE_TX_CHANNEL_T channel );
   int     (*tx_alignment)( const VCHI_MDRIVER_HANDLE_T *handle, MESSAGE_TX_CHANNEL_T channel );
   int     (*rx_alignment)( const VCHI_MDRIVER_HANDLE_T *handle, MESSAGE_RX_CHANNEL_T channel );
   void    (*form_bulk_aux)( VCHI_MDRIVER_HANDLE_T *handle, MESSAGE_TX_CHANNEL_T channel, const void *data, uint32_t len, uint32_t chunk_size, const void **aux_data, int32_t *aux_len );
   void    (*debug)( VCHI_MDRIVER_HANDLE_T *handle );
};


#endif // _VCHI_MESSAGE_H_

/****************************** End of file ***********************************/
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   /*
Copyright (c) 2014, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef VCHIQ_CFG_H
#define VCHIQ_CFG_H

#define VCHIQ_MAGIC              VCHIQ_MAKE_FOURCC('V', 'C', 'H', 'I')
/* The version of VCHIQ - change with any non-trivial change */
#define VCHIQ_VERSION            8
/* The minimum compatible version - update to match VCHIQ_VERSION with any
** incompatible change */
#define VCHIQ_VERSION_MIN        3

/* The version that introduced the VCHIQ_IOC_LIB_VERSION ioctl */
#define VCHIQ_VERSION_LIB_VERSION 7

/* The version that introduced the VCHIQ_IOC_CLOSE_DELIVERED ioctl */
#define VCHIQ_VERSION_CLOSE_DELIVERED 7

/* The version that made it safe to use SYNCHRONOUS mode */
#define VCHIQ_VERSION_SYNCHRONOUS_MODE 8

#define VCHIQ_MAX_STATES         2
#define VCHIQ_MAX_SERVICES       4096
#define VCHIQ_MAX_SLOTS          128
#define VCHIQ_MAX_SLOTS_PER_SIDE 64

#define VCHIQ_NUM_CURRENT_BULKS        32
#define VCHIQ_NUM_SERVICE_BULKS        4

#ifndef VCHIQ_ENABLE_DEBUG
#define VCHIQ_ENABLE_DEBUG             1
#endif

#ifndef VCHIQ_ENABLE_STATS
#define VCHIQ_ENABLE_STATS             1
#endif

#endif /* VCHIQ_CFG_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef VCHIQ_IF_H
#define VCHIQ_IF_H

#include "interface/vchi/vchi_mh.h"

#ifdef __cplusplus
extern "C" {
#endif

#define VCHIQ_SERVICE_HANDLE_INVALID 0

#define VCHIQ_SLOT_SIZE          4096
#define VCHIQ_MAX_MSG_SIZE       (VCHIQ_SLOT_SIZE - sizeof(VCHIQ_HEADER_T))
#define VCHIQ_CHANNEL_SIZE       VCHIQ_MAX_MSG_SIZE /* For backwards compatibility */

#define VCHIQ_MAKE_FOURCC(x0, x1, x2, x3)     (((x0) << 24) | ((x1) << 16) | ((x2) << 8) | (x3))
#define VCHIQ_GET_SERVICE_USERDATA(service) vchiq_get_service_userdata(service)
#define VCHIQ_GET_SERVICE_FOURCC(service)   vchiq_get_service_fourcc(service)

typedef enum {
   VCHIQ_SERVICE_OPENED,         // service, -, -
   VCHIQ_SERVICE_CLOSED,         // service, -, -
   VCHIQ_MESSAGE_AVAILABLE,      // service, header, -
   VCHIQ_BULK_TRANSMIT_DONE,     // service, -, bulk_userdata
   VCHIQ_BULK_RECEIVE_DONE,      // service, -, bulk_userdata
   VCHIQ_BULK_TRANSMIT_ABORTED,  // service, -, bulk_userdata
   VCHIQ_BULK_RECEIVE_ABORTED    // service, -, bulk_userdata
} VCHIQ_REASON_T;

typedef enum
{
   VCHIQ_ERROR   = -1,
   VCHIQ_SUCCESS = 0,
   VCHIQ_RETRY   = 1
} VCHIQ_STATUS_T;

typedef enum
{
   VCHIQ_BULK_MODE_CALLBACK,
   VCHIQ_BULK_MODE_BLOCKING,
   VCHIQ_BULK_MODE_NOCALLBACK
} VCHIQ_BULK_MODE_T;

typedef enum
{
   VCHIQ_SERVICE_OPTION_AUTOCLOSE,
   VCHIQ_SERVICE_OPTION_SLOT_QUOTA,
   VCHIQ_SERVICE_OPTION_MESSAGE_QUOTA,
   VCHIQ_SERVICE_OPTION_SYNCHRONOUS,
   VCHIQ_SERVICE_OPTION_TRACE
} VCHIQ_SERVICE_OPTION_T;

#ifdef __HIGHC__
/* Allow zero-sized arrays without warnings */
#pragma warning (push)
#pragma warning (disable : 4200)
#endif

typedef struct vchiq_header_struct {
   /* The message identifier - opaque to applications. */
   int msgid;

   /* Size of message data. */
   unsigned int size;      

   char data[0];           /* message */
} VCHIQ_HEADER_T;

#ifdef __HIGHC__
#pragma warning (pop)
#endif

typedef struct {
   const void *data;
   int size;
} VCHIQ_ELEMENT_T;

typedef unsigned int VCHIQ_SERVICE_HANDLE_T;

typedef VCHIQ_STATUS_T (*VCHIQ_CALLBACK_T)(VCHIQ_REASON_T, VCHIQ_HEADER_T *,
   VCHIQ_SERVICE_HANDLE_T, void *);

typedef struct vchiq_service_base_struct {
   int fourcc;
   VCHIQ_CALLBACK_T callback;
   void *userdata;
} VCHIQ_SERVICE_BASE_T;

typedef struct vchiq_service_params_struct {
   int fourcc;
   VCHIQ_CALLBACK_T callback;
   void *userdata;
   short version;       /* Increment for non-trivial changes */
   short version_min;   /* Update for incompatible changes */
} VCHIQ_SERVICE_PARAMS_T;

typedef struct vchiq_config_struct {
   int max_msg_size;
   int bulk_threshold; /* The message size aboce which it is better to use
                          a bulk transfer (<= max_msg_size) */
   int max_outstanding_bulks;
   int max_services;
   short version;      /* The version of VCHIQ */
   short version_min;  /* The minimum compatible version of VCHIQ */
} VCHIQ_CONFIG_T;

typedef struct vchiq_instance_struct *VCHIQ_INSTANCE_T;
typedef void (*VCHIQ_REMOTE_USE_CALLBACK_T)(void* cb_arg);
struct pagelist_struct;

extern VCHIQ_STATUS_T vchiq_initialise(VCHIQ_INSTANCE_T *pinstance);
extern VCHIQ_STATUS_T vchiq_initialise_fd(VCHIQ_INSTANCE_T *pinstance, int dev_vchiq_fd);
extern VCHIQ_STATUS_T vchiq_shutdown(VCHIQ_INSTANCE_T instance);
extern VCHIQ_STATUS_T vchiq_connect(VCHIQ_INSTANCE_T instance);
extern VCHIQ_STATUS_T vchiq_add_service(VCHIQ_INSTANCE_T instance,
   const VCHIQ_SERVICE_PARAMS_T *params,
   VCHIQ_SERVICE_HANDLE_T *pservice);
extern VCHIQ_STATUS_T vchiq_open_service(VCHIQ_INSTANCE_T instance,
   const VCHIQ_SERVICE_PARAMS_T *params,
   VCHIQ_SERVICE_HANDLE_T *pservice);
extern VCHIQ_STATUS_T vchiq_close_service(VCHIQ_SERVICE_HANDLE_T service);
extern VCHIQ_STATUS_T vchiq_remove_service(VCHIQ_SERVICE_HANDLE_T service);
extern VCHIQ_STATUS_T vchiq_use_service(VCHIQ_SERVICE_HANDLE_T service);
extern VCHIQ_STATUS_T vchiq_release_service(VCHIQ_SERVICE_HANDLE_T service);

extern VCHIQ_STATUS_T vchiq_queue_message(VCHIQ_SERVICE_HANDLE_T service,
   const VCHIQ_ELEMENT_T *elements, int count);
extern void           vchiq_release_message(VCHIQ_SERVICE_HANDLE_T service,
   VCHIQ_HEADER_T *header);
extern VCHIQ_STATUS_T vchiq_queue_bulk_transmit(VCHIQ_SERVICE_HANDLE_T service,
   const void *data, int size, void *userdata);
extern VCHIQ_STATUS_T vchiq_queue_bulk_receive(VCHIQ_SERVICE_HANDLE_T service,
   void *data, int size, void *userdata);
extern VCHIQ_STATUS_T vchiq_queue_bulk_transmit_handle(
   VCHIQ_SERVICE_HANDLE_T service, VCHI_MEM_HANDLE_T handle,
   const void *offset, int size, void *userdata);
extern VCHIQ_STATUS_T vchiq_queue_bulk_receive_handle(
   VCHIQ_SERVICE_HANDLE_T service, VCHI_MEM_HANDLE_T handle,
   void *offset, int size, void *userdata);
extern VCHIQ_STATUS_T vchiq_bulk_transmit(VCHIQ_SERVICE_HANDLE_T service,
   const void *data, int size, void *userdata, VCHIQ_BULK_MODE_T mode);
extern VCHIQ_STATUS_T vchiq_bulk_receive(VCHIQ_SERVICE_HANDLE_T service,
   void *data, int size, void *userdata, VCHIQ_BULK_MODE_T mode);
extern VCHIQ_STATUS_T vchiq_bulk_transmit_handle(VCHIQ_SERVICE_HANDLE_T service,
   VCHI_MEM_HANDLE_T handle, const void *offset, int size, void *userdata,
   VCHIQ_BULK_MODE_T mode);
extern VCHIQ_STATUS_T vchiq_bulk_receive_handle(VCHIQ_SERVICE_HANDLE_T service,
   VCHI_MEM_HANDLE_T handle, void *offset, int size, void *userdata,
   VCHIQ_BULK_MODE_T mode,
   int copy_pagelist(char *vcptr, const struct pagelist_struct *pagelist));
extern int   vchiq_get_client_id(VCHIQ_SERVICE_HANDLE_T service);
extern void *vchiq_get_service_userdata(VCHIQ_SERVICE_HANDLE_T service);
extern int   vchiq_get_service_fourcc(VCHIQ_SERVICE_HANDLE_T service);
extern VCHIQ_STATUS_T vchiq_get_config(VCHIQ_INSTANCE_T instance,
   int config_size, VCHIQ_CONFIG_T *pconfig);
extern VCHIQ_STATUS_T vchiq_set_service_option(VCHIQ_SERVICE_HANDLE_T service,
   VCHIQ_SERVICE_OPTION_T option, int value);

extern VCHIQ_STATUS_T vchiq_remote_use(VCHIQ_INSTANCE_T instance,
   VCHIQ_REMOTE_USE_CALLBACK_T callback, void *cb_arg);
extern VCHIQ_STATUS_T vchiq_remote_release(VCHIQ_INSTANCE_T instance);

extern VCHIQ_STATUS_T vchiq_dump_phys_mem(VCHIQ_SERVICE_HANDLE_T service,
   void *ptr, size_t num_bytes);

extern VCHIQ_STATUS_T vchiq_get_peer_version(VCHIQ_SERVICE_HANDLE_T handle,
      short *peer_version);

#ifdef __cplusplus
}
#endif

#endif /* VCHIQ_IF_H */
                                                                                                                                                                                                                                                                                                       /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef VCHIQ_IOCTLS_H
#define VCHIQ_IOCTLS_H

#include <linux/ioctl.h>
#include "vchiq_if.h"

#define VCHIQ_IOC_MAGIC 0xc4
#define VCHIQ_INVALID_HANDLE (~0)

typedef struct {
   VCHIQ_SERVICE_PARAMS_T params;
   int is_open;
   int is_vchi;
   unsigned int handle;       /* OUT */
} VCHIQ_CREATE_SERVICE_T;

typedef struct {
   unsigned int handle;
   unsigned int count;
   const VCHIQ_ELEMENT_T *elements;
} VCHIQ_QUEUE_MESSAGE_T;

typedef struct {
   unsigned int handle;
   void *data;
   unsigned int size;
   void *userdata;
   VCHIQ_BULK_MODE_T mode;
} VCHIQ_QUEUE_BULK_TRANSFER_T;

typedef struct {
   VCHIQ_REASON_T reason;
   VCHIQ_HEADER_T *header;
   void *service_userdata;
   void *bulk_userdata;
} VCHIQ_COMPLETION_DATA_T;

typedef struct {
   unsigned int count;
   VCHIQ_COMPLETION_DATA_T *buf;
   unsigned int msgbufsize;
   unsigned int msgbufcount; /* IN/OUT */
   void **msgbufs;
} VCHIQ_AWAIT_COMPLETION_T;

typedef struct {
   unsigned int handle;
   int blocking;
   unsigned int bufsize;
   void *buf;
} VCHIQ_DEQUEUE_MESSAGE_T;

typedef struct {
   unsigned int config_size;
   VCHIQ_CONFIG_T *pconfig;
} VCHIQ_GET_CONFIG_T;

typedef struct {
   unsigned int handle;
   VCHIQ_SERVICE_OPTION_T option;
   int value;
} VCHIQ_SET_SERVICE_OPTION_T;

typedef struct {
   void     *virt_addr;
   size_t    num_bytes;
} VCHIQ_DUMP_MEM_T;

#define VCHIQ_IOC_CONNECT              _IO(VCHIQ_IOC_MAGIC,   0)
#define VCHIQ_IOC_SHUTDOWN             _IO(VCHIQ_IOC_MAGIC,   1)
#define VCHIQ_IOC_CREATE_SERVICE       _IOWR(VCHIQ_IOC_MAGIC, 2, VCHIQ_CREATE_SERVICE_T)
#define VCHIQ_IOC_REMOVE_SERVICE       _IO(VCHIQ_IOC_MAGIC,   3)
#define VCHIQ_IOC_QUEUE_MESSAGE        _IOW(VCHIQ_IOC_MAGIC,  4, VCHIQ_QUEUE_MESSAGE_T)
#define VCHIQ_IOC_QUEUE_BULK_TRANSMIT  _IOWR(VCHIQ_IOC_MAGIC, 5, VCHIQ_QUEUE_BULK_TRANSFER_T)
#define VCHIQ_IOC_QUEUE_BULK_RECEIVE   _IOWR(VCHIQ_IOC_MAGIC, 6, VCHIQ_QUEUE_BULK_TRANSFER_T)
#define VCHIQ_IOC_AWAIT_COMPLETION     _IOWR(VCHIQ_IOC_MAGIC, 7, VCHIQ_AWAIT_COMPLETION_T)
#define VCHIQ_IOC_DEQUEUE_MESSAGE      _IOWR(VCHIQ_IOC_MAGIC, 8, VCHIQ_DEQUEUE_MESSAGE_T)
#define VCHIQ_IOC_GET_CLIENT_ID        _IO(VCHIQ_IOC_MAGIC,   9)
#define VCHIQ_IOC_GET_CONFIG           _IOWR(VCHIQ_IOC_MAGIC, 10, VCHIQ_GET_CONFIG_T)
#define VCHIQ_IOC_CLOSE_SERVICE        _IO(VCHIQ_IOC_MAGIC,   11)
#define VCHIQ_IOC_USE_SERVICE          _IO(VCHIQ_IOC_MAGIC,   12)
#define VCHIQ_IOC_RELEASE_SERVICE      _IO(VCHIQ_IOC_MAGIC,   13)
#define VCHIQ_IOC_SET_SERVICE_OPTION   _IOW(VCHIQ_IOC_MAGIC,  14, VCHIQ_SET_SERVICE_OPTION_T)
#define VCHIQ_IOC_DUMP_PHYS_MEM        _IOW(VCHIQ_IOC_MAGIC,  15, VCHIQ_DUMP_MEM_T)
#define VCHIQ_IOC_LIB_VERSION          _IO(VCHIQ_IOC_MAGIC,   16)
#define VCHIQ_IOC_CLOSE_DELIVERED      _IO(VCHIQ_IOC_MAGIC,   17)
#define VCHIQ_IOC_MAX                  17

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef VCHIQ_TEST_H
#define VCHIQ_TEST_H

#include "vchiq_test_if.h"

#define VCOS_LOG_CATEGORY (&vchiq_test_log_category)

#define VERBOSE_TRACE 1

#define FUNC_FOURCC VCHIQ_MAKE_FOURCC('f','u','n','c')
#define FUN2_FOURCC VCHIQ_MAKE_FOURCC('f','u','n','2')

#define SERVICE1_DATA_SIZE 1024
#define SERVICE2_DATA_SIZE 2048
#define FUN2_MAX_DATA_SIZE 16384
#define FUN2_MAX_ALIGN     4096
#define BULK_ALIGN_SIZE    4096

#define VCHIQ_TEST_VER     3

enum {
   MSG_ERROR,
   MSG_ONEWAY,
   MSG_ASYNC,
   MSG_SYNC,
   MSG_CONFIG,
   MSG_ECHO
};

struct test_params
{
   int magic; /* = MSG_CONFIG */
   int blocksize;
   int iters;
   int verify;
   int echo;
   int align_size;
   int client_align;
   int server_align;
   int client_message_quota;
   int server_message_quota;
};

#if VERBOSE_TRACE

#define EXPECT(_e, _v) if (_e != _v) { vcos_log_error("%d: " #_e " != " #_v, __LINE__); VCOS_BKPT; goto error_exit; } else { vcos_log_trace("%d: " #_e " == " #_v, __LINE__); }

#define START_CALLBACK(_r, _u) \
   if (++callback_index == callback_count) { \
      if (reason != _r) { \
         vcos_log_error("%d: expected callback reason " #_r ", got %d", __LINE__, reason); VCOS_BKPT; goto error_exit; \
      } \
      else if ((int)VCHIQ_GET_SERVICE_USERDATA(service) != _u) { \
         vcos_log_error("%d: expected userdata %d, got %d", __LINE__, _u, (int)VCHIQ_GET_SERVICE_USERDATA(service)); VCOS_BKPT; goto error_exit; \
      } \
      else \
      { \
         vcos_log_trace("%d: " #_r ", " #_u, __LINE__); \
      }

#define START_BULK_CALLBACK(_r, _u, _bu)   \
   if (++bulk_index == bulk_count) {  \
      if (reason != _r) { \
         vcos_log_error("%d: expected callback reason " #_r ", got %d", __LINE__, reason); VCOS_BKPT; goto error_exit; \
      } \
      else if ((int)VCHIQ_GET_SERVICE_USERDATA(service) != _u) { \
         vcos_log_error("%d: expected userdata %d, got %d", __LINE__, _u, (int)VCHIQ_GET_SERVICE_USERDATA(service)); VCOS_BKPT; goto error_exit; \
      } \
      else if ((int)bulk_userdata != _bu) { \
         vcos_log_error("%d: expected bulk_userdata %d, got %d", __LINE__, _bu, (int)bulk_userdata); VCOS_BKPT; goto error_exit; \
      } \
      else \
      { \
         vcos_log_trace("%d: " #_r ", " #_u ", " #_bu, __LINE__); \
      }

#else

#define EXPECT(_e, _v) if (_e != _v) { vcos_log_trace("%d: " #_e " != " #_v, __LINE__); VCOS_BKPT; goto error_exit; }

#define START_CALLBACK(_r, _u) \
   if (++callback_index == callback_count) { \
      if (reason != _r) { \
         vcos_log_error("%d: expected callback reason " #_r ", got %d", __LINE__, reason); VCOS_BKPT; goto error_exit; \
      } \
      else if ((int)VCHIQ_GET_SERVICE_USERDATA(service) != _u) { \
         vcos_log_error("%d: expected userdata %d, got %d", __LINE__, _u, (int)VCHIQ_GET_SERVICE_USERDATA(service)); VCOS_BKPT; goto error_exit; \
      }

#define START_BULK_CALLBACK(_r, _u, _bu)   \
   if (++bulk_index == bulk_count) {  \
      if (reason != _r) { \
         vcos_log_error("%d: expected callback reason " #_r ", got %d", __LINE__, reason); VCOS_BKPT; goto error_exit; \
      } \
      else if ((int)VCHIQ_GET_SERVICE_USERDATA(service) != _u) { \
         vcos_log_error("%d: expected userdata %d, got %d", __LINE__, _u, (int)VCHIQ_GET_SERVICE_USERDATA(service)); VCOS_BKPT; goto error_exit; \
      } \
      else if ((int)bulk_userdata != _bu) { \
         vcos_log_error("%d: expected bulkuserdata %d, got %d", __LINE__, _bu, (int)bulk_userdata); VCOS_BKPT; goto error_exit; \
      }

#endif

#define END_CALLBACK(_s) \
      return _s; \
   }

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef VCHIQ_TEST_IF_H
#define VCHIQ_TEST_IF_H

#include "vchiq.h"

extern void vchiq_test_start_services(VCHIQ_INSTANCE_T instance);

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef VCHIQ_UTIL_H
#define VCHIQ_UTIL_H

#include "vchiq_if.h"
#include "interface/vcos/vcos.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef struct {
   int size;
   int read;
   int write;

   VCOS_EVENT_T pop;
   VCOS_EVENT_T push;

   VCHIQ_HEADER_T **storage;
} VCHIU_QUEUE_T;

extern int  vchiu_queue_init(VCHIU_QUEUE_T *queue, int size);
extern void vchiu_queue_delete(VCHIU_QUEUE_T *queue);

extern int vchiu_queue_is_empty(VCHIU_QUEUE_T *queue);
extern int vchiu_queue_is_full(VCHIU_QUEUE_T *queue);

extern void vchiu_queue_push(VCHIU_QUEUE_T *queue, VCHIQ_HEADER_T *header);

extern VCHIQ_HEADER_T *vchiu_queue_peek(VCHIU_QUEUE_T *queue);
extern VCHIQ_HEADER_T *vchiu_queue_pop(VCHIU_QUEUE_T *queue);

#ifdef __cplusplus
}
#endif

#endif

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
#ifndef USER_NODEFS_H
#define USER_NODEFS_H

/*
 * This tells coverity not to expand the assert macro, so it still sees the
 * asserts in the code, even in release builds (we currently run coverity on
 * our release builds). Unfortunately MetaWare won't compile it, even though
 * __COVERITY__ isn't defined, so we put this in its own header.
 *
 * FIXME: This belongs in the Coverity config (in a file called
 * config/user_nodefs.h)
 */
#nodef assert

/*
 * So we need to declare the function now that it isn't a macro any more. It's
 * already built into coverity that assert is a "killpath".
 */
extern void assert(int cond);

#endif /* USER_NODEFS_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - public header file
=============================================================================*/

#ifndef VCOS_ATOMIC_FLAGS_H
#define VCOS_ATOMIC_FLAGS_H

#ifdef __cplusplus
extern "C" {
#endif

#include "interface/vcos/vcos_types.h"
#include "vcos.h"

/**
 * \file vcos_atomic_flags.h
 *
 * Defines atomic flags API.
 *
 * 32 flags. Atomic "or" and "get and clear" operations
 */

/**
 * Create an atomic flags instance.
 *
 * @param atomic_flags Pointer to atomic flags instance, filled in on return
 *
 * @return VCOS_SUCCESS if succeeded.
 */
VCOS_INLINE_DECL
VCOS_STATUS_T vcos_atomic_flags_create(VCOS_ATOMIC_FLAGS_T *atomic_flags);

/**
 * Atomically set the specified flags.
 *
 * @param atomic_flags Instance to set flags on
 * @param flags        Mask of flags to set
 */
VCOS_INLINE_DECL
void vcos_atomic_flags_or(VCOS_ATOMIC_FLAGS_T *atomic_flags, uint32_t flags);

/**
 * Retrieve the current flags and then clear them. The entire operation is
 * atomic.
 *
 * @param atomic_flags Instance to get/clear flags from/on
 *
 * @return Mask of flags which were set (and we cleared)
 */
VCOS_INLINE_DECL
uint32_t vcos_atomic_flags_get_and_clear(VCOS_ATOMIC_FLAGS_T *atomic_flags);

/**
 * Delete an atomic flags instance.
 *
 * @param atomic_flags Instance to delete
 */
VCOS_INLINE_DECL
void vcos_atomic_flags_delete(VCOS_ATOMIC_FLAGS_T *atomic_flags);

#ifdef __cplusplus
}
#endif

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - public header file
=============================================================================*/

/**
  * \mainpage OS Abstraction Layer
  *
  * \section intro Introduction
  *
  * This abstraction layer is here to allow the underlying OS to be easily changed (e.g. from
  * Nucleus to ThreadX) and to aid in porting host applications to new targets.
  *
  * \subsection error Error handling
  *
  * Wherever possible, VCOS functions assert internally and return void. The only exceptions
  * are creation functions (which might fail due to lack of resources) and functions that
  * might timeout or fail due to lack of space. Errors that might be reported by the underlying
  * OS API (e.g. invalid mutex) are treated as a programming error, and are merely asserted on.
  *
  * \section thread_synch Threads and synchronisation
  *
  * \subsection thread Threads
  *
  * The thread API is somewhat different to that found in Nucleus. In particular, threads
  * cannot just be destroyed at arbitrary times and nor can they merely exit. This is so
  * that the same API can be implemented across all interesting platforms without too much
  * difficulty. See vcos_thread.h for details. Thread attributes are configured via
  * the VCOS_THREAD_ATTR_T structure, found in vcos_thread_attr.h.
  *
  * \subsection sema Semaphores
  *
  * Counted semaphores (c.f. Nucleus NU_SEMAPHORE) are created with VCOS_SEMAPHORE_T.
  * Under ThreadX on VideoCore, semaphores are implemented using VideoCore spinlocks, and
  * so are quite a lot faster than ordinary ThreadX semaphores. See vcos_semaphore.h.
  *
  * \subsection mtx Mutexes
  *
  * Mutexes are used for locking. Attempts to take a mutex twice, or to unlock it
  * in a different thread to the one in which it was locked should be expected to fail.
  * Mutexes are not re-entrant (see vcos_reentrant_mutex.h for a slightly slower
  * re-entrant mutex).
  *
  * \subsection evflags Event flags
  *
  * Event flags (the ThreadX name - also known as event groups under Nucleus) provide
  * 32 flags which can be waited on by multiple clients, and signalled by multiple clients.
  * A timeout can be specified. See vcos_event_flags.h. An alternative to this is the
  * VCOS_EVENT_T (see vcos_event.h) which is akin to the Win32 auto-reset event, or a
  * saturating counted semaphore.
  *
  * \subsection event Events
  *
  * A VCOS_EVENT_T is a bit like a saturating semaphore. No matter how many times it
  * is signalled, the waiter will only wake up once. See vcos_event.h. You might think this
  * is useful if you suspect that the cost of reading the semaphore count (perhaps via a
  * system call) is expensive on your platform.
  *
  * \subsection tls Thread local storage
  *
  * Thread local storage is supported using vcos_tls.h. This is emulated on Nucleus
  * and ThreadX.
  *
  * \section int Interrupts
  *
  * The legacy LISR/HISR scheme found in Nucleus is supported via the legacy ISR API,
  * which is also supported on ThreadX. New code should avoid this, and old code should
  * be migrated away from it, since it is slow. See vcos_legacy_isr.h.
  *
  * Registering an interrupt handler, and disabling/restoring interrupts, is handled
  * using the functions in vcos_isr.h.
  *
  */

/**
  * \file vcos.h
  *
  * This is the top level header file. Clients include this. It pulls in the platform-specific
  * header file (vcos_platform.h) together with header files defining the expected APIs, such
  * as vcos_mutex.h, vcos_semaphore.h, etc. It is also possible to include these header files
  * directly.
  *
  */

#ifndef VCOS_H
#define VCOS_H

#include "interface/vcos/vcos_assert.h"
#include "vcos_types.h"

#if defined(__unix__) && !defined(__ANDROID__)
#include "interface/vcos/pthreads/vcos_platform.h"
#else
#include "vcos_platform.h"
#endif

#ifndef VCOS_INIT_H
#include "interface/vcos/vcos_init.h"
#endif

#ifndef VCOS_SEMAPHORE_H
#include "interface/vcos/vcos_semaphore.h"
#endif

#ifndef VCOS_THREAD_H
#include "interface/vcos/vcos_thread.h"
#endif

#ifndef VCOS_MUTEX_H
#include "interface/vcos/vcos_mutex.h"
#endif

#ifndef VCOS_MEM_H
#include "interface/vcos/vcos_mem.h"
#endif

#ifndef VCOS_LOGGING_H
#include "interface/vcos/vcos_logging.h"
#endif

#ifndef VCOS_STRING_H
#include "interface/vcos/vcos_string.h"
#endif

#ifndef VCOS_EVENT_H
#include "interface/vcos/vcos_event.h"
#endif

#ifndef VCOS_THREAD_ATTR_H
#include "interface/vcos/vcos_thread_attr.h"
#endif

#ifndef VCOS_TLS_H
#include "interface/vcos/vcos_tls.h"
#endif

#ifndef VCOS_REENTRANT_MUTEX_H
#include "interface/vcos/vcos_reentrant_mutex.h"
#endif

#ifndef VCOS_NAMED_SEMAPHORE_H
#include "interface/vcos/vcos_named_semaphore.h"
#endif

#ifndef VCOS_QUICKSLOW_MUTEX_H
#include "interface/vcos/vcos_quickslow_mutex.h"
#endif

/* Headers with predicates */

#if VCOS_HAVE_EVENT_FLAGS
#include "interface/vcos/vcos_event_flags.h"
#endif

#if VCOS_HAVE_QUEUE
#include "interface/vcos/vcos_queue.h"
#endif

#if VCOS_HAVE_LEGACY_ISR
#include "interface/vcos/vcos_legacy_isr.h"
#endif

#if VCOS_HAVE_TIMER
#include "interface/vcos/vcos_timer.h"
#endif

#if VCOS_HAVE_MEMPOOL
#include "interface/vcos/vcos_mempool.h"
#endif

#if VCOS_HAVE_ISR
#include "interface/vcos/vcos_isr.h"
#endif

#if VCOS_HAVE_ATOMIC_FLAGS
#include "interface/vcos/vcos_atomic_flags.h"
#endif

#if VCOS_HAVE_ONCE
#include "interface/vcos/vcos_once.h"
#endif

#if VCOS_HAVE_BLOCK_POOL
#include "interface/vcos/vcos_blockpool.h"
#endif

#if VCOS_HAVE_FILE
#include "interface/vcos/vcos_file.h"
#endif

#if VCOS_HAVE_CFG
#include "interface/vcos/vcos_cfg.h"
#endif

#if VCOS_HAVE_CMD
#include "interface/vcos/vcos_cmd.h"
#endif

#endif /* VCOS_H */

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - Assertion and error-handling macros.
=============================================================================*/


#ifndef VCOS_ASSERT_H
#define VCOS_ASSERT_H

/*
 * Macro:
 *    vcos_assert(cond)
 *    vcos_assert_msg(cond, fmt, ...)
 * Use:
 *    Detecting programming errors by ensuring that assumptions are correct.
 * On failure:
 *    Performs a platform-dependent "breakpoint", usually with an assert-style
 *    message. The '_msg' variant expects a printf-style format string and
 *    parameters.
 *    If a failure is detected, the code should be fixed and rebuilt.
 * In release builds:
 *    Generates no code, i.e. does not evaluate 'cond'.
 * Returns:
 *    Nothing.
 *
 * Macro:
 *    vcos_demand(cond)
 *    vcos_demand_msg(cond, fmt, ...)
 * Use:
 *    Detecting fatal system errors that require a reboot.
 * On failure:
 *    Performs a platform-dependent "breakpoint", usually with an assert-style
 *    message, then calls vcos_abort (see below).
 * In release builds:
 *    Calls vcos_abort() if 'cond' is false.
 * Returns:
 *    Nothing (never, on failure).
 *
 * Macro:
 *    vcos_verify(cond)
 *    vcos_verify_msg(cond, fmt, ...)
 * Use:
 *    Detecting run-time errors and interesting conditions, normally within an
 *    'if' statement to catch the failures, i.e.
 *       if (!vcos_verify(cond)) handle_error();
 * On failure:
 *    Generates a message and optionally stops at a platform-dependent
 *    "breakpoint" (usually disabled). See vcos_verify_bkpts_enable below.
 * In release builds:
 *    Just evaluates and returns 'cond'.
 * Returns:
 *    Non-zero if 'cond' is true, otherwise zero.
 *
 * Macro:
 *    vcos_static_assert(cond)
 * Use:
 *    Detecting compile-time errors.
 * On failure:
 *    Generates a compiler error.
 * In release builds:
 *    Generates a compiler error.
 *
 * Function:
 *    void vcos_abort(void)
 * Use:
 *    Invokes the fatal error handling mechanism, alerting the host where
 *    applicable.
 * Returns:
 *    Never.
 *
 * Macro:
 *    VCOS_VERIFY_BKPTS
 * Use:
 *    Define in a module (before including vcos.h) to specify an alternative
 *    flag to control breakpoints on vcos_verify() failures.
 * Returns:
 *    Non-zero values enable breakpoints.
 *
 * Function:
 *    int vcos_verify_bkpts_enable(int enable);
 * Use:
 *    Sets the global flag controlling breakpoints on vcos_verify failures,
 *    enabling the breakpoints iff 'enable' is non-zero.
 * Returns:
 *    The previous state of the flag.
 *
 * Function:
 *    int vcos_verify_bkpts_enabled(void);
 * Use:
 *    Queries the state of the global flag enabling breakpoints on vcos_verify
 *    failures.
 * Returns:
 *    The current state of the flag.
 *
 * Examples:
 *
 * int my_breakpoint_enable_flag = 1;
 *
 * #define VCOS_VERIFY_BKPTS my_breakpoint_enable_flag
 *
 * #include "interface/vcos/vcos.h"
 *
 * vcos_static_assert((sizeof(object) % 32) == 0);
 *
 * // ...
 *
 *    vcos_assert_msg(postcondition_is_true, "Coding error");
 *
 *    if (!vcos_verify_msg(buf, "Buffer allocation failed (%d bytes)", size))
 *    {
 *       // Tidy up
 *       // ...
 *       return OUT_OF_MEMORY;
 *    }
 *
 *    vcos_demand(*p++==GUARDWORDHEAP);
 */

#ifdef __cplusplus
extern "C" {
#endif

#include "interface/vcos/vcos_types.h"

#ifdef __COVERITY__
#include "interface/vcos/user_nodefs.h"

extern void __coverity_panic__(void);
#undef VCOS_ASSERT_BKPT
#define VCOS_ASSERT_BKPT __coverity_panic__()
#endif

/*
 * ANDROID should NOT be defined for files built for Videocore, but currently it
 * is. FIXME When that's fixed, remove the __VIDEOCORE__ band-aid.
 */
#if (defined(ANDROID) && !defined(__VIDEOCORE__))
#  include "assert.h"
#  define vcos_assert assert
#endif

#ifndef VCOS_VERIFY_BKPTS
#define VCOS_VERIFY_BKPTS vcos_verify_bkpts_enabled()
#endif

#ifndef VCOS_BKPT
#if defined(__VIDEOCORE__) && !defined(VCOS_ASSERT_NO_BKPTS)
#define VCOS_BKPT _bkpt()
#else
#define VCOS_BKPT (void )0
#endif
#endif

#ifndef VCOS_ASSERT_BKPT
#define VCOS_ASSERT_BKPT VCOS_BKPT
#endif

#ifndef VCOS_VERIFY_BKPT
#define VCOS_VERIFY_BKPT (VCOS_VERIFY_BKPTS ? VCOS_BKPT : (void)0)
#endif

VCOSPRE_ int VCOSPOST_ vcos_verify_bkpts_enabled(void);
VCOSPRE_ int VCOSPOST_ vcos_verify_bkpts_enable(int enable);
VCOSPRE_ void VCOSPOST_ vcos_abort(void);

#ifndef VCOS_ASSERT_MSG
#ifdef LOGGING
extern void logging_assert(const char *file, const char *func, int line, const char *format, ...);
extern void logging_assert_dump(void);
#define VCOS_ASSERT_MSG(...) ((VCOS_ASSERT_LOGGING && !VCOS_ASSERT_LOGGING_DISABLE) ? logging_assert_dump(), logging_assert(__FILE__, __func__, __LINE__, __VA_ARGS__) : (void)0)
#else
#define VCOS_ASSERT_MSG(...) ((void)0)
#endif
#endif

#ifndef VCOS_VERIFY_MSG
#define VCOS_VERIFY_MSG(...) VCOS_ASSERT_MSG(__VA_ARGS__)
#endif

#ifndef VCOS_ASSERT_LOGGING
#define VCOS_ASSERT_LOGGING 0
#endif

#ifndef VCOS_ASSERT_LOGGING_DISABLE
#define VCOS_ASSERT_LOGGING_DISABLE 0
#endif

#if !defined(NDEBUG) || defined(VCOS_RELEASE_ASSERTS)
#define VCOS_ASSERT_ENABLED 1
#define VCOS_VERIFY_ENABLED 1
#else
#define VCOS_ASSERT_ENABLED 0
#define VCOS_VERIFY_ENABLED 0
#endif

#define VCOS_DEMAND_ENABLED 1

#if VCOS_ASSERT_ENABLED

#ifndef vcos_assert
#define vcos_assert(cond) \
   ( (cond) ? (void)0 : (VCOS_ASSERT_BKPT, VCOS_ASSERT_MSG("%s", #cond)) )
#endif

#ifndef vcos_assert_msg
#define vcos_assert_msg(cond, ...) \
   ( (cond) ? (void)0 : (VCOS_ASSERT_BKPT, VCOS_ASSERT_MSG(__VA_ARGS__)) )
#endif

#else  /* VCOS_ASSERT_ENABLED */

#ifndef vcos_assert
#define vcos_assert(cond) (void)0
#endif

#ifndef vcos_assert_msg
#define vcos_assert_msg(cond, ...) (void)0
#endif

#endif /* VCOS_ASSERT_ENABLED */


#if VCOS_DEMAND_ENABLED

#ifndef vcos_demand
#define vcos_demand(cond) \
   ( (cond) ? (void)0 : (VCOS_ASSERT_BKPT, VCOS_ASSERT_MSG("%s", #cond), vcos_abort()) )
#endif

#ifndef vcos_demand_msg
#define vcos_demand_msg(cond, ...) \
   ( (cond) ? (void)0 : (VCOS_ASSERT_BKPT, VCOS_ASSERT_MSG(__VA_ARGS__), vcos_abort()) )
#endif

#else  /* VCOS_DEMAND_ENABLED */

#ifndef vcos_demand
#define vcos_demand(cond) \
   ( (cond) ? (void)0 : vcos_abort() )
#endif

#ifndef vcos_demand_msg
#define vcos_demand_msg(cond, ...) \
   ( (cond) ? (void)0 : vcos_abort() )
#endif

#endif /* VCOS_DEMAND_ENABLED */


#if VCOS_VERIFY_ENABLED

#ifndef vcos_verify
#define vcos_verify(cond) \
   ( (cond) ? 1 : (VCOS_VERIFY_MSG("%s", #cond), VCOS_VERIFY_BKPT, 0) )
#endif

#ifndef vcos_verify_msg
#define vcos_verify_msg(cond, ...) \
   ( (cond) ? 1 : (VCOS_VERIFY_MSG(__VA_ARGS__), VCOS_VERIFY_BKPT, 0) )
#endif

#else /* VCOS_VERIFY_ENABLED */

#ifndef vcos_verify
#define vcos_verify(cond) (cond)
#endif

#ifndef vcos_verify_msg
#define vcos_verify_msg(cond, ...) (cond)
#endif

#endif /* VCOS_VERIFY_ENABLED */


#ifndef vcos_static_assert
#if defined(__GNUC__)
#define vcos_static_assert(cond) __attribute__((unused)) extern int vcos_static_assert[(cond)?1:-1]
#else
#define vcos_static_assert(cond) extern int vcos_static_assert[(cond)?1:-1]
#endif
#endif

#ifndef vc_assert
#define vc_assert(cond) vcos_assert(cond)
#endif

#define vcos_unreachable() vcos_assert(0)
#define vcos_not_impl() vcos_assert(0)

/** Print out a backtrace, on supported platforms.
  */
extern void vcos_backtrace_self(void);

#ifdef __cplusplus
}
#endif

#endif /* VCOS_ASSERT_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

const char *vcos_get_build_hostname( void );
const char *vcos_get_build_version( void );
const char *vcos_get_build_time( void );
const char *vcos_get_build_date( void );
const char *vcos_get_build_variant( void );

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - compiler-specific attributes
=============================================================================*/

#ifndef VCOS_ATTR_H
#define VCOS_ATTR_H

/**
 * Type attribute indicating the enum should be stored in as few bytes as
 * possible. MetaWare does this by default, so the attribute is useful when
 * structs need to be portable to GCC too.
 *
 * MSVC doesn't support VCOS_ENUM_PACKED, so code that needs to be portable
 * across all platforms but wants the type-safety and debug-info benefits
 * of enum types when possible, should do:
 *
 *    typedef enum VCOS_ENUM_PACKED { a = 0, b = 0xffff } EXAMPLE_T;
 *    struct foo {
 *       int bar;
 *       #if VCOS_HAS_ENUM_PACKED
 *       EXAMPLE_T baz;
 *       #else
 *       uint16_t baz;
 *       #endif
 *    };
 */

#if defined(__VECTORC__)
# define VCOS_ENUM_PACKED
# define VCOS_HAS_ENUM_PACKED 0
#elif defined(__GNUC__)
# define VCOS_ENUM_PACKED  __attribute__ ((packed))
# define VCOS_HAS_ENUM_PACKED 1
#elif defined(__HIGHC__)
# define VCOS_ENUM_PACKED /* packed enums are default on Metaware */
# define VCOS_HAS_ENUM_PACKED 1
#else
# define VCOS_ENUM_PACKED
# define VCOS_HAS_ENUM_PACKED 0
#endif

/** Variable attribute indicating the variable must be emitted even if it appears unused. */
#if defined(__GNUC__) || defined(__HIGHC__)
# define VCOS_ATTR_USED  __attribute__ ((used))
#else
# define VCOS_ATTR_USED
#endif

/** Variable attribute indicating the compiler should not warn if the variable is unused. */
#if defined(__GNUC__) || defined(__HIGHC__)
# define VCOS_ATTR_POSSIBLY_UNUSED  __attribute__ ((unused))
#else
# define VCOS_ATTR_POSSIBLY_UNUSED
#endif

/** Variable attribute requiring specific alignment.
 *
 * Use as:
 *   int VCOS_ATTR_ALIGNED(256) n;
 * or:
 *   VCOS_ATTR_ALIGNED(256) int n;
 * or if you don't want to support MSVC:
 *   int n VCOS_ATTR_ALIGNED(256);
 */
#if defined(__GNUC__) || defined(__HIGHC__)
# define VCOS_ATTR_ALIGNED(n)  __attribute__ ((aligned(n)))
#elif defined(_MSC_VER)
# define VCOS_ATTR_ALIGNED(n)  __declspec(align(n))
#else
/* Force a syntax error if this is used when the compiler doesn't support it,
 * instead of silently misaligning */
# define VCOS_ATTR_ALIGNED(n) VCOS_ATTR_ALIGNED_NOT_SUPPORTED_ON_THIS_COMPILER
#endif

/** Variable attribute requiring specific ELF section.
 *
 * Use as:
 *   int n VCOS_ATTR_SECTION(".foo") = 1;
 *
 * A pointer like &n will have type "VCOS_ATTR_SECTION_QUALIFIER int *".
 */
#if defined(__HIGHC__) || defined(__VECTORC__)
/* hcvc requires 'far' else it'll put small objects in .sdata/.rsdata/.sbss */
# define VCOS_ATTR_SECTION(s)  __attribute__ ((far, section(s)))
# define VCOS_ATTR_SECTION_QUALIFIER _Far
#elif defined(__GNUC__)
# define VCOS_ATTR_SECTION(s)  __attribute__ ((section(s)))
# define VCOS_ATTR_SECTION_QUALIFIER
#else
/* Force a syntax error if this is used when the compiler doesn't support it */
# define VCOS_ATTR_SECTION(s) VCOS_ATTR_SECTION_NOT_SUPPORTED_ON_THIS_COMPILER
# define VCOS_ATTR_SECTION_QUALIFIER
#endif

/** Define a function as a weak alias to another function.
 * @param ret_type     Function return type.
 * @param alias_name   Name of the alias.
 * @param param_list   Function parameter list, including the parentheses.
 * @param target_name  Target function (bare function name, not a string).
 */
#if defined(__GNUC__) || defined(__HIGHC__)
  /* N.B. gcc allows __attribute__ after parameter list, but hcvc seems to silently ignore it. */
# define VCOS_WEAK_ALIAS(ret_type, alias_name, param_list, target_name) \
   __attribute__ ((weak, alias(#target_name))) ret_type alias_name param_list
#else
# define VCOS_WEAK_ALIAS(ret_type, alias, params, target)  VCOS_CASSERT(0)
#endif

/** Define a function as a weak alias to another function, specified as a string.
 * @param ret_type     Function return type.
 * @param alias_name   Name of the alias.
 * @param param_list   Function parameter list, including the parentheses.
 * @param target_name  Target function name as a string.
 * @note Prefer the use of VCOS_WEAK_ALIAS - it is likely to be more portable.
 *       Only use VCOS_WEAK_ALIAS_STR if you need to do pre-processor mangling of the target
 *       symbol.
 */
#if defined(__GNUC__) || defined(__HIGHC__)
  /* N.B. gcc allows __attribute__ after parameter list, but hcvc seems to silently ignore it. */
# define VCOS_WEAK_ALIAS_STR(ret_type, alias_name, param_list, target_name) \
   __attribute__ ((weak, alias(target_name))) ret_type alias_name param_list
#else
# define VCOS_WEAK_ALIAS_STR(ret_type, alias, params, target)  VCOS_CASSERT(0)
#endif

#endif /* VCOS_ATTR_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - fixed size allocator support
=============================================================================*/

#ifndef VCOS_BLOCKPOOL_H
#define VCOS_BLOCKPOOL_H

#ifdef __cplusplus
extern "C" {
#endif

#include "interface/vcos/vcos_types.h"
#include "vcos.h"

/** \file
  *
  * Thread safe, fixed size allocator API.
  *
  */

/** Initialises a block pool to use already allocated (e.g. statically)
 * allocated memory.
 *
 * Different implementations will incur different overheads. Use
 * VCOS_BLOCKPOOL_SIZE(num_blocks, block_size) to calculate the number
 * of bytes required including overheads for the desired pools.
 *
 * @param pool        Pointer to pool object
 * @param num_blocks  The number of blocks required.
 * @param block_size  The size of an individual block.
 * @param start       The address of the start of the pool.
 * @param pool_size   The size of the pool in bytes.
 * @param align       Alignment for block data. Use VCOS_BLOCKPOOL_ALIGN_DEFAULT
 *                    for default word alignment.
 * @param flags       Reserved for future use.
 * @param name        Name of the pool. Used for diagnostics.
 *
 * @return VCOS_SUCCESS if the pool was created.
 */

VCOS_INLINE_DECL
VCOS_STATUS_T vcos_blockpool_init(VCOS_BLOCKPOOL_T *pool,
      VCOS_UNSIGNED num_blocks, VCOS_UNSIGNED block_size,
      void *start, VCOS_UNSIGNED pool_size, VCOS_UNSIGNED align,
      VCOS_UNSIGNED flags, const char *name);

/** Creates a pool of blocks of a given size within a buffer allocated on
 * the heap.
 *
 * The heap memory is freed when the block pool is destroyed by
 * calling vcos_blockpool_delete.
 *
 * @param pool        Pointer to pool object
 * @param num_blocks  The number of blocks required.
 * @param block_size  The size of an individual block.
 * @param align       Alignment for block data. Use VCOS_BLOCKPOOL_ALIGN_DEFAULT
 *                    for default word alignment.
 * @param flags       Reserved for future use.
 * @param name        Name of the pool. Used for diagnostics.
 *
 * @return VCOS_SUCCESS if the pool was created.
 */
VCOS_INLINE_DECL
VCOS_STATUS_T vcos_blockpool_create_on_heap(VCOS_BLOCKPOOL_T *pool,
      VCOS_UNSIGNED num_blocks, VCOS_UNSIGNED block_size,
      VCOS_UNSIGNED align, VCOS_UNSIGNED flags,
      const char *name);

/** Allocate a block from the pool
 *
 * @param pool Pointer to the pool to allocate from.
 * @return a pointer to the newly allocated block or NULL if no blocks were
 * available.
 */
VCOS_INLINE_DECL
void *vcos_blockpool_alloc(VCOS_BLOCKPOOL_T *pool);

/** Allocate a block from the pool and zero it.
 *
 * @param pool Pointer to the pool to allocate from.
 * @return a pointer to the newly allocated block or NULL if no blocks were
 * available.
 */
VCOS_INLINE_DECL
void *vcos_blockpool_calloc(VCOS_BLOCKPOOL_T *pool);

/** Returns a block to the pool.
 *
 * @param block The block to free.
 */
VCOS_INLINE_DECL
void vcos_blockpool_free(void *block);

/** Queries the number of available blocks in the pool.
 * @param pool The pool to query.
 */
VCOS_INLINE_IMPL
   VCOS_UNSIGNED vcos_blockpool_available_count(VCOS_BLOCKPOOL_T *pool);

/** Queries the number of used blocks in the pool.
 * @param pool The pool to query.
 */
VCOS_INLINE_IMPL
   VCOS_UNSIGNED vcos_blockpool_used_count(VCOS_BLOCKPOOL_T *pool);

/** Deinitialize a memory pool.
 *
 * @param pool The pool to de-initialize.
 */
VCOS_INLINE_DECL
void vcos_blockpool_delete(VCOS_BLOCKPOOL_T *pool);

/** Return an integer handle for a given allocated block. */
VCOS_INLINE_DECL
uint32_t vcos_blockpool_elem_to_handle(void *block);

/** Convert an integer handle back into a pointer.
  * Returns NULL if invalid. */
VCOS_INLINE_DECL
void *vcos_blockpool_elem_from_handle(VCOS_BLOCKPOOL_T *pool, uint32_t handle);

/** Checks whether a pointer is an allocated block within the specified pool.
  * Returns true if the block is valid, otherwise, false is returned. */
VCOS_INLINE_DECL
uint32_t vcos_blockpool_is_valid_elem(
      VCOS_BLOCKPOOL_T *pool, const void *block);

/** May be called once to allow the block pool to be extended by dynamically
 * adding subpools. The block size cannot be altered.
 *
 * @param num_extensions The number of extensions that may be created.
 *                       The maximum is (VCOS_BLOCKPOOL_MAX_SUBPOOLS - 1)
 * @param num_blocks     The number of blocks to allocate in each in each
 *                       dynamically allocated subpool.
 * @return VCOS_SUCCESS if successful.
 */
VCOS_INLINE_DECL
   VCOS_STATUS_T vcos_blockpool_extend(VCOS_BLOCKPOOL_T *pool,
         VCOS_UNSIGNED num_extensions, VCOS_UNSIGNED num_blocks);

#ifdef __cplusplus
}
#endif
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#if !defined( VCOS_CFG_H )
#define VCOS_CFG_H

#ifdef __cplusplus
extern "C" {
#endif

#include "interface/vcos/vcos_types.h"
#include "vcos.h"

typedef struct opaque_vcos_cfg_buf_t    *VCOS_CFG_BUF_T;
typedef struct opaque_vcos_cfg_entry_t  *VCOS_CFG_ENTRY_T;

/** \file vcos_file.h
  *
  * API for accessing configuration/statistics information. This
  * is loosely modelled on the linux proc entries.
  */

typedef void (*VCOS_CFG_SHOW_FPTR)( VCOS_CFG_BUF_T buf, void *data );
typedef void (*VCOS_CFG_PARSE_FPTR)( VCOS_CFG_BUF_T buf, void *data );

/** Create a configuration directory.
  *
  * @param entry        Place to store the created config entry.
  * @param parent       Parent entry (for directory like config 
  *                     options).
  * @param entryName    Name of the directory.
  */

VCOS_STATUS_T vcos_cfg_mkdir( VCOS_CFG_ENTRY_T *entry,
                              VCOS_CFG_ENTRY_T *parent,
                              const char *dirName );           

/** Create a configuration entry.
  *
  * @param entry        Place to store the created config entry.
  * @param parent       Parent entry (for directory like config 
  *                     options).
  * @param entryName    Name of the configuration entry.
  * @param showFunc     Function pointer to show configuration 
  *                     data.
  * @param parseFunc    Function pointer to parse new data. 
  */

VCOS_STATUS_T vcos_cfg_create_entry( VCOS_CFG_ENTRY_T *entry,
                                     VCOS_CFG_ENTRY_T *parent,
                                     const char *entryName,
                                     VCOS_CFG_SHOW_FPTR showFunc,
                                     VCOS_CFG_PARSE_FPTR parseFunc,
                                     void *data );

/** Determines if a configuration entry has been created or not.
  *
  * @param entry        Configuration entry to query.
  */

int vcos_cfg_is_entry_created( VCOS_CFG_ENTRY_T entry );

/** Returns the name of a configuration entry.
  *
  * @param entry        Configuration entry to query.
  */

const char *vcos_cfg_get_entry_name( VCOS_CFG_ENTRY_T entry );

/** Removes a configuration entry.
  *
  * @param entry        Configuration entry to remove.
  */

VCOS_STATUS_T vcos_cfg_remove_entry( VCOS_CFG_ENTRY_T *entry );


/** Writes data into a configuration buffer. Only valid inside
  * the show function. 
  *
  * @param buf      Buffer to write data into.
  * @param fmt      printf style format string. 
  */

void vcos_cfg_buf_printf( VCOS_CFG_BUF_T buf, const char *fmt, ... );

/** Retrieves a null terminated string of the data associated
  * with the buffer. Only valid inside the parse function.
  *
  * @param buf      Buffer to get data from.
  * @param fmt      printf style format string. 
  */

char *vcos_cfg_buf_get_str( VCOS_CFG_BUF_T buf );

void *vcos_cfg_get_proc_entry( VCOS_CFG_ENTRY_T entry );

#ifdef __cplusplus
}
#endif
#endif

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#if !defined( VCOS_CMD_H )
#define VCOS_CMD_H

/* ---- Include Files ----------------------------------------------------- */

#ifndef VCOS_H
#include "interface/vcos/vcos.h"
#endif
#include "interface/vcos/vcos_stdint.h"


/* ---- Constants and Types ---------------------------------------------- */

struct VCOS_CMD_S;
typedef struct VCOS_CMD_S VCOS_CMD_T;

typedef struct
{
    int         argc;           /* Number of arguments (includes the command/sub-command) */
    char      **argv;           /* Array of arguments */
    char      **argv_orig;      /* Original array of arguments */

    VCOS_CMD_T *cmd_entry;
    VCOS_CMD_T *cmd_parent_entry;

    int         use_log;        /* Output being logged? */
    size_t      result_size;    /* Size of result buffer. */
    char       *result_ptr;     /* Next place to put output. */
    char       *result_buf;     /* Start of the buffer. */

} VCOS_CMD_PARAM_T;

typedef VCOS_STATUS_T (*VCOS_CMD_FUNC_T)( VCOS_CMD_PARAM_T *param );

struct VCOS_CMD_S
{
    const char         *name;
    const char         *args;
    VCOS_CMD_FUNC_T     cmd_fn;
    VCOS_CMD_T         *sub_cmd_entry;
    const char         *descr;

};

/* ---- Variable Externs ------------------------------------------------- */

/* ---- Function Prototypes ---------------------------------------------- */

/*
 * Common printing routine for generating command output.
 */
VCOSPRE_ void VCOSPOST_ vcos_cmd_error( VCOS_CMD_PARAM_T *param, const char *fmt, ... ) VCOS_FORMAT_ATTR_(printf, 2, 3);
VCOSPRE_ void VCOSPOST_ vcos_cmd_printf( VCOS_CMD_PARAM_T *param, const char *fmt, ... ) VCOS_FORMAT_ATTR_(printf, 2, 3);
VCOSPRE_ void VCOSPOST_ vcos_cmd_vprintf( VCOS_CMD_PARAM_T *param, const char *fmt, va_list args ) VCOS_FORMAT_ATTR_(printf, 2, 0);

/*
 * Cause vcos_cmd_error, printf and vprintf to always log to the provided
 * category. When this call is made, the results buffer passed into
 * vcos_cmd_execute is used as a line buffer and does not need to be
 * output by the caller.
 */
struct VCOS_LOG_CAT_T;
VCOSPRE_ void VCOSPOST_ vcos_cmd_always_log_output( struct VCOS_LOG_CAT_T *log_category );

/*
 * Prints command usage for the current command.
 */
VCOSPRE_ void VCOSPOST_ vcos_cmd_usage( VCOS_CMD_PARAM_T *param );

/*
 * Register commands to be processed
 */
VCOSPRE_ VCOS_STATUS_T VCOSPOST_ vcos_cmd_register( VCOS_CMD_T *cmd_entry );

/*
 * Registers multiple commands to be processed. The array should
 * be terminated by an entry with all zeros.
 */
VCOSPRE_ VCOS_STATUS_T VCOSPOST_ vcos_cmd_register_multiple( VCOS_CMD_T *cmd_entry );

/*
 * Executes a command based on a command line.
 */
VCOSPRE_ VCOS_STATUS_T VCOSPOST_ vcos_cmd_execute( int argc, char **argv, size_t result_size, char *result_buf );

/*
 * Shut down the command system and free all allocated data.
 * Do not call any other command functions after this.
 */
VCOSPRE_ void VCOSPOST_ vcos_cmd_shutdown( void );

#endif /* VCOS_CMD_H */

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        