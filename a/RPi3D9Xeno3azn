"""An NNTP client class based on RFC 977: Network News Transfer Protocol.

Example:

>>> from nntplib import NNTP
>>> s = NNTP('news')
>>> resp, count, first, last, name = s.group('comp.lang.python')
>>> print 'Group', name, 'has', count, 'articles, range', first, 'to', last
Group comp.lang.python has 51 articles, range 5770 to 5821
>>> resp, subs = s.xhdr('subject', first + '-' + last)
>>> resp = s.quit()
>>>

Here 'resp' is the server response line.
Error responses are turned into exceptions.

To post an article from a file:
>>> f = open(filename, 'r') # file containing article, including header
>>> resp = s.post(f)
>>>

For descriptions of all methods, read the comments in the code below.
Note that all arguments and return values representing article numbers
are strings, not numbers, since they are rarely used for calculations.
"""

# RFC 977 by Brian Kantor and Phil Lapsley.
# xover, xgtitle, xpath, date methods by Kevan Heydon


# Imports
import re
import socket

__all__ = ["NNTP","NNTPReplyError","NNTPTemporaryError",
           "NNTPPermanentError","NNTPProtocolError","NNTPDataError",
           "error_reply","error_temp","error_perm","error_proto",
           "error_data",]

# maximal line length when calling readline(). This is to prevent
# reading arbitrary length lines. RFC 3977 limits NNTP line length to
# 512 characters, including CRLF. We have selected 2048 just to be on
# the safe side.
_MAXLINE = 2048


# Exceptions raised when an error or invalid response is received
class NNTPError(Exception):
    """Base class for all nntplib exceptions"""
    def __init__(self, *args):
        Exception.__init__(self, *args)
        try:
            self.response = args[0]
        except IndexError:
            self.response = 'No response given'

class NNTPReplyError(NNTPError):
    """Unexpected [123]xx reply"""
    pass

class NNTPTemporaryError(NNTPError):
    """4xx errors"""
    pass

class NNTPPermanentError(NNTPError):
    """5xx errors"""
    pass

class NNTPProtocolError(NNTPError):
    """Response does not begin with [1-5]"""
    pass

class NNTPDataError(NNTPError):
    """Error in response data"""
    pass

# for backwards compatibility
error_reply = NNTPReplyError
error_temp = NNTPTemporaryError
error_perm = NNTPPermanentError
error_proto = NNTPProtocolError
error_data = NNTPDataError



# Standard port used by NNTP servers
NNTP_PORT = 119


# Response numbers that are followed by additional text (e.g. article)
LONGRESP = ['100', '215', '220', '221', '222', '224', '230', '231', '282']


# Line terminators (we always output CRLF, but accept any of CRLF, CR, LF)
CRLF = '\r\n'



# The class itself
class NNTP:
    def __init__(self, host, port=NNTP_PORT, user=None, password=None,
                 readermode=None, usenetrc=True):
        """Initialize an instance.  Arguments:
        - host: hostname to connect to
        - port: port to connect to (default the standard NNTP port)
        - user: username to authenticate with
        - password: password to use with username
        - readermode: if true, send 'mode reader' command after
                      connecting.

        readermode is sometimes necessary if you are connecting to an
        NNTP server on the local machine and intend to call
        reader-specific commands, such as `group'.  If you get
        unexpected NNTPPermanentErrors, you might need to set
        readermode.
        """
        self.host = host
        self.port = port
        self.sock = socket.create_connection((host, port))
        self.file = self.sock.makefile('rb')
        self.debugging = 0
        self.welcome = self.getresp()

        # 'mode reader' is sometimes necessary to enable 'reader' mode.
        # However, the order in which 'mode reader' and 'authinfo' need to
        # arrive differs between some NNTP servers. Try to send
        # 'mode reader', and if it fails with an authorization failed
        # error, try again after sending authinfo.
        readermode_afterauth = 0
        if readermode:
            try:
                self.welcome = self.shortcmd('mode reader')
            except NNTPPermanentError:
                # error 500, probably 'not implemented'
                pass
            except NNTPTemporaryError, e:
                if user and e.response[:3] == '480':
                    # Need authorization before 'mode reader'
                    readermode_afterauth = 1
                else:
                    raise
        # If no login/password was specified, try to get them from ~/.netrc
        # Presume that if .netc has an entry, NNRP authentication is required.
        try:
            if usenetrc and not user:
                import netrc
                credentials = netrc.netrc()
                auth = credentials.authenticators(host)
                if auth:
                    user = auth[0]
                    password = auth[2]
        except IOError:
            pass
        # Perform NNRP authentication if needed.
        if user:
            resp = self.shortcmd('authinfo user '+user)
            if resp[:3] == '381':
                if not password:
                    raise NNTPReplyError(resp)
                else:
                    resp = self.shortcmd(
                            'authinfo pass '+password)
                    if resp[:3] != '281':
                        raise NNTPPermanentError(resp)
            if readermode_afterauth:
                try:
                    self.welcome = self.shortcmd('mode reader')
                except NNTPPermanentError:
                    # error 500, probably 'not implemented'
                    pass


    # Get the welcome message from the server
    # (this is read and squirreled away by __init__()).
    # If the response code is 200, posting is allowed;
    # if it 201, posting is not allowed

    def getwelcome(self):
        """Get the welcome message from the server
        (this is read and squirreled away by __init__()).
        If the response code is 200, posting is allowed;
        if it 201, posting is not allowed."""

        if self.debugging: print '*welcome*', repr(self.welcome)
        return self.welcome

    def set_debuglevel(self, level):
        """Set the debugging level.  Argument 'level' means:
        0: no debugging output (default)
        1: print commands and responses but not body text etc.
        2: also print raw lines read and sent before stripping CR/LF"""

        self.debugging = level
    debug = set_debuglevel

    def putline(self, line):
        """Internal: send one line to the server, appending CRLF."""
        line = line + CRLF
        if self.debugging > 1: print '*put*', repr(line)
        self.sock.sendall(line)

    def putcmd(self, line):
        """Internal: send one command to the server (through putline())."""
        if self.debugging: print '*cmd*', repr(line)
        self.putline(line)

    def getline(self):
        """Internal: return one line from the server, stripping CRLF.
        Raise EOFError if the connection is closed."""
        line = self.file.readline(_MAXLINE + 1)
        if len(line) > _MAXLINE:
            raise NNTPDataError('line too long')
        if self.debugging > 1:
            print '*get*', repr(line)
        if not line: raise EOFError
        if line[-2:] == CRLF: line = line[:-2]
        elif line[-1:] in CRLF: line = line[:-1]
        return line

    def getresp(self):
        """Internal: get a response from the server.
        Raise various errors if the response indicates an error."""
        resp = self.getline()
        if self.debugging: print '*resp*', repr(resp)
        c = resp[:1]
        if c == '4':
            raise NNTPTemporaryError(resp)
        if c == '5':
            raise NNTPPermanentError(resp)
        if c not in '123':
            raise NNTPProtocolError(resp)
        return resp

    def getlongresp(self, file=None):
        """Internal: get a response plus following text from the server.
        Raise various errors if the response indicates an error."""

        openedFile = None
        try:
            # If a string was passed then open a file with that name
            if isinstance(file, str):
                openedFile = file = open(file, "w")

            resp = self.getresp()
            if resp[:3] not in LONGRESP:
                raise NNTPReplyError(resp)
            list = []
            while 1:
                line = self.getline()
                if line == '.':
                    break
                if line[:2] == '..':
                    line = line[1:]
                if file:
                    file.write(line + "\n")
                else:
                    list.append(line)
        finally:
            # If this method created the file, then it must close it
            if openedFile:
                openedFile.close()

        return resp, list

    def shortcmd(self, line):
        """Internal: send a command and get the response."""
        self.putcmd(line)
        return self.getresp()

    def longcmd(self, line, file=None):
        """Internal: send a command and get the response plus following text."""
        self.putcmd(line)
        return self.getlongresp(file)

    def newgroups(self, date, time, file=None):
        """Process a NEWGROUPS command.  Arguments:
        - date: string 'yymmdd' indicating the date
        - time: string 'hhmmss' indicating the time
        Return:
        - resp: server response if successful
        - list: list of newsgroup names"""

        return self.longcmd('NEWGROUPS ' + date + ' ' + time, file)

    def newnews(self, group, date, time, file=None):
        """Process a NEWNEWS command.  Arguments:
        - group: group name or '*'
        - date: string 'yymmdd' indicating the date
        - time: string 'hhmmss' indicating the time
        Return:
        - resp: server response if successful
        - list: list of message ids"""

        cmd = 'NEWNEWS ' + group + ' ' + date + ' ' + time
        return self.longcmd(cmd, file)

    def list(self, file=None):
        """Process a LIST command.  Return:
        - resp: server response if successful
        - list: list of (group, last, first, flag) (strings)"""

        resp, list = self.longcmd('LIST', file)
        for i in range(len(list)):
            # Parse lines into "group last first flag"
            list[i] = tuple(list[i].split())
        return resp, list

    def description(self, group):

        """Get a description for a single group.  If more than one
        group matches ('group' is a pattern), return the first.  If no
        group matches, return an empty string.

        This elides the response code from the server, since it can
        only be '215' or '285' (for xgtitle) anyway.  If the response
        code is needed, use the 'descriptions' method.

        NOTE: This neither checks for a wildcard in 'group' nor does
        it check whether the group actually exists."""

        resp, lines = self.descriptions(group)
        if len(lines) == 0:
            return ""
        else:
            return lines[0][1]

    def descriptions(self, group_pattern):
        """Get descriptions for a range of groups."""
        line_pat = re.compile("^(?P<group>[^ \t]+)[ \t]+(.*)$")
        # Try the more std (acc. to RFC2980) LIST NEWSGROUPS first
        resp, raw_lines = self.longcmd('LIST NEWSGROUPS ' + group_pattern)
        if resp[:3] != "215":
            # Now the deprecated XGTITLE.  This either raises an error
            # or succeeds with the same output structure as LIST
            # NEWSGROUPS.
            resp, raw_lines = self.longcmd('XGTITLE ' + group_pattern)
        lines = []
        for raw_line in raw_lines:
            match = line_pat.search(raw_line.strip())
            if match:
                lines.append(match.group(1, 2))
        return resp, lines

    def group(self, name):
        """Process a GROUP command.  Argument:
        - group: the group name
        Returns:
        - resp: server response if successful
        - count: number of articles (string)
        - first: first article number (string)
        - last: last article number (string)
        - name: the group name"""

        resp = self.shortcmd('GROUP ' + name)
        if resp[:3] != '211':
            raise NNTPReplyError(resp)
        words = resp.split()
        count = first = last = 0
        n = len(words)
        if n > 1:
            count = words[1]
            if n > 2:
                first = words[2]
                if n > 3:
                    last = words[3]
                    if n > 4:
                        name = words[4].lower()
        return resp, count, first, last, name

    def help(self, file=None):
        """Process a HELP command.  Returns:
        - resp: server response if successful
        - list: list of strings"""

        return self.longcmd('HELP',file)

    def statparse(self, resp):
        """Internal: parse the response of a STAT, NEXT or LAST command."""
        if resp[:2] != '22':
            raise NNTPReplyError(resp)
        words = resp.split()
        nr = 0
        id = ''
        n = len(words)
        if n > 1:
            nr = words[1]
            if n > 2:
                id = words[2]
        return resp, nr, id

    def statcmd(self, line):
        """Internal: process a STAT, NEXT or LAST command."""
        resp = self.shortcmd(line)
        return self.statparse(resp)

    def stat(self, id):
        """Process a STAT command.  Argument:
        - id: article number or message id
        Returns:
        - resp: server response if successful
        - nr:   the article number
        - id:   the message id"""

        return self.statcmd('STAT ' + id)

    def next(self):
        """Process a NEXT command.  No arguments.  Return as for STAT."""
        return self.statcmd('NEXT')

    def last(self):
        """Process a LAST command.  No arguments.  Return as for STAT."""
        return self.statcmd('LAST')

    def artcmd(self, line, file=None):
        """Internal: process a HEAD, BODY or ARTICLE command."""
        resp, list = self.longcmd(line, file)
        resp, nr, id = self.statparse(resp)
        return resp, nr, id, list

    def head(self, id):
        """Process a HEAD command.  Argument:
        - id: article number or message id
        Returns:
        - resp: server response if successful
        - nr: article number
        - id: message id
        - list: the lines of the article's header"""

        return self.artcmd('HEAD ' + id)

    def body(self, id, file=None):
        """Process a BODY command.  Argument:
        - id: article number or message id
        - file: Filename string or file object to store the article in
        Returns:
        - resp: server response if successful
        - nr: article number
        - id: message id
        - list: the lines of the article's body or an empty list
                if file was used"""

        return self.artcmd('BODY ' + id, file)

    def article(self, id):
        """Process an ARTICLE command.  Argument:
        - id: article number or message id
        Returns:
        - resp: server response if successful
        - nr: article number
        - id: message id
        - list: the lines of the article"""

        return self.artcmd('ARTICLE ' + id)

    def slave(self):
        """Process a SLAVE command.  Returns:
        - resp: server response if successful"""

        return self.shortcmd('SLAVE')

    def xhdr(self, hdr, str, file=None):
        """Process an XHDR command (optional server extension).  Arguments:
        - hdr: the header type (e.g. 'subject')
        - str: an article nr, a message id, or a range nr1-nr2
        Returns:
        - resp: server response if successful
        - list: list of (nr, value) strings"""

        pat = re.compile('^([0-9]+) ?(.*)\n?')
        resp, lines = self.longcmd('XHDR ' + hdr + ' ' + str, file)
        for i in range(len(lines)):
            line = lines[i]
            m = pat.match(line)
            if m:
                lines[i] = m.group(1, 2)
        return resp, lines

    def xover(self, start, end, file=None):
        """Process an XOVER command (optional server extension) Arguments:
        - start: start of range
        - end: end of range
        Returns:
        - resp: server response if successful
        - list: list of (art-nr, subject, poster, date,
                         id, references, size, lines)"""

        resp, lines = self.longcmd('XOVER ' + start + '-' + end, file)
        xover_lines = []
        for line in lines:
            elem = line.split("\t")
            try:
                xover_lines.append((elem[0],
                                    elem[1],
                                    elem[2],
                                    elem[3],
                                    elem[4],
                                    elem[5].split(),
                                    elem[6],
                                    elem[7]))
            except IndexError:
                raise NNTPDataError(line)
        return resp,xover_lines

    def xgtitle(self, group, file=None):
        """Process an XGTITLE command (optional server extension) Arguments:
        - group: group name wildcard (i.e. news.*)
        Returns:
        - resp: server response if successful
        - list: list of (name,title) strings"""

        line_pat = re.compile("^([^ \t]+)[ \t]+(.*)$")
        resp, raw_lines = self.longcmd('XGTITLE ' + group, file)
        lines = []
        for raw_line in raw_lines:
            match = line_pat.search(raw_line.strip())
            if match:
                lines.append(match.group(1, 2))
        return resp, lines

    def xpath(self,id):
        """Process an XPATH command (optional server extension) Arguments:
        - id: Message id of article
        Returns:
        resp: server response if successful
        path: directory path to article"""

        resp = self.shortcmd("XPATH " + id)
        if resp[:3] != '223':
            raise NNTPReplyError(resp)
        try:
            [resp_num, path] = resp.split()
        except ValueError:
            raise NNTPReplyError(resp)
        else:
            return resp, path

    def date (self):
        """Process the DATE command. Arguments:
        None
        Returns:
        resp: server response if successful
        date: Date suitable for newnews/newgroups commands etc.
        time: Time suitable for newnews/newgroups commands etc."""

        resp = self.shortcmd("DATE")
        if resp[:3] != '111':
            raise NNTPReplyError(resp)
        elem = resp.split()
        if len(elem) != 2:
            raise NNTPDataError(resp)
        date = elem[1][2:8]
        time = elem[1][-6:]
        if len(date) != 6 or len(time) != 6:
            raise NNTPDataError(resp)
        return resp, date, time


    def post(self, f):
        """Process a POST command.  Arguments:
        - f: file containing the article
        Returns:
        - resp: server response if successful"""

        resp = self.shortcmd('POST')
        # Raises error_??? if posting is not allowed
        if resp[0] != '3':
            raise NNTPReplyError(resp)
        while 1:
            line = f.readline()
            if not line:
                break
            if line[-1] == '\n':
                line = line[:-1]
            if line[:1] == '.':
                line = '.' + line
            self.putline(line)
        self.putline('.')
        return self.getresp()

    def ihave(self, id, f):
        """Process an IHAVE command.  Arguments:
        - id: message-id of the article
        - f:  file containing the article
        Returns:
        - resp: server response if successful
        Note that if the server refuses the article an exception is raised."""

        resp = self.shortcmd('IHAVE ' + id)
        # Raises error_??? if the server already has it
        if resp[0] != '3':
            raise NNTPReplyError(resp)
        while 1:
            line = f.readline()
            if not line:
                break
            if line[-1] == '\n':
                line = line[:-1]
            if line[:1] == '.':
                line = '.' + line
            self.putline(line)
        self.putline('.')
        return self.getresp()

    def quit(self):
        """Process a QUIT command and close the socket.  Returns:
        - resp: server response if successful"""

        resp = self.shortcmd('QUIT')
        self.file.close()
        self.sock.close()
        del self.file, self.sock
        return resp


# Test retrieval when run as a script.
# Assumption: if there's a local news server, it's called 'news'.
# Assumption: if user queries a remote news server, it's named
# in the environment variable NNTPSERVER (used by slrn and kin)
# and we want readermode off.
if __name__ == '__main__':
    import os
    newshost = 'news' and os.environ["NNTPSERVER"]
    if newshost.find('.') == -1:
        mode = 'readermode'
    else:
        mode = None
    s = NNTP(newshost, readermode=mode)
    resp, count, first, last, name = s.group('comp.lang.python')
    print resp
    print 'Group', name, 'has', count, 'articles, range', first, 'to', last
    resp, subs = s.xhdr('subject', first + '-' + last)
    print resp
    for item in subs:
        print "%7s %s" % item
    resp = s.quit()
    print resp
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ó
Ó«[c           @   s)  d  Z  d d l Z d d l Z d d d d d d d	 d
 d d d g Z d Z d e f d „  ƒ  YZ d e f d „  ƒ  YZ d e f d „  ƒ  YZ d e f d „  ƒ  YZ	 d e f d „  ƒ  YZ
 d e f d „  ƒ  YZ e Z e Z e	 Z e
 Z e Z d Z d d d d d d d d d g	 Z d  Z d f  d! „  ƒ  YZ e d" k r%d d l Z d# oUe j d$ Z e j d% ƒ d k rvd& Z n e Z e e d& e ƒZ e j d' ƒ \ Z Z Z  Z! Z" e GHd( Ge" Gd) Ge Gd* Ge  Gd+ Ge! GHe j# d, e  d- e! ƒ \ Z Z$ e GHx e$ D] Z% d. e% GHqþWe j& ƒ  Z e GHn  d S(/   sH  An NNTP client class based on RFC 977: Network News Transfer Protocol.

Example:

>>> from nntplib import NNTP
>>> s = NNTP('news')
>>> resp, count, first, last, name = s.group('comp.lang.python')
>>> print 'Group', name, 'has', count, 'articles, range', first, 'to', last
Group comp.lang.python has 51 articles, range 5770 to 5821
>>> resp, subs = s.xhdr('subject', first + '-' + last)
>>> resp = s.quit()
>>>

Here 'resp' is the server response line.
Error responses are turned into exceptions.

To post an article from a file:
>>> f = open(filename, 'r') # file containing article, including header
>>> resp = s.post(f)
>>>

For descriptions of all methods, read the comments in the code below.
Note that all arguments and return values representing article numbers
are strings, not numbers, since they are rarely used for calculations.
iÿÿÿÿNt   NNTPt   NNTPReplyErrort   NNTPTemporaryErrort   NNTPPermanentErrort   NNTPProtocolErrort   NNTPDataErrort   error_replyt
   error_tempt
   error_permt   error_protot
   error_datai   t	   NNTPErrorc           B   s   e  Z d  Z d „  Z RS(   s%   Base class for all nntplib exceptionsc         G   sB   t  j |  | Œ y | d |  _ Wn t k
 r= d |  _ n Xd  S(   Ni    s   No response given(   t	   Exceptiont   __init__t   responset
   IndexError(   t   selft   args(    (    s   /usr/lib/python2.7/nntplib.pyR   2   s
    (   t   __name__t
   __module__t   __doc__R   (    (    (    s   /usr/lib/python2.7/nntplib.pyR   0   s   c           B   s   e  Z d  Z RS(   s   Unexpected [123]xx reply(   R   R   R   (    (    (    s   /usr/lib/python2.7/nntplib.pyR   9   s   c           B   s   e  Z d  Z RS(   s
   4xx errors(   R   R   R   (    (    (    s   /usr/lib/python2.7/nntplib.pyR   =   s   c           B   s   e  Z d  Z RS(   s
   5xx errors(   R   R   R   (    (    (    s   /usr/lib/python2.7/nntplib.pyR   A   s   c           B   s   e  Z d  Z RS(   s"   Response does not begin with [1-5](   R   R   R   (    (    (    s   /usr/lib/python2.7/nntplib.pyR   E   s   c           B   s   e  Z d  Z RS(   s   Error in response data(   R   R   R   (    (    (    s   /usr/lib/python2.7/nntplib.pyR   I   s   iw   t   100t   215t   220t   221t   222t   224t   230t   231t   282s   
c           B   sy  e  Z e d# d# d# e d  „ Z d „  Z d „  Z e Z d „  Z	 d „  Z
 d „  Z d „  Z d# d „ Z d „  Z d# d	 „ Z d# d
 „ Z d# d „ Z d# d „ Z d „  Z d „  Z d „  Z d# d „ Z d „  Z d „  Z d „  Z d „  Z d „  Z d# d „ Z d „  Z d# d „ Z d „  Z d „  Z  d# d „ Z! d# d „ Z" d# d „ Z# d „  Z$ d „  Z% d  „  Z& d! „  Z' d" „  Z( RS($   c         C   sà  | |  _  | |  _ t j | | f ƒ |  _ |  j j d ƒ |  _ d |  _ |  j ƒ  |  _	 d } | rÇ y |  j
 d ƒ |  _	 WqÇ t k
 rŒ qÇ t k
 rÃ } | r½ | j d  d k r½ d } qÄ ‚  qÇ Xn  yX | r| rd d l }	 |	 j ƒ  }
 |
 j | ƒ } | r| d } | d	 } qn  Wn t k
 r2n X| rÜ|  j
 d
 | ƒ } | d  d k r¦| sqt | ƒ ‚ q¦|  j
 d | ƒ } | d  d k r¦t | ƒ ‚ q¦n  | rÜy |  j
 d ƒ |  _	 WqÙt k
 rÕqÙXqÜn  d S(   sm  Initialize an instance.  Arguments:
        - host: hostname to connect to
        - port: port to connect to (default the standard NNTP port)
        - user: username to authenticate with
        - password: password to use with username
        - readermode: if true, send 'mode reader' command after
                      connecting.

        readermode is sometimes necessary if you are connecting to an
        NNTP server on the local machine and intend to call
        reader-specific commands, such as `group'.  If you get
        unexpected NNTPPermanentErrors, you might need to set
        readermode.
        t   rbi    s   mode readeri   t   480i   iÿÿÿÿNi   s   authinfo user t   381s   authinfo pass t   281(   t   hostt   portt   sockett   create_connectiont   sockt   makefilet   filet	   debuggingt   getrespt   welcomet   shortcmdR   R   R   t   netrct   authenticatorst   IOErrorR   (   R   R"   R#   t   usert   passwordt
   readermodet   usenetrct   readermode_afterautht   eR-   t   credentialst   autht   resp(    (    s   /usr/lib/python2.7/nntplib.pyR   e   sP    				

c         C   s%   |  j  r d Gt |  j ƒ GHn  |  j S(   sÅ   Get the welcome message from the server
        (this is read and squirreled away by __init__()).
        If the response code is 200, posting is allowed;
        if it 201, posting is not allowed.s	   *welcome*(   R)   t   reprR+   (   R   (    (    s   /usr/lib/python2.7/nntplib.pyt
   getwelcome²   s    	 c         C   s   | |  _  d S(   sÞ   Set the debugging level.  Argument 'level' means:
        0: no debugging output (default)
        1: print commands and responses but not body text etc.
        2: also print raw lines read and sent before stripping CR/LFN(   R)   (   R   t   level(    (    s   /usr/lib/python2.7/nntplib.pyt   set_debuglevel»   s    c         C   s?   | t  } |  j d k r+ d Gt | ƒ GHn  |  j j | ƒ d S(   s6   Internal: send one line to the server, appending CRLF.i   s   *put*N(   t   CRLFR)   R9   R&   t   sendall(   R   t   line(    (    s   /usr/lib/python2.7/nntplib.pyt   putlineÄ   s    
 c         C   s,   |  j  r d Gt | ƒ GHn  |  j | ƒ d S(   s=   Internal: send one command to the server (through putline()).s   *cmd*N(   R)   R9   R@   (   R   R?   (    (    s   /usr/lib/python2.7/nntplib.pyt   putcmdÊ   s    	 c         C   s¥   |  j  j t d ƒ } t | ƒ t k r7 t d ƒ ‚ n  |  j d k rX d Gt | ƒ GHn  | sg t ‚ n  | d t k r„ | d  } n | d t k r¡ | d  } n  | S(   sn   Internal: return one line from the server, stripping CRLF.
        Raise EOFError if the connection is closed.i   s   line too longs   *get*iþÿÿÿiÿÿÿÿ(	   R(   t   readlinet   _MAXLINEt   lenR   R)   R9   t   EOFErrorR=   (   R   R?   (    (    s   /usr/lib/python2.7/nntplib.pyt   getlineÏ   s     	  c         C   s†   |  j  ƒ  } |  j r' d Gt | ƒ GHn  | d  } | d k rL t | ƒ ‚ n  | d k rg t | ƒ ‚ n  | d k r‚ t | ƒ ‚ n  | S(   sj   Internal: get a response from the server.
        Raise various errors if the response indicates an error.s   *resp*i   t   4t   5t   123(   RF   R)   R9   R   R   R   (   R   R8   t   c(    (    s   /usr/lib/python2.7/nntplib.pyR*   Ü   s    	 
c         C   sè   d } zÁ t | t ƒ r. t | d ƒ } } n  |  j ƒ  } | d  t k rY t | ƒ ‚ n  g  } xd |  j ƒ  } | d k r~ Pn  | d  d k r› | d } n  | rµ | j | d ƒ qb | j	 | ƒ qb WWd | rÝ | j
 ƒ  n  X| | f S(	   s~   Internal: get a response plus following text from the server.
        Raise various errors if the response indicates an error.t   wi   t   .i   s   ..i   s   
N(   t   Nonet
   isinstancet   strt   openR*   t   LONGRESPR   RF   t   writet   appendt   close(   R   R(   t
   openedFileR8   t   listR?   (    (    s   /usr/lib/python2.7/nntplib.pyt   getlongrespê   s(    c         C   s   |  j  | ƒ |  j ƒ  S(   s.   Internal: send a command and get the response.(   RA   R*   (   R   R?   (    (    s   /usr/lib/python2.7/nntplib.pyR,   	  s    c         C   s   |  j  | ƒ |  j | ƒ S(   sB   Internal: send a command and get the response plus following text.(   RA   RW   (   R   R?   R(   (    (    s   /usr/lib/python2.7/nntplib.pyt   longcmd  s    c         C   s   |  j  d | d | | ƒ S(   sö   Process a NEWGROUPS command.  Arguments:
        - date: string 'yymmdd' indicating the date
        - time: string 'hhmmss' indicating the time
        Return:
        - resp: server response if successful
        - list: list of newsgroup namess
   NEWGROUPS t    (   RX   (   R   t   datet   timeR(   (    (    s   /usr/lib/python2.7/nntplib.pyt	   newgroups  s    c         C   s*   d | d | d | } |  j  | | ƒ S(   s  Process a NEWNEWS command.  Arguments:
        - group: group name or '*'
        - date: string 'yymmdd' indicating the date
        - time: string 'hhmmss' indicating the time
        Return:
        - resp: server response if successful
        - list: list of message idss   NEWNEWS RY   (   RX   (   R   t   groupRZ   R[   R(   t   cmd(    (    s   /usr/lib/python2.7/nntplib.pyt   newnews  s    	c         C   sY   |  j  d | ƒ \ } } x4 t t | ƒ ƒ D]  } t | | j ƒ  ƒ | | <q+ W| | f S(   s‹   Process a LIST command.  Return:
        - resp: server response if successful
        - list: list of (group, last, first, flag) (strings)t   LIST(   RX   t   rangeRD   t   tuplet   split(   R   R(   R8   RV   t   i(    (    s   /usr/lib/python2.7/nntplib.pyRV   )  s    c         C   s;   |  j  | ƒ \ } } t | ƒ d k r+ d S| d d Sd S(   sé  Get a description for a single group.  If more than one
        group matches ('group' is a pattern), return the first.  If no
        group matches, return an empty string.

        This elides the response code from the server, since it can
        only be '215' or '285' (for xgtitle) anyway.  If the response
        code is needed, use the 'descriptions' method.

        NOTE: This neither checks for a wildcard in 'group' nor does
        it check whether the group actually exists.i    t    i   N(   t   descriptionsRD   (   R   R]   R8   t   lines(    (    s   /usr/lib/python2.7/nntplib.pyt   description4  s    c         C   s¬   t  j d ƒ } |  j d | ƒ \ } } | d  d k rT |  j d | ƒ \ } } n  g  } xE | D]= } | j | j ƒ  ƒ } | ra | j | j d d ƒ ƒ qa qa W| | f S(   s'   Get descriptions for a range of groups.s   ^(?P<group>[^ 	]+)[ 	]+(.*)$s   LIST NEWSGROUPS i   R   s   XGTITLE i   i   (   t   ret   compileRX   t   searcht   stripRS   R]   (   R   t   group_patternt   line_patR8   t	   raw_linesRg   t   raw_linet   match(    (    s   /usr/lib/python2.7/nntplib.pyRf   G  s     c         C   sÕ   |  j  d | ƒ } | d  d k r2 t | ƒ ‚ n  | j ƒ  } d } } } t | ƒ } | d k rÂ | d } | d k rÂ | d } | d k r¿ | d } | d k r¼ | d j ƒ  } q¼ q¿ qÂ n  | | | | | f S(   s*  Process a GROUP command.  Argument:
        - group: the group name
        Returns:
        - resp: server response if successful
        - count: number of articles (string)
        - first: first article number (string)
        - last: last article number (string)
        - name: the group names   GROUP i   t   211i    i   i   i   (   R,   R   Rc   RD   t   lower(   R   t   nameR8   t   wordst   countt   firstt   lastt   n(    (    s   /usr/lib/python2.7/nntplib.pyR]   X  s    



c         C   s   |  j  d | ƒ S(   so   Process a HELP command.  Returns:
        - resp: server response if successful
        - list: list of stringst   HELP(   RX   (   R   R(   (    (    s   /usr/lib/python2.7/nntplib.pyt   helpr  s    c         C   s‚   | d  d k r t  | ƒ ‚ n  | j ƒ  } d } d } t | ƒ } | d k ru | d } | d k ru | d } qu n  | | | f S(   s=   Internal: parse the response of a STAT, NEXT or LAST command.i   t   22i    Re   i   (   R   Rc   RD   (   R   R8   Ru   t   nrt   idRy   (    (    s   /usr/lib/python2.7/nntplib.pyt	   statparsey  s    
c         C   s   |  j  | ƒ } |  j | ƒ S(   s/   Internal: process a STAT, NEXT or LAST command.(   R,   R   (   R   R?   R8   (    (    s   /usr/lib/python2.7/nntplib.pyt   statcmd‡  s    c         C   s   |  j  d | ƒ S(   sÎ   Process a STAT command.  Argument:
        - id: article number or message id
        Returns:
        - resp: server response if successful
        - nr:   the article number
        - id:   the message ids   STAT (   R€   (   R   R~   (    (    s   /usr/lib/python2.7/nntplib.pyt   statŒ  s    c         C   s   |  j  d ƒ S(   s;   Process a NEXT command.  No arguments.  Return as for STAT.t   NEXT(   R€   (   R   (    (    s   /usr/lib/python2.7/nntplib.pyt   next–  s    c         C   s   |  j  d ƒ S(   s;   Process a LAST command.  No arguments.  Return as for STAT.t   LAST(   R€   (   R   (    (    s   /usr/lib/python2.7/nntplib.pyRx   š  s    c         C   s@   |  j  | | ƒ \ } } |  j | ƒ \ } } } | | | | f S(   s2   Internal: process a HEAD, BODY or ARTICLE command.(   RX   R   (   R   R?   R(   R8   RV   R}   R~   (    (    s   /usr/lib/python2.7/nntplib.pyt   artcmdž  s    c         C   s   |  j  d | ƒ S(   sô   Process a HEAD command.  Argument:
        - id: article number or message id
        Returns:
        - resp: server response if successful
        - nr: article number
        - id: message id
        - list: the lines of the article's headers   HEAD (   R…   (   R   R~   (    (    s   /usr/lib/python2.7/nntplib.pyt   head¤  s    	c         C   s   |  j  d | | ƒ S(   sk  Process a BODY command.  Argument:
        - id: article number or message id
        - file: Filename string or file object to store the article in
        Returns:
        - resp: server response if successful
        - nr: article number
        - id: message id
        - list: the lines of the article's body or an empty list
                if file was useds   BODY (   R…   (   R   R~   R(   (    (    s   /usr/lib/python2.7/nntplib.pyt   body¯  s    c         C   s   |  j  d | ƒ S(   sï   Process an ARTICLE command.  Argument:
        - id: article number or message id
        Returns:
        - resp: server response if successful
        - nr: article number
        - id: message id
        - list: the lines of the articles   ARTICLE (   R…   (   R   R~   (    (    s   /usr/lib/python2.7/nntplib.pyt   article¼  s    	c         C   s   |  j  d ƒ S(   sP   Process a SLAVE command.  Returns:
        - resp: server response if successfult   SLAVE(   R,   (   R   (    (    s   /usr/lib/python2.7/nntplib.pyt   slaveÇ  s    c   
      C   s’   t  j d ƒ } |  j d | d | | ƒ \ } } xR t t | ƒ ƒ D]> } | | } | j | ƒ }	 |	 rF |	 j d d ƒ | | <qF qF W| | f S(   s  Process an XHDR command (optional server extension).  Arguments:
        - hdr: the header type (e.g. 'subject')
        - str: an article nr, a message id, or a range nr1-nr2
        Returns:
        - resp: server response if successful
        - list: list of (nr, value) stringss   ^([0-9]+) ?(.*)
?s   XHDR RY   i   i   (   Ri   Rj   RX   Ra   RD   Rq   R]   (
   R   t   hdrRO   R(   t   patR8   Rg   Rd   R?   t   m(    (    s   /usr/lib/python2.7/nntplib.pyt   xhdrÍ  s    $
c   	      C   sÃ   |  j  d | d | | ƒ \ } } g  } xŒ | D]„ } | j d ƒ } yO | j | d | d | d | d | d | d	 j ƒ  | d
 | d f ƒ Wq1 t k
 r´ t | ƒ ‚ q1 Xq1 W| | f S(   s(  Process an XOVER command (optional server extension) Arguments:
        - start: start of range
        - end: end of range
        Returns:
        - resp: server response if successful
        - list: list of (art-nr, subject, poster, date,
                         id, references, size, lines)s   XOVER t   -s   	i    i   i   i   i   i   i   i   (   RX   Rc   RS   R   R   (	   R   t   startt   endR(   R8   Rg   t   xover_linesR?   t   elem(    (    s   /usr/lib/python2.7/nntplib.pyt   xoverÞ  s     	$c   	      C   sƒ   t  j d ƒ } |  j d | | ƒ \ } } g  } xE | D]= } | j | j ƒ  ƒ } | r8 | j | j d d ƒ ƒ q8 q8 W| | f S(   sà   Process an XGTITLE command (optional server extension) Arguments:
        - group: group name wildcard (i.e. news.*)
        Returns:
        - resp: server response if successful
        - list: list of (name,title) stringss   ^([^ 	]+)[ 	]+(.*)$s   XGTITLE i   i   (   Ri   Rj   RX   Rk   Rl   RS   R]   (	   R   R]   R(   Rn   R8   Ro   Rg   Rp   Rq   (    (    s   /usr/lib/python2.7/nntplib.pyt   xgtitleø  s     c         C   sv   |  j  d | ƒ } | d  d k r2 t | ƒ ‚ n  y | j ƒ  \ } } Wn t k
 rg t | ƒ ‚ n X| | f Sd S(   sÈ   Process an XPATH command (optional server extension) Arguments:
        - id: Message id of article
        Returns:
        resp: server response if successful
        path: directory path to articles   XPATH i   t   223N(   R,   R   Rc   t
   ValueError(   R   R~   R8   t   resp_numt   path(    (    s   /usr/lib/python2.7/nntplib.pyt   xpath  s    c         C   sº   |  j  d ƒ } | d  d k r. t | ƒ ‚ n  | j ƒ  } t | ƒ d k r[ t | ƒ ‚ n  | d d d !} | d d } t | ƒ d k sž t | ƒ d k r­ t | ƒ ‚ n  | | | f S(	   sî   Process the DATE command. Arguments:
        None
        Returns:
        resp: server response if successful
        date: Date suitable for newnews/newgroups commands etc.
        time: Time suitable for newnews/newgroups commands etc.t   DATEi   t   111i   i   i   iúÿÿÿi   (   R,   R   Rc   RD   R   (   R   R8   R“   RZ   R[   (    (    s   /usr/lib/python2.7/nntplib.pyRZ     s    $c         C   s©   |  j  d ƒ } | d d k r. t | ƒ ‚ n  xa | j ƒ  } | sG Pn  | d d k rd | d  } n  | d  d k r d | } n  |  j | ƒ q1 W|  j d ƒ |  j ƒ  S(   s‹   Process a POST command.  Arguments:
        - f: file containing the article
        Returns:
        - resp: server response if successfult   POSTi    t   3iÿÿÿÿs   
i   RL   (   R,   R   RB   R@   R*   (   R   t   fR8   R?   (    (    s   /usr/lib/python2.7/nntplib.pyt   post.  s    c         C   s­   |  j  d | ƒ } | d d k r2 t | ƒ ‚ n  xa | j ƒ  } | sK Pn  | d d k rh | d  } n  | d  d k r… d | } n  |  j | ƒ q5 W|  j d ƒ |  j ƒ  S(   s  Process an IHAVE command.  Arguments:
        - id: message-id of the article
        - f:  file containing the article
        Returns:
        - resp: server response if successful
        Note that if the server refuses the article an exception is raised.s   IHAVE i    Rž   iÿÿÿÿs   
i   RL   (   R,   R   RB   R@   R*   (   R   R~   RŸ   R8   R?   (    (    s   /usr/lib/python2.7/nntplib.pyt   ihaveD  s    c         C   s9   |  j  d ƒ } |  j j ƒ  |  j j ƒ  |  ` |  ` | S(   sd   Process a QUIT command and close the socket.  Returns:
        - resp: server response if successfult   QUIT(   R,   R(   RT   R&   (   R   R8   (    (    s   /usr/lib/python2.7/nntplib.pyt   quit\  s
    N()   R   R   t	   NNTP_PORTRM   t   TrueR   R:   R<   t   debugR@   RA   RF   R*   RW   R,   RX   R\   R_   RV   Rh   Rf   R]   R{   R   R€   R   Rƒ   Rx   R…   R†   R‡   Rˆ   RŠ   RŽ   R”   R•   Rš   RZ   R    R¡   R£   (    (    (    s   /usr/lib/python2.7/nntplib.pyR    d   sJ   	L								
						
									t   __main__t   newst
   NNTPSERVERRL   R2   s   comp.lang.pythont   Groupt   hass   articles, ranget   tot   subjectR   s   %7s %s('   R   Ri   R$   t   __all__RC   R   R   R   R   R   R   R   R   R   R   R	   R
   R¤   RQ   R=   R    R   t   ost   environt   newshostt   findt   modeRM   t   sR]   R8   Rv   Rw   Rx   Rt   RŽ   t   subst   itemR£   (    (    (    s   /usr/lib/python2.7/nntplib.pyt   <module>   sP   				!ÿ ÿ 
	!                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     # Module 'ntpath' -- common operations on WinNT/Win95 pathnames
"""Common pathname manipulations, WindowsNT/95 version.

Instead of importing this module directly, import os and refer to this
module as os.path.
"""

import os
import sys
import stat
import genericpath
import warnings

from genericpath import *
from genericpath import _unicode

__all__ = ["normcase","isabs","join","splitdrive","split","splitext",
           "basename","dirname","commonprefix","getsize","getmtime",
           "getatime","getctime", "islink","exists","lexists","isdir","isfile",
           "ismount","walk","expanduser","expandvars","normpath","abspath",
           "splitunc","curdir","pardir","sep","pathsep","defpath","altsep",
           "extsep","devnull","realpath","supports_unicode_filenames","relpath"]

# strings representing various path-related bits and pieces
curdir = '.'
pardir = '..'
extsep = '.'
sep = '\\'
pathsep = ';'
altsep = '/'
defpath = '.;C:\\bin'
if 'ce' in sys.builtin_module_names:
    defpath = '\\Windows'
elif 'os2' in sys.builtin_module_names:
    # OS/2 w/ VACPP
    altsep = '/'
devnull = 'nul'

# Normalize the case of a pathname and map slashes to backslashes.
# Other normalizations (such as optimizing '../' away) are not done
# (this is done by normpath).

def normcase(s):
    """Normalize case of pathname.

    Makes all characters lowercase and all slashes into backslashes."""
    return s.replace("/", "\\").lower()


# Return whether a path is absolute.
# Trivial in Posix, harder on the Mac or MS-DOS.
# For DOS it is absolute if it starts with a slash or backslash (current
# volume), or if a pathname after the volume letter and colon / UNC resource
# starts with a slash or backslash.

def isabs(s):
    """Test whether a path is absolute"""
    s = splitdrive(s)[1]
    return s != '' and s[:1] in '/\\'


# Join two (or more) paths.
def join(path, *paths):
    """Join two or more pathname components, inserting "\\" as needed."""
    result_drive, result_path = splitdrive(path)
    for p in paths:
        p_drive, p_path = splitdrive(p)
        if p_path and p_path[0] in '\\/':
            # Second path is absolute
            if p_drive or not result_drive:
                result_drive = p_drive
            result_path = p_path
            continue
        elif p_drive and p_drive != result_drive:
            if p_drive.lower() != result_drive.lower():
                # Different drives => ignore the first path entirely
                result_drive = p_drive
                result_path = p_path
                continue
            # Same drive in different case
            result_drive = p_drive
        # Second path is relative to the first
        if result_path and result_path[-1] not in '\\/':
            result_path = result_path + '\\'
        result_path = result_path + p_path
    ## add separator between UNC and non-absolute path
    if (result_path and result_path[0] not in '\\/' and
        result_drive and result_drive[-1:] != ':'):
        return result_drive + sep + result_path
    return result_drive + result_path


# Split a path in a drive specification (a drive letter followed by a
# colon) and the path specification.
# It is always true that drivespec + pathspec == p
def splitdrive(p):
    """Split a pathname into drive/UNC sharepoint and relative path specifiers.
    Returns a 2-tuple (drive_or_unc, path); either part may be empty.

    If you assign
        result = splitdrive(p)
    It is always true that:
        result[0] + result[1] == p

    If the path contained a drive letter, drive_or_unc will contain everything
    up to and including the colon.  e.g. splitdrive("c:/dir") returns ("c:", "/dir")

    If the path contained a UNC path, the drive_or_unc will contain the host name
    and share up to but not including the fourth directory separator character.
    e.g. splitdrive("//host/computer/dir") returns ("//host/computer", "/dir")

    Paths cannot contain both a drive letter and a UNC path.

    """
    if len(p) > 1:
        normp = p.replace(altsep, sep)
        if (normp[0:2] == sep*2) and (normp[2:3] != sep):
            # is a UNC path:
            # vvvvvvvvvvvvvvvvvvvv drive letter or UNC path
            # \\machine\mountpoint\directory\etc\...
            #           directory ^^^^^^^^^^^^^^^
            index = normp.find(sep, 2)
            if index == -1:
                return '', p
            index2 = normp.find(sep, index + 1)
            # a UNC path can't have two slashes in a row
            # (after the initial two)
            if index2 == index + 1:
                return '', p
            if index2 == -1:
                index2 = len(p)
            return p[:index2], p[index2:]
        if normp[1] == ':':
            return p[:2], p[2:]
    return '', p

# Parse UNC paths
def splitunc(p):
    """Split a pathname into UNC mount point and relative path specifiers.

    Return a 2-tuple (unc, rest); either part may be empty.
    If unc is not empty, it has the form '//host/mount' (or similar
    using backslashes).  unc+rest is always the input path.
    Paths containing drive letters never have a UNC part.
    """
    if p[1:2] == ':':
        return '', p # Drive letter present
    firstTwo = p[0:2]
    if firstTwo == '//' or firstTwo == '\\\\':
        # is a UNC path:
        # vvvvvvvvvvvvvvvvvvvv equivalent to drive letter
        # \\machine\mountpoint\directories...
        #           directory ^^^^^^^^^^^^^^^
        normp = p.replace('\\', '/')
        index = normp.find('/', 2)
        if index <= 2:
            return '', p
        index2 = normp.find('/', index + 1)
        # a UNC path can't have two slashes in a row
        # (after the initial two)
        if index2 == index + 1:
            return '', p
        if index2 == -1:
            index2 = len(p)
        return p[:index2], p[index2:]
    return '', p


# Split a path in head (everything up to the last '/') and tail (the
# rest).  After the trailing '/' is stripped, the invariant
# join(head, tail) == p holds.
# The resulting head won't end in '/' unless it is the root.

def split(p):
    """Split a pathname.

    Return tuple (head, tail) where tail is everything after the final slash.
    Either part may be empty."""

    d, p = splitdrive(p)
    # set i to index beyond p's last slash
    i = len(p)
    while i and p[i-1] not in '/\\':
        i = i - 1
    head, tail = p[:i], p[i:]  # now tail has no slashes
    # remove trailing slashes from head, unless it's all slashes
    head2 = head
    while head2 and head2[-1] in '/\\':
        head2 = head2[:-1]
    head = head2 or head
    return d + head, tail


# Split a path in root and extension.
# The extension is everything starting at the last dot in the last
# pathname component; the root is everything before that.
# It is always true that root + ext == p.

def splitext(p):
    return genericpath._splitext(p, sep, altsep, extsep)
splitext.__doc__ = genericpath._splitext.__doc__


# Return the tail (basename) part of a path.

def basename(p):
    """Returns the final component of a pathname"""
    return split(p)[1]


# Return the head (dirname) part of a path.

def dirname(p):
    """Returns the directory component of a pathname"""
    return split(p)[0]

# Is a path a symbolic link?
# This will always return false on systems where posix.lstat doesn't exist.

def islink(path):
    """Test for symbolic link.
    On WindowsNT/95 and OS/2 always returns false
    """
    return False

# alias exists to lexists
lexists = exists

# Is a path a mount point?  Either a root (with or without drive letter)
# or a UNC path with at most a / or \ after the mount point.

def ismount(path):
    """Test whether a path is a mount point (defined as root of drive)"""
    unc, rest = splitunc(path)
    if unc:
        return rest in ("", "/", "\\")
    p = splitdrive(path)[1]
    return len(p) == 1 and p[0] in '/\\'


# Directory tree walk.
# For each directory under top (including top itself, but excluding
# '.' and '..'), func(arg, dirname, filenames) is called, where
# dirname is the name of the directory and filenames is the list
# of files (and subdirectories etc.) in the directory.
# The func may modify the filenames list, to implement a filter,
# or to impose a different order of visiting.

def walk(top, func, arg):
    """Directory tree walk with callback function.

    For each directory in the directory tree rooted at top (including top
    itself, but excluding '.' and '..'), call func(arg, dirname, fnames).
    dirname is the name of the directory, and fnames a list of the names of
    the files and subdirectories in dirname (excluding '.' and '..').  func
    may modify the fnames list in-place (e.g. via del or slice assignment),
    and walk will only recurse into the subdirectories whose names remain in
    fnames; this can be used to implement a filter, or to impose a specific
    order of visiting.  No semantics are defined for, or required of, arg,
    beyond that arg is always passed to func.  It can be used, e.g., to pass
    a filename pattern, or a mutable object designed to accumulate
    statistics.  Passing None for arg is common."""
    warnings.warnpy3k("In 3.x, os.path.walk is removed in favor of os.walk.",
                      stacklevel=2)
    try:
        names = os.listdir(top)
    except os.error:
        return
    func(arg, top, names)
    for name in names:
        name = join(top, name)
        if isdir(name):
            walk(name, func, arg)


# Expand paths beginning with '~' or '~user'.
# '~' means $HOME; '~user' means that user's home directory.
# If the path doesn't begin with '~', or if the user or $HOME is unknown,
# the path is returned unchanged (leaving error reporting to whatever
# function is called with the expanded path as argument).
# See also module 'glob' for expansion of *, ? and [...] in pathnames.
# (A function should also be defined to do full *sh-style environment
# variable expansion.)

def expanduser(path):
    """Expand ~ and ~user constructs.

    If user or $HOME is unknown, do nothing."""
    if path[:1] != '~':
        return path
    i, n = 1, len(path)
    while i < n and path[i] not in '/\\':
        i = i + 1

    if 'HOME' in os.environ:
        userhome = os.environ['HOME']
    elif 'USERPROFILE' in os.environ:
        userhome = os.environ['USERPROFILE']
    elif not 'HOMEPATH' in os.environ:
        return path
    else:
        try:
            drive = os.environ['HOMEDRIVE']
        except KeyError:
            drive = ''
        userhome = join(drive, os.environ['HOMEPATH'])

    if i != 1: #~user
        userhome = join(dirname(userhome), path[1:i])

    return userhome + path[i:]


# Expand paths containing shell variable substitutions.
# The following rules apply:
#       - no expansion within single quotes
#       - '$$' is translated into '$'
#       - '%%' is translated into '%' if '%%' are not seen in %var1%%var2%
#       - ${varname} is accepted.
#       - $varname is accepted.
#       - %varname% is accepted.
#       - varnames can be made out of letters, digits and the characters '_-'
#         (though is not verified in the ${varname} and %varname% cases)
# XXX With COMMAND.COM you can use any characters in a variable name,
# XXX except '^|<>='.

def expandvars(path):
    """Expand shell variables of the forms $var, ${var} and %var%.

    Unknown variables are left unchanged."""
    if '$' not in path and '%' not in path:
        return path
    import string
    varchars = string.ascii_letters + string.digits + '_-'
    if isinstance(path, _unicode):
        encoding = sys.getfilesystemencoding()
        def getenv(var):
            return os.environ[var.encode(encoding)].decode(encoding)
    else:
        def getenv(var):
            return os.environ[var]
    res = ''
    index = 0
    pathlen = len(path)
    while index < pathlen:
        c = path[index]
        if c == '\'':   # no expansion within single quotes
            path = path[index + 1:]
            pathlen = len(path)
            try:
                index = path.index('\'')
                res = res + '\'' + path[:index + 1]
            except ValueError:
                res = res + c + path
                index = pathlen - 1
        elif c == '%':  # variable or '%'
            if path[index + 1:index + 2] == '%':
                res = res + c
                index = index + 1
            else:
                path = path[index+1:]
                pathlen = len(path)
                try:
                    index = path.index('%')
                except ValueError:
                    res = res + '%' + path
                    index = pathlen - 1
                else:
                    var = path[:index]
                    try:
                        res = res + getenv(var)
                    except KeyError:
                        res = res + '%' + var + '%'
        elif c == '$':  # variable or '$$'
            if path[index + 1:index + 2] == '$':
                res = res + c
                index = index + 1
            elif path[index + 1:index + 2] == '{':
                path = path[index+2:]
                pathlen = len(path)
                try:
                    index = path.index('}')
                    var = path[:index]
                    try:
                        res = res + getenv(var)
                    except KeyError:
                        res = res + '${' + var + '}'
                except ValueError:
                    res = res + '${' + path
                    index = pathlen - 1
            else:
                var = ''
                index = index + 1
                c = path[index:index + 1]
                while c != '' and c in varchars:
                    var = var + c
                    index = index + 1
                    c = path[index:index + 1]
                try:
                    res = res + getenv(var)
                except KeyError:
                    res = res + '$' + var
                if c != '':
                    index = index - 1
        else:
            res = res + c
        index = index + 1
    return res


# Normalize a path, e.g. A//B, A/./B and A/foo/../B all become A\B.
# Previously, this function also truncated pathnames to 8+3 format,
# but as this module is called "ntpath", that's obviously wrong!

def normpath(path):
    """Normalize path, eliminating double slashes, etc."""
    # Preserve unicode (if path is unicode)
    backslash, dot = (u'\\', u'.') if isinstance(path, _unicode) else ('\\', '.')
    if path.startswith(('\\\\.\\', '\\\\?\\')):
        # in the case of paths with these prefixes:
        # \\.\ -> device names
        # \\?\ -> literal paths
        # do not do any normalization, but return the path unchanged
        return path
    path = path.replace("/", "\\")
    prefix, path = splitdrive(path)
    # We need to be careful here. If the prefix is empty, and the path starts
    # with a backslash, it could either be an absolute path on the current
    # drive (\dir1\dir2\file) or a UNC filename (\\server\mount\dir1\file). It
    # is therefore imperative NOT to collapse multiple backslashes blindly in
    # that case.
    # The code below preserves multiple backslashes when there is no drive
    # letter. This means that the invalid filename \\\a\b is preserved
    # unchanged, where a\\\b is normalised to a\b. It's not clear that there
    # is any better behaviour for such edge cases.
    if prefix == '':
        # No drive letter - preserve initial backslashes
        while path[:1] == "\\":
            prefix = prefix + backslash
            path = path[1:]
    else:
        # We have a drive letter - collapse initial backslashes
        if path.startswith("\\"):
            prefix = prefix + backslash
            path = path.lstrip("\\")
    comps = path.split("\\")
    i = 0
    while i < len(comps):
        if comps[i] in ('.', ''):
            del comps[i]
        elif comps[i] == '..':
            if i > 0 and comps[i-1] != '..':
                del comps[i-1:i+1]
                i -= 1
            elif i == 0 and prefix.endswith("\\"):
                del comps[i]
            else:
                i += 1
        else:
            i += 1
    # If the path is now empty, substitute '.'
    if not prefix and not comps:
        comps.append(dot)
    return prefix + backslash.join(comps)


# Return an absolute path.
try:
    from nt import _getfullpathname

except ImportError: # not running on Windows - mock up something sensible
    def abspath(path):
        """Return the absolute version of a path."""
        if not isabs(path):
            if isinstance(path, _unicode):
                cwd = os.getcwdu()
            else:
                cwd = os.getcwd()
            path = join(cwd, path)
        return normpath(path)

else:  # use native Windows method on Windows
    def abspath(path):
        """Return the absolute version of a path."""

        if path: # Empty path must return current working directory.
            try:
                path = _getfullpathname(path)
            except WindowsError:
                pass # Bad path - return unchanged.
        elif isinstance(path, _unicode):
            path = os.getcwdu()
        else:
            path = os.getcwd()
        return normpath(path)

# realpath is a no-op on systems without islink support
realpath = abspath
# Win9x family and earlier have no Unicode filename support.
supports_unicode_filenames = (hasattr(sys, "getwindowsversion") and
                              sys.getwindowsversion()[3] >= 2)

def _abspath_split(path):
    abs = abspath(normpath(path))
    prefix, rest = splitunc(abs)
    is_unc = bool(prefix)
    if not is_unc:
        prefix, rest = splitdrive(abs)
    return is_unc, prefix, [x for x in rest.split(sep) if x]

def relpath(path, start=curdir):
    """Return a relative version of a path"""

    if not path:
        raise ValueError("no path specified")

    start_is_unc, start_prefix, start_list = _abspath_split(start)
    path_is_unc, path_prefix, path_list = _abspath_split(path)

    if path_is_unc ^ start_is_unc:
        raise ValueError("Cannot mix UNC and non-UNC paths (%s and %s)"
                                                            % (path, start))
    if path_prefix.lower() != start_prefix.lower():
        if path_is_unc:
            raise ValueError("path is on UNC root %s, start on UNC root %s"
                                                % (path_prefix, start_prefix))
        else:
            raise ValueError("path is on drive %s, start on drive %s"
                                                % (path_prefix, start_prefix))
    # Work out how much of the filepath is shared by start and path.
    i = 0
    for e1, e2 in zip(start_list, path_list):
        if e1.lower() != e2.lower():
            break
        i += 1

    rel_list = [pardir] * (len(start_list)-i) + path_list[i:]
    if not rel_list:
        return curdir
    return join(*rel_list)

try:
    # The genericpath.isdir implementation uses os.stat and checks the mode
    # attribute to tell whether or not the path is a directory.
    # This is overkill on Windows - just pass the path to GetFileAttributes
    # and check the attribute from there.
    from nt import _isdir as isdir
except ImportError:
    # Use genericpath.isdir as imported above.
    pass
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           """Convert a NT pathname to a file URL and vice versa."""

def url2pathname(url):
    """OS-specific conversion from a relative URL of the 'file' scheme
    to a file system path; not recommended for general use."""
    # e.g.
    #   ///C|/foo/bar/spam.foo
    # and
    #   ///C:/foo/bar/spam.foo
    # become
    #   C:\foo\bar\spam.foo
    import string, urllib
    # Windows itself uses ":" even in URLs.
    url = url.replace(':', '|')
    if not '|' in url:
        # No drive specifier, just convert slashes
        if url[:4] == '////':
            # path is something like ////host/path/on/remote/host
            # convert this to \\host\path\on\remote\host
            # (notice halving of slashes at the start of the path)
            url = url[2:]
        components = url.split('/')
        # make sure not to convert quoted slashes :-)
        return urllib.unquote('\\'.join(components))
    comp = url.split('|')
    if len(comp) != 2 or comp[0][-1] not in string.ascii_letters:
        error = 'Bad URL: ' + url
        raise IOError, error
    drive = comp[0][-1].upper()
    path = drive + ':'
    components = comp[1].split('/')
    for comp in components:
        if comp:
            path = path + '\\' + urllib.unquote(comp)
    # Issue #11474: url like '/C|/' should convert into 'C:\\'
    if path.endswith(':') and url.endswith('/'):
        path += '\\'
    return path

def pathname2url(p):
    """OS-specific conversion from a file system path to a relative URL
    of the 'file' scheme; not recommended for general use."""
    # e.g.
    #   C:\foo\bar\spam.foo
    # becomes
    #   ///C:/foo/bar/spam.foo
    import urllib
    if not ':' in p:
        # No drive specifier, just convert slashes and quote the name
        if p[:2] == '\\\\':
        # path is something like \\host\path\on\remote\host
        # convert this to ////host/path/on/remote/host
        # (notice doubling of slashes at the start of the path)
            p = '\\\\' + p
        components = p.split('\\')
        return urllib.quote('/'.join(components))
    comp = p.split(':')
    if len(comp) != 2 or len(comp[0]) > 1:
        error = 'Bad path: ' + p
        raise IOError, error

    drive = urllib.quote(comp[0].upper())
    components = comp[1].split('\\')
    path = '///' + drive + ':'
    for comp in components:
        if comp:
            path = path + '/' + urllib.quote(comp)
    return path
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ó
Ó«[c           @   s   d  Z  d „  Z d „  Z d S(   s3   Convert a NT pathname to a file URL and vice versa.c         C   sW  d d l  } d d l } |  j d d ƒ }  d |  k rx |  d  d k rS |  d }  n  |  j d ƒ } | j d	 j | ƒ ƒ S|  j d ƒ } t | ƒ d k s° | d
 d | j k rÆ d |  } t | ‚ n  | d
 d j	 ƒ  } | d } | d j d ƒ } x. | D]& } | rþ | d	 | j | ƒ } qþ qþ W| j
 d ƒ rS|  j
 d ƒ rS| d	 7} n  | S(   s{   OS-specific conversion from a relative URL of the 'file' scheme
    to a file system path; not recommended for general use.iÿÿÿÿNt   :t   |i   s   ////i   t   /s   \i    s	   Bad URL: i   (   t   stringt   urllibt   replacet   splitt   unquotet   joint   lent   ascii_letterst   IOErrort   uppert   endswith(   t   urlR   R   t
   componentst   compt   errort   drivet   path(    (    s    /usr/lib/python2.7/nturl2path.pyt   url2pathname   s(    	)

c         C   s  d d l  } d |  k rZ |  d  d k r5 d |  }  n  |  j d ƒ } | j d j | ƒ ƒ S|  j d ƒ } t | ƒ d k s‘ t | d ƒ d	 k r§ d
 |  } t | ‚ n  | j | d j ƒ  ƒ } | d	 j d ƒ } d | d } x. | D]& } | rè | d | j | ƒ } qè qè W| S(   s{   OS-specific conversion from a file system path to a relative URL
    of the 'file' scheme; not recommended for general use.iÿÿÿÿNR    i   s   \\s   \R   i    i   s
   Bad path: s   ///(   R   R   t   quoteR   R	   R   R   (   t   pR   R   R   R   R   R   (    (    s    /usr/lib/python2.7/nturl2path.pyt   pathname2url(   s"    (
N(   t   __doc__R   R   (    (    (    s    /usr/lib/python2.7/nturl2path.pyt   <module>   s   	%                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               # $Id$
#
#  Copyright (C) 2005   Gregory P. Smith (greg@krypto.org)
#  Licensed to PSF under a Contributor Agreement.

import warnings
warnings.warn("the sha module is deprecated; use the hashlib module instead",
                DeprecationWarning, 2)

from hashlib import sha1 as sha
new = sha

blocksize = 1        # legacy value (wrong in any useful sense)
digest_size = 20
digestsize = 20
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ó
Ó«[c        $   @   sp  d  Z  d d l Z d d l Z d d l Z d d l Z d d l Z d d l Td d l m Z d d d d d	 d
 d d d d d d d d d d d d d d d d d d d d d d  d! d" d# d$ d% d& d' d( g$ Z d) Z d* Z	 d) Z
 d+ Z d, Z d- Z d. Z d/ e j k rd0 Z n d1 e j k r(d- Z n  d2 Z d3 „  Z d4 „  Z d5 „  Z d6 „  Z d7 „  Z d8 „  Z d9 „  Z e j j  e _  d: „  Z d; „  Z d< „  Z e Z d= „  Z d> „  Z d? „  Z  d@ „  Z! dA „  Z" y d dB l# m$ Z$ Wn e% k
 rúdC „  Z& n
 XdD „  Z& e& Z' e( e dE ƒ o,e j) ƒ  dF dG k Z* dH „  Z+ e dI „ Z, y d dJ l# m- Z. Wn e% k
 rkn Xd S(K   s   Common pathname manipulations, WindowsNT/95 version.

Instead of importing this module directly, import os and refer to this
module as os.path.
iÿÿÿÿN(   t   *(   t   _unicodet   normcaset   isabst   joint
   splitdrivet   splitt   splitextt   basenamet   dirnamet   commonprefixt   getsizet   getmtimet   getatimet   getctimet   islinkt   existst   lexistst   isdirt   isfilet   ismountt   walkt
   expandusert
   expandvarst   normpatht   abspatht   splitunct   curdirt   pardirt   sept   pathsept   defpatht   altsept   extsept   devnullt   realpatht   supports_unicode_filenamest   relpatht   .s   ..s   \t   ;t   /s   .;C:\bint   ces   \Windowst   os2t   nulc         C   s   |  j  d d ƒ j ƒ  S(   sa   Normalize case of pathname.

    Makes all characters lowercase and all slashes into backslashes.R(   s   \(   t   replacet   lower(   t   s(    (    s   /usr/lib/python2.7/ntpath.pyR   +   s    c         C   s*   t  |  ƒ d }  |  d k o) |  d  d k S(   s   Test whether a path is absolutei   t    s   /\(   R   (   R.   (    (    s   /usr/lib/python2.7/ntpath.pyR   8   s    c         G   s  t  |  ƒ \ } } xÊ | D]Â } t  | ƒ \ } } | ri | d d k ri | sT | r] | } n  | } q nE | r® | | k r® | j ƒ  | j ƒ  k r¥ | } | } q n  | } n  | rÑ | d d k rÑ | d } n  | | } q W| r| d d k r| r| d d k r| t | S| | S(   s>   Join two or more pathname components, inserting "\" as needed.i    s   \/iÿÿÿÿs   \t   :(   R   R-   R   (   t   patht   pathst   result_drivet   result_patht   pt   p_drivet   p_path(    (    s   /usr/lib/python2.7/ntpath.pyR   ?   s*    		c         C   s  t  |  ƒ d k rø |  j t t ƒ } | d d !t d k rÓ | d d !t k rÓ | j t d ƒ } | d k rv d |  f S| j t | d ƒ } | | d k r¦ d |  f S| d k rÁ t  |  ƒ } n  |  |  |  | f S| d d k rø |  d  |  d f Sn  d |  f S(   sÚ  Split a pathname into drive/UNC sharepoint and relative path specifiers.
    Returns a 2-tuple (drive_or_unc, path); either part may be empty.

    If you assign
        result = splitdrive(p)
    It is always true that:
        result[0] + result[1] == p

    If the path contained a drive letter, drive_or_unc will contain everything
    up to and including the colon.  e.g. splitdrive("c:/dir") returns ("c:", "/dir")

    If the path contained a UNC path, the drive_or_unc will contain the host name
    and share up to but not including the fourth directory separator character.
    e.g. splitdrive("//host/computer/dir") returns ("//host/computer", "/dir")

    Paths cannot contain both a drive letter and a UNC path.

    i   i    i   i   iÿÿÿÿR/   R0   (   t   lenR,   R    R   t   find(   R5   t   normpt   indext   index2(    (    s   /usr/lib/python2.7/ntpath.pyR   `   s    *

c         C   sã   |  d d !d k r d |  f S|  d d !} | d k sB | d k rÙ |  j  d d	 ƒ } | j d	 d ƒ } | d k r| d |  f S| j d	 | d ƒ } | | d k r¬ d |  f S| d
 k rÇ t |  ƒ } n  |  |  |  | f Sd |  f S(   s?  Split a pathname into UNC mount point and relative path specifiers.

    Return a 2-tuple (unc, rest); either part may be empty.
    If unc is not empty, it has the form '//host/mount' (or similar
    using backslashes).  unc+rest is always the input path.
    Paths containing drive letters never have a UNC part.
    i   i   R0   R/   i    s   //s   \\s   \R(   iÿÿÿÿ(   R,   R9   R8   (   R5   t   firstTwoR:   R;   R<   (    (    s   /usr/lib/python2.7/ntpath.pyR   Š   s    


c         C   s¥   t  |  ƒ \ } }  t |  ƒ } x( | rH |  | d d k rH | d } q! W|  |  |  | } } | } x$ | rŠ | d d k rŠ | d  } qg W| p” | } | | | f S(   s~   Split a pathname.

    Return tuple (head, tail) where tail is everything after the final slash.
    Either part may be empty.i   s   /\iÿÿÿÿ(   R   R8   (   R5   t   dt   it   headt   tailt   head2(    (    s   /usr/lib/python2.7/ntpath.pyR   ®   s    c         C   s   t  j |  t t t ƒ S(   N(   t   genericpatht	   _splitextR   R    R!   (   R5   (    (    s   /usr/lib/python2.7/ntpath.pyR   Ç   s    c         C   s   t  |  ƒ d S(   s)   Returns the final component of a pathnamei   (   R   (   R5   (    (    s   /usr/lib/python2.7/ntpath.pyR   Î   s    c         C   s   t  |  ƒ d S(   s-   Returns the directory component of a pathnamei    (   R   (   R5   (    (    s   /usr/lib/python2.7/ntpath.pyR	   Õ   s    c         C   s   t  S(   sN   Test for symbolic link.
    On WindowsNT/95 and OS/2 always returns false
    (   t   False(   R1   (    (    s   /usr/lib/python2.7/ntpath.pyR   Ü   s    c         C   sR   t  |  ƒ \ } } | r" | d k St |  ƒ d } t | ƒ d k oQ | d d k S(   s?   Test whether a path is a mount point (defined as root of drive)R/   R(   s   \i   i    s   /\(   R/   R(   s   \(   R   R   R8   (   R1   t   unct   restR5   (    (    s   /usr/lib/python2.7/ntpath.pyR   è   s
    
c         C   s‘   t  j d d d ƒy t j |  ƒ } Wn t j k
 r= d SX| | |  | ƒ x< | D]4 } t |  | ƒ } t | ƒ rU t | | | ƒ qU qU Wd S(   sI  Directory tree walk with callback function.

    For each directory in the directory tree rooted at top (including top
    itself, but excluding '.' and '..'), call func(arg, dirname, fnames).
    dirname is the name of the directory, and fnames a list of the names of
    the files and subdirectories in dirname (excluding '.' and '..').  func
    may modify the fnames list in-place (e.g. via del or slice assignment),
    and walk will only recurse into the subdirectories whose names remain in
    fnames; this can be used to implement a filter, or to impose a specific
    order of visiting.  No semantics are defined for, or required of, arg,
    beyond that arg is always passed to func.  It can be used, e.g., to pass
    a filename pattern, or a mutable object designed to accumulate
    statistics.  Passing None for arg is common.s4   In 3.x, os.path.walk is removed in favor of os.walk.t
   stackleveli   N(   t   warningst   warnpy3kt   ost   listdirt   errorR   R   R   (   t   topt   funct   argt   namest   name(    (    s   /usr/lib/python2.7/ntpath.pyR   ù   s    c         C   s  |  d  d k r |  Sd t  |  ƒ } } x* | | k  rS |  | d k rS | d } q* Wd t j k rs t j d } ns d t j k r’ t j d } nT d t j k r¥ |  Sy t j d } Wn t k
 rÏ d } n Xt | t j d ƒ } | d k rt t | ƒ |  d | !ƒ } n  | |  | S(	   sL   Expand ~ and ~user constructs.

    If user or $HOME is unknown, do nothing.i   t   ~s   /\t   HOMEt   USERPROFILEt   HOMEPATHt	   HOMEDRIVER/   (   R8   RK   t   environt   KeyErrorR   R	   (   R1   R?   t   nt   userhomet   drive(    (    s   /usr/lib/python2.7/ntpath.pyR     s&    
c   	         sË  d |  k r d |  k r |  Sd d l  } | j | j d } t |  t ƒ ri t j ƒ  ‰  ‡  f d †  } n	 d „  } d } d	 } t |  ƒ } x:| | k  rÆ|  | } | d
 k r!|  | d }  t |  ƒ } y) |  j d
 ƒ } | d
 |  | d  } Wq¹t	 k
 r| | |  } | d } q¹Xn˜| d k rÿ|  | d | d !d k r_| | } | d } q¹|  | d }  t |  ƒ } y |  j d ƒ } Wn) t	 k
 r·| d |  } | d } q¹X|  |  } y | | | ƒ } Wq¹t
 k
 rû| d | d } q¹Xnº| d k r¯|  | d | d !d k r=| | } | d } q¹|  | d | d !d k rø|  | d }  t |  ƒ } yW |  j d ƒ } |  |  } y | | | ƒ } Wn# t
 k
 rÇ| d | d } n XWq¬t	 k
 rô| d |  } | d } q¬Xq¹d } | d } |  | | d !} xA | d k r\| | k r\| | } | d } |  | | d !} qWy | | | ƒ } Wn t
 k
 r’| d | } n X| d k r¹| d } q¹n
 | | } | d } q W| S(   sf   Expand shell variables of the forms $var, ${var} and %var%.

    Unknown variables are left unchanged.t   $t   %iÿÿÿÿNs   _-c            s   t  j |  j ˆ  ƒ j ˆ  ƒ S(   N(   RK   RX   t   encodet   decode(   t   var(   t   encoding(    s   /usr/lib/python2.7/ntpath.pyt   getenvQ  s    c         S   s   t  j |  S(   N(   RK   RX   (   Ra   (    (    s   /usr/lib/python2.7/ntpath.pyRc   T  s    R/   i    s   'i   i   t   {t   }s   ${(   t   stringt   ascii_letterst   digitst
   isinstanceR   t   syst   getfilesystemencodingR8   R;   t
   ValueErrorRY   (	   R1   Rf   t   varcharsRc   t   resR;   t   pathlent   cRa   (    (   Rb   s   /usr/lib/python2.7/ntpath.pyR   G  sŽ    	








c         C   s¿  t  |  t ƒ r d n d \ } } |  j d ƒ r4 |  S|  j d d ƒ }  t |  ƒ \ } }  | d k r’ xV |  d	  d k rŽ | | } |  d	 }  qg Wn+ |  j d ƒ r½ | | } |  j d ƒ }  n  |  j d ƒ } d
 } x» | t | ƒ k  r| | d k r| | =qÕ | | d k r‚| d
 k rP| | d	 d k rP| | d	 | d	 5| d	 8} qŒ| d
 k ru| j d ƒ ru| | =qŒ| d	 7} qÕ | d	 7} qÕ W| r®| r®| j	 | ƒ n  | | j
 | ƒ S(   s0   Normalize path, eliminating double slashes, etc.u   \u   .s   \R&   s   \\.\s   \\?\R(   R/   i   i    s   ..(   u   \u   .(   s   \R&   (   s   \\.\s   \\?\(   R&   R/   (   Ri   R   t
   startswithR,   R   t   lstripR   R8   t   endswitht   appendR   (   R1   t	   backslasht   dott   prefixt   compsR?   (    (    s   /usr/lib/python2.7/ntpath.pyR   Ÿ  s8    !



 
(   t   _getfullpathnamec         C   sR   t  |  ƒ sH t |  t ƒ r* t j ƒ  } n t j ƒ  } t | |  ƒ }  n  t |  ƒ S(   s&   Return the absolute version of a path.(   R   Ri   R   RK   t   getcwdut   getcwdR   R   (   R1   t   cwd(    (    s   /usr/lib/python2.7/ntpath.pyR   Ø  s    c         C   sa   |  r- y t  |  ƒ }  WqW t k
 r) qW Xn* t |  t ƒ rK t j ƒ  }  n t j ƒ  }  t |  ƒ S(   s&   Return the absolute version of a path.(   Ry   t   WindowsErrorRi   R   RK   Rz   R{   R   (   R1   (    (    s   /usr/lib/python2.7/ntpath.pyR   ã  s    t   getwindowsversioni   i   c         C   sz   t  t |  ƒ ƒ } t | ƒ \ } } t | ƒ } | sK t | ƒ \ } } n  | | g  | j t ƒ D] } | ra | ^ qa f S(   N(   R   R   R   t   boolR   R   R   (   R1   t   absRw   RG   t   is_unct   x(    (    s   /usr/lib/python2.7/ntpath.pyt   _abspath_split÷  s    c         C   s1  |  s t  d ƒ ‚ n  t | ƒ \ } } } t |  ƒ \ } } } | | Arb t  d |  | f ƒ ‚ n  | j ƒ  | j ƒ  k r² | r™ t  d | | f ƒ ‚ q² t  d | | f ƒ ‚ n  d } xC t | | ƒ D]2 \ }	 }
 |	 j ƒ  |
 j ƒ  k rð Pn  | d 7} qÈ Wt g t | ƒ | | | } | s't St | Œ  S(   s#   Return a relative version of a paths   no path specifieds,   Cannot mix UNC and non-UNC paths (%s and %s)s,   path is on UNC root %s, start on UNC root %ss&   path is on drive %s, start on drive %si    i   (   Rl   Rƒ   R-   t   zipR   R8   R   R   (   R1   t   startt   start_is_unct   start_prefixt
   start_listt   path_is_unct   path_prefixt	   path_listR?   t   e1t   e2t   rel_list(    (    s   /usr/lib/python2.7/ntpath.pyR%   ÿ  s,    
(   t   _isdir(/   t   __doc__RK   Rj   t   statRC   RI   R   t   __all__R   R   R!   R   R   R    R   t   builtin_module_namesR"   R   R   R   R   R   R   R   RD   R   R	   R   R   R   R   R   R   R   R   t   ntRy   t   ImportErrorR   R#   t   hasattrR~   R$   Rƒ   R%   R   R   (    (    (    s   /usr/lib/python2.7/ntpath.pyt   <module>   sp   
					!	*	$							$	*	X	5		                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   # Copyright 2007 Google, Inc. All Rights Reserved.
# Licensed to PSF under a Contributor Agreement.

"""Abstract Base Classes (ABCs) for numbers, according to PEP 3141.

TODO: Fill out more detailed documentation on the operators."""

from __future__ import division
from abc import ABCMeta, abstractmethod, abstractproperty

__all__ = ["Number", "Complex", "Real", "Rational", "Integral"]

class Number(object):
    """All numbers inherit from this class.

    If you just want to check if an argument x is a number, without
    caring what kind, use isinstance(x, Number).
    """
    __metaclass__ = ABCMeta
    __slots__ = ()

    # Concrete numeric types must provide their own hash implementation
    __hash__ = None


## Notes on Decimal
## ----------------
## Decimal has all of the methods specified by the Real abc, but it should
## not be registered as a Real because decimals do not interoperate with
## binary floats (i.e.  Decimal('3.14') + 2.71828 is undefined).  But,
## abstract reals are expected to interoperate (i.e. R1 + R2 should be
## expected to work if R1 and R2 are both Reals).

class Complex(Number):
    """Complex defines the operations that work on the builtin complex type.

    In short, those are: a conversion to complex, .real, .imag, +, -,
    *, /, abs(), .conjugate, ==, and !=.

    If it is given heterogenous arguments, and doesn't have special
    knowledge about them, it should fall back to the builtin complex
    type as described below.
    """

    __slots__ = ()

    @abstractmethod
    def __complex__(self):
        """Return a builtin complex instance. Called for complex(self)."""

    # Will be __bool__ in 3.0.
    def __nonzero__(self):
        """True if self != 0. Called for bool(self)."""
        return self != 0

    @abstractproperty
    def real(self):
        """Retrieve the real component of this number.

        This should subclass Real.
        """
        raise NotImplementedError

    @abstractproperty
    def imag(self):
        """Retrieve the imaginary component of this number.

        This should subclass Real.
        """
        raise NotImplementedError

    @abstractmethod
    def __add__(self, other):
        """self + other"""
        raise NotImplementedError

    @abstractmethod
    def __radd__(self, other):
        """other + self"""
        raise NotImplementedError

    @abstractmethod
    def __neg__(self):
        """-self"""
        raise NotImplementedError

    @abstractmethod
    def __pos__(self):
        """+self"""
        raise NotImplementedError

    def __sub__(self, other):
        """self - other"""
        return self + -other

    def __rsub__(self, other):
        """other - self"""
        return -self + other

    @abstractmethod
    def __mul__(self, other):
        """self * other"""
        raise NotImplementedError

    @abstractmethod
    def __rmul__(self, other):
        """other * self"""
        raise NotImplementedError

    @abstractmethod
    def __div__(self, other):
        """self / other without __future__ division

        May promote to float.
        """
        raise NotImplementedError

    @abstractmethod
    def __rdiv__(self, other):
        """other / self without __future__ division"""
        raise NotImplementedError

    @abstractmethod
    def __truediv__(self, other):
        """self / other with __future__ division.

        Should promote to float when necessary.
        """
        raise NotImplementedError

    @abstractmethod
    def __rtruediv__(self, other):
        """other / self with __future__ division"""
        raise NotImplementedError

    @abstractmethod
    def __pow__(self, exponent):
        """self**exponent; should promote to float or complex when necessary."""
        raise NotImplementedError

    @abstractmethod
    def __rpow__(self, base):
        """base ** self"""
        raise NotImplementedError

    @abstractmethod
    def __abs__(self):
        """Returns the Real distance from 0. Called for abs(self)."""
        raise NotImplementedError

    @abstractmethod
    def conjugate(self):
        """(x+y*i).conjugate() returns (x-y*i)."""
        raise NotImplementedError

    @abstractmethod
    def __eq__(self, other):
        """self == other"""
        raise NotImplementedError

    def __ne__(self, other):
        """self != other"""
        # The default __ne__ doesn't negate __eq__ until 3.0.
        return not (self == other)

Complex.register(complex)


class Real(Complex):
    """To Complex, Real adds the operations that work on real numbers.

    In short, those are: a conversion to float, trunc(), divmod,
    %, <, <=, >, and >=.

    Real also provides defaults for the derived operations.
    """

    __slots__ = ()

    @abstractmethod
    def __float__(self):
        """Any Real can be converted to a native float object.

        Called for float(self)."""
        raise NotImplementedError

    @abstractmethod
    def __trunc__(self):
        """trunc(self): Truncates self to an Integral.

        Returns an Integral i such that:
          * i>0 iff self>0;
          * abs(i) <= abs(self);
          * for any Integral j satisfying the first two conditions,
            abs(i) >= abs(j) [i.e. i has "maximal" abs among those].
        i.e. "truncate towards 0".
        """
        raise NotImplementedError

    def __divmod__(self, other):
        """divmod(self, other): The pair (self // other, self % other).

        Sometimes this can be computed faster than the pair of
        operations.
        """
        return (self // other, self % other)

    def __rdivmod__(self, other):
        """divmod(other, self): The pair (self // other, self % other).

        Sometimes this can be computed faster than the pair of
        operations.
        """
        return (other // self, other % self)

    @abstractmethod
    def __floordiv__(self, other):
        """self // other: The floor() of self/other."""
        raise NotImplementedError

    @abstractmethod
    def __rfloordiv__(self, other):
        """other // self: The floor() of other/self."""
        raise NotImplementedError

    @abstractmethod
    def __mod__(self, other):
        """self % other"""
        raise NotImplementedError

    @abstractmethod
    def __rmod__(self, other):
        """other % self"""
        raise NotImplementedError

    @abstractmethod
    def __lt__(self, other):
        """self < other

        < on Reals defines a total ordering, except perhaps for NaN."""
        raise NotImplementedError

    @abstractmethod
    def __le__(self, other):
        """self <= other"""
        raise NotImplementedError

    # Concrete implementations of Complex abstract methods.
    def __complex__(self):
        """complex(self) == complex(float(self), 0)"""
        return complex(float(self))

    @property
    def real(self):
        """Real numbers are their real component."""
        return +self

    @property
    def imag(self):
        """Real numbers have no imaginary component."""
        return 0

    def conjugate(self):
        """Conjugate is a no-op for Reals."""
        return +self

Real.register(float)


class Rational(Real):
    """.numerator and .denominator should be in lowest terms."""

    __slots__ = ()

    @abstractproperty
    def numerator(self):
        raise NotImplementedError

    @abstractproperty
    def denominator(self):
        raise NotImplementedError

    # Concrete implementation of Real's conversion to float.
    def __float__(self):
        """float(self) = self.numerator / self.denominator

        It's important that this conversion use the integer's "true"
        division rather than casting one side to float before dividing
        so that ratios of huge integers convert without overflowing.

        """
        return self.numerator / self.denominator


class Integral(Rational):
    """Integral adds a conversion to long and the bit-string operations."""

    __slots__ = ()

    @abstractmethod
    def __long__(self):
        """long(self)"""
        raise NotImplementedError

    def __index__(self):
        """Called whenever an index is needed, such as in slicing"""
        return long(self)

    @abstractmethod
    def __pow__(self, exponent, modulus=None):
        """self ** exponent % modulus, but maybe faster.

        Accept the modulus argument if you want to support the
        3-argument version of pow(). Raise a TypeError if exponent < 0
        or any argument isn't Integral. Otherwise, just implement the
        2-argument version described in Complex.
        """
        raise NotImplementedError

    @abstractmethod
    def __lshift__(self, other):
        """self << other"""
        raise NotImplementedError

    @abstractmethod
    def __rlshift__(self, other):
        """other << self"""
        raise NotImplementedError

    @abstractmethod
    def __rshift__(self, other):
        """self >> other"""
        raise NotImplementedError

    @abstractmethod
    def __rrshift__(self, other):
        """other >> self"""
        raise NotImplementedError

    @abstractmethod
    def __and__(self, other):
        """self & other"""
        raise NotImplementedError

    @abstractmethod
    def __rand__(self, other):
        """other & self"""
        raise NotImplementedError

    @abstractmethod
    def __xor__(self, other):
        """self ^ other"""
        raise NotImplementedError

    @abstractmethod
    def __rxor__(self, other):
        """other ^ self"""
        raise NotImplementedError

    @abstractmethod
    def __or__(self, other):
        """self | other"""
        raise NotImplementedError

    @abstractmethod
    def __ror__(self, other):
        """other | self"""
        raise NotImplementedError

    @abstractmethod
    def __invert__(self):
        """~self"""
        raise NotImplementedError

    # Concrete implementations of Rational and Real abstract methods.
    def __float__(self):
        """float(self) == float(long(self))"""
        return float(long(self))

    @property
    def numerator(self):
        """Integers are their own numerators."""
        return +self

    @property
    def denominator(self):
        """Integers have a denominator of 1."""
        return 1

Integral.register(int)
Integral.register(long)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ó
Ó«[c           @   sK   d  d l  Z  e  j d e d ƒ d  d l m Z e Z d Z d Z d Z	 d S(   iÿÿÿÿNs<   the sha module is deprecated; use the hashlib module insteadi   (   t   sha1i   i   (
   t   warningst   warnt   DeprecationWarningt   hashlibR    t   shat   newt	   blocksizet   digest_sizet
   digestsize(    (    (    s   /usr/lib/python2.7/sha.pyt   <module>   s   	
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ó
Ó«[c           @   sí   d  Z  d d l m Z d d l m Z m Z m Z d d d d d g Z d e f d	 „  ƒ  YZ	 d e	 f d
 „  ƒ  YZ
 e
 j e ƒ d e
 f d „  ƒ  YZ e j e ƒ d e f d „  ƒ  YZ d e f d „  ƒ  YZ e j e ƒ e j e ƒ d S(   s~   Abstract Base Classes (ABCs) for numbers, according to PEP 3141.

TODO: Fill out more detailed documentation on the operators.iÿÿÿÿ(   t   division(   t   ABCMetat   abstractmethodt   abstractpropertyt   Numbert   Complext   Realt   Rationalt   Integralc           B   s    e  Z d  Z e Z d Z d Z RS(   sŸ   All numbers inherit from this class.

    If you just want to check if an argument x is a number, without
    caring what kind, use isinstance(x, Number).
    (    N(   t   __name__t
   __module__t   __doc__R   t   __metaclass__t	   __slots__t   Nonet   __hash__(    (    (    s   /usr/lib/python2.7/numbers.pyR      s   c           B   sF  e  Z d  Z d Z e d „  ƒ Z d „  Z e d „  ƒ Z e d „  ƒ Z	 e d „  ƒ Z
 e d „  ƒ Z e d „  ƒ Z e d „  ƒ Z d	 „  Z d
 „  Z e d „  ƒ Z e d „  ƒ Z e d „  ƒ Z e d „  ƒ Z e d „  ƒ Z e d „  ƒ Z e d „  ƒ Z e d „  ƒ Z e d „  ƒ Z e d „  ƒ Z e d „  ƒ Z d „  Z RS(   sa  Complex defines the operations that work on the builtin complex type.

    In short, those are: a conversion to complex, .real, .imag, +, -,
    *, /, abs(), .conjugate, ==, and !=.

    If it is given heterogenous arguments, and doesn't have special
    knowledge about them, it should fall back to the builtin complex
    type as described below.
    c         C   s   d S(   s<   Return a builtin complex instance. Called for complex(self).N(    (   t   self(    (    s   /usr/lib/python2.7/numbers.pyt   __complex__/   s    c         C   s
   |  d k S(   s)   True if self != 0. Called for bool(self).i    (    (   R   (    (    s   /usr/lib/python2.7/numbers.pyt   __nonzero__4   s    c         C   s
   t  ‚ d S(   sX   Retrieve the real component of this number.

        This should subclass Real.
        N(   t   NotImplementedError(   R   (    (    s   /usr/lib/python2.7/numbers.pyt   real8   s    c         C   s
   t  ‚ d S(   s]   Retrieve the imaginary component of this number.

        This should subclass Real.
        N(   R   (   R   (    (    s   /usr/lib/python2.7/numbers.pyt   imag@   s    c         C   s
   t  ‚ d S(   s   self + otherN(   R   (   R   t   other(    (    s   /usr/lib/python2.7/numbers.pyt   __add__H   s    c         C   s
   t  ‚ d S(   s   other + selfN(   R   (   R   R   (    (    s   /usr/lib/python2.7/numbers.pyt   __radd__M   s    c         C   s
   t  ‚ d S(   s   -selfN(   R   (   R   (    (    s   /usr/lib/python2.7/numbers.pyt   __neg__R   s    c         C   s
   t  ‚ d S(   s   +selfN(   R   (   R   (    (    s   /usr/lib/python2.7/numbers.pyt   __pos__W   s    c         C   s	   |  | S(   s   self - other(    (   R   R   (    (    s   /usr/lib/python2.7/numbers.pyt   __sub__\   s    c         C   s	   |  | S(   s   other - self(    (   R   R   (    (    s   /usr/lib/python2.7/numbers.pyt   __rsub__`   s    c         C   s
   t  ‚ d S(   s   self * otherN(   R   (   R   R   (    (    s   /usr/lib/python2.7/numbers.pyt   __mul__d   s    c         C   s
   t  ‚ d S(   s   other * selfN(   R   (   R   R   (    (    s   /usr/lib/python2.7/numbers.pyt   __rmul__i   s    c         C   s
   t  ‚ d S(   sP   self / other without __future__ division

        May promote to float.
        N(   R   (   R   R   (    (    s   /usr/lib/python2.7/numbers.pyt   __div__n   s    c         C   s
   t  ‚ d S(   s(   other / self without __future__ divisionN(   R   (   R   R   (    (    s   /usr/lib/python2.7/numbers.pyt   __rdiv__v   s    c         C   s
   t  ‚ d S(   s`   self / other with __future__ division.

        Should promote to float when necessary.
        N(   R   (   R   R   (    (    s   /usr/lib/python2.7/numbers.pyt   __truediv__{   s    c         C   s
   t  ‚ d S(   s%   other / self with __future__ divisionN(   R   (   R   R   (    (    s   /usr/lib/python2.7/numbers.pyt   __rtruediv__ƒ   s    c         C   s
   t  ‚ d S(   sB   self**exponent; should promote to float or complex when necessary.N(   R   (   R   t   exponent(    (    s   /usr/lib/python2.7/numbers.pyt   __pow__ˆ   s    c         C   s
   t  ‚ d S(   s   base ** selfN(   R   (   R   t   base(    (    s   /usr/lib/python2.7/numbers.pyt   __rpow__   s    c         C   s
   t  ‚ d S(   s7   Returns the Real distance from 0. Called for abs(self).N(   R   (   R   (    (    s   /usr/lib/python2.7/numbers.pyt   __abs__’   s    c         C   s
   t  ‚ d S(   s$   (x+y*i).conjugate() returns (x-y*i).N(   R   (   R   (    (    s   /usr/lib/python2.7/numbers.pyt	   conjugate—   s    c         C   s
   t  ‚ d S(   s   self == otherN(   R   (   R   R   (    (    s   /usr/lib/python2.7/numbers.pyt   __eq__œ   s    c         C   s   |  | k S(   s   self != other(    (   R   R   (    (    s   /usr/lib/python2.7/numbers.pyt   __ne__¡   s    (    (   R	   R
   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R    R!   R"   R$   R&   R'   R(   R)   R*   (    (    (    s   /usr/lib/python2.7/numbers.pyR   "   s0   				c           B   sÎ   e  Z d  Z d Z e d „  ƒ Z e d „  ƒ Z d „  Z d „  Z e d „  ƒ Z	 e d „  ƒ Z
 e d „  ƒ Z e d „  ƒ Z e d	 „  ƒ Z e d
 „  ƒ Z d „  Z e d „  ƒ Z e d „  ƒ Z d „  Z RS(   sÜ   To Complex, Real adds the operations that work on real numbers.

    In short, those are: a conversion to float, trunc(), divmod,
    %, <, <=, >, and >=.

    Real also provides defaults for the derived operations.
    c         C   s
   t  ‚ d S(   sT   Any Real can be converted to a native float object.

        Called for float(self).N(   R   (   R   (    (    s   /usr/lib/python2.7/numbers.pyt	   __float__´   s    c         C   s
   t  ‚ d S(   sG  trunc(self): Truncates self to an Integral.

        Returns an Integral i such that:
          * i>0 iff self>0;
          * abs(i) <= abs(self);
          * for any Integral j satisfying the first two conditions,
            abs(i) >= abs(j) [i.e. i has "maximal" abs among those].
        i.e. "truncate towards 0".
        N(   R   (   R   (    (    s   /usr/lib/python2.7/numbers.pyt	   __trunc__»   s    c         C   s   |  | |  | f S(   s™   divmod(self, other): The pair (self // other, self % other).

        Sometimes this can be computed faster than the pair of
        operations.
        (    (   R   R   (    (    s   /usr/lib/python2.7/numbers.pyt
   __divmod__È   s    c         C   s   | |  | |  f S(   s™   divmod(other, self): The pair (self // other, self % other).

        Sometimes this can be computed faster than the pair of
        operations.
        (    (   R   R   (    (    s   /usr/lib/python2.7/numbers.pyt   __rdivmod__Ð   s    c         C   s
   t  ‚ d S(   s)   self // other: The floor() of self/other.N(   R   (   R   R   (    (    s   /usr/lib/python2.7/numbers.pyt   __floordiv__Ø   s    c         C   s
   t  ‚ d S(   s)   other // self: The floor() of other/self.N(   R   (   R   R   (    (    s   /usr/lib/python2.7/numbers.pyt   __rfloordiv__Ý   s    c         C   s
   t  ‚ d S(   s   self % otherN(   R   (   R   R   (    (    s   /usr/lib/python2.7/numbers.pyt   __mod__â   s    c         C   s
   t  ‚ d S(   s   other % selfN(   R   (   R   R   (    (    s   /usr/lib/python2.7/numbers.pyt   __rmod__ç   s    c         C   s
   t  ‚ d S(   sR   self < other

        < on Reals defines a total ordering, except perhaps for NaN.N(   R   (   R   R   (    (    s   /usr/lib/python2.7/numbers.pyt   __lt__ì   s    c         C   s
   t  ‚ d S(   s   self <= otherN(   R   (   R   R   (    (    s   /usr/lib/python2.7/numbers.pyt   __le__ó   s    c         C   s   t  t |  ƒ ƒ S(   s(   complex(self) == complex(float(self), 0)(   t   complext   float(   R   (    (    s   /usr/lib/python2.7/numbers.pyR   ù   s    c         C   s   |  
S(   s&   Real numbers are their real component.(    (   R   (    (    s   /usr/lib/python2.7/numbers.pyR   ý   s    c         C   s   d S(   s)   Real numbers have no imaginary component.i    (    (   R   (    (    s   /usr/lib/python2.7/numbers.pyR     s    c         C   s   |  
S(   s   Conjugate is a no-op for Reals.(    (   R   (    (    s   /usr/lib/python2.7/numbers.pyR(     s    (    (   R	   R
   R   R   R   R+   R,   R-   R.   R/   R0   R1   R2   R3   R4   R   t   propertyR   R   R(   (    (    (    s   /usr/lib/python2.7/numbers.pyR   ©   s    			c           B   s;   e  Z d  Z d Z e d „  ƒ Z e d „  ƒ Z d „  Z RS(   s6   .numerator and .denominator should be in lowest terms.c         C   s
   t  ‚ d  S(   N(   R   (   R   (    (    s   /usr/lib/python2.7/numbers.pyt	   numerator  s    c         C   s
   t  ‚ d  S(   N(   R   (   R   (    (    s   /usr/lib/python2.7/numbers.pyt   denominator  s    c         C   s   |  j  |  j S(   s  float(self) = self.numerator / self.denominator

        It's important that this conversion use the integer's "true"
        division rather than casting one side to float before dividing
        so that ratios of huge integers convert without overflowing.

        (   R8   R9   (   R   (    (    s   /usr/lib/python2.7/numbers.pyR+     s    (    (   R	   R
   R   R   R   R8   R9   R+   (    (    (    s   /usr/lib/python2.7/numbers.pyR     s
   c           B   s
  e  Z d  Z d Z e d „  ƒ Z d „  Z e d d „ ƒ Z e d „  ƒ Z	 e d „  ƒ Z
 e d „  ƒ Z e d „  ƒ Z e d „  ƒ Z e d	 „  ƒ Z e d
 „  ƒ Z e d „  ƒ Z e d „  ƒ Z e d „  ƒ Z e d „  ƒ Z d „  Z e d „  ƒ Z e d „  ƒ Z RS(   sA   Integral adds a conversion to long and the bit-string operations.c         C   s
   t  ‚ d S(   s
   long(self)N(   R   (   R   (    (    s   /usr/lib/python2.7/numbers.pyt   __long__,  s    c         C   s
   t  |  ƒ S(   s6   Called whenever an index is needed, such as in slicing(   t   long(   R   (    (    s   /usr/lib/python2.7/numbers.pyt	   __index__1  s    c         C   s
   t  ‚ d S(   s4  self ** exponent % modulus, but maybe faster.

        Accept the modulus argument if you want to support the
        3-argument version of pow(). Raise a TypeError if exponent < 0
        or any argument isn't Integral. Otherwise, just implement the
        2-argument version described in Complex.
        N(   R   (   R   R#   t   modulus(    (    s   /usr/lib/python2.7/numbers.pyR$   5  s    	c         C   s
   t  ‚ d S(   s   self << otherN(   R   (   R   R   (    (    s   /usr/lib/python2.7/numbers.pyt
   __lshift__@  s    c         C   s
   t  ‚ d S(   s   other << selfN(   R   (   R   R   (    (    s   /usr/lib/python2.7/numbers.pyt   __rlshift__E  s    c         C   s
   t  ‚ d S(   s   self >> otherN(   R   (   R   R   (    (    s   /usr/lib/python2.7/numbers.pyt
   __rshift__J  s    c         C   s
   t  ‚ d S(   s   other >> selfN(   R   (   R   R   (    (    s   /usr/lib/python2.7/numbers.pyt   __rrshift__O  s    c         C   s
   t  ‚ d S(   s   self & otherN(   R   (   R   R   (    (    s   /usr/lib/python2.7/numbers.pyt   __and__T  s    c         C   s
   t  ‚ d S(   s   other & selfN(   R   (   R   R   (    (    s   /usr/lib/python2.7/numbers.pyt   __rand__Y  s    c         C   s
   t  ‚ d S(   s   self ^ otherN(   R   (   R   R   (    (    s   /usr/lib/python2.7/numbers.pyt   __xor__^  s    c         C   s
   t  ‚ d S(   s   other ^ selfN(   R   (   R   R   (    (    s   /usr/lib/python2.7/numbers.pyt   __rxor__c  s    c         C   s
   t  ‚ d S(   s   self | otherN(   R   (   R   R   (    (    s   /usr/lib/python2.7/numbers.pyt   __or__h  s    c         C   s
   t  ‚ d S(   s   other | selfN(   R   (   R   R   (    (    s   /usr/lib/python2.7/numbers.pyt   __ror__m  s    c         C   s
   t  ‚ d S(   s   ~selfN(   R   (   R   (    (    s   /usr/lib/python2.7/numbers.pyt
   __invert__r  s    c         C   s   t  t |  ƒ ƒ S(   s    float(self) == float(long(self))(   R6   R;   (   R   (    (    s   /usr/lib/python2.7/numbers.pyR+   x  s    c         C   s   |  
S(   s"   Integers are their own numerators.(    (   R   (    (    s   /usr/lib/python2.7/numbers.pyR8   |  s    c         C   s   d S(   s!   Integers have a denominator of 1.i   (    (   R   (    (    s   /usr/lib/python2.7/numbers.pyR9     s    (    N(   R	   R
   R   R   R   R:   R<   R   R$   R>   R?   R@   RA   RB   RC   RD   RE   RF   RG   RH   R+   R7   R8   R9   (    (    (    s   /usr/lib/python2.7/numbers.pyR   '  s(   	
	N(   R   t
   __future__R    t   abcR   R   R   t   __all__t   objectR   R   t   registerR5   R   R6   R   R   t   intR;   (    (    (    s   /usr/lib/python2.7/numbers.pyt   <module>   s   „b_                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
"""
opcode module - potentially shared between dis and other modules which
operate on bytecodes (e.g. peephole optimizers).
"""

__all__ = ["cmp_op", "hasconst", "hasname", "hasjrel", "hasjabs",
           "haslocal", "hascompare", "hasfree", "opname", "opmap",
           "HAVE_ARGUMENT", "EXTENDED_ARG"]

cmp_op = ('<', '<=', '==', '!=', '>', '>=', 'in', 'not in', 'is',
        'is not', 'exception match', 'BAD')

hasconst = []
hasname = []
hasjrel = []
hasjabs = []
haslocal = []
hascompare = []
hasfree = []

opmap = {}
opname = [''] * 256
for op in range(256): opname[op] = '<%r>' % (op,)
del op

def def_op(name, op):
    opname[op] = name
    opmap[name] = op

def name_op(name, op):
    def_op(name, op)
    hasname.append(op)

def jrel_op(name, op):
    def_op(name, op)
    hasjrel.append(op)

def jabs_op(name, op):
    def_op(name, op)
    hasjabs.append(op)

# Instruction opcodes for compiled code
# Blank lines correspond to available opcodes

def_op('STOP_CODE', 0)
def_op('POP_TOP', 1)
def_op('ROT_TWO', 2)
def_op('ROT_THREE', 3)
def_op('DUP_TOP', 4)
def_op('ROT_FOUR', 5)

def_op('NOP', 9)
def_op('UNARY_POSITIVE', 10)
def_op('UNARY_NEGATIVE', 11)
def_op('UNARY_NOT', 12)
def_op('UNARY_CONVERT', 13)

def_op('UNARY_INVERT', 15)

def_op('BINARY_POWER', 19)
def_op('BINARY_MULTIPLY', 20)
def_op('BINARY_DIVIDE', 21)
def_op('BINARY_MODULO', 22)
def_op('BINARY_ADD', 23)
def_op('BINARY_SUBTRACT', 24)
def_op('BINARY_SUBSCR', 25)
def_op('BINARY_FLOOR_DIVIDE', 26)
def_op('BINARY_TRUE_DIVIDE', 27)
def_op('INPLACE_FLOOR_DIVIDE', 28)
def_op('INPLACE_TRUE_DIVIDE', 29)
def_op('SLICE+0', 30)
def_op('SLICE+1', 31)
def_op('SLICE+2', 32)
def_op('SLICE+3', 33)

def_op('STORE_SLICE+0', 40)
def_op('STORE_SLICE+1', 41)
def_op('STORE_SLICE+2', 42)
def_op('STORE_SLICE+3', 43)

def_op('DELETE_SLICE+0', 50)
def_op('DELETE_SLICE+1', 51)
def_op('DELETE_SLICE+2', 52)
def_op('DELETE_SLICE+3', 53)

def_op('STORE_MAP', 54)
def_op('INPLACE_ADD', 55)
def_op('INPLACE_SUBTRACT', 56)
def_op('INPLACE_MULTIPLY', 57)
def_op('INPLACE_DIVIDE', 58)
def_op('INPLACE_MODULO', 59)
def_op('STORE_SUBSCR', 60)
def_op('DELETE_SUBSCR', 61)
def_op('BINARY_LSHIFT', 62)
def_op('BINARY_RSHIFT', 63)
def_op('BINARY_AND', 64)
def_op('BINARY_XOR', 65)
def_op('BINARY_OR', 66)
def_op('INPLACE_POWER', 67)
def_op('GET_ITER', 68)

def_op('PRINT_EXPR', 70)
def_op('PRINT_ITEM', 71)
def_op('PRINT_NEWLINE', 72)
def_op('PRINT_ITEM_TO', 73)
def_op('PRINT_NEWLINE_TO', 74)
def_op('INPLACE_LSHIFT', 75)
def_op('INPLACE_RSHIFT', 76)
def_op('INPLACE_AND', 77)
def_op('INPLACE_XOR', 78)
def_op('INPLACE_OR', 79)
def_op('BREAK_LOOP', 80)
def_op('WITH_CLEANUP', 81)
def_op('LOAD_LOCALS', 82)
def_op('RETURN_VALUE', 83)
def_op('IMPORT_STAR', 84)
def_op('EXEC_STMT', 85)
def_op('YIELD_VALUE', 86)
def_op('POP_BLOCK', 87)
def_op('END_FINALLY', 88)
def_op('BUILD_CLASS', 89)

HAVE_ARGUMENT = 90              # Opcodes from here have an argument:

name_op('STORE_NAME', 90)       # Index in name list
name_op('DELETE_NAME', 91)      # ""
def_op('UNPACK_SEQUENCE', 92)   # Number of tuple items
jrel_op('FOR_ITER', 93)
def_op('LIST_APPEND', 94)
name_op('STORE_ATTR', 95)       # Index in name list
name_op('DELETE_ATTR', 96)      # ""
name_op('STORE_GLOBAL', 97)     # ""
name_op('DELETE_GLOBAL', 98)    # ""
def_op('DUP_TOPX', 99)          # number of items to duplicate
def_op('LOAD_CONST', 100)       # Index in const list
hasconst.append(100)
name_op('LOAD_NAME', 101)       # Index in name list
def_op('BUILD_TUPLE', 102)      # Number of tuple items
def_op('BUILD_LIST', 103)       # Number of list items
def_op('BUILD_SET', 104)        # Number of set items
def_op('BUILD_MAP', 105)        # Number of dict entries (upto 255)
name_op('LOAD_ATTR', 106)       # Index in name list
def_op('COMPARE_OP', 107)       # Comparison operator
hascompare.append(107)
name_op('IMPORT_NAME', 108)     # Index in name list
name_op('IMPORT_FROM', 109)     # Index in name list
jrel_op('JUMP_FORWARD', 110)    # Number of bytes to skip
jabs_op('JUMP_IF_FALSE_OR_POP', 111) # Target byte offset from beginning of code
jabs_op('JUMP_IF_TRUE_OR_POP', 112)  # ""
jabs_op('JUMP_ABSOLUTE', 113)        # ""
jabs_op('POP_JUMP_IF_FALSE', 114)    # ""
jabs_op('POP_JUMP_IF_TRUE', 115)     # ""

name_op('LOAD_GLOBAL', 116)     # Index in name list

jabs_op('CONTINUE_LOOP', 119)   # Target address
jrel_op('SETUP_LOOP', 120)      # Distance to target address
jrel_op('SETUP_EXCEPT', 121)    # ""
jrel_op('SETUP_FINALLY', 122)   # ""

def_op('LOAD_FAST', 124)        # Local variable number
haslocal.append(124)
def_op('STORE_FAST', 125)       # Local variable number
haslocal.append(125)
def_op('DELETE_FAST', 126)      # Local variable number
haslocal.append(126)

def_op('RAISE_VARARGS', 130)    # Number of raise arguments (1, 2, or 3)
def_op('CALL_FUNCTION', 131)    # #args + (#kwargs << 8)
def_op('MAKE_FUNCTION', 132)    # Number of args with default values
def_op('BUILD_SLICE', 133)      # Number of items
def_op('MAKE_CLOSURE', 134)
def_op('LOAD_CLOSURE', 135)
hasfree.append(135)
def_op('LOAD_DEREF', 136)
hasfree.append(136)
def_op('STORE_DEREF', 137)
hasfree.append(137)

def_op('CALL_FUNCTION_VAR', 140)     # #args + (#kwargs << 8)
def_op('CALL_FUNCTION_KW', 141)      # #args + (#kwargs << 8)
def_op('CALL_FUNCTION_VAR_KW', 142)  # #args + (#kwargs << 8)

jrel_op('SETUP_WITH', 143)

def_op('EXTENDED_ARG', 145)
EXTENDED_ARG = 145
def_op('SET_ADD', 146)
def_op('MAP_ADD', 147)

del def_op, name_op, jrel_op, jabs_op
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ó
Ó«[c           @   sQ  d  Z  d d d d d d d d d	 d
 d d g Z dZ g  Z g  Z g  Z g  Z g  Z g  Z g  Z	 i  Z
 d g d Z x% e d ƒ D] Z d e f e e <q€ W[ d „  Z d „  Z d „  Z d „  Z e d  d! ƒ e d" d# ƒ e d$ d% ƒ e d& d' ƒ e d( d) ƒ e d* d+ ƒ e d, d- ƒ e d. d/ ƒ e d0 d1 ƒ e d2 d3 ƒ e d4 d5 ƒ e d6 d7 ƒ e d8 d9 ƒ e d: d; ƒ e d< d= ƒ e d> d? ƒ e d@ dA ƒ e dB dC ƒ e dD dE ƒ e dF dG ƒ e dH dI ƒ e dJ dK ƒ e dL dM ƒ e dN dO ƒ e dP dQ ƒ e dR dS ƒ e dT dU ƒ e dV dW ƒ e dX dY ƒ e dZ d[ ƒ e d\ d] ƒ e d^ d_ ƒ e d` da ƒ e db dc ƒ e dd de ƒ e df dg ƒ e dh di ƒ e dj dk ƒ e dl dm ƒ e dn do ƒ e dp dq ƒ e dr ds ƒ e dt du ƒ e dv dw ƒ e dx dy ƒ e dz d{ ƒ e d| d} ƒ e d~ d ƒ e d€ d ƒ e d‚ dƒ ƒ e d„ d… ƒ e d† d‡ ƒ e dˆ d‰ ƒ e dŠ d‹ ƒ e dŒ d ƒ e dŽ d ƒ e d d‘ ƒ e d’ d“ ƒ e d” d• ƒ e d– d— ƒ e d˜ d™ ƒ e dš d› ƒ e dœ d ƒ e dž dŸ ƒ e d  d¡ ƒ e d¢ d£ ƒ e d¤ d¥ ƒ e d¦ d§ ƒ e d¨ d© ƒ e dª d« ƒ d¬ Z e d­ d¬ ƒ e d® d¯ ƒ e d° d± ƒ e d² d³ ƒ e d´ dµ ƒ e d¶ d· ƒ e d¸ d¹ ƒ e dº d» ƒ e d¼ d½ ƒ e d¾ d¿ ƒ e dÀ dÁ ƒ e j dÁ ƒ e dÂ dÃ ƒ e dÄ dÅ ƒ e dÆ dÇ ƒ e dÈ dÉ ƒ e dÊ dË ƒ e dÌ dÍ ƒ e dÎ dÏ ƒ e j dÏ ƒ e dÐ dÑ ƒ e dÒ dÓ ƒ e dÔ dÕ ƒ e dÖ d× ƒ e dØ dÙ ƒ e dÚ dÛ ƒ e dÜ dÝ ƒ e dÞ dß ƒ e dà dá ƒ e dâ dã ƒ e dä då ƒ e dæ dç ƒ e dè dé ƒ e dê dë ƒ e j dë ƒ e dì dí ƒ e j dí ƒ e dî dï ƒ e j dï ƒ e dð dñ ƒ e dò dó ƒ e dô dõ ƒ e dö d÷ ƒ e dø dù ƒ e dú dû ƒ e	 j dû ƒ e dü dý ƒ e	 j dý ƒ e dþ dÿ ƒ e	 j dÿ ƒ e d dƒ e ddƒ e ddƒ e ddƒ e d dƒ dZ e d	d
ƒ e ddƒ [ [ [ [ dS(  sy   
opcode module - potentially shared between dis and other modules which
operate on bytecodes (e.g. peephole optimizers).
t   cmp_opt   hasconstt   hasnamet   hasjrelt   hasjabst   haslocalt
   hascomparet   hasfreet   opnamet   opmapt   HAVE_ARGUMENTt   EXTENDED_ARGt   <s   <=s   ==s   !=t   >s   >=t   ins   not int   iss   is nots   exception matcht   BADt    i   s   <%r>c         C   s   |  t  | <| t |  <d  S(   N(   R   R	   (   t   namet   op(    (    s   /usr/lib/python2.7/opcode.pyt   def_op   s    
c         C   s   t  |  | ƒ t j | ƒ d  S(   N(   R   R   t   append(   R   R   (    (    s   /usr/lib/python2.7/opcode.pyt   name_op   s    c         C   s   t  |  | ƒ t j | ƒ d  S(   N(   R   R   R   (   R   R   (    (    s   /usr/lib/python2.7/opcode.pyt   jrel_op#   s    c         C   s   t  |  | ƒ t j | ƒ d  S(   N(   R   R   R   (   R   R   (    (    s   /usr/lib/python2.7/opcode.pyt   jabs_op'   s    t	   STOP_CODEi    t   POP_TOPi   t   ROT_TWOi   t	   ROT_THREEi   t   DUP_TOPi   t   ROT_FOURi   t   NOPi	   t   UNARY_POSITIVEi
   t   UNARY_NEGATIVEi   t	   UNARY_NOTi   t   UNARY_CONVERTi   t   UNARY_INVERTi   t   BINARY_POWERi   t   BINARY_MULTIPLYi   t   BINARY_DIVIDEi   t   BINARY_MODULOi   t
   BINARY_ADDi   t   BINARY_SUBTRACTi   t   BINARY_SUBSCRi   t   BINARY_FLOOR_DIVIDEi   t   BINARY_TRUE_DIVIDEi   t   INPLACE_FLOOR_DIVIDEi   t   INPLACE_TRUE_DIVIDEi   s   SLICE+0i   s   SLICE+1i   s   SLICE+2i    s   SLICE+3i!   s   STORE_SLICE+0i(   s   STORE_SLICE+1i)   s   STORE_SLICE+2i*   s   STORE_SLICE+3i+   s   DELETE_SLICE+0i2   s   DELETE_SLICE+1i3   s   DELETE_SLICE+2i4   s   DELETE_SLICE+3i5   t	   STORE_MAPi6   t   INPLACE_ADDi7   t   INPLACE_SUBTRACTi8   t   INPLACE_MULTIPLYi9   t   INPLACE_DIVIDEi:   t   INPLACE_MODULOi;   t   STORE_SUBSCRi<   t   DELETE_SUBSCRi=   t   BINARY_LSHIFTi>   t   BINARY_RSHIFTi?   t
   BINARY_ANDi@   t
   BINARY_XORiA   t	   BINARY_ORiB   t   INPLACE_POWERiC   t   GET_ITERiD   t
   PRINT_EXPRiF   t
   PRINT_ITEMiG   t   PRINT_NEWLINEiH   t   PRINT_ITEM_TOiI   t   PRINT_NEWLINE_TOiJ   t   INPLACE_LSHIFTiK   t   INPLACE_RSHIFTiL   t   INPLACE_ANDiM   t   INPLACE_XORiN   t
   INPLACE_ORiO   t
   BREAK_LOOPiP   t   WITH_CLEANUPiQ   t   LOAD_LOCALSiR   t   RETURN_VALUEiS   t   IMPORT_STARiT   t	   EXEC_STMTiU   t   YIELD_VALUEiV   t	   POP_BLOCKiW   t   END_FINALLYiX   t   BUILD_CLASSiY   iZ   t
   STORE_NAMEt   DELETE_NAMEi[   t   UNPACK_SEQUENCEi\   t   FOR_ITERi]   t   LIST_APPENDi^   t
   STORE_ATTRi_   t   DELETE_ATTRi`   t   STORE_GLOBALia   t   DELETE_GLOBALib   t   DUP_TOPXic   t
   LOAD_CONSTid   t	   LOAD_NAMEie   t   BUILD_TUPLEif   t
   BUILD_LISTig   t	   BUILD_SETih   t	   BUILD_MAPii   t	   LOAD_ATTRij   t
   COMPARE_OPik   t   IMPORT_NAMEil   t   IMPORT_FROMim   t   JUMP_FORWARDin   t   JUMP_IF_FALSE_OR_POPio   t   JUMP_IF_TRUE_OR_POPip   t   JUMP_ABSOLUTEiq   t   POP_JUMP_IF_FALSEir   t   POP_JUMP_IF_TRUEis   t   LOAD_GLOBALit   t   CONTINUE_LOOPiw   t
   SETUP_LOOPix   t   SETUP_EXCEPTiy   t   SETUP_FINALLYiz   t	   LOAD_FASTi|   t
   STORE_FASTi}   t   DELETE_FASTi~   t   RAISE_VARARGSi‚   t   CALL_FUNCTIONiƒ   t   MAKE_FUNCTIONi„   t   BUILD_SLICEi…   t   MAKE_CLOSUREi†   t   LOAD_CLOSUREi‡   t
   LOAD_DEREFiˆ   t   STORE_DEREFi‰   t   CALL_FUNCTION_VARiŒ   t   CALL_FUNCTION_KWi   t   CALL_FUNCTION_VAR_KWiŽ   t
   SETUP_WITHi   i‘   t   SET_ADDi’   t   MAP_ADDi“   N(   R   s   <=s   ==s   !=R   s   >=R   s   not inR   s   is nots   exception matchR   (   t   __doc__t   __all__R    R   R   R   R   R   R   R   R	   R   t   rangeR   R   R   R   R   R
   R   R   (    (    (    s   /usr/lib/python2.7/opcode.pyt   <module>   s.    				                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         """A powerful, extensible, and easy-to-use option parser.

By Greg Ward <gward@python.net>

Originally distributed as Optik.

For support, use the optik-users@lists.sourceforge.net mailing list
(http://lists.sourceforge.net/lists/listinfo/optik-users).

Simple usage example:

   from optparse import OptionParser

   parser = OptionParser()
   parser.add_option("-f", "--file", dest="filename",
                     help="write report to FILE", metavar="FILE")
   parser.add_option("-q", "--quiet",
                     action="store_false", dest="verbose", default=True,
                     help="don't print status messages to stdout")

   (options, args) = parser.parse_args()
"""

__version__ = "1.5.3"

__all__ = ['Option',
           'make_option',
           'SUPPRESS_HELP',
           'SUPPRESS_USAGE',
           'Values',
           'OptionContainer',
           'OptionGroup',
           'OptionParser',
           'HelpFormatter',
           'IndentedHelpFormatter',
           'TitledHelpFormatter',
           'OptParseError',
           'OptionError',
           'OptionConflictError',
           'OptionValueError',
           'BadOptionError']

__copyright__ = """
Copyright (c) 2001-2006 Gregory P. Ward.  All rights reserved.
Copyright (c) 2002-2006 Python Software Foundation.  All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

  * Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

  * Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the
    documentation and/or other materials provided with the distribution.

  * Neither the name of the author nor the names of its
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
"""

import sys, os
import types
import textwrap

def _repr(self):
    return "<%s at 0x%x: %s>" % (self.__class__.__name__, id(self), self)


# This file was generated from:
#   Id: option_parser.py 527 2006-07-23 15:21:30Z greg
#   Id: option.py 522 2006-06-11 16:22:03Z gward
#   Id: help.py 527 2006-07-23 15:21:30Z greg
#   Id: errors.py 509 2006-04-20 00:58:24Z gward

try:
    from gettext import gettext
except ImportError:
    def gettext(message):
        return message
_ = gettext


class OptParseError (Exception):
    def __init__(self, msg):
        self.msg = msg

    def __str__(self):
        return self.msg


class OptionError (OptParseError):
    """
    Raised if an Option instance is created with invalid or
    inconsistent arguments.
    """

    def __init__(self, msg, option):
        self.msg = msg
        self.option_id = str(option)

    def __str__(self):
        if self.option_id:
            return "option %s: %s" % (self.option_id, self.msg)
        else:
            return self.msg

class OptionConflictError (OptionError):
    """
    Raised if conflicting options are added to an OptionParser.
    """

class OptionValueError (OptParseError):
    """
    Raised if an invalid option value is encountered on the command
    line.
    """

class BadOptionError (OptParseError):
    """
    Raised if an invalid option is seen on the command line.
    """
    def __init__(self, opt_str):
        self.opt_str = opt_str

    def __str__(self):
        return _("no such option: %s") % self.opt_str

class AmbiguousOptionError (BadOptionError):
    """
    Raised if an ambiguous option is seen on the command line.
    """
    def __init__(self, opt_str, possibilities):
        BadOptionError.__init__(self, opt_str)
        self.possibilities = possibilities

    def __str__(self):
        return (_("ambiguous option: %s (%s?)")
                % (self.opt_str, ", ".join(self.possibilities)))


class HelpFormatter:

    """
    Abstract base class for formatting option help.  OptionParser
    instances should use one of the HelpFormatter subclasses for
    formatting help; by default IndentedHelpFormatter is used.

    Instance attributes:
      parser : OptionParser
        the controlling OptionParser instance
      indent_increment : int
        the number of columns to indent per nesting level
      max_help_position : int
        the maximum starting column for option help text
      help_position : int
        the calculated starting column for option help text;
        initially the same as the maximum
      width : int
        total number of columns for output (pass None to constructor for
        this value to be taken from the $COLUMNS environment variable)
      level : int
        current indentation level
      current_indent : int
        current indentation level (in columns)
      help_width : int
        number of columns available for option help text (calculated)
      default_tag : str
        text to replace with each option's default value, "%default"
        by default.  Set to false value to disable default value expansion.
      option_strings : { Option : str }
        maps Option instances to the snippet of help text explaining
        the syntax of that option, e.g. "-h, --help" or
        "-fFILE, --file=FILE"
      _short_opt_fmt : str
        format string controlling how short options with values are
        printed in help text.  Must be either "%s%s" ("-fFILE") or
        "%s %s" ("-f FILE"), because those are the two syntaxes that
        Optik supports.
      _long_opt_fmt : str
        similar but for long options; must be either "%s %s" ("--file FILE")
        or "%s=%s" ("--file=FILE").
    """

    NO_DEFAULT_VALUE = "none"

    def __init__(self,
                 indent_increment,
                 max_help_position,
                 width,
                 short_first):
        self.parser = None
        self.indent_increment = indent_increment
        if width is None:
            try:
                width = int(os.environ['COLUMNS'])
            except (KeyError, ValueError):
                width = 80
            width -= 2
        self.width = width
        self.help_position = self.max_help_position = \
                min(max_help_position, max(width - 20, indent_increment * 2))
        self.current_indent = 0
        self.level = 0
        self.help_width = None          # computed later
        self.short_first = short_first
        self.default_tag = "%default"
        self.option_strings = {}
        self._short_opt_fmt = "%s %s"
        self._long_opt_fmt = "%s=%s"

    def set_parser(self, parser):
        self.parser = parser

    def set_short_opt_delimiter(self, delim):
        if delim not in ("", " "):
            raise ValueError(
                "invalid metavar delimiter for short options: %r" % delim)
        self._short_opt_fmt = "%s" + delim + "%s"

    def set_long_opt_delimiter(self, delim):
        if delim not in ("=", " "):
            raise ValueError(
                "invalid metavar delimiter for long options: %r" % delim)
        self._long_opt_fmt = "%s" + delim + "%s"

    def indent(self):
        self.current_indent += self.indent_increment
        self.level += 1

    def dedent(self):
        self.current_indent -= self.indent_increment
        assert self.current_indent >= 0, "Indent decreased below 0."
        self.level -= 1

    def format_usage(self, usage):
        raise NotImplementedError, "subclasses must implement"

    def format_heading(self, heading):
        raise NotImplementedError, "subclasses must implement"

    def _format_text(self, text):
        """
        Format a paragraph of free-form text for inclusion in the
        help output at the current indentation level.
        """
        text_width = max(self.width - self.current_indent, 11)
        indent = " "*self.current_indent
        return textwrap.fill(text,
                             text_width,
                             initial_indent=indent,
                             subsequent_indent=indent)

    def format_description(self, description):
        if description:
            return self._format_text(description) + "\n"
        else:
            return ""

    def format_epilog(self, epilog):
        if epilog:
            return "\n" + self._format_text(epilog) + "\n"
        else:
            return ""


    def expand_default(self, option):
        if self.parser is None or not self.default_tag:
            return option.help

        default_value = self.parser.defaults.get(option.dest)
        if default_value is NO_DEFAULT or default_value is None:
            default_value = self.NO_DEFAULT_VALUE

        return option.help.replace(self.default_tag, str(default_value))

    def format_option(self, option):
        # The help for each option consists of two parts:
        #   * the opt strings and metavars
        #     eg. ("-x", or "-fFILENAME, --file=FILENAME")
        #   * the user-supplied help string
        #     eg. ("turn on expert mode", "read data from FILENAME")
        #
        # If possible, we write both of these on the same line:
        #   -x      turn on expert mode
        #
        # But if the opt string list is too long, we put the help
        # string on a second line, indented to the same column it would
        # start in if it fit on the first line.
        #   -fFILENAME, --file=FILENAME
        #           read data from FILENAME
        result = []
        opts = self.option_strings[option]
        opt_width = self.help_position - self.current_indent - 2
        if len(opts) > opt_width:
            opts = "%*s%s\n" % (self.current_indent, "", opts)
            indent_first = self.help_position
        else:                       # start help on same line as opts
            opts = "%*s%-*s  " % (self.current_indent, "", opt_width, opts)
            indent_first = 0
        result.append(opts)
        if option.help:
            help_text = self.expand_default(option)
            help_lines = textwrap.wrap(help_text, self.help_width)
            result.append("%*s%s\n" % (indent_first, "", help_lines[0]))
            result.extend(["%*s%s\n" % (self.help_position, "", line)
                           for line in help_lines[1:]])
        elif opts[-1] != "\n":
            result.append("\n")
        return "".join(result)

    def store_option_strings(self, parser):
        self.indent()
        max_len = 0
        for opt in parser.option_list:
            strings = self.format_option_strings(opt)
            self.option_strings[opt] = strings
            max_len = max(max_len, len(strings) + self.current_indent)
        self.indent()
        for group in parser.option_groups:
            for opt in group.option_list:
                strings = self.format_option_strings(opt)
                self.option_strings[opt] = strings
                max_len = max(max_len, len(strings) + self.current_indent)
        self.dedent()
        self.dedent()
        self.help_position = min(max_len + 2, self.max_help_position)
        self.help_width = max(self.width - self.help_position, 11)

    def format_option_strings(self, option):
        """Return a comma-separated list of option strings & metavariables."""
        if option.takes_value():
            metavar = option.metavar or option.dest.upper()
            short_opts = [self._short_opt_fmt % (sopt, metavar)
                          for sopt in option._short_opts]
            long_opts = [self._long_opt_fmt % (lopt, metavar)
                         for lopt in option._long_opts]
        else:
            short_opts = option._short_opts
            long_opts = option._long_opts

        if self.short_first:
            opts = short_opts + long_opts
        else:
            opts = long_opts + short_opts

        return ", ".join(opts)

class IndentedHelpFormatter (HelpFormatter):
    """Format help with indented section bodies.
    """

    def __init__(self,
                 indent_increment=2,
                 max_help_position=24,
                 width=None,
                 short_first=1):
        HelpFormatter.__init__(
            self, indent_increment, max_help_position, width, short_first)

    def format_usage(self, usage):
        return _("Usage: %s\n") % usage

    def format_heading(self, heading):
        return "%*s%s:\n" % (self.current_indent, "", heading)


class TitledHelpFormatter (HelpFormatter):
    """Format help with underlined section headers.
    """

    def __init__(self,
                 indent_increment=0,
                 max_help_position=24,
                 width=None,
                 short_first=0):
        HelpFormatter.__init__ (
            self, indent_increment, max_help_position, width, short_first)

    def format_usage(self, usage):
        return "%s  %s\n" % (self.format_heading(_("Usage")), usage)

    def format_heading(self, heading):
        return "%s\n%s\n" % (heading, "=-"[self.level] * len(heading))


def _parse_num(val, type):
    if val[:2].lower() == "0x":         # hexadecimal
        radix = 16
    elif val[:2].lower() == "0b":       # binary
        radix = 2
        val = val[2:] or "0"            # have to remove "0b" prefix
    elif val[:1] == "0":                # octal
        radix = 8
    else:                               # decimal
        radix = 10

    return type(val, radix)

def _parse_int(val):
    return _parse_num(val, int)

def _parse_long(val):
    return _parse_num(val, long)

_builtin_cvt = { "int" : (_parse_int, _("integer")),
                 "long" : (_parse_long, _("long integer")),
                 "float" : (float, _("floating-point")),
                 "complex" : (complex, _("complex")) }

def check_builtin(option, opt, value):
    (cvt, what) = _builtin_cvt[option.type]
    try:
        return cvt(value)
    except ValueError:
        raise OptionValueError(
            _("option %s: invalid %s value: %r") % (opt, what, value))

def check_choice(option, opt, value):
    if value in option.choices:
        return value
    else:
        choices = ", ".join(map(repr, option.choices))
        raise OptionValueError(
            _("option %s: invalid choice: %r (choose from %s)")
            % (opt, value, choices))

# Not supplying a default is different from a default of None,
# so we need an explicit "not supplied" value.
NO_DEFAULT = ("NO", "DEFAULT")


class Option:
    """
    Instance attributes:
      _short_opts : [string]
      _long_opts : [string]

      action : string
      type : string
      dest : string
      default : any
      nargs : int
      const : any
      choices : [string]
      callback : function
      callback_args : (any*)
      callback_kwargs : { string : any }
      help : string
      metavar : string
    """

    # The list of instance attributes that may be set through
    # keyword args to the constructor.
    ATTRS = ['action',
             'type',
             'dest',
             'default',
             'nargs',
             'const',
             'choices',
             'callback',
             'callback_args',
             'callback_kwargs',
             'help',
             'metavar']

    # The set of actions allowed by option parsers.  Explicitly listed
    # here so the constructor can validate its arguments.
    ACTIONS = ("store",
               "store_const",
               "store_true",
               "store_false",
               "append",
               "append_const",
               "count",
               "callback",
               "help",
               "version")

    # The set of actions that involve storing a value somewhere;
    # also listed just for constructor argument validation.  (If
    # the action is one of these, there must be a destination.)
    STORE_ACTIONS = ("store",
                     "store_const",
                     "store_true",
                     "store_false",
                     "append",
                     "append_const",
                     "count")

    # The set of actions for which it makes sense to supply a value
    # type, ie. which may consume an argument from the command line.
    TYPED_ACTIONS = ("store",
                     "append",
                     "callback")

    # The set of actions which *require* a value type, ie. that
    # always consume an argument from the command line.
    ALWAYS_TYPED_ACTIONS = ("store",
                            "append")

    # The set of actions which take a 'const' attribute.
    CONST_ACTIONS = ("store_const",
                     "append_const")

    # The set of known types for option parsers.  Again, listed here for
    # constructor argument validation.
    TYPES = ("string", "int", "long", "float", "complex", "choice")

    # Dictionary of argument checking functions, which convert and
    # validate option arguments according to the option type.
    #
    # Signature of checking functions is:
    #   check(option : Option, opt : string, value : string) -> any
    # where
    #   option is the Option instance calling the checker
    #   opt is the actual option seen on the command-line
    #     (eg. "-a", "--file")
    #   value is the option argument seen on the command-line
    #
    # The return value should be in the appropriate Python type
    # for option.type -- eg. an integer if option.type == "int".
    #
    # If no checker is defined for a type, arguments will be
    # unchecked and remain strings.
    TYPE_CHECKER = { "int"    : check_builtin,
                     "long"   : check_builtin,
                     "float"  : check_builtin,
                     "complex": check_builtin,
                     "choice" : check_choice,
                   }


    # CHECK_METHODS is a list of unbound method objects; they are called
    # by the constructor, in order, after all attributes are
    # initialized.  The list is created and filled in later, after all
    # the methods are actually defined.  (I just put it here because I
    # like to define and document all class attributes in the same
    # place.)  Subclasses that add another _check_*() method should
    # define their own CHECK_METHODS list that adds their check method
    # to those from this class.
    CHECK_METHODS = None


    # -- Constructor/initialization methods ----------------------------

    def __init__(self, *opts, **attrs):
        # Set _short_opts, _long_opts attrs from 'opts' tuple.
        # Have to be set now, in case no option strings are supplied.
        self._short_opts = []
        self._long_opts = []
        opts = self._check_opt_strings(opts)
        self._set_opt_strings(opts)

        # Set all other attrs (action, type, etc.) from 'attrs' dict
        self._set_attrs(attrs)

        # Check all the attributes we just set.  There are lots of
        # complicated interdependencies, but luckily they can be farmed
        # out to the _check_*() methods listed in CHECK_METHODS -- which
        # could be handy for subclasses!  The one thing these all share
        # is that they raise OptionError if they discover a problem.
        for checker in self.CHECK_METHODS:
            checker(self)

    def _check_opt_strings(self, opts):
        # Filter out None because early versions of Optik had exactly
        # one short option and one long option, either of which
        # could be None.
        opts = filter(None, opts)
        if not opts:
            raise TypeError("at least one option string must be supplied")
        return opts

    def _set_opt_strings(self, opts):
        for opt in opts:
            if len(opt) < 2:
                raise OptionError(
                    "invalid option string %r: "
                    "must be at least two characters long" % opt, self)
            elif len(opt) == 2:
                if not (opt[0] == "-" and opt[1] != "-"):
                    raise OptionError(
                        "invalid short option string %r: "
                        "must be of the form -x, (x any non-dash char)" % opt,
                        self)
                self._short_opts.append(opt)
            else:
                if not (opt[0:2] == "--" and opt[2] != "-"):
                    raise OptionError(
                        "invalid long option string %r: "
                        "must start with --, followed by non-dash" % opt,
                        self)
                self._long_opts.append(opt)

    def _set_attrs(self, attrs):
        for attr in self.ATTRS:
            if attr in attrs:
                setattr(self, attr, attrs[attr])
                del attrs[attr]
            else:
                if attr == 'default':
                    setattr(self, attr, NO_DEFAULT)
                else:
                    setattr(self, attr, None)
        if attrs:
            attrs = attrs.keys()
            attrs.sort()
            raise OptionError(
                "invalid keyword arguments: %s" % ", ".join(attrs),
                self)


    # -- Constructor validation methods --------------------------------

    def _check_action(self):
        if self.action is None:
            self.action = "store"
        elif self.action not in self.ACTIONS:
            raise OptionError("invalid action: %r" % self.action, self)

    def _check_type(self):
        if self.type is None:
            if self.action in self.ALWAYS_TYPED_ACTIONS:
                if self.choices is not None:
                    # The "choices" attribute implies "choice" type.
                    self.type = "choice"
                else:
                    # No type given?  "string" is the most sensible default.
                    self.type = "string"
        else:
            # Allow type objects or builtin type conversion functions
            # (int, str, etc.) as an alternative to their names.  (The
            # complicated check of __builtin__ is only necessary for
            # Python 2.1 and earlier, and is short-circuited by the
            # first check on modern Pythons.)
            import __builtin__
            if ( type(self.type) is types.TypeType or
                 (hasattr(self.type, "__name__") and
                  getattr(__builtin__, self.type.__name__, None) is self.type) ):
                self.type = self.type.__name__

            if self.type == "str":
                self.type = "string"

            if self.type not in self.TYPES:
                raise OptionError("invalid option type: %r" % self.type, self)
            if self.action not in self.TYPED_ACTIONS:
                raise OptionError(
                    "must not supply a type for action %r" % self.action, self)

    def _check_choice(self):
        if self.type == "choice":
            if self.choices is None:
                raise OptionError(
                    "must supply a list of choices for type 'choice'", self)
            elif type(self.choices) not in (types.TupleType, types.ListType):
                raise OptionError(
                    "choices must be a list of strings ('%s' supplied)"
                    % str(type(self.choices)).split("'")[1], self)
        elif self.choices is not None:
            raise OptionError(
                "must not supply choices for type %r" % self.type, self)

    def _check_dest(self):
        # No destination given, and we need one for this action.  The
        # self.type check is for callbacks that take a value.
        takes_value = (self.action in self.STORE_ACTIONS or
                       self.type is not None)
        if self.dest is None and takes_value:

            # Glean a destination from the first long option string,
            # or from the first short option string if no long options.
            if self._long_opts:
                # eg. "--foo-bar" -> "foo_bar"
                self.dest = self._long_opts[0][2:].replace('-', '_')
            else:
                self.dest = self._short_opts[0][1]

    def _check_const(self):
        if self.action not in self.CONST_ACTIONS and self.const is not None:
            raise OptionError(
                "'const' must not be supplied for action %r" % self.action,
                self)

    def _check_nargs(self):
        if self.action in self.TYPED_ACTIONS:
            if self.nargs is None:
                self.nargs = 1
        elif self.nargs is not None:
            raise OptionError(
                "'nargs' must not be supplied for action %r" % self.action,
                self)

    def _check_callback(self):
        if self.action == "callback":
            if not hasattr(self.callback, '__call__'):
                raise OptionError(
                    "callback not callable: %r" % self.callback, self)
            if (self.callback_args is not None and
                type(self.callback_args) is not types.TupleType):
                raise OptionError(
                    "callback_args, if supplied, must be a tuple: not %r"
                    % self.callback_args, self)
            if (self.callback_kwargs is not None and
                type(self.callback_kwargs) is not types.DictType):
                raise OptionError(
                    "callback_kwargs, if supplied, must be a dict: not %r"
                    % self.callback_kwargs, self)
        else:
            if self.callback is not None:
                raise OptionError(
                    "callback supplied (%r) for non-callback option"
                    % self.callback, self)
            if self.callback_args is not None:
                raise OptionError(
                    "callback_args supplied for non-callback option", self)
            if self.callback_kwargs is not None:
                raise OptionError(
                    "callback_kwargs supplied for non-callback option", self)


    CHECK_METHODS = [_check_action,
                     _check_type,
                     _check_choice,
                     _check_dest,
                     _check_const,
                     _check_nargs,
                     _check_callback]


    # -- Miscellaneous methods -----------------------------------------

    def __str__(self):
        return "/".join(self._short_opts + self._long_opts)

    __repr__ = _repr

    def takes_value(self):
        return self.type is not None

    def get_opt_string(self):
        if self._long_opts:
            return self._long_opts[0]
        else:
            return self._short_opts[0]


    # -- Processing methods --------------------------------------------

    def check_value(self, opt, value):
        checker = self.TYPE_CHECKER.get(self.type)
        if checker is None:
            return value
        else:
            return checker(self, opt, value)

    def convert_value(self, opt, value):
        if value is not None:
            if self.nargs == 1:
                return self.check_value(opt, value)
            else:
                return tuple([self.check_value(opt, v) for v in value])

    def process(self, opt, value, values, parser):

        # First, convert the value(s) to the right type.  Howl if any
        # value(s) are bogus.
        value = self.convert_value(opt, value)

        # And then take whatever action is expected of us.
        # This is a separate method to make life easier for
        # subclasses to add new actions.
        return self.take_action(
            self.action, self.dest, opt, value, values, parser)

    def take_action(self, action, dest, opt, value, values, parser):
        if action == "store":
            setattr(values, dest, value)
        elif action == "store_const":
            setattr(values, dest, self.const)
        elif action == "store_true":
            setattr(values, dest, True)
        elif action == "store_false":
            setattr(values, dest, False)
        elif action == "append":
            values.ensure_value(dest, []).append(value)
        elif action == "append_const":
            values.ensure_value(dest, []).append(self.const)
        elif action == "count":
            setattr(values, dest, values.ensure_value(dest, 0) + 1)
        elif action == "callback":
            args = self.callback_args or ()
            kwargs = self.callback_kwargs or {}
            self.callback(self, opt, value, parser, *args, **kwargs)
        elif action == "help":
            parser.print_help()
            parser.exit()
        elif action == "version":
            parser.print_version()
            parser.exit()
        else:
            raise ValueError("unknown action %r" % self.action)

        return 1

# class Option


SUPPRESS_HELP = "SUPPRESS"+"HELP"
SUPPRESS_USAGE = "SUPPRESS"+"USAGE"

try:
    basestring
except NameError:
    def isbasestring(x):
        return isinstance(x, (types.StringType, types.UnicodeType))
else:
    def isbasestring(x):
        return isinstance(x, basestring)

class Values:

    def __init__(self, defaults=None):
        if defaults:
            for (attr, val) in defaults.items():
                setattr(self, attr, val)

    def __str__(self):
        return str(self.__dict__)

    __repr__ = _repr

    def __cmp__(self, other):
        if isinstance(other, Values):
            return cmp(self.__dict__, other.__dict__)
        elif isinstance(other, types.DictType):
            return cmp(self.__dict__, other)
        else:
            return -1

    def _update_careful(self, dict):
        """
        Update the option values from an arbitrary dictionary, but only
        use keys from dict that already have a corresponding attribute
        in self.  Any keys in dict without a corresponding attribute
        are silently ignored.
        """
        for attr in dir(self):
            if attr in dict:
                dval = dict[attr]
                if dval is not None:
                    setattr(self, attr, dval)

    def _update_loose(self, dict):
        """
        Update the option values from an arbitrary dictionary,
        using all keys from the dictionary regardless of whether
        they have a corresponding attribute in self or not.
        """
        self.__dict__.update(dict)

    def _update(self, dict, mode):
        if mode == "careful":
            self._update_careful(dict)
        elif mode == "loose":
            self._update_loose(dict)
        else:
            raise ValueError, "invalid update mode: %r" % mode

    def read_module(self, modname, mode="careful"):
        __import__(modname)
        mod = sys.modules[modname]
        self._update(vars(mod), mode)

    def read_file(self, filename, mode="careful"):
        vars = {}
        execfile(filename, vars)
        self._update(vars, mode)

    def ensure_value(self, attr, value):
        if not hasattr(self, attr) or getattr(self, attr) is None:
            setattr(self, attr, value)
        return getattr(self, attr)


class OptionContainer:

    """
    Abstract base class.

    Class attributes:
      standard_option_list : [Option]
        list of standard options that will be accepted by all instances
        of this parser class (intended to be overridden by subclasses).

    Instance attributes:
      option_list : [Option]
        the list of Option objects contained by this OptionContainer
      _short_opt : { string : Option }
        dictionary mapping short option strings, eg. "-f" or "-X",
        to the Option instances that implement them.  If an Option
        has multiple short option strings, it will appear in this
        dictionary multiple times. [1]
      _long_opt : { string : Option }
        dictionary mapping long option strings, eg. "--file" or
        "--exclude", to the Option instances that implement them.
        Again, a given Option can occur multiple times in this
        dictionary. [1]
      defaults : { string : any }
        dictionary mapping option destination names to default
        values for each destination [1]

    [1] These mappings are common to (shared by) all components of the
        controlling OptionParser, where they are initially created.

    """

    def __init__(self, option_class, conflict_handler, description):
        # Initialize the option list and related data structures.
        # This method must be provided by subclasses, and it must
        # initialize at least the following instance attributes:
        # option_list, _short_opt, _long_opt, defaults.
        self._create_option_list()

        self.option_class = option_class
        self.set_conflict_handler(conflict_handler)
        self.set_description(description)

    def _create_option_mappings(self):
        # For use by OptionParser constructor -- create the master
        # option mappings used by this OptionParser and all
        # OptionGroups that it owns.
        self._short_opt = {}            # single letter -> Option instance
        self._long_opt = {}             # long option -> Option instance
        self.defaults = {}              # maps option dest -> default value


    def _share_option_mappings(self, parser):
        # For use by OptionGroup constructor -- use shared option
        # mappings from the OptionParser that owns this OptionGroup.
        self._short_opt = parser._short_opt
        self._long_opt = parser._long_opt
        self.defaults = parser.defaults

    def set_conflict_handler(self, handler):
        if handler not in ("error", "resolve"):
            raise ValueError, "invalid conflict_resolution value %r" % handler
        self.conflict_handler = handler

    def set_description(self, description):
        self.description = description

    def get_description(self):
        return self.description


    def destroy(self):
        """see OptionParser.destroy()."""
        del self._short_opt
        del self._long_opt
        del self.defaults


    # -- Option-adding methods -----------------------------------------

    def _check_conflict(self, option):
        conflict_opts = []
        for opt in option._short_opts:
            if opt in self._short_opt:
                conflict_opts.append((opt, self._short_opt[opt]))
        for opt in option._long_opts:
            if opt in self._long_opt:
                conflict_opts.append((opt, self._long_opt[opt]))

        if conflict_opts:
            handler = self.conflict_handler
            if handler == "error":
                raise OptionConflictError(
                    "conflicting option string(s): %s"
                    % ", ".join([co[0] for co in conflict_opts]),
                    option)
            elif handler == "resolve":
                for (opt, c_option) in conflict_opts:
                    if opt.startswith("--"):
                        c_option._long_opts.remove(opt)
                        del self._long_opt[opt]
                    else:
                        c_option._short_opts.remove(opt)
                        del self._short_opt[opt]
                    if not (c_option._short_opts or c_option._long_opts):
                        c_option.container.option_list.remove(c_option)

    def add_option(self, *args, **kwargs):
        """add_option(Option)
           add_option(opt_str, ..., kwarg=val, ...)
        """
        if type(args[0]) in types.StringTypes:
            option = self.option_class(*args, **kwargs)
        elif len(args) == 1 and not kwargs:
            option = args[0]
            if not isinstance(option, Option):
                raise TypeError, "not an Option instance: %r" % option
        else:
            raise TypeError, "invalid arguments"

        self._check_conflict(option)

        self.option_list.append(option)
        option.container = self
        for opt in option._short_opts:
            self._short_opt[opt] = option
        for opt in option._long_opts:
            self._long_opt[opt] = option

        if option.dest is not None:     # option has a dest, we need a default
            if option.default is not NO_DEFAULT:
                self.defaults[option.dest] = option.default
            elif option.dest not in self.defaults:
                self.defaults[option.dest] = None

        return option

    def add_options(self, option_list):
        for option in option_list:
            self.add_option(option)

    # -- Option query/removal methods ----------------------------------

    def get_option(self, opt_str):
        return (self._short_opt.get(opt_str) or
                self._long_opt.get(opt_str))

    def has_option(self, opt_str):
        return (opt_str in self._short_opt or
                opt_str in self._long_opt)

    def remove_option(self, opt_str):
        option = self._short_opt.get(opt_str)
        if option is None:
            option = self._long_opt.get(opt_str)
        if option is None:
            raise ValueError("no such option %r" % opt_str)

        for opt in option._short_opts:
            del self._short_opt[opt]
        for opt in option._long_opts:
            del self._long_opt[opt]
        option.container.option_list.remove(option)


    # -- Help-formatting methods ---------------------------------------

    def format_option_help(self, formatter):
        if not self.option_list:
            return ""
        result = []
        for option in self.option_list:
            if not option.help is SUPPRESS_HELP:
                result.append(formatter.format_option(option))
        return "".join(result)

    def format_description(self, formatter):
        return formatter.format_description(self.get_description())

    def format_help(self, formatter):
        result = []
        if self.description:
            result.append(self.format_description(formatter))
        if self.option_list:
            result.append(self.format_option_help(formatter))
        return "\n".join(result)


class OptionGroup (OptionContainer):

    def __init__(self, parser, title, description=None):
        self.parser = parser
        OptionContainer.__init__(
            self, parser.option_class, parser.conflict_handler, description)
        self.title = title

    def _create_option_list(self):
        self.option_list = []
        self._share_option_mappings(self.parser)

    def set_title(self, title):
        self.title = title

    def destroy(self):
        """see OptionParser.destroy()."""
        OptionContainer.destroy(self)
        del self.option_list

    # -- Help-formatting methods ---------------------------------------

    def format_help(self, formatter):
        result = formatter.format_heading(self.title)
        formatter.indent()
        result += OptionContainer.format_help(self, formatter)
        formatter.dedent()
        return result


class OptionParser (OptionContainer):

    """
    Class attributes:
      standard_option_list : [Option]
        list of standard options that will be accepted by all instances
        of this parser class (intended to be overridden by subclasses).

    Instance attributes:
      usage : string
        a usage string for your program.  Before it is displayed
        to the user, "%prog" will be expanded to the name of
        your program (self.prog or os.path.basename(sys.argv[0])).
      prog : string
        the name of the current program (to override
        os.path.basename(sys.argv[0])).
      description : string
        A paragraph of text giving a brief overview of your program.
        optparse reformats this paragraph to fit the current terminal
        width and prints it when the user requests help (after usage,
        but before the list of options).
      epilog : string
        paragraph of help text to print after option help

      option_groups : [OptionGroup]
        list of option groups in this parser (option groups are
        irrelevant for parsing the command-line, but very useful
        for generating help)

      allow_interspersed_args : bool = true
        if true, positional arguments may be interspersed with options.
        Assuming -a and -b each take a single argument, the command-line
          -ablah foo bar -bboo baz
        will be interpreted the same as
          -ablah -bboo -- foo bar baz
        If this flag were false, that command line would be interpreted as
          -ablah -- foo bar -bboo baz
        -- ie. we stop processing options as soon as we see the first
        non-option argument.  (This is the tradition followed by
        Python's getopt module, Perl's Getopt::Std, and other argument-
        parsing libraries, but it is generally annoying to users.)

      process_default_values : bool = true
        if true, option default values are processed similarly to option
        values from the command line: that is, they are passed to the
        type-checking function for the option's type (as long as the
        default value is a string).  (This really only matters if you
        have defined custom types; see SF bug #955889.)  Set it to false
        to restore the behaviour of Optik 1.4.1 and earlier.

      rargs : [string]
        the argument list currently being parsed.  Only set when
        parse_args() is active, and continually trimmed down as
        we consume arguments.  Mainly there for the benefit of
        callback options.
      largs : [string]
        the list of leftover arguments that we have skipped while
        parsing options.  If allow_interspersed_args is false, this
        list is always empty.
      values : Values
        the set of option values currently being accumulated.  Only
        set when parse_args() is active.  Also mainly for callbacks.

    Because of the 'rargs', 'largs', and 'values' attributes,
    OptionParser is not thread-safe.  If, for some perverse reason, you
    need to parse command-line arguments simultaneously in different
    threads, use different OptionParser instances.

    """

    standard_option_list = []

    def __init__(self,
                 usage=None,
                 option_list=None,
                 option_class=Option,
                 version=None,
                 conflict_handler="error",
                 description=None,
                 formatter=None,
                 add_help_option=True,
                 prog=None,
                 epilog=None):
        OptionContainer.__init__(
            self, option_class, conflict_handler, description)
        self.set_usage(usage)
        self.prog = prog
        self.version = version
        self.allow_interspersed_args = True
        self.process_default_values = True
        if formatter is None:
            formatter = IndentedHelpFormatter()
        self.formatter = formatter
        self.formatter.set_parser(self)
        self.epilog = epilog

        # Populate the option list; initial sources are the
        # standard_option_list class attribute, the 'option_list'
        # argument, and (if applicable) the _add_version_option() and
        # _add_help_option() methods.
        self._populate_option_list(option_list,
                                   add_help=add_help_option)

        self._init_parsing_state()


    def destroy(self):
        """
        Declare that you are done with this OptionParser.  This cleans up
        reference cycles so the OptionParser (and all objects referenced by
        it) can be garbage-collected promptly.  After calling destroy(), the
        OptionParser is unusable.
        """
        OptionContainer.destroy(self)
        for group in self.option_groups:
            group.destroy()
        del self.option_list
        del self.option_groups
        del self.formatter


    # -- Private methods -----------------------------------------------
    # (used by our or OptionContainer's constructor)

    def _create_option_list(self):
        self.option_list = []
        self.option_groups = []
        self._create_option_mappings()

    def _add_help_option(self):
        self.add_option("-h", "--help",
                        action="help",
                        help=_("show this help message and exit"))

    def _add_version_option(self):
        self.add_option("--version",
                        action="version",
                        help=_("show program's version number and exit"))

    def _populate_option_list(self, option_list, add_help=True):
        if self.standard_option_list:
            self.add_options(self.standard_option_list)
        if option_list:
            self.add_options(option_list)
        if self.version:
            self._add_version_option()
        if add_help:
            self._add_help_option()

    def _init_parsing_state(self):
        # These are set in parse_args() for the convenience of callbacks.
        self.rargs = None
        self.largs = None
        self.values = None


    # -- Simple modifier methods ---------------------------------------

    def set_usage(self, usage):
        if usage is None:
            self.usage = _("%prog [options]")
        elif usage is SUPPRESS_USAGE:
            self.usage = None
        # For backwards compatibility with Optik 1.3 and earlier.
        elif usage.lower().startswith("usage: "):
            self.usage = usage[7:]
        else:
            self.usage = usage

    def enable_interspersed_args(self):
        """Set parsing to not stop on the first non-option, allowing
        interspersing switches with command arguments. This is the
        default behavior. See also disable_interspersed_args() and the
        class documentation description of the attribute
        allow_interspersed_args."""
        self.allow_interspersed_args = True

    def disable_interspersed_args(self):
        """Set parsing to stop on the first non-option. Use this if
        you have a command processor which runs another command that
        has options of its own and you want to make sure these options
        don't get confused.
        """
        self.allow_interspersed_args = False

    def set_process_default_values(self, process):
        self.process_default_values = process

    def set_default(self, dest, value):
        self.defaults[dest] = value

    def set_defaults(self, **kwargs):
        self.defaults.update(kwargs)

    def _get_all_options(self):
        options = self.option_list[:]
        for group in self.option_groups:
            options.extend(group.option_list)
        return options

    def get_default_values(self):
        if not self.process_default_values:
            # Old, pre-Optik 1.5 behaviour.
            return Values(self.defaults)

        defaults = self.defaults.copy()
        for option in self._get_all_options():
            default = defaults.get(option.dest)
            if isbasestring(default):
                opt_str = option.get_opt_string()
                defaults[option.dest] = option.check_value(opt_str, default)

        return Values(defaults)


    # -- OptionGroup methods -------------------------------------------

    def add_option_group(self, *args, **kwargs):
        # XXX lots of overlap with OptionContainer.add_option()
        if type(args[0]) is types.StringType:
            group = OptionGroup(self, *args, **kwargs)
        elif len(args) == 1 and not kwargs:
            group = args[0]
            if not isinstance(group, OptionGroup):
                raise TypeError, "not an OptionGroup instance: %r" % group
            if group.parser is not self:
                raise ValueError, "invalid OptionGroup (wrong parser)"
        else:
            raise TypeError, "invalid arguments"

        self.option_groups.append(group)
        return group

    def get_option_group(self, opt_str):
        option = (self._short_opt.get(opt_str) or
                  self._long_opt.get(opt_str))
        if option and option.container is not self:
            return option.container
        return None


    # -- Option-parsing methods ----------------------------------------

    def _get_args(self, args):
        if args is None:
            return sys.argv[1:]
        else:
            return args[:]              # don't modify caller's list

    def parse_args(self, args=None, values=None):
        """
        parse_args(args : [string] = sys.argv[1:],
                   values : Values = None)
        -> (values : Values, args : [string])

        Parse the command-line options found in 'args' (default:
        sys.argv[1:]).  Any errors result in a call to 'error()', which
        by default prints the usage message to stderr and calls
        sys.exit() with an error message.  On success returns a pair
        (values, args) where 'values' is a Values instance (with all
        your option values) and 'args' is the list of arguments left
        over after parsing options.
        """
        rargs = self._get_args(args)
        if values is None:
            values = self.get_default_values()

        # Store the halves of the argument list as attributes for the
        # convenience of callbacks:
        #   rargs
        #     the rest of the command-line (the "r" stands for
        #     "remaining" or "right-hand")
        #   largs
        #     the leftover arguments -- ie. what's left after removing
        #     options and their arguments (the "l" stands for "leftover"
        #     or "left-hand")
        self.rargs = rargs
        self.largs = largs = []
        self.values = values

        try:
            stop = self._process_args(largs, rargs, values)
        except (BadOptionError, OptionValueError), err:
            self.error(str(err))

        args = largs + rargs
        return self.check_values(values, args)

    def check_values(self, values, args):
        """
        check_values(values : Values, args : [string])
        -> (values : Values, args : [string])

        Check that the supplied option values and leftover arguments are
        valid.  Returns the option values and leftover arguments
        (possibly adjusted, possibly completely new -- whatever you
        like).  Default implementation just returns the passed-in
        values; subclasses may override as desired.
        """
        return (values, args)

    def _process_args(self, largs, rargs, values):
        """_process_args(largs : [string],
                         rargs : [string],
                         values : Values)

        Process command-line arguments and populate 'values', consuming
        options and arguments from 'rargs'.  If 'allow_interspersed_args' is
        false, stop at the first non-option argument.  If true, accumulate any
        interspersed non-option arguments in 'largs'.
        """
        while rargs:
            arg = rargs[0]
            # We handle bare "--" explicitly, and bare "-" is handled by the
            # standard arg handler since the short arg case ensures that the
            # len of the opt string is greater than 1.
            if arg == "--":
                del rargs[0]
                return
            elif arg[0:2] == "--":
                # process a single long option (possibly with value(s))
                self._process_long_opt(rargs, values)
            elif arg[:1] == "-" and len(arg) > 1:
                # process a cluster of short options (possibly with
                # value(s) for the last one only)
                self._process_short_opts(rargs, values)
            elif self.allow_interspersed_args:
                largs.append(arg)
                del rargs[0]
            else:
                return                  # stop now, leave this arg in rargs

        # Say this is the original argument list:
        # [arg0, arg1, ..., arg(i-1), arg(i), arg(i+1), ..., arg(N-1)]
        #                            ^
        # (we are about to process arg(i)).
        #
        # Then rargs is [arg(i), ..., arg(N-1)] and largs is a *subset* of
        # [arg0, ..., arg(i-1)] (any options and their arguments will have
        # been removed from largs).
        #
        # The while loop will usually consume 1 or more arguments per pass.
        # If it consumes 1 (eg. arg is an option that takes no arguments),
        # then after _process_arg() is done the situation is:
        #
        #   largs = subset of [arg0, ..., arg(i)]
        #   rargs = [arg(i+1), ..., arg(N-1)]
        #
        # If allow_interspersed_args is false, largs will always be
        # *empty* -- still a subset of [arg0, ..., arg(i-1)], but
        # not a very interesting subset!

    def _match_long_opt(self, opt):
        """_match_long_opt(opt : string) -> string

        Determine which long option string 'opt' matches, ie. which one
        it is an unambiguous abbreviation for.  Raises BadOptionError if
        'opt' doesn't unambiguously match any long option string.
        """
        return _match_abbrev(opt, self._long_opt)

    def _process_long_opt(self, rargs, values):
        arg = rargs.pop(0)

        # Value explicitly attached to arg?  Pretend it's the next
        # argument.
        if "=" in arg:
            (opt, next_arg) = arg.split("=", 1)
            rargs.insert(0, next_arg)
            had_explicit_value = True
        else:
            opt = arg
            had_explicit_value = False

        opt = self._match_long_opt(opt)
        option = self._long_opt[opt]
        if option.takes_value():
            nargs = option.nargs
            if len(rargs) < nargs:
                if nargs == 1:
                    self.error(_("%s option requires an argument") % opt)
                else:
                    self.error(_("%s option requires %d arguments")
                               % (opt, nargs))
            elif nargs == 1:
                value = rargs.pop(0)
            else:
                value = tuple(rargs[0:nargs])
                del rargs[0:nargs]

        elif had_explicit_value:
            self.error(_("%s option does not take a value") % opt)

        else:
            value = None

        option.process(opt, value, values, self)

    def _process_short_opts(self, rargs, values):
        arg = rargs.pop(0)
        stop = False
        i = 1
        for ch in arg[1:]:
            opt = "-" + ch
            option = self._short_opt.get(opt)
            i += 1                      # we have consumed a character

            if not option:
                raise BadOptionError(opt)
            if option.takes_value():
                # Any characters left in arg?  Pretend they're the
                # next arg, and stop consuming characters of arg.
                if i < len(arg):
                    rargs.insert(0, arg[i:])
                    stop = True

                nargs = option.nargs
                if len(rargs) < nargs:
                    if nargs == 1:
                        self.error(_("%s option requires an argument") % opt)
                    else:
                        self.error(_("%s option requires %d arguments")
                                   % (opt, nargs))
                elif nargs == 1:
                    value = rargs.pop(0)
                else:
                    value = tuple(rargs[0:nargs])
                    del rargs[0:nargs]

            else:                       # option doesn't take a value
                value = None

            option.process(opt, value, values, self)

            if stop:
                break


    # -- Feedback methods ----------------------------------------------

    def get_prog_name(self):
        if self.prog is None:
            return os.path.basename(sys.argv[0])
        else:
            return self.prog

    def expand_prog_name(self, s):
        return s.replace("%prog", self.get_prog_name())

    def get_description(self):
        return self.expand_prog_name(self.description)

    def exit(self, status=0, msg=None):
        if msg:
            sys.stderr.write(msg)
        sys.exit(status)

    def error(self, msg):
        """error(msg : string)

        Print a usage message incorporating 'msg' to stderr and exit.
        If you override this in a subclass, it should not return -- it
        should either exit or raise an exception.
        """
        self.print_usage(sys.stderr)
        self.exit(2, "%s: error: %s\n" % (self.get_prog_name(), msg))

    def get_usage(self):
        if self.usage:
            return self.formatter.format_usage(
                self.expand_prog_name(self.usage))
        else:
            return ""

    def print_usage(self, file=None):
        """print_usage(file : file = stdout)

        Print the usage message for the current program (self.usage) to
        'file' (default stdout).  Any occurrence of the string "%prog" in
        self.usage is replaced with the name of the current program
        (basename of sys.argv[0]).  Does nothing if self.usage is empty
        or not defined.
        """
        if self.usage:
            print >>file, self.get_usage()

    def get_version(self):
        if self.version:
            return self.expand_prog_name(self.version)
        else:
            return ""

    def print_version(self, file=None):
        """print_version(file : file = stdout)

        Print the version message for this program (self.version) to
        'file' (default stdout).  As with print_usage(), any occurrence
        of "%prog" in self.version is replaced by the current program's
        name.  Does nothing if self.version is empty or undefined.
        """
        if self.version:
            print >>file, self.get_version()

    def format_option_help(self, formatter=None):
        if formatter is None:
            formatter = self.formatter
        formatter.store_option_strings(self)
        result = []
        result.append(formatter.format_heading(_("Options")))
        formatter.indent()
        if self.option_list:
            result.append(OptionContainer.format_option_help(self, formatter))
            result.append("\n")
        for group in self.option_groups:
            result.append(group.format_help(formatter))
            result.append("\n")
        formatter.dedent()
        # Drop the last "\n", or the header if no options or option groups:
        return "".join(result[:-1])

    def format_epilog(self, formatter):
        return formatter.format_epilog(self.epilog)

    def format_help(self, formatter=None):
        if formatter is None:
            formatter = self.formatter
        result = []
        if self.usage:
            result.append(self.get_usage() + "\n")
        if self.description:
            result.append(self.format_description(formatter) + "\n")
        result.append(self.format_option_help(formatter))
        result.append(self.format_epilog(formatter))
        return "".join(result)

    # used by test suite
    def _get_encoding(self, file):
        encoding = getattr(file, "encoding", None)
        if not encoding:
            encoding = sys.getdefaultencoding()
        return encoding

    def print_help(self, file=None):
        """print_help(file : file = stdout)

        Print an extended help message, listing all options and any
        help text provided with them, to 'file' (default stdout).
        """
        if file is None:
            file = sys.stdout
        encoding = self._get_encoding(file)
        file.write(self.format_help().encode(encoding, "replace"))

# class OptionParser


def _match_abbrev(s, wordmap):
    """_match_abbrev(s : string, wordmap : {string : Option}) -> string

    Return the string key in 'wordmap' for which 's' is an unambiguous
    abbreviation.  If 's' is found to be ambiguous or doesn't match any of
    'words', raise BadOptionError.
    """
    # Is there an exact match?
    if s in wordmap:
        return s
    else:
        # Isolate all words with s as a prefix.
        possibilities = [word for word in wordmap.keys()
                         if word.startswith(s)]
        # No exact match, so there had better be just one possibility.
        if len(possibilities) == 1:
            return possibilities[0]
        elif not possibilities:
            raise BadOptionError(s)
        else:
            # More than one possible completion: ambiguous prefix.
            possibilities.sort()
            raise AmbiguousOptionError(s, possibilities)


# Some day, there might be many Option classes.  As of Optik 1.3, the
# preferred way to instantiate Options is indirectly, via make_option(),
# which will become a factory function when there are many Option
# classes.
make_option = Option
                                                                                                                                                                                                                                             ó
Ó«[c           @   sÀ  d  Z  d Z d d d d d d d d	 d
 d d d d d d d g Z d Z d d l Z d d l Z d d l Z d d l Z d „  Z y d d l	 m	 Z	 Wn e
 k
 r± d „  Z	 n Xe	 Z d e f d „  ƒ  YZ d e f d „  ƒ  YZ d e f d „  ƒ  YZ d e f d „  ƒ  YZ d e f d „  ƒ  YZ d e f d „  ƒ  YZ d
 f  d „  ƒ  YZ d e f d  „  ƒ  YZ d e f d! „  ƒ  YZ d" „  Z d# „  Z d$ „  Z i e e d% ƒ f d& 6e e d' ƒ f d( 6e e d) ƒ f d* 6e e d+ ƒ f d+ 6Z d, „  Z d- „  Z d. d/ f Z d f  d0 „  ƒ  YZ d1 d2 Z  d1 d3 Z! y e" Wn e# k
 rQd4 „  Z$ n
 Xd5 „  Z$ d f  d6 „  ƒ  YZ% d f  d7 „  ƒ  YZ& d e& f d8 „  ƒ  YZ' d	 e& f d9 „  ƒ  YZ( d: „  Z) e Z* d S(;   s§  A powerful, extensible, and easy-to-use option parser.

By Greg Ward <gward@python.net>

Originally distributed as Optik.

For support, use the optik-users@lists.sourceforge.net mailing list
(http://lists.sourceforge.net/lists/listinfo/optik-users).

Simple usage example:

   from optparse import OptionParser

   parser = OptionParser()
   parser.add_option("-f", "--file", dest="filename",
                     help="write report to FILE", metavar="FILE")
   parser.add_option("-q", "--quiet",
                     action="store_false", dest="verbose", default=True,
                     help="don't print status messages to stdout")

   (options, args) = parser.parse_args()
s   1.5.3t   Optiont   make_optiont   SUPPRESS_HELPt   SUPPRESS_USAGEt   Valuest   OptionContainert   OptionGroupt   OptionParsert   HelpFormattert   IndentedHelpFormattert   TitledHelpFormattert   OptParseErrort   OptionErrort   OptionConflictErrort   OptionValueErrort   BadOptionErrors"  
Copyright (c) 2001-2006 Gregory P. Ward.  All rights reserved.
Copyright (c) 2002-2006 Python Software Foundation.  All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

  * Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

  * Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the
    documentation and/or other materials provided with the distribution.

  * Neither the name of the author nor the names of its
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
iÿÿÿÿNc         C   s   d |  j  j t |  ƒ |  f S(   Ns   <%s at 0x%x: %s>(   t	   __class__t   __name__t   id(   t   self(    (    s   /usr/lib/python2.7/optparse.pyt   _reprO   s    (   t   gettextc         C   s   |  S(   N(    (   t   message(    (    s   /usr/lib/python2.7/optparse.pyR   \   s    c           B   s   e  Z d  „  Z d „  Z RS(   c         C   s   | |  _  d  S(   N(   t   msg(   R   R   (    (    s   /usr/lib/python2.7/optparse.pyt   __init__b   s    c         C   s   |  j  S(   N(   R   (   R   (    (    s   /usr/lib/python2.7/optparse.pyt   __str__e   s    (   R   t
   __module__R   R   (    (    (    s   /usr/lib/python2.7/optparse.pyR   a   s   	c           B   s    e  Z d  Z d „  Z d „  Z RS(   s]   
    Raised if an Option instance is created with invalid or
    inconsistent arguments.
    c         C   s   | |  _  t | ƒ |  _ d  S(   N(   R   t   strt	   option_id(   R   R   t   option(    (    s   /usr/lib/python2.7/optparse.pyR   o   s    	c         C   s(   |  j  r d |  j  |  j f S|  j Sd  S(   Ns   option %s: %s(   R   R   (   R   (    (    s   /usr/lib/python2.7/optparse.pyR   s   s    	(   R   R   t   __doc__R   R   (    (    (    s   /usr/lib/python2.7/optparse.pyR   i   s   	c           B   s   e  Z d  Z RS(   sE   
    Raised if conflicting options are added to an OptionParser.
    (   R   R   R   (    (    (    s   /usr/lib/python2.7/optparse.pyR   y   s   c           B   s   e  Z d  Z RS(   sS   
    Raised if an invalid option value is encountered on the command
    line.
    (   R   R   R   (    (    (    s   /usr/lib/python2.7/optparse.pyR   ~   s   c           B   s    e  Z d  Z d „  Z d „  Z RS(   sB   
    Raised if an invalid option is seen on the command line.
    c         C   s   | |  _  d  S(   N(   t   opt_str(   R   R   (    (    s   /usr/lib/python2.7/optparse.pyR   ˆ   s    c         C   s   t  d ƒ |  j S(   Ns   no such option: %s(   t   _R   (   R   (    (    s   /usr/lib/python2.7/optparse.pyR   ‹   s    (   R   R   R   R   R   (    (    (    s   /usr/lib/python2.7/optparse.pyR   „   s   	t   AmbiguousOptionErrorc           B   s    e  Z d  Z d „  Z d „  Z RS(   sD   
    Raised if an ambiguous option is seen on the command line.
    c         C   s   t  j |  | ƒ | |  _ d  S(   N(   R   R   t   possibilities(   R   R   R"   (    (    s   /usr/lib/python2.7/optparse.pyR   ’   s    c         C   s#   t  d ƒ |  j d j |  j ƒ f S(   Ns   ambiguous option: %s (%s?)s   , (   R    R   t   joinR"   (   R   (    (    s   /usr/lib/python2.7/optparse.pyR   –   s    	(   R   R   R   R   R   (    (    (    s   /usr/lib/python2.7/optparse.pyR!   Ž   s   	c           B   s›   e  Z d  Z d Z d „  Z d „  Z d „  Z d „  Z d „  Z d „  Z	 d „  Z
 d	 „  Z d
 „  Z d „  Z d „  Z d „  Z d „  Z d „  Z d „  Z RS(   sÍ  
    Abstract base class for formatting option help.  OptionParser
    instances should use one of the HelpFormatter subclasses for
    formatting help; by default IndentedHelpFormatter is used.

    Instance attributes:
      parser : OptionParser
        the controlling OptionParser instance
      indent_increment : int
        the number of columns to indent per nesting level
      max_help_position : int
        the maximum starting column for option help text
      help_position : int
        the calculated starting column for option help text;
        initially the same as the maximum
      width : int
        total number of columns for output (pass None to constructor for
        this value to be taken from the $COLUMNS environment variable)
      level : int
        current indentation level
      current_indent : int
        current indentation level (in columns)
      help_width : int
        number of columns available for option help text (calculated)
      default_tag : str
        text to replace with each option's default value, "%default"
        by default.  Set to false value to disable default value expansion.
      option_strings : { Option : str }
        maps Option instances to the snippet of help text explaining
        the syntax of that option, e.g. "-h, --help" or
        "-fFILE, --file=FILE"
      _short_opt_fmt : str
        format string controlling how short options with values are
        printed in help text.  Must be either "%s%s" ("-fFILE") or
        "%s %s" ("-f FILE"), because those are the two syntaxes that
        Optik supports.
      _long_opt_fmt : str
        similar but for long options; must be either "%s %s" ("--file FILE")
        or "%s=%s" ("--file=FILE").
    t   nonec         C   sá   d  |  _ | |  _ | d  k rb y t t j d ƒ } Wn t t f k
 rT d } n X| d 8} n  | |  _ t	 | t
 | d | d ƒ ƒ |  _ |  _ d |  _ d |  _ d  |  _ | |  _ d |  _ i  |  _ d |  _ d |  _ d  S(	   Nt   COLUMNSiP   i   i   i    s   %defaults   %s %ss   %s=%s(   t   Nonet   parsert   indent_incrementt   intt   ost   environt   KeyErrort
   ValueErrort   widtht   mint   maxt   help_positiont   max_help_positiont   current_indentt   levelt
   help_widtht   short_firstt   default_tagt   option_stringst   _short_opt_fmtt   _long_opt_fmt(   R   R(   R2   R.   R6   (    (    s   /usr/lib/python2.7/optparse.pyR   È   s$    		
	*							c         C   s   | |  _  d  S(   N(   R'   (   R   R'   (    (    s   /usr/lib/python2.7/optparse.pyt
   set_parserá   s    c         C   s4   | d k r t  d | ƒ ‚ n  d | d |  _ d  S(   Nt    t    s/   invalid metavar delimiter for short options: %rs   %s(   R<   R=   (   R-   R9   (   R   t   delim(    (    s   /usr/lib/python2.7/optparse.pyt   set_short_opt_delimiterä   s    c         C   s4   | d k r t  d | ƒ ‚ n  d | d |  _ d  S(   Nt   =R=   s.   invalid metavar delimiter for long options: %rs   %s(   R@   R=   (   R-   R:   (   R   R>   (    (    s   /usr/lib/python2.7/optparse.pyt   set_long_opt_delimiterê   s    c         C   s%   |  j  |  j 7_  |  j d 7_ d  S(   Ni   (   R3   R(   R4   (   R   (    (    s   /usr/lib/python2.7/optparse.pyt   indentð   s    c         C   s@   |  j  |  j 8_  |  j  d k s- t d ƒ ‚ |  j d 8_ d  S(   Ni    s   Indent decreased below 0.i   (   R3   R(   t   AssertionErrorR4   (   R   (    (    s   /usr/lib/python2.7/optparse.pyt   dedentô   s    c         C   s   t  d ‚ d  S(   Ns   subclasses must implement(   t   NotImplementedError(   R   t   usage(    (    s   /usr/lib/python2.7/optparse.pyt   format_usageù   s    c         C   s   t  d ‚ d  S(   Ns   subclasses must implement(   RE   (   R   t   heading(    (    s   /usr/lib/python2.7/optparse.pyt   format_headingü   s    c         C   sB   t  |  j |  j d ƒ } d |  j } t j | | d | d | ƒS(   s   
        Format a paragraph of free-form text for inclusion in the
        help output at the current indentation level.
        i   R=   t   initial_indentt   subsequent_indent(   R0   R.   R3   t   textwrapt   fill(   R   t   textt
   text_widthRB   (    (    s   /usr/lib/python2.7/optparse.pyt   _format_textÿ   s    	c         C   s   | r |  j  | ƒ d Sd Sd  S(   Ns   
R<   (   RP   (   R   t   description(    (    s   /usr/lib/python2.7/optparse.pyt   format_description  s    c         C   s#   | r d |  j  | ƒ d Sd Sd  S(   Ns   
R<   (   RP   (   R   t   epilog(    (    s   /usr/lib/python2.7/optparse.pyt   format_epilog  s    c         C   sx   |  j  d  k s |  j r  | j S|  j  j j | j ƒ } | t k sP | d  k r\ |  j } n  | j j	 |  j t
 | ƒ ƒ S(   N(   R'   R&   R7   t   helpt   defaultst   gett   destt
   NO_DEFAULTt   NO_DEFAULT_VALUEt   replaceR   (   R   R   t   default_value(    (    s   /usr/lib/python2.7/optparse.pyt   expand_default  s    c   	      C   s6  g  } |  j  | } |  j |  j d } t | ƒ | k r[ d |  j d | f } |  j } n d |  j d | | f } d } | j | ƒ | j r	|  j | ƒ } t j | |  j	 ƒ } | j d | d | d f ƒ | j
 g  | d D] } d |  j d | f ^ qã ƒ n  | d d k r)| j d ƒ n  d j | ƒ S(	   Ni   s   %*s%s
R<   s	   %*s%-*s  i    i   iÿÿÿÿs   
(   R8   R1   R3   t   lent   appendRU   R]   RL   t   wrapR5   t   extendR#   (	   R   R   t   resultt   optst	   opt_widtht   indent_firstt	   help_textt
   help_linest   line(    (    s   /usr/lib/python2.7/optparse.pyt   format_option"  s$    		.c         C   s  |  j  ƒ  d } xI | j D]> } |  j | ƒ } | |  j | <t | t | ƒ |  j ƒ } q W|  j  ƒ  x] | j D]R } xI | j D]> } |  j | ƒ } | |  j | <t | t | ƒ |  j ƒ } q€ Wqp W|  j ƒ  |  j ƒ  t	 | d |  j
 ƒ |  _ t |  j |  j d ƒ |  _ d  S(   Ni    i   i   (   RB   t   option_listt   format_option_stringsR8   R0   R^   R3   t   option_groupsRD   R/   R2   R1   R.   R5   (   R   R'   t   max_lent   optt   stringst   group(    (    s   /usr/lib/python2.7/optparse.pyt   store_option_stringsE  s     
 
$

c         C   s¸   | j  ƒ  ry | j p! | j j ƒ  } g  | j D] } |  j | | f ^ q. } g  | j D] } |  j | | f ^ qW } n | j } | j } |  j r¡ | | } n
 | | } d j	 | ƒ S(   s@   Return a comma-separated list of option strings & metavariables.s   , (
   t   takes_valuet   metavarRX   t   uppert   _short_optsR9   t
   _long_optsR:   R6   R#   (   R   R   Rs   t   soptt
   short_optst   loptt	   long_optsRc   (    (    s   /usr/lib/python2.7/optparse.pyRk   W  s    &)			
(   R   R   R   RZ   R   R;   R?   RA   RB   RD   RG   RI   RP   RR   RT   R]   Ri   Rq   Rk   (    (    (    s   /usr/lib/python2.7/optparse.pyR   ›   s"   )												
	#	c           B   s5   e  Z d  Z d d d d d „ Z d „  Z d „  Z RS(   s.   Format help with indented section bodies.
    i   i   i   c         C   s   t  j |  | | | | ƒ d  S(   N(   R   R   (   R   R(   R2   R.   R6   (    (    s   /usr/lib/python2.7/optparse.pyR   n  s    c         C   s   t  d ƒ | S(   Ns
   Usage: %s
(   R    (   R   RF   (    (    s   /usr/lib/python2.7/optparse.pyRG   v  s    c         C   s   d |  j  d | f S(   Ns   %*s%s:
R<   (   R3   (   R   RH   (    (    s   /usr/lib/python2.7/optparse.pyRI   y  s    N(   R   R   R   R&   R   RG   RI   (    (    (    s   /usr/lib/python2.7/optparse.pyR	   j  s   	c           B   s5   e  Z d  Z d d d d d „ Z d „  Z d „  Z RS(   s1   Format help with underlined section headers.
    i    i   c         C   s   t  j |  | | | | ƒ d  S(   N(   R   R   (   R   R(   R2   R.   R6   (    (    s   /usr/lib/python2.7/optparse.pyR     s    c         C   s   d |  j  t d ƒ ƒ | f S(   Ns   %s  %s
t   Usage(   RI   R    (   R   RF   (    (    s   /usr/lib/python2.7/optparse.pyRG   ‰  s    c         C   s   d | d |  j  t | ƒ f S(   Ns   %s
%s
s   =-(   R4   R^   (   R   RH   (    (    s   /usr/lib/python2.7/optparse.pyRI   Œ  s    N(   R   R   R   R&   R   RG   RI   (    (    (    s   /usr/lib/python2.7/optparse.pyR
   }  s   	c         C   sz   |  d  j  ƒ  d k r d } nN |  d  j  ƒ  d k rN d } |  d pH d }  n |  d  d k rg d } n d } | |  | ƒ S(	   Ni   t   0xi   t   0bt   0i   i   i
   (   t   lower(   t   valt   typet   radix(    (    s   /usr/lib/python2.7/optparse.pyt
   _parse_num  s    		c         C   s   t  |  t ƒ S(   N(   Rƒ   R)   (   R€   (    (    s   /usr/lib/python2.7/optparse.pyt
   _parse_int  s    c         C   s   t  |  t ƒ S(   N(   Rƒ   t   long(   R€   (    (    s   /usr/lib/python2.7/optparse.pyt   _parse_long   s    t   integerR)   s   long integerR…   s   floating-pointt   floatt   complexc         C   sX   t  |  j \ } } y | | ƒ SWn0 t k
 rS t t d ƒ | | | f ƒ ‚ n Xd  S(   Ns   option %s: invalid %s value: %r(   t   _builtin_cvtR   R-   R   R    (   R   Rn   t   valuet   cvtt   what(    (    s   /usr/lib/python2.7/optparse.pyt   check_builtin¨  s    c         C   sQ   | |  j  k r | Sd j t t |  j  ƒ ƒ } t t d ƒ | | | f ƒ ‚ d  S(   Ns   , s.   option %s: invalid choice: %r (choose from %s)(   t   choicesR#   t   mapt   reprR   R    (   R   Rn   R‹   R   (    (    s   /usr/lib/python2.7/optparse.pyt   check_choice°  s    	t   NOt   DEFAULTc           B   sN  e  Z d  Z d d d d d d d d d	 d
 d d g Z d- Z d. Z d/ Z d0 Z d1 Z d2 Z	 i e
 d 6e
 d 6e
 d 6e
 d 6e d 6Z d3 Z d „  Z d „  Z d „  Z d „  Z d „  Z d  „  Z d! „  Z d" „  Z d# „  Z d$ „  Z d% „  Z e e e e e e e g Z d& „  Z e Z d' „  Z d( „  Z d) „  Z d* „  Z  d+ „  Z! d, „  Z" RS(4   sr  
    Instance attributes:
      _short_opts : [string]
      _long_opts : [string]

      action : string
      type : string
      dest : string
      default : any
      nargs : int
      const : any
      choices : [string]
      callback : function
      callback_args : (any*)
      callback_kwargs : { string : any }
      help : string
      metavar : string
    t   actionR   RX   t   defaultt   nargst   constR   t   callbackt   callback_argst   callback_kwargsRU   Rs   t   storet   store_constt
   store_truet   store_falseR_   t   append_constt   countt   versiont   stringR)   R…   Rˆ   R‰   t   choicec         O   s]   g  |  _  g  |  _ |  j | ƒ } |  j | ƒ |  j | ƒ x |  j D] } | |  ƒ qE Wd  S(   N(   Ru   Rv   t   _check_opt_stringst   _set_opt_stringst
   _set_attrst   CHECK_METHODS(   R   Rc   t   attrst   checker(    (    s   /usr/lib/python2.7/optparse.pyR   1  s    		c         C   s(   t  d  | ƒ } | s$ t d ƒ ‚ n  | S(   Ns+   at least one option string must be supplied(   t   filterR&   t	   TypeError(   R   Rc   (    (    s   /usr/lib/python2.7/optparse.pyR¥   D  s    c         C   sá   xÚ | D]Ò } t  | ƒ d k  r5 t d | |  ƒ ‚ q t  | ƒ d k r | d d k od | d d k s} t d | |  ƒ ‚ n  |  j j | ƒ q | d d !d k o° | d d k sÉ t d | |  ƒ ‚ n  |  j j | ƒ q Wd  S(	   Ni   s>   invalid option string %r: must be at least two characters longi    t   -i   sM   invalid short option string %r: must be of the form -x, (x any non-dash char)s   --sG   invalid long option string %r: must start with --, followed by non-dash(   R^   R   Ru   R_   Rv   (   R   Rc   Rn   (    (    s   /usr/lib/python2.7/optparse.pyR¦   M  s$     #c         C   s¬   xj |  j  D]_ } | | k r: t |  | | | ƒ | | =q
 | d k rY t |  | t ƒ q
 t |  | d  ƒ q
 W| r¨ | j ƒ  } | j ƒ  t d d j | ƒ |  ƒ ‚ n  d  S(   NR–   s   invalid keyword arguments: %ss   , (   t   ATTRSt   setattrRY   R&   t   keyst   sortR   R#   (   R   R©   t   attr(    (    s   /usr/lib/python2.7/optparse.pyR§   b  s    

c         C   sJ   |  j  d  k r d |  _  n+ |  j  |  j k rF t d |  j  |  ƒ ‚ n  d  S(   NRœ   s   invalid action: %r(   R•   R&   t   ACTIONSR   (   R   (    (    s   /usr/lib/python2.7/optparse.pyt   _check_actionv  s    c         C   s)  |  j  d  k rK |  j |  j k r%|  j d  k	 r< d |  _  qH d |  _  q%nÚ d d  l } t  |  j  ƒ t j k s¢ t |  j  d ƒ r´ t	 | |  j  j
 d  ƒ |  j  k r´ |  j  j
 |  _  n  |  j  d k rÏ d |  _  n  |  j  |  j k rú t d |  j  |  ƒ ‚ n  |  j |  j k r%t d |  j |  ƒ ‚ n  d  S(   NR¤   R£   iÿÿÿÿR   R   s   invalid option type: %rs$   must not supply a type for action %r(   R   R&   R•   t   ALWAYS_TYPED_ACTIONSR   t   __builtin__t   typest   TypeTypet   hasattrt   getattrR   t   TYPESR   t   TYPED_ACTIONS(   R   R¶   (    (    s   /usr/lib/python2.7/optparse.pyt   _check_type|  s"    !c         C   s²   |  j  d k r† |  j d  k r0 t d |  ƒ ‚ q® t  |  j ƒ t j t j f k r® t d t t  |  j ƒ ƒ j d ƒ d |  ƒ ‚ q® n( |  j d  k	 r® t d |  j  |  ƒ ‚ n  d  S(   NR¤   s/   must supply a list of choices for type 'choice's1   choices must be a list of strings ('%s' supplied)t   'i   s#   must not supply choices for type %r(	   R   R   R&   R   R·   t	   TupleTypet   ListTypeR   t   split(   R   (    (    s   /usr/lib/python2.7/optparse.pyt   _check_choiceš  s    !/c         C   s}   |  j  |  j k p |  j d  k	 } |  j d  k ry | ry |  j rb |  j d d j d d ƒ |  _ qy |  j d d |  _ n  d  S(   Ni    i   R­   R    i   (   R•   t   STORE_ACTIONSR   R&   RX   Rv   R[   Ru   (   R   Rr   (    (    s   /usr/lib/python2.7/optparse.pyt   _check_dest§  s    	#c         C   s>   |  j  |  j k r: |  j d  k	 r: t d |  j  |  ƒ ‚ n  d  S(   Ns*   'const' must not be supplied for action %r(   R•   t   CONST_ACTIONSR˜   R&   R   (   R   (    (    s   /usr/lib/python2.7/optparse.pyt   _check_const¶  s    !
c         C   s\   |  j  |  j k r0 |  j d  k rX d |  _ qX n( |  j d  k	 rX t d |  j  |  ƒ ‚ n  d  S(   Ni   s*   'nargs' must not be supplied for action %r(   R•   R¼   R—   R&   R   (   R   (    (    s   /usr/lib/python2.7/optparse.pyt   _check_nargs¼  s    
c         C   s+  |  j  d k r½ t |  j d ƒ s: t d |  j |  ƒ ‚ n  |  j d  k	 rz t |  j ƒ t j k	 rz t d |  j |  ƒ ‚ n  |  j	 d  k	 r't |  j	 ƒ t j
 k	 r't d |  j	 |  ƒ ‚ q'nj |  j d  k	 rå t d |  j |  ƒ ‚ n  |  j d  k	 rt d |  ƒ ‚ n  |  j	 d  k	 r't d |  ƒ ‚ n  d  S(	   NR™   t   __call__s   callback not callable: %rs3   callback_args, if supplied, must be a tuple: not %rs4   callback_kwargs, if supplied, must be a dict: not %rs.   callback supplied (%r) for non-callback options.   callback_args supplied for non-callback options0   callback_kwargs supplied for non-callback option(   R•   R¹   R™   R   Rš   R&   R   R·   R¿   R›   t   DictType(   R   (    (    s   /usr/lib/python2.7/optparse.pyt   _check_callbackÅ  s0    c         C   s   d j  |  j |  j ƒ S(   Nt   /(   R#   Ru   Rv   (   R   (    (    s   /usr/lib/python2.7/optparse.pyR   ì  s    c         C   s   |  j  d  k	 S(   N(   R   R&   (   R   (    (    s   /usr/lib/python2.7/optparse.pyRr   ñ  s    c         C   s#   |  j  r |  j  d S|  j d Sd  S(   Ni    (   Rv   Ru   (   R   (    (    s   /usr/lib/python2.7/optparse.pyt   get_opt_stringô  s    	c         C   s9   |  j  j |  j ƒ } | d  k r% | S| |  | | ƒ Sd  S(   N(   t   TYPE_CHECKERRW   R   R&   (   R   Rn   R‹   Rª   (    (    s   /usr/lib/python2.7/optparse.pyt   check_valueý  s    c         C   s[   | d  k	 rW |  j d k r+ |  j | | ƒ St g  | D] } |  j | | ƒ ^ q5 ƒ Sn  d  S(   Ni   (   R&   R—   RÎ   t   tuple(   R   Rn   R‹   t   v(    (    s   /usr/lib/python2.7/optparse.pyt   convert_value  s    c         C   s4   |  j  | | ƒ } |  j |  j |  j | | | | ƒ S(   N(   RÑ   t   take_actionR•   RX   (   R   Rn   R‹   t   valuesR'   (    (    s   /usr/lib/python2.7/optparse.pyt   process  s    c   	      C   s§  | d k r t  | | | ƒ n„| d k rA t  | | |  j ƒ nb| d k r` t  | | t ƒ nC| d k r t  | | t ƒ n$| d k r§ | j | g  ƒ j | ƒ nü | d k rÒ | j | g  ƒ j |  j ƒ nÑ | d k rt  | | | j | d ƒ d	 ƒ n¢ | d
 k rJ|  j pd } |  j p(i  } |  j |  | | | | | Ž nY | d k rm| j	 ƒ  | j
 ƒ  n6 | d k r| j ƒ  | j
 ƒ  n t d |  j ƒ ‚ d	 S(   NRœ   R   Rž   RŸ   R_   R    R¡   i    i   R™   RU   R¢   s   unknown action %r(    (   R¯   R˜   t   Truet   Falset   ensure_valueR_   Rš   R›   R™   t
   print_helpt   exitt   print_versionR-   R•   (	   R   R•   RX   Rn   R‹   RÓ   R'   t   argst   kwargs(    (    s   /usr/lib/python2.7/optparse.pyRÒ     s4    #

(
   Rœ   R   Rž   RŸ   R_   R    R¡   R™   RU   R¢   (   Rœ   R   Rž   RŸ   R_   R    R¡   (   Rœ   R_   R™   (   Rœ   R_   (   R   R    (   R£   R)   R…   Rˆ   R‰   R¤   N(#   R   R   R   R®   R³   RÃ   R¼   Rµ   RÅ   R»   RŽ   R’   RÍ   R&   R¨   R   R¥   R¦   R§   R´   R½   RÂ   RÄ   RÆ   RÇ   RÊ   R   R   t   __repr__Rr   RÌ   RÎ   RÑ   RÔ   RÒ   (    (    (    s   /usr/lib/python2.7/optparse.pyR    ¾  sŒ   	                   

																					t   SUPPRESSt   HELPt   USAGEc         C   s   t  |  t j t j f ƒ S(   N(   t
   isinstanceR·   t
   StringTypet   UnicodeType(   t   x(    (    s   /usr/lib/python2.7/optparse.pyt   isbasestring>  s    c         C   s   t  |  t ƒ S(   N(   Rá   t
   basestring(   Rä   (    (    s   /usr/lib/python2.7/optparse.pyRå   A  s    c           B   sh   e  Z d
 d  „ Z d „  Z e Z d „  Z d „  Z d „  Z	 d „  Z
 d d „ Z d d „ Z d	 „  Z RS(   c         C   s:   | r6 x- | j  ƒ  D] \ } } t |  | | ƒ q Wn  d  S(   N(   t   itemsR¯   (   R   RV   R²   R€   (    (    s   /usr/lib/python2.7/optparse.pyR   F  s    c         C   s   t  |  j ƒ S(   N(   R   t   __dict__(   R   (    (    s   /usr/lib/python2.7/optparse.pyR   K  s    c         C   sL   t  | t ƒ r" t |  j | j ƒ St  | t j ƒ rD t |  j | ƒ Sd Sd  S(   Niÿÿÿÿ(   Rá   R   t   cmpRè   R·   RÉ   (   R   t   other(    (    s   /usr/lib/python2.7/optparse.pyt   __cmp__P  s
    c         C   sS   xL t  |  ƒ D]> } | | k r | | } | d k	 rK t |  | | ƒ qK q q Wd S(   sû   
        Update the option values from an arbitrary dictionary, but only
        use keys from dict that already have a corresponding attribute
        in self.  Any keys in dict without a corresponding attribute
        are silently ignored.
        N(   t   dirR&   R¯   (   R   t   dictR²   t   dval(    (    s   /usr/lib/python2.7/optparse.pyt   _update_carefulX  s
    
c         C   s   |  j  j | ƒ d S(   sÅ   
        Update the option values from an arbitrary dictionary,
        using all keys from the dictionary regardless of whether
        they have a corresponding attribute in self or not.
        N(   Rè   t   update(   R   Rí   (    (    s   /usr/lib/python2.7/optparse.pyt   _update_loosee  s    c         C   sI   | d k r |  j  | ƒ n) | d k r8 |  j | ƒ n t d | ‚ d  S(   Nt   carefult   looses   invalid update mode: %r(   Rï   Rñ   R-   (   R   Rí   t   mode(    (    s   /usr/lib/python2.7/optparse.pyt   _updatem  s
    Rò   c         C   s1   t  | ƒ t j | } |  j t | ƒ | ƒ d  S(   N(   t
   __import__t   syst   modulesRõ   t   vars(   R   t   modnameRô   t   mod(    (    s   /usr/lib/python2.7/optparse.pyt   read_moduleu  s    
c         C   s'   i  } t  | | ƒ |  j | | ƒ d  S(   N(   t   execfileRõ   (   R   t   filenameRô   Rù   (    (    s   /usr/lib/python2.7/optparse.pyt	   read_filez  s    c         C   sE   t  |  | ƒ s% t |  | ƒ d  k r8 t |  | | ƒ n  t |  | ƒ S(   N(   R¹   Rº   R&   R¯   (   R   R²   R‹   (    (    s   /usr/lib/python2.7/optparse.pyR×     s    %N(   R   R   R&   R   R   R   RÝ   Rë   Rï   Rñ   Rõ   Rü   Rÿ   R×   (    (    (    s   /usr/lib/python2.7/optparse.pyR   D  s   					c           B   sž   e  Z d  Z d „  Z d „  Z d „  Z d „  Z d „  Z d „  Z d „  Z	 d „  Z
 d	 „  Z d
 „  Z d „  Z d „  Z d „  Z d „  Z d „  Z d „  Z RS(   s’  
    Abstract base class.

    Class attributes:
      standard_option_list : [Option]
        list of standard options that will be accepted by all instances
        of this parser class (intended to be overridden by subclasses).

    Instance attributes:
      option_list : [Option]
        the list of Option objects contained by this OptionContainer
      _short_opt : { string : Option }
        dictionary mapping short option strings, eg. "-f" or "-X",
        to the Option instances that implement them.  If an Option
        has multiple short option strings, it will appear in this
        dictionary multiple times. [1]
      _long_opt : { string : Option }
        dictionary mapping long option strings, eg. "--file" or
        "--exclude", to the Option instances that implement them.
        Again, a given Option can occur multiple times in this
        dictionary. [1]
      defaults : { string : any }
        dictionary mapping option destination names to default
        values for each destination [1]

    [1] These mappings are common to (shared by) all components of the
        controlling OptionParser, where they are initially created.

    c         C   s1   |  j  ƒ  | |  _ |  j | ƒ |  j | ƒ d  S(   N(   t   _create_option_listt   option_classt   set_conflict_handlert   set_description(   R   R  t   conflict_handlerRQ   (    (    s   /usr/lib/python2.7/optparse.pyR   ¥  s    
	c         C   s   i  |  _  i  |  _ i  |  _ d  S(   N(   t
   _short_optt	   _long_optRV   (   R   (    (    s   /usr/lib/python2.7/optparse.pyt   _create_option_mappings°  s    		c         C   s(   | j  |  _  | j |  _ | j |  _ d  S(   N(   R  R  RV   (   R   R'   (    (    s   /usr/lib/python2.7/optparse.pyt   _share_option_mappings¹  s    c         C   s)   | d k r t  d | ‚ n  | |  _ d  S(   Nt   errort   resolves$   invalid conflict_resolution value %r(   R	  R
  (   R-   R  (   R   t   handler(    (    s   /usr/lib/python2.7/optparse.pyR  À  s    c         C   s   | |  _  d  S(   N(   RQ   (   R   RQ   (    (    s   /usr/lib/python2.7/optparse.pyR  Å  s    c         C   s   |  j  S(   N(   RQ   (   R   (    (    s   /usr/lib/python2.7/optparse.pyt   get_descriptionÈ  s    c         C   s   |  `  |  ` |  ` d S(   s   see OptionParser.destroy().N(   R  R  RV   (   R   (    (    s   /usr/lib/python2.7/optparse.pyt   destroyÌ  s    c         C   sr  g  } x= | j  D]2 } | |  j k r | j | |  j | f ƒ q q Wx= | j D]2 } | |  j k rP | j | |  j | f ƒ qP qP W| rn|  j } | d k r× t d d j g  | D] } | d ^ q´ ƒ | ƒ ‚ qn| d k rnx… | D]z \ } } | j d ƒ r"| j j	 | ƒ |  j | =n | j  j	 | ƒ |  j | =| j  pK| j sê | j
 j j	 | ƒ qê qê Wqnn  d  S(   NR	  s    conflicting option string(s): %ss   , i    R
  s   --(   Ru   R  R_   Rv   R  R  R   R#   t
   startswitht   removet	   containerRj   (   R   R   t   conflict_optsRn   R  t   cot   c_option(    (    s   /usr/lib/python2.7/optparse.pyt   _check_conflictÕ  s.    !!	$
c         O   sD  t  | d ƒ t j k r. |  j | | Ž  } nN t | ƒ d k rs | rs | d } t | t ƒ s| t d | ‚ q| n	 t d ‚ |  j | ƒ |  j	 j
 | ƒ |  | _ x | j D] } | |  j | <q¬ Wx | j D] } | |  j | <qÍ W| j d k	 r@| j t k	 r| j |  j | j <q@| j |  j k r@d |  j | j <q@n  | S(   sO   add_option(Option)
           add_option(opt_str, ..., kwarg=val, ...)
        i    i   s   not an Option instance: %rs   invalid argumentsN(   R   R·   t   StringTypesR  R^   Rá   R    R¬   R  Rj   R_   R  Ru   R  Rv   R  RX   R&   R–   RY   RV   (   R   RÛ   RÜ   R   Rn   (    (    s   /usr/lib/python2.7/optparse.pyt
   add_optionð  s(    
		c         C   s"   x | D] } |  j  | ƒ q Wd  S(   N(   R  (   R   Rj   R   (    (    s   /usr/lib/python2.7/optparse.pyt   add_options  s    c         C   s"   |  j  j | ƒ p! |  j j | ƒ S(   N(   R  RW   R  (   R   R   (    (    s   /usr/lib/python2.7/optparse.pyt
   get_option  s    c         C   s   | |  j  k p | |  j k S(   N(   R  R  (   R   R   (    (    s   /usr/lib/python2.7/optparse.pyt
   has_option  s    c         C   s¥   |  j  j | ƒ } | d  k r3 |  j j | ƒ } n  | d  k rR t d | ƒ ‚ n  x | j D] } |  j  | =q\ Wx | j D] } |  j | =qz W| j j j	 | ƒ d  S(   Ns   no such option %r(
   R  RW   R&   R  R-   Ru   Rv   R  Rj   R  (   R   R   R   Rn   (    (    s   /usr/lib/python2.7/optparse.pyt   remove_option  s    c         C   s\   |  j  s d Sg  } x9 |  j  D]. } | j t k	 r | j | j | ƒ ƒ q q Wd j | ƒ S(   NR<   (   Rj   RU   R   R_   Ri   R#   (   R   t	   formatterRb   R   (    (    s   /usr/lib/python2.7/optparse.pyt   format_option_help,  s    	c         C   s   | j  |  j ƒ  ƒ S(   N(   RR   R  (   R   R  (    (    s   /usr/lib/python2.7/optparse.pyRR   5  s    c         C   sW   g  } |  j  r( | j |  j | ƒ ƒ n  |  j rJ | j |  j | ƒ ƒ n  d j | ƒ S(   Ns   
(   RQ   R_   RR   Rj   R  R#   (   R   R  Rb   (    (    s   /usr/lib/python2.7/optparse.pyt   format_help8  s    		(   R   R   R   R   R  R  R  R  R  R  R  R  R  R  R  R  R  RR   R  (    (    (    s   /usr/lib/python2.7/optparse.pyR   …  s"   																		c           B   s8   e  Z d d  „ Z d „  Z d „  Z d „  Z d „  Z RS(   c         C   s2   | |  _  t j |  | j | j | ƒ | |  _ d  S(   N(   R'   R   R   R  R  t   title(   R   R'   R  RQ   (    (    s   /usr/lib/python2.7/optparse.pyR   C  s    	c         C   s   g  |  _  |  j |  j ƒ d  S(   N(   Rj   R  R'   (   R   (    (    s   /usr/lib/python2.7/optparse.pyR   I  s    	c         C   s   | |  _  d  S(   N(   R  (   R   R  (    (    s   /usr/lib/python2.7/optparse.pyt	   set_titleM  s    c         C   s   t  j |  ƒ |  ` d S(   s   see OptionParser.destroy().N(   R   R  Rj   (   R   (    (    s   /usr/lib/python2.7/optparse.pyR  P  s    c         C   s@   | j  |  j ƒ } | j ƒ  | t j |  | ƒ 7} | j ƒ  | S(   N(   RI   R  RB   R   R  RD   (   R   R  Rb   (    (    s   /usr/lib/python2.7/optparse.pyR  W  s
    

N(   R   R   R&   R   R   R  R  R  (    (    (    s   /usr/lib/python2.7/optparse.pyR   A  s
   			c           B   s¦  e  Z d  Z g  Z d) d) e d) d d) d) e d) d) d „
 Z d „  Z d „  Z	 d „  Z
 d „  Z e d „ Z d „  Z d	 „  Z d
 „  Z d „  Z d „  Z d „  Z d „  Z d „  Z d „  Z d „  Z d „  Z d „  Z d) d) d „ Z d „  Z d „  Z d „  Z d „  Z d „  Z d „  Z d „  Z  d „  Z! d d) d „ Z" d „  Z# d  „  Z$ d) d! „ Z% d" „  Z& d) d# „ Z' d) d$ „ Z( d% „  Z) d) d& „ Z* d' „  Z+ d) d( „ Z, RS(*   s$  
    Class attributes:
      standard_option_list : [Option]
        list of standard options that will be accepted by all instances
        of this parser class (intended to be overridden by subclasses).

    Instance attributes:
      usage : string
        a usage string for your program.  Before it is displayed
        to the user, "%prog" will be expanded to the name of
        your program (self.prog or os.path.basename(sys.argv[0])).
      prog : string
        the name of the current program (to override
        os.path.basename(sys.argv[0])).
      description : string
        A paragraph of text giving a brief overview of your program.
        optparse reformats this paragraph to fit the current terminal
        width and prints it when the user requests help (after usage,
        but before the list of options).
      epilog : string
        paragraph of help text to print after option help

      option_groups : [OptionGroup]
        list of option groups in this parser (option groups are
        irrelevant for parsing the command-line, but very useful
        for generating help)

      allow_interspersed_args : bool = true
        if true, positional arguments may be interspersed with options.
        Assuming -a and -b each take a single argument, the command-line
          -ablah foo bar -bboo baz
        will be interpreted the same as
          -ablah -bboo -- foo bar baz
        If this flag were false, that command line would be interpreted as
          -ablah -- foo bar -bboo baz
        -- ie. we stop processing options as soon as we see the first
        non-option argument.  (This is the tradition followed by
        Python's getopt module, Perl's Getopt::Std, and other argument-
        parsing libraries, but it is generally annoying to users.)

      process_default_values : bool = true
        if true, option default values are processed similarly to option
        values from the command line: that is, they are passed to the
        type-checking function for the option's type (as long as the
        default value is a string).  (This really only matters if you
        have defined custom types; see SF bug #955889.)  Set it to false
        to restore the behaviour of Optik 1.4.1 and earlier.

      rargs : [string]
        the argument list currently being parsed.  Only set when
        parse_args() is active, and continually trimmed down as
        we consume arguments.  Mainly there for the benefit of
        callback options.
      largs : [string]
        the list of leftover arguments that we have skipped while
        parsing options.  If allow_interspersed_args is false, this
        list is always empty.
      values : Values
        the set of option values currently being accumulated.  Only
        set when parse_args() is active.  Also mainly for callbacks.

    Because of the 'rargs', 'largs', and 'values' attributes,
    OptionParser is not thread-safe.  If, for some perverse reason, you
    need to parse command-line arguments simultaneously in different
    threads, use different OptionParser instances.

    R	  c         C   s¢   t  j |  | | | ƒ |  j | ƒ |	 |  _ | |  _ t |  _ t |  _ | d  k r_ t	 ƒ  } n  | |  _
 |  j
 j |  ƒ |
 |  _ |  j | d | ƒ|  j ƒ  d  S(   Nt   add_help(   R   R   t	   set_usaget   progR¢   RÕ   t   allow_interspersed_argst   process_default_valuesR&   R	   R  R;   RS   t   _populate_option_listt   _init_parsing_state(   R   RF   Rj   R  R¢   R  RQ   R  t   add_help_optionR"  RS   (    (    s   /usr/lib/python2.7/optparse.pyR   §  s    						c         C   sA   t  j |  ƒ x |  j D] } | j ƒ  q W|  ` |  ` |  ` d S(   s  
        Declare that you are done with this OptionParser.  This cleans up
        reference cycles so the OptionParser (and all objects referenced by
        it) can be garbage-collected promptly.  After calling destroy(), the
        OptionParser is unusable.
        N(   R   R  Rl   Rj   R  (   R   Rp   (    (    s   /usr/lib/python2.7/optparse.pyR  É  s    c         C   s    g  |  _  g  |  _ |  j ƒ  d  S(   N(   Rj   Rl   R  (   R   (    (    s   /usr/lib/python2.7/optparse.pyR   Û  s    		c         C   s&   |  j  d d d d d t d ƒ ƒd  S(   Ns   -hs   --helpR•   RU   s   show this help message and exit(   R  R    (   R   (    (    s   /usr/lib/python2.7/optparse.pyt   _add_help_optionà  s    c         C   s#   |  j  d d d d t d ƒ ƒd  S(   Ns	   --versionR•   R¢   RU   s&   show program's version number and exit(   R  R    (   R   (    (    s   /usr/lib/python2.7/optparse.pyt   _add_version_optionå  s    c         C   s_   |  j  r |  j |  j  ƒ n  | r2 |  j | ƒ n  |  j rH |  j ƒ  n  | r[ |  j ƒ  n  d  S(   N(   t   standard_option_listR  R¢   R)  R(  (   R   Rj   R   (    (    s   /usr/lib/python2.7/optparse.pyR%  ê  s    		c         C   s   d  |  _ d  |  _ d  |  _ d  S(   N(   R&   t   rargst   largsRÓ   (   R   (    (    s   /usr/lib/python2.7/optparse.pyR&  ô  s    		c         C   sh   | d  k r t d ƒ |  _ nF | t k r6 d  |  _ n. | j ƒ  j d ƒ r[ | d |  _ n	 | |  _ d  S(   Ns   %prog [options]s   usage: i   (   R&   R    RF   R   R   R  (   R   RF   (    (    s   /usr/lib/python2.7/optparse.pyR!  ý  s    c         C   s   t  |  _ d S(   s  Set parsing to not stop on the first non-option, allowing
        interspersing switches with command arguments. This is the
        default behavior. See also disable_interspersed_args() and the
        class documentation description of the attribute
        allow_interspersed_args.N(   RÕ   R#  (   R   (    (    s   /usr/lib/python2.7/optparse.pyt   enable_interspersed_args  s    c         C   s   t  |  _ d S(   sé   Set parsing to stop on the first non-option. Use this if
        you have a command processor which runs another command that
        has options of its own and you want to make sure these options
        don't get confused.
        N(   RÖ   R#  (   R   (    (    s   /usr/lib/python2.7/optparse.pyt   disable_interspersed_args  s    c         C   s   | |  _  d  S(   N(   R$  (   R   RÔ   (    (    s   /usr/lib/python2.7/optparse.pyt   set_process_default_values  s    c         C   s   | |  j  | <d  S(   N(   RV   (   R   RX   R‹   (    (    s   /usr/lib/python2.7/optparse.pyt   set_default  s    c         K   s   |  j  j | ƒ d  S(   N(   RV   Rð   (   R   RÜ   (    (    s   /usr/lib/python2.7/optparse.pyt   set_defaults  s    c         C   s2   |  j  } x! |  j D] } | j | j  ƒ q W| S(   N(   Rj   Rl   Ra   (   R   t   optionsRp   (    (    s   /usr/lib/python2.7/optparse.pyt   _get_all_options!  s    
c         C   sŒ   |  j  s t |  j ƒ S|  j j ƒ  } xZ |  j ƒ  D]L } | j | j ƒ } t | ƒ r2 | j ƒ  } | j	 | | ƒ | | j <q2 q2 Wt | ƒ S(   N(
   R$  R   RV   t   copyR3  RW   RX   Rå   RÌ   RÎ   (   R   RV   R   R–   R   (    (    s   /usr/lib/python2.7/optparse.pyt   get_default_values'  s    	 c         O   s«   t  | d ƒ t j k r. t |  | | Ž } ni t | ƒ d k rŽ | rŽ | d } t | t ƒ sp t d | ‚ n  | j |  k	 r— t d ‚ q— n	 t d ‚ |  j	 j
 | ƒ | S(   Ni    i   s   not an OptionGroup instance: %rs"   invalid OptionGroup (wrong parser)s   invalid arguments(   R   R·   Râ   R   R^   Rá   R¬   R'   R-   Rl   R_   (   R   RÛ   RÜ   Rp   (    (    s   /usr/lib/python2.7/optparse.pyt   add_option_group8  s    
	c         C   sD   |  j  j | ƒ p! |  j j | ƒ } | r@ | j |  k	 r@ | j Sd  S(   N(   R  RW   R  R  R&   (   R   R   R   (    (    s   /usr/lib/python2.7/optparse.pyt   get_option_groupH  s
    c         C   s    | d  k r t j d S| Sd  S(   Ni   (   R&   R÷   t   argv(   R   RÛ   (    (    s   /usr/lib/python2.7/optparse.pyt	   _get_argsR  s    c         C   s«   |  j  | ƒ } | d k r* |  j ƒ  } n  | |  _ g  |  _ } | |  _ y |  j | | | ƒ } Wn, t t f k
 r } |  j	 t
 | ƒ ƒ n X| | } |  j | | ƒ S(   sR  
        parse_args(args : [string] = sys.argv[1:],
                   values : Values = None)
        -> (values : Values, args : [string])

        Parse the command-line options found in 'args' (default:
        sys.argv[1:]).  Any errors result in a call to 'error()', which
        by default prints the usage message to stderr and calls
        sys.exit() with an error message.  On success returns a pair
        (values, args) where 'values' is a Values instance (with all
        your option values) and 'args' is the list of arguments left
        over after parsing options.
        N(   R9  R&   R5  R+  R,  RÓ   t   _process_argsR   R   R	  R   t   check_values(   R   RÛ   RÓ   R+  R,  t   stopt   err(    (    s   /usr/lib/python2.7/optparse.pyt
   parse_argsX  s    		
c         C   s
   | | f S(   s³  
        check_values(values : Values, args : [string])
        -> (values : Values, args : [string])

        Check that the supplied option values and leftover arguments are
        valid.  Returns the option values and leftover arguments
        (possibly adjusted, possibly completely new -- whatever you
        like).  Default implementation just returns the passed-in
        values; subclasses may override as desired.
        (    (   R   RÓ   RÛ   (    (    s   /usr/lib/python2.7/optparse.pyR;    s    c         C   s±   xª | r¬ | d } | d k r* | d =d S| d d !d k rP |  j  | | ƒ q | d  d k r… t | ƒ d k r… |  j | | ƒ q |  j r¥ | j | ƒ | d =q d Sq Wd S(   s˜  _process_args(largs : [string],
                         rargs : [string],
                         values : Values)

        Process command-line arguments and populate 'values', consuming
        options and arguments from 'rargs'.  If 'allow_interspersed_args' is
        false, stop at the first non-option argument.  If true, accumulate any
        interspersed non-option arguments in 'largs'.
        i    s   --Ni   i   R­   (   t   _process_long_optR^   t   _process_short_optsR#  R_   (   R   R,  R+  RÓ   t   arg(    (    s   /usr/lib/python2.7/optparse.pyR:  Œ  s    
	
"	
c         C   s   t  | |  j ƒ S(   s  _match_long_opt(opt : string) -> string

        Determine which long option string 'opt' matches, ie. which one
        it is an unambiguous abbreviation for.  Raises BadOptionError if
        'opt' doesn't unambiguously match any long option string.
        (   t   _match_abbrevR  (   R   Rn   (    (    s   /usr/lib/python2.7/optparse.pyt   _match_long_opt¿  s    c   
      C   s_  | j  d ƒ } d | k rL | j d d ƒ \ } } | j d | ƒ t } n | } t } |  j | ƒ } |  j | } | j ƒ  r| j } t	 | ƒ | k  rá | d k rÁ |  j
 t d ƒ | ƒ q|  j
 t d ƒ | | f ƒ qE| d k rÿ | j  d ƒ }	 qEt | d | !ƒ }	 | d | 5n& | r?|  j
 t d ƒ | ƒ n d  }	 | j | |	 | |  ƒ d  S(   Ni    R@   i   s   %s option requires an arguments   %s option requires %d argumentss   %s option does not take a value(   t   popRÁ   t   insertRÕ   RÖ   RC  R  Rr   R—   R^   R	  R    RÏ   R&   RÔ   (
   R   R+  RÓ   RA  Rn   t   next_argt   had_explicit_valueR   R—   R‹   (    (    s   /usr/lib/python2.7/optparse.pyR?  È  s0    		c         C   so  | j  d ƒ } t } d } xM| d D]A} d | } |  j j | ƒ } | d 7} | sg t | ƒ ‚ n  | j ƒ  rA| t | ƒ k  r¢ | j d | | ƒ t } n  | j	 }	 t | ƒ |	 k  r|	 d k rã |  j
 t d ƒ | ƒ q>|  j
 t d ƒ | |	 f ƒ qG|	 d k r!| j  d ƒ }
 qGt | d |	 !ƒ }
 | d |	 5n d  }
 | j | |
 | |  ƒ | r& Pq& q& Wd  S(   Ni    i   R­   s   %s option requires an arguments   %s option requires %d arguments(   RD  RÖ   R  RW   R   Rr   R^   RE  RÕ   R—   R	  R    RÏ   R&   RÔ   (   R   R+  RÓ   RA  R<  t   it   chRn   R   R—   R‹   (    (    s   /usr/lib/python2.7/optparse.pyR@  í  s6    

		c         C   s1   |  j  d  k r& t j j t j d ƒ S|  j  Sd  S(   Ni    (   R"  R&   R*   t   patht   basenameR÷   R8  (   R   (    (    s   /usr/lib/python2.7/optparse.pyt   get_prog_name  s    c         C   s   | j  d |  j ƒ  ƒ S(   Ns   %prog(   R[   RL  (   R   t   s(    (    s   /usr/lib/python2.7/optparse.pyt   expand_prog_name  s    c         C   s   |  j  |  j ƒ S(   N(   RN  RQ   (   R   (    (    s   /usr/lib/python2.7/optparse.pyR     s    i    c         C   s*   | r t  j j | ƒ n  t  j | ƒ d  S(   N(   R÷   t   stderrt   writeRÙ   (   R   t   statusR   (    (    s   /usr/lib/python2.7/optparse.pyRÙ   #  s    c         C   s4   |  j  t j ƒ |  j d d |  j ƒ  | f ƒ d S(   sÜ   error(msg : string)

        Print a usage message incorporating 'msg' to stderr and exit.
        If you override this in a subclass, it should not return -- it
        should either exit or raise an exception.
        i   s   %s: error: %s
N(   t   print_usageR÷   RO  RÙ   RL  (   R   R   (    (    s   /usr/lib/python2.7/optparse.pyR	  (  s    c         C   s-   |  j  r% |  j j |  j |  j  ƒ ƒ Sd Sd  S(   NR<   (   RF   R  RG   RN  (   R   (    (    s   /usr/lib/python2.7/optparse.pyt	   get_usage2  s    		c         C   s    |  j  r | |  j ƒ  IJn  d S(   sa  print_usage(file : file = stdout)

        Print the usage message for the current program (self.usage) to
        'file' (default stdout).  Any occurrence of the string "%prog" in
        self.usage is replaced with the name of the current program
        (basename of sys.argv[0]).  Does nothing if self.usage is empty
        or not defined.
        N(   RF   RS  (   R   t   file(    (    s   /usr/lib/python2.7/optparse.pyRR  9  s    		c         C   s!   |  j  r |  j |  j  ƒ Sd Sd  S(   NR<   (   R¢   RN  (   R   (    (    s   /usr/lib/python2.7/optparse.pyt   get_versionE  s    	c         C   s    |  j  r | |  j ƒ  IJn  d S(   sE  print_version(file : file = stdout)

        Print the version message for this program (self.version) to
        'file' (default stdout).  As with print_usage(), any occurrence
        of "%prog" in self.version is replaced by the current program's
        name.  Does nothing if self.version is empty or undefined.
        N(   R¢   RU  (   R   RT  (    (    s   /usr/lib/python2.7/optparse.pyRÚ   K  s    	c         C   sÕ   | d  k r |  j } n  | j |  ƒ g  } | j | j t d ƒ ƒ ƒ | j ƒ  |  j rƒ | j t j	 |  | ƒ ƒ | j d ƒ n  x4 |  j
 D]) } | j | j | ƒ ƒ | j d ƒ q W| j ƒ  d j | d  ƒ S(   Nt   Optionss   
R<   iÿÿÿÿ(   R&   R  Rq   R_   RI   R    RB   Rj   R   R  Rl   R  RD   R#   (   R   R  Rb   Rp   (    (    s   /usr/lib/python2.7/optparse.pyR  V  s    
	
c         C   s   | j  |  j ƒ S(   N(   RT   RS   (   R   R  (    (    s   /usr/lib/python2.7/optparse.pyRT   g  s    c         C   s    | d  k r |  j } n  g  } |  j rA | j |  j ƒ  d ƒ n  |  j rg | j |  j | ƒ d ƒ n  | j |  j | ƒ ƒ | j |  j | ƒ ƒ d j	 | ƒ S(   Ns   
R<   (
   R&   R  RF   R_   RS  RQ   RR   R  RT   R#   (   R   R  Rb   (    (    s   /usr/lib/python2.7/optparse.pyR  j  s    		c         C   s+   t  | d d  ƒ } | s' t j ƒ  } n  | S(   Nt   encoding(   Rº   R&   R÷   t   getdefaultencoding(   R   RT  RW  (    (    s   /usr/lib/python2.7/optparse.pyt   _get_encodingw  s    c         C   sJ   | d k r t j } n  |  j | ƒ } | j |  j ƒ  j | d ƒ ƒ d S(   s°   print_help(file : file = stdout)

        Print an extended help message, listing all options and any
        help text provided with them, to 'file' (default stdout).
        R[   N(   R&   R÷   t   stdoutRY  RP  R  t   encode(   R   RT  RW  (    (    s   /usr/lib/python2.7/optparse.pyRØ   }  s    N(-   R   R   R   R*  R&   R    RÕ   R   R  R   R(  R)  R%  R&  R!  R-  R.  R/  R0  R1  R3  R5  R6  R7  R9  R>  R;  R:  RC  R?  R@  RL  RN  R  RÙ   R	  RS  RR  RU  RÚ   R  RT   R  RY  RØ   (    (    (    s   /usr/lib/python2.7/optparse.pyR   _  sb   D				
												
	'		3			%	*				
				c         C   sŠ   |  | k r |  Sg  | j  ƒ  D] } | j |  ƒ r | ^ q } t | ƒ d k rX | d S| sm t |  ƒ ‚ n | j ƒ  t |  | ƒ ‚ d S(   sû   _match_abbrev(s : string, wordmap : {string : Option}) -> string

    Return the string key in 'wordmap' for which 's' is an unambiguous
    abbreviation.  If 's' is found to be ambiguous or doesn't match any of
    'words', raise BadOptionError.
    i   i    N(   R°   R  R^   R   R±   R!   (   RM  t   wordmapt   wordR"   (    (    s   /usr/lib/python2.7/optparse.pyRB  ‹  s    
(+   R   t   __version__t   __all__t   __copyright__R÷   R*   R·   RL   R   R   t   ImportErrorR    t	   ExceptionR   R   R   R   R   R!   R   R	   R
   Rƒ   R„   R†   Rˆ   R‰   RŠ   RŽ   R’   RY   R    R   R   Ræ   t	   NameErrorRå   R   R   R   R   RB  R   (    (    (    s   /usr/lib/python2.7/optparse.pyt   <module>   s~   	 	

Ï					ÿ {

	A¼ÿ ÿ .	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  r"""OS routines for NT or Posix depending on what system we're on.

This exports:
  - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.
  - os.path is one of the modules posixpath, or ntpath
  - os.name is 'posix', 'nt', 'os2', 'ce' or 'riscos'
  - os.curdir is a string representing the current directory ('.' or ':')
  - os.pardir is a string representing the parent directory ('..' or '::')
  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\')
  - os.extsep is the extension separator ('.' or '/')
  - os.altsep is the alternate pathname separator (None or '/')
  - os.pathsep is the component separator used in $PATH etc
  - os.linesep is the line separator in text files ('\r' or '\n' or '\r\n')
  - os.defpath is the default search path for executables
  - os.devnull is the file path of the null device ('/dev/null', etc.)

Programs that import and use 'os' stand a better chance of being
portable between different platforms.  Of course, they must then
only use functions that are defined by all platforms (e.g., unlink
and opendir), and leave all pathname manipulation to os.path
(e.g., split and join).
"""

#'

import sys, errno

_names = sys.builtin_module_names

# Note:  more names are added to __all__ later.
__all__ = ["altsep", "curdir", "pardir", "sep", "extsep", "pathsep", "linesep",
           "defpath", "name", "path", "devnull",
           "SEEK_SET", "SEEK_CUR", "SEEK_END"]

def _get_exports_list(module):
    try:
        return list(module.__all__)
    except AttributeError:
        return [n for n in dir(module) if n[0] != '_']

if 'posix' in _names:
    name = 'posix'
    linesep = '\n'
    from posix import *
    try:
        from posix import _exit
    except ImportError:
        pass
    import posixpath as path

    import posix
    __all__.extend(_get_exports_list(posix))
    del posix

elif 'nt' in _names:
    name = 'nt'
    linesep = '\r\n'
    from nt import *
    try:
        from nt import _exit
    except ImportError:
        pass
    import ntpath as path

    import nt
    __all__.extend(_get_exports_list(nt))
    del nt

elif 'os2' in _names:
    name = 'os2'
    linesep = '\r\n'
    from os2 import *
    try:
        from os2 import _exit
    except ImportError:
        pass
    if sys.version.find('EMX GCC') == -1:
        import ntpath as path
    else:
        import os2emxpath as path
        from _emx_link import link

    import os2
    __all__.extend(_get_exports_list(os2))
    del os2

elif 'ce' in _names:
    name = 'ce'
    linesep = '\r\n'
    from ce import *
    try:
        from ce import _exit
    except ImportError:
        pass
    # We can use the standard Windows path.
    import ntpath as path

    import ce
    __all__.extend(_get_exports_list(ce))
    del ce

elif 'riscos' in _names:
    name = 'riscos'
    linesep = '\n'
    from riscos import *
    try:
        from riscos import _exit
    except ImportError:
        pass
    import riscospath as path

    import riscos
    __all__.extend(_get_exports_list(riscos))
    del riscos

else:
    raise ImportError, 'no os specific module found'

sys.modules['os.path'] = path
from os.path import (curdir, pardir, sep, pathsep, defpath, extsep, altsep,
    devnull)

del _names

# Python uses fixed values for the SEEK_ constants; they are mapped
# to native constants if necessary in posixmodule.c
SEEK_SET = 0
SEEK_CUR = 1
SEEK_END = 2

#'

# Super directory utilities.
# (Inspired by Eric Raymond; the doc strings are mostly his)

def makedirs(name, mode=0777):
    """makedirs(path [, mode=0777])

    Super-mkdir; create a leaf directory and all intermediate ones.
    Works like mkdir, except that any intermediate path segment (not
    just the rightmost) will be created if it does not exist.  This is
    recursive.

    """
    head, tail = path.split(name)
    if not tail:
        head, tail = path.split(head)
    if head and tail and not path.exists(head):
        try:
            makedirs(head, mode)
        except OSError, e:
            # be happy if someone already created the path
            if e.errno != errno.EEXIST:
                raise
        if tail == curdir:           # xxx/newdir/. exists if xxx/newdir exists
            return
    mkdir(name, mode)

def removedirs(name):
    """removedirs(path)

    Super-rmdir; remove a leaf directory and all empty intermediate
    ones.  Works like rmdir except that, if the leaf directory is
    successfully removed, directories corresponding to rightmost path
    segments will be pruned away until either the whole path is
    consumed or an error occurs.  Errors during this latter phase are
    ignored -- they generally mean that a directory was not empty.

    """
    rmdir(name)
    head, tail = path.split(name)
    if not tail:
        head, tail = path.split(head)
    while head and tail:
        try:
            rmdir(head)
        except error:
            break
        head, tail = path.split(head)

def renames(old, new):
    """renames(old, new)

    Super-rename; create directories as necessary and delete any left
    empty.  Works like rename, except creation of any intermediate
    directories needed to make the new pathname good is attempted
    first.  After the rename, directories corresponding to rightmost
    path segments of the old name will be pruned until either the
    whole path is consumed or a nonempty directory is found.

    Note: this function can fail with the new directory structure made
    if you lack permissions needed to unlink the leaf directory or
    file.

    """
    head, tail = path.split(new)
    if head and tail and not path.exists(head):
        makedirs(head)
    rename(old, new)
    head, tail = path.split(old)
    if head and tail:
        try:
            removedirs(head)
        except error:
            pass

__all__.extend(["makedirs", "removedirs", "renames"])

def walk(top, topdown=True, onerror=None, followlinks=False):
    """Directory tree generator.

    For each directory in the directory tree rooted at top (including top
    itself, but excluding '.' and '..'), yields a 3-tuple

        dirpath, dirnames, filenames

    dirpath is a string, the path to the directory.  dirnames is a list of
    the names of the subdirectories in dirpath (excluding '.' and '..').
    filenames is a list of the names of the non-directory files in dirpath.
    Note that the names in the lists are just names, with no path components.
    To get a full path (which begins with top) to a file or directory in
    dirpath, do os.path.join(dirpath, name).

    If optional arg 'topdown' is true or not specified, the triple for a
    directory is generated before the triples for any of its subdirectories
    (directories are generated top down).  If topdown is false, the triple
    for a directory is generated after the triples for all of its
    subdirectories (directories are generated bottom up).

    When topdown is true, the caller can modify the dirnames list in-place
    (e.g., via del or slice assignment), and walk will only recurse into the
    subdirectories whose names remain in dirnames; this can be used to prune the
    search, or to impose a specific order of visiting.  Modifying dirnames when
    topdown is false is ineffective, since the directories in dirnames have
    already been generated by the time dirnames itself is generated. No matter
    the value of topdown, the list of subdirectories is retrieved before the
    tuples for the directory and its subdirectories are generated.

    By default errors from the os.listdir() call are ignored.  If
    optional arg 'onerror' is specified, it should be a function; it
    will be called with one argument, an os.error instance.  It can
    report the error to continue with the walk, or raise the exception
    to abort the walk.  Note that the filename is available as the
    filename attribute of the exception object.

    By default, os.walk does not follow symbolic links to subdirectories on
    systems that support them.  In order to get this functionality, set the
    optional argument 'followlinks' to true.

    Caution:  if you pass a relative pathname for top, don't change the
    current working directory between resumptions of walk.  walk never
    changes the current directory, and assumes that the client doesn't
    either.

    Example:

    import os
    from os.path import join, getsize
    for root, dirs, files in os.walk('python/Lib/email'):
        print root, "consumes",
        print sum([getsize(join(root, name)) for name in files]),
        print "bytes in", len(files), "non-directory files"
        if 'CVS' in dirs:
            dirs.remove('CVS')  # don't visit CVS directories

    """

    islink, join, isdir = path.islink, path.join, path.isdir

    # We may not have read permission for top, in which case we can't
    # get a list of the files the directory contains.  os.path.walk
    # always suppressed the exception then, rather than blow up for a
    # minor reason when (say) a thousand readable directories are still
    # left to visit.  That logic is copied here.
    try:
        # Note that listdir and error are globals in this module due
        # to earlier import-*.
        names = listdir(top)
    except error, err:
        if onerror is not None:
            onerror(err)
        return

    dirs, nondirs = [], []
    for name in names:
        if isdir(join(top, name)):
            dirs.append(name)
        else:
            nondirs.append(name)

    if topdown:
        yield top, dirs, nondirs
    for name in dirs:
        new_path = join(top, name)
        if followlinks or not islink(new_path):
            for x in walk(new_path, topdown, onerror, followlinks):
                yield x
    if not topdown:
        yield top, dirs, nondirs

__all__.append("walk")

# Make sure os.environ exists, at least
try:
    environ
except NameError:
    environ = {}

def execl(file, *args):
    """execl(file, *args)

    Execute the executable file with argument list args, replacing the
    current process. """
    execv(file, args)

def execle(file, *args):
    """execle(file, *args, env)

    Execute the executable file with argument list args and
    environment env, replacing the current process. """
    env = args[-1]
    execve(file, args[:-1], env)

def execlp(file, *args):
    """execlp(file, *args)

    Execute the executable file (which is searched for along $PATH)
    with argument list args, replacing the current process. """
    execvp(file, args)

def execlpe(file, *args):
    """execlpe(file, *args, env)

    Execute the executable file (which is searched for along $PATH)
    with argument list args and environment env, replacing the current
    process. """
    env = args[-1]
    execvpe(file, args[:-1], env)

def execvp(file, args):
    """execvp(file, args)

    Execute the executable file (which is searched for along $PATH)
    with argument list args, replacing the current process.
    args may be a list or tuple of strings. """
    _execvpe(file, args)

def execvpe(file, args, env):
    """execvpe(file, args, env)

    Execute the executable file (which is searched for along $PATH)
    with argument list args and environment env , replacing the
    current process.
    args may be a list or tuple of strings. """
    _execvpe(file, args, env)

__all__.extend(["execl","execle","execlp","execlpe","execvp","execvpe"])

def _execvpe(file, args, env=None):
    if env is not None:
        func = execve
        argrest = (args, env)
    else:
        func = execv
        argrest = (args,)
        env = environ

    head, tail = path.split(file)
    if head:
        func(file, *argrest)
        return
    if 'PATH' in env:
        envpath = env['PATH']
    else:
        envpath = defpath
    PATH = envpath.split(pathsep)
    saved_exc = None
    saved_tb = None
    for dir in PATH:
        fullname = path.join(dir, file)
        try:
            func(fullname, *argrest)
        except error, e:
            tb = sys.exc_info()[2]
            if (e.errno != errno.ENOENT and e.errno != errno.ENOTDIR
                and saved_exc is None):
                saved_exc = e
                saved_tb = tb
    if saved_exc:
        raise error, saved_exc, saved_tb
    raise error, e, tb

# Change environ to automatically call putenv() if it exists
try:
    # This will fail if there's no putenv
    putenv
except NameError:
    pass
else:
    import UserDict

    # Fake unsetenv() for Windows
    # not sure about os2 here but
    # I'm guessing they are the same.

    if name in ('os2', 'nt'):
        def unsetenv(key):
            putenv(key, "")

    if name == "riscos":
        # On RISC OS, all env access goes through getenv and putenv
        from riscosenviron import _Environ
    elif name in ('os2', 'nt'):  # Where Env Var Names Must Be UPPERCASE
        # But we store them as upper case
        class _Environ(UserDict.IterableUserDict):
            def __init__(self, environ):
                UserDict.UserDict.__init__(self)
                data = self.data
                for k, v in environ.items():
                    data[k.upper()] = v
            def __setitem__(self, key, item):
                putenv(key, item)
                self.data[key.upper()] = item
            def __getitem__(self, key):
                return self.data[key.upper()]
            try:
                unsetenv
            except NameError:
                def __delitem__(self, key):
                    del self.data[key.upper()]
            else:
                def __delitem__(self, key):
                    unsetenv(key)
                    del self.data[key.upper()]
                def clear(self):
                    for key in self.data.keys():
                        unsetenv(key)
                        del self.data[key]
                def pop(self, key, *args):
                    unsetenv(key)
                    return self.data.pop(key.upper(), *args)
            def has_key(self, key):
                return key.upper() in self.data
            def __contains__(self, key):
                return key.upper() in self.data
            def get(self, key, failobj=None):
                return self.data.get(key.upper(), failobj)
            def update(self, dict=None, **kwargs):
                if dict:
                    try:
                        keys = dict.keys()
                    except AttributeError:
                        # List of (key, value)
                        for k, v in dict:
                            self[k] = v
                    else:
                        # got keys
                        # cannot use items(), since mappings
                        # may not have them.
                        for k in keys:
                            self[k] = dict[k]
                if kwargs:
                    self.update(kwargs)
            def copy(self):
                return dict(self)

    else:  # Where Env Var Names Can Be Mixed Case
        class _Environ(UserDict.IterableUserDict):
            def __init__(self, environ):
                UserDict.UserDict.__init__(self)
                self.data = environ
            def __setitem__(self, key, item):
                putenv(key, item)
                self.data[key] = item
            def update(self,  dict=None, **kwargs):
                if dict:
                    try:
                        keys = dict.keys()
                    except AttributeError:
                        # List of (key, value)
                        for k, v in dict:
                            self[k] = v
                    else:
                        # got keys
                        # cannot use items(), since mappings
                        # may not have them.
                        for k in keys:
                            self[k] = dict[k]
                if kwargs:
                    self.update(kwargs)
            try:
                unsetenv
            except NameError:
                pass
            else:
                def __delitem__(self, key):
                    unsetenv(key)
                    del self.data[key]
                def clear(self):
                    for key in self.data.keys():
                        unsetenv(key)
                        del self.data[key]
                def pop(self, key, *args):
                    unsetenv(key)
                    return self.data.pop(key, *args)
            def copy(self):
                return dict(self)


    environ = _Environ(environ)

def getenv(key, default=None):
    """Get an environment variable, return None if it doesn't exist.
    The optional second argument can specify an alternate default."""
    return environ.get(key, default)
__all__.append("getenv")

def _exists(name):
    return name in globals()

# Supply spawn*() (probably only for Unix)
if _exists("fork") and not _exists("spawnv") and _exists("execv"):

    P_WAIT = 0
    P_NOWAIT = P_NOWAITO = 1

    # XXX Should we support P_DETACH?  I suppose it could fork()**2
    # and close the std I/O streams.  Also, P_OVERLAY is the same
    # as execv*()?

    def _spawnvef(mode, file, args, env, func):
        # Internal helper; func is the exec*() function to use
        pid = fork()
        if not pid:
            # Child
            try:
                if env is None:
                    func(file, args)
                else:
                    func(file, args, env)
            except:
                _exit(127)
        else:
            # Parent
            if mode == P_NOWAIT:
                return pid # Caller is responsible for waiting!
            while 1:
                wpid, sts = waitpid(pid, 0)
                if WIFSTOPPED(sts):
                    continue
                elif WIFSIGNALED(sts):
                    return -WTERMSIG(sts)
                elif WIFEXITED(sts):
                    return WEXITSTATUS(sts)
                else:
                    raise error, "Not stopped, signaled or exited???"

    def spawnv(mode, file, args):
        """spawnv(mode, file, args) -> integer

Execute file with arguments from args in a subprocess.
If mode == P_NOWAIT return the pid of the process.
If mode == P_WAIT return the process's exit code if it exits normally;
otherwise return -SIG, where SIG is the signal that killed it. """
        return _spawnvef(mode, file, args, None, execv)

    def spawnve(mode, file, args, env):
        """spawnve(mode, file, args, env) -> integer

Execute file with arguments from args in a subprocess with the
specified environment.
If mode == P_NOWAIT return the pid of the process.
If mode == P_WAIT return the process's exit code if it exits normally;
otherwise return -SIG, where SIG is the signal that killed it. """
        return _spawnvef(mode, file, args, env, execve)

    # Note: spawnvp[e] is't currently supported on Windows

    def spawnvp(mode, file, args):
        """spawnvp(mode, file, args) -> integer

Execute file (which is looked for along $PATH) with arguments from
args in a subprocess.
If mode == P_NOWAIT return the pid of the process.
If mode == P_WAIT return the process's exit code if it exits normally;
otherwise return -SIG, where SIG is the signal that killed it. """
        return _spawnvef(mode, file, args, None, execvp)

    def spawnvpe(mode, file, args, env):
        """spawnvpe(mode, file, args, env) -> integer

Execute file (which is looked for along $PATH) with arguments from
args in a subprocess with the supplied environment.
If mode == P_NOWAIT return the pid of the process.
If mode == P_WAIT return the process's exit code if it exits normally;
otherwise return -SIG, where SIG is the signal that killed it. """
        return _spawnvef(mode, file, args, env, execvpe)

if _exists("spawnv"):
    # These aren't supplied by the basic Windows code
    # but can be easily implemented in Python

    def spawnl(mode, file, *args):
        """spawnl(mode, file, *args) -> integer

Execute file with arguments from args in a subprocess.
If mode == P_NOWAIT return the pid of the process.
If mode == P_WAIT return the process's exit code if it exits normally;
otherwise return -SIG, where SIG is the signal that killed it. """
        return spawnv(mode, file, args)

    def spawnle(mode, file, *args):
        """spawnle(mode, file, *args, env) -> integer

Execute file with arguments from args in a subprocess with the
supplied environment.
If mode == P_NOWAIT return the pid of the process.
If mode == P_WAIT return the process's exit code if it exits normally;
otherwise return -SIG, where SIG is the signal that killed it. """
        env = args[-1]
        return spawnve(mode, file, args[:-1], env)


    __all__.extend(["spawnv", "spawnve", "spawnl", "spawnle",])


if _exists("spawnvp"):
    # At the moment, Windows doesn't implement spawnvp[e],
    # so it won't have spawnlp[e] either.
    def spawnlp(mode, file, *args):
        """spawnlp(mode, file, *args) -> integer

Execute file (which is looked for along $PATH) with arguments from
args in a subprocess with the supplied environment.
If mode == P_NOWAIT return the pid of the process.
If mode == P_WAIT return the process's exit code if it exits normally;
otherwise return -SIG, where SIG is the signal that killed it. """
        return spawnvp(mode, file, args)

    def spawnlpe(mode, file, *args):
        """spawnlpe(mode, file, *args, env) -> integer

Execute file (which is looked for along $PATH) with arguments from
args in a subprocess with the supplied environment.
If mode == P_NOWAIT return the pid of the process.
If mode == P_WAIT return the process's exit code if it exits normally;
otherwise return -SIG, where SIG is the signal that killed it. """
        env = args[-1]
        return spawnvpe(mode, file, args[:-1], env)


    __all__.extend(["spawnvp", "spawnvpe", "spawnlp", "spawnlpe",])


# Supply popen2 etc. (for Unix)
if _exists("fork"):
    if not _exists("popen2"):
        def popen2(cmd, mode="t", bufsize=-1):
            """Execute the shell command 'cmd' in a sub-process.  On UNIX, 'cmd'
            may be a sequence, in which case arguments will be passed directly to
            the program without shell intervention (as with os.spawnv()).  If 'cmd'
            is a string it will be passed to the shell (as with os.system()). If
            'bufsize' is specified, it sets the buffer size for the I/O pipes.  The
            file objects (child_stdin, child_stdout) are returned."""
            import warnings
            msg = "os.popen2 is deprecated.  Use the subprocess module."
            warnings.warn(msg, DeprecationWarning, stacklevel=2)

            import subprocess
            PIPE = subprocess.PIPE
            p = subprocess.Popen(cmd, shell=isinstance(cmd, basestring),
                                 bufsize=bufsize, stdin=PIPE, stdout=PIPE,
                                 close_fds=True)
            return p.stdin, p.stdout
        __all__.append("popen2")

    if not _exists("popen3"):
        def popen3(cmd, mode="t", bufsize=-1):
            """Execute the shell command 'cmd' in a sub-process.  On UNIX, 'cmd'
            may be a sequence, in which case arguments will be passed directly to
            the program without shell intervention (as with os.spawnv()).  If 'cmd'
            is a string it will be passed to the shell (as with os.system()). If
            'bufsize' is specified, it sets the buffer size for the I/O pipes.  The
            file objects (child_stdin, child_stdout, child_stderr) are returned."""
            import warnings
            msg = "os.popen3 is deprecated.  Use the subprocess module."
            warnings.warn(msg, DeprecationWarning, stacklevel=2)

            import subprocess
            PIPE = subprocess.PIPE
            p = subprocess.Popen(cmd, shell=isinstance(cmd, basestring),
                                 bufsize=bufsize, stdin=PIPE, stdout=PIPE,
                                 stderr=PIPE, close_fds=True)
            return p.stdin, p.stdout, p.stderr
        __all__.append("popen3")

    if not _exists("popen4"):
        def popen4(cmd, mode="t", bufsize=-1):
            """Execute the shell command 'cmd' in a sub-process.  On UNIX, 'cmd'
            may be a sequence, in which case arguments will be passed directly to
            the program without shell intervention (as with os.spawnv()).  If 'cmd'
            is a string it will be passed to the shell (as with os.system()). If
            'bufsize' is specified, it sets the buffer size for the I/O pipes.  The
            file objects (child_stdin, child_stdout_stderr) are returned."""
            import warnings
            msg = "os.popen4 is deprecated.  Use the subprocess module."
            warnings.warn(msg, DeprecationWarning, stacklevel=2)

            import subprocess
            PIPE = subprocess.PIPE
            p = subprocess.Popen(cmd, shell=isinstance(cmd, basestring),
                                 bufsize=bufsize, stdin=PIPE, stdout=PIPE,
                                 stderr=subprocess.STDOUT, close_fds=True)
            return p.stdin, p.stdout
        __all__.append("popen4")

import copy_reg as _copy_reg

def _make_stat_result(tup, dict):
    return stat_result(tup, dict)

def _pickle_stat_result(sr):
    (type, args) = sr.__reduce__()
    return (_make_stat_result, args)

try:
    _copy_reg.pickle(stat_result, _pickle_stat_result, _make_stat_result)
except NameError: # stat_result may not exist
    pass

def _make_statvfs_result(tup, dict):
    return statvfs_result(tup, dict)

def _pickle_statvfs_result(sr):
    (type, args) = sr.__reduce__()
    return (_make_statvfs_result, args)

try:
    _copy_reg.pickle(statvfs_result, _pickle_statvfs_result,
                     _make_statvfs_result)
except NameError: # statvfs_result may not exist
    pass
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ó
Ó«[c           @   sú  d  Z  d d l Z d d l Z e j Z d d d d d d d	 d
 d d d d d d g Z d „  Z d e k rÛ d Z d Z d d l	 Ty d d l	 m
 Z
 Wn e k
 r© n Xd d l Z d d l	 Z	 e j e e	 ƒ ƒ [	 n,d e k rVd Z d Z d d l Ty d d l m
 Z
 Wn e k
 r$n Xd d l Z d d l Z e j e e ƒ ƒ [ n±d e k rd Z d Z d d l Ty d d l m
 Z
 Wn e k
 rŸn Xe j j d ƒ d k rÇd d l Z n d d l Z d d l m Z d d l Z e j e e ƒ ƒ [ nÿ d e k rƒd Z d Z d d l Ty d d l m
 Z
 Wn e k
 rQn Xd d l Z d d l Z e j e e ƒ ƒ [ n„ d e k rþd Z d Z d d l Ty d d l m
 Z
 Wn e k
 rÌn Xd d l Z d d l Z e j e e ƒ ƒ [ n	 e d ‚ e e j d <d d l m Z m Z m Z m Z m  Z  m! Z! m" Z" m# Z# [ d  Z$ d! Z% d" Z& d# d$ „ Z' d% „  Z( d& „  Z) e j d' d( d) g ƒ e* d e, d* „ Z- e j. d+ ƒ y e/ Wn e0 k
 r×i  Z/ n Xd, „  Z1 d- „  Z2 d. „  Z3 d/ „  Z4 d0 „  Z5 d1 „  Z6 e j d2 d3 d4 d5 d6 d7 g ƒ d d8 „ Z7 y e8 Wn e0 k
 rTn‘ Xd d l9 Z9 e d_ k ryd9 „  Z: n  e d k r˜d d: l; m< Z< nA e d` k rÀd; e9 j= f d< „  ƒ  YZ< n d; e9 j= f d= „  ƒ  YZ< e< e/ ƒ Z/ d d> „ Z> e j. d? ƒ d@ „  Z? e? dA ƒ rle? dB ƒ rle? dC ƒ rld  Z@ d! ZA ZB dD „  ZC dE „  ZD dF „  ZE dG „  ZF dH „  ZG n  e? dB ƒ r¦dI „  ZH dJ „  ZI e j dB dK dL dM g ƒ n  e? dN ƒ ràdO „  ZJ dP „  ZK e j dN dQ dR dS g ƒ n  e? dA ƒ rpe? dT ƒ sdU d dV „ ZL e j. dT ƒ n  e? dW ƒ sBdU d dX „ ZM e j. dW ƒ n  e? dY ƒ spdU d dZ „ ZN e j. dY ƒ qpn  d d lO ZP d[ „  ZQ d\ „  ZR y eP jS eT eR eQ ƒ Wn e0 k
 r¸n Xd] „  ZU d^ „  ZV y eP jS eW eV eU ƒ Wn e0 k
 rõn Xd S(a   s}  OS routines for NT or Posix depending on what system we're on.

This exports:
  - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.
  - os.path is one of the modules posixpath, or ntpath
  - os.name is 'posix', 'nt', 'os2', 'ce' or 'riscos'
  - os.curdir is a string representing the current directory ('.' or ':')
  - os.pardir is a string representing the parent directory ('..' or '::')
  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\')
  - os.extsep is the extension separator ('.' or '/')
  - os.altsep is the alternate pathname separator (None or '/')
  - os.pathsep is the component separator used in $PATH etc
  - os.linesep is the line separator in text files ('\r' or '\n' or '\r\n')
  - os.defpath is the default search path for executables
  - os.devnull is the file path of the null device ('/dev/null', etc.)

Programs that import and use 'os' stand a better chance of being
portable between different platforms.  Of course, they must then
only use functions that are defined by all platforms (e.g., unlink
and opendir), and leave all pathname manipulation to os.path
(e.g., split and join).
iÿÿÿÿNt   altsept   curdirt   pardirt   sept   extsept   pathsept   linesept   defpatht   namet   patht   devnullt   SEEK_SETt   SEEK_CURt   SEEK_ENDc         C   sS   y t  |  j ƒ SWn; t k
 rN g  t |  ƒ D] } | d d k r. | ^ q. SXd  S(   Ni    t   _(   t   listt   __all__t   AttributeErrort   dir(   t   modulet   n(    (    s   /usr/lib/python2.7/os.pyt   _get_exports_list#   s    t   posixs   
(   t   *(   t   _exitt   nts   
t   os2s   EMX GCC(   t   linkt   cet   riscoss   no os specific module founds   os.path(   R   R   R   R   R   R   R    R
   i    i   i   iÿ  c         C   s²   t  j |  ƒ \ } } | s3 t  j | ƒ \ } } n  | r¡ | r¡ t  j | ƒ r¡ y t | | ƒ Wn+ t k
 r } | j t j k rŽ ‚  qŽ n X| t k r¡ d Sn  t |  | ƒ d S(   s  makedirs(path [, mode=0777])

    Super-mkdir; create a leaf directory and all intermediate ones.
    Works like mkdir, except that any intermediate path segment (not
    just the rightmost) will be created if it does not exist.  This is
    recursive.

    N(	   R	   t   splitt   existst   makedirst   OSErrort   errnot   EEXISTR   t   mkdir(   R   t   modet   headt   tailt   e(    (    s   /usr/lib/python2.7/os.pyR    ˆ   s    	
c         C   sŒ   t  |  ƒ t j |  ƒ \ } } | s= t j | ƒ \ } } n  xH | r‡ | r‡ y t  | ƒ Wn t k
 rn Pn Xt j | ƒ \ } } q@ Wd S(   s¬  removedirs(path)

    Super-rmdir; remove a leaf directory and all empty intermediate
    ones.  Works like rmdir except that, if the leaf directory is
    successfully removed, directories corresponding to rightmost path
    segments will be pruned away until either the whole path is
    consumed or an error occurs.  Errors during this latter phase are
    ignored -- they generally mean that a directory was not empty.

    N(   t   rmdirR	   R   t   error(   R   R&   R'   (    (    s   /usr/lib/python2.7/os.pyt
   removedirsŸ   s    
c         C   s•   t  j | ƒ \ } } | r> | r> t  j | ƒ r> t | ƒ n  t |  | ƒ t  j |  ƒ \ } } | r‘ | r‘ y t | ƒ Wq‘ t k
 r q‘ Xn  d S(   s<  renames(old, new)

    Super-rename; create directories as necessary and delete any left
    empty.  Works like rename, except creation of any intermediate
    directories needed to make the new pathname good is attempted
    first.  After the rename, directories corresponding to rightmost
    path segments of the old name will be pruned until either the
    whole path is consumed or a nonempty directory is found.

    Note: this function can fail with the new directory structure made
    if you lack permissions needed to unlink the leaf directory or
    file.

    N(   R	   R   R   R    t   renameR+   R*   (   t   oldt   newR&   R'   (    (    s   /usr/lib/python2.7/os.pyt   renamesµ   s    R    R+   R/   c         c   s:  t  j t  j t  j } } } y t |  ƒ } Wn- t k
 r\ } | d k	 rX | | ƒ n  d SXg  g  }	 }
 x@ | D]8 } | | |  | ƒ ƒ rœ |	 j | ƒ qq |
 j | ƒ qq W| rÄ |  |	 |
 f Vn  xX |	 D]P } | |  | ƒ } | só | | ƒ rË x% t | | | | ƒ D] } | Vq	WqË qË W| s6|  |	 |
 f Vn  d S(   sÓ
  Directory tree generator.

    For each directory in the directory tree rooted at top (including top
    itself, but excluding '.' and '..'), yields a 3-tuple

        dirpath, dirnames, filenames

    dirpath is a string, the path to the directory.  dirnames is a list of
    the names of the subdirectories in dirpath (excluding '.' and '..').
    filenames is a list of the names of the non-directory files in dirpath.
    Note that the names in the lists are just names, with no path components.
    To get a full path (which begins with top) to a file or directory in
    dirpath, do os.path.join(dirpath, name).

    If optional arg 'topdown' is true or not specified, the triple for a
    directory is generated before the triples for any of its subdirectories
    (directories are generated top down).  If topdown is false, the triple
    for a directory is generated after the triples for all of its
    subdirectories (directories are generated bottom up).

    When topdown is true, the caller can modify the dirnames list in-place
    (e.g., via del or slice assignment), and walk will only recurse into the
    subdirectories whose names remain in dirnames; this can be used to prune the
    search, or to impose a specific order of visiting.  Modifying dirnames when
    topdown is false is ineffective, since the directories in dirnames have
    already been generated by the time dirnames itself is generated. No matter
    the value of topdown, the list of subdirectories is retrieved before the
    tuples for the directory and its subdirectories are generated.

    By default errors from the os.listdir() call are ignored.  If
    optional arg 'onerror' is specified, it should be a function; it
    will be called with one argument, an os.error instance.  It can
    report the error to continue with the walk, or raise the exception
    to abort the walk.  Note that the filename is available as the
    filename attribute of the exception object.

    By default, os.walk does not follow symbolic links to subdirectories on
    systems that support them.  In order to get this functionality, set the
    optional argument 'followlinks' to true.

    Caution:  if you pass a relative pathname for top, don't change the
    current working directory between resumptions of walk.  walk never
    changes the current directory, and assumes that the client doesn't
    either.

    Example:

    import os
    from os.path import join, getsize
    for root, dirs, files in os.walk('python/Lib/email'):
        print root, "consumes",
        print sum([getsize(join(root, name)) for name in files]),
        print "bytes in", len(files), "non-directory files"
        if 'CVS' in dirs:
            dirs.remove('CVS')  # don't visit CVS directories

    N(	   R	   t   islinkt   joint   isdirt   listdirR*   t   Nonet   appendt   walk(   t   topt   topdownt   onerrort   followlinksR0   R1   R2   t   namest   errt   dirst   nondirsR   t   new_patht   x(    (    s   /usr/lib/python2.7/os.pyR6   Ñ   s*    ;R6   c         G   s   t  |  | ƒ d S(   sp   execl(file, *args)

    Execute the executable file with argument list args, replacing the
    current process. N(   t   execv(   t   filet   args(    (    s   /usr/lib/python2.7/os.pyt   execl5  s    c         G   s"   | d } t  |  | d  | ƒ d S(   sŠ   execle(file, *args, env)

    Execute the executable file with argument list args and
    environment env, replacing the current process. iÿÿÿÿN(   t   execve(   RB   RC   t   env(    (    s   /usr/lib/python2.7/os.pyt   execle<  s    
c         G   s   t  |  | ƒ d S(   s•   execlp(file, *args)

    Execute the executable file (which is searched for along $PATH)
    with argument list args, replacing the current process. N(   t   execvp(   RB   RC   (    (    s   /usr/lib/python2.7/os.pyt   execlpD  s    c         G   s"   | d } t  |  | d  | ƒ d S(   s³   execlpe(file, *args, env)

    Execute the executable file (which is searched for along $PATH)
    with argument list args and environment env, replacing the current
    process. iÿÿÿÿN(   t   execvpe(   RB   RC   RF   (    (    s   /usr/lib/python2.7/os.pyt   execlpeK  s    
c         C   s   t  |  | ƒ d S(   sÀ   execvp(file, args)

    Execute the executable file (which is searched for along $PATH)
    with argument list args, replacing the current process.
    args may be a list or tuple of strings. N(   t   _execvpe(   RB   RC   (    (    s   /usr/lib/python2.7/os.pyRH   T  s    c         C   s   t  |  | | ƒ d S(   sß   execvpe(file, args, env)

    Execute the executable file (which is searched for along $PATH)
    with argument list args and environment env , replacing the
    current process.
    args may be a list or tuple of strings. N(   RL   (   RB   RC   RF   (    (    s   /usr/lib/python2.7/os.pyRJ   \  s    RD   RG   RI   RK   RH   RJ   c         C   sZ  | d  k	 r! t } | | f } n t } | f } t } t j |  ƒ \ } } | rb | |  | Œ d  Sd | k r{ | d } n t } | j t ƒ } d  }	 d  }
 x– | D]Ž } t j | |  ƒ } y | | | Œ Wq£ t	 k
 r0} t
 j ƒ  d } | j t j k r1| j t j k r1|	 d  k r1| }	 | }
 q1q£ Xq£ W|	 rJt	 |	 |
 ‚ n  t	 | | ‚ d  S(   Nt   PATHi   (   R4   RE   RA   t   environR	   R   R   R   R1   R*   t   syst   exc_infoR"   t   ENOENTt   ENOTDIR(   RB   RC   RF   t   funct   argrestR&   R'   t   envpathRM   t	   saved_exct   saved_tbR   t   fullnameR(   t   tb(    (    s   /usr/lib/python2.7/os.pyRL   g  s:    	$c         C   s   t  |  d ƒ d  S(   Nt    (   t   putenv(   t   key(    (    s   /usr/lib/python2.7/os.pyt   unsetenv—  s    (   t   _EnvironR^   c           B   s–   e  Z d  „  Z d „  Z d „  Z y e Wn e k
 rE d „  Z n Xd „  Z d „  Z d „  Z	 d „  Z
 d „  Z d d	 „ Z d d
 „ Z d „  Z RS(   c         C   sJ   t  j  j |  ƒ |  j } x* | j ƒ  D] \ } } | | | j ƒ  <q& Wd  S(   N(   t   UserDictt   __init__t   datat   itemst   upper(   t   selfRN   Ra   t   kt   v(    (    s   /usr/lib/python2.7/os.pyR`      s    	c         C   s$   t  | | ƒ | |  j | j ƒ  <d  S(   N(   R[   Ra   Rc   (   Rd   R\   t   item(    (    s   /usr/lib/python2.7/os.pyt   __setitem__¥  s    c         C   s   |  j  | j ƒ  S(   N(   Ra   Rc   (   Rd   R\   (    (    s   /usr/lib/python2.7/os.pyt   __getitem__¨  s    c         C   s   |  j  | j ƒ  =d  S(   N(   Ra   Rc   (   Rd   R\   (    (    s   /usr/lib/python2.7/os.pyt   __delitem__­  s    c         C   s   t  | ƒ |  j | j ƒ  =d  S(   N(   R]   Ra   Rc   (   Rd   R\   (    (    s   /usr/lib/python2.7/os.pyRj   °  s    
c         C   s2   x+ |  j  j ƒ  D] } t | ƒ |  j  | =q Wd  S(   N(   Ra   t   keysR]   (   Rd   R\   (    (    s   /usr/lib/python2.7/os.pyt   clear³  s    
c         G   s#   t  | ƒ |  j j | j ƒ  | Œ S(   N(   R]   Ra   t   popRc   (   Rd   R\   RC   (    (    s   /usr/lib/python2.7/os.pyRm   ·  s    
c         C   s   | j  ƒ  |  j k S(   N(   Rc   Ra   (   Rd   R\   (    (    s   /usr/lib/python2.7/os.pyt   has_keyº  s    c         C   s   | j  ƒ  |  j k S(   N(   Rc   Ra   (   Rd   R\   (    (    s   /usr/lib/python2.7/os.pyt   __contains__¼  s    c         C   s   |  j  j | j ƒ  | ƒ S(   N(   Ra   t   getRc   (   Rd   R\   t   failobj(    (    s   /usr/lib/python2.7/os.pyRp   ¾  s    c         K   s‡   | rm y | j  ƒ  } Wn2 t k
 rJ xA | D] \ } } | |  | <q- Wqm Xx | D] } | | |  | <qR Wn  | rƒ |  j | ƒ n  d  S(   N(   Rk   R   t   update(   Rd   t   dictt   kwargsRk   Re   Rf   (    (    s   /usr/lib/python2.7/os.pyRr   À  s    c         C   s
   t  |  ƒ S(   N(   Rs   (   Rd   (    (    s   /usr/lib/python2.7/os.pyt   copyÐ  s    N(   t   __name__t
   __module__R`   Rh   Ri   R]   t	   NameErrorRj   Rl   Rm   Rn   Ro   R4   Rp   Rr   Ru   (    (    (    s   /usr/lib/python2.7/os.pyR^   Ÿ  s   								c           B   sf   e  Z d  „  Z d „  Z d d „ Z y e Wn e k
 r? n Xd „  Z d „  Z	 d „  Z
 d „  Z RS(   c         C   s   t  j  j |  ƒ | |  _ d  S(   N(   R_   R`   Ra   (   Rd   RN   (    (    s   /usr/lib/python2.7/os.pyR`   Õ  s    c         C   s   t  | | ƒ | |  j | <d  S(   N(   R[   Ra   (   Rd   R\   Rg   (    (    s   /usr/lib/python2.7/os.pyRh   Ø  s    c         K   s‡   | rm y | j  ƒ  } Wn2 t k
 rJ xA | D] \ } } | |  | <q- Wqm Xx | D] } | | |  | <qR Wn  | rƒ |  j | ƒ n  d  S(   N(   Rk   R   Rr   (   Rd   Rs   Rt   Rk   Re   Rf   (    (    s   /usr/lib/python2.7/os.pyRr   Û  s    c         C   s   t  | ƒ |  j | =d  S(   N(   R]   Ra   (   Rd   R\   (    (    s   /usr/lib/python2.7/os.pyRj   ð  s    
c         C   s2   x+ |  j  j ƒ  D] } t | ƒ |  j  | =q Wd  S(   N(   Ra   Rk   R]   (   Rd   R\   (    (    s   /usr/lib/python2.7/os.pyRl   ó  s    
c         G   s   t  | ƒ |  j j | | Œ S(   N(   R]   Ra   Rm   (   Rd   R\   RC   (    (    s   /usr/lib/python2.7/os.pyRm   ÷  s    
c         C   s
   t  |  ƒ S(   N(   Rs   (   Rd   (    (    s   /usr/lib/python2.7/os.pyRu   ú  s    N(   Rv   Rw   R`   Rh   R4   Rr   R]   Rx   Rj   Rl   Rm   Ru   (    (    (    s   /usr/lib/python2.7/os.pyR^   Ô  s   					c         C   s   t  j |  | ƒ S(   s€   Get an environment variable, return None if it doesn't exist.
    The optional second argument can specify an alternate default.(   RN   Rp   (   R\   t   default(    (    s   /usr/lib/python2.7/os.pyt   getenv   s    Rz   c         C   s   |  t  ƒ  k S(   N(   t   globals(   R   (    (    s   /usr/lib/python2.7/os.pyt   _exists  s    t   forkt   spawnvRA   c         C   sÎ   t  ƒ  } | sV y0 | d  k r. | | | ƒ n | | | | ƒ WqÊ t d ƒ qÊ Xnt |  t k rf | Sxa t | d ƒ \ } } t | ƒ r qi qi t | ƒ r§ t | ƒ St | ƒ r½ t	 | ƒ St
 d ‚ qi Wd  S(   Ni   i    s"   Not stopped, signaled or exited???(   R}   R4   R   t   P_NOWAITt   waitpidt
   WIFSTOPPEDt   WIFSIGNALEDt   WTERMSIGt	   WIFEXITEDt   WEXITSTATUSR*   (   R%   RB   RC   RF   RS   t   pidt   wpidt   sts(    (    s   /usr/lib/python2.7/os.pyt	   _spawnvef  s&    	
c         C   s   t  |  | | d t ƒ S(   s  spawnv(mode, file, args) -> integer

Execute file with arguments from args in a subprocess.
If mode == P_NOWAIT return the pid of the process.
If mode == P_WAIT return the process's exit code if it exits normally;
otherwise return -SIG, where SIG is the signal that killed it. N(   R‰   R4   RA   (   R%   RB   RC   (    (    s   /usr/lib/python2.7/os.pyR~   .  s    c         C   s   t  |  | | | t ƒ S(   s:  spawnve(mode, file, args, env) -> integer

Execute file with arguments from args in a subprocess with the
specified environment.
If mode == P_NOWAIT return the pid of the process.
If mode == P_WAIT return the process's exit code if it exits normally;
otherwise return -SIG, where SIG is the signal that killed it. (   R‰   RE   (   R%   RB   RC   RF   (    (    s   /usr/lib/python2.7/os.pyt   spawnve7  s    c         C   s   t  |  | | d t ƒ S(   s8  spawnvp(mode, file, args) -> integer

Execute file (which is looked for along $PATH) with arguments from
args in a subprocess.
If mode == P_NOWAIT return the pid of the process.
If mode == P_WAIT return the process's exit code if it exits normally;
otherwise return -SIG, where SIG is the signal that killed it. N(   R‰   R4   RH   (   R%   RB   RC   (    (    s   /usr/lib/python2.7/os.pyt   spawnvpC  s    c         C   s   t  |  | | | t ƒ S(   s\  spawnvpe(mode, file, args, env) -> integer

Execute file (which is looked for along $PATH) with arguments from
args in a subprocess with the supplied environment.
If mode == P_NOWAIT return the pid of the process.
If mode == P_WAIT return the process's exit code if it exits normally;
otherwise return -SIG, where SIG is the signal that killed it. (   R‰   RJ   (   R%   RB   RC   RF   (    (    s   /usr/lib/python2.7/os.pyt   spawnvpeM  s    c         G   s   t  |  | | ƒ S(   s  spawnl(mode, file, *args) -> integer

Execute file with arguments from args in a subprocess.
If mode == P_NOWAIT return the pid of the process.
If mode == P_WAIT return the process's exit code if it exits normally;
otherwise return -SIG, where SIG is the signal that killed it. (   R~   (   R%   RB   RC   (    (    s   /usr/lib/python2.7/os.pyt   spawnl[  s    c         G   s!   | d } t  |  | | d  | ƒ S(   s:  spawnle(mode, file, *args, env) -> integer

Execute file with arguments from args in a subprocess with the
supplied environment.
If mode == P_NOWAIT return the pid of the process.
If mode == P_WAIT return the process's exit code if it exits normally;
otherwise return -SIG, where SIG is the signal that killed it. iÿÿÿÿ(   RŠ   (   R%   RB   RC   RF   (    (    s   /usr/lib/python2.7/os.pyt   spawnled  s    
RŠ   R   RŽ   R‹   c         G   s   t  |  | | ƒ S(   sW  spawnlp(mode, file, *args) -> integer

Execute file (which is looked for along $PATH) with arguments from
args in a subprocess with the supplied environment.
If mode == P_NOWAIT return the pid of the process.
If mode == P_WAIT return the process's exit code if it exits normally;
otherwise return -SIG, where SIG is the signal that killed it. (   R‹   (   R%   RB   RC   (    (    s   /usr/lib/python2.7/os.pyt   spawnlpv  s    c         G   s!   | d } t  |  | | d  | ƒ S(   s]  spawnlpe(mode, file, *args, env) -> integer

Execute file (which is looked for along $PATH) with arguments from
args in a subprocess with the supplied environment.
If mode == P_NOWAIT return the pid of the process.
If mode == P_WAIT return the process's exit code if it exits normally;
otherwise return -SIG, where SIG is the signal that killed it. iÿÿÿÿ(   RŒ   (   R%   RB   RC   RF   (    (    s   /usr/lib/python2.7/os.pyt   spawnlpe€  s    
RŒ   R   R   t   popen2t   tc         C   sƒ   d d l  } d } | j | t d d ƒd d l } | j } | j |  d t |  t ƒ d | d | d	 | d
 t ƒ} | j	 | j
 f S(   sÏ  Execute the shell command 'cmd' in a sub-process.  On UNIX, 'cmd'
            may be a sequence, in which case arguments will be passed directly to
            the program without shell intervention (as with os.spawnv()).  If 'cmd'
            is a string it will be passed to the shell (as with os.system()). If
            'bufsize' is specified, it sets the buffer size for the I/O pipes.  The
            file objects (child_stdin, child_stdout) are returned.iÿÿÿÿNs4   os.popen2 is deprecated.  Use the subprocess module.t
   stackleveli   t   shellt   bufsizet   stdint   stdoutt	   close_fds(   t   warningst   warnt   DeprecationWarningt
   subprocesst   PIPEt   Popent
   isinstancet
   basestringt   TrueR–   R—   (   t   cmdR%   R•   R™   t   msgRœ   R   t   p(    (    s   /usr/lib/python2.7/os.pyR‘   ’  s    		t   popen3c         C   s   d d l  } d } | j | t d d ƒd d l } | j } | j |  d t |  t ƒ d | d | d	 | d
 | d t ƒ} | j	 | j
 | j f S(   sÝ  Execute the shell command 'cmd' in a sub-process.  On UNIX, 'cmd'
            may be a sequence, in which case arguments will be passed directly to
            the program without shell intervention (as with os.spawnv()).  If 'cmd'
            is a string it will be passed to the shell (as with os.system()). If
            'bufsize' is specified, it sets the buffer size for the I/O pipes.  The
            file objects (child_stdin, child_stdout, child_stderr) are returned.iÿÿÿÿNs4   os.popen3 is deprecated.  Use the subprocess module.R“   i   R”   R•   R–   R—   t   stderrR˜   (   R™   Rš   R›   Rœ   R   Rž   RŸ   R    R¡   R–   R—   R¦   (   R¢   R%   R•   R™   R£   Rœ   R   R¤   (    (    s   /usr/lib/python2.7/os.pyR¥   ¦  s    	t   popen4c         C   sŒ   d d l  } d } | j | t d d ƒd d l } | j } | j |  d t |  t ƒ d | d | d	 | d
 | j d t	 ƒ} | j
 | j f S(   sÖ  Execute the shell command 'cmd' in a sub-process.  On UNIX, 'cmd'
            may be a sequence, in which case arguments will be passed directly to
            the program without shell intervention (as with os.spawnv()).  If 'cmd'
            is a string it will be passed to the shell (as with os.system()). If
            'bufsize' is specified, it sets the buffer size for the I/O pipes.  The
            file objects (child_stdin, child_stdout_stderr) are returned.iÿÿÿÿNs4   os.popen4 is deprecated.  Use the subprocess module.R“   i   R”   R•   R–   R—   R¦   R˜   (   R™   Rš   R›   Rœ   R   Rž   RŸ   R    t   STDOUTR¡   R–   R—   (   R¢   R%   R•   R™   R£   Rœ   R   R¤   (    (    s   /usr/lib/python2.7/os.pyR§   º  s    	c         C   s   t  |  | ƒ S(   N(   t   stat_result(   t   tupRs   (    (    s   /usr/lib/python2.7/os.pyt   _make_stat_resultÏ  s    c         C   s   |  j  ƒ  \ } } t | f S(   N(   t
   __reduce__R«   (   t   srt   typeRC   (    (    s   /usr/lib/python2.7/os.pyt   _pickle_stat_resultÒ  s    c         C   s   t  |  | ƒ S(   N(   t   statvfs_result(   Rª   Rs   (    (    s   /usr/lib/python2.7/os.pyt   _make_statvfs_resultÛ  s    c         C   s   |  j  ƒ  \ } } t | f S(   N(   R¬   R±   (   R­   R®   RC   (    (    s   /usr/lib/python2.7/os.pyt   _pickle_statvfs_resultÞ  s    (   R   R   (   R   R   (X   t   __doc__RO   R"   t   builtin_module_namest   _namesR   R   R   R   R   R   t   ImportErrort	   posixpathR	   t   extendR   t   ntpathR   t   versiont   findt
   os2emxpatht	   _emx_linkR   R   R   t
   riscospatht   modulest   os.pathR   R   R   R   R   R   R    R
   R   R   R   R    R+   R/   R¡   R4   t   FalseR6   R5   RN   Rx   RD   RG   RI   RK   RH   RJ   RL   R[   R_   R]   t   riscosenvironR^   t   IterableUserDictRz   R|   t   P_WAITR   t	   P_NOWAITOR‰   R~   RŠ   R‹   RŒ   R   RŽ   R   R   R‘   R¥   R§   t   copy_regt	   _copy_regR«   R¯   t   pickleR©   R±   R²   R°   (    (    (    s   /usr/lib/python2.7/os.pyt   <module>   s,  		




	:		\
								#5*	%
					

				
					                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ó
Ó«[c           @   s2   y d  d l  Z  Wn e k
 r# n Xe  j ƒ  d S(   iÿÿÿÿN(   t   apport_python_hookt   ImportErrort   install(    (    (    s#   /usr/lib/python2.7/sitecustomize.pyt   <module>   s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           # Module 'os2emxpath' -- common operations on OS/2 pathnames
"""Common pathname manipulations, OS/2 EMX version.

Instead of importing this module directly, import os and refer to this
module as os.path.
"""

import os
import stat
from genericpath import *
from genericpath import _unicode
from ntpath import (expanduser, expandvars, isabs, islink, splitdrive,
                    splitext, split, walk)

__all__ = ["normcase","isabs","join","splitdrive","split","splitext",
           "basename","dirname","commonprefix","getsize","getmtime",
           "getatime","getctime", "islink","exists","lexists","isdir","isfile",
           "ismount","walk","expanduser","expandvars","normpath","abspath",
           "splitunc","curdir","pardir","sep","pathsep","defpath","altsep",
           "extsep","devnull","realpath","supports_unicode_filenames"]

# strings representing various path-related bits and pieces
curdir = '.'
pardir = '..'
extsep = '.'
sep = '/'
altsep = '\\'
pathsep = ';'
defpath = '.;C:\\bin'
devnull = 'nul'

# Normalize the case of a pathname and map slashes to backslashes.
# Other normalizations (such as optimizing '../' away) are not done
# (this is done by normpath).

def normcase(s):
    """Normalize case of pathname.

    Makes all characters lowercase and all altseps into seps."""
    return s.replace('\\', '/').lower()


# Join two (or more) paths.

def join(a, *p):
    """Join two or more pathname components, inserting sep as needed"""
    path = a
    for b in p:
        if isabs(b):
            path = b
        elif path == '' or path[-1:] in '/\\:':
            path = path + b
        else:
            path = path + '/' + b
    return path


# Parse UNC paths
def splitunc(p):
    """Split a pathname into UNC mount point and relative path specifiers.

    Return a 2-tuple (unc, rest); either part may be empty.
    If unc is not empty, it has the form '//host/mount' (or similar
    using backslashes).  unc+rest is always the input path.
    Paths containing drive letters never have a UNC part.
    """
    if p[1:2] == ':':
        return '', p # Drive letter present
    firstTwo = p[0:2]
    if firstTwo == '/' * 2 or firstTwo == '\\' * 2:
        # is a UNC path:
        # vvvvvvvvvvvvvvvvvvvv equivalent to drive letter
        # \\machine\mountpoint\directories...
        #           directory ^^^^^^^^^^^^^^^
        normp = normcase(p)
        index = normp.find('/', 2)
        if index == -1:
            ##raise RuntimeError, 'illegal UNC path: "' + p + '"'
            return ("", p)
        index = normp.find('/', index + 1)
        if index == -1:
            index = len(p)
        return p[:index], p[index:]
    return '', p


# Return the tail (basename) part of a path.

def basename(p):
    """Returns the final component of a pathname"""
    return split(p)[1]


# Return the head (dirname) part of a path.

def dirname(p):
    """Returns the directory component of a pathname"""
    return split(p)[0]


# alias exists to lexists
lexists = exists


# Is a path a directory?

# Is a path a mount point?  Either a root (with or without drive letter)
# or a UNC path with at most a / or \ after the mount point.

def ismount(path):
    """Test whether a path is a mount point (defined as root of drive)"""
    unc, rest = splitunc(path)
    if unc:
        return rest in ("", "/", "\\")
    p = splitdrive(path)[1]
    return len(p) == 1 and p[0] in '/\\'


# Normalize a path, e.g. A//B, A/./B and A/foo/../B all become A/B.

def normpath(path):
    """Normalize path, eliminating double slashes, etc."""
    path = path.replace('\\', '/')
    prefix, path = splitdrive(path)
    while path[:1] == '/':
        prefix = prefix + '/'
        path = path[1:]
    comps = path.split('/')
    i = 0
    while i < len(comps):
        if comps[i] == '.':
            del comps[i]
        elif comps[i] == '..' and i > 0 and comps[i-1] not in ('', '..'):
            del comps[i-1:i+1]
            i = i - 1
        elif comps[i] == '' and i > 0 and comps[i-1] != '':
            del comps[i]
        else:
            i = i + 1
    # If the path is now empty, substitute '.'
    if not prefix and not comps:
        comps.append('.')
    return prefix + '/'.join(comps)


# Return an absolute path.
def abspath(path):
    """Return the absolute version of a path"""
    if not isabs(path):
        if isinstance(path, _unicode):
            cwd = os.getcwdu()
        else:
            cwd = os.getcwd()
        path = join(cwd, path)
    return normpath(path)

# realpath is a no-op on systems without islink support
realpath = abspath

supports_unicode_filenames = False
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ó
Ó«[c        #   @   so  d  Z  d d l Z d d l Z d d l Td d l m Z d d l m Z m Z m Z m	 Z	 m
 Z
 m Z m Z m Z d d d d	 d
 d d d d d d d d d d d d d d d d d d d d d d  d! d" d# d$ d% d& d' d( g# Z d) Z d* Z d) Z d+ Z d, Z d- Z d. Z d/ Z d0 „  Z d1 „  Z d2 „  Z d3 „  Z d4 „  Z e Z d5 „  Z d6 „  Z d7 „  Z  e  Z! e" Z# d S(8   sŒ   Common pathname manipulations, OS/2 EMX version.

Instead of importing this module directly, import os and refer to this
module as os.path.
iÿÿÿÿN(   t   *(   t   _unicode(   t
   expandusert
   expandvarst   isabst   islinkt
   splitdrivet   splitextt   splitt   walkt   normcaseR   t   joinR   R   R   t   basenamet   dirnamet   commonprefixt   getsizet   getmtimet   getatimet   getctimeR   t   existst   lexistst   isdirt   isfilet   ismountR	   R   R   t   normpatht   abspatht   splitunct   curdirt   pardirt   sept   pathsept   defpatht   altsept   extsept   devnullt   realpatht   supports_unicode_filenamest   .s   ..t   /s   \t   ;s   .;C:\bint   nulc         C   s   |  j  d d ƒ j ƒ  S(   sZ   Normalize case of pathname.

    Makes all characters lowercase and all altseps into seps.s   \R&   (   t   replacet   lower(   t   s(    (    s    /usr/lib/python2.7/os2emxpath.pyR
   $   s    c         G   sg   |  } xZ | D]R } t  | ƒ r( | } q | d k sD | d d k rQ | | } q | d | } q W| S(   s=   Join two or more pathname components, inserting sep as neededt    iÿÿÿÿs   /\:R&   (   R   (   t   at   pt   patht   b(    (    s    /usr/lib/python2.7/os2emxpath.pyR   -   s    	c         C   sÃ   |  d d !d k r d |  f S|  d d !} | d	 k sB | d
 k r¹ t  |  ƒ } | j d d ƒ } | d k rv d |  f S| j d | d ƒ } | d k r§ t |  ƒ } n  |  |  |  | f Sd |  f S(   s?  Split a pathname into UNC mount point and relative path specifiers.

    Return a 2-tuple (unc, rest); either part may be empty.
    If unc is not empty, it has the form '//host/mount' (or similar
    using backslashes).  unc+rest is always the input path.
    Paths containing drive letters never have a UNC part.
    i   i   t   :R,   i    R&   s   \iÿÿÿÿs   //s   \\(   R
   t   findt   len(   R.   t   firstTwot   normpt   index(    (    s    /usr/lib/python2.7/os2emxpath.pyR   ;   s    

c         C   s   t  |  ƒ d S(   s)   Returns the final component of a pathnamei   (   R   (   R.   (    (    s    /usr/lib/python2.7/os2emxpath.pyR   Y   s    c         C   s   t  |  ƒ d S(   s-   Returns the directory component of a pathnamei    (   R   (   R.   (    (    s    /usr/lib/python2.7/os2emxpath.pyR   `   s    c         C   sR   t  |  ƒ \ } } | r" | d k St |  ƒ d } t | ƒ d k oQ | d d k S(   s?   Test whether a path is a mount point (defined as root of drive)R,   R&   s   \i   i    s   /\(   R,   R&   s   \(   R   R   R3   (   R/   t   unct   restR.   (    (    s    /usr/lib/python2.7/os2emxpath.pyR   n   s
    
c         C   sY  |  j  d d ƒ }  t |  ƒ \ } }  x( |  d  d k rN | d } |  d }  q' W|  j d ƒ } d } xÃ | t | ƒ k  r)| | d k r“ | | =qg | | d k râ | d k râ | | d d k râ | | d | d 5| d } qg | | d k r| d k r| | d d k r| | =qg | d } qg W| rH| rH| j d ƒ n  | d j | ƒ S(	   s0   Normalize path, eliminating double slashes, etc.s   \R&   i   i    R%   s   ..R,   (   R,   s   ..(   R)   R   R   R3   t   appendR   (   R/   t   prefixt   compst   i(    (    s    /usr/lib/python2.7/os2emxpath.pyR   y   s&    

00
c         C   sR   t  |  ƒ sH t |  t ƒ r* t j ƒ  } n t j ƒ  } t | |  ƒ }  n  t |  ƒ S(   s%   Return the absolute version of a path(   R   t
   isinstanceR   t   ost   getcwdut   getcwdR   R   (   R/   t   cwd(    (    s    /usr/lib/python2.7/os2emxpath.pyR   “   s    ($   t   __doc__R>   t   statt   genericpathR   t   ntpathR   R   R   R   R   R   R   R	   t   __all__R   R   R!   R   R    R   R   R"   R
   R   R   R   R   R   R   R   R   R   R#   t   FalseR$   (    (    (    s    /usr/lib/python2.7/os2emxpath.pyt   <module>   s<   
:									                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     The Python Debugger Pdb
=======================

To use the debugger in its simplest form:

        >>> import pdb
        >>> pdb.run('<a statement>')

The debugger's prompt is '(Pdb) '.  This will stop in the first
function call in <a statement>.

Alternatively, if a statement terminated with an unhandled exception,
you can use pdb's post-mortem facility to inspect the contents of the
traceback:

        >>> <a statement>
        <exception traceback>
        >>> import pdb
        >>> pdb.pm()

The commands recognized by the debugger are listed in the next
section.  Most can be abbreviated as indicated; e.g., h(elp) means
that 'help' can be typed as 'h' or 'help' (but not as 'he' or 'hel',
nor as 'H' or 'Help' or 'HELP').  Optional arguments are enclosed in
square brackets.

A blank line repeats the previous command literally, except for
'list', where it lists the next 11 lines.

Commands that the debugger doesn't recognize are assumed to be Python
statements and are executed in the context of the program being
debugged.  Python statements can also be prefixed with an exclamation
point ('!').  This is a powerful way to inspect the program being
debugged; it is even possible to change variables.  When an exception
occurs in such a statement, the exception name is printed but the
debugger's state is not changed.

The debugger supports aliases, which can save typing.  And aliases can
have parameters (see the alias help entry) which allows one a certain
level of adaptability to the context under examination.

Multiple commands may be entered on a single line, separated by the
pair ';;'.  No intelligence is applied to separating the commands; the
input is split at the first ';;', even if it is in the middle of a
quoted string.

If a file ".pdbrc" exists in your home directory or in the current
directory, it is read in and executed as if it had been typed at the
debugger prompt.  This is particularly useful for aliases.  If both
files exist, the one in the home directory is read first and aliases
defined there can be overridden by the local file.

Aside from aliases, the debugger is not directly programmable; but it
is implemented as a class from which you can derive your own debugger
class, which you can make as fancy as you like.


Debugger commands
=================

h(elp)
        Without argument, print the list of available commands.  With
        a command name as argument, print help about that command
        (this is currently not implemented).

w(here)
        Print a stack trace, with the most recent frame at the bottom.
        An arrow indicates the "current frame", which determines the
        context of most commands.

d(own)
        Move the current frame one level down in the stack trace
        (to a newer frame).

u(p)
        Move the current frame one level up in the stack trace
        (to an older frame).

b(reak) [ ([filename:]lineno | function) [, condition] ]
        With a filename:line number argument, set a break there.  If
        filename is omitted, use the current file.  With a function
        name, set a break at the first executable line of that
        function.  Without argument, list all breaks.  Each breakpoint
        is assigned a number to which all the other breakpoint
        commands refer.

        The condition argument, if present, is a string which must
        evaluate to true in order for the breakpoint to be honored.

tbreak [ ([filename:]lineno | function) [, condition] ]
        Temporary breakpoint, which is removed automatically when it
        is first hit.  The arguments are the same as break.

cl(ear) [bpnumber [bpnumber ...] ]
        With a space separated list of breakpoint numbers, clear those
        breakpoints.  Without argument, clear all breaks (but first
        ask confirmation).

disable bpnumber [bpnumber ...]
        Disables the breakpoints given as a space separated list of
        breakpoint numbers.  Disabling a breakpoint means it cannot
        cause the program to stop execution, but unlike clearing a
        breakpoint, it remains in the list of breakpoints and can be
        (re-)enabled.

enable bpnumber [bpnumber ...]
        Enables the breakpoints specified.

ignore bpnumber count
        Sets the ignore count for the given breakpoint number.  If
        count is omitted, the ignore count is set to 0.  A breakpoint
        becomes active when the ignore count is zero.  When non-zero,
        the count is decremented each time the breakpoint is reached
        and the breakpoint is not disabled and any associated
        condition evaluates to true.

condition bpnumber condition
        condition is an expression which must evaluate to true before
        the breakpoint is honored.  If condition is absent, any
        existing condition is removed; i.e., the breakpoint is made
        unconditional.

s(tep)
        Execute the current line, stop at the first possible occasion
        (either in a function that is called or in the current function).

n(ext)
        Continue execution until the next line in the current function
        is reached or it returns.

unt(il)
        Continue execution until the line with a number greater than the 
        current one is reached or until the current frame returns.

r(eturn)
        Continue execution until the current function returns.

run [args...]
        Restart the debugged python program. If a string is supplied it is
        splitted with "shlex", and the result is used as the new sys.argv.
        History, breakpoints, actions and debugger options are preserved.
        "restart" is an alias for "run".

c(ont(inue))
        Continue execution, only stop when a breakpoint is encountered.

l(ist) [first [,last]]
        List source code for the current file.
        Without arguments, list 11 lines around the current line
        or continue the previous listing.
        With one argument, list 11 lines starting at that line.
        With two arguments, list the given range;
        if the second argument is less than the first, it is a count.

a(rgs)
        Print the argument list of the current function.

p expression
        Print the value of the expression.

(!) statement
        Execute the (one-line) statement in the context of the current
        stack frame.  The exclamation point can be omitted unless the
        first word of the statement resembles a debugger command.  To
        assign to a global variable you must always prefix the command
        with a 'global' command, e.g.:
        (Pdb) global list_options; list_options = ['-l']
        (Pdb)


whatis arg
         Prints the type of the argument.

alias [name [command]]
        Creates an alias called 'name' that executes 'command'.  The
        command must *not* be enclosed in quotes.  Replaceable
        parameters can be indicated by %1, %2, and so on, while %* is
        replaced by all the parameters.  If no command is given, the
        current alias for name is shown. If no name is given, all
        aliases are listed.

        Aliases may be nested and can contain anything that can be
        legally typed at the pdb prompt.  Note!  You *can* override
        internal pdb commands with aliases!  Those internal commands
        are then hidden until the alias is removed.  Aliasing is
        recursively applied to the first word of the command line; all
        other words in the line are left alone.

        As an example, here are two useful aliases (especially when
        placed in the .pdbrc file):

        #Print instance variables (usage "pi classInst")
        alias pi for k in %1.__dict__.keys(): print "%1.",k,"=",%1.__dict__[k]
        #Print instance variables in self
        alias ps pi self
                
unalias name
        Deletes the specified alias.

q(uit)
        Quit from the debugger.
        The program being executed is aborted.
                                                                                                                                                                                                                                                                                      #! /usr/bin/python2.7

"""A Python debugger."""

# (See pdb.doc for documentation.)

import sys
import linecache
import cmd
import bdb
from repr import Repr
import os
import re
import pprint
import traceback


class Restart(Exception):
    """Causes a debugger to be restarted for the debugged python program."""
    pass

# Create a custom safe Repr instance and increase its maxstring.
# The default of 30 truncates error messages too easily.
_repr = Repr()
_repr.maxstring = 200
_saferepr = _repr.repr

__all__ = ["run", "pm", "Pdb", "runeval", "runctx", "runcall", "set_trace",
           "post_mortem", "help"]

def find_function(funcname, filename):
    cre = re.compile(r'def\s+%s\s*[(]' % re.escape(funcname))
    try:
        fp = open(filename)
    except IOError:
        return None
    # consumer of this info expects the first line to be 1
    lineno = 1
    answer = None
    while 1:
        line = fp.readline()
        if line == '':
            break
        if cre.match(line):
            answer = funcname, filename, lineno
            break
        lineno = lineno + 1
    fp.close()
    return answer


# Interaction prompt line will separate file and call info from code
# text using value of line_prefix string.  A newline and arrow may
# be to your liking.  You can set it once pdb is imported using the
# command "pdb.line_prefix = '\n% '".
# line_prefix = ': '    # Use this to get the old situation back
line_prefix = '\n-> '   # Probably a better default

class Pdb(bdb.Bdb, cmd.Cmd):

    def __init__(self, completekey='tab', stdin=None, stdout=None, skip=None):
        bdb.Bdb.__init__(self, skip=skip)
        cmd.Cmd.__init__(self, completekey, stdin, stdout)
        if stdout:
            self.use_rawinput = 0
        self.prompt = '(Pdb) '
        self.aliases = {}
        self.mainpyfile = ''
        self._wait_for_mainpyfile = 0
        # Try to load readline if it exists
        try:
            import readline
        except ImportError:
            pass

        # Read $HOME/.pdbrc and ./.pdbrc
        self.rcLines = []
        if 'HOME' in os.environ:
            envHome = os.environ['HOME']
            try:
                rcFile = open(os.path.join(envHome, ".pdbrc"))
            except IOError:
                pass
            else:
                for line in rcFile.readlines():
                    self.rcLines.append(line)
                rcFile.close()
        try:
            rcFile = open(".pdbrc")
        except IOError:
            pass
        else:
            for line in rcFile.readlines():
                self.rcLines.append(line)
            rcFile.close()

        self.commands = {} # associates a command list to breakpoint numbers
        self.commands_doprompt = {} # for each bp num, tells if the prompt
                                    # must be disp. after execing the cmd list
        self.commands_silent = {} # for each bp num, tells if the stack trace
                                  # must be disp. after execing the cmd list
        self.commands_defining = False # True while in the process of defining
                                       # a command list
        self.commands_bnum = None # The breakpoint number for which we are
                                  # defining a list

    def reset(self):
        bdb.Bdb.reset(self)
        self.forget()

    def forget(self):
        self.lineno = None
        self.stack = []
        self.curindex = 0
        self.curframe = None

    def setup(self, f, t):
        self.forget()
        self.stack, self.curindex = self.get_stack(f, t)
        self.curframe = self.stack[self.curindex][0]
        # The f_locals dictionary is updated from the actual frame
        # locals whenever the .f_locals accessor is called, so we
        # cache it here to ensure that modifications are not overwritten.
        self.curframe_locals = self.curframe.f_locals
        self.execRcLines()

    # Can be executed earlier than 'setup' if desired
    def execRcLines(self):
        if self.rcLines:
            # Make local copy because of recursion
            rcLines = self.rcLines
            # executed only once
            self.rcLines = []
            for line in rcLines:
                line = line[:-1]
                if len(line) > 0 and line[0] != '#':
                    self.onecmd(line)

    # Override Bdb methods

    def user_call(self, frame, argument_list):
        """This method is called when there is the remote possibility
        that we ever need to stop in this function."""
        if self._wait_for_mainpyfile:
            return
        if self.stop_here(frame):
            print >>self.stdout, '--Call--'
            self.interaction(frame, None)

    def user_line(self, frame):
        """This function is called when we stop or break at this line."""
        if self._wait_for_mainpyfile:
            if (self.mainpyfile != self.canonic(frame.f_code.co_filename)
                or frame.f_lineno<= 0):
                return
            self._wait_for_mainpyfile = 0
        if self.bp_commands(frame):
            self.interaction(frame, None)

    def bp_commands(self,frame):
        """Call every command that was set for the current active breakpoint
        (if there is one).

        Returns True if the normal interaction function must be called,
        False otherwise."""
        # self.currentbp is set in bdb in Bdb.break_here if a breakpoint was hit
        if getattr(self, "currentbp", False) and \
               self.currentbp in self.commands:
            currentbp = self.currentbp
            self.currentbp = 0
            lastcmd_back = self.lastcmd
            self.setup(frame, None)
            for line in self.commands[currentbp]:
                self.onecmd(line)
            self.lastcmd = lastcmd_back
            if not self.commands_silent[currentbp]:
                self.print_stack_entry(self.stack[self.curindex])
            if self.commands_doprompt[currentbp]:
                self.cmdloop()
            self.forget()
            return
        return 1

    def user_return(self, frame, return_value):
        """This function is called when a return trap is set here."""
        if self._wait_for_mainpyfile:
            return
        frame.f_locals['__return__'] = return_value
        print >>self.stdout, '--Return--'
        self.interaction(frame, None)

    def user_exception(self, frame, exc_info):
        """This function is called if an exception occurs,
        but only if we are to stop at or just below this level."""
        if self._wait_for_mainpyfile:
            return
        exc_type, exc_value, exc_traceback = exc_info
        frame.f_locals['__exception__'] = exc_type, exc_value
        if type(exc_type) == type(''):
            exc_type_name = exc_type
        else: exc_type_name = exc_type.__name__
        print >>self.stdout, exc_type_name + ':', _saferepr(exc_value)
        self.interaction(frame, exc_traceback)

    # General interaction function

    def interaction(self, frame, traceback):
        self.setup(frame, traceback)
        self.print_stack_entry(self.stack[self.curindex])
        self.cmdloop()
        self.forget()

    def displayhook(self, obj):
        """Custom displayhook for the exec in default(), which prevents
        assignment of the _ variable in the builtins.
        """
        # reproduce the behavior of the standard displayhook, not printing None
        if obj is not None:
            print repr(obj)

    def default(self, line):
        if line[:1] == '!': line = line[1:]
        locals = self.curframe_locals
        globals = self.curframe.f_globals
        try:
            code = compile(line + '\n', '<stdin>', 'single')
            save_stdout = sys.stdout
            save_stdin = sys.stdin
            save_displayhook = sys.displayhook
            try:
                sys.stdin = self.stdin
                sys.stdout = self.stdout
                sys.displayhook = self.displayhook
                exec code in globals, locals
            finally:
                sys.stdout = save_stdout
                sys.stdin = save_stdin
                sys.displayhook = save_displayhook
        except:
            t, v = sys.exc_info()[:2]
            if type(t) == type(''):
                exc_type_name = t
            else: exc_type_name = t.__name__
            print >>self.stdout, '***', exc_type_name + ':', v

    def precmd(self, line):
        """Handle alias expansion and ';;' separator."""
        if not line.strip():
            return line
        args = line.split()
        while args[0] in self.aliases:
            line = self.aliases[args[0]]
            ii = 1
            for tmpArg in args[1:]:
                line = line.replace("%" + str(ii),
                                      tmpArg)
                ii = ii + 1
            line = line.replace("%*", ' '.join(args[1:]))
            args = line.split()
        # split into ';;' separated commands
        # unless it's an alias command
        if args[0] != 'alias':
            marker = line.find(';;')
            if marker >= 0:
                # queue up everything after marker
                next = line[marker+2:].lstrip()
                self.cmdqueue.append(next)
                line = line[:marker].rstrip()
        return line

    def onecmd(self, line):
        """Interpret the argument as though it had been typed in response
        to the prompt.

        Checks whether this line is typed at the normal prompt or in
        a breakpoint command list definition.
        """
        if not self.commands_defining:
            return cmd.Cmd.onecmd(self, line)
        else:
            return self.handle_command_def(line)

    def handle_command_def(self,line):
        """Handles one command line during command list definition."""
        cmd, arg, line = self.parseline(line)
        if not cmd:
            return
        if cmd == 'silent':
            self.commands_silent[self.commands_bnum] = True
            return # continue to handle other cmd def in the cmd list
        elif cmd == 'end':
            self.cmdqueue = []
            return 1 # end of cmd list
        cmdlist = self.commands[self.commands_bnum]
        if arg:
            cmdlist.append(cmd+' '+arg)
        else:
            cmdlist.append(cmd)
        # Determine if we must stop
        try:
            func = getattr(self, 'do_' + cmd)
        except AttributeError:
            func = self.default
        # one of the resuming commands
        if func.func_name in self.commands_resuming:
            self.commands_doprompt[self.commands_bnum] = False
            self.cmdqueue = []
            return 1
        return

    # Command definitions, called by cmdloop()
    # The argument is the remaining string on the command line
    # Return true to exit from the command loop

    do_h = cmd.Cmd.do_help

    def do_commands(self, arg):
        """Defines a list of commands associated to a breakpoint.

        Those commands will be executed whenever the breakpoint causes
        the program to stop execution."""
        if not arg:
            bnum = len(bdb.Breakpoint.bpbynumber)-1
        else:
            try:
                bnum = int(arg)
            except:
                print >>self.stdout, "Usage : commands [bnum]\n        ..." \
                                     "\n        end"
                return
        self.commands_bnum = bnum
        self.commands[bnum] = []
        self.commands_doprompt[bnum] = True
        self.commands_silent[bnum] = False
        prompt_back = self.prompt
        self.prompt = '(com) '
        self.commands_defining = True
        try:
            self.cmdloop()
        finally:
            self.commands_defining = False
            self.prompt = prompt_back

    def do_break(self, arg, temporary = 0):
        # break [ ([filename:]lineno | function) [, "condition"] ]
        if not arg:
            if self.breaks:  # There's at least one
                print >>self.stdout, "Num Type         Disp Enb   Where"
                for bp in bdb.Breakpoint.bpbynumber:
                    if bp:
                        bp.bpprint(self.stdout)
            return
        # parse arguments; comma has lowest precedence
        # and cannot occur in filename
        filename = None
        lineno = None
        cond = None
        comma = arg.find(',')
        if comma > 0:
            # parse stuff after comma: "condition"
            cond = arg[comma+1:].lstrip()
            arg = arg[:comma].rstrip()
        # parse stuff before comma: [filename:]lineno | function
        colon = arg.rfind(':')
        funcname = None
        if colon >= 0:
            filename = arg[:colon].rstrip()
            f = self.lookupmodule(filename)
            if not f:
                print >>self.stdout, '*** ', repr(filename),
                print >>self.stdout, 'not found from sys.path'
                return
            else:
                filename = f
            arg = arg[colon+1:].lstrip()
            try:
                lineno = int(arg)
            except ValueError, msg:
                print >>self.stdout, '*** Bad lineno:', arg
                return
        else:
            # no colon; can be lineno or function
            try:
                lineno = int(arg)
            except ValueError:
                try:
                    func = eval(arg,
                                self.curframe.f_globals,
                                self.curframe_locals)
                except:
                    func = arg
                try:
                    if hasattr(func, 'im_func'):
                        func = func.im_func
                    code = func.func_code
                    #use co_name to identify the bkpt (function names
                    #could be aliased, but co_name is invariant)
                    funcname = code.co_name
                    lineno = code.co_firstlineno
                    filename = code.co_filename
                except:
                    # last thing to try
                    (ok, filename, ln) = self.lineinfo(arg)
                    if not ok:
                        print >>self.stdout, '*** The specified object',
                        print >>self.stdout, repr(arg),
                        print >>self.stdout, 'is not a function'
                        print >>self.stdout, 'or was not found along sys.path.'
                        return
                    funcname = ok # ok contains a function name
                    lineno = int(ln)
        if not filename:
            filename = self.defaultFile()
        # Check for reasonable breakpoint
        line = self.checkline(filename, lineno)
        if line:
            # now set the break point
            err = self.set_break(filename, line, temporary, cond, funcname)
            if err: print >>self.stdout, '***', err
            else:
                bp = self.get_breaks(filename, line)[-1]
                print >>self.stdout, "Breakpoint %d at %s:%d" % (bp.number,
                                                                 bp.file,
                                                                 bp.line)

    # To be overridden in derived debuggers
    def defaultFile(self):
        """Produce a reasonable default."""
        filename = self.curframe.f_code.co_filename
        if filename == '<string>' and self.mainpyfile:
            filename = self.mainpyfile
        return filename

    do_b = do_break

    def do_tbreak(self, arg):
        self.do_break(arg, 1)

    def lineinfo(self, identifier):
        failed = (None, None, None)
        # Input is identifier, may be in single quotes
        idstring = identifier.split("'")
        if len(idstring) == 1:
            # not in single quotes
            id = idstring[0].strip()
        elif len(idstring) == 3:
            # quoted
            id = idstring[1].strip()
        else:
            return failed
        if id == '': return failed
        parts = id.split('.')
        # Protection for derived debuggers
        if parts[0] == 'self':
            del parts[0]
            if len(parts) == 0:
                return failed
        # Best first guess at file to look at
        fname = self.defaultFile()
        if len(parts) == 1:
            item = parts[0]
        else:
            # More than one part.
            # First is module, second is method/class
            f = self.lookupmodule(parts[0])
            if f:
                fname = f
            item = parts[1]
        answer = find_function(item, fname)
        return answer or failed

    def checkline(self, filename, lineno):
        """Check whether specified line seems to be executable.

        Return `lineno` if it is, 0 if not (e.g. a docstring, comment, blank
        line or EOF). Warning: testing is not comprehensive.
        """
        # this method should be callable before starting debugging, so default
        # to "no globals" if there is no current frame
        globs = self.curframe.f_globals if hasattr(self, 'curframe') else None
        line = linecache.getline(filename, lineno, globs)
        if not line:
            print >>self.stdout, 'End of file'
            return 0
        line = line.strip()
        # Don't allow setting breakpoint at a blank line
        if (not line or (line[0] == '#') or
             (line[:3] == '"""') or line[:3] == "'''"):
            print >>self.stdout, '*** Blank or comment'
            return 0
        return lineno

    def do_enable(self, arg):
        args = arg.split()
        for i in args:
            try:
                i = int(i)
            except ValueError:
                print >>self.stdout, 'Breakpoint index %r is not a number' % i
                continue

            if not (0 <= i < len(bdb.Breakpoint.bpbynumber)):
                print >>self.stdout, 'No breakpoint numbered', i
                continue

            bp = bdb.Breakpoint.bpbynumber[i]
            if bp:
                bp.enable()

    def do_disable(self, arg):
        args = arg.split()
        for i in args:
            try:
                i = int(i)
            except ValueError:
                print >>self.stdout, 'Breakpoint index %r is not a number' % i
                continue

            if not (0 <= i < len(bdb.Breakpoint.bpbynumber)):
                print >>self.stdout, 'No breakpoint numbered', i
                continue

            bp = bdb.Breakpoint.bpbynumber[i]
            if bp:
                bp.disable()

    def do_condition(self, arg):
        # arg is breakpoint number and condition
        args = arg.split(' ', 1)
        try:
            bpnum = int(args[0].strip())
        except ValueError:
            # something went wrong
            print >>self.stdout, \
                'Breakpoint index %r is not a number' % args[0]
            return
        try:
            cond = args[1]
        except:
            cond = None
        try:
            bp = bdb.Breakpoint.bpbynumber[bpnum]
        except IndexError:
            print >>self.stdout, 'Breakpoint index %r is not valid' % args[0]
            return
        if bp:
            bp.cond = cond
            if not cond:
                print >>self.stdout, 'Breakpoint', bpnum,
                print >>self.stdout, 'is now unconditional.'

    def do_ignore(self,arg):
        """arg is bp number followed by ignore count."""
        args = arg.split()
        try:
            bpnum = int(args[0].strip())
        except ValueError:
            # something went wrong
            print >>self.stdout, \
                'Breakpoint index %r is not a number' % args[0]
            return
        try:
            count = int(args[1].strip())
        except:
            count = 0
        try:
            bp = bdb.Breakpoint.bpbynumber[bpnum]
        except IndexError:
            print >>self.stdout, 'Breakpoint index %r is not valid' % args[0]
            return
        if bp:
            bp.ignore = count
            if count > 0:
                reply = 'Will ignore next '
                if count > 1:
                    reply = reply + '%d crossings' % count
                else:
                    reply = reply + '1 crossing'
                print >>self.stdout, reply + ' of breakpoint %d.' % bpnum
            else:
                print >>self.stdout, 'Will stop next time breakpoint',
                print >>self.stdout, bpnum, 'is reached.'

    def do_clear(self, arg):
        """Three possibilities, tried in this order:
        clear -> clear all breaks, ask for confirmation
        clear file:lineno -> clear all breaks at file:lineno
        clear bpno bpno ... -> clear breakpoints by number"""
        if not arg:
            try:
                reply = raw_input('Clear all breaks? ')
            except EOFError:
                reply = 'no'
            reply = reply.strip().lower()
            if reply in ('y', 'yes'):
                self.clear_all_breaks()
            return
        if ':' in arg:
            # Make sure it works for "clear C:\foo\bar.py:12"
            i = arg.rfind(':')
            filename = arg[:i]
            arg = arg[i+1:]
            try:
                lineno = int(arg)
            except ValueError:
                err = "Invalid line number (%s)" % arg
            else:
                err = self.clear_break(filename, lineno)
            if err: print >>self.stdout, '***', err
            return
        numberlist = arg.split()
        for i in numberlist:
            try:
                i = int(i)
            except ValueError:
                print >>self.stdout, 'Breakpoint index %r is not a number' % i
                continue

            if not (0 <= i < len(bdb.Breakpoint.bpbynumber)):
                print >>self.stdout, 'No breakpoint numbered', i
                continue
            err = self.clear_bpbynumber(i)
            if err:
                print >>self.stdout, '***', err
            else:
                print >>self.stdout, 'Deleted breakpoint', i
    do_cl = do_clear # 'c' is already an abbreviation for 'continue'

    def do_where(self, arg):
        self.print_stack_trace()
    do_w = do_where
    do_bt = do_where

    def do_up(self, arg):
        if self.curindex == 0:
            print >>self.stdout, '*** Oldest frame'
        else:
            self.curindex = self.curindex - 1
            self.curframe = self.stack[self.curindex][0]
            self.curframe_locals = self.curframe.f_locals
            self.print_stack_entry(self.stack[self.curindex])
            self.lineno = None
    do_u = do_up

    def do_down(self, arg):
        if self.curindex + 1 == len(self.stack):
            print >>self.stdout, '*** Newest frame'
        else:
            self.curindex = self.curindex + 1
            self.curframe = self.stack[self.curindex][0]
            self.curframe_locals = self.curframe.f_locals
            self.print_stack_entry(self.stack[self.curindex])
            self.lineno = None
    do_d = do_down

    def do_until(self, arg):
        self.set_until(self.curframe)
        return 1
    do_unt = do_until

    def do_step(self, arg):
        self.set_step()
        return 1
    do_s = do_step

    def do_next(self, arg):
        self.set_next(self.curframe)
        return 1
    do_n = do_next

    def do_run(self, arg):
        """Restart program by raising an exception to be caught in the main
        debugger loop.  If arguments were given, set them in sys.argv."""
        if arg:
            import shlex
            argv0 = sys.argv[0:1]
            sys.argv = shlex.split(arg)
            sys.argv[:0] = argv0
        raise Restart

    do_restart = do_run

    def do_return(self, arg):
        self.set_return(self.curframe)
        return 1
    do_r = do_return

    def do_continue(self, arg):
        self.set_continue()
        return 1
    do_c = do_cont = do_continue

    def do_jump(self, arg):
        if self.curindex + 1 != len(self.stack):
            print >>self.stdout, "*** You can only jump within the bottom frame"
            return
        try:
            arg = int(arg)
        except ValueError:
            print >>self.stdout, "*** The 'jump' command requires a line number."
        else:
            try:
                # Do the jump, fix up our copy of the stack, and display the
                # new position
                self.curframe.f_lineno = arg
                self.stack[self.curindex] = self.stack[self.curindex][0], arg
                self.print_stack_entry(self.stack[self.curindex])
            except ValueError, e:
                print >>self.stdout, '*** Jump failed:', e
    do_j = do_jump

    def do_debug(self, arg):
        sys.settrace(None)
        globals = self.curframe.f_globals
        locals = self.curframe_locals
        p = Pdb(self.completekey, self.stdin, self.stdout)
        p.prompt = "(%s) " % self.prompt.strip()
        print >>self.stdout, "ENTERING RECURSIVE DEBUGGER"
        sys.call_tracing(p.run, (arg, globals, locals))
        print >>self.stdout, "LEAVING RECURSIVE DEBUGGER"
        sys.settrace(self.trace_dispatch)
        self.lastcmd = p.lastcmd

    def do_quit(self, arg):
        self._user_requested_quit = 1
        self.set_quit()
        return 1

    do_q = do_quit
    do_exit = do_quit

    def do_EOF(self, arg):
        print >>self.stdout
        self._user_requested_quit = 1
        self.set_quit()
        return 1

    def do_args(self, arg):
        co = self.curframe.f_code
        dict = self.curframe_locals
        n = co.co_argcount
        if co.co_flags & 4: n = n+1
        if co.co_flags & 8: n = n+1
        for i in range(n):
            name = co.co_varnames[i]
            print >>self.stdout, name, '=',
            if name in dict: print >>self.stdout, dict[name]
            else: print >>self.stdout, "*** undefined ***"
    do_a = do_args

    def do_retval(self, arg):
        if '__return__' in self.curframe_locals:
            print >>self.stdout, self.curframe_locals['__return__']
        else:
            print >>self.stdout, '*** Not yet returned!'
    do_rv = do_retval

    def _getval(self, arg):
        try:
            return eval(arg, self.curframe.f_globals,
                        self.curframe_locals)
        except:
            t, v = sys.exc_info()[:2]
            if isinstance(t, str):
                exc_type_name = t
            else: exc_type_name = t.__name__
            print >>self.stdout, '***', exc_type_name + ':', repr(v)
            raise

    def do_p(self, arg):
        try:
            print >>self.stdout, repr(self._getval(arg))
        except:
            pass

    def do_pp(self, arg):
        try:
            pprint.pprint(self._getval(arg), self.stdout)
        except:
            pass

    def do_list(self, arg):
        self.lastcmd = 'list'
        last = None
        if arg:
            try:
                x = eval(arg, {}, {})
                if type(x) == type(()):
                    first, last = x
                    first = int(first)
                    last = int(last)
                    if last < first:
                        # Assume it's a count
                        last = first + last
                else:
                    first = max(1, int(x) - 5)
            except:
                print >>self.stdout, '*** Error in argument:', repr(arg)
                return
        elif self.lineno is None:
            first = max(1, self.curframe.f_lineno - 5)
        else:
            first = self.lineno + 1
        if last is None:
            last = first + 10
        filename = self.curframe.f_code.co_filename
        breaklist = self.get_file_breaks(filename)
        try:
            for lineno in range(first, last+1):
                line = linecache.getline(filename, lineno,
                                         self.curframe.f_globals)
                if not line:
                    print >>self.stdout, '[EOF]'
                    break
                else:
                    s = repr(lineno).rjust(3)
                    if len(s) < 4: s = s + ' '
                    if lineno in breaklist: s = s + 'B'
                    else: s = s + ' '
                    if lineno == self.curframe.f_lineno:
                        s = s + '->'
                    print >>self.stdout, s + '\t' + line,
                    self.lineno = lineno
        except KeyboardInterrupt:
            pass
    do_l = do_list

    def do_whatis(self, arg):
        try:
            value = eval(arg, self.curframe.f_globals,
                            self.curframe_locals)
        except:
            t, v = sys.exc_info()[:2]
            if type(t) == type(''):
                exc_type_name = t
            else: exc_type_name = t.__name__
            print >>self.stdout, '***', exc_type_name + ':', repr(v)
            return
        code = None
        # Is it a function?
        try: code = value.func_code
        except: pass
        if code:
            print >>self.stdout, 'Function', code.co_name
            return
        # Is it an instance method?
        try: code = value.im_func.func_code
        except: pass
        if code:
            print >>self.stdout, 'Method', code.co_name
            return
        # None of the above...
        print >>self.stdout, type(value)

    def do_alias(self, arg):
        args = arg.split()
        if len(args) == 0:
            keys = self.aliases.keys()
            keys.sort()
            for alias in keys:
                print >>self.stdout, "%s = %s" % (alias, self.aliases[alias])
            return
        if args[0] in self.aliases and len(args) == 1:
            print >>self.stdout, "%s = %s" % (args[0], self.aliases[args[0]])
        else:
            self.aliases[args[0]] = ' '.join(args[1:])

    def do_unalias(self, arg):
        args = arg.split()
        if len(args) == 0: return
        if args[0] in self.aliases:
            del self.aliases[args[0]]

    #list of all the commands making the program resume execution.
    commands_resuming = ['do_continue', 'do_step', 'do_next', 'do_return',
                         'do_quit', 'do_jump']

    # Print a traceback starting at the top stack frame.
    # The most recently entered frame is printed last;
    # this is different from dbx and gdb, but consistent with
    # the Python interpreter's stack trace.
    # It is also consistent with the up/down commands (which are
    # compatible with dbx and gdb: up moves towards 'main()'
    # and down moves towards the most recent stack frame).

    def print_stack_trace(self):
        try:
            for frame_lineno in self.stack:
                self.print_stack_entry(frame_lineno)
        except KeyboardInterrupt:
            pass

    def print_stack_entry(self, frame_lineno, prompt_prefix=line_prefix):
        frame, lineno = frame_lineno
        if frame is self.curframe:
            print >>self.stdout, '>',
        else:
            print >>self.stdout, ' ',
        print >>self.stdout, self.format_stack_entry(frame_lineno,
                                                     prompt_prefix)


    # Help methods (derived from pdb.doc)

    def help_help(self):
        self.help_h()

    def help_h(self):
        print >>self.stdout, """h(elp)
Without argument, print the list of available commands.
With a command name as argument, print help about that command
"help pdb" pipes the full documentation file to the $PAGER
"help exec" gives help on the ! command"""

    def help_where(self):
        self.help_w()

    def help_w(self):
        print >>self.stdout, """w(here)
Print a stack trace, with the most recent frame at the bottom.
An arrow indicates the "current frame", which determines the
context of most commands.  'bt' is an alias for this command."""

    help_bt = help_w

    def help_down(self):
        self.help_d()

    def help_d(self):
        print >>self.stdout, """d(own)
Move the current frame one level down in the stack trace
(to a newer frame)."""

    def help_up(self):
        self.help_u()

    def help_u(self):
        print >>self.stdout, """u(p)
Move the current frame one level up in the stack trace
(to an older frame)."""

    def help_break(self):
        self.help_b()

    def help_b(self):
        print >>self.stdout, """b(reak) ([file:]lineno | function) [, condition]
With a line number argument, set a break there in the current
file.  With a function name, set a break at first executable line
of that function.  Without argument, list all breaks.  If a second
argument is present, it is a string specifying an expression
which must evaluate to true before the breakpoint is honored.

The line number may be prefixed with a filename and a colon,
to specify a breakpoint in another file (probably one that
hasn't been loaded yet).  The file is searched for on sys.path;
the .py suffix may be omitted."""

    def help_clear(self):
        self.help_cl()

    def help_cl(self):
        print >>self.stdout, "cl(ear) filename:lineno"
        print >>self.stdout, """cl(ear) [bpnumber [bpnumber...]]
With a space separated list of breakpoint numbers, clear
those breakpoints.  Without argument, clear all breaks (but
first ask confirmation).  With a filename:lineno argument,
clear all breaks at that line in that file.

Note that the argument is different from previous versions of
the debugger (in python distributions 1.5.1 and before) where
a linenumber was used instead of either filename:lineno or
breakpoint numbers."""

    def help_tbreak(self):
        print >>self.stdout, """tbreak  same arguments as break, but breakpoint
is removed when first hit."""

    def help_enable(self):
        print >>self.stdout, """enable bpnumber [bpnumber ...]
Enables the breakpoints given as a space separated list of
bp numbers."""

    def help_disable(self):
        print >>self.stdout, """disable bpnumber [bpnumber ...]
Disables the breakpoints given as a space separated list of
bp numbers."""

    def help_ignore(self):
        print >>self.stdout, """ignore bpnumber count
Sets the ignore count for the given breakpoint number.  A breakpoint
becomes active when the ignore count is zero.  When non-zero, the
count is decremented each time the breakpoint is reached and the
breakpoint is not disabled and any associated condition evaluates
to true."""

    def help_condition(self):
        print >>self.stdout, """condition bpnumber str_condition
str_condition is a string specifying an expression which
must evaluate to true before the breakpoint is honored.
If str_condition is absent, any existing condition is removed;
i.e., the breakpoint is made unconditional."""

    def help_step(self):
        self.help_s()

    def help_s(self):
        print >>self.stdout, """s(tep)
Execute the current line, stop at the first possible occasion
(either in a function that is called or in the current function)."""

    def help_until(self):
        self.help_unt()

    def help_unt(self):
        print """unt(il)
Continue execution until the line with a number greater than the current
one is reached or until the current frame returns"""

    def help_next(self):
        self.help_n()

    def help_n(self):
        print >>self.stdout, """n(ext)
Continue execution until the next line in the current function
is reached or it returns."""

    def help_return(self):
        self.help_r()

    def help_r(self):
        print >>self.stdout, """r(eturn)
Continue execution until the current function returns."""

    def help_continue(self):
        self.help_c()

    def help_cont(self):
        self.help_c()

    def help_c(self):
        print >>self.stdout, """c(ont(inue))
Continue execution, only stop when a breakpoint is encountered."""

    def help_jump(self):
        self.help_j()

    def help_j(self):
        print >>self.stdout, """j(ump) lineno
Set the next line that will be executed."""

    def help_debug(self):
        print >>self.stdout, """debug code
Enter a recursive debugger that steps through the code argument
(which is an arbitrary expression or statement to be executed
in the current environment)."""

    def help_list(self):
        self.help_l()

    def help_l(self):
        print >>self.stdout, """l(ist) [first [,last]]
List source code for the current file.
Without arguments, list 11 lines around the current line
or continue the previous listing.
With one argument, list 11 lines starting at that line.
With two arguments, list the given range;
if the second argument is less than the first, it is a count."""

    def help_args(self):
        self.help_a()

    def help_a(self):
        print >>self.stdout, """a(rgs)
Print the arguments of the current function."""

    def help_p(self):
        print >>self.stdout, """p expression
Print the value of the expression."""

    def help_pp(self):
        print >>self.stdout, """pp expression
Pretty-print the value of the expression."""

    def help_exec(self):
        print >>self.stdout, """(!) statement
Execute the (one-line) statement in the context of
the current stack frame.
The exclamation point can be omitted unless the first word
of the statement resembles a debugger command.
To assign to a global variable you must always prefix the
command with a 'global' command, e.g.:
(Pdb) global list_options; list_options = ['-l']
(Pdb)"""

    def help_run(self):
        print """run [args...]
Restart the debugged python program. If a string is supplied, it is
split with "shlex" and the result is used as the new sys.argv.
History, breakpoints, actions and debugger options are preserved.
"restart" is an alias for "run"."""

    help_restart = help_run

    def help_quit(self):
        self.help_q()

    def help_q(self):
        print >>self.stdout, """q(uit) or exit - Quit from the debugger.
The program being executed is aborted."""

    help_exit = help_q

    def help_whatis(self):
        print >>self.stdout, """whatis arg
Prints the type of the argument."""

    def help_EOF(self):
        print >>self.stdout, """EOF
Handles the receipt of EOF as a command."""

    def help_alias(self):
        print >>self.stdout, """alias [name [command [parameter parameter ...]]]
Creates an alias called 'name' the executes 'command'.  The command
must *not* be enclosed in quotes.  Replaceable parameters are
indicated by %1, %2, and so on, while %* is replaced by all the
parameters.  If no command is given, the current alias for name
is shown. If no name is given, all aliases are listed.

Aliases may be nested and can contain anything that can be
legally typed at the pdb prompt.  Note!  You *can* override
internal pdb commands with aliases!  Those internal commands
are then hidden until the alias is removed.  Aliasing is recursively
applied to the first word of the command line; all other words
in the line are left alone.

Some useful aliases (especially when placed in the .pdbrc file) are:

#Print instance variables (usage "pi classInst")
alias pi for k in %1.__dict__.keys(): print "%1.",k,"=",%1.__dict__[k]

#Print instance variables in self
alias ps pi self
"""

    def help_unalias(self):
        print >>self.stdout, """unalias name
Deletes the specified alias."""

    def help_commands(self):
        print >>self.stdout, """commands [bpnumber]
(com) ...
(com) end
(Pdb)

Specify a list of commands for breakpoint number bpnumber.  The
commands themselves appear on the following lines.  Type a line
containing just 'end' to terminate the commands.

To remove all commands from a breakpoint, type commands and
follow it immediately with  end; that is, give no commands.

With no bpnumber argument, commands refers to the last
breakpoint set.

You can use breakpoint commands to start your program up again.
Simply use the continue command, or step, or any other
command that resumes execution.

Specifying any command resuming execution (currently continue,
step, next, return, jump, quit and their abbreviations) terminates
the command list (as if that command was immediately followed by end).
This is because any time you resume execution
(even with a simple next or step), you may encounter
another breakpoint--which could have its own command list, leading to
ambiguities about which list to execute.

   If you use the 'silent' command in the command list, the
usual message about stopping at a breakpoint is not printed.  This may
be desirable for breakpoints that are to print a specific message and
then continue.  If none of the other commands print anything, you
see no sign that the breakpoint was reached.
"""

    def help_pdb(self):
        help()

    def lookupmodule(self, filename):
        """Helper function for break/clear parsing -- may be overridden.

        lookupmodule() translates (possibly incomplete) file or module name
        into an absolute file name.
        """
        if os.path.isabs(filename) and  os.path.exists(filename):
            return filename
        f = os.path.join(sys.path[0], filename)
        if  os.path.exists(f) and self.canonic(f) == self.mainpyfile:
            return f
        root, ext = os.path.splitext(filename)
        if ext == '':
            filename = filename + '.py'
        if os.path.isabs(filename):
            return filename
        for dirname in sys.path:
            while os.path.islink(dirname):
                dirname = os.readlink(dirname)
            fullname = os.path.join(dirname, filename)
            if os.path.exists(fullname):
                return fullname
        return None

    def _runscript(self, filename):
        # The script has to run in __main__ namespace (or imports from
        # __main__ will break).
        #
        # So we clear up the __main__ and set several special variables
        # (this gets rid of pdb's globals and cleans old variables on restarts).
        import __main__
        __main__.__dict__.clear()
        __main__.__dict__.update({"__name__"    : "__main__",
                                  "__file__"    : filename,
                                  "__builtins__": __builtins__,
                                 })

        # When bdb sets tracing, a number of call and line events happens
        # BEFORE debugger even reaches user's code (and the exact sequence of
        # events depends on python version). So we take special measures to
        # avoid stopping before we reach the main script (see user_line and
        # user_call for details).
        self._wait_for_mainpyfile = 1
        self.mainpyfile = self.canonic(filename)
        self._user_requested_quit = 0
        statement = 'execfile(%r)' % filename
        self.run(statement)

# Simplified interface

def run(statement, globals=None, locals=None):
    Pdb().run(statement, globals, locals)

def runeval(expression, globals=None, locals=None):
    return Pdb().runeval(expression, globals, locals)

def runctx(statement, globals, locals):
    # B/W compatibility
    run(statement, globals, locals)

def runcall(*args, **kwds):
    return Pdb().runcall(*args, **kwds)

def set_trace():
    Pdb().set_trace(sys._getframe().f_back)

# Post-Mortem interface

def post_mortem(t=None):
    # handling the default
    if t is None:
        # sys.exc_info() returns (type, value, traceback) if an exception is
        # being handled, otherwise it returns None
        t = sys.exc_info()[2]
        if t is None:
            raise ValueError("A valid traceback must be passed if no "
                                               "exception is being handled")

    p = Pdb()
    p.reset()
    p.interaction(None, t)

def pm():
    post_mortem(sys.last_traceback)


# Main program for testing

TESTCMD = 'import x; x.main()'

def test():
    run(TESTCMD)

# print help
def help():
    for dirname in sys.path:
        fullname = os.path.join(dirname, 'pdb.doc')
        if os.path.exists(fullname):
            sts = os.system('${PAGER-more} '+fullname)
            if sts: print '*** Pager exit status:', sts
            break
    else:
        print 'Sorry, can\'t find the help file "pdb.doc"',
        print 'along the Python search path'

def main():
    if not sys.argv[1:] or sys.argv[1] in ("--help", "-h"):
        print "usage: pdb.py scriptfile [arg] ..."
        sys.exit(2)

    mainpyfile =  sys.argv[1]     # Get script filename
    if not os.path.exists(mainpyfile):
        print 'Error:', mainpyfile, 'does not exist'
        sys.exit(1)

    del sys.argv[0]         # Hide "pdb.py" from argument list

    # Replace pdb's dir with script's dir in front of module search path.
    sys.path[0] = os.path.dirname(mainpyfile)

    # Note on saving/restoring sys.argv: it's a good idea when sys.argv was
    # modified by the script being debugged. It's a bad idea when it was
    # changed by the user from the command line. There is a "restart" command
    # which allows explicit specification of command line arguments.
    pdb = Pdb()
    while True:
        try:
            pdb._runscript(mainpyfile)
            if pdb._user_requested_quit:
                break
            print "The program finished and will be restarted"
        except Restart:
            print "Restarting", mainpyfile, "with arguments:"
            print "\t" + " ".join(sys.argv[1:])
        except SystemExit:
            # In most cases SystemExit does not warrant a post-mortem session.
            print "The program exited via sys.exit(). Exit status: ",
            print sys.exc_info()[1]
        except SyntaxError:
            traceback.print_exc()
            sys.exit(1)
        except:
            traceback.print_exc()
            print "Uncaught exception. Entering post mortem debugging"
            print "Running 'cont' or 'step' will restart the program"
            t = sys.exc_info()[2]
            pdb.interaction(None, t)
            print "Post mortem debugger finished. The " + mainpyfile + \
                  " will be restarted"


# When invoked as main program, invoke the debugger on a script
if __name__ == '__main__':
    import pdb
    pdb.main()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ó
Ó«[c        	   @   sŽ  d  Z  d d l Z d d l Z d d l Z d d l Z d d l m Z d d l Z d d l Z d d l	 Z	 d d l
 Z
 d e f d „  ƒ  YZ e ƒ  Z d e _ e j Z d d d	 d
 d d d d d g	 Z d „  Z d Z d	 e j e j f d „  ƒ  YZ e e d „ Z e e d „ Z d „  Z d „  Z d „  Z e d „ Z d „  Z d Z d „  Z d „  Z  d „  Z! e" d k rŠd d l# Z# e# j! ƒ  n  d S(   s   A Python debugger.iÿÿÿÿN(   t   Reprt   Restartc           B   s   e  Z d  Z RS(   sB   Causes a debugger to be restarted for the debugged python program.(   t   __name__t
   __module__t   __doc__(    (    (    s   /usr/lib/python2.7/pdb.pyR      s   iÈ   t   runt   pmt   Pdbt   runevalt   runctxt   runcallt	   set_tracet   post_mortemt   helpc         C   sª   t  j d t  j |  ƒ ƒ } y t | ƒ } Wn t k
 r@ d  SXd } d  } xL | j ƒ  } | d k rl Pn  | j | ƒ rŽ |  | | f } Pn  | d } qP W| j ƒ  | S(   Ns   def\s+%s\s*[(]i   t    (	   t   ret   compilet   escapet   opent   IOErrort   Nonet   readlinet   matcht   close(   t   funcnamet   filenamet   cret   fpt   linenot   answert   line(    (    s   /usr/lib/python2.7/pdb.pyt   find_function   s"    
s   
-> c           B   sD  e  Z d  dl dl dl d „ Z d „  Z d „  Z d „  Z d „  Z d „  Z d „  Z	 d „  Z
 d	 „  Z d
 „  Z d „  Z d „  Z d „  Z d „  Z d „  Z d „  Z e j j Z d „  Z d d „ Z d „  Z e Z d „  Z d „  Z d „  Z d „  Z d „  Z d „  Z  d „  Z! d „  Z" e" Z# d „  Z$ e$ Z% e$ Z& d „  Z' e' Z( d „  Z) e) Z* d  „  Z+ e+ Z, d! „  Z- e- Z. d" „  Z/ e/ Z0 d# „  Z1 e1 Z2 d$ „  Z3 e3 Z4 d% „  Z5 e5 Z6 Z7 d& „  Z8 e8 Z9 d' „  Z: d( „  Z; e; Z< e; Z= d) „  Z> d* „  Z? e? Z@ d+ „  ZA eA ZB d, „  ZC d- „  ZD d. „  ZE d/ „  ZF eF ZG d0 „  ZH d1 „  ZI d2 „  ZJ d3 d4 d5 d6 d7 d8 g ZK d9 „  ZL eM d: „ ZN d; „  ZO d< „  ZP d= „  ZQ d> „  ZR eR ZS d? „  ZT d@ „  ZU dA „  ZV dB „  ZW dC „  ZX dD „  ZY dE „  ZZ dF „  Z[ dG „  Z\ dH „  Z] dI „  Z^ dJ „  Z_ dK „  Z` dL „  Za dM „  Zb dN „  Zc dO „  Zd dP „  Ze dQ „  Zf dR „  Zg dS „  Zh dT „  Zi dU „  Zj dV „  Zk dW „  Zl dX „  Zm dY „  Zn dZ „  Zo d[ „  Zp d\ „  Zq d] „  Zr d^ „  Zs d_ „  Zt d` „  Zu da „  Zv ev Zw db „  Zx dc „  Zy ey Zz dd „  Z{ de „  Z| df „  Z} dg „  Z~ dh „  Z di „  Z€ dj „  Z dk „  Z‚ RS(m   t   tabc   	      C   s›  t  j j |  d | ƒt j j |  | | | ƒ | rA d |  _ n  d |  _ i  |  _ d |  _ d |  _	 y d d  l
 } Wn t k
 rˆ n Xg  |  _ d t j k rt j d } y t t j j | d ƒ ƒ } Wn t k
 rà qXx$ | j ƒ  D] } |  j j | ƒ qî W| j ƒ  n  y t d ƒ } Wn t k
 r8n2 Xx$ | j ƒ  D] } |  j j | ƒ qFW| j ƒ  i  |  _ i  |  _ i  |  _ t |  _ d  |  _ d  S(   Nt   skipi    s   (Pdb) R   iÿÿÿÿt   HOMEs   .pdbrc(   t   bdbt   Bdbt   __init__t   cmdt   Cmdt   use_rawinputt   promptt   aliasest
   mainpyfilet   _wait_for_mainpyfileR   t   ImportErrort   rcLinest   ost   environR   t   patht   joinR   t	   readlinest   appendR   t   commandst   commands_dopromptt   commands_silentt   Falset   commands_definingR   t   commands_bnum(	   t   selft   completekeyt   stdint   stdoutR!   R   t   envHomet   rcFileR   (    (    s   /usr/lib/python2.7/pdb.pyR%   =   sD    					
				c         C   s   t  j j |  ƒ |  j ƒ  d  S(   N(   R#   R$   t   resett   forget(   R;   (    (    s   /usr/lib/python2.7/pdb.pyRA   k   s    c         C   s(   d  |  _ g  |  _ d |  _ d  |  _ d  S(   Ni    (   R   R   t   stackt   curindext   curframe(   R;   (    (    s   /usr/lib/python2.7/pdb.pyRB   o   s    			c         C   s\   |  j  ƒ  |  j | | ƒ \ |  _ |  _ |  j |  j d |  _ |  j j |  _ |  j ƒ  d  S(   Ni    (   RB   t	   get_stackRC   RD   RE   t   f_localst   curframe_localst   execRcLines(   R;   t   ft   t(    (    s   /usr/lib/python2.7/pdb.pyt   setupu   s
    
c         C   so   |  j  rk |  j  } g  |  _  xM | D]B } | d  } t | ƒ d k r" | d d k r" |  j | ƒ q" q" Wn  d  S(   Niÿÿÿÿi    t   #(   R.   t   lent   onecmd(   R;   R.   R   (    (    s   /usr/lib/python2.7/pdb.pyRI   €   s    			
"c         C   s@   |  j  r d S|  j | ƒ r< |  j d IJ|  j | d ƒ n  d S(   sn   This method is called when there is the remote possibility
        that we ever need to stop in this function.Ns   --Call--(   R,   t	   stop_hereR>   t   interactionR   (   R;   t   framet   argument_list(    (    s   /usr/lib/python2.7/pdb.pyt	   user_call   s
    	c         C   sl   |  j  rF |  j |  j | j j ƒ k s6 | j d k r: d Sd |  _  n  |  j | ƒ rh |  j | d ƒ n  d S(   s;   This function is called when we stop or break at this line.i    N(	   R,   R+   t   canonict   f_codet   co_filenamet   f_linenot   bp_commandsRQ   R   (   R;   RR   (    (    s   /usr/lib/python2.7/pdb.pyt	   user_line–   s    	c         C   sÐ   t  |  d t ƒ rÌ |  j |  j k rÌ |  j } d |  _ |  j } |  j | d ƒ x" |  j | D] } |  j | ƒ q] W| |  _ |  j | s¤ |  j	 |  j
 |  j ƒ n  |  j | r¾ |  j ƒ  n  |  j ƒ  d Sd S(   s¾   Call every command that was set for the current active breakpoint
        (if there is one).

        Returns True if the normal interaction function must be called,
        False otherwise.t	   currentbpi    Ni   (   t   getattrR8   R[   R5   t   lastcmdRL   R   RO   R7   t   print_stack_entryRC   RD   R6   t   cmdloopRB   (   R;   RR   R[   t   lastcmd_backR   (    (    s   /usr/lib/python2.7/pdb.pyRY       s     				
c         C   s;   |  j  r d S| | j d <|  j d IJ|  j | d ƒ d S(   s7   This function is called when a return trap is set here.Nt
   __return__s
   --Return--(   R,   RG   R>   RQ   R   (   R;   RR   t   return_value(    (    s   /usr/lib/python2.7/pdb.pyt   user_return¸   s
    	c         C   sŠ   |  j  r d S| \ } } } | | f | j d <t | ƒ t d ƒ k rP | } n	 | j } |  j | d It | ƒ IJ|  j | | ƒ d S(   so   This function is called if an exception occurs,
        but only if we are to stop at or just below this level.Nt   __exception__R   t   :(   R,   RG   t   typeR   R>   t	   _safereprRQ   (   R;   RR   t   exc_infot   exc_typet	   exc_valuet   exc_tracebackt   exc_type_name(    (    s   /usr/lib/python2.7/pdb.pyt   user_exceptionÀ   s    			c         C   s?   |  j  | | ƒ |  j |  j |  j ƒ |  j ƒ  |  j ƒ  d  S(   N(   RL   R^   RC   RD   R_   RB   (   R;   RR   t	   traceback(    (    s   /usr/lib/python2.7/pdb.pyRQ   Ï   s    
c         C   s   | d k	 r t | ƒ GHn  d S(   s{   Custom displayhook for the exec in default(), which prevents
        assignment of the _ variable in the builtins.
        N(   R   t   repr(   R;   t   obj(    (    s   /usr/lib/python2.7/pdb.pyt   displayhookÕ   s    c         B   s#  | d  d k r | d } n  |  j  } |  j j } y† e | d d d ƒ } e j } e j } e j } z2 |  j e _ |  j e _ |  j e _ | | | UWd  | e _ | e _ | e _ XWnd e j ƒ  d  \ } }	 e	 | ƒ e	 d ƒ k rõ | }
 n	 | j
 }
 |  j d I|
 d	 I|	 IJn Xd  S(
   Ni   t   !s   
s   <stdin>t   singlei   R   s   ***Re   (   RH   RE   t	   f_globalsR   t   sysR>   R=   Rq   Rh   Rf   R   (   R;   R   t   localst   globalst   codet   save_stdoutt
   save_stdint   save_displayhookRK   t   vRl   (    (    s   /usr/lib/python2.7/pdb.pyt   defaultÝ   s.     								c         C   s  | j  ƒ  s | S| j ƒ  } x” | d |  j k r² |  j | d } d } x8 | d D], } | j d t | ƒ | ƒ } | d } qT W| j d d j | d ƒ ƒ } | j ƒ  } q W| d d k r| j d ƒ } | d k r| | d j ƒ  } |  j j	 | ƒ | |  j
 ƒ  } qn  | S(	   s*   Handle alias expansion and ';;' separator.i    i   t   %s   %*t    t   aliass   ;;i   (   t   stript   splitR*   t   replacet   strR2   t   findt   lstript   cmdqueueR4   t   rstrip(   R;   R   t   argst   iit   tmpArgt   markert   next(    (    s   /usr/lib/python2.7/pdb.pyt   precmdö   s&    	c         C   s-   |  j  s t j j |  | ƒ S|  j | ƒ Sd S(   sÒ   Interpret the argument as though it had been typed in response
        to the prompt.

        Checks whether this line is typed at the normal prompt or in
        a breakpoint command list definition.
        N(   R9   R&   R'   RO   t   handle_command_def(   R;   R   (    (    s   /usr/lib/python2.7/pdb.pyRO     s    	c         C   sý   |  j  | ƒ \ } } } | s" d S| d k rB t |  j |  j <d S| d k r[ g  |  _ d S|  j |  j } | r‰ | j | d | ƒ n | j | ƒ y t |  d | ƒ } Wn t k
 rÉ |  j	 } n X| j
 |  j k rù t |  j |  j <g  |  _ d Sd S(   s8   Handles one command line during command list definition.Nt   silentt   endi   R   t   do_(   t	   parselinet   TrueR7   R:   R‡   R5   R4   R\   t   AttributeErrorR}   t	   func_namet   commands_resumingR8   R6   (   R;   R   R&   t   argt   cmdlistt   func(    (    s   /usr/lib/python2.7/pdb.pyR     s,    		c         C   sº   | s t  t j j ƒ d } n( y t | ƒ } Wn |  j d IJd SX| |  _ g  |  j | <t |  j	 | <t
 |  j | <|  j } d |  _ t |  _ z |  j ƒ  Wd t
 |  _ | |  _ Xd S(   s¥   Defines a list of commands associated to a breakpoint.

        Those commands will be executed whenever the breakpoint causes
        the program to stop execution.i   s/   Usage : commands [bnum]
        ...
        endNs   (com) (   RN   R#   t
   Breakpointt
   bpbynumbert   intR>   R:   R5   R”   R6   R8   R7   R)   R9   R_   (   R;   R˜   t   bnumt   prompt_back(    (    s   /usr/lib/python2.7/pdb.pyt   do_commands=  s$    					i    c         C   s   | sS |  j  rO |  j d IJx0 t j j D] } | r) | j |  j ƒ q) q) Wn  d  Sd  } d  } d  } | j d ƒ } | d k r§ | | d j ƒ  } | |  j	 ƒ  } n  | j
 d ƒ } d  }	 | d k rn| |  j	 ƒ  } |  j | ƒ }
 |
 s|  j d It | ƒ I|  j d IJd  S|
 } | | d j ƒ  } y t | ƒ } Wq|t k
 rj} |  j d I| IJd  SXny t | ƒ } Wnû t k
 r{y t | |  j j |  j ƒ } Wn | } n XyC t | d	 ƒ rÛ| j } n  | j } | j }	 | j } | j } Wq||  j | ƒ \ } } } | sb|  j d
 I|  j t | ƒ I|  j d IJ|  j d IJd  S| }	 t | ƒ } q|Xn X| s‘|  j ƒ  } n  |  j | | ƒ } | r|  j | | | | |	 ƒ } | rà|  j d I| IJq|  j | | ƒ d } |  j d | j | j | j  f IJn  d  S(   Ns!   Num Type         Disp Enb   Wheret   ,i    i   Re   s   *** s   not found from sys.paths   *** Bad lineno:t   im_funcs   *** The specified objects   is not a functions    or was not found along sys.path.s   ***iÿÿÿÿs   Breakpoint %d at %s:%d(!   t   breaksR>   R#   R›   Rœ   t   bpprintR   R…   R†   Rˆ   t   rfindt   lookupmoduleRo   R   t
   ValueErrort   evalRE   Rt   RH   t   hasattrR¢   t	   func_codet   co_namet   co_firstlinenoRW   t   lineinfot   defaultFilet	   checklinet	   set_breakt
   get_breakst   numbert   fileR   (   R;   R˜   t	   temporaryt   bpR   R   t   condt   commat   colonR   RJ   t   msgRš   Rx   t   okt   lnR   t   err(    (    s   /usr/lib/python2.7/pdb.pyt   do_breakX  s†    		
			 c         C   s4   |  j  j j } | d k r0 |  j r0 |  j } n  | S(   s   Produce a reasonable default.s   <string>(   RE   RV   RW   R+   (   R;   R   (    (    s   /usr/lib/python2.7/pdb.pyR®   «  s    c         C   s   |  j  | d ƒ d  S(   Ni   (   R½   (   R;   R˜   (    (    s   /usr/lib/python2.7/pdb.pyt	   do_tbreak´  s    c   
      C   s"  d } | j d ƒ } t | ƒ d k r: | d j ƒ  } n) t | ƒ d k r_ | d j ƒ  } n | S| d k rs | S| j d ƒ } | d d k r² | d =t | ƒ d k r² | Sn  |  j ƒ  } t | ƒ d k rÝ | d } n, |  j | d ƒ } | rÿ | } n  | d } t | | ƒ }	 |	 p!| S(	   Nt   'i   i    i   R   t   .R;   (   NNN(   R   R‚   RN   R   R®   R¦   R   (
   R;   t
   identifiert   failedt   idstringt   idt   partst   fnamet   itemRJ   R   (    (    s   /usr/lib/python2.7/pdb.pyR­   ·  s.     	
c         C   s¥   t  |  d ƒ r |  j j n d	 } t j | | | ƒ } | sM |  j d IJd S| j ƒ  } | s | d d k s | d  d k s | d  d k r¡ |  j d IJd S| S(
   sÈ   Check whether specified line seems to be executable.

        Return `lineno` if it is, 0 if not (e.g. a docstring, comment, blank
        line or EOF). Warning: testing is not comprehensive.
        RE   s   End of filei    RM   i   s   """s   '''s   *** Blank or commentN(   R©   RE   Rt   R   t	   linecachet   getlineR>   R   (   R;   R   R   t   globsR   (    (    s   /usr/lib/python2.7/pdb.pyR¯   Ø  s    ! c         C   s½   | j  ƒ  } xª | D]¢ } y t | ƒ } Wn% t k
 rP |  j d | IJq n Xd | k ot t t j j ƒ k  n s’ |  j d I| IJq n  t j j | } | r | j ƒ  q q Wd  S(   Ns#   Breakpoint index %r is not a numberi    s   No breakpoint numbered(	   R‚   R   R§   R>   RN   R#   R›   Rœ   t   enable(   R;   R˜   R‰   t   iRµ   (    (    s   /usr/lib/python2.7/pdb.pyt	   do_enableí  s    (c         C   s½   | j  ƒ  } xª | D]¢ } y t | ƒ } Wn% t k
 rP |  j d | IJq n Xd | k ot t t j j ƒ k  n s’ |  j d I| IJq n  t j j | } | r | j ƒ  q q Wd  S(   Ns#   Breakpoint index %r is not a numberi    s   No breakpoint numbered(	   R‚   R   R§   R>   RN   R#   R›   Rœ   t   disable(   R;   R˜   R‰   RÌ   Rµ   (    (    s   /usr/lib/python2.7/pdb.pyt
   do_disableþ  s    (c         C   sñ   | j  d d ƒ } y t | d j ƒ  ƒ } Wn' t k
 rU |  j d | d IJd  SXy | d } Wn d  } n Xy t j j | } Wn' t	 k
 r± |  j d | d IJd  SX| rí | | _
 | sí |  j d I| I|  j d IJqí n  d  S(   NR   i   i    s#   Breakpoint index %r is not a numbers    Breakpoint index %r is not validR›   s   is now unconditional.(   R‚   R   R   R§   R>   R   R#   R›   Rœ   t
   IndexErrorR¶   (   R;   R˜   R‰   t   bpnumR¶   Rµ   (    (    s   /usr/lib/python2.7/pdb.pyt   do_condition  s*    
	c         C   s?  | j  ƒ  } y t | d j ƒ  ƒ } Wn' t k
 rO |  j d | d IJd SXy t | d j ƒ  ƒ } Wn d } n Xy t j j | } Wn' t k
 r· |  j d | d IJd SX| r;| | _	 | d k rd } | d k rö | d | } n
 | d } |  j | d	 | IJq;|  j d
 I|  j | Id IJn  d S(   s*   arg is bp number followed by ignore count.i    s#   Breakpoint index %r is not a numberNi   s    Breakpoint index %r is not valids   Will ignore next s   %d crossingss
   1 crossings    of breakpoint %d.s   Will stop next time breakpoints   is reached.(
   R‚   R   R   R§   R>   R#   R›   Rœ   RÐ   t   ignore(   R;   R˜   R‰   RÑ   t   countRµ   t   reply(    (    s   /usr/lib/python2.7/pdb.pyt	   do_ignore(  s4    
	
c         C   sÊ  | s_ y t  d ƒ } Wn t k
 r/ d } n X| j ƒ  j ƒ  } | d k r[ |  j ƒ  n  d Sd | k rò | j d ƒ } | |  } | | d } y t | ƒ } Wn t k
 r¿ d | } n X|  j | | ƒ } | rî |  j	 d	 I| IJn  d S| j
 ƒ  } xÅ | D]½ } y t | ƒ } Wn% t k
 rB|  j	 d
 | IJqn Xd | k oft t j j ƒ k  n s„|  j	 d I| IJqn  |  j | ƒ } | r¯|  j	 d	 I| IJq|  j	 d I| IJqWd S(   sÙ   Three possibilities, tried in this order:
        clear -> clear all breaks, ask for confirmation
        clear file:lineno -> clear all breaks at file:lineno
        clear bpno bpno ... -> clear breakpoints by numbers   Clear all breaks? t   not   yt   yesNRe   i   s   Invalid line number (%s)s   ***s#   Breakpoint index %r is not a numberi    s   No breakpoint numbereds   Deleted breakpoint(   RØ   RÙ   (   t	   raw_inputt   EOFErrorR   t   lowert   clear_all_breaksR¥   R   R§   t   clear_breakR>   R‚   RN   R#   R›   Rœ   t   clear_bpbynumber(   R;   R˜   RÕ   RÌ   R   R   R¼   t
   numberlist(    (    s   /usr/lib/python2.7/pdb.pyt   do_clearH  sF    

 (c         C   s   |  j  ƒ  d  S(   N(   t   print_stack_trace(   R;   R˜   (    (    s   /usr/lib/python2.7/pdb.pyt   do_whereu  s    c         C   sy   |  j  d k r |  j d IJnV |  j  d |  _  |  j |  j  d |  _ |  j j |  _ |  j |  j |  j  ƒ d  |  _ d  S(   Ni    s   *** Oldest framei   (	   RD   R>   RC   RE   RG   RH   R^   R   R   (   R;   R˜   (    (    s   /usr/lib/python2.7/pdb.pyt   do_upz  s    c         C   s†   |  j  d t |  j ƒ k r, |  j d IJnV |  j  d |  _  |  j |  j  d |  _ |  j j |  _ |  j |  j |  j  ƒ d  |  _	 d  S(   Ni   s   *** Newest framei    (
   RD   RN   RC   R>   RE   RG   RH   R^   R   R   (   R;   R˜   (    (    s   /usr/lib/python2.7/pdb.pyt   do_down…  s    c         C   s   |  j  |  j ƒ d S(   Ni   (   t	   set_untilRE   (   R;   R˜   (    (    s   /usr/lib/python2.7/pdb.pyt   do_until  s    c         C   s   |  j  ƒ  d S(   Ni   (   t   set_step(   R;   R˜   (    (    s   /usr/lib/python2.7/pdb.pyt   do_step•  s    
c         C   s   |  j  |  j ƒ d S(   Ni   (   t   set_nextRE   (   R;   R˜   (    (    s   /usr/lib/python2.7/pdb.pyt   do_nextš  s    c         C   sN   | rD d d l  } t j d d !} | j | ƒ t _ | t j d *n  t ‚ d S(   s‡   Restart program by raising an exception to be caught in the main
        debugger loop.  If arguments were given, set them in sys.argv.iÿÿÿÿNi    i   (   t   shlexRu   t   argvR‚   R   (   R;   R˜   Rì   t   argv0(    (    s   /usr/lib/python2.7/pdb.pyt   do_runŸ  s    c         C   s   |  j  |  j ƒ d S(   Ni   (   t
   set_returnRE   (   R;   R˜   (    (    s   /usr/lib/python2.7/pdb.pyt	   do_return«  s    c         C   s   |  j  ƒ  d S(   Ni   (   t   set_continue(   R;   R˜   (    (    s   /usr/lib/python2.7/pdb.pyt   do_continue°  s    
c         C   sÖ   |  j  d t |  j ƒ k r- |  j d IJd  Sy t | ƒ } Wn t k
 r] |  j d IJnu XyK | |  j _ |  j |  j  d | f |  j |  j  <|  j |  j |  j  ƒ Wn& t k
 rÑ } |  j d I| IJn Xd  S(   Ni   s-   *** You can only jump within the bottom frames.   *** The 'jump' command requires a line number.i    s   *** Jump failed:(	   RD   RN   RC   R>   R   R§   RE   RX   R^   (   R;   R˜   t   e(    (    s   /usr/lib/python2.7/pdb.pyt   do_jumpµ  s    $c         C   s©   t  j d  ƒ |  j j } |  j } t |  j |  j |  j	 ƒ } d |  j
 j ƒ  | _
 |  j	 d IJt  j | j | | | f ƒ |  j	 d IJt  j |  j ƒ | j |  _ d  S(   Ns   (%s) s   ENTERING RECURSIVE DEBUGGERs   LEAVING RECURSIVE DEBUGGER(   Ru   t   settraceR   RE   Rt   RH   R   R<   R=   R>   R)   R   t   call_tracingR   t   trace_dispatchR]   (   R;   R˜   Rw   Rv   t   p(    (    s   /usr/lib/python2.7/pdb.pyt   do_debugÈ  s    	c         C   s   d |  _  |  j ƒ  d S(   Ni   (   t   _user_requested_quitt   set_quit(   R;   R˜   (    (    s   /usr/lib/python2.7/pdb.pyt   do_quitÔ  s    	
c         C   s   |  j  Jd |  _ |  j ƒ  d S(   Ni   (   R>   Rû   Rü   (   R;   R˜   (    (    s   /usr/lib/python2.7/pdb.pyt   do_EOFÜ  s    	
c         C   sº   |  j  j } |  j } | j } | j d @r8 | d } n  | j d @rR | d } n  xa t | ƒ D]S } | j | } |  j | Id I| | k r¥ |  j | | IJq_ |  j d IJq_ Wd  S(   Ni   i   i   t   =s   *** undefined ***(   RE   RV   RH   t   co_argcountt   co_flagst   ranget   co_varnamesR>   (   R;   R˜   t   cot   dictt   nRÌ   t   name(    (    s   /usr/lib/python2.7/pdb.pyt   do_argsâ  s    		   c         C   s7   d |  j  k r& |  j |  j  d IJn |  j d IJd  S(   NRa   s   *** Not yet returned!(   RH   R>   (   R;   R˜   (    (    s   /usr/lib/python2.7/pdb.pyt	   do_retvalï  s    c         C   sˆ   y t  | |  j j |  j ƒ SWnd t j ƒ  d  \ } } t | t ƒ rQ | } n	 | j } |  j	 d I| d It
 | ƒ IJ‚  n Xd  S(   Ni   s   ***Re   (   R¨   RE   Rt   RH   Ru   Rh   t
   isinstanceR„   R   R>   Ro   (   R;   R˜   RK   R|   Rl   (    (    s   /usr/lib/python2.7/pdb.pyt   _getvalö  s    		#c         C   s.   y  |  j  t |  j | ƒ ƒ IJWn n Xd  S(   N(   R>   Ro   R  (   R;   R˜   (    (    s   /usr/lib/python2.7/pdb.pyt   do_p  s     c         C   s.   y  t  j  |  j | ƒ |  j ƒ Wn n Xd  S(   N(   t   pprintR  R>   (   R;   R˜   (    (    s   /usr/lib/python2.7/pdb.pyt   do_pp  s     c   
      C   s2  d |  _  d  } | rÃ y‡ t | i  i  ƒ } t | ƒ t d ƒ k r‚ | \ } } t | ƒ } t | ƒ } | | k  r› | | } q› n t d t | ƒ d ƒ } Wqû |  j d It | ƒ IJd  SXn8 |  j d  k rî t d |  j	 j
 d ƒ } n |  j d } | d  k r| d } n  |  j	 j j } |  j | ƒ } yè xá t | | d ƒ D]Ì } t j | | |  j	 j ƒ } | s|  j d IJPqIt | ƒ j d ƒ }	 t |	 ƒ d k  rµ|	 d	 }	 n  | | k rÎ|	 d
 }	 n
 |	 d	 }	 | |  j	 j
 k r÷|	 d }	 n  |  j |	 d | I| |  _ qIWWn t k
 r-n Xd  S(   Nt   listi   i   s   *** Error in argument:i
   s   [EOF]i   i   R   t   Bs   ->s   	(    (   R]   R   R¨   Rf   R   t   maxR>   Ro   R   RE   RX   RV   RW   t   get_file_breaksR  RÈ   RÉ   Rt   t   rjustRN   t   KeyboardInterrupt(
   R;   R˜   t   lastt   xt   firstR   t	   breaklistR   R   t   s(    (    s   /usr/lib/python2.7/pdb.pyt   do_list  sR    	  
c         C   s  y t  | |  j j |  j ƒ } Wnk t j ƒ  d  \ } } t | ƒ t d ƒ k r\ | } n	 | j } |  j d I| d It	 | ƒ IJd  SXd  } y | j } Wn n X| rÊ |  j d I| j IJd  Sy | j j } Wn n X| r|  j d I| j IJd  S|  j t | ƒ IJd  S(   Ni   R   s   ***Re   t   Functiont   Method(   R¨   RE   Rt   RH   Ru   Rh   Rf   R   R>   Ro   R   Rª   R«   R¢   (   R;   R˜   t   valueRK   R|   Rl   Rx   (    (    s   /usr/lib/python2.7/pdb.pyt	   do_whatis<  s4    		#    c         C   sÚ   | j  ƒ  } t | ƒ d k rj |  j j ƒ  } | j ƒ  x, | D]$ } |  j d | |  j | f IJq> Wd  S| d |  j k r¸ t | ƒ d k r¸ |  j d | d |  j | d f IJn d j | d ƒ |  j | d <d  S(   Ni    s   %s = %si   R   (   R‚   RN   R*   t   keyst   sortR>   R2   (   R;   R˜   R‰   R  R€   (    (    s   /usr/lib/python2.7/pdb.pyt   do_aliasW  s    
"%)c         C   sJ   | j  ƒ  } t | ƒ d k r" d  S| d |  j k rF |  j | d =n  d  S(   Ni    (   R‚   RN   R*   (   R;   R˜   R‰   (    (    s   /usr/lib/python2.7/pdb.pyt
   do_unaliasd  s
     Ró   Ré   Rë   Rñ   Rý   Rõ   c         C   s=   y% x |  j  D] } |  j | ƒ q WWn t k
 r8 n Xd  S(   N(   RC   R^   R  (   R;   t   frame_lineno(    (    s   /usr/lib/python2.7/pdb.pyRâ   v  s
    c         C   sU   | \ } } | |  j  k r+ |  j d In |  j d I|  j |  j | | ƒ IJd  S(   Nt   >R   (   RE   R>   t   format_stack_entry(   R;   R#  t   prompt_prefixRR   R   (    (    s   /usr/lib/python2.7/pdb.pyR^   }  s    c         C   s   |  j  ƒ  d  S(   N(   t   help_h(   R;   (    (    s   /usr/lib/python2.7/pdb.pyt	   help_help‰  s    c         C   s   |  j  d IJd  S(   Nsà   h(elp)
Without argument, print the list of available commands.
With a command name as argument, print help about that command
"help pdb" pipes the full documentation file to the $PAGER
"help exec" gives help on the ! command(   R>   (   R;   (    (    s   /usr/lib/python2.7/pdb.pyR'  Œ  s    c         C   s   |  j  ƒ  d  S(   N(   t   help_w(   R;   (    (    s   /usr/lib/python2.7/pdb.pyt
   help_where“  s    c         C   s   |  j  d IJd  S(   NsÁ   w(here)
Print a stack trace, with the most recent frame at the bottom.
An arrow indicates the "current frame", which determines the
context of most commands.  'bt' is an alias for this command.(   R>   (   R;   (    (    s   /usr/lib/python2.7/pdb.pyR)  –  s    c         C   s   |  j  ƒ  d  S(   N(   t   help_d(   R;   (    (    s   /usr/lib/python2.7/pdb.pyt	   help_downž  s    c         C   s   |  j  d IJd  S(   NsS   d(own)
Move the current frame one level down in the stack trace
(to a newer frame).(   R>   (   R;   (    (    s   /usr/lib/python2.7/pdb.pyR+  ¡  s    c         C   s   |  j  ƒ  d  S(   N(   t   help_u(   R;   (    (    s   /usr/lib/python2.7/pdb.pyt   help_up¦  s    c         C   s   |  j  d IJd  S(   NsP   u(p)
Move the current frame one level up in the stack trace
(to an older frame).(   R>   (   R;   (    (    s   /usr/lib/python2.7/pdb.pyR-  ©  s    c         C   s   |  j  ƒ  d  S(   N(   t   help_b(   R;   (    (    s   /usr/lib/python2.7/pdb.pyt
   help_break®  s    c         C   s   |  j  d IJd  S(   NsF  b(reak) ([file:]lineno | function) [, condition]
With a line number argument, set a break there in the current
file.  With a function name, set a break at first executable line
of that function.  Without argument, list all breaks.  If a second
argument is present, it is a string specifying an expression
which must evaluate to true before the breakpoint is honored.

The line number may be prefixed with a filename and a colon,
to specify a breakpoint in another file (probably one that
hasn't been loaded yet).  The file is searched for on sys.path;
the .py suffix may be omitted.(   R>   (   R;   (    (    s   /usr/lib/python2.7/pdb.pyR/  ±  s    
c         C   s   |  j  ƒ  d  S(   N(   t   help_cl(   R;   (    (    s   /usr/lib/python2.7/pdb.pyt
   help_clear¾  s    c         C   s   |  j  d IJ|  j  d IJd  S(   Ns   cl(ear) filename:linenosÈ  cl(ear) [bpnumber [bpnumber...]]
With a space separated list of breakpoint numbers, clear
those breakpoints.  Without argument, clear all breaks (but
first ask confirmation).  With a filename:lineno argument,
clear all breaks at that line in that file.

Note that the argument is different from previous versions of
the debugger (in python distributions 1.5.1 and before) where
a linenumber was used instead of either filename:lineno or
breakpoint numbers.(   R>   (   R;   (    (    s   /usr/lib/python2.7/pdb.pyR1  Á  s    	c         C   s   |  j  d IJd  S(   NsJ   tbreak  same arguments as break, but breakpoint
is removed when first hit.(   R>   (   R;   (    (    s   /usr/lib/python2.7/pdb.pyt   help_tbreakÎ  s    c         C   s   |  j  d IJd  S(   Nse   enable bpnumber [bpnumber ...]
Enables the breakpoints given as a space separated list of
bp numbers.(   R>   (   R;   (    (    s   /usr/lib/python2.7/pdb.pyt   help_enableÒ  s    c         C   s   |  j  d IJd  S(   Nsg   disable bpnumber [bpnumber ...]
Disables the breakpoints given as a space separated list of
bp numbers.(   R>   (   R;   (    (    s   /usr/lib/python2.7/pdb.pyt   help_disable×  s    c         C   s   |  j  d IJd  S(   Ns(  ignore bpnumber count
Sets the ignore count for the given breakpoint number.  A breakpoint
becomes active when the ignore count is zero.  When non-zero, the
count is decremented each time the breakpoint is reached and the
breakpoint is not disabled and any associated condition evaluates
to true.(   R>   (   R;   (    (    s   /usr/lib/python2.7/pdb.pyt   help_ignoreÜ  s    c         C   s   |  j  d IJd  S(   Nsü   condition bpnumber str_condition
str_condition is a string specifying an expression which
must evaluate to true before the breakpoint is honored.
If str_condition is absent, any existing condition is removed;
i.e., the breakpoint is made unconditional.(   R>   (   R;   (    (    s   /usr/lib/python2.7/pdb.pyt   help_conditionä  s    c         C   s   |  j  ƒ  d  S(   N(   t   help_s(   R;   (    (    s   /usr/lib/python2.7/pdb.pyt	   help_stepë  s    c         C   s   |  j  d IJd  S(   Ns†   s(tep)
Execute the current line, stop at the first possible occasion
(either in a function that is called or in the current function).(   R>   (   R;   (    (    s   /usr/lib/python2.7/pdb.pyR8  î  s    c         C   s   |  j  ƒ  d  S(   N(   t   help_unt(   R;   (    (    s   /usr/lib/python2.7/pdb.pyt
   help_untiló  s    c         C   s	   d GHd  S(   Ns‚   unt(il)
Continue execution until the line with a number greater than the current
one is reached or until the current frame returns(    (   R;   (    (    s   /usr/lib/python2.7/pdb.pyR:  ö  s    c         C   s   |  j  ƒ  d  S(   N(   t   help_n(   R;   (    (    s   /usr/lib/python2.7/pdb.pyt	   help_nextû  s    c         C   s   |  j  d IJd  S(   Ns_   n(ext)
Continue execution until the next line in the current function
is reached or it returns.(   R>   (   R;   (    (    s   /usr/lib/python2.7/pdb.pyR<  þ  s    c         C   s   |  j  ƒ  d  S(   N(   t   help_r(   R;   (    (    s   /usr/lib/python2.7/pdb.pyt   help_return  s    c         C   s   |  j  d IJd  S(   Ns?   r(eturn)
Continue execution until the current function returns.(   R>   (   R;   (    (    s   /usr/lib/python2.7/pdb.pyR>    s    c         C   s   |  j  ƒ  d  S(   N(   t   help_c(   R;   (    (    s   /usr/lib/python2.7/pdb.pyt   help_continue
  s    c         C   s   |  j  ƒ  d  S(   N(   R@  (   R;   (    (    s   /usr/lib/python2.7/pdb.pyt	   help_cont  s    c         C   s   |  j  d IJd  S(   NsL   c(ont(inue))
Continue execution, only stop when a breakpoint is encountered.(   R>   (   R;   (    (    s   /usr/lib/python2.7/pdb.pyR@    s    c         C   s   |  j  ƒ  d  S(   N(   t   help_j(   R;   (    (    s   /usr/lib/python2.7/pdb.pyt	   help_jump  s    c         C   s   |  j  d IJd  S(   Ns6   j(ump) lineno
Set the next line that will be executed.(   R>   (   R;   (    (    s   /usr/lib/python2.7/pdb.pyRC    s    c         C   s   |  j  d IJd  S(   Ns¥   debug code
Enter a recursive debugger that steps through the code argument
(which is an arbitrary expression or statement to be executed
in the current environment).(   R>   (   R;   (    (    s   /usr/lib/python2.7/pdb.pyt
   help_debug  s    c         C   s   |  j  ƒ  d  S(   N(   t   help_l(   R;   (    (    s   /usr/lib/python2.7/pdb.pyt	   help_list!  s    c         C   s   |  j  d IJd  S(   Ns8  l(ist) [first [,last]]
List source code for the current file.
Without arguments, list 11 lines around the current line
or continue the previous listing.
With one argument, list 11 lines starting at that line.
With two arguments, list the given range;
if the second argument is less than the first, it is a count.(   R>   (   R;   (    (    s   /usr/lib/python2.7/pdb.pyRF  $  s    c         C   s   |  j  ƒ  d  S(   N(   t   help_a(   R;   (    (    s   /usr/lib/python2.7/pdb.pyt	   help_args-  s    c         C   s   |  j  d IJd  S(   Ns3   a(rgs)
Print the arguments of the current function.(   R>   (   R;   (    (    s   /usr/lib/python2.7/pdb.pyRH  0  s    c         C   s   |  j  d IJd  S(   Ns/   p expression
Print the value of the expression.(   R>   (   R;   (    (    s   /usr/lib/python2.7/pdb.pyt   help_p4  s    c         C   s   |  j  d IJd  S(   Ns7   pp expression
Pretty-print the value of the expression.(   R>   (   R;   (    (    s   /usr/lib/python2.7/pdb.pyt   help_pp8  s    c         C   s   |  j  d IJd  S(   Ns[  (!) statement
Execute the (one-line) statement in the context of
the current stack frame.
The exclamation point can be omitted unless the first word
of the statement resembles a debugger command.
To assign to a global variable you must always prefix the
command with a 'global' command, e.g.:
(Pdb) global list_options; list_options = ['-l']
(Pdb)(   R>   (   R;   (    (    s   /usr/lib/python2.7/pdb.pyt	   help_exec<  s    c         C   s	   d GHd  S(   Nsó   run [args...]
Restart the debugged python program. If a string is supplied, it is
split with "shlex" and the result is used as the new sys.argv.
History, breakpoints, actions and debugger options are preserved.
"restart" is an alias for "run".(    (   R;   (    (    s   /usr/lib/python2.7/pdb.pyt   help_runG  s    c         C   s   |  j  ƒ  d  S(   N(   t   help_q(   R;   (    (    s   /usr/lib/python2.7/pdb.pyt	   help_quitP  s    c         C   s   |  j  d IJd  S(   NsO   q(uit) or exit - Quit from the debugger.
The program being executed is aborted.(   R>   (   R;   (    (    s   /usr/lib/python2.7/pdb.pyRN  S  s    c         C   s   |  j  d IJd  S(   Ns+   whatis arg
Prints the type of the argument.(   R>   (   R;   (    (    s   /usr/lib/python2.7/pdb.pyt   help_whatisY  s    c         C   s   |  j  d IJd  S(   Ns,   EOF
Handles the receipt of EOF as a command.(   R>   (   R;   (    (    s   /usr/lib/python2.7/pdb.pyt   help_EOF]  s    c         C   s   |  j  d IJd  S(   Ns²  alias [name [command [parameter parameter ...]]]
Creates an alias called 'name' the executes 'command'.  The command
must *not* be enclosed in quotes.  Replaceable parameters are
indicated by %1, %2, and so on, while %* is replaced by all the
parameters.  If no command is given, the current alias for name
is shown. If no name is given, all aliases are listed.

Aliases may be nested and can contain anything that can be
legally typed at the pdb prompt.  Note!  You *can* override
internal pdb commands with aliases!  Those internal commands
are then hidden until the alias is removed.  Aliasing is recursively
applied to the first word of the command line; all other words
in the line are left alone.

Some useful aliases (especially when placed in the .pdbrc file) are:

#Print instance variables (usage "pi classInst")
alias pi for k in %1.__dict__.keys(): print "%1.",k,"=",%1.__dict__[k]

#Print instance variables in self
alias ps pi self
(   R>   (   R;   (    (    s   /usr/lib/python2.7/pdb.pyt
   help_aliasa  s    c         C   s   |  j  d IJd  S(   Ns)   unalias name
Deletes the specified alias.(   R>   (   R;   (    (    s   /usr/lib/python2.7/pdb.pyt   help_unaliasy  s    c         C   s   |  j  d IJd  S(   Ns  commands [bpnumber]
(com) ...
(com) end
(Pdb)

Specify a list of commands for breakpoint number bpnumber.  The
commands themselves appear on the following lines.  Type a line
containing just 'end' to terminate the commands.

To remove all commands from a breakpoint, type commands and
follow it immediately with  end; that is, give no commands.

With no bpnumber argument, commands refers to the last
breakpoint set.

You can use breakpoint commands to start your program up again.
Simply use the continue command, or step, or any other
command that resumes execution.

Specifying any command resuming execution (currently continue,
step, next, return, jump, quit and their abbreviations) terminates
the command list (as if that command was immediately followed by end).
This is because any time you resume execution
(even with a simple next or step), you may encounter
another breakpoint--which could have its own command list, leading to
ambiguities about which list to execute.

   If you use the 'silent' command in the command list, the
usual message about stopping at a breakpoint is not printed.  This may
be desirable for breakpoints that are to print a specific message and
then continue.  If none of the other commands print anything, you
see no sign that the breakpoint was reached.
(   R>   (   R;   (    (    s   /usr/lib/python2.7/pdb.pyt   help_commands}  s     c         C   s   t  ƒ  d  S(   N(   R   (   R;   (    (    s   /usr/lib/python2.7/pdb.pyt   help_pdb   s    c         C   s$  t  j j | ƒ r( t  j j | ƒ r( | St  j j t j d | ƒ } t  j j | ƒ rr |  j | ƒ |  j k rr | St  j j | ƒ \ } } | d k r£ | d } n  t  j j | ƒ r¹ | Sxd t j D]Y } x% t  j j	 | ƒ rð t  j
 | ƒ } qÌ Wt  j j | | ƒ } t  j j | ƒ rÃ | SqÃ Wd S(   s·   Helper function for break/clear parsing -- may be overridden.

        lookupmodule() translates (possibly incomplete) file or module name
        into an absolute file name.
        i    R   s   .pyN(   R/   R1   t   isabst   existsR2   Ru   RU   R+   t   splitextt   islinkt   readlinkR   (   R;   R   RJ   t   roott   extt   dirnamet   fullname(    (    s   /usr/lib/python2.7/pdb.pyR¦   £  s"    $*c         C   s}   d d  l  } | j j ƒ  | j j i d d 6| d 6t d 6ƒ d |  _ |  j | ƒ |  _ d |  _ d | } |  j	 | ƒ d  S(	   Niÿÿÿÿt   __main__R   t   __file__t   __builtins__i   i    s   execfile(%r)(
   R_  t   __dict__t   cleart   updateRa  R,   RU   R+   Rû   R   (   R;   R   R_  t	   statement(    (    s   /usr/lib/python2.7/pdb.pyt
   _runscript»  s    		
N(ƒ   R   R   R   R%   RA   RB   RL   RI   RT   RZ   RY   Rc   Rm   RQ   Rq   R}   RŽ   RO   R   R&   R'   t   do_helpt   do_hR    R½   R®   t   do_bR¾   R­   R¯   RÍ   RÏ   RÒ   RÖ   Rá   t   do_clRã   t   do_wt   do_btRä   t   do_uRå   t   do_dRç   t   do_untRé   t   do_sRë   t   do_nRï   t
   do_restartRñ   t   do_rRó   t   do_ct   do_contRõ   t   do_jRú   Rý   t   do_qt   do_exitRþ   R  t   do_aR	  t   do_rvR  R  R  R  t   do_lR  R!  R"  R—   Râ   t   line_prefixR^   R(  R'  R*  R)  t   help_btR,  R+  R.  R-  R0  R/  R2  R1  R3  R4  R5  R6  R7  R9  R8  R;  R:  R=  R<  R?  R>  RA  RB  R@  RD  RC  RE  RG  RF  RI  RH  RJ  RK  RL  RM  t   help_restartRO  RN  t	   help_exitRP  RQ  RR  RS  RT  RU  R¦   Rf  (    (    (    s   /usr/lib/python2.7/pdb.pyR   ;   sø   .							
									 	S			!					 	+									
		
										,			
																																																#		c         C   s   t  ƒ  j |  | | ƒ d  S(   N(   R   R   (   Re  Rw   Rv   (    (    s   /usr/lib/python2.7/pdb.pyR   Õ  s    c         C   s   t  ƒ  j |  | | ƒ S(   N(   R   R   (   t
   expressionRw   Rv   (    (    s   /usr/lib/python2.7/pdb.pyR   Ø  s    c         C   s   t  |  | | ƒ d  S(   N(   R   (   Re  Rw   Rv   (    (    s   /usr/lib/python2.7/pdb.pyR	   Û  s    c          O   s   t  ƒ  j |  | Ž  S(   N(   R   R
   (   R‰   t   kwds(    (    s   /usr/lib/python2.7/pdb.pyR
   ß  s    c           C   s   t  ƒ  j t j ƒ  j ƒ d  S(   N(   R   R   Ru   t	   _getframet   f_back(    (    (    s   /usr/lib/python2.7/pdb.pyR   â  s    c         C   sa   |  d  k r: t j ƒ  d }  |  d  k r: t d ƒ ‚ q: n  t ƒ  } | j ƒ  | j d  |  ƒ d  S(   Ni   sA   A valid traceback must be passed if no exception is being handled(   R   Ru   Rh   R§   R   RA   RQ   (   RK   Rù   (    (    s   /usr/lib/python2.7/pdb.pyR   ç  s    	
c           C   s   t  t j ƒ d  S(   N(   R   Ru   t   last_traceback(    (    (    s   /usr/lib/python2.7/pdb.pyR   õ  s    s   import x; x.main()c           C   s   t  t ƒ d  S(   N(   R   t   TESTCMD(    (    (    s   /usr/lib/python2.7/pdb.pyt   testý  s    c          C   sq   xj t  j D]V }  t j j |  d ƒ } t j j | ƒ r
 t j d | ƒ } | r\ d G| GHn  Pq
 q
 Wd Gd GHd  S(   Ns   pdb.docs   ${PAGER-more} s   *** Pager exit status:s)   Sorry, can't find the help file "pdb.doc"s   along the Python search path(   Ru   R1   R/   R2   RW  t   system(   R]  R^  t   sts(    (    s   /usr/lib/python2.7/pdb.pyR     s     c          C   s  t  j d s! t  j d d k r6 d GHt  j d ƒ n  t  j d }  t j j |  ƒ sr d G|  Gd GHt  j d ƒ n  t  j d =t j j |  ƒ t  j d <t ƒ  } xø t r˜y# | j	 |  ƒ | j
 rÄ Pn  d	 GHWq¡ t k
 rd
 G|  Gd GHd d j t  j d ƒ GHq¡ t k
 r&d Gt  j ƒ  d GHq¡ t k
 rMt j ƒ  t  j d ƒ q¡ t j ƒ  d GHd GHt  j ƒ  d } | j d  | ƒ d |  d GHq¡ Xq¡ Wd  S(   Ni   s   --helps   -hs"   usage: pdb.py scriptfile [arg] ...i   s   Error:s   does not existi    s*   The program finished and will be restartedt
   Restartings   with arguments:s   	R   s0   The program exited via sys.exit(). Exit status: s2   Uncaught exception. Entering post mortem debuggings1   Running 'cont' or 'step' will restart the programs#   Post mortem debugger finished. The s    will be restarted(   s   --helps   -h(   Ru   Rí   t   exitR/   R1   RW  R]  R   R”   Rf  Rû   R   R2   t
   SystemExitRh   t   SyntaxErrorRn   t	   print_excRQ   R   (   R+   t   pdbRK   (    (    s   /usr/lib/python2.7/pdb.pyt   main  sB    !
				

R_  ($   R   Ru   RÈ   R&   R#   Ro   R    R/   R   R  Rn   t	   ExceptionR   t   _reprt	   maxstringRg   t   __all__R   R|  R$   R'   R   R   R   R   R	   R
   R   R   R   R…  R†  R   R  R   RŽ  (    (    (    s   /usr/lib/python2.7/pdb.pyt   <module>   sH   				ÿ ÿ ÿ ÿ ž							/                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               """Create portable serialized representations of Python objects.

See module cPickle for a (much) faster implementation.
See module copy_reg for a mechanism for registering custom picklers.
See module pickletools source for extensive comments.

Classes:

    Pickler
    Unpickler

Functions:

    dump(object, file)
    dumps(object) -> string
    load(file) -> object
    loads(string) -> object

Misc variables:

    __version__
    format_version
    compatible_formats

"""

__version__ = "$Revision: 72223 $"       # Code version

from types import *
from copy_reg import dispatch_table
from copy_reg import _extension_registry, _inverted_registry, _extension_cache
import marshal
import sys
import struct
import re

__all__ = ["PickleError", "PicklingError", "UnpicklingError", "Pickler",
           "Unpickler", "dump", "dumps", "load", "loads"]

# These are purely informational; no code uses these.
format_version = "2.0"                  # File format version we write
compatible_formats = ["1.0",            # Original protocol 0
                      "1.1",            # Protocol 0 with INST added
                      "1.2",            # Original protocol 1
                      "1.3",            # Protocol 1 with BINFLOAT added
                      "2.0",            # Protocol 2
                      ]                 # Old format versions we can read

# Keep in synch with cPickle.  This is the highest protocol number we
# know how to read.
HIGHEST_PROTOCOL = 2

# Why use struct.pack() for pickling but marshal.loads() for
# unpickling?  struct.pack() is 40% faster than marshal.dumps(), but
# marshal.loads() is twice as fast as struct.unpack()!
mloads = marshal.loads

class PickleError(Exception):
    """A common base class for the other pickling exceptions."""
    pass

class PicklingError(PickleError):
    """This exception is raised when an unpicklable object is passed to the
    dump() method.

    """
    pass

class UnpicklingError(PickleError):
    """This exception is raised when there is a problem unpickling an object,
    such as a security violation.

    Note that other exceptions may also be raised during unpickling, including
    (but not necessarily limited to) AttributeError, EOFError, ImportError,
    and IndexError.

    """
    pass

# An instance of _Stop is raised by Unpickler.load_stop() in response to
# the STOP opcode, passing the object that is the result of unpickling.
class _Stop(Exception):
    def __init__(self, value):
        self.value = value

# Jython has PyStringMap; it's a dict subclass with string keys
try:
    from org.python.core import PyStringMap
except ImportError:
    PyStringMap = None

# UnicodeType may or may not be exported (normally imported from types)
try:
    UnicodeType
except NameError:
    UnicodeType = None

# Pickle opcodes.  See pickletools.py for extensive docs.  The listing
# here is in kind-of alphabetical order of 1-character pickle code.
# pickletools groups them by purpose.

MARK            = '('   # push special markobject on stack
STOP            = '.'   # every pickle ends with STOP
POP             = '0'   # discard topmost stack item
POP_MARK        = '1'   # discard stack top through topmost markobject
DUP             = '2'   # duplicate top stack item
FLOAT           = 'F'   # push float object; decimal string argument
INT             = 'I'   # push integer or bool; decimal string argument
BININT          = 'J'   # push four-byte signed int
BININT1         = 'K'   # push 1-byte unsigned int
LONG            = 'L'   # push long; decimal string argument
BININT2         = 'M'   # push 2-byte unsigned int
NONE            = 'N'   # push None
PERSID          = 'P'   # push persistent object; id is taken from string arg
BINPERSID       = 'Q'   #  "       "         "  ;  "  "   "     "  stack
REDUCE          = 'R'   # apply callable to argtuple, both on stack
STRING          = 'S'   # push string; NL-terminated string argument
BINSTRING       = 'T'   # push string; counted binary string argument
SHORT_BINSTRING = 'U'   #  "     "   ;    "      "       "      " < 256 bytes
UNICODE         = 'V'   # push Unicode string; raw-unicode-escaped'd argument
BINUNICODE      = 'X'   #   "     "       "  ; counted UTF-8 string argument
APPEND          = 'a'   # append stack top to list below it
BUILD           = 'b'   # call __setstate__ or __dict__.update()
GLOBAL          = 'c'   # push self.find_class(modname, name); 2 string args
DICT            = 'd'   # build a dict from stack items
EMPTY_DICT      = '}'   # push empty dict
APPENDS         = 'e'   # extend list on stack by topmost stack slice
GET             = 'g'   # push item from memo on stack; index is string arg
BINGET          = 'h'   #   "    "    "    "   "   "  ;   "    " 1-byte arg
INST            = 'i'   # build & push class instance
LONG_BINGET     = 'j'   # push item from memo on stack; index is 4-byte arg
LIST            = 'l'   # build list from topmost stack items
EMPTY_LIST      = ']'   # push empty list
OBJ             = 'o'   # build & push class instance
PUT             = 'p'   # store stack top in memo; index is string arg
BINPUT          = 'q'   #   "     "    "   "   " ;   "    " 1-byte arg
LONG_BINPUT     = 'r'   #   "     "    "   "   " ;   "    " 4-byte arg
SETITEM         = 's'   # add key+value pair to dict
TUPLE           = 't'   # build tuple from topmost stack items
EMPTY_TUPLE     = ')'   # push empty tuple
SETITEMS        = 'u'   # modify dict by adding topmost key+value pairs
BINFLOAT        = 'G'   # push float; arg is 8-byte float encoding

TRUE            = 'I01\n'  # not an opcode; see INT docs in pickletools.py
FALSE           = 'I00\n'  # not an opcode; see INT docs in pickletools.py

# Protocol 2

PROTO           = '\x80'  # identify pickle protocol
NEWOBJ          = '\x81'  # build object by applying cls.__new__ to argtuple
EXT1            = '\x82'  # push object from extension registry; 1-byte index
EXT2            = '\x83'  # ditto, but 2-byte index
EXT4            = '\x84'  # ditto, but 4-byte index
TUPLE1          = '\x85'  # build 1-tuple from stack top
TUPLE2          = '\x86'  # build 2-tuple from two topmost stack items
TUPLE3          = '\x87'  # build 3-tuple from three topmost stack items
NEWTRUE         = '\x88'  # push True
NEWFALSE        = '\x89'  # push False
LONG1           = '\x8a'  # push long from < 256 bytes
LONG4           = '\x8b'  # push really big long

_tuplesize2code = [EMPTY_TUPLE, TUPLE1, TUPLE2, TUPLE3]


__all__.extend([x for x in dir() if re.match("[A-Z][A-Z0-9_]+$",x)])
del x


# Pickling machinery

class Pickler:

    def __init__(self, file, protocol=None):
        """This takes a file-like object for writing a pickle data stream.

        The optional protocol argument tells the pickler to use the
        given protocol; supported protocols are 0, 1, 2.  The default
        protocol is 0, to be backwards compatible.  (Protocol 0 is the
        only protocol that can be written to a file opened in text
        mode and read back successfully.  When using a protocol higher
        than 0, make sure the file is opened in binary mode, both when
        pickling and unpickling.)

        Protocol 1 is more efficient than protocol 0; protocol 2 is
        more efficient than protocol 1.

        Specifying a negative protocol version selects the highest
        protocol version supported.  The higher the protocol used, the
        more recent the version of Python needed to read the pickle
        produced.

        The file parameter must have a write() method that accepts a single
        string argument.  It can thus be an open file object, a StringIO
        object, or any other custom object that meets this interface.

        """
        if protocol is None:
            protocol = 0
        if protocol < 0:
            protocol = HIGHEST_PROTOCOL
        elif not 0 <= protocol <= HIGHEST_PROTOCOL:
            raise ValueError("pickle protocol must be <= %d" % HIGHEST_PROTOCOL)
        self.write = file.write
        self.memo = {}
        self.proto = int(protocol)
        self.bin = protocol >= 1
        self.fast = 0

    def clear_memo(self):
        """Clears the pickler's "memo".

        The memo is the data structure that remembers which objects the
        pickler has already seen, so that shared or recursive objects are
        pickled by reference and not by value.  This method is useful when
        re-using picklers.

        """
        self.memo.clear()

    def dump(self, obj):
        """Write a pickled representation of obj to the open file."""
        if self.proto >= 2:
            self.write(PROTO + chr(self.proto))
        self.save(obj)
        self.write(STOP)

    def memoize(self, obj):
        """Store an object in the memo."""

        # The Pickler memo is a dictionary mapping object ids to 2-tuples
        # that contain the Unpickler memo key and the object being memoized.
        # The memo key is written to the pickle and will become
        # the key in the Unpickler's memo.  The object is stored in the
        # Pickler memo so that transient objects are kept alive during
        # pickling.

        # The use of the Unpickler memo length as the memo key is just a
        # convention.  The only requirement is that the memo values be unique.
        # But there appears no advantage to any other scheme, and this
        # scheme allows the Unpickler memo to be implemented as a plain (but
        # growable) array, indexed by memo key.
        if self.fast:
            return
        assert id(obj) not in self.memo
        memo_len = len(self.memo)
        self.write(self.put(memo_len))
        self.memo[id(obj)] = memo_len, obj

    # Return a PUT (BINPUT, LONG_BINPUT) opcode string, with argument i.
    def put(self, i, pack=struct.pack):
        if self.bin:
            if i < 256:
                return BINPUT + chr(i)
            else:
                return LONG_BINPUT + pack("<i", i)

        return PUT + repr(i) + '\n'

    # Return a GET (BINGET, LONG_BINGET) opcode string, with argument i.
    def get(self, i, pack=struct.pack):
        if self.bin:
            if i < 256:
                return BINGET + chr(i)
            else:
                return LONG_BINGET + pack("<i", i)

        return GET + repr(i) + '\n'

    def save(self, obj):
        # Check for persistent id (defined by a subclass)
        pid = self.persistent_id(obj)
        if pid is not None:
            self.save_pers(pid)
            return

        # Check the memo
        x = self.memo.get(id(obj))
        if x:
            self.write(self.get(x[0]))
            return

        # Check the type dispatch table
        t = type(obj)
        f = self.dispatch.get(t)
        if f:
            f(self, obj) # Call unbound method with explicit self
            return

        # Check copy_reg.dispatch_table
        reduce = dispatch_table.get(t)
        if reduce:
            rv = reduce(obj)
        else:
            # Check for a class with a custom metaclass; treat as regular class
            try:
                issc = issubclass(t, TypeType)
            except TypeError: # t is not a class (old Boost; see SF #502085)
                issc = 0
            if issc:
                self.save_global(obj)
                return

            # Check for a __reduce_ex__ method, fall back to __reduce__
            reduce = getattr(obj, "__reduce_ex__", None)
            if reduce:
                rv = reduce(self.proto)
            else:
                reduce = getattr(obj, "__reduce__", None)
                if reduce:
                    rv = reduce()
                else:
                    raise PicklingError("Can't pickle %r object: %r" %
                                        (t.__name__, obj))

        # Check for string returned by reduce(), meaning "save as global"
        if type(rv) is StringType:
            self.save_global(obj, rv)
            return

        # Assert that reduce() returned a tuple
        if type(rv) is not TupleType:
            raise PicklingError("%s must return string or tuple" % reduce)

        # Assert that it returned an appropriately sized tuple
        l = len(rv)
        if not (2 <= l <= 5):
            raise PicklingError("Tuple returned by %s must have "
                                "two to five elements" % reduce)

        # Save the reduce() output and finally memoize the object
        self.save_reduce(obj=obj, *rv)

    def persistent_id(self, obj):
        # This exists so a subclass can override it
        return None

    def save_pers(self, pid):
        # Save a persistent id reference
        if self.bin:
            self.save(pid)
            self.write(BINPERSID)
        else:
            self.write(PERSID + str(pid) + '\n')

    def save_reduce(self, func, args, state=None,
                    listitems=None, dictitems=None, obj=None):
        # This API is called by some subclasses

        # Assert that args is a tuple or None
        if not isinstance(args, TupleType):
            raise PicklingError("args from reduce() should be a tuple")

        # Assert that func is callable
        if not hasattr(func, '__call__'):
            raise PicklingError("func from reduce should be callable")

        save = self.save
        write = self.write

        # Protocol 2 special case: if func's name is __newobj__, use NEWOBJ
        if self.proto >= 2 and getattr(func, "__name__", "") == "__newobj__":
            # A __reduce__ implementation can direct protocol 2 to
            # use the more efficient NEWOBJ opcode, while still
            # allowing protocol 0 and 1 to work normally.  For this to
            # work, the function returned by __reduce__ should be
            # called __newobj__, and its first argument should be a
            # new-style class.  The implementation for __newobj__
            # should be as follows, although pickle has no way to
            # verify this:
            #
            # def __newobj__(cls, *args):
            #     return cls.__new__(cls, *args)
            #
            # Protocols 0 and 1 will pickle a reference to __newobj__,
            # while protocol 2 (and above) will pickle a reference to
            # cls, the remaining args tuple, and the NEWOBJ code,
            # which calls cls.__new__(cls, *args) at unpickling time
            # (see load_newobj below).  If __reduce__ returns a
            # three-tuple, the state from the third tuple item will be
            # pickled regardless of the protocol, calling __setstate__
            # at unpickling time (see load_build below).
            #
            # Note that no standard __newobj__ implementation exists;
            # you have to provide your own.  This is to enforce
            # compatibility with Python 2.2 (pickles written using
            # protocol 0 or 1 in Python 2.3 should be unpicklable by
            # Python 2.2).
            cls = args[0]
            if not hasattr(cls, "__new__"):
                raise PicklingError(
                    "args[0] from __newobj__ args has no __new__")
            if obj is not None and cls is not obj.__class__:
                raise PicklingError(
                    "args[0] from __newobj__ args has the wrong class")
            args = args[1:]
            save(cls)
            save(args)
            write(NEWOBJ)
        else:
            save(func)
            save(args)
            write(REDUCE)

        if obj is not None:
            # If the object is already in the memo, this means it is
            # recursive. In this case, throw away everything we put on the
            # stack, and fetch the object back from the memo.
            if id(obj) in self.memo:
                write(POP + self.get(self.memo[id(obj)][0]))
            else:
                self.memoize(obj)

        # More new special cases (that work with older protocols as
        # well): when __reduce__ returns a tuple with 4 or 5 items,
        # the 4th and 5th item should be iterators that provide list
        # items and dict items (as (key, value) tuples), or None.

        if listitems is not None:
            self._batch_appends(listitems)

        if dictitems is not None:
            self._batch_setitems(dictitems)

        if state is not None:
            save(state)
            write(BUILD)

    # Methods below this point are dispatched through the dispatch table

    dispatch = {}

    def save_none(self, obj):
        self.write(NONE)
    dispatch[NoneType] = save_none

    def save_bool(self, obj):
        if self.proto >= 2:
            self.write(obj and NEWTRUE or NEWFALSE)
        else:
            self.write(obj and TRUE or FALSE)
    dispatch[bool] = save_bool

    def save_int(self, obj, pack=struct.pack):
        if self.bin:
            # If the int is small enough to fit in a signed 4-byte 2's-comp
            # format, we can store it more efficiently than the general
            # case.
            # First one- and two-byte unsigned ints:
            if obj >= 0:
                if obj <= 0xff:
                    self.write(BININT1 + chr(obj))
                    return
                if obj <= 0xffff:
                    self.write("%c%c%c" % (BININT2, obj&0xff, obj>>8))
                    return
            # Next check for 4-byte signed ints:
            high_bits = obj >> 31  # note that Python shift sign-extends
            if high_bits == 0 or high_bits == -1:
                # All high bits are copies of bit 2**31, so the value
                # fits in a 4-byte signed int.
                self.write(BININT + pack("<i", obj))
                return
        # Text pickle, or int too big to fit in signed 4-byte format.
        self.write(INT + repr(obj) + '\n')
    dispatch[IntType] = save_int

    def save_long(self, obj, pack=struct.pack):
        if self.proto >= 2:
            bytes = encode_long(obj)
            n = len(bytes)
            if n < 256:
                self.write(LONG1 + chr(n) + bytes)
            else:
                self.write(LONG4 + pack("<i", n) + bytes)
            return
        self.write(LONG + repr(obj) + '\n')
    dispatch[LongType] = save_long

    def save_float(self, obj, pack=struct.pack):
        if self.bin:
            self.write(BINFLOAT + pack('>d', obj))
        else:
            self.write(FLOAT + repr(obj) + '\n')
    dispatch[FloatType] = save_float

    def save_string(self, obj, pack=struct.pack):
        if self.bin:
            n = len(obj)
            if n < 256:
                self.write(SHORT_BINSTRING + chr(n) + obj)
            else:
                self.write(BINSTRING + pack("<i", n) + obj)
        else:
            self.write(STRING + repr(obj) + '\n')
        self.memoize(obj)
    dispatch[StringType] = save_string

    def save_unicode(self, obj, pack=struct.pack):
        if self.bin:
            encoding = obj.encode('utf-8')
            n = len(encoding)
            self.write(BINUNICODE + pack("<i", n) + encoding)
        else:
            obj = obj.replace("\\", "\\u005c")
            obj = obj.replace("\n", "\\u000a")
            self.write(UNICODE + obj.encode('raw-unicode-escape') + '\n')
        self.memoize(obj)
    dispatch[UnicodeType] = save_unicode

    if StringType is UnicodeType:
        # This is true for Jython
        def save_string(self, obj, pack=struct.pack):
            unicode = obj.isunicode()

            if self.bin:
                if unicode:
                    obj = obj.encode("utf-8")
                l = len(obj)
                if l < 256 and not unicode:
                    self.write(SHORT_BINSTRING + chr(l) + obj)
                else:
                    s = pack("<i", l)
                    if unicode:
                        self.write(BINUNICODE + s + obj)
                    else:
                        self.write(BINSTRING + s + obj)
            else:
                if unicode:
                    obj = obj.replace("\\", "\\u005c")
                    obj = obj.replace("\n", "\\u000a")
                    obj = obj.encode('raw-unicode-escape')
                    self.write(UNICODE + obj + '\n')
                else:
                    self.write(STRING + repr(obj) + '\n')
            self.memoize(obj)
        dispatch[StringType] = save_string

    def save_tuple(self, obj):
        write = self.write
        proto = self.proto

        n = len(obj)
        if n == 0:
            if proto:
                write(EMPTY_TUPLE)
            else:
                write(MARK + TUPLE)
            return

        save = self.save
        memo = self.memo
        if n <= 3 and proto >= 2:
            for element in obj:
                save(element)
            # Subtle.  Same as in the big comment below.
            if id(obj) in memo:
                get = self.get(memo[id(obj)][0])
                write(POP * n + get)
            else:
                write(_tuplesize2code[n])
                self.memoize(obj)
            return

        # proto 0 or proto 1 and tuple isn't empty, or proto > 1 and tuple
        # has more than 3 elements.
        write(MARK)
        for element in obj:
            save(element)

        if id(obj) in memo:
            # Subtle.  d was not in memo when we entered save_tuple(), so
            # the process of saving the tuple's elements must have saved
            # the tuple itself:  the tuple is recursive.  The proper action
            # now is to throw away everything we put on the stack, and
            # simply GET the tuple (it's already constructed).  This check
            # could have been done in the "for element" loop instead, but
            # recursive tuples are a rare thing.
            get = self.get(memo[id(obj)][0])
            if proto:
                write(POP_MARK + get)
            else:   # proto 0 -- POP_MARK not available
                write(POP * (n+1) + get)
            return

        # No recursion.
        self.write(TUPLE)
        self.memoize(obj)

    dispatch[TupleType] = save_tuple

    # save_empty_tuple() isn't used by anything in Python 2.3.  However, I
    # found a Pickler subclass in Zope3 that calls it, so it's not harmless
    # to remove it.
    def save_empty_tuple(self, obj):
        self.write(EMPTY_TUPLE)

    def save_list(self, obj):
        write = self.write

        if self.bin:
            write(EMPTY_LIST)
        else:   # proto 0 -- can't use EMPTY_LIST
            write(MARK + LIST)

        self.memoize(obj)
        self._batch_appends(iter(obj))

    dispatch[ListType] = save_list

    # Keep in synch with cPickle's BATCHSIZE.  Nothing will break if it gets
    # out of synch, though.
    _BATCHSIZE = 1000

    def _batch_appends(self, items):
        # Helper to batch up APPENDS sequences
        save = self.save
        write = self.write

        if not self.bin:
            for x in items:
                save(x)
                write(APPEND)
            return

        r = xrange(self._BATCHSIZE)
        while items is not None:
            tmp = []
            for i in r:
                try:
                    x = items.next()
                    tmp.append(x)
                except StopIteration:
                    items = None
                    break
            n = len(tmp)
            if n > 1:
                write(MARK)
                for x in tmp:
                    save(x)
                write(APPENDS)
            elif n:
                save(tmp[0])
                write(APPEND)
            # else tmp is empty, and we're done

    def save_dict(self, obj):
        write = self.write

        if self.bin:
            write(EMPTY_DICT)
        else:   # proto 0 -- can't use EMPTY_DICT
            write(MARK + DICT)

        self.memoize(obj)
        self._batch_setitems(obj.iteritems())

    dispatch[DictionaryType] = save_dict
    if not PyStringMap is None:
        dispatch[PyStringMap] = save_dict

    def _batch_setitems(self, items):
        # Helper to batch up SETITEMS sequences; proto >= 1 only
        save = self.save
        write = self.write

        if not self.bin:
            for k, v in items:
                save(k)
                save(v)
                write(SETITEM)
            return

        r = xrange(self._BATCHSIZE)
        while items is not None:
            tmp = []
            for i in r:
                try:
                    tmp.append(items.next())
                except StopIteration:
                    items = None
                    break
            n = len(tmp)
            if n > 1:
                write(MARK)
                for k, v in tmp:
                    save(k)
                    save(v)
                write(SETITEMS)
            elif n:
                k, v = tmp[0]
                save(k)
                save(v)
                write(SETITEM)
            # else tmp is empty, and we're done

    def save_inst(self, obj):
        cls = obj.__class__

        memo  = self.memo
        write = self.write
        save  = self.save

        if hasattr(obj, '__getinitargs__'):
            args = obj.__getinitargs__()
            len(args) # XXX Assert it's a sequence
            _keep_alive(args, memo)
        else:
            args = ()

        write(MARK)

        if self.bin:
            save(cls)
            for arg in args:
                save(arg)
            write(OBJ)
        else:
            for arg in args:
                save(arg)
            write(INST + cls.__module__ + '\n' + cls.__name__ + '\n')

        self.memoize(obj)

        try:
            getstate = obj.__getstate__
        except AttributeError:
            stuff = obj.__dict__
        else:
            stuff = getstate()
            _keep_alive(stuff, memo)
        save(stuff)
        write(BUILD)

    dispatch[InstanceType] = save_inst

    def save_global(self, obj, name=None, pack=struct.pack):
        write = self.write
        memo = self.memo

        if name is None:
            name = obj.__name__

        module = getattr(obj, "__module__", None)
        if module is None:
            module = whichmodule(obj, name)

        try:
            __import__(module)
            mod = sys.modules[module]
            klass = getattr(mod, name)
        except (ImportError, KeyError, AttributeError):
            raise PicklingError(
                "Can't pickle %r: it's not found as %s.%s" %
                (obj, module, name))
        else:
            if klass is not obj:
                raise PicklingError(
                    "Can't pickle %r: it's not the same object as %s.%s" %
                    (obj, module, name))

        if self.proto >= 2:
            code = _extension_registry.get((module, name))
            if code:
                assert code > 0
                if code <= 0xff:
                    write(EXT1 + chr(code))
                elif code <= 0xffff:
                    write("%c%c%c" % (EXT2, code&0xff, code>>8))
                else:
                    write(EXT4 + pack("<i", code))
                return

        write(GLOBAL + module + '\n' + name + '\n')
        self.memoize(obj)

    dispatch[ClassType] = save_global
    dispatch[FunctionType] = save_global
    dispatch[BuiltinFunctionType] = save_global
    dispatch[TypeType] = save_global

# Pickling helpers

def _keep_alive(x, memo):
    """Keeps a reference to the object x in the memo.

    Because we remember objects by their id, we have
    to assure that possibly temporary objects are kept
    alive by referencing them.
    We store a reference at the id of the memo, which should
    normally not be used unless someone tries to deepcopy
    the memo itself...
    """
    try:
        memo[id(memo)].append(x)
    except KeyError:
        # aha, this is the first one :-)
        memo[id(memo)]=[x]


# A cache for whichmodule(), mapping a function object to the name of
# the module in which the function was found.

classmap = {} # called classmap for backwards compatibility

def whichmodule(func, funcname):
    """Figure out the module in which a function occurs.

    Search sys.modules for the module.
    Cache in classmap.
    Return a module name.
    If the function cannot be found, return "__main__".
    """
    # Python functions should always get an __module__ from their globals.
    mod = getattr(func, "__module__", None)
    if mod is not None:
        return mod
    if func in classmap:
        return classmap[func]

    for name, module in sys.modules.items():
        if module is None:
            continue # skip dummy package entries
        if name != '__main__' and getattr(module, funcname, None) is func:
            break
    else:
        name = '__main__'
    classmap[func] = name
    return name


# Unpickling machinery

class Unpickler:

    def __init__(self, file):
        """This takes a file-like object for reading a pickle data stream.

        The protocol version of the pickle is detected automatically, so no
        proto argument is needed.

        The file-like object must have two methods, a read() method that
        takes an integer argument, and a readline() method that requires no
        arguments.  Both methods should return a string.  Thus file-like
        object can be a file object opened for reading, a StringIO object,
        or any other custom object that meets this interface.
        """
        self.readline = file.readline
        self.read = file.read
        self.memo = {}

    def load(self):
        """Read a pickled object representation from the open file.

        Return the reconstituted object hierarchy specified in the file.
        """
        self.mark = object() # any new unique object
        self.stack = []
        self.append = self.stack.append
        read = self.read
        dispatch = self.dispatch
        try:
            while 1:
                key = read(1)
                dispatch[key](self)
        except _Stop, stopinst:
            return stopinst.value

    # Return largest index k such that self.stack[k] is self.mark.
    # If the stack doesn't contain a mark, eventually raises IndexError.
    # This could be sped by maintaining another stack, of indices at which
    # the mark appears.  For that matter, the latter stack would suffice,
    # and we wouldn't need to push mark objects on self.stack at all.
    # Doing so is probably a good thing, though, since if the pickle is
    # corrupt (or hostile) we may get a clue from finding self.mark embedded
    # in unpickled objects.
    def marker(self):
        stack = self.stack
        mark = self.mark
        k = len(stack)-1
        while stack[k] is not mark: k = k-1
        return k

    dispatch = {}

    def load_eof(self):
        raise EOFError
    dispatch[''] = load_eof

    def load_proto(self):
        proto = ord(self.read(1))
        if not 0 <= proto <= 2:
            raise ValueError, "unsupported pickle protocol: %d" % proto
    dispatch[PROTO] = load_proto

    def load_persid(self):
        pid = self.readline()[:-1]
        self.append(self.persistent_load(pid))
    dispatch[PERSID] = load_persid

    def load_binpersid(self):
        pid = self.stack.pop()
        self.append(self.persistent_load(pid))
    dispatch[BINPERSID] = load_binpersid

    def load_none(self):
        self.append(None)
    dispatch[NONE] = load_none

    def load_false(self):
        self.append(False)
    dispatch[NEWFALSE] = load_false

    def load_true(self):
        self.append(True)
    dispatch[NEWTRUE] = load_true

    def load_int(self):
        data = self.readline()
        if data == FALSE[1:]:
            val = False
        elif data == TRUE[1:]:
            val = True
        else:
            try:
                val = int(data)
            except ValueError:
                val = long(data)
        self.append(val)
    dispatch[INT] = load_int

    def load_binint(self):
        self.append(mloads('i' + self.read(4)))
    dispatch[BININT] = load_binint

    def load_binint1(self):
        self.append(ord(self.read(1)))
    dispatch[BININT1] = load_binint1

    def load_binint2(self):
        self.append(mloads('i' + self.read(2) + '\000\000'))
    dispatch[BININT2] = load_binint2

    def load_long(self):
        self.append(long(self.readline()[:-1], 0))
    dispatch[LONG] = load_long

    def load_long1(self):
        n = ord(self.read(1))
        bytes = self.read(n)
        self.append(decode_long(bytes))
    dispatch[LONG1] = load_long1

    def load_long4(self):
        n = mloads('i' + self.read(4))
        bytes = self.read(n)
        self.append(decode_long(bytes))
    dispatch[LONG4] = load_long4

    def load_float(self):
        self.append(float(self.readline()[:-1]))
    dispatch[FLOAT] = load_float

    def load_binfloat(self, unpack=struct.unpack):
        self.append(unpack('>d', self.read(8))[0])
    dispatch[BINFLOAT] = load_binfloat

    def load_string(self):
        rep = self.readline()[:-1]
        for q in "\"'": # double or single quote
            if rep.startswith(q):
                if len(rep) < 2 or not rep.endswith(q):
                    raise ValueError, "insecure string pickle"
                rep = rep[len(q):-len(q)]
                break
        else:
            raise ValueError, "insecure string pickle"
        self.append(rep.decode("string-escape"))
    dispatch[STRING] = load_string

    def load_binstring(self):
        len = mloads('i' + self.read(4))
        self.append(self.read(len))
    dispatch[BINSTRING] = load_binstring

    def load_unicode(self):
        self.append(unicode(self.readline()[:-1],'raw-unicode-escape'))
    dispatch[UNICODE] = load_unicode

    def load_binunicode(self):
        len = mloads('i' + self.read(4))
        self.append(unicode(self.read(len),'utf-8'))
    dispatch[BINUNICODE] = load_binunicode

    def load_short_binstring(self):
        len = ord(self.read(1))
        self.append(self.read(len))
    dispatch[SHORT_BINSTRING] = load_short_binstring

    def load_tuple(self):
        k = self.marker()
        self.stack[k:] = [tuple(self.stack[k+1:])]
    dispatch[TUPLE] = load_tuple

    def load_empty_tuple(self):
        self.stack.append(())
    dispatch[EMPTY_TUPLE] = load_empty_tuple

    def load_tuple1(self):
        self.stack[-1] = (self.stack[-1],)
    dispatch[TUPLE1] = load_tuple1

    def load_tuple2(self):
        self.stack[-2:] = [(self.stack[-2], self.stack[-1])]
    dispatch[TUPLE2] = load_tuple2

    def load_tuple3(self):
        self.stack[-3:] = [(self.stack[-3], self.stack[-2], self.stack[-1])]
    dispatch[TUPLE3] = load_tuple3

    def load_empty_list(self):
        self.stack.append([])
    dispatch[EMPTY_LIST] = load_empty_list

    def load_empty_dictionary(self):
        self.stack.append({})
    dispatch[EMPTY_DICT] = load_empty_dictionary

    def load_list(self):
        k = self.marker()
        self.stack[k:] = [self.stack[k+1:]]
    dispatch[LIST] = load_list

    def load_dict(self):
        k = self.marker()
        d = {}
        items = self.stack[k+1:]
        for i in range(0, len(items), 2):
            key = items[i]
            value = items[i+1]
            d[key] = value
        self.stack[k:] = [d]
    dispatch[DICT] = load_dict

    # INST and OBJ differ only in how they get a class object.  It's not
    # only sensible to do the rest in a common routine, the two routines
    # previously diverged and grew different bugs.
    # klass is the class to instantiate, and k points to the topmost mark
    # object, following which are the arguments for klass.__init__.
    def _instantiate(self, klass, k):
        args = tuple(self.stack[k+1:])
        del self.stack[k:]
        instantiated = 0
        if (not args and
                type(klass) is ClassType and
                not hasattr(klass, "__getinitargs__")):
            try:
                value = _EmptyClass()
                value.__class__ = klass
                instantiated = 1
            except RuntimeError:
                # In restricted execution, assignment to inst.__class__ is
                # prohibited
                pass
        if not instantiated:
            try:
                value = klass(*args)
            except TypeError, err:
                raise TypeError, "in constructor for %s: %s" % (
                    klass.__name__, str(err)), sys.exc_info()[2]
        self.append(value)

    def load_inst(self):
        module = self.readline()[:-1]
        name = self.readline()[:-1]
        klass = self.find_class(module, name)
        self._instantiate(klass, self.marker())
    dispatch[INST] = load_inst

    def load_obj(self):
        # Stack is ... markobject classobject arg1 arg2 ...
        k = self.marker()
        klass = self.stack.pop(k+1)
        self._instantiate(klass, k)
    dispatch[OBJ] = load_obj

    def load_newobj(self):
        args = self.stack.pop()
        cls = self.stack[-1]
        obj = cls.__new__(cls, *args)
        self.stack[-1] = obj
    dispatch[NEWOBJ] = load_newobj

    def load_global(self):
        module = self.readline()[:-1]
        name = self.readline()[:-1]
        klass = self.find_class(module, name)
        self.append(klass)
    dispatch[GLOBAL] = load_global

    def load_ext1(self):
        code = ord(self.read(1))
        self.get_extension(code)
    dispatch[EXT1] = load_ext1

    def load_ext2(self):
        code = mloads('i' + self.read(2) + '\000\000')
        self.get_extension(code)
    dispatch[EXT2] = load_ext2

    def load_ext4(self):
        code = mloads('i' + self.read(4))
        self.get_extension(code)
    dispatch[EXT4] = load_ext4

    def get_extension(self, code):
        nil = []
        obj = _extension_cache.get(code, nil)
        if obj is not nil:
            self.append(obj)
            return
        key = _inverted_registry.get(code)
        if not key:
            raise ValueError("unregistered extension code %d" % code)
        obj = self.find_class(*key)
        _extension_cache[code] = obj
        self.append(obj)

    def find_class(self, module, name):
        # Subclasses may override this
        __import__(module)
        mod = sys.modules[module]
        klass = getattr(mod, name)
        return klass

    def load_reduce(self):
        stack = self.stack
        args = stack.pop()
        func = stack[-1]
        value = func(*args)
        stack[-1] = value
    dispatch[REDUCE] = load_reduce

    def load_pop(self):
        del self.stack[-1]
    dispatch[POP] = load_pop

    def load_pop_mark(self):
        k = self.marker()
        del self.stack[k:]
    dispatch[POP_MARK] = load_pop_mark

    def load_dup(self):
        self.append(self.stack[-1])
    dispatch[DUP] = load_dup

    def load_get(self):
        self.append(self.memo[self.readline()[:-1]])
    dispatch[GET] = load_get

    def load_binget(self):
        i = ord(self.read(1))
        self.append(self.memo[repr(i)])
    dispatch[BINGET] = load_binget

    def load_long_binget(self):
        i = mloads('i' + self.read(4))
        self.append(self.memo[repr(i)])
    dispatch[LONG_BINGET] = load_long_binget

    def load_put(self):
        self.memo[self.readline()[:-1]] = self.stack[-1]
    dispatch[PUT] = load_put

    def load_binput(self):
        i = ord(self.read(1))
        self.memo[repr(i)] = self.stack[-1]
    dispatch[BINPUT] = load_binput

    def load_long_binput(self):
        i = mloads('i' + self.read(4))
        self.memo[repr(i)] = self.stack[-1]
    dispatch[LONG_BINPUT] = load_long_binput

    def load_append(self):
        stack = self.stack
        value = stack.pop()
        list = stack[-1]
        list.append(value)
    dispatch[APPEND] = load_append

    def load_appends(self):
        stack = self.stack
        mark = self.marker()
        list = stack[mark - 1]
        list.extend(stack[mark + 1:])
        del stack[mark:]
    dispatch[APPENDS] = load_appends

    def load_setitem(self):
        stack = self.stack
        value = stack.pop()
        key = stack.pop()
        dict = stack[-1]
        dict[key] = value
    dispatch[SETITEM] = load_setitem

    def load_setitems(self):
        stack = self.stack
        mark = self.marker()
        dict = stack[mark - 1]
        for i in range(mark + 1, len(stack), 2):
            dict[stack[i]] = stack[i + 1]

        del stack[mark:]
    dispatch[SETITEMS] = load_setitems

    def load_build(self):
        stack = self.stack
        state = stack.pop()
        inst = stack[-1]
        setstate = getattr(inst, "__setstate__", None)
        if setstate:
            setstate(state)
            return
        slotstate = None
        if isinstance(state, tuple) and len(state) == 2:
            state, slotstate = state
        if state:
            try:
                d = inst.__dict__
                try:
                    for k, v in state.iteritems():
                        d[intern(k)] = v
                # keys in state don't have to be strings
                # don't blow up, but don't go out of our way
                except TypeError:
                    d.update(state)

            except RuntimeError:
                # XXX In restricted execution, the instance's __dict__
                # is not accessible.  Use the old way of unpickling
                # the instance variables.  This is a semantic
                # difference when unpickling in restricted
                # vs. unrestricted modes.
                # Note, however, that cPickle has never tried to do the
                # .update() business, and always uses
                #     PyObject_SetItem(inst.__dict__, key, value) in a
                # loop over state.items().
                for k, v in state.items():
                    setattr(inst, k, v)
        if slotstate:
            for k, v in slotstate.items():
                setattr(inst, k, v)
    dispatch[BUILD] = load_build

    def load_mark(self):
        self.append(self.mark)
    dispatch[MARK] = load_mark

    def load_stop(self):
        value = self.stack.pop()
        raise _Stop(value)
    dispatch[STOP] = load_stop

# Helper class for load_inst/load_obj

class _EmptyClass:
    pass

# Encode/decode longs in linear time.

import binascii as _binascii

def encode_long(x):
    r"""Encode a long to a two's complement little-endian binary string.
    Note that 0L is a special case, returning an empty string, to save a
    byte in the LONG1 pickling context.

    >>> encode_long(0L)
    ''
    >>> encode_long(255L)
    '\xff\x00'
    >>> encode_long(32767L)
    '\xff\x7f'
    >>> encode_long(-256L)
    '\x00\xff'
    >>> encode_long(-32768L)
    '\x00\x80'
    >>> encode_long(-128L)
    '\x80'
    >>> encode_long(127L)
    '\x7f'
    >>>
    """

    if x == 0:
        return ''
    if x > 0:
        ashex = hex(x)
        assert ashex.startswith("0x")
        njunkchars = 2 + ashex.endswith('L')
        nibbles = len(ashex) - njunkchars
        if nibbles & 1:
            # need an even # of nibbles for unhexlify
            ashex = "0x0" + ashex[2:]
        elif int(ashex[2], 16) >= 8:
            # "looks negative", so need a byte of sign bits
            ashex = "0x00" + ashex[2:]
    else:
        # Build the 256's-complement:  (1L << nbytes) + x.  The trick is
        # to find the number of bytes in linear time (although that should
        # really be a constant-time task).
        ashex = hex(-x)
        assert ashex.startswith("0x")
        njunkchars = 2 + ashex.endswith('L')
        nibbles = len(ashex) - njunkchars
        if nibbles & 1:
            # Extend to a full byte.
            nibbles += 1
        nbits = nibbles * 4
        x += 1L << nbits
        assert x > 0
        ashex = hex(x)
        njunkchars = 2 + ashex.endswith('L')
        newnibbles = len(ashex) - njunkchars
        if newnibbles < nibbles:
            ashex = "0x" + "0" * (nibbles - newnibbles) + ashex[2:]
        if int(ashex[2], 16) < 8:
            # "looks positive", so need a byte of sign bits
            ashex = "0xff" + ashex[2:]

    if ashex.endswith('L'):
        ashex = ashex[2:-1]
    else:
        ashex = ashex[2:]
    assert len(ashex) & 1 == 0, (x, ashex)
    binary = _binascii.unhexlify(ashex)
    return binary[::-1]

def decode_long(data):
    r"""Decode a long from a two's complement little-endian binary string.

    >>> decode_long('')
    0L
    >>> decode_long("\xff\x00")
    255L
    >>> decode_long("\xff\x7f")
    32767L
    >>> decode_long("\x00\xff")
    -256L
    >>> decode_long("\x00\x80")
    -32768L
    >>> decode_long("\x80")
    -128L
    >>> decode_long("\x7f")
    127L
    """

    nbytes = len(data)
    if nbytes == 0:
        return 0L
    ashex = _binascii.hexlify(data[::-1])
    n = long(ashex, 16) # quadratic time before Python 2.3; linear now
    if data[-1] >= '\x80':
        n -= 1L << (nbytes * 8)
    return n

# Shorthands

try:
    from cStringIO import StringIO
except ImportError:
    from StringIO import StringIO

def dump(obj, file, protocol=None):
    Pickler(file, protocol).dump(obj)

def dumps(obj, protocol=None):
    file = StringIO()
    Pickler(file, protocol).dump(obj)
    return file.getvalue()

def load(file):
    return Unpickler(file).load()

def loads(str):
    file = StringIO(str)
    return Unpickler(file).load()

# Doctest

def _test():
    import doctest
    return doctest.testmod()

if __name__ == "__main__":
    _test()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ó
Ó«[c        	   @   sí  d  Z  d Z d d l Td d l m Z d d l m Z m Z m Z d d l Z d d l	 Z	 d d l
 Z
 d d l Z d d d	 d
 d d d d d g	 Z d Z d d d d d g Z d Z e j Z d e f d „  ƒ  YZ d e f d „  ƒ  YZ d	 e f d „  ƒ  YZ d e f d „  ƒ  YZ y d d l m Z Wn e k
 rBe Z n Xy e Wn e k
 rde Z n Xd Z d Z d Z d Z  d  Z! d! Z" d" Z# d# Z$ d$ Z% d% Z& d& Z' d' Z( d( Z) d) Z* d* Z+ d+ Z, d, Z- d- Z. d. Z/ d/ Z0 d0 Z1 d1 Z2 d2 Z3 d3 Z4 d4 Z5 d5 Z6 d6 Z7 d7 Z8 d8 Z9 d9 Z: d: Z; d; Z< d< Z= d= Z> d> Z? d? Z@ d@ ZA dA ZB dB ZC dC ZD dD ZE dE ZF dF ZG dG ZH dH ZI dI ZJ dJ ZK dK ZL dL ZM dM ZN dN ZO dO ZP dP ZQ dQ ZR dR ZS eC eM eN eO g ZT e jU g  eV ƒ  D] ZW e jX dS eW ƒ rïeW ^ qÑƒ [W d
 f  dT „  ƒ  YZY dU „  ZZ i  Z[ dV „  Z\ d f  dW „  ƒ  YZ] dX f  dY „  ƒ  YZ^ d d l_ Z` dZ „  Za d[ „  Zb y d d\ lc md Zd Wn! e k
 rŸd d\ ld md Zd n Xe d] „ Ze e d^ „ Zf d_ „  Zg d` „  Z da „  Zh ei db k réeh ƒ  n  d S(c   sØ  Create portable serialized representations of Python objects.

See module cPickle for a (much) faster implementation.
See module copy_reg for a mechanism for registering custom picklers.
See module pickletools source for extensive comments.

Classes:

    Pickler
    Unpickler

Functions:

    dump(object, file)
    dumps(object) -> string
    load(file) -> object
    loads(string) -> object

Misc variables:

    __version__
    format_version
    compatible_formats

s   $Revision: 72223 $iÿÿÿÿ(   t   *(   t   dispatch_table(   t   _extension_registryt   _inverted_registryt   _extension_cacheNt   PickleErrort   PicklingErrort   UnpicklingErrort   Picklert	   Unpicklert   dumpt   dumpst   loadt   loadss   2.0s   1.0s   1.1s   1.2s   1.3i   c           B   s   e  Z d  Z RS(   s6   A common base class for the other pickling exceptions.(   t   __name__t
   __module__t   __doc__(    (    (    s   /usr/lib/python2.7/pickle.pyR   :   s   c           B   s   e  Z d  Z RS(   s]   This exception is raised when an unpicklable object is passed to the
    dump() method.

    (   R   R   R   (    (    (    s   /usr/lib/python2.7/pickle.pyR   >   s   c           B   s   e  Z d  Z RS(   s  This exception is raised when there is a problem unpickling an object,
    such as a security violation.

    Note that other exceptions may also be raised during unpickling, including
    (but not necessarily limited to) AttributeError, EOFError, ImportError,
    and IndexError.

    (   R   R   R   (    (    (    s   /usr/lib/python2.7/pickle.pyR   E   s   t   _Stopc           B   s   e  Z d  „  Z RS(   c         C   s   | |  _  d  S(   N(   t   value(   t   selfR   (    (    s   /usr/lib/python2.7/pickle.pyt   __init__S   s    (   R   R   R   (    (    (    s   /usr/lib/python2.7/pickle.pyR   R   s   (   t   PyStringMapt   (t   .t   0t   1t   2t   Ft   It   Jt   Kt   Lt   Mt   Nt   Pt   Qt   Rt   St   Tt   Ut   Vt   Xt   at   bt   ct   dt   }t   et   gt   ht   it   jt   lt   ]t   ot   pt   qt   rt   st   tt   )t   ut   Gs   I01
s   I00
s   €s   s   ‚s   ƒs   „s   …s   †s   ‡s   ˆs   ‰s   Šs   ‹s   [A-Z][A-Z0-9_]+$c           B   s  e  Z d d  „ Z d „  Z d „  Z d „  Z e j d „ Z	 e j d „ Z
 d „  Z d „  Z d „  Z d d d d d	 „ Z i  Z d
 „  Z e e e <d „  Z e e e <e j d „ Z e e e <e j d „ Z e e e <e j d „ Z e e e <e j d „ Z e e e <e j d „ Z e e e <e e k rLe j d „ Z e e e <n  d „  Z e e e <d „  Z  d „  Z! e! e e" <d Z# d „  Z$ d „  Z% e% e e& <e' d k	 r¶e% e e' <n  d „  Z( d „  Z) e) e e* <d e j d „ Z+ e+ e e, <e+ e e- <e+ e e. <e+ e e/ <RS(   c         C   s™   | d k r d } n  | d k  r* t } n/ d | k oA t k n sY t d t ƒ ‚ n  | j |  _ i  |  _ t | ƒ |  _ | d k |  _ d |  _ d S(   s8  This takes a file-like object for writing a pickle data stream.

        The optional protocol argument tells the pickler to use the
        given protocol; supported protocols are 0, 1, 2.  The default
        protocol is 0, to be backwards compatible.  (Protocol 0 is the
        only protocol that can be written to a file opened in text
        mode and read back successfully.  When using a protocol higher
        than 0, make sure the file is opened in binary mode, both when
        pickling and unpickling.)

        Protocol 1 is more efficient than protocol 0; protocol 2 is
        more efficient than protocol 1.

        Specifying a negative protocol version selects the highest
        protocol version supported.  The higher the protocol used, the
        more recent the version of Python needed to read the pickle
        produced.

        The file parameter must have a write() method that accepts a single
        string argument.  It can thus be an open file object, a StringIO
        object, or any other custom object that meets this interface.

        i    s   pickle protocol must be <= %di   N(	   t   Nonet   HIGHEST_PROTOCOLt
   ValueErrort   writet   memot   intt   protot   bint   fast(   R   t   filet   protocol(    (    s   /usr/lib/python2.7/pickle.pyR   ­   s    			c         C   s   |  j  j ƒ  d S(   s  Clears the pickler's "memo".

        The memo is the data structure that remembers which objects the
        pickler has already seen, so that shared or recursive objects are
        pickled by reference and not by value.  This method is useful when
        re-using picklers.

        N(   RC   t   clear(   R   (    (    s   /usr/lib/python2.7/pickle.pyt
   clear_memoÑ   s    	c         C   sJ   |  j  d k r, |  j t t |  j  ƒ ƒ n  |  j | ƒ |  j t ƒ d S(   s7   Write a pickled representation of obj to the open file.i   N(   RE   RB   t   PROTOt   chrt   savet   STOP(   R   t   obj(    (    s   /usr/lib/python2.7/pickle.pyR
   Ü   s    c         C   sj   |  j  r d St | ƒ |  j k s( t ‚ t |  j ƒ } |  j |  j | ƒ ƒ | | f |  j t | ƒ <d S(   s   Store an object in the memo.N(   RG   t   idRC   t   AssertionErrort   lenRB   t   put(   R   RP   t   memo_len(    (    s   /usr/lib/python2.7/pickle.pyt   memoizeã   s    	c         C   sI   |  j  r7 | d k  r# t t | ƒ St | d | ƒ Sn  t t | ƒ d S(   Ni   s   <is   
(   RF   t   BINPUTRM   t   LONG_BINPUTt   PUTt   repr(   R   R2   t   pack(    (    s   /usr/lib/python2.7/pickle.pyRT   ú   s
    	c         C   sI   |  j  r7 | d k  r# t t | ƒ St | d | ƒ Sn  t t | ƒ d S(   Ni   s   <is   
(   RF   t   BINGETRM   t   LONG_BINGETt   GETRZ   (   R   R2   R[   (    (    s   /usr/lib/python2.7/pickle.pyt   get  s
    	c   
      C   s	  |  j  | ƒ } | d  k	 r, |  j | ƒ d  S|  j j t | ƒ ƒ } | rh |  j |  j | d ƒ ƒ d  St | ƒ } |  j j | ƒ } | r | |  | ƒ d  St	 j | ƒ } | rÁ | | ƒ } n« y t
 | t ƒ } Wn t k
 rí d } n X| r|  j | ƒ d  St | d d  ƒ } | r/| |  j ƒ } n= t | d d  ƒ } | rS| ƒ  } n t d | j | f ƒ ‚ t | ƒ t k r’|  j | | ƒ d  St | ƒ t k	 r·t d | ƒ ‚ n  t | ƒ }	 d |	 k oÚd k n sòt d | ƒ ‚ n  |  j d	 | | Œ d  S(
   Ni    t   __reduce_ex__t
   __reduce__s   Can't pickle %r object: %rs   %s must return string or tuplei   i   s3   Tuple returned by %s must have two to five elementsRP   (   t   persistent_idR?   t	   save_persRC   R_   RQ   RB   t   typet   dispatchR   t
   issubclasst   TypeTypet	   TypeErrort   save_globalt   getattrRE   R   R   t
   StringTypet	   TupleTypeRS   t   save_reduce(
   R   RP   t   pidt   xR;   t   ft   reducet   rvt   isscR4   (    (    s   /usr/lib/python2.7/pickle.pyRN     sR    
c         C   s   d  S(   N(   R?   (   R   RP   (    (    s   /usr/lib/python2.7/pickle.pyRb   M  s    c         C   sE   |  j  r& |  j | ƒ |  j t ƒ n |  j t t | ƒ d ƒ d  S(   Ns   
(   RF   RN   RB   t	   BINPERSIDt   PERSIDt   str(   R   Rn   (    (    s   /usr/lib/python2.7/pickle.pyRc   Q  s    	c   
      C   sË  t  | t ƒ s t d ƒ ‚ n  t | d ƒ s< t d ƒ ‚ n  |  j } |  j } |  j d k rò t | d d ƒ d k rò | d }	 t |	 d	 ƒ s t d
 ƒ ‚ n  | d  k	 rÇ |	 | j	 k	 rÇ t d ƒ ‚ n  | d } | |	 ƒ | | ƒ | t
 ƒ n | | ƒ | | ƒ | t ƒ | d  k	 rlt | ƒ |  j k r\| t |  j |  j t | ƒ d ƒ ƒ ql|  j | ƒ n  | d  k	 rˆ|  j | ƒ n  | d  k	 r¤|  j | ƒ n  | d  k	 rÇ| | ƒ | t ƒ n  d  S(   Ns$   args from reduce() should be a tuplet   __call__s#   func from reduce should be callablei   R   t    t
   __newobj__i    t   __new__s+   args[0] from __newobj__ args has no __new__s0   args[0] from __newobj__ args has the wrong classi   (   t
   isinstanceRl   R   t   hasattrRN   RB   RE   Rj   R?   t	   __class__t   NEWOBJt   REDUCERQ   RC   t   POPR_   RV   t   _batch_appendst   _batch_setitemst   BUILD(
   R   t   funct   argst   statet	   listitemst	   dictitemsRP   RN   RB   t   cls(    (    s   /usr/lib/python2.7/pickle.pyRm   Y  s@    		'






+
c         C   s   |  j  t ƒ d  S(   N(   RB   t   NONE(   R   RP   (    (    s   /usr/lib/python2.7/pickle.pyt	   save_none°  s    c         C   sH   |  j  d k r+ |  j | r! t p$ t ƒ n |  j | r= t p@ t ƒ d  S(   Ni   (   RE   RB   t   NEWTRUEt   NEWFALSEt   TRUEt   FALSE(   R   RP   (    (    s   /usr/lib/python2.7/pickle.pyt	   save_bool´  s    c         C   sÓ   |  j  r´ | d k rq | d k r< |  j t t | ƒ ƒ d  S| d k rq |  j d t | d @| d ?f ƒ d  Sn  | d ?} | d k s“ | d k r´ |  j t | d | ƒ ƒ d  Sn  |  j t t | ƒ d	 ƒ d  S(
   Ni    iÿ   iÿÿ  s   %c%c%ci   i   iÿÿÿÿs   <is   
(   RF   RB   t   BININT1RM   t   BININT2t   BININTt   INTRZ   (   R   RP   R[   t	   high_bits(    (    s   /usr/lib/python2.7/pickle.pyt   save_int»  s    	"
c         C   s’   |  j  d k rs t | ƒ } t | ƒ } | d k  rQ |  j t t | ƒ | ƒ n |  j t | d | ƒ | ƒ d  S|  j t t | ƒ d ƒ d  S(   Ni   i   s   <is   
(	   RE   t   encode_longRS   RB   t   LONG1RM   t   LONG4t   LONGRZ   (   R   RP   R[   t   bytest   n(    (    s   /usr/lib/python2.7/pickle.pyt	   save_longÓ  s    c         C   sE   |  j  r& |  j t | d | ƒ ƒ n |  j t t | ƒ d ƒ d  S(   Ns   >ds   
(   RF   RB   t   BINFLOATt   FLOATRZ   (   R   RP   R[   (    (    s   /usr/lib/python2.7/pickle.pyt
   save_floatß  s    	c         C   sŒ   |  j  r` t | ƒ } | d k  r? |  j t t | ƒ | ƒ q{ |  j t | d | ƒ | ƒ n |  j t t | ƒ d ƒ |  j | ƒ d  S(   Ni   s   <is   
(	   RF   RS   RB   t   SHORT_BINSTRINGRM   t	   BINSTRINGt   STRINGRZ   RV   (   R   RP   R[   Rœ   (    (    s   /usr/lib/python2.7/pickle.pyt   save_stringæ  s    	!c         C   s˜   |  j  rE | j d ƒ } t | ƒ } |  j t | d | ƒ | ƒ nB | j d d ƒ } | j d d ƒ } |  j t | j d ƒ d ƒ |  j | ƒ d  S(   Ns   utf-8s   <is   \s   \u005cs   
s   \u000as   raw-unicode-escape(   RF   t   encodeRS   RB   t
   BINUNICODEt   replacet   UNICODERV   (   R   RP   R[   t   encodingRœ   (    (    s   /usr/lib/python2.7/pickle.pyt   save_unicodeò  s    	!c         C   s,  | j  ƒ  } |  j r¯ | r- | j d ƒ } n  t | ƒ } | d k  rj | rj |  j t t | ƒ | ƒ q| d | ƒ } | r— |  j t | | ƒ q|  j t | | ƒ nl | r | j	 d d ƒ } | j	 d d ƒ } | j d ƒ } |  j t
 | d ƒ n |  j t t | ƒ d ƒ |  j | ƒ d  S(	   Ns   utf-8i   s   <is   \s   \u005cs   
s   \u000as   raw-unicode-escape(   t	   isunicodeRF   R¥   RS   RB   R¡   RM   R¦   R¢   R§   R¨   R£   RZ   RV   (   R   RP   R[   t   unicodeR4   R:   (    (    s   /usr/lib/python2.7/pickle.pyR¤      s$    	c   	      C   sš  |  j  } |  j } t | ƒ } | d k rO | r= | t ƒ n | t t ƒ d  S|  j } |  j } | d k r÷ | d k r÷ x | D] } | | ƒ q€ Wt | ƒ | k rØ |  j	 | t | ƒ d ƒ } | t
 | | ƒ n | t | ƒ |  j | ƒ d  S| t ƒ x | D] } | | ƒ qWt | ƒ | k r||  j	 | t | ƒ d ƒ } | rb| t | ƒ n | t
 | d | ƒ d  S|  j  t ƒ |  j | ƒ d  S(   Ni    i   i   i   (   RB   RE   RS   t   EMPTY_TUPLEt   MARKt   TUPLERN   RC   RQ   R_   R€   t   _tuplesize2codeRV   t   POP_MARK(	   R   RP   RB   RE   Rœ   RN   RC   t   elementR_   (    (    s   /usr/lib/python2.7/pickle.pyt
   save_tuple  s<    				
c         C   s   |  j  t ƒ d  S(   N(   RB   R­   (   R   RP   (    (    s   /usr/lib/python2.7/pickle.pyt   save_empty_tupleR  s    c         C   sQ   |  j  } |  j r | t ƒ n | t t ƒ |  j | ƒ |  j t | ƒ ƒ d  S(   N(   RB   RF   t
   EMPTY_LISTR®   t   LISTRV   R   t   iter(   R   RP   RB   (    (    s   /usr/lib/python2.7/pickle.pyt	   save_listU  s    		iè  c   	      C   s$  |  j  } |  j } |  j sD x" | D] } | | ƒ | t ƒ q" Wd  St |  j ƒ } xÊ | d  k	 rg  } xF | D]> } y | j ƒ  } | j | ƒ Wqo t	 k
 r¬ d  } Pqo Xqo Wt
 | ƒ } | d k rû | t ƒ x | D] } | | ƒ qÚ W| t ƒ qV | rV | | d ƒ | t ƒ qV qV Wd  S(   Ni   i    (   RN   RB   RF   t   APPENDt   xranget
   _BATCHSIZER?   t   nextt   appendt   StopIterationRS   R®   t   APPENDS(	   R   t   itemsRN   RB   Ro   R9   t   tmpR2   Rœ   (    (    s   /usr/lib/python2.7/pickle.pyR   f  s4    			
	
c         C   sQ   |  j  } |  j r | t ƒ n | t t ƒ |  j | ƒ |  j | j ƒ  ƒ d  S(   N(   RB   RF   t
   EMPTY_DICTR®   t   DICTRV   R‚   t	   iteritems(   R   RP   RB   (    (    s   /usr/lib/python2.7/pickle.pyt	   save_dict†  s    		c   
      C   sT  |  j  } |  j } |  j sT x2 | D]* \ } } | | ƒ | | ƒ | t ƒ q" Wd  St |  j ƒ } xê | d  k	 rOg  } x@ | D]8 } y | j | j ƒ  ƒ Wq t	 k
 r¶ d  } Pq Xq Wt
 | ƒ }	 |	 d k r| t ƒ x( | D]  \ } } | | ƒ | | ƒ qä W| t ƒ qf |	 rf | d \ } } | | ƒ | | ƒ | t ƒ qf qf Wd  S(   Ni   i    (   RN   RB   RF   t   SETITEMRº   R»   R?   R½   R¼   R¾   RS   R®   t   SETITEMS(
   R   RÀ   RN   RB   t   kt   vR9   RÁ   R2   Rœ   (    (    s   /usr/lib/python2.7/pickle.pyR‚   •  s:    			

	



c   
      C   sD  | j  } |  j } |  j } |  j } t | d ƒ rY | j ƒ  } t | ƒ t | | ƒ n d } | t ƒ |  j	 r¤ | | ƒ x | D] } | | ƒ qƒ W| t
 ƒ n; x | D] } | | ƒ q« W| t | j d | j d ƒ |  j | ƒ y | j } Wn t k
 r| j }	 n X| ƒ  }	 t |	 | ƒ | |	 ƒ | t ƒ d  S(   Nt   __getinitargs__s   
(    (   R}   RC   RB   RN   R|   RÊ   RS   t   _keep_aliveR®   RF   t   OBJt   INSTR   R   RV   t   __getstate__t   AttributeErrort   __dict__Rƒ   (
   R   RP   R‰   RC   RB   RN   R…   t   argt   getstatet   stuff(    (    s   /usr/lib/python2.7/pickle.pyt	   save_inst¸  s6    				

	
 	
c   
      C   s¸  |  j  } |  j } | d  k r* | j } n  t | d d  ƒ } | d  k rZ t | | ƒ } n  y* t | ƒ t j | } t | | ƒ } Wn3 t	 t
 t f k
 r¹ t d | | | f ƒ ‚ n) X| | k	 râ t d | | | f ƒ ‚ n  |  j d k rt j | | f ƒ }	 |	 r|	 d k st ‚ |	 d k rA| t t |	 ƒ ƒ nE |	 d k ro| d t |	 d @|	 d	 ?f ƒ n | t | d
 |	 ƒ ƒ d  Sn  | t | d | d ƒ |  j | ƒ d  S(   NR   s(   Can't pickle %r: it's not found as %s.%ss2   Can't pickle %r: it's not the same object as %s.%si   i    iÿ   iÿÿ  s   %c%c%ci   s   <is   
(   RB   RC   R?   R   Rj   t   whichmodulet
   __import__t   syst   modulest   ImportErrort   KeyErrorRÏ   R   RE   R   R_   RR   t   EXT1RM   t   EXT2t   EXT4t   GLOBALRV   (
   R   RP   t   nameR[   RB   RC   t   modulet   modt   klasst   code(    (    s   /usr/lib/python2.7/pickle.pyRi   à  s>    		
"N(0   R   R   R?   R   RK   R
   RV   t   structR[   RT   R_   RN   Rb   Rc   Rm   Re   R‹   t   NoneTypeR   t   boolR–   t   IntTypeR   t   LongTypeR    t	   FloatTypeR¤   Rk   Rª   t   UnicodeTypeR³   Rl   R´   R¸   t   ListTypeR»   R   RÅ   t   DictionaryTypeR   R‚   RÔ   t   InstanceTypeRi   t	   ClassTypet   FunctionTypet   BuiltinFunctionTypeRg   (    (    (    s   /usr/lib/python2.7/pickle.pyR   «   s`   $			
		@		T	
	








	3
		
	 	
	#	&
(


c         C   sF   y | t  | ƒ j |  ƒ Wn$ t k
 rA |  g | t  | ƒ <n Xd S(   sM  Keeps a reference to the object x in the memo.

    Because we remember objects by their id, we have
    to assure that possibly temporary objects are kept
    alive by referencing them.
    We store a reference at the id of the memo, which should
    normally not be used unless someone tries to deepcopy
    the memo itself...
    N(   RQ   R½   RÚ   (   Ro   RC   (    (    s   /usr/lib/python2.7/pickle.pyRË     s    
c         C   s¤   t  |  d d ƒ } | d k	 r" | S|  t k r6 t |  Sx] t j j ƒ  D]F \ } } | d k rd qF n  | d k rF t  | | d ƒ |  k rF PqF qF Wd } | t |  <| S(   sÇ   Figure out the module in which a function occurs.

    Search sys.modules for the module.
    Cache in classmap.
    Return a module name.
    If the function cannot be found, return "__main__".
    R   t   __main__N(   Rj   R?   t   classmapR×   RØ   RÀ   (   R„   t   funcnameRá   Rß   Rà   (    (    s   /usr/lib/python2.7/pickle.pyRÕ   %  s    	$
c           B   sL  e  Z d  „  Z d „  Z d „  Z i  Z d „  Z e e d <d „  Z e e e <d „  Z	 e	 e e
 <d „  Z e e e <d „  Z e e e <d	 „  Z e e e <d
 „  Z e e e <d „  Z e e e <d „  Z e e e <d „  Z e e e <d „  Z e e e <d „  Z e e e <d „  Z e e e <d „  Z e e e  <d „  Z! e! e e" <e# j$ d „ Z% e% e e& <d „  Z' e' e e( <d „  Z) e) e e* <d „  Z+ e+ e e, <d „  Z- e- e e. <d „  Z/ e/ e e0 <d „  Z1 e1 e e2 <d „  Z3 e3 e e4 <d „  Z5 e5 e e6 <d „  Z7 e7 e e8 <d „  Z9 e9 e e: <d „  Z; e; e e< <d „  Z= e= e e> <d  „  Z? e? e e@ <d! „  ZA eA e eB <d" „  ZC d# „  ZD eD e eE <d$ „  ZF eF e eG <d% „  ZH eH e eI <d& „  ZJ eJ e eK <d' „  ZL eL e eM <d( „  ZN eN e eO <d) „  ZP eP e eQ <d* „  ZR d+ „  ZS d, „  ZT eT e eU <d- „  ZV eV e eW <d. „  ZX eX e eY <d/ „  ZZ eZ e e[ <d0 „  Z\ e\ e e] <d1 „  Z^ e^ e e_ <d2 „  Z` e` e ea <d3 „  Zb eb e ec <d4 „  Zd ed e ee <d5 „  Zf ef e eg <d6 „  Zh eh e ei <d7 „  Zj ej e ek <d8 „  Zl el e em <d9 „  Zn en e eo <d: „  Zp ep e eq <d; „  Zr er e es <d< „  Zt et e eu <RS(=   c         C   s%   | j  |  _  | j |  _ i  |  _ d S(   s  This takes a file-like object for reading a pickle data stream.

        The protocol version of the pickle is detected automatically, so no
        proto argument is needed.

        The file-like object must have two methods, a read() method that
        takes an integer argument, and a readline() method that requires no
        arguments.  Both methods should return a string.  Thus file-like
        object can be a file object opened for reading, a StringIO object,
        or any other custom object that meets this interface.
        N(   t   readlinet   readRC   (   R   RH   (    (    s   /usr/lib/python2.7/pickle.pyR   C  s    c         C   sy   t  ƒ  |  _ g  |  _ |  j j |  _ |  j } |  j } y% x | d ƒ } | | |  ƒ q< WWn t k
 rt } | j SXd S(   s‹   Read a pickled object representation from the open file.

        Return the reconstituted object hierarchy specified in the file.
        i   N(   t   objectt   markt   stackR½   Rõ   Re   R   R   (   R   Rõ   Re   t   keyt   stopinst(    (    s   /usr/lib/python2.7/pickle.pyR   S  s    			c         C   sG   |  j  } |  j } t | ƒ d } x | | | k	 rB | d } q% W| S(   Ni   (   Rø   R÷   RS   (   R   Rø   R÷   RÈ   (    (    s   /usr/lib/python2.7/pickle.pyt   markerl  s    		 c         C   s
   t  ‚ d  S(   N(   t   EOFError(   R   (    (    s   /usr/lib/python2.7/pickle.pyt   load_eofu  s    Rx   c         C   sE   t  |  j d ƒ ƒ } d | k o, d k n sA t d | ‚ n  d  S(   Ni   i    i   s   unsupported pickle protocol: %d(   t   ordRõ   RA   (   R   RE   (    (    s   /usr/lib/python2.7/pickle.pyt
   load_protoy  s    c         C   s*   |  j  ƒ  d  } |  j |  j | ƒ ƒ d  S(   Niÿÿÿÿ(   Rô   R½   t   persistent_load(   R   Rn   (    (    s   /usr/lib/python2.7/pickle.pyt   load_persid  s    c         C   s)   |  j  j ƒ  } |  j |  j | ƒ ƒ d  S(   N(   Rø   t   popR½   R   (   R   Rn   (    (    s   /usr/lib/python2.7/pickle.pyt   load_binpersid„  s    c         C   s   |  j  d  ƒ d  S(   N(   R½   R?   (   R   (    (    s   /usr/lib/python2.7/pickle.pyt	   load_none‰  s    c         C   s   |  j  t ƒ d  S(   N(   R½   t   False(   R   (    (    s   /usr/lib/python2.7/pickle.pyt
   load_false  s    c         C   s   |  j  t ƒ d  S(   N(   R½   t   True(   R   (    (    s   /usr/lib/python2.7/pickle.pyt	   load_true‘  s    c         C   s   |  j  ƒ  } | t d k r% t } nI | t d k r> t } n0 y t | ƒ } Wn t k
 rm t | ƒ } n X|  j | ƒ d  S(   Ni   (	   Rô   R   R  RŽ   R  RD   RA   t   longR½   (   R   t   datat   val(    (    s   /usr/lib/python2.7/pickle.pyt   load_int•  s    		c         C   s$   |  j  t d |  j d ƒ ƒ ƒ d  S(   NR2   i   (   R½   t   mloadsRõ   (   R   (    (    s   /usr/lib/python2.7/pickle.pyt   load_binint£  s    c         C   s    |  j  t |  j d ƒ ƒ ƒ d  S(   Ni   (   R½   Rþ   Rõ   (   R   (    (    s   /usr/lib/python2.7/pickle.pyt   load_binint1§  s    c         C   s(   |  j  t d |  j d ƒ d ƒ ƒ d  S(   NR2   i   s     (   R½   R  Rõ   (   R   (    (    s   /usr/lib/python2.7/pickle.pyt   load_binint2«  s    c         C   s$   |  j  t |  j ƒ  d  d ƒ ƒ d  S(   Niÿÿÿÿi    (   R½   R	  Rô   (   R   (    (    s   /usr/lib/python2.7/pickle.pyt	   load_long¯  s    c         C   s;   t  |  j d ƒ ƒ } |  j | ƒ } |  j t | ƒ ƒ d  S(   Ni   (   Rþ   Rõ   R½   t   decode_long(   R   Rœ   R›   (    (    s   /usr/lib/python2.7/pickle.pyt
   load_long1³  s    c         C   s?   t  d |  j d ƒ ƒ } |  j | ƒ } |  j t | ƒ ƒ d  S(   NR2   i   (   R  Rõ   R½   R  (   R   Rœ   R›   (    (    s   /usr/lib/python2.7/pickle.pyt
   load_long4¹  s    c         C   s!   |  j  t |  j ƒ  d  ƒ ƒ d  S(   Niÿÿÿÿ(   R½   t   floatRô   (   R   (    (    s   /usr/lib/python2.7/pickle.pyt
   load_float¿  s    c         C   s'   |  j  | d |  j d ƒ ƒ d ƒ d  S(   Ns   >di   i    (   R½   Rõ   (   R   t   unpack(    (    s   /usr/lib/python2.7/pickle.pyt   load_binfloatÃ  s    c         C   sŸ   |  j  ƒ  d  } xr d D]a } | j | ƒ r t | ƒ d k  sN | j | ƒ rZ t d ‚ n  | t | ƒ t | ƒ !} Pq q Wt d ‚ |  j | j d ƒ ƒ d  S(   Niÿÿÿÿs   "'i   s   insecure string pickles   string-escape(   Rô   t
   startswithRS   t   endswithRA   R½   t   decode(   R   t   repR8   (    (    s   /usr/lib/python2.7/pickle.pyt   load_stringÇ  s    "	c         C   s3   t  d |  j d ƒ ƒ } |  j |  j | ƒ ƒ d  S(   NR2   i   (   R  Rõ   R½   (   R   RS   (    (    s   /usr/lib/python2.7/pickle.pyt   load_binstringÔ  s    c         C   s$   |  j  t |  j ƒ  d  d ƒ ƒ d  S(   Niÿÿÿÿs   raw-unicode-escape(   R½   R¬   Rô   (   R   (    (    s   /usr/lib/python2.7/pickle.pyt   load_unicodeÙ  s    c         C   s<   t  d |  j d ƒ ƒ } |  j t |  j | ƒ d ƒ ƒ d  S(   NR2   i   s   utf-8(   R  Rõ   R½   R¬   (   R   RS   (    (    s   /usr/lib/python2.7/pickle.pyt   load_binunicodeÝ  s    c         C   s/   t  |  j d ƒ ƒ } |  j |  j | ƒ ƒ d  S(   Ni   (   Rþ   Rõ   R½   (   R   RS   (    (    s   /usr/lib/python2.7/pickle.pyt   load_short_binstringâ  s    c         C   s1   |  j  ƒ  } t |  j | d ƒ g |  j | )d  S(   Ni   (   Rû   t   tupleRø   (   R   RÈ   (    (    s   /usr/lib/python2.7/pickle.pyt
   load_tupleç  s    c         C   s   |  j  j d ƒ d  S(   N(    (   Rø   R½   (   R   (    (    s   /usr/lib/python2.7/pickle.pyt   load_empty_tupleì  s    c         C   s   |  j  d f |  j  d <d  S(   Niÿÿÿÿ(   Rø   (   R   (    (    s   /usr/lib/python2.7/pickle.pyt   load_tuple1ð  s    c         C   s(   |  j  d |  j  d f g |  j  d )d  S(   Niþÿÿÿiÿÿÿÿ(   Rø   (   R   (    (    s   /usr/lib/python2.7/pickle.pyt   load_tuple2ô  s    c         C   s2   |  j  d |  j  d |  j  d f g |  j  d )d  S(   Niýÿÿÿiþÿÿÿiÿÿÿÿ(   Rø   (   R   (    (    s   /usr/lib/python2.7/pickle.pyt   load_tuple3ø  s    c         C   s   |  j  j g  ƒ d  S(   N(   Rø   R½   (   R   (    (    s   /usr/lib/python2.7/pickle.pyt   load_empty_listü  s    c         C   s   |  j  j i  ƒ d  S(   N(   Rø   R½   (   R   (    (    s   /usr/lib/python2.7/pickle.pyt   load_empty_dictionary   s    c         C   s+   |  j  ƒ  } |  j | d g |  j | )d  S(   Ni   (   Rû   Rø   (   R   RÈ   (    (    s   /usr/lib/python2.7/pickle.pyt	   load_list  s    c         C   s|   |  j  ƒ  } i  } |  j | d } xB t d t | ƒ d ƒ D]( } | | } | | d } | | | <q< W| g |  j | )d  S(   Ni   i    i   (   Rû   Rø   t   rangeRS   (   R   RÈ   R-   RÀ   R2   Rù   R   (    (    s   /usr/lib/python2.7/pickle.pyt	   load_dict	  s    
c         C   sì   t  |  j | d ƒ } |  j | 3d } | rƒ t | ƒ t k rƒ t | d ƒ rƒ y t ƒ  } | | _ d } Wqƒ t k
 r qƒ Xn  | sÛ y | | Œ  } WqÛ t k
 r× } t d | j	 t
 | ƒ f t j ƒ  d ‚ qÛ Xn  |  j | ƒ d  S(   Ni   i    RÊ   s   in constructor for %s: %si   (   R"  Rø   Rd   Rî   R|   t   _EmptyClassR}   t   RuntimeErrorRh   R   Rv   R×   t   exc_infoR½   (   R   Râ   RÈ   R…   t   instantiatedR   t   err(    (    s   /usr/lib/python2.7/pickle.pyt   _instantiate  s&    
		
*c         C   sL   |  j  ƒ  d  } |  j  ƒ  d  } |  j | | ƒ } |  j | |  j ƒ  ƒ d  S(   Niÿÿÿÿ(   Rô   t
   find_classR2  Rû   (   R   Rà   Rß   Râ   (    (    s   /usr/lib/python2.7/pickle.pyt	   load_inst0  s    c         C   s6   |  j  ƒ  } |  j j | d ƒ } |  j | | ƒ d  S(   Ni   (   Rû   Rø   R  R2  (   R   RÈ   Râ   (    (    s   /usr/lib/python2.7/pickle.pyt   load_obj7  s    c         C   s?   |  j  j ƒ  } |  j  d } | j | | Œ } | |  j  d <d  S(   Niÿÿÿÿ(   Rø   R  Rz   (   R   R…   R‰   RP   (    (    s   /usr/lib/python2.7/pickle.pyt   load_newobj>  s    c         C   sC   |  j  ƒ  d  } |  j  ƒ  d  } |  j | | ƒ } |  j | ƒ d  S(   Niÿÿÿÿ(   Rô   R3  R½   (   R   Rà   Rß   Râ   (    (    s   /usr/lib/python2.7/pickle.pyt   load_globalE  s    c         C   s&   t  |  j d ƒ ƒ } |  j | ƒ d  S(   Ni   (   Rþ   Rõ   t   get_extension(   R   Rã   (    (    s   /usr/lib/python2.7/pickle.pyt	   load_ext1L  s    c         C   s.   t  d |  j d ƒ d ƒ } |  j | ƒ d  S(   NR2   i   s     (   R  Rõ   R8  (   R   Rã   (    (    s   /usr/lib/python2.7/pickle.pyt	   load_ext2Q  s    c         C   s*   t  d |  j d ƒ ƒ } |  j | ƒ d  S(   NR2   i   (   R  Rõ   R8  (   R   Rã   (    (    s   /usr/lib/python2.7/pickle.pyt	   load_ext4V  s    c         C   s‡   g  } t  j | | ƒ } | | k	 r5 |  j | ƒ d  St j | ƒ } | s] t d | ƒ ‚ n  |  j | Œ  } | t  | <|  j | ƒ d  S(   Ns   unregistered extension code %d(   R   R_   R½   R   RA   R3  (   R   Rã   t   nilRP   Rù   (    (    s   /usr/lib/python2.7/pickle.pyR8  [  s    
c         C   s*   t  | ƒ t j | } t | | ƒ } | S(   N(   RÖ   R×   RØ   Rj   (   R   Rà   Rß   Rá   Râ   (    (    s   /usr/lib/python2.7/pickle.pyR3  h  s    
c         C   s9   |  j  } | j ƒ  } | d } | | Œ  } | | d <d  S(   Niÿÿÿÿ(   Rø   R  (   R   Rø   R…   R„   R   (    (    s   /usr/lib/python2.7/pickle.pyt   load_reduceo  s
    	
c         C   s   |  j  d =d  S(   Niÿÿÿÿ(   Rø   (   R   (    (    s   /usr/lib/python2.7/pickle.pyt   load_popw  s    c         C   s   |  j  ƒ  } |  j | 3d  S(   N(   Rû   Rø   (   R   RÈ   (    (    s   /usr/lib/python2.7/pickle.pyt   load_pop_mark{  s    c         C   s   |  j  |  j d ƒ d  S(   Niÿÿÿÿ(   R½   Rø   (   R   (    (    s   /usr/lib/python2.7/pickle.pyt   load_dup€  s    c         C   s"   |  j  |  j |  j ƒ  d  ƒ d  S(   Niÿÿÿÿ(   R½   RC   Rô   (   R   (    (    s   /usr/lib/python2.7/pickle.pyt   load_get„  s    c         C   s3   t  |  j d ƒ ƒ } |  j |  j t | ƒ ƒ d  S(   Ni   (   Rþ   Rõ   R½   RC   RZ   (   R   R2   (    (    s   /usr/lib/python2.7/pickle.pyt   load_bingetˆ  s    c         C   s7   t  d |  j d ƒ ƒ } |  j |  j t | ƒ ƒ d  S(   NR2   i   (   R  Rõ   R½   RC   RZ   (   R   R2   (    (    s   /usr/lib/python2.7/pickle.pyt   load_long_binget  s    c         C   s"   |  j  d |  j |  j ƒ  d  <d  S(   Niÿÿÿÿ(   Rø   RC   Rô   (   R   (    (    s   /usr/lib/python2.7/pickle.pyt   load_put’  s    c         C   s3   t  |  j d ƒ ƒ } |  j d |  j t | ƒ <d  S(   Ni   iÿÿÿÿ(   Rþ   Rõ   Rø   RC   RZ   (   R   R2   (    (    s   /usr/lib/python2.7/pickle.pyt   load_binput–  s    c         C   s7   t  d |  j d ƒ ƒ } |  j d |  j t | ƒ <d  S(   NR2   i   iÿÿÿÿ(   R  Rõ   Rø   RC   RZ   (   R   R2   (    (    s   /usr/lib/python2.7/pickle.pyt   load_long_binput›  s    c         C   s0   |  j  } | j ƒ  } | d } | j | ƒ d  S(   Niÿÿÿÿ(   Rø   R  R½   (   R   Rø   R   t   list(    (    s   /usr/lib/python2.7/pickle.pyt   load_append   s    	
c         C   sC   |  j  } |  j ƒ  } | | d } | j | | d ƒ | | 3d  S(   Ni   (   Rø   Rû   t   extend(   R   Rø   R÷   RG  (    (    s   /usr/lib/python2.7/pickle.pyt   load_appends§  s
    	c         C   s9   |  j  } | j ƒ  } | j ƒ  } | d } | | | <d  S(   Niÿÿÿÿ(   Rø   R  (   R   Rø   R   Rù   t   dict(    (    s   /usr/lib/python2.7/pickle.pyt   load_setitem¯  s
    	
c         C   sk   |  j  } |  j ƒ  } | | d } x: t | d t | ƒ d ƒ D] } | | d | | | <q@ W| | 3d  S(   Ni   i   (   Rø   Rû   R+  RS   (   R   Rø   R÷   RK  R2   (    (    s   /usr/lib/python2.7/pickle.pyt   load_setitems·  s    	#c   	      C   s^  |  j  } | j ƒ  } | d } t | d d  ƒ } | rE | | ƒ d  Sd  } t | t ƒ r{ t | ƒ d k r{ | \ } } n  | r$y_ | j } y1 x* | j ƒ  D] \ } } | | t	 | ƒ <q WWn t
 k
 rÞ | j | ƒ n XWq$t k
 r x. | j ƒ  D] \ } } t | | | ƒ qý Wq$Xn  | rZx- | j ƒ  D] \ } } t | | | ƒ q7Wn  d  S(   Niÿÿÿÿt   __setstate__i   (   Rø   R  Rj   R?   R{   R"  RS   RÐ   RÄ   t   internRh   t   updateR.  RÀ   t   setattr(	   R   Rø   R†   t   instt   setstatet	   slotstateR-   RÈ   RÉ   (    (    s   /usr/lib/python2.7/pickle.pyt
   load_buildÁ  s0    	

!	
c         C   s   |  j  |  j ƒ d  S(   N(   R½   R÷   (   R   (    (    s   /usr/lib/python2.7/pickle.pyt	   load_markè  s    c         C   s   |  j  j ƒ  } t | ƒ ‚ d  S(   N(   Rø   R  R   (   R   R   (    (    s   /usr/lib/python2.7/pickle.pyt	   load_stopì  s    (v   R   R   R   R   Rû   Re   Rý   Rÿ   RL   R  Ru   R  Rt   R  RŠ   R  R   R  RŒ   R  R”   R  R“   R  R‘   R  R’   R  Rš   R  R˜   R  R™   R  RŸ   Rä   R  R  Rž   R  R£   R  R¢   R  R¨   R   R¦   R!  R¡   R#  R¯   R$  R­   R%  t   TUPLE1R&  t   TUPLE2R'  t   TUPLE3R(  Rµ   R)  RÂ   R*  R¶   R,  RÃ   R2  R4  RÍ   R5  RÌ   R6  R~   R7  RÞ   R9  RÛ   R:  RÜ   R;  RÝ   R8  R3  R=  R   R>  R€   R?  R±   R@  t   DUPRA  R^   RB  R\   RC  R]   RD  RY   RE  RW   RF  RX   RH  R¹   RJ  R¿   RL  RÆ   RM  RÇ   RU  Rƒ   RV  R®   RW  RO   (    (    (    s   /usr/lib/python2.7/pickle.pyR	   A  sæ   				
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
		
		
	
	
	
	
	
	
			
	
	
	
	
	
	
	
	
	
	
	
	
	
	%
	
	R-  c           B   s   e  Z RS(    (   R   R   (    (    (    s   /usr/lib/python2.7/pickle.pyR-  ó  s   c         C   s!  |  d k r d S|  d k r¨ t  |  ƒ } | j d ƒ s= t ‚ d | j d ƒ } t | ƒ | } | d @r{ d | d } q°t | d d ƒ d	 k r°d
 | d } q°nt  |  ƒ } | j d ƒ sÊ t ‚ d | j d ƒ } t | ƒ | } | d @r| d 7} n  | d } |  d | >7}  |  d k s.t ‚ t  |  ƒ } d | j d ƒ } t | ƒ | } | | k  r†d d | | | d } n  t | d d ƒ d	 k  r°d | d } n  | j d ƒ rÏ| d d !} n
 | d } t | ƒ d @d k st |  | f ƒ ‚ t j | ƒ } | d d d … S(   sÓ  Encode a long to a two's complement little-endian binary string.
    Note that 0L is a special case, returning an empty string, to save a
    byte in the LONG1 pickling context.

    >>> encode_long(0L)
    ''
    >>> encode_long(255L)
    '\xff\x00'
    >>> encode_long(32767L)
    '\xff\x7f'
    >>> encode_long(-256L)
    '\x00\xff'
    >>> encode_long(-32768L)
    '\x00\x80'
    >>> encode_long(-128L)
    '\x80'
    >>> encode_long(127L)
    '\x7f'
    >>>
    i    Rx   t   0xi   R   i   t   0x0i   i   t   0x00i   l    R   t   0xffiÿÿÿÿN(   t   hexR  RR   R  RS   RD   t	   _binasciit	   unhexlify(   Ro   t   ashext
   njunkcharst   nibblest   nbitst
   newnibblest   binary(    (    s   /usr/lib/python2.7/pickle.pyR—   ú  sB    



(c         C   sp   t  |  ƒ } | d k r d St j |  d d d … ƒ } t | d ƒ } |  d d k rl | d | d >8} n  | S(	   s\  Decode a long from a two's complement little-endian binary string.

    >>> decode_long('')
    0L
    >>> decode_long("\xff\x00")
    255L
    >>> decode_long("\xff\x7f")
    32767L
    >>> decode_long("\x00\xff")
    -256L
    >>> decode_long("\x00\x80")
    -32768L
    >>> decode_long("\x80")
    -128L
    >>> decode_long("\x7f")
    127L
    i    l    Niÿÿÿÿi   s   €l    i   (   RS   Ra  t   hexlifyR	  (   R
  t   nbytesRc  Rœ   (    (    s   /usr/lib/python2.7/pickle.pyR  <  s    (   t   StringIOc         C   s   t  | | ƒ j |  ƒ d  S(   N(   R   R
   (   RP   RH   RI   (    (    s   /usr/lib/python2.7/pickle.pyR
   _  s    c         C   s)   t  ƒ  } t | | ƒ j |  ƒ | j ƒ  S(   N(   Rk  R   R
   t   getvalue(   RP   RI   RH   (    (    s   /usr/lib/python2.7/pickle.pyR   b  s    	c         C   s   t  |  ƒ j ƒ  S(   N(   R	   R   (   RH   (    (    s   /usr/lib/python2.7/pickle.pyR   g  s    c         C   s   t  |  ƒ } t | ƒ j ƒ  S(   N(   Rk  R	   R   (   Rv   RH   (    (    s   /usr/lib/python2.7/pickle.pyR   j  s    c          C   s   d d  l  }  |  j ƒ  S(   Niÿÿÿÿ(   t   doctestt   testmod(   Rm  (    (    s   /usr/lib/python2.7/pickle.pyt   _testp  s    Rñ   (j   R   t   __version__t   typest   copy_regR   R   R   R   t   marshalR×   Rä   t   ret   __all__t   format_versiont   compatible_formatsR@   R   R  t	   ExceptionR   R   R   R   t   org.python.coreR   RÙ   R?   Rê   t	   NameErrorR®   RO   R€   R±   R[  RŸ   R”   R“   R‘   Rš   R’   RŠ   Ru   Rt   R   R£   R¢   R¡   R¨   R¦   R¹   Rƒ   RÞ   RÃ   RÂ   R¿   R^   R\   RÍ   R]   R¶   Rµ   RÌ   RY   RW   RX   RÆ   R¯   R­   RÇ   Rž   RŽ   R   RL   R~   RÛ   RÜ   RÝ   RX  RY  RZ  RŒ   R   R˜   R™   R°   RI  t   dirRo   t   matchR   RË   Rò   RÕ   R	   R-  t   binasciiRa  R—   R  t	   cStringIORk  R
   R   R   Ro  R   (    (    (    s   /usr/lib/python2.7/pickle.pyt   <module>   sÞ   
		

5ÿ ÿ f		ÿ ³	B				                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                '''"Executable documentation" for the pickle module.

Extensive comments about the pickle protocols and pickle-machine opcodes
can be found here.  Some functions meant for external use:

genops(pickle)
   Generate all the opcodes in a pickle, as (opcode, arg, position) triples.

dis(pickle, out=None, memo=None, indentlevel=4)
   Print a symbolic disassembly of a pickle.
'''

__all__ = ['dis', 'genops', 'optimize']

# Other ideas:
#
# - A pickle verifier:  read a pickle and check it exhaustively for
#   well-formedness.  dis() does a lot of this already.
#
# - A protocol identifier:  examine a pickle and return its protocol number
#   (== the highest .proto attr value among all the opcodes in the pickle).
#   dis() already prints this info at the end.
#
# - A pickle optimizer:  for example, tuple-building code is sometimes more
#   elaborate than necessary, catering for the possibility that the tuple
#   is recursive.  Or lots of times a PUT is generated that's never accessed
#   by a later GET.


"""
"A pickle" is a program for a virtual pickle machine (PM, but more accurately
called an unpickling machine).  It's a sequence of opcodes, interpreted by the
PM, building an arbitrarily complex Python object.

For the most part, the PM is very simple:  there are no looping, testing, or
conditional instructions, no arithmetic and no function calls.  Opcodes are
executed once each, from first to last, until a STOP opcode is reached.

The PM has two data areas, "the stack" and "the memo".

Many opcodes push Python objects onto the stack; e.g., INT pushes a Python
integer object on the stack, whose value is gotten from a decimal string
literal immediately following the INT opcode in the pickle bytestream.  Other
opcodes take Python objects off the stack.  The result of unpickling is
whatever object is left on the stack when the final STOP opcode is executed.

The memo is simply an array of objects, or it can be implemented as a dict
mapping little integers to objects.  The memo serves as the PM's "long term
memory", and the little integers indexing the memo are akin to variable
names.  Some opcodes pop a stack object into the memo at a given index,
and others push a memo object at a given index onto the stack again.

At heart, that's all the PM has.  Subtleties arise for these reasons:

+ Object identity.  Objects can be arbitrarily complex, and subobjects
  may be shared (for example, the list [a, a] refers to the same object a
  twice).  It can be vital that unpickling recreate an isomorphic object
  graph, faithfully reproducing sharing.

+ Recursive objects.  For example, after "L = []; L.append(L)", L is a
  list, and L[0] is the same list.  This is related to the object identity
  point, and some sequences of pickle opcodes are subtle in order to
  get the right result in all cases.

+ Things pickle doesn't know everything about.  Examples of things pickle
  does know everything about are Python's builtin scalar and container
  types, like ints and tuples.  They generally have opcodes dedicated to
  them.  For things like module references and instances of user-defined
  classes, pickle's knowledge is limited.  Historically, many enhancements
  have been made to the pickle protocol in order to do a better (faster,
  and/or more compact) job on those.

+ Backward compatibility and micro-optimization.  As explained below,
  pickle opcodes never go away, not even when better ways to do a thing
  get invented.  The repertoire of the PM just keeps growing over time.
  For example, protocol 0 had two opcodes for building Python integers (INT
  and LONG), protocol 1 added three more for more-efficient pickling of short
  integers, and protocol 2 added two more for more-efficient pickling of
  long integers (before protocol 2, the only ways to pickle a Python long
  took time quadratic in the number of digits, for both pickling and
  unpickling).  "Opcode bloat" isn't so much a subtlety as a source of
  wearying complication.


Pickle protocols:

For compatibility, the meaning of a pickle opcode never changes.  Instead new
pickle opcodes get added, and each version's unpickler can handle all the
pickle opcodes in all protocol versions to date.  So old pickles continue to
be readable forever.  The pickler can generally be told to restrict itself to
the subset of opcodes available under previous protocol versions too, so that
users can create pickles under the current version readable by older
versions.  However, a pickle does not contain its version number embedded
within it.  If an older unpickler tries to read a pickle using a later
protocol, the result is most likely an exception due to seeing an unknown (in
the older unpickler) opcode.

The original pickle used what's now called "protocol 0", and what was called
"text mode" before Python 2.3.  The entire pickle bytestream is made up of
printable 7-bit ASCII characters, plus the newline character, in protocol 0.
That's why it was called text mode.  Protocol 0 is small and elegant, but
sometimes painfully inefficient.

The second major set of additions is now called "protocol 1", and was called
"binary mode" before Python 2.3.  This added many opcodes with arguments
consisting of arbitrary bytes, including NUL bytes and unprintable "high bit"
bytes.  Binary mode pickles can be substantially smaller than equivalent
text mode pickles, and sometimes faster too; e.g., BININT represents a 4-byte
int as 4 bytes following the opcode, which is cheaper to unpickle than the
(perhaps) 11-character decimal string attached to INT.  Protocol 1 also added
a number of opcodes that operate on many stack elements at once (like APPENDS
and SETITEMS), and "shortcut" opcodes (like EMPTY_DICT and EMPTY_TUPLE).

The third major set of additions came in Python 2.3, and is called "protocol
2".  This added:

- A better way to pickle instances of new-style classes (NEWOBJ).

- A way for a pickle to identify its protocol (PROTO).

- Time- and space- efficient pickling of long ints (LONG{1,4}).

- Shortcuts for small tuples (TUPLE{1,2,3}}.

- Dedicated opcodes for bools (NEWTRUE, NEWFALSE).

- The "extension registry", a vector of popular objects that can be pushed
  efficiently by index (EXT{1,2,4}).  This is akin to the memo and GET, but
  the registry contents are predefined (there's nothing akin to the memo's
  PUT).

Another independent change with Python 2.3 is the abandonment of any
pretense that it might be safe to load pickles received from untrusted
parties -- no sufficient security analysis has been done to guarantee
this and there isn't a use case that warrants the expense of such an
analysis.

To this end, all tests for __safe_for_unpickling__ or for
copy_reg.safe_constructors are removed from the unpickling code.
References to these variables in the descriptions below are to be seen
as describing unpickling in Python 2.2 and before.
"""

# Meta-rule:  Descriptions are stored in instances of descriptor objects,
# with plain constructors.  No meta-language is defined from which
# descriptors could be constructed.  If you want, e.g., XML, write a little
# program to generate XML from the objects.

##############################################################################
# Some pickle opcodes have an argument, following the opcode in the
# bytestream.  An argument is of a specific type, described by an instance
# of ArgumentDescriptor.  These are not to be confused with arguments taken
# off the stack -- ArgumentDescriptor applies only to arguments embedded in
# the opcode stream, immediately following an opcode.

# Represents the number of bytes consumed by an argument delimited by the
# next newline character.
UP_TO_NEWLINE = -1

# Represents the number of bytes consumed by a two-argument opcode where
# the first argument gives the number of bytes in the second argument.
TAKEN_FROM_ARGUMENT1 = -2   # num bytes is 1-byte unsigned int
TAKEN_FROM_ARGUMENT4 = -3   # num bytes is 4-byte signed little-endian int

class ArgumentDescriptor(object):
    __slots__ = (
        # name of descriptor record, also a module global name; a string
        'name',

        # length of argument, in bytes; an int; UP_TO_NEWLINE and
        # TAKEN_FROM_ARGUMENT{1,4} are negative values for variable-length
        # cases
        'n',

        # a function taking a file-like object, reading this kind of argument
        # from the object at the current position, advancing the current
        # position by n bytes, and returning the value of the argument
        'reader',

        # human-readable docs for this arg descriptor; a string
        'doc',
    )

    def __init__(self, name, n, reader, doc):
        assert isinstance(name, str)
        self.name = name

        assert isinstance(n, int) and (n >= 0 or
                                       n in (UP_TO_NEWLINE,
                                             TAKEN_FROM_ARGUMENT1,
                                             TAKEN_FROM_ARGUMENT4))
        self.n = n

        self.reader = reader

        assert isinstance(doc, str)
        self.doc = doc

from struct import unpack as _unpack

def read_uint1(f):
    r"""
    >>> import StringIO
    >>> read_uint1(StringIO.StringIO('\xff'))
    255
    """

    data = f.read(1)
    if data:
        return ord(data)
    raise ValueError("not enough data in stream to read uint1")

uint1 = ArgumentDescriptor(
            name='uint1',
            n=1,
            reader=read_uint1,
            doc="One-byte unsigned integer.")


def read_uint2(f):
    r"""
    >>> import StringIO
    >>> read_uint2(StringIO.StringIO('\xff\x00'))
    255
    >>> read_uint2(StringIO.StringIO('\xff\xff'))
    65535
    """

    data = f.read(2)
    if len(data) == 2:
        return _unpack("<H", data)[0]
    raise ValueError("not enough data in stream to read uint2")

uint2 = ArgumentDescriptor(
            name='uint2',
            n=2,
            reader=read_uint2,
            doc="Two-byte unsigned integer, little-endian.")


def read_int4(f):
    r"""
    >>> import StringIO
    >>> read_int4(StringIO.StringIO('\xff\x00\x00\x00'))
    255
    >>> read_int4(StringIO.StringIO('\x00\x00\x00\x80')) == -(2**31)
    True
    """

    data = f.read(4)
    if len(data) == 4:
        return _unpack("<i", data)[0]
    raise ValueError("not enough data in stream to read int4")

int4 = ArgumentDescriptor(
           name='int4',
           n=4,
           reader=read_int4,
           doc="Four-byte signed integer, little-endian, 2's complement.")


def read_stringnl(f, decode=True, stripquotes=True):
    r"""
    >>> import StringIO
    >>> read_stringnl(StringIO.StringIO("'abcd'\nefg\n"))
    'abcd'

    >>> read_stringnl(StringIO.StringIO("\n"))
    Traceback (most recent call last):
    ...
    ValueError: no string quotes around ''

    >>> read_stringnl(StringIO.StringIO("\n"), stripquotes=False)
    ''

    >>> read_stringnl(StringIO.StringIO("''\n"))
    ''

    >>> read_stringnl(StringIO.StringIO('"abcd"'))
    Traceback (most recent call last):
    ...
    ValueError: no newline found when trying to read stringnl

    Embedded escapes are undone in the result.
    >>> read_stringnl(StringIO.StringIO(r"'a\n\\b\x00c\td'" + "\n'e'"))
    'a\n\\b\x00c\td'
    """

    data = f.readline()
    if not data.endswith('\n'):
        raise ValueError("no newline found when trying to read stringnl")
    data = data[:-1]    # lose the newline

    if stripquotes:
        for q in "'\"":
            if data.startswith(q):
                if not data.endswith(q):
                    raise ValueError("strinq quote %r not found at both "
                                     "ends of %r" % (q, data))
                data = data[1:-1]
                break
        else:
            raise ValueError("no string quotes around %r" % data)

    # I'm not sure when 'string_escape' was added to the std codecs; it's
    # crazy not to use it if it's there.
    if decode:
        data = data.decode('string_escape')
    return data

stringnl = ArgumentDescriptor(
               name='stringnl',
               n=UP_TO_NEWLINE,
               reader=read_stringnl,
               doc="""A newline-terminated string.

                   This is a repr-style string, with embedded escapes, and
                   bracketing quotes.
                   """)

def read_stringnl_noescape(f):
    return read_stringnl(f, decode=False, stripquotes=False)

stringnl_noescape = ArgumentDescriptor(
                        name='stringnl_noescape',
                        n=UP_TO_NEWLINE,
                        reader=read_stringnl_noescape,
                        doc="""A newline-terminated string.

                        This is a str-style string, without embedded escapes,
                        or bracketing quotes.  It should consist solely of
                        printable ASCII characters.
                        """)

def read_stringnl_noescape_pair(f):
    r"""
    >>> import StringIO
    >>> read_stringnl_noescape_pair(StringIO.StringIO("Queue\nEmpty\njunk"))
    'Queue Empty'
    """

    return "%s %s" % (read_stringnl_noescape(f), read_stringnl_noescape(f))

stringnl_noescape_pair = ArgumentDescriptor(
                             name='stringnl_noescape_pair',
                             n=UP_TO_NEWLINE,
                             reader=read_stringnl_noescape_pair,
                             doc="""A pair of newline-terminated strings.

                             These are str-style strings, without embedded
                             escapes, or bracketing quotes.  They should
                             consist solely of printable ASCII characters.
                             The pair is returned as a single string, with
                             a single blank separating the two strings.
                             """)

def read_string4(f):
    r"""
    >>> import StringIO
    >>> read_string4(StringIO.StringIO("\x00\x00\x00\x00abc"))
    ''
    >>> read_string4(StringIO.StringIO("\x03\x00\x00\x00abcdef"))
    'abc'
    >>> read_string4(StringIO.StringIO("\x00\x00\x00\x03abcdef"))
    Traceback (most recent call last):
    ...
    ValueError: expected 50331648 bytes in a string4, but only 6 remain
    """

    n = read_int4(f)
    if n < 0:
        raise ValueError("string4 byte count < 0: %d" % n)
    data = f.read(n)
    if len(data) == n:
        return data
    raise ValueError("expected %d bytes in a string4, but only %d remain" %
                     (n, len(data)))

string4 = ArgumentDescriptor(
              name="string4",
              n=TAKEN_FROM_ARGUMENT4,
              reader=read_string4,
              doc="""A counted string.

              The first argument is a 4-byte little-endian signed int giving
              the number of bytes in the string, and the second argument is
              that many bytes.
              """)


def read_string1(f):
    r"""
    >>> import StringIO
    >>> read_string1(StringIO.StringIO("\x00"))
    ''
    >>> read_string1(StringIO.StringIO("\x03abcdef"))
    'abc'
    """

    n = read_uint1(f)
    assert n >= 0
    data = f.read(n)
    if len(data) == n:
        return data
    raise ValueError("expected %d bytes in a string1, but only %d remain" %
                     (n, len(data)))

string1 = ArgumentDescriptor(
              name="string1",
              n=TAKEN_FROM_ARGUMENT1,
              reader=read_string1,
              doc="""A counted string.

              The first argument is a 1-byte unsigned int giving the number
              of bytes in the string, and the second argument is that many
              bytes.
              """)


def read_unicodestringnl(f):
    r"""
    >>> import StringIO
    >>> read_unicodestringnl(StringIO.StringIO("abc\uabcd\njunk"))
    u'abc\uabcd'
    """

    data = f.readline()
    if not data.endswith('\n'):
        raise ValueError("no newline found when trying to read "
                         "unicodestringnl")
    data = data[:-1]    # lose the newline
    return unicode(data, 'raw-unicode-escape')

unicodestringnl = ArgumentDescriptor(
                      name='unicodestringnl',
                      n=UP_TO_NEWLINE,
                      reader=read_unicodestringnl,
                      doc="""A newline-terminated Unicode string.

                      This is raw-unicode-escape encoded, so consists of
                      printable ASCII characters, and may contain embedded
                      escape sequences.
                      """)

def read_unicodestring4(f):
    r"""
    >>> import StringIO
    >>> s = u'abcd\uabcd'
    >>> enc = s.encode('utf-8')
    >>> enc
    'abcd\xea\xaf\x8d'
    >>> n = chr(len(enc)) + chr(0) * 3  # little-endian 4-byte length
    >>> t = read_unicodestring4(StringIO.StringIO(n + enc + 'junk'))
    >>> s == t
    True

    >>> read_unicodestring4(StringIO.StringIO(n + enc[:-1]))
    Traceback (most recent call last):
    ...
    ValueError: expected 7 bytes in a unicodestring4, but only 6 remain
    """

    n = read_int4(f)
    if n < 0:
        raise ValueError("unicodestring4 byte count < 0: %d" % n)
    data = f.read(n)
    if len(data) == n:
        return unicode(data, 'utf-8')
    raise ValueError("expected %d bytes in a unicodestring4, but only %d "
                     "remain" % (n, len(data)))

unicodestring4 = ArgumentDescriptor(
                    name="unicodestring4",
                    n=TAKEN_FROM_ARGUMENT4,
                    reader=read_unicodestring4,
                    doc="""A counted Unicode string.

                    The first argument is a 4-byte little-endian signed int
                    giving the number of bytes in the string, and the second
                    argument-- the UTF-8 encoding of the Unicode string --
                    contains that many bytes.
                    """)


def read_decimalnl_short(f):
    r"""
    >>> import StringIO
    >>> read_decimalnl_short(StringIO.StringIO("1234\n56"))
    1234

    >>> read_decimalnl_short(StringIO.StringIO("1234L\n56"))
    Traceback (most recent call last):
    ...
    ValueError: trailing 'L' not allowed in '1234L'
    """

    s = read_stringnl(f, decode=False, stripquotes=False)
    if s.endswith("L"):
        raise ValueError("trailing 'L' not allowed in %r" % s)

    # It's not necessarily true that the result fits in a Python short int:
    # the pickle may have been written on a 64-bit box.  There's also a hack
    # for True and False here.
    if s == "00":
        return False
    elif s == "01":
        return True

    try:
        return int(s)
    except OverflowError:
        return long(s)

def read_decimalnl_long(f):
    r"""
    >>> import StringIO

    >>> read_decimalnl_long(StringIO.StringIO("1234\n56"))
    Traceback (most recent call last):
    ...
    ValueError: trailing 'L' required in '1234'

    Someday the trailing 'L' will probably go away from this output.

    >>> read_decimalnl_long(StringIO.StringIO("1234L\n56"))
    1234L

    >>> read_decimalnl_long(StringIO.StringIO("123456789012345678901234L\n6"))
    123456789012345678901234L
    """

    s = read_stringnl(f, decode=False, stripquotes=False)
    if not s.endswith("L"):
        raise ValueError("trailing 'L' required in %r" % s)
    return long(s)


decimalnl_short = ArgumentDescriptor(
                      name='decimalnl_short',
                      n=UP_TO_NEWLINE,
                      reader=read_decimalnl_short,
                      doc="""A newline-terminated decimal integer literal.

                          This never has a trailing 'L', and the integer fit
                          in a short Python int on the box where the pickle
                          was written -- but there's no guarantee it will fit
                          in a short Python int on the box where the pickle
                          is read.
                          """)

decimalnl_long = ArgumentDescriptor(
                     name='decimalnl_long',
                     n=UP_TO_NEWLINE,
                     reader=read_decimalnl_long,
                     doc="""A newline-terminated decimal integer literal.

                         This has a trailing 'L', and can represent integers
                         of any size.
                         """)


def read_floatnl(f):
    r"""
    >>> import StringIO
    >>> read_floatnl(StringIO.StringIO("-1.25\n6"))
    -1.25
    """
    s = read_stringnl(f, decode=False, stripquotes=False)
    return float(s)

floatnl = ArgumentDescriptor(
              name='floatnl',
              n=UP_TO_NEWLINE,
              reader=read_floatnl,
              doc="""A newline-terminated decimal floating literal.

              In general this requires 17 significant digits for roundtrip
              identity, and pickling then unpickling infinities, NaNs, and
              minus zero doesn't work across boxes, or on some boxes even
              on itself (e.g., Windows can't read the strings it produces
              for infinities or NaNs).
              """)

def read_float8(f):
    r"""
    >>> import StringIO, struct
    >>> raw = struct.pack(">d", -1.25)
    >>> raw
    '\xbf\xf4\x00\x00\x00\x00\x00\x00'
    >>> read_float8(StringIO.StringIO(raw + "\n"))
    -1.25
    """

    data = f.read(8)
    if len(data) == 8:
        return _unpack(">d", data)[0]
    raise ValueError("not enough data in stream to read float8")


float8 = ArgumentDescriptor(
             name='float8',
             n=8,
             reader=read_float8,
             doc="""An 8-byte binary representation of a float, big-endian.

             The format is unique to Python, and shared with the struct
             module (format string '>d') "in theory" (the struct and cPickle
             implementations don't share the code -- they should).  It's
             strongly related to the IEEE-754 double format, and, in normal
             cases, is in fact identical to the big-endian 754 double format.
             On other boxes the dynamic range is limited to that of a 754
             double, and "add a half and chop" rounding is used to reduce
             the precision to 53 bits.  However, even on a 754 box,
             infinities, NaNs, and minus zero may not be handled correctly
             (may not survive roundtrip pickling intact).
             """)

# Protocol 2 formats

from pickle import decode_long

def read_long1(f):
    r"""
    >>> import StringIO
    >>> read_long1(StringIO.StringIO("\x00"))
    0L
    >>> read_long1(StringIO.StringIO("\x02\xff\x00"))
    255L
    >>> read_long1(StringIO.StringIO("\x02\xff\x7f"))
    32767L
    >>> read_long1(StringIO.StringIO("\x02\x00\xff"))
    -256L
    >>> read_long1(StringIO.StringIO("\x02\x00\x80"))
    -32768L
    """

    n = read_uint1(f)
    data = f.read(n)
    if len(data) != n:
        raise ValueError("not enough data in stream to read long1")
    return decode_long(data)

long1 = ArgumentDescriptor(
    name="long1",
    n=TAKEN_FROM_ARGUMENT1,
    reader=read_long1,
    doc="""A binary long, little-endian, using 1-byte size.

    This first reads one byte as an unsigned size, then reads that
    many bytes and interprets them as a little-endian 2's-complement long.
    If the size is 0, that's taken as a shortcut for the long 0L.
    """)

def read_long4(f):
    r"""
    >>> import StringIO
    >>> read_long4(StringIO.StringIO("\x02\x00\x00\x00\xff\x00"))
    255L
    >>> read_long4(StringIO.StringIO("\x02\x00\x00\x00\xff\x7f"))
    32767L
    >>> read_long4(StringIO.StringIO("\x02\x00\x00\x00\x00\xff"))
    -256L
    >>> read_long4(StringIO.StringIO("\x02\x00\x00\x00\x00\x80"))
    -32768L
    >>> read_long1(StringIO.StringIO("\x00\x00\x00\x00"))
    0L
    """

    n = read_int4(f)
    if n < 0:
        raise ValueError("long4 byte count < 0: %d" % n)
    data = f.read(n)
    if len(data) != n:
        raise ValueError("not enough data in stream to read long4")
    return decode_long(data)

long4 = ArgumentDescriptor(
    name="long4",
    n=TAKEN_FROM_ARGUMENT4,
    reader=read_long4,
    doc="""A binary representation of a long, little-endian.

    This first reads four bytes as a signed size (but requires the
    size to be >= 0), then reads that many bytes and interprets them
    as a little-endian 2's-complement long.  If the size is 0, that's taken
    as a shortcut for the long 0L, although LONG1 should really be used
    then instead (and in any case where # of bytes < 256).
    """)


##############################################################################
# Object descriptors.  The stack used by the pickle machine holds objects,
# and in the stack_before and stack_after attributes of OpcodeInfo
# descriptors we need names to describe the various types of objects that can
# appear on the stack.

class StackObject(object):
    __slots__ = (
        # name of descriptor record, for info only
        'name',

        # type of object, or tuple of type objects (meaning the object can
        # be of any type in the tuple)
        'obtype',

        # human-readable docs for this kind of stack object; a string
        'doc',
    )

    def __init__(self, name, obtype, doc):
        assert isinstance(name, str)
        self.name = name

        assert isinstance(obtype, type) or isinstance(obtype, tuple)
        if isinstance(obtype, tuple):
            for contained in obtype:
                assert isinstance(contained, type)
        self.obtype = obtype

        assert isinstance(doc, str)
        self.doc = doc

    def __repr__(self):
        return self.name


pyint = StackObject(
            name='int',
            obtype=int,
            doc="A short (as opposed to long) Python integer object.")

pylong = StackObject(
             name='long',
             obtype=long,
             doc="A long (as opposed to short) Python integer object.")

pyinteger_or_bool = StackObject(
                        name='int_or_bool',
                        obtype=(int, long, bool),
                        doc="A Python integer object (short or long), or "
                            "a Python bool.")

pybool = StackObject(
             name='bool',
             obtype=(bool,),
             doc="A Python bool object.")

pyfloat = StackObject(
              name='float',
              obtype=float,
              doc="A Python float object.")

pystring = StackObject(
               name='str',
               obtype=str,
               doc="A Python string object.")

pyunicode = StackObject(
                name='unicode',
                obtype=unicode,
                doc="A Python Unicode string object.")

pynone = StackObject(
             name="None",
             obtype=type(None),
             doc="The Python None object.")

pytuple = StackObject(
              name="tuple",
              obtype=tuple,
              doc="A Python tuple object.")

pylist = StackObject(
             name="list",
             obtype=list,
             doc="A Python list object.")

pydict = StackObject(
             name="dict",
             obtype=dict,
             doc="A Python dict object.")

anyobject = StackObject(
                name='any',
                obtype=object,
                doc="Any kind of object whatsoever.")

markobject = StackObject(
                 name="mark",
                 obtype=StackObject,
                 doc="""'The mark' is a unique object.

                 Opcodes that operate on a variable number of objects
                 generally don't embed the count of objects in the opcode,
                 or pull it off the stack.  Instead the MARK opcode is used
                 to push a special marker object on the stack, and then
                 some other opcodes grab all the objects from the top of
                 the stack down to (but not including) the topmost marker
                 object.
                 """)

stackslice = StackObject(
                 name="stackslice",
                 obtype=StackObject,
                 doc="""An object representing a contiguous slice of the stack.

                 This is used in conjunction with markobject, to represent all
                 of the stack following the topmost markobject.  For example,
                 the POP_MARK opcode changes the stack from

                     [..., markobject, stackslice]
                 to
                     [...]

                 No matter how many object are on the stack after the topmost
                 markobject, POP_MARK gets rid of all of them (including the
                 topmost markobject too).
                 """)

##############################################################################
# Descriptors for pickle opcodes.

class OpcodeInfo(object):

    __slots__ = (
        # symbolic name of opcode; a string
        'name',

        # the code used in a bytestream to represent the opcode; a
        # one-character string
        'code',

        # If the opcode has an argument embedded in the byte string, an
        # instance of ArgumentDescriptor specifying its type.  Note that
        # arg.reader(s) can be used to read and decode the argument from
        # the bytestream s, and arg.doc documents the format of the raw
        # argument bytes.  If the opcode doesn't have an argument embedded
        # in the bytestream, arg should be None.
        'arg',

        # what the stack looks like before this opcode runs; a list
        'stack_before',

        # what the stack looks like after this opcode runs; a list
        'stack_after',

        # the protocol number in which this opcode was introduced; an int
        'proto',

        # human-readable docs for this opcode; a string
        'doc',
    )

    def __init__(self, name, code, arg,
                 stack_before, stack_after, proto, doc):
        assert isinstance(name, str)
        self.name = name

        assert isinstance(code, str)
        assert len(code) == 1
        self.code = code

        assert arg is None or isinstance(arg, ArgumentDescriptor)
        self.arg = arg

        assert isinstance(stack_before, list)
        for x in stack_before:
            assert isinstance(x, StackObject)
        self.stack_before = stack_before

        assert isinstance(stack_after, list)
        for x in stack_after:
            assert isinstance(x, StackObject)
        self.stack_after = stack_after

        assert isinstance(proto, int) and 0 <= proto <= 2
        self.proto = proto

        assert isinstance(doc, str)
        self.doc = doc

I = OpcodeInfo
opcodes = [

    # Ways to spell integers.

    I(name='INT',
      code='I',
      arg=decimalnl_short,
      stack_before=[],
      stack_after=[pyinteger_or_bool],
      proto=0,
      doc="""Push an integer or bool.

      The argument is a newline-terminated decimal literal string.

      The intent may have been that this always fit in a short Python int,
      but INT can be generated in pickles written on a 64-bit box that
      require a Python long on a 32-bit box.  The difference between this
      and LONG then is that INT skips a trailing 'L', and produces a short
      int whenever possible.

      Another difference is due to that, when bool was introduced as a
      distinct type in 2.3, builtin names True and False were also added to
      2.2.2, mapping to ints 1 and 0.  For compatibility in both directions,
      True gets pickled as INT + "I01\\n", and False as INT + "I00\\n".
      Leading zeroes are never produced for a genuine integer.  The 2.3
      (and later) unpicklers special-case these and return bool instead;
      earlier unpicklers ignore the leading "0" and return the int.
      """),

    I(name='BININT',
      code='J',
      arg=int4,
      stack_before=[],
      stack_after=[pyint],
      proto=1,
      doc="""Push a four-byte signed integer.

      This handles the full range of Python (short) integers on a 32-bit
      box, directly as binary bytes (1 for the opcode and 4 for the integer).
      If the integer is non-negative and fits in 1 or 2 bytes, pickling via
      BININT1 or BININT2 saves space.
      """),

    I(name='BININT1',
      code='K',
      arg=uint1,
      stack_before=[],
      stack_after=[pyint],
      proto=1,
      doc="""Push a one-byte unsigned integer.

      This is a space optimization for pickling very small non-negative ints,
      in range(256).
      """),

    I(name='BININT2',
      code='M',
      arg=uint2,
      stack_before=[],
      stack_after=[pyint],
      proto=1,
      doc="""Push a two-byte unsigned integer.

      This is a space optimization for pickling small positive ints, in
      range(256, 2**16).  Integers in range(256) can also be pickled via
      BININT2, but BININT1 instead saves a byte.
      """),

    I(name='LONG',
      code='L',
      arg=decimalnl_long,
      stack_before=[],
      stack_after=[pylong],
      proto=0,
      doc="""Push a long integer.

      The same as INT, except that the literal ends with 'L', and always
      unpickles to a Python long.  There doesn't seem a real purpose to the
      trailing 'L'.

      Note that LONG takes time quadratic in the number of digits when
      unpickling (this is simply due to the nature of decimal->binary
      conversion).  Proto 2 added linear-time (in C; still quadratic-time
      in Python) LONG1 and LONG4 opcodes.
      """),

    I(name="LONG1",
      code='\x8a',
      arg=long1,
      stack_before=[],
      stack_after=[pylong],
      proto=2,
      doc="""Long integer using one-byte length.

      A more efficient encoding of a Python long; the long1 encoding
      says it all."""),

    I(name="LONG4",
      code='\x8b',
      arg=long4,
      stack_before=[],
      stack_after=[pylong],
      proto=2,
      doc="""Long integer using found-byte length.

      A more efficient encoding of a Python long; the long4 encoding
      says it all."""),

    # Ways to spell strings (8-bit, not Unicode).

    I(name='STRING',
      code='S',
      arg=stringnl,
      stack_before=[],
      stack_after=[pystring],
      proto=0,
      doc="""Push a Python string object.

      The argument is a repr-style string, with bracketing quote characters,
      and perhaps embedded escapes.  The argument extends until the next
      newline character.
      """),

    I(name='BINSTRING',
      code='T',
      arg=string4,
      stack_before=[],
      stack_after=[pystring],
      proto=1,
      doc="""Push a Python string object.

      There are two arguments:  the first is a 4-byte little-endian signed int
      giving the number of bytes in the string, and the second is that many
      bytes, which are taken literally as the string content.
      """),

    I(name='SHORT_BINSTRING',
      code='U',
      arg=string1,
      stack_before=[],
      stack_after=[pystring],
      proto=1,
      doc="""Push a Python string object.

      There are two arguments:  the first is a 1-byte unsigned int giving
      the number of bytes in the string, and the second is that many bytes,
      which are taken literally as the string content.
      """),

    # Ways to spell None.

    I(name='NONE',
      code='N',
      arg=None,
      stack_before=[],
      stack_after=[pynone],
      proto=0,
      doc="Push None on the stack."),

    # Ways to spell bools, starting with proto 2.  See INT for how this was
    # done before proto 2.

    I(name='NEWTRUE',
      code='\x88',
      arg=None,
      stack_before=[],
      stack_after=[pybool],
      proto=2,
      doc="""True.

      Push True onto the stack."""),

    I(name='NEWFALSE',
      code='\x89',
      arg=None,
      stack_before=[],
      stack_after=[pybool],
      proto=2,
      doc="""True.

      Push False onto the stack."""),

    # Ways to spell Unicode strings.

    I(name='UNICODE',
      code='V',
      arg=unicodestringnl,
      stack_before=[],
      stack_after=[pyunicode],
      proto=0,  # this may be pure-text, but it's a later addition
      doc="""Push a Python Unicode string object.

      The argument is a raw-unicode-escape encoding of a Unicode string,
      and so may contain embedded escape sequences.  The argument extends
      until the next newline character.
      """),

    I(name='BINUNICODE',
      code='X',
      arg=unicodestring4,
      stack_before=[],
      stack_after=[pyunicode],
      proto=1,
      doc="""Push a Python Unicode string object.

      There are two arguments:  the first is a 4-byte little-endian signed int
      giving the number of bytes in the string.  The second is that many
      bytes, and is the UTF-8 encoding of the Unicode string.
      """),

    # Ways to spell floats.

    I(name='FLOAT',
      code='F',
      arg=floatnl,
      stack_before=[],
      stack_after=[pyfloat],
      proto=0,
      doc="""Newline-terminated decimal float literal.

      The argument is repr(a_float), and in general requires 17 significant
      digits for roundtrip conversion to be an identity (this is so for
      IEEE-754 double precision values, which is what Python float maps to
      on most boxes).

      In general, FLOAT cannot be used to transport infinities, NaNs, or
      minus zero across boxes (or even on a single box, if the platform C
      library can't read the strings it produces for such things -- Windows
      is like that), but may do less damage than BINFLOAT on boxes with
      greater precision or dynamic range than IEEE-754 double.
      """),

    I(name='BINFLOAT',
      code='G',
      arg=float8,
      stack_before=[],
      stack_after=[pyfloat],
      proto=1,
      doc="""Float stored in binary form, with 8 bytes of data.

      This generally requires less than half the space of FLOAT encoding.
      In general, BINFLOAT cannot be used to transport infinities, NaNs, or
      minus zero, raises an exception if the exponent exceeds the range of
      an IEEE-754 double, and retains no more than 53 bits of precision (if
      there are more than that, "add a half and chop" rounding is used to
      cut it back to 53 significant bits).
      """),

    # Ways to build lists.

    I(name='EMPTY_LIST',
      code=']',
      arg=None,
      stack_before=[],
      stack_after=[pylist],
      proto=1,
      doc="Push an empty list."),

    I(name='APPEND',
      code='a',
      arg=None,
      stack_before=[pylist, anyobject],
      stack_after=[pylist],
      proto=0,
      doc="""Append an object to a list.

      Stack before:  ... pylist anyobject
      Stack after:   ... pylist+[anyobject]

      although pylist is really extended in-place.
      """),

    I(name='APPENDS',
      code='e',
      arg=None,
      stack_before=[pylist, markobject, stackslice],
      stack_after=[pylist],
      proto=1,
      doc="""Extend a list by a slice of stack objects.

      Stack before:  ... pylist markobject stackslice
      Stack after:   ... pylist+stackslice

      although pylist is really extended in-place.
      """),

    I(name='LIST',
      code='l',
      arg=None,
      stack_before=[markobject, stackslice],
      stack_after=[pylist],
      proto=0,
      doc="""Build a list out of the topmost stack slice, after markobject.

      All the stack entries following the topmost markobject are placed into
      a single Python list, which single list object replaces all of the
      stack from the topmost markobject onward.  For example,

      Stack before: ... markobject 1 2 3 'abc'
      Stack after:  ... [1, 2, 3, 'abc']
      """),

    # Ways to build tuples.

    I(name='EMPTY_TUPLE',
      code=')',
      arg=None,
      stack_before=[],
      stack_after=[pytuple],
      proto=1,
      doc="Push an empty tuple."),

    I(name='TUPLE',
      code='t',
      arg=None,
      stack_before=[markobject, stackslice],
      stack_after=[pytuple],
      proto=0,
      doc="""Build a tuple out of the topmost stack slice, after markobject.

      All the stack entries following the topmost markobject are placed into
      a single Python tuple, which single tuple object replaces all of the
      stack from the topmost markobject onward.  For example,

      Stack before: ... markobject 1 2 3 'abc'
      Stack after:  ... (1, 2, 3, 'abc')
      """),

    I(name='TUPLE1',
      code='\x85',
      arg=None,
      stack_before=[anyobject],
      stack_after=[pytuple],
      proto=2,
      doc="""Build a one-tuple out of the topmost item on the stack.

      This code pops one value off the stack and pushes a tuple of
      length 1 whose one item is that value back onto it.  In other
      words:

          stack[-1] = tuple(stack[-1:])
      """),

    I(name='TUPLE2',
      code='\x86',
      arg=None,
      stack_before=[anyobject, anyobject],
      stack_after=[pytuple],
      proto=2,
      doc="""Build a two-tuple out of the top two items on the stack.

      This code pops two values off the stack and pushes a tuple of
      length 2 whose items are those values back onto it.  In other
      words:

          stack[-2:] = [tuple(stack[-2:])]
      """),

    I(name='TUPLE3',
      code='\x87',
      arg=None,
      stack_before=[anyobject, anyobject, anyobject],
      stack_after=[pytuple],
      proto=2,
      doc="""Build a three-tuple out of the top three items on the stack.

      This code pops three values off the stack and pushes a tuple of
      length 3 whose items are those values back onto it.  In other
      words:

          stack[-3:] = [tuple(stack[-3:])]
      """),

    # Ways to build dicts.

    I(name='EMPTY_DICT',
      code='}',
      arg=None,
      stack_before=[],
      stack_after=[pydict],
      proto=1,
      doc="Push an empty dict."),

    I(name='DICT',
      code='d',
      arg=None,
      stack_before=[markobject, stackslice],
      stack_after=[pydict],
      proto=0,
      doc="""Build a dict out of the topmost stack slice, after markobject.

      All the stack entries following the topmost markobject are placed into
      a single Python dict, which single dict object replaces all of the
      stack from the topmost markobject onward.  The stack slice alternates
      key, value, key, value, ....  For example,

      Stack before: ... markobject 1 2 3 'abc'
      Stack after:  ... {1: 2, 3: 'abc'}
      """),

    I(name='SETITEM',
      code='s',
      arg=None,
      stack_before=[pydict, anyobject, anyobject],
      stack_after=[pydict],
      proto=0,
      doc="""Add a key+value pair to an existing dict.

      Stack before:  ... pydict key value
      Stack after:   ... pydict

      where pydict has been modified via pydict[key] = value.
      """),

    I(name='SETITEMS',
      code='u',
      arg=None,
      stack_before=[pydict, markobject, stackslice],
      stack_after=[pydict],
      proto=1,
      doc="""Add an arbitrary number of key+value pairs to an existing dict.

      The slice of the stack following the topmost markobject is taken as
      an alternating sequence of keys and values, added to the dict
      immediately under the topmost markobject.  Everything at and after the
      topmost markobject is popped, leaving the mutated dict at the top
      of the stack.

      Stack before:  ... pydict markobject key_1 value_1 ... key_n value_n
      Stack after:   ... pydict

      where pydict has been modified via pydict[key_i] = value_i for i in
      1, 2, ..., n, and in that order.
      """),

    # Stack manipulation.

    I(name='POP',
      code='0',
      arg=None,
      stack_before=[anyobject],
      stack_after=[],
      proto=0,
      doc="Discard the top stack item, shrinking the stack by one item."),

    I(name='DUP',
      code='2',
      arg=None,
      stack_before=[anyobject],
      stack_after=[anyobject, anyobject],
      proto=0,
      doc="Push the top stack item onto the stack again, duplicating it."),

    I(name='MARK',
      code='(',
      arg=None,
      stack_before=[],
      stack_after=[markobject],
      proto=0,
      doc="""Push markobject onto the stack.

      markobject is a unique object, used by other opcodes to identify a
      region of the stack containing a variable number of objects for them
      to work on.  See markobject.doc for more detail.
      """),

    I(name='POP_MARK',
      code='1',
      arg=None,
      stack_before=[markobject, stackslice],
      stack_after=[],
      proto=1,
      doc="""Pop all the stack objects at and above the topmost markobject.

      When an opcode using a variable number of stack objects is done,
      POP_MARK is used to remove those objects, and to remove the markobject
      that delimited their starting position on the stack.
      """),

    # Memo manipulation.  There are really only two operations (get and put),
    # each in all-text, "short binary", and "long binary" flavors.

    I(name='GET',
      code='g',
      arg=decimalnl_short,
      stack_before=[],
      stack_after=[anyobject],
      proto=0,
      doc="""Read an object from the memo and push it on the stack.

      The index of the memo object to push is given by the newline-terminated
      decimal string following.  BINGET and LONG_BINGET are space-optimized
      versions.
      """),

    I(name='BINGET',
      code='h',
      arg=uint1,
      stack_before=[],
      stack_after=[anyobject],
      proto=1,
      doc="""Read an object from the memo and push it on the stack.

      The index of the memo object to push is given by the 1-byte unsigned
      integer following.
      """),

    I(name='LONG_BINGET',
      code='j',
      arg=int4,
      stack_before=[],
      stack_after=[anyobject],
      proto=1,
      doc="""Read an object from the memo and push it on the stack.

      The index of the memo object to push is given by the 4-byte signed
      little-endian integer following.
      """),

    I(name='PUT',
      code='p',
      arg=decimalnl_short,
      stack_before=[],
      stack_after=[],
      proto=0,
      doc="""Store the stack top into the memo.  The stack is not popped.

      The index of the memo location to write into is given by the newline-
      terminated decimal string following.  BINPUT and LONG_BINPUT are
      space-optimized versions.
      """),

    I(name='BINPUT',
      code='q',
      arg=uint1,
      stack_before=[],
      stack_after=[],
      proto=1,
      doc="""Store the stack top into the memo.  The stack is not popped.

      The index of the memo location to write into is given by the 1-byte
      unsigned integer following.
      """),

    I(name='LONG_BINPUT',
      code='r',
      arg=int4,
      stack_before=[],
      stack_after=[],
      proto=1,
      doc="""Store the stack top into the memo.  The stack is not popped.

      The index of the memo location to write into is given by the 4-byte
      signed little-endian integer following.
      """),

    # Access the extension registry (predefined objects).  Akin to the GET
    # family.

    I(name='EXT1',
      code='\x82',
      arg=uint1,
      stack_before=[],
      stack_after=[anyobject],
      proto=2,
      doc="""Extension code.

      This code and the similar EXT2 and EXT4 allow using a registry
      of popular objects that are pickled by name, typically classes.
      It is envisioned that through a global negotiation and
      registration process, third parties can set up a mapping between
      ints and object names.

      In order to guarantee pickle interchangeability, the extension
      code registry ought to be global, although a range of codes may
      be reserved for private use.

      EXT1 has a 1-byte integer argument.  This is used to index into the
      extension registry, and the object at that index is pushed on the stack.
      """),

    I(name='EXT2',
      code='\x83',
      arg=uint2,
      stack_before=[],
      stack_after=[anyobject],
      proto=2,
      doc="""Extension code.

      See EXT1.  EXT2 has a two-byte integer argument.
      """),

    I(name='EXT4',
      code='\x84',
      arg=int4,
      stack_before=[],
      stack_after=[anyobject],
      proto=2,
      doc="""Extension code.

      See EXT1.  EXT4 has a four-byte integer argument.
      """),

    # Push a class object, or module function, on the stack, via its module
    # and name.

    I(name='GLOBAL',
      code='c',
      arg=stringnl_noescape_pair,
      stack_before=[],
      stack_after=[anyobject],
      proto=0,
      doc="""Push a global object (module.attr) on the stack.

      Two newline-terminated strings follow the GLOBAL opcode.  The first is
      taken as a module name, and the second as a class name.  The class
      object module.class is pushed on the stack.  More accurately, the
      object returned by self.find_class(module, class) is pushed on the
      stack, so unpickling subclasses can override this form of lookup.
      """),

    # Ways to build objects of classes pickle doesn't know about directly
    # (user-defined classes).  I despair of documenting this accurately
    # and comprehensibly -- you really have to read the pickle code to
    # find all the special cases.

    I(name='REDUCE',
      code='R',
      arg=None,
      stack_before=[anyobject, anyobject],
      stack_after=[anyobject],
      proto=0,
      doc="""Push an object built from a callable and an argument tuple.

      The opcode is named to remind of the __reduce__() method.

      Stack before: ... callable pytuple
      Stack after:  ... callable(*pytuple)

      The callable and the argument tuple are the first two items returned
      by a __reduce__ method.  Applying the callable to the argtuple is
      supposed to reproduce the original object, or at least get it started.
      If the __reduce__ method returns a 3-tuple, the last component is an
      argument to be passed to the object's __setstate__, and then the REDUCE
      opcode is followed by code to create setstate's argument, and then a
      BUILD opcode to apply  __setstate__ to that argument.

      If type(callable) is not ClassType, REDUCE complains unless the
      callable has been registered with the copy_reg module's
      safe_constructors dict, or the callable has a magic
      '__safe_for_unpickling__' attribute with a true value.  I'm not sure
      why it does this, but I've sure seen this complaint often enough when
      I didn't want to <wink>.
      """),

    I(name='BUILD',
      code='b',
      arg=None,
      stack_before=[anyobject, anyobject],
      stack_after=[anyobject],
      proto=0,
      doc="""Finish building an object, via __setstate__ or dict update.

      Stack before: ... anyobject argument
      Stack after:  ... anyobject

      where anyobject may have been mutated, as follows:

      If the object has a __setstate__ method,

          anyobject.__setstate__(argument)

      is called.

      Else the argument must be a dict, the object must have a __dict__, and
      the object is updated via

          anyobject.__dict__.update(argument)

      This may raise RuntimeError in restricted execution mode (which
      disallows access to __dict__ directly); in that case, the object
      is updated instead via

          for k, v in argument.items():
              anyobject[k] = v
      """),

    I(name='INST',
      code='i',
      arg=stringnl_noescape_pair,
      stack_before=[markobject, stackslice],
      stack_after=[anyobject],
      proto=0,
      doc="""Build a class instance.

      This is the protocol 0 version of protocol 1's OBJ opcode.
      INST is followed by two newline-terminated strings, giving a
      module and class name, just as for the GLOBAL opcode (and see
      GLOBAL for more details about that).  self.find_class(module, name)
      is used to get a class object.

      In addition, all the objects on the stack following the topmost
      markobject are gathered into a tuple and popped (along with the
      topmost markobject), just as for the TUPLE opcode.

      Now it gets complicated.  If all of these are true:

        + The argtuple is empty (markobject was at the top of the stack
          at the start).

        + It's an old-style class object (the type of the class object is
          ClassType).

        + The class object does not have a __getinitargs__ attribute.

      then we want to create an old-style class instance without invoking
      its __init__() method (pickle has waffled on this over the years; not
      calling __init__() is current wisdom).  In this case, an instance of
      an old-style dummy class is created, and then we try to rebind its
      __class__ attribute to the desired class object.  If this succeeds,
      the new instance object is pushed on the stack, and we're done.  In
      restricted execution mode it can fail (assignment to __class__ is
      disallowed), and I'm not really sure what happens then -- it looks
      like the code ends up calling the class object's __init__ anyway,
      via falling into the next case.

      Else (the argtuple is not empty, it's not an old-style class object,
      or the class object does have a __getinitargs__ attribute), the code
      first insists that the class object have a __safe_for_unpickling__
      attribute.  Unlike as for the __safe_for_unpickling__ check in REDUCE,
      it doesn't matter whether this attribute has a true or false value, it
      only matters whether it exists (XXX this is a bug; cPickle
      requires the attribute to be true).  If __safe_for_unpickling__
      doesn't exist, UnpicklingError is raised.

      Else (the class object does have a __safe_for_unpickling__ attr),
      the class object obtained from INST's arguments is applied to the
      argtuple obtained from the stack, and the resulting instance object
      is pushed on the stack.

      NOTE:  checks for __safe_for_unpickling__ went away in Python 2.3.
      """),

    I(name='OBJ',
      code='o',
      arg=None,
      stack_before=[markobject, anyobject, stackslice],
      stack_after=[anyobject],
      proto=1,
      doc="""Build a class instance.

      This is the protocol 1 version of protocol 0's INST opcode, and is
      very much like it.  The major difference is that the class object
      is taken off the stack, allowing it to be retrieved from the memo
      repeatedly if several instances of the same class are created.  This
      can be much more efficient (in both time and space) than repeatedly
      embedding the module and class names in INST opcodes.

      Unlike INST, OBJ takes no arguments from the opcode stream.  Instead
      the class object is taken off the stack, immediately above the
      topmost markobject:

      Stack before: ... markobject classobject stackslice
      Stack after:  ... new_instance_object

      As for INST, the remainder of the stack above the markobject is
      gathered into an argument tuple, and then the logic seems identical,
      except that no __safe_for_unpickling__ check is done (XXX this is
      a bug; cPickle does test __safe_for_unpickling__).  See INST for
      the gory details.

      NOTE:  In Python 2.3, INST and OBJ are identical except for how they
      get the class object.  That was always the intent; the implementations
      had diverged for accidental reasons.
      """),

    I(name='NEWOBJ',
      code='\x81',
      arg=None,
      stack_before=[anyobject, anyobject],
      stack_after=[anyobject],
      proto=2,
      doc="""Build an object instance.

      The stack before should be thought of as containing a class
      object followed by an argument tuple (the tuple being the stack
      top).  Call these cls and args.  They are popped off the stack,
      and the value returned by cls.__new__(cls, *args) is pushed back
      onto the stack.
      """),

    # Machine control.

    I(name='PROTO',
      code='\x80',
      arg=uint1,
      stack_before=[],
      stack_after=[],
      proto=2,
      doc="""Protocol version indicator.

      For protocol 2 and above, a pickle must start with this opcode.
      The argument is the protocol version, an int in range(2, 256).
      """),

    I(name='STOP',
      code='.',
      arg=None,
      stack_before=[anyobject],
      stack_after=[],
      proto=0,
      doc="""Stop the unpickling machine.

      Every pickle ends with this opcode.  The object at the top of the stack
      is popped, and that's the result of unpickling.  The stack should be
      empty then.
      """),

    # Ways to deal with persistent IDs.

    I(name='PERSID',
      code='P',
      arg=stringnl_noescape,
      stack_before=[],
      stack_after=[anyobject],
      proto=0,
      doc="""Push an object identified by a persistent ID.

      The pickle module doesn't define what a persistent ID means.  PERSID's
      argument is a newline-terminated str-style (no embedded escapes, no
      bracketing quote characters) string, which *is* "the persistent ID".
      The unpickler passes this string to self.persistent_load().  Whatever
      object that returns is pushed on the stack.  There is no implementation
      of persistent_load() in Python's unpickler:  it must be supplied by an
      unpickler subclass.
      """),

    I(name='BINPERSID',
      code='Q',
      arg=None,
      stack_before=[anyobject],
      stack_after=[anyobject],
      proto=1,
      doc="""Push an object identified by a persistent ID.

      Like PERSID, except the persistent ID is popped off the stack (instead
      of being a string embedded in the opcode bytestream).  The persistent
      ID is passed to self.persistent_load(), and whatever object that
      returns is pushed on the stack.  See PERSID for more detail.
      """),
]
del I

# Verify uniqueness of .name and .code members.
name2i = {}
code2i = {}

for i, d in enumerate(opcodes):
    if d.name in name2i:
        raise ValueError("repeated name %r at indices %d and %d" %
                         (d.name, name2i[d.name], i))
    if d.code in code2i:
        raise ValueError("repeated code %r at indices %d and %d" %
                         (d.code, code2i[d.code], i))

    name2i[d.name] = i
    code2i[d.code] = i

del name2i, code2i, i, d

##############################################################################
# Build a code2op dict, mapping opcode characters to OpcodeInfo records.
# Also ensure we've got the same stuff as pickle.py, although the
# introspection here is dicey.

code2op = {}
for d in opcodes:
    code2op[d.code] = d
del d

def assure_pickle_consistency(verbose=False):
    import pickle, re

    copy = code2op.copy()
    for name in pickle.__all__:
        if not re.match("[A-Z][A-Z0-9_]+$", name):
            if verbose:
                print "skipping %r: it doesn't look like an opcode name" % name
            continue
        picklecode = getattr(pickle, name)
        if not isinstance(picklecode, str) or len(picklecode) != 1:
            if verbose:
                print ("skipping %r: value %r doesn't look like a pickle "
                       "code" % (name, picklecode))
            continue
        if picklecode in copy:
            if verbose:
                print "checking name %r w/ code %r for consistency" % (
                      name, picklecode)
            d = copy[picklecode]
            if d.name != name:
                raise ValueError("for pickle code %r, pickle.py uses name %r "
                                 "but we're using name %r" % (picklecode,
                                                              name,
                                                              d.name))
            # Forget this one.  Any left over in copy at the end are a problem
            # of a different kind.
            del copy[picklecode]
        else:
            raise ValueError("pickle.py appears to have a pickle opcode with "
                             "name %r and code %r, but we don't" %
                             (name, picklecode))
    if copy:
        msg = ["we appear to have pickle opcodes that pickle.py doesn't have:"]
        for code, d in copy.items():
            msg.append("    name %r with code %r" % (d.name, code))
        raise ValueError("\n".join(msg))

assure_pickle_consistency()
del assure_pickle_consistency

##############################################################################
# A pickle opcode generator.

def genops(pickle):
    """Generate all the opcodes in a pickle.

    'pickle' is a file-like object, or string, containing the pickle.

    Each opcode in the pickle is generated, from the current pickle position,
    stopping after a STOP opcode is delivered.  A triple is generated for
    each opcode:

        opcode, arg, pos

    opcode is an OpcodeInfo record, describing the current opcode.

    If the opcode has an argument embedded in the pickle, arg is its decoded
    value, as a Python object.  If the opcode doesn't have an argument, arg
    is None.

    If the pickle has a tell() method, pos was the value of pickle.tell()
    before reading the current opcode.  If the pickle is a string object,
    it's wrapped in a StringIO object, and the latter's tell() result is
    used.  Else (the pickle doesn't have a tell(), and it's not obvious how
    to query its current position) pos is None.
    """

    import cStringIO as StringIO

    if isinstance(pickle, str):
        pickle = StringIO.StringIO(pickle)

    if hasattr(pickle, "tell"):
        getpos = pickle.tell
    else:
        getpos = lambda: None

    while True:
        pos = getpos()
        code = pickle.read(1)
        opcode = code2op.get(code)
        if opcode is None:
            if code == "":
                raise ValueError("pickle exhausted before seeing STOP")
            else:
                raise ValueError("at position %s, opcode %r unknown" % (
                                 pos is None and "<unknown>" or pos,
                                 code))
        if opcode.arg is None:
            arg = None
        else:
            arg = opcode.arg.reader(pickle)
        yield opcode, arg, pos
        if code == '.':
            assert opcode.name == 'STOP'
            break

##############################################################################
# A pickle optimizer.

def optimize(p):
    'Optimize a pickle string by removing unused PUT opcodes'
    gets = set()            # set of args used by a GET opcode
    puts = []               # (arg, startpos, stoppos) for the PUT opcodes
    prevpos = None          # set to pos if previous opcode was a PUT
    for opcode, arg, pos in genops(p):
        if prevpos is not None:
            puts.append((prevarg, prevpos, pos))
            prevpos = None
        if 'PUT' in opcode.name:
            prevarg, prevpos = arg, pos
        elif 'GET' in opcode.name:
            gets.add(arg)

    # Copy the pickle string except for PUTS without a corresponding GET
    s = []
    i = 0
    for arg, start, stop in puts:
        j = stop if (arg in gets) else start
        s.append(p[i:j])
        i = stop
    s.append(p[i:])
    return ''.join(s)

##############################################################################
# A symbolic pickle disassembler.

def dis(pickle, out=None, memo=None, indentlevel=4):
    """Produce a symbolic disassembly of a pickle.

    'pickle' is a file-like object, or string, containing a (at least one)
    pickle.  The pickle is disassembled from the current position, through
    the first STOP opcode encountered.

    Optional arg 'out' is a file-like object to which the disassembly is
    printed.  It defaults to sys.stdout.

    Optional arg 'memo' is a Python dict, used as the pickle's memo.  It
    may be mutated by dis(), if the pickle contains PUT or BINPUT opcodes.
    Passing the same memo object to another dis() call then allows disassembly
    to proceed across multiple pickles that were all created by the same
    pickler with the same memo.  Ordinarily you don't need to worry about this.

    Optional arg indentlevel is the number of blanks by which to indent
    a new MARK level.  It defaults to 4.

    In addition to printing the disassembly, some sanity checks are made:

    + All embedded opcode arguments "make sense".

    + Explicit and implicit pop operations have enough items on the stack.

    + When an opcode implicitly refers to a markobject, a markobject is
      actually on the stack.

    + A memo entry isn't referenced before it's defined.

    + The markobject isn't stored in the memo.

    + A memo entry isn't redefined.
    """

    # Most of the hair here is for sanity checks, but most of it is needed
    # anyway to detect when a protocol 0 POP takes a MARK off the stack
    # (which in turn is needed to indent MARK blocks correctly).

    stack = []          # crude emulation of unpickler stack
    if memo is None:
        memo = {}       # crude emulation of unpickler memo
    maxproto = -1       # max protocol number seen
    markstack = []      # bytecode positions of MARK opcodes
    indentchunk = ' ' * indentlevel
    errormsg = None
    for opcode, arg, pos in genops(pickle):
        if pos is not None:
            print >> out, "%5d:" % pos,

        line = "%-4s %s%s" % (repr(opcode.code)[1:-1],
                              indentchunk * len(markstack),
                              opcode.name)

        maxproto = max(maxproto, opcode.proto)
        before = opcode.stack_before    # don't mutate
        after = opcode.stack_after      # don't mutate
        numtopop = len(before)

        # See whether a MARK should be popped.
        markmsg = None
        if markobject in before or (opcode.name == "POP" and
                                    stack and
                                    stack[-1] is markobject):
            assert markobject not in after
            if __debug__:
                if markobject in before:
                    assert before[-1] is stackslice
            if markstack:
                markpos = markstack.pop()
                if markpos is None:
                    markmsg = "(MARK at unknown opcode offset)"
                else:
                    markmsg = "(MARK at %d)" % markpos
                # Pop everything at and after the topmost markobject.
                while stack[-1] is not markobject:
                    stack.pop()
                stack.pop()
                # Stop later code from popping too much.
                try:
                    numtopop = before.index(markobject)
                except ValueError:
                    assert opcode.name == "POP"
                    numtopop = 0
            else:
                errormsg = markmsg = "no MARK exists on stack"

        # Check for correct memo usage.
        if opcode.name in ("PUT", "BINPUT", "LONG_BINPUT"):
            assert arg is not None
            if arg in memo:
                errormsg = "memo key %r already defined" % arg
            elif not stack:
                errormsg = "stack is empty -- can't store into memo"
            elif stack[-1] is markobject:
                errormsg = "can't store markobject in the memo"
            else:
                memo[arg] = stack[-1]

        elif opcode.name in ("GET", "BINGET", "LONG_BINGET"):
            if arg in memo:
                assert len(after) == 1
                after = [memo[arg]]     # for better stack emulation
            else:
                errormsg = "memo key %r has never been stored into" % arg

        if arg is not None or markmsg:
            # make a mild effort to align arguments
            line += ' ' * (10 - len(opcode.name))
            if arg is not None:
                line += ' ' + repr(arg)
            if markmsg:
                line += ' ' + markmsg
        print >> out, line

        if errormsg:
            # Note that we delayed complaining until the offending opcode
            # was printed.
            raise ValueError(errormsg)

        # Emulate the stack effects.
        if len(stack) < numtopop:
            raise ValueError("tries to pop %d items from stack with "
                             "only %d items" % (numtopop, len(stack)))
        if numtopop:
            del stack[-numtopop:]
        if markobject in after:
            assert markobject not in before
            markstack.append(pos)

        stack.extend(after)

    print >> out, "highest protocol among opcodes =", maxproto
    if stack:
        raise ValueError("stack not empty after STOP: %r" % stack)

# For use in the doctest, simply as an example of a class to pickle.
class _Example:
    def __init__(self, value):
        self.value = value

_dis_test = r"""
>>> import pickle
>>> x = [1, 2, (3, 4), {'abc': u"def"}]
>>> pkl = pickle.dumps(x, 0)
>>> dis(pkl)
    0: (    MARK
    1: l        LIST       (MARK at 0)
    2: p    PUT        0
    5: I    INT        1
    8: a    APPEND
    9: I    INT        2
   12: a    APPEND
   13: (    MARK
   14: I        INT        3
   17: I        INT        4
   20: t        TUPLE      (MARK at 13)
   21: p    PUT        1
   24: a    APPEND
   25: (    MARK
   26: d        DICT       (MARK at 25)
   27: p    PUT        2
   30: S    STRING     'abc'
   37: p    PUT        3
   40: V    UNICODE    u'def'
   45: p    PUT        4
   48: s    SETITEM
   49: a    APPEND
   50: .    STOP
highest protocol among opcodes = 0

Try again with a "binary" pickle.

>>> pkl = pickle.dumps(x, 1)
>>> dis(pkl)
    0: ]    EMPTY_LIST
    1: q    BINPUT     0
    3: (    MARK
    4: K        BININT1    1
    6: K        BININT1    2
    8: (        MARK
    9: K            BININT1    3
   11: K            BININT1    4
   13: t            TUPLE      (MARK at 8)
   14: q        BINPUT     1
   16: }        EMPTY_DICT
   17: q        BINPUT     2
   19: U        SHORT_BINSTRING 'abc'
   24: q        BINPUT     3
   26: X        BINUNICODE u'def'
   34: q        BINPUT     4
   36: s        SETITEM
   37: e        APPENDS    (MARK at 3)
   38: .    STOP
highest protocol among opcodes = 1

Exercise the INST/OBJ/BUILD family.

>>> import pickletools
>>> dis(pickle.dumps(pickletools.dis, 0))
    0: c    GLOBAL     'pickletools dis'
   17: p    PUT        0
   20: .    STOP
highest protocol among opcodes = 0

>>> from pickletools import _Example
>>> x = [_Example(42)] * 2
>>> dis(pickle.dumps(x, 0))
    0: (    MARK
    1: l        LIST       (MARK at 0)
    2: p    PUT        0
    5: (    MARK
    6: i        INST       'pickletools _Example' (MARK at 5)
   28: p    PUT        1
   31: (    MARK
   32: d        DICT       (MARK at 31)
   33: p    PUT        2
   36: S    STRING     'value'
   45: p    PUT        3
   48: I    INT        42
   52: s    SETITEM
   53: b    BUILD
   54: a    APPEND
   55: g    GET        1
   58: a    APPEND
   59: .    STOP
highest protocol among opcodes = 0

>>> dis(pickle.dumps(x, 1))
    0: ]    EMPTY_LIST
    1: q    BINPUT     0
    3: (    MARK
    4: (        MARK
    5: c            GLOBAL     'pickletools _Example'
   27: q            BINPUT     1
   29: o            OBJ        (MARK at 4)
   30: q        BINPUT     2
   32: }        EMPTY_DICT
   33: q        BINPUT     3
   35: U        SHORT_BINSTRING 'value'
   42: q        BINPUT     4
   44: K        BININT1    42
   46: s        SETITEM
   47: b        BUILD
   48: h        BINGET     2
   50: e        APPENDS    (MARK at 3)
   51: .    STOP
highest protocol among opcodes = 1

Try "the canonical" recursive-object test.

>>> L = []
>>> T = L,
>>> L.append(T)
>>> L[0] is T
True
>>> T[0] is L
True
>>> L[0][0] is L
True
>>> T[0][0] is T
True
>>> dis(pickle.dumps(L, 0))
    0: (    MARK
    1: l        LIST       (MARK at 0)
    2: p    PUT        0
    5: (    MARK
    6: g        GET        0
    9: t        TUPLE      (MARK at 5)
   10: p    PUT        1
   13: a    APPEND
   14: .    STOP
highest protocol among opcodes = 0

>>> dis(pickle.dumps(L, 1))
    0: ]    EMPTY_LIST
    1: q    BINPUT     0
    3: (    MARK
    4: h        BINGET     0
    6: t        TUPLE      (MARK at 3)
    7: q    BINPUT     1
    9: a    APPEND
   10: .    STOP
highest protocol among opcodes = 1

Note that, in the protocol 0 pickle of the recursive tuple, the disassembler
has to emulate the stack in order to realize that the POP opcode at 16 gets
rid of the MARK at 0.

>>> dis(pickle.dumps(T, 0))
    0: (    MARK
    1: (        MARK
    2: l            LIST       (MARK at 1)
    3: p        PUT        0
    6: (        MARK
    7: g            GET        0
   10: t            TUPLE      (MARK at 6)
   11: p        PUT        1
   14: a        APPEND
   15: 0        POP
   16: 0        POP        (MARK at 0)
   17: g    GET        1
   20: .    STOP
highest protocol among opcodes = 0

>>> dis(pickle.dumps(T, 1))
    0: (    MARK
    1: ]        EMPTY_LIST
    2: q        BINPUT     0
    4: (        MARK
    5: h            BINGET     0
    7: t            TUPLE      (MARK at 4)
    8: q        BINPUT     1
   10: a        APPEND
   11: 1        POP_MARK   (MARK at 0)
   12: h    BINGET     1
   14: .    STOP
highest protocol among opcodes = 1

Try protocol 2.

>>> dis(pickle.dumps(L, 2))
    0: \x80 PROTO      2
    2: ]    EMPTY_LIST
    3: q    BINPUT     0
    5: h    BINGET     0
    7: \x85 TUPLE1
    8: q    BINPUT     1
   10: a    APPEND
   11: .    STOP
highest protocol among opcodes = 2

>>> dis(pickle.dumps(T, 2))
    0: \x80 PROTO      2
    2: ]    EMPTY_LIST
    3: q    BINPUT     0
    5: h    BINGET     0
    7: \x85 TUPLE1
    8: q    BINPUT     1
   10: a    APPEND
   11: 0    POP
   12: h    BINGET     1
   14: .    STOP
highest protocol among opcodes = 2
"""

_memo_test = r"""
>>> import pickle
>>> from StringIO import StringIO
>>> f = StringIO()
>>> p = pickle.Pickler(f, 2)
>>> x = [1, 2, 3]
>>> p.dump(x)
>>> p.dump(x)
>>> f.seek(0)
>>> memo = {}
>>> dis(f, memo=memo)
    0: \x80 PROTO      2
    2: ]    EMPTY_LIST
    3: q    BINPUT     0
    5: (    MARK
    6: K        BININT1    1
    8: K        BININT1    2
   10: K        BININT1    3
   12: e        APPENDS    (MARK at 5)
   13: .    STOP
highest protocol among opcodes = 2
>>> dis(f, memo=memo)
   14: \x80 PROTO      2
   16: h    BINGET     0
   18: .    STOP
highest protocol among opcodes = 2
"""

__test__ = {'disassembler_test': _dis_test,
            'disassembler_memo_test': _memo_test,
           }

def _test():
    import doctest
    return doctest.testmod()

if __name__ == "__main__":
    _test()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ó
Ó«[c        C   @   s/  d  Z  d d d g Z d Z d Z d Z d e f d „  ƒ  YZ d d	 l m Z	 d
 „  Z
 e d d d d d e
 d d ƒ Z d „  Z e d d d d d e d d ƒ Z d „  Z e d d d d d e d d ƒ Z e e d „ Z e d d d e d e d d ƒ Z d „  Z e d d d e d e d d ƒ Z d  „  Z e d d! d e d e d d" ƒ Z d# „  Z e d d$ d e d e d d% ƒ Z d& „  Z e d d' d e d e d d( ƒ Z d) „  Z e d d* d e d e d d+ ƒ Z d, „  Z e d d- d e d e d d. ƒ Z d/ „  Z d0 „  Z  e d d1 d e d e d d2 ƒ Z! e d d3 d e d e  d d4 ƒ Z" d5 „  Z# e d d6 d e d e# d d7 ƒ Z$ d8 „  Z% e d d9 d d: d e% d d; ƒ Z& d d< l' m( Z( d= „  Z) e d d> d e d e) d d? ƒ Z* d@ „  Z+ e d dA d e d e+ d dB ƒ Z, dC e f dD „  ƒ  YZ- e- d dE dF e. d dG ƒ Z/ e- d dH dF e0 d dI ƒ Z1 e- d dJ dF e. e0 e2 f d dK ƒ Z3 e- d dL dF e2 f d dM ƒ Z4 e- d dN dF e5 d dO ƒ Z6 e- d dP dF e7 d dQ ƒ Z8 e- d dR dF e9 d dS ƒ Z: e- d dT dF e; dƒ d dU ƒ Z= e- d dV dF e> d dW ƒ Z? e- d dX dF e@ d dY ƒ ZA e- d dZ dF eB d d[ ƒ ZC e- d d\ dF e d d] ƒ ZD e- d d^ dF e- d d_ ƒ ZE e- d d` dF e- d da ƒ ZF db e f dc „  ƒ  YZG eG ZH eH d dd de df dg e! dh g  di e3 g dj dk d dl ƒ eH d dm de dn dg e dh g  di e/ g dj d d do ƒ eH d dp de dq dg e dh g  di e/ g dj d d dr ƒ eH d ds de dt dg e dh g  di e/ g dj d d du ƒ eH d dv de dw dg e" dh g  di e1 g dj dk d dx ƒ eH d dy de dz dg e* dh g  di e1 g dj d d d{ ƒ eH d d| de d} dg e, dh g  di e1 g dj d d d~ ƒ eH d d de d€ dg e dh g  di e8 g dj dk d d ƒ eH d d‚ de dƒ dg e dh g  di e8 g dj d d d„ ƒ eH d d… de d† dg e dh g  di e8 g dj d d d‡ ƒ eH d dˆ de d‰ dg ddh g  di e= g dj dk d dŠ ƒ eH d d‹ de dŒ dg ddh g  di e4 g dj d d d ƒ eH d dŽ de d dg ddh g  di e4 g dj d d d ƒ eH d d‘ de d’ dg e dh g  di e: g dj dk d d“ ƒ eH d d” de d• dg e dh g  di e: g dj d d d– ƒ eH d d— de d˜ dg e$ dh g  di e6 g dj dk d d™ ƒ eH d dš de d› dg e& dh g  di e6 g dj d d dœ ƒ eH d d de dž dg ddh g  di eA g dj d d dŸ ƒ eH d d  de d¡ dg ddh eA eD g di eA g dj dk d d¢ ƒ eH d d£ de d¤ dg ddh eA eE eF g di eA g dj d d d¥ ƒ eH d d¦ de d§ dg ddh eE eF g di eA g dj dk d d¨ ƒ eH d d© de dª dg ddh g  di e? g dj d d d« ƒ eH d d¬ de d­ dg ddh eE eF g di e? g dj dk d d® ƒ eH d d¯ de d° dg ddh eD g di e? g dj d d d± ƒ eH d d² de d³ dg ddh eD eD g di e? g dj d d d´ ƒ eH d dµ de d¶ dg ddh eD eD eD g di e? g dj d d d· ƒ eH d d¸ de d¹ dg ddh g  di eC g dj d d dº ƒ eH d d» de d¼ dg ddh eE eF g di eC g dj dk d d½ ƒ eH d d¾ de d¿ dg ddh eC eD eD g di eC g dj dk d dÀ ƒ eH d dÁ de dÂ dg ddh eC eE eF g di eC g dj d d dÃ ƒ eH d dÄ de dÅ dg ddh eD g di g  dj dk d dÆ ƒ eH d dÇ de dÈ dg ddh eD g di eD eD g dj dk d dÉ ƒ eH d dÊ de dË dg ddh g  di eE g dj dk d dÌ ƒ eH d dÍ de dÎ dg ddh eE eF g di g  dj d d dÏ ƒ eH d dÐ de dÑ dg e! dh g  di eD g dj dk d dÒ ƒ eH d dÓ de dÔ dg e dh g  di eD g dj d d dÕ ƒ eH d dÖ de d× dg e dh g  di eD g dj d d dØ ƒ eH d dÙ de dÚ dg e! dh g  di g  dj dk d dÛ ƒ eH d dÜ de dÝ dg e dh g  di g  dj d d dÞ ƒ eH d dß de dà dg e dh g  di g  dj d d dá ƒ eH d dâ de dã dg e dh g  di eD g dj d d dä ƒ eH d då de dæ dg e dh g  di eD g dj d d dç ƒ eH d dè de dé dg e dh g  di eD g dj d d dê ƒ eH d dë de dì dg e dh g  di eD g dj dk d dí ƒ eH d dî de dï dg ddh eD eD g di eD g dj dk d dð ƒ eH d dñ de dò dg ddh eD eD g di eD g dj dk d dó ƒ eH d dô de dõ dg e dh eE eF g di eD g dj dk d dö ƒ eH d d÷ de dø dg ddh eE eD eF g di eD g dj d d dù ƒ eH d dú de dû dg ddh eD eD g di eD g dj d d dü ƒ eH d dý de dþ dg e dh g  di g  dj d d dÿ ƒ eH d d de ddg ddh eD g di g  dj dk d dƒ eH d dde ddg e dh g  di eD g dj dk d dƒ eH d dde ddg ddh eD g di eD g dj d d dƒ g5 ZI [H i  ZJ i  ZK xž eL eI ƒ D] \ ZM ZN eN jO eJ k reP d	eN jO eJ eN jO eM f ƒ ‚ n  eN jQ eK k rNeP d
eN jQ eK eN jQ eM f ƒ ‚ n  eM eJ eN jO <eM eK eN jQ <qØW[J [K [M [N i  ZR x eI D] ZN eN eR eN jQ <q…W[N eS d„ ZT eT ƒ  [T d„  ZU d„  ZV ddd d„ ZW ddd„  ƒ  YZX dZY dZZ i eY d6eZ d6Z[ d„  Z\ e] dk r+e\ ƒ  n  dS(  sr  "Executable documentation" for the pickle module.

Extensive comments about the pickle protocols and pickle-machine opcodes
can be found here.  Some functions meant for external use:

genops(pickle)
   Generate all the opcodes in a pickle, as (opcode, arg, position) triples.

dis(pickle, out=None, memo=None, indentlevel=4)
   Print a symbolic disassembly of a pickle.
t   dist   genopst   optimizeiÿÿÿÿiþÿÿÿiýÿÿÿt   ArgumentDescriptorc           B   s   e  Z d Z d „  Z RS(   t   namet   nt   readert   docc         C   sˆ   t  | t ƒ s t ‚ | |  _ t  | t ƒ rN | d k sT | t t t f k sT t ‚ | |  _ | |  _	 t  | t ƒ s{ t ‚ | |  _
 d  S(   Ni    (   t
   isinstancet   strt   AssertionErrorR   t   intt   UP_TO_NEWLINEt   TAKEN_FROM_ARGUMENT1t   TAKEN_FROM_ARGUMENT4R   R   R   (   t   selfR   R   R   R   (    (    s!   /usr/lib/python2.7/pickletools.pyt   __init__¸   s    			(   R   R   R   R   (   t   __name__t
   __module__t	   __slots__R   (    (    (    s!   /usr/lib/python2.7/pickletools.pyR   ¥   s
      (   t   unpackc         C   s/   |  j  d ƒ } | r t | ƒ St d ƒ ‚ d S(   sS   
    >>> import StringIO
    >>> read_uint1(StringIO.StringIO('\xff'))
    255
    i   s'   not enough data in stream to read uint1N(   t   readt   ordt
   ValueError(   t   ft   data(    (    s!   /usr/lib/python2.7/pickletools.pyt
   read_uint1É   s    
R   t   uint1R   i   R   R   s   One-byte unsigned integer.c         C   sB   |  j  d ƒ } t | ƒ d k r2 t d | ƒ d St d ƒ ‚ d S(   s“   
    >>> import StringIO
    >>> read_uint2(StringIO.StringIO('\xff\x00'))
    255
    >>> read_uint2(StringIO.StringIO('\xff\xff'))
    65535
    i   s   <Hi    s'   not enough data in stream to read uint2N(   R   t   lent   _unpackR   (   R   R   (    (    s!   /usr/lib/python2.7/pickletools.pyt
   read_uint2Ü   s    	t   uint2i   s)   Two-byte unsigned integer, little-endian.c         C   sB   |  j  d ƒ } t | ƒ d k r2 t d | ƒ d St d ƒ ‚ d S(   s¬   
    >>> import StringIO
    >>> read_int4(StringIO.StringIO('\xff\x00\x00\x00'))
    255
    >>> read_int4(StringIO.StringIO('\x00\x00\x00\x80')) == -(2**31)
    True
    i   s   <ii    s&   not enough data in stream to read int4N(   R   R   R   R   (   R   R   (    (    s!   /usr/lib/python2.7/pickletools.pyt	   read_int4ñ   s    	t   int4i   s8   Four-byte signed integer, little-endian, 2's complement.c         C   sÂ   |  j  ƒ  } | j d ƒ s* t d ƒ ‚ n  | d  } | r¦ xi d D]N } | j | ƒ rA | j | ƒ s~ t d | | f ƒ ‚ n  | d d !} PqA qA Wt d | ƒ ‚ n  | r¾ | j d ƒ } n  | S(	   s  
    >>> import StringIO
    >>> read_stringnl(StringIO.StringIO("'abcd'\nefg\n"))
    'abcd'

    >>> read_stringnl(StringIO.StringIO("\n"))
    Traceback (most recent call last):
    ...
    ValueError: no string quotes around ''

    >>> read_stringnl(StringIO.StringIO("\n"), stripquotes=False)
    ''

    >>> read_stringnl(StringIO.StringIO("''\n"))
    ''

    >>> read_stringnl(StringIO.StringIO('"abcd"'))
    Traceback (most recent call last):
    ...
    ValueError: no newline found when trying to read stringnl

    Embedded escapes are undone in the result.
    >>> read_stringnl(StringIO.StringIO(r"'a\n\\b\x00c\td'" + "\n'e'"))
    'a\n\\b\x00c\td'
    s   
s-   no newline found when trying to read stringnliÿÿÿÿs   '"s,   strinq quote %r not found at both ends of %ri   s   no string quotes around %rt   string_escape(   t   readlinet   endswithR   t
   startswitht   decode(   R   R&   t   stripquotesR   t   q(    (    s!   /usr/lib/python2.7/pickletools.pyt   read_stringnl  s     
t   stringnls¢   A newline-terminated string.

                   This is a repr-style string, with embedded escapes, and
                   bracketing quotes.
                   c         C   s   t  |  d t d t ƒS(   NR&   R'   (   R)   t   False(   R   (    (    s!   /usr/lib/python2.7/pickletools.pyt   read_stringnl_noescapeA  s    t   stringnl_noescapes  A newline-terminated string.

                        This is a str-style string, without embedded escapes,
                        or bracketing quotes.  It should consist solely of
                        printable ASCII characters.
                        c         C   s   d t  |  ƒ t  |  ƒ f S(   s|   
    >>> import StringIO
    >>> read_stringnl_noescape_pair(StringIO.StringIO("Queue\nEmpty\njunk"))
    'Queue Empty'
    s   %s %s(   R,   (   R   (    (    s!   /usr/lib/python2.7/pickletools.pyt   read_stringnl_noescape_pairO  s    t   stringnl_noescape_pairs¶  A pair of newline-terminated strings.

                             These are str-style strings, without embedded
                             escapes, or bracketing quotes.  They should
                             consist solely of printable ASCII characters.
                             The pair is returned as a single string, with
                             a single blank separating the two strings.
                             c         C   sp   t  |  ƒ } | d k  r+ t d | ƒ ‚ n  |  j | ƒ } t | ƒ | k rP | St d | t | ƒ f ƒ ‚ d S(   sh  
    >>> import StringIO
    >>> read_string4(StringIO.StringIO("\x00\x00\x00\x00abc"))
    ''
    >>> read_string4(StringIO.StringIO("\x03\x00\x00\x00abcdef"))
    'abc'
    >>> read_string4(StringIO.StringIO("\x00\x00\x00\x03abcdef"))
    Traceback (most recent call last):
    ...
    ValueError: expected 50331648 bytes in a string4, but only 6 remain
    i    s   string4 byte count < 0: %ds2   expected %d bytes in a string4, but only %d remainN(   R    R   R   R   (   R   R   R   (    (    s!   /usr/lib/python2.7/pickletools.pyt   read_string4e  s    t   string4sÙ   A counted string.

              The first argument is a 4-byte little-endian signed int giving
              the number of bytes in the string, and the second argument is
              that many bytes.
              c         C   sc   t  |  ƒ } | d k s t ‚ |  j | ƒ } t | ƒ | k rC | St d | t | ƒ f ƒ ‚ d S(   s”   
    >>> import StringIO
    >>> read_string1(StringIO.StringIO("\x00"))
    ''
    >>> read_string1(StringIO.StringIO("\x03abcdef"))
    'abc'
    i    s2   expected %d bytes in a string1, but only %d remainN(   R   R
   R   R   R   (   R   R   R   (    (    s!   /usr/lib/python2.7/pickletools.pyt   read_string1‡  s    	t   string1sÍ   A counted string.

              The first argument is a 1-byte unsigned int giving the number
              of bytes in the string, and the second argument is that many
              bytes.
              c         C   sA   |  j  ƒ  } | j d ƒ s* t d ƒ ‚ n  | d  } t | d ƒ S(   sq   
    >>> import StringIO
    >>> read_unicodestringnl(StringIO.StringIO("abc\uabcd\njunk"))
    u'abc\uabcd'
    s   
s4   no newline found when trying to read unicodestringnliÿÿÿÿs   raw-unicode-escape(   R#   R$   R   t   unicode(   R   R   (    (    s!   /usr/lib/python2.7/pickletools.pyt   read_unicodestringnl¤  s
    
t   unicodestringnlsø   A newline-terminated Unicode string.

                      This is raw-unicode-escape encoded, so consists of
                      printable ASCII characters, and may contain embedded
                      escape sequences.
                      c         C   sy   t  |  ƒ } | d k  r+ t d | ƒ ‚ n  |  j | ƒ } t | ƒ | k rY t | d ƒ St d | t | ƒ f ƒ ‚ d S(   sÒ  
    >>> import StringIO
    >>> s = u'abcd\uabcd'
    >>> enc = s.encode('utf-8')
    >>> enc
    'abcd\xea\xaf\x8d'
    >>> n = chr(len(enc)) + chr(0) * 3  # little-endian 4-byte length
    >>> t = read_unicodestring4(StringIO.StringIO(n + enc + 'junk'))
    >>> s == t
    True

    >>> read_unicodestring4(StringIO.StringIO(n + enc[:-1]))
    Traceback (most recent call last):
    ...
    ValueError: expected 7 bytes in a unicodestring4, but only 6 remain
    i    s!   unicodestring4 byte count < 0: %ds   utf-8s9   expected %d bytes in a unicodestring4, but only %d remainN(   R    R   R   R   R4   (   R   R   R   (    (    s!   /usr/lib/python2.7/pickletools.pyt   read_unicodestring4½  s    t   unicodestring4sA  A counted Unicode string.

                    The first argument is a 4-byte little-endian signed int
                    giving the number of bytes in the string, and the second
                    argument-- the UTF-8 encoding of the Unicode string --
                    contains that many bytes.
                    c         C   s‡   t  |  d t d t ƒ} | j d ƒ r: t d | ƒ ‚ n  | d k rJ t S| d k rZ t Sy t | ƒ SWn t k
 r‚ t | ƒ SXd S(   s  
    >>> import StringIO
    >>> read_decimalnl_short(StringIO.StringIO("1234\n56"))
    1234

    >>> read_decimalnl_short(StringIO.StringIO("1234L\n56"))
    Traceback (most recent call last):
    ...
    ValueError: trailing 'L' not allowed in '1234L'
    R&   R'   t   Ls   trailing 'L' not allowed in %rt   00t   01N(   R)   R+   R$   R   t   TrueR   t   OverflowErrort   long(   R   t   s(    (    s!   /usr/lib/python2.7/pickletools.pyt   read_decimalnl_shortå  s    c         C   sD   t  |  d t d t ƒ} | j d ƒ s: t d | ƒ ‚ n  t | ƒ S(   s³  
    >>> import StringIO

    >>> read_decimalnl_long(StringIO.StringIO("1234\n56"))
    Traceback (most recent call last):
    ...
    ValueError: trailing 'L' required in '1234'

    Someday the trailing 'L' will probably go away from this output.

    >>> read_decimalnl_long(StringIO.StringIO("1234L\n56"))
    1234L

    >>> read_decimalnl_long(StringIO.StringIO("123456789012345678901234L\n6"))
    123456789012345678901234L
    R&   R'   R9   s   trailing 'L' required in %r(   R)   R+   R$   R   R>   (   R   R?   (    (    s!   /usr/lib/python2.7/pickletools.pyt   read_decimalnl_long  s    t   decimalnl_shortsŸ  A newline-terminated decimal integer literal.

                          This never has a trailing 'L', and the integer fit
                          in a short Python int on the box where the pickle
                          was written -- but there's no guarantee it will fit
                          in a short Python int on the box where the pickle
                          is read.
                          t   decimalnl_longs»   A newline-terminated decimal integer literal.

                         This has a trailing 'L', and can represent integers
                         of any size.
                         c         C   s"   t  |  d t d t ƒ} t | ƒ S(   s[   
    >>> import StringIO
    >>> read_floatnl(StringIO.StringIO("-1.25\n6"))
    -1.25
    R&   R'   (   R)   R+   t   float(   R   R?   (    (    s!   /usr/lib/python2.7/pickletools.pyt   read_floatnl2  s    t   floatnls  A newline-terminated decimal floating literal.

              In general this requires 17 significant digits for roundtrip
              identity, and pickling then unpickling infinities, NaNs, and
              minus zero doesn't work across boxes, or on some boxes even
              on itself (e.g., Windows can't read the strings it produces
              for infinities or NaNs).
              c         C   sB   |  j  d ƒ } t | ƒ d k r2 t d | ƒ d St d ƒ ‚ d S(   s¼   
    >>> import StringIO, struct
    >>> raw = struct.pack(">d", -1.25)
    >>> raw
    '\xbf\xf4\x00\x00\x00\x00\x00\x00'
    >>> read_float8(StringIO.StringIO(raw + "\n"))
    -1.25
    i   s   >di    s(   not enough data in stream to read float8N(   R   R   R   R   (   R   R   (    (    s!   /usr/lib/python2.7/pickletools.pyt   read_float8H  s    
t   float8i   s  An 8-byte binary representation of a float, big-endian.

             The format is unique to Python, and shared with the struct
             module (format string '>d') "in theory" (the struct and cPickle
             implementations don't share the code -- they should).  It's
             strongly related to the IEEE-754 double format, and, in normal
             cases, is in fact identical to the big-endian 754 double format.
             On other boxes the dynamic range is limited to that of a 754
             double, and "add a half and chop" rounding is used to reduce
             the precision to 53 bits.  However, even on a 754 box,
             infinities, NaNs, and minus zero may not be handled correctly
             (may not survive roundtrip pickling intact).
             (   t   decode_longc         C   sF   t  |  ƒ } |  j | ƒ } t | ƒ | k r< t d ƒ ‚ n  t | ƒ S(   sT  
    >>> import StringIO
    >>> read_long1(StringIO.StringIO("\x00"))
    0L
    >>> read_long1(StringIO.StringIO("\x02\xff\x00"))
    255L
    >>> read_long1(StringIO.StringIO("\x02\xff\x7f"))
    32767L
    >>> read_long1(StringIO.StringIO("\x02\x00\xff"))
    -256L
    >>> read_long1(StringIO.StringIO("\x02\x00\x80"))
    -32768L
    s'   not enough data in stream to read long1(   R   R   R   R   RI   (   R   R   R   (    (    s!   /usr/lib/python2.7/pickletools.pyt
   read_long1n  s
    t   long1s  A binary long, little-endian, using 1-byte size.

    This first reads one byte as an unsigned size, then reads that
    many bytes and interprets them as a little-endian 2's-complement long.
    If the size is 0, that's taken as a shortcut for the long 0L.
    c         C   se   t  |  ƒ } | d k  r+ t d | ƒ ‚ n  |  j | ƒ } t | ƒ | k r[ t d ƒ ‚ n  t | ƒ S(   s  
    >>> import StringIO
    >>> read_long4(StringIO.StringIO("\x02\x00\x00\x00\xff\x00"))
    255L
    >>> read_long4(StringIO.StringIO("\x02\x00\x00\x00\xff\x7f"))
    32767L
    >>> read_long4(StringIO.StringIO("\x02\x00\x00\x00\x00\xff"))
    -256L
    >>> read_long4(StringIO.StringIO("\x02\x00\x00\x00\x00\x80"))
    -32768L
    >>> read_long1(StringIO.StringIO("\x00\x00\x00\x00"))
    0L
    i    s   long4 byte count < 0: %ds'   not enough data in stream to read long4(   R    R   R   R   RI   (   R   R   R   (    (    s!   /usr/lib/python2.7/pickletools.pyt
   read_long4Ž  s    t   long4sŽ  A binary representation of a long, little-endian.

    This first reads four bytes as a signed size (but requires the
    size to be >= 0), then reads that many bytes and interprets them
    as a little-endian 2's-complement long.  If the size is 0, that's taken
    as a shortcut for the long 0L, although LONG1 should really be used
    then instead (and in any case where # of bytes < 256).
    t   StackObjectc           B   s    e  Z d Z d „  Z d „  Z RS(   R   t   obtypeR   c         C   s¥   t  | t ƒ s t ‚ | |  _ t  | t ƒ sB t  | t ƒ sB t ‚ t  | t ƒ rz x& | D] } t  | t ƒ sX t ‚ qX Wn  | |  _ t  | t ƒ s˜ t ‚ | |  _ d  S(   N(   R   R	   R
   R   t   typet   tupleRO   R   (   R   R   RO   R   t	   contained(    (    s!   /usr/lib/python2.7/pickletools.pyR   Æ  s    	$	c         C   s   |  j  S(   N(   R   (   R   (    (    s!   /usr/lib/python2.7/pickletools.pyt   __repr__Ó  s    (   R   RO   R   (   R   R   R   R   RS   (    (    (    s!   /usr/lib/python2.7/pickletools.pyRN   ¹  s
     	R   RO   s3   A short (as opposed to long) Python integer object.R>   s3   A long (as opposed to short) Python integer object.t   int_or_bools:   A Python integer object (short or long), or a Python bool.t   bools   A Python bool object.RD   s   A Python float object.R	   s   A Python string object.R4   s   A Python Unicode string object.t   Nones   The Python None object.RQ   s   A Python tuple object.t   lists   A Python list object.t   dicts   A Python dict object.t   anys   Any kind of object whatsoever.t   marks  'The mark' is a unique object.

                 Opcodes that operate on a variable number of objects
                 generally don't embed the count of objects in the opcode,
                 or pull it off the stack.  Instead the MARK opcode is used
                 to push a special marker object on the stack, and then
                 some other opcodes grab all the objects from the top of
                 the stack down to (but not including) the topmost marker
                 object.
                 t
   stackslicesL  An object representing a contiguous slice of the stack.

                 This is used in conjunction with markobject, to represent all
                 of the stack following the topmost markobject.  For example,
                 the POP_MARK opcode changes the stack from

                     [..., markobject, stackslice]
                 to
                     [...]

                 No matter how many object are on the stack after the topmost
                 markobject, POP_MARK gets rid of all of them (including the
                 topmost markobject too).
                 t
   OpcodeInfoc           B   s   e  Z d Z d „  Z RS(	   R   t   codet   argt   stack_beforet   stack_aftert   protoR   c   	      C   sb  t  | t ƒ s t ‚ | |  _ t  | t ƒ s3 t ‚ t | ƒ d k sK t ‚ | |  _ | d  k su t  | t ƒ su t ‚ | |  _ t  | t	 ƒ s“ t ‚ x# | D] } t  | t
 ƒ sš t ‚ qš W| |  _ t  | t	 ƒ s× t ‚ x# | D] } t  | t
 ƒ sÞ t ‚ qÞ W| |  _ t  | t ƒ r1d | k o,d k n s7t ‚ | |  _ t  | t ƒ sUt ‚ | |  _ d  S(   Ni   i    i   (   R   R	   R
   R   R   R]   RV   R   R^   RW   RN   R_   R`   R   Ra   R   (	   R   R   R]   R^   R_   R`   Ra   R   t   x(    (    s!   /usr/lib/python2.7/pickletools.pyR   V  s&    		!			1	(   R   R]   R^   R_   R`   Ra   R   (   R   R   R   R   (    (    (    s!   /usr/lib/python2.7/pickletools.pyR\   7  s         t   INTR]   t   IR^   R_   R`   Ra   i    s¤  Push an integer or bool.

      The argument is a newline-terminated decimal literal string.

      The intent may have been that this always fit in a short Python int,
      but INT can be generated in pickles written on a 64-bit box that
      require a Python long on a 32-bit box.  The difference between this
      and LONG then is that INT skips a trailing 'L', and produces a short
      int whenever possible.

      Another difference is due to that, when bool was introduced as a
      distinct type in 2.3, builtin names True and False were also added to
      2.2.2, mapping to ints 1 and 0.  For compatibility in both directions,
      True gets pickled as INT + "I01\n", and False as INT + "I00\n".
      Leading zeroes are never produced for a genuine integer.  The 2.3
      (and later) unpicklers special-case these and return bool instead;
      earlier unpicklers ignore the leading "0" and return the int.
      t   BININTt   Js1  Push a four-byte signed integer.

      This handles the full range of Python (short) integers on a 32-bit
      box, directly as binary bytes (1 for the opcode and 4 for the integer).
      If the integer is non-negative and fits in 1 or 2 bytes, pickling via
      BININT1 or BININT2 saves space.
      t   BININT1t   KsŒ   Push a one-byte unsigned integer.

      This is a space optimization for pickling very small non-negative ints,
      in range(256).
      t   BININT2t   Msë   Push a two-byte unsigned integer.

      This is a space optimization for pickling small positive ints, in
      range(256, 2**16).  Integers in range(256) can also be pickled via
      BININT2, but BININT1 instead saves a byte.
      t   LONGR9   sÇ  Push a long integer.

      The same as INT, except that the literal ends with 'L', and always
      unpickles to a Python long.  There doesn't seem a real purpose to the
      trailing 'L'.

      Note that LONG takes time quadratic in the number of digits when
      unpickling (this is simply due to the nature of decimal->binary
      conversion).  Proto 2 added linear-time (in C; still quadratic-time
      in Python) LONG1 and LONG4 opcodes.
      t   LONG1s   Šs|   Long integer using one-byte length.

      A more efficient encoding of a Python long; the long1 encoding
      says it all.t   LONG4s   ‹s~   Long integer using found-byte length.

      A more efficient encoding of a Python long; the long4 encoding
      says it all.t   STRINGt   SsÓ   Push a Python string object.

      The argument is a repr-style string, with bracketing quote characters,
      and perhaps embedded escapes.  The argument extends until the next
      newline character.
      t	   BINSTRINGt   Tsý   Push a Python string object.

      There are two arguments:  the first is a 4-byte little-endian signed int
      giving the number of bytes in the string, and the second is that many
      bytes, which are taken literally as the string content.
      t   SHORT_BINSTRINGt   Usñ   Push a Python string object.

      There are two arguments:  the first is a 1-byte unsigned int giving
      the number of bytes in the string, and the second is that many bytes,
      which are taken literally as the string content.
      t   NONEt   Ns   Push None on the stack.t   NEWTRUEs   ˆs&   True.

      Push True onto the stack.t   NEWFALSEs   ‰s'   True.

      Push False onto the stack.t   UNICODEt   Vsç   Push a Python Unicode string object.

      The argument is a raw-unicode-escape encoding of a Unicode string,
      and so may contain embedded escape sequences.  The argument extends
      until the next newline character.
      t
   BINUNICODEt   Xs  Push a Python Unicode string object.

      There are two arguments:  the first is a 4-byte little-endian signed int
      giving the number of bytes in the string.  The second is that many
      bytes, and is the UTF-8 encoding of the Unicode string.
      t   FLOATt   Fs  Newline-terminated decimal float literal.

      The argument is repr(a_float), and in general requires 17 significant
      digits for roundtrip conversion to be an identity (this is so for
      IEEE-754 double precision values, which is what Python float maps to
      on most boxes).

      In general, FLOAT cannot be used to transport infinities, NaNs, or
      minus zero across boxes (or even on a single box, if the platform C
      library can't read the strings it produces for such things -- Windows
      is like that), but may do less damage than BINFLOAT on boxes with
      greater precision or dynamic range than IEEE-754 double.
      t   BINFLOATt   GsÜ  Float stored in binary form, with 8 bytes of data.

      This generally requires less than half the space of FLOAT encoding.
      In general, BINFLOAT cannot be used to transport infinities, NaNs, or
      minus zero, raises an exception if the exponent exceeds the range of
      an IEEE-754 double, and retains no more than 53 bits of precision (if
      there are more than that, "add a half and chop" rounding is used to
      cut it back to 53 significant bits).
      t
   EMPTY_LISTt   ]s   Push an empty list.t   APPENDt   as­   Append an object to a list.

      Stack before:  ... pylist anyobject
      Stack after:   ... pylist+[anyobject]

      although pylist is really extended in-place.
      t   APPENDSt   esÇ   Extend a list by a slice of stack objects.

      Stack before:  ... pylist markobject stackslice
      Stack after:   ... pylist+stackslice

      although pylist is really extended in-place.
      t   LISTt   lss  Build a list out of the topmost stack slice, after markobject.

      All the stack entries following the topmost markobject are placed into
      a single Python list, which single list object replaces all of the
      stack from the topmost markobject onward.  For example,

      Stack before: ... markobject 1 2 3 'abc'
      Stack after:  ... [1, 2, 3, 'abc']
      t   EMPTY_TUPLEt   )s   Push an empty tuple.t   TUPLEt   tsv  Build a tuple out of the topmost stack slice, after markobject.

      All the stack entries following the topmost markobject are placed into
      a single Python tuple, which single tuple object replaces all of the
      stack from the topmost markobject onward.  For example,

      Stack before: ... markobject 1 2 3 'abc'
      Stack after:  ... (1, 2, 3, 'abc')
      t   TUPLE1s   …sü   Build a one-tuple out of the topmost item on the stack.

      This code pops one value off the stack and pushes a tuple of
      length 1 whose one item is that value back onto it.  In other
      words:

          stack[-1] = tuple(stack[-1:])
      t   TUPLE2s   †s  Build a two-tuple out of the top two items on the stack.

      This code pops two values off the stack and pushes a tuple of
      length 2 whose items are those values back onto it.  In other
      words:

          stack[-2:] = [tuple(stack[-2:])]
      t   TUPLE3s   ‡s  Build a three-tuple out of the top three items on the stack.

      This code pops three values off the stack and pushes a tuple of
      length 3 whose items are those values back onto it.  In other
      words:

          stack[-3:] = [tuple(stack[-3:])]
      t
   EMPTY_DICTt   }s   Push an empty dict.t   DICTt   ds²  Build a dict out of the topmost stack slice, after markobject.

      All the stack entries following the topmost markobject are placed into
      a single Python dict, which single dict object replaces all of the
      stack from the topmost markobject onward.  The stack slice alternates
      key, value, key, value, ....  For example,

      Stack before: ... markobject 1 2 3 'abc'
      Stack after:  ... {1: 2, 3: 'abc'}
      t   SETITEMR?   sº   Add a key+value pair to an existing dict.

      Stack before:  ... pydict key value
      Stack after:   ... pydict

      where pydict has been modified via pydict[key] = value.
      t   SETITEMSt   us\  Add an arbitrary number of key+value pairs to an existing dict.

      The slice of the stack following the topmost markobject is taken as
      an alternating sequence of keys and values, added to the dict
      immediately under the topmost markobject.  Everything at and after the
      topmost markobject is popped, leaving the mutated dict at the top
      of the stack.

      Stack before:  ... pydict markobject key_1 value_1 ... key_n value_n
      Stack after:   ... pydict

      where pydict has been modified via pydict[key_i] = value_i for i in
      1, 2, ..., n, and in that order.
      t   POPt   0s<   Discard the top stack item, shrinking the stack by one item.t   DUPt   2s=   Push the top stack item onto the stack again, duplicating it.t   MARKt   (sò   Push markobject onto the stack.

      markobject is a unique object, used by other opcodes to identify a
      region of the stack containing a variable number of objects for them
      to work on.  See markobject.doc for more detail.
      t   POP_MARKt   1s  Pop all the stack objects at and above the topmost markobject.

      When an opcode using a variable number of stack objects is done,
      POP_MARK is used to remove those objects, and to remove the markobject
      that delimited their starting position on the stack.
      t   GETt   gsè   Read an object from the memo and push it on the stack.

      The index of the memo object to push is given by the newline-terminated
      decimal string following.  BINGET and LONG_BINGET are space-optimized
      versions.
      t   BINGETt   hs¢   Read an object from the memo and push it on the stack.

      The index of the memo object to push is given by the 1-byte unsigned
      integer following.
      t   LONG_BINGETt   js®   Read an object from the memo and push it on the stack.

      The index of the memo object to push is given by the 4-byte signed
      little-endian integer following.
      t   PUTt   ps÷   Store the stack top into the memo.  The stack is not popped.

      The index of the memo location to write into is given by the newline-
      terminated decimal string following.  BINPUT and LONG_BINPUT are
      space-optimized versions.
      t   BINPUTR(   s°   Store the stack top into the memo.  The stack is not popped.

      The index of the memo location to write into is given by the 1-byte
      unsigned integer following.
      t   LONG_BINPUTt   rs¼   Store the stack top into the memo.  The stack is not popped.

      The index of the memo location to write into is given by the 4-byte
      signed little-endian integer following.
      t   EXT1s   ‚sŒ  Extension code.

      This code and the similar EXT2 and EXT4 allow using a registry
      of popular objects that are pickled by name, typically classes.
      It is envisioned that through a global negotiation and
      registration process, third parties can set up a mapping between
      ints and object names.

      In order to guarantee pickle interchangeability, the extension
      code registry ought to be global, although a range of codes may
      be reserved for private use.

      EXT1 has a 1-byte integer argument.  This is used to index into the
      extension registry, and the object at that index is pushed on the stack.
      t   EXT2s   ƒsN   Extension code.

      See EXT1.  EXT2 has a two-byte integer argument.
      t   EXT4s   „sO   Extension code.

      See EXT1.  EXT4 has a four-byte integer argument.
      t   GLOBALt   cs§  Push a global object (module.attr) on the stack.

      Two newline-terminated strings follow the GLOBAL opcode.  The first is
      taken as a module name, and the second as a class name.  The class
      object module.class is pushed on the stack.  More accurately, the
      object returned by self.find_class(module, class) is pushed on the
      stack, so unpickling subclasses can override this form of lookup.
      t   REDUCEt   RsN  Push an object built from a callable and an argument tuple.

      The opcode is named to remind of the __reduce__() method.

      Stack before: ... callable pytuple
      Stack after:  ... callable(*pytuple)

      The callable and the argument tuple are the first two items returned
      by a __reduce__ method.  Applying the callable to the argtuple is
      supposed to reproduce the original object, or at least get it started.
      If the __reduce__ method returns a 3-tuple, the last component is an
      argument to be passed to the object's __setstate__, and then the REDUCE
      opcode is followed by code to create setstate's argument, and then a
      BUILD opcode to apply  __setstate__ to that argument.

      If type(callable) is not ClassType, REDUCE complains unless the
      callable has been registered with the copy_reg module's
      safe_constructors dict, or the callable has a magic
      '__safe_for_unpickling__' attribute with a true value.  I'm not sure
      why it does this, but I've sure seen this complaint often enough when
      I didn't want to <wink>.
      t   BUILDt   bsÈ  Finish building an object, via __setstate__ or dict update.

      Stack before: ... anyobject argument
      Stack after:  ... anyobject

      where anyobject may have been mutated, as follows:

      If the object has a __setstate__ method,

          anyobject.__setstate__(argument)

      is called.

      Else the argument must be a dict, the object must have a __dict__, and
      the object is updated via

          anyobject.__dict__.update(argument)

      This may raise RuntimeError in restricted execution mode (which
      disallows access to __dict__ directly); in that case, the object
      is updated instead via

          for k, v in argument.items():
              anyobject[k] = v
      t   INSTt   is“	  Build a class instance.

      This is the protocol 0 version of protocol 1's OBJ opcode.
      INST is followed by two newline-terminated strings, giving a
      module and class name, just as for the GLOBAL opcode (and see
      GLOBAL for more details about that).  self.find_class(module, name)
      is used to get a class object.

      In addition, all the objects on the stack following the topmost
      markobject are gathered into a tuple and popped (along with the
      topmost markobject), just as for the TUPLE opcode.

      Now it gets complicated.  If all of these are true:

        + The argtuple is empty (markobject was at the top of the stack
          at the start).

        + It's an old-style class object (the type of the class object is
          ClassType).

        + The class object does not have a __getinitargs__ attribute.

      then we want to create an old-style class instance without invoking
      its __init__() method (pickle has waffled on this over the years; not
      calling __init__() is current wisdom).  In this case, an instance of
      an old-style dummy class is created, and then we try to rebind its
      __class__ attribute to the desired class object.  If this succeeds,
      the new instance object is pushed on the stack, and we're done.  In
      restricted execution mode it can fail (assignment to __class__ is
      disallowed), and I'm not really sure what happens then -- it looks
      like the code ends up calling the class object's __init__ anyway,
      via falling into the next case.

      Else (the argtuple is not empty, it's not an old-style class object,
      or the class object does have a __getinitargs__ attribute), the code
      first insists that the class object have a __safe_for_unpickling__
      attribute.  Unlike as for the __safe_for_unpickling__ check in REDUCE,
      it doesn't matter whether this attribute has a true or false value, it
      only matters whether it exists (XXX this is a bug; cPickle
      requires the attribute to be true).  If __safe_for_unpickling__
      doesn't exist, UnpicklingError is raised.

      Else (the class object does have a __safe_for_unpickling__ attr),
      the class object obtained from INST's arguments is applied to the
      argtuple obtained from the stack, and the resulting instance object
      is pushed on the stack.

      NOTE:  checks for __safe_for_unpickling__ went away in Python 2.3.
      t   OBJt   osØ  Build a class instance.

      This is the protocol 1 version of protocol 0's INST opcode, and is
      very much like it.  The major difference is that the class object
      is taken off the stack, allowing it to be retrieved from the memo
      repeatedly if several instances of the same class are created.  This
      can be much more efficient (in both time and space) than repeatedly
      embedding the module and class names in INST opcodes.

      Unlike INST, OBJ takes no arguments from the opcode stream.  Instead
      the class object is taken off the stack, immediately above the
      topmost markobject:

      Stack before: ... markobject classobject stackslice
      Stack after:  ... new_instance_object

      As for INST, the remainder of the stack above the markobject is
      gathered into an argument tuple, and then the logic seems identical,
      except that no __safe_for_unpickling__ check is done (XXX this is
      a bug; cPickle does test __safe_for_unpickling__).  See INST for
      the gory details.

      NOTE:  In Python 2.3, INST and OBJ are identical except for how they
      get the class object.  That was always the intent; the implementations
      had diverged for accidental reasons.
      t   NEWOBJs   sL  Build an object instance.

      The stack before should be thought of as containing a class
      object followed by an argument tuple (the tuple being the stack
      top).  Call these cls and args.  They are popped off the stack,
      and the value returned by cls.__new__(cls, *args) is pushed back
      onto the stack.
      t   PROTOs   €s®   Protocol version indicator.

      For protocol 2 and above, a pickle must start with this opcode.
      The argument is the protocol version, an int in range(2, 256).
      t   STOPt   .sÏ   Stop the unpickling machine.

      Every pickle ends with this opcode.  The object at the top of the stack
      is popped, and that's the result of unpickling.  The stack should be
      empty then.
      t   PERSIDt   Ps  Push an object identified by a persistent ID.

      The pickle module doesn't define what a persistent ID means.  PERSID's
      argument is a newline-terminated str-style (no embedded escapes, no
      bracketing quote characters) string, which *is* "the persistent ID".
      The unpickler passes this string to self.persistent_load().  Whatever
      object that returns is pushed on the stack.  There is no implementation
      of persistent_load() in Python's unpickler:  it must be supplied by an
      unpickler subclass.
      t	   BINPERSIDt   QsX  Push an object identified by a persistent ID.

      Like PERSID, except the persistent ID is popped off the stack (instead
      of being a string embedded in the opcode bytestream).  The persistent
      ID is passed to self.persistent_load(), and whatever object that
      returns is pushed on the stack.  See PERSID for more detail.
      s%   repeated name %r at indices %d and %ds%   repeated code %r at indices %d and %dc   	      C   s  d d  l  } d d  l } t j ƒ  } x| j D]û } | j d | ƒ s^ |  r. d | GHq. q. n  t | | ƒ } t | t ƒ s t	 | ƒ d k r­ |  r. d | | f GHq. q. n  | | k r|  rÑ d | | f GHn  | | } | j
 | k r	t d | | | j
 f ƒ ‚ n  | | =q. t d | | f ƒ ‚ q. W| r‹d	 g } x4 | j ƒ  D]& \ } } | j d
 | j
 | f ƒ qIWt d j | ƒ ƒ ‚ n  d  S(   Niÿÿÿÿs   [A-Z][A-Z0-9_]+$s0   skipping %r: it doesn't look like an opcode namei   s5   skipping %r: value %r doesn't look like a pickle codes+   checking name %r w/ code %r for consistencysB   for pickle code %r, pickle.py uses name %r but we're using name %rsP   pickle.py appears to have a pickle opcode with name %r and code %r, but we don'ts=   we appear to have pickle opcodes that pickle.py doesn't have:s       name %r with code %rs   
(   t   picklet   ret   code2opt   copyt   __all__t   matcht   getattrR   R	   R   R   R   t   itemst   appendt   join(	   t   verboseR¾   R¿   RÁ   R   t
   picklecodeR’   t   msgR]   (    (    s!   /usr/lib/python2.7/pickletools.pyt   assure_pickle_consistencyã  s>    "

	c         c   s8  d d l  } t |  t ƒ r- | j |  ƒ }  n  t |  d ƒ rH |  j } n	 d „  } xà t r3| ƒ  } |  j d ƒ } t j	 | ƒ } | d k rÓ | d k r¨ t d ƒ ‚ qÓ t d | d k rÀ d	 pÃ | | f ƒ ‚ n  | j d k rë d } n | j j |  ƒ } | | | f V| d
 k rT | j d k s,t ‚ PqT qT Wd S(   sz  Generate all the opcodes in a pickle.

    'pickle' is a file-like object, or string, containing the pickle.

    Each opcode in the pickle is generated, from the current pickle position,
    stopping after a STOP opcode is delivered.  A triple is generated for
    each opcode:

        opcode, arg, pos

    opcode is an OpcodeInfo record, describing the current opcode.

    If the opcode has an argument embedded in the pickle, arg is its decoded
    value, as a Python object.  If the opcode doesn't have an argument, arg
    is None.

    If the pickle has a tell() method, pos was the value of pickle.tell()
    before reading the current opcode.  If the pickle is a string object,
    it's wrapped in a StringIO object, and the latter's tell() result is
    used.  Else (the pickle doesn't have a tell(), and it's not obvious how
    to query its current position) pos is None.
    iÿÿÿÿNt   tellc           S   s   d  S(   N(   RV   (    (    (    s!   /usr/lib/python2.7/pickletools.pyt   <lambda>/  s    i   t    s#   pickle exhausted before seeing STOPs!   at position %s, opcode %r unknowns	   <unknown>R¹   R¸   (   t	   cStringIOR   R	   t   StringIOt   hasattrRÌ   R<   R   RÀ   t   getRV   R   R^   R   R   R
   (   R¾   RÐ   t   getpost   posR]   t   opcodeR^   (    (    s!   /usr/lib/python2.7/pickletools.pyR     s.    				c         C   s  t  ƒ  } g  } d } x† t |  ƒ D]x \ } } } | d k	 r\ | j | | | f ƒ d } n  d | j k r{ | | } } q" d | j k r" | j | ƒ q" q" Wg  } d }	 xI | D]A \ } }
 } | | k rÒ | n |
 } | j |  |	 | !ƒ | }	 q± W| j |  |	 ƒ d j | ƒ S(   s7   Optimize a pickle string by removing unused PUT opcodesR¤   Rž   i    RÎ   N(   t   setRV   R   RÆ   R   t   addRÇ   (   R¥   t   getst   putst   prevposRÕ   R^   RÔ   t   prevargR?   R³   t   startt   stopR£   (    (    s!   /usr/lib/python2.7/pickletools.pyR   H  s&    		
c         C   sæ  g  } | d k r i  } n  d } g  } d | } d } xt |  ƒ D]q\ }	 }
 } | d k	 rp | d | In  d t |	 j ƒ d d !| t | ƒ |	 j f } t | |	 j ƒ } |	 j } |	 j	 } t | ƒ } d } t
 | k s|	 j d k rì| rì| d t
 k rìt
 | k st ‚ t
 | k r>| d t k s>t ‚ n  | rß| j ƒ  } | d k red } n
 d | } x | d t
 k	 r| j ƒ  qrW| j ƒ  y | j t
 ƒ } Wqét k
 rÛ|	 j d k sÒt ‚ d	 } qéXqìd
 } } n  |	 j d k r_|
 d k	 st ‚ |
 | k r&d |
 } q¯| s5d } q¯| d t
 k rNd } q¯| d | |
 <nP |	 j d k r¯|
 | k r¢t | ƒ d k s’t ‚ | |
 g } q¯d |
 } n  |
 d k	 sÁ| r| d d t |	 j ƒ 7} |
 d k	 rÿ| d t |
 ƒ 7} n  | r| d | 7} qn  | | IJ| r8t | ƒ ‚ n  t | ƒ | k  rit d | t | ƒ f ƒ ‚ n  | rz| | 3n  t
 | k r¨t
 | k s˜t ‚ | j | ƒ n  | j | ƒ qD W| d I| IJ| rât d | ƒ ‚ n  d S(   s  Produce a symbolic disassembly of a pickle.

    'pickle' is a file-like object, or string, containing a (at least one)
    pickle.  The pickle is disassembled from the current position, through
    the first STOP opcode encountered.

    Optional arg 'out' is a file-like object to which the disassembly is
    printed.  It defaults to sys.stdout.

    Optional arg 'memo' is a Python dict, used as the pickle's memo.  It
    may be mutated by dis(), if the pickle contains PUT or BINPUT opcodes.
    Passing the same memo object to another dis() call then allows disassembly
    to proceed across multiple pickles that were all created by the same
    pickler with the same memo.  Ordinarily you don't need to worry about this.

    Optional arg indentlevel is the number of blanks by which to indent
    a new MARK level.  It defaults to 4.

    In addition to printing the disassembly, some sanity checks are made:

    + All embedded opcode arguments "make sense".

    + Explicit and implicit pop operations have enough items on the stack.

    + When an opcode implicitly refers to a markobject, a markobject is
      actually on the stack.

    + A memo entry isn't referenced before it's defined.

    + The markobject isn't stored in the memo.

    + A memo entry isn't redefined.
    iÿÿÿÿt    s   %5d:s	   %-4s %s%si   R–   s   (MARK at unknown opcode offset)s   (MARK at %d)i    s   no MARK exists on stackR¤   R¦   R§   s   memo key %r already defineds'   stack is empty -- can't store into memos"   can't store markobject in the memoRž   R    R¢   s&   memo key %r has never been stored intoi
   s3   tries to pop %d items from stack with only %d itemss    highest protocol among opcodes =s   stack not empty after STOP: %rN(   R¤   R¦   R§   (   Rž   R    R¢   (   RV   R   t   reprR]   R   R   t   maxRa   R_   R`   t
   markobjectR
   R[   t   popt   indexR   RÆ   t   extend(   R¾   t   outt   memot   indentlevelt   stackt   maxprotot	   markstackt   indentchunkt   errormsgRÕ   R^   RÔ   t   linet   beforet   aftert   numtopopt   markmsgt   markpos(    (    s!   /usr/lib/python2.7/pickletools.pyR    c  s’    '	
			

		
t   _Examplec           B   s   e  Z d  „  Z RS(   c         C   s   | |  _  d  S(   N(   t   value(   R   Rô   (    (    s!   /usr/lib/python2.7/pickletools.pyR   í  s    (   R   R   R   (    (    (    s!   /usr/lib/python2.7/pickletools.pyRó   ì  s   s  
>>> import pickle
>>> x = [1, 2, (3, 4), {'abc': u"def"}]
>>> pkl = pickle.dumps(x, 0)
>>> dis(pkl)
    0: (    MARK
    1: l        LIST       (MARK at 0)
    2: p    PUT        0
    5: I    INT        1
    8: a    APPEND
    9: I    INT        2
   12: a    APPEND
   13: (    MARK
   14: I        INT        3
   17: I        INT        4
   20: t        TUPLE      (MARK at 13)
   21: p    PUT        1
   24: a    APPEND
   25: (    MARK
   26: d        DICT       (MARK at 25)
   27: p    PUT        2
   30: S    STRING     'abc'
   37: p    PUT        3
   40: V    UNICODE    u'def'
   45: p    PUT        4
   48: s    SETITEM
   49: a    APPEND
   50: .    STOP
highest protocol among opcodes = 0

Try again with a "binary" pickle.

>>> pkl = pickle.dumps(x, 1)
>>> dis(pkl)
    0: ]    EMPTY_LIST
    1: q    BINPUT     0
    3: (    MARK
    4: K        BININT1    1
    6: K        BININT1    2
    8: (        MARK
    9: K            BININT1    3
   11: K            BININT1    4
   13: t            TUPLE      (MARK at 8)
   14: q        BINPUT     1
   16: }        EMPTY_DICT
   17: q        BINPUT     2
   19: U        SHORT_BINSTRING 'abc'
   24: q        BINPUT     3
   26: X        BINUNICODE u'def'
   34: q        BINPUT     4
   36: s        SETITEM
   37: e        APPENDS    (MARK at 3)
   38: .    STOP
highest protocol among opcodes = 1

Exercise the INST/OBJ/BUILD family.

>>> import pickletools
>>> dis(pickle.dumps(pickletools.dis, 0))
    0: c    GLOBAL     'pickletools dis'
   17: p    PUT        0
   20: .    STOP
highest protocol among opcodes = 0

>>> from pickletools import _Example
>>> x = [_Example(42)] * 2
>>> dis(pickle.dumps(x, 0))
    0: (    MARK
    1: l        LIST       (MARK at 0)
    2: p    PUT        0
    5: (    MARK
    6: i        INST       'pickletools _Example' (MARK at 5)
   28: p    PUT        1
   31: (    MARK
   32: d        DICT       (MARK at 31)
   33: p    PUT        2
   36: S    STRING     'value'
   45: p    PUT        3
   48: I    INT        42
   52: s    SETITEM
   53: b    BUILD
   54: a    APPEND
   55: g    GET        1
   58: a    APPEND
   59: .    STOP
highest protocol among opcodes = 0

>>> dis(pickle.dumps(x, 1))
    0: ]    EMPTY_LIST
    1: q    BINPUT     0
    3: (    MARK
    4: (        MARK
    5: c            GLOBAL     'pickletools _Example'
   27: q            BINPUT     1
   29: o            OBJ        (MARK at 4)
   30: q        BINPUT     2
   32: }        EMPTY_DICT
   33: q        BINPUT     3
   35: U        SHORT_BINSTRING 'value'
   42: q        BINPUT     4
   44: K        BININT1    42
   46: s        SETITEM
   47: b        BUILD
   48: h        BINGET     2
   50: e        APPENDS    (MARK at 3)
   51: .    STOP
highest protocol among opcodes = 1

Try "the canonical" recursive-object test.

>>> L = []
>>> T = L,
>>> L.append(T)
>>> L[0] is T
True
>>> T[0] is L
True
>>> L[0][0] is L
True
>>> T[0][0] is T
True
>>> dis(pickle.dumps(L, 0))
    0: (    MARK
    1: l        LIST       (MARK at 0)
    2: p    PUT        0
    5: (    MARK
    6: g        GET        0
    9: t        TUPLE      (MARK at 5)
   10: p    PUT        1
   13: a    APPEND
   14: .    STOP
highest protocol among opcodes = 0

>>> dis(pickle.dumps(L, 1))
    0: ]    EMPTY_LIST
    1: q    BINPUT     0
    3: (    MARK
    4: h        BINGET     0
    6: t        TUPLE      (MARK at 3)
    7: q    BINPUT     1
    9: a    APPEND
   10: .    STOP
highest protocol among opcodes = 1

Note that, in the protocol 0 pickle of the recursive tuple, the disassembler
has to emulate the stack in order to realize that the POP opcode at 16 gets
rid of the MARK at 0.

>>> dis(pickle.dumps(T, 0))
    0: (    MARK
    1: (        MARK
    2: l            LIST       (MARK at 1)
    3: p        PUT        0
    6: (        MARK
    7: g            GET        0
   10: t            TUPLE      (MARK at 6)
   11: p        PUT        1
   14: a        APPEND
   15: 0        POP
   16: 0        POP        (MARK at 0)
   17: g    GET        1
   20: .    STOP
highest protocol among opcodes = 0

>>> dis(pickle.dumps(T, 1))
    0: (    MARK
    1: ]        EMPTY_LIST
    2: q        BINPUT     0
    4: (        MARK
    5: h            BINGET     0
    7: t            TUPLE      (MARK at 4)
    8: q        BINPUT     1
   10: a        APPEND
   11: 1        POP_MARK   (MARK at 0)
   12: h    BINGET     1
   14: .    STOP
highest protocol among opcodes = 1

Try protocol 2.

>>> dis(pickle.dumps(L, 2))
    0: \x80 PROTO      2
    2: ]    EMPTY_LIST
    3: q    BINPUT     0
    5: h    BINGET     0
    7: \x85 TUPLE1
    8: q    BINPUT     1
   10: a    APPEND
   11: .    STOP
highest protocol among opcodes = 2

>>> dis(pickle.dumps(T, 2))
    0: \x80 PROTO      2
    2: ]    EMPTY_LIST
    3: q    BINPUT     0
    5: h    BINGET     0
    7: \x85 TUPLE1
    8: q    BINPUT     1
   10: a    APPEND
   11: 0    POP
   12: h    BINGET     1
   14: .    STOP
highest protocol among opcodes = 2
sM  
>>> import pickle
>>> from StringIO import StringIO
>>> f = StringIO()
>>> p = pickle.Pickler(f, 2)
>>> x = [1, 2, 3]
>>> p.dump(x)
>>> p.dump(x)
>>> f.seek(0)
>>> memo = {}
>>> dis(f, memo=memo)
    0: \x80 PROTO      2
    2: ]    EMPTY_LIST
    3: q    BINPUT     0
    5: (    MARK
    6: K        BININT1    1
    8: K        BININT1    2
   10: K        BININT1    3
   12: e        APPENDS    (MARK at 5)
   13: .    STOP
highest protocol among opcodes = 2
>>> dis(f, memo=memo)
   14: \x80 PROTO      2
   16: h    BINGET     0
   18: .    STOP
highest protocol among opcodes = 2
t   disassembler_testt   disassembler_memo_testc          C   s   d d  l  }  |  j ƒ  S(   Niÿÿÿÿ(   t   doctestt   testmod(   R÷   (    (    s!   /usr/lib/python2.7/pickletools.pyt   _testÝ  s    t   __main__N(    (^   t   __doc__RÂ   R   R   R   t   objectR   t   structR   R   R   R   R   R   R    R!   R<   R)   R*   R,   R-   R.   R/   R0   R1   R2   R3   R5   R6   R7   R8   R@   RA   RB   RC   RE   RF   RG   RH   R¾   RI   RJ   RK   RL   RM   RN   R   t   pyintR>   t   pylongRU   t   pyinteger_or_boolt   pyboolRD   t   pyfloatR	   t   pystringR4   t	   pyunicodeRP   RV   t   pynoneRQ   t   pytupleRW   t   pylistRX   t   pydictt	   anyobjectRá   R[   R\   Rd   t   opcodest   name2it   code2it	   enumerateR³   R’   R   R   R]   RÀ   R+   RË   R   R   R    Ró   t	   _dis_testt
   _memo_testt   __test__Rù   R   (    (    (    s!   /usr/lib/python2.7/pickletools.pyt   <module>   sh  ‘"						1																																									
		;																																
															1				
		  &	9	‰Ï

	                                                                                                                                                                                                                                                                                                                                                                                    """Conversion pipeline templates.

The problem:
------------

Suppose you have some data that you want to convert to another format,
such as from GIF image format to PPM image format.  Maybe the
conversion involves several steps (e.g. piping it through compress or
uuencode).  Some of the conversion steps may require that their input
is a disk file, others may be able to read standard input; similar for
their output.  The input to the entire conversion may also be read
from a disk file or from an open file, and similar for its output.

The module lets you construct a pipeline template by sticking one or
more conversion steps together.  It will take care of creating and
removing temporary files if they are necessary to hold intermediate
data.  You can then use the template to do conversions from many
different sources to many different destinations.  The temporary
file names used are different each time the template is used.

The templates are objects so you can create templates for many
different conversion steps and store them in a dictionary, for
instance.


Directions:
-----------

To create a template:
    t = Template()

To add a conversion step to a template:
   t.append(command, kind)
where kind is a string of two characters: the first is '-' if the
command reads its standard input or 'f' if it requires a file; the
second likewise for the output. The command must be valid /bin/sh
syntax.  If input or output files are required, they are passed as
$IN and $OUT; otherwise, it must be  possible to use the command in
a pipeline.

To add a conversion step at the beginning:
   t.prepend(command, kind)

To convert a file to another file using a template:
  sts = t.copy(infile, outfile)
If infile or outfile are the empty string, standard input is read or
standard output is written, respectively.  The return value is the
exit status of the conversion pipeline.

To open a file for reading or writing through a conversion pipeline:
   fp = t.open(file, mode)
where mode is 'r' to read the file, or 'w' to write it -- just like
for the built-in function open() or for os.popen().

To create a new template object initialized to a given one:
   t2 = t.clone()
"""                                     # '


import re
import os
import tempfile
import string

__all__ = ["Template"]

# Conversion step kinds

FILEIN_FILEOUT = 'ff'                   # Must read & write real files
STDIN_FILEOUT  = '-f'                   # Must write a real file
FILEIN_STDOUT  = 'f-'                   # Must read a real file
STDIN_STDOUT   = '--'                   # Normal pipeline element
SOURCE         = '.-'                   # Must be first, writes stdout
SINK           = '-.'                   # Must be last, reads stdin

stepkinds = [FILEIN_FILEOUT, STDIN_FILEOUT, FILEIN_STDOUT, STDIN_STDOUT, \
             SOURCE, SINK]


class Template:
    """Class representing a pipeline template."""

    def __init__(self):
        """Template() returns a fresh pipeline template."""
        self.debugging = 0
        self.reset()

    def __repr__(self):
        """t.__repr__() implements repr(t)."""
        return '<Template instance, steps=%r>' % (self.steps,)

    def reset(self):
        """t.reset() restores a pipeline template to its initial state."""
        self.steps = []

    def clone(self):
        """t.clone() returns a new pipeline template with identical
        initial state as the current one."""
        t = Template()
        t.steps = self.steps[:]
        t.debugging = self.debugging
        return t

    def debug(self, flag):
        """t.debug(flag) turns debugging on or off."""
        self.debugging = flag

    def append(self, cmd, kind):
        """t.append(cmd, kind) adds a new step at the end."""
        if type(cmd) is not type(''):
            raise TypeError, \
                  'Template.append: cmd must be a string'
        if kind not in stepkinds:
            raise ValueError, \
                  'Template.append: bad kind %r' % (kind,)
        if kind == SOURCE:
            raise ValueError, \
                  'Template.append: SOURCE can only be prepended'
        if self.steps and self.steps[-1][1] == SINK:
            raise ValueError, \
                  'Template.append: already ends with SINK'
        if kind[0] == 'f' and not re.search(r'\$IN\b', cmd):
            raise ValueError, \
                  'Template.append: missing $IN in cmd'
        if kind[1] == 'f' and not re.search(r'\$OUT\b', cmd):
            raise ValueError, \
                  'Template.append: missing $OUT in cmd'
        self.steps.append((cmd, kind))

    def prepend(self, cmd, kind):
        """t.prepend(cmd, kind) adds a new step at the front."""
        if type(cmd) is not type(''):
            raise TypeError, \
                  'Template.prepend: cmd must be a string'
        if kind not in stepkinds:
            raise ValueError, \
                  'Template.prepend: bad kind %r' % (kind,)
        if kind == SINK:
            raise ValueError, \
                  'Template.prepend: SINK can only be appended'
        if self.steps and self.steps[0][1] == SOURCE:
            raise ValueError, \
                  'Template.prepend: already begins with SOURCE'
        if kind[0] == 'f' and not re.search(r'\$IN\b', cmd):
            raise ValueError, \
                  'Template.prepend: missing $IN in cmd'
        if kind[1] == 'f' and not re.search(r'\$OUT\b', cmd):
            raise ValueError, \
                  'Template.prepend: missing $OUT in cmd'
        self.steps.insert(0, (cmd, kind))

    def open(self, file, rw):
        """t.open(file, rw) returns a pipe or file object open for
        reading or writing; the file is the other end of the pipeline."""
        if rw == 'r':
            return self.open_r(file)
        if rw == 'w':
            return self.open_w(file)
        raise ValueError, \
              'Template.open: rw must be \'r\' or \'w\', not %r' % (rw,)

    def open_r(self, file):
        """t.open_r(file) and t.open_w(file) implement
        t.open(file, 'r') and t.open(file, 'w') respectively."""
        if not self.steps:
            return open(file, 'r')
        if self.steps[-1][1] == SINK:
            raise ValueError, \
                  'Template.open_r: pipeline ends width SINK'
        cmd = self.makepipeline(file, '')
        return os.popen(cmd, 'r')

    def open_w(self, file):
        if not self.steps:
            return open(file, 'w')
        if self.steps[0][1] == SOURCE:
            raise ValueError, \
                  'Template.open_w: pipeline begins with SOURCE'
        cmd = self.makepipeline('', file)
        return os.popen(cmd, 'w')

    def copy(self, infile, outfile):
        return os.system(self.makepipeline(infile, outfile))

    def makepipeline(self, infile, outfile):
        cmd = makepipeline(infile, self.steps, outfile)
        if self.debugging:
            print cmd
            cmd = 'set -x; ' + cmd
        return cmd


def makepipeline(infile, steps, outfile):
    # Build a list with for each command:
    # [input filename or '', command string, kind, output filename or '']

    list = []
    for cmd, kind in steps:
        list.append(['', cmd, kind, ''])
    #
    # Make sure there is at least one step
    #
    if not list:
        list.append(['', 'cat', '--', ''])
    #
    # Take care of the input and output ends
    #
    [cmd, kind] = list[0][1:3]
    if kind[0] == 'f' and not infile:
        list.insert(0, ['', 'cat', '--', ''])
    list[0][0] = infile
    #
    [cmd, kind] = list[-1][1:3]
    if kind[1] == 'f' and not outfile:
        list.append(['', 'cat', '--', ''])
    list[-1][-1] = outfile
    #
    # Invent temporary files to connect stages that need files
    #
    garbage = []
    for i in range(1, len(list)):
        lkind = list[i-1][2]
        rkind = list[i][2]
        if lkind[1] == 'f' or rkind[0] == 'f':
            (fd, temp) = tempfile.mkstemp()
            os.close(fd)
            garbage.append(temp)
            list[i-1][-1] = list[i][0] = temp
    #
    for item in list:
        [inf, cmd, kind, outf] = item
        if kind[1] == 'f':
            cmd = 'OUT=' + quote(outf) + '; ' + cmd
        if kind[0] == 'f':
            cmd = 'IN=' + quote(inf) + '; ' + cmd
        if kind[0] == '-' and inf:
            cmd = cmd + ' <' + quote(inf)
        if kind[1] == '-' and outf:
            cmd = cmd + ' >' + quote(outf)
        item[1] = cmd
    #
    cmdlist = list[0][1]
    for item in list[1:]:
        [cmd, kind] = item[1:3]
        if item[0] == '':
            if 'f' in kind:
                cmd = '{ ' + cmd + '; }'
            cmdlist = cmdlist + ' |\n' + cmd
        else:
            cmdlist = cmdlist + '\n' + cmd
    #
    if garbage:
        rmcmd = 'rm -f'
        for file in garbage:
            rmcmd = rmcmd + ' ' + quote(file)
        trapcmd = 'trap ' + quote(rmcmd + '; exit') + ' 1 2 3 13 14 15'
        cmdlist = trapcmd + '\n' + cmdlist + '\n' + rmcmd
    #
    return cmdlist


# Reliably quote a string as a single argument for /bin/sh

# Safe unquoted
_safechars = frozenset(string.ascii_letters + string.digits + '@%_-+=:,./')

def quote(file):
    """Return a shell-escaped version of the file string."""
    for c in file:
        if c not in _safechars:
            break
    else:
        if not file:
            return "''"
        return file
    # use single quotes, and put single quotes into double quotes
    # the string $'b is then quoted as '$'"'"'b'
    return "'" + file.replace("'", "'\"'\"'") + "'"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ó
Ó«[c           @   s¾   d  Z  d d l Z d d l Z d d l Z d d l Z d g Z d Z d Z d Z d Z	 d Z
 d	 Z e e e e	 e
 e g Z d d d
 „  ƒ  YZ d „  Z e e j e j d ƒ Z d „  Z d S(   s†  Conversion pipeline templates.

The problem:
------------

Suppose you have some data that you want to convert to another format,
such as from GIF image format to PPM image format.  Maybe the
conversion involves several steps (e.g. piping it through compress or
uuencode).  Some of the conversion steps may require that their input
is a disk file, others may be able to read standard input; similar for
their output.  The input to the entire conversion may also be read
from a disk file or from an open file, and similar for its output.

The module lets you construct a pipeline template by sticking one or
more conversion steps together.  It will take care of creating and
removing temporary files if they are necessary to hold intermediate
data.  You can then use the template to do conversions from many
different sources to many different destinations.  The temporary
file names used are different each time the template is used.

The templates are objects so you can create templates for many
different conversion steps and store them in a dictionary, for
instance.


Directions:
-----------

To create a template:
    t = Template()

To add a conversion step to a template:
   t.append(command, kind)
where kind is a string of two characters: the first is '-' if the
command reads its standard input or 'f' if it requires a file; the
second likewise for the output. The command must be valid /bin/sh
syntax.  If input or output files are required, they are passed as
$IN and $OUT; otherwise, it must be  possible to use the command in
a pipeline.

To add a conversion step at the beginning:
   t.prepend(command, kind)

To convert a file to another file using a template:
  sts = t.copy(infile, outfile)
If infile or outfile are the empty string, standard input is read or
standard output is written, respectively.  The return value is the
exit status of the conversion pipeline.

To open a file for reading or writing through a conversion pipeline:
   fp = t.open(file, mode)
where mode is 'r' to read the file, or 'w' to write it -- just like
for the built-in function open() or for os.popen().

To create a new template object initialized to a given one:
   t2 = t.clone()
iÿÿÿÿNt   Templatet   ffs   -fs   f-s   --s   .-s   -.c           B   sz   e  Z d  Z d „  Z d „  Z d „  Z d „  Z d „  Z d „  Z d „  Z	 d „  Z
 d	 „  Z d
 „  Z d „  Z d „  Z RS(   s'   Class representing a pipeline template.c         C   s   d |  _  |  j ƒ  d S(   s-   Template() returns a fresh pipeline template.i    N(   t	   debuggingt   reset(   t   self(    (    s   /usr/lib/python2.7/pipes.pyt   __init__S   s    	c         C   s   d |  j  f S(   s    t.__repr__() implements repr(t).s   <Template instance, steps=%r>(   t   steps(   R   (    (    s   /usr/lib/python2.7/pipes.pyt   __repr__X   s    c         C   s   g  |  _  d S(   s<   t.reset() restores a pipeline template to its initial state.N(   R   (   R   (    (    s   /usr/lib/python2.7/pipes.pyR   \   s    c         C   s&   t  ƒ  } |  j | _ |  j | _ | S(   sb   t.clone() returns a new pipeline template with identical
        initial state as the current one.(   R    R   R   (   R   t   t(    (    s   /usr/lib/python2.7/pipes.pyt   clone`   s    	c         C   s   | |  _  d S(   s(   t.debug(flag) turns debugging on or off.N(   R   (   R   t   flag(    (    s   /usr/lib/python2.7/pipes.pyt   debugh   s    c         C   sÿ   t  | ƒ t  d ƒ k	 r$ t d ‚ n  | t k rC t d | f ‚ n  | t k r[ t d ‚ n  |  j r‡ |  j d d t k r‡ t d ‚ n  | d d	 k r¶ t j d
 | ƒ r¶ t d ‚ n  | d d	 k rå t j d | ƒ rå t d ‚ n  |  j j	 | | f ƒ d S(   s/   t.append(cmd, kind) adds a new step at the end.t    s%   Template.append: cmd must be a strings   Template.append: bad kind %rs-   Template.append: SOURCE can only be prependediÿÿÿÿi   s'   Template.append: already ends with SINKi    t   fs   \$IN\bs#   Template.append: missing $IN in cmds   \$OUT\bs$   Template.append: missing $OUT in cmdN(
   t   typet	   TypeErrort	   stepkindst
   ValueErrort   SOURCER   t   SINKt   ret   searcht   append(   R   t   cmdt   kind(    (    s   /usr/lib/python2.7/pipes.pyR   l   s&    		 	#	#	c         C   s  t  | ƒ t  d ƒ k	 r$ t d ‚ n  | t k rC t d | f ‚ n  | t k r[ t d ‚ n  |  j r‡ |  j d d t k r‡ t d ‚ n  | d d k r¶ t j d	 | ƒ r¶ t d
 ‚ n  | d d k rå t j d | ƒ rå t d ‚ n  |  j j	 d | | f ƒ d S(   s2   t.prepend(cmd, kind) adds a new step at the front.R   s&   Template.prepend: cmd must be a strings   Template.prepend: bad kind %rs+   Template.prepend: SINK can only be appendedi    i   s,   Template.prepend: already begins with SOURCER   s   \$IN\bs$   Template.prepend: missing $IN in cmds   \$OUT\bs%   Template.prepend: missing $OUT in cmdN(
   R   R   R   R   R   R   R   R   R   t   insert(   R   R   R   (    (    s   /usr/lib/python2.7/pipes.pyt   prepend‚   s&    		 	#	#	c         C   sF   | d k r |  j  | ƒ S| d k r2 |  j | ƒ St d | f ‚ d S(   s~   t.open(file, rw) returns a pipe or file object open for
        reading or writing; the file is the other end of the pipeline.t   rt   ws,   Template.open: rw must be 'r' or 'w', not %rN(   t   open_rt   open_wR   (   R   t   filet   rw(    (    s   /usr/lib/python2.7/pipes.pyt   open˜   s    c         C   s[   |  j  s t | d ƒ S|  j  d d t k r9 t d ‚ n  |  j | d ƒ } t j | d ƒ S(   si   t.open_r(file) and t.open_w(file) implement
        t.open(file, 'r') and t.open(file, 'w') respectively.R   iÿÿÿÿi   s)   Template.open_r: pipeline ends width SINKR   (   R   R!   R   R   t   makepipelinet   ost   popen(   R   R   R   (    (    s   /usr/lib/python2.7/pipes.pyR   ¢   s    		c         C   s[   |  j  s t | d ƒ S|  j  d d t k r9 t d ‚ n  |  j d | ƒ } t j | d ƒ S(   NR   i    i   s,   Template.open_w: pipeline begins with SOURCER   (   R   R!   R   R   R"   R#   R$   (   R   R   R   (    (    s   /usr/lib/python2.7/pipes.pyR   ­   s    		c         C   s   t  j |  j | | ƒ ƒ S(   N(   R#   t   systemR"   (   R   t   infilet   outfile(    (    s   /usr/lib/python2.7/pipes.pyt   copy¶   s    c         C   s4   t  | |  j | ƒ } |  j r0 | GHd | } n  | S(   Ns   set -x; (   R"   R   R   (   R   R&   R'   R   (    (    s   /usr/lib/python2.7/pipes.pyR"   ¹   s
    	(   t   __name__t
   __module__t   __doc__R   R   R   R	   R   R   R   R!   R   R   R(   R"   (    (    (    s   /usr/lib/python2.7/pipes.pyR    P   s   								
				c         C   sƒ  g  } x- | D]% \ } } | j  d | | d g ƒ q W| sX | j  d d d d g ƒ n  | d d d !\ } } | d d k r¥ |  r¥ | j d d d d d g ƒ n  |  | d d <| d d d !\ } } | d d k rý | rý | j  d d d d g ƒ n  | | d d <g  } xª t d t | ƒ ƒ D]“ } | | d d	 } | | d	 }	 | d d k sm|	 d d k r't j ƒ  \ }
 } t j |
 ƒ | j  | ƒ | | | d d <| | d <q'q'WxÚ | D]Ò } | \ } } } } | d d k rd
 t | ƒ d | } n  | d d k r3d t | ƒ d | } n  | d d k r`| r`| d t | ƒ } n  | d d k r| r| d t | ƒ } n  | | d <qÅW| d d } xq | d D]e } | d d !\ } } | d d k rd | k rúd | d } n  | d | } q´| d | } q´W| rd } x" | D] } | d t | ƒ } q0Wd t | d ƒ d } | d | d | } n  | S(   NR   t   cats   --i    i   i   R   iÿÿÿÿi   s   OUT=s   ; s   IN=t   -s    <s    >s   { s   ; }s    |
s   
s   rm -ft    s   trap s   ; exits    1 2 3 13 14 15(	   R   R   t   ranget   lent   tempfilet   mkstempR#   t   closet   quote(   R&   R   R'   t   listR   R   t   garbaget   it   lkindt   rkindt   fdt   tempt   itemt   inft   outft   cmdlistt   rmcmdR   t   trapcmd(    (    s   /usr/lib/python2.7/pipes.pyR"   Á   s`     %s
   @%_-+=:,./c         C   sG   x, |  D] } | t  k r Pq q W|  s+ d S|  Sd |  j d d ƒ d S(   s2   Return a shell-escaped version of the file string.s   ''t   's   '"'"'(   t
   _safecharst   replace(   R   t   c(    (    s   /usr/lib/python2.7/pipes.pyR4     s    (    (   R+   R   R#   R1   t   stringt   __all__t   FILEIN_FILEOUTt   STDIN_FILEOUTt   FILEIN_STDOUTt   STDIN_STDOUTR   R   R   R    R"   t	   frozensett   ascii_letterst   digitsRC   R4   (    (    (    s   /usr/lib/python2.7/pipes.pyt   <module>9   s"   	q	H                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    """Utilities to support packages."""

# NOTE: This module must remain compatible with Python 2.3, as it is shared
# by setuptools for distribution with Python 2.3 and up.

import os
import sys
import imp
import os.path
from types import ModuleType

__all__ = [
    'get_importer', 'iter_importers', 'get_loader', 'find_loader',
    'walk_packages', 'iter_modules', 'get_data',
    'ImpImporter', 'ImpLoader', 'read_code', 'extend_path',
]

def read_code(stream):
    # This helper is needed in order for the PEP 302 emulation to
    # correctly handle compiled files
    import marshal

    magic = stream.read(4)
    if magic != imp.get_magic():
        return None

    stream.read(4) # Skip timestamp
    return marshal.load(stream)


def simplegeneric(func):
    """Make a trivial single-dispatch generic function"""
    registry = {}
    def wrapper(*args, **kw):
        ob = args[0]
        try:
            cls = ob.__class__
        except AttributeError:
            cls = type(ob)
        try:
            mro = cls.__mro__
        except AttributeError:
            try:
                class cls(cls, object):
                    pass
                mro = cls.__mro__[1:]
            except TypeError:
                mro = object,   # must be an ExtensionClass or some such  :(
        for t in mro:
            if t in registry:
                return registry[t](*args, **kw)
        else:
            return func(*args, **kw)
    try:
        wrapper.__name__ = func.__name__
    except (TypeError, AttributeError):
        pass    # Python 2.3 doesn't allow functions to be renamed

    def register(typ, func=None):
        if func is None:
            return lambda f: register(typ, f)
        registry[typ] = func
        return func

    wrapper.__dict__ = func.__dict__
    wrapper.__doc__ = func.__doc__
    wrapper.register = register
    return wrapper


def walk_packages(path=None, prefix='', onerror=None):
    """Yields (module_loader, name, ispkg) for all modules recursively
    on path, or, if path is None, all accessible modules.

    'path' should be either None or a list of paths to look for
    modules in.

    'prefix' is a string to output on the front of every module name
    on output.

    Note that this function must import all *packages* (NOT all
    modules!) on the given path, in order to access the __path__
    attribute to find submodules.

    'onerror' is a function which gets called with one argument (the
    name of the package which was being imported) if any exception
    occurs while trying to import a package.  If no onerror function is
    supplied, ImportErrors are caught and ignored, while all other
    exceptions are propagated, terminating the search.

    Examples:

    # list all modules python can access
    walk_packages()

    # list all submodules of ctypes
    walk_packages(ctypes.__path__, ctypes.__name__+'.')
    """

    def seen(p, m={}):
        if p in m:
            return True
        m[p] = True

    for importer, name, ispkg in iter_modules(path, prefix):
        yield importer, name, ispkg

        if ispkg:
            try:
                __import__(name)
            except ImportError:
                if onerror is not None:
                    onerror(name)
            except Exception:
                if onerror is not None:
                    onerror(name)
                else:
                    raise
            else:
                path = getattr(sys.modules[name], '__path__', None) or []

                # don't traverse path items we've seen before
                path = [p for p in path if not seen(p)]

                for item in walk_packages(path, name+'.', onerror):
                    yield item


def iter_modules(path=None, prefix=''):
    """Yields (module_loader, name, ispkg) for all submodules on path,
    or, if path is None, all top-level modules on sys.path.

    'path' should be either None or a list of paths to look for
    modules in.

    'prefix' is a string to output on the front of every module name
    on output.
    """

    if path is None:
        importers = iter_importers()
    else:
        importers = map(get_importer, path)

    yielded = {}
    for i in importers:
        for name, ispkg in iter_importer_modules(i, prefix):
            if name not in yielded:
                yielded[name] = 1
                yield i, name, ispkg


#@simplegeneric
def iter_importer_modules(importer, prefix=''):
    if not hasattr(importer, 'iter_modules'):
        return []
    return importer.iter_modules(prefix)

iter_importer_modules = simplegeneric(iter_importer_modules)


class ImpImporter:
    """PEP 302 Importer that wraps Python's "classic" import algorithm

    ImpImporter(dirname) produces a PEP 302 importer that searches that
    directory.  ImpImporter(None) produces a PEP 302 importer that searches
    the current sys.path, plus any modules that are frozen or built-in.

    Note that ImpImporter does not currently support being used by placement
    on sys.meta_path.
    """

    def __init__(self, path=None):
        self.path = path

    def find_module(self, fullname, path=None):
        # Note: we ignore 'path' argument since it is only used via meta_path
        subname = fullname.split(".")[-1]
        if subname != fullname and self.path is None:
            return None
        if self.path is None:
            path = None
        else:
            path = [os.path.realpath(self.path)]
        try:
            file, filename, etc = imp.find_module(subname, path)
        except ImportError:
            return None
        return ImpLoader(fullname, file, filename, etc)

    def iter_modules(self, prefix=''):
        if self.path is None or not os.path.isdir(self.path):
            return

        yielded = {}
        import inspect
        try:
            filenames = os.listdir(self.path)
        except OSError:
            # ignore unreadable directories like import does
            filenames = []
        filenames.sort()  # handle packages before same-named modules

        for fn in filenames:
            modname = inspect.getmodulename(fn)
            if modname=='__init__' or modname in yielded:
                continue

            path = os.path.join(self.path, fn)
            ispkg = False

            if not modname and os.path.isdir(path) and '.' not in fn:
                modname = fn
                try:
                    dircontents = os.listdir(path)
                except OSError:
                    # ignore unreadable directories like import does
                    dircontents = []
                for fn in dircontents:
                    subname = inspect.getmodulename(fn)
                    if subname=='__init__':
                        ispkg = True
                        break
                else:
                    continue    # not a package

            if modname and '.' not in modname:
                yielded[modname] = 1
                yield prefix + modname, ispkg


class ImpLoader:
    """PEP 302 Loader that wraps Python's "classic" import algorithm
    """
    code = source = None

    def __init__(self, fullname, file, filename, etc):
        self.file = file
        self.filename = filename
        self.fullname = fullname
        self.etc = etc

    def load_module(self, fullname):
        self._reopen()
        try:
            mod = imp.load_module(fullname, self.file, self.filename, self.etc)
        finally:
            if self.file:
                self.file.close()
        # Note: we don't set __loader__ because we want the module to look
        # normal; i.e. this is just a wrapper for standard import machinery
        return mod

    def get_data(self, pathname):
        return open(pathname, "rb").read()

    def _reopen(self):
        if self.file and self.file.closed:
            mod_type = self.etc[2]
            if mod_type==imp.PY_SOURCE:
                self.file = open(self.filename, 'rU')
            elif mod_type in (imp.PY_COMPILED, imp.C_EXTENSION):
                self.file = open(self.filename, 'rb')

    def _fix_name(self, fullname):
        if fullname is None:
            fullname = self.fullname
        elif fullname != self.fullname:
            raise ImportError("Loader for module %s cannot handle "
                              "module %s" % (self.fullname, fullname))
        return fullname

    def is_package(self, fullname):
        fullname = self._fix_name(fullname)
        return self.etc[2]==imp.PKG_DIRECTORY

    def get_code(self, fullname=None):
        fullname = self._fix_name(fullname)
        if self.code is None:
            mod_type = self.etc[2]
            if mod_type==imp.PY_SOURCE:
                source = self.get_source(fullname)
                self.code = compile(source, self.filename, 'exec')
            elif mod_type==imp.PY_COMPILED:
                self._reopen()
                try:
                    self.code = read_code(self.file)
                finally:
                    self.file.close()
            elif mod_type==imp.PKG_DIRECTORY:
                self.code = self._get_delegate().get_code()
        return self.code

    def get_source(self, fullname=None):
        fullname = self._fix_name(fullname)
        if self.source is None:
            mod_type = self.etc[2]
            if mod_type==imp.PY_SOURCE:
                self._reopen()
                try:
                    self.source = self.file.read()
                finally:
                    self.file.close()
            elif mod_type==imp.PY_COMPILED:
                if os.path.exists(self.filename[:-1]):
                    f = open(self.filename[:-1], 'rU')
                    self.source = f.read()
                    f.close()
            elif mod_type==imp.PKG_DIRECTORY:
                self.source = self._get_delegate().get_source()
        return self.source


    def _get_delegate(self):
        return ImpImporter(self.filename).find_module('__init__')

    def get_filename(self, fullname=None):
        fullname = self._fix_name(fullname)
        mod_type = self.etc[2]
        if self.etc[2]==imp.PKG_DIRECTORY:
            return self._get_delegate().get_filename()
        elif self.etc[2] in (imp.PY_SOURCE, imp.PY_COMPILED, imp.C_EXTENSION):
            return self.filename
        return None


try:
    import zipimport
    from zipimport import zipimporter

    def iter_zipimport_modules(importer, prefix=''):
        dirlist = zipimport._zip_directory_cache[importer.archive].keys()
        dirlist.sort()
        _prefix = importer.prefix
        plen = len(_prefix)
        yielded = {}
        import inspect
        for fn in dirlist:
            if not fn.startswith(_prefix):
                continue

            fn = fn[plen:].split(os.sep)

            if len(fn)==2 and fn[1].startswith('__init__.py'):
                if fn[0] not in yielded:
                    yielded[fn[0]] = 1
                    yield fn[0], True

            if len(fn)!=1:
                continue

            modname = inspect.getmodulename(fn[0])
            if modname=='__init__':
                continue

            if modname and '.' not in modname and modname not in yielded:
                yielded[modname] = 1
                yield prefix + modname, False

    iter_importer_modules.register(zipimporter, iter_zipimport_modules)

except ImportError:
    pass


def get_importer(path_item):
    """Retrieve a PEP 302 importer for the given path item

    The returned importer is cached in sys.path_importer_cache
    if it was newly created by a path hook.

    If there is no importer, a wrapper around the basic import
    machinery is returned. This wrapper is never inserted into
    the importer cache (None is inserted instead).

    The cache (or part of it) can be cleared manually if a
    rescan of sys.path_hooks is necessary.
    """
    try:
        importer = sys.path_importer_cache[path_item]
    except KeyError:
        for path_hook in sys.path_hooks:
            try:
                importer = path_hook(path_item)
                break
            except ImportError:
                pass
        else:
            importer = None
        sys.path_importer_cache.setdefault(path_item, importer)

    if importer is None:
        try:
            importer = ImpImporter(path_item)
        except ImportError:
            importer = None
    return importer


def iter_importers(fullname=""):
    """Yield PEP 302 importers for the given module name

    If fullname contains a '.', the importers will be for the package
    containing fullname, otherwise they will be importers for sys.meta_path,
    sys.path, and Python's "classic" import machinery, in that order.  If
    the named module is in a package, that package is imported as a side
    effect of invoking this function.

    Non PEP 302 mechanisms (e.g. the Windows registry) used by the
    standard import machinery to find files in alternative locations
    are partially supported, but are searched AFTER sys.path. Normally,
    these locations are searched BEFORE sys.path, preventing sys.path
    entries from shadowing them.

    For this to cause a visible difference in behaviour, there must
    be a module or package name that is accessible via both sys.path
    and one of the non PEP 302 file system mechanisms. In this case,
    the emulation will find the former version, while the builtin
    import mechanism will find the latter.

    Items of the following types can be affected by this discrepancy:
        imp.C_EXTENSION, imp.PY_SOURCE, imp.PY_COMPILED, imp.PKG_DIRECTORY
    """
    if fullname.startswith('.'):
        raise ImportError("Relative module names not supported")
    if '.' in fullname:
        # Get the containing package's __path__
        pkg = '.'.join(fullname.split('.')[:-1])
        if pkg not in sys.modules:
            __import__(pkg)
        path = getattr(sys.modules[pkg], '__path__', None) or []
    else:
        for importer in sys.meta_path:
            yield importer
        path = sys.path
    for item in path:
        yield get_importer(item)
    if '.' not in fullname:
        yield ImpImporter()

def get_loader(module_or_name):
    """Get a PEP 302 "loader" object for module_or_name

    If the module or package is accessible via the normal import
    mechanism, a wrapper around the relevant part of that machinery
    is returned.  Returns None if the module cannot be found or imported.
    If the named module is not already imported, its containing package
    (if any) is imported, in order to establish the package __path__.

    This function uses iter_importers(), and is thus subject to the same
    limitations regarding platform-specific special import locations such
    as the Windows registry.
    """
    if module_or_name in sys.modules:
        module_or_name = sys.modules[module_or_name]
    if isinstance(module_or_name, ModuleType):
        module = module_or_name
        loader = getattr(module, '__loader__', None)
        if loader is not None:
            return loader
        fullname = module.__name__
    else:
        fullname = module_or_name
    return find_loader(fullname)

def find_loader(fullname):
    """Find a PEP 302 "loader" object for fullname

    If fullname contains dots, path must be the containing package's __path__.
    Returns None if the module cannot be found or imported. This function uses
    iter_importers(), and is thus subject to the same limitations regarding
    platform-specific special import locations such as the Windows registry.
    """
    for importer in iter_importers(fullname):
        loader = importer.find_module(fullname)
        if loader is not None:
            return loader

    return None


def extend_path(path, name):
    """Extend a package's path.

    Intended use is to place the following code in a package's __init__.py:

        from pkgutil import extend_path
        __path__ = extend_path(__path__, __name__)

    This will add to the package's __path__ all subdirectories of
    directories on sys.path named after the package.  This is useful
    if one wants to distribute different parts of a single logical
    package as multiple directories.

    It also looks for *.pkg files beginning where * matches the name
    argument.  This feature is similar to *.pth files (see site.py),
    except that it doesn't special-case lines starting with 'import'.
    A *.pkg file is trusted at face value: apart from checking for
    duplicates, all entries found in a *.pkg file are added to the
    path, regardless of whether they are exist the filesystem.  (This
    is a feature.)

    If the input path is not a list (as is the case for frozen
    packages) it is returned unchanged.  The input path is not
    modified; an extended copy is returned.  Items are only appended
    to the copy at the end.

    It is assumed that sys.path is a sequence.  Items of sys.path that
    are not (unicode or 8-bit) strings referring to existing
    directories are ignored.  Unicode items of sys.path that cause
    errors when used as filenames may cause this function to raise an
    exception (in line with os.path.isdir() behavior).
    """

    if not isinstance(path, list):
        # This could happen e.g. when this is called from inside a
        # frozen package.  Return the path unchanged in that case.
        return path

    pname = os.path.join(*name.split('.')) # Reconstitute as relative path
    # Just in case os.extsep != '.'
    sname = os.extsep.join(name.split('.'))
    sname_pkg = sname + os.extsep + "pkg"
    init_py = "__init__" + os.extsep + "py"

    path = path[:] # Start with a copy of the existing path

    for dir in sys.path:
        if not isinstance(dir, basestring) or not os.path.isdir(dir):
            continue
        subdir = os.path.join(dir, pname)
        # XXX This may still add duplicate entries to path on
        # case-insensitive filesystems
        initfile = os.path.join(subdir, init_py)
        if subdir not in path and os.path.isfile(initfile):
            path.append(subdir)
        # XXX Is this the right thing for subpackages like zope.app?
        # It looks for a file named "zope.app.pkg"
        pkgfile = os.path.join(dir, sname_pkg)
        if os.path.isfile(pkgfile):
            try:
                f = open(pkgfile)
            except IOError, msg:
                sys.stderr.write("Can't open %s: %s\n" %
                                 (pkgfile, msg))
            else:
                for line in f:
                    line = line.rstrip('\n')
                    if not line or line.startswith('#'):
                        continue
                    path.append(line) # Don't check for existence!
                f.close()

    return path

def get_data(package, resource):
    """Get a resource from a package.

    This is a wrapper round the PEP 302 loader get_data API. The package
    argument should be the name of a package, in standard module format
    (foo.bar). The resource argument should be in the form of a relative
    filename, using '/' as the path separator. The parent directory name '..'
    is not allowed, and nor is a rooted name (starting with a '/').

    The function returns a binary string, which is the contents of the
    specified resource.

    For packages located in the filesystem, which have already been imported,
    this is the rough equivalent of

        d = os.path.dirname(sys.modules[package].__file__)
        data = open(os.path.join(d, resource), 'rb').read()

    If the package cannot be located or loaded, or it uses a PEP 302 loader
    which does not support get_data(), then None is returned.
    """

    loader = get_loader(package)
    if loader is None or not hasattr(loader, 'get_data'):
        return None
    mod = sys.modules.get(package) or loader.load_module(package)
    if mod is None or not hasattr(mod, '__file__'):
        return None

    # Modify the resource name to be compatible with the loader.get_data
    # signature - an os.path format "filename" starting with the dirname of
    # the package's __file__
    parts = resource.split('/')
    parts.insert(0, os.path.dirname(mod.__file__))
    resource_name = os.path.join(*parts)
    return loader.get_data(resource_name)
                                                                                                                                      ó
Ó«[c           @   sk  d  Z  d d l Z d d l Z d d l Z d d l Z d d l m Z d d d d d d	 d
 d d d d g Z d „  Z d „  Z	 d d d d „ Z d d d „ Z d d „ Z e	 e ƒ Z d d d „  ƒ  YZ d d  d „  ƒ  YZ y< d d l Z d d l m Z d d „ Z e j e e ƒ Wn e k
 r-n Xd „  Z d d „ Z d „  Z d „  Z d „  Z d „  Z d S(!   s   Utilities to support packages.iÿÿÿÿN(   t
   ModuleTypet   get_importert   iter_importerst
   get_loadert   find_loadert   walk_packagest   iter_modulest   get_datat   ImpImportert	   ImpLoadert	   read_codet   extend_pathc         C   sK   d d  l  } |  j d ƒ } | t j ƒ  k r1 d  S|  j d ƒ | j |  ƒ S(   Niÿÿÿÿi   (   t   marshalt   readt   impt	   get_magict   Nonet   load(   t   streamR   t   magic(    (    s   /usr/lib/python2.7/pkgutil.pyR
      s    c            s|   i  ‰ ‡  ‡ f d †  } y ˆ  j  | _  Wn t t f k
 rA n Xd ‡ ‡ f d † ‰ ˆ  j | _ ˆ  j | _ ˆ | _ | S(   s/   Make a trivial single-dispatch generic functionc             sÞ   |  d } y | j  } Wn t k
 r6 t | ƒ } n Xy | j } WnX t k
 rž y* d | t f d „  ƒ  Y} | j d } WqŸ t k
 rš t f } qŸ Xn Xx8 | D]# } | ˆ k r¦ ˆ | |  | Ž  Sq¦ Wˆ  |  | Ž  Sd  S(   Ni    t   clsc           B   s   e  Z RS(    (   t   __name__t
   __module__(    (    (    s   /usr/lib/python2.7/pkgutil.pyR   ,   s   i   (   t	   __class__t   AttributeErrort   typet   __mro__t   objectt	   TypeError(   t   argst   kwt   obR   t   mrot   t(   t   funct   registry(    s   /usr/lib/python2.7/pkgutil.pyt   wrapper"   s"    
c            s*   | d  k r ‡ ‡  f d †  S| ˆ ˆ  <| S(   Nc            s   ˆ  ˆ |  ƒ S(   N(    (   t   f(   t   registert   typ(    s   /usr/lib/python2.7/pkgutil.pyt   <lambda>=   s    (   R   (   R'   R"   (   R&   R#   (   R'   s   /usr/lib/python2.7/pkgutil.pyR&   ;   s    
N(   R   R   R   R   t   __dict__t   __doc__R&   (   R"   R$   (    (   R"   R&   R#   s   /usr/lib/python2.7/pkgutil.pyt   simplegeneric   s    	t    c   	      c   s  i  d „ } xt  |  | ƒ D]÷ \ } } } | | | f V| r y t | ƒ WnV t k
 ry | d k	 r| | ƒ qqt k
 r¥ | d k	 rŸ | | ƒ q‚  qXt t j | d d ƒ pÂ g  }  g  |  D] } | | ƒ sÌ | ^ qÌ }  x& t |  | d | ƒ D] } | VqWq q Wd S(   s½  Yields (module_loader, name, ispkg) for all modules recursively
    on path, or, if path is None, all accessible modules.

    'path' should be either None or a list of paths to look for
    modules in.

    'prefix' is a string to output on the front of every module name
    on output.

    Note that this function must import all *packages* (NOT all
    modules!) on the given path, in order to access the __path__
    attribute to find submodules.

    'onerror' is a function which gets called with one argument (the
    name of the package which was being imported) if any exception
    occurs while trying to import a package.  If no onerror function is
    supplied, ImportErrors are caught and ignored, while all other
    exceptions are propagated, terminating the search.

    Examples:

    # list all modules python can access
    walk_packages()

    # list all submodules of ctypes
    walk_packages(ctypes.__path__, ctypes.__name__+'.')
    c         S   s   |  | k r t  St  | |  <d  S(   N(   t   True(   t   pt   m(    (    s   /usr/lib/python2.7/pkgutil.pyt   seend   s    t   __path__t   .N(	   R   t
   __import__t   ImportErrorR   t	   Exceptiont   getattrt   syst   modulesR   (	   t   patht   prefixt   onerrorR0   t   importert   namet   ispkgR.   t   item(    (    s   /usr/lib/python2.7/pkgutil.pyR   G   s"    %c         c   s‰   |  d k r t ƒ  } n t t |  ƒ } i  } xU | D]M } xD t | | ƒ D]3 \ } } | | k rJ d | | <| | | f VqJ qJ Wq4 Wd S(   s&  Yields (module_loader, name, ispkg) for all submodules on path,
    or, if path is None, all top-level modules on sys.path.

    'path' should be either None or a list of paths to look for
    modules in.

    'prefix' is a string to output on the front of every module name
    on output.
    i   N(   R   R   t   mapR   t   iter_importer_modules(   R9   R:   t	   importerst   yieldedt   iR=   R>   (    (    s   /usr/lib/python2.7/pkgutil.pyR      s    
c         C   s    t  |  d ƒ s g  S|  j | ƒ S(   NR   (   t   hasattrR   (   R<   R:   (    (    s   /usr/lib/python2.7/pkgutil.pyRA   š   s    c           B   s2   e  Z d  Z d d „ Z d d „ Z d d „ Z RS(   s…  PEP 302 Importer that wraps Python's "classic" import algorithm

    ImpImporter(dirname) produces a PEP 302 importer that searches that
    directory.  ImpImporter(None) produces a PEP 302 importer that searches
    the current sys.path, plus any modules that are frozen or built-in.

    Note that ImpImporter does not currently support being used by placement
    on sys.meta_path.
    c         C   s   | |  _  d  S(   N(   R9   (   t   selfR9   (    (    s   /usr/lib/python2.7/pkgutil.pyt   __init__­   s    c         C   s©   | j  d ƒ d } | | k r2 |  j d  k r2 d  S|  j d  k rJ d  } n t j j |  j ƒ g } y t j | | ƒ \ } } } Wn t k
 r• d  SXt | | | | ƒ S(   NR2   iÿÿÿÿ(	   t   splitR9   R   t   ost   realpathR   t   find_moduleR4   R	   (   RF   t   fullnameR9   t   subnamet   filet   filenamet   etc(    (    s   /usr/lib/python2.7/pkgutil.pyRK   °   s    	R,   c         c   s—  |  j  d  k s% t j  j |  j  ƒ r) d  Si  } d d  l } y t j |  j  ƒ } Wn t k
 rj g  } n X| j ƒ  x| D]} | j | ƒ } | d k s| | | k r¯ q| n  t j  j	 |  j  | ƒ } t
 } | rat j  j | ƒ rad | k ra| } y t j | ƒ }	 Wn t k
 r$g  }	 n Xx9 |	 D]+ } | j | ƒ }
 |
 d k r,t } Pq,q,Wq| n  | r| d | k r| d | | <| | | f Vq| q| Wd  S(   NiÿÿÿÿRG   R2   i   (   R9   R   RI   t   isdirt   inspectt   listdirt   OSErrort   sortt   getmodulenamet   joint   FalseR-   (   RF   R:   RC   RR   t	   filenamest   fnt   modnameR9   R>   t   dircontentsRM   (    (    s   /usr/lib/python2.7/pkgutil.pyR   ¿   s<    %

%

N(   R   R   R*   R   RG   RK   R   (    (    (    s   /usr/lib/python2.7/pkgutil.pyR   ¢   s   	c           B   s{   e  Z d  Z d Z Z d „  Z d „  Z d „  Z d „  Z	 d „  Z
 d „  Z d d „ Z d d „ Z d	 „  Z d d
 „ Z RS(   sB   PEP 302 Loader that wraps Python's "classic" import algorithm
    c         C   s(   | |  _  | |  _ | |  _ | |  _ d  S(   N(   RN   RO   RL   RP   (   RF   RL   RN   RO   RP   (    (    s   /usr/lib/python2.7/pkgutil.pyRG   í   s    			c         C   sP   |  j  ƒ  z% t j | |  j |  j |  j ƒ } Wd  |  j rK |  j j ƒ  n  X| S(   N(   t   _reopenR   t   load_moduleRN   RO   RP   t   close(   RF   RL   t   mod(    (    s   /usr/lib/python2.7/pkgutil.pyR^   ó   s    
%	c         C   s   t  | d ƒ j ƒ  S(   Nt   rb(   t   openR   (   RF   t   pathname(    (    s   /usr/lib/python2.7/pkgutil.pyR   þ   s    c         C   s€   |  j  r| |  j  j r| |  j d } | t j k rI t |  j d ƒ |  _  q| | t j t j f k r| t |  j d ƒ |  _  q| n  d  S(   Ni   t   rURa   (	   RN   t   closedRP   R   t	   PY_SOURCERb   RO   t   PY_COMPILEDt   C_EXTENSION(   RF   t   mod_type(    (    s   /usr/lib/python2.7/pkgutil.pyR]     s    c         C   sG   | d  k r |  j } n+ | |  j k rC t d |  j | f ƒ ‚ n  | S(   Ns,   Loader for module %s cannot handle module %s(   R   RL   R4   (   RF   RL   (    (    s   /usr/lib/python2.7/pkgutil.pyt	   _fix_name	  s    c         C   s#   |  j  | ƒ } |  j d t j k S(   Ni   (   Rj   RP   R   t   PKG_DIRECTORY(   RF   RL   (    (    s   /usr/lib/python2.7/pkgutil.pyt
   is_package  s    c         C   sØ   |  j  | ƒ } |  j d  k rÑ |  j d } | t j k rd |  j | ƒ } t | |  j d ƒ |  _ qÑ | t j	 k r§ |  j
 ƒ  z t |  j ƒ |  _ Wd  |  j j ƒ  XqÑ | t j k rÑ |  j ƒ  j ƒ  |  _ qÑ n  |  j S(   Ni   t   exec(   Rj   t   codeR   RP   R   Rf   t
   get_sourcet   compileRO   Rg   R]   R
   RN   R_   Rk   t   _get_delegatet   get_code(   RF   RL   Ri   t   source(    (    s   /usr/lib/python2.7/pkgutil.pyRr     s    
c         C   sü   |  j  | ƒ } |  j d  k rõ |  j d } | t j k rn |  j ƒ  z |  j j ƒ  |  _ Wd  |  j j	 ƒ  Xqõ | t j
 k rË t j j |  j d  ƒ rò t |  j d  d ƒ } | j ƒ  |  _ | j	 ƒ  qò qõ | t j k rõ |  j ƒ  j ƒ  |  _ qõ n  |  j S(   Ni   iÿÿÿÿRd   (   Rj   Rs   R   RP   R   Rf   R]   RN   R   R_   Rg   RI   R9   t   existsRO   Rb   Rk   Rq   Ro   (   RF   RL   Ri   R%   (    (    s   /usr/lib/python2.7/pkgutil.pyRo   &  s     
c         C   s   t  |  j ƒ j d ƒ S(   NRG   (   R   RO   RK   (   RF   (    (    s   /usr/lib/python2.7/pkgutil.pyRq   :  s    c         C   sr   |  j  | ƒ } |  j d } |  j d t j k rB |  j ƒ  j ƒ  S|  j d t j t j t j f k rn |  j	 Sd  S(   Ni   (   Rj   RP   R   Rk   Rq   t   get_filenameRf   Rg   Rh   RO   R   (   RF   RL   Ri   (    (    s   /usr/lib/python2.7/pkgutil.pyRu   =  s    %N(   R   R   R*   R   Rn   Rs   RG   R^   R   R]   Rj   Rl   Rr   Ro   Rq   Ru   (    (    (    s   /usr/lib/python2.7/pkgutil.pyR	   è   s   
							(   t   zipimporterc   	      c   sV  t  j |  j j ƒ  } | j ƒ  |  j } t | ƒ } i  } d d  l } x| D] } | j | ƒ si qN n  | | j	 t
 j ƒ } t | ƒ d k r× | d j d ƒ r× | d | k r× d | | d <| d t f Vq× n  t | ƒ d k rï qN n  | j | d ƒ } | d k rqN n  | rN d | k rN | | k rN d | | <| | t f VqN qN Wd  S(   Niÿÿÿÿi   i   s   __init__.pyi    RG   R2   (   t	   zipimportt   _zip_directory_cachet   archivet   keysRU   R:   t   lenRR   t
   startswithRH   RI   t   sepR-   RV   RX   (	   R<   R:   t   dirlistt   _prefixt   plenRC   RR   RZ   R[   (    (    s   /usr/lib/python2.7/pkgutil.pyt   iter_zipimport_modulesK  s,    
	%
c         C   s´   y t  j |  } Wnc t k
 rv x< t  j D]+ } y | |  ƒ } PWq+ t k
 rU q+ Xq+ Wd } t  j j |  | ƒ n X| d k r° y t |  ƒ } Wq° t k
 r¬ d } q° Xn  | S(   s½  Retrieve a PEP 302 importer for the given path item

    The returned importer is cached in sys.path_importer_cache
    if it was newly created by a path hook.

    If there is no importer, a wrapper around the basic import
    machinery is returned. This wrapper is never inserted into
    the importer cache (None is inserted instead).

    The cache (or part of it) can be cleared manually if a
    rescan of sys.path_hooks is necessary.
    N(   R7   t   path_importer_cachet   KeyErrort
   path_hooksR4   R   t
   setdefaultR   (   t	   path_itemR<   t	   path_hook(    (    s   /usr/lib/python2.7/pkgutil.pyR   n  s"    c         c   sÝ   |  j  d ƒ r t d ƒ ‚ n  d |  k r„ d j |  j d ƒ d  ƒ } | t j k rb t | ƒ n  t t j | d d ƒ p~ g  } n" x t j	 D] } | VqŽ Wt j
 } x | D] } t | ƒ Vq­ Wd |  k rÙ t ƒ  Vn  d S(   s‰  Yield PEP 302 importers for the given module name

    If fullname contains a '.', the importers will be for the package
    containing fullname, otherwise they will be importers for sys.meta_path,
    sys.path, and Python's "classic" import machinery, in that order.  If
    the named module is in a package, that package is imported as a side
    effect of invoking this function.

    Non PEP 302 mechanisms (e.g. the Windows registry) used by the
    standard import machinery to find files in alternative locations
    are partially supported, but are searched AFTER sys.path. Normally,
    these locations are searched BEFORE sys.path, preventing sys.path
    entries from shadowing them.

    For this to cause a visible difference in behaviour, there must
    be a module or package name that is accessible via both sys.path
    and one of the non PEP 302 file system mechanisms. In this case,
    the emulation will find the former version, while the builtin
    import mechanism will find the latter.

    Items of the following types can be affected by this discrepancy:
        imp.C_EXTENSION, imp.PY_SOURCE, imp.PY_COMPILED, imp.PKG_DIRECTORY
    R2   s#   Relative module names not supportediÿÿÿÿR1   N(   R|   R4   RW   RH   R7   R8   R3   R6   R   t	   meta_pathR9   R   R   (   RL   t   pkgR9   R<   R?   (    (    s   /usr/lib/python2.7/pkgutil.pyR     s    "		c         C   sr   |  t  j k r t  j |  }  n  t |  t ƒ rb |  } t | d d ƒ } | d k	 rV | S| j } n |  } t | ƒ S(   sD  Get a PEP 302 "loader" object for module_or_name

    If the module or package is accessible via the normal import
    mechanism, a wrapper around the relevant part of that machinery
    is returned.  Returns None if the module cannot be found or imported.
    If the named module is not already imported, its containing package
    (if any) is imported, in order to establish the package __path__.

    This function uses iter_importers(), and is thus subject to the same
    limitations regarding platform-specific special import locations such
    as the Windows registry.
    t
   __loader__N(   R7   R8   t
   isinstanceR    R6   R   R   R   (   t   module_or_namet   modulet   loaderRL   (    (    s   /usr/lib/python2.7/pkgutil.pyR   ¹  s    c         C   s:   x3 t  |  ƒ D]% } | j |  ƒ } | d k	 r | Sq Wd S(   sh  Find a PEP 302 "loader" object for fullname

    If fullname contains dots, path must be the containing package's __path__.
    Returns None if the module cannot be found or imported. This function uses
    iter_importers(), and is thus subject to the same limitations regarding
    platform-specific special import locations such as the Windows registry.
    N(   R   RK   R   (   RL   R<   RŽ   (    (    s   /usr/lib/python2.7/pkgutil.pyR   Ò  s
    c         C   sÈ  t  |  t ƒ s |  St j j | j d ƒ Œ  } t j j | j d ƒ ƒ } | t j d } d t j d } |  }  xOt j D]D} t  | t ƒ s| t j j	 | ƒ r« q| n  t j j | | ƒ } t j j | | ƒ } | |  k rt j j
 | ƒ r|  j | ƒ n  t j j | | ƒ }	 t j j
 |	 ƒ r| y t |	 ƒ }
 Wn- t k
 ri} t j j d |	 | f ƒ qÀXxF |
 D]> } | j d ƒ } | sq| j d ƒ r¢qqn  |  j | ƒ qqW|
 j ƒ  q| q| W|  S(   s‹  Extend a package's path.

    Intended use is to place the following code in a package's __init__.py:

        from pkgutil import extend_path
        __path__ = extend_path(__path__, __name__)

    This will add to the package's __path__ all subdirectories of
    directories on sys.path named after the package.  This is useful
    if one wants to distribute different parts of a single logical
    package as multiple directories.

    It also looks for *.pkg files beginning where * matches the name
    argument.  This feature is similar to *.pth files (see site.py),
    except that it doesn't special-case lines starting with 'import'.
    A *.pkg file is trusted at face value: apart from checking for
    duplicates, all entries found in a *.pkg file are added to the
    path, regardless of whether they are exist the filesystem.  (This
    is a feature.)

    If the input path is not a list (as is the case for frozen
    packages) it is returned unchanged.  The input path is not
    modified; an extended copy is returned.  Items are only appended
    to the copy at the end.

    It is assumed that sys.path is a sequence.  Items of sys.path that
    are not (unicode or 8-bit) strings referring to existing
    directories are ignored.  Unicode items of sys.path that cause
    errors when used as filenames may cause this function to raise an
    exception (in line with os.path.isdir() behavior).
    R2   R‰   RG   t   pys   Can't open %s: %s
s   
t   #(   R‹   t   listRI   R9   RW   RH   t   extsepR7   t
   basestringRQ   t   isfilet   appendRb   t   IOErrort   stderrt   writet   rstripR|   R_   (   R9   R=   t   pnamet   snamet	   sname_pkgt   init_pyt   dirt   subdirt   initfilet   pkgfileR%   t   msgt   line(    (    s   /usr/lib/python2.7/pkgutil.pyR   â  s8    !#c         C   sº   t  |  ƒ } | d k s( t | d ƒ r, d St j j |  ƒ pJ | j |  ƒ } | d k si t | d ƒ rm d S| j d ƒ } | j d t	 j
 j | j ƒ ƒ t	 j
 j | Œ  } | j | ƒ S(   sf  Get a resource from a package.

    This is a wrapper round the PEP 302 loader get_data API. The package
    argument should be the name of a package, in standard module format
    (foo.bar). The resource argument should be in the form of a relative
    filename, using '/' as the path separator. The parent directory name '..'
    is not allowed, and nor is a rooted name (starting with a '/').

    The function returns a binary string, which is the contents of the
    specified resource.

    For packages located in the filesystem, which have already been imported,
    this is the rough equivalent of

        d = os.path.dirname(sys.modules[package].__file__)
        data = open(os.path.join(d, resource), 'rb').read()

    If the package cannot be located or loaded, or it uses a PEP 302 loader
    which does not support get_data(), then None is returned.
    R   t   __file__t   /i    N(   R   R   RE   R7   R8   t   getR^   RH   t   insertRI   R9   t   dirnameR¤   RW   R   (   t   packaget   resourceRŽ   R`   t   partst   resource_name(    (    s   /usr/lib/python2.7/pkgutil.pyR   ,  s    !(    (    (   R*   RI   R7   R   t   os.patht   typesR    t   __all__R
   R+   R   R   R   RA   R   R	   Rw   Rv   R   R&   R4   R   R   R   R   R   R   (    (    (    s   /usr/lib/python2.7/pkgutil.pyt   <module>   s:   			(:F_	")			J                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             #! /usr/bin/python2.7

""" This module tries to retrieve as much platform-identifying data as
    possible. It makes this information available via function APIs.

    If called from the command line, it prints the platform
    information concatenated as single string to stdout. The output
    format is useable as part of a filename.

"""
#    This module is maintained by Marc-Andre Lemburg <mal@egenix.com>.
#    If you find problems, please submit bug reports/patches via the
#    Python bug tracker (http://bugs.python.org) and assign them to "lemburg".
#
#    Note: Please keep this module compatible to Python 1.5.2.
#
#    Still needed:
#    * more support for WinCE
#    * support for MS-DOS (PythonDX ?)
#    * support for Amiga and other still unsupported platforms running Python
#    * support for additional Linux distributions
#
#    Many thanks to all those who helped adding platform-specific
#    checks (in no particular order):
#
#      Charles G Waldman, David Arnold, Gordon McMillan, Ben Darnell,
#      Jeff Bauer, Cliff Crawford, Ivan Van Laningham, Josef
#      Betancourt, Randall Hopper, Karl Putland, John Farrell, Greg
#      Andruk, Just van Rossum, Thomas Heller, Mark R. Levinson, Mark
#      Hammond, Bill Tutt, Hans Nowak, Uwe Zessin (OpenVMS support),
#      Colin Kong, Trent Mick, Guido van Rossum, Anthony Baxter, Steve
#      Dower
#
#    History:
#
#    <see CVS and SVN checkin messages for history>
#
#    1.0.8 - changed Windows support to read version from kernel32.dll
#    1.0.7 - added DEV_NULL
#    1.0.6 - added linux_distribution()
#    1.0.5 - fixed Java support to allow running the module on Jython
#    1.0.4 - added IronPython support
#    1.0.3 - added normalization of Windows system name
#    1.0.2 - added more Windows support
#    1.0.1 - reformatted to make doc.py happy
#    1.0.0 - reformatted a bit and checked into Python CVS
#    0.8.0 - added sys.version parser and various new access
#            APIs (python_version(), python_compiler(), etc.)
#    0.7.2 - fixed architecture() to use sizeof(pointer) where available
#    0.7.1 - added support for Caldera OpenLinux
#    0.7.0 - some fixes for WinCE; untabified the source file
#    0.6.2 - support for OpenVMS - requires version 1.5.2-V006 or higher and
#            vms_lib.getsyi() configured
#    0.6.1 - added code to prevent 'uname -p' on platforms which are
#            known not to support it
#    0.6.0 - fixed win32_ver() to hopefully work on Win95,98,NT and Win2k;
#            did some cleanup of the interfaces - some APIs have changed
#    0.5.5 - fixed another type in the MacOS code... should have
#            used more coffee today ;-)
#    0.5.4 - fixed a few typos in the MacOS code
#    0.5.3 - added experimental MacOS support; added better popen()
#            workarounds in _syscmd_ver() -- still not 100% elegant
#            though
#    0.5.2 - fixed uname() to return '' instead of 'unknown' in all
#            return values (the system uname command tends to return
#            'unknown' instead of just leaving the field empty)
#    0.5.1 - included code for slackware dist; added exception handlers
#            to cover up situations where platforms don't have os.popen
#            (e.g. Mac) or fail on socket.gethostname(); fixed libc
#            detection RE
#    0.5.0 - changed the API names referring to system commands to *syscmd*;
#            added java_ver(); made syscmd_ver() a private
#            API (was system_ver() in previous versions) -- use uname()
#            instead; extended the win32_ver() to also return processor
#            type information
#    0.4.0 - added win32_ver() and modified the platform() output for WinXX
#    0.3.4 - fixed a bug in _follow_symlinks()
#    0.3.3 - fixed popen() and "file" command invokation bugs
#    0.3.2 - added architecture() API and support for it in platform()
#    0.3.1 - fixed syscmd_ver() RE to support Windows NT
#    0.3.0 - added system alias support
#    0.2.3 - removed 'wince' again... oh well.
#    0.2.2 - added 'wince' to syscmd_ver() supported platforms
#    0.2.1 - added cache logic and changed the platform string format
#    0.2.0 - changed the API to use functions instead of module globals
#            since some action take too long to be run on module import
#    0.1.0 - first release
#
#    You can always get the latest version of this module at:
#
#             http://www.egenix.com/files/python/platform.py
#
#    If that URL should fail, try contacting the author.

__copyright__ = """
    Copyright (c) 1999-2000, Marc-Andre Lemburg; mailto:mal@lemburg.com
    Copyright (c) 2000-2010, eGenix.com Software GmbH; mailto:info@egenix.com

    Permission to use, copy, modify, and distribute this software and its
    documentation for any purpose and without fee or royalty is hereby granted,
    provided that the above copyright notice appear in all copies and that
    both that copyright notice and this permission notice appear in
    supporting documentation or portions thereof, including modifications,
    that you make.

    EGENIX.COM SOFTWARE GMBH DISCLAIMS ALL WARRANTIES WITH REGARD TO
    THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
    FITNESS, IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL,
    INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING
    FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
    NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
    WITH THE USE OR PERFORMANCE OF THIS SOFTWARE !

"""

__version__ = '1.0.7'

import sys,string,os,re

### Globals & Constants

# Determine the platform's /dev/null device
try:
    DEV_NULL = os.devnull
except AttributeError:
    # os.devnull was added in Python 2.4, so emulate it for earlier
    # Python versions
    if sys.platform in ('dos','win32','win16','os2'):
        # Use the old CP/M NUL as device name
        DEV_NULL = 'NUL'
    else:
        # Standard Unix uses /dev/null
        DEV_NULL = '/dev/null'

### Platform specific APIs

_libc_search = re.compile(r'(__libc_init)'
                          '|'
                          '(GLIBC_([0-9.]+))'
                          '|'
                          '(libc(_\w+)?\.so(?:\.(\d[0-9.]*))?)')

def libc_ver(executable=sys.executable,lib='',version='',

             chunksize=2048):

    """ Tries to determine the libc version that the file executable
        (which defaults to the Python interpreter) is linked against.

        Returns a tuple of strings (lib,version) which default to the
        given parameters in case the lookup fails.

        Note that the function has intimate knowledge of how different
        libc versions add symbols to the executable and thus is probably
        only useable for executables compiled using gcc.

        The file is read and scanned in chunks of chunksize bytes.

    """
    if hasattr(os.path, 'realpath'):
        # Python 2.2 introduced os.path.realpath(); it is used
        # here to work around problems with Cygwin not being
        # able to open symlinks for reading
        executable = os.path.realpath(executable)
    f = open(executable,'rb')
    binary = f.read(chunksize)
    pos = 0
    while 1:
        m = _libc_search.search(binary,pos)
        if not m:
            binary = f.read(chunksize)
            if not binary:
                break
            pos = 0
            continue
        libcinit,glibc,glibcversion,so,threads,soversion = m.groups()
        if libcinit and not lib:
            lib = 'libc'
        elif glibc:
            if lib != 'glibc':
                lib = 'glibc'
                version = glibcversion
            elif glibcversion > version:
                version = glibcversion
        elif so:
            if lib != 'glibc':
                lib = 'libc'
                if soversion and soversion > version:
                    version = soversion
                if threads and version[-len(threads):] != threads:
                    version = version + threads
        pos = m.end()
    f.close()
    return lib,version

def _dist_try_harder(distname,version,id):

    """ Tries some special tricks to get the distribution
        information in case the default method fails.

        Currently supports older SuSE Linux, Caldera OpenLinux and
        Slackware Linux distributions.

    """
    if os.path.exists('/var/adm/inst-log/info'):
        # SuSE Linux stores distribution information in that file
        info = open('/var/adm/inst-log/info').readlines()
        distname = 'SuSE'
        for line in info:
            tv = string.split(line)
            if len(tv) == 2:
                tag,value = tv
            else:
                continue
            if tag == 'MIN_DIST_VERSION':
                version = string.strip(value)
            elif tag == 'DIST_IDENT':
                values = string.split(value,'-')
                id = values[2]
        return distname,version,id

    if os.path.exists('/etc/.installed'):
        # Caldera OpenLinux has some infos in that file (thanks to Colin Kong)
        info = open('/etc/.installed').readlines()
        for line in info:
            pkg = string.split(line,'-')
            if len(pkg) >= 2 and pkg[0] == 'OpenLinux':
                # XXX does Caldera support non Intel platforms ? If yes,
                #     where can we find the needed id ?
                return 'OpenLinux',pkg[1],id

    if os.path.isdir('/usr/lib/setup'):
        # Check for slackware version tag file (thanks to Greg Andruk)
        verfiles = os.listdir('/usr/lib/setup')
        for n in range(len(verfiles)-1, -1, -1):
            if verfiles[n][:14] != 'slack-version-':
                del verfiles[n]
        if verfiles:
            verfiles.sort()
            distname = 'slackware'
            version = verfiles[-1][14:]
            return distname,version,id

    return distname,version,id

_release_filename = re.compile(r'(\w+)[-_](release|version)')
_lsb_release_version = re.compile(r'(.+)'
                                   ' release '
                                   '([\d.]+)'
                                   '[^(]*(?:\((.+)\))?')
_release_version = re.compile(r'([^0-9]+)'
                               '(?: release )?'
                               '([\d.]+)'
                               '[^(]*(?:\((.+)\))?')

# See also http://www.novell.com/coolsolutions/feature/11251.html
# and http://linuxmafia.com/faq/Admin/release-files.html
# and http://data.linux-ntfs.org/rpm/whichrpm
# and http://www.die.net/doc/linux/man/man1/lsb_release.1.html

_supported_dists = (
    'SuSE', 'debian', 'fedora', 'redhat', 'centos',
    'mandrake', 'mandriva', 'rocks', 'slackware', 'yellowdog', 'gentoo',
    'UnitedLinux', 'turbolinux', 'Ubuntu')

def _parse_release_file(firstline):

    # Default to empty 'version' and 'id' strings.  Both defaults are used
    # when 'firstline' is empty.  'id' defaults to empty when an id can not
    # be deduced.
    version = ''
    id = ''

    # Parse the first line
    m = _lsb_release_version.match(firstline)
    if m is not None:
        # LSB format: "distro release x.x (codename)"
        return tuple(m.groups())

    # Pre-LSB format: "distro x.x (codename)"
    m = _release_version.match(firstline)
    if m is not None:
        return tuple(m.groups())

    # Unknown format... take the first two words
    l = string.split(string.strip(firstline))
    if l:
        version = l[0]
        if len(l) > 1:
            id = l[1]
    return '', version, id

_distributor_id_file_re = re.compile("(?:DISTRIB_ID\s*=)\s*(.*)", re.I)
_release_file_re = re.compile("(?:DISTRIB_RELEASE\s*=)\s*(.*)", re.I)
_codename_file_re = re.compile("(?:DISTRIB_CODENAME\s*=)\s*(.*)", re.I)

def linux_distribution(distname='', version='', id='',

                       supported_dists=_supported_dists,
                       full_distribution_name=1):

    """ Tries to determine the name of the Linux OS distribution name.

        The function first looks for a distribution release file in
        /etc and then reverts to _dist_try_harder() in case no
        suitable files are found.

        supported_dists may be given to define the set of Linux
        distributions to look for. It defaults to a list of currently
        supported Linux distributions identified by their release file
        name.

        If full_distribution_name is true (default), the full
        distribution read from the OS is returned. Otherwise the short
        name taken from supported_dists is used.

        Returns a tuple (distname,version,id) which default to the
        args given as parameters.

    """
    # check for the LSB /etc/lsb-release file first, needed so
    # that the distribution doesn't get identified as Debian.
    try:
        with open("/etc/lsb-release", "rU") as etclsbrel:
            for line in etclsbrel:
                m = _distributor_id_file_re.search(line)
                if m:
                    _u_distname = m.group(1).strip()
                m = _release_file_re.search(line)
                if m:
                    _u_version = m.group(1).strip()
                m = _codename_file_re.search(line)
                if m:
                    _u_id = m.group(1).strip()
            if _u_distname and _u_version:
                return (_u_distname, _u_version, _u_id)
    except (EnvironmentError, UnboundLocalError):
        pass

    try:
        etc = os.listdir('/etc')
    except os.error:
        # Probably not a Unix system
        return distname,version,id
    etc.sort()
    for file in etc:
        m = _release_filename.match(file)
        if m is not None:
            _distname,dummy = m.groups()
            if _distname in supported_dists:
                distname = _distname
                break
    else:
        return _dist_try_harder(distname,version,id)

    # Read the first line
    f = open('/etc/'+file, 'r')
    firstline = f.readline()
    f.close()
    _distname, _version, _id = _parse_release_file(firstline)

    if _distname and full_distribution_name:
        distname = _distname
    if _version:
        version = _version
    if _id:
        id = _id
    return distname, version, id

# To maintain backwards compatibility:

def dist(distname='',version='',id='',

         supported_dists=_supported_dists):

    """ Tries to determine the name of the Linux OS distribution name.

        The function first looks for a distribution release file in
        /etc and then reverts to _dist_try_harder() in case no
        suitable files are found.

        Returns a tuple (distname,version,id) which default to the
        args given as parameters.

    """
    return linux_distribution(distname, version, id,
                              supported_dists=supported_dists,
                              full_distribution_name=0)

class _popen:

    """ Fairly portable (alternative) popen implementation.

        This is mostly needed in case os.popen() is not available, or
        doesn't work as advertised, e.g. in Win9X GUI programs like
        PythonWin or IDLE.

        Writing to the pipe is currently not supported.

    """
    tmpfile = ''
    pipe = None
    bufsize = None
    mode = 'r'

    def __init__(self,cmd,mode='r',bufsize=None):

        if mode != 'r':
            raise ValueError,'popen()-emulation only supports read mode'
        import tempfile
        self.tmpfile = tmpfile = tempfile.mktemp()
        os.system(cmd + ' > %s' % tmpfile)
        self.pipe = open(tmpfile,'rb')
        self.bufsize = bufsize
        self.mode = mode

    def read(self):

        return self.pipe.read()

    def readlines(self):

        if self.bufsize is not None:
            return self.pipe.readlines()

    def close(self,

              remove=os.unlink,error=os.error):

        if self.pipe:
            rc = self.pipe.close()
        else:
            rc = 255
        if self.tmpfile:
            try:
                remove(self.tmpfile)
            except error:
                pass
        return rc

    # Alias
    __del__ = close

def popen(cmd, mode='r', bufsize=None):

    """ Portable popen() interface.
    """
    # Find a working popen implementation preferring win32pipe.popen
    # over os.popen over _popen
    popen = None
    if os.environ.get('OS','') == 'Windows_NT':
        # On NT win32pipe should work; on Win9x it hangs due to bugs
        # in the MS C lib (see MS KnowledgeBase article Q150956)
        try:
            import win32pipe
        except ImportError:
            pass
        else:
            popen = win32pipe.popen
    if popen is None:
        if hasattr(os,'popen'):
            popen = os.popen
            # Check whether it works... it doesn't in GUI programs
            # on Windows platforms
            if sys.platform == 'win32': # XXX Others too ?
                try:
                    popen('')
                except os.error:
                    popen = _popen
        else:
            popen = _popen
    if bufsize is None:
        return popen(cmd,mode)
    else:
        return popen(cmd,mode,bufsize)

def _norm_version(version, build=''):

    """ Normalize the version and build strings and return a single
        version string using the format major.minor.build (or patchlevel).
    """
    l = string.split(version,'.')
    if build:
        l.append(build)
    try:
        ints = map(int,l)
    except ValueError:
        strings = l
    else:
        strings = map(str,ints)
    version = string.join(strings[:3],'.')
    return version

_ver_output = re.compile(r'(?:([\w ]+) ([\w.]+) '
                         '.*'
                         '\[.* ([\d.]+)\])')

# Examples of VER command output:
#
#   Windows 2000:  Microsoft Windows 2000 [Version 5.00.2195]
#   Windows XP:    Microsoft Windows XP [Version 5.1.2600]
#   Windows Vista: Microsoft Windows [Version 6.0.6002]
#
# Note that the "Version" string gets localized on different
# Windows versions.

def _syscmd_ver(system='', release='', version='',

               supported_platforms=('win32','win16','dos','os2')):

    """ Tries to figure out the OS version used and returns
        a tuple (system,release,version).

        It uses the "ver" shell command for this which is known
        to exists on Windows, DOS and OS/2. XXX Others too ?

        In case this fails, the given parameters are used as
        defaults.

    """
    if sys.platform not in supported_platforms:
        return system,release,version

    # Try some common cmd strings
    for cmd in ('ver','command /c ver','cmd /c ver'):
        try:
            pipe = popen(cmd)
            info = pipe.read()
            if pipe.close():
                raise os.error,'command failed'
            # XXX How can I suppress shell errors from being written
            #     to stderr ?
        except os.error,why:
            #print 'Command %s failed: %s' % (cmd,why)
            continue
        except IOError,why:
            #print 'Command %s failed: %s' % (cmd,why)
            continue
        else:
            break
    else:
        return system,release,version

    # Parse the output
    info = string.strip(info)
    m = _ver_output.match(info)
    if m is not None:
        system,release,version = m.groups()
        # Strip trailing dots from version and release
        if release[-1] == '.':
            release = release[:-1]
        if version[-1] == '.':
            version = version[:-1]
        # Normalize the version and build strings (eliminating additional
        # zeros)
        version = _norm_version(version)
    return system,release,version

_WIN32_CLIENT_RELEASES = {
    (5, 0): "2000",
    (5, 1): "XP",
    # Strictly, 5.2 client is XP 64-bit, but platform.py historically
    # has always called it 2003 Server
    (5, 2): "2003Server",
    (5, None): "post2003",

    (6, 0): "Vista",
    (6, 1): "7",
    (6, 2): "8",
    (6, 3): "8.1",
    (6, None): "post8.1",

    (10, 0): "10",
    (10, None): "post10",
}

# Server release name lookup will default to client names if necessary
_WIN32_SERVER_RELEASES = {
    (5, 2): "2003Server",

    (6, 0): "2008Server",
    (6, 1): "2008ServerR2",
    (6, 2): "2012Server",
    (6, 3): "2012ServerR2",
    (6, None): "post2012ServerR2",
}

def _get_real_winver(maj, min, build):
    if maj < 6 or (maj == 6 and min < 2):
        return maj, min, build

    from ctypes import (c_buffer, POINTER, byref, create_unicode_buffer,
                        Structure, WinDLL, _Pointer)
    from ctypes.wintypes import DWORD, HANDLE

    class VS_FIXEDFILEINFO(Structure):
        _fields_ = [
            ("dwSignature", DWORD),
            ("dwStrucVersion", DWORD),
            ("dwFileVersionMS", DWORD),
            ("dwFileVersionLS", DWORD),
            ("dwProductVersionMS", DWORD),
            ("dwProductVersionLS", DWORD),
            ("dwFileFlagsMask", DWORD),
            ("dwFileFlags", DWORD),
            ("dwFileOS", DWORD),
            ("dwFileType", DWORD),
            ("dwFileSubtype", DWORD),
            ("dwFileDateMS", DWORD),
            ("dwFileDateLS", DWORD),
        ]
    class PVS_FIXEDFILEINFO(_Pointer):
        _type_ = VS_FIXEDFILEINFO

    kernel32 = WinDLL('kernel32')
    version = WinDLL('version')

    # We will immediately double the length up to MAX_PATH, but the
    # path may be longer, so we retry until the returned string is
    # shorter than our buffer.
    name_len = actual_len = 130
    while actual_len == name_len:
        name_len *= 2
        name = create_unicode_buffer(name_len)
        actual_len = kernel32.GetModuleFileNameW(HANDLE(kernel32._handle),
                                                 name, len(name))
        if not actual_len:
            return maj, min, build

    size = version.GetFileVersionInfoSizeW(name, None)
    if not size:
        return maj, min, build

    ver_block = c_buffer(size)
    if (not version.GetFileVersionInfoW(name, None, size, ver_block) or
        not ver_block):
        return maj, min, build

    pvi = PVS_FIXEDFILEINFO()
    if not version.VerQueryValueW(ver_block, "", byref(pvi), byref(DWORD())):
        return maj, min, build

    maj = pvi.contents.dwProductVersionMS >> 16
    min = pvi.contents.dwProductVersionMS & 0xFFFF
    build = pvi.contents.dwProductVersionLS >> 16

    return maj, min, build

def win32_ver(release='', version='', csd='', ptype=''):
    try:
        from sys import getwindowsversion
    except ImportError:
        return release, version, csd, ptype
    try:
        from winreg import OpenKeyEx, QueryValueEx, CloseKey, HKEY_LOCAL_MACHINE
    except ImportError:
        from _winreg import OpenKeyEx, QueryValueEx, CloseKey, HKEY_LOCAL_MACHINE

    winver = getwindowsversion()
    maj, min, build = _get_real_winver(*winver[:3])
    version = '{0}.{1}.{2}'.format(maj, min, build)

    release = (_WIN32_CLIENT_RELEASES.get((maj, min)) or
               _WIN32_CLIENT_RELEASES.get((maj, None)) or
               release)

    # getwindowsversion() reflect the compatibility mode Python is
    # running under, and so the service pack value is only going to be
    # valid if the versions match.
    if winver[:2] == (maj, min):
        try:
            csd = 'SP{}'.format(winver.service_pack_major)
        except AttributeError:
            if csd[:13] == 'Service Pack ':
                csd = 'SP' + csd[13:]

    # VER_NT_SERVER = 3
    if getattr(winver, 'product_type', None) == 3:
        release = (_WIN32_SERVER_RELEASES.get((maj, min)) or
                   _WIN32_SERVER_RELEASES.get((maj, None)) or
                   release)

    key = None
    try:
        key = OpenKeyEx(HKEY_LOCAL_MACHINE,
                        r'SOFTWARE\Microsoft\Windows NT\CurrentVersion')
        ptype = QueryValueEx(key, 'CurrentType')[0]
    except:
        pass
    finally:
        if key:
            CloseKey(key)

    return release, version, csd, ptype

def _mac_ver_lookup(selectors,default=None):

    from gestalt import gestalt
    import MacOS
    l = []
    append = l.append
    for selector in selectors:
        try:
            append(gestalt(selector))
        except (RuntimeError, MacOS.Error):
            append(default)
    return l

def _bcd2str(bcd):

    return hex(bcd)[2:]

def _mac_ver_gestalt():
    """
        Thanks to Mark R. Levinson for mailing documentation links and
        code examples for this function. Documentation for the
        gestalt() API is available online at:

           http://www.rgaros.nl/gestalt/
    """
    # Check whether the version info module is available
    try:
        import gestalt
        import MacOS
    except ImportError:
        return None
    # Get the infos
    sysv,sysa = _mac_ver_lookup(('sysv','sysa'))
    # Decode the infos
    if sysv:
        major = (sysv & 0xFF00) >> 8
        minor = (sysv & 0x00F0) >> 4
        patch = (sysv & 0x000F)

        if (major, minor) >= (10, 4):
            # the 'sysv' gestald cannot return patchlevels
            # higher than 9. Apple introduced 3 new
            # gestalt codes in 10.4 to deal with this
            # issue (needed because patch levels can
            # run higher than 9, such as 10.4.11)
            major,minor,patch = _mac_ver_lookup(('sys1','sys2','sys3'))
            release = '%i.%i.%i' %(major, minor, patch)
        else:
            release = '%s.%i.%i' % (_bcd2str(major),minor,patch)

    if sysa:
        machine = {0x1: '68k',
                   0x2: 'PowerPC',
                   0xa: 'i386'}.get(sysa,'')

    versioninfo=('', '', '')
    return release,versioninfo,machine

def _mac_ver_xml():
    fn = '/System/Library/CoreServices/SystemVersion.plist'
    if not os.path.exists(fn):
        return None

    try:
        import plistlib
    except ImportError:
        return None

    pl = plistlib.readPlist(fn)
    release = pl['ProductVersion']
    versioninfo=('', '', '')
    machine = os.uname()[4]
    if machine in ('ppc', 'Power Macintosh'):
        # for compatibility with the gestalt based code
        machine = 'PowerPC'

    return release,versioninfo,machine


def mac_ver(release='',versioninfo=('','',''),machine=''):

    """ Get MacOS version information and return it as tuple (release,
        versioninfo, machine) with versioninfo being a tuple (version,
        dev_stage, non_release_version).

        Entries which cannot be determined are set to the parameter values
        which default to ''. All tuple entries are strings.
    """

    # First try reading the information from an XML file which should
    # always be present
    info = _mac_ver_xml()
    if info is not None:
        return info

    # If that doesn't work for some reason fall back to reading the
    # information using gestalt calls.
    info = _mac_ver_gestalt()
    if info is not None:
        return info

    # If that also doesn't work return the default values
    return release,versioninfo,machine

def _java_getprop(name,default):

    from java.lang import System
    try:
        value = System.getProperty(name)
        if value is None:
            return default
        return value
    except AttributeError:
        return default

def java_ver(release='',vendor='',vminfo=('','',''),osinfo=('','','')):

    """ Version interface for Jython.

        Returns a tuple (release,vendor,vminfo,osinfo) with vminfo being
        a tuple (vm_name,vm_release,vm_vendor) and osinfo being a
        tuple (os_name,os_version,os_arch).

        Values which cannot be determined are set to the defaults
        given as parameters (which all default to '').

    """
    # Import the needed APIs
    try:
        import java.lang
    except ImportError:
        return release,vendor,vminfo,osinfo

    vendor = _java_getprop('java.vendor', vendor)
    release = _java_getprop('java.version', release)
    vm_name, vm_release, vm_vendor = vminfo
    vm_name = _java_getprop('java.vm.name', vm_name)
    vm_vendor = _java_getprop('java.vm.vendor', vm_vendor)
    vm_release = _java_getprop('java.vm.version', vm_release)
    vminfo = vm_name, vm_release, vm_vendor
    os_name, os_version, os_arch = osinfo
    os_arch = _java_getprop('java.os.arch', os_arch)
    os_name = _java_getprop('java.os.name', os_name)
    os_version = _java_getprop('java.os.version', os_version)
    osinfo = os_name, os_version, os_arch

    return release, vendor, vminfo, osinfo

### System name aliasing

def system_alias(system,release,version):

    """ Returns (system,release,version) aliased to common
        marketing names used for some systems.

        It also does some reordering of the information in some cases
        where it would otherwise cause confusion.

    """
    if system == 'Rhapsody':
        # Apple's BSD derivative
        # XXX How can we determine the marketing release number ?
        return 'MacOS X Server',system+release,version

    elif system == 'SunOS':
        # Sun's OS
        if release < '5':
            # These releases use the old name SunOS
            return system,release,version
        # Modify release (marketing release = SunOS release - 3)
        l = string.split(release,'.')
        if l:
            try:
                major = int(l[0])
            except ValueError:
                pass
            else:
                major = major - 3
                l[0] = str(major)
                release = string.join(l,'.')
        if release < '6':
            system = 'Solaris'
        else:
            # XXX Whatever the new SunOS marketing name is...
            system = 'Solaris'

    elif system == 'IRIX64':
        # IRIX reports IRIX64 on platforms with 64-bit support; yet it
        # is really a version and not a different platform, since 32-bit
        # apps are also supported..
        system = 'IRIX'
        if version:
            version = version + ' (64bit)'
        else:
            version = '64bit'

    elif system in ('win32','win16'):
        # In case one of the other tricks
        system = 'Windows'

    return system,release,version

### Various internal helpers

def _platform(*args):

    """ Helper to format the platform string in a filename
        compatible format e.g. "system-version-machine".
    """
    # Format the platform string
    platform = string.join(
        map(string.strip,
            filter(len, args)),
        '-')

    # Cleanup some possible filename obstacles...
    replace = string.replace
    platform = replace(platform,' ','_')
    platform = replace(platform,'/','-')
    platform = replace(platform,'\\','-')
    platform = replace(platform,':','-')
    platform = replace(platform,';','-')
    platform = replace(platform,'"','-')
    platform = replace(platform,'(','-')
    platform = replace(platform,')','-')

    # No need to report 'unknown' information...
    platform = replace(platform,'unknown','')

    # Fold '--'s and remove trailing '-'
    while 1:
        cleaned = replace(platform,'--','-')
        if cleaned == platform:
            break
        platform = cleaned
    while platform[-1] == '-':
        platform = platform[:-1]

    return platform

def _node(default=''):

    """ Helper to determine the node name of this machine.
    """
    try:
        import socket
    except ImportError:
        # No sockets...
        return default
    try:
        return socket.gethostname()
    except socket.error:
        # Still not working...
        return default

# os.path.abspath is new in Python 1.5.2:
if not hasattr(os.path,'abspath'):

    def _abspath(path,

                 isabs=os.path.isabs,join=os.path.join,getcwd=os.getcwd,
                 normpath=os.path.normpath):

        if not isabs(path):
            path = join(getcwd(), path)
        return normpath(path)

else:

    _abspath = os.path.abspath

def _follow_symlinks(filepath):

    """ In case filepath is a symlink, follow it until a
        real file is reached.
    """
    filepath = _abspath(filepath)
    while os.path.islink(filepath):
        filepath = os.path.normpath(
            os.path.join(os.path.dirname(filepath),os.readlink(filepath)))
    return filepath

def _syscmd_uname(option,default=''):

    """ Interface to the system's uname command.
    """
    if sys.platform in ('dos','win32','win16','os2'):
        # XXX Others too ?
        return default
    try:
        f = os.popen('uname %s 2> %s' % (option, DEV_NULL))
    except (AttributeError,os.error):
        return default
    output = string.strip(f.read())
    rc = f.close()
    if not output or rc:
        return default
    else:
        return output

def _syscmd_file(target,default=''):

    """ Interface to the system's file command.

        The function uses the -b option of the file command to have it
        ommit the filename in its output and if possible the -L option
        to have the command follow symlinks. It returns default in
        case the command should fail.

    """

    # We do the import here to avoid a bootstrap issue.
    # See c73b90b6dadd changeset.
    #
    # [..]
    # ranlib libpython2.7.a
    # gcc   -o python \
    #        Modules/python.o \
    #        libpython2.7.a -lsocket -lnsl -ldl    -lm
    # Traceback (most recent call last):
    #  File "./setup.py", line 8, in <module>
    #    from platform import machine as platform_machine
    #  File "[..]/build/Lib/platform.py", line 116, in <module>
    #    import sys,string,os,re,subprocess
    #  File "[..]/build/Lib/subprocess.py", line 429, in <module>
    #    import select
    # ImportError: No module named select

    import subprocess

    if sys.platform in ('dos','win32','win16','os2'):
        # XXX Others too ?
        return default
    target = _follow_symlinks(target)
    try:
        proc = subprocess.Popen(['file', target],
                stdout=subprocess.PIPE, stderr=subprocess.STDOUT)

    except (AttributeError,os.error):
        return default
    output = proc.communicate()[0]
    rc = proc.wait()
    if not output or rc:
        return default
    else:
        return output

### Information about the used architecture

# Default values for architecture; non-empty strings override the
# defaults given as parameters
_default_architecture = {
    'win32': ('','WindowsPE'),
    'win16': ('','Windows'),
    'dos': ('','MSDOS'),
}

_architecture_split = re.compile(r'[\s,]').split

def architecture(executable=sys.executable,bits='',linkage=''):

    """ Queries the given executable (defaults to the Python interpreter
        binary) for various architecture information.

        Returns a tuple (bits,linkage) which contains information about
        the bit architecture and the linkage format used for the
        executable. Both values are returned as strings.

        Values that cannot be determined are returned as given by the
        parameter presets. If bits is given as '', the sizeof(pointer)
        (or sizeof(long) on Python version < 1.5.2) is used as
        indicator for the supported pointer size.

        The function relies on the system's "file" command to do the
        actual work. This is available on most if not all Unix
        platforms. On some non-Unix platforms where the "file" command
        does not exist and the executable is set to the Python interpreter
        binary defaults from _default_architecture are used.

    """
    # Use the sizeof(pointer) as default number of bits if nothing
    # else is given as default.
    if not bits:
        import struct
        try:
            size = struct.calcsize('P')
        except struct.error:
            # Older installations can only query longs
            size = struct.calcsize('l')
        bits = str(size*8) + 'bit'

    # Get data from the 'file' system command
    if executable:
        output = _syscmd_file(executable, '')
    else:
        output = ''

    if not output and \
       executable == sys.executable:
        # "file" command did not return anything; we'll try to provide
        # some sensible defaults then...
        if sys.platform in _default_architecture:
            b, l = _default_architecture[sys.platform]
            if b:
                bits = b
            if l:
                linkage = l
        return bits, linkage

    # Split the output into a list of strings omitting the filename
    fileout = _architecture_split(output)[1:]

    if 'executable' not in fileout:
        # Format not supported
        return bits,linkage

    # Bits
    if '32-bit' in fileout:
        bits = '32bit'
    elif 'N32' in fileout:
        # On Irix only
        bits = 'n32bit'
    elif '64-bit' in fileout:
        bits = '64bit'

    # Linkage
    if 'ELF' in fileout:
        linkage = 'ELF'
    elif 'PE' in fileout:
        # E.g. Windows uses this format
        if 'Windows' in fileout:
            linkage = 'WindowsPE'
        else:
            linkage = 'PE'
    elif 'COFF' in fileout:
        linkage = 'COFF'
    elif 'MS-DOS' in fileout:
        linkage = 'MSDOS'
    else:
        # XXX the A.OUT format also falls under this class...
        pass

    return bits,linkage

### Portable uname() interface

_uname_cache = None

def uname():

    """ Fairly portable uname interface. Returns a tuple
        of strings (system,node,release,version,machine,processor)
        identifying the underlying platform.

        Note that unlike the os.uname function this also returns
        possible processor information as an additional tuple entry.

        Entries which cannot be determined are set to ''.

    """
    global _uname_cache
    no_os_uname = 0

    if _uname_cache is not None:
        return _uname_cache

    processor = ''

    # Get some infos from the builtin os.uname API...
    try:
        system,node,release,version,machine = os.uname()
    except AttributeError:
        no_os_uname = 1

    if no_os_uname or not filter(None, (system, node, release, version, machine)):
        # Hmm, no there is either no uname or uname has returned
        #'unknowns'... we'll have to poke around the system then.
        if no_os_uname:
            system = sys.platform
            release = ''
            version = ''
            node = _node()
            machine = ''

        use_syscmd_ver = 1

        # Try win32_ver() on win32 platforms
        if system == 'win32':
            release,version,csd,ptype = win32_ver()
            if release and version:
                use_syscmd_ver = 0
            # Try to use the PROCESSOR_* environment variables
            # available on Win XP and later; see
            # http://support.microsoft.com/kb/888731 and
            # http://www.geocities.com/rick_lively/MANUALS/ENV/MSWIN/PROCESSI.HTM
            if not machine:
                # WOW64 processes mask the native architecture
                if "PROCESSOR_ARCHITEW6432" in os.environ:
                    machine = os.environ.get("PROCESSOR_ARCHITEW6432", '')
                else:
                    machine = os.environ.get('PROCESSOR_ARCHITECTURE', '')
            if not processor:
                processor = os.environ.get('PROCESSOR_IDENTIFIER', machine)

        # Try the 'ver' system command available on some
        # platforms
        if use_syscmd_ver:
            system,release,version = _syscmd_ver(system)
            # Normalize system to what win32_ver() normally returns
            # (_syscmd_ver() tends to return the vendor name as well)
            if system == 'Microsoft Windows':
                system = 'Windows'
            elif system == 'Microsoft' and release == 'Windows':
                # Under Windows Vista and Windows Server 2008,
                # Microsoft changed the output of the ver command. The
                # release is no longer printed.  This causes the
                # system and release to be misidentified.
                system = 'Windows'
                if '6.0' == version[:3]:
                    release = 'Vista'
                else:
                    release = ''

        # In case we still don't know anything useful, we'll try to
        # help ourselves
        if system in ('win32','win16'):
            if not version:
                if system == 'win32':
                    version = '32bit'
                else:
                    version = '16bit'
            system = 'Windows'

        elif system[:4] == 'java':
            release,vendor,vminfo,osinfo = java_ver()
            system = 'Java'
            version = string.join(vminfo,', ')
            if not version:
                version = vendor

    # System specific extensions
    if system == 'OpenVMS':
        # OpenVMS seems to have release and version mixed up
        if not release or release == '0':
            release = version
            version = ''
        # Get processor information
        try:
            import vms_lib
        except ImportError:
            pass
        else:
            csid, cpu_number = vms_lib.getsyi('SYI$_CPU',0)
            if (cpu_number >= 128):
                processor = 'Alpha'
            else:
                processor = 'VAX'
    if not processor:
        # Get processor information from the uname system command
        processor = _syscmd_uname('-p','')

    #If any unknowns still exist, replace them with ''s, which are more portable
    if system == 'unknown':
        system = ''
    if node == 'unknown':
        node = ''
    if release == 'unknown':
        release = ''
    if version == 'unknown':
        version = ''
    if machine == 'unknown':
        machine = ''
    if processor == 'unknown':
        processor = ''

    #  normalize name
    if system == 'Microsoft' and release == 'Windows':
        system = 'Windows'
        release = 'Vista'

    _uname_cache = system,node,release,version,machine,processor
    return _uname_cache

### Direct interfaces to some of the uname() return values

def system():

    """ Returns the system/OS name, e.g. 'Linux', 'Windows' or 'Java'.

        An empty string is returned if the value cannot be determined.

    """
    return uname()[0]

def node():

    """ Returns the computer's network name (which may not be fully
        qualified)

        An empty string is returned if the value cannot be determined.

    """
    return uname()[1]

def release():

    """ Returns the system's release, e.g. '2.2.0' or 'NT'

        An empty string is returned if the value cannot be determined.

    """
    return uname()[2]

def version():

    """ Returns the system's release version, e.g. '#3 on degas'

        An empty string is returned if the value cannot be determined.

    """
    return uname()[3]

def machine():

    """ Returns the machine type, e.g. 'i386'

        An empty string is returned if the value cannot be determined.

    """
    return uname()[4]

def processor():

    """ Returns the (true) processor name, e.g. 'amdk6'

        An empty string is returned if the value cannot be
        determined. Note that many platforms do not provide this
        information or simply return the same value as for machine(),
        e.g.  NetBSD does this.

    """
    return uname()[5]

### Various APIs for extracting information from sys.version

_sys_version_parser = re.compile(
    r'([\w.+]+)\s*'  # "version<space>"
    r'\(#?([^,]+)'  # "(#buildno"
    r'(?:,\s*([\w ]*)'  # ", builddate"
    r'(?:,\s*([\w :]*))?)?\)\s*'  # ", buildtime)<space>"
    r'\[([^\]]+)\]?')  # "[compiler]"

_ironpython_sys_version_parser = re.compile(
    r'IronPython\s*'
    '([\d\.]+)'
    '(?: \(([\d\.]+)\))?'
    ' on (.NET [\d\.]+)')

# IronPython covering 2.6 and 2.7
_ironpython26_sys_version_parser = re.compile(
    r'([\d.]+)\s*'
    '\(IronPython\s*'
    '[\d.]+\s*'
    '\(([\d.]+)\) on ([\w.]+ [\d.]+(?: \(\d+-bit\))?)\)'
)

_pypy_sys_version_parser = re.compile(
    r'([\w.+]+)\s*'
    '\(#?([^,]+),\s*([\w ]+),\s*([\w :]+)\)\s*'
    '\[PyPy [^\]]+\]?')

_sys_version_cache = {}

def _sys_version(sys_version=None):

    """ Returns a parsed version of Python's sys.version as tuple
        (name, version, branch, revision, buildno, builddate, compiler)
        referring to the Python implementation name, version, branch,
        revision, build number, build date/time as string and the compiler
        identification string.

        Note that unlike the Python sys.version, the returned value
        for the Python version will always include the patchlevel (it
        defaults to '.0').

        The function returns empty strings for tuple entries that
        cannot be determined.

        sys_version may be given to parse an alternative version
        string, e.g. if the version was read from a different Python
        interpreter.

    """
    # Get the Python version
    if sys_version is None:
        sys_version = sys.version

    # Try the cache first
    result = _sys_version_cache.get(sys_version, None)
    if result is not None:
        return result

    # Parse it
    if 'IronPython' in sys_version:
        # IronPython
        name = 'IronPython'
        if sys_version.startswith('IronPython'):
            match = _ironpython_sys_version_parser.match(sys_version)
        else:
            match = _ironpython26_sys_version_parser.match(sys_version)

        if match is None:
            raise ValueError(
                'failed to parse IronPython sys.version: %s' %
                repr(sys_version))

        version, alt_version, compiler = match.groups()
        buildno = ''
        builddate = ''

    elif sys.platform.startswith('java'):
        # Jython
        name = 'Jython'
        match = _sys_version_parser.match(sys_version)
        if match is None:
            raise ValueError(
                'failed to parse Jython sys.version: %s' %
                repr(sys_version))
        version, buildno, builddate, buildtime, _ = match.groups()
        if builddate is None:
            builddate = ''
        compiler = sys.platform

    elif "PyPy" in sys_version:
        # PyPy
        name = "PyPy"
        match = _pypy_sys_version_parser.match(sys_version)
        if match is None:
            raise ValueError("failed to parse PyPy sys.version: %s" %
                             repr(sys_version))
        version, buildno, builddate, buildtime = match.groups()
        compiler = ""

    else:
        # CPython
        match = _sys_version_parser.match(sys_version)
        if match is None:
            raise ValueError(
                'failed to parse CPython sys.version: %s' %
                repr(sys_version))
        version, buildno, builddate, buildtime, compiler = \
              match.groups()
        name = 'CPython'
        if builddate is None:
            builddate = ''
        elif buildtime:
            builddate = builddate + ' ' + buildtime

    if hasattr(sys, 'subversion'):
        # sys.subversion was added in Python 2.5
        _, branch, revision = sys.subversion
    else:
        branch = ''
        revision = ''

    # Add the patchlevel version if missing
    l = string.split(version, '.')
    if len(l) == 2:
        l.append('0')
        version = string.join(l, '.')

    # Build and cache the result
    result = (name, version, branch, revision, buildno, builddate, compiler)
    _sys_version_cache[sys_version] = result
    return result

def python_implementation():

    """ Returns a string identifying the Python implementation.

        Currently, the following implementations are identified:
          'CPython' (C implementation of Python),
          'IronPython' (.NET implementation of Python),
          'Jython' (Java implementation of Python),
          'PyPy' (Python implementation of Python).

    """
    return _sys_version()[0]

def python_version():

    """ Returns the Python version as string 'major.minor.patchlevel'

        Note that unlike the Python sys.version, the returned value
        will always include the patchlevel (it defaults to 0).

    """
    return _sys_version()[1]

def python_version_tuple():

    """ Returns the Python version as tuple (major, minor, patchlevel)
        of strings.

        Note that unlike the Python sys.version, the returned value
        will always include the patchlevel (it defaults to 0).

    """
    return tuple(string.split(_sys_version()[1], '.'))

def python_branch():

    """ Returns a string identifying the Python implementation
        branch.

        For CPython this is the Subversion branch from which the
        Python binary was built.

        If not available, an empty string is returned.

    """

    return _sys_version()[2]

def python_revision():

    """ Returns a string identifying the Python implementation
        revision.

        For CPython this is the Subversion revision from which the
        Python binary was built.

        If not available, an empty string is returned.

    """
    return _sys_version()[3]

def python_build():

    """ Returns a tuple (buildno, builddate) stating the Python
        build number and date as strings.

    """
    return _sys_version()[4:6]

def python_compiler():

    """ Returns a string identifying the compiler used for compiling
        Python.

    """
    return _sys_version()[6]

### The Opus Magnum of platform strings :-)

_platform_cache = {}

def platform(aliased=0, terse=0):

    """ Returns a single string identifying the underlying platform
        with as much useful information as possible (but no more :).

        The output is intended to be human readable rather than
        machine parseable. It may look different on different
        platforms and this is intended.

        If "aliased" is true, the function will use aliases for
        various platforms that report system names which differ from
        their common names, e.g. SunOS will be reported as
        Solaris. The system_alias() function is used to implement
        this.

        Setting terse to true causes the function to return only the
        absolute minimum information needed to identify the platform.

    """
    result = _platform_cache.get((aliased, terse), None)
    if result is not None:
        return result

    # Get uname information and then apply platform specific cosmetics
    # to it...
    system,node,release,version,machine,processor = uname()
    if machine == processor:
        processor = ''
    if aliased:
        system,release,version = system_alias(system,release,version)

    if system == 'Windows':
        # MS platforms
        rel,vers,csd,ptype = win32_ver(version)
        if terse:
            platform = _platform(system,release)
        else:
            platform = _platform(system,release,version,csd)

    elif system in ('Linux',):
        # Linux based systems
        distname,distversion,distid = dist('')
        if distname and not terse:
            platform = _platform(system,release,machine,processor,
                                 'with',
                                 distname,distversion,distid)
        else:
            # If the distribution name is unknown check for libc vs. glibc
            libcname,libcversion = libc_ver(sys.executable)
            platform = _platform(system,release,machine,processor,
                                 'with',
                                 libcname+libcversion)
    elif system == 'Java':
        # Java platforms
        r,v,vminfo,(os_name,os_version,os_arch) = java_ver()
        if terse or not os_name:
            platform = _platform(system,release,version)
        else:
            platform = _platform(system,release,version,
                                 'on',
                                 os_name,os_version,os_arch)

    elif system == 'MacOS':
        # MacOS platforms
        if terse:
            platform = _platform(system,release)
        else:
            platform = _platform(system,release,machine)

    else:
        # Generic handler
        if terse:
            platform = _platform(system,release)
        else:
            bits,linkage = architecture(sys.executable)
            platform = _platform(system,release,machine,processor,bits,linkage)

    _platform_cache[(aliased, terse)] = platform
    return platform

### Command line interface

if __name__ == '__main__':
    # Default is to print the aliased verbose platform string
    terse = ('terse' in sys.argv or '--terse' in sys.argv)
    aliased = (not 'nonaliased' in sys.argv and not '--nonaliased' in sys.argv)
    print platform(aliased,terse)
    sys.exit(0)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ó
Ó«[c           @   sÀ  d  Z  d Z d Z d d l Z d d l Z d d l Z d d l Z y e j Z Wn/ e	 k
 r€ e j
 dt k rw d	 Z q d
 Z n Xe j d ƒ Z e j d d d d „ Z d „  Z e j d ƒ Z e j d ƒ Z e j d ƒ Z du Z d! „  Z e j d" e j ƒ Z e j d# e j ƒ Z e j d$ e j ƒ Z d d d e d% d& „ Z d d d e d' „ Z d( dv d) „  ƒ  YZ d* d d+ „ Z d d, „ Z e j d- ƒ Z d d d dw d. „ Z  i d/ dx 6d2 dy 6d3 dz 6d5 d{ 6d6 d| 6d8 d} 6d9 d~ 6d: d 6d< d€ 6d= d 6d? d‚ 6Z! i d3 dƒ 6d@ d„ 6dA d… 6dB d† 6dC d‡ 6dD dˆ 6Z" dE „  Z# d d d d dF „ Z$ d dG „ Z% dH „  Z& dI „  Z' dJ „  Z( d d‰ d dK „ Z) dL „  Z* d d dŠ d‹ dM „ Z+ dN „  Z, dO „  Z- d dP „ Z. e/ e j0 dQ ƒ s e j0 j1 e j0 j2 e j3 e j0 j4 dR „ Z5 n e j0 j6 Z5 dS „  Z7 d dT „ Z8 d dU „ Z9 i dŒ d 6d d 6dŽ d 6Z: e j dY ƒ j; Z< e j d d dZ „ Z= d a> d[ „  Z? d\ „  Z@ d] „  ZA d^ „  ZB d_ „  ZC d` „  ZD da „  ZE e j db ƒ ZF e j dc ƒ ZG e j dd ƒ ZH e j de ƒ ZI i  ZJ d df „ ZK dg „  ZL dh „  ZM di „  ZN dj „  ZO dk „  ZP dl „  ZQ dm „  ZR i  ZS d1 d1 dn „ Z
 eT do k r¼dp e jU k p}dq e jU k ZV dr e jU k o›ds e jU k ZW e
 eW eV ƒ GHe jX d1 ƒ n  d S(   s8   This module tries to retrieve as much platform-identifying data as
    possible. It makes this information available via function APIs.

    If called from the command line, it prints the platform
    information concatenated as single string to stdout. The output
    format is useable as part of a filename.

s  
    Copyright (c) 1999-2000, Marc-Andre Lemburg; mailto:mal@lemburg.com
    Copyright (c) 2000-2010, eGenix.com Software GmbH; mailto:info@egenix.com

    Permission to use, copy, modify, and distribute this software and its
    documentation for any purpose and without fee or royalty is hereby granted,
    provided that the above copyright notice appear in all copies and that
    both that copyright notice and this permission notice appear in
    supporting documentation or portions thereof, including modifications,
    that you make.

    EGENIX.COM SOFTWARE GMBH DISCLAIMS ALL WARRANTIES WITH REGARD TO
    THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
    FITNESS, IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL,
    INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING
    FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
    NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
    WITH THE USE OR PERFORMANCE OF THIS SOFTWARE !

s   1.0.7iÿÿÿÿNt   dost   win32t   win16t   os2t   NULs	   /dev/nullsC   (__libc_init)|(GLIBC_([0-9.]+))|(libc(_\w+)?\.so(?:\.(\d[0-9.]*))?)t    i   c         C   s  t  t j d ƒ r' t j j |  ƒ }  n  t |  d ƒ } | j | ƒ } d } xt j | | ƒ } | s‹ | j | ƒ } | s Pn  d } qN n  | j ƒ  \ } }	 }
 } } } | r¿ | r¿ d } nœ |	 rø | d k rà d } |
 } q[|
 | k r[|
 } q[nc | r[| d k r[d } | r+| | k r+| } n  | rX| t	 | ƒ | k rX| | } qXq[n  | j
 ƒ  } qN W| j ƒ  | | f S(   s   Tries to determine the libc version that the file executable
        (which defaults to the Python interpreter) is linked against.

        Returns a tuple of strings (lib,version) which default to the
        given parameters in case the lookup fails.

        Note that the function has intimate knowledge of how different
        libc versions add symbols to the executable and thus is probably
        only useable for executables compiled using gcc.

        The file is read and scanned in chunks of chunksize bytes.

    t   realpatht   rbi    t   libct   glibc(   t   hasattrt   ost   pathR   t   opent   readt   _libc_searcht   searcht   groupst   lent   endt   close(   t
   executablet   libt   versiont	   chunksizet   ft   binaryt   post   mt   libcinitR	   t   glibcversiont   sot   threadst	   soversion(    (    s   /usr/lib/python2.7/platform.pyt   libc_ver   s@    			
c         C   sè  t  j j d ƒ rÄ t d ƒ j ƒ  } d }  xŠ | D]‚ } t j | ƒ } t | ƒ d k r1 | \ } } n q1 | d k rˆ t j | ƒ } q1 | d k r1 t j | d ƒ } | d } q1 q1 W|  | | f St  j j d ƒ rAt d ƒ j ƒ  } xV | D]K } t j | d ƒ }	 t |	 ƒ d k rï |	 d d	 k rï d	 |	 d
 | f Sqï Wn  t  j j	 d ƒ rÛt  j
 d ƒ }
 xB t t |
 ƒ d
 d d ƒ D]$ } |
 | d  d k r|
 | =qqW|
 rÛ|
 j ƒ  d }  |
 d d } |  | | f Sn  |  | | f S(   sÙ    Tries some special tricks to get the distribution
        information in case the default method fails.

        Currently supports older SuSE Linux, Caldera OpenLinux and
        Slackware Linux distributions.

    s   /var/adm/inst-log/infot   SuSEi   t   MIN_DIST_VERSIONt
   DIST_IDENTt   -s   /etc/.installedi    t	   OpenLinuxi   s   /usr/lib/setupiÿÿÿÿi   s   slack-version-t	   slackware(   R   R   t   existsR   t	   readlinest   stringt   splitR   t   stript   isdirt   listdirt   ranget   sort(   t   distnameR   t   idt   infot   linet   tvt   tagt   valuet   valuest   pkgt   verfilest   n(    (    s   /usr/lib/python2.7/platform.pyt   _dist_try_harderÄ   s>    	"#
s   (\w+)[-_](release|version)s'   (.+) release ([\d.]+)[^(]*(?:\((.+)\))?s1   ([^0-9]+)(?: release )?([\d.]+)[^(]*(?:\((.+)\))?R#   t   debiant   fedorat   redhatt   centost   mandraket   mandrivat   rocksR(   t	   yellowdogt   gentoot   UnitedLinuxt
   turbolinuxt   Ubuntuc         C   s¹   d } d } t  j |  ƒ } | d  k	 r7 t | j ƒ  ƒ St j |  ƒ } | d  k	 rb t | j ƒ  ƒ St j t j |  ƒ ƒ } | r¬ | d } t	 | ƒ d k r¬ | d } q¬ n  d | | f S(   NR   i    i   (
   t   _lsb_release_versiont   matcht   Nonet   tupleR   t   _release_versionR+   R,   R-   R   (   t	   firstlineR   R3   R   t   l(    (    s   /usr/lib/python2.7/platform.pyt   _parse_release_file
  s    
s   (?:DISTRIB_ID\s*=)\s*(.*)s   (?:DISTRIB_RELEASE\s*=)\s*(.*)s   (?:DISTRIB_CODENAME\s*=)\s*(.*)i   c         C   s
  yÍ t  d d ƒ ¸ } x• | D] } t j | ƒ } | rO | j d ƒ j ƒ  } n  t j | ƒ } | r| | j d ƒ j ƒ  }	 n  t j | ƒ } | r | j d ƒ j ƒ  }
 q q W| rÆ |	 rÆ | |	 |
 f SWd QXWn t t f k
 ræ n Xy t	 j
 d ƒ } Wn t	 j k
 r|  | | f SX| j ƒ  xd | D]L } t j | ƒ } | d k	 r,| j ƒ  \ } } | | k rx| }  Pqxq,q,Wt |  | | ƒ St  d | d ƒ } | j ƒ  } | j ƒ  t | ƒ \ } } } | rß| rß| }  n  | rî| } n  | rý| } n  |  | | f S(   sä   Tries to determine the name of the Linux OS distribution name.

        The function first looks for a distribution release file in
        /etc and then reverts to _dist_try_harder() in case no
        suitable files are found.

        supported_dists may be given to define the set of Linux
        distributions to look for. It defaults to a list of currently
        supported Linux distributions identified by their release file
        name.

        If full_distribution_name is true (default), the full
        distribution read from the OS is returned. Otherwise the short
        name taken from supported_dists is used.

        Returns a tuple (distname,version,id) which default to the
        args given as parameters.

    s   /etc/lsb-releaset   rUi   Ns   /etcs   /etc/t   r(   R   t   _distributor_id_file_reR   t   groupR-   t   _release_file_ret   _codename_file_ret   EnvironmentErrort   UnboundLocalErrorR   R/   t   errorR1   t   _release_filenameRK   RL   R   R=   t   readlineR   RQ   (   R2   R   R3   t   supported_distst   full_distribution_namet	   etclsbrelR5   R   t   _u_distnamet
   _u_versiont   _u_idt   etct   filet	   _distnamet   dummyR   RO   t   _versiont   _id(    (    s   /usr/lib/python2.7/platform.pyt   linux_distribution)  sP    

			c         C   s   t  |  | | d | d d ƒS(   sQ   Tries to determine the name of the Linux OS distribution name.

        The function first looks for a distribution release file in
        /etc and then reverts to _dist_try_harder() in case no
        suitable files are found.

        Returns a tuple (distname,version,id) which default to the
        args given as parameters.

    R]   R^   i    (   Ri   (   R2   R   R3   R]   (    (    s   /usr/lib/python2.7/platform.pyt   distt  s    t   _popenc           B   sb   e  Z d  Z d Z d Z d Z d Z d d d „ Z d „  Z	 d „  Z
 e j e j d „ Z e Z RS(   s   Fairly portable (alternative) popen implementation.

        This is mostly needed in case os.popen() is not available, or
        doesn't work as advertised, e.g. in Win9X GUI programs like
        PythonWin or IDLE.

        Writing to the pipe is currently not supported.

    R   RS   c         C   st   | d k r t  d ‚ n  d d  l } | j ƒ  |  _ } t j | d | ƒ t | d ƒ |  _ | |  _ | |  _	 d  S(   NRS   s)   popen()-emulation only supports read modeiÿÿÿÿs    > %sR   (
   t
   ValueErrort   tempfilet   mktempt   tmpfileR   t   systemR   t   pipet   bufsizet   mode(   t   selft   cmdRs   Rr   Rm   Ro   (    (    s   /usr/lib/python2.7/platform.pyt   __init__–  s    	c         C   s   |  j  j ƒ  S(   N(   Rq   R   (   Rt   (    (    s   /usr/lib/python2.7/platform.pyR   ¡  s    c         C   s    |  j  d  k	 r |  j j ƒ  Sd  S(   N(   Rr   RL   Rq   R*   (   Rt   (    (    s   /usr/lib/python2.7/platform.pyR*   ¥  s    c         C   sV   |  j  r |  j  j ƒ  } n d } |  j rR y | |  j ƒ WqR | k
 rN qR Xn  | S(   Niÿ   (   Rq   R   Ro   (   Rt   t   removeRZ   t   rc(    (    s   /usr/lib/python2.7/platform.pyR   ª  s    		N(   t   __name__t
   __module__t   __doc__Ro   RL   Rq   Rr   Rs   Rv   R   R*   R   t   unlinkRZ   R   t   __del__(    (    (    s   /usr/lib/python2.7/platform.pyRk   †  s   
		RS   c         C   së   d } t j j d d ƒ d k rQ y d d l } Wn t k
 rD qQ X| j } n  | d k r¾ t t d ƒ rµ t j } t j	 d k r» y | d ƒ Wq² t j
 k
 r® t } q² Xq» q¾ t } n  | d k r× | |  | ƒ S| |  | | ƒ Sd S(   s!    Portable popen() interface.
    t   OSR   t
   Windows_NTiÿÿÿÿNt   popenR   (   RL   R   t   environt   gett	   win32pipet   ImportErrorR€   R
   t   syst   platformRZ   Rk   (   Ru   Rs   Rr   R€   Rƒ   (    (    s   /usr/lib/python2.7/platform.pyR€   ¼  s&    		c         C   s~   t  j |  d ƒ } | r( | j | ƒ n  y t t | ƒ } Wn t k
 rT | } n Xt t | ƒ } t  j | d  d ƒ }  |  S(   sŒ    Normalize the version and build strings and return a single
        version string using the format major.minor.build (or patchlevel).
    t   .i   (   R+   R,   t   appendt   mapt   intRl   t   strt   join(   R   t   buildRP   t   intst   strings(    (    s   /usr/lib/python2.7/platform.pyt   _norm_versionÝ  s    
s'   (?:([\w ]+) ([\w.]+) .*\[.* ([\d.]+)\])c   	      C   s8  t  j | k r |  | | f Sx„ d D]o } y7 t | ƒ } | j ƒ  } | j ƒ  r_ t j d ‚ n  Wn. t j k
 r{ } q# q# t k
 r } q# q# XPq# W|  | | f St j	 | ƒ } t
 j | ƒ } | d k	 r+| j ƒ  \ }  } } | d d k rÿ | d  } n  | d d k r| d  } n  t | ƒ } n  |  | | f S(	   s2   Tries to figure out the OS version used and returns
        a tuple (system,release,version).

        It uses the "ver" shell command for this which is known
        to exists on Windows, DOS and OS/2. XXX Others too ?

        In case this fails, the given parameters are used as
        defaults.

    t   vers   command /c vers
   cmd /c vers   command failediÿÿÿÿR‡   (   R‘   s   command /c vers
   cmd /c verN(   R…   R†   R€   R   R   R   RZ   t   IOErrorR+   R-   t   _ver_outputRK   RL   R   R   (	   Rp   t   releaseR   t   supported_platformsRu   Rq   R4   t   whyR   (    (    s   /usr/lib/python2.7/platform.pyt   _syscmd_verû  s0    t   2000i   i    t   XPt
   2003Serveri   t   post2003t   Vistai   t   7t   8s   8.1i   s   post8.1t   10i
   t   post10t
   2008Servert   2008ServerR2t
   2012Servert   2012ServerR2t   post2012ServerR2c            s  |  d k  s$ |  d k r1 | d k  r1 |  | | f Sd d l  m } m } m } m } m } m } m }	 d d l m	 ‰  m
 }
 d | f ‡  f d †  ƒ  Y‰ d |	 f ‡ f d	 †  ƒ  Y} | d
 ƒ } | d ƒ } d } } x] | | k r4| d 9} | | ƒ } | j |
 | j ƒ | t | ƒ ƒ } | sØ |  | | f SqØ W| j | d  ƒ } | sZ|  | | f S| | ƒ } | j | d  | | ƒ s†| r“|  | | f S| ƒ  } | j | d | | ƒ | ˆ  ƒ  ƒ ƒ sÐ|  | | f S| j j d ?}  | j j d @} | j j d ?} |  | | f S(   Ni   i   iÿÿÿÿ(   t   c_buffert   POINTERt   byreft   create_unicode_buffert	   Structuret   WinDLLt   _Pointer(   t   DWORDt   HANDLEt   VS_FIXEDFILEINFOc              sƒ   e  Z d  ˆ  f d ˆ  f d ˆ  f d ˆ  f d ˆ  f d ˆ  f d ˆ  f d ˆ  f d ˆ  f d	 ˆ  f d
 ˆ  f d ˆ  f d ˆ  f g Z RS(   t   dwSignaturet   dwStrucVersiont   dwFileVersionMSt   dwFileVersionLSt   dwProductVersionMSt   dwProductVersionLSt   dwFileFlagsMaskt   dwFileFlagst   dwFileOSt
   dwFileTypet   dwFileSubtypet   dwFileDateMSt   dwFileDateLS(   Ry   Rz   t   _fields_(    (   R­   (    s   /usr/lib/python2.7/platform.pyR¯   T  s   												t   PVS_FIXEDFILEINFOc              s   e  Z ˆ  Z RS(    (   Ry   Rz   t   _type_(    (   R¯   (    s   /usr/lib/python2.7/platform.pyR¾   d  s   t   kernel32R   i‚   R   i   iÿÿ  (   t   ctypesR¦   R§   R¨   R©   Rª   R«   R¬   t   ctypes.wintypesR­   R®   t   GetModuleFileNameWt   _handleR   t   GetFileVersionInfoSizeWRL   t   GetFileVersionInfoWt   VerQueryValueWt   contentsR´   Rµ   (   t   majt   minR   R¦   R§   R¨   R©   Rª   R«   R¬   R®   R¾   RÀ   R   t   name_lent
   actual_lent   namet   sizet	   ver_blockt   pvi(    (   R­   R¯   s   /usr/lib/python2.7/platform.pyt   _get_real_winverL  s<    $4

	'c         C   s  y d d l  m } Wn t k
 r4 |  | | | f SXy& d d l m } m } m } m } Wn3 t k
 r d d l m } m } m } m } n X| ƒ  }	 t	 |	 d  Œ  \ }
 } } d j
 |
 | | ƒ } t j |
 | f ƒ põ t j |
 d  f ƒ põ |  }  |	 d  |
 | f k r\y d j
 |	 j ƒ } Wq\t k
 rX| d  d	 k rYd
 | d } qYq\Xn  t |	 d d  ƒ d k r§t j |
 | f ƒ p¡t j |
 d  f ƒ p¡|  }  n  d  } z4 y& | | d ƒ } | | d ƒ d } Wn n XWd  | r÷| | ƒ n  X|  | | | f S(   Niÿÿÿÿ(   t   getwindowsversion(   t	   OpenKeyExt   QueryValueExt   CloseKeyt   HKEY_LOCAL_MACHINEi   s   {0}.{1}.{2}i   s   SP{}i   s   Service Pack t   SPt   product_types,   SOFTWARE\Microsoft\Windows NT\CurrentVersiont   CurrentTypei    (   R…   RÒ   R„   t   winregRÓ   RÔ   RÕ   RÖ   t   _winregRÑ   t   formatt   _WIN32_CLIENT_RELEASESR‚   RL   t   service_pack_majort   AttributeErrort   getattrt   _WIN32_SERVER_RELEASES(   R”   R   t   csdt   ptypeRÒ   RÓ   RÔ   RÕ   RÖ   t   winverRÉ   RÊ   R   t   key(    (    s   /usr/lib/python2.7/platform.pyt	   win32_ver‰  sF    &&		 	c         C   s{   d d l  m  } d d  l } g  } | j } xI |  D]A } y | | | ƒ ƒ Wq2 t | j f k
 rr | | ƒ q2 Xq2 W| S(   Niÿÿÿÿ(   t   gestalt(   Rç   t   MacOSRˆ   t   RuntimeErrort   Error(   t	   selectorst   defaultRç   Rè   RP   Rˆ   t   selector(    (    s   /usr/lib/python2.7/platform.pyt   _mac_ver_lookup¸  s    	c         C   s   t  |  ƒ d S(   Ni   (   t   hex(   t   bcd(    (    s   /usr/lib/python2.7/platform.pyt   _bcd2strÅ  s    c    
      C   s  y d d l  }  d d l } Wn t k
 r0 d SXt d ƒ \ } } | rÈ | d @d ?} | d @d ?} | d	 @} | | f d k r¬ t d ƒ \ } } } d | | | f } qÈ d t | ƒ | | f } n  | rø i d d 6d d 6d d
 6j | d ƒ } n  d }	 | |	 | f S(   sã   
        Thanks to Mark R. Levinson for mailing documentation links and
        code examples for this function. Documentation for the
        gestalt() API is available online at:

           http://www.rgaros.nl/gestalt/
    iÿÿÿÿNt   sysvt   sysai ÿ  i   ið   i   i   i
   t   sys1t   sys2t   sys3s   %i.%i.%is   %s.%i.%it   68ki   t   PowerPCi   t   i386R   (   Rò   Ró   (   i
   i   (   Rô   Rõ   Rö   (   R   R   R   (   Rç   Rè   R„   RL   Rî   Rñ   R‚   (
   Rç   Rè   Rò   Ró   t   majort   minort   patchR”   t   machinet   versioninfo(    (    s   /usr/lib/python2.7/platform.pyt   _mac_ver_gestaltÉ  s(    	

c          C   s’   d }  t  j j |  ƒ s d  Sy d d  l } Wn t k
 r@ d  SX| j |  ƒ } | d } d	 } t  j ƒ  d } | d
 k r… d } n  | | | f S(   Ns0   /System/Library/CoreServices/SystemVersion.plistiÿÿÿÿt   ProductVersionR   i   t   ppcs   Power MacintoshRø   (   R   R   R   (   R  s   Power Macintosh(   R   R   R)   RL   t   plistlibR„   t	   readPlistt   uname(   t   fnR  t   plR”   Rþ   Rý   (    (    s   /usr/lib/python2.7/platform.pyt   _mac_ver_xmlò  s    
	c         C   s?   t  ƒ  } | d k	 r | St ƒ  } | d k	 r2 | S|  | | f S(   s<   Get MacOS version information and return it as tuple (release,
        versioninfo, machine) with versioninfo being a tuple (version,
        dev_stage, non_release_version).

        Entries which cannot be determined are set to the parameter values
        which default to ''. All tuple entries are strings.
    N(   R  RL   Rÿ   (   R”   Rþ   Rý   R4   (    (    s   /usr/lib/python2.7/platform.pyt   mac_ver  s    		c         C   sP   d d l  m } y' | j |  ƒ } | d  k r2 | S| SWn t k
 rK | SXd  S(   Niÿÿÿÿ(   t   System(   t	   java.langR	  t   getPropertyRL   Rß   (   RÍ   Rì   R	  R8   (    (    s   /usr/lib/python2.7/platform.pyt   _java_getprop   s    c         C   sõ   y d d l  } Wn t k
 r0 |  | | | f SXt d | ƒ } t d |  ƒ }  | \ } } } t d | ƒ } t d | ƒ } t d | ƒ } | | | f } | \ } }	 }
 t d |
 ƒ }
 t d	 | ƒ } t d
 |	 ƒ }	 | |	 |
 f } |  | | | f S(   sV   Version interface for Jython.

        Returns a tuple (release,vendor,vminfo,osinfo) with vminfo being
        a tuple (vm_name,vm_release,vm_vendor) and osinfo being a
        tuple (os_name,os_version,os_arch).

        Values which cannot be determined are set to the defaults
        given as parameters (which all default to '').

    iÿÿÿÿNs   java.vendors   java.versions   java.vm.names   java.vm.vendors   java.vm.versions   java.os.archs   java.os.names   java.os.version(   R
  R„   R  (   R”   t   vendort   vminfot   osinfot   javat   vm_namet
   vm_releaset	   vm_vendort   os_namet
   os_versiont   os_arch(    (    s   /usr/lib/python2.7/platform.pyt   java_ver+  s"    c         C   s  |  d k r d |  | | f S|  d k rÏ | d k  rB |  | | f St  j | d ƒ } | r± y t | d ƒ } Wn t k
 r q± X| d } t | ƒ | d <t  j | d ƒ } n  | d k  rÆ d	 }  qd	 }  nC |  d
 k rý d }  | rô | d } qd } n |  d k rd }  n  |  | | f S(   sá    Returns (system,release,version) aliased to common
        marketing names used for some systems.

        It also does some reordering of the information in some cases
        where it would otherwise cause confusion.

    t   Rhapsodys   MacOS X Servert   SunOSt   5R‡   i    i   t   6t   Solarist   IRIX64t   IRIXs    (64bit)t   64bitR   R   t   Windows(   R   R   (   R+   R,   RŠ   Rl   R‹   RŒ   (   Rp   R”   R   RP   Rú   (    (    s   /usr/lib/python2.7/platform.pyt   system_aliasN  s2    	
				c          G   s&  t  j t t  j t t |  ƒ ƒ d ƒ } t  j } | | d d ƒ } | | d d ƒ } | | d d ƒ } | | d d ƒ } | | d d ƒ } | | d d ƒ } | | d	 d ƒ } | | d
 d ƒ } | | d d ƒ } x, | | d d ƒ } | | k r÷ Pn  | } qÕ Wx | d d k r!| d  } qW| S(   sq    Helper to format the platform string in a filename
        compatible format e.g. "system-version-machine".
    R&   t    t   _t   /s   \t   :t   ;t   "t   (t   )t   unknownR   s   --iÿÿÿÿ(   R+   RŒ   R‰   R-   t   filterR   t   replace(   t   argsR†   R,  t   cleaned(    (    s   /usr/lib/python2.7/platform.pyt	   _platform„  s,    			
c         C   sO   y d d l  } Wn t k
 r$ |  SXy | j ƒ  SWn | j k
 rJ |  SXd S(   s8    Helper to determine the node name of this machine.
    iÿÿÿÿN(   t   socketR„   t   gethostnameRZ   (   Rì   R0  (    (    s   /usr/lib/python2.7/platform.pyt   _node¨  s    t   abspathc         C   s+   | |  ƒ s! | | ƒ  |  ƒ }  n  | |  ƒ S(   N(    (   R   t   isabsRŒ   t   getcwdt   normpath(    (    s   /usr/lib/python2.7/platform.pyt   _abspathº  s    c         C   s_   t  |  ƒ }  xL t j j |  ƒ rZ t j j t j j t j j |  ƒ t j |  ƒ ƒ ƒ }  q W|  S(   sT    In case filepath is a symlink, follow it until a
        real file is reached.
    (   R7  R   R   t   islinkR6  RŒ   t   dirnamet   readlink(   t   filepath(    (    s   /usr/lib/python2.7/platform.pyt   _follow_symlinksÇ  s
    	1c         C   sˆ   t  j d k r | Sy t j d |  t f ƒ } Wn t t j f k
 rM | SXt j | j	 ƒ  ƒ } | j
 ƒ  } | s| | r€ | S| Sd S(   s.    Interface to the system's uname command.
    R    R   R   R   s   uname %s 2> %sN(   R    R   R   R   (   R…   R†   R   R€   t   DEV_NULLRß   RZ   R+   R-   R   R   (   t   optionRì   R   t   outputRx   (    (    s   /usr/lib/python2.7/platform.pyt   _syscmd_unameÒ  s    c         C   s©   d d l  } t j d k r | St |  ƒ }  y+ | j d |  g d | j d	 | j ƒ} Wn t t j	 f k
 rs | SX| j
 ƒ  d
 } | j ƒ  } | s | r¡ | S| Sd S(   s&   Interface to the system's file command.

        The function uses the -b option of the file command to have it
        ommit the filename in its output and if possible the -L option
        to have the command follow symlinks. It returns default in
        case the command should fail.

    iÿÿÿÿNR    R   R   R   Rd   t   stdoutt   stderri    (   R    R   R   R   (   t
   subprocessR…   R†   R<  t   Popent   PIPEt   STDOUTRß   R   RZ   t   communicatet   wait(   t   targetRì   RC  t   procR?  Rx   (    (    s   /usr/lib/python2.7/platform.pyt   _syscmd_fileä  s    t	   WindowsPER   t   MSDOSs   [\s,]c   	      C   s»  | sb d d l  } y | j d ƒ } Wn# | j k
 rJ | j d ƒ } n Xt | d ƒ d } n  |  rz t |  d ƒ } n d } | rã |  t j k rã t j t k rÙ t t j \ } } | rÇ | } n  | rÙ | } qÙ n  | | f St	 | ƒ d } d	 | k r	| | f Sd
 | k rd } n* d | k r3d } n d | k rHd } n  d | k r]d } nT d | k r‡d | k r~d } q±d } n* d | k rœd } n d | k r±d } n  | | f S(   s“   Queries the given executable (defaults to the Python interpreter
        binary) for various architecture information.

        Returns a tuple (bits,linkage) which contains information about
        the bit architecture and the linkage format used for the
        executable. Both values are returned as strings.

        Values that cannot be determined are returned as given by the
        parameter presets. If bits is given as '', the sizeof(pointer)
        (or sizeof(long) on Python version < 1.5.2) is used as
        indicator for the supported pointer size.

        The function relies on the system's "file" command to do the
        actual work. This is available on most if not all Unix
        platforms. On some non-Unix platforms where the "file" command
        does not exist and the executable is set to the Python interpreter
        binary defaults from _default_architecture are used.

    iÿÿÿÿNt   PRP   i   t   bitR   i   R   s   32-bitt   32bitt   N32t   n32bits   64-bitR  t   ELFt   PER   RL  t   COFFs   MS-DOSRM  (
   t   structt   calcsizeRZ   R‹   RK  R…   R   R†   t   _default_architecturet   _architecture_split(	   R   t   bitst   linkageRV  RÎ   R?  t   bRP   t   fileout(    (    s   /usr/lib/python2.7/platform.pyt   architecture  sN    	

								c          C   s¨  d }  t  d k	 r t  Sd } y t j ƒ  \ } } } } } Wn t k
 rT d }  n X|  sz t d | | | | | f ƒ rG|  r§ t j } d } d } t ƒ  } d } n  d } | d k rIt	 ƒ  \ } } } }	 | rã | rã d } n  | s(d t j
 k rt j
 j d d ƒ } q(t j
 j d d ƒ } n  | sIt j
 j d | ƒ } qIn  | r¼t | ƒ \ } } } | d k ryd	 } q¼| d
 k r¼| d	 k r¼d	 } d | d  k r°d } q¹d } q¼n  | d k rõ| sì| d k rãd } qìd } n  d	 } qG| d  d k rGt ƒ  \ } }
 } } d } t j | d ƒ } | sD|
 } qDqGn  | d k rÏ| sf| d k ru| } d } n  y d d l } Wn t k
 r˜qÏX| j d d ƒ \ } } | d k rÆd } qÏd } n  | sçt d d ƒ } n  | d k rüd } n  | d k rd } n  | d k r&d } n  | d k r;d } n  | d k rPd } n  | d k red } n  | d
 k rŒ| d	 k rŒd	 } d } n  | | | | | | f a  t  S(    si   Fairly portable uname interface. Returns a tuple
        of strings (system,node,release,version,machine,processor)
        identifying the underlying platform.

        Note that unlike the os.uname function this also returns
        possible processor information as an additional tuple entry.

        Entries which cannot be determined are set to ''.

    i    R   i   R   t   PROCESSOR_ARCHITEW6432t   PROCESSOR_ARCHITECTUREt   PROCESSOR_IDENTIFIERs   Microsoft WindowsR   t	   Microsofts   6.0i   Rœ   R   RP  t   16biti   R  t   Javas   , t   OpenVMSt   0iÿÿÿÿNs   SYI$_CPUi€   t   Alphat   VAXs   -pR*  (   R   R   (   t   _uname_cacheRL   R   R  Rß   R+  R…   R†   R2  Ræ   R   R‚   R—   R  R+   RŒ   t   vms_libR„   t   getsyiR@  (   t   no_os_unamet	   processorRp   t   nodeR”   R   Rý   t   use_syscmd_verRâ   Rã   R  R  R  Rj  t   csidt
   cpu_number(    (    s   /usr/lib/python2.7/platform.pyR  x  sœ    
%																			c           C   s   t  ƒ  d S(   s    Returns the system/OS name, e.g. 'Linux', 'Windows' or 'Java'.

        An empty string is returned if the value cannot be determined.

    i    (   R  (    (    (    s   /usr/lib/python2.7/platform.pyRp     s    c           C   s   t  ƒ  d S(   s    Returns the computer's network name (which may not be fully
        qualified)

        An empty string is returned if the value cannot be determined.

    i   (   R  (    (    (    s   /usr/lib/python2.7/platform.pyRn  
  s    c           C   s   t  ƒ  d S(   s    Returns the system's release, e.g. '2.2.0' or 'NT'

        An empty string is returned if the value cannot be determined.

    i   (   R  (    (    (    s   /usr/lib/python2.7/platform.pyR”     s    c           C   s   t  ƒ  d S(   s‡    Returns the system's release version, e.g. '#3 on degas'

        An empty string is returned if the value cannot be determined.

    i   (   R  (    (    (    s   /usr/lib/python2.7/platform.pyR     s    c           C   s   t  ƒ  d S(   st    Returns the machine type, e.g. 'i386'

        An empty string is returned if the value cannot be determined.

    i   (   R  (    (    (    s   /usr/lib/python2.7/platform.pyRý   &  s    c           C   s   t  ƒ  d S(   s   Returns the (true) processor name, e.g. 'amdk6'

        An empty string is returned if the value cannot be
        determined. Note that many platforms do not provide this
        information or simply return the same value as for machine(),
        e.g.  NetBSD does this.

    i   (   R  (    (    (    s   /usr/lib/python2.7/platform.pyRm  /  s    
sL   ([\w.+]+)\s*\(#?([^,]+)(?:,\s*([\w ]*)(?:,\s*([\w :]*))?)?\)\s*\[([^\]]+)\]?s;   IronPython\s*([\d\.]+)(?: \(([\d\.]+)\))? on (.NET [\d\.]+)sU   ([\d.]+)\s*\(IronPython\s*[\d.]+\s*\(([\d.]+)\) on ([\w.]+ [\d.]+(?: \(\d+-bit\))?)\)sE   ([\w.+]+)\s*\(#?([^,]+),\s*([\w ]+),\s*([\w :]+)\)\s*\[PyPy [^\]]+\]?c         C   sÔ  |  d k r t j }  n  t j |  d ƒ } | d k	 r: | Sd |  k rÅ d } |  j d ƒ rm t j |  ƒ } n t j |  ƒ } | d k r¡ t	 d t
 |  ƒ ƒ ‚ n  | j ƒ  \ } } } d } d } npt j j d ƒ rMd } t j |  ƒ } | d k rt	 d t
 |  ƒ ƒ ‚ n  | j ƒ  \ } } } }	 }
 | d k rAd } n  t j } nè d |  k r´d } t j |  ƒ } | d k r“t	 d t
 |  ƒ ƒ ‚ n  | j ƒ  \ } } } }	 d } n t j |  ƒ } | d k rèt	 d	 t
 |  ƒ ƒ ‚ n  | j ƒ  \ } } } }	 } d
 } | d k rd } n |	 r5| d |	 } n  t t d ƒ rYt j \ }
 } } n d } d } t j | d ƒ } t | ƒ d k r«| j d ƒ t j | d ƒ } n  | | | | | | | f } | t |  <| S(   sÛ   Returns a parsed version of Python's sys.version as tuple
        (name, version, branch, revision, buildno, builddate, compiler)
        referring to the Python implementation name, version, branch,
        revision, build number, build date/time as string and the compiler
        identification string.

        Note that unlike the Python sys.version, the returned value
        for the Python version will always include the patchlevel (it
        defaults to '.0').

        The function returns empty strings for tuple entries that
        cannot be determined.

        sys_version may be given to parse an alternative version
        string, e.g. if the version was read from a different Python
        interpreter.

    t
   IronPythons*   failed to parse IronPython sys.version: %sR   R  t   Jythons&   failed to parse Jython sys.version: %st   PyPys$   failed to parse PyPy sys.version: %ss'   failed to parse CPython sys.version: %st   CPythonR"  t
   subversionR‡   i   Rf  N(   RL   R…   R   t   _sys_version_cacheR‚   t
   startswitht   _ironpython_sys_version_parserRK   t    _ironpython26_sys_version_parserRl   t   reprR   R†   t   _sys_version_parsert   _pypy_sys_version_parserR
   Rv  R+   R,   R   Rˆ   RŒ   (   t   sys_versiont   resultRÍ   RK   R   t   alt_versiont   compilert   buildnot	   builddatet	   buildtimeR#  t   brancht   revisionRP   (    (    s   /usr/lib/python2.7/platform.pyt   _sys_versionY  st    				
c           C   s   t  ƒ  d S(   sR   Returns a string identifying the Python implementation.

        Currently, the following implementations are identified:
          'CPython' (C implementation of Python),
          'IronPython' (.NET implementation of Python),
          'Jython' (Java implementation of Python),
          'PyPy' (Python implementation of Python).

    i    (   R‡  (    (    (    s   /usr/lib/python2.7/platform.pyt   python_implementationÀ  s    c           C   s   t  ƒ  d S(   sÈ    Returns the Python version as string 'major.minor.patchlevel'

        Note that unlike the Python sys.version, the returned value
        will always include the patchlevel (it defaults to 0).

    i   (   R‡  (    (    (    s   /usr/lib/python2.7/platform.pyt   python_versionÍ  s    c           C   s   t  t j t ƒ  d d ƒ ƒ S(   sÝ    Returns the Python version as tuple (major, minor, patchlevel)
        of strings.

        Note that unlike the Python sys.version, the returned value
        will always include the patchlevel (it defaults to 0).

    i   R‡   (   RM   R+   R,   R‡  (    (    (    s   /usr/lib/python2.7/platform.pyt   python_version_tuple×  s    	c           C   s   t  ƒ  d S(   sè    Returns a string identifying the Python implementation
        branch.

        For CPython this is the Subversion branch from which the
        Python binary was built.

        If not available, an empty string is returned.

    i   (   R‡  (    (    (    s   /usr/lib/python2.7/platform.pyt   python_branchâ  s    c           C   s   t  ƒ  d S(   sì    Returns a string identifying the Python implementation
        revision.

        For CPython this is the Subversion revision from which the
        Python binary was built.

        If not available, an empty string is returned.

    i   (   R‡  (    (    (    s   /usr/lib/python2.7/platform.pyt   python_revisionð  s    c           C   s   t  ƒ  d d !S(   sh    Returns a tuple (buildno, builddate) stating the Python
        build number and date as strings.

    i   i   (   R‡  (    (    (    s   /usr/lib/python2.7/platform.pyt   python_buildý  s    c           C   s   t  ƒ  d S(   sS    Returns a string identifying the compiler used for compiling
        Python.

    i   (   R‡  (    (    (    s   /usr/lib/python2.7/platform.pyt   python_compiler  s    c      	   C   s[  t  j |  | f d ƒ } | d k	 r( | St ƒ  \ } } } } } } | | k rX d } n  |  r| t | | | ƒ \ } } } n  | d k rÐ t | ƒ \ }	 }
 } } | r¸ t | | ƒ } qGt | | | | ƒ } nw| d	 k rYt d ƒ \ } } } | r"| r"t | | | | d | | | ƒ } qGt t	 j
 ƒ \ } } t | | | | d | | ƒ } nî | d k rÆt ƒ  \ } } } \ } } } | s| r¥t | | | ƒ } qGt | | | d | | | ƒ } n | d k rÿ| rêt | | ƒ } qGt | | | ƒ } nH | rt | | ƒ } n0 t t	 j
 ƒ \ } } t | | | | | | ƒ } | t  |  | f <| S(
   sË   Returns a single string identifying the underlying platform
        with as much useful information as possible (but no more :).

        The output is intended to be human readable rather than
        machine parseable. It may look different on different
        platforms and this is intended.

        If "aliased" is true, the function will use aliases for
        various platforms that report system names which differ from
        their common names, e.g. SunOS will be reported as
        Solaris. The system_alias() function is used to implement
        this.

        Setting terse to true causes the function to return only the
        absolute minimum information needed to identify the platform.

    R   R   t   Linuxt   withRd  t   onRè   N(   R  (   t   _platform_cacheR‚   RL   R  R!  Ræ   R/  Rj   R"   R…   R   R  R^  (   t   aliasedt   terseR  Rp   Rn  R”   R   Rý   Rm  t   relt   versRâ   Rã   R†   R2   t   distversiont   distidt   libcnamet   libcversionRS   t   vR  R  R  R  RZ  R[  (    (    s   /usr/lib/python2.7/platform.pyR†     sP    	t   __main__R”  s   --terset
   nonaliaseds   --nonaliased(   R    R   R   R   (   R#   R>   R?   R@   RA   RB   RC   RD   R(   RE   RF   RG   RH   RI   (    (   R   R   R    R   (   i   i    (   i   i   (   i   i   (   i   N(   i   i    (   i   i   (   i   i   (   i   i   (   i   N(   i
   i    (   i
   N(   i   i   (   i   i    (   i   i   (   i   i   (   i   i   (   i   N(   R   R   R   (   R   R   R   (   R   R   R   (   R   RL  (   R   R   (   R   RM  (Y   R{   t   __copyright__t   __version__R…   R+   R   t   ret   devnullR=  Rß   R†   t   compileR   R   R"   R=   R[   RJ   RN   t   _supported_distsRQ   t   IRT   RV   RW   Ri   Rj   Rk   RL   R€   R   R“   R—   RÝ   Rá   RÑ   Ræ   Rî   Rñ   Rÿ   R  R  R  R  R!  R/  R2  R
   R   R4  RŒ   R5  R6  R7  R3  R<  R@  RK  RX  R,   RY  R^  Ri  R  Rp   Rn  R”   R   Rý   Rm  R|  Ry  Rz  R}  Rw  R‡  Rˆ  R‰  RŠ  R‹  RŒ  R  RŽ  R’  Ry   t   argvR”  R“  t   exit(    (    (    s   /usr/lib/python2.7/platform.pyt   <module>
   sÜ   h0	
3	2  		H	6!	2

	=/		)		#	6	$	3
W	‰			
											g		
					
R                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        """This file is only retained for backwards compatibility.
It will be removed in the future.  sre was moved to re in version 2.5.
"""

import warnings
warnings.warn("The sre module is deprecated, please import re.",
              DeprecationWarning, 2)

from re import *
from re import __all__

# old pickles expect the _compile() reconstructor in this module
from re import _compile
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                r"""plistlib.py -- a tool to generate and parse MacOSX .plist files.

The PropertyList (.plist) file format is a simple XML pickle supporting
basic object types, like dictionaries, lists, numbers and strings.
Usually the top level object is a dictionary.

To write out a plist file, use the writePlist(rootObject, pathOrFile)
function. 'rootObject' is the top level object, 'pathOrFile' is a
filename or a (writable) file object.

To parse a plist from a file, use the readPlist(pathOrFile) function,
with a file name or a (readable) file object as the only argument. It
returns the top level object (again, usually a dictionary).

To work with plist data in strings, you can use readPlistFromString()
and writePlistToString().

Values can be strings, integers, floats, booleans, tuples, lists,
dictionaries, Data or datetime.datetime objects. String values (including
dictionary keys) may be unicode strings -- they will be written out as
UTF-8.

The <data> plist type is supported through the Data class. This is a
thin wrapper around a Python string.

Generate Plist example:

    pl = dict(
        aString="Doodah",
        aList=["A", "B", 12, 32.1, [1, 2, 3]],
        aFloat=0.1,
        anInt=728,
        aDict=dict(
            anotherString="<hello & hi there!>",
            aUnicodeValue=u'M\xe4ssig, Ma\xdf',
            aTrueValue=True,
            aFalseValue=False,
        ),
        someData=Data("<binary gunk>"),
        someMoreData=Data("<lots of binary gunk>" * 10),
        aDate=datetime.datetime.fromtimestamp(time.mktime(time.gmtime())),
    )
    # unicode keys are possible, but a little awkward to use:
    pl[u'\xc5benraa'] = "That was a unicode key."
    writePlist(pl, fileName)

Parse Plist example:

    pl = readPlist(pathOrFile)
    print pl["aKey"]
"""


__all__ = [
    "readPlist", "writePlist", "readPlistFromString", "writePlistToString",
    "readPlistFromResource", "writePlistToResource",
    "Plist", "Data", "Dict"
]
# Note: the Plist and Dict classes have been deprecated.

import binascii
import datetime
from cStringIO import StringIO
import re
import warnings


def readPlist(pathOrFile):
    """Read a .plist file. 'pathOrFile' may either be a file name or a
    (readable) file object. Return the unpacked root object (which
    usually is a dictionary).
    """
    didOpen = 0
    if isinstance(pathOrFile, (str, unicode)):
        pathOrFile = open(pathOrFile)
        didOpen = 1
    p = PlistParser()
    rootObject = p.parse(pathOrFile)
    if didOpen:
        pathOrFile.close()
    return rootObject


def writePlist(rootObject, pathOrFile):
    """Write 'rootObject' to a .plist file. 'pathOrFile' may either be a
    file name or a (writable) file object.
    """
    didOpen = 0
    if isinstance(pathOrFile, (str, unicode)):
        pathOrFile = open(pathOrFile, "w")
        didOpen = 1
    writer = PlistWriter(pathOrFile)
    writer.writeln("<plist version=\"1.0\">")
    writer.writeValue(rootObject)
    writer.writeln("</plist>")
    if didOpen:
        pathOrFile.close()


def readPlistFromString(data):
    """Read a plist data from a string. Return the root object.
    """
    return readPlist(StringIO(data))


def writePlistToString(rootObject):
    """Return 'rootObject' as a plist-formatted string.
    """
    f = StringIO()
    writePlist(rootObject, f)
    return f.getvalue()


def readPlistFromResource(path, restype='plst', resid=0):
    """Read plst resource from the resource fork of path.
    """
    warnings.warnpy3k("In 3.x, readPlistFromResource is removed.",
                      stacklevel=2)
    from Carbon.File import FSRef, FSGetResourceForkName
    from Carbon.Files import fsRdPerm
    from Carbon import Res
    fsRef = FSRef(path)
    resNum = Res.FSOpenResourceFile(fsRef, FSGetResourceForkName(), fsRdPerm)
    Res.UseResFile(resNum)
    plistData = Res.Get1Resource(restype, resid).data
    Res.CloseResFile(resNum)
    return readPlistFromString(plistData)


def writePlistToResource(rootObject, path, restype='plst', resid=0):
    """Write 'rootObject' as a plst resource to the resource fork of path.
    """
    warnings.warnpy3k("In 3.x, writePlistToResource is removed.", stacklevel=2)
    from Carbon.File import FSRef, FSGetResourceForkName
    from Carbon.Files import fsRdWrPerm
    from Carbon import Res
    plistData = writePlistToString(rootObject)
    fsRef = FSRef(path)
    resNum = Res.FSOpenResourceFile(fsRef, FSGetResourceForkName(), fsRdWrPerm)
    Res.UseResFile(resNum)
    try:
        Res.Get1Resource(restype, resid).RemoveResource()
    except Res.Error:
        pass
    res = Res.Resource(plistData)
    res.AddResource(restype, resid, '')
    res.WriteResource()
    Res.CloseResFile(resNum)


class DumbXMLWriter:

    def __init__(self, file, indentLevel=0, indent="\t"):
        self.file = file
        self.stack = []
        self.indentLevel = indentLevel
        self.indent = indent

    def beginElement(self, element):
        self.stack.append(element)
        self.writeln("<%s>" % element)
        self.indentLevel += 1

    def endElement(self, element):
        assert self.indentLevel > 0
        assert self.stack.pop() == element
        self.indentLevel -= 1
        self.writeln("</%s>" % element)

    def simpleElement(self, element, value=None):
        if value is not None:
            value = _escapeAndEncode(value)
            self.writeln("<%s>%s</%s>" % (element, value, element))
        else:
            self.writeln("<%s/>" % element)

    def writeln(self, line):
        if line:
            self.file.write(self.indentLevel * self.indent + line + "\n")
        else:
            self.file.write("\n")


# Contents should conform to a subset of ISO 8601
# (in particular, YYYY '-' MM '-' DD 'T' HH ':' MM ':' SS 'Z'.  Smaller units may be omitted with
#  a loss of precision)
_dateParser = re.compile(r"(?P<year>\d\d\d\d)(?:-(?P<month>\d\d)(?:-(?P<day>\d\d)(?:T(?P<hour>\d\d)(?::(?P<minute>\d\d)(?::(?P<second>\d\d))?)?)?)?)?Z")

def _dateFromString(s):
    order = ('year', 'month', 'day', 'hour', 'minute', 'second')
    gd = _dateParser.match(s).groupdict()
    lst = []
    for key in order:
        val = gd[key]
        if val is None:
            break
        lst.append(int(val))
    return datetime.datetime(*lst)

def _dateToString(d):
    return '%04d-%02d-%02dT%02d:%02d:%02dZ' % (
        d.year, d.month, d.day,
        d.hour, d.minute, d.second
    )


# Regex to find any control chars, except for \t \n and \r
_controlCharPat = re.compile(
    r"[\x00\x01\x02\x03\x04\x05\x06\x07\x08\x0b\x0c\x0e\x0f"
    r"\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f]")

def _escapeAndEncode(text):
    m = _controlCharPat.search(text)
    if m is not None:
        raise ValueError("strings can't contains control characters; "
                         "use plistlib.Data instead")
    text = text.replace("\r\n", "\n")       # convert DOS line endings
    text = text.replace("\r", "\n")         # convert Mac line endings
    text = text.replace("&", "&amp;")       # escape '&'
    text = text.replace("<", "&lt;")        # escape '<'
    text = text.replace(">", "&gt;")        # escape '>'
    return text.encode("utf-8")             # encode as UTF-8


PLISTHEADER = """\
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
"""

class PlistWriter(DumbXMLWriter):

    def __init__(self, file, indentLevel=0, indent="\t", writeHeader=1):
        if writeHeader:
            file.write(PLISTHEADER)
        DumbXMLWriter.__init__(self, file, indentLevel, indent)

    def writeValue(self, value):
        if isinstance(value, (str, unicode)):
            self.simpleElement("string", value)
        elif isinstance(value, bool):
            # must switch for bool before int, as bool is a
            # subclass of int...
            if value:
                self.simpleElement("true")
            else:
                self.simpleElement("false")
        elif isinstance(value, (int, long)):
            self.simpleElement("integer", "%d" % value)
        elif isinstance(value, float):
            self.simpleElement("real", repr(value))
        elif isinstance(value, dict):
            self.writeDict(value)
        elif isinstance(value, Data):
            self.writeData(value)
        elif isinstance(value, datetime.datetime):
            self.simpleElement("date", _dateToString(value))
        elif isinstance(value, (tuple, list)):
            self.writeArray(value)
        else:
            raise TypeError("unsuported type: %s" % type(value))

    def writeData(self, data):
        self.beginElement("data")
        self.indentLevel -= 1
        maxlinelength = max(16, 76 - len(self.indent.replace("\t", " " * 8) *
                                 self.indentLevel))
        for line in data.asBase64(maxlinelength).split("\n"):
            if line:
                self.writeln(line)
        self.indentLevel += 1
        self.endElement("data")

    def writeDict(self, d):
        self.beginElement("dict")
        items = d.items()
        items.sort()
        for key, value in items:
            if not isinstance(key, (str, unicode)):
                raise TypeError("keys must be strings")
            self.simpleElement("key", key)
            self.writeValue(value)
        self.endElement("dict")

    def writeArray(self, array):
        self.beginElement("array")
        for value in array:
            self.writeValue(value)
        self.endElement("array")


class _InternalDict(dict):

    # This class is needed while Dict is scheduled for deprecation:
    # we only need to warn when a *user* instantiates Dict or when
    # the "attribute notation for dict keys" is used.

    def __getattr__(self, attr):
        try:
            value = self[attr]
        except KeyError:
            raise AttributeError, attr
        from warnings import warn
        warn("Attribute access from plist dicts is deprecated, use d[key] "
             "notation instead", PendingDeprecationWarning, 2)
        return value

    def __setattr__(self, attr, value):
        from warnings import warn
        warn("Attribute access from plist dicts is deprecated, use d[key] "
             "notation instead", PendingDeprecationWarning, 2)
        self[attr] = value

    def __delattr__(self, attr):
        try:
            del self[attr]
        except KeyError:
            raise AttributeError, attr
        from warnings import warn
        warn("Attribute access from plist dicts is deprecated, use d[key] "
             "notation instead", PendingDeprecationWarning, 2)

class Dict(_InternalDict):

    def __init__(self, **kwargs):
        from warnings import warn
        warn("The plistlib.Dict class is deprecated, use builtin dict instead",
             PendingDeprecationWarning, 2)
        super(Dict, self).__init__(**kwargs)


class Plist(_InternalDict):

    """This class has been deprecated. Use readPlist() and writePlist()
    functions instead, together with regular dict objects.
    """

    def __init__(self, **kwargs):
        from warnings import warn
        warn("The Plist class is deprecated, use the readPlist() and "
             "writePlist() functions instead", PendingDeprecationWarning, 2)
        super(Plist, self).__init__(**kwargs)

    def fromFile(cls, pathOrFile):
        """Deprecated. Use the readPlist() function instead."""
        rootObject = readPlist(pathOrFile)
        plist = cls()
        plist.update(rootObject)
        return plist
    fromFile = classmethod(fromFile)

    def write(self, pathOrFile):
        """Deprecated. Use the writePlist() function instead."""
        writePlist(self, pathOrFile)


def _encodeBase64(s, maxlinelength=76):
    # copied from base64.encodestring(), with added maxlinelength argument
    maxbinsize = (maxlinelength//4)*3
    pieces = []
    for i in range(0, len(s), maxbinsize):
        chunk = s[i : i + maxbinsize]
        pieces.append(binascii.b2a_base64(chunk))
    return "".join(pieces)

class Data:

    """Wrapper for binary data."""

    def __init__(self, data):
        self.data = data

    def fromBase64(cls, data):
        # base64.decodestring just calls binascii.a2b_base64;
        # it seems overkill to use both base64 and binascii.
        return cls(binascii.a2b_base64(data))
    fromBase64 = classmethod(fromBase64)

    def asBase64(self, maxlinelength=76):
        return _encodeBase64(self.data, maxlinelength)

    def __cmp__(self, other):
        if isinstance(other, self.__class__):
            return cmp(self.data, other.data)
        elif isinstance(other, str):
            return cmp(self.data, other)
        else:
            return cmp(id(self), id(other))

    def __repr__(self):
        return "%s(%s)" % (self.__class__.__name__, repr(self.data))


class PlistParser:

    def __init__(self):
        self.stack = []
        self.currentKey = None
        self.root = None

    def parse(self, fileobj):
        from xml.parsers.expat import ParserCreate
        parser = ParserCreate()
        parser.StartElementHandler = self.handleBeginElement
        parser.EndElementHandler = self.handleEndElement
        parser.CharacterDataHandler = self.handleData
        parser.ParseFile(fileobj)
        return self.root

    def handleBeginElement(self, element, attrs):
        self.data = []
        handler = getattr(self, "begin_" + element, None)
        if handler is not None:
            handler(attrs)

    def handleEndElement(self, element):
        handler = getattr(self, "end_" + element, None)
        if handler is not None:
            handler()

    def handleData(self, data):
        self.data.append(data)

    def addObject(self, value):
        if self.currentKey is not None:
            self.stack[-1][self.currentKey] = value
            self.currentKey = None
        elif not self.stack:
            # this is the root object
            self.root = value
        else:
            self.stack[-1].append(value)

    def getData(self):
        data = "".join(self.data)
        try:
            data = data.encode("ascii")
        except UnicodeError:
            pass
        self.data = []
        return data

    # element handlers

    def begin_dict(self, attrs):
        d = _InternalDict()
        self.addObject(d)
        self.stack.append(d)
    def end_dict(self):
        self.stack.pop()

    def end_key(self):
        self.currentKey = self.getData()

    def begin_array(self, attrs):
        a = []
        self.addObject(a)
        self.stack.append(a)
    def end_array(self):
        self.stack.pop()

    def end_true(self):
        self.addObject(True)
    def end_false(self):
        self.addObject(False)
    def end_integer(self):
        self.addObject(int(self.getData()))
    def end_real(self):
        self.addObject(float(self.getData()))
    def end_string(self):
        self.addObject(self.getData())
    def end_data(self):
        self.addObject(Data.fromBase64(self.getData()))
    def end_date(self):
        self.addObject(_dateFromString(self.getData()))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ó
Ó«[c        	   @   s‰  d  Z  d d d d d d d d d	 g	 Z d
 d l Z d
 d l Z d
 d l m Z d
 d l Z d
 d l Z d „  Z d „  Z	 d „  Z
 d „  Z d d d „ Z d d d „ Z d d( d „  ƒ  YZ e j d ƒ Z d „  Z d „  Z e j d ƒ Z d „  Z d Z d e f d „  ƒ  YZ d e f d  „  ƒ  YZ d	 e f d! „  ƒ  YZ d e f d" „  ƒ  YZ d# d$ „ Z d d) d% „  ƒ  YZ d& d* d' „  ƒ  YZ d S(+   sù  plistlib.py -- a tool to generate and parse MacOSX .plist files.

The PropertyList (.plist) file format is a simple XML pickle supporting
basic object types, like dictionaries, lists, numbers and strings.
Usually the top level object is a dictionary.

To write out a plist file, use the writePlist(rootObject, pathOrFile)
function. 'rootObject' is the top level object, 'pathOrFile' is a
filename or a (writable) file object.

To parse a plist from a file, use the readPlist(pathOrFile) function,
with a file name or a (readable) file object as the only argument. It
returns the top level object (again, usually a dictionary).

To work with plist data in strings, you can use readPlistFromString()
and writePlistToString().

Values can be strings, integers, floats, booleans, tuples, lists,
dictionaries, Data or datetime.datetime objects. String values (including
dictionary keys) may be unicode strings -- they will be written out as
UTF-8.

The <data> plist type is supported through the Data class. This is a
thin wrapper around a Python string.

Generate Plist example:

    pl = dict(
        aString="Doodah",
        aList=["A", "B", 12, 32.1, [1, 2, 3]],
        aFloat=0.1,
        anInt=728,
        aDict=dict(
            anotherString="<hello & hi there!>",
            aUnicodeValue=u'M\xe4ssig, Ma\xdf',
            aTrueValue=True,
            aFalseValue=False,
        ),
        someData=Data("<binary gunk>"),
        someMoreData=Data("<lots of binary gunk>" * 10),
        aDate=datetime.datetime.fromtimestamp(time.mktime(time.gmtime())),
    )
    # unicode keys are possible, but a little awkward to use:
    pl[u'\xc5benraa'] = "That was a unicode key."
    writePlist(pl, fileName)

Parse Plist example:

    pl = readPlist(pathOrFile)
    print pl["aKey"]
t	   readPlistt
   writePlistt   readPlistFromStringt   writePlistToStringt   readPlistFromResourcet   writePlistToResourcet   Plistt   Datat   DictiÿÿÿÿN(   t   StringIOc         C   s_   d } t  |  t t f ƒ r0 t |  ƒ }  d } n  t ƒ  } | j |  ƒ } | r[ |  j ƒ  n  | S(   s¥   Read a .plist file. 'pathOrFile' may either be a file name or a
    (readable) file object. Return the unpacked root object (which
    usually is a dictionary).
    i    i   (   t
   isinstancet   strt   unicodet   opent   PlistParsert   parset   close(   t
   pathOrFilet   didOpent   pt
   rootObject(    (    s   /usr/lib/python2.7/plistlib.pyR    D   s    		c         C   s}   d } t  | t t f ƒ r3 t | d ƒ } d } n  t | ƒ } | j d ƒ | j |  ƒ | j d ƒ | ry | j ƒ  n  d S(   sq   Write 'rootObject' to a .plist file. 'pathOrFile' may either be a
    file name or a (writable) file object.
    i    t   wi   s   <plist version="1.0">s   </plist>N(   R
   R   R   R   t   PlistWritert   writelnt
   writeValueR   (   R   R   R   t   writer(    (    s   /usr/lib/python2.7/plistlib.pyR   T   s    	c         C   s   t  t |  ƒ ƒ S(   s=   Read a plist data from a string. Return the root object.
    (   R    R	   (   t   data(    (    s   /usr/lib/python2.7/plistlib.pyR   d   s    c         C   s    t  ƒ  } t |  | ƒ | j ƒ  S(   s5   Return 'rootObject' as a plist-formatted string.
    (   R	   R   t   getvalue(   R   t   f(    (    s   /usr/lib/python2.7/plistlib.pyR   j   s    	t   plsti    c   
      C   s¦   t  j d d d ƒd d l m } m } d d l m } d d l m } | |  ƒ } | j	 | | ƒ  | ƒ } | j
 | ƒ | j | | ƒ j }	 | j | ƒ t |	 ƒ S(   s7   Read plst resource from the resource fork of path.
    s)   In 3.x, readPlistFromResource is removed.t
   stackleveli   iÿÿÿÿ(   t   FSReft   FSGetResourceForkName(   t   fsRdPerm(   t   Res(   t   warningst   warnpy3kt   Carbon.FileR   R    t   Carbon.FilesR!   t   CarbonR"   t   FSOpenResourceFilet
   UseResFilet   Get1ResourceR   t   CloseResFileR   (
   t   patht   restypet   residR   R    R!   R"   t   fsReft   resNumt	   plistData(    (    s   /usr/lib/python2.7/plistlib.pyR   r   s    c         C   sô   t  j d d d ƒd d l m } m } d d l m } d d l m } t	 |  ƒ } | | ƒ }	 | j
 |	 | ƒ  | ƒ }
 | j |
 ƒ y | j | | ƒ j ƒ  Wn | j k
 r¶ n X| j | ƒ } | j | | d ƒ | j ƒ  | j |
 ƒ d	 S(
   sH   Write 'rootObject' as a plst resource to the resource fork of path.
    s(   In 3.x, writePlistToResource is removed.R   i   iÿÿÿÿ(   R   R    (   t
   fsRdWrPerm(   R"   t    N(   R#   R$   R%   R   R    R&   R2   R'   R"   R   R(   R)   R*   t   RemoveResourcet   Errort   Resourcet   AddResourcet   WriteResourceR+   (   R   R,   R-   R.   R   R    R2   R"   R1   R/   R0   t   res(    (    s   /usr/lib/python2.7/plistlib.pyR   ‚   s     
t   DumbXMLWriterc           B   s>   e  Z d  d d „ Z d „  Z d „  Z d d „ Z d „  Z RS(   i    s   	c         C   s(   | |  _  g  |  _ | |  _ | |  _ d  S(   N(   t   filet   stackt   indentLevelt   indent(   t   selfR;   R=   R>   (    (    s   /usr/lib/python2.7/plistlib.pyt   __init__™   s    			c         C   s4   |  j  j | ƒ |  j d | ƒ |  j d 7_ d  S(   Ns   <%s>i   (   R<   t   appendR   R=   (   R?   t   element(    (    s   /usr/lib/python2.7/plistlib.pyt   beginElementŸ   s    c         C   sT   |  j  d k s t ‚ |  j j ƒ  | k s0 t ‚ |  j  d 8_  |  j d | ƒ d  S(   Ni    i   s   </%s>(   R=   t   AssertionErrorR<   t   popR   (   R?   RB   (    (    s   /usr/lib/python2.7/plistlib.pyt
   endElement¤   s    c         C   sJ   | d  k	 r5 t | ƒ } |  j d | | | f ƒ n |  j d | ƒ d  S(   Ns   <%s>%s</%s>s   <%s/>(   t   Nonet   _escapeAndEncodeR   (   R?   RB   t   value(    (    s   /usr/lib/python2.7/plistlib.pyt   simpleElementª   s    c         C   s?   | r+ |  j  j |  j |  j | d ƒ n |  j  j d ƒ d  S(   Ns   
(   R;   t   writeR=   R>   (   R?   t   line(    (    s   /usr/lib/python2.7/plistlib.pyR   ±   s    %N(   t   __name__t
   __module__R@   RC   RF   RG   RJ   R   (    (    (    s   /usr/lib/python2.7/plistlib.pyR:   —   s
   		s{   (?P<year>\d\d\d\d)(?:-(?P<month>\d\d)(?:-(?P<day>\d\d)(?:T(?P<hour>\d\d)(?::(?P<minute>\d\d)(?::(?P<second>\d\d))?)?)?)?)?Zc         C   sl   d } t  j |  ƒ j ƒ  } g  } x; | D]3 } | | } | d  k rH Pn  | j t | ƒ ƒ q( Wt j | Œ  S(   Nt   yeart   montht   dayt   hourt   minutet   second(   RO   RP   RQ   RR   RS   RT   (   t   _dateParsert   matcht	   groupdictRG   RA   t   intt   datetime(   t   st   ordert   gdt   lstt   keyt   val(    (    s   /usr/lib/python2.7/plistlib.pyt   _dateFromString½   s    
c         C   s,   d |  j  |  j |  j |  j |  j |  j f S(   Ns   %04d-%02d-%02dT%02d:%02d:%02dZ(   RO   RP   RQ   RR   RS   RT   (   t   d(    (    s   /usr/lib/python2.7/plistlib.pyt   _dateToStringÈ   s    sv   [\x00\x01\x02\x03\x04\x05\x06\x07\x08\x0b\x0c\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f]c         C   s‘   t  j |  ƒ } | d  k	 r* t d ƒ ‚ n  |  j d d ƒ }  |  j d d ƒ }  |  j d d ƒ }  |  j d d ƒ }  |  j d	 d
 ƒ }  |  j d ƒ S(   NsD   strings can't contains control characters; use plistlib.Data insteads   
s   
s   t   &s   &amp;t   <s   &lt;t   >s   &gt;s   utf-8(   t   _controlCharPatt   searchRG   t
   ValueErrort   replacet   encode(   t   textt   m(    (    s   /usr/lib/python2.7/plistlib.pyRH   Ô   s    sŽ   <?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
R   c           B   s>   e  Z d  d d d „ Z d „  Z d „  Z d „  Z d „  Z RS(   i    s   	i   c         C   s0   | r | j  t ƒ n  t j |  | | | ƒ d  S(   N(   RK   t   PLISTHEADERR:   R@   (   R?   R;   R=   R>   t   writeHeader(    (    s   /usr/lib/python2.7/plistlib.pyR@   è   s    c         C   sY  t  | t t f ƒ r( |  j d | ƒ n-t  | t ƒ r] | rM |  j d ƒ qU|  j d ƒ nø t  | t t f ƒ r‰ |  j d d | ƒ nÌ t  | t ƒ r± |  j d t | ƒ ƒ n¤ t  | t	 ƒ rÐ |  j
 | ƒ n… t  | t ƒ rï |  j | ƒ nf t  | t j ƒ r|  j d t | ƒ ƒ n; t  | t t f ƒ r?|  j | ƒ n t d t | ƒ ƒ ‚ d  S(	   Nt   stringt   truet   falset   integers   %dt   realt   dates   unsuported type: %s(   R
   R   R   RJ   t   boolRX   t   longt   floatt   reprt   dictt	   writeDictR   t	   writeDataRY   Rb   t   tuplet   listt
   writeArrayt	   TypeErrort   type(   R?   RI   (    (    s   /usr/lib/python2.7/plistlib.pyR   í   s&    c         C   s¤   |  j  d ƒ |  j d 8_ t d d t |  j j d d	 ƒ |  j ƒ ƒ } x6 | j | ƒ j d ƒ D] } | rd |  j | ƒ qd qd W|  j d 7_ |  j	 d ƒ d  S(
   NR   i   i   iL   s   	t    i   s   
s           (
   RC   R=   t   maxt   lenR>   Ri   t   asBase64t   splitR   RF   (   R?   R   t   maxlinelengthRL   (    (    s   /usr/lib/python2.7/plistlib.pyR{     s    c         C   sŒ   |  j  d ƒ | j ƒ  } | j ƒ  xU | D]M \ } } t | t t f ƒ sZ t d ƒ ‚ n  |  j d | ƒ |  j | ƒ q* W|  j	 d ƒ d  S(   NRy   s   keys must be stringsR^   (
   RC   t   itemst   sortR
   R   R   R   RJ   R   RF   (   R?   Ra   R‡   R^   RI   (    (    s   /usr/lib/python2.7/plistlib.pyRz     s    
c         C   s<   |  j  d ƒ x | D] } |  j | ƒ q W|  j d ƒ d  S(   Nt   array(   RC   R   RF   (   R?   R‰   RI   (    (    s   /usr/lib/python2.7/plistlib.pyR~     s    (   RM   RN   R@   R   R{   Rz   R~   (    (    (    s   /usr/lib/python2.7/plistlib.pyR   æ   s
   			t   _InternalDictc           B   s#   e  Z d  „  Z d „  Z d „  Z RS(   c         C   sO   y |  | } Wn t  k
 r* t | ‚ n Xd d l m } | d t d ƒ | S(   Niÿÿÿÿ(   t   warnsL   Attribute access from plist dicts is deprecated, use d[key] notation insteadi   (   t   KeyErrort   AttributeErrorR#   R‹   t   PendingDeprecationWarning(   R?   t   attrRI   R‹   (    (    s   /usr/lib/python2.7/plistlib.pyt   __getattr__)  s    
c         C   s.   d d l  m } | d t d ƒ | |  | <d  S(   Niÿÿÿÿ(   R‹   sL   Attribute access from plist dicts is deprecated, use d[key] notation insteadi   (   R#   R‹   RŽ   (   R?   R   RI   R‹   (    (    s   /usr/lib/python2.7/plistlib.pyt   __setattr__3  s    
c         C   sL   y |  | =Wn t  k
 r' t | ‚ n Xd d l m } | d t d ƒ d  S(   Niÿÿÿÿ(   R‹   sL   Attribute access from plist dicts is deprecated, use d[key] notation insteadi   (   RŒ   R   R#   R‹   RŽ   (   R?   R   R‹   (    (    s   /usr/lib/python2.7/plistlib.pyt   __delattr__9  s    (   RM   RN   R   R‘   R’   (    (    (    s   /usr/lib/python2.7/plistlib.pyRŠ   #  s   	
	c           B   s   e  Z d  „  Z RS(   c         K   s:   d d l  m } | d t d ƒ t t |  ƒ j |   d  S(   Niÿÿÿÿ(   R‹   s?   The plistlib.Dict class is deprecated, use builtin dict insteadi   (   R#   R‹   RŽ   t   superR   R@   (   R?   t   kwargsR‹   (    (    s   /usr/lib/python2.7/plistlib.pyR@   D  s    
(   RM   RN   R@   (    (    (    s   /usr/lib/python2.7/plistlib.pyR   B  s   c           B   s5   e  Z d  Z d „  Z d „  Z e e ƒ Z d „  Z RS(   s€   This class has been deprecated. Use readPlist() and writePlist()
    functions instead, together with regular dict objects.
    c         K   s:   d d l  m } | d t d ƒ t t |  ƒ j |   d  S(   Niÿÿÿÿ(   R‹   sU   The Plist class is deprecated, use the readPlist() and writePlist() functions insteadi   (   R#   R‹   RŽ   R“   R   R@   (   R?   R”   R‹   (    (    s   /usr/lib/python2.7/plistlib.pyR@   Q  s    
c         C   s&   t  | ƒ } |  ƒ  } | j | ƒ | S(   s1   Deprecated. Use the readPlist() function instead.(   R    t   update(   t   clsR   R   t   plist(    (    s   /usr/lib/python2.7/plistlib.pyt   fromFileW  s    	c         C   s   t  |  | ƒ d S(   s2   Deprecated. Use the writePlist() function instead.N(   R   (   R?   R   (    (    s   /usr/lib/python2.7/plistlib.pyRK   _  s    (   RM   RN   t   __doc__R@   R˜   t   classmethodRK   (    (    (    s   /usr/lib/python2.7/plistlib.pyR   K  s
   		iL   c         C   sk   | d d } g  } xG t  d t |  ƒ | ƒ D]- } |  | | | !} | j t j | ƒ ƒ q- Wd j | ƒ S(   Ni   i   i    R3   (   t   rangeRƒ   RA   t   binasciit
   b2a_base64t   join(   RZ   R†   t
   maxbinsizet   piecest   it   chunk(    (    s   /usr/lib/python2.7/plistlib.pyt   _encodeBase64d  s    c           B   sJ   e  Z d  Z d „  Z d „  Z e e ƒ Z d d „ Z d „  Z d „  Z RS(   s   Wrapper for binary data.c         C   s   | |  _  d  S(   N(   R   (   R?   R   (    (    s   /usr/lib/python2.7/plistlib.pyR@   q  s    c         C   s   |  t  j | ƒ ƒ S(   N(   Rœ   t
   a2b_base64(   R–   R   (    (    s   /usr/lib/python2.7/plistlib.pyt
   fromBase64t  s    iL   c         C   s   t  |  j | ƒ S(   N(   R£   R   (   R?   R†   (    (    s   /usr/lib/python2.7/plistlib.pyR„   z  s    c         C   sa   t  | |  j ƒ r% t |  j | j ƒ St  | t ƒ rD t |  j | ƒ St t |  ƒ t | ƒ ƒ Sd  S(   N(   R
   t	   __class__t   cmpR   R   t   id(   R?   t   other(    (    s   /usr/lib/python2.7/plistlib.pyt   __cmp__}  s
    c         C   s   d |  j  j t |  j ƒ f S(   Ns   %s(%s)(   R¦   RM   Rx   R   (   R?   (    (    s   /usr/lib/python2.7/plistlib.pyt   __repr__…  s    (	   RM   RN   R™   R@   R¥   Rš   R„   Rª   R«   (    (    (    s   /usr/lib/python2.7/plistlib.pyR   m  s   			R   c           B   s³   e  Z d  „  Z d „  Z d „  Z d „  Z d „  Z d „  Z d „  Z d „  Z	 d „  Z
 d	 „  Z d
 „  Z d „  Z d „  Z d „  Z d „  Z d „  Z d „  Z d „  Z d „  Z RS(   c         C   s   g  |  _  d  |  _ d  |  _ d  S(   N(   R<   RG   t
   currentKeyt   root(   R?   (    (    s   /usr/lib/python2.7/plistlib.pyR@   ‹  s    		c         C   sQ   d d l  m } | ƒ  } |  j | _ |  j | _ |  j | _ | j | ƒ |  j	 S(   Niÿÿÿÿ(   t   ParserCreate(
   t   xml.parsers.expatR®   t   handleBeginElementt   StartElementHandlert   handleEndElementt   EndElementHandlert
   handleDatat   CharacterDataHandlert	   ParseFileR­   (   R?   t   fileobjR®   t   parser(    (    s   /usr/lib/python2.7/plistlib.pyR     s    	c         C   s<   g  |  _  t |  d | d  ƒ } | d  k	 r8 | | ƒ n  d  S(   Nt   begin_(   R   t   getattrRG   (   R?   RB   t   attrst   handler(    (    s   /usr/lib/python2.7/plistlib.pyR°   ™  s    	c         C   s0   t  |  d | d  ƒ } | d  k	 r, | ƒ  n  d  S(   Nt   end_(   Rº   RG   (   R?   RB   R¼   (    (    s   /usr/lib/python2.7/plistlib.pyR²   Ÿ  s    c         C   s   |  j  j | ƒ d  S(   N(   R   RA   (   R?   R   (    (    s   /usr/lib/python2.7/plistlib.pyR´   ¤  s    c         C   s\   |  j  d  k	 r/ | |  j d |  j  <d  |  _  n) |  j sD | |  _ n |  j d j | ƒ d  S(   Niÿÿÿÿ(   R¬   RG   R<   R­   RA   (   R?   RI   (    (    s   /usr/lib/python2.7/plistlib.pyt	   addObject§  s    	c         C   sF   d j  |  j ƒ } y | j d ƒ } Wn t k
 r8 n Xg  |  _ | S(   NR3   t   ascii(   Rž   R   Rj   t   UnicodeError(   R?   R   (    (    s   /usr/lib/python2.7/plistlib.pyt   getData±  s    	c         C   s*   t  ƒ  } |  j | ƒ |  j j | ƒ d  S(   N(   RŠ   R¾   R<   RA   (   R?   R»   Ra   (    (    s   /usr/lib/python2.7/plistlib.pyt
   begin_dict¼  s    	c         C   s   |  j  j ƒ  d  S(   N(   R<   RE   (   R?   (    (    s   /usr/lib/python2.7/plistlib.pyt   end_dictÀ  s    c         C   s   |  j  ƒ  |  _ d  S(   N(   RÁ   R¬   (   R?   (    (    s   /usr/lib/python2.7/plistlib.pyt   end_keyÃ  s    c         C   s'   g  } |  j  | ƒ |  j j | ƒ d  S(   N(   R¾   R<   RA   (   R?   R»   t   a(    (    s   /usr/lib/python2.7/plistlib.pyt   begin_arrayÆ  s    c         C   s   |  j  j ƒ  d  S(   N(   R<   RE   (   R?   (    (    s   /usr/lib/python2.7/plistlib.pyt	   end_arrayÊ  s    c         C   s   |  j  t ƒ d  S(   N(   R¾   t   True(   R?   (    (    s   /usr/lib/python2.7/plistlib.pyt   end_trueÍ  s    c         C   s   |  j  t ƒ d  S(   N(   R¾   t   False(   R?   (    (    s   /usr/lib/python2.7/plistlib.pyt	   end_falseÏ  s    c         C   s   |  j  t |  j ƒ  ƒ ƒ d  S(   N(   R¾   RX   RÁ   (   R?   (    (    s   /usr/lib/python2.7/plistlib.pyt   end_integerÑ  s    c         C   s   |  j  t |  j ƒ  ƒ ƒ d  S(   N(   R¾   Rw   RÁ   (   R?   (    (    s   /usr/lib/python2.7/plistlib.pyt   end_realÓ  s    c         C   s   |  j  |  j ƒ  ƒ d  S(   N(   R¾   RÁ   (   R?   (    (    s   /usr/lib/python2.7/plistlib.pyt
   end_stringÕ  s    c         C   s    |  j  t j |  j ƒ  ƒ ƒ d  S(   N(   R¾   R   R¥   RÁ   (   R?   (    (    s   /usr/lib/python2.7/plistlib.pyt   end_data×  s    c         C   s   |  j  t |  j ƒ  ƒ ƒ d  S(   N(   R¾   R`   RÁ   (   R?   (    (    s   /usr/lib/python2.7/plistlib.pyt   end_dateÙ  s    (   RM   RN   R@   R   R°   R²   R´   R¾   RÁ   RÂ   RÃ   RÄ   RÆ   RÇ   RÉ   RË   RÌ   RÍ   RÎ   RÏ   RÐ   (    (    (    s   /usr/lib/python2.7/plistlib.pyR   ‰  s&   							
												(    (    (    (   R™   t   __all__Rœ   RY   t	   cStringIOR	   t   reR#   R    R   R   R   R   R   R:   t   compileRU   R`   Rb   Rf   RH   Rm   R   Ry   RŠ   R   R   R£   R   R   (    (    (    s   /usr/lib/python2.7/plistlib.pyt   <module>3   s:   				$				=		                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             """Spawn a command with pipes to its stdin, stdout, and optionally stderr.

The normal os.popen(cmd, mode) call spawns a shell command and provides a
file interface to just the input or output of the process depending on
whether mode is 'r' or 'w'.  This module provides the functions popen2(cmd)
and popen3(cmd) which return two or three pipes to the spawned command.
"""

import os
import sys
import warnings
warnings.warn("The popen2 module is deprecated.  Use the subprocess module.",
              DeprecationWarning, stacklevel=2)

__all__ = ["popen2", "popen3", "popen4"]

try:
    MAXFD = os.sysconf('SC_OPEN_MAX')
except (AttributeError, ValueError):
    MAXFD = 256

_active = []

def _cleanup():
    for inst in _active[:]:
        if inst.poll(_deadstate=sys.maxint) >= 0:
            try:
                _active.remove(inst)
            except ValueError:
                # This can happen if two threads create a new Popen instance.
                # It's harmless that it was already removed, so ignore.
                pass

class Popen3:
    """Class representing a child process.  Normally, instances are created
    internally by the functions popen2() and popen3()."""

    sts = -1                    # Child not completed yet

    def __init__(self, cmd, capturestderr=False, bufsize=-1):
        """The parameter 'cmd' is the shell command to execute in a
        sub-process.  On UNIX, 'cmd' may be a sequence, in which case arguments
        will be passed directly to the program without shell intervention (as
        with os.spawnv()).  If 'cmd' is a string it will be passed to the shell
        (as with os.system()).   The 'capturestderr' flag, if true, specifies
        that the object should capture standard error output of the child
        process.  The default is false.  If the 'bufsize' parameter is
        specified, it specifies the size of the I/O buffers to/from the child
        process."""
        _cleanup()
        self.cmd = cmd
        p2cread, p2cwrite = os.pipe()
        c2pread, c2pwrite = os.pipe()
        if capturestderr:
            errout, errin = os.pipe()
        self.pid = os.fork()
        if self.pid == 0:
            # Child
            os.dup2(p2cread, 0)
            os.dup2(c2pwrite, 1)
            if capturestderr:
                os.dup2(errin, 2)
            self._run_child(cmd)
        os.close(p2cread)
        self.tochild = os.fdopen(p2cwrite, 'w', bufsize)
        os.close(c2pwrite)
        self.fromchild = os.fdopen(c2pread, 'r', bufsize)
        if capturestderr:
            os.close(errin)
            self.childerr = os.fdopen(errout, 'r', bufsize)
        else:
            self.childerr = None

    def __del__(self):
        # In case the child hasn't been waited on, check if it's done.
        self.poll(_deadstate=sys.maxint)
        if self.sts < 0:
            if _active is not None:
                # Child is still running, keep us alive until we can wait on it.
                _active.append(self)

    def _run_child(self, cmd):
        if isinstance(cmd, basestring):
            cmd = ['/bin/sh', '-c', cmd]
        os.closerange(3, MAXFD)
        try:
            os.execvp(cmd[0], cmd)
        finally:
            os._exit(1)

    def poll(self, _deadstate=None):
        """Return the exit status of the child process if it has finished,
        or -1 if it hasn't finished yet."""
        if self.sts < 0:
            try:
                pid, sts = os.waitpid(self.pid, os.WNOHANG)
                # pid will be 0 if self.pid hasn't terminated
                if pid == self.pid:
                    self.sts = sts
            except os.error:
                if _deadstate is not None:
                    self.sts = _deadstate
        return self.sts

    def wait(self):
        """Wait for and return the exit status of the child process."""
        if self.sts < 0:
            pid, sts = os.waitpid(self.pid, 0)
            # This used to be a test, but it is believed to be
            # always true, so I changed it to an assertion - mvl
            assert pid == self.pid
            self.sts = sts
        return self.sts


class Popen4(Popen3):
    childerr = None

    def __init__(self, cmd, bufsize=-1):
        _cleanup()
        self.cmd = cmd
        p2cread, p2cwrite = os.pipe()
        c2pread, c2pwrite = os.pipe()
        self.pid = os.fork()
        if self.pid == 0:
            # Child
            os.dup2(p2cread, 0)
            os.dup2(c2pwrite, 1)
            os.dup2(c2pwrite, 2)
            self._run_child(cmd)
        os.close(p2cread)
        self.tochild = os.fdopen(p2cwrite, 'w', bufsize)
        os.close(c2pwrite)
        self.fromchild = os.fdopen(c2pread, 'r', bufsize)


if sys.platform[:3] == "win" or sys.platform == "os2emx":
    # Some things don't make sense on non-Unix platforms.
    del Popen3, Popen4

    def popen2(cmd, bufsize=-1, mode='t'):
        """Execute the shell command 'cmd' in a sub-process. On UNIX, 'cmd' may
        be a sequence, in which case arguments will be passed directly to the
        program without shell intervention (as with os.spawnv()). If 'cmd' is a
        string it will be passed to the shell (as with os.system()). If
        'bufsize' is specified, it sets the buffer size for the I/O pipes. The
        file objects (child_stdout, child_stdin) are returned."""
        w, r = os.popen2(cmd, mode, bufsize)
        return r, w

    def popen3(cmd, bufsize=-1, mode='t'):
        """Execute the shell command 'cmd' in a sub-process. On UNIX, 'cmd' may
        be a sequence, in which case arguments will be passed directly to the
        program without shell intervention (as with os.spawnv()). If 'cmd' is a
        string it will be passed to the shell (as with os.system()). If
        'bufsize' is specified, it sets the buffer size for the I/O pipes. The
        file objects (child_stdout, child_stdin, child_stderr) are returned."""
        w, r, e = os.popen3(cmd, mode, bufsize)
        return r, w, e

    def popen4(cmd, bufsize=-1, mode='t'):
        """Execute the shell command 'cmd' in a sub-process. On UNIX, 'cmd' may
        be a sequence, in which case arguments will be passed directly to the
        program without shell intervention (as with os.spawnv()). If 'cmd' is a
        string it will be passed to the shell (as with os.system()). If
        'bufsize' is specified, it sets the buffer size for the I/O pipes. The
        file objects (child_stdout_stderr, child_stdin) are returned."""
        w, r = os.popen4(cmd, mode, bufsize)
        return r, w
else:
    def popen2(cmd, bufsize=-1, mode='t'):
        """Execute the shell command 'cmd' in a sub-process. On UNIX, 'cmd' may
        be a sequence, in which case arguments will be passed directly to the
        program without shell intervention (as with os.spawnv()). If 'cmd' is a
        string it will be passed to the shell (as with os.system()). If
        'bufsize' is specified, it sets the buffer size for the I/O pipes. The
        file objects (child_stdout, child_stdin) are returned."""
        inst = Popen3(cmd, False, bufsize)
        return inst.fromchild, inst.tochild

    def popen3(cmd, bufsize=-1, mode='t'):
        """Execute the shell command 'cmd' in a sub-process. On UNIX, 'cmd' may
        be a sequence, in which case arguments will be passed directly to the
        program without shell intervention (as with os.spawnv()). If 'cmd' is a
        string it will be passed to the shell (as with os.system()). If
        'bufsize' is specified, it sets the buffer size for the I/O pipes. The
        file objects (child_stdout, child_stdin, child_stderr) are returned."""
        inst = Popen3(cmd, True, bufsize)
        return inst.fromchild, inst.tochild, inst.childerr

    def popen4(cmd, bufsize=-1, mode='t'):
        """Execute the shell command 'cmd' in a sub-process. On UNIX, 'cmd' may
        be a sequence, in which case arguments will be passed directly to the
        program without shell intervention (as with os.spawnv()). If 'cmd' is a
        string it will be passed to the shell (as with os.system()). If
        'bufsize' is specified, it sets the buffer size for the I/O pipes. The
        file objects (child_stdout_stderr, child_stdin) are returned."""
        inst = Popen4(cmd, bufsize)
        return inst.fromchild, inst.tochild

    __all__.extend(["Popen3", "Popen4"])
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ó
Ó«[c           @   sV  d  Z  d d l Z d d l Z d d l Z e j d e d d ƒd d d g Z y e j d	 ƒ Z Wn e	 e
 f k
 r d
 Z n Xg  Z d „  Z d d d „  ƒ  YZ d e f d „  ƒ  YZ e j d  d k sÜ e j d k r[ [ d d d „ Z d d d „ Z d d d „ Z n@ d d d „ Z d d d „ Z d d d „ Z e j d d g ƒ d S(   sn  Spawn a command with pipes to its stdin, stdout, and optionally stderr.

The normal os.popen(cmd, mode) call spawns a shell command and provides a
file interface to just the input or output of the process depending on
whether mode is 'r' or 'w'.  This module provides the functions popen2(cmd)
and popen3(cmd) which return two or three pipes to the spawned command.
iÿÿÿÿNs<   The popen2 module is deprecated.  Use the subprocess module.t
   stackleveli   t   popen2t   popen3t   popen4t   SC_OPEN_MAXi   c          C   sY   xR t  D]I }  |  j d t j ƒ d k r y t  j |  ƒ WqQ t k
 rM qQ Xq q Wd  S(   Nt
   _deadstatei    (   t   _activet   pollt   syst   maxintt   removet
   ValueError(   t   inst(    (    s   /usr/lib/python2.7/popen2.pyt   _cleanup   s    t   Popen3c           B   sJ   e  Z d  Z d Z e d d „ Z d „  Z d „  Z d d „ Z	 d „  Z
 RS(   s{   Class representing a child process.  Normally, instances are created
    internally by the functions popen2() and popen3().iÿÿÿÿc   
      C   s;  t  ƒ  | |  _ t j ƒ  \ } } t j ƒ  \ } } | rO t j ƒ  \ } }	 n  t j ƒ  |  _ |  j d k r¶ t j | d ƒ t j | d ƒ | r¦ t j |	 d ƒ n  |  j | ƒ n  t j | ƒ t j	 | d | ƒ |  _
 t j | ƒ t j	 | d | ƒ |  _ | r.t j |	 ƒ t j	 | d | ƒ |  _ n	 d |  _ d S(   sd  The parameter 'cmd' is the shell command to execute in a
        sub-process.  On UNIX, 'cmd' may be a sequence, in which case arguments
        will be passed directly to the program without shell intervention (as
        with os.spawnv()).  If 'cmd' is a string it will be passed to the shell
        (as with os.system()).   The 'capturestderr' flag, if true, specifies
        that the object should capture standard error output of the child
        process.  The default is false.  If the 'bufsize' parameter is
        specified, it specifies the size of the I/O buffers to/from the child
        process.i    i   i   t   wt   rN(   R   t   cmdt   ost   pipet   forkt   pidt   dup2t
   _run_childt   closet   fdopent   tochildt	   fromchildt   childerrt   None(
   t   selfR   t   capturestderrt   bufsizet   p2creadt   p2cwritet   c2preadt   c2pwritet   erroutt   errin(    (    s   /usr/lib/python2.7/popen2.pyt   __init__(   s*    
	c         C   sE   |  j  d t j ƒ |  j d k  rA t d  k	 rA t j |  ƒ qA n  d  S(   NR   i    (   R   R   R	   t   stsR   R   t   append(   R   (    (    s   /usr/lib/python2.7/popen2.pyt   __del__J   s    c         C   s^   t  | t ƒ r! d d | g } n  t j d t ƒ z t j | d | ƒ Wd  t j d ƒ Xd  S(   Ns   /bin/shs   -ci   i    i   (   t
   isinstancet
   basestringR   t
   closeranget   MAXFDt   execvpt   _exit(   R   R   (    (    s   /usr/lib/python2.7/popen2.pyR   R   s    c         C   s…   |  j  d k  r~ y= t j |  j t j ƒ \ } } | |  j k rK | |  _  n  Wq~ t j k
 rz | d k	 r{ | |  _  q{ q~ Xn  |  j  S(   sh   Return the exit status of the child process if it has finished,
        or -1 if it hasn't finished yet.i    N(   R(   R   t   waitpidR   t   WNOHANGt   errorR   (   R   R   R   R(   (    (    s   /usr/lib/python2.7/popen2.pyR   [   s    c         C   sR   |  j  d k  rK t j |  j d ƒ \ } } | |  j k s? t ‚ | |  _  n  |  j  S(   s9   Wait for and return the exit status of the child process.i    (   R(   R   R1   R   t   AssertionError(   R   R   R(   (    (    s   /usr/lib/python2.7/popen2.pyt   waiti   s
    N(   t   __name__t
   __module__t   __doc__R(   t   FalseR'   R*   R   R   R   R5   (    (    (    s   /usr/lib/python2.7/popen2.pyR   "   s   "			t   Popen4c           B   s   e  Z d Z d  d „ Z RS(   iÿÿÿÿc         C   sà   t  ƒ  | |  _ t j ƒ  \ } } t j ƒ  \ } } t j ƒ  |  _ |  j d k r’ t j | d ƒ t j | d ƒ t j | d ƒ |  j | ƒ n  t j | ƒ t j	 | d | ƒ |  _
 t j | ƒ t j	 | d | ƒ |  _ d  S(   Ni    i   i   R   R   (   R   R   R   R   R   R   R   R   R   R   R   R   (   R   R   R    R!   R"   R#   R$   (    (    s   /usr/lib/python2.7/popen2.pyR'   w   s    	N(   R6   R7   R   R   R'   (    (    (    s   /usr/lib/python2.7/popen2.pyR:   t   s   i   t   wint   os2emxt   tc         C   s%   t  j |  | | ƒ \ } } | | f S(   s¸  Execute the shell command 'cmd' in a sub-process. On UNIX, 'cmd' may
        be a sequence, in which case arguments will be passed directly to the
        program without shell intervention (as with os.spawnv()). If 'cmd' is a
        string it will be passed to the shell (as with os.system()). If
        'bufsize' is specified, it sets the buffer size for the I/O pipes. The
        file objects (child_stdout, child_stdin) are returned.(   R   R   (   R   R    t   modeR   R   (    (    s   /usr/lib/python2.7/popen2.pyR      s    c         C   s+   t  j |  | | ƒ \ } } } | | | f S(   sÆ  Execute the shell command 'cmd' in a sub-process. On UNIX, 'cmd' may
        be a sequence, in which case arguments will be passed directly to the
        program without shell intervention (as with os.spawnv()). If 'cmd' is a
        string it will be passed to the shell (as with os.system()). If
        'bufsize' is specified, it sets the buffer size for the I/O pipes. The
        file objects (child_stdout, child_stdin, child_stderr) are returned.(   R   R   (   R   R    R>   R   R   t   e(    (    s   /usr/lib/python2.7/popen2.pyR   —   s    c         C   s%   t  j |  | | ƒ \ } } | | f S(   s¿  Execute the shell command 'cmd' in a sub-process. On UNIX, 'cmd' may
        be a sequence, in which case arguments will be passed directly to the
        program without shell intervention (as with os.spawnv()). If 'cmd' is a
        string it will be passed to the shell (as with os.system()). If
        'bufsize' is specified, it sets the buffer size for the I/O pipes. The
        file objects (child_stdout_stderr, child_stdin) are returned.(   R   R   (   R   R    R>   R   R   (    (    s   /usr/lib/python2.7/popen2.pyR   ¡   s    c         C   s"   t  |  t | ƒ } | j | j f S(   s¸  Execute the shell command 'cmd' in a sub-process. On UNIX, 'cmd' may
        be a sequence, in which case arguments will be passed directly to the
        program without shell intervention (as with os.spawnv()). If 'cmd' is a
        string it will be passed to the shell (as with os.system()). If
        'bufsize' is specified, it sets the buffer size for the I/O pipes. The
        file objects (child_stdout, child_stdin) are returned.(   R   R9   R   R   (   R   R    R>   R   (    (    s   /usr/lib/python2.7/popen2.pyR   «   s    c         C   s(   t  |  t | ƒ } | j | j | j f S(   sÆ  Execute the shell command 'cmd' in a sub-process. On UNIX, 'cmd' may
        be a sequence, in which case arguments will be passed directly to the
        program without shell intervention (as with os.spawnv()). If 'cmd' is a
        string it will be passed to the shell (as with os.system()). If
        'bufsize' is specified, it sets the buffer size for the I/O pipes. The
        file objects (child_stdout, child_stdin, child_stderr) are returned.(   R   t   TrueR   R   R   (   R   R    R>   R   (    (    s   /usr/lib/python2.7/popen2.pyR   µ   s    c         C   s   t  |  | ƒ } | j | j f S(   s¿  Execute the shell command 'cmd' in a sub-process. On UNIX, 'cmd' may
        be a sequence, in which case arguments will be passed directly to the
        program without shell intervention (as with os.spawnv()). If 'cmd' is a
        string it will be passed to the shell (as with os.system()). If
        'bufsize' is specified, it sets the buffer size for the I/O pipes. The
        file objects (child_stdout_stderr, child_stdin) are returned.(   R:   R   R   (   R   R    R>   R   (    (    s   /usr/lib/python2.7/popen2.pyR   ¿   s    (    (   R8   R   R   t   warningst   warnt   DeprecationWarningt   __all__t   sysconfR.   t   AttributeErrorR   R   R   R   R:   t   platformR   R   R   t   extend(    (    (    s   /usr/lib/python2.7/popen2.pyt   <module>   s.   	
	
R"





                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ó
Ó«[c           @   sS   d  Z  d d l Z e j d e d ƒ d d l Td d l m Z d d l m Z d S(   s   This file is only retained for backwards compatibility.
It will be removed in the future.  sre was moved to re in version 2.5.
iÿÿÿÿNs/   The sre module is deprecated, please import re.i   (   t   *(   t   __all__(   t   _compile(   t   __doc__t   warningst   warnt   DeprecationWarningt   reR   R   (    (    (    s   /usr/lib/python2.7/sre.pyt   <module>   s   	

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           """A POP3 client class.

Based on the J. Myers POP3 draft, Jan. 96
"""

# Author: David Ascher <david_ascher@brown.edu>
#         [heavily stealing from nntplib.py]
# Updated: Piers Lauder <piers@cs.su.oz.au> [Jul '97]
# String method conversion and test jig improvements by ESR, February 2001.
# Added the POP3_SSL class. Methods loosely based on IMAP_SSL. Hector Urtubia <urtubia@mrbook.org> Aug 2003

# Example (see the test function at the end of this file)

# Imports

import re, socket

__all__ = ["POP3","error_proto"]

# Exception raised when an error or invalid response is received:

class error_proto(Exception): pass

# Standard Port
POP3_PORT = 110

# POP SSL PORT
POP3_SSL_PORT = 995

# Line terminators (we always output CRLF, but accept any of CRLF, LFCR, LF)
CR = '\r'
LF = '\n'
CRLF = CR+LF

# maximal line length when calling readline(). This is to prevent
# reading arbitrary length lines. RFC 1939 limits POP3 line length to
# 512 characters, including CRLF. We have selected 2048 just to be on
# the safe side.
_MAXLINE = 2048


class POP3:

    """This class supports both the minimal and optional command sets.
    Arguments can be strings or integers (where appropriate)
    (e.g.: retr(1) and retr('1') both work equally well.

    Minimal Command Set:
            USER name               user(name)
            PASS string             pass_(string)
            STAT                    stat()
            LIST [msg]              list(msg = None)
            RETR msg                retr(msg)
            DELE msg                dele(msg)
            NOOP                    noop()
            RSET                    rset()
            QUIT                    quit()

    Optional Commands (some servers support these):
            RPOP name               rpop(name)
            APOP name digest        apop(name, digest)
            TOP msg n               top(msg, n)
            UIDL [msg]              uidl(msg = None)

    Raises one exception: 'error_proto'.

    Instantiate with:
            POP3(hostname, port=110)

    NB:     the POP protocol locks the mailbox from user
            authorization until QUIT, so be sure to get in, suck
            the messages, and quit, each time you access the
            mailbox.

            POP is a line-based protocol, which means large mail
            messages consume lots of python cycles reading them
            line-by-line.

            If it's available on your mail server, use IMAP4
            instead, it doesn't suffer from the two problems
            above.
    """


    def __init__(self, host, port=POP3_PORT,
                 timeout=socket._GLOBAL_DEFAULT_TIMEOUT):
        self.host = host
        self.port = port
        self.sock = socket.create_connection((host, port), timeout)
        self.file = self.sock.makefile('rb')
        self._debugging = 0
        self.welcome = self._getresp()


    def _putline(self, line):
        if self._debugging > 1: print '*put*', repr(line)
        self.sock.sendall('%s%s' % (line, CRLF))


    # Internal: send one command to the server (through _putline())

    def _putcmd(self, line):
        if self._debugging: print '*cmd*', repr(line)
        self._putline(line)


    # Internal: return one line from the server, stripping CRLF.
    # This is where all the CPU time of this module is consumed.
    # Raise error_proto('-ERR EOF') if the connection is closed.

    def _getline(self):
        line = self.file.readline(_MAXLINE + 1)
        if len(line) > _MAXLINE:
            raise error_proto('line too long')
        if self._debugging > 1: print '*get*', repr(line)
        if not line: raise error_proto('-ERR EOF')
        octets = len(line)
        # server can send any combination of CR & LF
        # however, 'readline()' returns lines ending in LF
        # so only possibilities are ...LF, ...CRLF, CR...LF
        if line[-2:] == CRLF:
            return line[:-2], octets
        if line[0] == CR:
            return line[1:-1], octets
        return line[:-1], octets


    # Internal: get a response from the server.
    # Raise 'error_proto' if the response doesn't start with '+'.

    def _getresp(self):
        resp, o = self._getline()
        if self._debugging > 1: print '*resp*', repr(resp)
        c = resp[:1]
        if c != '+':
            raise error_proto(resp)
        return resp


    # Internal: get a response plus following text from the server.

    def _getlongresp(self):
        resp = self._getresp()
        list = []; octets = 0
        line, o = self._getline()
        while line != '.':
            if line[:2] == '..':
                o = o-1
                line = line[1:]
            octets = octets + o
            list.append(line)
            line, o = self._getline()
        return resp, list, octets


    # Internal: send a command and get the response

    def _shortcmd(self, line):
        self._putcmd(line)
        return self._getresp()


    # Internal: send a command and get the response plus following text

    def _longcmd(self, line):
        self._putcmd(line)
        return self._getlongresp()


    # These can be useful:

    def getwelcome(self):
        return self.welcome


    def set_debuglevel(self, level):
        self._debugging = level


    # Here are all the POP commands:

    def user(self, user):
        """Send user name, return response

        (should indicate password required).
        """
        return self._shortcmd('USER %s' % user)


    def pass_(self, pswd):
        """Send password, return response

        (response includes message count, mailbox size).

        NB: mailbox is locked by server from here to 'quit()'
        """
        return self._shortcmd('PASS %s' % pswd)


    def stat(self):
        """Get mailbox status.

        Result is tuple of 2 ints (message count, mailbox size)
        """
        retval = self._shortcmd('STAT')
        rets = retval.split()
        if self._debugging: print '*stat*', repr(rets)
        numMessages = int(rets[1])
        sizeMessages = int(rets[2])
        return (numMessages, sizeMessages)


    def list(self, which=None):
        """Request listing, return result.

        Result without a message number argument is in form
        ['response', ['mesg_num octets', ...], octets].

        Result when a message number argument is given is a
        single response: the "scan listing" for that message.
        """
        if which is not None:
            return self._shortcmd('LIST %s' % which)
        return self._longcmd('LIST')


    def retr(self, which):
        """Retrieve whole message number 'which'.

        Result is in form ['response', ['line', ...], octets].
        """
        return self._longcmd('RETR %s' % which)


    def dele(self, which):
        """Delete message number 'which'.

        Result is 'response'.
        """
        return self._shortcmd('DELE %s' % which)


    def noop(self):
        """Does nothing.

        One supposes the response indicates the server is alive.
        """
        return self._shortcmd('NOOP')


    def rset(self):
        """Unmark all messages marked for deletion."""
        return self._shortcmd('RSET')


    def quit(self):
        """Signoff: commit changes on server, unlock mailbox, close connection."""
        try:
            resp = self._shortcmd('QUIT')
        except error_proto, val:
            resp = val
        self.file.close()
        self.sock.close()
        del self.file, self.sock
        return resp

    #__del__ = quit


    # optional commands:

    def rpop(self, user):
        """Not sure what this does."""
        return self._shortcmd('RPOP %s' % user)


    timestamp = re.compile(br'\+OK.[^<]*(<.*>)')

    def apop(self, user, secret):
        """Authorisation

        - only possible if server has supplied a timestamp in initial greeting.

        Args:
                user    - mailbox user;
                secret  - secret shared between client and server.

        NB: mailbox is locked by server from here to 'quit()'
        """
        m = self.timestamp.match(self.welcome)
        if not m:
            raise error_proto('-ERR APOP not supported by server')
        import hashlib
        digest = hashlib.md5(m.group(1)+secret).digest()
        digest = ''.join(map(lambda x:'%02x'%ord(x), digest))
        return self._shortcmd('APOP %s %s' % (user, digest))


    def top(self, which, howmuch):
        """Retrieve message header of message number 'which'
        and first 'howmuch' lines of message body.

        Result is in form ['response', ['line', ...], octets].
        """
        return self._longcmd('TOP %s %s' % (which, howmuch))


    def uidl(self, which=None):
        """Return message digest (unique id) list.

        If 'which', result contains unique id for that message
        in the form 'response mesgnum uid', otherwise result is
        the list ['response', ['mesgnum uid', ...], octets]
        """
        if which is not None:
            return self._shortcmd('UIDL %s' % which)
        return self._longcmd('UIDL')

try:
    import ssl
except ImportError:
    pass
else:

    class POP3_SSL(POP3):
        """POP3 client class over SSL connection

        Instantiate with: POP3_SSL(hostname, port=995, keyfile=None, certfile=None)

               hostname - the hostname of the pop3 over ssl server
               port - port number
               keyfile - PEM formatted file that contains your private key
               certfile - PEM formatted certificate chain file

            See the methods of the parent class POP3 for more documentation.
        """

        def __init__(self, host, port = POP3_SSL_PORT, keyfile = None, certfile = None):
            self.host = host
            self.port = port
            self.keyfile = keyfile
            self.certfile = certfile
            self.buffer = ""
            msg = "getaddrinfo returns an empty list"
            self.sock = None
            for res in socket.getaddrinfo(self.host, self.port, 0, socket.SOCK_STREAM):
                af, socktype, proto, canonname, sa = res
                try:
                    self.sock = socket.socket(af, socktype, proto)
                    self.sock.connect(sa)
                except socket.error, msg:
                    if self.sock:
                        self.sock.close()
                    self.sock = None
                    continue
                break
            if not self.sock:
                raise socket.error, msg
            self.file = self.sock.makefile('rb')
            self.sslobj = ssl.wrap_socket(self.sock, self.keyfile, self.certfile)
            self._debugging = 0
            self.welcome = self._getresp()

        def _fillBuffer(self):
            localbuf = self.sslobj.read()
            if len(localbuf) == 0:
                raise error_proto('-ERR EOF')
            self.buffer += localbuf

        def _getline(self):
            line = ""
            renewline = re.compile(r'.*?\n')
            match = renewline.match(self.buffer)
            while not match:
                self._fillBuffer()
                if len(self.buffer) > _MAXLINE:
                    raise error_proto('line too long')
                match = renewline.match(self.buffer)
            line = match.group(0)
            self.buffer = renewline.sub('' ,self.buffer, 1)
            if self._debugging > 1: print '*get*', repr(line)

            octets = len(line)
            if line[-2:] == CRLF:
                return line[:-2], octets
            if line[0] == CR:
                return line[1:-1], octets
            return line[:-1], octets

        def _putline(self, line):
            if self._debugging > 1: print '*put*', repr(line)
            line += CRLF
            bytes = len(line)
            while bytes > 0:
                sent = self.sslobj.write(line)
                if sent == bytes:
                    break    # avoid copy
                line = line[sent:]
                bytes = bytes - sent

        def quit(self):
            """Signoff: commit changes on server, unlock mailbox, close connection."""
            try:
                resp = self._shortcmd('QUIT')
            except error_proto, val:
                resp = val
            self.sock.close()
            del self.sslobj, self.sock
            return resp

    __all__.append("POP3_SSL")

if __name__ == "__main__":
    import sys
    a = POP3(sys.argv[1])
    print a.getwelcome()
    a.user(sys.argv[2])
    a.pass_(sys.argv[3])
    a.list()
    (numMsgs, totalSize) = a.stat()
    for i in range(1, numMsgs + 1):
        (header, msg, octets) = a.retr(i)
        print "Message %d:" % i
        for line in msg:
            print '   ' + line
        print '-----------------------'
    a.quit()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ó
Ó«[c           @   s«  d  Z  d d l Z d d l Z d d g Z d e f d „  ƒ  YZ d Z d Z d Z d	 Z	 e e	 Z
 d
 Z d f  d „  ƒ  YZ y d d l Z Wn e k
 rž n$ Xd e f d „  ƒ  YZ e j d ƒ e d k r§d d l Z e e j d ƒ Z e j ƒ  GHe j e j d ƒ e j e j d ƒ e j ƒ  e j ƒ  \ Z Z x[ e d e d ƒ D]F Z e j e ƒ \ Z Z  Z! d e GHx e  D] Z" d e" GHq~Wd GHqPWe j# ƒ  n  d S(   s@   A POP3 client class.

Based on the J. Myers POP3 draft, Jan. 96
iÿÿÿÿNt   POP3t   error_protoc           B   s   e  Z RS(    (   t   __name__t
   __module__(    (    (    s   /usr/lib/python2.7/poplib.pyR      s    in   iã  s   s   
i   c           B   sû   e  Z d  Z e e j d „ Z d „  Z d „  Z d „  Z	 d „  Z
 d „  Z d „  Z d „  Z d	 „  Z d
 „  Z d „  Z d „  Z d „  Z d d „ Z d „  Z d „  Z d „  Z d „  Z d „  Z d „  Z e j d ƒ Z d „  Z d „  Z d d „ Z  RS(   sÏ  This class supports both the minimal and optional command sets.
    Arguments can be strings or integers (where appropriate)
    (e.g.: retr(1) and retr('1') both work equally well.

    Minimal Command Set:
            USER name               user(name)
            PASS string             pass_(string)
            STAT                    stat()
            LIST [msg]              list(msg = None)
            RETR msg                retr(msg)
            DELE msg                dele(msg)
            NOOP                    noop()
            RSET                    rset()
            QUIT                    quit()

    Optional Commands (some servers support these):
            RPOP name               rpop(name)
            APOP name digest        apop(name, digest)
            TOP msg n               top(msg, n)
            UIDL [msg]              uidl(msg = None)

    Raises one exception: 'error_proto'.

    Instantiate with:
            POP3(hostname, port=110)

    NB:     the POP protocol locks the mailbox from user
            authorization until QUIT, so be sure to get in, suck
            the messages, and quit, each time you access the
            mailbox.

            POP is a line-based protocol, which means large mail
            messages consume lots of python cycles reading them
            line-by-line.

            If it's available on your mail server, use IMAP4
            instead, it doesn't suffer from the two problems
            above.
    c         C   s^   | |  _  | |  _ t j | | f | ƒ |  _ |  j j d ƒ |  _ d |  _ |  j ƒ  |  _	 d  S(   Nt   rbi    (
   t   hostt   portt   sockett   create_connectiont   sockt   makefilet   filet
   _debuggingt   _getrespt   welcome(   t   selfR   R   t   timeout(    (    s   /usr/lib/python2.7/poplib.pyt   __init__U   s    			c         C   s?   |  j  d k r! d Gt | ƒ GHn  |  j j d | t f ƒ d  S(   Ni   s   *put*s   %s%s(   R   t   reprR	   t   sendallt   CRLF(   R   t   line(    (    s   /usr/lib/python2.7/poplib.pyt   _putline_   s     c         C   s,   |  j  r d Gt | ƒ GHn  |  j | ƒ d  S(   Ns   *cmd*(   R   R   R   (   R   R   (    (    s   /usr/lib/python2.7/poplib.pyt   _putcmdf   s    	 c         C   sÆ   |  j  j t d ƒ } t | ƒ t k r7 t d ƒ ‚ n  |  j d k rX d Gt | ƒ GHn  | sm t d ƒ ‚ n  t | ƒ } | d t k r— | d  | f S| d t k r¸ | d d !| f S| d  | f S(   Ni   s   line too longs   *get*s   -ERR EOFiþÿÿÿi    iÿÿÿÿ(	   R   t   readlinet   _MAXLINEt   lenR   R   R   R   t   CR(   R   R   t   octets(    (    s   /usr/lib/python2.7/poplib.pyt   _getlineo   s      c         C   s\   |  j  ƒ  \ } } |  j d k r3 d Gt | ƒ GHn  | d  } | d k rX t | ƒ ‚ n  | S(   Ni   s   *resp*t   +(   R   R   R   R   (   R   t   respt   ot   c(    (    s   /usr/lib/python2.7/poplib.pyR   ƒ   s     
c         C   sš   |  j  ƒ  } g  } d } |  j ƒ  \ } } x` | d k rŒ | d  d k r` | d } | d } n  | | } | j | ƒ |  j ƒ  \ } } q- W| | | f S(   Ni    t   .i   s   ..i   (   R   R   t   append(   R   R   t   listR   R   R    (    (    s   /usr/lib/python2.7/poplib.pyt   _getlongrespŽ   s     

c         C   s   |  j  | ƒ |  j ƒ  S(   N(   R   R   (   R   R   (    (    s   /usr/lib/python2.7/poplib.pyt	   _shortcmdž   s    c         C   s   |  j  | ƒ |  j ƒ  S(   N(   R   R%   (   R   R   (    (    s   /usr/lib/python2.7/poplib.pyt   _longcmd¥   s    c         C   s   |  j  S(   N(   R   (   R   (    (    s   /usr/lib/python2.7/poplib.pyt
   getwelcome¬   s    c         C   s   | |  _  d  S(   N(   R   (   R   t   level(    (    s   /usr/lib/python2.7/poplib.pyt   set_debuglevel°   s    c         C   s   |  j  d | ƒ S(   sV   Send user name, return response

        (should indicate password required).
        s   USER %s(   R&   (   R   t   user(    (    s   /usr/lib/python2.7/poplib.pyR+   ¶   s    c         C   s   |  j  d | ƒ S(   s    Send password, return response

        (response includes message count, mailbox size).

        NB: mailbox is locked by server from here to 'quit()'
        s   PASS %s(   R&   (   R   t   pswd(    (    s   /usr/lib/python2.7/poplib.pyt   pass_¾   s    c         C   s`   |  j  d ƒ } | j ƒ  } |  j r6 d Gt | ƒ GHn  t | d ƒ } t | d ƒ } | | f S(   s]   Get mailbox status.

        Result is tuple of 2 ints (message count, mailbox size)
        t   STATs   *stat*i   i   (   R&   t   splitR   R   t   int(   R   t   retvalt   retst   numMessagest   sizeMessages(    (    s   /usr/lib/python2.7/poplib.pyt   statÈ   s    	 c         C   s*   | d k	 r |  j d | ƒ S|  j d ƒ S(   s  Request listing, return result.

        Result without a message number argument is in form
        ['response', ['mesg_num octets', ...], octets].

        Result when a message number argument is given is a
        single response: the "scan listing" for that message.
        s   LIST %st   LISTN(   t   NoneR&   R'   (   R   t   which(    (    s   /usr/lib/python2.7/poplib.pyR$   Õ   s    	c         C   s   |  j  d | ƒ S(   so   Retrieve whole message number 'which'.

        Result is in form ['response', ['line', ...], octets].
        s   RETR %s(   R'   (   R   R8   (    (    s   /usr/lib/python2.7/poplib.pyt   retrã   s    c         C   s   |  j  d | ƒ S(   sF   Delete message number 'which'.

        Result is 'response'.
        s   DELE %s(   R&   (   R   R8   (    (    s   /usr/lib/python2.7/poplib.pyt   deleë   s    c         C   s   |  j  d ƒ S(   sX   Does nothing.

        One supposes the response indicates the server is alive.
        t   NOOP(   R&   (   R   (    (    s   /usr/lib/python2.7/poplib.pyt   noopó   s    c         C   s   |  j  d ƒ S(   s(   Unmark all messages marked for deletion.t   RSET(   R&   (   R   (    (    s   /usr/lib/python2.7/poplib.pyt   rsetû   s    c         C   sY   y |  j  d ƒ } Wn t k
 r. } | } n X|  j j ƒ  |  j j ƒ  |  ` |  ` | S(   sD   Signoff: commit changes on server, unlock mailbox, close connection.t   QUIT(   R&   R   R   t   closeR	   (   R   R   t   val(    (    s   /usr/lib/python2.7/poplib.pyt   quit   s    
c         C   s   |  j  d | ƒ S(   s   Not sure what this does.s   RPOP %s(   R&   (   R   R+   (    (    s   /usr/lib/python2.7/poplib.pyt   rpop  s    s   \+OK.[^<]*(<.*>)c         C   sŠ   |  j  j |  j ƒ } | s* t d ƒ ‚ n  d d l } | j | j d ƒ | ƒ j ƒ  } d j t	 d „  | ƒ ƒ } |  j
 d | | f ƒ S(   s   Authorisation

        - only possible if server has supplied a timestamp in initial greeting.

        Args:
                user    - mailbox user;
                secret  - secret shared between client and server.

        NB: mailbox is locked by server from here to 'quit()'
        s!   -ERR APOP not supported by serveriÿÿÿÿNi   t    c         S   s   d t  |  ƒ S(   Ns   %02x(   t   ord(   t   x(    (    s   /usr/lib/python2.7/poplib.pyt   <lambda>'  s    s
   APOP %s %s(   t	   timestampt   matchR   R   t   hashlibt   md5t   groupt   digestt   joint   mapR&   (   R   R+   t   secrett   mRJ   RM   (    (    s   /usr/lib/python2.7/poplib.pyt   apop  s    "c         C   s   |  j  d | | f ƒ S(   s­   Retrieve message header of message number 'which'
        and first 'howmuch' lines of message body.

        Result is in form ['response', ['line', ...], octets].
        s	   TOP %s %s(   R'   (   R   R8   t   howmuch(    (    s   /usr/lib/python2.7/poplib.pyt   top+  s    c         C   s*   | d k	 r |  j d | ƒ S|  j d ƒ S(   sì   Return message digest (unique id) list.

        If 'which', result contains unique id for that message
        in the form 'response mesgnum uid', otherwise result is
        the list ['response', ['mesgnum uid', ...], octets]
        s   UIDL %st   UIDLN(   R7   R&   R'   (   R   R8   (    (    s   /usr/lib/python2.7/poplib.pyt   uidl4  s    N(!   R   R   t   __doc__t	   POP3_PORTR   t   _GLOBAL_DEFAULT_TIMEOUTR   R   R   R   R   R%   R&   R'   R(   R*   R+   R-   R5   R7   R$   R9   R:   R<   R>   RB   RC   t   ret   compileRH   RR   RT   RV   (    (    (    s   /usr/lib/python2.7/poplib.pyR    *   s4   (													
										t   POP3_SSLc           B   sD   e  Z d  Z e d d d „ Z d „  Z d „  Z d „  Z d „  Z	 RS(   sÁ  POP3 client class over SSL connection

        Instantiate with: POP3_SSL(hostname, port=995, keyfile=None, certfile=None)

               hostname - the hostname of the pop3 over ssl server
               port - port number
               keyfile - PEM formatted file that contains your private key
               certfile - PEM formatted certificate chain file

            See the methods of the parent class POP3 for more documentation.
        c         C   sR  | |  _  | |  _ | |  _ | |  _ d |  _ d } d  |  _ x© t j |  j  |  j d t j	 ƒ D]† } | \ } } }	 }
 } y, t j | | |	 ƒ |  _ |  j j
 | ƒ Wn; t j k
 râ } |  j rÓ |  j j ƒ  n  d  |  _ q^ n XPq^ W|  j s t j | ‚ n  |  j j d ƒ |  _ t j |  j |  j |  j ƒ |  _ d |  _ |  j ƒ  |  _ d  S(   NRD   s!   getaddrinfo returns an empty listi    R   (   R   R   t   keyfilet   certfilet   bufferR7   R	   R   t   getaddrinfot   SOCK_STREAMt   connectt   errorR@   R
   R   t   sslt   wrap_sockett   sslobjR   R   R   (   R   R   R   R]   R^   t   msgt   rest   aft   socktypet   protot	   canonnamet   sa(    (    s   /usr/lib/python2.7/poplib.pyR   R  s0    						(			!	c         C   sC   |  j  j ƒ  } t | ƒ d k r0 t d ƒ ‚ n  |  j | 7_ d  S(   Ni    s   -ERR EOF(   Rf   t   readR   R   R_   (   R   t   localbuf(    (    s   /usr/lib/python2.7/poplib.pyt   _fillBufferl  s    c         C   s  d } t  j d ƒ } | j |  j ƒ } xJ | ss |  j ƒ  t |  j ƒ t k r^ t d ƒ ‚ n  | j |  j ƒ } q* W| j d ƒ } | j	 d |  j d ƒ |  _ |  j
 d k r¿ d Gt | ƒ GHn  t | ƒ } | d t k ré | d  | f S| d t k r
| d d !| f S| d  | f S(	   NRD   s   .*?\ns   line too longi    i   s   *get*iþÿÿÿiÿÿÿÿ(   RZ   R[   RI   R_   Rp   R   R   R   RL   t   subR   R   R   R   (   R   R   t	   renewlineRI   R   (    (    s   /usr/lib/python2.7/poplib.pyR   r  s$    	
 c         C   s„   |  j  d k r! d Gt | ƒ GHn  | t 7} t | ƒ } xF | d k r |  j j | ƒ } | | k rh Pn  | | } | | } q: Wd  S(   Ni   s   *put*i    (   R   R   R   R   Rf   t   write(   R   R   t   bytest   sent(    (    s   /usr/lib/python2.7/poplib.pyR   †  s     

c         C   sL   y |  j  d ƒ } Wn t k
 r. } | } n X|  j j ƒ  |  ` |  ` | S(   sD   Signoff: commit changes on server, unlock mailbox, close connection.R?   (   R&   R   R	   R@   Rf   (   R   R   RA   (    (    s   /usr/lib/python2.7/poplib.pyRB   ‘  s    
N(
   R   R   RW   t   POP3_SSL_PORTR7   R   Rp   R   R   RB   (    (    (    s   /usr/lib/python2.7/poplib.pyR\   E  s   			t   __main__i   i   i   s   Message %d:s      s   -----------------------($   RW   RZ   R   t   __all__t	   ExceptionR   RX   Rv   R   t   LFR   R   R    Rd   t   ImportErrorR\   R#   R   t   syst   argvt   aR(   R+   R-   R$   R5   t   numMsgst	   totalSizet   ranget   iR9   t   headerRg   R   R   RB   (    (    (    s   /usr/lib/python2.7/poplib.pyt   <module>   s@   
ÿ V
		                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 """Extended file operations available in POSIX.

f = posixfile.open(filename, [mode, [bufsize]])
      will create a new posixfile object

f = posixfile.fileopen(fileobject)
      will create a posixfile object from a builtin file object

f.file()
      will return the original builtin file object

f.dup()
      will return a new file object based on a new filedescriptor

f.dup2(fd)
      will return a new file object based on the given filedescriptor

f.flags(mode)
      will turn on the associated flag (merge)
      mode can contain the following characters:

  (character representing a flag)
      a       append only flag
      c       close on exec flag
      n       no delay flag
      s       synchronization flag
  (modifiers)
      !       turn flags 'off' instead of default 'on'
      =       copy flags 'as is' instead of default 'merge'
      ?       return a string in which the characters represent the flags
              that are set

      note: - the '!' and '=' modifiers are mutually exclusive.
            - the '?' modifier will return the status of the flags after they
              have been changed by other characters in the mode string

f.lock(mode [, len [, start [, whence]]])
      will (un)lock a region
      mode can contain the following characters:

  (character representing type of lock)
      u       unlock
      r       read lock
      w       write lock
  (modifiers)
      |       wait until the lock can be granted
      ?       return the first lock conflicting with the requested lock
              or 'None' if there is no conflict. The lock returned is in the
              format (mode, len, start, whence, pid) where mode is a
              character representing the type of lock ('r' or 'w')

      note: - the '?' modifier prevents a region from being locked; it is
              query only
"""
import warnings
warnings.warn("The posixfile module is deprecated; "
                "fcntl.lockf() provides better locking", DeprecationWarning, 2)

class _posixfile_:
    """File wrapper class that provides extra POSIX file routines."""

    states = ['open', 'closed']

    #
    # Internal routines
    #
    def __repr__(self):
        file = self._file_
        return "<%s posixfile '%s', mode '%s' at %s>" % \
                (self.states[file.closed], file.name, file.mode, \
                 hex(id(self))[2:])

    #
    # Initialization routines
    #
    def open(self, name, mode='r', bufsize=-1):
        import __builtin__
        return self.fileopen(__builtin__.open(name, mode, bufsize))

    def fileopen(self, file):
        import types
        if repr(type(file)) != "<type 'file'>":
            raise TypeError, 'posixfile.fileopen() arg must be file object'
        self._file_  = file
        # Copy basic file methods
        for maybemethod in dir(file):
            if not maybemethod.startswith('_'):
                attr = getattr(file, maybemethod)
                if isinstance(attr, types.BuiltinMethodType):
                    setattr(self, maybemethod, attr)
        return self

    #
    # New methods
    #
    def file(self):
        return self._file_

    def dup(self):
        import posix

        if not hasattr(posix, 'fdopen'):
            raise AttributeError, 'dup() method unavailable'

        return posix.fdopen(posix.dup(self._file_.fileno()), self._file_.mode)

    def dup2(self, fd):
        import posix

        if not hasattr(posix, 'fdopen'):
            raise AttributeError, 'dup() method unavailable'

        posix.dup2(self._file_.fileno(), fd)
        return posix.fdopen(fd, self._file_.mode)

    def flags(self, *which):
        import fcntl, os

        if which:
            if len(which) > 1:
                raise TypeError, 'Too many arguments'
            which = which[0]
        else: which = '?'

        l_flags = 0
        if 'n' in which: l_flags = l_flags | os.O_NDELAY
        if 'a' in which: l_flags = l_flags | os.O_APPEND
        if 's' in which: l_flags = l_flags | os.O_SYNC

        file = self._file_

        if '=' not in which:
            cur_fl = fcntl.fcntl(file.fileno(), fcntl.F_GETFL, 0)
            if '!' in which: l_flags = cur_fl & ~ l_flags
            else: l_flags = cur_fl | l_flags

        l_flags = fcntl.fcntl(file.fileno(), fcntl.F_SETFL, l_flags)

        if 'c' in which:
            arg = ('!' not in which)    # 0 is don't, 1 is do close on exec
            l_flags = fcntl.fcntl(file.fileno(), fcntl.F_SETFD, arg)

        if '?' in which:
            which = ''                  # Return current flags
            l_flags = fcntl.fcntl(file.fileno(), fcntl.F_GETFL, 0)
            if os.O_APPEND & l_flags: which = which + 'a'
            if fcntl.fcntl(file.fileno(), fcntl.F_GETFD, 0) & 1:
                which = which + 'c'
            if os.O_NDELAY & l_flags: which = which + 'n'
            if os.O_SYNC & l_flags: which = which + 's'
            return which

    def lock(self, how, *args):
        import struct, fcntl

        if 'w' in how: l_type = fcntl.F_WRLCK
        elif 'r' in how: l_type = fcntl.F_RDLCK
        elif 'u' in how: l_type = fcntl.F_UNLCK
        else: raise TypeError, 'no type of lock specified'

        if '|' in how: cmd = fcntl.F_SETLKW
        elif '?' in how: cmd = fcntl.F_GETLK
        else: cmd = fcntl.F_SETLK

        l_whence = 0
        l_start = 0
        l_len = 0

        if len(args) == 1:
            l_len = args[0]
        elif len(args) == 2:
            l_len, l_start = args
        elif len(args) == 3:
            l_len, l_start, l_whence = args
        elif len(args) > 3:
            raise TypeError, 'too many arguments'

        # Hack by davem@magnet.com to get locking to go on freebsd;
        # additions for AIX by Vladimir.Marangozov@imag.fr
        import sys, os
        if sys.platform in ('netbsd1',
                            'openbsd2',
                            'freebsd2', 'freebsd3', 'freebsd4', 'freebsd5',
                            'freebsd6', 'freebsd7', 'freebsd8',
                            'bsdos2', 'bsdos3', 'bsdos4'):
            flock = struct.pack('lxxxxlxxxxlhh', \
                  l_start, l_len, os.getpid(), l_type, l_whence)
        elif sys.platform in ('aix3', 'aix4'):
            flock = struct.pack('hhlllii', \
                  l_type, l_whence, l_start, l_len, 0, 0, 0)
        else:
            flock = struct.pack('hhllhh', \
                  l_type, l_whence, l_start, l_len, 0, 0)

        flock = fcntl.fcntl(self._file_.fileno(), cmd, flock)

        if '?' in how:
            if sys.platform in ('netbsd1',
                                'openbsd2',
                                'freebsd2', 'freebsd3', 'freebsd4', 'freebsd5',
                                'bsdos2', 'bsdos3', 'bsdos4'):
                l_start, l_len, l_pid, l_type, l_whence = \
                    struct.unpack('lxxxxlxxxxlhh', flock)
            elif sys.platform in ('aix3', 'aix4'):
                l_type, l_whence, l_start, l_len, l_sysid, l_pid, l_vfs = \
                    struct.unpack('hhlllii', flock)
            elif sys.platform == "linux2":
                l_type, l_whence, l_start, l_len, l_pid, l_sysid = \
                    struct.unpack('hhllhh', flock)
            else:
                l_type, l_whence, l_start, l_len, l_sysid, l_pid = \
                    struct.unpack('hhllhh', flock)

            if l_type != fcntl.F_UNLCK:
                if l_type == fcntl.F_RDLCK:
                    return 'r', l_len, l_start, l_whence, l_pid
                else:
                    return 'w', l_len, l_start, l_whence, l_pid

def open(name, mode='r', bufsize=-1):
    """Public routine to open a file as a posixfile object."""
    return _posixfile_().open(name, mode, bufsize)

def fileopen(file):
    """Public routine to get a posixfile object from a Python file object."""
    return _posixfile_().fileopen(file)

#
# Constants
#
SEEK_SET = 0
SEEK_CUR = 1
SEEK_END = 2

#
# End of posixfile.py
#
                                                                                                                                                                                             ó
Ó«[c           @   sf   d  Z  d d l Z e j d e d ƒ d d d „  ƒ  YZ d d d „ Z d	 „  Z d
 Z d Z d Z	 d S(   s:  Extended file operations available in POSIX.

f = posixfile.open(filename, [mode, [bufsize]])
      will create a new posixfile object

f = posixfile.fileopen(fileobject)
      will create a posixfile object from a builtin file object

f.file()
      will return the original builtin file object

f.dup()
      will return a new file object based on a new filedescriptor

f.dup2(fd)
      will return a new file object based on the given filedescriptor

f.flags(mode)
      will turn on the associated flag (merge)
      mode can contain the following characters:

  (character representing a flag)
      a       append only flag
      c       close on exec flag
      n       no delay flag
      s       synchronization flag
  (modifiers)
      !       turn flags 'off' instead of default 'on'
      =       copy flags 'as is' instead of default 'merge'
      ?       return a string in which the characters represent the flags
              that are set

      note: - the '!' and '=' modifiers are mutually exclusive.
            - the '?' modifier will return the status of the flags after they
              have been changed by other characters in the mode string

f.lock(mode [, len [, start [, whence]]])
      will (un)lock a region
      mode can contain the following characters:

  (character representing type of lock)
      u       unlock
      r       read lock
      w       write lock
  (modifiers)
      |       wait until the lock can be granted
      ?       return the first lock conflicting with the requested lock
              or 'None' if there is no conflict. The lock returned is in the
              format (mode, len, start, whence, pid) where mode is a
              character representing the type of lock ('r' or 'w')

      note: - the '?' modifier prevents a region from being locked; it is
              query only
iÿÿÿÿNsI   The posixfile module is deprecated; fcntl.lockf() provides better lockingi   t   _posixfile_c           B   sh   e  Z d  Z d d g Z d „  Z d d d „ Z d „  Z d „  Z d	 „  Z d
 „  Z	 d „  Z
 d „  Z RS(   s;   File wrapper class that provides extra POSIX file routines.t   opent   closedc         C   s=   |  j  } d |  j | j | j | j t t |  ƒ ƒ d f S(   Ns$   <%s posixfile '%s', mode '%s' at %s>i   (   t   _file_t   statesR   t   namet   modet   hext   id(   t   selft   file(    (    s   /usr/lib/python2.7/posixfile.pyt   __repr__C   s    	t   riÿÿÿÿc         C   s(   d d  l  } |  j | j | | | ƒ ƒ S(   Niÿÿÿÿ(   t   __builtin__t   fileopenR   (   R	   R   R   t   bufsizeR   (    (    s   /usr/lib/python2.7/posixfile.pyR   L   s    c         C   sš   d d  l  } t t | ƒ ƒ d k r0 t d ‚ n  | |  _ xZ t | ƒ D]L } | j d ƒ sF t | | ƒ } t | | j	 ƒ r’ t
 |  | | ƒ q’ qF qF W|  S(   Niÿÿÿÿs   <type 'file'>s,   posixfile.fileopen() arg must be file objectt   _(   t   typest   reprt   typet	   TypeErrorR   t   dirt
   startswitht   getattrt
   isinstancet   BuiltinMethodTypet   setattr(   R	   R
   R   t   maybemethodt   attr(    (    s   /usr/lib/python2.7/posixfile.pyR   P   s    	c         C   s   |  j  S(   N(   R   (   R	   (    (    s   /usr/lib/python2.7/posixfile.pyR
   `   s    c         C   sO   d d  l  } t | d ƒ s' t d ‚ n  | j | j |  j j ƒ  ƒ |  j j ƒ S(   Niÿÿÿÿt   fdopens   dup() method unavailable(   t   posixt   hasattrt   AttributeErrorR   t   dupR   t   filenoR   (   R	   R   (    (    s   /usr/lib/python2.7/posixfile.pyR!   c   s    c         C   sV   d d  l  } t | d ƒ s' t d ‚ n  | j |  j j ƒ  | ƒ | j | |  j j ƒ S(   NiÿÿÿÿR   s   dup() method unavailable(   R   R   R    t   dup2R   R"   R   R   (   R	   t   fdR   (    (    s   /usr/lib/python2.7/posixfile.pyR#   k   s
    c         G   s  d d  l  } d d  l } | rI t | ƒ d k r< t d ‚ n  | d } n d } d } d | k rq | | j B} n  d | k r | | j B} n  d | k r© | | j B} n  |  j } d	 | k r| j  | j ƒ  | j	 d ƒ } d
 | k rö | | @} q| | B} n  | j  | j ƒ  | j
 | ƒ } d | k rZd
 | k } | j  | j ƒ  | j | ƒ } n  d | k rd } | j  | j ƒ  | j	 d ƒ } | j | @r¤| d } n  | j  | j ƒ  | j d ƒ d @rÓ| d } n  | j | @rí| d } n  | j | @r| d } n  | Sd  S(   Niÿÿÿÿi   s   Too many argumentsi    t   ?t   nt   at   st   =t   !t   ct    (   t   fcntlt   ost   lenR   t   O_NDELAYt   O_APPENDt   O_SYNCR   R"   t   F_GETFLt   F_SETFLt   F_SETFDt   F_GETFD(   R	   t   whichR-   R.   t   l_flagsR
   t   cur_flt   arg(    (    s   /usr/lib/python2.7/posixfile.pyt   flagst   sF       	 ! "  c         G   s  d d  l  } d d  l } d | k r0 | j } n9 d | k rH | j } n! d | k r` | j } n	 t d ‚ d | k r | j } n! d | k r™ | j } n	 | j } d } d } d }	 t	 | ƒ d	 k rÓ | d }	 nc t	 | ƒ d
 k rô | \ }	 } nB t	 | ƒ d k r| \ }	 } } n t	 | ƒ d k r6t d ‚ n  d d  l
 }
 d d  l } |
 j d k r„| j d | |	 | j ƒ  | | ƒ } nW |
 j d  k rº| j d | | | |	 d d d ƒ } n! | j d | | | |	 d d ƒ } | j |  j j ƒ  | | ƒ } d | k r|
 j d! k r8| j d | ƒ \ } }	 } } } n“ |
 j d" k rq| j d | ƒ \ } } } }	 } } } nZ |
 j d k r§| j d | ƒ \ } } } }	 } } n$ | j d | ƒ \ } } } }	 } } | | j k r| | j k rüd |	 | | | f Sd |	 | | | f Sqn  d  S(#   Niÿÿÿÿt   wR   t   us   no type of lock specifiedt   |R%   i    i   i   i   s   too many argumentst   netbsd1t   openbsd2t   freebsd2t   freebsd3t   freebsd4t   freebsd5t   freebsd6t   freebsd7t   freebsd8t   bsdos2t   bsdos3t   bsdos4t   lxxxxlxxxxlhht   aix3t   aix4t   hhllliit   hhllhht   linux2(   R?   R@   RA   RB   RC   RD   RE   RF   RG   RH   RI   RJ   (   RL   RM   (	   R?   R@   RA   RB   RC   RD   RH   RI   RJ   (   RL   RM   (   t   structR-   t   F_WRLCKt   F_RDLCKt   F_UNLCKR   t   F_SETLKWt   F_GETLKt   F_SETLKR/   t   sysR.   t   platformt   packt   getpidR   R"   t   unpack(   R	   t   howt   argsRQ   R-   t   l_typet   cmdt   l_whencet   l_startt   l_lenRX   R.   t   flockt   l_pidt   l_sysidt   l_vfs(    (    s   /usr/lib/python2.7/posixfile.pyt   lock™   sj       	  	   				  	$*'$(   t   __name__t
   __module__t   __doc__R   R   R   R   R
   R!   R#   R;   Rh   (    (    (    s   /usr/lib/python2.7/posixfile.pyR    ;   s   								%R   c         C   s   t  ƒ  j |  | | ƒ S(   s4   Public routine to open a file as a posixfile object.(   R    R   (   R   R   R   (    (    s   /usr/lib/python2.7/posixfile.pyR   Ü   s    c         C   s   t  ƒ  j |  ƒ S(   sC   Public routine to get a posixfile object from a Python file object.(   R    R   (   R
   (    (    s   /usr/lib/python2.7/posixfile.pyR   à   s    i    i   (    (
   Rk   t   warningst   warnt   DeprecationWarningR    R   R   t   SEEK_SETt   SEEK_CURt   SEEK_END(    (    (    s   /usr/lib/python2.7/posixfile.pyt   <module>6   s   	
¡	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    """Common operations on Posix pathnames.

Instead of importing this module directly, import os and refer to
this module as os.path.  The "os.path" name is an alias for this
module on Posix systems; on other systems (e.g. Mac, Windows),
os.path provides the same operations in a manner specific to that
platform, and is an alias to another module (e.g. macpath, ntpath).

Some of this can actually be useful on non-Posix systems too, e.g.
for manipulation of the pathname component of URLs.
"""

import os
import sys
import stat
import genericpath
import warnings
from genericpath import *
from genericpath import _unicode

__all__ = ["normcase","isabs","join","splitdrive","split","splitext",
           "basename","dirname","commonprefix","getsize","getmtime",
           "getatime","getctime","islink","exists","lexists","isdir","isfile",
           "ismount","walk","expanduser","expandvars","normpath","abspath",
           "samefile","sameopenfile","samestat",
           "curdir","pardir","sep","pathsep","defpath","altsep","extsep",
           "devnull","realpath","supports_unicode_filenames","relpath"]

# strings representing various path-related bits and pieces
curdir = '.'
pardir = '..'
extsep = '.'
sep = '/'
pathsep = ':'
defpath = ':/bin:/usr/bin'
altsep = None
devnull = '/dev/null'

# Normalize the case of a pathname.  Trivial in Posix, string.lower on Mac.
# On MS-DOS this may also turn slashes into backslashes; however, other
# normalizations (such as optimizing '../' away) are not allowed
# (another function should be defined to do that).

def normcase(s):
    """Normalize case of pathname.  Has no effect under Posix"""
    return s


# Return whether a path is absolute.
# Trivial in Posix, harder on the Mac or MS-DOS.

def isabs(s):
    """Test whether a path is absolute"""
    return s.startswith('/')


# Join pathnames.
# Ignore the previous parts if a part is absolute.
# Insert a '/' unless the first part is empty or already ends in '/'.

def join(a, *p):
    """Join two or more pathname components, inserting '/' as needed.
    If any component is an absolute path, all previous path components
    will be discarded.  An empty last part will result in a path that
    ends with a separator."""
    path = a
    for b in p:
        if b.startswith('/'):
            path = b
        elif path == '' or path.endswith('/'):
            path +=  b
        else:
            path += '/' + b
    return path


# Split a path in head (everything up to the last '/') and tail (the
# rest).  If the path ends in '/', tail will be empty.  If there is no
# '/' in the path, head  will be empty.
# Trailing '/'es are stripped from head unless it is the root.

def split(p):
    """Split a pathname.  Returns tuple "(head, tail)" where "tail" is
    everything after the final slash.  Either part may be empty."""
    i = p.rfind('/') + 1
    head, tail = p[:i], p[i:]
    if head and head != '/'*len(head):
        head = head.rstrip('/')
    return head, tail


# Split a path in root and extension.
# The extension is everything starting at the last dot in the last
# pathname component; the root is everything before that.
# It is always true that root + ext == p.

def splitext(p):
    return genericpath._splitext(p, sep, altsep, extsep)
splitext.__doc__ = genericpath._splitext.__doc__

# Split a pathname into a drive specification and the rest of the
# path.  Useful on DOS/Windows/NT; on Unix, the drive is always empty.

def splitdrive(p):
    """Split a pathname into drive and path. On Posix, drive is always
    empty."""
    return '', p


# Return the tail (basename) part of a path, same as split(path)[1].

def basename(p):
    """Returns the final component of a pathname"""
    i = p.rfind('/') + 1
    return p[i:]


# Return the head (dirname) part of a path, same as split(path)[0].

def dirname(p):
    """Returns the directory component of a pathname"""
    i = p.rfind('/') + 1
    head = p[:i]
    if head and head != '/'*len(head):
        head = head.rstrip('/')
    return head


# Is a path a symbolic link?
# This will always return false on systems where os.lstat doesn't exist.

def islink(path):
    """Test whether a path is a symbolic link"""
    try:
        st = os.lstat(path)
    except (os.error, AttributeError):
        return False
    return stat.S_ISLNK(st.st_mode)

# Being true for dangling symbolic links is also useful.

def lexists(path):
    """Test whether a path exists.  Returns True for broken symbolic links"""
    try:
        os.lstat(path)
    except os.error:
        return False
    return True


# Are two filenames really pointing to the same file?

def samefile(f1, f2):
    """Test whether two pathnames reference the same actual file"""
    s1 = os.stat(f1)
    s2 = os.stat(f2)
    return samestat(s1, s2)


# Are two open files really referencing the same file?
# (Not necessarily the same file descriptor!)

def sameopenfile(fp1, fp2):
    """Test whether two open file objects reference the same file"""
    s1 = os.fstat(fp1)
    s2 = os.fstat(fp2)
    return samestat(s1, s2)


# Are two stat buffers (obtained from stat, fstat or lstat)
# describing the same file?

def samestat(s1, s2):
    """Test whether two stat buffers reference the same file"""
    return s1.st_ino == s2.st_ino and \
           s1.st_dev == s2.st_dev


# Is a path a mount point?
# (Does this work for all UNIXes?  Is it even guaranteed to work by Posix?)

def ismount(path):
    """Test whether a path is a mount point"""
    if islink(path):
        # A symlink can never be a mount point
        return False
    try:
        s1 = os.lstat(path)
        s2 = os.lstat(realpath(join(path, '..')))
    except os.error:
        return False # It doesn't exist -- so not a mount point :-)
    dev1 = s1.st_dev
    dev2 = s2.st_dev
    if dev1 != dev2:
        return True     # path/.. on a different device as path
    ino1 = s1.st_ino
    ino2 = s2.st_ino
    if ino1 == ino2:
        return True     # path/.. is the same i-node as path
    return False


# Directory tree walk.
# For each directory under top (including top itself, but excluding
# '.' and '..'), func(arg, dirname, filenames) is called, where
# dirname is the name of the directory and filenames is the list
# of files (and subdirectories etc.) in the directory.
# The func may modify the filenames list, to implement a filter,
# or to impose a different order of visiting.

def walk(top, func, arg):
    """Directory tree walk with callback function.

    For each directory in the directory tree rooted at top (including top
    itself, but excluding '.' and '..'), call func(arg, dirname, fnames).
    dirname is the name of the directory, and fnames a list of the names of
    the files and subdirectories in dirname (excluding '.' and '..').  func
    may modify the fnames list in-place (e.g. via del or slice assignment),
    and walk will only recurse into the subdirectories whose names remain in
    fnames; this can be used to implement a filter, or to impose a specific
    order of visiting.  No semantics are defined for, or required of, arg,
    beyond that arg is always passed to func.  It can be used, e.g., to pass
    a filename pattern, or a mutable object designed to accumulate
    statistics.  Passing None for arg is common."""
    warnings.warnpy3k("In 3.x, os.path.walk is removed in favor of os.walk.",
                      stacklevel=2)
    try:
        names = os.listdir(top)
    except os.error:
        return
    func(arg, top, names)
    for name in names:
        name = join(top, name)
        try:
            st = os.lstat(name)
        except os.error:
            continue
        if stat.S_ISDIR(st.st_mode):
            walk(name, func, arg)


# Expand paths beginning with '~' or '~user'.
# '~' means $HOME; '~user' means that user's home directory.
# If the path doesn't begin with '~', or if the user or $HOME is unknown,
# the path is returned unchanged (leaving error reporting to whatever
# function is called with the expanded path as argument).
# See also module 'glob' for expansion of *, ? and [...] in pathnames.
# (A function should also be defined to do full *sh-style environment
# variable expansion.)

def expanduser(path):
    """Expand ~ and ~user constructions.  If user or $HOME is unknown,
    do nothing."""
    if not path.startswith('~'):
        return path
    i = path.find('/', 1)
    if i < 0:
        i = len(path)
    if i == 1:
        if 'HOME' not in os.environ:
            import pwd
            userhome = pwd.getpwuid(os.getuid()).pw_dir
        else:
            userhome = os.environ['HOME']
    else:
        import pwd
        try:
            pwent = pwd.getpwnam(path[1:i])
        except KeyError:
            return path
        userhome = pwent.pw_dir
    userhome = userhome.rstrip('/')
    return (userhome + path[i:]) or '/'


# Expand paths containing shell variable substitutions.
# This expands the forms $variable and ${variable} only.
# Non-existent variables are left unchanged.

_varprog = None
_uvarprog = None

def expandvars(path):
    """Expand shell variables of form $var and ${var}.  Unknown variables
    are left unchanged."""
    global _varprog, _uvarprog
    if '$' not in path:
        return path
    if isinstance(path, _unicode):
        if not _uvarprog:
            import re
            _uvarprog = re.compile(ur'\$(\w+|\{[^}]*\})', re.UNICODE)
        varprog = _uvarprog
        encoding = sys.getfilesystemencoding()
    else:
        if not _varprog:
            import re
            _varprog = re.compile(r'\$(\w+|\{[^}]*\})')
        varprog = _varprog
        encoding = None
    i = 0
    while True:
        m = varprog.search(path, i)
        if not m:
            break
        i, j = m.span(0)
        name = m.group(1)
        if name.startswith('{') and name.endswith('}'):
            name = name[1:-1]
        if encoding:
            name = name.encode(encoding)
        if name in os.environ:
            tail = path[j:]
            value = os.environ[name]
            if encoding:
                value = value.decode(encoding)
            path = path[:i] + value
            i = len(path)
            path += tail
        else:
            i = j
    return path


# Normalize a path, e.g. A//B, A/./B and A/foo/../B all become A/B.
# It should be understood that this may change the meaning of the path
# if it contains symbolic links!

def normpath(path):
    """Normalize path, eliminating double slashes, etc."""
    # Preserve unicode (if path is unicode)
    slash, dot = (u'/', u'.') if isinstance(path, _unicode) else ('/', '.')
    if path == '':
        return dot
    initial_slashes = path.startswith('/')
    # POSIX allows one or two initial slashes, but treats three or more
    # as single slash.
    if (initial_slashes and
        path.startswith('//') and not path.startswith('///')):
        initial_slashes = 2
    comps = path.split('/')
    new_comps = []
    for comp in comps:
        if comp in ('', '.'):
            continue
        if (comp != '..' or (not initial_slashes and not new_comps) or
             (new_comps and new_comps[-1] == '..')):
            new_comps.append(comp)
        elif new_comps:
            new_comps.pop()
    comps = new_comps
    path = slash.join(comps)
    if initial_slashes:
        path = slash*initial_slashes + path
    return path or dot


def abspath(path):
    """Return an absolute path."""
    if not isabs(path):
        if isinstance(path, _unicode):
            cwd = os.getcwdu()
        else:
            cwd = os.getcwd()
        path = join(cwd, path)
    return normpath(path)


# Return a canonical path (i.e. the absolute location of a file on the
# filesystem).

def realpath(filename):
    """Return the canonical path of the specified filename, eliminating any
symbolic links encountered in the path."""
    path, ok = _joinrealpath('', filename, {})
    return abspath(path)

# Join two paths, normalizing and eliminating any symbolic links
# encountered in the second path.
def _joinrealpath(path, rest, seen):
    if isabs(rest):
        rest = rest[1:]
        path = sep

    while rest:
        name, _, rest = rest.partition(sep)
        if not name or name == curdir:
            # current dir
            continue
        if name == pardir:
            # parent dir
            if path:
                path, name = split(path)
                if name == pardir:
                    path = join(path, pardir, pardir)
            else:
                path = pardir
            continue
        newpath = join(path, name)
        if not islink(newpath):
            path = newpath
            continue
        # Resolve the symbolic link
        if newpath in seen:
            # Already seen this path
            path = seen[newpath]
            if path is not None:
                # use cached value
                continue
            # The symlink is not resolved, so we must have a symlink loop.
            # Return already resolved part + rest of the path unchanged.
            return join(newpath, rest), False
        seen[newpath] = None # not resolved symlink
        path, ok = _joinrealpath(path, os.readlink(newpath), seen)
        if not ok:
            return join(path, rest), False
        seen[newpath] = path # resolved symlink

    return path, True


supports_unicode_filenames = (sys.platform == 'darwin')

def relpath(path, start=curdir):
    """Return a relative version of a path"""

    if not path:
        raise ValueError("no path specified")

    start_list = [x for x in abspath(start).split(sep) if x]
    path_list = [x for x in abspath(path).split(sep) if x]

    # Work out how much of the filepath is shared by start and path.
    i = len(commonprefix([start_list, path_list]))

    rel_list = [pardir] * (len(start_list)-i) + path_list[i:]
    if not rel_list:
        return curdir
    return join(*rel_list)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ó
Ó«[c        &   @   sû  d  Z  d d l Z d d l Z d d l Z d d l Z d d l Z d d l Td d l m Z d d d d d	 d
 d d d d d d d d d d d d d d d d d d d d d d  d! d" d# d$ d% d& d' d( d) d* g& Z d+ Z d, Z	 d+ Z
 d- Z d. Z d/ Z d Z d0 Z d1 „  Z d2 „  Z d3 „  Z d4 „  Z d5 „  Z e j j  e _  d6 „  Z d7 „  Z d8 „  Z d9 „  Z d: „  Z d; „  Z d< „  Z d= „  Z d> „  Z d? „  Z  d@ „  Z! d a" d a# dA „  Z$ dB „  Z% dC „  Z& dD „  Z' dE „  Z( e j) dF k Z* e dG „ Z+ d S(H   sç  Common operations on Posix pathnames.

Instead of importing this module directly, import os and refer to
this module as os.path.  The "os.path" name is an alias for this
module on Posix systems; on other systems (e.g. Mac, Windows),
os.path provides the same operations in a manner specific to that
platform, and is an alias to another module (e.g. macpath, ntpath).

Some of this can actually be useful on non-Posix systems too, e.g.
for manipulation of the pathname component of URLs.
iÿÿÿÿN(   t   *(   t   _unicodet   normcaset   isabst   joint
   splitdrivet   splitt   splitextt   basenamet   dirnamet   commonprefixt   getsizet   getmtimet   getatimet   getctimet   islinkt   existst   lexistst   isdirt   isfilet   ismountt   walkt
   expandusert
   expandvarst   normpatht   abspatht   samefilet   sameopenfilet   samestatt   curdirt   pardirt   sept   pathsept   defpatht   altsept   extsept   devnullt   realpatht   supports_unicode_filenamest   relpatht   .s   ..t   /t   :s   :/bin:/usr/bins	   /dev/nullc         C   s   |  S(   s6   Normalize case of pathname.  Has no effect under Posix(    (   t   s(    (    s   /usr/lib/python2.7/posixpath.pyR   ,   s    c         C   s   |  j  d ƒ S(   s   Test whether a path is absoluteR)   (   t
   startswith(   R+   (    (    s   /usr/lib/python2.7/posixpath.pyR   4   s    c         G   si   |  } x\ | D]T } | j  d ƒ r+ | } q | d k sF | j d ƒ rS | | 7} q | d | 7} q W| S(   sæ   Join two or more pathname components, inserting '/' as needed.
    If any component is an absolute path, all previous path components
    will be discarded.  An empty last part will result in a path that
    ends with a separator.R)   t    (   R,   t   endswith(   t   at   pt   patht   b(    (    s   /usr/lib/python2.7/posixpath.pyR   =   s    	c         C   s`   |  j  d ƒ d } |  |  |  | } } | rV | d t | ƒ k rV | j d ƒ } n  | | f S(   s€   Split a pathname.  Returns tuple "(head, tail)" where "tail" is
    everything after the final slash.  Either part may be empty.R)   i   (   t   rfindt   lent   rstrip(   R0   t   it   headt   tail(    (    s   /usr/lib/python2.7/posixpath.pyR   R   s
    c         C   s   t  j |  t t t ƒ S(   N(   t   genericpatht	   _splitextR   R"   R#   (   R0   (    (    s   /usr/lib/python2.7/posixpath.pyR   a   s    c         C   s
   d |  f S(   sJ   Split a pathname into drive and path. On Posix, drive is always
    empty.R-   (    (   R0   (    (    s   /usr/lib/python2.7/posixpath.pyR   h   s    c         C   s   |  j  d ƒ d } |  | S(   s)   Returns the final component of a pathnameR)   i   (   R3   (   R0   R6   (    (    s   /usr/lib/python2.7/posixpath.pyR   p   s    c         C   sO   |  j  d ƒ d } |  |  } | rK | d t | ƒ k rK | j d ƒ } n  | S(   s-   Returns the directory component of a pathnameR)   i   (   R3   R4   R5   (   R0   R6   R7   (    (    s   /usr/lib/python2.7/posixpath.pyR	   x   s
    
c         C   sA   y t  j |  ƒ } Wn t  j t f k
 r0 t SXt j | j ƒ S(   s&   Test whether a path is a symbolic link(   t   ost   lstatt   errort   AttributeErrort   Falset   statt   S_ISLNKt   st_mode(   R1   t   st(    (    s   /usr/lib/python2.7/posixpath.pyR   „   s
    c         C   s-   y t  j |  ƒ Wn t  j k
 r( t SXt S(   sC   Test whether a path exists.  Returns True for broken symbolic links(   R;   R<   R=   R?   t   True(   R1   (    (    s   /usr/lib/python2.7/posixpath.pyR   Ž   s
    c         C   s+   t  j |  ƒ } t  j | ƒ } t | | ƒ S(   s9   Test whether two pathnames reference the same actual file(   R;   R@   R   (   t   f1t   f2t   s1t   s2(    (    s   /usr/lib/python2.7/posixpath.pyR   ™   s    c         C   s+   t  j |  ƒ } t  j | ƒ } t | | ƒ S(   s:   Test whether two open file objects reference the same file(   R;   t   fstatR   (   t   fp1t   fp2RG   RH   (    (    s   /usr/lib/python2.7/posixpath.pyR   £   s    c         C   s"   |  j  | j  k o! |  j | j k S(   s5   Test whether two stat buffers reference the same file(   t   st_inot   st_dev(   RG   RH   (    (    s   /usr/lib/python2.7/posixpath.pyR   ­   s    c         C   s¡   t  |  ƒ r t Sy1 t j |  ƒ } t j t t |  d ƒ ƒ ƒ } Wn t j k
 rX t SX| j } | j } | | k r{ t S| j	 } | j	 } | | k r t St S(   s$   Test whether a path is a mount points   ..(
   R   R?   R;   R<   R%   R   R=   RM   RD   RL   (   R1   RG   RH   t   dev1t   dev2t   ino1t   ino2(    (    s   /usr/lib/python2.7/posixpath.pyR   ¶   s     "				c         C   sÄ   t  j d d d ƒy t j |  ƒ } Wn t j k
 r= d SX| | |  | ƒ xo | D]g } t |  | ƒ } y t j | ƒ } Wn t j k
 r– qU n Xt j | j	 ƒ rU t
 | | | ƒ qU qU Wd S(   sI  Directory tree walk with callback function.

    For each directory in the directory tree rooted at top (including top
    itself, but excluding '.' and '..'), call func(arg, dirname, fnames).
    dirname is the name of the directory, and fnames a list of the names of
    the files and subdirectories in dirname (excluding '.' and '..').  func
    may modify the fnames list in-place (e.g. via del or slice assignment),
    and walk will only recurse into the subdirectories whose names remain in
    fnames; this can be used to implement a filter, or to impose a specific
    order of visiting.  No semantics are defined for, or required of, arg,
    beyond that arg is always passed to func.  It can be used, e.g., to pass
    a filename pattern, or a mutable object designed to accumulate
    statistics.  Passing None for arg is common.s4   In 3.x, os.path.walk is removed in favor of os.walk.t
   stackleveli   N(   t   warningst   warnpy3kR;   t   listdirR=   R   R<   R@   t   S_ISDIRRB   R   (   t   topt   funct   argt   namest   nameRC   (    (    s   /usr/lib/python2.7/posixpath.pyR   Ó   s    c         C   s÷   |  j  d ƒ s |  S|  j d d ƒ } | d k  r@ t |  ƒ } n  | d k r’ d t j k r‚ d d l } | j t j ƒ  ƒ j } qÖ t j d } nD d d l } y | j	 |  d | !ƒ } Wn t
 k
 rÌ |  SX| j } | j d ƒ } | |  | pö d S(   sO   Expand ~ and ~user constructions.  If user or $HOME is unknown,
    do nothing.t   ~R)   i   i    t   HOMEiÿÿÿÿN(   R,   t   findR4   R;   t   environt   pwdt   getpwuidt   getuidt   pw_dirt   getpwnamt   KeyErrorR5   (   R1   R6   R`   t   userhomet   pwent(    (    s   /usr/lib/python2.7/posixpath.pyR   û   s$    	c   
      C   s–  d |  k r |  St  |  t ƒ r^ t sI d d l } | j d | j ƒ a n  t } t j ƒ  } n0 t s‚ d d l } | j d ƒ a n  t } d } d } xû t
 r‘| j |  | ƒ } | s¹ Pn  | j d ƒ \ } } | j d ƒ } | j d ƒ r| j d	 ƒ r| d d !} n  | r#| j | ƒ } n  | t j k rˆ|  | } t j | }	 | ra|	 j | ƒ }	 n  |  |  |	 }  t |  ƒ } |  | 7}  q— | } q— W|  S(
   sZ   Expand shell variables of form $var and ${var}.  Unknown variables
    are left unchanged.t   $iÿÿÿÿNu   \$(\w+|\{[^}]*\})s   \$(\w+|\{[^}]*\})i    i   t   {t   }(   t
   isinstanceR   t	   _uvarprogt   ret   compilet   UNICODEt   syst   getfilesystemencodingt   _varprogt   NoneRD   t   searcht   spant   groupR,   R.   t   encodeR;   R_   t   decodeR4   (
   R1   Rm   t   varprogt   encodingR6   t   mt   jR[   R8   t   value(    (    s   /usr/lib/python2.7/posixpath.pyR     sD    	

c         C   s/  t  |  t ƒ r d n d \ } } |  d k r1 | S|  j d ƒ } | rn |  j d ƒ rn |  j d ƒ rn d } n  |  j d ƒ } g  } xs | D]k } | d k r¢ qŠ n  | d	 k sÒ | r¼ | sÒ | râ | d
 d	 k râ | j | ƒ qŠ | rŠ | j ƒ  qŠ qŠ W| } | j | ƒ }  | r%| | |  }  n  |  p.| S(   s0   Normalize path, eliminating double slashes, etc.u   /u   .R)   R(   R-   s   //s   ///i   s   ..iÿÿÿÿ(   u   /u   .(   R)   R(   (   R-   R(   (   Rk   R   R,   R   t   appendt   popR   (   R1   t   slasht   dott   initial_slashest   compst	   new_compst   comp(    (    s   /usr/lib/python2.7/posixpath.pyR   I  s,    !	c         C   sR   t  |  ƒ sH t |  t ƒ r* t j ƒ  } n t j ƒ  } t | |  ƒ }  n  t |  ƒ S(   s   Return an absolute path.(   R   Rk   R   R;   t   getcwdut   getcwdR   R   (   R1   t   cwd(    (    s   /usr/lib/python2.7/posixpath.pyR   f  s    c         C   s"   t  d |  i  ƒ \ } } t | ƒ S(   sl   Return the canonical path of the specified filename, eliminating any
symbolic links encountered in the path.R-   (   t   _joinrealpathR   (   t   filenameR1   t   ok(    (    s   /usr/lib/python2.7/posixpath.pyR%   t  s    c         C   sk  t  | ƒ r | d } t }  n  x?| r`| j t ƒ \ } } } | s" | t k rY q" n  | t k r­ |  r¡ t |  ƒ \ }  } | t k r§ t |  t t ƒ }  q§ q" t }  q" n  t |  | ƒ } t | ƒ sÔ | }  q" n  | | k r| | }  |  d  k	 rü q" n  t | | ƒ t	 f Sd  | | <t
 |  t j | ƒ | ƒ \ }  } | sSt |  | ƒ t	 f S|  | | <q" W|  t f S(   Ni   (   R   R   t	   partitionR   R   R   R   R   Rs   R?   R‰   R;   t   readlinkRD   (   R1   t   restt   seenR[   t   _t   newpathR‹   (    (    s   /usr/lib/python2.7/posixpath.pyR‰   |  s:    
		

!t   darwinc         C   s¼   |  s t  d ƒ ‚ n  g  t | ƒ j t ƒ D] } | r+ | ^ q+ } g  t |  ƒ j t ƒ D] } | rY | ^ qY } t t | | g ƒ ƒ } t g t | ƒ | | | } | s² t St | Œ  S(   s#   Return a relative version of a paths   no path specified(	   t
   ValueErrorR   R   R   R4   R
   R   R   R   (   R1   t   startt   xt
   start_listt	   path_listR6   t   rel_list(    (    s   /usr/lib/python2.7/posixpath.pyR'   ¨  s    ..(,   t   __doc__R;   Rp   R@   R9   RS   R   t   __all__R   R   R#   R   R    R!   Rs   R"   R$   R   R   R   R   R   R:   R   R   R	   R   R   R   R   R   R   R   R   Rr   Rl   R   R   R   R%   R‰   t   platformR&   R'   (    (    (    s   /usr/lib/python2.7/posixpath.pyt   <module>   s`   
											
		
	
				(		.				*                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       #  Author:      Fred L. Drake, Jr.
#               fdrake@acm.org
#
#  This is a simple little module I wrote to make life easier.  I didn't
#  see anything quite like it in the library, though I may have overlooked
#  something.  I wrote this when I was trying to read some heavily nested
#  tuples with fairly non-descriptive content.  This is modeled very much
#  after Lisp/Scheme - style pretty-printing of lists.  If you find it
#  useful, thank small children who sleep at night.

"""Support to pretty-print lists, tuples, & dictionaries recursively.

Very simple, but useful, especially in debugging data structures.

Classes
-------

PrettyPrinter()
    Handle pretty-printing operations onto a stream using a configured
    set of formatting parameters.

Functions
---------

pformat()
    Format a Python object into a pretty-printed representation.

pprint()
    Pretty-print a Python object to a stream [default is sys.stdout].

saferepr()
    Generate a 'standard' repr()-like value, but protect against recursive
    data structures.

"""

import sys as _sys
import warnings

try:
    from cStringIO import StringIO as _StringIO
except ImportError:
    from StringIO import StringIO as _StringIO

__all__ = ["pprint","pformat","isreadable","isrecursive","saferepr",
           "PrettyPrinter"]

# cache these for faster access:
_commajoin = ", ".join
_id = id
_len = len
_type = type


def pprint(object, stream=None, indent=1, width=80, depth=None):
    """Pretty-print a Python object to a stream [default is sys.stdout]."""
    printer = PrettyPrinter(
        stream=stream, indent=indent, width=width, depth=depth)
    printer.pprint(object)

def pformat(object, indent=1, width=80, depth=None):
    """Format a Python object into a pretty-printed representation."""
    return PrettyPrinter(indent=indent, width=width, depth=depth).pformat(object)

def saferepr(object):
    """Version of repr() which can handle recursive data structures."""
    return _safe_repr(object, {}, None, 0)[0]

def isreadable(object):
    """Determine if saferepr(object) is readable by eval()."""
    return _safe_repr(object, {}, None, 0)[1]

def isrecursive(object):
    """Determine if object requires a recursive representation."""
    return _safe_repr(object, {}, None, 0)[2]

def _sorted(iterable):
    with warnings.catch_warnings():
        if _sys.py3kwarning:
            warnings.filterwarnings("ignore", "comparing unequal types "
                                    "not supported", DeprecationWarning)
        return sorted(iterable)

class PrettyPrinter:
    def __init__(self, indent=1, width=80, depth=None, stream=None):
        """Handle pretty printing operations onto a stream using a set of
        configured parameters.

        indent
            Number of spaces to indent for each level of nesting.

        width
            Attempted maximum number of columns in the output.

        depth
            The maximum depth to print out nested structures.

        stream
            The desired output stream.  If omitted (or false), the standard
            output stream available at construction will be used.

        """
        indent = int(indent)
        width = int(width)
        assert indent >= 0, "indent must be >= 0"
        assert depth is None or depth > 0, "depth must be > 0"
        assert width, "width must be != 0"
        self._depth = depth
        self._indent_per_level = indent
        self._width = width
        if stream is not None:
            self._stream = stream
        else:
            self._stream = _sys.stdout

    def pprint(self, object):
        self._format(object, self._stream, 0, 0, {}, 0)
        self._stream.write("\n")

    def pformat(self, object):
        sio = _StringIO()
        self._format(object, sio, 0, 0, {}, 0)
        return sio.getvalue()

    def isrecursive(self, object):
        return self.format(object, {}, 0, 0)[2]

    def isreadable(self, object):
        s, readable, recursive = self.format(object, {}, 0, 0)
        return readable and not recursive

    def _format(self, object, stream, indent, allowance, context, level):
        level = level + 1
        objid = _id(object)
        if objid in context:
            stream.write(_recursion(object))
            self._recursive = True
            self._readable = False
            return
        rep = self._repr(object, context, level - 1)
        typ = _type(object)
        sepLines = _len(rep) > (self._width - 1 - indent - allowance)
        write = stream.write

        if self._depth and level > self._depth:
            write(rep)
            return

        r = getattr(typ, "__repr__", None)
        if issubclass(typ, dict) and r is dict.__repr__:
            write('{')
            if self._indent_per_level > 1:
                write((self._indent_per_level - 1) * ' ')
            length = _len(object)
            if length:
                context[objid] = 1
                indent = indent + self._indent_per_level
                items = _sorted(object.items())
                key, ent = items[0]
                rep = self._repr(key, context, level)
                write(rep)
                write(': ')
                self._format(ent, stream, indent + _len(rep) + 2,
                              allowance + 1, context, level)
                if length > 1:
                    for key, ent in items[1:]:
                        rep = self._repr(key, context, level)
                        if sepLines:
                            write(',\n%s%s: ' % (' '*indent, rep))
                        else:
                            write(', %s: ' % rep)
                        self._format(ent, stream, indent + _len(rep) + 2,
                                      allowance + 1, context, level)
                indent = indent - self._indent_per_level
                del context[objid]
            write('}')
            return

        if ((issubclass(typ, list) and r is list.__repr__) or
            (issubclass(typ, tuple) and r is tuple.__repr__) or
            (issubclass(typ, set) and r is set.__repr__) or
            (issubclass(typ, frozenset) and r is frozenset.__repr__)
           ):
            length = _len(object)
            if issubclass(typ, list):
                write('[')
                endchar = ']'
            elif issubclass(typ, tuple):
                write('(')
                endchar = ')'
            else:
                if not length:
                    write(rep)
                    return
                write(typ.__name__)
                write('([')
                endchar = '])'
                indent += len(typ.__name__) + 1
                object = _sorted(object)
            if self._indent_per_level > 1 and sepLines:
                write((self._indent_per_level - 1) * ' ')
            if length:
                context[objid] = 1
                indent = indent + self._indent_per_level
                self._format(object[0], stream, indent, allowance + 1,
                             context, level)
                if length > 1:
                    for ent in object[1:]:
                        if sepLines:
                            write(',\n' + ' '*indent)
                        else:
                            write(', ')
                        self._format(ent, stream, indent,
                                      allowance + 1, context, level)
                indent = indent - self._indent_per_level
                del context[objid]
            if issubclass(typ, tuple) and length == 1:
                write(',')
            write(endchar)
            return

        write(rep)

    def _repr(self, object, context, level):
        repr, readable, recursive = self.format(object, context.copy(),
                                                self._depth, level)
        if not readable:
            self._readable = False
        if recursive:
            self._recursive = True
        return repr

    def format(self, object, context, maxlevels, level):
        """Format object for a specific context, returning a string
        and flags indicating whether the representation is 'readable'
        and whether the object represents a recursive construct.
        """
        return _safe_repr(object, context, maxlevels, level)


# Return triple (repr_string, isreadable, isrecursive).

def _safe_repr(object, context, maxlevels, level):
    typ = _type(object)
    if typ is str:
        if 'locale' not in _sys.modules:
            return repr(object), True, False
        if "'" in object and '"' not in object:
            closure = '"'
            quotes = {'"': '\\"'}
        else:
            closure = "'"
            quotes = {"'": "\\'"}
        qget = quotes.get
        sio = _StringIO()
        write = sio.write
        for char in object:
            if char.isalpha():
                write(char)
            else:
                write(qget(char, repr(char)[1:-1]))
        return ("%s%s%s" % (closure, sio.getvalue(), closure)), True, False

    r = getattr(typ, "__repr__", None)
    if issubclass(typ, dict) and r is dict.__repr__:
        if not object:
            return "{}", True, False
        objid = _id(object)
        if maxlevels and level >= maxlevels:
            return "{...}", False, objid in context
        if objid in context:
            return _recursion(object), False, True
        context[objid] = 1
        readable = True
        recursive = False
        components = []
        append = components.append
        level += 1
        saferepr = _safe_repr
        for k, v in _sorted(object.items()):
            krepr, kreadable, krecur = saferepr(k, context, maxlevels, level)
            vrepr, vreadable, vrecur = saferepr(v, context, maxlevels, level)
            append("%s: %s" % (krepr, vrepr))
            readable = readable and kreadable and vreadable
            if krecur or vrecur:
                recursive = True
        del context[objid]
        return "{%s}" % _commajoin(components), readable, recursive

    if (issubclass(typ, list) and r is list.__repr__) or \
       (issubclass(typ, tuple) and r is tuple.__repr__):
        if issubclass(typ, list):
            if not object:
                return "[]", True, False
            format = "[%s]"
        elif _len(object) == 1:
            format = "(%s,)"
        else:
            if not object:
                return "()", True, False
            format = "(%s)"
        objid = _id(object)
        if maxlevels and level >= maxlevels:
            return format % "...", False, objid in context
        if objid in context:
            return _recursion(object), False, True
        context[objid] = 1
        readable = True
        recursive = False
        components = []
        append = components.append
        level += 1
        for o in object:
            orepr, oreadable, orecur = _safe_repr(o, context, maxlevels, level)
            append(orepr)
            if not oreadable:
                readable = False
            if orecur:
                recursive = True
        del context[objid]
        return format % _commajoin(components), readable, recursive

    rep = repr(object)
    return rep, (rep and not rep.startswith('<')), False


def _recursion(object):
    return ("<Recursion on %s with id=%s>"
            % (_type(object).__name__, _id(object)))


def _perfcheck(object=None):
    import time
    if object is None:
        object = [("string", (1, 2), [3, 4], {5: 6, 7: 8})] * 100000
    p = PrettyPrinter()
    t1 = time.time()
    _safe_repr(object, {}, None, 0)
    t2 = time.time()
    p.pformat(object)
    t3 = time.time()
    print "_safe_repr:", t2 - t1
    print "pformat:", t3 - t2

if __name__ == "__main__":
    _perfcheck()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ó
Ó«[c           @   s  d  Z  d d l Z d d l Z y d d l m Z Wn! e k
 rU d d l m Z n Xd d d d d d	 g Z d
 j	 Z
 e Z e Z e Z d d d d d „ Z d d d d „ Z d „  Z d „  Z d „  Z d „  Z d	 d d „  ƒ  YZ d „  Z d „  Z d d „ Z e d k re ƒ  n  d S(   s/  Support to pretty-print lists, tuples, & dictionaries recursively.

Very simple, but useful, especially in debugging data structures.

Classes
-------

PrettyPrinter()
    Handle pretty-printing operations onto a stream using a configured
    set of formatting parameters.

Functions
---------

pformat()
    Format a Python object into a pretty-printed representation.

pprint()
    Pretty-print a Python object to a stream [default is sys.stdout].

saferepr()
    Generate a 'standard' repr()-like value, but protect against recursive
    data structures.

iÿÿÿÿN(   t   StringIOt   pprintt   pformatt
   isreadablet   isrecursivet   safereprt   PrettyPrinters   , i   iP   c      	   C   s2   t  d | d | d | d | ƒ } | j |  ƒ d S(   sA   Pretty-print a Python object to a stream [default is sys.stdout].t   streamt   indentt   widtht   depthN(   R   R   (   t   objectR   R   R	   R
   t   printer(    (    s   /usr/lib/python2.7/pprint.pyR   7   s    c         C   s"   t  d | d | d | ƒ j |  ƒ S(   s<   Format a Python object into a pretty-printed representation.R   R	   R
   (   R   R   (   R   R   R	   R
   (    (    s   /usr/lib/python2.7/pprint.pyR   =   s    c         C   s   t  |  i  d d ƒ d S(   s=   Version of repr() which can handle recursive data structures.i    N(   t
   _safe_reprt   None(   R   (    (    s   /usr/lib/python2.7/pprint.pyR   A   s    c         C   s   t  |  i  d d ƒ d S(   s4   Determine if saferepr(object) is readable by eval().i    i   N(   R   R   (   R   (    (    s   /usr/lib/python2.7/pprint.pyR   E   s    c         C   s   t  |  i  d d ƒ d S(   s8   Determine if object requires a recursive representation.i    i   N(   R   R   (   R   (    (    s   /usr/lib/python2.7/pprint.pyR   I   s    c         C   s@   t  j ƒ  . t j r, t  j d d t ƒ n  t |  ƒ SWd  QXd  S(   Nt   ignores%   comparing unequal types not supported(   t   warningst   catch_warningst   _syst   py3kwarningt   filterwarningst   DeprecationWarningt   sorted(   t   iterable(    (    s   /usr/lib/python2.7/pprint.pyt   _sortedM   s
    	
c           B   s\   e  Z d  d d
 d
 d „ Z d „  Z d „  Z d „  Z d „  Z d „  Z d „  Z	 d	 „  Z
 RS(   i   iP   c         C   s©   t  | ƒ } t  | ƒ } | d k s0 t d ƒ ‚ | d k sT | d k sT t d ƒ ‚ | sf t d ƒ ‚ | |  _ | |  _ | |  _ | d k	 r™ | |  _ n t j |  _ d S(   sò  Handle pretty printing operations onto a stream using a set of
        configured parameters.

        indent
            Number of spaces to indent for each level of nesting.

        width
            Attempted maximum number of columns in the output.

        depth
            The maximum depth to print out nested structures.

        stream
            The desired output stream.  If omitted (or false), the standard
            output stream available at construction will be used.

        i    s   indent must be >= 0s   depth must be > 0s   width must be != 0N(	   t   intt   AssertionErrorR   t   _deptht   _indent_per_levelt   _widtht   _streamR   t   stdout(   t   selfR   R	   R
   R   (    (    s   /usr/lib/python2.7/pprint.pyt   __init__U   s    $			c         C   s3   |  j  | |  j d d i  d ƒ |  j j d ƒ d  S(   Ni    s   
(   t   _formatR   t   write(   R    R   (    (    s   /usr/lib/python2.7/pprint.pyR   t   s    c         C   s/   t  ƒ  } |  j | | d d i  d ƒ | j ƒ  S(   Ni    (   t	   _StringIOR"   t   getvalue(   R    R   t   sio(    (    s   /usr/lib/python2.7/pprint.pyR   x   s    	c         C   s   |  j  | i  d d ƒ d S(   Ni    i   (   t   format(   R    R   (    (    s   /usr/lib/python2.7/pprint.pyR   }   s    c         C   s,   |  j  | i  d d ƒ \ } } } | o+ | S(   Ni    (   R'   (   R    R   t   st   readablet	   recursive(    (    s   /usr/lib/python2.7/pprint.pyR   €   s    !c         C   sÒ  | d } t  | ƒ } | | k rK | j t | ƒ ƒ t |  _ t |  _ d  S|  j | | | d ƒ } t | ƒ }	 t	 | ƒ |  j
 d | | k }
 | j } |  j rÀ | |  j k rÀ | | ƒ d  St |	 d d  ƒ } t |	 t ƒ r„| t j k r„| d ƒ |  j d k r!| |  j d d ƒ n  t	 | ƒ } | rvd | | <| |  j } t | j ƒ  ƒ } | d \ } } |  j | | | ƒ } | | ƒ | d ƒ |  j | | | t	 | ƒ d | d | | ƒ | d k r_x | d D]~ \ } } |  j | | | ƒ } |
 r| d d | | f ƒ n | d	 | ƒ |  j | | | t	 | ƒ d | d | | ƒ qÚWn  | |  j } | | =n  | d
 ƒ d  St |	 t ƒ r¢| t j k süt |	 t ƒ rÀ| t j k süt |	 t ƒ rÞ| t j k süt |	 t ƒ rÄ| t j k rÄt	 | ƒ } t |	 t ƒ r*| d ƒ d } nv t |	 t ƒ rL| d ƒ d } nT | s`| | ƒ d  S| |	 j ƒ | d ƒ d } | t |	 j ƒ d 7} t | ƒ } |  j d k rÍ|
 rÍ| |  j d d ƒ n  | rŽd | | <| |  j } |  j | d | | | d | | ƒ | d k rwxZ | d D]K } |
 rF| d d | ƒ n
 | d ƒ |  j | | | | d | | ƒ q%Wn  | |  j } | | =n  t |	 t ƒ r¶| d k r¶| d ƒ n  | | ƒ d  S| | ƒ d  S(   Ni   t   __repr__t   {t    i    s   : i   s   ,
%s%s: s   , %s: t   }t   [t   ]t   (t   )s   ([s   ])s   ,
s   , t   ,(   t   _idR#   t
   _recursiont   Truet
   _recursivet   Falset	   _readablet   _reprt   _typet   _lenR   R   t   getattrR   t
   issubclasst   dictR+   R   R   t   itemsR"   t   listt   tuplet   sett	   frozensett   __name__t   len(   R    R   R   R   t	   allowancet   contextt   levelt   objidt   rept   typt   sepLinesR#   t   rt   lengthR@   t   keyt   entt   endchar(    (    s   /usr/lib/python2.7/pprint.pyR"   „   s¤    
		!	







	
	






c         C   sR   |  j  | | j ƒ  |  j | ƒ \ } } } | s< t |  _ n  | rN t |  _ n  | S(   N(   R'   t   copyR   R8   R9   R6   R7   (   R    R   RH   RI   t   reprR)   R*   (    (    s   /usr/lib/python2.7/pprint.pyR:   à   s    c         C   s   t  | | | | ƒ S(   sÈ   Format object for a specific context, returning a string
        and flags indicating whether the representation is 'readable'
        and whether the object represents a recursive construct.
        (   R   (   R    R   RH   t	   maxlevelsRI   (    (    s   /usr/lib/python2.7/pprint.pyR'   é   s    N(   RE   t
   __module__R   R!   R   R   R   R   R"   R:   R'   (    (    (    s   /usr/lib/python2.7/pprint.pyR   T   s   					\		c          C   s<  t  |  ƒ } | t k r d t j k r: t |  ƒ t t f Sd |  k rh d |  k rh d } i d d 6} n d } i d d 6} | j } t ƒ  } | j	 }	 xG |  D]? }
 |
 j
 ƒ  r¼ |	 |
 ƒ q |	 | |
 t |
 ƒ d d !ƒ ƒ q Wd | | j ƒ  | f t t f St | d	 d  ƒ } t | t ƒ r€| t j k r€|  sCd
 t t f St |  ƒ } | rt| | k rtd t | | k f S| | k r“t |  ƒ t t f Sd | | <t } t } g  } | j } | d 7} t } x— t |  j ƒ  ƒ D]ƒ \ } } | | | | | ƒ \ } } } | | | | | ƒ \ } } } | d | | f ƒ | oF| oF| } | sU| rÛt } qÛqÛW| | =d t | ƒ | | f St | t ƒ rž| t j k s¼t | t ƒ r| t j k rt | t ƒ rç|  sÞd t t f Sd } n4 t |  ƒ d k rd } n |  sd t t f Sd } t |  ƒ } | rP| | k rP| d t | | k f S| | k rot |  ƒ t t f Sd | | <t } t } g  } | j } | d 7} xT |  D]L } t | | | | ƒ \ } } } | | ƒ | sât } n  | r¥t } q¥q¥W| | =| t | ƒ | | f St |  ƒ } | | o5| j d ƒ t f S(   Nt   localet   't   "s   \"s   \'i   iÿÿÿÿs   %s%s%sR+   s   {}s   {...}s   %s: %ss   {%s}s   []s   [%s]s   (%s,)s   ()s   (%s)s   ...t   <(   R;   t   strR   t   modulesRT   R6   R8   t   getR$   R#   t   isalphaR%   R=   R   R>   R?   R+   R4   R5   t   appendR   R   R@   t
   _commajoinRA   RB   R<   t
   startswith(    R   RH   RU   RI   RL   t   closuret   quotest   qgetR&   R#   t   charRN   RJ   R)   R*   t
   componentsR_   R   t   kt   vt   kreprt	   kreadablet   krecurt   vreprt	   vreadablet   vrecurR'   t   ot   oreprt	   oreadablet   orecurRK   (    (    s   /usr/lib/python2.7/pprint.pyR   ó   s–    			$ 
	
		
	

	c         C   s   d t  |  ƒ j t |  ƒ f S(   Ns   <Recursion on %s with id=%s>(   R;   RE   R4   (   R   (    (    s   /usr/lib/python2.7/pprint.pyR5   G  s    c         C   s³   d d  l  } |  d  k rH d d d d g i d d 6d	 d
 6f g d }  n  t ƒ  } | j  ƒ  } t |  i  d  d ƒ | j  ƒ  } | j |  ƒ | j  ƒ  } d G| | GHd G| | GHd  S(   Niÿÿÿÿt   stringi   i   i   i   i   i   i   i   i † i    s   _safe_repr:s   pformat:(   i   i   (   t   timeR   R   R   R   (   R   Rt   t   pt   t1t   t2t   t3(    (    s   /usr/lib/python2.7/pprint.pyt
   _perfcheckL  s    0	t   __main__(    (   t   __doc__t   sysR   R   t	   cStringIOR    R$   t   ImportErrort   __all__t   joinR`   t   idR4   RF   R<   t   typeR;   R   R   R   R   R   R   R   R   R   R5   Ry   RE   (    (    (    s   /usr/lib/python2.7/pprint.pyt   <module>#   s0   						Ÿ	T	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    #! /usr/bin/python2.7
#
# Class for profiling python code. rev 1.0  6/2/94
#
# Written by James Roskind
# Based on prior profile module by Sjoerd Mullender...
#   which was hacked somewhat by: Guido van Rossum

"""Class for profiling Python code."""

# Copyright Disney Enterprises, Inc.  All Rights Reserved.
# Licensed to PSF under a Contributor Agreement
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
# either express or implied.  See the License for the specific language
# governing permissions and limitations under the License.


import sys
import os
import time
import marshal
from optparse import OptionParser

__all__ = ["run", "runctx", "help", "Profile"]

# Sample timer for use with
#i_count = 0
#def integer_timer():
#       global i_count
#       i_count = i_count + 1
#       return i_count
#itimes = integer_timer # replace with C coded timer returning integers

#**************************************************************************
# The following are the static member functions for the profiler class
# Note that an instance of Profile() is *not* needed to call them.
#**************************************************************************

def run(statement, filename=None, sort=-1):
    """Run statement under profiler optionally saving results in filename

    This function takes a single argument that can be passed to the
    "exec" statement, and an optional file name.  In all cases this
    routine attempts to "exec" its first argument and gather profiling
    statistics from the execution. If no file name is present, then this
    function automatically prints a simple profiling report, sorted by the
    standard name string (file/line/function-name) that is presented in
    each line.
    """
    prof = Profile()
    try:
        prof = prof.run(statement)
    except SystemExit:
        pass
    if filename is not None:
        prof.dump_stats(filename)
    else:
        return prof.print_stats(sort)

def runctx(statement, globals, locals, filename=None, sort=-1):
    """Run statement under profiler, supplying your own globals and locals,
    optionally saving results in filename.

    statement and filename have the same semantics as profile.run
    """
    prof = Profile()
    try:
        prof = prof.runctx(statement, globals, locals)
    except SystemExit:
        pass

    if filename is not None:
        prof.dump_stats(filename)
    else:
        return prof.print_stats(sort)

# Backwards compatibility.
def help():
    print "Documentation for the profile module can be found "
    print "in the Python Library Reference, section 'The Python Profiler'."

if hasattr(os, "times"):
    def _get_time_times(timer=os.times):
        t = timer()
        return t[0] + t[1]

# Using getrusage(3) is better than clock(3) if available:
# on some systems (e.g. FreeBSD), getrusage has a higher resolution
# Furthermore, on a POSIX system, returns microseconds, which
# wrap around after 36min.
_has_res = 0
try:
    import resource
    resgetrusage = lambda: resource.getrusage(resource.RUSAGE_SELF)
    def _get_time_resource(timer=resgetrusage):
        t = timer()
        return t[0] + t[1]
    _has_res = 1
except ImportError:
    pass

class Profile:
    """Profiler class.

    self.cur is always a tuple.  Each such tuple corresponds to a stack
    frame that is currently active (self.cur[-2]).  The following are the
    definitions of its members.  We use this external "parallel stack" to
    avoid contaminating the program that we are profiling. (old profiler
    used to write into the frames local dictionary!!) Derived classes
    can change the definition of some entries, as long as they leave
    [-2:] intact (frame and previous tuple).  In case an internal error is
    detected, the -3 element is used as the function name.

    [ 0] = Time that needs to be charged to the parent frame's function.
           It is used so that a function call will not have to access the
           timing data for the parent frame.
    [ 1] = Total time spent in this frame's function, excluding time in
           subfunctions (this latter is tallied in cur[2]).
    [ 2] = Total time spent in subfunctions, excluding time executing the
           frame's function (this latter is tallied in cur[1]).
    [-3] = Name of the function that corresponds to this frame.
    [-2] = Actual frame that we correspond to (used to sync exception handling).
    [-1] = Our parent 6-tuple (corresponds to frame.f_back).

    Timing data for each function is stored as a 5-tuple in the dictionary
    self.timings[].  The index is always the name stored in self.cur[-3].
    The following are the definitions of the members:

    [0] = The number of times this function was called, not counting direct
          or indirect recursion,
    [1] = Number of times this function appears on the stack, minus one
    [2] = Total time spent internal to this function
    [3] = Cumulative time that this function was present on the stack.  In
          non-recursive functions, this is the total execution time from start
          to finish of each invocation of a function, including time spent in
          all subfunctions.
    [4] = A dictionary indicating for each function name, the number of times
          it was called by us.
    """

    bias = 0  # calibration constant

    def __init__(self, timer=None, bias=None):
        self.timings = {}
        self.cur = None
        self.cmd = ""
        self.c_func_name = ""

        if bias is None:
            bias = self.bias
        self.bias = bias     # Materialize in local dict for lookup speed.

        if not timer:
            if _has_res:
                self.timer = resgetrusage
                self.dispatcher = self.trace_dispatch
                self.get_time = _get_time_resource
            elif hasattr(time, 'clock'):
                self.timer = self.get_time = time.clock
                self.dispatcher = self.trace_dispatch_i
            elif hasattr(os, 'times'):
                self.timer = os.times
                self.dispatcher = self.trace_dispatch
                self.get_time = _get_time_times
            else:
                self.timer = self.get_time = time.time
                self.dispatcher = self.trace_dispatch_i
        else:
            self.timer = timer
            t = self.timer() # test out timer function
            try:
                length = len(t)
            except TypeError:
                self.get_time = timer
                self.dispatcher = self.trace_dispatch_i
            else:
                if length == 2:
                    self.dispatcher = self.trace_dispatch
                else:
                    self.dispatcher = self.trace_dispatch_l
                # This get_time() implementation needs to be defined
                # here to capture the passed-in timer in the parameter
                # list (for performance).  Note that we can't assume
                # the timer() result contains two values in all
                # cases.
                def get_time_timer(timer=timer, sum=sum):
                    return sum(timer())
                self.get_time = get_time_timer
        self.t = self.get_time()
        self.simulate_call('profiler')

    # Heavily optimized dispatch routine for os.times() timer

    def trace_dispatch(self, frame, event, arg):
        timer = self.timer
        t = timer()
        t = t[0] + t[1] - self.t - self.bias

        if event == "c_call":
            self.c_func_name = arg.__name__

        if self.dispatch[event](self, frame,t):
            t = timer()
            self.t = t[0] + t[1]
        else:
            r = timer()
            self.t = r[0] + r[1] - t # put back unrecorded delta

    # Dispatch routine for best timer program (return = scalar, fastest if
    # an integer but float works too -- and time.clock() relies on that).

    def trace_dispatch_i(self, frame, event, arg):
        timer = self.timer
        t = timer() - self.t - self.bias

        if event == "c_call":
            self.c_func_name = arg.__name__

        if self.dispatch[event](self, frame, t):
            self.t = timer()
        else:
            self.t = timer() - t  # put back unrecorded delta

    # Dispatch routine for macintosh (timer returns time in ticks of
    # 1/60th second)

    def trace_dispatch_mac(self, frame, event, arg):
        timer = self.timer
        t = timer()/60.0 - self.t - self.bias

        if event == "c_call":
            self.c_func_name = arg.__name__

        if self.dispatch[event](self, frame, t):
            self.t = timer()/60.0
        else:
            self.t = timer()/60.0 - t  # put back unrecorded delta

    # SLOW generic dispatch routine for timer returning lists of numbers

    def trace_dispatch_l(self, frame, event, arg):
        get_time = self.get_time
        t = get_time() - self.t - self.bias

        if event == "c_call":
            self.c_func_name = arg.__name__

        if self.dispatch[event](self, frame, t):
            self.t = get_time()
        else:
            self.t = get_time() - t # put back unrecorded delta

    # In the event handlers, the first 3 elements of self.cur are unpacked
    # into vrbls w/ 3-letter names.  The last two characters are meant to be
    # mnemonic:
    #     _pt  self.cur[0] "parent time"   time to be charged to parent frame
    #     _it  self.cur[1] "internal time" time spent directly in the function
    #     _et  self.cur[2] "external time" time spent in subfunctions

    def trace_dispatch_exception(self, frame, t):
        rpt, rit, ret, rfn, rframe, rcur = self.cur
        if (rframe is not frame) and rcur:
            return self.trace_dispatch_return(rframe, t)
        self.cur = rpt, rit+t, ret, rfn, rframe, rcur
        return 1


    def trace_dispatch_call(self, frame, t):
        if self.cur and frame.f_back is not self.cur[-2]:
            rpt, rit, ret, rfn, rframe, rcur = self.cur
            if not isinstance(rframe, Profile.fake_frame):
                assert rframe.f_back is frame.f_back, ("Bad call", rfn,
                                                       rframe, rframe.f_back,
                                                       frame, frame.f_back)
                self.trace_dispatch_return(rframe, 0)
                assert (self.cur is None or \
                        frame.f_back is self.cur[-2]), ("Bad call",
                                                        self.cur[-3])
        fcode = frame.f_code
        fn = (fcode.co_filename, fcode.co_firstlineno, fcode.co_name)
        self.cur = (t, 0, 0, fn, frame, self.cur)
        timings = self.timings
        if fn in timings:
            cc, ns, tt, ct, callers = timings[fn]
            timings[fn] = cc, ns + 1, tt, ct, callers
        else:
            timings[fn] = 0, 0, 0, 0, {}
        return 1

    def trace_dispatch_c_call (self, frame, t):
        fn = ("", 0, self.c_func_name)
        self.cur = (t, 0, 0, fn, frame, self.cur)
        timings = self.timings
        if fn in timings:
            cc, ns, tt, ct, callers = timings[fn]
            timings[fn] = cc, ns+1, tt, ct, callers
        else:
            timings[fn] = 0, 0, 0, 0, {}
        return 1

    def trace_dispatch_return(self, frame, t):
        if frame is not self.cur[-2]:
            assert frame is self.cur[-2].f_back, ("Bad return", self.cur[-3])
            self.trace_dispatch_return(self.cur[-2], 0)

        # Prefix "r" means part of the Returning or exiting frame.
        # Prefix "p" means part of the Previous or Parent or older frame.

        rpt, rit, ret, rfn, frame, rcur = self.cur
        rit = rit + t
        frame_total = rit + ret

        ppt, pit, pet, pfn, pframe, pcur = rcur
        self.cur = ppt, pit + rpt, pet + frame_total, pfn, pframe, pcur

        timings = self.timings
        cc, ns, tt, ct, callers = timings[rfn]
        if not ns:
            # This is the only occurrence of the function on the stack.
            # Else this is a (directly or indirectly) recursive call, and
            # its cumulative time will get updated when the topmost call to
            # it returns.
            ct = ct + frame_total
            cc = cc + 1

        if pfn in callers:
            callers[pfn] = callers[pfn] + 1  # hack: gather more
            # stats such as the amount of time added to ct courtesy
            # of this specific call, and the contribution to cc
            # courtesy of this call.
        else:
            callers[pfn] = 1

        timings[rfn] = cc, ns - 1, tt + rit, ct, callers

        return 1


    dispatch = {
        "call": trace_dispatch_call,
        "exception": trace_dispatch_exception,
        "return": trace_dispatch_return,
        "c_call": trace_dispatch_c_call,
        "c_exception": trace_dispatch_return,  # the C function returned
        "c_return": trace_dispatch_return,
        }


    # The next few functions play with self.cmd. By carefully preloading
    # our parallel stack, we can force the profiled result to include
    # an arbitrary string as the name of the calling function.
    # We use self.cmd as that string, and the resulting stats look
    # very nice :-).

    def set_cmd(self, cmd):
        if self.cur[-1]: return   # already set
        self.cmd = cmd
        self.simulate_call(cmd)

    class fake_code:
        def __init__(self, filename, line, name):
            self.co_filename = filename
            self.co_line = line
            self.co_name = name
            self.co_firstlineno = 0

        def __repr__(self):
            return repr((self.co_filename, self.co_line, self.co_name))

    class fake_frame:
        def __init__(self, code, prior):
            self.f_code = code
            self.f_back = prior

    def simulate_call(self, name):
        code = self.fake_code('profile', 0, name)
        if self.cur:
            pframe = self.cur[-2]
        else:
            pframe = None
        frame = self.fake_frame(code, pframe)
        self.dispatch['call'](self, frame, 0)

    # collect stats from pending stack, including getting final
    # timings for self.cmd frame.

    def simulate_cmd_complete(self):
        get_time = self.get_time
        t = get_time() - self.t
        while self.cur[-1]:
            # We *can* cause assertion errors here if
            # dispatch_trace_return checks for a frame match!
            self.dispatch['return'](self, self.cur[-2], t)
            t = 0
        self.t = get_time() - t


    def print_stats(self, sort=-1):
        import pstats
        pstats.Stats(self).strip_dirs().sort_stats(sort). \
                  print_stats()

    def dump_stats(self, file):
        f = open(file, 'wb')
        self.create_stats()
        marshal.dump(self.stats, f)
        f.close()

    def create_stats(self):
        self.simulate_cmd_complete()
        self.snapshot_stats()

    def snapshot_stats(self):
        self.stats = {}
        for func, (cc, ns, tt, ct, callers) in self.timings.iteritems():
            callers = callers.copy()
            nc = 0
            for callcnt in callers.itervalues():
                nc += callcnt
            self.stats[func] = cc, nc, tt, ct, callers


    # The following two methods can be called by clients to use
    # a profiler to profile a statement, given as a string.

    def run(self, cmd):
        import __main__
        dict = __main__.__dict__
        return self.runctx(cmd, dict, dict)

    def runctx(self, cmd, globals, locals):
        self.set_cmd(cmd)
        sys.setprofile(self.dispatcher)
        try:
            exec cmd in globals, locals
        finally:
            sys.setprofile(None)
        return self

    # This method is more useful to profile a single function call.
    def runcall(self, func, *args, **kw):
        self.set_cmd(repr(func))
        sys.setprofile(self.dispatcher)
        try:
            return func(*args, **kw)
        finally:
            sys.setprofile(None)


    #******************************************************************
    # The following calculates the overhead for using a profiler.  The
    # problem is that it takes a fair amount of time for the profiler
    # to stop the stopwatch (from the time it receives an event).
    # Similarly, there is a delay from the time that the profiler
    # re-starts the stopwatch before the user's code really gets to
    # continue.  The following code tries to measure the difference on
    # a per-event basis.
    #
    # Note that this difference is only significant if there are a lot of
    # events, and relatively little user code per event.  For example,
    # code with small functions will typically benefit from having the
    # profiler calibrated for the current platform.  This *could* be
    # done on the fly during init() time, but it is not worth the
    # effort.  Also note that if too large a value specified, then
    # execution time on some functions will actually appear as a
    # negative number.  It is *normal* for some functions (with very
    # low call counts) to have such negative stats, even if the
    # calibration figure is "correct."
    #
    # One alternative to profile-time calibration adjustments (i.e.,
    # adding in the magic little delta during each event) is to track
    # more carefully the number of events (and cumulatively, the number
    # of events during sub functions) that are seen.  If this were
    # done, then the arithmetic could be done after the fact (i.e., at
    # display time).  Currently, we track only call/return events.
    # These values can be deduced by examining the callees and callers
    # vectors for each functions.  Hence we *can* almost correct the
    # internal time figure at print time (note that we currently don't
    # track exception event processing counts).  Unfortunately, there
    # is currently no similar information for cumulative sub-function
    # time.  It would not be hard to "get all this info" at profiler
    # time.  Specifically, we would have to extend the tuples to keep
    # counts of this in each frame, and then extend the defs of timing
    # tuples to include the significant two figures. I'm a bit fearful
    # that this additional feature will slow the heavily optimized
    # event/time ratio (i.e., the profiler would run slower, fur a very
    # low "value added" feature.)
    #**************************************************************

    def calibrate(self, m, verbose=0):
        if self.__class__ is not Profile:
            raise TypeError("Subclasses must override .calibrate().")

        saved_bias = self.bias
        self.bias = 0
        try:
            return self._calibrate_inner(m, verbose)
        finally:
            self.bias = saved_bias

    def _calibrate_inner(self, m, verbose):
        get_time = self.get_time

        # Set up a test case to be run with and without profiling.  Include
        # lots of calls, because we're trying to quantify stopwatch overhead.
        # Do not raise any exceptions, though, because we want to know
        # exactly how many profile events are generated (one call event, +
        # one return event, per Python-level call).

        def f1(n):
            for i in range(n):
                x = 1

        def f(m, f1=f1):
            for i in range(m):
                f1(100)

        f(m)    # warm up the cache

        # elapsed_noprofile <- time f(m) takes without profiling.
        t0 = get_time()
        f(m)
        t1 = get_time()
        elapsed_noprofile = t1 - t0
        if verbose:
            print "elapsed time without profiling =", elapsed_noprofile

        # elapsed_profile <- time f(m) takes with profiling.  The difference
        # is profiling overhead, only some of which the profiler subtracts
        # out on its own.
        p = Profile()
        t0 = get_time()
        p.runctx('f(m)', globals(), locals())
        t1 = get_time()
        elapsed_profile = t1 - t0
        if verbose:
            print "elapsed time with profiling =", elapsed_profile

        # reported_time <- "CPU seconds" the profiler charged to f and f1.
        total_calls = 0.0
        reported_time = 0.0
        for (filename, line, funcname), (cc, ns, tt, ct, callers) in \
                p.timings.items():
            if funcname in ("f", "f1"):
                total_calls += cc
                reported_time += tt

        if verbose:
            print "'CPU seconds' profiler reported =", reported_time
            print "total # calls =", total_calls
        if total_calls != m + 1:
            raise ValueError("internal error: total calls = %d" % total_calls)

        # reported_time - elapsed_noprofile = overhead the profiler wasn't
        # able to measure.  Divide by twice the number of calls (since there
        # are two profiler events per call in this test) to get the hidden
        # overhead per event.
        mean = (reported_time - elapsed_noprofile) / 2.0 / total_calls
        if verbose:
            print "mean stopwatch overhead per profile event =", mean
        return mean

#****************************************************************************
def Stats(*args):
    print 'Report generating functions are in the "pstats" module\a'

def main():
    usage = "profile.py [-o output_file_path] [-s sort] scriptfile [arg] ..."
    parser = OptionParser(usage=usage)
    parser.allow_interspersed_args = False
    parser.add_option('-o', '--outfile', dest="outfile",
        help="Save stats to <outfile>", default=None)
    parser.add_option('-s', '--sort', dest="sort",
        help="Sort order when printing to stdout, based on pstats.Stats class",
        default=-1)

    if not sys.argv[1:]:
        parser.print_usage()
        sys.exit(2)

    (options, args) = parser.parse_args()
    sys.argv[:] = args

    if len(args) > 0:
        progname = args[0]
        sys.path.insert(0, os.path.dirname(progname))
        with open(progname, 'rb') as fp:
            code = compile(fp.read(), progname, 'exec')
        globs = {
            '__file__': progname,
            '__name__': '__main__',
            '__package__': None,
        }
        runctx(code, globs, None, options.outfile, options.sort)
    else:
        parser.print_usage()
    return parser

# When invoked as main program, invoke the profiler on a script
if __name__ == '__main__':
    main()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   """Constants/functions for interpreting results of os.stat() and os.lstat().

Suggested usage: from stat import *
"""

# Indices for stat struct members in the tuple returned by os.stat()

ST_MODE  = 0
ST_INO   = 1
ST_DEV   = 2
ST_NLINK = 3
ST_UID   = 4
ST_GID   = 5
ST_SIZE  = 6
ST_ATIME = 7
ST_MTIME = 8
ST_CTIME = 9

# Extract bits from the mode

def S_IMODE(mode):
    return mode & 07777

def S_IFMT(mode):
    return mode & 0170000

# Constants used as S_IFMT() for various file types
# (not all are implemented on all systems)

S_IFDIR  = 0040000
S_IFCHR  = 0020000
S_IFBLK  = 0060000
S_IFREG  = 0100000
S_IFIFO  = 0010000
S_IFLNK  = 0120000
S_IFSOCK = 0140000

# Functions to test for each file type

def S_ISDIR(mode):
    return S_IFMT(mode) == S_IFDIR

def S_ISCHR(mode):
    return S_IFMT(mode) == S_IFCHR

def S_ISBLK(mode):
    return S_IFMT(mode) == S_IFBLK

def S_ISREG(mode):
    return S_IFMT(mode) == S_IFREG

def S_ISFIFO(mode):
    return S_IFMT(mode) == S_IFIFO

def S_ISLNK(mode):
    return S_IFMT(mode) == S_IFLNK

def S_ISSOCK(mode):
    return S_IFMT(mode) == S_IFSOCK

# Names for permission bits

S_ISUID = 04000
S_ISGID = 02000
S_ENFMT = S_ISGID
S_ISVTX = 01000
S_IREAD = 00400
S_IWRITE = 00200
S_IEXEC = 00100
S_IRWXU = 00700
S_IRUSR = 00400
S_IWUSR = 00200
S_IXUSR = 00100
S_IRWXG = 00070
S_IRGRP = 00040
S_IWGRP = 00020
S_IXGRP = 00010
S_IRWXO = 00007
S_IROTH = 00004
S_IWOTH = 00002
S_IXOTH = 00001

# Names for file flags

UF_NODUMP    = 0x00000001
UF_IMMUTABLE = 0x00000002
UF_APPEND    = 0x00000004
UF_OPAQUE    = 0x00000008
UF_NOUNLINK  = 0x00000010
UF_COMPRESSED = 0x00000020  # OS X: file is hfs-compressed
UF_HIDDEN    = 0x00008000   # OS X: file should not be displayed
SF_ARCHIVED  = 0x00010000
SF_IMMUTABLE = 0x00020000
SF_APPEND    = 0x00040000
SF_NOUNLINK  = 0x00100000
SF_SNAPSHOT  = 0x00200000
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ó
Ó«[c           @   s$  d  Z  d d l Z d d l Z d d l Z d d l Z d d l m Z d d d d g Z e d d „ Z	 e d d	 „ Z
 d
 „  Z e e d ƒ r  e j d „ Z n  d Z y+ d d l Z d „  Z e d „ Z d Z Wn e k
 rä n Xd f  d „  ƒ  YZ d „  Z d „  Z e d k r e ƒ  n  d S(   s    Class for profiling Python code.iÿÿÿÿN(   t   OptionParsert   runt   runctxt   helpt   Profilec         C   s]   t  ƒ  } y | j |  ƒ } Wn t k
 r/ n X| d k	 rL | j | ƒ n | j | ƒ Sd S(   s  Run statement under profiler optionally saving results in filename

    This function takes a single argument that can be passed to the
    "exec" statement, and an optional file name.  In all cases this
    routine attempts to "exec" its first argument and gather profiling
    statistics from the execution. If no file name is present, then this
    function automatically prints a simple profiling report, sorted by the
    standard name string (file/line/function-name) that is presented in
    each line.
    N(   R   R   t
   SystemExitt   Nonet
   dump_statst   print_stats(   t	   statementt   filenamet   sortt   prof(    (    s   /usr/lib/python2.7/profile.pyR   0   s    	c         C   sc   t  ƒ  } y | j |  | | ƒ } Wn t k
 r5 n X| d k	 rR | j | ƒ n | j | ƒ Sd S(   s·   Run statement under profiler, supplying your own globals and locals,
    optionally saving results in filename.

    statement and filename have the same semantics as profile.run
    N(   R   R   R   R   R   R   (   R	   t   globalst   localsR
   R   R   (    (    s   /usr/lib/python2.7/profile.pyR   E   s    	c           C   s   d GHd GHd  S(   Ns2   Documentation for the profile module can be found s?   in the Python Library Reference, section 'The Python Profiler'.(    (    (    (    s   /usr/lib/python2.7/profile.pyR   W   s    t   timesc         C   s   |  ƒ  } | d | d S(   Ni    i   (    (   t   timert   t(    (    s   /usr/lib/python2.7/profile.pyt   _get_time_times\   s    	i    c           C   s   t  j t  j ƒ S(   N(   t   resourcet	   getrusaget   RUSAGE_SELF(    (    (    s   /usr/lib/python2.7/profile.pyt   <lambda>g   s    c         C   s   |  ƒ  } | d | d S(   Ni    i   (    (   R   R   (    (    s   /usr/lib/python2.7/profile.pyt   _get_time_resourceh   s    	i   c           B   s3  e  Z d  Z d Z d" d" d „ Z d „  Z d „  Z d „  Z d „  Z	 d „  Z
 d „  Z d	 „  Z d
 „  Z i e d 6e
 d 6e d 6e d 6e d 6e d 6Z d „  Z d d# d „  ƒ  YZ d d$ d „  ƒ  YZ d „  Z d „  Z d d „ Z d „  Z d „  Z d „  Z d „  Z d „  Z d „  Z d d  „ Z d! „  Z RS(%   s  Profiler class.

    self.cur is always a tuple.  Each such tuple corresponds to a stack
    frame that is currently active (self.cur[-2]).  The following are the
    definitions of its members.  We use this external "parallel stack" to
    avoid contaminating the program that we are profiling. (old profiler
    used to write into the frames local dictionary!!) Derived classes
    can change the definition of some entries, as long as they leave
    [-2:] intact (frame and previous tuple).  In case an internal error is
    detected, the -3 element is used as the function name.

    [ 0] = Time that needs to be charged to the parent frame's function.
           It is used so that a function call will not have to access the
           timing data for the parent frame.
    [ 1] = Total time spent in this frame's function, excluding time in
           subfunctions (this latter is tallied in cur[2]).
    [ 2] = Total time spent in subfunctions, excluding time executing the
           frame's function (this latter is tallied in cur[1]).
    [-3] = Name of the function that corresponds to this frame.
    [-2] = Actual frame that we correspond to (used to sync exception handling).
    [-1] = Our parent 6-tuple (corresponds to frame.f_back).

    Timing data for each function is stored as a 5-tuple in the dictionary
    self.timings[].  The index is always the name stored in self.cur[-3].
    The following are the definitions of the members:

    [0] = The number of times this function was called, not counting direct
          or indirect recursion,
    [1] = Number of times this function appears on the stack, minus one
    [2] = Total time spent internal to this function
    [3] = Cumulative time that this function was present on the stack.  In
          non-recursive functions, this is the total execution time from start
          to finish of each invocation of a function, including time spent in
          all subfunctions.
    [4] = A dictionary indicating for each function name, the number of times
          it was called by us.
    i    c         C   s¥  i  |  _  d  |  _ d |  _ d |  _ | d  k r< |  j } n  | |  _ | sø t rr t |  _ |  j	 |  _
 t |  _ q…t t d ƒ r£ t j |  _ |  _ |  j |  _
 q…t t d ƒ rÖ t j |  _ |  j	 |  _
 t |  _ q…t j |  _ |  _ |  j |  _
 n | |  _ |  j ƒ  } y t | ƒ } Wn& t k
 rE| |  _ |  j |  _
 n@ X| d k ra|  j	 |  _
 n |  j |  _
 | t d „ } | |  _ |  j ƒ  |  _ |  j d ƒ d  S(   Nt    t   clockR   i   c         S   s   | |  ƒ  ƒ S(   N(    (   R   t   sum(    (    s   /usr/lib/python2.7/profile.pyt   get_time_timerÃ   s    t   profiler(   t   timingsR   t   curt   cmdt   c_func_namet   biast   _has_rest   resgetrusageR   t   trace_dispatcht
   dispatcherR   t   get_timet   hasattrt   timeR   t   trace_dispatch_it   osR   R   t   lent	   TypeErrort   trace_dispatch_lR   R   t   simulate_call(   t   selfR   R!   R   t   lengthR   (    (    s   /usr/lib/python2.7/profile.pyt   __init__˜   sF    									c         C   s­   |  j  } | ƒ  } | d | d |  j |  j } | d k rM | j |  _ n  |  j | |  | | ƒ r‡ | ƒ  } | d | d |  _ n" | ƒ  } | d | d | |  _ d  S(   Ni    i   t   c_call(   R   R   R!   t   __name__R    t   dispatch(   R/   t   framet   eventt   argR   R   t   r(    (    s   /usr/lib/python2.7/profile.pyR$   Ë   s    		 		c         C   sw   |  j  } | ƒ  |  j |  j } | d k r; | j |  _ n  |  j | |  | | ƒ rc | ƒ  |  _ n | ƒ  | |  _ d  S(   NR2   (   R   R   R!   R3   R    R4   (   R/   R5   R6   R7   R   R   (    (    s   /usr/lib/python2.7/profile.pyR)   Ý   s    	c         C   sƒ   |  j  } | ƒ  d |  j |  j } | d k r? | j |  _ n  |  j | |  | | ƒ rk | ƒ  d |  _ n | ƒ  d | |  _ d  S(   Ng      N@R2   (   R   R   R!   R3   R    R4   (   R/   R5   R6   R7   R   R   (    (    s   /usr/lib/python2.7/profile.pyt   trace_dispatch_macì   s    	c         C   sw   |  j  } | ƒ  |  j |  j } | d k r; | j |  _ n  |  j | |  | | ƒ rc | ƒ  |  _ n | ƒ  | |  _ d  S(   NR2   (   R&   R   R!   R3   R    R4   (   R/   R5   R6   R7   R&   R   (    (    s   /usr/lib/python2.7/profile.pyR-   ú   s    	c   	      C   s`   |  j  \ } } } } } } | | k	 r= | r= |  j | | ƒ S| | | | | | | f |  _  d S(   Ni   (   R   t   trace_dispatch_return(	   R/   R5   R   t   rptt   ritt   rett   rfnt   rframet   rcur(    (    s   /usr/lib/python2.7/profile.pyt   trace_dispatch_exception  s
    c         C   s€  |  j  rÖ | j |  j  d k	 rÖ |  j  \ } } } } } } t | t j ƒ sÖ | j | j k s‚ t d | | | j | | j f ƒ ‚ |  j | d ƒ |  j  d  k sÓ | j |  j  d k sÓ t d |  j  d f ƒ ‚ qÖ n  | j }	 |	 j	 |	 j
 |	 j f }
 | d d |
 | |  j  f |  _  |  j } |
 | k rc| |
 \ } } } } } | | d | | | f | |
 <n d d d d i  f | |
 <d S(   Niþÿÿÿs   Bad calli    iýÿÿÿi   (   R   t   f_backt
   isinstanceR   t
   fake_framet   AssertionErrorR:   R   t   f_codet   co_filenamet   co_firstlinenot   co_nameR   (   R/   R5   R   R;   R<   R=   R>   R?   R@   t   fcodet   fnR   t   cct   nst   ttt   ctt   callers(    (    s   /usr/lib/python2.7/profile.pyt   trace_dispatch_call  s&    			 c   
      C   s›   d d |  j  f } | d d | | |  j f |  _ |  j } | | k r~ | | \ } } } } }	 | | d | | |	 f | | <n d d d d i  f | | <d S(   NR   i    i   (   R    R   R   (
   R/   R5   R   RK   R   RL   RM   RN   RO   RP   (    (    s   /usr/lib/python2.7/profile.pyt   trace_dispatch_c_call+  s    	 c         C   sU  | |  j  d k	 r\ | |  j  d j k sB t d |  j  d f ƒ ‚ |  j |  j  d d ƒ n  |  j  \ } } } } } } | | } | | } | \ }	 }
 } } } } |	 |
 | | | | | | f |  _  |  j } | | \ } } } } } | s| | } | d } n  | | k r&| | d | | <n
 d | | <| | d | | | | f | | <d S(   Niþÿÿÿs
   Bad returniýÿÿÿi    i   (   R   RB   RE   R:   R   (   R/   R5   R   R;   R<   R=   R>   R@   t   frame_totalt   pptt   pitt   pett   pfnt   pframet   pcurR   RL   RM   RN   RO   RP   (    (    s   /usr/lib/python2.7/profile.pyR:   6  s$    /

#	

!t   callt	   exceptiont   returnR2   t   c_exceptiont   c_returnc         C   s+   |  j  d r d  S| |  _ |  j | ƒ d  S(   Niÿÿÿÿ(   R   R   R.   (   R/   R   (    (    s   /usr/lib/python2.7/profile.pyt   set_cmdl  s     	t	   fake_codec           B   s   e  Z d  „  Z d „  Z RS(   c         C   s(   | |  _  | |  _ | |  _ d |  _ d  S(   Ni    (   RG   t   co_lineRI   RH   (   R/   R
   t   linet   name(    (    s   /usr/lib/python2.7/profile.pyR1   r  s    			c         C   s   t  |  j |  j |  j f ƒ S(   N(   t   reprRG   Ra   RI   (   R/   (    (    s   /usr/lib/python2.7/profile.pyt   __repr__x  s    (   R3   t
   __module__R1   Re   (    (    (    s   /usr/lib/python2.7/profile.pyR`   q  s   	RD   c           B   s   e  Z d  „  Z RS(   c         C   s   | |  _  | |  _ d  S(   N(   RF   RB   (   R/   t   codet   prior(    (    s   /usr/lib/python2.7/profile.pyR1   |  s    	(   R3   Rf   R1   (    (    (    s   /usr/lib/python2.7/profile.pyRD   {  s   c         C   sa   |  j  d d | ƒ } |  j r. |  j d } n d  } |  j | | ƒ } |  j d |  | d ƒ d  S(   Nt   profilei    iþÿÿÿRZ   (   R`   R   R   RD   R4   (   R/   Rc   Rg   RX   R5   (    (    s   /usr/lib/python2.7/profile.pyR.   €  s    	c         C   se   |  j  } | ƒ  |  j } x5 |  j d rP |  j d |  |  j d | ƒ d } q W| ƒ  | |  _ d  S(   NiÿÿÿÿR\   iþÿÿÿi    (   R&   R   R   R4   (   R/   R&   R   (    (    s   /usr/lib/python2.7/profile.pyt   simulate_cmd_completeŒ  s    	
iÿÿÿÿc         C   s2   d d  l  } | j |  ƒ j ƒ  j | ƒ j ƒ  d  S(   Niÿÿÿÿ(   t   pstatst   Statst
   strip_dirst
   sort_statsR   (   R/   R   Rk   (    (    s   /usr/lib/python2.7/profile.pyR   —  s    c         C   s:   t  | d ƒ } |  j ƒ  t j |  j | ƒ | j ƒ  d  S(   Nt   wb(   t   opent   create_statst   marshalt   dumpt   statst   close(   R/   t   filet   f(    (    s   /usr/lib/python2.7/profile.pyR   œ  s    
c         C   s   |  j  ƒ  |  j ƒ  d  S(   N(   Rj   t   snapshot_stats(   R/   (    (    s   /usr/lib/python2.7/profile.pyRq   ¢  s    
c   	      C   s‹   i  |  _  x{ |  j j ƒ  D]j \ } \ } } } } } | j ƒ  } d } x | j ƒ  D] } | | 7} qS W| | | | | f |  j  | <q Wd  S(   Ni    (   Rt   R   t	   iteritemst   copyt
   itervalues(	   R/   t   funcRL   RM   RN   RO   RP   t   nct   callcnt(    (    s   /usr/lib/python2.7/profile.pyRx   ¦  s    	+c         C   s(   d d  l  } | j } |  j | | | ƒ S(   Niÿÿÿÿ(   t   __main__t   __dict__R   (   R/   R   R   t   dict(    (    s   /usr/lib/python2.7/profile.pyR   ³  s    	c         B   s@   |  j  | ƒ e j |  j ƒ z | | | UWd  e j d  ƒ X|  S(   N(   R_   t   syst
   setprofileR%   R   (   R/   R   R   R   (    (    s   /usr/lib/python2.7/profile.pyR   ¸  s    c         O   sI   |  j  t | ƒ ƒ t j |  j ƒ z | | | Ž  SWd  t j d  ƒ Xd  S(   N(   R_   Rd   R‚   Rƒ   R%   R   (   R/   R|   t   argst   kw(    (    s   /usr/lib/python2.7/profile.pyt   runcallÂ  s
    c         C   sU   |  j  t k	 r t d ƒ ‚ n  |  j } d |  _ z |  j | | ƒ SWd  | |  _ Xd  S(   Ns&   Subclasses must override .calibrate().i    (   t	   __class__R   R,   R!   t   _calibrate_inner(   R/   t   mt   verboset
   saved_bias(    (    s   /usr/lib/python2.7/profile.pyt	   calibrateó  s    		c         C   s}  |  j  } d „  } | d „ } | | ƒ | ƒ  } | | ƒ | ƒ  } | | } | r` d G| GHn  t ƒ  }	 | ƒ  } |	 j d t ƒ  t ƒ  ƒ | ƒ  } | | }
 | r° d G|
 GHn  d } d } xX |	 j j ƒ  D]G \ \ } } } \ } } } } } | d k rÌ | | 7} | | 7} qÌ qÌ W| r2d	 G| GHd
 G| GHn  | | d k rUt d | ƒ ‚ n  | | d | } | ryd G| GHn  | S(   Nc         S   s!   x t  |  ƒ D] } d } q Wd  S(   Ni   (   t   range(   t   nt   it   x(    (    s   /usr/lib/python2.7/profile.pyt   f1  s    c         S   s%   x t  |  ƒ D] } | d ƒ q Wd  S(   Nid   (   R   (   R‰   R‘   R   (    (    s   /usr/lib/python2.7/profile.pyRw     s    s    elapsed time without profiling =s   f(m)s   elapsed time with profiling =g        Rw   R‘   s!   'CPU seconds' profiler reported =s   total # calls =i   s    internal error: total calls = %dg       @s+   mean stopwatch overhead per profile event =(   Rw   R‘   (   R&   R   R   R   R   R   t   itemst
   ValueError(   R/   R‰   RŠ   R&   R‘   Rw   t   t0t   t1t   elapsed_noprofilet   pt   elapsed_profilet   total_callst   reported_timeR
   Rb   t   funcnameRL   RM   RN   RO   RP   t   mean(    (    s   /usr/lib/python2.7/profile.pyRˆ   þ  sB    		
	
	
			
1
	N(    (    (   R3   Rf   t   __doc__R!   R   R1   R$   R)   R9   R-   RA   RQ   RR   R:   R4   R_   R`   RD   R.   Rj   R   R   Rq   Rx   R   R   R†   RŒ   Rˆ   (    (    (    s   /usr/lib/python2.7/profile.pyR   o   s@   %3								&

	
							
	1c          G   s	   d GHd  S(   Ns7   Report generating functions are in the "pstats" module(    (   R„   (    (    s   /usr/lib/python2.7/profile.pyRl   =  s    c       	   C   sX  d }  t  d |  ƒ } t | _ | j d d d d d d d	 d  ƒ| j d
 d d d d d d	 d ƒt j d s‰ | j ƒ  t j d ƒ n  | j	 ƒ  \ } } | t j (t
 | ƒ d k rJ| d } t j j d t j j | ƒ ƒ t | d ƒ  } t | j ƒ  | d ƒ } Wd  QXi | d 6d d 6d  d 6} t | | d  | j | j ƒ n
 | j ƒ  | S(   Ns?   profile.py [-o output_file_path] [-s sort] scriptfile [arg] ...t   usages   -os	   --outfilet   destt   outfileR   s   Save stats to <outfile>t   defaults   -ss   --sortR   s?   Sort order when printing to stdout, based on pstats.Stats classiÿÿÿÿi   i   i    t   rbt   exect   __file__R   R3   t   __package__(   R    t   Falset   allow_interspersed_argst
   add_optionR   R‚   t   argvt   print_usaget   exitt
   parse_argsR+   t   patht   insertR*   t   dirnameRp   t   compilet   readR   R    R   (   Rž   t   parsert   optionsR„   t   prognamet   fpRg   t   globs(    (    s   /usr/lib/python2.7/profile.pyt   main@  s2    	




R   (   R   R‚   R*   R(   Rr   t   optparseR    t   __all__R   R   R   R   R'   R   R   R"   R   R#   R   t   ImportErrorR   Rl   R·   R3   (    (    (    s   /usr/lib/python2.7/profile.pyt   <module>	   s2   		
ÿ Ï		!      