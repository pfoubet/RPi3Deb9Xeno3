
     char *SvMp_name = (char *) (name);                     \
     I32 SvMp_namlen = (namlen);                            \
     if (SvMp_name && SvMp_namlen == 0)                     \
     {                                                      \
       MAGIC *mg;                                           \
       sv_magic(SvMp_sv, obj, how, 0, 0);                   \
       mg = SvMAGIC(SvMp_sv);                               \
       mg->mg_len = -42; /* XXX: this is the tricky part */ \
       mg->mg_ptr = SvMp_name;                              \
     }                                                      \
     else                                                   \
     {                                                      \
       sv_magic(SvMp_sv, obj, how, SvMp_name, SvMp_namlen); \
     }                                                      \
   } STMT_END

#else

#  define sv_magic_portable(a, b, c, d, e)  sv_magic(a, b, c, d, e)

#endif

#if !defined(mg_findext)
#if defined(NEED_mg_findext)
static MAGIC * DPPP_(my_mg_findext)(SV * sv, int type, const MGVTBL *vtbl);
static
#else
extern MAGIC * DPPP_(my_mg_findext)(SV * sv, int type, const MGVTBL *vtbl);
#endif

#define mg_findext DPPP_(my_mg_findext)
#define Perl_mg_findext DPPP_(my_mg_findext)

#if defined(NEED_mg_findext) || defined(NEED_mg_findext_GLOBAL)

MAGIC *
DPPP_(my_mg_findext)(SV * sv, int type, const MGVTBL *vtbl) {
    if (sv) {
        MAGIC *mg;

#ifdef AvPAD_NAMELIST
        assert(!(SvTYPE(sv) == SVt_PVAV && AvPAD_NAMELIST(sv)));
#endif

        for (mg = SvMAGIC (sv); mg; mg = mg->mg_moremagic) {
            if (mg->mg_type == type && mg->mg_virtual == vtbl)
                return mg;
        }
    }

    return NULL;
}

#endif
#endif

#if !defined(sv_unmagicext)
#if defined(NEED_sv_unmagicext)
static int DPPP_(my_sv_unmagicext)(pTHX_ SV * const sv, const int type, MGVTBL * vtbl);
static
#else
extern int DPPP_(my_sv_unmagicext)(pTHX_ SV * const sv, const int type, MGVTBL * vtbl);
#endif

#ifdef sv_unmagicext
#  undef sv_unmagicext
#endif
#define sv_unmagicext(a,b,c) DPPP_(my_sv_unmagicext)(aTHX_ a,b,c)
#define Perl_sv_unmagicext DPPP_(my_sv_unmagicext)

#if defined(NEED_sv_unmagicext) || defined(NEED_sv_unmagicext_GLOBAL)

int
DPPP_(my_sv_unmagicext)(pTHX_ SV *const sv, const int type, MGVTBL *vtbl)
{
    MAGIC* mg;
    MAGIC** mgp;

    if (SvTYPE(sv) < SVt_PVMG || !SvMAGIC(sv))
	return 0;
    mgp = &(SvMAGIC(sv));
    for (mg = *mgp; mg; mg = *mgp) {
	const MGVTBL* const virt = mg->mg_virtual;
	if (mg->mg_type == type && virt == vtbl) {
	    *mgp = mg->mg_moremagic;
	    if (virt && virt->svt_free)
		virt->svt_free(aTHX_ sv, mg);
	    if (mg->mg_ptr && mg->mg_type != PERL_MAGIC_regex_global) {
		if (mg->mg_len > 0)
		    Safefree(mg->mg_ptr);
		else if (mg->mg_len == HEf_SVKEY) /* Questionable on older perls... */
		    SvREFCNT_dec(MUTABLE_SV(mg->mg_ptr));
		else if (mg->mg_type == PERL_MAGIC_utf8)
		    Safefree(mg->mg_ptr);
            }
	    if (mg->mg_flags & MGf_REFCOUNTED)
		SvREFCNT_dec(mg->mg_obj);
	    Safefree(mg);
	}
	else
	    mgp = &mg->mg_moremagic;
    }
    if (SvMAGIC(sv)) {
	if (SvMAGICAL(sv))	/* if we're under save_magic, wait for restore_magic; */
	    mg_magical(sv);	/*    else fix the flags now */
    }
    else {
	SvMAGICAL_off(sv);
	SvFLAGS(sv) |= (SvFLAGS(sv) & (SVp_IOK|SVp_NOK|SVp_POK)) >> PRIVSHIFT;
    }
    return 0;
}

#endif
#endif

#ifdef USE_ITHREADS
#ifndef CopFILE
#  define CopFILE(c)                     ((c)->cop_file)
#endif

#ifndef CopFILEGV
#  define CopFILEGV(c)                   (CopFILE(c) ? gv_fetchfile(CopFILE(c)) : Nullgv)
#endif

#ifndef CopFILE_set
#  define CopFILE_set(c,pv)              ((c)->cop_file = savepv(pv))
#endif

#ifndef CopFILESV
#  define CopFILESV(c)                   (CopFILE(c) ? GvSV(gv_fetchfile(CopFILE(c))) : Nullsv)
#endif

#ifndef CopFILEAV
#  define CopFILEAV(c)                   (CopFILE(c) ? GvAV(gv_fetchfile(CopFILE(c))) : Nullav)
#endif

#ifndef CopSTASHPV
#  define CopSTASHPV(c)                  ((c)->cop_stashpv)
#endif

#ifndef CopSTASHPV_set
#  define CopSTASHPV_set(c,pv)           ((c)->cop_stashpv = ((pv) ? savepv(pv) : Nullch))
#endif

#ifndef CopSTASH
#  define CopSTASH(c)                    (CopSTASHPV(c) ? gv_stashpv(CopSTASHPV(c),GV_ADD) : Nullhv)
#endif

#ifndef CopSTASH_set
#  define CopSTASH_set(c,hv)             CopSTASHPV_set(c, (hv) ? HvNAME(hv) : Nullch)
#endif

#ifndef CopSTASH_eq
#  define CopSTASH_eq(c,hv)              ((hv) && (CopSTASHPV(c) == HvNAME(hv) \
                                        || (CopSTASHPV(c) && HvNAME(hv) \
                                        && strEQ(CopSTASHPV(c), HvNAME(hv)))))
#endif

#else
#ifndef CopFILEGV
#  define CopFILEGV(c)                   ((c)->cop_filegv)
#endif

#ifndef CopFILEGV_set
#  define CopFILEGV_set(c,gv)            ((c)->cop_filegv = (GV*)SvREFCNT_inc(gv))
#endif

#ifndef CopFILE_set
#  define CopFILE_set(c,pv)              CopFILEGV_set((c), gv_fetchfile(pv))
#endif

#ifndef CopFILESV
#  define CopFILESV(c)                   (CopFILEGV(c) ? GvSV(CopFILEGV(c)) : Nullsv)
#endif

#ifndef CopFILEAV
#  define CopFILEAV(c)                   (CopFILEGV(c) ? GvAV(CopFILEGV(c)) : Nullav)
#endif

#ifndef CopFILE
#  define CopFILE(c)                     (CopFILESV(c) ? SvPVX(CopFILESV(c)) : Nullch)
#endif

#ifndef CopSTASH
#  define CopSTASH(c)                    ((c)->cop_stash)
#endif

#ifndef CopSTASH_set
#  define CopSTASH_set(c,hv)             ((c)->cop_stash = (hv))
#endif

#ifndef CopSTASHPV
#  define CopSTASHPV(c)                  (CopSTASH(c) ? HvNAME(CopSTASH(c)) : Nullch)
#endif

#ifndef CopSTASHPV_set
#  define CopSTASHPV_set(c,pv)           CopSTASH_set((c), gv_stashpv(pv,GV_ADD))
#endif

#ifndef CopSTASH_eq
#  define CopSTASH_eq(c,hv)              (CopSTASH(c) == (hv))
#endif

#endif /* USE_ITHREADS */

#if (PERL_BCDVERSION >= 0x5006000)
#ifndef caller_cx

# if defined(NEED_caller_cx) || defined(NEED_caller_cx_GLOBAL)
static I32
DPPP_dopoptosub_at(const PERL_CONTEXT *cxstk, I32 startingblock)
{
    I32 i;

    for (i = startingblock; i >= 0; i--) {
	register const PERL_CONTEXT * const cx = &cxstk[i];
	switch (CxTYPE(cx)) {
	default:
	    continue;
	case CXt_EVAL:
	case CXt_SUB:
	case CXt_FORMAT:
	    return i;
	}
    }
    return i;
}
# endif

# if defined(NEED_caller_cx)
static const PERL_CONTEXT * DPPP_(my_caller_cx)(pTHX_ I32 count, const PERL_CONTEXT **dbcxp);
static
#else
extern const PERL_CONTEXT * DPPP_(my_caller_cx)(pTHX_ I32 count, const PERL_CONTEXT **dbcxp);
#endif

#ifdef caller_cx
#  undef caller_cx
#endif
#define caller_cx(a,b) DPPP_(my_caller_cx)(aTHX_ a,b)
#define Perl_caller_cx DPPP_(my_caller_cx)

#if defined(NEED_caller_cx) || defined(NEED_caller_cx_GLOBAL)

const PERL_CONTEXT *
DPPP_(my_caller_cx)(pTHX_ I32 count, const PERL_CONTEXT **dbcxp)
{
    register I32 cxix = DPPP_dopoptosub_at(cxstack, cxstack_ix);
    register const PERL_CONTEXT *cx;
    register const PERL_CONTEXT *ccstack = cxstack;
    const PERL_SI *top_si = PL_curstackinfo;

    for (;;) {
	/* we may be in a higher stacklevel, so dig down deeper */
	while (cxix < 0 && top_si->si_type != PERLSI_MAIN) {
	    top_si = top_si->si_prev;
	    ccstack = top_si->si_cxstack;
	    cxix = DPPP_dopoptosub_at(ccstack, top_si->si_cxix);
	}
	if (cxix < 0)
	    return NULL;
	/* caller() should not report the automatic calls to &DB::sub */
	if (PL_DBsub && GvCV(PL_DBsub) && cxix >= 0 &&
		ccstack[cxix].blk_sub.cv == GvCV(PL_DBsub))
	    count++;
	if (!count--)
	    break;
	cxix = DPPP_dopoptosub_at(ccstack, cxix - 1);
    }

    cx = &ccstack[cxix];
    if (dbcxp) *dbcxp = cx;

    if (CxTYPE(cx) == CXt_SUB || CxTYPE(cx) == CXt_FORMAT) {
        const I32 dbcxix = DPPP_dopoptosub_at(ccstack, cxix - 1);
	/* We expect that ccstack[dbcxix] is CXt_SUB, anyway, the
	   field below is defined for any cx. */
	/* caller() should not report the automatic calls to &DB::sub */
	if (PL_DBsub && GvCV(PL_DBsub) && dbcxix >= 0 && ccstack[dbcxix].blk_sub.cv == GvCV(PL_DBsub))
	    cx = &ccstack[dbcxix];
    }

    return cx;
}

# endif
#endif /* caller_cx */
#endif /* 5.6.0 */
#ifndef IN_PERL_COMPILETIME
#  define IN_PERL_COMPILETIME            (PL_curcop == &PL_compiling)
#endif

#ifndef IN_LOCALE_RUNTIME
#  define IN_LOCALE_RUNTIME              (PL_curcop->op_private & HINT_LOCALE)
#endif

#ifndef IN_LOCALE_COMPILETIME
#  define IN_LOCALE_COMPILETIME          (PL_hints & HINT_LOCALE)
#endif

#ifndef IN_LOCALE
#  define IN_LOCALE                      (IN_PERL_COMPILETIME ? IN_LOCALE_COMPILETIME : IN_LOCALE_RUNTIME)
#endif
#ifndef IS_NUMBER_IN_UV
#  define IS_NUMBER_IN_UV                0x01
#endif

#ifndef IS_NUMBER_GREATER_THAN_UV_MAX
#  define IS_NUMBER_GREATER_THAN_UV_MAX  0x02
#endif

#ifndef IS_NUMBER_NOT_INT
#  define IS_NUMBER_NOT_INT              0x04
#endif

#ifndef IS_NUMBER_NEG
#  define IS_NUMBER_NEG                  0x08
#endif

#ifndef IS_NUMBER_INFINITY
#  define IS_NUMBER_INFINITY             0x10
#endif

#ifndef IS_NUMBER_NAN
#  define IS_NUMBER_NAN                  0x20
#endif
#ifndef GROK_NUMERIC_RADIX
#  define GROK_NUMERIC_RADIX(sp, send)   grok_numeric_radix(sp, send)
#endif
#ifndef PERL_SCAN_GREATER_THAN_UV_MAX
#  define PERL_SCAN_GREATER_THAN_UV_MAX  0x02
#endif

#ifndef PERL_SCAN_SILENT_ILLDIGIT
#  define PERL_SCAN_SILENT_ILLDIGIT      0x04
#endif

#ifndef PERL_SCAN_ALLOW_UNDERSCORES
#  define PERL_SCAN_ALLOW_UNDERSCORES    0x01
#endif

#ifndef PERL_SCAN_DISALLOW_PREFIX
#  define PERL_SCAN_DISALLOW_PREFIX      0x02
#endif

#ifndef grok_numeric_radix
#if defined(NEED_grok_numeric_radix)
static bool DPPP_(my_grok_numeric_radix)(pTHX_ const char ** sp, const char * send);
static
#else
extern bool DPPP_(my_grok_numeric_radix)(pTHX_ const char ** sp, const char * send);
#endif

#ifdef grok_numeric_radix
#  undef grok_numeric_radix
#endif
#define grok_numeric_radix(a,b) DPPP_(my_grok_numeric_radix)(aTHX_ a,b)
#define Perl_grok_numeric_radix DPPP_(my_grok_numeric_radix)

#if defined(NEED_grok_numeric_radix) || defined(NEED_grok_numeric_radix_GLOBAL)
bool
DPPP_(my_grok_numeric_radix)(pTHX_ const char **sp, const char *send)
{
#ifdef USE_LOCALE_NUMERIC
#ifdef PL_numeric_radix_sv
    if (PL_numeric_radix_sv && IN_LOCALE) {
        STRLEN len;
        char* radix = SvPV(PL_numeric_radix_sv, len);
        if (*sp + len <= send && memEQ(*sp, radix, len)) {
            *sp += len;
            return TRUE;
        }
    }
#else
    /* older perls don't have PL_numeric_radix_sv so the radix
     * must manually be requested from locale.h
     */
#include <locale.h>
    dTHR;  /* needed for older threaded perls */
    struct lconv *lc = localeconv();
    char *radix = lc->decimal_point;
    if (radix && IN_LOCALE) {
        STRLEN len = strlen(radix);
        if (*sp + len <= send && memEQ(*sp, radix, len)) {
            *sp += len;
            return TRUE;
        }
    }
#endif
#endif /* USE_LOCALE_NUMERIC */
    /* always try "." if numeric radix didn't match because
     * we may have data from different locales mixed */
    if (*sp < send && **sp == '.') {
        ++*sp;
        return TRUE;
    }
    return FALSE;
}
#endif
#endif

#ifndef grok_number
#if defined(NEED_grok_number)
static int DPPP_(my_grok_number)(pTHX_ const char * pv, STRLEN len, UV * valuep);
static
#else
extern int DPPP_(my_grok_number)(pTHX_ const char * pv, STRLEN len, UV * valuep);
#endif

#ifdef grok_number
#  undef grok_number
#endif
#define grok_number(a,b,c) DPPP_(my_grok_number)(aTHX_ a,b,c)
#define Perl_grok_number DPPP_(my_grok_number)

#if defined(NEED_grok_number) || defined(NEED_grok_number_GLOBAL)
int
DPPP_(my_grok_number)(pTHX_ const char *pv, STRLEN len, UV *valuep)
{
  const char *s = pv;
  const char *send = pv + len;
  const UV max_div_10 = UV_MAX / 10;
  const char max_mod_10 = UV_MAX % 10;
  int numtype = 0;
  int sawinf = 0;
  int sawnan = 0;

  while (s < send && isSPACE(*s))
    s++;
  if (s == send) {
    return 0;
  } else if (*s == '-') {
    s++;
    numtype = IS_NUMBER_NEG;
  }
  else if (*s == '+')
  s++;

  if (s == send)
    return 0;

  /* next must be digit or the radix separator or beginning of infinity */
  if (isDIGIT(*s)) {
    /* UVs are at least 32 bits, so the first 9 decimal digits cannot
       overflow.  */
    UV value = *s - '0';
    /* This construction seems to be more optimiser friendly.
       (without it gcc does the isDIGIT test and the *s - '0' separately)
       With it gcc on arm is managing 6 instructions (6 cycles) per digit.
       In theory the optimiser could deduce how far to unroll the loop
       before checking for overflow.  */
    if (++s < send) {
      int digit = *s - '0';
      if (digit >= 0 && digit <= 9) {
        value = value * 10 + digit;
        if (++s < send) {
          digit = *s - '0';
          if (digit >= 0 && digit <= 9) {
            value = value * 10 + digit;
            if (++s < send) {
              digit = *s - '0';
              if (digit >= 0 && digit <= 9) {
                value = value * 10 + digit;
                if (++s < send) {
                  digit = *s - '0';
                  if (digit >= 0 && digit <= 9) {
                    value = value * 10 + digit;
                    if (++s < send) {
                      digit = *s - '0';
                      if (digit >= 0 && digit <= 9) {
                        value = value * 10 + digit;
                        if (++s < send) {
                          digit = *s - '0';
                          if (digit >= 0 && digit <= 9) {
                            value = value * 10 + digit;
                            if (++s < send) {
                              digit = *s - '0';
                              if (digit >= 0 && digit <= 9) {
                                value = value * 10 + digit;
                                if (++s < send) {
                                  digit = *s - '0';
                                  if (digit >= 0 && digit <= 9) {
                                    value = value * 10 + digit;
                                    if (++s < send) {
                                      /* Now got 9 digits, so need to check
                                         each time for overflow.  */
                                      digit = *s - '0';
                                      while (digit >= 0 && digit <= 9
                                             && (value < max_div_10
                                                 || (value == max_div_10
                                                     && digit <= max_mod_10))) {
                                        value = value * 10 + digit;
                                        if (++s < send)
                                          digit = *s - '0';
                                        else
                                          break;
                                      }
                                      if (digit >= 0 && digit <= 9
                                          && (s < send)) {
                                        /* value overflowed.
                                           skip the remaining digits, don't
                                           worry about setting *valuep.  */
                                        do {
                                          s++;
                                        } while (s < send && isDIGIT(*s));
                                        numtype |=
                                          IS_NUMBER_GREATER_THAN_UV_MAX;
                                        goto skip_value;
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    numtype |= IS_NUMBER_IN_UV;
    if (valuep)
      *valuep = value;

  skip_value:
    if (GROK_NUMERIC_RADIX(&s, send)) {
      numtype |= IS_NUMBER_NOT_INT;
      while (s < send && isDIGIT(*s))  /* optional digits after the radix */
        s++;
    }
  }
  else if (GROK_NUMERIC_RADIX(&s, send)) {
    numtype |= IS_NUMBER_NOT_INT | IS_NUMBER_IN_UV; /* valuep assigned below */
    /* no digits before the radix means we need digits after it */
    if (s < send && isDIGIT(*s)) {
      do {
        s++;
      } while (s < send && isDIGIT(*s));
      if (valuep) {
        /* integer approximation is valid - it's 0.  */
        *valuep = 0;
      }
    }
    else
      return 0;
  } else if (*s == 'I' || *s == 'i') {
    s++; if (s == send || (*s != 'N' && *s != 'n')) return 0;
    s++; if (s == send || (*s != 'F' && *s != 'f')) return 0;
    s++; if (s < send && (*s == 'I' || *s == 'i')) {
      s++; if (s == send || (*s != 'N' && *s != 'n')) return 0;
      s++; if (s == send || (*s != 'I' && *s != 'i')) return 0;
      s++; if (s == send || (*s != 'T' && *s != 't')) return 0;
      s++; if (s == send || (*s != 'Y' && *s != 'y')) return 0;
      s++;
    }
    sawinf = 1;
  } else if (*s == 'N' || *s == 'n') {
    /* XXX TODO: There are signaling NaNs and quiet NaNs. */
    s++; if (s == send || (*s != 'A' && *s != 'a')) return 0;
    s++; if (s == send || (*s != 'N' && *s != 'n')) return 0;
    s++;
    sawnan = 1;
  } else
    return 0;

  if (sawinf) {
    numtype &= IS_NUMBER_NEG; /* Keep track of sign  */
    numtype |= IS_NUMBER_INFINITY | IS_NUMBER_NOT_INT;
  } else if (sawnan) {
    numtype &= IS_NUMBER_NEG; /* Keep track of sign  */
    numtype |= IS_NUMBER_NAN | IS_NUMBER_NOT_INT;
  } else if (s < send) {
    /* we can have an optional exponent part */
    if (*s == 'e' || *s == 'E') {
      /* The only flag we keep is sign.  Blow away any "it's UV"  */
      numtype &= IS_NUMBER_NEG;
      numtype |= IS_NUMBER_NOT_INT;
      s++;
      if (s < send && (*s == '-' || *s == '+'))
        s++;
      if (s < send && isDIGIT(*s)) {
        do {
          s++;
        } while (s < send && isDIGIT(*s));
      }
      else
      return 0;
    }
  }
  while (s < send && isSPACE(*s))
    s++;
  if (s >= send)
    return numtype;
  if (len == 10 && memEQ(pv, "0 but true", 10)) {
    if (valuep)
      *valuep = 0;
    return IS_NUMBER_IN_UV;
  }
  return 0;
}
#endif
#endif

/*
 * The grok_* routines have been modified to use warn() instead of
 * Perl_warner(). Also, 'hexdigit' was the former name of PL_hexdigit,
 * which is why the stack variable has been renamed to 'xdigit'.
 */

#ifndef grok_bin
#if defined(NEED_grok_bin)
static UV DPPP_(my_grok_bin)(pTHX_ const char * start, STRLEN * len_p, I32 * flags, NV * result);
static
#else
extern UV DPPP_(my_grok_bin)(pTHX_ const char * start, STRLEN * len_p, I32 * flags, NV * result);
#endif

#ifdef grok_bin
#  undef grok_bin
#endif
#define grok_bin(a,b,c,d) DPPP_(my_grok_bin)(aTHX_ a,b,c,d)
#define Perl_grok_bin DPPP_(my_grok_bin)

#if defined(NEED_grok_bin) || defined(NEED_grok_bin_GLOBAL)
UV
DPPP_(my_grok_bin)(pTHX_ const char *start, STRLEN *len_p, I32 *flags, NV *result)
{
    const char *s = start;
    STRLEN len = *len_p;
    UV value = 0;
    NV value_nv = 0;

    const UV max_div_2 = UV_MAX / 2;
    bool allow_underscores = *flags & PERL_SCAN_ALLOW_UNDERSCORES;
    bool overflowed = FALSE;

    if (!(*flags & PERL_SCAN_DISALLOW_PREFIX)) {
        /* strip off leading b or 0b.
           for compatibility silently suffer "b" and "0b" as valid binary
           numbers. */
        if (len >= 1) {
            if (s[0] == 'b') {
                s++;
                len--;
            }
            else if (len >= 2 && s[0] == '0' && s[1] == 'b') {
                s+=2;
                len-=2;
            }
        }
    }

    for (; len-- && *s; s++) {
        char bit = *s;
        if (bit == '0' || bit == '1') {
            /* Write it in this wonky order with a goto to attempt to get the
               compiler to make the common case integer-only loop pretty tight.
               With gcc seems to be much straighter code than old scan_bin.  */
          redo:
            if (!overflowed) {
                if (value <= max_div_2) {
                    value = (value << 1) | (bit - '0');
                    continue;
                }
                /* Bah. We're just overflowed.  */
                warn("Integer overflow in binary number");
                overflowed = TRUE;
                value_nv = (NV) value;
            }
            value_nv *= 2.0;
            /* If an NV has not enough bits in its mantissa to
             * represent a UV this summing of small low-order numbers
             * is a waste of time (because the NV cannot preserve
             * the low-order bits anyway): we could just remember when
             * did we overflow and in the end just multiply value_nv by the
             * right amount. */
            value_nv += (NV)(bit - '0');
            continue;
        }
        if (bit == '_' && len && allow_underscores && (bit = s[1])
            && (bit == '0' || bit == '1'))
            {
                --len;
                ++s;
                goto redo;
            }
        if (!(*flags & PERL_SCAN_SILENT_ILLDIGIT))
            warn("Illegal binary digit '%c' ignored", *s);
        break;
    }

    if (   ( overflowed && value_nv > 4294967295.0)
#if UVSIZE > 4
        || (!overflowed && value > 0xffffffff  )
#endif
        ) {
        warn("Binary number > 0b11111111111111111111111111111111 non-portable");
    }
    *len_p = s - start;
    if (!overflowed) {
        *flags = 0;
        return value;
    }
    *flags = PERL_SCAN_GREATER_THAN_UV_MAX;
    if (result)
        *result = value_nv;
    return UV_MAX;
}
#endif
#endif

#ifndef grok_hex
#if defined(NEED_grok_hex)
static UV DPPP_(my_grok_hex)(pTHX_ const char * start, STRLEN * len_p, I32 * flags, NV * result);
static
#else
extern UV DPPP_(my_grok_hex)(pTHX_ const char * start, STRLEN * len_p, I32 * flags, NV * result);
#endif

#ifdef grok_hex
#  undef grok_hex
#endif
#define grok_hex(a,b,c,d) DPPP_(my_grok_hex)(aTHX_ a,b,c,d)
#define Perl_grok_hex DPPP_(my_grok_hex)

#if defined(NEED_grok_hex) || defined(NEED_grok_hex_GLOBAL)
UV
DPPP_(my_grok_hex)(pTHX_ const char *start, STRLEN *len_p, I32 *flags, NV *result)
{
    const char *s = start;
    STRLEN len = *len_p;
    UV value = 0;
    NV value_nv = 0;

    const UV max_div_16 = UV_MAX / 16;
    bool allow_underscores = *flags & PERL_SCAN_ALLOW_UNDERSCORES;
    bool overflowed = FALSE;
    const char *xdigit;

    if (!(*flags & PERL_SCAN_DISALLOW_PREFIX)) {
        /* strip off leading x or 0x.
           for compatibility silently suffer "x" and "0x" as valid hex numbers.
        */
        if (len >= 1) {
            if (s[0] == 'x') {
                s++;
                len--;
            }
            else if (len >= 2 && s[0] == '0' && s[1] == 'x') {
                s+=2;
                len-=2;
            }
        }
    }

    for (; len-- && *s; s++) {
        xdigit = strchr((char *) PL_hexdigit, *s);
        if (xdigit) {
            /* Write it in this wonky order with a goto to attempt to get the
               compiler to make the common case integer-only loop pretty tight.
               With gcc seems to be much straighter code than old scan_hex.  */
          redo:
            if (!overflowed) {
                if (value <= max_div_16) {
                    value = (value << 4) | ((xdigit - PL_hexdigit) & 15);
                    continue;
                }
                warn("Integer overflow in hexadecimal number");
                overflowed = TRUE;
                value_nv = (NV) value;
            }
            value_nv *= 16.0;
            /* If an NV has not enough bits in its mantissa to
             * represent a UV this summing of small low-order numbers
             * is a waste of time (because the NV cannot preserve
             * the low-order bits anyway): we could just remember when
             * did we overflow and in the end just multiply value_nv by the
             * right amount of 16-tuples. */
            value_nv += (NV)((xdigit - PL_hexdigit) & 15);
            continue;
        }
        if (*s == '_' && len && allow_underscores && s[1]
                && (xdigit = strchr((char *) PL_hexdigit, s[1])))
            {
                --len;
                ++s;
                goto redo;
            }
        if (!(*flags & PERL_SCAN_SILENT_ILLDIGIT))
            warn("Illegal hexadecimal digit '%c' ignored", *s);
        break;
    }

    if (   ( overflowed && value_nv > 4294967295.0)
#if UVSIZE > 4
        || (!overflowed && value > 0xffffffff  )
#endif
        ) {
        warn("Hexadecimal number > 0xffffffff non-portable");
    }
    *len_p = s - start;
    if (!overflowed) {
        *flags = 0;
        return value;
    }
    *flags = PERL_SCAN_GREATER_THAN_UV_MAX;
    if (result)
        *result = value_nv;
    return UV_MAX;
}
#endif
#endif

#ifndef grok_oct
#if defined(NEED_grok_oct)
static UV DPPP_(my_grok_oct)(pTHX_ const char * start, STRLEN * len_p, I32 * flags, NV * result);
static
#else
extern UV DPPP_(my_grok_oct)(pTHX_ const char * start, STRLEN * len_p, I32 * flags, NV * result);
#endif

#ifdef grok_oct
#  undef grok_oct
#endif
#define grok_oct(a,b,c,d) DPPP_(my_grok_oct)(aTHX_ a,b,c,d)
#define Perl_grok_oct DPPP_(my_grok_oct)

#if defined(NEED_grok_oct) || defined(NEED_grok_oct_GLOBAL)
UV
DPPP_(my_grok_oct)(pTHX_ const char *start, STRLEN *len_p, I32 *flags, NV *result)
{
    const char *s = start;
    STRLEN len = *len_p;
    UV value = 0;
    NV value_nv = 0;

    const UV max_div_8 = UV_MAX / 8;
    bool allow_underscores = *flags & PERL_SCAN_ALLOW_UNDERSCORES;
    bool overflowed = FALSE;

    for (; len-- && *s; s++) {
         /* gcc 2.95 optimiser not smart enough to figure that this subtraction
            out front allows slicker code.  */
        int digit = *s - '0';
        if (digit >= 0 && digit <= 7) {
            /* Write it in this wonky order with a goto to attempt to get the
               compiler to make the common case integer-only loop pretty tight.
            */
          redo:
            if (!overflowed) {
                if (value <= max_div_8) {
                    value = (value << 3) | digit;
                    continue;
                }
                /* Bah. We're just overflowed.  */
                warn("Integer overflow in octal number");
                overflowed = TRUE;
                value_nv = (NV) value;
            }
            value_nv *= 8.0;
            /* If an NV has not enough bits in its mantissa to
             * represent a UV this summing of small low-order numbers
             * is a waste of time (because the NV cannot preserve
             * the low-order bits anyway): we could just remember when
             * did we overflow and in the end just multiply value_nv by the
             * right amount of 8-tuples. */
            value_nv += (NV)digit;
            continue;
        }
        if (digit == ('_' - '0') && len && allow_underscores
            && (digit = s[1] - '0') && (digit >= 0 && digit <= 7))
            {
                --len;
                ++s;
                goto redo;
            }
        /* Allow \octal to work the DWIM way (that is, stop scanning
         * as soon as non-octal characters are seen, complain only iff
         * someone seems to want to use the digits eight and nine). */
        if (digit == 8 || digit == 9) {
            if (!(*flags & PERL_SCAN_SILENT_ILLDIGIT))
                warn("Illegal octal digit '%c' ignored", *s);
        }
        break;
    }

    if (   ( overflowed && value_nv > 4294967295.0)
#if UVSIZE > 4
        || (!overflowed && value > 0xffffffff  )
#endif
        ) {
        warn("Octal number > 037777777777 non-portable");
    }
    *len_p = s - start;
    if (!overflowed) {
        *flags = 0;
        return value;
    }
    *flags = PERL_SCAN_GREATER_THAN_UV_MAX;
    if (result)
        *result = value_nv;
    return UV_MAX;
}
#endif
#endif

#if !defined(my_snprintf)
#if defined(NEED_my_snprintf)
static int DPPP_(my_my_snprintf)(char * buffer, const Size_t len, const char * format, ...);
static
#else
extern int DPPP_(my_my_snprintf)(char * buffer, const Size_t len, const char * format, ...);
#endif

#define my_snprintf DPPP_(my_my_snprintf)
#define Perl_my_snprintf DPPP_(my_my_snprintf)

#if defined(NEED_my_snprintf) || defined(NEED_my_snprintf_GLOBAL)

int
DPPP_(my_my_snprintf)(char *buffer, const Size_t len, const char *format, ...)
{
    dTHX;
    int retval;
    va_list ap;
    va_start(ap, format);
#ifdef HAS_VSNPRINTF
    retval = vsnprintf(buffer, len, format, ap);
#else
    retval = vsprintf(buffer, format, ap);
#endif
    va_end(ap);
    if (retval < 0 || (len > 0 && (Size_t)retval >= len))
        Perl_croak(aTHX_ "panic: my_snprintf buffer overflow");
    return retval;
}

#endif
#endif

#if !defined(my_sprintf)
#if defined(NEED_my_sprintf)
static int DPPP_(my_my_sprintf)(char * buffer, const char * pat, ...);
static
#else
extern int DPPP_(my_my_sprintf)(char * buffer, const char * pat, ...);
#endif

#define my_sprintf DPPP_(my_my_sprintf)
#define Perl_my_sprintf DPPP_(my_my_sprintf)

#if defined(NEED_my_sprintf) || defined(NEED_my_sprintf_GLOBAL)

int
DPPP_(my_my_sprintf)(char *buffer, const char* pat, ...)
{
    va_list args;
    va_start(args, pat);
    vsprintf(buffer, pat, args);
    va_end(args);
    return strlen(buffer);
}

#endif
#endif

#ifdef NO_XSLOCKS
#  ifdef dJMPENV
#    define dXCPT             dJMPENV; int rEtV = 0
#    define XCPT_TRY_START    JMPENV_PUSH(rEtV); if (rEtV == 0)
#    define XCPT_TRY_END      JMPENV_POP;
#    define XCPT_CATCH        if (rEtV != 0)
#    define XCPT_RETHROW      JMPENV_JUMP(rEtV)
#  else
#    define dXCPT             Sigjmp_buf oldTOP; int rEtV = 0
#    define XCPT_TRY_START    Copy(top_env, oldTOP, 1, Sigjmp_buf); rEtV = Sigsetjmp(top_env, 1); if (rEtV == 0)
#    define XCPT_TRY_END      Copy(oldTOP, top_env, 1, Sigjmp_buf);
#    define XCPT_CATCH        if (rEtV != 0)
#    define XCPT_RETHROW      Siglongjmp(top_env, rEtV)
#  endif
#endif

#if !defined(my_strlcat)
#if defined(NEED_my_strlcat)
static Size_t DPPP_(my_my_strlcat)(char * dst, const char * src, Size_t size);
static
#else
extern Size_t DPPP_(my_my_strlcat)(char * dst, const char * src, Size_t size);
#endif

#define my_strlcat DPPP_(my_my_strlcat)
#define Perl_my_strlcat DPPP_(my_my_strlcat)

#if defined(NEED_my_strlcat) || defined(NEED_my_strlcat_GLOBAL)

Size_t
DPPP_(my_my_strlcat)(char *dst, const char *src, Size_t size)
{
    Size_t used, length, copy;

    used = strlen(dst);
    length = strlen(src);
    if (size > 0 && used < size - 1) {
        copy = (length >= size - used) ? size - used - 1 : length;
        memcpy(dst + used, src, copy);
        dst[used + copy] = '\0';
    }
    return used + length;
}
#endif
#endif

#if !defined(my_strlcpy)
#if defined(NEED_my_strlcpy)
static Size_t DPPP_(my_my_strlcpy)(char * dst, const char * src, Size_t size);
static
#else
extern Size_t DPPP_(my_my_strlcpy)(char * dst, const char * src, Size_t size);
#endif

#define my_strlcpy DPPP_(my_my_strlcpy)
#define Perl_my_strlcpy DPPP_(my_my_strlcpy)

#if defined(NEED_my_strlcpy) || defined(NEED_my_strlcpy_GLOBAL)

Size_t
DPPP_(my_my_strlcpy)(char *dst, const char *src, Size_t size)
{
    Size_t length, copy;

    length = strlen(src);
    if (size > 0) {
        copy = (length >= size) ? size - 1 : length;
        memcpy(dst, src, copy);
        dst[copy] = '\0';
    }
    return length;
}

#endif
#endif
#ifndef PERL_PV_ESCAPE_QUOTE
#  define PERL_PV_ESCAPE_QUOTE           0x0001
#endif

#ifndef PERL_PV_PRETTY_QUOTE
#  define PERL_PV_PRETTY_QUOTE           PERL_PV_ESCAPE_QUOTE
#endif

#ifndef PERL_PV_PRETTY_ELLIPSES
#  define PERL_PV_PRETTY_ELLIPSES        0x0002
#endif

#ifndef PERL_PV_PRETTY_LTGT
#  define PERL_PV_PRETTY_LTGT            0x0004
#endif

#ifndef PERL_PV_ESCAPE_FIRSTCHAR
#  define PERL_PV_ESCAPE_FIRSTCHAR       0x0008
#endif

#ifndef PERL_PV_ESCAPE_UNI
#  define PERL_PV_ESCAPE_UNI             0x0100
#endif

#ifndef PERL_PV_ESCAPE_UNI_DETECT
#  define PERL_PV_ESCAPE_UNI_DETECT      0x0200
#endif

#ifndef PERL_PV_ESCAPE_ALL
#  define PERL_PV_ESCAPE_ALL             0x1000
#endif

#ifndef PERL_PV_ESCAPE_NOBACKSLASH
#  define PERL_PV_ESCAPE_NOBACKSLASH     0x2000
#endif

#ifndef PERL_PV_ESCAPE_NOCLEAR
#  define PERL_PV_ESCAPE_NOCLEAR         0x4000
#endif

#ifndef PERL_PV_ESCAPE_RE
#  define PERL_PV_ESCAPE_RE              0x8000
#endif

#ifndef PERL_PV_PRETTY_NOCLEAR
#  define PERL_PV_PRETTY_NOCLEAR         PERL_PV_ESCAPE_NOCLEAR
#endif
#ifndef PERL_PV_PRETTY_DUMP
#  define PERL_PV_PRETTY_DUMP            PERL_PV_PRETTY_ELLIPSES|PERL_PV_PRETTY_QUOTE
#endif

#ifndef PERL_PV_PRETTY_REGPROP
#  define PERL_PV_PRETTY_REGPROP         PERL_PV_PRETTY_ELLIPSES|PERL_PV_PRETTY_LTGT|PERL_PV_ESCAPE_RE
#endif

/* Hint: pv_escape
 * Note that unicode functionality is only backported to
 * those perl versions that support it. For older perl
 * versions, the implementation will fall back to bytes.
 */

#ifndef pv_escape
#if defined(NEED_pv_escape)
static char * DPPP_(my_pv_escape)(pTHX_ SV * dsv, char const * const str, const STRLEN count, const STRLEN max, STRLEN * const escaped, const U32 flags);
static
#else
extern char * DPPP_(my_pv_escape)(pTHX_ SV * dsv, char const * const str, const STRLEN count, const STRLEN max, STRLEN * const escaped, const U32 flags);
#endif

#ifdef pv_escape
#  undef pv_escape
#endif
#define pv_escape(a,b,c,d,e,f) DPPP_(my_pv_escape)(aTHX_ a,b,c,d,e,f)
#define Perl_pv_escape DPPP_(my_pv_escape)

#if defined(NEED_pv_escape) || defined(NEED_pv_escape_GLOBAL)

char *
DPPP_(my_pv_escape)(pTHX_ SV *dsv, char const * const str,
  const STRLEN count, const STRLEN max,
  STRLEN * const escaped, const U32 flags)
{
    const char esc = flags & PERL_PV_ESCAPE_RE ? '%' : '\\';
    const char dq = flags & PERL_PV_ESCAPE_QUOTE ? '"' : esc;
    char octbuf[32] = "%123456789ABCDF";
    STRLEN wrote = 0;
    STRLEN chsize = 0;
    STRLEN readsize = 1;
#if defined(is_utf8_string) && defined(utf8_to_uvchr)
    bool isuni = flags & PERL_PV_ESCAPE_UNI ? 1 : 0;
#endif
    const char *pv  = str;
    const char * const end = pv + count;
    octbuf[0] = esc;

    if (!(flags & PERL_PV_ESCAPE_NOCLEAR))
        sv_setpvs(dsv, "");

#if defined(is_utf8_string) && defined(utf8_to_uvchr)
    if ((flags & PERL_PV_ESCAPE_UNI_DETECT) && is_utf8_string((U8*)pv, count))
        isuni = 1;
#endif

    for (; pv < end && (!max || wrote < max) ; pv += readsize) {
        const UV u =
#if defined(is_utf8_string) && defined(utf8_to_uvchr)
                     isuni ? utf8_to_uvchr((U8*)pv, &readsize) :
#endif
                             (U8)*pv;
        const U8 c = (U8)u & 0xFF;

        if (u > 255 || (flags & PERL_PV_ESCAPE_ALL)) {
            if (flags & PERL_PV_ESCAPE_FIRSTCHAR)
                chsize = my_snprintf(octbuf, sizeof octbuf,
                                      "%" UVxf, u);
            else
                chsize = my_snprintf(octbuf, sizeof octbuf,
                                      "%cx{%" UVxf "}", esc, u);
        } else if (flags & PERL_PV_ESCAPE_NOBACKSLASH) {
            chsize = 1;
        } else {
            if (c == dq || c == esc || !isPRINT(c)) {
                chsize = 2;
                switch (c) {
                case '\\' : /* fallthrough */
                case '%'  : if (c == esc)
                                octbuf[1] = esc;
                            else
                                chsize = 1;
                            break;
                case '\v' : octbuf[1] = 'v'; break;
                case '\t' : octbuf[1] = 't'; break;
                case '\r' : octbuf[1] = 'r'; break;
                case '\n' : octbuf[1] = 'n'; break;
                case '\f' : octbuf[1] = 'f'; break;
                case '"'  : if (dq == '"')
                                octbuf[1] = '"';
                            else
                                chsize = 1;
                            break;
                default:    chsize = my_snprintf(octbuf, sizeof octbuf,
                                pv < end && isDIGIT((U8)*(pv+readsize))
                                ? "%c%03o" : "%c%o", esc, c);
                }
            } else {
                chsize = 1;
            }
        }
        if (max && wrote + chsize > max) {
            break;
        } else if (chsize > 1) {
            sv_catpvn(dsv, octbuf, chsize);
            wrote += chsize;
        } else {
            char tmp[2];
            my_snprintf(tmp, sizeof tmp, "%c", c);
            sv_catpvn(dsv, tmp, 1);
            wrote++;
        }
        if (flags & PERL_PV_ESCAPE_FIRSTCHAR)
            break;
    }
    if (escaped != NULL)
        *escaped= pv - str;
    return SvPVX(dsv);
}

#endif
#endif

#ifndef pv_pretty
#if defined(NEED_pv_pretty)
static char * DPPP_(my_pv_pretty)(pTHX_ SV * dsv, char const * const str, const STRLEN count, const STRLEN max, char const * const start_color, char const * const end_color, const U32 flags);
static
#else
extern char * DPPP_(my_pv_pretty)(pTHX_ SV * dsv, char const * const str, const STRLEN count, const STRLEN max, char const * const start_color, char const * const end_color, const U32 flags);
#endif

#ifdef pv_pretty
#  undef pv_pretty
#endif
#define pv_pretty(a,b,c,d,e,f,g) DPPP_(my_pv_pretty)(aTHX_ a,b,c,d,e,f,g)
#define Perl_pv_pretty DPPP_(my_pv_pretty)

#if defined(NEED_pv_pretty) || defined(NEED_pv_pretty_GLOBAL)

char *
DPPP_(my_pv_pretty)(pTHX_ SV *dsv, char const * const str, const STRLEN count,
  const STRLEN max, char const * const start_color, char const * const end_color,
  const U32 flags)
{
    const U8 dq = (flags & PERL_PV_PRETTY_QUOTE) ? '"' : '%';
    STRLEN escaped;

    if (!(flags & PERL_PV_PRETTY_NOCLEAR))
        sv_setpvs(dsv, "");

    if (dq == '"')
        sv_catpvs(dsv, "\"");
    else if (flags & PERL_PV_PRETTY_LTGT)
        sv_catpvs(dsv, "<");

    if (start_color != NULL)
        sv_catpv(dsv, D_PPP_CONSTPV_ARG(start_color));

    pv_escape(dsv, str, count, max, &escaped, flags | PERL_PV_ESCAPE_NOCLEAR);

    if (end_color != NULL)
        sv_catpv(dsv, D_PPP_CONSTPV_ARG(end_color));

    if (dq == '"')
        sv_catpvs(dsv, "\"");
    else if (flags & PERL_PV_PRETTY_LTGT)
        sv_catpvs(dsv, ">");

    if ((flags & PERL_PV_PRETTY_ELLIPSES) && escaped < count)
        sv_catpvs(dsv, "...");

    return SvPVX(dsv);
}

#endif
#endif

#ifndef pv_display
#if defined(NEED_pv_display)
static char * DPPP_(my_pv_display)(pTHX_ SV * dsv, const char * pv, STRLEN cur, STRLEN len, STRLEN pvlim);
static
#else
extern char * DPPP_(my_pv_display)(pTHX_ SV * dsv, const char * pv, STRLEN cur, STRLEN len, STRLEN pvlim);
#endif

#ifdef pv_display
#  undef pv_display
#endif
#define pv_display(a,b,c,d,e) DPPP_(my_pv_display)(aTHX_ a,b,c,d,e)
#define Perl_pv_display DPPP_(my_pv_display)

#if defined(NEED_pv_display) || defined(NEED_pv_display_GLOBAL)

char *
DPPP_(my_pv_display)(pTHX_ SV *dsv, const char *pv, STRLEN cur, STRLEN len, STRLEN pvlim)
{
    pv_pretty(dsv, pv, cur, pvlim, NULL, NULL, PERL_PV_PRETTY_DUMP);
    if (len > cur && pv[cur] == '\0')
        sv_catpvs(dsv, "\\0");
    return SvPVX(dsv);
}

#endif
#endif

#endif /* _P_P_PORTABILITY_H_ */

/* End of File ppport.h */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # Devel::Peek - A data debugging tool for the XS programmer
# The documentation is after the __END__

package Devel::Peek;

$VERSION = '1.23';
$XS_VERSION = $VERSION;
$VERSION = eval $VERSION;

require Exporter;
require XSLoader;

@ISA = qw(Exporter);
@EXPORT = qw(Dump mstat DeadCode DumpArray DumpWithOP DumpProg
	     fill_mstats mstats_fillhash mstats2hash runops_debug debug_flags);
@EXPORT_OK = qw(SvREFCNT CvGV);
%EXPORT_TAGS = ('ALL' => [@EXPORT, @EXPORT_OK]);

XSLoader::load();

sub import {
  my $c = shift;
  my $ops_rx = qr/^:opd(=[stP]*)?\b/;
  my @db = grep m/$ops_rx/, @_;
  @_ = grep !m/$ops_rx/, @_;
  if (@db) {
    die "Too many :opd options" if @db > 1;
    runops_debug(1);
    my $flags = ($db[0] =~ m/$ops_rx/ and $1);
    $flags = 'st' unless defined $flags;
    my $f = 0;
    $f |= 2  if $flags =~ /s/;
    $f |= 8  if $flags =~ /t/;
    $f |= 64 if $flags =~ /P/;
    $^D |= $f if $f;
  }
  unshift @_, $c;
  goto &Exporter::import;
}

sub DumpWithOP ($;$) {
   local($Devel::Peek::dump_ops)=1;
   my $depth = @_ > 1 ? $_[1] : 4 ;
   Dump($_[0],$depth);
}

$D_flags = 'psltocPmfrxuLHXDSTR';

sub debug_flags (;$) {
  my $out = "";
  for my $i (0 .. length($D_flags)-1) {
    $out .= substr $D_flags, $i, 1 if $^D & (1<<$i);
  }
  my $arg = shift;
  my $num = $arg;
  if (defined $arg and $arg =~ /\D/) {
    die "unknown flags in debug_flags()" if $arg =~ /[^-$D_flags]/;
    my ($on,$off) = split /-/, "$arg-";
    $num = $^D;
    $num |=  (1<<index($D_flags, $_)) for split //, $on;
    $num &= ~(1<<index($D_flags, $_)) for split //, $off;
  }
  $^D = $num if defined $arg;
  $out
}

sub B::Deparse::pp_Devel_Peek_Dump {
  my ($deparse,$op,$cx) = @_;
  my @kids = $deparse->deparse($op->first, 6);
  my $sib = $op->first->sibling;
  if (ref $sib ne 'B::NULL') {
    push @kids, $deparse->deparse($sib, 6);
  }
  return "Devel::Peek::Dump(" . join(", ", @kids) . ")";
}

1;
__END__

=head1 NAME

Devel::Peek - A data debugging tool for the XS programmer

=head1 SYNOPSIS

        use Devel::Peek;
        Dump( $a );
        Dump( $a, 5 );
        Dump( @a );
        Dump( %h );
        DumpArray( 5, $a, $b, ... );
	mstat "Point 5";

        use Devel::Peek ':opd=st';

=head1 DESCRIPTION

Devel::Peek contains functions which allows raw Perl datatypes to be
manipulated from a Perl script.  This is used by those who do XS programming
to check that the data they are sending from C to Perl looks as they think
it should look.  The trick, then, is to know what the raw datatype is
supposed to look like when it gets to Perl.  This document offers some tips
and hints to describe good and bad raw data.

It is very possible that this document will fall far short of being useful
to the casual reader.  The reader is expected to understand the material in
the first few sections of L<perlguts>.

Devel::Peek supplies a C<Dump()> function which can dump a raw Perl
datatype, and C<mstat("marker")> function to report on memory usage
(if perl is compiled with corresponding option).  The function
DeadCode() provides statistics on the data "frozen" into inactive
C<CV>.  Devel::Peek also supplies C<SvREFCNT()> which can query reference
counts on SVs.  This document will take a passive, and safe, approach
to data debugging and for that it will describe only the C<Dump()>
function.

All output is to STDERR.

The C<Dump()> function takes one or two arguments: something to dump, and
an optional limit for recursion and array elements (default is 4).  The
first argument is evaluted in rvalue scalar context, with exceptions for
@array and %hash, which dump the array or hash itself.  So C<Dump @array>
works, as does C<Dump $foo>.  And C<Dump pos> will call C<pos> in rvalue
context, whereas C<Dump ${\pos}> will call it in lvalue context.

Function C<DumpArray()> allows dumping of multiple values (useful when you
need to analyze returns of functions).

The global variable $Devel::Peek::pv_limit can be set to limit the
number of character printed in various string values.  Setting it to 0
means no limit.

If C<use Devel::Peek> directive has a C<:opd=FLAGS> argument,
this switches on debugging of opcode dispatch.  C<FLAGS> should be a
combination of C<s>, C<t>, and C<P> (see B<-D> flags in L<perlrun>).
C<:opd> is a shortcut for C<:opd=st>.

=head2 Runtime debugging

C<CvGV($cv)> return one of the globs associated to a subroutine reference $cv.

debug_flags() returns a string representation of C<$^D> (similar to
what is allowed for B<-D> flag).  When called with a numeric argument,
sets $^D to the corresponding value.  When called with an argument of
the form C<"flags-flags">, set on/off bits of C<$^D> corresponding to
letters before/after C<->.  (The returned value is for C<$^D> before
the modification.)

runops_debug() returns true if the current I<opcode dispatcher> is the
debugging one.  When called with an argument, switches to debugging or
non-debugging dispatcher depending on the argument (active for
newly-entered subs/etc only).  (The returned value is for the dispatcher before the modification.)

=head2 Memory footprint debugging

When perl is compiled with support for memory footprint debugging
(default with Perl's malloc()), Devel::Peek provides an access to this API.

Use mstat() function to emit a memory state statistic to the terminal.
For more information on the format of output of mstat() see
L<perldebguts/Using $ENV{PERL_DEBUG_MSTATS}>.

Three additional functions allow access to this statistic from Perl.
First, use C<mstats_fillhash(%hash)> to get the information contained
in the output of mstat() into %hash. The field of this hash are

  minbucket nbuckets sbrk_good sbrk_slack sbrked_remains sbrks
  start_slack topbucket topbucket_ev topbucket_odd total total_chain
  total_sbrk totfree

Two additional fields C<free>, C<used> contain array references which
provide per-bucket count of free and used chunks.  Two other fields
C<mem_size>, C<available_size> contain array references which provide
the information about the allocated size and usable size of chunks in
each bucket.  Again, see L<perldebguts/Using $ENV{PERL_DEBUG_MSTATS}>
for details.


Keep in mind that only the first several "odd-numbered" buckets are
used, so the information on size of the "odd-numbered" buckets which are
not used is probably meaningless.

The information in

 mem_size available_size minbucket nbuckets

is the property of a particular build of perl, and does not depend on
the current process.  If you do not provide the optional argument to
the functions mstats_fillhash(), fill_mstats(), mstats2hash(), then
the information in fields C<mem_size>, C<available_size> is not
updated.

C<fill_mstats($buf)> is a much cheaper call (both speedwise and
memory-wise) which collects the statistic into $buf in
machine-readable form.  At a later moment you may need to call
C<mstats2hash($buf, %hash)> to use this information to fill %hash.

All three APIs C<fill_mstats($buf)>, C<mstats_fillhash(%hash)>, and
C<mstats2hash($buf, %hash)> are designed to allocate no memory if used
I<the second time> on the same $buf and/or %hash.

So, if you want to collect memory info in a cycle, you may call

  $#buf = 999;
  fill_mstats($_) for @buf;
  mstats_fillhash(%report, 1);		# Static info too

  foreach (@buf) {
    # Do something...
    fill_mstats $_;			# Collect statistic
  }
  foreach (@buf) {
    mstats2hash($_, %report);		# Preserve static info
    # Do something with %report
  }

=head1 EXAMPLES

The following examples don't attempt to show everything as that would be a
monumental task, and, frankly, we don't want this manpage to be an internals
document for Perl.  The examples do demonstrate some basics of the raw Perl
datatypes, and should suffice to get most determined people on their way.
There are no guidewires or safety nets, nor blazed trails, so be prepared to
travel alone from this point and on and, if at all possible, don't fall into
the quicksand (it's bad for business).

Oh, one final bit of advice: take L<perlguts> with you.  When you return we
expect to see it well-thumbed.

=head2 A simple scalar string

Let's begin by looking a simple scalar which is holding a string.

        use Devel::Peek;
        $a = 42; $a = "hello";
        Dump $a;

The output:

        SV = PVIV(0xbc288) at 0xbe9a8
          REFCNT = 1
          FLAGS = (POK,pPOK)
          IV = 42
          PV = 0xb2048 "hello"\0
          CUR = 5
          LEN = 8

This says C<$a> is an SV, a scalar.  The scalar type is a PVIV, which is
capable of holding an integer (IV) and/or a string (PV) value. The scalar's
head is allocated at address 0xbe9a8, while the body is at 0xbc288.
Its reference count is 1.  It has the C<POK> flag set, meaning its
current PV field is valid.  Because POK is set we look at the PV item
to see what is in the scalar.  The \0 at the end indicate that this
PV is properly NUL-terminated.
Note that the IV field still contains its old numeric value, but because
FLAGS doesn't have IOK set, we must ignore the IV item.
CUR indicates the number of characters in the PV.  LEN indicates the
number of bytes allocated for the PV (at least one more than CUR, because
LEN includes an extra byte for the end-of-string marker, then usually
rounded up to some efficient allocation unit).

=head2 A simple scalar number

If the scalar contains a number the raw SV will be leaner.

        use Devel::Peek;
        $a = 42;
        Dump $a;

The output:

        SV = IV(0xbc818) at 0xbe9a8
          REFCNT = 1
          FLAGS = (IOK,pIOK)
          IV = 42

This says C<$a> is an SV, a scalar.  The scalar is an IV, a number.  Its
reference count is 1.  It has the C<IOK> flag set, meaning it is currently
being evaluated as a number.  Because IOK is set we look at the IV item to
see what is in the scalar.

=head2 A simple scalar with an extra reference

If the scalar from the previous example had an extra reference:

        use Devel::Peek;
        $a = 42;
        $b = \$a;
        Dump $a;

The output:

        SV = IV(0xbe860) at 0xbe9a8
          REFCNT = 2
          FLAGS = (IOK,pIOK)
          IV = 42

Notice that this example differs from the previous example only in its
reference count.  Compare this to the next example, where we dump C<$b>
instead of C<$a>.

=head2 A reference to a simple scalar

This shows what a reference looks like when it references a simple scalar.

        use Devel::Peek;
        $a = 42;
        $b = \$a;
        Dump $b;

The output:

        SV = IV(0xf041c) at 0xbe9a0
          REFCNT = 1
          FLAGS = (ROK)
          RV = 0xbab08
          SV = IV(0xbe860) at 0xbe9a8
            REFCNT = 2
            FLAGS = (IOK,pIOK)
            IV = 42

Starting from the top, this says C<$b> is an SV.  The scalar is an IV,
which is capable of holding an integer or reference value.
It has the C<ROK> flag set, meaning it is a reference (rather than an
integer or string).  Notice that Dump
follows the reference and shows us what C<$b> was referencing.  We see the
same C<$a> that we found in the previous example.

Note that the value of C<RV> coincides with the numbers we see when we
stringify $b. The addresses inside IV() are addresses of
C<X***> structures which hold the current state of an C<SV>. This
address may change during lifetime of an SV.

=head2 A reference to an array

This shows what a reference to an array looks like.

        use Devel::Peek;
        $a = [42];
        Dump $a;

The output:

        SV = IV(0xc85998) at 0xc859a8
          REFCNT = 1
          FLAGS = (ROK)
          RV = 0xc70de8
          SV = PVAV(0xc71e10) at 0xc70de8
            REFCNT = 1
            FLAGS = ()
            ARRAY = 0xc7e820
            FILL = 0
            MAX = 0
            ARYLEN = 0x0
            FLAGS = (REAL)
            Elt No. 0
            SV = IV(0xc70f88) at 0xc70f98
              REFCNT = 1
              FLAGS = (IOK,pIOK)
              IV = 42

This says C<$a> is a reference (ROK), which points to
another SV which is a PVAV, an array.  The array has one element,
element zero, which is another SV. The field C<FILL> above indicates
the last element in the array, similar to C<$#$a>.

If C<$a> pointed to an array of two elements then we would see the
following.

        use Devel::Peek 'Dump';
        $a = [42,24];
        Dump $a;

The output:

        SV = IV(0x158c998) at 0x158c9a8
          REFCNT = 1
          FLAGS = (ROK)
          RV = 0x1577de8
          SV = PVAV(0x1578e10) at 0x1577de8
            REFCNT = 1
            FLAGS = ()
            ARRAY = 0x1585820
            FILL = 1
            MAX = 1
            ARYLEN = 0x0
            FLAGS = (REAL)
            Elt No. 0
            SV = IV(0x1577f88) at 0x1577f98
              REFCNT = 1
              FLAGS = (IOK,pIOK)
              IV = 42
            Elt No. 1
            SV = IV(0x158be88) at 0x158be98
              REFCNT = 1
              FLAGS = (IOK,pIOK)
              IV = 24

Note that C<Dump> will not report I<all> the elements in the array,
only several first (depending on how deep it already went into the
report tree).

=head2 A reference to a hash

The following shows the raw form of a reference to a hash.

        use Devel::Peek;
        $a = {hello=>42};
        Dump $a;

The output:

	SV = IV(0x8177858) at 0x816a618
	  REFCNT = 1
	  FLAGS = (ROK)
	  RV = 0x814fc10
	  SV = PVHV(0x8167768) at 0x814fc10
	    REFCNT = 1
	    FLAGS = (SHAREKEYS)
	    ARRAY = 0x816c5b8  (0:7, 1:1)
	    hash quality = 100.0%
	    KEYS = 1
	    FILL = 1
	    MAX = 7
	    RITER = -1
	    EITER = 0x0
	    Elt "hello" HASH = 0xc8fd181b
	    SV = IV(0x816c030) at 0x814fcf4
	      REFCNT = 1
	      FLAGS = (IOK,pIOK)
	      IV = 42

This shows C<$a> is a reference pointing to an SV.  That SV is a PVHV, a
hash. Fields RITER and EITER are used by C<L<perlfunc/each>>.

The "quality" of a hash is defined as the total number of comparisons needed
to access every element once, relative to the expected number needed for a
random hash. The value can go over 100%.

The total number of comparisons is equal to the sum of the squares of the
number of entries in each bucket.  For a random hash of C<<n>> keys into
C<<k>> buckets, the expected value is:

		n + n(n-1)/2k

=head2 Dumping a large array or hash

The C<Dump()> function, by default, dumps up to 4 elements from a
toplevel array or hash.  This number can be increased by supplying a
second argument to the function.

        use Devel::Peek;
        $a = [10,11,12,13,14];
        Dump $a;

Notice that C<Dump()> prints only elements 10 through 13 in the above code.
The following code will print all of the elements.

        use Devel::Peek 'Dump';
        $a = [10,11,12,13,14];
        Dump $a, 5;

=head2 A reference to an SV which holds a C pointer

This is what you really need to know as an XS programmer, of course.  When
an XSUB returns a pointer to a C structure that pointer is stored in an SV
and a reference to that SV is placed on the XSUB stack.  So the output from
an XSUB which uses something like the T_PTROBJ map might look something like
this:

        SV = IV(0xf381c) at 0xc859a8
          REFCNT = 1
          FLAGS = (ROK)
          RV = 0xb8ad8
          SV = PVMG(0xbb3c8) at 0xc859a0
            REFCNT = 1
            FLAGS = (OBJECT,IOK,pIOK)
            IV = 729160
            NV = 0
            PV = 0
            STASH = 0xc1d10       "CookBookB::Opaque"

This shows that we have an SV which is a reference, which points at another
SV.  In this case that second SV is a PVMG, a blessed scalar.  Because it is
blessed it has the C<OBJECT> flag set.  Note that an SV which holds a C
pointer also has the C<IOK> flag set.  The C<STASH> is set to the package
name which this SV was blessed into.

The output from an XSUB which uses something like the T_PTRREF map, which
doesn't bless the object, might look something like this:

        SV = IV(0xf381c) at 0xc859a8
          REFCNT = 1
          FLAGS = (ROK)
          RV = 0xb8ad8
          SV = PVMG(0xbb3c8) at 0xc859a0
            REFCNT = 1
            FLAGS = (IOK,pIOK)
            IV = 729160
            NV = 0
            PV = 0

=head2 A reference to a subroutine

Looks like this:

	SV = IV(0x24d2dd8) at 0x24d2de8
	  REFCNT = 1
	  FLAGS = (TEMP,ROK)
	  RV = 0x24e79d8
	  SV = PVCV(0x24e5798) at 0x24e79d8
	    REFCNT = 2
	    FLAGS = ()
	    COMP_STASH = 0x22c9c50	"main"
	    START = 0x22eed60 ===> 0
	    ROOT = 0x22ee490
	    GVGV::GV = 0x22de9d8	"MY" :: "top_targets"
	    FILE = "(eval 5)"
	    DEPTH = 0
	    FLAGS = 0x0
	    OUTSIDE_SEQ = 93
	    PADLIST = 0x22e9ed8
	    PADNAME = 0x22e9ec0(0x22eed00) PAD = 0x22e9ea8(0x22eecd0)
	    OUTSIDE = 0x22c9fb0 (MAIN)


This shows that 

=over 4

=item *

the subroutine is not an XSUB (since C<START> and C<ROOT> are
non-zero, and C<XSUB> is not listed, and is thus null);

=item *

that it was compiled in the package C<main>;

=item *

under the name C<MY::top_targets>; 

=item *

inside a 5th eval in the program;

=item *

it is not currently executed (see C<DEPTH>);

=item *

it has no prototype (C<PROTOTYPE> field is missing).

=back

=head1 EXPORTS

C<Dump>, C<mstat>, C<DeadCode>, C<DumpArray>, C<DumpWithOP> and
C<DumpProg>, C<fill_mstats>, C<mstats_fillhash>, C<mstats2hash> by
default. Additionally available C<SvREFCNT>, C<SvREFCNT_inc> and
C<SvREFCNT_dec>.

=head1 BUGS

Readers have been known to skip important parts of L<perlguts>, causing much
frustration for all.

=head1 AUTHOR

Ilya Zakharevich	ilya@math.ohio-state.edu

Copyright (c) 1995-98 Ilya Zakharevich. All rights reserved.
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

Author of this software makes no claim whatsoever about suitability,
reliability, edability, editability or usability of this product, and
should not be kept liable for any damage resulting from the use of
it. If you can use it, you are in luck, if not, I should not be kept
responsible. Keep a handy copy of your backup tape at hand.

=head1 SEE ALSO

L<perlguts>, and L<perlguts>, again.

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       package Digest::MD5;

use strict;
use vars qw($VERSION @ISA @EXPORT_OK);

$VERSION = '2.54';

require Exporter;
*import = \&Exporter::import;
@EXPORT_OK = qw(md5 md5_hex md5_base64);

eval {
    require Digest::base;
    push(@ISA, 'Digest::base');
};
if ($@) {
    my $err = $@;
    *add_bits = sub { die $err };
}


eval {
    require XSLoader;
    XSLoader::load('Digest::MD5', $VERSION);
};
if ($@) {
    my $olderr = $@;
    eval {
	# Try to load the pure perl version
	require Digest::Perl::MD5;

	Digest::Perl::MD5->import(qw(md5 md5_hex md5_base64));
	unshift(@ISA, "Digest::Perl::MD5");  # make OO interface work
    };
    if ($@) {
	# restore the original error
	die $olderr;
    }
}
else {
    *reset = \&new;
}

1;
__END__

=head1 NAME

Digest::MD5 - Perl interface to the MD5 Algorithm

=head1 SYNOPSIS

 # Functional style
 use Digest::MD5 qw(md5 md5_hex md5_base64);

 $digest = md5($data);
 $digest = md5_hex($data);
 $digest = md5_base64($data);

 # OO style
 use Digest::MD5;

 $ctx = Digest::MD5->new;

 $ctx->add($data);
 $ctx->addfile($file_handle);

 $digest = $ctx->digest;
 $digest = $ctx->hexdigest;
 $digest = $ctx->b64digest;

=head1 DESCRIPTION

The C<Digest::MD5> module allows you to use the RSA Data Security
Inc. MD5 Message Digest algorithm from within Perl programs.  The
algorithm takes as input a message of arbitrary length and produces as
output a 128-bit "fingerprint" or "message digest" of the input.

Note that the MD5 algorithm is not as strong as it used to be.  It has
since 2005 been easy to generate different messages that produce the
same MD5 digest.  It still seems hard to generate messages that
produce a given digest, but it is probably wise to move to stronger
algorithms for applications that depend on the digest to uniquely identify
a message.

The C<Digest::MD5> module provide a procedural interface for simple
use, as well as an object oriented interface that can handle messages
of arbitrary length and which can read files directly.

=head1 FUNCTIONS

The following functions are provided by the C<Digest::MD5> module.
None of these functions are exported by default.

=over 4

=item md5($data,...)

This function will concatenate all arguments, calculate the MD5 digest
of this "message", and return it in binary form.  The returned string
will be 16 bytes long.

The result of md5("a", "b", "c") will be exactly the same as the
result of md5("abc").

=item md5_hex($data,...)

Same as md5(), but will return the digest in hexadecimal form. The
length of the returned string will be 32 and it will only contain
characters from this set: '0'..'9' and 'a'..'f'.

=item md5_base64($data,...)

Same as md5(), but will return the digest as a base64 encoded string.
The length of the returned string will be 22 and it will only contain
characters from this set: 'A'..'Z', 'a'..'z', '0'..'9', '+' and
'/'.

Note that the base64 encoded string returned is not padded to be a
multiple of 4 bytes long.  If you want interoperability with other
base64 encoded md5 digests you might want to append the redundant
string "==" to the result.

=back

=head1 METHODS

The object oriented interface to C<Digest::MD5> is described in this
section.  After a C<Digest::MD5> object has been created, you will add
data to it and finally ask for the digest in a suitable format.  A
single object can be used to calculate multiple digests.

The following methods are provided:

=over 4

=item $md5 = Digest::MD5->new

The constructor returns a new C<Digest::MD5> object which encapsulate
the state of the MD5 message-digest algorithm.

If called as an instance method (i.e. $md5->new) it will just reset the
state the object to the state of a newly created object.  No new
object is created in this case.

=item $md5->reset

This is just an alias for $md5->new.

=item $md5->clone

This a copy of the $md5 object. It is useful when you do not want to
destroy the digests state, but need an intermediate value of the
digest, e.g. when calculating digests iteratively on a continuous data
stream.  Example:

    my $md5 = Digest::MD5->new;
    while (<>) {
	$md5->add($_);
	print "Line $.: ", $md5->clone->hexdigest, "\n";
    }

=item $md5->add($data,...)

The $data provided as argument are appended to the message we
calculate the digest for.  The return value is the $md5 object itself.

All these lines will have the same effect on the state of the $md5
object:

    $md5->add("a"); $md5->add("b"); $md5->add("c");
    $md5->add("a")->add("b")->add("c");
    $md5->add("a", "b", "c");
    $md5->add("abc");

=item $md5->addfile($io_handle)

The $io_handle will be read until EOF and its content appended to the
message we calculate the digest for.  The return value is the $md5
object itself.

The addfile() method will croak() if it fails reading data for some
reason.  If it croaks it is unpredictable what the state of the $md5
object will be in. The addfile() method might have been able to read
the file partially before it failed.  It is probably wise to discard
or reset the $md5 object if this occurs.

In most cases you want to make sure that the $io_handle is in
C<binmode> before you pass it as argument to the addfile() method.

=item $md5->add_bits($data, $nbits)

=item $md5->add_bits($bitstring)

Since the MD5 algorithm is byte oriented you might only add bits as
multiples of 8, so you probably want to just use add() instead.  The
add_bits() method is provided for compatibility with other digest
implementations.  See L<Digest> for description of the arguments
that add_bits() take.

=item $md5->digest

Return the binary digest for the message.  The returned string will be
16 bytes long.

Note that the C<digest> operation is effectively a destructive,
read-once operation. Once it has been performed, the C<Digest::MD5>
object is automatically C<reset> and can be used to calculate another
digest value.  Call $md5->clone->digest if you want to calculate the
digest without resetting the digest state.

=item $md5->hexdigest

Same as $md5->digest, but will return the digest in hexadecimal
form. The length of the returned string will be 32 and it will only
contain characters from this set: '0'..'9' and 'a'..'f'.

=item $md5->b64digest

Same as $md5->digest, but will return the digest as a base64 encoded
string.  The length of the returned string will be 22 and it will only
contain characters from this set: 'A'..'Z', 'a'..'z', '0'..'9', '+'
and '/'.


The base64 encoded string returned is not padded to be a multiple of 4
bytes long.  If you want interoperability with other base64 encoded
md5 digests you might want to append the string "==" to the result.

=item @ctx = $md5->context

=item $md5->context(@ctx)

Saves or restores the internal state.  When called with no arguments,
returns a 3-element list: number of blocks processed, a 16-byte
internal state buffer, then up to 63 bytes of unprocessed data.  When
passed those same arguments, restores the state.  This is only useful
for specialised operations.

=back


=head1 EXAMPLES

The simplest way to use this library is to import the md5_hex()
function (or one of its cousins):

    use Digest::MD5 qw(md5_hex);
    print "Digest is ", md5_hex("foobarbaz"), "\n";

The above example would print out the message:

    Digest is 6df23dc03f9b54cc38a0fc1483df6e21

The same checksum can also be calculated in OO style:

    use Digest::MD5;
    
    $md5 = Digest::MD5->new;
    $md5->add('foo', 'bar');
    $md5->add('baz');
    $digest = $md5->hexdigest;
    
    print "Digest is $digest\n";

With OO style, you can break the message arbitrarily.  This means that we
are no longer limited to have space for the whole message in memory, i.e.
we can handle messages of any size.

This is useful when calculating checksum for files:

    use Digest::MD5;

    my $filename = shift || "/etc/passwd";
    open (my $fh, '<', $filename) or die "Can't open '$filename': $!";
    binmode($fh);

    $md5 = Digest::MD5->new;
    while (<$fh>) {
        $md5->add($_);
    }
    close($fh);
    print $md5->b64digest, " $filename\n";

Or we can use the addfile method for more efficient reading of
the file:

    use Digest::MD5;

    my $filename = shift || "/etc/passwd";
    open (my $fh, '<', $filename) or die "Can't open '$filename': $!";
    binmode ($fh);

    print Digest::MD5->new->addfile($fh)->hexdigest, " $filename\n";

Since the MD5 algorithm is only defined for strings of bytes, it can not be
used on strings that contains chars with ordinal number above 255 (Unicode
strings).  The MD5 functions and methods will croak if you try to feed them
such input data:

    use Digest::MD5 qw(md5_hex);

    my $str = "abc\x{300}";
    print md5_hex($str), "\n";  # croaks
    # Wide character in subroutine entry

What you can do is calculate the MD5 checksum of the UTF-8
representation of such strings.  This is achieved by filtering the
string through encode_utf8() function:

    use Digest::MD5 qw(md5_hex);
    use Encode qw(encode_utf8);

    my $str = "abc\x{300}";
    print md5_hex(encode_utf8($str)), "\n";
    # 8c2d46911f3f5a326455f0ed7a8ed3b3

=head1 SEE ALSO

L<Digest>,
L<Digest::MD2>,
L<Digest::SHA>,
L<Digest::HMAC>

L<md5sum(1)>

RFC 1321

http://en.wikipedia.org/wiki/MD5

The paper "How to Break MD5 and Other Hash Functions" by Xiaoyun Wang
and Hongbo Yu.

=head1 COPYRIGHT

This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

 Copyright 1998-2003 Gisle Aas.
 Copyright 1995-1996 Neil Winton.
 Copyright 1991-1992 RSA Data Security, Inc.

The MD5 algorithm is defined in RFC 1321. This implementation is
derived from the reference C code in RFC 1321 which is covered by
the following copyright statement:

=over 4

=item

Copyright (C) 1991-2, RSA Data Security, Inc. Created 1991. All
rights reserved.

License to copy and use this software is granted provided that it
is identified as the "RSA Data Security, Inc. MD5 Message-Digest
Algorithm" in all material mentioning or referencing this software
or this function.

License is also granted to make and use derivative works provided
that such works are identified as "derived from the RSA Data
Security, Inc. MD5 Message-Digest Algorithm" in all material
mentioning or referencing the derived work.

RSA Data Security, Inc. makes no representations concerning either
the merchantability of this software or the suitability of this
software for any particular purpose. It is provided "as is"
without express or implied warranty of any kind.

These notices must be retained in any copies of any part of this
documentation and/or software.

=back

This copyright does not prohibit distribution of any version of Perl
containing this extension under the terms of the GNU or Artistic
licenses.

=head1 AUTHORS

The original C<MD5> interface was written by Neil Winton
(C<N.Winton@axion.bt.co.uk>).

The C<Digest::MD5> module is written by Gisle Aas <gisle@ActiveState.com>.

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   package Digest::SHA;

require 5.003000;

use strict;
use warnings;
use vars qw($VERSION @ISA @EXPORT @EXPORT_OK);
use Fcntl;
use integer;

$VERSION = '5.95_01';

require Exporter;
require DynaLoader;
@ISA = qw(Exporter DynaLoader);
@EXPORT_OK = qw(
	hmac_sha1	hmac_sha1_base64	hmac_sha1_hex
	hmac_sha224	hmac_sha224_base64	hmac_sha224_hex
	hmac_sha256	hmac_sha256_base64	hmac_sha256_hex
	hmac_sha384	hmac_sha384_base64	hmac_sha384_hex
	hmac_sha512	hmac_sha512_base64	hmac_sha512_hex
	hmac_sha512224	hmac_sha512224_base64	hmac_sha512224_hex
	hmac_sha512256	hmac_sha512256_base64	hmac_sha512256_hex
	sha1		sha1_base64		sha1_hex
	sha224		sha224_base64		sha224_hex
	sha256		sha256_base64		sha256_hex
	sha384		sha384_base64		sha384_hex
	sha512		sha512_base64		sha512_hex
	sha512224	sha512224_base64	sha512224_hex
	sha512256	sha512256_base64	sha512256_hex);

# Inherit from Digest::base if possible

eval {
	require Digest::base;
	push(@ISA, 'Digest::base');
};

# The following routines aren't time-critical, so they can be left in Perl

sub new {
	my($class, $alg) = @_;
	$alg =~ s/\D+//g if defined $alg;
	if (ref($class)) {	# instance method
		if (!defined($alg) || ($alg == $class->algorithm)) {
			sharewind($class);
			return($class);
		}
		return shainit($class, $alg) ? $class : undef;
	}
	$alg = 1 unless defined $alg;
	return $class->newSHA($alg);
}

BEGIN { *reset = \&new }

sub add_bits {
	my($self, $data, $nbits) = @_;
	unless (defined $nbits) {
		$nbits = length($data);
		$data = pack("B*", $data);
	}
	$nbits = length($data) * 8 if $nbits > length($data) * 8;
	shawrite($data, $nbits, $self);
	return($self);
}

sub _bail {
	my $msg = shift;

	$msg .= ": $!";
	require Carp;
	Carp::croak($msg);
}

{
	my $_can_T_filehandle;

	sub _istext {
		local *FH = shift;
		my $file = shift;

		if (! defined $_can_T_filehandle) {
			local $^W = 0;
			my $istext = eval { -T FH };
			$_can_T_filehandle = $@ ? 0 : 1;
			return $_can_T_filehandle ? $istext : -T $file;
		}
		return $_can_T_filehandle ? -T FH : -T $file;
	}
}

sub _addfile {
	my ($self, $handle) = @_;

	my $n;
	my $buf = "";

	while (($n = read($handle, $buf, 4096))) {
		$self->add($buf);
	}
	_bail("Read failed") unless defined $n;

	$self;
}

sub addfile {
	my ($self, $file, $mode) = @_;

	return(_addfile($self, $file)) unless ref(\$file) eq 'SCALAR';

	$mode = defined($mode) ? $mode : "";
	my ($binary, $UNIVERSAL, $BITS, $portable) =
		map { $_ eq $mode } ("b", "U", "0", "p");

		## Always interpret "-" to mean STDIN; otherwise use
		## sysopen to handle full range of POSIX file names

	local *FH;
	$file eq '-' and open(FH, '< -')
		or sysopen(FH, $file, O_RDONLY)
			or _bail('Open failed');

	if ($BITS) {
		my ($n, $buf) = (0, "");
		while (($n = read(FH, $buf, 4096))) {
			$buf =~ s/[^01]//g;
			$self->add_bits($buf);
		}
		_bail("Read failed") unless defined $n;
		close(FH);
		return($self);
	}

	binmode(FH) if $binary || $portable || $UNIVERSAL;
	if ($UNIVERSAL && _istext(*FH, $file)) {
		$self->_addfileuniv(*FH);
	}
	elsif ($portable && _istext(*FH, $file)) {
		while (<FH>) {
			s/\015?\015\012/\012/g;
			s/\015/\012/g;
			$self->add($_);
		}
	}
	else { $self->_addfilebin(*FH) }
	close(FH);

	$self;
}

sub getstate {
	my $self = shift;

	my $alg = $self->algorithm or return;
	my $state = $self->_getstate or return;
	my $nD = $alg <= 256 ?  8 :  16;
	my $nH = $alg <= 256 ? 32 :  64;
	my $nB = $alg <= 256 ? 64 : 128;
	my($H, $block, $blockcnt, $lenhh, $lenhl, $lenlh, $lenll) =
		$state =~ /^(.{$nH})(.{$nB})(.{4})(.{4})(.{4})(.{4})(.{4})$/s;
	for ($alg, $H, $block, $blockcnt, $lenhh, $lenhl, $lenlh, $lenll) {
		return unless defined $_;
	}

	my @s = ();
	push(@s, "alg:" . $alg);
	push(@s, "H:" . join(":", unpack("H*", $H) =~ /.{$nD}/g));
	push(@s, "block:" . join(":", unpack("H*", $block) =~ /.{2}/g));
	push(@s, "blockcnt:" . unpack("N", $blockcnt));
	push(@s, "lenhh:" . unpack("N", $lenhh));
	push(@s, "lenhl:" . unpack("N", $lenhl));
	push(@s, "lenlh:" . unpack("N", $lenlh));
	push(@s, "lenll:" . unpack("N", $lenll));
	join("\n", @s) . "\n";
}

sub putstate {
	my($class, $state) = @_;

	my %s = ();
	for (split(/\n/, $state)) {
		s/^\s+//;
		s/\s+$//;
		next if (/^(#|$)/);
		my @f = split(/[:\s]+/);
		my $tag = shift(@f);
		$s{$tag} = join('', @f);
	}

	# H and block may contain arbitrary values, but check everything else
	grep { $_ == $s{'alg'} } (1,224,256,384,512,512224,512256) or return;
	length($s{'H'}) == ($s{'alg'} <= 256 ? 64 : 128) or return;
	length($s{'block'}) == ($s{'alg'} <= 256 ? 128 : 256) or return;
	{
		no integer;
		for (qw(blockcnt lenhh lenhl lenlh lenll)) {
			0 <= $s{$_} or return;
			$s{$_} <= 4294967295 or return;
		}
		$s{'blockcnt'} < ($s{'alg'} <= 256 ? 512 : 1024) or return;
	}

	my $packed_state = (
		pack("H*", $s{'H'}) .
		pack("H*", $s{'block'}) .
		pack("N",  $s{'blockcnt'}) .
		pack("N",  $s{'lenhh'}) .
		pack("N",  $s{'lenhl'}) .
		pack("N",  $s{'lenlh'}) .
		pack("N",  $s{'lenll'})
	);

	return $class->new($s{'alg'})->_putstate($packed_state);
}

sub dump {
	my $self = shift;
	my $file = shift;

	my $state = $self->getstate or return;
	$file = "-" if (!defined($file) || $file eq "");

	local *FH;
	open(FH, "> $file") or return;
	print FH $state;
	close(FH);

	return($self);
}

sub load {
	my $class = shift;
	my $file = shift;

	$file = "-" if (!defined($file) || $file eq "");

	local *FH;
	open(FH, "< $file") or return;
	my $str = join('', <FH>);
	close(FH);

	$class->putstate($str);
}

Digest::SHA->bootstrap($VERSION);

1;
__END__

=head1 NAME

Digest::SHA - Perl extension for SHA-1/224/256/384/512

=head1 SYNOPSIS

In programs:

		# Functional interface

	use Digest::SHA qw(sha1 sha1_hex sha1_base64 ...);

	$digest = sha1($data);
	$digest = sha1_hex($data);
	$digest = sha1_base64($data);

	$digest = sha256($data);
	$digest = sha384_hex($data);
	$digest = sha512_base64($data);

		# Object-oriented

	use Digest::SHA;

	$sha = Digest::SHA->new($alg);

	$sha->add($data);		# feed data into stream

	$sha->addfile(*F);
	$sha->addfile($filename);

	$sha->add_bits($bits);
	$sha->add_bits($data, $nbits);

	$sha_copy = $sha->clone;	# make copy of digest object
	$state = $sha->getstate;	# save current state to string
	$sha->putstate($state);		# restore previous $state

	$digest = $sha->digest;		# compute digest
	$digest = $sha->hexdigest;
	$digest = $sha->b64digest;

From the command line:

	$ shasum files

	$ shasum --help

=head1 SYNOPSIS (HMAC-SHA)

		# Functional interface only

	use Digest::SHA qw(hmac_sha1 hmac_sha1_hex ...);

	$digest = hmac_sha1($data, $key);
	$digest = hmac_sha224_hex($data, $key);
	$digest = hmac_sha256_base64($data, $key);

=head1 ABSTRACT

Digest::SHA is a complete implementation of the NIST Secure Hash Standard.
It gives Perl programmers a convenient way to calculate SHA-1, SHA-224,
SHA-256, SHA-384, SHA-512, SHA-512/224, and SHA-512/256 message digests.
The module can handle all types of input, including partial-byte data.

=head1 DESCRIPTION

Digest::SHA is written in C for speed.  If your platform lacks a
C compiler, you can install the functionally equivalent (but much
slower) L<Digest::SHA::PurePerl> module.

The programming interface is easy to use: it's the same one found
in CPAN's L<Digest> module.  So, if your applications currently
use L<Digest::MD5> and you'd prefer the stronger security of SHA,
it's a simple matter to convert them.

The interface provides two ways to calculate digests:  all-at-once,
or in stages.  To illustrate, the following short program computes
the SHA-256 digest of "hello world" using each approach:

	use Digest::SHA qw(sha256_hex);

	$data = "hello world";
	@frags = split(//, $data);

	# all-at-once (Functional style)
	$digest1 = sha256_hex($data);

	# in-stages (OOP style)
	$state = Digest::SHA->new(256);
	for (@frags) { $state->add($_) }
	$digest2 = $state->hexdigest;

	print $digest1 eq $digest2 ?
		"whew!\n" : "oops!\n";

To calculate the digest of an n-bit message where I<n> is not a
multiple of 8, use the I<add_bits()> method.  For example, consider
the 446-bit message consisting of the bit-string "110" repeated
148 times, followed by "11".  Here's how to display its SHA-1
digest:

	use Digest::SHA;
	$bits = "110" x 148 . "11";
	$sha = Digest::SHA->new(1)->add_bits($bits);
	print $sha->hexdigest, "\n";

Note that for larger bit-strings, it's more efficient to use the
two-argument version I<add_bits($data, $nbits)>, where I<$data> is
in the customary packed binary format used for Perl strings.

The module also lets you save intermediate SHA states to a string.  The
I<getstate()> method generates portable, human-readable text describing
the current state of computation.  You can subsequently restore that
state with I<putstate()> to resume where the calculation left off.

To see what a state description looks like, just run the following:

	use Digest::SHA;
	print Digest::SHA->new->add("Shaw" x 1962)->getstate;

As an added convenience, the Digest::SHA module offers routines to
calculate keyed hashes using the HMAC-SHA-1/224/256/384/512
algorithms.  These services exist in functional form only, and
mimic the style and behavior of the I<sha()>, I<sha_hex()>, and
I<sha_base64()> functions.

	# Test vector from draft-ietf-ipsec-ciph-sha-256-01.txt

	use Digest::SHA qw(hmac_sha256_hex);
	print hmac_sha256_hex("Hi There", chr(0x0b) x 32), "\n";

=head1 UNICODE AND SIDE EFFECTS

Perl supports Unicode strings as of version 5.6.  Such strings may
contain wide characters, namely, characters whose ordinal values are
greater than 255.  This can cause problems for digest algorithms such
as SHA that are specified to operate on sequences of bytes.

The rule by which Digest::SHA handles a Unicode string is easy
to state, but potentially confusing to grasp: the string is interpreted
as a sequence of byte values, where each byte value is equal to the
ordinal value (viz. code point) of its corresponding Unicode character.
That way, the Unicode string 'abc' has exactly the same digest value as
the ordinary string 'abc'.

Since a wide character does not fit into a byte, the Digest::SHA
routines croak if they encounter one.  Whereas if a Unicode string
contains no wide characters, the module accepts it quite happily.
The following code illustrates the two cases:

	$str1 = pack('U*', (0..255));
	print sha1_hex($str1);		# ok

	$str2 = pack('U*', (0..256));
	print sha1_hex($str2);		# croaks

Be aware that the digest routines silently convert UTF-8 input into its
equivalent byte sequence in the native encoding (cf. utf8::downgrade).
This side effect influences only the way Perl stores the data internally,
but otherwise leaves the actual value of the data intact.

=head1 NIST STATEMENT ON SHA-1

NIST acknowledges that the work of Prof. Xiaoyun Wang constitutes a
practical collision attack on SHA-1.  Therefore, NIST encourages the
rapid adoption of the SHA-2 hash functions (e.g. SHA-256) for applications
requiring strong collision resistance, such as digital signatures.

ref. L<http://csrc.nist.gov/groups/ST/hash/statement.html>

=head1 PADDING OF BASE64 DIGESTS

By convention, CPAN Digest modules do B<not> pad their Base64 output.
Problems can occur when feeding such digests to other software that
expects properly padded Base64 encodings.

For the time being, any necessary padding must be done by the user.
Fortunately, this is a simple operation: if the length of a Base64-encoded
digest isn't a multiple of 4, simply append "=" characters to the end
of the digest until it is:

	while (length($b64_digest) % 4) {
		$b64_digest .= '=';
	}

To illustrate, I<sha256_base64("abc")> is computed to be

	ungWv48Bz+pBQUDeXa4iI7ADYaOWF3qctBD/YfIAFa0

which has a length of 43.  So, the properly padded version is

	ungWv48Bz+pBQUDeXa4iI7ADYaOWF3qctBD/YfIAFa0=

=head1 EXPORT

None by default.

=head1 EXPORTABLE FUNCTIONS

Provided your C compiler supports a 64-bit type (e.g. the I<long
long> of C99, or I<__int64> used by Microsoft C/C++), all of these
functions will be available for use.  Otherwise, you won't be able
to perform the SHA-384 and SHA-512 transforms, both of which require
64-bit operations.

I<Functional style>

=over 4

=item B<sha1($data, ...)>

=item B<sha224($data, ...)>

=item B<sha256($data, ...)>

=item B<sha384($data, ...)>

=item B<sha512($data, ...)>

=item B<sha512224($data, ...)>

=item B<sha512256($data, ...)>

Logically joins the arguments into a single string, and returns
its SHA-1/224/256/384/512 digest encoded as a binary string.

=item B<sha1_hex($data, ...)>

=item B<sha224_hex($data, ...)>

=item B<sha256_hex($data, ...)>

=item B<sha384_hex($data, ...)>

=item B<sha512_hex($data, ...)>

=item B<sha512224_hex($data, ...)>

=item B<sha512256_hex($data, ...)>

Logically joins the arguments into a single string, and returns
its SHA-1/224/256/384/512 digest encoded as a hexadecimal string.

=item B<sha1_base64($data, ...)>

=item B<sha224_base64($data, ...)>

=item B<sha256_base64($data, ...)>

=item B<sha384_base64($data, ...)>

=item B<sha512_base64($data, ...)>

=item B<sha512224_base64($data, ...)>

=item B<sha512256_base64($data, ...)>

Logically joins the arguments into a single string, and returns
its SHA-1/224/256/384/512 digest encoded as a Base64 string.

It's important to note that the resulting string does B<not> contain
the padding characters typical of Base64 encodings.  This omission is
deliberate, and is done to maintain compatibility with the family of
CPAN Digest modules.  See L</"PADDING OF BASE64 DIGESTS"> for details.

=back

I<OOP style>

=over 4

=item B<new($alg)>

Returns a new Digest::SHA object.  Allowed values for I<$alg> are 1,
224, 256, 384, 512, 512224, or 512256.  It's also possible to use
common string representations of the algorithm (e.g. "sha256",
"SHA-384").  If the argument is missing, SHA-1 will be used by
default.

Invoking I<new> as an instance method will reset the object to the
initial state associated with I<$alg>.  If the argument is missing,
the object will continue using the same algorithm that was selected
at creation.

=item B<reset($alg)>

This method has exactly the same effect as I<new($alg)>.  In fact,
I<reset> is just an alias for I<new>.

=item B<hashsize>

Returns the number of digest bits for this object.  The values are
160, 224, 256, 384, 512, 224, and 256 for SHA-1, SHA-224, SHA-256,
SHA-384, SHA-512, SHA-512/224 and SHA-512/256, respectively.

=item B<algorithm>

Returns the digest algorithm for this object.  The values are 1,
224, 256, 384, 512, 512224, and 512256 for SHA-1, SHA-224, SHA-256,
SHA-384, SHA-512, SHA-512/224, and SHA-512/256, respectively.

=item B<clone>

Returns a duplicate copy of the object.

=item B<add($data, ...)>

Logically joins the arguments into a single string, and uses it to
update the current digest state.  In other words, the following
statements have the same effect:

	$sha->add("a"); $sha->add("b"); $sha->add("c");
	$sha->add("a")->add("b")->add("c");
	$sha->add("a", "b", "c");
	$sha->add("abc");

The return value is the updated object itself.

=item B<add_bits($data, $nbits)>

=item B<add_bits($bits)>

Updates the current digest state by appending bits to it.  The
return value is the updated object itself.

The first form causes the most-significant I<$nbits> of I<$data>
to be appended to the stream.  The I<$data> argument is in the
customary binary format used for Perl strings.

The second form takes an ASCII string of "0" and "1" characters as
its argument.  It's equivalent to

	$sha->add_bits(pack("B*", $bits), length($bits));

So, the following two statements do the same thing:

	$sha->add_bits("111100001010");
	$sha->add_bits("\xF0\xA0", 12);

Note that SHA-1 and SHA-2 use I<most-significant-bit ordering>
for their internal state.  This means that

	$sha3->add_bits("110");

is equivalent to

	$sha3->add_bits("1")->add_bits("1")->add_bits("0");

=item B<addfile(*FILE)>

Reads from I<FILE> until EOF, and appends that data to the current
state.  The return value is the updated object itself.

=item B<addfile($filename [, $mode])>

Reads the contents of I<$filename>, and appends that data to the current
state.  The return value is the updated object itself.

By default, I<$filename> is simply opened and read; no special modes
or I/O disciplines are used.  To change this, set the optional I<$mode>
argument to one of the following values:

	"b"	read file in binary mode

	"U"	use universal newlines

	"0"	use BITS mode

	"p"	use portable mode (to be deprecated)

The "U" mode is modeled on Python's "Universal Newlines" concept, whereby
DOS and Mac OS line terminators are converted internally to UNIX newlines
before processing.  This ensures consistent digest values when working
simultaneously across multiple file systems.  B<The "U" mode influences
only text files>, namely those passing Perl's I<-T> test; binary files
are processed with no translation whatsoever.

The "p" mode differs from "U" only in that it treats "\r\r\n" as a single
newline, a quirky feature designed to accommodate legacy applications that
occasionally added an extra carriage return before DOS line terminators.
The "p" mode will be phased out eventually in favor of the cleaner and
more well-established Universal Newlines concept.

The BITS mode ("0") interprets the contents of I<$filename> as a logical
stream of bits, where each ASCII '0' or '1' character represents a 0 or
1 bit, respectively.  All other characters are ignored.  This provides
a convenient way to calculate the digest values of partial-byte data
by using files, rather than having to write separate programs employing
the I<add_bits> method.

=item B<getstate>

Returns a string containing a portable, human-readable representation
of the current SHA state.

=item B<putstate($str)>

Returns a Digest::SHA object representing the SHA state contained
in I<$str>.  The format of I<$str> matches the format of the output
produced by method I<getstate>.  If called as a class method, a new
object is created; if called as an instance method, the object is reset
to the state contained in I<$str>.

=item B<dump($filename)>

Writes the output of I<getstate> to I<$filename>.  If the argument is
missing, or equal to the empty string, the state information will be
written to STDOUT.

=item B<load($filename)>

Returns a Digest::SHA object that results from calling I<putstate> on
the contents of I<$filename>.  If the argument is missing, or equal to
the empty string, the state information will be read from STDIN.

=item B<digest>

Returns the digest encoded as a binary string.

Note that the I<digest> method is a read-once operation. Once it
has been performed, the Digest::SHA object is automatically reset
in preparation for calculating another digest value.  Call
I<$sha-E<gt>clone-E<gt>digest> if it's necessary to preserve the
original digest state.

=item B<hexdigest>

Returns the digest encoded as a hexadecimal string.

Like I<digest>, this method is a read-once operation.  Call
I<$sha-E<gt>clone-E<gt>hexdigest> if it's necessary to preserve
the original digest state.

=item B<b64digest>

Returns the digest encoded as a Base64 string.

Like I<digest>, this method is a read-once operation.  Call
I<$sha-E<gt>clone-E<gt>b64digest> if it's necessary to preserve
the original digest state.

It's important to note that the resulting string does B<not> contain
the padding characters typical of Base64 encodings.  This omission is
deliberate, and is done to maintain compatibility with the family of
CPAN Digest modules.  See L</"PADDING OF BASE64 DIGESTS"> for details.

=back

I<HMAC-SHA-1/224/256/384/512>

=over 4

=item B<hmac_sha1($data, $key)>

=item B<hmac_sha224($data, $key)>

=item B<hmac_sha256($data, $key)>

=item B<hmac_sha384($data, $key)>

=item B<hmac_sha512($data, $key)>

=item B<hmac_sha512224($data, $key)>

=item B<hmac_sha512256($data, $key)>

Returns the HMAC-SHA-1/224/256/384/512 digest of I<$data>/I<$key>,
with the result encoded as a binary string.  Multiple I<$data>
arguments are allowed, provided that I<$key> is the last argument
in the list.

=item B<hmac_sha1_hex($data, $key)>

=item B<hmac_sha224_hex($data, $key)>

=item B<hmac_sha256_hex($data, $key)>

=item B<hmac_sha384_hex($data, $key)>

=item B<hmac_sha512_hex($data, $key)>

=item B<hmac_sha512224_hex($data, $key)>

=item B<hmac_sha512256_hex($data, $key)>

Returns the HMAC-SHA-1/224/256/384/512 digest of I<$data>/I<$key>,
with the result encoded as a hexadecimal string.  Multiple I<$data>
arguments are allowed, provided that I<$key> is the last argument
in the list.

=item B<hmac_sha1_base64($data, $key)>

=item B<hmac_sha224_base64($data, $key)>

=item B<hmac_sha256_base64($data, $key)>

=item B<hmac_sha384_base64($data, $key)>

=item B<hmac_sha512_base64($data, $key)>

=item B<hmac_sha512224_base64($data, $key)>

=item B<hmac_sha512256_base64($data, $key)>

Returns the HMAC-SHA-1/224/256/384/512 digest of I<$data>/I<$key>,
with the result encoded as a Base64 string.  Multiple I<$data>
arguments are allowed, provided that I<$key> is the last argument
in the list.

It's important to note that the resulting string does B<not> contain
the padding characters typical of Base64 encodings.  This omission is
deliberate, and is done to maintain compatibility with the family of
CPAN Digest modules.  See L</"PADDING OF BASE64 DIGESTS"> for details.

=back

=head1 SEE ALSO

L<Digest>, L<Digest::SHA::PurePerl>

The Secure Hash Standard (Draft FIPS PUB 180-4) can be found at:

L<http://csrc.nist.gov/publications/drafts/fips180-4/Draft-FIPS180-4_Feb2011.pdf>

The Keyed-Hash Message Authentication Code (HMAC):

L<http://csrc.nist.gov/publications/fips/fips198/fips-198a.pdf>

=head1 AUTHOR

	Mark Shelor	<mshelor@cpan.org>

=head1 ACKNOWLEDGMENTS

The author is particularly grateful to

	Gisle Aas
	H. Merijn Brand
	Sean Burke
	Chris Carey
	Alexandr Ciornii
	Jim Doble
	Thomas Drugeon
	Julius Duque
	Jeffrey Friedl
	Robert Gilmour
	Brian Gladman
	Jarkko Hietaniemi
	Adam Kennedy
	Mark Lawrence
	Andy Lester
	Alex Muntada
	Steve Peters
	Chris Skiscim
	Martin Thurn
	Gunnar Wolf
	Adam Woodbury

"who by trained skill rescued life from such great billows and such thick
darkness and moored it in so perfect a calm and in so brilliant a light"
- Lucretius

=head1 COPYRIGHT AND LICENSE

Copyright (C) 2003-2015 Mark Shelor

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

L<perlartistic>

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              package Encode::Alias;
use strict;
use warnings;
no warnings 'redefine';
our $VERSION = do { my @r = ( q$Revision: 2.20 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
use constant DEBUG => !!$ENV{PERL_ENCODE_DEBUG};

use Exporter 'import';

# Public, encouraged API is exported by default

our @EXPORT =
  qw (
  define_alias
  find_alias
);

our @Alias;    # ordered matching list
our %Alias;    # cached known aliases

sub find_alias {
    require Encode;
    my $class = shift;
    my $find  = shift;
    unless ( exists $Alias{$find} ) {
        $Alias{$find} = undef;    # Recursion guard
        for ( my $i = 0 ; $i < @Alias ; $i += 2 ) {
            my $alias = $Alias[$i];
            my $val   = $Alias[ $i + 1 ];
            my $new;
            if ( ref($alias) eq 'Regexp' && $find =~ $alias ) {
                DEBUG and warn "eval $val";
                $new = eval $val;
                DEBUG and $@ and warn "$val, $@";
            }
            elsif ( ref($alias) eq 'CODE' ) {
                DEBUG and warn "$alias", "->", "($find)";
                $new = $alias->($find);
            }
            elsif ( lc($find) eq lc($alias) ) {
                $new = $val;
            }
            if ( defined($new) ) {
                next if $new eq $find;    # avoid (direct) recursion on bugs
                DEBUG and warn "$alias, $new";
                my $enc =
                  ( ref($new) ) ? $new : Encode::find_encoding($new);
                if ($enc) {
                    $Alias{$find} = $enc;
                    last;
                }
            }
        }

        # case insensitive search when canonical is not in all lowercase
        # RT ticket #7835
        unless ( $Alias{$find} ) {
            my $lcfind = lc($find);
            for my $name ( keys %Encode::Encoding, keys %Encode::ExtModule )
            {
                $lcfind eq lc($name) or next;
                $Alias{$find} = Encode::find_encoding($name);
                DEBUG and warn "$find => $name";
            }
        }
    }
    if (DEBUG) {
        my $name;
        if ( my $e = $Alias{$find} ) {
            $name = $e->name;
        }
        else {
            $name = "";
        }
        warn "find_alias($class, $find)->name = $name";
    }
    return $Alias{$find};
}

sub define_alias {
    while (@_) {
        my ( $alias, $name ) = splice( @_, 0, 2 );
        unshift( @Alias, $alias => $name );    # newer one has precedence
        if ( ref($alias) ) {

            # clear %Alias cache to allow overrides
            my @a = keys %Alias;
            for my $k (@a) {
                if ( ref($alias) eq 'Regexp' && $k =~ $alias ) {
                    DEBUG and warn "delete \$Alias\{$k\}";
                    delete $Alias{$k};
                }
                elsif ( ref($alias) eq 'CODE' && $alias->($k) ) {
                    DEBUG and warn "delete \$Alias\{$k\}";
                    delete $Alias{$k};
                }
            }
        }
        else {
            DEBUG and warn "delete \$Alias\{$alias\}";
            delete $Alias{$alias};
        }
    }
}

# Allow latin-1 style names as well
# 0  1  2  3  4  5   6   7   8   9  10
our @Latin2iso = ( 0, 1, 2, 3, 4, 9, 10, 13, 14, 15, 16 );

# Allow winlatin1 style names as well
our %Winlatin2cp = (
    'latin1'     => 1252,
    'latin2'     => 1250,
    'cyrillic'   => 1251,
    'greek'      => 1253,
    'turkish'    => 1254,
    'hebrew'     => 1255,
    'arabic'     => 1256,
    'baltic'     => 1257,
    'vietnamese' => 1258,
);

init_aliases();

sub undef_aliases {
    @Alias = ();
    %Alias = ();
}

sub init_aliases {
    require Encode;
    undef_aliases();

    # Try all-lower-case version should all else fails
    define_alias( qr/^(.*)$/ => '"\L$1"' );

    # UTF/UCS stuff
    define_alias( qr/^(unicode-1-1-)?UTF-?7$/i     => '"UTF-7"' );
    define_alias( qr/^UCS-?2-?LE$/i => '"UCS-2LE"' );
    define_alias(
        qr/^UCS-?2-?(BE)?$/i    => '"UCS-2BE"',
        qr/^UCS-?4-?(BE|LE|)?$/i => 'uc("UTF-32$1")',
        qr/^iso-10646-1$/i      => '"UCS-2BE"'
    );
    define_alias(
        qr/^UTF-?(16|32)-?BE$/i => '"UTF-$1BE"',
        qr/^UTF-?(16|32)-?LE$/i => '"UTF-$1LE"',
        qr/^UTF-?(16|32)$/i     => '"UTF-$1"',
    );

    # ASCII
    define_alias( qr/^(?:US-?)ascii$/i       => '"ascii"' );
    define_alias( 'C'                        => 'ascii' );
    define_alias( qr/\b(?:ISO[-_]?)?646(?:[-_]?US)?$/i => '"ascii"' );

    # Allow variants of iso-8859-1 etc.
    define_alias( qr/\biso[-_]?(\d+)[-_](\d+)$/i => '"iso-$1-$2"' );

    # At least HP-UX has these.
    define_alias( qr/\biso8859(\d+)$/i => '"iso-8859-$1"' );

    # More HP stuff.
    define_alias(
        qr/\b(?:hp-)?(arabic|greek|hebrew|kana|roman|thai|turkish)8$/i =>
          '"${1}8"' );

    # The Official name of ASCII.
    define_alias( qr/\bANSI[-_]?X3\.4[-_]?1968$/i => '"ascii"' );

    # This is a font issue, not an encoding issue.
    # (The currency symbol of the Latin 1 upper half
    #  has been redefined as the euro symbol.)
    define_alias( qr/^(.+)\@euro$/i => '"$1"' );

    define_alias( qr/\b(?:iso[-_]?)?latin[-_]?(\d+)$/i =>
'defined $Encode::Alias::Latin2iso[$1] ? "iso-8859-$Encode::Alias::Latin2iso[$1]" : undef'
    );

    define_alias(
        qr/\bwin(latin[12]|cyrillic|baltic|greek|turkish|
             hebrew|arabic|baltic|vietnamese)$/ix =>
          '"cp" . $Encode::Alias::Winlatin2cp{lc($1)}'
    );

    # Common names for non-latin preferred MIME names
    define_alias(
        'ascii'    => 'US-ascii',
        'cyrillic' => 'iso-8859-5',
        'arabic'   => 'iso-8859-6',
        'greek'    => 'iso-8859-7',
        'hebrew'   => 'iso-8859-8',
        'thai'     => 'iso-8859-11',
    );
    # RT #20781
    define_alias(qr/\btis-?620\b/i  => '"iso-8859-11"');

    # At least AIX has IBM-NNN (surprisingly...) instead of cpNNN.
    # And Microsoft has their own naming (again, surprisingly).
    # And windows-* is registered in IANA!
    define_alias(
        qr/\b(?:cp|ibm|ms|windows)[-_ ]?(\d{2,4})$/i => '"cp$1"' );

    # Sometimes seen with a leading zero.
    # define_alias( qr/\bcp037\b/i => '"cp37"');

    # Mac Mappings
    # predefined in *.ucm; unneeded
    # define_alias( qr/\bmacIcelandic$/i => '"macIceland"');
    define_alias( qr/^(?:x[_-])?mac[_-](.*)$/i => '"mac$1"' );
    # http://rt.cpan.org/Ticket/Display.html?id=36326
    define_alias( qr/^macintosh$/i => '"MacRoman"' );
    # https://rt.cpan.org/Ticket/Display.html?id=78125
    define_alias( qr/^macce$/i => '"MacCentralEurRoman"' );
    # Ououououou. gone.  They are different!
    # define_alias( qr/\bmacRomanian$/i => '"macRumanian"');

    # Standardize on the dashed versions.
    define_alias( qr/\bkoi8[\s\-_]*([ru])$/i => '"koi8-$1"' );

    unless ($Encode::ON_EBCDIC) {

        # for Encode::CN
        define_alias( qr/\beuc.*cn$/i => '"euc-cn"' );
        define_alias( qr/\bcn.*euc$/i => '"euc-cn"' );

        # define_alias( qr/\bGB[- ]?(\d+)$/i => '"euc-cn"' )
        # CP936 doesn't have vendor-addon for GBK, so they're identical.
        define_alias( qr/^gbk$/i => '"cp936"' );

        # This fixes gb2312 vs. euc-cn confusion, practically
        define_alias( qr/\bGB[-_ ]?2312(?!-?raw)/i => '"euc-cn"' );

        # for Encode::JP
        define_alias( qr/\bjis$/i         => '"7bit-jis"' );
        define_alias( qr/\beuc.*jp$/i     => '"euc-jp"' );
        define_alias( qr/\bjp.*euc$/i     => '"euc-jp"' );
        define_alias( qr/\bujis$/i        => '"euc-jp"' );
        define_alias( qr/\bshift.*jis$/i  => '"shiftjis"' );
        define_alias( qr/\bsjis$/i        => '"shiftjis"' );
        define_alias( qr/\bwindows-31j$/i => '"cp932"' );

        # for Encode::KR
        define_alias( qr/\beuc.*kr$/i => '"euc-kr"' );
        define_alias( qr/\bkr.*euc$/i => '"euc-kr"' );

        # This fixes ksc5601 vs. euc-kr confusion, practically
        define_alias( qr/(?:x-)?uhc$/i         => '"cp949"' );
        define_alias( qr/(?:x-)?windows-949$/i => '"cp949"' );
        define_alias( qr/\bks_c_5601-1987$/i   => '"cp949"' );

        # for Encode::TW
        define_alias( qr/\bbig-?5$/i              => '"big5-eten"' );
        define_alias( qr/\bbig5-?et(?:en)?$/i     => '"big5-eten"' );
        define_alias( qr/\btca[-_]?big5$/i        => '"big5-eten"' );
        define_alias( qr/\bbig5-?hk(?:scs)?$/i    => '"big5-hkscs"' );
        define_alias( qr/\bhk(?:scs)?[-_]?big5$/i => '"big5-hkscs"' );
    }

    # https://github.com/dankogai/p5-encode/issues/37
    define_alias(qr/cp65000/i => '"UTF-7"');
    define_alias(qr/cp65001/i => '"utf-8-strict"');

    # utf8 is blessed :)
    define_alias( qr/\bUTF-8$/i => '"utf-8-strict"' );

    # At last, Map white space and _ to '-'
    define_alias( qr/^(\S+)[\s_]+(.*)$/i => '"$1-$2"' );
}

1;
__END__

# TODO: HP-UX '8' encodings arabic8 greek8 hebrew8 kana8 thai8 turkish8
# TODO: HP-UX '15' encodings japanese15 korean15 roi15
# TODO: Cyrillic encoding ISO-IR-111 (useful?)
# TODO: Armenian encoding ARMSCII-8
# TODO: Hebrew encoding ISO-8859-8-1
# TODO: Thai encoding TCVN
# TODO: Vietnamese encodings VPS
# TODO: Mac Asian+African encodings: Arabic Armenian Bengali Burmese
#       ChineseSimp ChineseTrad Devanagari Ethiopic ExtArabic
#       Farsi Georgian Gujarati Gurmukhi Hebrew Japanese
#       Kannada Khmer Korean Laotian Malayalam Mongolian
#       Oriya Sinhalese Symbol Tamil Telugu Tibetan Vietnamese

=head1 NAME

Encode::Alias - alias definitions to encodings

=head1 SYNOPSIS

  use Encode;
  use Encode::Alias;
  define_alias( "newName" => ENCODING);
  define_alias( qr/.../ => ENCODING);
  define_alias( sub { return ENCODING if ...; } );

=head1 DESCRIPTION

Allows newName to be used as an alias for ENCODING. ENCODING may be
either the name of an encoding or an encoding object (as described 
in L<Encode>).

Currently the first argument to define_alias() can be specified in the
following ways:

=over 4

=item As a simple string.

=item As a qr// compiled regular expression, e.g.:

  define_alias( qr/^iso8859-(\d+)$/i => '"iso-8859-$1"' );

In this case, if I<ENCODING> is not a reference, it is C<eval>-ed
in order to allow C<$1> etc. to be substituted.  The example is one
way to alias names as used in X11 fonts to the MIME names for the
iso-8859-* family.  Note the double quotes inside the single quotes.

(or, you don't have to do this yourself because this example is predefined)

If you are using a regex here, you have to use the quotes as shown or
it won't work.  Also note that regex handling is tricky even for the
experienced.  Use this feature with caution.

=item As a code reference, e.g.:

  define_alias( sub {shift =~ /^iso8859-(\d+)$/i ? "iso-8859-$1" : undef } );

The same effect as the example above in a different way.  The coderef
takes the alias name as an argument and returns a canonical name on
success or undef if not.  Note the second argument is ignored if provided.
Use this with even more caution than the regex version.

=back

=head3 Changes in code reference aliasing

As of Encode 1.87, the older form

  define_alias( sub { return  /^iso8859-(\d+)$/i ? "iso-8859-$1" : undef } );

no longer works. 

Encode up to 1.86 internally used "local $_" to implement this older
form.  But consider the code below;

  use Encode;
  $_ = "eeeee" ;
  while (/(e)/g) {
    my $utf = decode('aliased-encoding-name', $1);
    print "position:",pos,"\n";
  }

Prior to Encode 1.86 this fails because of "local $_".

=head2 Alias overloading

You can override predefined aliases by simply applying define_alias().
The new alias is always evaluated first, and when necessary,
define_alias() flushes the internal cache to make the new definition
available.

  # redirect SHIFT_JIS to MS/IBM Code Page 932, which is a
  # superset of SHIFT_JIS

  define_alias( qr/shift.*jis$/i  => '"cp932"' );
  define_alias( qr/sjis$/i        => '"cp932"' );

If you want to zap all predefined aliases, you can use

  Encode::Alias->undef_aliases;

to do so.  And

  Encode::Alias->init_aliases;

gets the factory settings back.

Note that define_alias() will not be able to override the canonical name
of encodings. Encodings are first looked up by canonical name before
potential aliases are tried.

=head1 SEE ALSO

L<Encode>, L<Encode::Supported>

=cut

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          package Encode::Byte;
use strict;
use warnings;
use Encode;
our $VERSION = do { my @r = ( q$Revision: 2.4 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };

use XSLoader;
XSLoader::load( __PACKAGE__, $VERSION );

1;
__END__

=head1 NAME

Encode::Byte - Single Byte Encodings

=head1 SYNOPSIS

    use Encode qw/encode decode/; 
    $greek = encode("iso-8859-7", $utf8);  # loads Encode::Byte implicitly
    $utf8  = decode("iso-8859-7", $greek); # ditto

=head1 ABSTRACT

This module implements various single byte encodings.  For most cases it uses
\x80-\xff (upper half) to map non-ASCII characters.  Encodings
supported are as follows.   

  Canonical      Alias		                      Description
  --------------------------------------------------------------------
  # ISO 8859 series
  (iso-8859-1	is in built-in)
  iso-8859-2	latin2					     [ISO]
  iso-8859-3	latin3					     [ISO]
  iso-8859-4	latin4					     [ISO]
  iso-8859-5						     [ISO]
  iso-8859-6						     [ISO]
  iso-8859-7						     [ISO]
  iso-8859-8						     [ISO]
  iso-8859-9	latin5					     [ISO]
  iso-8859-10	latin6					     [ISO]
  iso-8859-11
  (iso-8859-12 is nonexistent)
  iso-8859-13   latin7					     [ISO]
  iso-8859-14	latin8					     [ISO]
  iso-8859-15	latin9					     [ISO]
  iso-8859-16	latin10					     [ISO]

  # Cyrillic
  koi8-f					
  koi8-r        cp878					 [RFC1489]
  koi8-u						 [RFC2319]

  # Vietnamese
  viscii

  # all cp* are also available as ibm-*, ms-*, and windows-*
  # also see L<http://msdn.microsoft.com/en-us/library/aa752010%28VS.85%29.aspx>

  cp424  
  cp437  
  cp737  
  cp775  
  cp850  
  cp852  
  cp855  
  cp856  
  cp857  
  cp860  
  cp861  
  cp862  
  cp863  
  cp864  
  cp865  
  cp866  
  cp869  
  cp874  
  cp1006  
  cp1250	WinLatin2
  cp1251	WinCyrillic
  cp1252	WinLatin1
  cp1253	WinGreek
  cp1254	WinTurkish
  cp1255	WinHebrew
  cp1256	WinArabic
  cp1257	WinBaltic
  cp1258	WinVietnamese

  # Macintosh
  # Also see L<http://developer.apple.com/technotes/tn/tn1150.html>
  MacArabic  
  MacCentralEurRoman  
  MacCroatian  
  MacCyrillic  
  MacFarsi  
  MacGreek  
  MacHebrew  
  MacIcelandic  
  MacRoman  
  MacRomanian  
  MacRumanian  
  MacSami  
  MacThai  
  MacTurkish  
  MacUkrainian  

  # More vendor encodings
  AdobeStandardEncoding
  nextstep
  hp-roman8

=head1 DESCRIPTION

To find how to use this module in detail, see L<Encode>.

=head1 SEE ALSO

L<Encode>

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  #
# $Id: CJKConstants.pm,v 2.2 2006/06/03 20:28:48 dankogai Exp $
#

package Encode::CJKConstants;

use strict;
use warnings;
our $RCSID = q$Id: CJKConstants.pm,v 2.2 2006/06/03 20:28:48 dankogai Exp $;
our $VERSION = do { my @r = ( q$Revision: 2.2 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };

use Carp;

require Exporter;
our @ISA         = qw(Exporter);
our @EXPORT      = qw();
our @EXPORT_OK   = qw(%CHARCODE %ESC %RE);
our %EXPORT_TAGS = ( 'all' => [ @EXPORT_OK, @EXPORT ] );

my %_0208 = (
    1978 => '\e\$\@',
    1983 => '\e\$B',
    1990 => '\e&\@\e\$B',
);

our %CHARCODE = (
    UNDEF_EUC     => "\xa2\xae",    #  in EUC
    UNDEF_SJIS    => "\x81\xac",    #  in SJIS
    UNDEF_JIS     => "\xa2\xf7",    #  -- used in unicode
    UNDEF_UNICODE => "\x20\x20",    #  -- used in unicode
);

our %ESC = (
    GB_2312   => "\e\$A",
    JIS_0208  => "\e\$B",
    JIS_0212  => "\e\$(D",
    KSC_5601  => "\e\$(C",
    ASC       => "\e\(B",
    KANA      => "\e\(I",
    '2022_KR' => "\e\$)C",
);

our %RE = (
    ASCII     => '[\x00-\x7f]',
    BIN       => '[\x00-\x06\x7f\xff]',
    EUC_0212  => '\x8f[\xa1-\xfe][\xa1-\xfe]',
    EUC_C     => '[\xa1-\xfe][\xa1-\xfe]',
    EUC_KANA  => '\x8e[\xa1-\xdf]',
    JIS_0208  => "$_0208{1978}|$_0208{1983}|$_0208{1990}",
    JIS_0212  => "\e" . '\$\(D',
    ISO_ASC   => "\e" . '\([BJ]',
    JIS_KANA  => "\e" . '\(I',
    '2022_KR' => "\e" . '\$\)C',
    SJIS_C    => '[\x81-\x9f\xe0-\xfc][\x40-\x7e\x80-\xfc]',
    SJIS_KANA => '[\xa1-\xdf]',
    UTF8      => '[\xc0-\xdf][\x80-\xbf]|[\xe0-\xef][\x80-\xbf][\x80-\xbf]'
);

1;

=head1 NAME

Encode::CJKConstants.pm -- Internally used by Encode::??::ISO_2022_*

=cut

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             package Encode::CN;
BEGIN {
    if ( ord("A") == 193 ) {
        die "Encode::CN not supported on EBCDIC\n";
    }
}
use strict;
use warnings;
use Encode;
our $VERSION = do { my @r = ( q$Revision: 2.3 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
use XSLoader;
XSLoader::load( __PACKAGE__, $VERSION );

# Relocated from Encode.pm

use Encode::CN::HZ;

# use Encode::CN::2022_CN;

1;
__END__

=head1 NAME

Encode::CN - China-based Chinese Encodings

=head1 SYNOPSIS

    use Encode qw/encode decode/; 
    $euc_cn = encode("euc-cn", $utf8);   # loads Encode::CN implicitly
    $utf8   = decode("euc-cn", $euc_cn); # ditto

=head1 DESCRIPTION

This module implements China-based Chinese charset encodings.
Encodings supported are as follows.

  Canonical   Alias		Description
  --------------------------------------------------------------------
  euc-cn      /\beuc.*cn$/i	EUC (Extended Unix Character)
          /\bcn.*euc$/i
              /\bGB[-_ ]?2312(?:\D.*$|$)/i (see below)
  gb2312-raw			The raw (low-bit) GB2312 character map
  gb12345-raw			Traditional chinese counterpart to 
                GB2312 (raw)
  iso-ir-165			GB2312 + GB6345 + GB8565 + additions
  MacChineseSimp                GB2312 + Apple Additions
  cp936				Code Page 936, also known as GBK 
                (Extended GuoBiao)
  hz				7-bit escaped GB2312 encoding
  --------------------------------------------------------------------

To find how to use this module in detail, see L<Encode>.

=head1 NOTES

Due to size concerns, C<GB 18030> (an extension to C<GBK>) is distributed
separately on CPAN, under the name L<Encode::HanExtra>. That module
also contains extra Taiwan-based encodings.

=head1 BUGS

When you see C<charset=gb2312> on mails and web pages, they really
mean C<euc-cn> encodings.  To fix that, C<gb2312> is aliased to C<euc-cn>.
Use C<gb2312-raw> when you really mean it.

The ASCII region (0x00-0x7f) is preserved for all encodings, even though
this conflicts with mappings by the Unicode Consortium.

=head1 SEE ALSO

L<Encode>

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      package Encode::EBCDIC;
use strict;
use warnings;
use Encode;
our $VERSION = do { my @r = ( q$Revision: 2.2 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };

use XSLoader;
XSLoader::load( __PACKAGE__, $VERSION );

1;
__END__

=head1 NAME

Encode::EBCDIC - EBCDIC Encodings

=head1 SYNOPSIS

    use Encode qw/encode decode/; 
    $posix_bc  = encode("posix-bc", $utf8); # loads Encode::EBCDIC implicitly
    $utf8 = decode("", $posix_bc);          # ditto

=head1 ABSTRACT

This module implements various EBCDIC-Based encodings.  Encodings
supported are as follows.   

  Canonical   Alias		Description
  --------------------------------------------------------------------
  cp37  
  cp500  
  cp875  
  cp1026  
  cp1047  
  posix-bc

=head1 DESCRIPTION

To find how to use this module in detail, see L<Encode>.

=head1 SEE ALSO

L<Encode>, L<perlebcdic>

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               #
# Demand-load module list
#
package Encode::Config;
our $VERSION = do { my @r = ( q$Revision: 2.5 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };

use strict;
use warnings;

our %ExtModule = (

    # Encode::Byte
    #iso-8859-1 is in Encode.pm itself
    'iso-8859-2'            => 'Encode::Byte',
    'iso-8859-3'            => 'Encode::Byte',
    'iso-8859-4'            => 'Encode::Byte',
    'iso-8859-5'            => 'Encode::Byte',
    'iso-8859-6'            => 'Encode::Byte',
    'iso-8859-7'            => 'Encode::Byte',
    'iso-8859-8'            => 'Encode::Byte',
    'iso-8859-9'            => 'Encode::Byte',
    'iso-8859-10'           => 'Encode::Byte',
    'iso-8859-11'           => 'Encode::Byte',
    'iso-8859-13'           => 'Encode::Byte',
    'iso-8859-14'           => 'Encode::Byte',
    'iso-8859-15'           => 'Encode::Byte',
    'iso-8859-16'           => 'Encode::Byte',
    'koi8-f'                => 'Encode::Byte',
    'koi8-r'                => 'Encode::Byte',
    'koi8-u'                => 'Encode::Byte',
    'viscii'                => 'Encode::Byte',
    'cp424'                 => 'Encode::Byte',
    'cp437'                 => 'Encode::Byte',
    'cp737'                 => 'Encode::Byte',
    'cp775'                 => 'Encode::Byte',
    'cp850'                 => 'Encode::Byte',
    'cp852'                 => 'Encode::Byte',
    'cp855'                 => 'Encode::Byte',
    'cp856'                 => 'Encode::Byte',
    'cp857'                 => 'Encode::Byte',
    'cp858'                 => 'Encode::Byte',
    'cp860'                 => 'Encode::Byte',
    'cp861'                 => 'Encode::Byte',
    'cp862'                 => 'Encode::Byte',
    'cp863'                 => 'Encode::Byte',
    'cp864'                 => 'Encode::Byte',
    'cp865'                 => 'Encode::Byte',
    'cp866'                 => 'Encode::Byte',
    'cp869'                 => 'Encode::Byte',
    'cp874'                 => 'Encode::Byte',
    'cp1006'                => 'Encode::Byte',
    'cp1250'                => 'Encode::Byte',
    'cp1251'                => 'Encode::Byte',
    'cp1252'                => 'Encode::Byte',
    'cp1253'                => 'Encode::Byte',
    'cp1254'                => 'Encode::Byte',
    'cp1255'                => 'Encode::Byte',
    'cp1256'                => 'Encode::Byte',
    'cp1257'                => 'Encode::Byte',
    'cp1258'                => 'Encode::Byte',
    'AdobeStandardEncoding' => 'Encode::Byte',
    'MacArabic'             => 'Encode::Byte',
    'MacCentralEurRoman'    => 'Encode::Byte',
    'MacCroatian'           => 'Encode::Byte',
    'MacCyrillic'           => 'Encode::Byte',
    'MacFarsi'              => 'Encode::Byte',
    'MacGreek'              => 'Encode::Byte',
    'MacHebrew'             => 'Encode::Byte',
    'MacIcelandic'          => 'Encode::Byte',
    'MacRoman'              => 'Encode::Byte',
    'MacRomanian'           => 'Encode::Byte',
    'MacRumanian'           => 'Encode::Byte',
    'MacSami'               => 'Encode::Byte',
    'MacThai'               => 'Encode::Byte',
    'MacTurkish'            => 'Encode::Byte',
    'MacUkrainian'          => 'Encode::Byte',
    'nextstep'              => 'Encode::Byte',
    'hp-roman8'             => 'Encode::Byte',
    #'gsm0338'               => 'Encode::Byte',
    'gsm0338'               => 'Encode::GSM0338',

    # Encode::EBCDIC
    'cp37'     => 'Encode::EBCDIC',
    'cp500'    => 'Encode::EBCDIC',
    'cp875'    => 'Encode::EBCDIC',
    'cp1026'   => 'Encode::EBCDIC',
    'cp1047'   => 'Encode::EBCDIC',
    'posix-bc' => 'Encode::EBCDIC',

    # Encode::Symbol
    'dingbats'      => 'Encode::Symbol',
    'symbol'        => 'Encode::Symbol',
    'AdobeSymbol'   => 'Encode::Symbol',
    'AdobeZdingbat' => 'Encode::Symbol',
    'MacDingbats'   => 'Encode::Symbol',
    'MacSymbol'     => 'Encode::Symbol',

    # Encode::Unicode
    'UCS-2BE'  => 'Encode::Unicode',
    'UCS-2LE'  => 'Encode::Unicode',
    'UTF-16'   => 'Encode::Unicode',
    'UTF-16BE' => 'Encode::Unicode',
    'UTF-16LE' => 'Encode::Unicode',
    'UTF-32'   => 'Encode::Unicode',
    'UTF-32BE' => 'Encode::Unicode',
    'UTF-32LE' => 'Encode::Unicode',
    'UTF-7'    => 'Encode::Unicode::UTF7',
);

unless ( ord("A") == 193 ) {
    %ExtModule = (
        %ExtModule,
        'euc-cn'         => 'Encode::CN',
        'gb12345-raw'    => 'Encode::CN',
        'gb2312-raw'     => 'Encode::CN',
        'hz'             => 'Encode::CN',
        'iso-ir-165'     => 'Encode::CN',
        'cp936'          => 'Encode::CN',
        'MacChineseSimp' => 'Encode::CN',

        '7bit-jis'      => 'Encode::JP',
        'euc-jp'        => 'Encode::JP',
        'iso-2022-jp'   => 'Encode::JP',
        'iso-2022-jp-1' => 'Encode::JP',
        'jis0201-raw'   => 'Encode::JP',
        'jis0208-raw'   => 'Encode::JP',
        'jis0212-raw'   => 'Encode::JP',
        'cp932'         => 'Encode::JP',
        'MacJapanese'   => 'Encode::JP',
        'shiftjis'      => 'Encode::JP',

        'euc-kr'      => 'Encode::KR',
        'iso-2022-kr' => 'Encode::KR',
        'johab'       => 'Encode::KR',
        'ksc5601-raw' => 'Encode::KR',
        'cp949'       => 'Encode::KR',
        'MacKorean'   => 'Encode::KR',

        'big5-eten'      => 'Encode::TW',
        'big5-hkscs'     => 'Encode::TW',
        'cp950'          => 'Encode::TW',
        'MacChineseTrad' => 'Encode::TW',

        #'big5plus'           => 'Encode::HanExtra',
        #'euc-tw'             => 'Encode::HanExtra',
        #'gb18030'            => 'Encode::HanExtra',

        'MIME-Header' => 'Encode::MIME::Header',
        'MIME-B'      => 'Encode::MIME::Header',
        'MIME-Q'      => 'Encode::MIME::Header',

        'MIME-Header-ISO_2022_JP' => 'Encode::MIME::Header::ISO_2022_JP',
    );
}

#
# Why not export ? to keep ConfigLocal Happy!
#
while ( my ( $enc, $mod ) = each %ExtModule ) {
    $Encode::ExtModule{$enc} = $mod;
}

1;
__END__

=head1 NAME

Encode::Config -- internally used by Encode

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               #
# $Id: Encoder.pm,v 2.3 2013/09/14 07:51:59 dankogai Exp $
#
package Encode::Encoder;
use strict;
use warnings;
our $VERSION = do { my @r = ( q$Revision: 2.3 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };

require Exporter;
our @ISA       = qw(Exporter);
our @EXPORT_OK = qw ( encoder );

our $AUTOLOAD;
use constant DEBUG => !!$ENV{PERL_ENCODE_DEBUG};
use Encode qw(encode decode find_encoding from_to);
use Carp;

sub new {
    my ( $class, $data, $encname ) = @_;
    unless ($encname) {
        $encname = Encode::is_utf8($data) ? 'utf8' : '';
    }
    else {
        my $obj = find_encoding($encname)
          or croak __PACKAGE__, ": unknown encoding: $encname";
        $encname = $obj->name;
    }
    my $self = {
        data     => $data,
        encoding => $encname,
    };
    bless $self => $class;
}

sub encoder { __PACKAGE__->new(@_) }

sub data {
    my ( $self, $data ) = @_;
    if ( defined $data ) {
        $self->{data} = $data;
        return $data;
    }
    else {
        return $self->{data};
    }
}

sub encoding {
    my ( $self, $encname ) = @_;
    if ($encname) {
        my $obj = find_encoding($encname)
          or confess __PACKAGE__, ": unknown encoding: $encname";
        $self->{encoding} = $obj->name;
        return $self;
    }
    else {
        return $self->{encoding};
    }
}

sub bytes {
    my ( $self, $encname ) = @_;
    $encname ||= $self->{encoding};
    my $obj = find_encoding($encname)
      or confess __PACKAGE__, ": unknown encoding: $encname";
    $self->{data} = $obj->decode( $self->{data}, 1 );
    $self->{encoding} = '';
    return $self;
}

sub DESTROY {    # defined so it won't autoload.
    DEBUG and warn shift;
}

sub AUTOLOAD {
    my $self = shift;
    my $type = ref($self)
      or confess "$self is not an object";
    my $myname = $AUTOLOAD;
    $myname =~ s/.*://;    # strip fully-qualified portion
    my $obj = find_encoding($myname)
      or confess __PACKAGE__, ": unknown encoding: $myname";
    DEBUG and warn $self->{encoding}, " => ", $obj->name;
    if ( $self->{encoding} ) {
        from_to( $self->{data}, $self->{encoding}, $obj->name, 1 );
    }
    else {
        $self->{data} = $obj->encode( $self->{data}, 1 );
    }
    $self->{encoding} = $obj->name;
    return $self;
}

use overload
  q("") => sub { $_[0]->{data} },
  q(0+) => sub { use bytes(); bytes::length( $_[0]->{data} ) },
  fallback => 1,
  ;

1;
__END__

=head1 NAME

Encode::Encoder -- Object Oriented Encoder

=head1 SYNOPSIS

  use Encode::Encoder;
  # Encode::encode("ISO-8859-1", $data); 
  Encode::Encoder->new($data)->iso_8859_1; # OOP way
  # shortcut
  use Encode::Encoder qw(encoder);
  encoder($data)->iso_8859_1;
  # you can stack them!
  encoder($data)->iso_8859_1->base64;  # provided base64() is defined
  # you can use it as a decoder as well
  encoder($base64)->bytes('base64')->latin1;
  # stringified
  print encoder($data)->utf8->latin1;  # prints the string in latin1
  # numified
  encoder("\x{abcd}\x{ef}g")->utf8 == 6; # true. bytes::length($data)

=head1 ABSTRACT

B<Encode::Encoder> allows you to use Encode in an object-oriented
style.  This is not only more intuitive than a functional approach,
but also handier when you want to stack encodings.  Suppose you want
your UTF-8 string converted to Latin1 then Base64: you can simply say

  my $base64 = encoder($utf8)->latin1->base64;

instead of

  my $latin1 = encode("latin1", $utf8);
  my $base64 = encode_base64($utf8);

or the lazier and more convoluted

  my $base64 = encode_base64(encode("latin1", $utf8));

=head1 Description

Here is how to use this module.

=over 4

=item *

There are at least two instance variables stored in a hash reference,
{data} and {encoding}.

=item *

When there is no method, it takes the method name as the name of the
encoding and encodes the instance I<data> with I<encoding>.  If successful,
the instance I<encoding> is set accordingly.

=item *

You can retrieve the result via -E<gt>data but usually you don't have to 
because the stringify operator ("") is overridden to do exactly that.

=back

=head2 Predefined Methods

This module predefines the methods below:

=over 4

=item $e = Encode::Encoder-E<gt>new([$data, $encoding]);

returns an encoder object.  Its data is initialized with $data if
present, and its encoding is set to $encoding if present.

When $encoding is omitted, it defaults to utf8 if $data is already in
utf8 or "" (empty string) otherwise.

=item encoder()

is an alias of Encode::Encoder-E<gt>new().  This one is exported on demand.

=item $e-E<gt>data([$data])

When $data is present, sets the instance data to $data and returns the
object itself.  Otherwise, the current instance data is returned.

=item $e-E<gt>encoding([$encoding])

When $encoding is present, sets the instance encoding to $encoding and
returns the object itself.  Otherwise, the current instance encoding is
returned.

=item $e-E<gt>bytes([$encoding])

decodes instance data from $encoding, or the instance encoding if
omitted.  If the conversion is successful, the instance encoding
will be set to "".

The name I<bytes> was deliberately picked to avoid namespace tainting
-- this module may be used as a base class so method names that appear
in Encode::Encoding are avoided.

=back

=head2 Example: base64 transcoder

This module is designed to work with L<Encode::Encoding>.
To make the Base64 transcoder example above really work, you could
write a module like this:

  package Encode::Base64;
  use parent 'Encode::Encoding';
  __PACKAGE__->Define('base64');
  use MIME::Base64;
  sub encode{ 
      my ($obj, $data) = @_; 
      return encode_base64($data);
  }
  sub decode{
      my ($obj, $data) = @_; 
      return decode_base64($data);
  }
  1;
  __END__

And your caller module would be something like this:

  use Encode::Encoder;
  use Encode::Base64;

  # now you can really do the following

  encoder($data)->iso_8859_1->base64;
  encoder($base64)->bytes('base64')->latin1;

=head2 Operator Overloading

This module overloads two operators, stringify ("") and numify (0+).

Stringify dumps the data inside the object.

Numify returns the number of bytes in the instance data.

They come in handy when you want to print or find the size of data.

=head1 SEE ALSO

L<Encode>,
L<Encode::Encoding>

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    package Encode::Encoding;

# Base class for classes which implement encodings
use strict;
use warnings;
our $VERSION = do { my @r = ( q$Revision: 2.7 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };

require Encode;

sub DEBUG { 0 }

sub Define {
    my $obj       = shift;
    my $canonical = shift;
    $obj = bless { Name => $canonical }, $obj unless ref $obj;

    # warn "$canonical => $obj\n";
    Encode::define_encoding( $obj, $canonical, @_ );
}

sub name { return shift->{'Name'} }

sub mime_name{
    require Encode::MIME::Name;
    return Encode::MIME::Name::get_mime_name(shift->name);
}

# sub renew { return $_[0] }

sub renew {
    my $self = shift;
    my $clone = bless {%$self} => ref($self);
    $clone->{renewed}++;    # so the caller can see it
    DEBUG and warn $clone->{renewed};
    return $clone;
}

sub renewed { return $_[0]->{renewed} || 0 }

*new_sequence = \&renew;

sub needs_lines { 0 }

sub perlio_ok {
    eval { require PerlIO::encoding };
    return $@ ? 0 : 1;
}

# (Temporary|legacy) methods

sub toUnicode   { shift->decode(@_) }
sub fromUnicode { shift->encode(@_) }

#
# Needs to be overloaded or just croak
#

sub encode {
    require Carp;
    my $obj = shift;
    my $class = ref($obj) ? ref($obj) : $obj;
    Carp::croak( $class . "->encode() not defined!" );
}

sub decode {
    require Carp;
    my $obj = shift;
    my $class = ref($obj) ? ref($obj) : $obj;
    Carp::croak( $class . "->encode() not defined!" );
}

sub DESTROY { }

1;
__END__

=head1 NAME

Encode::Encoding - Encode Implementation Base Class

=head1 SYNOPSIS

  package Encode::MyEncoding;
  use parent qw(Encode::Encoding);

  __PACKAGE__->Define(qw(myCanonical myAlias));

=head1 DESCRIPTION

As mentioned in L<Encode>, encodings are (in the current
implementation at least) defined as objects. The mapping of encoding
name to object is via the C<%Encode::Encoding> hash.  Though you can
directly manipulate this hash, it is strongly encouraged to use this
base class module and add encode() and decode() methods.

=head2 Methods you should implement

You are strongly encouraged to implement methods below, at least
either encode() or decode().

=over 4

=item -E<gt>encode($string [,$check])

MUST return the octet sequence representing I<$string>. 

=over 2

=item *

If I<$check> is true, it SHOULD modify I<$string> in place to remove
the converted part (i.e.  the whole string unless there is an error).
If perlio_ok() is true, SHOULD becomes MUST.

=item *

If an error occurs, it SHOULD return the octet sequence for the
fragment of string that has been converted and modify $string in-place
to remove the converted part leaving it starting with the problem
fragment.  If perlio_ok() is true, SHOULD becomes MUST.

=item *

If I<$check> is false then C<encode> MUST  make a "best effort" to
convert the string - for example, by using a replacement character.

=back

=item -E<gt>decode($octets [,$check])

MUST return the string that I<$octets> represents.

=over 2

=item *

If I<$check> is true, it SHOULD modify I<$octets> in place to remove
the converted part (i.e.  the whole sequence unless there is an
error).  If perlio_ok() is true, SHOULD becomes MUST.

=item *

If an error occurs, it SHOULD return the fragment of string that has
been converted and modify $octets in-place to remove the converted
part leaving it starting with the problem fragment.  If perlio_ok() is
true, SHOULD becomes MUST.

=item *

If I<$check> is false then C<decode> should make a "best effort" to
convert the string - for example by using Unicode's "\x{FFFD}" as a
replacement character.

=back

=back

If you want your encoding to work with L<encoding> pragma, you should
also implement the method below.

=over 4

=item -E<gt>cat_decode($destination, $octets, $offset, $terminator [,$check])

MUST decode I<$octets> with I<$offset> and concatenate it to I<$destination>.
Decoding will terminate when $terminator (a string) appears in output.
I<$offset> will be modified to the last $octets position at end of decode.
Returns true if $terminator appears output, else returns false.

=back

=head2 Other methods defined in Encode::Encodings

You do not have to override methods shown below unless you have to.

=over 4

=item -E<gt>name

Predefined As:

  sub name  { return shift->{'Name'} }

MUST return the string representing the canonical name of the encoding.

=item -E<gt>mime_name

Predefined As:

  sub mime_name{
    require Encode::MIME::Name;
    return Encode::MIME::Name::get_mime_name(shift->name);
  }

MUST return the string representing the IANA charset name of the encoding.

=item -E<gt>renew

Predefined As:

  sub renew {
    my $self = shift;
    my $clone = bless { %$self } => ref($self);
    $clone->{renewed}++;
    return $clone;
  }

This method reconstructs the encoding object if necessary.  If you need
to store the state during encoding, this is where you clone your object.

PerlIO ALWAYS calls this method to make sure it has its own private
encoding object.

=item -E<gt>renewed

Predefined As:

  sub renewed { $_[0]->{renewed} || 0 }

Tells whether the object is renewed (and how many times).  Some
modules emit C<Use of uninitialized value in null operation> warning
unless the value is numeric so return 0 for false.

=item -E<gt>perlio_ok()

Predefined As:

  sub perlio_ok { 
      eval{ require PerlIO::encoding };
      return $@ ? 0 : 1;
  }

If your encoding does not support PerlIO for some reasons, just;

 sub perlio_ok { 0 }

=item -E<gt>needs_lines()

Predefined As:

  sub needs_lines { 0 };

If your encoding can work with PerlIO but needs line buffering, you
MUST define this method so it returns true.  7bit ISO-2022 encodings
are one example that needs this.  When this method is missing, false
is assumed.

=back

=head2 Example: Encode::ROT13

  package Encode::ROT13;
  use strict;
  use parent qw(Encode::Encoding);

  __PACKAGE__->Define('rot13');

  sub encode($$;$){
      my ($obj, $str, $chk) = @_;
      $str =~ tr/A-Za-z/N-ZA-Mn-za-m/;
      $_[1] = '' if $chk; # this is what in-place edit means
      return $str;
  }

  # Jr pna or ynml yvxr guvf;
  *decode = \&encode;

  1;

=head1 Why the heck Encode API is different?

It should be noted that the I<$check> behaviour is different from the
outer public API. The logic is that the "unchecked" case is useful
when the encoding is part of a stream which may be reporting errors
(e.g. STDERR).  In such cases, it is desirable to get everything
through somehow without causing additional errors which obscure the
original one. Also, the encoding is best placed to know what the
correct replacement character is, so if that is the desired behaviour
then letting low level code do it is the most efficient.

By contrast, if I<$check> is true, the scheme above allows the
encoding to do as much as it can and tell the layer above how much
that was. What is lacking at present is a mechanism to report what
went wrong. The most likely interface will be an additional method
call to the object, or perhaps (to avoid forcing per-stream objects
on otherwise stateless encodings) an additional parameter.

It is also highly desirable that encoding classes inherit from
C<Encode::Encoding> as a base class. This allows that class to define
additional behaviour for all encoding objects.

  package Encode::MyEncoding;
  use parent qw(Encode::Encoding);

  __PACKAGE__->Define(qw(myCanonical myAlias));

to create an object with C<< bless {Name => ...}, $class >>, and call
define_encoding.  They inherit their C<name> method from
C<Encode::Encoding>.

=head2 Compiled Encodings

For the sake of speed and efficiency, most of the encodings are now
supported via a I<compiled form>: XS modules generated from UCM
files.   Encode provides the enc2xs tool to achieve that.  Please see
L<enc2xs> for more details.

=head1 SEE ALSO

L<perlmod>, L<enc2xs>

=begin future

=over 4

=item Scheme 1

The fixup routine gets passed the remaining fragment of string being
processed.  It modifies it in place to remove bytes/characters it can
understand and returns a string used to represent them.  For example:

 sub fixup {
   my $ch = substr($_[0],0,1,'');
   return sprintf("\x{%02X}",ord($ch);
 }

This scheme is close to how the underlying C code for Encode works,
but gives the fixup routine very little context.

=item Scheme 2

The fixup routine gets passed the original string, an index into
it of the problem area, and the output string so far.  It appends
what it wants to the output string and returns a new index into the
original string.  For example:

 sub fixup {
   # my ($s,$i,$d) = @_;
   my $ch = substr($_[0],$_[1],1);
   $_[2] .= sprintf("\x{%02X}",ord($ch);
   return $_[1]+1;
 }

This scheme gives maximal control to the fixup routine but is more
complicated to code, and may require that the internals of Encode be tweaked to
keep the original string intact.

=item Other Schemes

Hybrids of the above.

Multiple return values rather than in-place modifications.

Index into the string could be C<pos($str)> allowing C<s/\G...//>.

=back

=end future

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       #
# $Id: GSM0338.pm,v 2.5 2013/09/14 07:51:59 dankogai Exp $
#
package Encode::GSM0338;

use strict;
use warnings;
use Carp;

use vars qw($VERSION);
$VERSION = do { my @r = ( q$Revision: 2.5 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };

use Encode qw(:fallbacks);

use parent qw(Encode::Encoding);
__PACKAGE__->Define('gsm0338');

sub needs_lines { 1 }
sub perlio_ok   { 0 }

use utf8;
our %UNI2GSM = (
    "\x{0040}" => "\x00",        # COMMERCIAL AT
    "\x{000A}" => "\x0A",        # LINE FEED
    "\x{000C}" => "\x1B\x0A",    # FORM FEED
    "\x{000D}" => "\x0D",        # CARRIAGE RETURN
    "\x{0020}" => "\x20",        # SPACE
    "\x{0021}" => "\x21",        # EXCLAMATION MARK
    "\x{0022}" => "\x22",        # QUOTATION MARK
    "\x{0023}" => "\x23",        # NUMBER SIGN
    "\x{0024}" => "\x02",        # DOLLAR SIGN
    "\x{0025}" => "\x25",        # PERCENT SIGN
    "\x{0026}" => "\x26",        # AMPERSAND
    "\x{0027}" => "\x27",        # APOSTROPHE
    "\x{0028}" => "\x28",        # LEFT PARENTHESIS
    "\x{0029}" => "\x29",        # RIGHT PARENTHESIS
    "\x{002A}" => "\x2A",        # ASTERISK
    "\x{002B}" => "\x2B",        # PLUS SIGN
    "\x{002C}" => "\x2C",        # COMMA
    "\x{002D}" => "\x2D",        # HYPHEN-MINUS
    "\x{002E}" => "\x2E",        # FULL STOP
    "\x{002F}" => "\x2F",        # SOLIDUS
    "\x{0030}" => "\x30",        # DIGIT ZERO
    "\x{0031}" => "\x31",        # DIGIT ONE
    "\x{0032}" => "\x32",        # DIGIT TWO
    "\x{0033}" => "\x33",        # DIGIT THREE
    "\x{0034}" => "\x34",        # DIGIT FOUR
    "\x{0035}" => "\x35",        # DIGIT FIVE
    "\x{0036}" => "\x36",        # DIGIT SIX
    "\x{0037}" => "\x37",        # DIGIT SEVEN
    "\x{0038}" => "\x38",        # DIGIT EIGHT
    "\x{0039}" => "\x39",        # DIGIT NINE
    "\x{003A}" => "\x3A",        # COLON
    "\x{003B}" => "\x3B",        # SEMICOLON
    "\x{003C}" => "\x3C",        # LESS-THAN SIGN
    "\x{003D}" => "\x3D",        # EQUALS SIGN
    "\x{003E}" => "\x3E",        # GREATER-THAN SIGN
    "\x{003F}" => "\x3F",        # QUESTION MARK
    "\x{0041}" => "\x41",        # LATIN CAPITAL LETTER A
    "\x{0042}" => "\x42",        # LATIN CAPITAL LETTER B
    "\x{0043}" => "\x43",        # LATIN CAPITAL LETTER C
    "\x{0044}" => "\x44",        # LATIN CAPITAL LETTER D
    "\x{0045}" => "\x45",        # LATIN CAPITAL LETTER E
    "\x{0046}" => "\x46",        # LATIN CAPITAL LETTER F
    "\x{0047}" => "\x47",        # LATIN CAPITAL LETTER G
    "\x{0048}" => "\x48",        # LATIN CAPITAL LETTER H
    "\x{0049}" => "\x49",        # LATIN CAPITAL LETTER I
    "\x{004A}" => "\x4A",        # LATIN CAPITAL LETTER J
    "\x{004B}" => "\x4B",        # LATIN CAPITAL LETTER K
    "\x{004C}" => "\x4C",        # LATIN CAPITAL LETTER L
    "\x{004D}" => "\x4D",        # LATIN CAPITAL LETTER M
    "\x{004E}" => "\x4E",        # LATIN CAPITAL LETTER N
    "\x{004F}" => "\x4F",        # LATIN CAPITAL LETTER O
    "\x{0050}" => "\x50",        # LATIN CAPITAL LETTER P
    "\x{0051}" => "\x51",        # LATIN CAPITAL LETTER Q
    "\x{0052}" => "\x52",        # LATIN CAPITAL LETTER R
    "\x{0053}" => "\x53",        # LATIN CAPITAL LETTER S
    "\x{0054}" => "\x54",        # LATIN CAPITAL LETTER T
    "\x{0055}" => "\x55",        # LATIN CAPITAL LETTER U
    "\x{0056}" => "\x56",        # LATIN CAPITAL LETTER V
    "\x{0057}" => "\x57",        # LATIN CAPITAL LETTER W
    "\x{0058}" => "\x58",        # LATIN CAPITAL LETTER X
    "\x{0059}" => "\x59",        # LATIN CAPITAL LETTER Y
    "\x{005A}" => "\x5A",        # LATIN CAPITAL LETTER Z
    "\x{005F}" => "\x11",        # LOW LINE
    "\x{0061}" => "\x61",        # LATIN SMALL LETTER A
    "\x{0062}" => "\x62",        # LATIN SMALL LETTER B
    "\x{0063}" => "\x63",        # LATIN SMALL LETTER C
    "\x{0064}" => "\x64",        # LATIN SMALL LETTER D
    "\x{0065}" => "\x65",        # LATIN SMALL LETTER E
    "\x{0066}" => "\x66",        # LATIN SMALL LETTER F
    "\x{0067}" => "\x67",        # LATIN SMALL LETTER G
    "\x{0068}" => "\x68",        # LATIN SMALL LETTER H
    "\x{0069}" => "\x69",        # LATIN SMALL LETTER I
    "\x{006A}" => "\x6A",        # LATIN SMALL LETTER J
    "\x{006B}" => "\x6B",        # LATIN SMALL LETTER K
    "\x{006C}" => "\x6C",        # LATIN SMALL LETTER L
    "\x{006D}" => "\x6D",        # LATIN SMALL LETTER M
    "\x{006E}" => "\x6E",        # LATIN SMALL LETTER N
    "\x{006F}" => "\x6F",        # LATIN SMALL LETTER O
    "\x{0070}" => "\x70",        # LATIN SMALL LETTER P
    "\x{0071}" => "\x71",        # LATIN SMALL LETTER Q
    "\x{0072}" => "\x72",        # LATIN SMALL LETTER R
    "\x{0073}" => "\x73",        # LATIN SMALL LETTER S
    "\x{0074}" => "\x74",        # LATIN SMALL LETTER T
    "\x{0075}" => "\x75",        # LATIN SMALL LETTER U
    "\x{0076}" => "\x76",        # LATIN SMALL LETTER V
    "\x{0077}" => "\x77",        # LATIN SMALL LETTER W
    "\x{0078}" => "\x78",        # LATIN SMALL LETTER X
    "\x{0079}" => "\x79",        # LATIN SMALL LETTER Y
    "\x{007A}" => "\x7A",        # LATIN SMALL LETTER Z
    "\x{000C}" => "\x1B\x0A",    # FORM FEED
    "\x{005B}" => "\x1B\x3C",    # LEFT SQUARE BRACKET
    "\x{005C}" => "\x1B\x2F",    # REVERSE SOLIDUS
    "\x{005D}" => "\x1B\x3E",    # RIGHT SQUARE BRACKET
    "\x{005E}" => "\x1B\x14",    # CIRCUMFLEX ACCENT
    "\x{007B}" => "\x1B\x28",    # LEFT CURLY BRACKET
    "\x{007C}" => "\x1B\x40",    # VERTICAL LINE
    "\x{007D}" => "\x1B\x29",    # RIGHT CURLY BRACKET
    "\x{007E}" => "\x1B\x3D",    # TILDE
    "\x{00A0}" => "\x1B",        # NO-BREAK SPACE
    "\x{00A1}" => "\x40",        # INVERTED EXCLAMATION MARK
    "\x{00A3}" => "\x01",        # POUND SIGN
    "\x{00A4}" => "\x24",        # CURRENCY SIGN
    "\x{00A5}" => "\x03",        # YEN SIGN
    "\x{00A7}" => "\x5F",        # SECTION SIGN
    "\x{00BF}" => "\x60",        # INVERTED QUESTION MARK
    "\x{00C4}" => "\x5B",        # LATIN CAPITAL LETTER A WITH DIAERESIS
    "\x{00C5}" => "\x0E",        # LATIN CAPITAL LETTER A WITH RING ABOVE
    "\x{00C6}" => "\x1C",        # LATIN CAPITAL LETTER AE
    "\x{00C9}" => "\x1F",        # LATIN CAPITAL LETTER E WITH ACUTE
    "\x{00D1}" => "\x5D",        # LATIN CAPITAL LETTER N WITH TILDE
    "\x{00D6}" => "\x5C",        # LATIN CAPITAL LETTER O WITH DIAERESIS
    "\x{00D8}" => "\x0B",        # LATIN CAPITAL LETTER O WITH STROKE
    "\x{00DC}" => "\x5E",        # LATIN CAPITAL LETTER U WITH DIAERESIS
    "\x{00DF}" => "\x1E",        # LATIN SMALL LETTER SHARP S
    "\x{00E0}" => "\x7F",        # LATIN SMALL LETTER A WITH GRAVE
    "\x{00E4}" => "\x7B",        # LATIN SMALL LETTER A WITH DIAERESIS
    "\x{00E5}" => "\x0F",        # LATIN SMALL LETTER A WITH RING ABOVE
    "\x{00E6}" => "\x1D",        # LATIN SMALL LETTER AE
    #"\x{00E7}" => "\x09",        # LATIN SMALL LETTER C WITH CEDILLA
    "\x{00C7}" => "\x09",        # LATIN CAPITAL LETTER C WITH CEDILLA
    "\x{00E8}" => "\x04",        # LATIN SMALL LETTER E WITH GRAVE
    "\x{00E9}" => "\x05",        # LATIN SMALL LETTER E WITH ACUTE
    "\x{00EC}" => "\x07",        # LATIN SMALL LETTER I WITH GRAVE
    "\x{00F1}" => "\x7D",        # LATIN SMALL LETTER N WITH TILDE
    "\x{00F2}" => "\x08",        # LATIN SMALL LETTER O WITH GRAVE
    "\x{00F6}" => "\x7C",        # LATIN SMALL LETTER O WITH DIAERESIS
    "\x{00F8}" => "\x0C",        # LATIN SMALL LETTER O WITH STROKE
    "\x{00F9}" => "\x06",        # LATIN SMALL LETTER U WITH GRAVE
    "\x{00FC}" => "\x7E",        # LATIN SMALL LETTER U WITH DIAERESIS
    "\x{0393}" => "\x13",        # GREEK CAPITAL LETTER GAMMA
    "\x{0394}" => "\x10",        # GREEK CAPITAL LETTER DELTA
    "\x{0398}" => "\x19",        # GREEK CAPITAL LETTER THETA
    "\x{039B}" => "\x14",        # GREEK CAPITAL LETTER LAMDA
    "\x{039E}" => "\x1A",        # GREEK CAPITAL LETTER XI
    "\x{03A0}" => "\x16",        # GREEK CAPITAL LETTER PI
    "\x{03A3}" => "\x18",        # GREEK CAPITAL LETTER SIGMA
    "\x{03A6}" => "\x12",        # GREEK CAPITAL LETTER PHI
    "\x{03A8}" => "\x17",        # GREEK CAPITAL LETTER PSI
    "\x{03A9}" => "\x15",        # GREEK CAPITAL LETTER OMEGA
    "\x{20AC}" => "\x1B\x65",    # EURO SIGN
);
our %GSM2UNI = reverse %UNI2GSM;
our $ESC    = "\x1b";
our $ATMARK = "\x40";
our $FBCHAR = "\x3F";
our $NBSP   = "\x{00A0}";

#define ERR_DECODE_NOMAP "%s \"\\x%02" UVXf "\" does not map to Unicode"

sub decode ($$;$) {
    my ( $obj, $bytes, $chk ) = @_;
    my $str = substr($bytes, 0, 0); # to propagate taintedness;
    while ( length $bytes ) {
        my $c = substr( $bytes, 0, 1, '' );
        my $u;
        if ( $c eq "\x00" ) {
            my $c2 = substr( $bytes, 0, 1, '' );
            $u =
                !length $c2 ? $ATMARK
              : $c2 eq "\x00" ? "\x{0000}"
              : exists $GSM2UNI{$c2} ? $ATMARK . $GSM2UNI{$c2}
              : $chk
              ? croak sprintf( "\\x%02X\\x%02X does not map to Unicode",
			       ord($c), ord($c2) )
              : $ATMARK . $FBCHAR;

        }
        elsif ( $c eq $ESC ) {
            my $c2 = substr( $bytes, 0, 1, '' );
            $u =
                exists $GSM2UNI{ $c . $c2 } ? $GSM2UNI{ $c . $c2 }
              : exists $GSM2UNI{$c2}        ? $NBSP . $GSM2UNI{$c2}
              : $chk
              ? croak sprintf( "\\x%02X\\x%02X does not map to Unicode",
			       ord($c), ord($c2) )
              : $NBSP . $FBCHAR;
        }
        else {
            $u =
              exists $GSM2UNI{$c}
              ? $GSM2UNI{$c}
              : $chk ? ref $chk eq 'CODE'
                  ? $chk->( ord $c )
                  : croak sprintf( "\\x%02X does not map to Unicode", ord($c) )
              : $FBCHAR;
        }
        $str .= $u;
    }
    $_[1] = $bytes if $chk;
    return $str;
}

#define ERR_ENCODE_NOMAP "\"\\x{%04" UVxf "}\" does not map to %s"

sub encode($$;$) {
    my ( $obj, $str, $chk ) = @_;
    my $bytes = substr($str, 0, 0); # to propagate taintedness
    while ( length $str ) {
        my $u = substr( $str, 0, 1, '' );
        my $c;
        $bytes .=
          exists $UNI2GSM{$u}
          ? $UNI2GSM{$u}
          : $chk ? ref $chk eq 'CODE'
              ? $chk->( ord($u) )
              : croak sprintf( "\\x{%04x} does not map to %s", 
			       ord($u), $obj->name )
          : $FBCHAR;
    }
    $_[1] = $str if $chk;
    return $bytes;
}

1;
__END__

=head1 NAME

Encode::GSM0338 -- ESTI GSM 03.38 Encoding

=head1 SYNOPSIS

  use Encode qw/encode decode/; 
  $gsm0338 = encode("gsm0338", $utf8);    # loads Encode::GSM0338 implicitly
  $utf8    = decode("gsm0338", $gsm0338); # ditto

=head1 DESCRIPTION

GSM0338 is for GSM handsets. Though it shares alphanumerals with ASCII,
control character ranges and other parts are mapped very differently,
mainly to store Greek characters.  There are also escape sequences
(starting with 0x1B) to cover e.g. the Euro sign.

This was once handled by L<Encode::Bytes> but because of all those
unusual specifications, Encode 2.20 has relocated the support to
this module.

=head1 NOTES

Unlike most other encodings,  the following always croaks on error
for any $chk that evaluates to true.

  $gsm0338 = encode("gsm0338", $utf8      $chk);
  $utf8    = decode("gsm0338", $gsm0338,  $chk);

So if you want to check the validity of the encoding, surround the
expression with C<eval {}> block as follows;

  eval {
    $utf8    = decode("gsm0338", $gsm0338,  $chk);
  };
  if ($@){
    # handle exception here
  }

=head1 BUGS

ESTI GSM 03.38 Encoding itself.

Mapping \x00 to '@' causes too much pain everywhere.

Its use of \x1b (escape) is also very questionable.  

Because of those two, the code paging approach used use in ucm-based
Encoding SOMETIMES fails so this module was written.

=head1 SEE ALSO

L<Encode>

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    package Encode::Guess;
use strict;
use warnings;
use Encode qw(:fallbacks find_encoding);
our $VERSION = do { my @r = ( q$Revision: 2.6 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };

my $Canon = 'Guess';
use constant DEBUG => !!$ENV{PERL_ENCODE_DEBUG};
our %DEF_SUSPECTS = map { $_ => find_encoding($_) } qw(ascii utf8);
$Encode::Encoding{$Canon} = bless {
    Name     => $Canon,
    Suspects => {%DEF_SUSPECTS},
} => __PACKAGE__;

use parent qw(Encode::Encoding);
sub needs_lines { 1 }
sub perlio_ok   { 0 }

our @EXPORT         = qw(guess_encoding);
our $NoUTFAutoGuess = 0;
our $UTF8_BOM       = pack( "C3", 0xef, 0xbb, 0xbf );

sub import {    # Exporter not used so we do it on our own
    my $callpkg = caller;
    for my $item (@EXPORT) {
        no strict 'refs';
        *{"$callpkg\::$item"} = \&{"$item"};
    }
    set_suspects(@_);
}

sub set_suspects {
    my $class = shift;
    my $self = ref($class) ? $class : $Encode::Encoding{$Canon};
    $self->{Suspects} = {%DEF_SUSPECTS};
    $self->add_suspects(@_);
}

sub add_suspects {
    my $class = shift;
    my $self = ref($class) ? $class : $Encode::Encoding{$Canon};
    for my $c (@_) {
        my $e = find_encoding($c) or die "Unknown encoding: $c";
        $self->{Suspects}{ $e->name } = $e;
        DEBUG and warn "Added: ", $e->name;
    }
}

sub decode($$;$) {
    my ( $obj, $octet, $chk ) = @_;
    my $guessed = guess( $obj, $octet );
    unless ( ref($guessed) ) {
        require Carp;
        Carp::croak($guessed);
    }
    my $utf8 = $guessed->decode( $octet, $chk || 0 );
    $_[1] = $octet if $chk;
    return $utf8;
}

sub guess_encoding {
    guess( $Encode::Encoding{$Canon}, @_ );
}

sub guess {
    my $class = shift;
    my $obj   = ref($class) ? $class : $Encode::Encoding{$Canon};
    my $octet = shift;

    # sanity check
    return "Empty string, empty guess" unless defined $octet and length $octet;

    # cheat 0: utf8 flag;
    if ( Encode::is_utf8($octet) ) {
        return find_encoding('utf8') unless $NoUTFAutoGuess;
        Encode::_utf8_off($octet);
    }

    # cheat 1: BOM
    use Encode::Unicode;
    unless ($NoUTFAutoGuess) {
        my $BOM = pack( 'C3', unpack( "C3", $octet ) );
        return find_encoding('utf8')
          if ( defined $BOM and $BOM eq $UTF8_BOM );
        $BOM = unpack( 'N', $octet );
        return find_encoding('UTF-32')
          if ( defined $BOM and ( $BOM == 0xFeFF or $BOM == 0xFFFe0000 ) );
        $BOM = unpack( 'n', $octet );
        return find_encoding('UTF-16')
          if ( defined $BOM and ( $BOM == 0xFeFF or $BOM == 0xFFFe ) );
        if ( $octet =~ /\x00/o )
        {    # if \x00 found, we assume UTF-(16|32)(BE|LE)
            my $utf;
            my ( $be, $le ) = ( 0, 0 );
            if ( $octet =~ /\x00\x00/o ) {    # UTF-32(BE|LE) assumed
                $utf = "UTF-32";
                for my $char ( unpack( 'N*', $octet ) ) {
                    $char & 0x0000ffff and $be++;
                    $char & 0xffff0000 and $le++;
                }
            }
            else {                            # UTF-16(BE|LE) assumed
                $utf = "UTF-16";
                for my $char ( unpack( 'n*', $octet ) ) {
                    $char & 0x00ff and $be++;
                    $char & 0xff00 and $le++;
                }
            }
            DEBUG and warn "$utf, be == $be, le == $le";
            $be == $le
              and return
              "Encodings ambiguous between $utf BE and LE ($be, $le)";
            $utf .= ( $be > $le ) ? 'BE' : 'LE';
            return find_encoding($utf);
        }
    }
    my %try = %{ $obj->{Suspects} };
    for my $c (@_) {
        my $e = find_encoding($c) or die "Unknown encoding: $c";
        $try{ $e->name } = $e;
        DEBUG and warn "Added: ", $e->name;
    }
    my $nline = 1;
    for my $line ( split /\r\n?|\n/, $octet ) {

        # cheat 2 -- \e in the string
        if ( $line =~ /\e/o ) {
            my @keys = keys %try;
            delete @try{qw/utf8 ascii/};
            for my $k (@keys) {
                ref( $try{$k} ) eq 'Encode::XS' and delete $try{$k};
            }
        }
        my %ok = %try;

        # warn join(",", keys %try);
        for my $k ( keys %try ) {
            my $scratch = $line;
            $try{$k}->decode( $scratch, FB_QUIET );
            if ( $scratch eq '' ) {
                DEBUG and warn sprintf( "%4d:%-24s ok\n", $nline, $k );
            }
            else {
                use bytes ();
                DEBUG
                  and warn sprintf( "%4d:%-24s not ok; %d bytes left\n",
                    $nline, $k, bytes::length($scratch) );
                delete $ok{$k};
            }
        }
        %ok or return "No appropriate encodings found!";
        if ( scalar( keys(%ok) ) == 1 ) {
            my ($retval) = values(%ok);
            return $retval;
        }
        %try = %ok;
        $nline++;
    }
    $try{ascii}
      or return "Encodings too ambiguous: ", join( " or ", keys %try );
    return $try{ascii};
}

1;
__END__

=head1 NAME

Encode::Guess -- Guesses encoding from data

=head1 SYNOPSIS

  # if you are sure $data won't contain anything bogus

  use Encode;
  use Encode::Guess qw/euc-jp shiftjis 7bit-jis/;
  my $utf8 = decode("Guess", $data);
  my $data = encode("Guess", $utf8);   # this doesn't work!

  # more elaborate way
  use Encode::Guess;
  my $enc = guess_encoding($data, qw/euc-jp shiftjis 7bit-jis/);
  ref($enc) or die "Can't guess: $enc"; # trap error this way
  $utf8 = $enc->decode($data);
  # or
  $utf8 = decode($enc->name, $data)

=head1 ABSTRACT

Encode::Guess enables you to guess in what encoding a given data is
encoded, or at least tries to.  

=head1 DESCRIPTION

By default, it checks only ascii, utf8 and UTF-16/32 with BOM.

  use Encode::Guess; # ascii/utf8/BOMed UTF

To use it more practically, you have to give the names of encodings to
check (I<suspects> as follows).  The name of suspects can either be
canonical names or aliases.

CAVEAT: Unlike UTF-(16|32), BOM in utf8 is NOT AUTOMATICALLY STRIPPED.

 # tries all major Japanese Encodings as well
  use Encode::Guess qw/euc-jp shiftjis 7bit-jis/;

If the C<$Encode::Guess::NoUTFAutoGuess> variable is set to a true
value, no heuristics will be applied to UTF8/16/32, and the result
will be limited to the suspects and C<ascii>.

=over 4

=item Encode::Guess->set_suspects

You can also change the internal suspects list via C<set_suspects>
method. 

  use Encode::Guess;
  Encode::Guess->set_suspects(qw/euc-jp shiftjis 7bit-jis/);

=item Encode::Guess->add_suspects

Or you can use C<add_suspects> method.  The difference is that
C<set_suspects> flushes the current suspects list while
C<add_suspects> adds.

  use Encode::Guess;
  Encode::Guess->add_suspects(qw/euc-jp shiftjis 7bit-jis/);
  # now the suspects are euc-jp,shiftjis,7bit-jis, AND
  # euc-kr,euc-cn, and big5-eten
  Encode::Guess->add_suspects(qw/euc-kr euc-cn big5-eten/);

=item Encode::decode("Guess" ...)

When you are content with suspects list, you can now

  my $utf8 = Encode::decode("Guess", $data);

=item Encode::Guess->guess($data)

But it will croak if:

=over

=item *

Two or more suspects remain

=item *

No suspects left

=back

So you should instead try this;

  my $decoder = Encode::Guess->guess($data);

On success, $decoder is an object that is documented in
L<Encode::Encoding>.  So you can now do this;

  my $utf8 = $decoder->decode($data);

On failure, $decoder now contains an error message so the whole thing
would be as follows;

  my $decoder = Encode::Guess->guess($data);
  die $decoder unless ref($decoder);
  my $utf8 = $decoder->decode($data);

=item guess_encoding($data, [, I<list of suspects>])

You can also try C<guess_encoding> function which is exported by
default.  It takes $data to check and it also takes the list of
suspects by option.  The optional suspect list is I<not reflected> to
the internal suspects list.

  my $decoder = guess_encoding($data, qw/euc-jp euc-kr euc-cn/);
  die $decoder unless ref($decoder);
  my $utf8 = $decoder->decode($data);
  # check only ascii, utf8 and UTF-(16|32) with BOM
  my $decoder = guess_encoding($data);

=back

=head1 CAVEATS

=over 4

=item *

Because of the algorithm used, ISO-8859 series and other single-byte
encodings do not work well unless either one of ISO-8859 is the only
one suspect (besides ascii and utf8).

  use Encode::Guess;
  # perhaps ok
  my $decoder = guess_encoding($data, 'latin1');
  # definitely NOT ok
  my $decoder = guess_encoding($data, qw/latin1 greek/);

The reason is that Encode::Guess guesses encoding by trial and error.
It first splits $data into lines and tries to decode the line for each
suspect.  It keeps it going until all but one encoding is eliminated
out of suspects list.  ISO-8859 series is just too successful for most
cases (because it fills almost all code points in \x00-\xff).

=item *

Do not mix national standard encodings and the corresponding vendor
encodings.

  # a very bad idea
  my $decoder
     = guess_encoding($data, qw/shiftjis MacJapanese cp932/);

The reason is that vendor encoding is usually a superset of national
standard so it becomes too ambiguous for most cases.

=item *

On the other hand, mixing various national standard encodings
automagically works unless $data is too short to allow for guessing.

 # This is ok if $data is long enough
 my $decoder =  
  guess_encoding($data, qw/euc-cn
                           euc-jp shiftjis 7bit-jis
                           euc-kr
                           big5-eten/);

=item *

DO NOT PUT TOO MANY SUSPECTS!  Don't you try something like this!

  my $decoder = guess_encoding($data, 
                               Encode->encodings(":all"));

=back

It is, after all, just a guess.  You should alway be explicit when it
comes to encodings.  But there are some, especially Japanese,
environment that guess-coding is a must.  Use this module with care. 

=head1 TO DO

Encode::Guess does not work on EBCDIC platforms.

=head1 SEE ALSO

L<Encode>, L<Encode::Encoding>

=cut

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    package Encode::JP;
BEGIN {
    if ( ord("A") == 193 ) {
        die "Encode::JP not supported on EBCDIC\n";
    }
}
use strict;
use warnings;
use Encode;
our $VERSION = do { my @r = ( q$Revision: 2.4 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };

use XSLoader;
XSLoader::load( __PACKAGE__, $VERSION );

use Encode::JP::JIS7;

1;
__END__

=head1 NAME

Encode::JP - Japanese Encodings

=head1 SYNOPSIS

    use Encode qw/encode decode/; 
    $euc_jp = encode("euc-jp", $utf8);   # loads Encode::JP implicitly
    $utf8   = decode("euc-jp", $euc_jp); # ditto

=head1 ABSTRACT

This module implements Japanese charset encodings.  Encodings
supported are as follows.

  Canonical   Alias		Description
  --------------------------------------------------------------------
  euc-jp      /\beuc.*jp$/i	EUC (Extended Unix Character)
              /\bjp.*euc/i   
          /\bujis$/i
  shiftjis    /\bshift.*jis$/i	Shift JIS (aka MS Kanji)
          /\bsjis$/i
  7bit-jis    /\bjis$/i		7bit JIS
  iso-2022-jp			ISO-2022-JP                  [RFC1468]
                = 7bit JIS with all Halfwidth Kana 
                  converted to Fullwidth
  iso-2022-jp-1			ISO-2022-JP-1                [RFC2237]
                                = ISO-2022-JP with JIS X 0212-1990
                  support.  See below
  MacJapanese	                Shift JIS + Apple vendor mappings
  cp932       /\bwindows-31j$/i Code Page 932
                                = Shift JIS + MS/IBM vendor mappings
  jis0201-raw                   JIS0201, raw format
  jis0208-raw                   JIS0201, raw format
  jis0212-raw                   JIS0201, raw format
  --------------------------------------------------------------------

=head1 DESCRIPTION

To find out how to use this module in detail, see L<Encode>.

=head1 Note on ISO-2022-JP(-1)?

ISO-2022-JP-1 (RFC2237) is a superset of ISO-2022-JP (RFC1468) which
adds support for JIS X 0212-1990.  That means you can use the same
code to decode to utf8 but not vice versa.

  $utf8 = decode('iso-2022-jp-1', $stream);

and

  $utf8 = decode('iso-2022-jp',   $stream);

yield the same result but

  $with_0212 = encode('iso-2022-jp-1', $utf8);

is now different from

  $without_0212 = encode('iso-2022-jp', $utf8 );

In the latter case, characters that map to 0212 are first converted
to U+3013 (0xA2AE in EUC-JP; a white square also known as 'Tofu' or
'geta mark') then fed to the decoding engine.  U+FFFD is not used,
in order to preserve text layout as much as possible.

=head1 BUGS

The ASCII region (0x00-0x7f) is preserved for all encodings, even
though this conflicts with mappings by the Unicode Consortium.

=head1 SEE ALSO

L<Encode>

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      package Encode::KR;
BEGIN {
    if ( ord("A") == 193 ) {
        die "Encode::KR not supported on EBCDIC\n";
    }
}
use strict;
use warnings;
use Encode;
our $VERSION = do { my @r = ( q$Revision: 2.3 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
use XSLoader;
XSLoader::load( __PACKAGE__, $VERSION );

use Encode::KR::2022_KR;

1;
__END__

=head1 NAME

Encode::KR - Korean Encodings

=head1 SYNOPSIS

    use Encode qw/encode decode/; 
    $euc_kr = encode("euc-kr", $utf8);   # loads Encode::KR implicitly
    $utf8   = decode("euc-kr", $euc_kr); # ditto

=head1 DESCRIPTION

This module implements Korean charset encodings.  Encodings supported
are as follows.


  Canonical   Alias		Description
  --------------------------------------------------------------------
  euc-kr      /\beuc.*kr$/i	EUC (Extended Unix Character)
          /\bkr.*euc$/i
  ksc5601-raw			Korean standard code set (as is)
  cp949	      /(?:x-)?uhc$/i
              /(?:x-)?windows-949$/i
              /\bks_c_5601-1987$/i
                                Code Page 949 (EUC-KR + 8,822 
                                (additional Hangul syllables)
  MacKorean			EUC-KR + Apple Vendor Mappings
  johab       JOHAB             A supplementary encoding defined in 
                                             Annex 3 of KS X 1001:1998
  iso-2022-kr                   iso-2022-kr                  [RFC1557]
  --------------------------------------------------------------------

To find how to use this module in detail, see L<Encode>.

=head1 BUGS

When you see C<charset=ks_c_5601-1987> on mails and web pages, they really
mean "cp949" encodings.  To fix that, the following aliases are set;

  qr/(?:x-)?uhc$/i         => '"cp949"'
  qr/(?:x-)?windows-949$/i => '"cp949"'
  qr/ks_c_5601-1987$/i     => '"cp949"'

The ASCII region (0x00-0x7f) is preserved for all encodings, even
though this conflicts with mappings by the Unicode Consortium.

=head1 SEE ALSO

L<Encode>

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        package Encode::Symbol;
use strict;
use warnings;
use Encode;
our $VERSION = do { my @r = ( q$Revision: 2.2 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };

use XSLoader;
XSLoader::load( __PACKAGE__, $VERSION );

1;
__END__

=head1 NAME

Encode::Symbol - Symbol Encodings

=head1 SYNOPSIS

    use Encode qw/encode decode/; 
    $symbol  = encode("symbol", $utf8); # loads Encode::Symbol implicitly
    $utf8 = decode("", $symbol);        # ditto

=head1 ABSTRACT

This module implements symbol and dingbats encodings.  Encodings
supported are as follows.   

  Canonical   Alias		Description
  --------------------------------------------------------------------
  symbol
  dingbats
  AdobeZDingbat
  AdobeSymbol
  MacDingbats

=head1 DESCRIPTION

To find out how to use this module in detail, see L<Encode>.

=head1 SEE ALSO

L<Encode>

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 package Encode::TW;
BEGIN {
    if ( ord("A") == 193 ) {
        die "Encode::TW not supported on EBCDIC\n";
    }
}
use strict;
use warnings;
use Encode;
our $VERSION = do { my @r = ( q$Revision: 2.3 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
use XSLoader;
XSLoader::load( __PACKAGE__, $VERSION );

1;
__END__

=head1 NAME

Encode::TW - Taiwan-based Chinese Encodings

=head1 SYNOPSIS

    use Encode qw/encode decode/; 
    $big5 = encode("big5", $utf8); # loads Encode::TW implicitly
    $utf8 = decode("big5", $big5); # ditto

=head1 DESCRIPTION

This module implements tradition Chinese charset encodings as used
in Taiwan and Hong Kong.
Encodings supported are as follows.

  Canonical   Alias		Description
  --------------------------------------------------------------------
  big5-eten   /\bbig-?5$/i	Big5 encoding (with ETen extensions)
          /\bbig5-?et(en)?$/i
          /\btca-?big5$/i
  big5-hkscs  /\bbig5-?hk(scs)?$/i
              /\bhk(scs)?-?big5$/i
                                Big5 + Cantonese characters in Hong Kong
  MacChineseTrad		Big5 + Apple Vendor Mappings
  cp950		                Code Page 950 
                                = Big5 + Microsoft vendor mappings
  --------------------------------------------------------------------

To find out how to use this module in detail, see L<Encode>.

=head1 NOTES

Due to size concerns, C<EUC-TW> (Extended Unix Character), C<CCCII>
(Chinese Character Code for Information Interchange), C<BIG5PLUS>
(CMEX's Big5+) and C<BIG5EXT> (CMEX's Big5e) are distributed separately
on CPAN, under the name L<Encode::HanExtra>. That module also contains
extra China-based encodings.

=head1 BUGS

Since the original C<big5> encoding (1984) is not supported anywhere
(glibc and DOS-based systems uses C<big5> to mean C<big5-eten>; Microsoft
uses C<big5> to mean C<cp950>), a conscious decision was made to alias
C<big5> to C<big5-eten>, which is the de facto superset of the original
big5.

The C<CNS11643> encoding files are not complete. For common C<CNS11643>
manipulation, please use C<EUC-TW> in L<Encode::HanExtra>, which contains
planes 1-7.

The ASCII region (0x00-0x7f) is preserved for all encodings, even
though this conflicts with mappings by the Unicode Consortium.

=head1 SEE ALSO

L<Encode>

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            package Encode::Unicode;

use strict;
use warnings;
no warnings 'redefine';

our $VERSION = do { my @r = ( q$Revision: 2.15 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };

use XSLoader;
XSLoader::load( __PACKAGE__, $VERSION );

#
# Object Generator 8 transcoders all at once!
#

require Encode;

our %BOM_Unknown = map { $_ => 1 } qw(UTF-16 UTF-32);

for my $name (
    qw(UTF-16 UTF-16BE UTF-16LE
    UTF-32 UTF-32BE UTF-32LE
    UCS-2BE  UCS-2LE)
  )
{
    my ( $size, $endian, $ucs2, $mask );
    $name =~ /^(\w+)-(\d+)(\w*)$/o;
    if ( $ucs2 = ( $1 eq 'UCS' ) ) {
        $size = 2;
    }
    else {
        $size = $2 / 8;
    }
    $endian = ( $3 eq 'BE' ) ? 'n' : ( $3 eq 'LE' ) ? 'v' : '';
    $size == 4 and $endian = uc($endian);

    $Encode::Encoding{$name} = bless {
        Name   => $name,
        size   => $size,
        endian => $endian,
        ucs2   => $ucs2,
    } => __PACKAGE__;
}

use parent qw(Encode::Encoding);

sub renew {
    my $self = shift;
    $BOM_Unknown{ $self->name } or return $self;
    my $clone = bless {%$self} => ref($self);
    $clone->{renewed}++;    # so the caller knows it is renewed.
    return $clone;
}

# There used to be a perl implementation of (en|de)code but with
# XS version is ripe, perl version is zapped for optimal speed

*decode = \&decode_xs;
*encode = \&encode_xs;

1;
__END__

=head1 NAME

Encode::Unicode -- Various Unicode Transformation Formats

=cut

=head1 SYNOPSIS

    use Encode qw/encode decode/;
    $ucs2 = encode("UCS-2BE", $utf8);
    $utf8 = decode("UCS-2BE", $ucs2);

=head1 ABSTRACT

This module implements all Character Encoding Schemes of Unicode that
are officially documented by Unicode Consortium (except, of course,
for UTF-8, which is a native format in perl).

=over 4

=item L<http://www.unicode.org/glossary/> says:

I<Character Encoding Scheme> A character encoding form plus byte
serialization. There are Seven character encoding schemes in Unicode:
UTF-8, UTF-16, UTF-16BE, UTF-16LE, UTF-32 (UCS-4), UTF-32BE (UCS-4BE) and
UTF-32LE (UCS-4LE), and UTF-7.

Since UTF-7 is a 7-bit (re)encoded version of UTF-16BE, It is not part of
Unicode's Character Encoding Scheme.  It is separately implemented in
Encode::Unicode::UTF7.  For details see L<Encode::Unicode::UTF7>.

=item Quick Reference

                Decodes from ord(N)           Encodes chr(N) to...
       octet/char BOM S.P d800-dfff  ord > 0xffff     \x{1abcd} ==
  ---------------+-----------------+------------------------------
  UCS-2BE       2   N   N  is bogus                  Not Available
  UCS-2LE       2   N   N     bogus                  Not Available
  UTF-16      2/4   Y   Y  is   S.P           S.P            BE/LE
  UTF-16BE    2/4   N   Y       S.P           S.P    0xd82a,0xdfcd
  UTF-16LE    2/4   N   Y       S.P           S.P    0x2ad8,0xcddf
  UTF-32        4   Y   -  is bogus         As is            BE/LE
  UTF-32BE      4   N   -     bogus         As is       0x0001abcd
  UTF-32LE      4   N   -     bogus         As is       0xcdab0100
  UTF-8       1-4   -   -     bogus   >= 4 octets   \xf0\x9a\af\8d
  ---------------+-----------------+------------------------------

=back

=head1 Size, Endianness, and BOM

You can categorize these CES by 3 criteria:  size of each character,
endianness, and Byte Order Mark.

=head2 by size

UCS-2 is a fixed-length encoding with each character taking 16 bits.
It B<does not> support I<surrogate pairs>.  When a surrogate pair
is encountered during decode(), its place is filled with \x{FFFD}
if I<CHECK> is 0, or the routine croaks if I<CHECK> is 1.  When a
character whose ord value is larger than 0xFFFF is encountered,
its place is filled with \x{FFFD} if I<CHECK> is 0, or the routine
croaks if I<CHECK> is 1.

UTF-16 is almost the same as UCS-2 but it supports I<surrogate pairs>.
When it encounters a high surrogate (0xD800-0xDBFF), it fetches the
following low surrogate (0xDC00-0xDFFF) and C<desurrogate>s them to
form a character.  Bogus surrogates result in death.  When \x{10000}
or above is encountered during encode(), it C<ensurrogate>s them and
pushes the surrogate pair to the output stream.

UTF-32 (UCS-4) is a fixed-length encoding with each character taking 32 bits.
Since it is 32-bit, there is no need for I<surrogate pairs>.

=head2 by endianness

The first (and now failed) goal of Unicode was to map all character
repertoires into a fixed-length integer so that programmers are happy.
Since each character is either a I<short> or I<long> in C, you have to
pay attention to the endianness of each platform when you pass data
to one another.

Anything marked as BE is Big Endian (or network byte order) and LE is
Little Endian (aka VAX byte order).  For anything not marked either
BE or LE, a character called Byte Order Mark (BOM) indicating the
endianness is prepended to the string.

CAVEAT: Though BOM in utf8 (\xEF\xBB\xBF) is valid, it is meaningless
and as of this writing Encode suite just leave it as is (\x{FeFF}).

=over 4

=item BOM as integer when fetched in network byte order

              16         32 bits/char
  -------------------------
  BE      0xFeFF 0x0000FeFF
  LE      0xFFFe 0xFFFe0000
  -------------------------

=back

This modules handles the BOM as follows.

=over 4

=item *

When BE or LE is explicitly stated as the name of encoding, BOM is
simply treated as a normal character (ZERO WIDTH NO-BREAK SPACE).

=item *

When BE or LE is omitted during decode(), it checks if BOM is at the
beginning of the string; if one is found, the endianness is set to
what the BOM says.  

=item *

Default Byte Order

When no BOM is found, Encode 2.76 and blow croaked.  Since Encode
2.77, it falls back to BE accordingly to RFC2781 and the Unicode
Standard version 8.0. This behaviour has also been backported to
Encode 2.72 and later as shipped in the Debian perl package since
version 5.22.1-1 (see L<https://bugs.debian.org/798727>).

=item *

When BE or LE is omitted during encode(), it returns a BE-encoded
string with BOM prepended.  So when you want to encode a whole text
file, make sure you encode() the whole text at once, not line by line
or each line, not file, will have a BOM prepended.

=item *

C<UCS-2> is an exception.  Unlike others, this is an alias of UCS-2BE.
UCS-2 is already registered by IANA and others that way.

=back

=head1 Surrogate Pairs

To say the least, surrogate pairs were the biggest mistake of the
Unicode Consortium.  But according to the late Douglas Adams in I<The
Hitchhiker's Guide to the Galaxy> Trilogy, C<In the beginning the
Universe was created. This has made a lot of people very angry and
been widely regarded as a bad move>.  Their mistake was not of this
magnitude so let's forgive them.

(I don't dare make any comparison with Unicode Consortium and the
Vogons here ;)  Or, comparing Encode to Babel Fish is completely
appropriate -- if you can only stick this into your ear :)

Surrogate pairs were born when the Unicode Consortium finally
admitted that 16 bits were not big enough to hold all the world's
character repertoires.  But they already made UCS-2 16-bit.  What
do we do?

Back then, the range 0xD800-0xDFFF was not allocated.  Let's split
that range in half and use the first half to represent the C<upper
half of a character> and the second half to represent the C<lower
half of a character>.  That way, you can represent 1024 * 1024 =
1048576 more characters.  Now we can store character ranges up to
\x{10ffff} even with 16-bit encodings.  This pair of half-character is
now called a I<surrogate pair> and UTF-16 is the name of the encoding
that embraces them.

Here is a formula to ensurrogate a Unicode character \x{10000} and
above;

  $hi = ($uni - 0x10000) / 0x400 + 0xD800;
  $lo = ($uni - 0x10000) % 0x400 + 0xDC00;

And to desurrogate;

 $uni = 0x10000 + ($hi - 0xD800) * 0x400 + ($lo - 0xDC00);

Note this move has made \x{D800}-\x{DFFF} into a forbidden zone but
perl does not prohibit the use of characters within this range.  To perl,
every one of \x{0000_0000} up to \x{ffff_ffff} (*) is I<a character>.

  (*) or \x{ffff_ffff_ffff_ffff} if your perl is compiled with 64-bit
  integer support!

=head1 Error Checking

Unlike most encodings which accept various ways to handle errors,
Unicode encodings simply croaks.

  % perl -MEncode -e'$_ = "\xfe\xff\xd8\xd9\xda\xdb\0\n"' \
         -e'Encode::from_to($_, "utf16","shift_jis", 0); print'
  UTF-16:Malformed LO surrogate d8d9 at /path/to/Encode.pm line 184.
  % perl -MEncode -e'$a = "BOM missing"' \
         -e' Encode::from_to($a, "utf16", "shift_jis", 0); print'
  UTF-16:Unrecognised BOM 424f at /path/to/Encode.pm line 184.

Unlike other encodings where mappings are not one-to-one against
Unicode, UTFs are supposed to map 100% against one another.  So Encode
is more strict on UTFs.

Consider that "division by zero" of Encode :)

=head1 SEE ALSO

L<Encode>, L<Encode::Unicode::UTF7>, L<http://www.unicode.org/glossary/>,
L<http://www.unicode.org/unicode/faq/utf_bom.html>,

RFC 2781 L<http://www.ietf.org/rfc/rfc2781.txt>,

The whole Unicode standard L<http://www.unicode.org/unicode/uni2book/u2.html>

Ch. 15, pp. 403 of C<Programming Perl (3rd Edition)>
by Larry Wall, Tom Christiansen, Jon Orwant;
O'Reilly & Associates; ISBN 0-596-00027-8

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        package Encode::CN::HZ;

use strict;
use warnings;
use utf8 ();

use vars qw($VERSION);
$VERSION = do { my @r = ( q$Revision: 2.7 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };

use Encode qw(:fallbacks);

use parent qw(Encode::Encoding);
__PACKAGE__->Define('hz');

# HZ is a combination of ASCII and escaped GB, so we implement it
# with the GB2312(raw) encoding here. Cf. RFCs 1842 & 1843.

# not ported for EBCDIC.  Which should be used, "~" or "\x7E"?

sub needs_lines { 1 }

sub decode ($$;$) {
    my ( $obj, $str, $chk ) = @_;

    my $GB  = Encode::find_encoding('gb2312-raw');
    my $ret = substr($str, 0, 0); # to propagate taintedness
    my $in_ascii = 1;    # default mode is ASCII.

    while ( length $str ) {
        if ($in_ascii) {    # ASCII mode
            if ( $str =~ s/^([\x00-\x7D\x7F]+)// ) {    # no '~' => ASCII
                $ret .= $1;

                # EBCDIC should need ascii2native, but not ported.
            }
            elsif ( $str =~ s/^\x7E\x7E// ) {           # escaped tilde
                $ret .= '~';
            }
            elsif ( $str =~ s/^\x7E\cJ// ) {    # '\cJ' == LF in ASCII
                1;                              # no-op
            }
            elsif ( $str =~ s/^\x7E\x7B// ) {    # '~{'
                $in_ascii = 0;                   # to GB
            }
            else {    # encounters an invalid escape, \x80 or greater
                last;
            }
        }
        else {        # GB mode; the byte ranges are as in RFC 1843.
            no warnings 'uninitialized';
            if ( $str =~ s/^((?:[\x21-\x77][\x21-\x7E])+)// ) {
                $ret .= $GB->decode( $1, $chk );
            }
            elsif ( $str =~ s/^\x7E\x7D// ) {    # '~}'
                $in_ascii = 1;
            }
            else {                               # invalid
                last;
            }
        }
    }
    $_[1] = '' if $chk;    # needs_lines guarantees no partial character
    return $ret;
}

sub cat_decode {
    my ( $obj, undef, $src, $pos, $trm, $chk ) = @_;
    my ( $rdst, $rsrc, $rpos ) = \@_[ 1 .. 3 ];

    my $GB  = Encode::find_encoding('gb2312-raw');
    my $ret = '';
    my $in_ascii = 1;      # default mode is ASCII.

    my $ini_pos = pos($$rsrc);

    substr( $src, 0, $pos ) = '';

    my $ini_len = bytes::length($src);

    # $trm is the first of the pair '~~', then 2nd tilde is to be removed.
    # XXX: Is better C<$src =~ s/^\x7E// or die if ...>?
    $src =~ s/^\x7E// if $trm eq "\x7E";

    while ( length $src ) {
        my $now;
        if ($in_ascii) {    # ASCII mode
            if ( $src =~ s/^([\x00-\x7D\x7F])// ) {    # no '~' => ASCII
                $now = $1;
            }
            elsif ( $src =~ s/^\x7E\x7E// ) {          # escaped tilde
                $now = '~';
            }
            elsif ( $src =~ s/^\x7E\cJ// ) {    # '\cJ' == LF in ASCII
                next;
            }
            elsif ( $src =~ s/^\x7E\x7B// ) {    # '~{'
                $in_ascii = 0;                   # to GB
                next;
            }
            else {    # encounters an invalid escape, \x80 or greater
                last;
            }
        }
        else {        # GB mode; the byte ranges are as in RFC 1843.
            if ( $src =~ s/^((?:[\x21-\x77][\x21-\x7F])+)// ) {
                $now = $GB->decode( $1, $chk );
            }
            elsif ( $src =~ s/^\x7E\x7D// ) {    # '~}'
                $in_ascii = 1;
                next;
            }
            else {                               # invalid
                last;
            }
        }

        next if !defined $now;

        $ret .= $now;

        if ( $now eq $trm ) {
            $$rdst .= $ret;
            $$rpos = $ini_pos + $pos + $ini_len - bytes::length($src);
            pos($$rsrc) = $ini_pos;
            return 1;
        }
    }

    $$rdst .= $ret;
    $$rpos = $ini_pos + $pos + $ini_len - bytes::length($src);
    pos($$rsrc) = $ini_pos;
    return '';    # terminator not found
}

sub encode($$;$) {
     my ( $obj, $str, $chk ) = @_;

    my $GB  = Encode::find_encoding('gb2312-raw');
    my $ret = substr($str, 0, 0); # to propagate taintedness;
    my $in_ascii = 1;    # default mode is ASCII.

    no warnings 'utf8';  # $str may be malformed UTF8 at the end of a chunk.

    while ( length $str ) {
        if ( $str =~ s/^([[:ascii:]]+)// ) {
            my $tmp = $1;
            $tmp =~ s/~/~~/g;    # escapes tildes
            if ( !$in_ascii ) {
                $ret .= "\x7E\x7D";    # '~}'
                $in_ascii = 1;
            }
            $ret .= pack 'a*', $tmp;    # remove UTF8 flag.
        }
        elsif ( $str =~ s/(.)// ) {
            my $s = $1;
            my $tmp = $GB->encode( $s, $chk );
            last if !defined $tmp;
            if ( length $tmp == 2 ) {    # maybe a valid GB char (XXX)
                if ($in_ascii) {
                    $ret .= "\x7E\x7B";    # '~{'
                    $in_ascii = 0;
                }
                $ret .= $tmp;
            }
            elsif ( length $tmp ) {        # maybe FALLBACK in ASCII (XXX)
                if ( !$in_ascii ) {
                    $ret .= "\x7E\x7D";    # '~}'
                    $in_ascii = 1;
                }
                $ret .= $tmp;
            }
        }
        else {    # if $str is malformed UTF8 *and* if length $str != 0.
            last;
        }
    }
    $_[1] = $str if $chk;

    # The state at the end of the chunk is discarded, even if in GB mode.
    # That results in the combination of GB-OUT and GB-IN, i.e. "~}~{".
    # Parhaps it is harmless, but further investigations may be required...

    if ( !$in_ascii ) {
        $ret .= "\x7E\x7D";    # '~}'
        $in_ascii = 1;
    }
    utf8::encode($ret); # https://rt.cpan.org/Ticket/Display.html?id=35120
    return $ret;
}

1;
__END__

=head1 NAME

Encode::CN::HZ -- internally used by Encode::CN

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    #
# $Id: H2Z.pm,v 2.2 2006/06/03 20:28:48 dankogai Exp $
#

package Encode::JP::H2Z;

use strict;
use warnings;

our $RCSID = q$Id: H2Z.pm,v 2.2 2006/06/03 20:28:48 dankogai Exp $;
our $VERSION = do { my @r = ( q$Revision: 2.2 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };

use Encode::CJKConstants qw(:all);

use vars qw(%_D2Z  $_PAT_D2Z
  %_Z2D  $_PAT_Z2D
  %_H2Z  $_PAT_H2Z
  %_Z2H  $_PAT_Z2H);

%_H2Z = (
    "\x8e\xa1" => "\xa1\xa3",    #
    "\x8e\xa2" => "\xa1\xd6",    #
    "\x8e\xa3" => "\xa1\xd7",    #
    "\x8e\xa4" => "\xa1\xa2",    #
    "\x8e\xa5" => "\xa1\xa6",    #
    "\x8e\xa6" => "\xa5\xf2",    #
    "\x8e\xa7" => "\xa5\xa1",    #
    "\x8e\xa8" => "\xa5\xa3",    #
    "\x8e\xa9" => "\xa5\xa5",    #
    "\x8e\xaa" => "\xa5\xa7",    #
    "\x8e\xab" => "\xa5\xa9",    #
    "\x8e\xac" => "\xa5\xe3",    #
    "\x8e\xad" => "\xa5\xe5",    #
    "\x8e\xae" => "\xa5\xe7",    #
    "\x8e\xaf" => "\xa5\xc3",    #
    "\x8e\xb0" => "\xa1\xbc",    #
    "\x8e\xb1" => "\xa5\xa2",    #
    "\x8e\xb2" => "\xa5\xa4",    #
    "\x8e\xb3" => "\xa5\xa6",    #
    "\x8e\xb4" => "\xa5\xa8",    #
    "\x8e\xb5" => "\xa5\xaa",    #
    "\x8e\xb6" => "\xa5\xab",    #
    "\x8e\xb7" => "\xa5\xad",    #
    "\x8e\xb8" => "\xa5\xaf",    #
    "\x8e\xb9" => "\xa5\xb1",    #
    "\x8e\xba" => "\xa5\xb3",    #
    "\x8e\xbb" => "\xa5\xb5",    #
    "\x8e\xbc" => "\xa5\xb7",    #
    "\x8e\xbd" => "\xa5\xb9",    #
    "\x8e\xbe" => "\xa5\xbb",    #
    "\x8e\xbf" => "\xa5\xbd",    #
    "\x8e\xc0" => "\xa5\xbf",    #
    "\x8e\xc1" => "\xa5\xc1",    #
    "\x8e\xc2" => "\xa5\xc4",    #
    "\x8e\xc3" => "\xa5\xc6",    #
    "\x8e\xc4" => "\xa5\xc8",    #
    "\x8e\xc5" => "\xa5\xca",    #
    "\x8e\xc6" => "\xa5\xcb",    #
    "\x8e\xc7" => "\xa5\xcc",    #
    "\x8e\xc8" => "\xa5\xcd",    #
    "\x8e\xc9" => "\xa5\xce",    #
    "\x8e\xca" => "\xa5\xcf",    #
    "\x8e\xcb" => "\xa5\xd2",    #
    "\x8e\xcc" => "\xa5\xd5",    #
    "\x8e\xcd" => "\xa5\xd8",    #
    "\x8e\xce" => "\xa5\xdb",    #
    "\x8e\xcf" => "\xa5\xde",    #
    "\x8e\xd0" => "\xa5\xdf",    #
    "\x8e\xd1" => "\xa5\xe0",    #
    "\x8e\xd2" => "\xa5\xe1",    #
    "\x8e\xd3" => "\xa5\xe2",    #
    "\x8e\xd4" => "\xa5\xe4",    #
    "\x8e\xd5" => "\xa5\xe6",    #
    "\x8e\xd6" => "\xa5\xe8",    #
    "\x8e\xd7" => "\xa5\xe9",    #
    "\x8e\xd8" => "\xa5\xea",    #
    "\x8e\xd9" => "\xa5\xeb",    #
    "\x8e\xda" => "\xa5\xec",    #
    "\x8e\xdb" => "\xa5\xed",    #
    "\x8e\xdc" => "\xa5\xef",    #
    "\x8e\xdd" => "\xa5\xf3",    #
    "\x8e\xde" => "\xa1\xab",    #
    "\x8e\xdf" => "\xa1\xac",    #
);

%_D2Z = (
    "\x8e\xb6\x8e\xde" => "\xa5\xac",    #
    "\x8e\xb7\x8e\xde" => "\xa5\xae",    #
    "\x8e\xb8\x8e\xde" => "\xa5\xb0",    #
    "\x8e\xb9\x8e\xde" => "\xa5\xb2",    #
    "\x8e\xba\x8e\xde" => "\xa5\xb4",    #
    "\x8e\xbb\x8e\xde" => "\xa5\xb6",    #
    "\x8e\xbc\x8e\xde" => "\xa5\xb8",    #
    "\x8e\xbd\x8e\xde" => "\xa5\xba",    #
    "\x8e\xbe\x8e\xde" => "\xa5\xbc",    #
    "\x8e\xbf\x8e\xde" => "\xa5\xbe",    #
    "\x8e\xc0\x8e\xde" => "\xa5\xc0",    #
    "\x8e\xc1\x8e\xde" => "\xa5\xc2",    #
    "\x8e\xc2\x8e\xde" => "\xa5\xc5",    #
    "\x8e\xc3\x8e\xde" => "\xa5\xc7",    #
    "\x8e\xc4\x8e\xde" => "\xa5\xc9",    #
    "\x8e\xca\x8e\xde" => "\xa5\xd0",    #
    "\x8e\xcb\x8e\xde" => "\xa5\xd3",    #
    "\x8e\xcc\x8e\xde" => "\xa5\xd6",    #
    "\x8e\xcd\x8e\xde" => "\xa5\xd9",    #
    "\x8e\xce\x8e\xde" => "\xa5\xdc",    #
    "\x8e\xca\x8e\xdf" => "\xa5\xd1",    #
    "\x8e\xcb\x8e\xdf" => "\xa5\xd4",    #
    "\x8e\xcc\x8e\xdf" => "\xa5\xd7",    #
    "\x8e\xcd\x8e\xdf" => "\xa5\xda",    #
    "\x8e\xce\x8e\xdf" => "\xa5\xdd",    #
    "\x8e\xb3\x8e\xde" => "\xa5\xf4",    #
);

# init only once;

#$_PAT_D2Z = join("|", keys %_D2Z);
#$_PAT_H2Z = join("|", keys %_H2Z);

%_Z2H = reverse %_H2Z;
%_Z2D = reverse %_D2Z;

#$_PAT_Z2H    = join("|", keys %_Z2H);
#$_PAT_Z2D    = join("|", keys %_Z2D);

sub h2z {
    no warnings qw(uninitialized);
    my $r_str          = shift;
    my ($keep_dakuten) = @_;
    my $n              = 0;
    unless ($keep_dakuten) {
        $n = (
            $$r_str =~ s(
               ($RE{EUC_KANA}
                (?:\x8e[\xde\xdf])?)
               ){
          my $str = $1;
          $_D2Z{$str} || $_H2Z{$str} || 
              # in case dakuten and handakuten are side-by-side!
              $_H2Z{substr($str,0,2)} . $_H2Z{substr($str,2,2)};
          }eogx
        );
    }
    else {
        $n = (
            $$r_str =~ s(
               ($RE{EUC_KANA})
               ){
          $_H2Z{$1};
          }eogx
        );
    }
    $n;
}

sub z2h {
    my $r_str = shift;
    my $n     = (
        $$r_str =~ s(
              ($RE{EUC_C}|$RE{EUC_0212}|$RE{EUC_KANA})
              ){
         $_Z2D{$1} || $_Z2H{$1} || $1;
         }eogx
    );
    $n;
}

1;
__END__


=head1 NAME

Encode::JP::H2Z -- internally used by Encode::JP::2022_JP*

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          package Encode::JP::JIS7;
use strict;
use warnings;
our $VERSION = do { my @r = ( q$Revision: 2.5 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };

use Encode qw(:fallbacks);

for my $name ( '7bit-jis', 'iso-2022-jp', 'iso-2022-jp-1' ) {
    my $h2z     = ( $name eq '7bit-jis' )    ? 0 : 1;
    my $jis0212 = ( $name eq 'iso-2022-jp' ) ? 0 : 1;

    $Encode::Encoding{$name} = bless {
        Name    => $name,
        h2z     => $h2z,
        jis0212 => $jis0212,
    } => __PACKAGE__;
}

use parent qw(Encode::Encoding);

# we override this to 1 so PerlIO works
sub needs_lines { 1 }

use Encode::CJKConstants qw(:all);

#
# decode is identical for all 2022 variants
#

sub decode($$;$) {
    my ( $obj, $str, $chk ) = @_;
    my $residue = '';
    if ($chk) {
        $str =~ s/([^\x00-\x7f].*)$//so and $residue = $1;
    }
    $residue .= jis_euc( \$str );
    $_[1] = $residue if $chk;
    return Encode::decode( 'euc-jp', $str, FB_PERLQQ );
}

#
# encode is different
#

sub encode($$;$) {
    require Encode::JP::H2Z;
    my ( $obj, $utf8, $chk ) = @_;

    # empty the input string in the stack so perlio is ok
    $_[1] = '' if $chk;
    my ( $h2z, $jis0212 ) = @$obj{qw(h2z jis0212)};
    my $octet = Encode::encode( 'euc-jp', $utf8, $chk );
    $h2z and &Encode::JP::H2Z::h2z( \$octet );
    euc_jis( \$octet, $jis0212 );
    return $octet;
}

#
# cat_decode
#
my $re_scan_jis_g = qr{
   \G ( ($RE{JIS_0212}) |  $RE{JIS_0208}  |
        ($RE{ISO_ASC})  | ($RE{JIS_KANA}) | )
      ([^\e]*)
}x;

sub cat_decode {    # ($obj, $dst, $src, $pos, $trm, $chk)
    my ( $obj, undef, undef, $pos, $trm ) = @_;    # currently ignores $chk
    my ( $rdst, $rsrc, $rpos ) = \@_[ 1, 2, 3 ];
    local ${^ENCODING};
    use bytes;
    my $opos = pos($$rsrc);
    pos($$rsrc) = $pos;
    while ( $$rsrc =~ /$re_scan_jis_g/gc ) {
        my ( $esc, $esc_0212, $esc_asc, $esc_kana, $chunk ) =
          ( $1, $2, $3, $4, $5 );

        unless ($chunk) { $esc or last; next; }

        if ( $esc && !$esc_asc ) {
            $chunk =~ tr/\x21-\x7e/\xa1-\xfe/;
            if ($esc_kana) {
                $chunk =~ s/([\xa1-\xdf])/\x8e$1/og;
            }
            elsif ($esc_0212) {
                $chunk =~ s/([\xa1-\xfe][\xa1-\xfe])/\x8f$1/og;
            }
            $chunk = Encode::decode( 'euc-jp', $chunk, 0 );
        }
        elsif ( ( my $npos = index( $chunk, $trm ) ) >= 0 ) {
            $$rdst .= substr( $chunk, 0, $npos + length($trm) );
            $$rpos += length($esc) + $npos + length($trm);
            pos($$rsrc) = $opos;
            return 1;
        }
        $$rdst .= $chunk;
        $$rpos = pos($$rsrc);
    }
    $$rpos = pos($$rsrc);
    pos($$rsrc) = $opos;
    return '';
}

# JIS<->EUC
my $re_scan_jis = qr{
   (?:($RE{JIS_0212})|$RE{JIS_0208}|($RE{ISO_ASC})|($RE{JIS_KANA}))([^\e]*)
}x;

sub jis_euc {
    local ${^ENCODING};
    my $r_str = shift;
    $$r_str =~ s($re_scan_jis)
    {
    my ($esc_0212, $esc_asc, $esc_kana, $chunk) =
       ($1, $2, $3, $4);
    if (!$esc_asc) {
        $chunk =~ tr/\x21-\x7e/\xa1-\xfe/;
        if ($esc_kana) {
        $chunk =~ s/([\xa1-\xdf])/\x8e$1/og;
        }
        elsif ($esc_0212) {
        $chunk =~ s/([\xa1-\xfe][\xa1-\xfe])/\x8f$1/og;
        }
    }
    $chunk;
    }geox;
    my ($residue) = ( $$r_str =~ s/(\e.*)$//so );
    return $residue;
}

sub euc_jis {
    no warnings qw(uninitialized);
    local ${^ENCODING};
    my $r_str   = shift;
    my $jis0212 = shift;
    $$r_str =~ s{
    ((?:$RE{EUC_C})+|(?:$RE{EUC_KANA})+|(?:$RE{EUC_0212})+)
    }{
        my $chunk = $1;
        my $esc =
        ( $chunk =~ tr/\x8E//d ) ? $ESC{KANA} :
            ( $chunk =~ tr/\x8F//d ) ? $ESC{JIS_0212} :
            $ESC{JIS_0208};
        if ($esc eq $ESC{JIS_0212} && !$jis0212){
        # fallback to '?'
        $chunk =~ tr/\xA1-\xFE/\x3F/;
        }else{
        $chunk =~ tr/\xA1-\xFE/\x21-\x7E/;
        }
        $esc . $chunk . $ESC{ASC};
    }geox;
    $$r_str =~ s/\Q$ESC{ASC}\E
        (\Q$ESC{KANA}\E|\Q$ESC{JIS_0212}\E|\Q$ESC{JIS_0208}\E)/$1/gox;
    $$r_str;
}

1;
__END__


=head1 NAME

Encode::JP::JIS7 -- internally used by Encode::JP

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     package Encode::KR::2022_KR;
use strict;
use warnings;
our $VERSION = do { my @r = ( q$Revision: 2.3 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };

use Encode qw(:fallbacks);

use parent qw(Encode::Encoding);
__PACKAGE__->Define('iso-2022-kr');

sub needs_lines { 1 }

sub perlio_ok {
    return 0;    # for the time being
}

sub decode {
    my ( $obj, $str, $chk ) = @_;
    my $res     = $str;
    my $residue = iso_euc( \$res );

    # This is for PerlIO
    $_[1] = $residue if $chk;
    return Encode::decode( 'euc-kr', $res, FB_PERLQQ );
}

sub encode {
    my ( $obj, $utf8, $chk ) = @_;

    # empty the input string in the stack so perlio is ok
    $_[1] = '' if $chk;
    my $octet = Encode::encode( 'euc-kr', $utf8, FB_PERLQQ );
    euc_iso( \$octet );
    return $octet;
}

use Encode::CJKConstants qw(:all);

# ISO<->EUC

sub iso_euc {
    my $r_str = shift;
    $$r_str =~ s/$RE{'2022_KR'}//gox;    # remove the designator
    $$r_str =~ s{                      # replace characters in GL
     \x0e                              # between SO(\x0e) and SI(\x0f)
     ([^\x0f]*)                        # with characters in GR
     \x0f
        }
    {
                        my $out= $1;
      $out =~ tr/\x21-\x7e/\xa1-\xfe/;
      $out;
    }geox;
    my ($residue) = ( $$r_str =~ s/(\e.*)$//so );
    return $residue;
}

sub euc_iso {
    no warnings qw(uninitialized);
    my $r_str = shift;
    substr( $$r_str, 0, 0 ) =
      $ESC{'2022_KR'};    # put the designator at the beg.
    $$r_str =~
      s{                         # move KS X 1001 characters in GR to GL
        ($RE{EUC_C}+)                     # and enclose them with SO and SI
        }{
            my $str = $1;
            $str =~ tr/\xA1-\xFE/\x21-\x7E/;
            "\x0e" . $str . "\x0f";
        }geox;
    $$r_str;
}

1;
__END__

=head1 NAME

Encode::KR::2022_KR -- internally used by Encode::KR

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    package Encode::MIME::Name;
use strict;
use warnings;
our $VERSION = do { my @r = ( q$Revision: 1.1 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };

our %MIME_NAME_OF = (
    'AdobeStandardEncoding' => 'Adobe-Standard-Encoding',
    'AdobeSymbol'           => 'Adobe-Symbol-Encoding',
    'ascii'                 => 'US-ASCII',
    'big5-hkscs'            => 'Big5-HKSCS',
    'cp1026'                => 'IBM1026',
    'cp1047'                => 'IBM1047',
    'cp1250'                => 'windows-1250',
    'cp1251'                => 'windows-1251',
    'cp1252'                => 'windows-1252',
    'cp1253'                => 'windows-1253',
    'cp1254'                => 'windows-1254',
    'cp1255'                => 'windows-1255',
    'cp1256'                => 'windows-1256',
    'cp1257'                => 'windows-1257',
    'cp1258'                => 'windows-1258',
    'cp37'                  => 'IBM037',
    'cp424'                 => 'IBM424',
    'cp437'                 => 'IBM437',
    'cp500'                 => 'IBM500',
    'cp775'                 => 'IBM775',
    'cp850'                 => 'IBM850',
    'cp852'                 => 'IBM852',
    'cp855'                 => 'IBM855',
    'cp857'                 => 'IBM857',
    'cp860'                 => 'IBM860',
    'cp861'                 => 'IBM861',
    'cp862'                 => 'IBM862',
    'cp863'                 => 'IBM863',
    'cp864'                 => 'IBM864',
    'cp865'                 => 'IBM865',
    'cp866'                 => 'IBM866',
    'cp869'                 => 'IBM869',
    'cp936'                 => 'GBK',
    'euc-jp'                => 'EUC-JP',
    'euc-kr'                => 'EUC-KR',
    #'gb2312-raw'            => 'GB2312', # no, you're wrong, I18N::Charset
    'hp-roman8'             => 'hp-roman8',
    'hz'                    => 'HZ-GB-2312',
    'iso-2022-jp'           => 'ISO-2022-JP',
    'iso-2022-jp-1'         => 'ISO-2022-JP',
    'iso-2022-kr'           => 'ISO-2022-KR',
    'iso-8859-1'            => 'ISO-8859-1',
    'iso-8859-10'           => 'ISO-8859-10',
    'iso-8859-13'           => 'ISO-8859-13',
    'iso-8859-14'           => 'ISO-8859-14',
    'iso-8859-15'           => 'ISO-8859-15',
    'iso-8859-16'           => 'ISO-8859-16',
    'iso-8859-2'            => 'ISO-8859-2',
    'iso-8859-3'            => 'ISO-8859-3',
    'iso-8859-4'            => 'ISO-8859-4',
    'iso-8859-5'            => 'ISO-8859-5',
    'iso-8859-6'            => 'ISO-8859-6',
    'iso-8859-7'            => 'ISO-8859-7',
    'iso-8859-8'            => 'ISO-8859-8',
    'iso-8859-9'            => 'ISO-8859-9',
    #'jis0201-raw'           => 'JIS_X0201',
    #'jis0208-raw'           => 'JIS_C6226-1983',
    #'jis0212-raw'           => 'JIS_X0212-1990',
    'koi8-r'                => 'KOI8-R',
    'koi8-u'                => 'KOI8-U',
    #'ksc5601-raw'           => 'KS_C_5601-1987',
    'shiftjis'              => 'Shift_JIS',
    'UTF-16'                => 'UTF-16',
    'UTF-16BE'              => 'UTF-16BE',
    'UTF-16LE'              => 'UTF-16LE',
    'UTF-32'                => 'UTF-32',
    'UTF-32BE'              => 'UTF-32BE',
    'UTF-32LE'              => 'UTF-32LE',
    'UTF-7'                 => 'UTF-7',
    'utf8'                  => 'UTF-8',
    'utf-8-strict'          => 'UTF-8',
    'viscii'                => 'VISCII',
);

sub get_mime_name($) { $MIME_NAME_OF{$_[0]} };

1;
__END__

=head1 NAME

Encode::MIME::NAME -- internally used by Encode

=head1 SEE ALSO

L<I18N::Charset>

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            package Encode::MIME::Header;
use strict;
use warnings;
no warnings 'redefine';

our $VERSION = do { my @r = ( q$Revision: 2.19 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
use Encode qw(find_encoding encode_utf8 decode_utf8);
use MIME::Base64;
use Carp;

my %seed = (
    decode_b => '1',    # decodes 'B' encoding ?
    decode_q => '1',    # decodes 'Q' encoding ?
    encode   => 'B',    # encode with 'B' or 'Q' ?
    bpl      => 75,     # bytes per line
);

$Encode::Encoding{'MIME-Header'} =
  bless { %seed, Name => 'MIME-Header', } => __PACKAGE__;

$Encode::Encoding{'MIME-B'} = bless {
    %seed,
    decode_q => 0,
    Name     => 'MIME-B',
} => __PACKAGE__;

$Encode::Encoding{'MIME-Q'} = bless {
    %seed,
    decode_q => 1,
    encode   => 'Q',
    Name     => 'MIME-Q',
} => __PACKAGE__;

use parent qw(Encode::Encoding);

sub needs_lines { 1 }
sub perlio_ok   { 0 }

sub decode($$;$) {
    use utf8;
    my ( $obj, $str, $chk ) = @_;
    # zap spaces between encoded words
    $str =~ s/\?=\s+=\?/\?==\?/gos;
    
    # multi-line header to single line
    $str =~ s/(?:\r\n|[\r\n])[ \t]//gos;

    1 while ( $str =~
              s/(=\?[-0-9A-Za-z_]+\?[Qq]\?)([^?]*?)\?=\1([^?]*?\?=)/$1$2$3/ )
      ;    # Concat consecutive QP encoded mime headers
           # Fixes breaking inside multi-byte characters

    $str =~ s{
        =\?              # begin encoded word
        ([-0-9A-Za-z_]+) # charset (encoding)
        (?:\*[A-Za-z]{1,8}(?:-[A-Za-z]{1,8})*)? # language (RFC 2231)
        \?([QqBb])\?     # delimiter
        (.*?)            # Base64-encodede contents
        \?=              # end encoded word
    }{
        if      (uc($2) eq 'B'){
            $obj->{decode_b} or croak qq(MIME "B" unsupported);
            decode_b($1, $3, $chk);
        } elsif (uc($2) eq 'Q'){
            $obj->{decode_q} or croak qq(MIME "Q" unsupported);
            decode_q($1, $3, $chk);
        } else {
            croak qq(MIME "$2" encoding is nonexistent!);
        }
    }egox;
    $_[1] = $str if $chk;
    return $str;
}

sub decode_b {
    my $enc  = shift;
    my $d    = find_encoding($enc) or croak qq(Unknown encoding "$enc");
    my $db64 = decode_base64(shift);
    my $chk  = shift;
    return $d->name eq 'utf8'
      ? Encode::decode_utf8($db64)
      : $d->decode( $db64, $chk || Encode::FB_PERLQQ );
}

sub decode_q {
    my ( $enc, $q, $chk ) = @_;
    my $d = find_encoding($enc) or croak qq(Unknown encoding "$enc");
    $q =~ s/_/ /go;
    $q =~ s/=([0-9A-Fa-f]{2})/pack("C", hex($1))/ego;
    return $d->name eq 'utf8'
      ? Encode::decode_utf8($q)
      : $d->decode( $q, $chk || Encode::FB_PERLQQ );
}

my $especials =
  join( '|' => map { quotemeta( chr($_) ) }
      unpack( "C*", qq{()<>,;:"'/[]?=} ) );

my $re_encoded_word = qr{
    =\?                # begin encoded word
    (?:[-0-9A-Za-z_]+) # charset (encoding)
    (?:\*[A-Za-z]{1,8}(?:-[A-Za-z]{1,8})*)? # language (RFC 2231)
    \?(?:[QqBb])\?     # delimiter
    (?:.*?)            # Base64-encodede contents
    \?=                # end encoded word
}xo;

my $re_especials = qr{$re_encoded_word|$especials}xo;

# cf:
#    https://rt.cpan.org/Ticket/Display.html?id=88717
#    https://www.ietf.org/rfc/rfc0822.txt
my $re_linear_white_space = qr{(?:[ \t]|\r\n?)};

sub encode($$;$) {
    my ( $obj, $str, $chk ) = @_;
    my @line = ();
    for my $line ( split /\r\n|[\r\n]/o, $str ) {
        my ( @word, @subline );
        if ($line =~ /\A([\w\-]+:\s+)(.*)\z/o) {
            push @word, $1, $obj->_encode($2); # "X-Header-Name: ..."
        } else {
            push @word, $obj->_encode($line);  # anything else
        }
        my $subline = '';
        for my $word (@word) {
            use bytes ();
            if ( bytes::length($subline) + bytes::length($word) >
                $obj->{bpl} - 1 )
            {
                push @subline, $subline;
                $subline = '';
            }
            $subline .= ' ' if ($subline =~ /\?=$/ and $word =~ /^=\?/);
            $subline .= $word;
        }
        length($subline) and push @subline, $subline;
        push @line, join( "\n " => grep !/^$/, @subline );
    }
    $_[1] = '' if $chk;
    return (substr($str, 0, 0) . join( "\n", @line ));
}

use constant HEAD   => '=?UTF-8?';
use constant TAIL   => '?=';
use constant SINGLE => { B => \&_encode_b, Q => \&_encode_q, };

sub _encode {
    my ( $o, $str ) = @_;
    my $enc  = $o->{encode};
    my $llen = ( $o->{bpl} - length(HEAD) - 2 - length(TAIL) );

    # to coerce a floating-point arithmetics, the following contains
    # .0 in numbers -- dankogai
    $llen *= $enc eq 'B' ? 3.0 / 4.0 : 1.0 / 3.0;
    my @result = ();
    my $chunk  = '';
    while ( length( my $chr = substr( $str, 0, 1, '' ) ) ) {
        use bytes ();
        if ( bytes::length($chunk) + bytes::length($chr) > $llen ) {
            push @result, SINGLE->{$enc}($chunk);
            $chunk = '';
        }
        $chunk .= $chr;
    }
    length($chunk) and push @result, SINGLE->{$enc}($chunk);
    return @result;
}

sub _encode_b {
    HEAD . 'B?' . encode_base64( encode_utf8(shift), '' ) . TAIL;
}

sub _encode_q {
    my $chunk = shift;
    $chunk = encode_utf8($chunk);
    $chunk =~ s{
	   ([^0-9A-Za-z])
       }{
            join("" => map {sprintf "=%02X", $_} unpack("C*", $1))
       }egox;
    return HEAD . 'Q?' . $chunk . TAIL;
}

1;
__END__

=head1 NAME

Encode::MIME::Header -- MIME 'B' and 'Q' header encoding

=head1 SYNOPSIS

    use Encode qw/encode decode/;
    $utf8   = decode('MIME-Header', $header);
    $header = encode('MIME-Header', $utf8);

=head1 ABSTRACT

This module implements RFC 2047 Mime Header Encoding.  There are 3
variant encoding names; C<MIME-Header>, C<MIME-B> and C<MIME-Q>.  The
difference is described below

              decode()          encode()
  ----------------------------------------------
  MIME-Header Both B and Q      =?UTF-8?B?....?=
  MIME-B      B only; Q croaks  =?UTF-8?B?....?=
  MIME-Q      Q only; B croaks  =?UTF-8?Q?....?=

=head1 DESCRIPTION

When you decode(=?I<encoding>?I<X>?I<ENCODED WORD>?=), I<ENCODED WORD>
is extracted and decoded for I<X> encoding (B for Base64, Q for
Quoted-Printable). Then the decoded chunk is fed to
decode(I<encoding>).  So long as I<encoding> is supported by Encode,
any source encoding is fine.

When you encode, it just encodes UTF-8 string with I<X> encoding then
quoted with =?UTF-8?I<X>?....?= .  The parts that RFC 2047 forbids to
encode are left as is and long lines are folded within 76 bytes per
line.

=head1 BUGS

It would be nice to support encoding to non-UTF8, such as =?ISO-2022-JP?
and =?ISO-8859-1?= but that makes the implementation too complicated.
These days major mail agents all support =?UTF-8? so I think it is
just good enough.

Due to popular demand, 'MIME-Header-ISO_2022_JP' was introduced by
Makamaka.  Thre are still too many MUAs especially cellular phone
handsets which does not grok UTF-8.

=head1 SEE ALSO

L<Encode>

RFC 2047, L<http://www.faqs.org/rfcs/rfc2047.html> and many other
locations.

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 package Encode::MIME::Header::ISO_2022_JP;

use strict;
use warnings;

use parent qw(Encode::MIME::Header);

$Encode::Encoding{'MIME-Header-ISO_2022_JP'} =
  bless { encode => 'B', bpl => 76, Name => 'MIME-Header-ISO_2022_JP' } =>
  __PACKAGE__;

use constant HEAD => '=?ISO-2022-JP?B?';
use constant TAIL => '?=';

use Encode::CJKConstants qw(%RE);

our $VERSION = do { my @r = ( q$Revision: 1.4 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };

# I owe the below codes totally to
#   Jcode by Dan Kogai & http://www.din.or.jp/~ohzaki/perl.htm#JP_Base64

sub encode {
    my $self = shift;
    my $str  = shift;

    utf8::encode($str) if ( Encode::is_utf8($str) );
    Encode::from_to( $str, 'utf8', 'euc-jp' );

    my ($trailing_crlf) = ( $str =~ /(\n|\r|\x0d\x0a)$/o );

    $str = _mime_unstructured_header( $str, $self->{bpl} );

    not $trailing_crlf and $str =~ s/(\n|\r|\x0d\x0a)$//o;

    return $str;
}

sub _mime_unstructured_header {
    my ( $oldheader, $bpl ) = @_;
    my $crlf = $oldheader =~ /\n$/;
    my ( $header, @words, @wordstmp, $i ) = ('');

    $oldheader =~ s/\s+$//;

    @wordstmp = split /\s+/, $oldheader;

    for ( $i = 0 ; $i < $#wordstmp ; $i++ ) {
        if (    $wordstmp[$i] !~ /^[\x21-\x7E]+$/
            and $wordstmp[ $i + 1 ] !~ /^[\x21-\x7E]+$/ )
        {
            $wordstmp[ $i + 1 ] = "$wordstmp[$i] $wordstmp[$i + 1]";
        }
        else {
            push( @words, $wordstmp[$i] );
        }
    }

    push( @words, $wordstmp[-1] );

    for my $word (@words) {
        if ( $word =~ /^[\x21-\x7E]+$/ ) {
            $header =~ /(?:.*\n)*(.*)/;
            if ( length($1) + length($word) > $bpl ) {
                $header .= "\n $word";
            }
            else {
                $header .= $word;
            }
        }
        else {
            $header = _add_encoded_word( $word, $header, $bpl );
        }

        $header =~ /(?:.*\n)*(.*)/;

        if ( length($1) == $bpl ) {
            $header .= "\n ";
        }
        else {
            $header .= ' ';
        }
    }

    $header =~ s/\n? $//mg;

    $crlf ? "$header\n" : $header;
}

sub _add_encoded_word {
    my ( $str, $line, $bpl ) = @_;
    my $result = '';

    while ( length($str) ) {
        my $target = $str;
        $str = '';

        if (
            length($line) + 22 +
            ( $target =~ /^(?:$RE{EUC_0212}|$RE{EUC_C})/o ) * 8 > $bpl )
        {
            $line =~ s/[ \t\n\r]*$/\n/;
            $result .= $line;
            $line = ' ';
        }

        while (1) {
            my $iso_2022_jp = $target;
            Encode::from_to( $iso_2022_jp, 'euc-jp', 'iso-2022-jp' );

            my $encoded =
              HEAD . MIME::Base64::encode_base64( $iso_2022_jp, '' ) . TAIL;

            if ( length($encoded) + length($line) > $bpl ) {
                $target =~
                  s/($RE{EUC_0212}|$RE{EUC_KANA}|$RE{EUC_C}|$RE{ASCII})$//o;
                $str = $1 . $str;
            }
            else {
                $line .= $encoded;
                last;
            }
        }

    }

    $result . $line;
}

1;
__END__

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             #
# $Id: UTF7.pm,v 2.8 2013/09/14 07:51:59 dankogai Exp $
#
package Encode::Unicode::UTF7;
use strict;
use warnings;
no warnings 'redefine';
use parent qw(Encode::Encoding);
__PACKAGE__->Define('UTF-7');
our $VERSION = do { my @r = ( q$Revision: 2.8 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
use MIME::Base64;
use Encode;

#
# Algorithms taken from Unicode::String by Gisle Aas
#

our $OPTIONAL_DIRECT_CHARS = 1;
my $specials = quotemeta "\'(),-./:?";
$OPTIONAL_DIRECT_CHARS
  and $specials .= quotemeta "!\"#$%&*;<=>@[]^_`{|}";

# \s will not work because it matches U+3000 DEOGRAPHIC SPACE
# We use qr/[\n\r\t\ ] instead
my $re_asis    = qr/(?:[\n\r\t\ A-Za-z0-9$specials])/;
my $re_encoded = qr/(?:[^\n\r\t\ A-Za-z0-9$specials])/;
my $e_utf16    = find_encoding("UTF-16BE");

sub needs_lines { 1 }

sub encode($$;$) {
    my ( $obj, $str, $chk ) = @_;
    my $len = length($str);
    pos($str) = 0;
    my $bytes = substr($str, 0, 0); # to propagate taintedness
    while ( pos($str) < $len ) {
        if ( $str =~ /\G($re_asis+)/ogc ) {
	    my $octets = $1;
	    utf8::downgrade($octets);
	    $bytes .= $octets;
        }
        elsif ( $str =~ /\G($re_encoded+)/ogsc ) {
            if ( $1 eq "+" ) {
                $bytes .= "+-";
            }
            else {
                my $s = $1;
                my $base64 = encode_base64( $e_utf16->encode($s), '' );
                $base64 =~ s/=+$//;
                $bytes .= "+$base64-";
            }
        }
        else {
            die "This should not happen! (pos=" . pos($str) . ")";
        }
    }
    $_[1] = '' if $chk;
    return $bytes;
}

sub decode($$;$) {
    use re 'taint';
    my ( $obj, $bytes, $chk ) = @_;
    my $len = length($bytes);
    my $str = substr($bytes, 0, 0); # to propagate taintedness;
    pos($bytes) = 0;
    no warnings 'uninitialized';
    while ( pos($bytes) < $len ) {
        if ( $bytes =~ /\G([^+]+)/ogc ) {
            $str .= $1;
        }
        elsif ( $bytes =~ /\G\+-/ogc ) {
            $str .= "+";
        }
        elsif ( $bytes =~ /\G\+([A-Za-z0-9+\/]+)-?/ogsc ) {
            my $base64 = $1;
            my $pad    = length($base64) % 4;
            $base64 .= "=" x ( 4 - $pad ) if $pad;
            $str .= $e_utf16->decode( decode_base64($base64) );
        }
        elsif ( $bytes =~ /\G\+/ogc ) {
            $^W and warn "Bad UTF7 data escape";
            $str .= "+";
        }
        else {
            die "This should not happen " . pos($bytes);
        }
    }
    $_[1] = '' if $chk;
    return $str;
}
1;
__END__

=head1 NAME

Encode::Unicode::UTF7 -- UTF-7 encoding

=head1 SYNOPSIS

    use Encode qw/encode decode/; 
    $utf7 = encode("UTF-7", $utf8);
    $utf8 = decode("UTF-7", $ucs2);

=head1 ABSTRACT

This module implements UTF-7 encoding documented in RFC 2152.  UTF-7,
as its name suggests, is a 7-bit re-encoded version of UTF-16BE.  It
is designed to be MTA-safe and expected to be a standard way to
exchange Unicoded mails via mails.  But with the advent of UTF-8 and
8-bit compliant MTAs, UTF-7 is hardly ever used.

UTF-7 was not supported by Encode until version 1.95 because of that.
But Unicode::String, a module by Gisle Aas which adds Unicode supports
to non-utf8-savvy perl did support UTF-7, the UTF-7 support was added
so Encode can supersede Unicode::String 100%.

=head1 In Practice

When you want to encode Unicode for mails and web pages, however, do
not use UTF-7 unless you are sure your recipients and readers can
handle it.  Very few MUAs and WWW Browsers support these days (only
Mozilla seems to support one).  For general cases, use UTF-8 for
message body and MIME-Header for header instead.

=head1 SEE ALSO

L<Encode>, L<Encode::Unicode>, L<Unicode::String>

RFC 2781 L<http://www.ietf.org/rfc/rfc2152.txt>

=cut
                                                                                                                                                                                                                                                                                                       #!perl -w

#
# Documentation at the __END__
#

package File::DosGlob;

our $VERSION = '1.12';
use strict;
use warnings;

require XSLoader;
XSLoader::load();

sub doglob {
    my $cond = shift;
    my @retval = ();
    my $fix_drive_relative_paths;
  OUTER:
    for my $pat (@_) {
	my @matched = ();
	my @globdirs = ();
	my $head = '.';
	my $sepchr = '/';
        my $tail;
	next OUTER unless defined $pat and $pat ne '';
	# if arg is within quotes strip em and do no globbing
	if ($pat =~ /^"(.*)"\z/s) {
	    $pat = $1;
	    if ($cond eq 'd') { push(@retval, $pat) if -d $pat }
	    else              { push(@retval, $pat) if -e $pat }
	    next OUTER;
	}
	# wildcards with a drive prefix such as h:*.pm must be changed
	# to h:./*.pm to expand correctly
	if ($pat =~ m|^([A-Za-z]:)[^/\\]|s) {
	    substr($pat,0,2) = $1 . "./";
	    $fix_drive_relative_paths = 1;
	}
	if ($pat =~ m|^(.*)([\\/])([^\\/]*)\z|s) {
	    ($head, $sepchr, $tail) = ($1,$2,$3);
	    push (@retval, $pat), next OUTER if $tail eq '';
	    if ($head =~ /[*?]/) {
		@globdirs = doglob('d', $head);
		push(@retval, doglob($cond, map {"$_$sepchr$tail"} @globdirs)),
		    next OUTER if @globdirs;
	    }
	    $head .= $sepchr if $head eq '' or $head =~ /^[A-Za-z]:\z/s;
	    $pat = $tail;
	}
	#
	# If file component has no wildcards, we can avoid opendir
	unless ($pat =~ /[*?]/) {
	    $head = '' if $head eq '.';
	    $head .= $sepchr unless $head eq '' or substr($head,-1) eq $sepchr;
	    $head .= $pat;
	    if ($cond eq 'd') { push(@retval,$head) if -d $head }
	    else              { push(@retval,$head) if -e $head }
	    next OUTER;
	}
	opendir(D, $head) or next OUTER;
	my @leaves = readdir D;
	closedir D;

	# VMS-format filespecs, especially if they contain extended characters,
	# are unlikely to match patterns correctly, so Unixify them.
	if ($^O eq 'VMS') {
	    require VMS::Filespec;
	    @leaves = map {$_ =~ s/\.$//; VMS::Filespec::unixify($_)} @leaves;
        }
	$head = '' if $head eq '.';
	$head .= $sepchr unless $head eq '' or substr($head,-1) eq $sepchr;

	# escape regex metachars but not glob chars
	$pat =~ s:([].+^\-\${}()[|]):\\$1:g;
	# and convert DOS-style wildcards to regex
	$pat =~ s/\*/.*/g;
	$pat =~ s/\?/.?/g;

	my $matchsub = sub { $_[0] =~ m|^$pat\z|is };
      INNER:
	for my $e (@leaves) {
	    next INNER if $e eq '.' or $e eq '..';
	    next INNER if $cond eq 'd' and ! -d "$head$e";
	    push(@matched, "$head$e"), next INNER if &$matchsub($e);
	    #
	    # [DOS compatibility special case]
	    # Failed, add a trailing dot and try again, but only
	    # if name does not have a dot in it *and* pattern
	    # has a dot *and* name is shorter than 9 chars.
	    #
	    if (index($e,'.') == -1 and length($e) < 9
	        and index($pat,'\\.') != -1) {
		push(@matched, "$head$e"), next INNER if &$matchsub("$e.");
	    }
	}
	push @retval, @matched if @matched;
    }
    if ($fix_drive_relative_paths) {
	s|^([A-Za-z]:)\./|$1| for @retval;
    }
    return @retval;
}

#
# this can be used to override CORE::glob in a specific
# package by saying C<use File::DosGlob 'glob';> in that
# namespace.
#

# context (keyed by second cxix arg provided by core)
our %entries;

sub glob {
    my($pat,$cxix) = ($_[0], _callsite());
    my @pat;

    # glob without args defaults to $_
    $pat = $_ unless defined $pat;

    # if we're just beginning, do it all first
    if (!$entries{$cxix}) {
      # extract patterns
      if ($pat =~ /\s/) {
	require Text::ParseWords;
	@pat = Text::ParseWords::parse_line('\s+',0,$pat);
      }
      else {
	push @pat, $pat;
      }

      # Mike Mestnik: made to do abc{1,2,3} == abc1 abc2 abc3.
      #   abc3 will be the original {3} (and drop the {}).
      #   abc1 abc2 will be put in @appendpat.
      # This was just the easiest way, not nearly the best.
      REHASH: {
	my @appendpat = ();
	for (@pat) {
	    # There must be a "," I.E. abc{efg} is not what we want.
	    while ( /^(.*)(?<!\\)\{(.*?)(?<!\\)\,.*?(?<!\\)\}(.*)$/ ) {
		my ($start, $match, $end) = ($1, $2, $3);
		#print "Got: \n\t$start\n\t$match\n\t$end\n";
		my $tmp = "$start$match$end";
		while ( $tmp =~ s/^(.*?)(?<!\\)\{(?:.*(?<!\\)\,)?(.*\Q$match\E.*?)(?:(?<!\\)\,.*)?(?<!\\)\}(.*)$/$1$2$3/ ) {
		    #  these expansions will be performed by the original,
		    #  when we call REHASH.
		}
		push @appendpat, ("$tmp");
		s/^\Q$start\E(?<!\\)\{\Q$match\E(?<!\\)\,/$start\{/;
		if ( /^\Q$start\E(?<!\\)\{(?!.*?(?<!\\)\,.*?\Q$end\E$)(.*)(?<!\\)\}\Q$end\E$/ ) {
		    $match = $1;
		    #print "GOT: \n\t$start\n\t$match\n\t$end\n\n";
		    $_ = "$start$match$end";
		}
	    }
	    #print "Sould have "GOT" vs "Got"!\n";
		#FIXME: There should be checking for this.
		#  How or what should be done about failure is beyond me.
	}
	if ( $#appendpat != -1
		) {
	    #FIXME: Max loop, no way! :")
	    for ( @appendpat ) {
	        push @pat, $_;
	    }
	    goto REHASH;
	}
      }
      for ( @pat ) {
	s/\\([{},])/$1/g;
      }
 
      $entries{$cxix} = [doglob(1,@pat)];
    }

    # chuck it all out, quick or slow
    if (wantarray) {
	return @{delete $entries{$cxix}};
    }
    else {
	if (scalar @{$entries{$cxix}}) {
	    return shift @{$entries{$cxix}};
	}
	else {
	    # return undef for EOL
	    delete $entries{$cxix};
	    return undef;
	}
    }
}

{
    no strict 'refs';

    sub import {
    my $pkg = shift;
    return unless @_;
    my $sym = shift;
    my $callpkg = ($sym =~ s/^GLOBAL_//s ? 'CORE::GLOBAL' : caller(0));
    *{$callpkg.'::'.$sym} = \&{$pkg.'::'.$sym} if $sym eq 'glob';
    }
}
1;

__END__

=head1 NAME

File::DosGlob - DOS like globbing and then some

=head1 SYNOPSIS

    require 5.004;

    # override CORE::glob in current package
    use File::DosGlob 'glob';

    # override CORE::glob in ALL packages (use with extreme caution!)
    use File::DosGlob 'GLOBAL_glob';

    @perlfiles = glob  "..\\pe?l/*.p?";
    print <..\\pe?l/*.p?>;

    # from the command line (overrides only in main::)
    > perl -MFile::DosGlob=glob -e "print <../pe*/*p?>"

=head1 DESCRIPTION

A module that implements DOS-like globbing with a few enhancements.
It is largely compatible with perlglob.exe (the M$ setargv.obj
version) in all but one respect--it understands wildcards in
directory components.

For example, C<< <..\\l*b\\file/*glob.p?> >> will work as expected (in
that it will find something like '..\lib\File/DosGlob.pm' alright).
Note that all path components are case-insensitive, and that
backslashes and forward slashes are both accepted, and preserved.
You may have to double the backslashes if you are putting them in
literally, due to double-quotish parsing of the pattern by perl.

Spaces in the argument delimit distinct patterns, so
C<glob('*.exe *.dll')> globs all filenames that end in C<.exe>
or C<.dll>.  If you want to put in literal spaces in the glob
pattern, you can escape them with either double quotes, or backslashes.
e.g. C<glob('c:/"Program Files"/*/*.dll')>, or
C<glob('c:/Program\ Files/*/*.dll')>.  The argument is tokenized using
C<Text::ParseWords::parse_line()>, so see L<Text::ParseWords> for details
of the quoting rules used.

Extending it to csh patterns is left as an exercise to the reader.

=head1 EXPORTS (by request only)

glob()

=head1 BUGS

Should probably be built into the core, and needs to stop
pandering to DOS habits.  Needs a dose of optimization too.

=head1 AUTHOR

Gurusamy Sarathy <gsar@activestate.com>

=head1 HISTORY

=over 4

=item *

Support for globally overriding glob() (GSAR 3-JUN-98)

=item *

Scalar context, independent iterator context fixes (GSAR 15-SEP-97)

=item *

A few dir-vs-file optimizations result in glob importation being
10 times faster than using perlglob.exe, and using perlglob.bat is
only twice as slow as perlglob.exe (GSAR 28-MAY-97)

=item *

Several cleanups prompted by lack of compatible perlglob.exe
under Borland (GSAR 27-MAY-97)

=item *

Initial version (GSAR 20-FEB-97)

=back

=head1 SEE ALSO

perl

perlglob.bat

Text::ParseWords

=cut

                                                                                                                                                                                                      package File::Glob;

use strict;
our($VERSION, @ISA, @EXPORT_OK, @EXPORT_FAIL, %EXPORT_TAGS, $DEFAULT_FLAGS);

require XSLoader;

@ISA = qw(Exporter);

# NOTE: The glob() export is only here for compatibility with 5.6.0.
# csh_glob() should not be used directly, unless you know what you're doing.

%EXPORT_TAGS = (
    'glob' => [ qw(
        GLOB_ABEND
	GLOB_ALPHASORT
        GLOB_ALTDIRFUNC
        GLOB_BRACE
        GLOB_CSH
        GLOB_ERR
        GLOB_ERROR
        GLOB_LIMIT
        GLOB_MARK
        GLOB_NOCASE
        GLOB_NOCHECK
        GLOB_NOMAGIC
        GLOB_NOSORT
        GLOB_NOSPACE
        GLOB_QUOTE
        GLOB_TILDE
        bsd_glob
        glob
    ) ],
);
$EXPORT_TAGS{bsd_glob} = [@{$EXPORT_TAGS{glob}}];
pop @{$EXPORT_TAGS{bsd_glob}}; # no "glob"

@EXPORT_OK   = (@{$EXPORT_TAGS{'glob'}}, 'csh_glob');

$VERSION = '1.26';

sub import {
    require Exporter;
    local $Exporter::ExportLevel = $Exporter::ExportLevel + 1;
    Exporter::import(grep {
        my $passthrough;
        if ($_ eq ':case') {
            $DEFAULT_FLAGS &= ~GLOB_NOCASE()
        }
        elsif ($_ eq ':nocase') {
            $DEFAULT_FLAGS |= GLOB_NOCASE();
        }
        elsif ($_ eq ':globally') {
	    no warnings 'redefine';
	    *CORE::GLOBAL::glob = \&File::Glob::csh_glob;
	}
        elsif ($_ eq ':bsd_glob') {
	    no strict; *{caller."::glob"} = \&bsd_glob_override;
            $passthrough = 1;
	}
	else {
            $passthrough = 1;
        }
        $passthrough;
    } @_);
}

XSLoader::load();

$DEFAULT_FLAGS = GLOB_CSH();
if ($^O =~ /^(?:MSWin32|VMS|os2|dos|riscos)$/) {
    $DEFAULT_FLAGS |= GLOB_NOCASE();
}

# File::Glob::glob() is deprecated because its prototype is different from
# CORE::glob() (use bsd_glob() instead)
sub glob {
    splice @_, 1; # no flags
    goto &bsd_glob;
}

1;
__END__

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   package File::Spec;

use strict;
use vars qw(@ISA $VERSION);

$VERSION = '3.63_01';
$VERSION =~ tr/_//d;

my %module = (MacOS   => 'Mac',
	      MSWin32 => 'Win32',
	      os2     => 'OS2',
	      VMS     => 'VMS',
	      epoc    => 'Epoc',
	      NetWare => 'Win32', # Yes, File::Spec::Win32 works on NetWare.
	      symbian => 'Win32', # Yes, File::Spec::Win32 works on symbian.
	      dos     => 'OS2',   # Yes, File::Spec::OS2 works on DJGPP.
	      cygwin  => 'Cygwin',
	      amigaos => 'AmigaOS');

my $module = $module{$^O} || 'Unix';

require "File/Spec/$module.pm";
@ISA = ("File::Spec::$module");

1;

__END__

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  package File::Spec::AmigaOS;

use strict;
use vars qw(@ISA $VERSION);
require File::Spec::Unix;

$VERSION = '3.64';
$VERSION =~ tr/_//d;

@ISA = qw(File::Spec::Unix);

=head1 NAME

File::Spec::AmigaOS - File::Spec for AmigaOS

=head1 SYNOPSIS

 require File::Spec::AmigaOS; # Done automatically by File::Spec
                              # if needed

=head1 DESCRIPTION

Methods for manipulating file specifications.

=head1 METHODS

=over 2

=item tmpdir

Returns $ENV{TMPDIR} or if that is unset, "/t".

=cut

my $tmpdir;
sub tmpdir {
  return $tmpdir if defined $tmpdir;
  $tmpdir = $_[0]->_tmpdir( $ENV{TMPDIR}, "/t" );
}

=item file_name_is_absolute

Returns true if there's a colon in the file name,
or if it begins with a slash.

=cut

sub file_name_is_absolute {
  my ($self, $file) = @_;

  # Not 100% robust as a "/" must not preceded a ":"
  # but this cannot happen in a well formed path.
  return $file =~ m{^/|:}s;
}

=back

All the other methods are from L<File::Spec::Unix>.

=cut

1;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      package File::Spec::Cygwin;

use strict;
use vars qw(@ISA $VERSION);
require File::Spec::Unix;

$VERSION = '3.63_01';
$VERSION =~ tr/_//d;

@ISA = qw(File::Spec::Unix);

=head1 NAME

File::Spec::Cygwin - methods for Cygwin file specs

=head1 SYNOPSIS

 require File::Spec::Cygwin; # Done internally by File::Spec if needed

=head1 DESCRIPTION

See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
implementation of these methods, not the semantics.

This module is still in beta.  Cygwin-knowledgeable folks are invited
to offer patches and suggestions.

=cut

=pod

=over 4

=item canonpath

Any C<\> (backslashes) are converted to C</> (forward slashes),
and then File::Spec::Unix canonpath() is called on the result.

=cut

sub canonpath {
    my($self,$path) = @_;
    return unless defined $path;

    $path =~ s|\\|/|g;

    # Handle network path names beginning with double slash
    my $node = '';
    if ( $path =~ s@^(//[^/]+)(?:/|\z)@/@s ) {
        $node = $1;
    }
    return $node . $self->SUPER::canonpath($path);
}

sub catdir {
    my $self = shift;
    return unless @_;

    # Don't create something that looks like a //network/path
    if ($_[0] and ($_[0] eq '/' or $_[0] eq '\\')) {
        shift;
        return $self->SUPER::catdir('', @_);
    }

    $self->SUPER::catdir(@_);
}

=pod

=item file_name_is_absolute

True is returned if the file name begins with C<drive_letter:>,
and if not, File::Spec::Unix file_name_is_absolute() is called.

=cut


sub file_name_is_absolute {
    my ($self,$file) = @_;
    return 1 if $file =~ m{^([a-z]:)?[\\/]}is; # C:/test
    return $self->SUPER::file_name_is_absolute($file);
}

=item tmpdir (override)

Returns a string representation of the first existing directory
from the following list:

    $ENV{TMPDIR}
    /tmp
    $ENV{'TMP'}
    $ENV{'TEMP'}
    C:/temp

If running under taint mode, and if the environment
variables are tainted, they are not used.

=cut

sub tmpdir {
    my $cached = $_[0]->_cached_tmpdir(qw 'TMPDIR TMP TEMP');
    return $cached if defined $cached;
    $_[0]->_cache_tmpdir(
        $_[0]->_tmpdir(
            $ENV{TMPDIR}, "/tmp", $ENV{'TMP'}, $ENV{'TEMP'}, 'C:/temp'
        ),
        qw 'TMPDIR TMP TEMP'
    );
}

=item case_tolerant

Override Unix. Cygwin case-tolerance depends on managed mount settings and
as with MsWin32 on GetVolumeInformation() $ouFsFlags == FS_CASE_SENSITIVE,
indicating the case significance when comparing file specifications.
Default: 1

=cut

sub case_tolerant {
  return 1 unless $^O eq 'cygwin'
    and defined &Cygwin::mount_flags;

  my $drive = shift;
  if (! $drive) {
      my @flags = split(/,/, Cygwin::mount_flags('/cygwin'));
      my $prefix = pop(@flags);
      if (! $prefix || $prefix eq 'cygdrive') {
          $drive = '/cygdrive/c';
      } elsif ($prefix eq '/') {
          $drive = '/c';
      } else {
          $drive = "$prefix/c";
      }
  }
  my $mntopts = Cygwin::mount_flags($drive);
  if ($mntopts and ($mntopts =~ /,managed/)) {
    return 0;
  }
  eval {
      local @INC = @INC;
      pop @INC if $INC[-1] eq '.';
      require Win32API::File;
  } or return 1;
  my $osFsType = "\0"x256;
  my $osVolName = "\0"x256;
  my $ouFsFlags = 0;
  Win32API::File::GetVolumeInformation($drive, $osVolName, 256, [], [], $ouFsFlags, $osFsType, 256 );
  if ($ouFsFlags & Win32API::File::FS_CASE_SENSITIVE()) { return 0; }
  else { return 1; }
}

=back

=head1 COPYRIGHT

Copyright (c) 2004,2007 by the Perl 5 Porters.  All rights reserved.

This program is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=cut

1;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                               package File::Spec::Epoc;

use strict;
use vars qw($VERSION @ISA);

$VERSION = '3.63_01';
$VERSION =~ tr/_//d;

require File::Spec::Unix;
@ISA = qw(File::Spec::Unix);

=head1 NAME

File::Spec::Epoc - methods for Epoc file specs

=head1 SYNOPSIS

 require File::Spec::Epoc; # Done internally by File::Spec if needed

=head1 DESCRIPTION

See File::Spec::Unix for a documentation of the methods provided
there.  This package overrides the implementation of these methods, not
the semantics.

This package is still a work in progress. ;-)

=cut

sub case_tolerant {
    return 1;
}

=pod

=over 4

=item canonpath()

No physical check on the filesystem, but a logical cleanup of a
path.  On UNIX eliminated successive slashes and successive "/.".

=back

=cut

sub canonpath {
    my ($self,$path) = @_;
    return unless defined $path;

    $path =~ s|/+|/|g;                             # xx////xx  -> xx/xx
    $path =~ s|(/\.)+/|/|g;                        # xx/././xx -> xx/xx
    $path =~ s|^(\./)+||s unless $path eq "./";    # ./xx      -> xx
    $path =~ s|^/(\.\./)+|/|s;                     # /../../xx -> xx
    $path =~  s|/\Z(?!\n)|| unless $path eq "/";          # xx/       -> xx
    return $path;
}

=pod

=head1 AUTHOR

o.flebbe@gmx.de

=head1 COPYRIGHT

Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.

This program is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=head1 SEE ALSO

See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
implementation of these methods, not the semantics.

=cut

1;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      package File::Spec::Functions;

use File::Spec;
use strict;

use vars qw(@ISA @EXPORT @EXPORT_OK %EXPORT_TAGS $VERSION);

$VERSION = '3.63_01';
$VERSION =~ tr/_//d;

require Exporter;

@ISA = qw(Exporter);

@EXPORT = qw(
	canonpath
	catdir
	catfile
	curdir
	rootdir
	updir
	no_upwards
	file_name_is_absolute
	path
);

@EXPORT_OK = qw(
	devnull
	tmpdir
	splitpath
	splitdir
	catpath
	abs2rel
	rel2abs
	case_tolerant
);

%EXPORT_TAGS = ( ALL => [ @EXPORT_OK, @EXPORT ] );

require File::Spec::Unix;
my %udeps = (
    canonpath => [],
    catdir => [qw(canonpath)],
    catfile => [qw(canonpath catdir)],
    case_tolerant => [],
    curdir => [],
    devnull => [],
    rootdir => [],
    updir => [],
);

foreach my $meth (@EXPORT, @EXPORT_OK) {
    my $sub = File::Spec->can($meth);
    no strict 'refs';
    if (exists($udeps{$meth}) && $sub == File::Spec::Unix->can($meth) &&
	    !(grep {
		File::Spec->can($_) != File::Spec::Unix->can($_)
	    } @{$udeps{$meth}}) &&
	    defined(&{"File::Spec::Unix::_fn_$meth"})) {
	*{$meth} = \&{"File::Spec::Unix::_fn_$meth"};
    } else {
	*{$meth} = sub {&$sub('File::Spec', @_)};
    }
}


1;
__END__

=head1 NAME

File::Spec::Functions - portably perform operations on file names

=head1 SYNOPSIS

	use File::Spec::Functions;
	$x = catfile('a','b');

=head1 DESCRIPTION

This module exports convenience functions for all of the class methods
provided by File::Spec.

For a reference of available functions, please consult L<File::Spec::Unix>,
which contains the entire set, and which is inherited by the modules for
other platforms. For further information, please see L<File::Spec::Mac>,
L<File::Spec::OS2>, L<File::Spec::Win32>, or L<File::Spec::VMS>.

=head2 Exports

The following functions are exported by default.

	canonpath
	catdir
	catfile
	curdir
	rootdir
	updir
	no_upwards
	file_name_is_absolute
	path


The following functions are exported only by request.

	devnull
	tmpdir
	splitpath
	splitdir
	catpath
	abs2rel
	rel2abs
	case_tolerant

All the functions may be imported using the C<:ALL> tag.

=head1 COPYRIGHT

Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.

This program is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=head1 SEE ALSO

File::Spec, File::Spec::Unix, File::Spec::Mac, File::Spec::OS2,
File::Spec::Win32, File::Spec::VMS, ExtUtils::MakeMaker

=cut

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        package File::Spec::Mac;

use strict;
use vars qw(@ISA $VERSION);
require File::Spec::Unix;

$VERSION = '3.63_01';
$VERSION =~ tr/_//d;

@ISA = qw(File::Spec::Unix);

my $macfiles;
if ($^O eq 'MacOS') {
	$macfiles = eval { require Mac::Files };
}

sub case_tolerant { 1 }


=head1 NAME

File::Spec::Mac - File::Spec for Mac OS (Classic)

=head1 SYNOPSIS

 require File::Spec::Mac; # Done internally by File::Spec if needed

=head1 DESCRIPTION

Methods for manipulating file specifications.

=head1 METHODS

=over 2

=item canonpath

On Mac OS, there's nothing to be done. Returns what it's given.

=cut

sub canonpath {
    my ($self,$path) = @_;
    return $path;
}

=item catdir()

Concatenate two or more directory names to form a path separated by colons
(":") ending with a directory. Resulting paths are B<relative> by default,
but can be forced to be absolute (but avoid this, see below). Automatically
puts a trailing ":" on the end of the complete path, because that's what's
done in MacPerl's environment and helps to distinguish a file path from a
directory path.

B<IMPORTANT NOTE:> Beginning with version 1.3 of this module, the resulting
path is relative by default and I<not> absolute. This decision was made due
to portability reasons. Since C<File::Spec-E<gt>catdir()> returns relative paths
on all other operating systems, it will now also follow this convention on Mac
OS. Note that this may break some existing scripts.

The intended purpose of this routine is to concatenate I<directory names>.
But because of the nature of Macintosh paths, some additional possibilities
are allowed to make using this routine give reasonable results for some
common situations. In other words, you are also allowed to concatenate
I<paths> instead of directory names (strictly speaking, a string like ":a"
is a path, but not a name, since it contains a punctuation character ":").

So, beside calls like

    catdir("a") = ":a:"
    catdir("a","b") = ":a:b:"
    catdir() = ""                    (special case)

calls like the following

    catdir(":a:") = ":a:"
    catdir(":a","b") = ":a:b:"
    catdir(":a:","b") = ":a:b:"
    catdir(":a:",":b:") = ":a:b:"
    catdir(":") = ":"

are allowed.

Here are the rules that are used in C<catdir()>; note that we try to be as
compatible as possible to Unix:

=over 2

=item 1.

The resulting path is relative by default, i.e. the resulting path will have a
leading colon.

=item 2.

A trailing colon is added automatically to the resulting path, to denote a
directory.

=item 3.

Generally, each argument has one leading ":" and one trailing ":"
removed (if any). They are then joined together by a ":". Special
treatment applies for arguments denoting updir paths like "::lib:",
see (4), or arguments consisting solely of colons ("colon paths"),
see (5).

=item 4.

When an updir path like ":::lib::" is passed as argument, the number
of directories to climb up is handled correctly, not removing leading
or trailing colons when necessary. E.g.

    catdir(":::a","::b","c")    = ":::a::b:c:"
    catdir(":::a::","::b","c")  = ":::a:::b:c:"

=item 5.

Adding a colon ":" or empty string "" to a path at I<any> position
doesn't alter the path, i.e. these arguments are ignored. (When a ""
is passed as the first argument, it has a special meaning, see
(6)). This way, a colon ":" is handled like a "." (curdir) on Unix,
while an empty string "" is generally ignored (see
C<Unix-E<gt>canonpath()> ). Likewise, a "::" is handled like a ".."
(updir), and a ":::" is handled like a "../.." etc.  E.g.

    catdir("a",":",":","b")   = ":a:b:"
    catdir("a",":","::",":b") = ":a::b:"

=item 6.

If the first argument is an empty string "" or is a volume name, i.e. matches
the pattern /^[^:]+:/, the resulting path is B<absolute>.

=item 7.

Passing an empty string "" as the first argument to C<catdir()> is
like passingC<File::Spec-E<gt>rootdir()> as the first argument, i.e.

    catdir("","a","b")          is the same as

    catdir(rootdir(),"a","b").

This is true on Unix, where C<catdir("","a","b")> yields "/a/b" and
C<rootdir()> is "/". Note that C<rootdir()> on Mac OS is the startup
volume, which is the closest in concept to Unix' "/". This should help
to run existing scripts originally written for Unix.

=item 8.

For absolute paths, some cleanup is done, to ensure that the volume
name isn't immediately followed by updirs. This is invalid, because
this would go beyond "root". Generally, these cases are handled like
their Unix counterparts:

 Unix:
    Unix->catdir("","")                 =  "/"
    Unix->catdir("",".")                =  "/"
    Unix->catdir("","..")               =  "/"        # can't go
                                                      # beyond root
    Unix->catdir("",".","..","..","a")  =  "/a"
 Mac:
    Mac->catdir("","")                  =  rootdir()  # (e.g. "HD:")
    Mac->catdir("",":")                 =  rootdir()
    Mac->catdir("","::")                =  rootdir()  # can't go
                                                      # beyond root
    Mac->catdir("",":","::","::","a")   =  rootdir() . "a:"
                                                    # (e.g. "HD:a:")

However, this approach is limited to the first arguments following
"root" (again, see C<Unix-E<gt>canonpath()> ). If there are more
arguments that move up the directory tree, an invalid path going
beyond root can be created.

=back

As you've seen, you can force C<catdir()> to create an absolute path
by passing either an empty string or a path that begins with a volume
name as the first argument. However, you are strongly encouraged not
to do so, since this is done only for backward compatibility. Newer
versions of File::Spec come with a method called C<catpath()> (see
below), that is designed to offer a portable solution for the creation
of absolute paths.  It takes volume, directory and file portions and
returns an entire path. While C<catdir()> is still suitable for the
concatenation of I<directory names>, you are encouraged to use
C<catpath()> to concatenate I<volume names> and I<directory
paths>. E.g.

    $dir      = File::Spec->catdir("tmp","sources");
    $abs_path = File::Spec->catpath("MacintoshHD:", $dir,"");

yields

    "MacintoshHD:tmp:sources:" .

=cut

sub catdir {
	my $self = shift;
	return '' unless @_;
	my @args = @_;
	my $first_arg;
	my $relative;

	# take care of the first argument

	if ($args[0] eq '')  { # absolute path, rootdir
		shift @args;
		$relative = 0;
		$first_arg = $self->rootdir;

	} elsif ($args[0] =~ /^[^:]+:/) { # absolute path, volume name
		$relative = 0;
		$first_arg = shift @args;
		# add a trailing ':' if need be (may be it's a path like HD:dir)
		$first_arg = "$first_arg:" unless ($first_arg =~ /:\Z(?!\n)/);

	} else { # relative path
		$relative = 1;
		if ( $args[0] =~ /^::+\Z(?!\n)/ ) {
			# updir colon path ('::', ':::' etc.), don't shift
			$first_arg = ':';
		} elsif ($args[0] eq ':') {
			$first_arg = shift @args;
		} else {
			# add a trailing ':' if need be
			$first_arg = shift @args;
			$first_arg = "$first_arg:" unless ($first_arg =~ /:\Z(?!\n)/);
		}
	}

	# For all other arguments,
	# (a) ignore arguments that equal ':' or '',
	# (b) handle updir paths specially:
	#     '::' 			-> concatenate '::'
	#     '::' . '::' 	-> concatenate ':::' etc.
	# (c) add a trailing ':' if need be

	my $result = $first_arg;
	while (@args) {
		my $arg = shift @args;
		unless (($arg eq '') || ($arg eq ':')) {
			if ($arg =~ /^::+\Z(?!\n)/ ) { # updir colon path like ':::'
				my $updir_count = length($arg) - 1;
				while ((@args) && ($args[0] =~ /^::+\Z(?!\n)/) ) { # while updir colon path
					$arg = shift @args;
					$updir_count += (length($arg) - 1);
				}
				$arg = (':' x $updir_count);
			} else {
				$arg =~ s/^://s; # remove a leading ':' if any
				$arg = "$arg:" unless ($arg =~ /:\Z(?!\n)/); # ensure trailing ':'
			}
			$result .= $arg;
		}#unless
	}

	if ( ($relative) && ($result !~ /^:/) ) {
		# add a leading colon if need be
		$result = ":$result";
	}

	unless ($relative) {
		# remove updirs immediately following the volume name
		$result =~ s/([^:]+:)(:*)(.*)\Z(?!\n)/$1$3/;
	}

	return $result;
}

=item catfile

Concatenate one or more directory names and a filename to form a
complete path ending with a filename. Resulting paths are B<relative>
by default, but can be forced to be absolute (but avoid this).

B<IMPORTANT NOTE:> Beginning with version 1.3 of this module, the
resulting path is relative by default and I<not> absolute. This
decision was made due to portability reasons. Since
C<File::Spec-E<gt>catfile()> returns relative paths on all other
operating systems, it will now also follow this convention on Mac OS.
Note that this may break some existing scripts.

The last argument is always considered to be the file portion. Since
C<catfile()> uses C<catdir()> (see above) for the concatenation of the
directory portions (if any), the following with regard to relative and
absolute paths is true:

    catfile("")     = ""
    catfile("file") = "file"

but

    catfile("","")        = rootdir()         # (e.g. "HD:")
    catfile("","file")    = rootdir() . file  # (e.g. "HD:file")
    catfile("HD:","file") = "HD:file"

This means that C<catdir()> is called only when there are two or more
arguments, as one might expect.

Note that the leading ":" is removed from the filename, so that

    catfile("a","b","file")  = ":a:b:file"    and

    catfile("a","b",":file") = ":a:b:file"

give the same answer.

To concatenate I<volume names>, I<directory paths> and I<filenames>,
you are encouraged to use C<catpath()> (see below).

=cut

sub catfile {
    my $self = shift;
    return '' unless @_;
    my $file = pop @_;
    return $file unless @_;
    my $dir = $self->catdir(@_);
    $file =~ s/^://s;
    return $dir.$file;
}

=item curdir

Returns a string representing the current directory. On Mac OS, this is ":".

=cut

sub curdir {
    return ":";
}

=item devnull

Returns a string representing the null device. On Mac OS, this is "Dev:Null".

=cut

sub devnull {
    return "Dev:Null";
}

=item rootdir

Returns a string representing the root directory.  Under MacPerl,
returns the name of the startup volume, since that's the closest in
concept, although other volumes aren't rooted there. The name has a
trailing ":", because that's the correct specification for a volume
name on Mac OS.

If Mac::Files could not be loaded, the empty string is returned.

=cut

sub rootdir {
#
#  There's no real root directory on Mac OS. The name of the startup
#  volume is returned, since that's the closest in concept.
#
    return '' unless $macfiles;
    my $system = Mac::Files::FindFolder(&Mac::Files::kOnSystemDisk,
	&Mac::Files::kSystemFolderType);
    $system =~ s/:.*\Z(?!\n)/:/s;
    return $system;
}

=item tmpdir

Returns the contents of $ENV{TMPDIR}, if that directory exits or the
current working directory otherwise. Under MacPerl, $ENV{TMPDIR} will
contain a path like "MacintoshHD:Temporary Items:", which is a hidden
directory on your startup volume.

=cut

sub tmpdir {
    my $cached = $_[0]->_cached_tmpdir('TMPDIR');
    return $cached if defined $cached;
    $_[0]->_cache_tmpdir($_[0]->_tmpdir( $ENV{TMPDIR} ), 'TMPDIR');
}

=item updir

Returns a string representing the parent directory. On Mac OS, this is "::".

=cut

sub updir {
    return "::";
}

=item file_name_is_absolute

Takes as argument a path and returns true, if it is an absolute path.
If the path has a leading ":", it's a relative path. Otherwise, it's an
absolute path, unless the path doesn't contain any colons, i.e. it's a name
like "a". In this particular case, the path is considered to be relative
(i.e. it is considered to be a filename). Use ":" in the appropriate place
in the path if you want to distinguish unambiguously. As a special case,
the filename '' is always considered to be absolute. Note that with version
1.2 of File::Spec::Mac, this does no longer consult the local filesystem.

E.g.

    File::Spec->file_name_is_absolute("a");         # false (relative)
    File::Spec->file_name_is_absolute(":a:b:");     # false (relative)
    File::Spec->file_name_is_absolute("MacintoshHD:");
                                                    # true (absolute)
    File::Spec->file_name_is_absolute("");          # true (absolute)


=cut

sub file_name_is_absolute {
    my ($self,$file) = @_;
    if ($file =~ /:/) {
	return (! ($file =~ m/^:/s) );
    } elsif ( $file eq '' ) {
        return 1 ;
    } else {
	return 0; # i.e. a file like "a"
    }
}

=item path

Returns the null list for the MacPerl application, since the concept is
usually meaningless under Mac OS. But if you're using the MacPerl tool under
MPW, it gives back $ENV{Commands} suitably split, as is done in
:lib:ExtUtils:MM_Mac.pm.

=cut

sub path {
#
#  The concept is meaningless under the MacPerl application.
#  Under MPW, it has a meaning.
#
    return unless exists $ENV{Commands};
    return split(/,/, $ENV{Commands});
}

=item splitpath

    ($volume,$directories,$file) = File::Spec->splitpath( $path );
    ($volume,$directories,$file) = File::Spec->splitpath( $path,
                                                          $no_file );

Splits a path into volume, directory, and filename portions.

On Mac OS, assumes that the last part of the path is a filename unless
$no_file is true or a trailing separator ":" is present.

The volume portion is always returned with a trailing ":". The directory portion
is always returned with a leading (to denote a relative path) and a trailing ":"
(to denote a directory). The file portion is always returned I<without> a leading ":".
Empty portions are returned as empty string ''.

The results can be passed to C<catpath()> to get back a path equivalent to
(usually identical to) the original path.


=cut

sub splitpath {
    my ($self,$path, $nofile) = @_;
    my ($volume,$directory,$file);

    if ( $nofile ) {
        ( $volume, $directory ) = $path =~ m|^((?:[^:]+:)?)(.*)|s;
    }
    else {
        $path =~
            m|^( (?: [^:]+: )? )
               ( (?: .*: )? )
               ( .* )
             |xs;
        $volume    = $1;
        $directory = $2;
        $file      = $3;
    }

    $volume = '' unless defined($volume);
	$directory = ":$directory" if ( $volume && $directory ); # take care of "HD::dir"
    if ($directory) {
        # Make sure non-empty directories begin and end in ':'
        $directory .= ':' unless (substr($directory,-1) eq ':');
        $directory = ":$directory" unless (substr($directory,0,1) eq ':');
    } else {
	$directory = '';
    }
    $file = '' unless defined($file);

    return ($volume,$directory,$file);
}


=item splitdir

The opposite of C<catdir()>.

    @dirs = File::Spec->splitdir( $directories );

$directories should be only the directory portion of the path on systems
that have the concept of a volume or that have path syntax that differentiates
files from directories. Consider using C<splitpath()> otherwise.

Unlike just splitting the directories on the separator, empty directory names
(C<"">) can be returned. Since C<catdir()> on Mac OS always appends a trailing
colon to distinguish a directory path from a file path, a single trailing colon
will be ignored, i.e. there's no empty directory name after it.

Hence, on Mac OS, both

    File::Spec->splitdir( ":a:b::c:" );    and
    File::Spec->splitdir( ":a:b::c" );

yield:

    ( "a", "b", "::", "c")

while

    File::Spec->splitdir( ":a:b::c::" );

yields:

    ( "a", "b", "::", "c", "::")


=cut

sub splitdir {
	my ($self, $path) = @_;
	my @result = ();
	my ($head, $sep, $tail, $volume, $directories);

	return @result if ( (!defined($path)) || ($path eq '') );
	return (':') if ($path eq ':');

	( $volume, $sep, $directories ) = $path =~ m|^((?:[^:]+:)?)(:*)(.*)|s;

	# deprecated, but handle it correctly
	if ($volume) {
		push (@result, $volume);
		$sep .= ':';
	}

	while ($sep || $directories) {
		if (length($sep) > 1) {
			my $updir_count = length($sep) - 1;
			for (my $i=0; $i<$updir_count; $i++) {
				# push '::' updir_count times;
				# simulate Unix '..' updirs
				push (@result, '::');
			}
		}
		$sep = '';
		if ($directories) {
			( $head, $sep, $tail ) = $directories =~ m|^((?:[^:]+)?)(:*)(.*)|s;
			push (@result, $head);
			$directories = $tail;
		}
	}
	return @result;
}


=item catpath

    $path = File::Spec->catpath($volume,$directory,$file);

Takes volume, directory and file portions and returns an entire path. On Mac OS,
$volume, $directory and $file are concatenated.  A ':' is inserted if need be. You
may pass an empty string for each portion. If all portions are empty, the empty
string is returned. If $volume is empty, the result will be a relative path,
beginning with a ':'. If $volume and $directory are empty, a leading ":" (if any)
is removed form $file and the remainder is returned. If $file is empty, the
resulting path will have a trailing ':'.


=cut

sub catpath {
    my ($self,$volume,$directory,$file) = @_;

    if ( (! $volume) && (! $directory) ) {
	$file =~ s/^:// if $file;
	return $file ;
    }

    # We look for a volume in $volume, then in $directory, but not both

    my ($dir_volume, $dir_dirs) = $self->splitpath($directory, 1);

    $volume = $dir_volume unless length $volume;
    my $path = $volume; # may be ''
    $path .= ':' unless (substr($path, -1) eq ':'); # ensure trailing ':'

    if ($directory) {
	$directory = $dir_dirs if $volume;
	$directory =~ s/^://; # remove leading ':' if any
	$path .= $directory;
	$path .= ':' unless (substr($path, -1) eq ':'); # ensure trailing ':'
    }

    if ($file) {
	$file =~ s/^://; # remove leading ':' if any
	$path .= $file;
    }

    return $path;
}

=item abs2rel

Takes a destination path and an optional base path and returns a relative path
from the base path to the destination path:

    $rel_path = File::Spec->abs2rel( $path ) ;
    $rel_path = File::Spec->abs2rel( $path, $base ) ;

Note that both paths are assumed to have a notation that distinguishes a
directory path (with trailing ':') from a file path (without trailing ':').

If $base is not present or '', then the current working directory is used.
If $base is relative, then it is converted to absolute form using C<rel2abs()>.
This means that it is taken to be relative to the current working directory.

If $path and $base appear to be on two different volumes, we will not
attempt to resolve the two paths, and we will instead simply return
$path.  Note that previous versions of this module ignored the volume
of $base, which resulted in garbage results part of the time.

If $base doesn't have a trailing colon, the last element of $base is
assumed to be a filename.  This filename is ignored.  Otherwise all path
components are assumed to be directories.

If $path is relative, it is converted to absolute form using C<rel2abs()>.
This means that it is taken to be relative to the current working directory.

Based on code written by Shigio Yamaguchi.


=cut

# maybe this should be done in canonpath() ?
sub _resolve_updirs {
	my $path = shift @_;
	my $proceed;

	# resolve any updirs, e.g. "HD:tmp::file" -> "HD:file"
	do {
		$proceed = ($path =~ s/^(.*):[^:]+::(.*?)\z/$1:$2/);
	} while ($proceed);

	return $path;
}


sub abs2rel {
    my($self,$path,$base) = @_;

    # Clean up $path
    if ( ! $self->file_name_is_absolute( $path ) ) {
        $path = $self->rel2abs( $path ) ;
    }

    # Figure out the effective $base and clean it up.
    if ( !defined( $base ) || $base eq '' ) {
	$base = $self->_cwd();
    }
    elsif ( ! $self->file_name_is_absolute( $base ) ) {
        $base = $self->rel2abs( $base ) ;
	$base = _resolve_updirs( $base ); # resolve updirs in $base
    }
    else {
	$base = _resolve_updirs( $base );
    }

    # Split up paths - ignore $base's file
    my ( $path_vol, $path_dirs, $path_file ) =  $self->splitpath( $path );
    my ( $base_vol, $base_dirs )             =  $self->splitpath( $base );

    return $path unless lc( $path_vol ) eq lc( $base_vol );

    # Now, remove all leading components that are the same
    my @pathchunks = $self->splitdir( $path_dirs );
    my @basechunks = $self->splitdir( $base_dirs );
	
    while ( @pathchunks &&
	    @basechunks &&
	    lc( $pathchunks[0] ) eq lc( $basechunks[0] ) ) {
        shift @pathchunks ;
        shift @basechunks ;
    }

    # @pathchunks now has the directories to descend in to.
    # ensure relative path, even if @pathchunks is empty
    $path_dirs = $self->catdir( ':', @pathchunks );

    # @basechunks now contains the number of directories to climb out of.
    $base_dirs = (':' x @basechunks) . ':' ;

    return $self->catpath( '', $self->catdir( $base_dirs, $path_dirs ), $path_file ) ;
}

=item rel2abs

Converts a relative path to an absolute path:

    $abs_path = File::Spec->rel2abs( $path ) ;
    $abs_path = File::Spec->rel2abs( $path, $base ) ;

Note that both paths are assumed to have a notation that distinguishes a
directory path (with trailing ':') from a file path (without trailing ':').

If $base is not present or '', then $base is set to the current working
directory. If $base is relative, then it is converted to absolute form
using C<rel2abs()>. This means that it is taken to be relative to the
current working directory.

If $base doesn't have a trailing colon, the last element of $base is
assumed to be a filename.  This filename is ignored.  Otherwise all path
components are assumed to be directories.

If $path is already absolute, it is returned and $base is ignored.

Based on code written by Shigio Yamaguchi.

=cut

sub rel2abs {
    my ($self,$path,$base) = @_;

    if ( ! $self->file_name_is_absolute($path) ) {
        # Figure out the effective $base and clean it up.
        if ( !defined( $base ) || $base eq '' ) {
	    $base = $self->_cwd();
        }
        elsif ( ! $self->file_name_is_absolute($base) ) {
            $base = $self->rel2abs($base) ;
        }

	# Split up paths

	# ignore $path's volume
        my ( $path_dirs, $path_file ) = ($self->splitpath($path))[1,2] ;

        # ignore $base's file part
	my ( $base_vol, $base_dirs ) = $self->splitpath($base) ;

	# Glom them together
	$path_dirs = ':' if ($path_dirs eq '');
	$base_dirs =~ s/:$//; # remove trailing ':', if any
	$base_dirs = $base_dirs . $path_dirs;

        $path = $self->catpath( $base_vol, $base_dirs, $path_file );
    }
    return $path;
}


=back

=head1 AUTHORS

See the authors list in I<File::Spec>. Mac OS support by Paul Schinder
<schinder@pobox.com> and Thomas Wegner <wegner_thomas@yahoo.com>.

=head1 COPYRIGHT

Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.

This program is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=head1 SEE ALSO

See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
implementation of these methods, not the semantics.

=cut

1;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              package File::Spec::OS2;

use strict;
use vars qw(@ISA $VERSION);
require File::Spec::Unix;

$VERSION = '3.63_01';
$VERSION =~ tr/_//d;

@ISA = qw(File::Spec::Unix);

sub devnull {
    return "/dev/nul";
}

sub case_tolerant {
    return 1;
}

sub file_name_is_absolute {
    my ($self,$file) = @_;
    return scalar($file =~ m{^([a-z]:)?[\\/]}is);
}

sub path {
    my $path = $ENV{PATH};
    $path =~ s:\\:/:g;
    my @path = split(';',$path);
    foreach (@path) { $_ = '.' if $_ eq '' }
    return @path;
}

sub _cwd {
    # In OS/2 the "require Cwd" is unnecessary bloat.
    return Cwd::sys_cwd();
}

sub tmpdir {
    my $cached = $_[0]->_cached_tmpdir(qw 'TMPDIR TEMP TMP');
    return $cached if defined $cached;
    my @d = @ENV{qw(TMPDIR TEMP TMP)};	# function call could autovivivy
    $_[0]->_cache_tmpdir(
	$_[0]->_tmpdir( @d, '/tmp', '/' ), qw 'TMPDIR TEMP TMP'
    );
}

sub catdir {
    my $self = shift;
    my @args = @_;
    foreach (@args) {
	tr[\\][/];
        # append a backslash to each argument unless it has one there
        $_ .= "/" unless m{/$};
    }
    return $self->canonpath(join('', @args));
}

sub canonpath {
    my ($self,$path) = @_;
    return unless defined $path;

    $path =~ s/^([a-z]:)/\l$1/s;
    $path =~ s|\\|/|g;
    $path =~ s|([^/])/+|$1/|g;                  # xx////xx  -> xx/xx
    $path =~ s|(/\.)+/|/|g;                     # xx/././xx -> xx/xx
    $path =~ s|^(\./)+(?=[^/])||s;		# ./xx      -> xx
    $path =~ s|/\Z(?!\n)||
             unless $path =~ m#^([a-z]:)?/\Z(?!\n)#si;# xx/       -> xx
    $path =~ s{^/\.\.$}{/};                     # /..    -> /
    1 while $path =~ s{^/\.\.}{};               # /../xx -> /xx
    return $path;
}


sub splitpath {
    my ($self,$path, $nofile) = @_;
    my ($volume,$directory,$file) = ('','','');
    if ( $nofile ) {
        $path =~ 
            m{^( (?:[a-zA-Z]:|(?:\\\\|//)[^\\/]+[\\/][^\\/]+)? ) 
                 (.*)
             }xs;
        $volume    = $1;
        $directory = $2;
    }
    else {
        $path =~ 
            m{^ ( (?: [a-zA-Z]: |
                      (?:\\\\|//)[^\\/]+[\\/][^\\/]+
                  )?
                )
                ( (?:.*[\\\\/](?:\.\.?\Z(?!\n))?)? )
                (.*)
             }xs;
        $volume    = $1;
        $directory = $2;
        $file      = $3;
    }

    return ($volume,$directory,$file);
}


sub splitdir {
    my ($self,$directories) = @_ ;
    split m|[\\/]|, $directories, -1;
}


sub catpath {
    my ($self,$volume,$directory,$file) = @_;

    # If it's UNC, make sure the glue separator is there, reusing
    # whatever separator is first in the $volume
    $volume .= $1
        if ( $volume =~ m@^([\\/])[\\/][^\\/]+[\\/][^\\/]+\Z(?!\n)@s &&
             $directory =~ m@^[^\\/]@s
           ) ;

    $volume .= $directory ;

    # If the volume is not just A:, make sure the glue separator is 
    # there, reusing whatever separator is first in the $volume if possible.
    if ( $volume !~ m@^[a-zA-Z]:\Z(?!\n)@s &&
         $volume =~ m@[^\\/]\Z(?!\n)@      &&
         $file   =~ m@[^\\/]@
       ) {
        $volume =~ m@([\\/])@ ;
        my $sep = $1 ? $1 : '/' ;
        $volume .= $sep ;
    }

    $volume .= $file ;

    return $volume ;
}


sub abs2rel {
    my($self,$path,$base) = @_;

    # Clean up $path
    if ( ! $self->file_name_is_absolute( $path ) ) {
        $path = $self->rel2abs( $path ) ;
    } else {
        $path = $self->canonpath( $path ) ;
    }

    # Figure out the effective $base and clean it up.
    if ( !defined( $base ) || $base eq '' ) {
	$base = $self->_cwd();
    } elsif ( ! $self->file_name_is_absolute( $base ) ) {
        $base = $self->rel2abs( $base ) ;
    } else {
        $base = $self->canonpath( $base ) ;
    }

    # Split up paths
    my ( $path_volume, $path_directories, $path_file ) = $self->splitpath( $path, 1 ) ;
    my ( $base_volume, $base_directories ) = $self->splitpath( $base, 1 ) ;
    return $path unless $path_volume eq $base_volume;

    # Now, remove all leading components that are the same
    my @pathchunks = $self->splitdir( $path_directories );
    my @basechunks = $self->splitdir( $base_directories );

    while ( @pathchunks && 
            @basechunks && 
            lc( $pathchunks[0] ) eq lc( $basechunks[0] ) 
          ) {
        shift @pathchunks ;
        shift @basechunks ;
    }

    # No need to catdir, we know these are well formed.
    $path_directories = CORE::join( '/', @pathchunks );
    $base_directories = CORE::join( '/', @basechunks );

    # $base_directories now contains the directories the resulting relative
    # path must ascend out of before it can descend to $path_directory.  So, 
    # replace all names with $parentDir

    #FA Need to replace between backslashes...
    $base_directories =~ s|[^\\/]+|..|g ;

    # Glue the two together, using a separator if necessary, and preventing an
    # empty result.

    #FA Must check that new directories are not empty.
    if ( $path_directories ne '' && $base_directories ne '' ) {
        $path_directories = "$base_directories/$path_directories" ;
    } else {
        $path_directories = "$base_directories$path_directories" ;
    }

    return $self->canonpath( 
        $self->catpath( "", $path_directories, $path_file ) 
    ) ;
}


sub rel2abs {
    my ($self,$path,$base ) = @_;

    if ( ! $self->file_name_is_absolute( $path ) ) {

        if ( !defined( $base ) || $base eq '' ) {
	    $base = $self->_cwd();
        }
        elsif ( ! $self->file_name_is_absolute( $base ) ) {
            $base = $self->rel2abs( $base ) ;
        }
        else {
            $base = $self->canonpath( $base ) ;
        }

        my ( $path_directories, $path_file ) =
            ($self->splitpath( $path, 1 ))[1,2] ;

        my ( $base_volume, $base_directories ) =
            $self->splitpath( $base, 1 ) ;

        $path = $self->catpath( 
            $base_volume, 
            $self->catdir( $base_directories, $path_directories ), 
            $path_file
        ) ;
    }

    return $self->canonpath( $path ) ;
}

1;
__END__

=head1 NAME

File::Spec::OS2 - methods for OS/2 file specs

=head1 SYNOPSIS

 require File::Spec::OS2; # Done internally by File::Spec if needed

=head1 DESCRIPTION

See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
implementation of these methods, not the semantics.

Amongst the changes made for OS/2 are...

=over 4

=item tmpdir

Modifies the list of places temp directory information is looked for.

    $ENV{TMPDIR}
    $ENV{TEMP}
    $ENV{TMP}
    /tmp
    /

=item splitpath

Volumes can be drive letters or UNC sharenames (\\server\share).

=back

=head1 COPYRIGHT

Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.

This program is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        package File::Spec::Unix;

use strict;
use vars qw($VERSION);

$VERSION = '3.63_01';
my $xs_version = $VERSION;
$VERSION =~ tr/_//d;

#dont try to load XSLoader and DynaLoader only to ultimately fail on miniperl
if(!defined &canonpath && defined &DynaLoader::boot_DynaLoader) {
  eval {#eval is questionable since we are handling potential errors like
        #"Cwd object version 3.48 does not match bootstrap parameter 3.50
        #at lib/DynaLoader.pm line 216." by having this eval
    if ( $] >= 5.006 ) {
	require XSLoader;
	XSLoader::load("Cwd", $xs_version);
    } else {
	require Cwd;
    }
  };
}

sub _pp_canonpath {
    my ($self,$path) = @_;
    return unless defined $path;
    
    # Handle POSIX-style node names beginning with double slash (qnx, nto)
    # (POSIX says: "a pathname that begins with two successive slashes
    # may be interpreted in an implementation-defined manner, although
    # more than two leading slashes shall be treated as a single slash.")
    my $node = '';
    my $double_slashes_special = $^O eq 'qnx' || $^O eq 'nto';

    if ( $double_slashes_special
         && ( $path =~ s{^(//[^/]+)/?\z}{}s || $path =~ s{^(//[^/]+)/}{/}s ) ) {
      $node = $1;
    }
    # This used to be
    # $path =~ s|/+|/|g unless ($^O eq 'cygwin');
    # but that made tests 29, 30, 35, 46, and 213 (as of #13272) to fail
    # (Mainly because trailing "" directories didn't get stripped).
    # Why would cygwin avoid collapsing multiple slashes into one? --jhi
    $path =~ s|/{2,}|/|g;                            # xx////xx  -> xx/xx
    $path =~ s{(?:/\.)+(?:/|\z)}{/}g;                # xx/././xx -> xx/xx
    $path =~ s|^(?:\./)+||s unless $path eq "./";    # ./xx      -> xx
    $path =~ s|^/(?:\.\./)+|/|;                      # /../../xx -> xx
    $path =~ s|^/\.\.$|/|;                         # /..       -> /
    $path =~ s|/\z|| unless $path eq "/";          # xx/       -> xx
    return "$node$path";
}
*canonpath = \&_pp_canonpath unless defined &canonpath;

sub _pp_catdir {
    my $self = shift;

    $self->canonpath(join('/', @_, '')); # '' because need a trailing '/'
}
*catdir = \&_pp_catdir unless defined &catdir;

sub _pp_catfile {
    my $self = shift;
    my $file = $self->canonpath(pop @_);
    return $file unless @_;
    my $dir = $self->catdir(@_);
    $dir .= "/" unless substr($dir,-1) eq "/";
    return $dir.$file;
}
*catfile = \&_pp_catfile unless defined &catfile;

sub curdir { '.' }
use constant _fn_curdir => ".";

sub devnull { '/dev/null' }
use constant _fn_devnull => "/dev/null";

sub rootdir { '/' }
use constant _fn_rootdir => "/";

my ($tmpdir, %tmpenv);
# Cache and return the calculated tmpdir, recording which env vars
# determined it.
sub _cache_tmpdir {
    @tmpenv{@_[2..$#_]} = @ENV{@_[2..$#_]};
    return $tmpdir = $_[1];
}
# Retrieve the cached tmpdir, checking first whether relevant env vars have
# changed and invalidated the cache.
sub _cached_tmpdir {
    shift;
    local $^W;
    return if grep $ENV{$_} ne $tmpenv{$_}, @_;
    return $tmpdir;
}
sub _tmpdir {
    my $self = shift;
    my @dirlist = @_;
    my $taint = do { no strict 'refs'; ${"\cTAINT"} };
    if ($taint) { # Check for taint mode on perl >= 5.8.0
	require Scalar::Util;
	@dirlist = grep { ! Scalar::Util::tainted($_) } @dirlist;
    }
    elsif ($] < 5.007) { # No ${^TAINT} before 5.8
	@dirlist = grep { eval { eval('1'.substr $_,0,0) } } @dirlist;
    }
    
    foreach (@dirlist) {
	next unless defined && -d && -w _;
	$tmpdir = $_;
	last;
    }
    $tmpdir = $self->curdir unless defined $tmpdir;
    $tmpdir = defined $tmpdir && $self->canonpath($tmpdir);
    if ( !$self->file_name_is_absolute($tmpdir) ) {
        # See [perl #120593] for the full details
        # If possible, return a full path, rather than '.' or 'lib', but
        # jump through some hoops to avoid returning a tainted value.
        ($tmpdir) = grep {
            $taint     ? ! Scalar::Util::tainted($_) :
            $] < 5.007 ? eval { eval('1'.substr $_,0,0) } : 1
        } $self->rel2abs($tmpdir), $tmpdir;
    }
    return $tmpdir;
}

sub tmpdir {
    my $cached = $_[0]->_cached_tmpdir('TMPDIR');
    return $cached if defined $cached;
    $_[0]->_cache_tmpdir($_[0]->_tmpdir( $ENV{TMPDIR}, "/tmp" ), 'TMPDIR');
}

sub updir { '..' }
use constant _fn_updir => "..";

sub no_upwards {
    my $self = shift;
    return grep(!/^\.{1,2}\z/s, @_);
}

sub case_tolerant { 0 }
use constant _fn_case_tolerant => 0;

sub file_name_is_absolute {
    my ($self,$file) = @_;
    return scalar($file =~ m:^/:s);
}

sub path {
    return () unless exists $ENV{PATH};
    my @path = split(':', $ENV{PATH});
    foreach (@path) { $_ = '.' if $_ eq '' }
    return @path;
}

sub join {
    my $self = shift;
    return $self->catfile(@_);
}

sub splitpath {
    my ($self,$path, $nofile) = @_;

    my ($volume,$directory,$file) = ('','','');

    if ( $nofile ) {
        $directory = $path;
    }
    else {
        $path =~ m|^ ( (?: .* / (?: \.\.?\z )? )? ) ([^/]*) |xs;
        $directory = $1;
        $file      = $2;
    }

    return ($volume,$directory,$file);
}

sub splitdir {
    return split m|/|, $_[1], -1;  # Preserve trailing fields
}

sub catpath {
    my ($self,$volume,$directory,$file) = @_;

    if ( $directory ne ''                && 
         $file ne ''                     && 
         substr( $directory, -1 ) ne '/' && 
         substr( $file, 0, 1 ) ne '/' 
    ) {
        $directory .= "/$file" ;
    }
    else {
        $directory .= $file ;
    }

    return $directory ;
}

sub abs2rel {
    my($self,$path,$base) = @_;
    $base = $self->_cwd() unless defined $base and length $base;

    ($path, $base) = map $self->canonpath($_), $path, $base;

    my $path_directories;
    my $base_directories;

    if (grep $self->file_name_is_absolute($_), $path, $base) {
	($path, $base) = map $self->rel2abs($_), $path, $base;

	my ($path_volume) = $self->splitpath($path, 1);
	my ($base_volume) = $self->splitpath($base, 1);

	# Can't relativize across volumes
	return $path unless $path_volume eq $base_volume;

	$path_directories = ($self->splitpath($path, 1))[1];
	$base_directories = ($self->splitpath($base, 1))[1];

	# For UNC paths, the user might give a volume like //foo/bar that
	# strictly speaking has no directory portion.  Treat it as if it
	# had the root directory for that volume.
	if (!length($base_directories) and $self->file_name_is_absolute($base)) {
	    $base_directories = $self->rootdir;
	}
    }
    else {
	my $wd= ($self->splitpath($self->_cwd(), 1))[1];
	$path_directories = $self->catdir($wd, $path);
	$base_directories = $self->catdir($wd, $base);
    }

    # Now, remove all leading components that are the same
    my @pathchunks = $self->splitdir( $path_directories );
    my @basechunks = $self->splitdir( $base_directories );

    if ($base_directories eq $self->rootdir) {
      return $self->curdir if $path_directories eq $self->rootdir;
      shift @pathchunks;
      return $self->canonpath( $self->catpath('', $self->catdir( @pathchunks ), '') );
    }

    my @common;
    while (@pathchunks && @basechunks && $self->_same($pathchunks[0], $basechunks[0])) {
        push @common, shift @pathchunks ;
        shift @basechunks ;
    }
    return $self->curdir unless @pathchunks || @basechunks;

    # @basechunks now contains the directories the resulting relative path 
    # must ascend out of before it can descend to $path_directory.  If there
    # are updir components, we must descend into the corresponding directories
    # (this only works if they are no symlinks).
    my @reverse_base;
    while( defined(my $dir= shift @basechunks) ) {
	if( $dir ne $self->updir ) {
	    unshift @reverse_base, $self->updir;
	    push @common, $dir;
	}
	elsif( @common ) {
	    if( @reverse_base && $reverse_base[0] eq $self->updir ) {
		shift @reverse_base;
		pop @common;
	    }
	    else {
		unshift @reverse_base, pop @common;
	    }
	}
    }
    my $result_dirs = $self->catdir( @reverse_base, @pathchunks );
    return $self->canonpath( $self->catpath('', $result_dirs, '') );
}

sub _same {
  $_[1] eq $_[2];
}

sub rel2abs {
    my ($self,$path,$base ) = @_;

    # Clean up $path
    if ( ! $self->file_name_is_absolute( $path ) ) {
        # Figure out the effective $base and clean it up.
        if ( !defined( $base ) || $base eq '' ) {
	    $base = $self->_cwd();
        }
        elsif ( ! $self->file_name_is_absolute( $base ) ) {
            $base = $self->rel2abs( $base ) ;
        }
        else {
            $base = $self->canonpath( $base ) ;
        }

        # Glom them together
        $path = $self->catdir( $base, $path ) ;
    }

    return $self->canonpath( $path ) ;
}

# Internal routine to File::Spec, no point in making this public since
# it is the standard Cwd interface.  Most of the platform-specific
# File::Spec subclasses use this.
sub _cwd {
    require Cwd;
    Cwd::getcwd();
}

# Internal method to reduce xx\..\yy -> yy
sub _collapse {
    my($fs, $path) = @_;

    my $updir  = $fs->updir;
    my $curdir = $fs->curdir;

    my($vol, $dirs, $file) = $fs->splitpath($path);
    my @dirs = $fs->splitdir($dirs);
    pop @dirs if @dirs && $dirs[-1] eq '';

    my @collapsed;
    foreach my $dir (@dirs) {
        if( $dir eq $updir              and   # if we have an updir
            @collapsed                  and   # and something to collapse
            length $collapsed[-1]       and   # and its not the rootdir
            $collapsed[-1] ne $updir    and   # nor another updir
            $collapsed[-1] ne $curdir         # nor the curdir
          ) 
        {                                     # then
            pop @collapsed;                   # collapse
        }
        else {                                # else
            push @collapsed, $dir;            # just hang onto it
        }
    }

    return $fs->catpath($vol,
                        $fs->catdir(@collapsed),
                        $file
                       );
}

1;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  package I18N::Langinfo;

use 5.006;
use strict;
use warnings;
use Carp;

require Exporter;
require XSLoader;

our @ISA = qw(Exporter);

our @EXPORT = qw(langinfo);

our @EXPORT_OK = qw(
	ABDAY_1
	ABDAY_2
	ABDAY_3
	ABDAY_4
	ABDAY_5
	ABDAY_6
	ABDAY_7
	ABMON_1
	ABMON_10
	ABMON_11
	ABMON_12
	ABMON_2
	ABMON_3
	ABMON_4
	ABMON_5
	ABMON_6
	ABMON_7
	ABMON_8
	ABMON_9
	ALT_DIGITS
	AM_STR
	CODESET
	CRNCYSTR
	DAY_1
	DAY_2
	DAY_3
	DAY_4
	DAY_5
	DAY_6
	DAY_7
	D_FMT
	D_T_FMT
	ERA
	ERA_D_FMT
	ERA_D_T_FMT
	ERA_T_FMT
	MON_1
	MON_10
	MON_11
	MON_12
	MON_2
	MON_3
	MON_4
	MON_5
	MON_6
	MON_7
	MON_8
	MON_9
	NOEXPR
	NOSTR
	PM_STR
	RADIXCHAR
	THOUSEP
	T_FMT
	T_FMT_AMPM
	YESEXPR
	YESSTR
);

our $VERSION = '0.13';

XSLoader::load();

1;
__END__

=head1 NAME

I18N::Langinfo - query locale information

=head1 SYNOPSIS

  use I18N::Langinfo;

=head1 DESCRIPTION

The langinfo() function queries various locale information that can be
used to localize output and user interfaces.  The langinfo() requires
one numeric argument that identifies the locale constant to query:
if no argument is supplied, C<$_> is used.  The numeric constants
appropriate to be used as arguments are exportable from I18N::Langinfo.

The following example will import the langinfo() function itself and
three constants to be used as arguments to langinfo(): a constant for
the abbreviated first day of the week (the numbering starts from
Sunday = 1) and two more constants for the affirmative and negative
answers for a yes/no question in the current locale.

    use I18N::Langinfo qw(langinfo ABDAY_1 YESSTR NOSTR);

    my ($abday_1, $yesstr, $nostr) =
        map { langinfo($_) } (ABDAY_1, YESSTR, NOSTR);

    print "$abday_1? [$yesstr/$nostr] ";

In other words, in the "C" (or English) locale the above will probably
print something like:

    Sun? [yes/no] 

but under a French locale

    dim? [oui/non] 

The usually available constants are

    ABDAY_1 ABDAY_2 ABDAY_3 ABDAY_4 ABDAY_5 ABDAY_6 ABDAY_7
    ABMON_1 ABMON_2 ABMON_3 ABMON_4 ABMON_5 ABMON_6
    ABMON_7 ABMON_8 ABMON_9 ABMON_10 ABMON_11 ABMON_12
    DAY_1 DAY_2 DAY_3 DAY_4 DAY_5 DAY_6 DAY_7
    MON_1 MON_2 MON_3 MON_4 MON_5 MON_6
    MON_7 MON_8 MON_9 MON_10 MON_11 MON_12

for abbreviated and full length days of the week and months of the year,

    D_T_FMT D_FMT T_FMT

for the date-time, date, and time formats used by the strftime() function
(see L<POSIX>)

    AM_STR PM_STR T_FMT_AMPM

for the locales for which it makes sense to have ante meridiem and post
meridiem time formats,

    CODESET CRNCYSTR RADIXCHAR

for the character code set being used (such as "ISO8859-1", "cp850",
"koi8-r", "sjis", "utf8", etc.), for the currency string, for the
radix character used between the integer and the fractional part
of decimal numbers (yes, this is redundant with POSIX::localeconv())

    YESSTR YESEXPR NOSTR NOEXPR

for the affirmative and negative responses and expressions, and

    ERA ERA_D_FMT ERA_D_T_FMT ERA_T_FMT

for the Japanese Emperor eras (naturally only defined under Japanese locales).

See your L<langinfo(3)> for more information about the available
constants.  (Often this means having to look directly at the
F<langinfo.h> C header file.)

Note that unfortunately none of the above constants are guaranteed
to be available on a particular platform.  To be on the safe side
you can wrap the import in an eval like this:

    eval {
        require I18N::Langinfo;
        I18N::Langinfo->import(qw(langinfo CODESET));
        $codeset = langinfo(CODESET()); # note the ()
    };
    if ($@) { ... failed ... }

=head2 EXPORT

By default only the C<langinfo()> function is exported.

=head1 SEE ALSO

L<perllocale>, L<POSIX/localeconv>, L<POSIX/setlocale>, L<nl_langinfo(3)>.

The langinfo() is just a wrapper for the C nl_langinfo() interface.

=head1 AUTHOR

Jarkko Hietaniemi, E<lt>jhi@hut.fiE<gt>

=head1 COPYRIGHT AND LICENSE

Copyright 2001 by Jarkko Hietaniemi

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself. 

=cut
                                                    package File::Spec::VMS;

use strict;
use vars qw(@ISA $VERSION);
require File::Spec::Unix;

$VERSION = '3.63_01';
$VERSION =~ tr/_//d;

@ISA = qw(File::Spec::Unix);

use File::Basename;
use VMS::Filespec;

=head1 NAME

File::Spec::VMS - methods for VMS file specs

=head1 SYNOPSIS

 require File::Spec::VMS; # Done internally by File::Spec if needed

=head1 DESCRIPTION

See File::Spec::Unix for a documentation of the methods provided
there. This package overrides the implementation of these methods, not
the semantics.

The default behavior is to allow either VMS or Unix syntax on input and to 
return VMS syntax on output unless Unix syntax has been explicitly requested
via the C<DECC$FILENAME_UNIX_REPORT> CRTL feature.

=over 4

=cut

# Need to look up the feature settings.  The preferred way is to use the
# VMS::Feature module, but that may not be available to dual life modules.

my $use_feature;
BEGIN {
    if (eval { local $SIG{__DIE__};
               local @INC = @INC;
               pop @INC if $INC[-1] eq '.';
               require VMS::Feature; }) {
        $use_feature = 1;
    }
}

# Need to look up the UNIX report mode.  This may become a dynamic mode
# in the future.
sub _unix_rpt {
    my $unix_rpt;
    if ($use_feature) {
        $unix_rpt = VMS::Feature::current("filename_unix_report");
    } else {
        my $env_unix_rpt = $ENV{'DECC$FILENAME_UNIX_REPORT'} || '';
        $unix_rpt = $env_unix_rpt =~ /^[ET1]/i; 
    }
    return $unix_rpt;
}

=item canonpath (override)

Removes redundant portions of file specifications and returns results
in native syntax unless Unix filename reporting has been enabled.

=cut


sub canonpath {
    my($self,$path) = @_;

    return undef unless defined $path;

    my $unix_rpt = $self->_unix_rpt;

    if ($path =~ m|/|) {
      my $pathify = $path =~ m|/\Z(?!\n)|;
      $path = $self->SUPER::canonpath($path);

      return $path if $unix_rpt;
      $path = $pathify ? vmspath($path) : vmsify($path);
    }

    $path =~ s/(?<!\^)</[/;			# < and >       ==> [ and ]
    $path =~ s/(?<!\^)>/]/;
    $path =~ s/(?<!\^)\]\[\./\.\]\[/g;		# ][.		==> .][
    $path =~ s/(?<!\^)\[000000\.\]\[/\[/g;	# [000000.][	==> [
    $path =~ s/(?<!\^)\[000000\./\[/g;		# [000000.	==> [
    $path =~ s/(?<!\^)\.\]\[000000\]/\]/g;	# .][000000]	==> ]
    $path =~ s/(?<!\^)\.\]\[/\./g;		# foo.][bar     ==> foo.bar
    1 while ($path =~ s/(?<!\^)([\[\.])(-+)\.(-+)([\.\]])/$1$2$3$4/);
						# That loop does the following
						# with any amount of dashes:
						# .-.-.		==> .--.
						# [-.-.		==> [--.
						# .-.-]		==> .--]
						# [-.-]		==> [--]
    1 while ($path =~ s/(?<!\^)([\[\.])[^\]\.]+\.-(-+)([\]\.])/$1$2$3/);
						# That loop does the following
						# with any amount (minimum 2)
						# of dashes:
						# .foo.--.	==> .-.
						# .foo.--]	==> .-]
						# [foo.--.	==> [-.
						# [foo.--]	==> [-]
						#
						# And then, the remaining cases
    $path =~ s/(?<!\^)\[\.-/[-/;		# [.-		==> [-
    $path =~ s/(?<!\^)\.[^\]\.]+\.-\./\./g;	# .foo.-.	==> .
    $path =~ s/(?<!\^)\[[^\]\.]+\.-\./\[/g;	# [foo.-.	==> [
    $path =~ s/(?<!\^)\.[^\]\.]+\.-\]/\]/g;	# .foo.-]	==> ]
						# [foo.-]       ==> [000000]
    $path =~ s/(?<!\^)\[[^\]\.]+\.-\]/\[000000\]/g;
						# []		==>
    $path =~ s/(?<!\^)\[\]// unless $path eq '[]';
    return $unix_rpt ? unixify($path) : $path;
}

=item catdir (override)

Concatenates a list of file specifications, and returns the result as a
native directory specification unless the Unix filename reporting feature
has been enabled.  No check is made for "impossible" cases (e.g. elements
other than the first being absolute filespecs).

=cut

sub catdir {
    my $self = shift;
    my $dir = pop;

    my $unix_rpt = $self->_unix_rpt;

    my @dirs = grep {defined() && length()} @_;

    my $rslt;
    if (@dirs) {
	my $path = (@dirs == 1 ? $dirs[0] : $self->catdir(@dirs));
	my ($spath,$sdir) = ($path,$dir);
	$spath =~ s/\.dir\Z(?!\n)//i; $sdir =~ s/\.dir\Z(?!\n)//i; 

	if ($unix_rpt) {
	    $spath = unixify($spath) unless $spath =~ m#/#;
	    $sdir= unixify($sdir) unless $sdir =~ m#/#;
            return $self->SUPER::catdir($spath, $sdir)
	}

	$rslt = vmspath( unixify($spath) . '/' . unixify($sdir));

	# Special case for VMS absolute directory specs: these will have
	# had device prepended during trip through Unix syntax in
	# eliminate_macros(), since Unix syntax has no way to express
	# "absolute from the top of this device's directory tree".
	if ($spath =~ /^[\[<][^.\-]/s) { $rslt =~ s/^[^\[<]+//s; }

    } else {
	# Single directory. Return an empty string on null input; otherwise
	# just return a canonical path.

	if    (not defined $dir or not length $dir) {
	    $rslt = '';
	} else {
	    $rslt = $unix_rpt ? $dir : vmspath($dir);
	}
    }
    return $self->canonpath($rslt);
}

=item catfile (override)

Concatenates a list of directory specifications with a filename specification
to build a path.

=cut

sub catfile {
    my $self = shift;
    my $tfile = pop();
    my $file = $self->canonpath($tfile);
    my @files = grep {defined() && length()} @_;

    my $unix_rpt = $self->_unix_rpt;

    my $rslt;
    if (@files) {
	my $path = (@files == 1 ? $files[0] : $self->catdir(@files));
	my $spath = $path;

        # Something building a VMS path in pieces may try to pass a
        # directory name in filename format, so normalize it.
	$spath =~ s/\.dir\Z(?!\n)//i;

        # If the spath ends with a directory delimiter and the file is bare,
        # then just concatenate them.
	if ($spath =~ /^(?<!\^)[^\)\]\/:>]+\)\Z(?!\n)/s && basename($file) eq $file) {
	    $rslt = "$spath$file";
	} else {
           $rslt = unixify($spath);
           $rslt .= (defined($rslt) && length($rslt) ? '/' : '') . unixify($file);
           $rslt = vmsify($rslt) unless $unix_rpt;
	}
    }
    else {
        # Only passed a single file?
        my $xfile = (defined($file) && length($file)) ? $file : '';

        $rslt = $unix_rpt ? $xfile : vmsify($xfile);
    }
    return $self->canonpath($rslt) unless $unix_rpt;

    # In Unix report mode, do not strip off redundant path information.
    return $rslt;
}


=item curdir (override)

Returns a string representation of the current directory: '[]' or '.'

=cut

sub curdir {
    my $self = shift @_;
    return '.' if ($self->_unix_rpt);
    return '[]';
}

=item devnull (override)

Returns a string representation of the null device: '_NLA0:' or '/dev/null'

=cut

sub devnull {
    my $self = shift @_;
    return '/dev/null' if ($self->_unix_rpt);
    return "_NLA0:";
}

=item rootdir (override)

Returns a string representation of the root directory: 'SYS$DISK:[000000]'
or '/'

=cut

sub rootdir {
    my $self = shift @_;
    if ($self->_unix_rpt) {
       # Root may exist, try it first.
       my $try = '/';
       my ($dev1, $ino1) = stat('/');
       my ($dev2, $ino2) = stat('.');

       # Perl falls back to '.' if it can not determine '/'
       if (($dev1 != $dev2) || ($ino1 != $ino2)) {
           return $try;
       }
       # Fall back to UNIX format sys$disk.
       return '/sys$disk/';
    }
    return 'SYS$DISK:[000000]';
}

=item tmpdir (override)

Returns a string representation of the first writable directory
from the following list or '' if none are writable:

    /tmp if C<DECC$FILENAME_UNIX_REPORT> is enabled.
    sys$scratch:
    $ENV{TMPDIR}

If running under taint mode, and if $ENV{TMPDIR}
is tainted, it is not used.

=cut

sub tmpdir {
    my $self = shift @_;
    my $tmpdir = $self->_cached_tmpdir('TMPDIR');
    return $tmpdir if defined $tmpdir;
    if ($self->_unix_rpt) {
        $tmpdir = $self->_tmpdir('/tmp', '/sys$scratch', $ENV{TMPDIR});
    }
    else {
        $tmpdir = $self->_tmpdir( 'sys$scratch:', $ENV{TMPDIR} );
    }
    $self->_cache_tmpdir($tmpdir, 'TMPDIR');
}

=item updir (override)

Returns a string representation of the parent directory: '[-]' or '..'

=cut

sub updir {
    my $self = shift @_;
    return '..' if ($self->_unix_rpt);
    return '[-]';
}

=item case_tolerant (override)

VMS file specification syntax is case-tolerant.

=cut

sub case_tolerant {
    return 1;
}

=item path (override)

Translate logical name DCL$PATH as a searchlist, rather than trying
to C<split> string value of C<$ENV{'PATH'}>.

=cut

sub path {
    my (@dirs,$dir,$i);
    while ($dir = $ENV{'DCL$PATH;' . $i++}) { push(@dirs,$dir); }
    return @dirs;
}

=item file_name_is_absolute (override)

Checks for VMS directory spec as well as Unix separators.

=cut

sub file_name_is_absolute {
    my ($self,$file) = @_;
    # If it's a logical name, expand it.
    $file = $ENV{$file} while $file =~ /^[\w\$\-]+\Z(?!\n)/s && $ENV{$file};
    return scalar($file =~ m!^/!s             ||
		  $file =~ m![<\[][^.\-\]>]!  ||
		  $file =~ /^[A-Za-z0-9_\$\-\~]+(?<!\^):/);
}

=item splitpath (override)

   ($volume,$directories,$file) = File::Spec->splitpath( $path );
   ($volume,$directories,$file) = File::Spec->splitpath( $path,
                                                         $no_file );

Passing a true value for C<$no_file> indicates that the path being
split only contains directory components, even on systems where you
can usually (when not supporting a foreign syntax) tell the difference
between directories and files at a glance.

=cut

sub splitpath {
    my($self,$path, $nofile) = @_;
    my($dev,$dir,$file)      = ('','','');
    my $vmsify_path = vmsify($path);

    if ( $nofile ) {
        #vmsify('d1/d2/d3') returns '[.d1.d2]d3'
        #vmsify('/d1/d2/d3') returns 'd1:[d2]d3'
        if( $vmsify_path =~ /(.*)\](.+)/ ){
            $vmsify_path = $1.'.'.$2.']';
        }
        $vmsify_path =~ /(.+:)?(.*)/s;
        $dir = defined $2 ? $2 : ''; # dir can be '0'
        return ($1 || '',$dir,$file);
    }
    else {
        $vmsify_path =~ /(.+:)?([\[<].*[\]>])?(.*)/s;
        return ($1 || '',$2 || '',$3);
    }
}

=item splitdir (override)

Split a directory specification into the components.

=cut

sub splitdir {
    my($self,$dirspec) = @_;
    my @dirs = ();
    return @dirs if ( (!defined $dirspec) || ('' eq $dirspec) );

    $dirspec =~ s/(?<!\^)</[/;                  # < and >	==> [ and ]
    $dirspec =~ s/(?<!\^)>/]/;
    $dirspec =~ s/(?<!\^)\]\[\./\.\]\[/g;	# ][.		==> .][
    $dirspec =~ s/(?<!\^)\[000000\.\]\[/\[/g;	# [000000.][	==> [
    $dirspec =~ s/(?<!\^)\[000000\./\[/g;	# [000000.	==> [
    $dirspec =~ s/(?<!\^)\.\]\[000000\]/\]/g;	# .][000000]	==> ]
    $dirspec =~ s/(?<!\^)\.\]\[/\./g;		# foo.][bar	==> foo.bar
    while ($dirspec =~ s/(^|[\[\<\.])\-(\-+)($|[\]\>\.])/$1-.$2$3/g) {}
						# That loop does the following
						# with any amount of dashes:
						# .--.		==> .-.-.
						# [--.		==> [-.-.
						# .--]		==> .-.-]
						# [--]		==> [-.-]
    $dirspec = "[$dirspec]" unless $dirspec =~ /(?<!\^)[\[<]/; # make legal
    $dirspec =~ s/^(\[|<)\./$1/;
    @dirs = split /(?<!\^)\./, vmspath($dirspec);
    $dirs[0] =~ s/^[\[<]//s;  $dirs[-1] =~ s/[\]>]\Z(?!\n)//s;
    @dirs;
}


=item catpath (override)

Construct a complete filespec.

=cut

sub catpath {
    my($self,$dev,$dir,$file) = @_;
    
    # We look for a volume in $dev, then in $dir, but not both
    my ($dir_volume, $dir_dir, $dir_file) = $self->splitpath($dir);
    $dev = $dir_volume unless length $dev;
    $dir = length $dir_file ? $self->catfile($dir_dir, $dir_file) : $dir_dir;
    
    if ($dev =~ m|^(?<!\^)/+([^/]+)|) { $dev = "$1:"; }
    else { $dev .= ':' unless $dev eq '' or $dev =~ /:\Z(?!\n)/; }
    if (length($dev) or length($dir)) {
        $dir = "[$dir]" unless $dir =~ /(?<!\^)[\[<\/]/;
        $dir = vmspath($dir);
    }
    $dir = '' if length($dev) && ($dir eq '[]' || $dir eq '<>');
    "$dev$dir$file";
}

=item abs2rel (override)

Attempt to convert an absolute file specification to a relative specification.

=cut

sub abs2rel {
    my $self = shift;
    my($path,$base) = @_;

    $base = $self->_cwd() unless defined $base and length $base;

    # If there is no device or directory syntax on $base, make sure it
    # is treated as a directory.
    $base = vmspath($base) unless $base =~ m{(?<!\^)[\[<:]};

    for ($path, $base) { $_ = $self->rel2abs($_) }

    # Are we even starting $path on the same (node::)device as $base?  Note that
    # logical paths or nodename differences may be on the "same device" 
    # but the comparison that ignores device differences so as to concatenate 
    # [---] up directory specs is not even a good idea in cases where there is 
    # a logical path difference between $path and $base nodename and/or device.
    # Hence we fall back to returning the absolute $path spec
    # if there is a case blind device (or node) difference of any sort
    # and we do not even try to call $parse() or consult %ENV for $trnlnm()
    # (this module needs to run on non VMS platforms after all).
    
    my ($path_volume, $path_directories, $path_file) = $self->splitpath($path);
    my ($base_volume, $base_directories, $base_file) = $self->splitpath($base);
    return $self->canonpath( $path ) unless lc($path_volume) eq lc($base_volume);

    # Now, remove all leading components that are the same
    my @pathchunks = $self->splitdir( $path_directories );
    my $pathchunks = @pathchunks;
    unshift(@pathchunks,'000000') unless $pathchunks[0] eq '000000';
    my @basechunks = $self->splitdir( $base_directories );
    my $basechunks = @basechunks;
    unshift(@basechunks,'000000') unless $basechunks[0] eq '000000';

    while ( @pathchunks && 
            @basechunks && 
            lc( $pathchunks[0] ) eq lc( $basechunks[0] ) 
          ) {
        shift @pathchunks ;
        shift @basechunks ;
    }

    # @basechunks now contains the directories to climb out of,
    # @pathchunks now has the directories to descend in to.
    if ((@basechunks > 0) || ($basechunks != $pathchunks)) {
      $path_directories = join '.', ('-' x @basechunks, @pathchunks) ;
    }
    else {
      $path_directories = join '.', @pathchunks;
    }
    $path_directories = '['.$path_directories.']';
    return $self->canonpath( $self->catpath( '', $path_directories, $path_file ) ) ;
}


=item rel2abs (override)

Return an absolute file specification from a relative one.

=cut

sub rel2abs {
    my $self = shift ;
    my ($path,$base ) = @_;
    return undef unless defined $path;
    if ($path =~ m/\//) {
       $path = ( -d $path || $path =~ m/\/\z/  # educated guessing about
                  ? vmspath($path)             # whether it's a directory
                  : vmsify($path) );
    }
    $base = vmspath($base) if defined $base && $base =~ m/\//;

    # Clean up and split up $path
    if ( ! $self->file_name_is_absolute( $path ) ) {
        # Figure out the effective $base and clean it up.
        if ( !defined( $base ) || $base eq '' ) {
            $base = $self->_cwd;
        }
        elsif ( ! $self->file_name_is_absolute( $base ) ) {
            $base = $self->rel2abs( $base ) ;
        }
        else {
            $base = $self->canonpath( $base ) ;
        }

        # Split up paths
        my ( $path_directories, $path_file ) =
            ($self->splitpath( $path ))[1,2] ;

        my ( $base_volume, $base_directories ) =
            $self->splitpath( $base ) ;

        $path_directories = '' if $path_directories eq '[]' ||
                                  $path_directories eq '<>';
        my $sep = '' ;
        $sep = '.'
            if ( $base_directories =~ m{[^.\]>]\Z(?!\n)} &&
                 $path_directories =~ m{^[^.\[<]}s
            ) ;
        $base_directories = "$base_directories$sep$path_directories";
        $base_directories =~ s{\.?[\]>][\[<]\.?}{.};

        $path = $self->catpath( $base_volume, $base_directories, $path_file );
   }

    return $self->canonpath( $path ) ;
}


=back

=head1 COPYRIGHT

Copyright (c) 2004-14 by the Perl 5 Porters.  All rights reserved.

This program is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=head1 SEE ALSO

See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
implementation of these methods, not the semantics.

An explanation of VMS file specs can be found at
L<http://h71000.www7.hp.com/doc/731FINAL/4506/4506pro_014.html#apps_locating_naming_files>.

=cut

1;
                                                                                         package File::Spec::Win32;

use strict;

use vars qw(@ISA $VERSION);
require File::Spec::Unix;

$VERSION = '3.63_01';
$VERSION =~ tr/_//d;

@ISA = qw(File::Spec::Unix);

# Some regexes we use for path splitting
my $DRIVE_RX = '[a-zA-Z]:';
my $UNC_RX = '(?:\\\\\\\\|//)[^\\\\/]+[\\\\/][^\\\\/]+';
my $VOL_RX = "(?:$DRIVE_RX|$UNC_RX)";


=head1 NAME

File::Spec::Win32 - methods for Win32 file specs

=head1 SYNOPSIS

 require File::Spec::Win32; # Done internally by File::Spec if needed

=head1 DESCRIPTION

See File::Spec::Unix for a documentation of the methods provided
there. This package overrides the implementation of these methods, not
the semantics.

=over 4

=item devnull

Returns a string representation of the null device.

=cut

sub devnull {
    return "nul";
}

sub rootdir { '\\' }


=item tmpdir

Returns a string representation of the first existing directory
from the following list:

    $ENV{TMPDIR}
    $ENV{TEMP}
    $ENV{TMP}
    SYS:/temp
    C:\system\temp
    C:/temp
    /tmp
    /

The SYS:/temp is preferred in Novell NetWare and the C:\system\temp
for Symbian (the File::Spec::Win32 is used also for those platforms).

If running under taint mode, and if the environment
variables are tainted, they are not used.

=cut

sub tmpdir {
    my $tmpdir = $_[0]->_cached_tmpdir(qw(TMPDIR TEMP TMP));
    return $tmpdir if defined $tmpdir;
    $tmpdir = $_[0]->_tmpdir( map( $ENV{$_}, qw(TMPDIR TEMP TMP) ),
			      'SYS:/temp',
			      'C:\system\temp',
			      'C:/temp',
			      '/tmp',
			      '/'  );
    $_[0]->_cache_tmpdir($tmpdir, qw(TMPDIR TEMP TMP));
}

=item case_tolerant

MSWin32 case-tolerance depends on GetVolumeInformation() $ouFsFlags == FS_CASE_SENSITIVE,
indicating the case significance when comparing file specifications.
Since XP FS_CASE_SENSITIVE is effectively disabled for the NT subsubsystem.
See http://cygwin.com/ml/cygwin/2007-07/msg00891.html
Default: 1

=cut

sub case_tolerant {
  eval {
    local @INC = @INC;
    pop @INC if $INC[-1] eq '.';
    require Win32API::File;
  } or return 1;
  my $drive = shift || "C:";
  my $osFsType = "\0"x256;
  my $osVolName = "\0"x256;
  my $ouFsFlags = 0;
  Win32API::File::GetVolumeInformation($drive, $osVolName, 256, [], [], $ouFsFlags, $osFsType, 256 );
  if ($ouFsFlags & Win32API::File::FS_CASE_SENSITIVE()) { return 0; }
  else { return 1; }
}

=item file_name_is_absolute

As of right now, this returns 2 if the path is absolute with a
volume, 1 if it's absolute with no volume, 0 otherwise.

=cut

sub file_name_is_absolute {

    my ($self,$file) = @_;

    if ($file =~ m{^($VOL_RX)}o) {
      my $vol = $1;
      return ($vol =~ m{^$UNC_RX}o ? 2
	      : $file =~ m{^$DRIVE_RX[\\/]}o ? 2
	      : 0);
    }
    return $file =~  m{^[\\/]} ? 1 : 0;
}

=item catfile

Concatenate one or more directory names and a filename to form a
complete path ending with a filename

=cut

sub catfile {
    shift;

    # Legacy / compatibility support
    #
    shift, return _canon_cat( "/", @_ )
	if $_[0] eq "";

    # Compatibility with File::Spec <= 3.26:
    #     catfile('A:', 'foo') should return 'A:\foo'.
    return _canon_cat( ($_[0].'\\'), @_[1..$#_] )
        if $_[0] =~ m{^$DRIVE_RX\z}o;

    return _canon_cat( @_ );
}

sub catdir {
    shift;

    # Legacy / compatibility support
    #
    return ""
    	unless @_;
    shift, return _canon_cat( "/", @_ )
	if $_[0] eq "";

    # Compatibility with File::Spec <= 3.26:
    #     catdir('A:', 'foo') should return 'A:\foo'.
    return _canon_cat( ($_[0].'\\'), @_[1..$#_] )
        if $_[0] =~ m{^$DRIVE_RX\z}o;

    return _canon_cat( @_ );
}

sub path {
    my @path = split(';', $ENV{PATH});
    s/"//g for @path;
    @path = grep length, @path;
    unshift(@path, ".");
    return @path;
}

=item canonpath

No physical check on the filesystem, but a logical cleanup of a
path. On UNIX eliminated successive slashes and successive "/.".
On Win32 makes 

	dir1\dir2\dir3\..\..\dir4 -> \dir\dir4 and even
	dir1\dir2\dir3\...\dir4   -> \dir\dir4

=cut

sub canonpath {
    # Legacy / compatibility support
    #
    return $_[1] if !defined($_[1]) or $_[1] eq '';
    return _canon_cat( $_[1] );
}

=item splitpath

   ($volume,$directories,$file) = File::Spec->splitpath( $path );
   ($volume,$directories,$file) = File::Spec->splitpath( $path,
                                                         $no_file );

Splits a path into volume, directory, and filename portions. Assumes that 
the last file is a path unless the path ends in '\\', '\\.', '\\..'
or $no_file is true.  On Win32 this means that $no_file true makes this return 
( $volume, $path, '' ).

Separators accepted are \ and /.

Volumes can be drive letters or UNC sharenames (\\server\share).

The results can be passed to L</catpath> to get back a path equivalent to
(usually identical to) the original path.

=cut

sub splitpath {
    my ($self,$path, $nofile) = @_;
    my ($volume,$directory,$file) = ('','','');
    if ( $nofile ) {
        $path =~ 
            m{^ ( $VOL_RX ? ) (.*) }sox;
        $volume    = $1;
        $directory = $2;
    }
    else {
        $path =~ 
            m{^ ( $VOL_RX ? )
                ( (?:.*[\\/](?:\.\.?\Z(?!\n))?)? )
                (.*)
             }sox;
        $volume    = $1;
        $directory = $2;
        $file      = $3;
    }

    return ($volume,$directory,$file);
}


=item splitdir

The opposite of L<catdir()|File::Spec/catdir>.

    @dirs = File::Spec->splitdir( $directories );

$directories must be only the directory portion of the path on systems 
that have the concept of a volume or that have path syntax that differentiates
files from directories.

Unlike just splitting the directories on the separator, leading empty and 
trailing directory entries can be returned, because these are significant
on some OSs. So,

    File::Spec->splitdir( "/a/b/c" );

Yields:

    ( '', 'a', 'b', '', 'c', '' )

=cut

sub splitdir {
    my ($self,$directories) = @_ ;
    #
    # split() likes to forget about trailing null fields, so here we
    # check to be sure that there will not be any before handling the
    # simple case.
    #
    if ( $directories !~ m|[\\/]\Z(?!\n)| ) {
        return split( m|[\\/]|, $directories );
    }
    else {
        #
        # since there was a trailing separator, add a file name to the end, 
        # then do the split, then replace it with ''.
        #
        my( @directories )= split( m|[\\/]|, "${directories}dummy" ) ;
        $directories[ $#directories ]= '' ;
        return @directories ;
    }
}


=item catpath

Takes volume, directory and file portions and returns an entire path. Under
Unix, $volume is ignored, and this is just like catfile(). On other OSs,
the $volume become significant.

=cut

sub catpath {
    my ($self,$volume,$directory,$file) = @_;

    # If it's UNC, make sure the glue separator is there, reusing
    # whatever separator is first in the $volume
    my $v;
    $volume .= $v
        if ( (($v) = $volume =~ m@^([\\/])[\\/][^\\/]+[\\/][^\\/]+\Z(?!\n)@s) &&
             $directory =~ m@^[^\\/]@s
           ) ;

    $volume .= $directory ;

    # If the volume is not just A:, make sure the glue separator is 
    # there, reusing whatever separator is first in the $volume if possible.
    if ( $volume !~ m@^[a-zA-Z]:\Z(?!\n)@s &&
         $volume =~ m@[^\\/]\Z(?!\n)@      &&
         $file   =~ m@[^\\/]@
       ) {
        $volume =~ m@([\\/])@ ;
        my $sep = $1 ? $1 : '\\' ;
        $volume .= $sep ;
    }

    $volume .= $file ;

    return $volume ;
}

sub _same {
  lc($_[1]) eq lc($_[2]);
}

sub rel2abs {
    my ($self,$path,$base ) = @_;

    my $is_abs = $self->file_name_is_absolute($path);

    # Check for volume (should probably document the '2' thing...)
    return $self->canonpath( $path ) if $is_abs == 2;

    if ($is_abs) {
      # It's missing a volume, add one
      my $vol = ($self->splitpath( $self->_cwd() ))[0];
      return $self->canonpath( $vol . $path );
    }

    if ( !defined( $base ) || $base eq '' ) {
      require Cwd ;
      $base = Cwd::getdcwd( ($self->splitpath( $path ))[0] ) if defined &Cwd::getdcwd ;
      $base = $self->_cwd() unless defined $base ;
    }
    elsif ( ! $self->file_name_is_absolute( $base ) ) {
      $base = $self->rel2abs( $base ) ;
    }
    else {
      $base = $self->canonpath( $base ) ;
    }

    my ( $path_directories, $path_file ) =
      ($self->splitpath( $path, 1 ))[1,2] ;

    my ( $base_volume, $base_directories ) =
      $self->splitpath( $base, 1 ) ;

    $path = $self->catpath( 
			   $base_volume, 
			   $self->catdir( $base_directories, $path_directories ), 
			   $path_file
			  ) ;

    return $self->canonpath( $path ) ;
}

=back

=head2 Note For File::Spec::Win32 Maintainers

Novell NetWare inherits its File::Spec behaviour from File::Spec::Win32.

=head1 COPYRIGHT

Copyright (c) 2004,2007 by the Perl 5 Porters.  All rights reserved.

This program is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=head1 SEE ALSO

See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
implementation of these methods, not the semantics.

=cut


sub _canon_cat				# @path -> path
{
    my ($first, @rest) = @_;

    my $volume = $first =~ s{ \A ([A-Za-z]:) ([\\/]?) }{}x	# drive letter
    	       ? ucfirst( $1 ).( $2 ? "\\" : "" )
	       : $first =~ s{ \A (?:\\\\|//) ([^\\/]+)
				 (?: [\\/] ([^\\/]+) )?
	       			 [\\/]? }{}xs			# UNC volume
	       ? "\\\\$1".( defined $2 ? "\\$2" : "" )."\\"
	       : $first =~ s{ \A [\\/] }{}x			# root dir
	       ? "\\"
	       : "";
    my $path   = join "\\", $first, @rest;

    $path =~ tr#\\/#\\\\#s;		# xx/yy --> xx\yy & xx\\yy --> xx\yy

    					# xx/././yy --> xx/yy
    $path =~ s{(?:
		(?:\A|\\)		# at begin or after a slash
		\.
		(?:\\\.)*		# and more
		(?:\\|\z) 		# at end or followed by slash
	       )+			# performance boost -- I do not know why
	     }{\\}gx;

    # XXX I do not know whether more dots are supported by the OS supporting
    #     this ... annotation (NetWare or symbian but not MSWin32).
    #     Then .... could easily become ../../.. etc:
    # Replace \.\.\. by (\.\.\.+)  and substitute with
    # { $1 . ".." . "\\.." x (length($2)-2) }gex
	     				# ... --> ../..
    $path =~ s{ (\A|\\)			# at begin or after a slash
    		\.\.\.
		(?=\\|\z) 		# at end or followed by slash
	     }{$1..\\..}gx;
    					# xx\yy\..\zz --> xx\zz
    while ( $path =~ s{(?:
		(?:\A|\\)		# at begin or after a slash
		[^\\]+			# rip this 'yy' off
		\\\.\.
		(?<!\A\.\.\\\.\.)	# do *not* replace ^..\..
		(?<!\\\.\.\\\.\.)	# do *not* replace \..\..
		(?:\\|\z) 		# at end or followed by slash
	       )+			# performance boost -- I do not know why
	     }{\\}sx ) {}

    $path =~ s#\A\\##;			# \xx --> xx  NOTE: this is *not* root
    $path =~ s#\\\z##;			# xx\ --> xx

    if ( $volume =~ m#\\\z# )
    {					# <vol>\.. --> <vol>\
	$path =~ s{ \A			# at begin
		    \.\.
		    (?:\\\.\.)*		# and more
		    (?:\\|\z) 		# at end or followed by slash
		 }{}x;

	return $1			# \\HOST\SHARE\ --> \\HOST\SHARE
	    if    $path eq ""
	      and $volume =~ m#\A(\\\\.*)\\\z#s;
    }
    return $path ne "" || $volume ? $volume.$path : ".";
}

1;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                #

package IO::File;

use 5.006_001;
use strict;
our($VERSION, @EXPORT, @EXPORT_OK, @ISA);
use Carp;
use Symbol;
use SelectSaver;
use IO::Seekable;

require Exporter;

@ISA = qw(IO::Handle IO::Seekable Exporter);

$VERSION = "1.16";

@EXPORT = @IO::Seekable::EXPORT;

eval {
    # Make all Fcntl O_XXX constants available for importing
    require Fcntl;
    my @O = grep /^O_/, @Fcntl::EXPORT;
    Fcntl->import(@O);  # first we import what we want to export
    push(@EXPORT, @O);
};

################################################
## Constructor
##

sub new {
    my $type = shift;
    my $class = ref($type) || $type || "IO::File";
    @_ >= 0 && @_ <= 3
	or croak "usage: $class->new([FILENAME [,MODE [,PERMS]]])";
    my $fh = $class->SUPER::new();
    if (@_) {
	$fh->open(@_)
	    or return undef;
    }
    $fh;
}

################################################
## Open
##

sub open {
    @_ >= 2 && @_ <= 4 or croak 'usage: $fh->open(FILENAME [,MODE [,PERMS]])';
    my ($fh, $file) = @_;
    if (@_ > 2) {
	my ($mode, $perms) = @_[2, 3];
	if ($mode =~ /^\d+$/) {
	    defined $perms or $perms = 0666;
	    return sysopen($fh, $file, $mode, $perms);
	} elsif ($mode =~ /:/) {
	    return open($fh, $mode, $file) if @_ == 3;
	    croak 'usage: $fh->open(FILENAME, IOLAYERS)';
	} else {
            return open($fh, IO::Handle::_open_mode_string($mode), $file);
        }
    }
    open($fh, $file);
}

################################################
## Binmode
##

sub binmode {
    ( @_ == 1 or @_ == 2 ) or croak 'usage $fh->binmode([LAYER])';

    my($fh, $layer) = @_;

    return binmode $$fh unless $layer;
    return binmode $$fh, $layer;
}

1;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              # Call.pm
#
# Copyright (c) 1995-2011 Paul Marquess. All rights reserved.
# Copyright (c) 2011-2014 Reini Urban. All rights reserved.
#
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.
 
package Filter::Util::Call ;

require 5.005 ;
require DynaLoader;
require Exporter;
use Carp ;
use strict;
use warnings;
use vars qw($VERSION @ISA @EXPORT) ;

@ISA = qw(Exporter DynaLoader);
@EXPORT = qw( filter_add filter_del filter_read filter_read_exact) ;
$VERSION = "1.55" ;

sub filter_read_exact($)
{
    my ($size)   = @_ ;
    my ($left)   = $size ;
    my ($status) ;

    croak ("filter_read_exact: size parameter must be > 0")
	unless $size > 0 ;

    # try to read a block which is exactly $size bytes long
    while ($left and ($status = filter_read($left)) > 0) {
        $left = $size - length $_ ;
    }

    # EOF with pending data is a special case
    return 1 if $status == 0 and length $_ ;

    return $status ;
}

sub filter_add($)
{
    my($obj) = @_ ;

    # Did we get a code reference?
    my $coderef = (ref $obj eq 'CODE');

    # If the parameter isn't already a reference, make it one.
    if (!$coderef and (!ref($obj) or ref($obj) =~ /^ARRAY|HASH$/)) {
      $obj = bless (\$obj, (caller)[0]);
    }

    # finish off the installation of the filter in C.
    Filter::Util::Call::real_import($obj, (caller)[0], $coderef) ;
}

bootstrap Filter::Util::Call ;

1;
__END__

=head1 NAME

Filter::Util::Call - Perl Source Filter Utility Module

=head1 SYNOPSIS

    use Filter::Util::Call ;

=head1 DESCRIPTION

This module provides you with the framework to write I<Source Filters>
in Perl. 

An alternate interface to Filter::Util::Call is now available. See
L<Filter::Simple> for more details.

A I<Perl Source Filter> is implemented as a Perl module. The structure
of the module can take one of two broadly similar formats. To
distinguish between them, the first will be referred to as I<method
filter> and the second as I<closure filter>.

Here is a skeleton for the I<method filter>:

    package MyFilter ;

    use Filter::Util::Call ;

    sub import
    {
        my($type, @arguments) = @_ ;
        filter_add([]) ;
    }

    sub filter
    {
        my($self) = @_ ;
        my($status) ;

        $status = filter_read() ;
        $status ;
    }

    1 ;

and this is the equivalent skeleton for the I<closure filter>:

    package MyFilter ;

    use Filter::Util::Call ;

    sub import
    {
        my($type, @arguments) = @_ ;

        filter_add(
            sub 
            {
                my($status) ;
                $status = filter_read() ;
                $status ;
            } )
    }

    1 ;

To make use of either of the two filter modules above, place the line
below in a Perl source file.

    use MyFilter; 

In fact, the skeleton modules shown above are fully functional I<Source
Filters>, albeit fairly useless ones. All they does is filter the
source stream without modifying it at all.

As you can see both modules have a broadly similar structure. They both
make use of the C<Filter::Util::Call> module and both have an C<import>
method. The difference between them is that the I<method filter>
requires a I<filter> method, whereas the I<closure filter> gets the
equivalent of a I<filter> method with the anonymous sub passed to
I<filter_add>.

To make proper use of the I<closure filter> shown above you need to
have a good understanding of the concept of a I<closure>. See
L<perlref> for more details on the mechanics of I<closures>.

=head2 B<use Filter::Util::Call>

The following functions are exported by C<Filter::Util::Call>:

    filter_add()
    filter_read()
    filter_read_exact()
    filter_del()

=head2 B<import()>

The C<import> method is used to create an instance of the filter. It is
called indirectly by Perl when it encounters the C<use MyFilter> line
in a source file (See L<perlfunc/import> for more details on
C<import>).

It will always have at least one parameter automatically passed by Perl
- this corresponds to the name of the package. In the example above it
will be C<"MyFilter">.

Apart from the first parameter, import can accept an optional list of
parameters. These can be used to pass parameters to the filter. For
example:

    use MyFilter qw(a b c) ;

will result in the C<@_> array having the following values:

    @_ [0] => "MyFilter"
    @_ [1] => "a"
    @_ [2] => "b"
    @_ [3] => "c"

Before terminating, the C<import> function must explicitly install the
filter by calling C<filter_add>.

=head2 B<filter_add()>

The function, C<filter_add>, actually installs the filter. It takes one
parameter which should be a reference. The kind of reference used will
dictate which of the two filter types will be used.

If a CODE reference is used then a I<closure filter> will be assumed.

If a CODE reference is not used, a I<method filter> will be assumed.
In a I<method filter>, the reference can be used to store context
information. The reference will be I<blessed> into the package by
C<filter_add>, unless the reference was already blessed.

See the filters at the end of this documents for examples of using
context information using both I<method filters> and I<closure
filters>.

=head2 B<filter() and anonymous sub>

Both the C<filter> method used with a I<method filter> and the
anonymous sub used with a I<closure filter> is where the main
processing for the filter is done.

The big difference between the two types of filter is that the I<method
filter> uses the object passed to the method to store any context data,
whereas the I<closure filter> uses the lexical variables that are
maintained by the closure.

Note that the single parameter passed to the I<method filter>,
C<$self>, is the same reference that was passed to C<filter_add>
blessed into the filter's package. See the example filters later on for
details of using C<$self>.

Here is a list of the common features of the anonymous sub and the
C<filter()> method.

=over 5

=item B<$_>

Although C<$_> doesn't actually appear explicitly in the sample filters
above, it is implicitly used in a number of places.

Firstly, when either C<filter> or the anonymous sub are called, a local
copy of C<$_> will automatically be created. It will always contain the
empty string at this point.

Next, both C<filter_read> and C<filter_read_exact> will append any
source data that is read to the end of C<$_>.

Finally, when C<filter> or the anonymous sub are finished processing,
they are expected to return the filtered source using C<$_>.

This implicit use of C<$_> greatly simplifies the filter.

=item B<$status>

The status value that is returned by the user's C<filter> method or
anonymous sub and the C<filter_read> and C<read_exact> functions take
the same set of values, namely:

    < 0  Error
    = 0  EOF
    > 0  OK

=item B<filter_read> and B<filter_read_exact>

These functions are used by the filter to obtain either a line or block
from the next filter in the chain or the actual source file if there
aren't any other filters.

The function C<filter_read> takes two forms:

    $status = filter_read() ;
    $status = filter_read($size) ;

The first form is used to request a I<line>, the second requests a
I<block>.

In line mode, C<filter_read> will append the next source line to the
end of the C<$_> scalar.

In block mode, C<filter_read> will append a block of data which is <=
C<$size> to the end of the C<$_> scalar. It is important to emphasise
the that C<filter_read> will not necessarily read a block which is
I<precisely> C<$size> bytes.

If you need to be able to read a block which has an exact size, you can
use the function C<filter_read_exact>. It works identically to
C<filter_read> in block mode, except it will try to read a block which
is exactly C<$size> bytes in length. The only circumstances when it
will not return a block which is C<$size> bytes long is on EOF or
error.

It is I<very> important to check the value of C<$status> after I<every>
call to C<filter_read> or C<filter_read_exact>.

=item B<filter_del>

The function, C<filter_del>, is used to disable the current filter. It
does not affect the running of the filter. All it does is tell Perl not
to call filter any more.

See L<Example 4: Using filter_del> for details.

=item I<real_import>

Internal function which adds the filter, based on the L<filter_add>
argument type.

=item I<unimport()>

May be used to disable a filter, but is rarely needed. See L<filter_del>.

=back

=head1 LIMITATIONS

See L<perlfilter/LIMITATIONS> for an overview of the general problems
filtering code in a textual line-level only.

=over

=item __DATA__ is ignored

The content from the __DATA__ block is not filtered.
This is a serious limitation, e.g. for the L<Switch> module.
See L<http://search.cpan.org/perldoc?Switch#LIMITATIONS> for more.

=item Max. codesize limited to 32-bit

Currently internal buffer lengths are limited to 32-bit only.

=back

=head1 EXAMPLES

Here are a few examples which illustrate the key concepts - as such
most of them are of little practical use.

The C<examples> sub-directory has copies of all these filters
implemented both as I<method filters> and as I<closure filters>.

=head2 Example 1: A simple filter.

Below is a I<method filter> which is hard-wired to replace all
occurrences of the string C<"Joe"> to C<"Jim">. Not particularly
Useful, but it is the first example and I wanted to keep it simple.

    package Joe2Jim ;

    use Filter::Util::Call ;

    sub import
    {
        my($type) = @_ ;

        filter_add(bless []) ;
    }

    sub filter
    {
        my($self) = @_ ;
        my($status) ;

        s/Joe/Jim/g
            if ($status = filter_read()) > 0 ;
        $status ;
    }

    1 ;

Here is an example of using the filter:

    use Joe2Jim ;
    print "Where is Joe?\n" ;

And this is what the script above will print:

    Where is Jim?

=head2 Example 2: Using the context

The previous example was not particularly useful. To make it more
general purpose we will make use of the context data and allow any
arbitrary I<from> and I<to> strings to be used. This time we will use a
I<closure filter>. To reflect its enhanced role, the filter is called
C<Subst>.

    package Subst ;

    use Filter::Util::Call ;
    use Carp ;

    sub import
    {
        croak("usage: use Subst qw(from to)")
            unless @_ == 3 ;
        my ($self, $from, $to) = @_ ;
        filter_add(
            sub 
            {
                my ($status) ;
                s/$from/$to/
                    if ($status = filter_read()) > 0 ;
                $status ;
            })
    }
    1 ;

and is used like this:

    use Subst qw(Joe Jim) ;
    print "Where is Joe?\n" ;


=head2 Example 3: Using the context within the filter

Here is a filter which a variation of the C<Joe2Jim> filter. As well as
substituting all occurrences of C<"Joe"> to C<"Jim"> it keeps a count
of the number of substitutions made in the context object.

Once EOF is detected (C<$status> is zero) the filter will insert an
extra line into the source stream. When this extra line is executed it
will print a count of the number of substitutions actually made.
Note that C<$status> is set to C<1> in this case.

    package Count ;

    use Filter::Util::Call ;

    sub filter
    {
        my ($self) = @_ ;
        my ($status) ;

        if (($status = filter_read()) > 0 ) {
            s/Joe/Jim/g ;
	    ++ $$self ;
        }
	elsif ($$self >= 0) { # EOF
            $_ = "print q[Made ${$self} substitutions\n]" ;
            $status = 1 ;
	    $$self = -1 ;
        }

        $status ;
    }

    sub import
    {
        my ($self) = @_ ;
        my ($count) = 0 ;
        filter_add(\$count) ;
    }

    1 ;

Here is a script which uses it:

    use Count ;
    print "Hello Joe\n" ;
    print "Where is Joe\n" ;

Outputs:

    Hello Jim
    Where is Jim
    Made 2 substitutions

=head2 Example 4: Using filter_del

Another variation on a theme. This time we will modify the C<Subst>
filter to allow a starting and stopping pattern to be specified as well
as the I<from> and I<to> patterns. If you know the I<vi> editor, it is
the equivalent of this command:

    :/start/,/stop/s/from/to/

When used as a filter we want to invoke it like this:

    use NewSubst qw(start stop from to) ;

Here is the module.

    package NewSubst ;

    use Filter::Util::Call ;
    use Carp ;

    sub import
    {
        my ($self, $start, $stop, $from, $to) = @_ ;
        my ($found) = 0 ;
        croak("usage: use Subst qw(start stop from to)")
            unless @_ == 5 ;

        filter_add( 
            sub 
            {
                my ($status) ;

                if (($status = filter_read()) > 0) {

                    $found = 1
                        if $found == 0 and /$start/ ;

                    if ($found) {
                        s/$from/$to/ ;
                        filter_del() if /$stop/ ;
                    }

                }
                $status ;
            } )

    }

    1 ;

=head1 Filter::Simple

If you intend using the Filter::Call functionality, I would strongly
recommend that you check out Damian Conway's excellent Filter::Simple
module. Damian's module provides a much cleaner interface than
Filter::Util::Call. Although it doesn't allow the fine control that
Filter::Util::Call does, it should be adequate for the majority of
applications. It's available at

   http://search.cpan.org/dist/Filter-Simple/

=head1 AUTHOR

Paul Marquess 

=head1 DATE

26th January 1996

=head1 LICENSE

Copyright (c) 1995-2011 Paul Marquess. All rights reserved.
Copyright (c) 2011-2014 Reini Urban. All rights reserved.

This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

=cut

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                package Hash::Util;

require 5.007003;
use strict;
use Carp;
use warnings;
no warnings 'uninitialized';
use warnings::register;
use Scalar::Util qw(reftype);

require Exporter;
our @ISA        = qw(Exporter);
our @EXPORT_OK  = qw(
                     fieldhash fieldhashes

                     all_keys
                     lock_keys unlock_keys
                     lock_value unlock_value
                     lock_hash unlock_hash
                     lock_keys_plus
                     hash_locked hash_unlocked
                     hashref_locked hashref_unlocked
                     hidden_keys legal_keys

                     lock_ref_keys unlock_ref_keys
                     lock_ref_value unlock_ref_value
                     lock_hashref unlock_hashref
                     lock_ref_keys_plus
                     hidden_ref_keys legal_ref_keys

                     hash_seed hash_value hv_store
                     bucket_stats bucket_stats_formatted bucket_info bucket_array
                     lock_hash_recurse unlock_hash_recurse
                     lock_hashref_recurse unlock_hashref_recurse

                     hash_traversal_mask
                    );
our $VERSION = '0.19';
require XSLoader;
XSLoader::load();

sub import {
    my $class = shift;
    if ( grep /fieldhash/, @_ ) {
        require Hash::Util::FieldHash;
        Hash::Util::FieldHash->import(':all'); # for re-export
    }
    unshift @_, $class;
    goto &Exporter::import;
}

sub lock_ref_keys {
    my($hash, @keys) = @_;

    Internals::hv_clear_placeholders %$hash;
    if( @keys ) {
        my %keys = map { ($_ => 1) } @keys;
        my %original_keys = map { ($_ => 1) } keys %$hash;
        foreach my $k (keys %original_keys) {
            croak "Hash has key '$k' which is not in the new key set"
              unless $keys{$k};
        }

        foreach my $k (@keys) {
            $hash->{$k} = undef unless exists $hash->{$k};
        }
        Internals::SvREADONLY %$hash, 1;

        foreach my $k (@keys) {
            delete $hash->{$k} unless $original_keys{$k};
        }
    }
    else {
        Internals::SvREADONLY %$hash, 1;
    }

    return $hash;
}

sub unlock_ref_keys {
    my $hash = shift;

    Internals::SvREADONLY %$hash, 0;
    return $hash;
}

sub   lock_keys (\%;@) {   lock_ref_keys(@_) }
sub unlock_keys (\%)   { unlock_ref_keys(@_) }

sub lock_ref_keys_plus {
    my ($hash,@keys) = @_;
    my @delete;
    Internals::hv_clear_placeholders(%$hash);
    foreach my $key (@keys) {
        unless (exists($hash->{$key})) {
            $hash->{$key}=undef;
            push @delete,$key;
        }
    }
    Internals::SvREADONLY(%$hash,1);
    delete @{$hash}{@delete};
    return $hash
}

sub lock_keys_plus(\%;@) { lock_ref_keys_plus(@_) }

sub lock_ref_value {
    my($hash, $key) = @_;
    # I'm doubtful about this warning, as it seems not to be true.
    # Marking a value in the hash as RO is useful, regardless
    # of the status of the hash itself.
    carp "Cannot usefully lock values in an unlocked hash"
      if !Internals::SvREADONLY(%$hash) && warnings::enabled;
    Internals::SvREADONLY $hash->{$key}, 1;
    return $hash
}

sub unlock_ref_value {
    my($hash, $key) = @_;
    Internals::SvREADONLY $hash->{$key}, 0;
    return $hash
}

sub   lock_value (\%$) {   lock_ref_value(@_) }
sub unlock_value (\%$) { unlock_ref_value(@_) }

sub lock_hashref {
    my $hash = shift;

    lock_ref_keys($hash);

    foreach my $value (values %$hash) {
        Internals::SvREADONLY($value,1);
    }

    return $hash;
}

sub unlock_hashref {
    my $hash = shift;

    foreach my $value (values %$hash) {
        Internals::SvREADONLY($value, 0);
    }

    unlock_ref_keys($hash);

    return $hash;
}

sub   lock_hash (\%) {   lock_hashref(@_) }
sub unlock_hash (\%) { unlock_hashref(@_) }

sub lock_hashref_recurse {
    my $hash = shift;

    lock_ref_keys($hash);
    foreach my $value (values %$hash) {
        my $type = reftype($value);
        if (defined($type) and $type eq 'HASH') {
            lock_hashref_recurse($value);
        }
        Internals::SvREADONLY($value,1);
    }
    return $hash
}

sub unlock_hashref_recurse {
    my $hash = shift;

    foreach my $value (values %$hash) {
        my $type = reftype($value);
        if (defined($type) and $type eq 'HASH') {
            unlock_hashref_recurse($value);
        }
        Internals::SvREADONLY($value,0);
    }
    unlock_ref_keys($hash);
    return $hash;
}

sub   lock_hash_recurse (\%) {   lock_hashref_recurse(@_) }
sub unlock_hash_recurse (\%) { unlock_hashref_recurse(@_) }

sub hashref_locked {
    my $hash=shift;
    Internals::SvREADONLY(%$hash);
}

sub hash_locked(\%) { hashref_locked(@_) }

sub hashref_unlocked {
    my $hash=shift;
    !Internals::SvREADONLY(%$hash);
}

sub hash_unlocked(\%) { hashref_unlocked(@_) }

sub legal_keys(\%) { legal_ref_keys(@_)  }
sub hidden_keys(\%){ hidden_ref_keys(@_) }

sub bucket_stats {
    my ($hash) = @_;
    my ($keys, $buckets, $used, @length_counts) = bucket_info($hash);
    my $sum;
    my $score;
    for (1 .. $#length_counts) {
        $sum += ($length_counts[$_] * $_);
        $score += $length_counts[$_] * ( $_ * ($_ + 1 ) / 2 );
    }
    $score = $score /
             (( $keys / (2 * $buckets )) * ( $keys + ( 2 * $buckets ) - 1 ))
                 if $keys;
    my ($mean, $stddev)= (0, 0);
    if ($used) {
        $mean= $sum / $used;
        $sum= 0;
        $sum += ($length_counts[$_] * (($_-$mean)**2)) for 1 .. $#length_counts;

        $stddev= sqrt($sum/$used);
    }
    return $keys, $buckets, $used, $keys ? ($score, $used/$buckets, ($keys-$used)/$keys, $mean, $stddev, @length_counts) : ();
}

sub _bucket_stats_formatted_bars {
    my ($total, $ary, $start_idx, $title, $row_title)= @_;

    my $return = "";
    my $max_width= $total > 64 ? 64 : $total;
    my $bar_width= $max_width / $total;

    my $str= "";
    if ( @$ary < 10) {
        for my $idx ($start_idx .. $#$ary) {
            $str .= $idx x sprintf("%.0f", ($ary->[$idx] * $bar_width));
        }
    } else {
        $str= "-" x $max_width;
    }
    $return .= sprintf "%-7s         %6d [%s]\n",$title, $total, $str;

    foreach my $idx ($start_idx .. $#$ary) {
        $return .= sprintf "%-.3s %3d %6.2f%% %6d [%s]\n",
            $row_title,
            $idx,
            $ary->[$idx] / $total * 100,
            $ary->[$idx],
            "#" x sprintf("%.0f", ($ary->[$idx] * $bar_width)),
        ;
    }
    return $return;
}

sub bucket_stats_formatted {
    my ($hashref)= @_;
    my ($keys, $buckets, $used, $score, $utilization_ratio, $collision_pct,
        $mean, $stddev, @length_counts) = bucket_stats($hashref);

    my $return= sprintf   "Keys: %d Buckets: %d/%d Quality-Score: %.2f (%s)\n"
                        . "Utilized Buckets: %.2f%% Optimal: %.2f%% Keys In Collision: %.2f%%\n"
                        . "Chain Length - mean: %.2f stddev: %.2f\n",
                $keys, $used, $buckets, $score, $score <= 1.05 ? "Good" : $score < 1.2 ? "Poor" : "Bad",
                $utilization_ratio * 100,
                $keys/$buckets * 100,
                $collision_pct * 100,
                $mean, $stddev;

    my @key_depth;
    $key_depth[$_]= $length_counts[$_] + ( $key_depth[$_+1] || 0 )
        for reverse 1 .. $#length_counts;

    if ($keys) {
        $return .= _bucket_stats_formatted_bars($buckets, \@length_counts, 0, "Buckets", "Len");
        $return .= _bucket_stats_formatted_bars($keys, \@key_depth, 1, "Keys", "Pos");
    }
    return $return
}

1;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    # IO::Dir.pm
#
# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.

package IO::Dir;

use 5.006;

use strict;
use Carp;
use Symbol;
use Exporter;
use IO::File;
our(@ISA, $VERSION, @EXPORT_OK);
use Tie::Hash;
use File::stat;
use File::Spec;

@ISA = qw(Tie::Hash Exporter);
$VERSION = "1.10";
$VERSION = eval $VERSION;
@EXPORT_OK = qw(DIR_UNLINK);

sub DIR_UNLINK () { 1 }

sub new {
    @_ >= 1 && @_ <= 2 or croak 'usage: IO::Dir->new([DIRNAME])';
    my $class = shift;
    my $dh = gensym;
    if (@_) {
	IO::Dir::open($dh, $_[0])
	    or return undef;
    }
    bless $dh, $class;
}

sub DESTROY {
    my ($dh) = @_;
    local($., $@, $!, $^E, $?);
    no warnings 'io';
    closedir($dh);
}

sub open {
    @_ == 2 or croak 'usage: $dh->open(DIRNAME)';
    my ($dh, $dirname) = @_;
    return undef
	unless opendir($dh, $dirname);
    # a dir name should always have a ":" in it; assume dirname is
    # in current directory
    $dirname = ':' .  $dirname if ( ($^O eq 'MacOS') && ($dirname !~ /:/) );
    ${*$dh}{io_dir_path} = $dirname;
    1;
}

sub close {
    @_ == 1 or croak 'usage: $dh->close()';
    my ($dh) = @_;
    closedir($dh);
}

sub read {
    @_ == 1 or croak 'usage: $dh->read()';
    my ($dh) = @_;
    readdir($dh);
}

sub seek {
    @_ == 2 or croak 'usage: $dh->seek(POS)';
    my ($dh,$pos) = @_;
    seekdir($dh,$pos);
}

sub tell {
    @_ == 1 or croak 'usage: $dh->tell()';
    my ($dh) = @_;
    telldir($dh);
}

sub rewind {
    @_ == 1 or croak 'usage: $dh->rewind()';
    my ($dh) = @_;
    rewinddir($dh);
}

sub TIEHASH {
    my($class,$dir,$options) = @_;

    my $dh = $class->new($dir)
	or return undef;

    $options ||= 0;

    ${*$dh}{io_dir_unlink} = $options & DIR_UNLINK;
    $dh;
}

sub FIRSTKEY {
    my($dh) = @_;
    $dh->rewind;
    scalar $dh->read;
}

sub NEXTKEY {
    my($dh) = @_;
    scalar $dh->read;
}

sub EXISTS {
    my($dh,$key) = @_;
    -e File::Spec->catfile(${*$dh}{io_dir_path}, $key);
}

sub FETCH {
    my($dh,$key) = @_;
    &lstat(File::Spec->catfile(${*$dh}{io_dir_path}, $key));
}

sub STORE {
    my($dh,$key,$data) = @_;
    my($atime,$mtime) = ref($data) ? @$data : ($data,$data);
    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);
    unless(-e $file) {
	my $io = IO::File->new($file,O_CREAT | O_RDWR);
	$io->close if $io;
    }
    utime($atime,$mtime, $file);
}

sub DELETE {
    my($dh,$key) = @_;

    # Only unlink if unlink-ing is enabled
    return 0
	unless ${*$dh}{io_dir_unlink};

    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);

    -d $file
	? rmdir($file)
	: unlink($file);
}

1;

__END__

=head1 NAME 

IO::Dir - supply object methods for directory handles

=head1 SYNOPSIS

    use IO::Dir;
    $d = IO::Dir->new(".");
    if (defined $d) {
        while (defined($_ = $d->read)) { something($_); }
        $d->rewind;
        while (defined($_ = $d->read)) { something_else($_); }
        undef $d;
    }

    tie %dir, 'IO::Dir', ".";
    foreach (keys %dir) {
	print $_, " " , $dir{$_}->size,"\n";
    }

=head1 DESCRIPTION

The C<IO::Dir> package provides two interfaces to perl's directory reading
routines.

The first interface is an object approach. C<IO::Dir> provides an object
constructor and methods, which are just wrappers around perl's built in
directory reading routines.

=over 4

=item new ( [ DIRNAME ] )

C<new> is the constructor for C<IO::Dir> objects. It accepts one optional
argument which,  if given, C<new> will pass to C<open>

=back

The following methods are wrappers for the directory related functions built
into perl (the trailing 'dir' has been removed from the names). See L<perlfunc>
for details of these functions.

=over 4

=item open ( DIRNAME )

=item read ()

=item seek ( POS )

=item tell ()

=item rewind ()

=item close ()

=back

C<IO::Dir> also provides an interface to reading directories via a tied
hash. The tied hash extends the interface beyond just the directory
reading routines by the use of C<lstat>, from the C<File::stat> package,
C<unlink>, C<rmdir> and C<utime>.

=over 4

=item tie %hash, 'IO::Dir', DIRNAME [, OPTIONS ]

=back

The keys of the hash will be the names of the entries in the directory. 
Reading a value from the hash will be the result of calling
C<File::stat::lstat>.  Deleting an element from the hash will 
delete the corresponding file or subdirectory,
provided that C<DIR_UNLINK> is included in the C<OPTIONS>.

Assigning to an entry in the hash will cause the time stamps of the file
to be modified. If the file does not exist then it will be created. Assigning
a single integer to a hash element will cause both the access and 
modification times to be changed to that value. Alternatively a reference to
an array of two values can be passed. The first array element will be used to
set the access time and the second element will be used to set the modification
time.

=head1 SEE ALSO

L<File::stat>

=head1 AUTHOR

Graham Barr. Currently maintained by the Perl Porters.  Please report all
bugs to <perlbug@perl.org>.

=head1 COPYRIGHT

Copyright (c) 1997-2003 Graham Barr <gbarr@pobox.com>. All rights reserved.
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        package IO::Handle;

use 5.006_001;
use strict;
our($VERSION, @EXPORT_OK, @ISA);
use Carp;
use Symbol;
use SelectSaver;
use IO ();	# Load the XS module

require Exporter;
@ISA = qw(Exporter);

$VERSION = "1.36";
$VERSION = eval $VERSION;

@EXPORT_OK = qw(
    autoflush
    output_field_separator
    output_record_separator
    input_record_separator
    input_line_number
    format_page_number
    format_lines_per_page
    format_lines_left
    format_name
    format_top_name
    format_line_break_characters
    format_formfeed
    format_write

    print
    printf
    say
    getline
    getlines

    printflush
    flush

    SEEK_SET
    SEEK_CUR
    SEEK_END
    _IOFBF
    _IOLBF
    _IONBF
);

################################################
## Constructors, destructors.
##

sub new {
    my $class = ref($_[0]) || $_[0] || "IO::Handle";
    if (@_ != 1) {
	# Since perl will automatically require IO::File if needed, but
	# also initialises IO::File's @ISA as part of the core we must
	# ensure IO::File is loaded if IO::Handle is. This avoids effect-
	# ively "half-loading" IO::File.
	if ($] > 5.013 && $class eq 'IO::File' && !$INC{"IO/File.pm"}) {
	    require IO::File;
	    shift;
	    return IO::File::->new(@_);
	}
	croak "usage: $class->new()";
    }
    my $io = gensym;
    bless $io, $class;
}

sub new_from_fd {
    my $class = ref($_[0]) || $_[0] || "IO::Handle";
    @_ == 3 or croak "usage: $class->new_from_fd(FD, MODE)";
    my $io = gensym;
    shift;
    IO::Handle::fdopen($io, @_)
	or return undef;
    bless $io, $class;
}

#
# There is no need for DESTROY to do anything, because when the
# last reference to an IO object is gone, Perl automatically
# closes its associated files (if any).  However, to avoid any
# attempts to autoload DESTROY, we here define it to do nothing.
#
sub DESTROY {}

################################################
## Open and close.
##

sub _open_mode_string {
    my ($mode) = @_;
    $mode =~ /^\+?(<|>>?)$/
      or $mode =~ s/^r(\+?)$/$1</
      or $mode =~ s/^w(\+?)$/$1>/
      or $mode =~ s/^a(\+?)$/$1>>/
      or croak "IO::Handle: bad open mode: $mode";
    $mode;
}

sub fdopen {
    @_ == 3 or croak 'usage: $io->fdopen(FD, MODE)';
    my ($io, $fd, $mode) = @_;
    local(*GLOB);

    if (ref($fd) && "".$fd =~ /GLOB\(/o) {
	# It's a glob reference; Alias it as we cannot get name of anon GLOBs
	my $n = qualify(*GLOB);
	*GLOB = *{*$fd};
	$fd =  $n;
    } elsif ($fd =~ m#^\d+$#) {
	# It's an FD number; prefix with "=".
	$fd = "=$fd";
    }

    open($io, _open_mode_string($mode) . '&' . $fd)
	? $io : undef;
}

sub close {
    @_ == 1 or croak 'usage: $io->close()';
    my($io) = @_;

    close($io);
}

################################################
## Normal I/O functions.
##

# flock
# select

sub opened {
    @_ == 1 or croak 'usage: $io->opened()';
    defined fileno($_[0]);
}

sub fileno {
    @_ == 1 or croak 'usage: $io->fileno()';
    fileno($_[0]);
}

sub getc {
    @_ == 1 or croak 'usage: $io->getc()';
    getc($_[0]);
}

sub eof {
    @_ == 1 or croak 'usage: $io->eof()';
    eof($_[0]);
}

sub print {
    @_ or croak 'usage: $io->print(ARGS)';
    my $this = shift;
    print $this @_;
}

sub printf {
    @_ >= 2 or croak 'usage: $io->printf(FMT,[ARGS])';
    my $this = shift;
    printf $this @_;
}

sub say {
    @_ or croak 'usage: $io->say(ARGS)';
    my $this = shift;
    local $\ = "\n";
    print $this @_;
}

# Special XS wrapper to make them inherit lexical hints from the caller.
_create_getline_subs( <<'END' ) or die $@;
sub getline {
    @_ == 1 or croak 'usage: $io->getline()';
    my $this = shift;
    return scalar <$this>;
} 

sub getlines {
    @_ == 1 or croak 'usage: $io->getlines()';
    wantarray or
	croak 'Can\'t call $io->getlines in a scalar context, use $io->getline';
    my $this = shift;
    return <$this>;
}
1; # return true for error checking
END

*gets = \&getline;  # deprecated

sub truncate {
    @_ == 2 or croak 'usage: $io->truncate(LEN)';
    truncate($_[0], $_[1]);
}

sub read {
    @_ == 3 || @_ == 4 or croak 'usage: $io->read(BUF, LEN [, OFFSET])';
    read($_[0], $_[1], $_[2], $_[3] || 0);
}

sub sysread {
    @_ == 3 || @_ == 4 or croak 'usage: $io->sysread(BUF, LEN [, OFFSET])';
    sysread($_[0], $_[1], $_[2], $_[3] || 0);
}

sub write {
    @_ >= 2 && @_ <= 4 or croak 'usage: $io->write(BUF [, LEN [, OFFSET]])';
    local($\) = "";
    $_[2] = length($_[1]) unless defined $_[2];
    print { $_[0] } substr($_[1], $_[3] || 0, $_[2]);
}

sub syswrite {
    @_ >= 2 && @_ <= 4 or croak 'usage: $io->syswrite(BUF [, LEN [, OFFSET]])';
    if (defined($_[2])) {
	syswrite($_[0], $_[1], $_[2], $_[3] || 0);
    } else {
	syswrite($_[0], $_[1]);
    }
}

sub stat {
    @_ == 1 or croak 'usage: $io->stat()';
    stat($_[0]);
}

################################################
## State modification functions.
##

sub autoflush {
    my $old = new SelectSaver qualify($_[0], caller);
    my $prev = $|;
    $| = @_ > 1 ? $_[1] : 1;
    $prev;
}

sub output_field_separator {
    carp "output_field_separator is not supported on a per-handle basis"
	if ref($_[0]);
    my $prev = $,;
    $, = $_[1] if @_ > 1;
    $prev;
}

sub output_record_separator {
    carp "output_record_separator is not supported on a per-handle basis"
	if ref($_[0]);
    my $prev = $\;
    $\ = $_[1] if @_ > 1;
    $prev;
}

sub input_record_separator {
    carp "input_record_separator is not supported on a per-handle basis"
	if ref($_[0]);
    my $prev = $/;
    $/ = $_[1] if @_ > 1;
    $prev;
}

sub input_line_number {
    local $.;
    () = tell qualify($_[0], caller) if ref($_[0]);
    my $prev = $.;
    $. = $_[1] if @_ > 1;
    $prev;
}

sub format_page_number {
    my $old;
    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);
    my $prev = $%;
    $% = $_[1] if @_ > 1;
    $prev;
}

sub format_lines_per_page {
    my $old;
    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);
    my $prev = $=;
    $= = $_[1] if @_ > 1;
    $prev;
}

sub format_lines_left {
    my $old;
    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);
    my $prev = $-;
    $- = $_[1] if @_ > 1;
    $prev;
}

sub format_name {
    my $old;
    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);
    my $prev = $~;
    $~ = qualify($_[1], caller) if @_ > 1;
    $prev;
}

sub format_top_name {
    my $old;
    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);
    my $prev = $^;
    $^ = qualify($_[1], caller) if @_ > 1;
    $prev;
}

sub format_line_break_characters {
    carp "format_line_break_characters is not supported on a per-handle basis"
	if ref($_[0]);
    my $prev = $:;
    $: = $_[1] if @_ > 1;
    $prev;
}

sub format_formfeed {
    carp "format_formfeed is not supported on a per-handle basis"
	if ref($_[0]);
    my $prev = $^L;
    $^L = $_[1] if @_ > 1;
    $prev;
}

sub formline {
    my $io = shift;
    my $picture = shift;
    local($^A) = $^A;
    local($\) = "";
    formline($picture, @_);
    print $io $^A;
}

sub format_write {
    @_ < 3 || croak 'usage: $io->write( [FORMAT_NAME] )';
    if (@_ == 2) {
	my ($io, $fmt) = @_;
	my $oldfmt = $io->format_name(qualify($fmt,caller));
	CORE::write($io);
	$io->format_name($oldfmt);
    } else {
	CORE::write($_[0]);
    }
}

sub fcntl {
    @_ == 3 || croak 'usage: $io->fcntl( OP, VALUE );';
    my ($io, $op) = @_;
    return fcntl($io, $op, $_[2]);
}

sub ioctl {
    @_ == 3 || croak 'usage: $io->ioctl( OP, VALUE );';
    my ($io, $op) = @_;
    return ioctl($io, $op, $_[2]);
}

# this sub is for compatibility with older releases of IO that used
# a sub called constant to determine if a constant existed -- GMB
#
# The SEEK_* and _IO?BF constants were the only constants at that time
# any new code should just check defined(&CONSTANT_NAME)

sub constant {
    no strict 'refs';
    my $name = shift;
    (($name =~ /^(SEEK_(SET|CUR|END)|_IO[FLN]BF)$/) && defined &{$name})
	? &{$name}() : undef;
}

# so that flush.pl can be deprecated

sub printflush {
    my $io = shift;
    my $old;
    $old = new SelectSaver qualify($io, caller) if ref($io);
    local $| = 1;
    if(ref($io)) {
        print $io @_;
    }
    else {
	print @_;
    }
}

1;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     # IO::Pipe.pm
#
# Copyright (c) 1996-8 Graham Barr <gbarr@pobox.com>. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.

package IO::Pipe;

use 5.006_001;

use IO::Handle;
use strict;
our($VERSION);
use Carp;
use Symbol;

$VERSION = "1.15";

sub new {
    my $type = shift;
    my $class = ref($type) || $type || "IO::Pipe";
    @_ == 0 || @_ == 2 or croak "usage: $class->([READFH, WRITEFH])";

    my $me = bless gensym(), $class;

    my($readfh,$writefh) = @_ ? @_ : $me->handles;

    pipe($readfh, $writefh)
	or return undef;

    @{*$me} = ($readfh, $writefh);

    $me;
}

sub handles {
    @_ == 1 or croak 'usage: $pipe->handles()';
    (IO::Pipe::End->new(), IO::Pipe::End->new());
}

my $do_spawn = $^O eq 'os2' || $^O eq 'MSWin32';

sub _doit {
    my $me = shift;
    my $rw = shift;

    my $pid = $do_spawn ? 0 : fork();

    if($pid) { # Parent
        return $pid;
    }
    elsif(defined $pid) { # Child or spawn
        my $fh;
        my $io = $rw ? \*STDIN : \*STDOUT;
        my ($mode, $save) = $rw ? "r" : "w";
        if ($do_spawn) {
          require Fcntl;
          $save = IO::Handle->new_from_fd($io, $mode);
	  my $handle = shift;
          # Close in child:
	  unless ($^O eq 'MSWin32') {
            fcntl($handle, Fcntl::F_SETFD(), 1) or croak "fcntl: $!";
	  }
          $fh = $rw ? ${*$me}[0] : ${*$me}[1];
        } else {
          shift;
          $fh = $rw ? $me->reader() : $me->writer(); # close the other end
        }
        bless $io, "IO::Handle";
        $io->fdopen($fh, $mode);
	$fh->close;

        if ($do_spawn) {
          $pid = eval { system 1, @_ }; # 1 == P_NOWAIT
          my $err = $!;
    
          $io->fdopen($save, $mode);
          $save->close or croak "Cannot close $!";
          croak "IO::Pipe: Cannot spawn-NOWAIT: $err" if not $pid or $pid < 0;
          return $pid;
        } else {
          exec @_ or
            croak "IO::Pipe: Cannot exec: $!";
        }
    }
    else {
        croak "IO::Pipe: Cannot fork: $!";
    }

    # NOT Reached
}

sub reader {
    @_ >= 1 or croak 'usage: $pipe->reader( [SUB_COMMAND_ARGS] )';
    my $me = shift;

    return undef
	unless(ref($me) || ref($me = $me->new));

    my $fh  = ${*$me}[0];
    my $pid;
    $pid = $me->_doit(0, $fh, @_)
        if(@_);

    close ${*$me}[1];
    bless $me, ref($fh);
    *$me = *$fh;          # Alias self to handle
    $me->fdopen($fh->fileno,"r")
	unless defined($me->fileno);
    bless $fh;                  # Really wan't un-bless here
    ${*$me}{'io_pipe_pid'} = $pid
        if defined $pid;

    $me;
}

sub writer {
    @_ >= 1 or croak 'usage: $pipe->writer( [SUB_COMMAND_ARGS] )';
    my $me = shift;

    return undef
	unless(ref($me) || ref($me = $me->new));

    my $fh  = ${*$me}[1];
    my $pid;
    $pid = $me->_doit(1, $fh, @_)
        if(@_);

    close ${*$me}[0];
    bless $me, ref($fh);
    *$me = *$fh;          # Alias self to handle
    $me->fdopen($fh->fileno,"w")
	unless defined($me->fileno);
    bless $fh;                  # Really wan't un-bless here
    ${*$me}{'io_pipe_pid'} = $pid
        if defined $pid;

    $me;
}

package IO::Pipe::End;

our(@ISA);

@ISA = qw(IO::Handle);

sub close {
    my $fh = shift;
    my $r = $fh->SUPER::close(@_);

    waitpid(${*$fh}{'io_pipe_pid'},0)
	if(defined ${*$fh}{'io_pipe_pid'});

    $r;
}

1;

__END__

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               package Hash::Util::FieldHash;

use 5.009004;
use strict;
use warnings;
use Scalar::Util qw( reftype);

our $VERSION = '1.19';

require Exporter;
our @ISA = qw(Exporter);
our %EXPORT_TAGS = (
    'all' => [ qw(
        fieldhash
        fieldhashes
        idhash
        idhashes
        id
        id_2obj
        register
    )],
);
our @EXPORT_OK = ( @{ $EXPORT_TAGS{'all'} } );

{
    require XSLoader;
    my %ob_reg; # private object registry
    sub _ob_reg { \ %ob_reg }
    XSLoader::load();
}

sub fieldhash (\%) {
    for ( shift ) {
        return unless ref() && reftype( $_) eq 'HASH';
        return $_ if Hash::Util::FieldHash::_fieldhash( $_, 0);
        return $_ if Hash::Util::FieldHash::_fieldhash( $_, 2) == 2;
        return;
    }
}

sub idhash (\%) {
    for ( shift ) {
        return unless ref() && reftype( $_) eq 'HASH';
        return $_ if Hash::Util::FieldHash::_fieldhash( $_, 0);
        return $_ if Hash::Util::FieldHash::_fieldhash( $_, 1) == 1;
        return;
    }
}

sub fieldhashes { map &fieldhash( $_), @_ }
sub idhashes { map &idhash( $_), @_ }

1;
__END__

=head1 NAME

Hash::Util::FieldHash - Support for Inside-Out Classes

=head1 SYNOPSIS

  ### Create fieldhashes
  use Hash::Util qw(fieldhash fieldhashes);

  # Create a single field hash
  fieldhash my %foo;

  # Create three at once...
  fieldhashes \ my(%foo, %bar, %baz);
  # ...or any number
  fieldhashes @hashrefs;

  ### Create an idhash and register it for garbage collection
  use Hash::Util::FieldHash qw(idhash register);
  idhash my %name;
  my $object = \ do { my $o };
  # register the idhash for garbage collection with $object
  register($object, \ %name);
  # the following entry will be deleted when $object goes out of scope
  $name{$object} = 'John Doe';

  ### Register an ordinary hash for garbage collection
  use Hash::Util::FieldHash qw(id register);
  my %name;
  my $object = \ do { my $o };
  # register the hash %name for garbage collection of $object's id
  register $object, \ %name;
  # the following entry will be deleted when $object goes out of scope
  $name{id $object} = 'John Doe';

=head1 FUNCTIONS

C<Hash::Util::FieldHash> offers a number of functions in support of
L<The Inside-out Technique> of class construction.

=over

=item id

    id($obj)

Returns the reference address of a reference $obj.  If $obj is
not a reference, returns $obj.

This function is a stand-in replacement for
L<Scalar::Util::refaddr|Scalar::Util/refaddr>,
that is, it returns
the reference address of its argument as a numeric value.  The only
difference is that C<refaddr()> returns C<undef> when given a
non-reference while C<id()> returns its argument unchanged.

C<id()> also uses a caching technique that makes it faster when
the id of an object is requested often, but slower if it is needed
only once or twice.

=item id_2obj

    $obj = id_2obj($id)

If C<$id> is the id of a registered object (see L</register>), returns
the object, otherwise an undefined value.  For registered objects this
is the inverse function of C<id()>.

=item register

    register($obj)
    register($obj, @hashrefs)

In the first form, registers an object to work with for the function
C<id_2obj()>.  In the second form, it additionally marks the given
hashrefs down for garbage collection.  This means that when the object
goes out of scope, any entries in the given hashes under the key of
C<id($obj)> will be deleted from the hashes.

It is a fatal error to register a non-reference $obj.  Any non-hashrefs
among the following arguments are silently ignored.

It is I<not> an error to register the same object multiple times with
varying sets of hashrefs.  Any hashrefs that are not registered yet
will be added, others ignored.

Registry also implies thread support.  When a new thread is created,
all references are replaced with new ones, including all objects.
If a hash uses the reference address of an object as a key, that
connection would be broken.  With a registered object, its id will
be updated in all hashes registered with it.

=item idhash

    idhash my %hash

Makes an idhash from the argument, which must be a hash.

An I<idhash> works like a normal hash, except that it stringifies a
I<reference used as a key> differently.  A reference is stringified
as if the C<id()> function had been invoked on it, that is, its
reference address in decimal is used as the key.

=item idhashes

    idhashes \ my(%hash, %gnash, %trash)
    idhashes \ @hashrefs

Creates many idhashes from its hashref arguments.  Returns those
arguments that could be converted or their number in scalar context.

=item fieldhash

    fieldhash %hash;

Creates a single fieldhash.  The argument must be a hash.  Returns
a reference to the given hash if successful, otherwise nothing.

A I<fieldhash> is, in short, an idhash with auto-registry.  When an
object (or, indeed, any reference) is used as a fieldhash key, the
fieldhash is automatically registered for garbage collection with
the object, as if C<register $obj, \ %fieldhash> had been called.

=item fieldhashes

    fieldhashes @hashrefs;

Creates any number of field hashes.  Arguments must be hash references.
Returns the converted hashrefs in list context, their number in scalar
context.

=back

=head1 DESCRIPTION

A word on terminology:  I shall use the term I<field> for a scalar
piece of data that a class associates with an object.  Other terms that
have been used for this concept are "object variable", "(object) property",
"(object) attribute" and more.  Especially "attribute" has some currency
among Perl programmer, but that clashes with the C<attributes> pragma.  The
term "field" also has some currency in this sense and doesn't seem
to conflict with other Perl terminology.

In Perl, an object is a blessed reference.  The standard way of associating
data with an object is to store the data inside the object's body, that is,
the piece of data pointed to by the reference.

In consequence, if two or more classes want to access an object they
I<must> agree on the type of reference and also on the organization of
data within the object body.  Failure to agree on the type results in
immediate death when the wrong method tries to access an object.  Failure
to agree on data organization may lead to one class trampling over the
data of another.

This object model leads to a tight coupling between subclasses.
If one class wants to inherit from another (and both classes access
object data), the classes must agree about implementation details.
Inheritance can only be used among classes that are maintained together,
in a single source or not.

In particular, it is not possible to write general-purpose classes
in this technique, classes that can advertise themselves as "Put me
on your @ISA list and use my methods".  If the other class has different
ideas about how the object body is used, there is trouble.

For reference C<Name_hash> in L</Example 1> shows the standard implementation of
a simple class C<Name> in the well-known hash based way.  It also demonstrates
the predictable failure to construct a common subclass C<NamedFile>
of C<Name> and the class C<IO::File> (whose objects I<must> be globrefs).

Thus, techniques are of interest that store object data I<not> in
the object body but some other place.

=head2 The Inside-out Technique

With I<inside-out> classes, each class declares a (typically lexical)
hash for each field it wants to use.  The reference address of an
object is used as the hash key.  By definition, the reference address
is unique to each object so this guarantees a place for each field that
is private to the class and unique to each object.  See C<Name_id>
in L</Example 1> for a simple example.

In comparison to the standard implementation where the object is a
hash and the fields correspond to hash keys, here the fields correspond
to hashes, and the object determines the hash key.  Thus the hashes
appear to be turned I<inside out>.

The body of an object is never examined by an inside-out class, only
its reference address is used.  This allows for the body of an actual
object to be I<anything at all> while the object methods of the class
still work as designed.  This is a key feature of inside-out classes.

=head2 Problems of Inside-out

Inside-out classes give us freedom of inheritance, but as usual there
is a price.

Most obviously, there is the necessity of retrieving the reference
address of an object for each data access.  It's a minor inconvenience,
but it does clutter the code.

More important (and less obvious) is the necessity of garbage
collection.  When a normal object dies, anything stored in the
object body is garbage-collected by perl.  With inside-out objects,
Perl knows nothing about the data stored in field hashes by a class,
but these must be deleted when the object goes out of scope.  Thus
the class must provide a C<DESTROY> method to take care of that.

In the presence of multiple classes it can be non-trivial
to make sure that every relevant destructor is called for
every object.  Perl calls the first one it finds on the
inheritance tree (if any) and that's it.

A related issue is thread-safety.  When a new thread is created,
the Perl interpreter is cloned, which implies that all reference
addresses in use will be replaced with new ones.  Thus, if a class
tries to access a field of a cloned object its (cloned) data will
still be stored under the now invalid reference address of the
original in the parent thread.  A general C<CLONE> method must
be provided to re-establish the association.

=head2 Solutions

C<Hash::Util::FieldHash> addresses these issues on several
levels.

The C<id()> function is provided in addition to the
existing C<Scalar::Util::refaddr()>.  Besides its short name
it can be a little faster under some circumstances (and a
bit slower under others).  Benchmark if it matters.  The
working of C<id()> also allows the use of the class name
as a I<generic object> as described L<further down|/"The Generic Object">.

The C<id()> function is incorporated in I<id hashes> in the sense
that it is called automatically on every key that is used with
the hash.  No explicit call is necessary.

The problems of garbage collection and thread safety are both
addressed by the function C<register()>.  It registers an object
together with any number of hashes.  Registry means that when the
object dies, an entry in any of the hashes under the reference
address of this object will be deleted.  This guarantees garbage
collection in these hashes.  It also means that on thread
cloning the object's entries in registered hashes will be
replaced with updated entries whose key is the cloned object's
reference address.  Thus the object-data association becomes
thread-safe.

Object registry is best done when the object is initialized
for use with a class.  That way, garbage collection and thread
safety are established for every object and every field that is
initialized.

Finally, I<field hashes> incorporate all these functions in one
package.  Besides automatically calling the C<id()> function
on every object used as a key, the object is registered with
the field hash on first use.  Classes based on field hashes
are fully garbage-collected and thread safe without further
measures.

=head2 More Problems

Another problem that occurs with inside-out classes is serialization.
Since the object data is not in its usual place, standard routines
like C<Storable::freeze()>, C<Storable::thaw()> and 
C<Data::Dumper::Dumper()> can't deal with it on their own.  Both
C<Data::Dumper> and C<Storable> provide the necessary hooks to
make things work, but the functions or methods used by the hooks
must be provided by each inside-out class.

A general solution to the serialization problem would require another
level of registry, one that associates I<classes> and fields.
So far, the functions of C<Hash::Util::FieldHash> are unaware of
any classes, which I consider a feature.  Therefore C<Hash::Util::FieldHash>
doesn't address the serialization problems.

=head2 The Generic Object

Classes based on the C<id()> function (and hence classes based on
C<idhash()> and C<fieldhash()>) show a peculiar behavior in that
the class name can be used like an object.  Specifically, methods
that set or read data associated with an object continue to work as
class methods, just as if the class name were an object, distinct from
all other objects, with its own data.  This object may be called
the I<generic object> of the class.

This works because field hashes respond to keys that are not references
like a normal hash would and use the string offered as the hash key.
Thus, if a method is called as a class method, the field hash is presented
with the class name instead of an object and blithely uses it as a key.
Since the keys of real objects are decimal numbers, there is no
conflict and the slot in the field hash can be used like any other.
The C<id()> function behaves correspondingly with respect to non-reference
arguments.

Two possible uses (besides ignoring the property) come to mind.
A singleton class could be implemented this using the generic object.
If necessary, an C<init()> method could die or ignore calls with
actual objects (references), so only the generic object will ever exist.

Another use of the generic object would be as a template.  It is
a convenient place to store class-specific defaults for various
fields to be used in actual object initialization.

Usually, the feature can be entirely ignored.  Calling I<object
methods> as I<class methods> normally leads to an error and isn't used
routinely anywhere.  It may be a problem that this error isn't
indicated by a class with a generic object.

=head2 How to use Field Hashes

Traditionally, the definition of an inside-out class contains a bare
block inside which a number of lexical hashes are declared and the
basic accessor methods defined, usually through C<Scalar::Util::refaddr>.
Further methods may be defined outside this block.  There has to be
a DESTROY method and, for thread support, a CLONE method.

When field hashes are used, the basic structure remains the same.
Each lexical hash will be made a field hash.  The call to C<refaddr>
can be omitted from the accessor methods.  DESTROY and CLONE methods
are not necessary.

If you have an existing inside-out class, simply making all hashes
field hashes with no other change should make no difference.  Through
the calls to C<refaddr> or equivalent, the field hashes never get to
see a reference and work like normal hashes.  Your DESTROY (and
CLONE) methods are still needed.

To make the field hashes kick in, it is easiest to redefine C<refaddr>
as

    sub refaddr { shift }

instead of importing it from C<Scalar::Util>.  It should now be possible
to disable DESTROY and CLONE.  Note that while it isn't disabled,
DESTROY will be called before the garbage collection of field hashes,
so it will be invoked with a functional object and will continue to
function.

It is not desirable to import the functions C<fieldhash> and/or
C<fieldhashes> into every class that is going to use them.  They
are only used once to set up the class.  When the class is up and running,
these functions serve no more purpose.

If there are only a few field hashes to declare, it is simplest to

    use Hash::Util::FieldHash;

early and call the functions qualified:

    Hash::Util::FieldHash::fieldhash my %foo;

Otherwise, import the functions into a convenient package like
C<HUF> or, more general, C<Aux>

    {
        package Aux;
        use Hash::Util::FieldHash ':all';
    }

and call

    Aux::fieldhash my %foo;

as needed.

=head2 Garbage-Collected Hashes

Garbage collection in a field hash means that entries will "spontaneously"
disappear when the object that created them disappears.  That must be
borne in mind, especially when looping over a field hash.  If anything
you do inside the loop could cause an object to go out of scope, a
random key may be deleted from the hash you are looping over.  That
can throw the loop iterator, so it's best to cache a consistent snapshot
of the keys and/or values and loop over that.  You will still have to
check that a cached entry still exists when you get to it.

Garbage collection can be confusing when keys are created in a field hash
from normal scalars as well as references.  Once a reference is I<used> with
a field hash, the entry will be collected, even if it was later overwritten
with a plain scalar key (every positive integer is a candidate).  This
is true even if the original entry was deleted in the meantime.  In fact,
deletion from a field hash, and also a test for existence constitute
I<use> in this sense and create a liability to delete the entry when
the reference goes out of scope.  If you happen to create an entry
with an identical key from a string or integer, that will be collected
instead.  Thus, mixed use of references and plain scalars as field hash
keys is not entirely supported.

=head1 EXAMPLES

The examples show a very simple class that implements a I<name>, consisting
of a first and last name (no middle initial).  The name class has four
methods:

=over

=item * C<init()>

An object method that initializes the first and last name to its
two arguments. If called as a class method, C<init()> creates an
object in the given class and initializes that.

=item * C<first()>

Retrieve the first name

=item * C<last()>

Retrieve the last name

=item * C<name()>

Retrieve the full name, the first and last name joined by a blank.

=back

The examples show this class implemented with different levels of
support by C<Hash::Util::FieldHash>.  All supported combinations
are shown.  The difference between implementations is often quite
small.  The implementations are:

=over

=item * C<Name_hash>

A conventional (not inside-out) implementation where an object is
a hash that stores the field values, without support by
C<Hash::Util::FieldHash>.  This implementation doesn't allow
arbitrary inheritance.

=item * C<Name_id>

Inside-out implementation based on the C<id()> function.  It needs
a C<DESTROY> method.  For thread support a C<CLONE> method (not shown)
would also be needed.  Instead of C<Hash::Util::FieldHash::id()> the
function C<Scalar::Util::refaddr> could be used with very little
functional difference.  This is the basic pattern of an inside-out
class.

=item * C<Name_idhash>

Idhash-based inside-out implementation.  Like C<Name_id> it needs
a C<DESTROY> method and would need C<CLONE> for thread support.

=item * C<Name_id_reg>

Inside-out implementation based on the C<id()> function with explicit
object registry.  No destructor is needed and objects are thread safe.

=item * C<Name_idhash_reg>

Idhash-based inside-out implementation with explicit object registry.
No destructor is needed and objects are thread safe.

=item * C<Name_fieldhash>

FieldHash-based inside-out implementation.  Object registry happens
automatically.  No destructor is needed and objects are thread safe.

=back

These examples are realized in the code below, which could be copied
to a file F<Example.pm>.

=head2 Example 1

    use strict; use warnings;

    {
        package Name_hash;  # standard implementation: the
                            # object is a hash
        sub init {
            my $obj = shift;
            my ($first, $last) = @_;
            # create an object if called as class method
            $obj = bless {}, $obj unless ref $obj;
            $obj->{ first} = $first;
            $obj->{ last} = $last;
            $obj;
        }

        sub first { shift()->{ first} }
        sub last { shift()->{ last} }

        sub name {
            my $n = shift;
            join ' ' => $n->first, $n->last;
        }

    }

    {
        package Name_id;
        use Hash::Util::FieldHash qw(id);

        my (%first, %last);

        sub init {
            my $obj = shift;
            my ($first, $last) = @_;
            # create an object if called as class method
            $obj = bless \ my $o, $obj unless ref $obj;
            $first{ id $obj} = $first;
            $last{ id $obj} = $last;
            $obj;
        }

        sub first { $first{ id shift()} }
        sub last { $last{ id shift()} }

        sub name {
            my $n = shift;
            join ' ' => $n->first, $n->last;
        }

        sub DESTROY {
            my $id = id shift;
            delete $first{ $id};
            delete $last{ $id};
        }

    }

    {
        package Name_idhash;
        use Hash::Util::FieldHash;

        Hash::Util::FieldHash::idhashes( \ my (%first, %last) );

        sub init {
            my $obj = shift;
            my ($first, $last) = @_;
            # create an object if called as class method
            $obj = bless \ my $o, $obj unless ref $obj;
            $first{ $obj} = $first;
            $last{ $obj} = $last;
            $obj;
        }

        sub first { $first{ shift()} }
        sub last { $last{ shift()} }

        sub name {
            my $n = shift;
            join ' ' => $n->first, $n->last;
        }

        sub DESTROY {
            my $n = shift;
            delete $first{ $n};
            delete $last{ $n};
        }

    }

    {
        package Name_id_reg;
        use Hash::Util::FieldHash qw(id register);

        my (%first, %last);

        sub init {
            my $obj = shift;
            my ($first, $last) = @_;
            # create an object if called as class method
            $obj = bless \ my $o, $obj unless ref $obj;
            register( $obj, \ (%first, %last) );
            $first{ id $obj} = $first;
            $last{ id $obj} = $last;
            $obj;
        }

        sub first { $first{ id shift()} }
        sub last { $last{ id shift()} }

        sub name {
            my $n = shift;
            join ' ' => $n->first, $n->last;
        }
    }

    {
        package Name_idhash_reg;
        use Hash::Util::FieldHash qw(register);

        Hash::Util::FieldHash::idhashes \ my (%first, %last);

        sub init {
            my $obj = shift;
            my ($first, $last) = @_;
            # create an object if called as class method
            $obj = bless \ my $o, $obj unless ref $obj;
            register( $obj, \ (%first, %last) );
            $first{ $obj} = $first;
            $last{ $obj} = $last;
            $obj;
        }

        sub first { $first{ shift()} }
        sub last { $last{ shift()} }

        sub name {
            my $n = shift;
            join ' ' => $n->first, $n->last;
        }
    }

    {
        package Name_fieldhash;
        use Hash::Util::FieldHash;

        Hash::Util::FieldHash::fieldhashes \ my (%first, %last);

        sub init {
            my $obj = shift;
            my ($first, $last) = @_;
            # create an object if called as class method
            $obj = bless \ my $o, $obj unless ref $obj;
            $first{ $obj} = $first;
            $last{ $obj} = $last;
            $obj;
        }

        sub first { $first{ shift()} }
        sub last { $last{ shift()} }

        sub name {
            my $n = shift;
            join ' ' => $n->first, $n->last;
        }
    }

    1;

To exercise the various implementations the script L<below|/"Example 2"> can
be used.

It sets up a class C<Name> that is a mirror of one of the implementation
classes C<Name_hash>, C<Name_id>, ..., C<Name_fieldhash>.  That determines
which implementation is run.

The script first verifies the function of the C<Name> class.

In the second step, the free inheritability of the implementation
(or lack thereof) is demonstrated.  For this purpose it constructs
a class called C<NamedFile> which is a common subclass of C<Name> and
the standard class C<IO::File>.  This puts inheritability to the test
because objects of C<IO::File> I<must> be globrefs.  Objects of C<NamedFile>
should behave like a file opened for reading and also support the C<name()>
method.  This class juncture works with exception of the C<Name_hash>
implementation, where object initialization fails because of the
incompatibility of object bodies.

=head2 Example 2

    use strict; use warnings; $| = 1;

    use Example;

    {
        package Name;
        use parent 'Name_id';  # define here which implementation to run
    }


    # Verify that the base package works
    my $n = Name->init(qw(Albert Einstein));
    print $n->name, "\n";
    print "\n";

    # Create a named file handle (See definition below)
    my $nf = NamedFile->init(qw(/tmp/x Filomena File));
    # use as a file handle...
    for ( 1 .. 3 ) {
        my $l = <$nf>;
        print "line $_: $l";
    }
    # ...and as a Name object
    print "...brought to you by ", $nf->name, "\n";
    exit;


    # Definition of NamedFile
    package NamedFile;
    use parent 'Name';
    use parent 'IO::File';

    sub init {
        my $obj = shift;
        my ($file, $first, $last) = @_;
        $obj = $obj->IO::File::new() unless ref $obj;
        $obj->open($file) or die "Can't read '$file': $!";
        $obj->Name::init($first, $last);
    }
    __END__


=head1 GUTS

To make C<Hash::Util::FieldHash> work, there were two changes to
F<perl> itself.  C<PERL_MAGIC_uvar> was made available for hashes,
and weak references now call uvar C<get> magic after a weakref has been
cleared.  The first feature is used to make field hashes intercept
their keys upon access.  The second one triggers garbage collection.

=head2 The C<PERL_MAGIC_uvar> interface for hashes

C<PERL_MAGIC_uvar> I<get> magic is called from C<hv_fetch_common> and
C<hv_delete_common> through the function C<hv_magic_uvar_xkey>, which
defines the interface.  The call happens for hashes with "uvar" magic
if the C<ufuncs> structure has equal values in the C<uf_val> and C<uf_set>
fields.  Hashes are unaffected if (and as long as) these fields
hold different values.

Upon the call, the C<mg_obj> field will hold the hash key to be accessed.
Upon return, the C<SV*> value in C<mg_obj> will be used in place of the
original key in the hash access.  The integer index value in the first
parameter will be the C<action> value from C<hv_fetch_common>, or -1
if the call is from C<hv_delete_common>.

This is a template for a function suitable for the C<uf_val> field in
a C<ufuncs> structure for this call.  The C<uf_set> and C<uf_index>
fields are irrelevant.

    IV watch_key(pTHX_ IV action, SV* field) {
        MAGIC* mg = mg_find(field, PERL_MAGIC_uvar);
        SV* keysv = mg->mg_obj;
        /* Do whatever you need to.  If you decide to
           supply a different key newkey, return it like this
        */
        sv_2mortal(newkey);
        mg->mg_obj = newkey;
        return 0;
    }

=head2 Weakrefs call uvar magic

When a weak reference is stored in an C<SV> that has "uvar" magic, C<set>
magic is called after the reference has gone stale.  This hook can be
used to trigger further garbage-collection activities associated with
the referenced object.

=head2 How field hashes work

The three features of key hashes, I<key replacement>, I<thread support>,
and I<garbage collection> are supported by a data structure called
the I<object registry>.  This is a private hash where every object
is stored.  An "object" in this sense is any reference (blessed or
unblessed) that has been used as a field hash key.

The object registry keeps track of references that have been used as
field hash keys.  The keys are generated from the reference address
like in a field hash (though the registry isn't a field hash).  Each
value is a weak copy of the original reference, stored in an C<SV> that
is itself magical (C<PERL_MAGIC_uvar> again).  The magical structure
holds a list (another hash, really) of field hashes that the reference
has been used with.  When the weakref becomes stale, the magic is
activated and uses the list to delete the reference from all field
hashes it has been used with.  After that, the entry is removed from
the object registry itself.  Implicitly, that frees the magic structure
and the storage it has been using.

Whenever a reference is used as a field hash key, the object registry
is checked and a new entry is made if necessary.  The field hash is
then added to the list of fields this reference has used.

The object registry is also used to repair a field hash after thread
cloning.  Here, the entire object registry is processed.  For every
reference found there, the field hashes it has used are visited and
the entry is updated.

=head2 Internal function Hash::Util::FieldHash::_fieldhash

    # test if %hash is a field hash
    my $result = _fieldhash \ %hash, 0;

    # make %hash a field hash
    my $result = _fieldhash \ %hash, 1;

C<_fieldhash> is the internal function used to create field hashes.
It takes two arguments, a hashref and a mode.  If the mode is boolean
false, the hash is not changed but tested if it is a field hash.  If
the hash isn't a field hash the return value is boolean false.  If it
is, the return value indicates the mode of field hash.  When called with
a boolean true mode, it turns the given hash into a field hash of this
mode, returning the mode of the created field hash.  C<_fieldhash>
does not erase the given hash.

Currently there is only one type of field hash, and only the boolean
value of the mode makes a difference, but that may change.

=head1 AUTHOR

Anno Siegel (ANNO) wrote the xs code and the changes in perl proper
Jerry Hedden (JDHEDDEN) made it faster

=head1 COPYRIGHT AND LICENSE

Copyright (C) 2006-2007 by (Anno Siegel)

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.7 or,
at your option, any later version of Perl 5 you may have available.

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
# IO::Poll.pm
#
# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.

package IO::Poll;

use strict;
use IO::Handle;
use Exporter ();
our(@ISA, @EXPORT_OK, @EXPORT, $VERSION);

@ISA = qw(Exporter);
$VERSION = "0.10";

@EXPORT = qw( POLLIN
	      POLLOUT
	      POLLERR
	      POLLHUP
	      POLLNVAL
	    );

@EXPORT_OK = qw(
 POLLPRI   
 POLLRDNORM
 POLLWRNORM
 POLLRDBAND
 POLLWRBAND
 POLLNORM  
	       );

# [0] maps fd's to requested masks
# [1] maps fd's to returned  masks
# [2] maps fd's to handles
sub new {
    my $class = shift;

    my $self = bless [{},{},{}], $class;

    $self;
}

sub mask {
    my $self = shift;
    my $io = shift;
    my $fd = fileno($io);
    return unless defined $fd;
    if (@_) {
	my $mask = shift;
	if($mask) {
	  $self->[0]{$fd}{$io} = $mask; # the error events are always returned
	  $self->[1]{$fd}      = 0;     # output mask
	  $self->[2]{$io}      = $io;   # remember handle
	} else {
          delete $self->[0]{$fd}{$io};
          unless(%{$self->[0]{$fd}}) {
            # We no longer have any handles for this FD
            delete $self->[1]{$fd};
            delete $self->[0]{$fd};
          }
          delete $self->[2]{$io};
	}
    }
    
    return unless exists $self->[0]{$fd} and exists $self->[0]{$fd}{$io};
	return $self->[0]{$fd}{$io};
}


sub poll {
    my($self,$timeout) = @_;

    $self->[1] = {};

    my($fd,$mask,$iom);
    my @poll = ();

    while(($fd,$iom) = each %{$self->[0]}) {
	$mask   = 0;
	$mask  |= $_ for values(%$iom);
	push(@poll,$fd => $mask);
    }

    my $ret = _poll(defined($timeout) ? $timeout * 1000 : -1,@poll);

    return $ret
	unless $ret > 0;

    while(@poll) {
	my($fd,$got) = splice(@poll,0,2);
	$self->[1]{$fd} = $got if $got;
    }

    return $ret;  
}

sub events {
    my $self = shift;
    my $io = shift;
    my $fd = fileno($io);
    exists $self->[1]{$fd} and exists $self->[0]{$fd}{$io} 
                ? $self->[1]{$fd} & ($self->[0]{$fd}{$io}|POLLHUP|POLLERR|POLLNVAL)
	: 0;
}

sub remove {
    my $self = shift;
    my $io = shift;
    $self->mask($io,0);
}

sub handles {
    my $self = shift;
    return values %{$self->[2]} unless @_;

    my $events = shift || 0;
    my($fd,$ev,$io,$mask);
    my @handles = ();

    while(($fd,$ev) = each %{$self->[1]}) {
	while (($io,$mask) = each %{$self->[0]{$fd}}) {
	    $mask |= POLLHUP|POLLERR|POLLNVAL;  # must allow these
	    push @handles,$self->[2]{$io} if ($ev & $mask) & $events;
	}
    }
    return @handles;
}

1;

__END__

=head1 NAME

IO::Poll - Object interface to system poll call

=head1 SYNOPSIS

    use IO::Poll qw(POLLRDNORM POLLWRNORM POLLIN POLLHUP);

    $poll = IO::Poll->new();

    $poll->mask($input_handle => POLLIN);
    $poll->mask($output_handle => POLLOUT);

    $poll->poll($timeout);

    $ev = $poll->events($input);

=head1 DESCRIPTION

C<IO::Poll> is a simple interface to the system level poll routine.

=head1 METHODS

=over 4

=item mask ( IO [, EVENT_MASK ] )

If EVENT_MASK is given, then, if EVENT_MASK is non-zero, IO is added to the
list of file descriptors and the next call to poll will check for
any event specified in EVENT_MASK. If EVENT_MASK is zero then IO will be
removed from the list of file descriptors.

If EVENT_MASK is not given then the return value will be the current
event mask value for IO.

=item poll ( [ TIMEOUT ] )

Call the system level poll routine. If TIMEOUT is not specified then the
call will block. Returns the number of handles which had events
happen, or -1 on error.

=item events ( IO )

Returns the event mask which represents the events that happened on IO
during the last call to C<poll>.

=item remove ( IO )

Remove IO from the list of file descriptors for the next poll.

=item handles( [ EVENT_MASK ] )

Returns a list of handles. If EVENT_MASK is not given then a list of all
handles known will be returned. If EVENT_MASK is given then a list
of handles will be returned which had one of the events specified by
EVENT_MASK happen during the last call ti C<poll>

=back

=head1 SEE ALSO

L<poll(2)>, L<IO::Handle>, L<IO::Select>

=head1 AUTHOR

Graham Barr. Currently maintained by the Perl Porters.  Please report all
bugs to <perlbug@perl.org>.

=head1 COPYRIGHT

Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     #

package IO::Seekable;

use 5.006_001;
use Carp;
use strict;
our($VERSION, @EXPORT, @ISA);
use IO::Handle ();
# XXX we can't get these from IO::Handle or we'll get prototype
# mismatch warnings on C<use POSIX; use IO::File;> :-(
use Fcntl qw(SEEK_SET SEEK_CUR SEEK_END);
require Exporter;

@EXPORT = qw(SEEK_SET SEEK_CUR SEEK_END);
@ISA = qw(Exporter);

$VERSION = "1.10";
$VERSION = eval $VERSION;

sub seek {
    @_ == 3 or croak 'usage: $io->seek(POS, WHENCE)';
    seek($_[0], $_[1], $_[2]);
}

sub sysseek {
    @_ == 3 or croak 'usage: $io->sysseek(POS, WHENCE)';
    sysseek($_[0], $_[1], $_[2]);
}

sub tell {
    @_ == 1 or croak 'usage: $io->tell()';
    tell($_[0]);
}

1;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  # IO::Socket::UNIX.pm
#
# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.

package IO::Socket::UNIX;

use strict;
our(@ISA, $VERSION);
use IO::Socket;
use Carp;

@ISA = qw(IO::Socket);
$VERSION = "1.26";
$VERSION = eval $VERSION;

IO::Socket::UNIX->register_domain( AF_UNIX );

sub new {
    my $class = shift;
    unshift(@_, "Peer") if @_ == 1;
    return $class->SUPER::new(@_);
}

sub configure {
    my($sock,$arg) = @_;
    my($bport,$cport);

    my $type = $arg->{Type} || SOCK_STREAM;

    $sock->socket(AF_UNIX, $type, 0) or
	return undef;

    if(exists $arg->{Local}) {
	my $addr = sockaddr_un($arg->{Local});
	$sock->bind($addr) or
	    return undef;
    }
    if(exists $arg->{Listen} && $type != SOCK_DGRAM) {
	$sock->listen($arg->{Listen} || 5) or
	    return undef;
    }
    elsif(exists $arg->{Peer}) {
	my $addr = sockaddr_un($arg->{Peer});
	$sock->connect($addr) or
	    return undef;
    }

    $sock;
}

sub hostpath {
    @_ == 1 or croak 'usage: $sock->hostpath()';
    my $n = $_[0]->sockname || return undef;
    (sockaddr_un($n))[0];
}

sub peerpath {
    @_ == 1 or croak 'usage: $sock->peerpath()';
    my $n = $_[0]->peername || return undef;
    (sockaddr_un($n))[0];
}

1; # Keep require happy

__END__

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 # IO::Select.pm
#
# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.

package IO::Select;

use     strict;
use warnings::register;
use     vars qw($VERSION @ISA);
require Exporter;

$VERSION = "1.22";

@ISA = qw(Exporter); # This is only so we can do version checking

sub VEC_BITS () {0}
sub FD_COUNT () {1}
sub FIRST_FD () {2}

sub new
{
 my $self = shift;
 my $type = ref($self) || $self;

 my $vec = bless [undef,0], $type;

 $vec->add(@_)
    if @_;

 $vec;
}

sub add
{
 shift->_update('add', @_);
}

sub remove
{
 shift->_update('remove', @_);
}

sub exists
{
 my $vec = shift;
 my $fno = $vec->_fileno(shift);
 return undef unless defined $fno;
 $vec->[$fno + FIRST_FD];
}

sub _fileno
{
 my($self, $f) = @_;
 return unless defined $f;
 $f = $f->[0] if ref($f) eq 'ARRAY';
 ($f =~ /^\d+$/) ? $f : fileno($f);
}

sub _update
{
 my $vec = shift;
 my $add = shift eq 'add';

 my $bits = $vec->[VEC_BITS];
 $bits = '' unless defined $bits;

 my $count = 0;
 my $f;
 foreach $f (@_)
  {
   my $fn = $vec->_fileno($f);
   if ($add) {
     next unless defined $fn;
     my $i = $fn + FIRST_FD;
     if (defined $vec->[$i]) {
	 $vec->[$i] = $f;  # if array rest might be different, so we update
	 next;
     }
     $vec->[FD_COUNT]++;
     vec($bits, $fn, 1) = 1;
     $vec->[$i] = $f;
   } else {      # remove
     if ( ! defined $fn ) { # remove if fileno undef'd
       $fn = 0;
       for my $fe (@{$vec}[FIRST_FD .. $#$vec]) {
         if (defined($fe) && $fe == $f) {
	   $vec->[FD_COUNT]--;
	   $fe = undef;
	   vec($bits, $fn, 1) = 0;
	   last;
	 }
	 ++$fn;
       }
     }
     else {
       my $i = $fn + FIRST_FD;
       next unless defined $vec->[$i];
       $vec->[FD_COUNT]--;
       vec($bits, $fn, 1) = 0;
       $vec->[$i] = undef;
     }
   }
   $count++;
  }
 $vec->[VEC_BITS] = $vec->[FD_COUNT] ? $bits : undef;
 $count;
}

sub can_read
{
 my $vec = shift;
 my $timeout = shift;
 my $r = $vec->[VEC_BITS];

 defined($r) && (select($r,undef,undef,$timeout) > 0)
    ? handles($vec, $r)
    : ();
}

sub can_write
{
 my $vec = shift;
 my $timeout = shift;
 my $w = $vec->[VEC_BITS];

 defined($w) && (select(undef,$w,undef,$timeout) > 0)
    ? handles($vec, $w)
    : ();
}

sub has_exception
{
 my $vec = shift;
 my $timeout = shift;
 my $e = $vec->[VEC_BITS];

 defined($e) && (select(undef,undef,$e,$timeout) > 0)
    ? handles($vec, $e)
    : ();
}

sub has_error
{
 warnings::warn("Call to deprecated method 'has_error', use 'has_exception'")
	if warnings::enabled();
 goto &has_exception;
}

sub count
{
 my $vec = shift;
 $vec->[FD_COUNT];
}

sub bits
{
 my $vec = shift;
 $vec->[VEC_BITS];
}

sub as_string  # for debugging
{
 my $vec = shift;
 my $str = ref($vec) . ": ";
 my $bits = $vec->bits;
 my $count = $vec->count;
 $str .= defined($bits) ? unpack("b*", $bits) : "undef";
 $str .= " $count";
 my @handles = @$vec;
 splice(@handles, 0, FIRST_FD);
 for (@handles) {
     $str .= " " . (defined($_) ? "$_" : "-");
 }
 $str;
}

sub _max
{
 my($a,$b,$c) = @_;
 $a > $b
    ? $a > $c
        ? $a
        : $c
    : $b > $c
        ? $b
        : $c;
}

sub select
{
 shift
   if defined $_[0] && !ref($_[0]);

 my($r,$w,$e,$t) = @_;
 my @result = ();

 my $rb = defined $r ? $r->[VEC_BITS] : undef;
 my $wb = defined $w ? $w->[VEC_BITS] : undef;
 my $eb = defined $e ? $e->[VEC_BITS] : undef;

 if(select($rb,$wb,$eb,$t) > 0)
  {
   my @r = ();
   my @w = ();
   my @e = ();
   my $i = _max(defined $r ? scalar(@$r)-1 : 0,
                defined $w ? scalar(@$w)-1 : 0,
                defined $e ? scalar(@$e)-1 : 0);

   for( ; $i >= FIRST_FD ; $i--)
    {
     my $j = $i - FIRST_FD;
     push(@r, $r->[$i])
        if defined $rb && defined $r->[$i] && vec($rb, $j, 1);
     push(@w, $w->[$i])
        if defined $wb && defined $w->[$i] && vec($wb, $j, 1);
     push(@e, $e->[$i])
        if defined $eb && defined $e->[$i] && vec($eb, $j, 1);
    }

   @result = (\@r, \@w, \@e);
  }
 @result;
}

sub handles
{
 my $vec = shift;
 my $bits = shift;
 my @h = ();
 my $i;
 my $max = scalar(@$vec) - 1;

 for ($i = FIRST_FD; $i <= $max; $i++)
  {
   next unless defined $vec->[$i];
   push(@h, $vec->[$i])
      if !defined($bits) || vec($bits, $i - FIRST_FD, 1);
  }
 
 @h;
}

1;
__END__

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         # IO::Socket.pm
#
# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.

package IO::Socket;

require 5.006;

use IO::Handle;
use Socket 1.3;
use Carp;
use strict;
our(@ISA, $VERSION, @EXPORT_OK);
use Exporter;
use Errno;

# legacy

require IO::Socket::INET;
require IO::Socket::UNIX if ($^O ne 'epoc' && $^O ne 'symbian');

@ISA = qw(IO::Handle);

$VERSION = "1.38";

@EXPORT_OK = qw(sockatmark);

sub import {
    my $pkg = shift;
    if (@_ && $_[0] eq 'sockatmark') { # not very extensible but for now, fast
	Exporter::export_to_level('IO::Socket', 1, $pkg, 'sockatmark');
    } else {
	my $callpkg = caller;
	Exporter::export 'Socket', $callpkg, @_;
    }
}

sub new {
    my($class,%arg) = @_;
    my $sock = $class->SUPER::new();

    $sock->autoflush(1);

    ${*$sock}{'io_socket_timeout'} = delete $arg{Timeout};

    return scalar(%arg) ? $sock->configure(\%arg)
			: $sock;
}

my @domain2pkg;

sub register_domain {
    my($p,$d) = @_;
    $domain2pkg[$d] = $p;
}

sub configure {
    my($sock,$arg) = @_;
    my $domain = delete $arg->{Domain};

    croak 'IO::Socket: Cannot configure a generic socket'
	unless defined $domain;

    croak "IO::Socket: Unsupported socket domain"
	unless defined $domain2pkg[$domain];

    croak "IO::Socket: Cannot configure socket in domain '$domain'"
	unless ref($sock) eq "IO::Socket";

    bless($sock, $domain2pkg[$domain]);
    $sock->configure($arg);
}

sub socket {
    @_ == 4 or croak 'usage: $sock->socket(DOMAIN, TYPE, PROTOCOL)';
    my($sock,$domain,$type,$protocol) = @_;

    socket($sock,$domain,$type,$protocol) or
    	return undef;

    ${*$sock}{'io_socket_domain'} = $domain;
    ${*$sock}{'io_socket_type'}   = $type;
    ${*$sock}{'io_socket_proto'}  = $protocol;

    $sock;
}

sub socketpair {
    @_ == 4 || croak 'usage: IO::Socket->socketpair(DOMAIN, TYPE, PROTOCOL)';
    my($class,$domain,$type,$protocol) = @_;
    my $sock1 = $class->new();
    my $sock2 = $class->new();

    socketpair($sock1,$sock2,$domain,$type,$protocol) or
    	return ();

    ${*$sock1}{'io_socket_type'}  = ${*$sock2}{'io_socket_type'}  = $type;
    ${*$sock1}{'io_socket_proto'} = ${*$sock2}{'io_socket_proto'} = $protocol;

    ($sock1,$sock2);
}

sub connect {
    @_ == 2 or croak 'usage: $sock->connect(NAME)';
    my $sock = shift;
    my $addr = shift;
    my $timeout = ${*$sock}{'io_socket_timeout'};
    my $err;
    my $blocking;

    $blocking = $sock->blocking(0) if $timeout;
    if (!connect($sock, $addr)) {
	if (defined $timeout && ($!{EINPROGRESS} || $!{EWOULDBLOCK})) {
	    require IO::Select;

	    my $sel = new IO::Select $sock;

	    undef $!;
	    my($r,$w,$e) = IO::Select::select(undef,$sel,$sel,$timeout);
	    if(@$e[0]) {
		# Windows return from select after the timeout in case of
		# WSAECONNREFUSED(10061) if exception set is not used.
		# This behavior is different from Linux.
		# Using the exception
		# set we now emulate the behavior in Linux
		#    - Karthik Rajagopalan
		$err = $sock->getsockopt(SOL_SOCKET,SO_ERROR);
		$@ = "connect: $err";
	    }
	    elsif(!@$w[0]) {
		$err = $! || (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);
		$@ = "connect: timeout";
	    }
	    elsif (!connect($sock,$addr) &&
                not ($!{EISCONN} || ($^O eq 'MSWin32' &&
                ($! == (($] < 5.019004) ? 10022 : Errno::EINVAL))))
            ) {
		# Some systems refuse to re-connect() to
		# an already open socket and set errno to EISCONN.
		# Windows sets errno to WSAEINVAL (10022) (pre-5.19.4) or
		# EINVAL (22) (5.19.4 onwards).
		$err = $!;
		$@ = "connect: $!";
	    }
	}
        elsif ($blocking || !($!{EINPROGRESS} || $!{EWOULDBLOCK}))  {
	    $err = $!;
	    $@ = "connect: $!";
	}
    }

    $sock->blocking(1) if $blocking;

    $! = $err if $err;

    $err ? undef : $sock;
}

# Enable/disable blocking IO on sockets.
# Without args return the current status of blocking,
# with args change the mode as appropriate, returning the
# old setting, or in case of error during the mode change
# undef.

sub blocking {
    my $sock = shift;

    return $sock->SUPER::blocking(@_)
        if $^O ne 'MSWin32' && $^O ne 'VMS';

    # Windows handles blocking differently
    #
    # http://groups.google.co.uk/group/perl.perl5.porters/browse_thread/thread/b4e2b1d88280ddff/630b667a66e3509f?#630b667a66e3509f
    # http://msdn.microsoft.com/library/default.asp?url=/library/en-us/winsock/winsock/ioctlsocket_2.asp
    #
    # 0x8004667e is FIONBIO
    #
    # which is used to set blocking behaviour.

    # NOTE: 
    # This is a little confusing, the perl keyword for this is
    # 'blocking' but the OS level behaviour is 'non-blocking', probably
    # because sockets are blocking by default.
    # Therefore internally we have to reverse the semantics.

    my $orig= !${*$sock}{io_sock_nonblocking};
        
    return $orig unless @_;

    my $block = shift;
    
    if ( !$block != !$orig ) {
        ${*$sock}{io_sock_nonblocking} = $block ? 0 : 1;
        ioctl($sock, 0x8004667e, pack("L!",${*$sock}{io_sock_nonblocking}))
            or return undef;
    }
    
    return $orig;        
}

sub close {
    @_ == 1 or croak 'usage: $sock->close()';
    my $sock = shift;
    ${*$sock}{'io_socket_peername'} = undef;
    $sock->SUPER::close();
}

sub bind {
    @_ == 2 or croak 'usage: $sock->bind(NAME)';
    my $sock = shift;
    my $addr = shift;

    return bind($sock, $addr) ? $sock
			      : undef;
}

sub listen {
    @_ >= 1 && @_ <= 2 or croak 'usage: $sock->listen([QUEUE])';
    my($sock,$queue) = @_;
    $queue = 5
	unless $queue && $queue > 0;

    return listen($sock, $queue) ? $sock
				 : undef;
}

sub accept {
    @_ == 1 || @_ == 2 or croak 'usage $sock->accept([PKG])';
    my $sock = shift;
    my $pkg = shift || $sock;
    my $timeout = ${*$sock}{'io_socket_timeout'};
    my $new = $pkg->new(Timeout => $timeout);
    my $peer = undef;

    if(defined $timeout) {
	require IO::Select;

	my $sel = new IO::Select $sock;

	unless ($sel->can_read($timeout)) {
	    $@ = 'accept: timeout';
	    $! = (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);
	    return;
	}
    }

    $peer = accept($new,$sock)
	or return;

    ${*$new}{$_} = ${*$sock}{$_} for qw( io_socket_domain io_socket_type io_socket_proto );

    return wantarray ? ($new, $peer)
    	      	     : $new;
}

sub sockname {
    @_ == 1 or croak 'usage: $sock->sockname()';
    getsockname($_[0]);
}

sub peername {
    @_ == 1 or croak 'usage: $sock->peername()';
    my($sock) = @_;
    ${*$sock}{'io_socket_peername'} ||= getpeername($sock);
}

sub connected {
    @_ == 1 or croak 'usage: $sock->connected()';
    my($sock) = @_;
    getpeername($sock);
}

sub send {
    @_ >= 2 && @_ <= 4 or croak 'usage: $sock->send(BUF, [FLAGS, [TO]])';
    my $sock  = $_[0];
    my $flags = $_[2] || 0;
    my $peer  = $_[3] || $sock->peername;

    croak 'send: Cannot determine peer address'
	 unless(defined $peer);

    my $r = defined(getpeername($sock))
	? send($sock, $_[1], $flags)
	: send($sock, $_[1], $flags, $peer);

    # remember who we send to, if it was successful
    ${*$sock}{'io_socket_peername'} = $peer
	if(@_ == 4 && defined $r);

    $r;
}

sub recv {
    @_ == 3 || @_ == 4 or croak 'usage: $sock->recv(BUF, LEN [, FLAGS])';
    my $sock  = $_[0];
    my $len   = $_[2];
    my $flags = $_[3] || 0;

    # remember who we recv'd from
    ${*$sock}{'io_socket_peername'} = recv($sock, $_[1]='', $len, $flags);
}

sub shutdown {
    @_ == 2 or croak 'usage: $sock->shutdown(HOW)';
    my($sock, $how) = @_;
    ${*$sock}{'io_socket_peername'} = undef;
    shutdown($sock, $how);
}

sub setsockopt {
    @_ == 4 or croak '$sock->setsockopt(LEVEL, OPTNAME, OPTVAL)';
    setsockopt($_[0],$_[1],$_[2],$_[3]);
}

my $intsize = length(pack("i",0));

sub getsockopt {
    @_ == 3 or croak '$sock->getsockopt(LEVEL, OPTNAME)';
    my $r = getsockopt($_[0],$_[1],$_[2]);
    # Just a guess
    $r = unpack("i", $r)
	if(defined $r && length($r) == $intsize);
    $r;
}

sub sockopt {
    my $sock = shift;
    @_ == 1 ? $sock->getsockopt(SOL_SOCKET,@_)
	    : $sock->setsockopt(SOL_SOCKET,@_);
}

sub atmark {
    @_ == 1 or croak 'usage: $sock->atmark()';
    my($sock) = @_;
    sockatmark($sock);
}

sub timeout {
    @_ == 1 || @_ == 2 or croak 'usage: $sock->timeout([VALUE])';
    my($sock,$val) = @_;
    my $r = ${*$sock}{'io_socket_timeout'};

    ${*$sock}{'io_socket_timeout'} = defined $val ? 0 + $val : $val
	if(@_ == 2);

    $r;
}

sub sockdomain {
    @_ == 1 or croak 'usage: $sock->sockdomain()';
    my $sock = shift;
    if (!defined(${*$sock}{'io_socket_domain'})) {
	my $addr = $sock->sockname();
	${*$sock}{'io_socket_domain'} = sockaddr_family($addr)
	    if (defined($addr));
    }
    ${*$sock}{'io_socket_domain'};
}

sub socktype {
    @_ == 1 or croak 'usage: $sock->socktype()';
    my $sock = shift;
    ${*$sock}{'io_socket_type'} = $sock->sockopt(Socket::SO_TYPE)
	if (!defined(${*$sock}{'io_socket_type'}) && defined(eval{Socket::SO_TYPE}));
    ${*$sock}{'io_socket_type'}
}

sub protocol {
    @_ == 1 or croak 'usage: $sock->protocol()';
    my($sock) = @_;
    ${*$sock}{'io_socket_proto'} = $sock->sockopt(Socket::SO_PROTOCOL)
	if (!defined(${*$sock}{'io_socket_proto'}) && defined(eval{Socket::SO_PROTOCOL}));
    ${*$sock}{'io_socket_proto'};
}

1;

__END__

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 # Copyright (c) 1997-2009 Graham Barr <gbarr@pobox.com>. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.
#
# Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>

package List::Util;

use strict;
require Exporter;

our @ISA        = qw(Exporter);
our @EXPORT_OK  = qw(
  all any first min max minstr maxstr none notall product reduce sum sum0 shuffle
  pairs unpairs pairkeys pairvalues pairmap pairgrep pairfirst
);
our $VERSION    = "1.42_02";
our $XS_VERSION = $VERSION;
$VERSION    = eval $VERSION;

require XSLoader;
XSLoader::load('List::Util', $XS_VERSION);

sub import
{
  my $pkg = caller;

  # (RT88848) Touch the caller's $a and $b, to avoid the warning of
  #   Name "main::a" used only once: possible typo" warning
  no strict 'refs';
  ${"${pkg}::a"} = ${"${pkg}::a"};
  ${"${pkg}::b"} = ${"${pkg}::b"};

  goto &Exporter::import;
}

# For objects returned by pairs()
sub List::Util::_Pair::key   { shift->[0] }
sub List::Util::_Pair::value { shift->[1] }

1;

__END__

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          # IO::Socket::INET.pm
#
# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.

package IO::Socket::INET;

use strict;
our(@ISA, $VERSION);
use IO::Socket;
use Socket;
use Carp;
use Exporter;
use Errno;

@ISA = qw(IO::Socket);
$VERSION = "1.35";

my $EINVAL = exists(&Errno::EINVAL) ? Errno::EINVAL() : 1;

IO::Socket::INET->register_domain( AF_INET );

my %socket_type = ( tcp  => SOCK_STREAM,
		    udp  => SOCK_DGRAM,
		    icmp => SOCK_RAW
		  );
my %proto_number;
$proto_number{tcp}  = Socket::IPPROTO_TCP()  if defined &Socket::IPPROTO_TCP;
$proto_number{udp}  = Socket::IPPROTO_UDP()  if defined &Socket::IPPROTO_UDP;
$proto_number{icmp} = Socket::IPPROTO_ICMP() if defined &Socket::IPPROTO_ICMP;
my %proto_name = reverse %proto_number;

sub new {
    my $class = shift;
    unshift(@_, "PeerAddr") if @_ == 1;
    return $class->SUPER::new(@_);
}

sub _cache_proto {
    my @proto = @_;
    for (map lc($_), $proto[0], split(' ', $proto[1])) {
	$proto_number{$_} = $proto[2];
    }
    $proto_name{$proto[2]} = $proto[0];
}

sub _get_proto_number {
    my $name = lc(shift);
    return undef unless defined $name;
    return $proto_number{$name} if exists $proto_number{$name};

    my @proto = eval { getprotobyname($name) };
    return undef unless @proto;
    _cache_proto(@proto);

    return $proto[2];
}

sub _get_proto_name {
    my $num = shift;
    return undef unless defined $num;
    return $proto_name{$num} if exists $proto_name{$num};

    my @proto = eval { getprotobynumber($num) };
    return undef unless @proto;
    _cache_proto(@proto);

    return $proto[0];
}

sub _sock_info {
  my($addr,$port,$proto) = @_;
  my $origport = $port;
  my @serv = ();

  $port = $1
	if(defined $addr && $addr =~ s,:([\w\(\)/]+)$,,);

  if(defined $proto  && $proto =~ /\D/) {
    my $num = _get_proto_number($proto);
    unless (defined $num) {
      $@ = "Bad protocol '$proto'";
      return;
    }
    $proto = $num;
  }

  if(defined $port) {
    my $defport = ($port =~ s,\((\d+)\)$,,) ? $1 : undef;
    my $pnum = ($port =~ m,^(\d+)$,)[0];

    @serv = getservbyname($port, _get_proto_name($proto) || "")
	if ($port =~ m,\D,);

    $port = $serv[2] || $defport || $pnum;
    unless (defined $port) {
	$@ = "Bad service '$origport'";
	return;
    }

    $proto = _get_proto_number($serv[3]) if @serv && !$proto;
  }

 return ($addr || undef,
	 $port || undef,
	 $proto || undef
	);
}

sub _error {
    my $sock = shift;
    my $err = shift;
    {
      local($!);
      my $title = ref($sock).": ";
      $@ = join("", $_[0] =~ /^$title/ ? "" : $title, @_);
      $sock->close()
	if(defined fileno($sock));
    }
    $! = $err;
    return undef;
}

sub _get_addr {
    my($sock,$addr_str, $multi) = @_;
    my @addr;
    if ($multi && $addr_str !~ /^\d+(?:\.\d+){3}$/) {
	(undef, undef, undef, undef, @addr) = gethostbyname($addr_str);
    } else {
	my $h = inet_aton($addr_str);
	push(@addr, $h) if defined $h;
    }
    @addr;
}

sub configure {
    my($sock,$arg) = @_;
    my($lport,$rport,$laddr,$raddr,$proto,$type);

    $arg->{LocalAddr} = $arg->{LocalHost}
	if exists $arg->{LocalHost} && !exists $arg->{LocalAddr};

    ($laddr,$lport,$proto) = _sock_info($arg->{LocalAddr},
					$arg->{LocalPort},
					$arg->{Proto})
			or return _error($sock, $!, $@);

    $laddr = defined $laddr ? inet_aton($laddr)
			    : INADDR_ANY;

    return _error($sock, $EINVAL, "Bad hostname '",$arg->{LocalAddr},"'")
	unless(defined $laddr);

    $arg->{PeerAddr} = $arg->{PeerHost}
	if exists $arg->{PeerHost} && !exists $arg->{PeerAddr};

    unless(exists $arg->{Listen}) {
	($raddr,$rport,$proto) = _sock_info($arg->{PeerAddr},
					    $arg->{PeerPort},
					    $proto)
			or return _error($sock, $!, $@);
    }

    $proto ||= _get_proto_number('tcp');

    $type = $arg->{Type} || $socket_type{lc _get_proto_name($proto)};

    my @raddr = ();

    if(defined $raddr) {
	@raddr = $sock->_get_addr($raddr, $arg->{MultiHomed});
	return _error($sock, $EINVAL, "Bad hostname '",$arg->{PeerAddr},"'")
	    unless @raddr;
    }

    while(1) {

	$sock->socket(AF_INET, $type, $proto) or
	    return _error($sock, $!, "$!");

        if (defined $arg->{Blocking}) {
	    defined $sock->blocking($arg->{Blocking})
		or return _error($sock, $!, "$!");
	}

	if ($arg->{Reuse} || $arg->{ReuseAddr}) {
	    $sock->sockopt(SO_REUSEADDR,1) or
		    return _error($sock, $!, "$!");
	}

	if ($arg->{ReusePort}) {
	    $sock->sockopt(SO_REUSEPORT,1) or
		    return _error($sock, $!, "$!");
	}

	if ($arg->{Broadcast}) {
		$sock->sockopt(SO_BROADCAST,1) or
		    return _error($sock, $!, "$!");
	}

	if($lport || ($laddr ne INADDR_ANY) || exists $arg->{Listen}) {
	    $sock->bind($lport || 0, $laddr) or
		    return _error($sock, $!, "$!");
	}

	if(exists $arg->{Listen}) {
	    $sock->listen($arg->{Listen} || 5) or
		return _error($sock, $!, "$!");
	    last;
	}

 	# don't try to connect unless we're given a PeerAddr
 	last unless exists($arg->{PeerAddr});
 
        $raddr = shift @raddr;

	return _error($sock, $EINVAL, 'Cannot determine remote port')
		unless($rport || $type == SOCK_DGRAM || $type == SOCK_RAW);

	last
	    unless($type == SOCK_STREAM || defined $raddr);

	return _error($sock, $EINVAL, "Bad hostname '",$arg->{PeerAddr},"'")
	    unless defined $raddr;

#        my $timeout = ${*$sock}{'io_socket_timeout'};
#        my $before = time() if $timeout;

	undef $@;
        if ($sock->connect(pack_sockaddr_in($rport, $raddr))) {
#            ${*$sock}{'io_socket_timeout'} = $timeout;
            return $sock;
        }

	return _error($sock, $!, $@ || "Timeout")
	    unless @raddr;

#	if ($timeout) {
#	    my $new_timeout = $timeout - (time() - $before);
#	    return _error($sock,
#                         (exists(&Errno::ETIMEDOUT) ? Errno::ETIMEDOUT() : $EINVAL),
#                         "Timeout") if $new_timeout <= 0;
#	    ${*$sock}{'io_socket_timeout'} = $new_timeout;
#        }

    }

    $sock;
}

sub connect {
    @_ == 2 || @_ == 3 or
       croak 'usage: $sock->connect(NAME) or $sock->connect(PORT, ADDR)';
    my $sock = shift;
    return $sock->SUPER::connect(@_ == 1 ? shift : pack_sockaddr_in(@_));
}

sub bind {
    @_ == 2 || @_ == 3 or
       croak 'usage: $sock->bind(NAME) or $sock->bind(PORT, ADDR)';
    my $sock = shift;
    return $sock->SUPER::bind(@_ == 1 ? shift : pack_sockaddr_in(@_))
}

sub sockaddr {
    @_ == 1 or croak 'usage: $sock->sockaddr()';
    my($sock) = @_;
    my $name = $sock->sockname;
    $name ? (sockaddr_in($name))[1] : undef;
}

sub sockport {
    @_ == 1 or croak 'usage: $sock->sockport()';
    my($sock) = @_;
    my $name = $sock->sockname;
    $name ? (sockaddr_in($name))[0] : undef;
}

sub sockhost {
    @_ == 1 or croak 'usage: $sock->sockhost()';
    my($sock) = @_;
    my $addr = $sock->sockaddr;
    $addr ? inet_ntoa($addr) : undef;
}

sub peeraddr {
    @_ == 1 or croak 'usage: $sock->peeraddr()';
    my($sock) = @_;
    my $name = $sock->peername;
    $name ? (sockaddr_in($name))[1] : undef;
}

sub peerport {
    @_ == 1 or croak 'usage: $sock->peerport()';
    my($sock) = @_;
    my $name = $sock->peername;
    $name ? (sockaddr_in($name))[0] : undef;
}

sub peerhost {
    @_ == 1 or croak 'usage: $sock->peerhost()';
    my($sock) = @_;
    my $addr = $sock->peeraddr;
    $addr ? inet_ntoa($addr) : undef;
}

1;

__END__

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ################################################################################
#
#  Version 2.x, Copyright (C) 2007-2013, Marcus Holland-Moritz <mhx@cpan.org>.
#  Version 1.x, Copyright (C) 1997, Graham Barr <gbarr@pobox.com>.
#
#  This program is free software; you can redistribute it and/or
#  modify it under the same terms as Perl itself.
#
################################################################################

package IPC::Msg;

use IPC::SysV qw(IPC_STAT IPC_SET IPC_RMID);
use strict;
use vars qw($VERSION);
use Carp;

$VERSION = '2.06_01';

# Figure out if we have support for native sized types
my $N = do { my $foo = eval { pack "L!", 0 }; $@ ? '' : '!' };

{
    package IPC::Msg::stat;

    use Class::Struct qw(struct);

    struct 'IPC::Msg::stat' => [
	uid	=> '$',
	gid	=> '$',
	cuid	=> '$',
	cgid	=> '$',
	mode	=> '$',
	qnum	=> '$',
	qbytes	=> '$',
	lspid	=> '$',
	lrpid	=> '$',
	stime	=> '$',
	rtime	=> '$',
	ctime	=> '$',
    ];
}

sub new {
    @_ == 3 || croak 'new IPC::Msg ( KEY , FLAGS )';
    my $class = shift;

    my $id = msgget($_[0],$_[1]);

    defined($id)
	? bless \$id, $class
	: undef;
}

sub id {
    my $self = shift;
    $$self;
}

sub stat {
    my $self = shift;
    my $data = "";
    msgctl($$self,IPC_STAT,$data) or
	return undef;
    IPC::Msg::stat->new->unpack($data);
}

sub set {
    my $self = shift;
    my $ds;

    if(@_ == 1) {
	$ds = shift;
    }
    else {
	croak 'Bad arg count' if @_ % 2;
	my %arg = @_;
	$ds = $self->stat
		or return undef;
	my($key,$val);
	$ds->$key($val)
	    while(($key,$val) = each %arg);
    }

    msgctl($$self,IPC_SET,$ds->pack);
}

sub remove {
    my $self = shift;
    (msgctl($$self,IPC_RMID,0), undef $$self)[0];
}

sub rcv {
    @_ <= 5 && @_ >= 3 or croak '$msg->rcv( BUF, LEN, TYPE, FLAGS )';
    my $self = shift;
    my $buf = "";
    msgrcv($$self,$buf,$_[1],$_[2] || 0, $_[3] || 0) or
	return;
    my $type;
    ($type,$_[0]) = unpack("l$N a*",$buf);
    $type;
}

sub snd {
    @_ <= 4 && @_ >= 3 or  croak '$msg->snd( TYPE, BUF, FLAGS )';
    my $self = shift;
    msgsnd($$self,pack("l$N a*",$_[0],$_[1]), $_[2] || 0);
}


1;

__END__

=head1 NAME

IPC::Msg - SysV Msg IPC object class

=head1 SYNOPSIS

    use IPC::SysV qw(IPC_PRIVATE S_IRUSR S_IWUSR);
    use IPC::Msg;

    $msg = IPC::Msg->new(IPC_PRIVATE, S_IRUSR | S_IWUSR);

    $msg->snd($msgtype, $msgdata);

    $msg->rcv($buf, 256);

    $ds = $msg->stat;

    $msg->remove;

=head1 DESCRIPTION

A class providing an object based interface to SysV IPC message queues.

=head1 METHODS

=over 4

=item new ( KEY , FLAGS )

Creates a new message queue associated with C<KEY>. A new queue is
created if

=over 4

=item *

C<KEY> is equal to C<IPC_PRIVATE>

=item *

C<KEY> does not already have a message queue associated with
it, and C<I<FLAGS> & IPC_CREAT> is true.

=back

On creation of a new message queue C<FLAGS> is used to set the
permissions.  Be careful not to set any flags that the Sys V
IPC implementation does not allow: in some systems setting
execute bits makes the operations fail.

=item id

Returns the system message queue identifier.

=item rcv ( BUF, LEN [, TYPE [, FLAGS ]] )

Read a message from the queue. Returns the type of the message read.
See L<msgrcv(2)>.  The BUF becomes tainted.

=item remove

Remove and destroy the message queue from the system.

=item set ( STAT )

=item set ( NAME => VALUE [, NAME => VALUE ...] )

C<set> will set the following values of the C<stat> structure associated
with the message queue.

    uid
    gid
    mode (oly the permission bits)
    qbytes

C<set> accepts either a stat object, as returned by the C<stat> method,
or a list of I<name>-I<value> pairs.

=item snd ( TYPE, MSG [, FLAGS ] )

Place a message on the queue with the data from C<MSG> and with type C<TYPE>.
See L<msgsnd(2)>.

=item stat

Returns an object of type C<IPC::Msg::stat> which is a sub-class of
C<Class::Struct>. It provides the following fields. For a description
of these fields see you system documentation.

    uid
    gid
    cuid
    cgid
    mode
    qnum
    qbytes
    lspid
    lrpid
    stime
    rtime
    ctime

=back

=head1 SEE ALSO

L<IPC::SysV>, L<Class::Struct>

=head1 AUTHORS

Graham Barr <gbarr@pobox.com>,
Marcus Holland-Moritz <mhx@cpan.org>

=head1 COPYRIGHT

Version 2.x, Copyright (C) 2007-2013, Marcus Holland-Moritz.

Version 1.x, Copyright (c) 1997, Graham Barr.

This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

=cut

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ################################################################################
#
#  Version 2.x, Copyright (C) 2007-2013, Marcus Holland-Moritz <mhx@cpan.org>.
#  Version 1.x, Copyright (C) 1997, Graham Barr <gbarr@pobox.com>.
#
#  This program is free software; you can redistribute it and/or
#  modify it under the same terms as Perl itself.
#
################################################################################

package IPC::Semaphore;

use IPC::SysV qw(GETNCNT GETZCNT GETVAL SETVAL GETPID GETALL SETALL
		 IPC_STAT IPC_SET IPC_RMID);
use strict;
use vars qw($VERSION);
use Carp;

$VERSION = '2.06_01';

# Figure out if we have support for native sized types
my $N = do { my $foo = eval { pack "L!", 0 }; $@ ? '' : '!' };

{
    package IPC::Semaphore::stat;

    use Class::Struct qw(struct);

    struct 'IPC::Semaphore::stat' => [
	uid	=> '$',
	gid	=> '$',
	cuid	=> '$',
	cgid	=> '$',
	mode	=> '$',
	ctime	=> '$',
	otime	=> '$',
	nsems	=> '$',
    ];
}

sub new {
    @_ == 4 || croak 'new ' . __PACKAGE__ . '( KEY, NSEMS, FLAGS )';
    my $class = shift;

    my $id = semget($_[0],$_[1],$_[2]);

    defined($id)
	? bless \$id, $class
	: undef;
}

sub id {
    my $self = shift;
    $$self;
}

sub remove {
    my $self = shift;
    my $result = semctl($$self,0,IPC_RMID,0);
    undef $$self;
    $result;
}

sub getncnt {
    @_ == 2 || croak '$sem->getncnt( SEM )';
    my $self = shift;
    my $sem = shift;
    my $v = semctl($$self,$sem,GETNCNT,0);
    $v ? 0 + $v : undef;
}

sub getzcnt {
    @_ == 2 || croak '$sem->getzcnt( SEM )';
    my $self = shift;
    my $sem = shift;
    my $v = semctl($$self,$sem,GETZCNT,0);
    $v ? 0 + $v : undef;
}

sub getval {
    @_ == 2 || croak '$sem->getval( SEM )';
    my $self = shift;
    my $sem = shift;
    my $v = semctl($$self,$sem,GETVAL,0);
    $v ? 0 + $v : undef;
}

sub getpid {
    @_ == 2 || croak '$sem->getpid( SEM )';
    my $self = shift;
    my $sem = shift;
    my $v = semctl($$self,$sem,GETPID,0);
    $v ? 0 + $v : undef;
}

sub op {
    @_ >= 4 || croak '$sem->op( OPLIST )';
    my $self = shift;
    croak 'Bad arg count' if @_ % 3;
    my $data = pack("s$N*",@_);
    semop($$self,$data);
}

sub stat {
    my $self = shift;
    my $data = "";
    semctl($$self,0,IPC_STAT,$data)
	or return undef;
    IPC::Semaphore::stat->new->unpack($data);
}

sub set {
    my $self = shift;
    my $ds;

    if(@_ == 1) {
	$ds = shift;
    }
    else {
	croak 'Bad arg count' if @_ % 2;
	my %arg = @_;
	$ds = $self->stat
		or return undef;
	my($key,$val);
	$ds->$key($val)
	    while(($key,$val) = each %arg);
    }

    my $v = semctl($$self,0,IPC_SET,$ds->pack);
    $v ? 0 + $v : undef;
}

sub getall {
    my $self = shift;
    my $data = "";
    semctl($$self,0,GETALL,$data)
	or return ();
    (unpack("s$N*",$data));
}

sub setall {
    my $self = shift;
    my $data = pack("s$N*",@_);
    semctl($$self,0,SETALL,$data);
}

sub setval {
    @_ == 3 || croak '$sem->setval( SEM, VAL )';
    my $self = shift;
    my $sem = shift;
    my $val = shift;
    semctl($$self,$sem,SETVAL,$val);
}

1;

__END__

=head1 NAME

IPC::Semaphore - SysV Semaphore IPC object class

=head1 SYNOPSIS

    use IPC::SysV qw(IPC_PRIVATE S_IRUSR S_IWUSR IPC_CREAT);
    use IPC::Semaphore;

    $sem = IPC::Semaphore->new(IPC_PRIVATE, 10, S_IRUSR | S_IWUSR | IPC_CREAT);

    $sem->setall( (0) x 10);

    @sem = $sem->getall;

    $ncnt = $sem->getncnt;

    $zcnt = $sem->getzcnt;

    $ds = $sem->stat;

    $sem->remove;

=head1 DESCRIPTION

A class providing an object based interface to SysV IPC semaphores.

=head1 METHODS

=over 4

=item new ( KEY , NSEMS , FLAGS )

Create a new semaphore set associated with C<KEY>. C<NSEMS> is the number
of semaphores in the set. A new set is created if

=over 4

=item *

C<KEY> is equal to C<IPC_PRIVATE>

=item *

C<KEY> does not already have a semaphore identifier
associated with it, and C<I<FLAGS> & IPC_CREAT> is true.

=back

On creation of a new semaphore set C<FLAGS> is used to set the
permissions.  Be careful not to set any flags that the Sys V
IPC implementation does not allow: in some systems setting
execute bits makes the operations fail.

=item getall

Returns the values of the semaphore set as an array.

=item getncnt ( SEM )

Returns the number of processes waiting for the semaphore C<SEM> to
become greater than its current value

=item getpid ( SEM )

Returns the process id of the last process that performed an operation
on the semaphore C<SEM>.

=item getval ( SEM )

Returns the current value of the semaphore C<SEM>.

=item getzcnt ( SEM )

Returns the number of processes waiting for the semaphore C<SEM> to
become zero.

=item id

Returns the system identifier for the semaphore set.

=item op ( OPLIST )

C<OPLIST> is a list of operations to pass to C<semop>. C<OPLIST> is
a concatenation of smaller lists, each which has three values. The
first is the semaphore number, the second is the operation and the last
is a flags value. See L<semop(2)> for more details. For example

    $sem->op(
	0, -1, IPC_NOWAIT,
	1,  1, IPC_NOWAIT
    );

=item remove

Remove and destroy the semaphore set from the system.

=item set ( STAT )

=item set ( NAME => VALUE [, NAME => VALUE ...] )

C<set> will set the following values of the C<stat> structure associated
with the semaphore set.

    uid
    gid
    mode (only the permission bits)

C<set> accepts either a stat object, as returned by the C<stat> method,
or a list of I<name>-I<value> pairs.

=item setall ( VALUES )

Sets all values in the semaphore set to those given on the C<VALUES> list.
C<VALUES> must contain the correct number of values.

=item setval ( N , VALUE )

Set the C<N>th value in the semaphore set to C<VALUE>

=item stat

Returns an object of type C<IPC::Semaphore::stat> which is a sub-class of
C<Class::Struct>. It provides the following fields. For a description
of these fields see your system documentation.

    uid
    gid
    cuid
    cgid
    mode
    ctime
    otime
    nsems

=back

=head1 SEE ALSO

L<IPC::SysV>, L<Class::Struct>, L<semget(2)>, L<semctl(2)>, L<semop(2)>

=head1 AUTHORS

Graham Barr <gbarr@pobox.com>,
Marcus Holland-Moritz <mhx@cpan.org>

=head1 COPYRIGHT

Version 2.x, Copyright (C) 2007-2013, Marcus Holland-Moritz.

Version 1.x, Copyright (c) 1997, Graham Barr.

This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ################################################################################
#
#  Version 2.x, Copyright (C) 2007-2013, Marcus Holland-Moritz <mhx@cpan.org>.
#  Version 1.x, Copyright (C) 1997, Graham Barr <gbarr@pobox.com>.
#
#  This program is free software; you can redistribute it and/or
#  modify it under the same terms as Perl itself.
#
################################################################################

package IPC::SharedMem;

use IPC::SysV qw(IPC_STAT IPC_RMID shmat shmdt memread memwrite);
use strict;
use vars qw($VERSION);
use Carp;

$VERSION = '2.06_01';

# Figure out if we have support for native sized types
my $N = do { my $foo = eval { pack "L!", 0 }; $@ ? '' : '!' };

{
    package IPC::SharedMem::stat;

    use Class::Struct qw(struct);

    struct 'IPC::SharedMem::stat' => [
	uid	=> '$',
	gid	=> '$',
	cuid	=> '$',
	cgid	=> '$',
	mode	=> '$',
	segsz	=> '$',
	lpid	=> '$',
	cpid	=> '$',
	nattch	=> '$',
	atime	=> '$',
	dtime	=> '$',
	ctime	=> '$',
    ];
}

sub new
{
  @_ == 4 or croak 'IPC::SharedMem->new(KEY, SIZE, FLAGS)';
  my($class, $key, $size, $flags) = @_;

  my $id = shmget $key, $size, $flags;

  return undef unless defined $id;

  bless { _id => $id, _addr => undef, _isrm => 0 }, $class
}

sub id
{
  my $self = shift;
  $self->{_id};
}

sub addr
{
  my $self = shift;
  $self->{_addr};
}

sub stat
{
  my $self = shift;
  my $data = '';
  shmctl $self->id, IPC_STAT, $data or return undef;
  IPC::SharedMem::stat->new->unpack($data);
}

sub attach
{
  @_ >= 1 && @_ <= 2 or croak '$shm->attach([FLAG])';
  my($self, $flag) = @_;
  defined $self->addr and return undef;
  $self->{_addr} = shmat($self->id, undef, $flag || 0);
  defined $self->addr;
}

sub detach
{
  my $self = shift;
  defined $self->addr or return undef;
  my $rv = defined shmdt($self->addr);
  undef $self->{_addr} if $rv;
  $rv;
}

sub remove
{
  my $self = shift;
  return undef if $self->is_removed;
  my $rv = shmctl $self->id, IPC_RMID, 0;
  $self->{_isrm} = 1 if $rv;
  return $rv;
}

sub is_removed
{
  my $self = shift;
  $self->{_isrm};
}

sub read
{
  @_ == 3 or croak '$shm->read(POS, SIZE)';
  my($self, $pos, $size) = @_;
  my $buf = '';
  if (defined $self->addr) {
    memread($self->addr, $buf, $pos, $size) or return undef;
  }
  else {
    shmread($self->id, $buf, $pos, $size) or return undef;
  }
  $buf;
}

sub write
{
  @_ == 4 or croak '$shm->write(STRING, POS, SIZE)';
  my($self, $str, $pos, $size) = @_;
  if (defined $self->addr) {
    return memwrite($self->addr, $str, $pos, $size);
  }
  else {
    return shmwrite($self->id, $str, $pos, $size);
  }
}

1;

__END__

=head1 NAME

IPC::SharedMem - SysV Shared Memory IPC object class

=head1 SYNOPSIS

    use IPC::SysV qw(IPC_PRIVATE S_IRUSR S_IWUSR);
    use IPC::SharedMem;

    $shm = IPC::SharedMem->new(IPC_PRIVATE, 8, S_IRWXU);

    $shm->write(pack("S", 4711), 2, 2);

    $data = $shm->read(0, 2);

    $ds = $shm->stat;

    $shm->remove;

=head1 DESCRIPTION

A class providing an object based interface to SysV IPC shared memory.

=head1 METHODS

=over 4

=item new ( KEY , SIZE , FLAGS )

Creates a new shared memory segment of C<SIZE> bytes size associated
with C<KEY>. A new segment is created if

=over 4

=item *

C<KEY> is equal to C<IPC_PRIVATE>

=item *

C<KEY> does not already have a shared memory segment associated
with it, and C<I<FLAGS> & IPC_CREAT> is true.

=back

On creation of a new shared memory segment C<FLAGS> is used to
set the permissions.  Be careful not to set any flags that the
Sys V IPC implementation does not allow: in some systems setting
execute bits makes the operations fail.

=item id

Returns the shared memory identifier.

=item read ( POS, SIZE )

Read C<SIZE> bytes from the shared memory segment at C<POS>. Returns
the string read, or C<undef> if there was an error. The return value
becomes tainted. See L<shmread>.

=item write ( STRING, POS, SIZE )

Write C<SIZE> bytes to the shared memory segment at C<POS>. Returns
true if successful, or false if there is an error. See L<shmwrite>.

=item remove

Remove the shared memory segment from the system or mark it as
removed as long as any processes are still attached to it.

=item is_removed

Returns true if the shared memory segment has been removed or
marked for removal.

=item stat

Returns an object of type C<IPC::SharedMem::stat> which is a sub-class
of C<Class::Struct>. It provides the following fields. For a description
of these fields see you system documentation.

    uid
    gid
    cuid
    cgid
    mode
    segsz
    lpid
    cpid
    nattch
    atime
    dtime
    ctime

=item attach ( [FLAG] )

Permanently attach to the shared memory segment. When a C<IPC::SharedMem>
object is attached, it will use L<memread> and L<memwrite> instead of
L<shmread> and L<shmwrite> for accessing the shared memory segment.
Returns true if successful, or false on error. See L<shmat(2)>.

=item detach

Detach from the shared memory segment that previously has been attached
to. Returns true if successful, or false on error. See L<shmdt(2)>.

=item addr

Returns the address of the shared memory that has been attached to in a
format suitable for use with C<pack('P')>. Returns C<undef> if the shared
memory has not been attached.

=back

=head1 SEE ALSO

L<IPC::SysV>, L<Class::Struct>

=head1 AUTHORS

Marcus Holland-Moritz <mhx@cpan.org>

=head1 COPYRIGHT

Version 2.x, Copyright (C) 2007-2013, Marcus Holland-Moritz.

Version 1.x, Copyright (c) 1997, Graham Barr.

This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

=cut

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ################################################################################
#
#  Version 2.x, Copyright (C) 2007-2013, Marcus Holland-Moritz <mhx@cpan.org>.
#  Version 1.x, Copyright (C) 1997, Graham Barr <gbarr@pobox.com>.
#
#  This program is free software; you can redistribute it and/or
#  modify it under the same terms as Perl itself.
#
################################################################################

package IPC::SysV;

use strict;
use vars qw(@ISA @EXPORT @EXPORT_OK %EXPORT_TAGS $VERSION $AUTOLOAD);
use Carp;
use Config;

require Exporter;
@ISA = qw(Exporter);

$VERSION = '2.06_01';

# To support new constants, just add them to @EXPORT_OK
# and the C/XS code will be generated automagically.
@EXPORT_OK = (qw(

  GETALL GETNCNT GETPID GETVAL GETZCNT

  IPC_ALLOC IPC_CREAT IPC_EXCL IPC_GETACL IPC_INFO IPC_LOCKED
  IPC_M IPC_NOERROR IPC_NOWAIT IPC_PRIVATE IPC_R IPC_RMID
  IPC_SET IPC_SETACL IPC_SETLABEL IPC_STAT IPC_W IPC_WANTED

  MSG_EXCEPT MSG_FWAIT MSG_INFO MSG_LOCKED MSG_MWAIT MSG_NOERROR
  MSG_QWAIT MSG_R MSG_RWAIT MSG_STAT MSG_W MSG_WAIT MSG_WWAIT

  SEM_A SEM_ALLOC SEM_DEST SEM_ERR SEM_INFO SEM_ORDER SEM_R
  SEM_STAT SEM_UNDO

  SETALL SETVAL

  SHMLBA

  SHM_A SHM_CLEAR SHM_COPY SHM_DCACHE SHM_DEST SHM_ECACHE
  SHM_FMAP SHM_HUGETLB SHM_ICACHE SHM_INFO SHM_INIT SHM_LOCK
  SHM_LOCKED SHM_MAP SHM_NORESERVE SHM_NOSWAP SHM_R SHM_RDONLY
  SHM_REMAP SHM_REMOVED SHM_RND SHM_SHARE_MMU SHM_SHATTR
  SHM_SIZE SHM_STAT SHM_UNLOCK SHM_W

  S_IRUSR S_IWUSR S_IXUSR S_IRWXU
  S_IRGRP S_IWGRP S_IXGRP S_IRWXG
  S_IROTH S_IWOTH S_IXOTH S_IRWXO

  ENOSPC ENOSYS ENOMEM EACCES

), qw(

  ftok shmat shmdt memread memwrite

));

%EXPORT_TAGS = (
  all => [@EXPORT, @EXPORT_OK],
);

sub AUTOLOAD
{
  my $constname = $AUTOLOAD;
  $constname =~ s/.*:://;
  die "&IPC::SysV::_constant not defined" if $constname eq '_constant';
  my ($error, $val) = _constant($constname);
  if ($error) {
    my (undef, $file, $line) = caller;
    die "$error at $file line $line.\n";
  }
  {
    no strict 'refs';
    *$AUTOLOAD = sub { $val };
  }
  goto &$AUTOLOAD;
}

BOOT_XS: {
  # If I inherit DynaLoader then I inherit AutoLoader and I DON'T WANT TO
  require DynaLoader;

  # DynaLoader calls dl_load_flags as a static method.
  *dl_load_flags = DynaLoader->can('dl_load_flags');

  do {
    __PACKAGE__->can('bootstrap') || \&DynaLoader::bootstrap
  }->(__PACKAGE__, $VERSION);
}

1;

__END__

=head1 NAME

IPC::SysV - System V IPC constants and system calls

=head1 SYNOPSIS

  use IPC::SysV qw(IPC_STAT IPC_PRIVATE);

=head1 DESCRIPTION

C<IPC::SysV> defines and conditionally exports all the constants
defined in your system include files which are needed by the SysV
IPC calls.  Common ones include

  IPC_CREAT IPC_EXCL IPC_NOWAIT IPC_PRIVATE IPC_RMID IPC_SET IPC_STAT
  GETVAL SETVAL GETPID GETNCNT GETZCNT GETALL SETALL
  SEM_A SEM_R SEM_UNDO
  SHM_RDONLY SHM_RND SHMLBA

and auxiliary ones

  S_IRUSR S_IWUSR S_IRWXU
  S_IRGRP S_IWGRP S_IRWXG
  S_IROTH S_IWOTH S_IRWXO

but your system might have more.

=over 4

=item ftok( PATH )

=item ftok( PATH, ID )

Return a key based on PATH and ID, which can be used as a key for
C<msgget>, C<semget> and C<shmget>. See L<ftok(3)>.

If ID is omitted, it defaults to C<1>. If a single character is
given for ID, the numeric value of that character is used.

=item shmat( ID, ADDR, FLAG )

Attach the shared memory segment identified by ID to the address
space of the calling process. See L<shmat(2)>.

ADDR should be C<undef> unless you really know what you're doing.

=item shmdt( ADDR )

Detach the shared memory segment located at the address specified
by ADDR from the address space of the calling process. See L<shmdt(2)>.

=item memread( ADDR, VAR, POS, SIZE )

Reads SIZE bytes from a memory segment at ADDR starting at position POS.
VAR must be a variable that will hold the data read. Returns true if
successful, or false if there is an error. memread() taints the variable.

=item memwrite( ADDR, STRING, POS, SIZE )

Writes SIZE bytes from STRING to a memory segment at ADDR starting at
position POS. If STRING is too long, only SIZE bytes are used; if STRING
is too short, nulls are written to fill out SIZE bytes. Returns true if
successful, or false if there is an error.

=back

=head1 SEE ALSO

L<IPC::Msg>, L<IPC::Semaphore>, L<IPC::SharedMem>, L<ftok(3)>, L<shmat(2)>, L<shmdt(2)>

=head1 AUTHORS

Graham Barr <gbarr@pobox.com>,
Jarkko Hietaniemi <jhi@iki.fi>,
Marcus Holland-Moritz <mhx@cpan.org>

=head1 COPYRIGHT

Version 2.x, Copyright (C) 2007-2013, Marcus Holland-Moritz.

Version 1.x, Copyright (c) 1997, Graham Barr.

This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

=cut

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  package List::Util::XS;
use strict;
use List::Util;

our $VERSION = "1.42_02";       # FIXUP
$VERSION = eval $VERSION;    # FIXUP

1;
__END__

=head1 NAME

List::Util::XS - Indicate if List::Util was compiled with a C compiler

=head1 SYNOPSIS

    use List::Util::XS 1.20;

=head1 DESCRIPTION

C<List::Util::XS> can be used as a dependency to ensure List::Util was
installed using a C compiler and that the XS version is installed.

During installation C<$List::Util::XS::VERSION> will be set to
C<undef> if the XS was not compiled.

Starting with release 1.23_03, Scalar-List-Util is B<always> using
the XS implementation, but for backwards compatibility, we still
ship the C<List::Util::XS> module which just loads C<List::Util>.

=head1 SEE ALSO

L<Scalar::Util>, L<List::Util>, L<List::MoreUtils>

=head1 COPYRIGHT

Copyright (c) 2008 Graham Barr <gbarr@pobox.com>. All rights reserved.
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 package MIME::QuotedPrint;

use strict;
use vars qw(@ISA @EXPORT $VERSION);

require Exporter;
@ISA = qw(Exporter);
@EXPORT = qw(encode_qp decode_qp);

$VERSION = "3.13";

use MIME::Base64;  # will load XS version of {en,de}code_qp()

*encode = \&encode_qp;
*decode = \&decode_qp;

1;

__END__

=head1 NAME

MIME::QuotedPrint - Encoding and decoding of quoted-printable strings

=head1 SYNOPSIS

 use MIME::QuotedPrint;

 $encoded = encode_qp($decoded);
 $decoded = decode_qp($encoded);

=head1 DESCRIPTION

This module provides functions to encode and decode strings into and from the
quoted-printable encoding specified in RFC 2045 - I<MIME (Multipurpose
Internet Mail Extensions)>.  The quoted-printable encoding is intended
to represent data that largely consists of bytes that correspond to
printable characters in the ASCII character set.  Each non-printable
character (as defined by English Americans) is represented by a
triplet consisting of the character "=" followed by two hexadecimal
digits.

The following functions are provided:

=over 4

=item encode_qp( $str)

=item encode_qp( $str, $eol)

=item encode_qp( $str, $eol, $binmode )

This function returns an encoded version of the string ($str) given as
argument.

The second argument ($eol) is the line-ending sequence to use.  It is
optional and defaults to "\n".  Every occurrence of "\n" is replaced
with this string, and it is also used for additional "soft line
breaks" to ensure that no line end up longer than 76 characters.  Pass
it as "\015\012" to produce data suitable for external consumption.
The string "\r\n" produces the same result on many platforms, but not
all.

The third argument ($binmode) will select binary mode if passed as a
TRUE value.  In binary mode "\n" will be encoded in the same way as
any other non-printable character.  This ensures that a decoder will
end up with exactly the same string whatever line ending sequence it
uses.  In general it is preferable to use the base64 encoding for
binary data; see L<MIME::Base64>.

An $eol of "" (the empty string) is special.  In this case, no "soft
line breaks" are introduced and binary mode is effectively enabled so
that any "\n" in the original data is encoded as well.

=item decode_qp( $str )

This function returns the plain text version of the string given
as argument.  The lines of the result are "\n" terminated, even if
the $str argument contains "\r\n" terminated lines.

=back


If you prefer not to import these routines into your namespace, you can
call them as:

  use MIME::QuotedPrint ();
  $encoded = MIME::QuotedPrint::encode($decoded);
  $decoded = MIME::QuotedPrint::decode($encoded);

Perl v5.8 and better allow extended Unicode characters in strings.
Such strings cannot be encoded directly, as the quoted-printable
encoding is only defined for single-byte characters.  The solution is
to use the Encode module to select the byte encoding you want.  For
example:

    use MIME::QuotedPrint qw(encode_qp);
    use Encode qw(encode);

    $encoded = encode_qp(encode("UTF-8", "\x{FFFF}\n"));
    print $encoded;

=head1 COPYRIGHT

Copyright 1995-1997,2002-2004 Gisle Aas.

This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

=head1 SEE ALSO

L<MIME::Base64>

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      package MIME::Base64;

use strict;
use vars qw(@ISA @EXPORT @EXPORT_OK $VERSION);

require Exporter;
@ISA = qw(Exporter);
@EXPORT = qw(encode_base64 decode_base64);
@EXPORT_OK = qw(encode_base64url decode_base64url encoded_base64_length decoded_base64_length);

$VERSION = '3.15';

require XSLoader;
XSLoader::load('MIME::Base64', $VERSION);

*encode = \&encode_base64;
*decode = \&decode_base64;

sub encode_base64url {
    my $e = encode_base64(shift, "");
    $e =~ s/=+\z//;
    $e =~ tr[+/][-_];
    return $e;
}

sub decode_base64url {
    my $s = shift;
    $s =~ tr[-_][+/];
    $s .= '=' while length($s) % 4;
    return decode_base64($s);
}

1;

__END__

=head1 NAME

MIME::Base64 - Encoding and decoding of base64 strings

=head1 SYNOPSIS

 use MIME::Base64;

 $encoded = encode_base64('Aladdin:open sesame');
 $decoded = decode_base64($encoded);

=head1 DESCRIPTION

This module provides functions to encode and decode strings into and from the
base64 encoding specified in RFC 2045 - I<MIME (Multipurpose Internet
Mail Extensions)>. The base64 encoding is designed to represent
arbitrary sequences of octets in a form that need not be humanly
readable. A 65-character subset ([A-Za-z0-9+/=]) of US-ASCII is used,
enabling 6 bits to be represented per printable character.

The following primary functions are provided:

=over 4

=item encode_base64( $bytes )

=item encode_base64( $bytes, $eol );

Encode data by calling the encode_base64() function.  The first
argument is the byte string to encode.  The second argument is the
line-ending sequence to use.  It is optional and defaults to "\n".  The
returned encoded string is broken into lines of no more than 76
characters each and it will end with $eol unless it is empty.  Pass an
empty string as second argument if you do not want the encoded string
to be broken into lines.

The function will croak with "Wide character in subroutine entry" if $bytes
contains characters with code above 255.  The base64 encoding is only defined
for single-byte characters.  Use the Encode module to select the byte encoding
you want.

=item decode_base64( $str )

Decode a base64 string by calling the decode_base64() function.  This
function takes a single argument which is the string to decode and
returns the decoded data.

Any character not part of the 65-character base64 subset is
silently ignored.  Characters occurring after a '=' padding character
are never decoded.

=back

If you prefer not to import these routines into your namespace, you can
call them as:

    use MIME::Base64 ();
    $encoded = MIME::Base64::encode($decoded);
    $decoded = MIME::Base64::decode($encoded);

Additional functions not exported by default:

=over 4

=item encode_base64url( $bytes )

=item decode_base64url( $str )

Encode and decode according to the base64 scheme for "URL applications" [1].
This is a variant of the base64 encoding which does not use padding, does not
break the string into multiple lines and use the characters "-" and "_" instead
of "+" and "/" to avoid using reserved URL characters.

=item encoded_base64_length( $bytes )

=item encoded_base64_length( $bytes, $eol )

Returns the length that the encoded string would have without actually
encoding it.  This will return the same value as C<< length(encode_base64($bytes)) >>,
but should be more efficient.

=item decoded_base64_length( $str )

Returns the length that the decoded string would have without actually
decoding it.  This will return the same value as C<< length(decode_base64($str)) >>,
but should be more efficient.

=back

=head1 EXAMPLES

If you want to encode a large file, you should encode it in chunks
that are a multiple of 57 bytes.  This ensures that the base64 lines
line up and that you do not end up with padding in the middle. 57
bytes of data fills one complete base64 line (76 == 57*4/3):

   use MIME::Base64 qw(encode_base64);

   open(FILE, "/var/log/wtmp") or die "$!";
   while (read(FILE, $buf, 60*57)) {
       print encode_base64($buf);
   }

or if you know you have enough memory

   use MIME::Base64 qw(encode_base64);
   local($/) = undef;  # slurp
   print encode_base64(<STDIN>);

The same approach as a command line:

   perl -MMIME::Base64 -0777 -ne 'print encode_base64($_)' <file

Decoding does not need slurp mode if every line contains a multiple
of four base64 chars:

   perl -MMIME::Base64 -ne 'print decode_base64($_)' <file

Perl v5.8 and better allow extended Unicode characters in strings.
Such strings cannot be encoded directly, as the base64
encoding is only defined for single-byte characters.  The solution is
to use the Encode module to select the byte encoding you want.  For
example:

    use MIME::Base64 qw(encode_base64);
    use Encode qw(encode);

    $encoded = encode_base64(encode("UTF-8", "\x{FFFF}\n"));
    print $encoded;

=head1 COPYRIGHT

Copyright 1995-1999, 2001-2004, 2010 Gisle Aas.

This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

Distantly based on LWP::Base64 written by Martijn Koster
<m.koster@nexor.co.uk> and Joerg Reichelt <j.reichelt@nexor.co.uk> and
code posted to comp.lang.perl <3pd2lp$6gf@wsinti07.win.tue.nl> by Hans
Mulder <hansm@wsinti07.win.tue.nl>

The XS implementation uses code from metamail.  Copyright 1991 Bell
Communications Research, Inc. (Bellcore)

=head1 SEE ALSO

L<MIME::QuotedPrint>

[1] L<http://en.wikipedia.org/wiki/Base64#URL_applications>

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      package Math::BigInt::FastCalc;

use 5.006;
use strict;
use warnings;

use Math::BigInt::Calc 1.999706;

our $VERSION = '0.40';

##############################################################################
# global constants, flags and accessory

# announce that we are compatible with MBI v1.83 and up
sub api_version () { 2; }

# use Calc to override the methods that we do not provide in XS

for my $method (qw/
    str num
    add sub mul div
    rsft lsft
    mod modpow modinv
    gcd
    pow root sqrt log_int fac nok
    digit check
    from_hex from_bin from_oct as_hex as_bin as_oct
    zeros base_len
    xor or and
    alen 1ex
    /)
    {
    no strict 'refs';
    *{'Math::BigInt::FastCalc::_' . $method} = \&{'Math::BigInt::Calc::_' . $method};
    }

require XSLoader;
XSLoader::load(__PACKAGE__, $VERSION, Math::BigInt::Calc::_base_len());

##############################################################################
##############################################################################

1;

__END__

=pod

=head1 NAME

Math::BigInt::FastCalc - Math::BigInt::Calc with some XS for more speed

=head1 SYNOPSIS

Provides support for big integer calculations. Not intended to be used by
other modules. Other modules which sport the same functions can also be used
to support Math::BigInt, like L<Math::BigInt::GMP> or L<Math::BigInt::Pari>.

=head1 DESCRIPTION

In order to allow for multiple big integer libraries, Math::BigInt was
rewritten to use library modules for core math routines. Any module which
follows the same API as this can be used instead by using the following:

	use Math::BigInt lib => 'libname';

'libname' is either the long name ('Math::BigInt::Pari'), or only the short
version like 'Pari'. To use this library:

	use Math::BigInt lib => 'FastCalc';

Note that from L<Math::BigInt> v1.76 onwards, FastCalc will be loaded
automatically, if possible.

=head1 STORAGE

FastCalc works exactly like Calc, in stores the numbers in decimal form,
chopped into parts.

=head1 METHODS

The following functions are now implemented in FastCalc.xs:

	_is_odd		_is_even	_is_one		_is_zero
	_is_two		_is_ten
	_zero		_one		_two		_ten
	_acmp		_len
	_inc		_dec
	__strip_zeros	_copy

=head1 BUGS

Please report any bugs or feature requests to
C<bug-math-bigint-fastcalc at rt.cpan.org>, or through the web interface at
L<https://rt.cpan.org/Ticket/Create.html?Queue=Math-BigInt-FastCalc>
(requires login).
We will be notified, and then you'll automatically be notified of progress on
your bug as I make changes.

=head1 SUPPORT

You can find documentation for this module with the perldoc command.

    perldoc Math::BigInt::FastCalc

You can also look for information at:

=over 4

=item * RT: CPAN's request tracker

L<https://rt.cpan.org/Public/Dist/Display.html?Name=Math-BigInt-FastCalc>

=item * AnnoCPAN: Annotated CPAN documentation

L<http://annocpan.org/dist/Math-BigInt-FastCalc>

=item * CPAN Ratings

L<http://cpanratings.perl.org/dist/Math-BigInt-FastCalc>

=item * Search CPAN

L<http://search.cpan.org/dist/Math-BigInt-FastCalc/>

=item * CPAN Testers Matrix

L<http://matrix.cpantesters.org/?dist=Math-BigInt-FastCalc>

=item * The Bignum mailing list

=over 4

=item * Post to mailing list

C<bignum at lists.scsys.co.uk>

=item * View mailing list

L<http://lists.scsys.co.uk/pipermail/bignum/>

=item * Subscribe/Unsubscribe

L<http://lists.scsys.co.uk/cgi-bin/mailman/listinfo/bignum>

=back

=back

=head1 LICENSE

This program is free software; you may redistribute it and/or modify it under
the same terms as Perl itself.

=head1 AUTHORS

Original math code by Mark Biggar, rewritten by Tels L<http://bloodgate.com/>
in late 2000.
Separated from BigInt and shaped API with the help of John Peacock.

Fixed, sped-up and enhanced by Tels http://bloodgate.com 2001-2003.
Further streamlining (api_version 1 etc.) by Tels 2004-2007.

Bug-fixing by Peter John Acklam E<lt>pjacklam@online.noE<gt> 2010-2015.

=head1 SEE ALSO

L<Math::BigInt>, L<Math::BigFloat>, and the other backends
L<Math::BigInt::Calc>, L<Math::BigInt::GMP>, and L<Math::BigInt::Pari>.

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              package PerlIO::encoding;

use strict;
our $VERSION = '0.24';
our $DEBUG = 0;
$DEBUG and warn __PACKAGE__, " called by ", join(", ", caller), "\n";

#
# Equivalent of this is done in encoding.xs - do not uncomment.
#
# use Encode ();

require XSLoader;
XSLoader::load();

our $fallback =
    Encode::PERLQQ()|Encode::WARN_ON_ERR()|Encode::STOP_AT_PARTIAL();

1;
__END__

=head1 NAME

PerlIO::encoding - encoding layer

=head1 SYNOPSIS

  use PerlIO::encoding;

  open($f, "<:encoding(foo)", "infoo");
  open($f, ">:encoding(bar)", "outbar");

  use Encode qw(:fallbacks);
  $PerlIO::encoding::fallback = FB_PERLQQ;

=head1 DESCRIPTION

This PerlIO layer opens a filehandle with a transparent encoding filter.

On input, it converts the bytes expected to be in the specified
character set and encoding to Perl string data (Unicode and
Perl's internal Unicode encoding, UTF-8).  On output, it converts
Perl string data into the specified character set and encoding.

When the layer is pushed, the current value of C<$PerlIO::encoding::fallback>
is saved and used as the CHECK argument when calling the Encode methods
encode() and decode().

=head1 SEE ALSO

L<open>, L<Encode>, L<perlfunc/binmode>, L<perluniintro>

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             package PerlIO::mmap;
use strict;
use warnings;
our $VERSION = '0.016';

use XSLoader;
XSLoader::load(__PACKAGE__, __PACKAGE__->VERSION);

1;

__END__

=head1 NAME

PerlIO::mmap - Memory mapped IO

=head1 SYNOPSIS

 open my $fh, '<:mmap', $filename;

=head1 DESCRIPTION

This layer does C<read> and C<write> operations by mmap()ing the file if possible, but falls back to the default behavior if not.

=head1 IMPLEMENTATION NOTE

C<PerlIO::mmap> only exists to use XSLoader to load C code that provides support for using memory mapped IO. One does not need to explicitly C<use PerlIO::mmap;>.

=cut

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        package PerlIO::scalar;
our $VERSION = '0.24';
require XSLoader;
XSLoader::load();
1;
__END__

=head1 NAME

PerlIO::scalar - in-memory IO, scalar IO

=head1 SYNOPSIS

   my $scalar = '';
   ...
   open my $fh, "<",  \$scalar or die;
   open my $fh, ">",  \$scalar or die;
   open my $fh, ">>", \$scalar or die;

or

   my $scalar = '';
   ...
   open my $fh, "<:scalar",  \$scalar or die;
   open my $fh, ">:scalar",  \$scalar or die;
   open my $fh, ">>:scalar", \$scalar or die;

=head1 DESCRIPTION

A filehandle is opened but the file operations are performed "in-memory"
on a scalar variable.  All the normal file operations can be performed
on the handle. The scalar is considered a stream of bytes.  Currently
fileno($fh) returns -1.

=head1 IMPLEMENTATION NOTE

C<PerlIO::scalar> only exists to use XSLoader to load C code that
provides support for treating a scalar as an "in memory" file.
One does not need to explicitly C<use PerlIO::scalar>.

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 # Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.
#
# Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>

package Scalar::Util;

use strict;
require Exporter;

our @ISA       = qw(Exporter);
our @EXPORT_OK = qw(
  blessed refaddr reftype weaken unweaken isweak

  dualvar isdual isvstring looks_like_number openhandle readonly set_prototype
  tainted
);
our $VERSION    = "1.42_02";
$VERSION   = eval $VERSION;

require List::Util; # List::Util loads the XS
List::Util->VERSION( $VERSION ); # Ensure we got the right XS version (RT#100863)

our @EXPORT_FAIL;

unless (defined &weaken) {
  push @EXPORT_FAIL, qw(weaken);
}
unless (defined &isweak) {
  push @EXPORT_FAIL, qw(isweak isvstring);
}
unless (defined &isvstring) {
  push @EXPORT_FAIL, qw(isvstring);
}

sub export_fail {
  if (grep { /^(?:weaken|isweak)$/ } @_ ) {
    require Carp;
    Carp::croak("Weak references are not implemented in the version of perl");
  }

  if (grep { /^isvstring$/ } @_ ) {
    require Carp;
    Carp::croak("Vstrings are not implemented in the version of perl");
  }

  @_;
}

# set_prototype has been moved to Sub::Util with a different interface
sub set_prototype(&$)
{
  my ( $code, $proto ) = @_;
  return Sub::Util::set_prototype( $proto, $code );
}

1;

__END__

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              package PerlIO::via;
our $VERSION = '0.16';
require XSLoader;
XSLoader::load();
1;
__END__

=head1 NAME

PerlIO::via - Helper class for PerlIO layers implemented in perl

=head1 SYNOPSIS

   use PerlIO::via::Layer;
   open($fh,"<:via(Layer)",...);

   use Some::Other::Package;
   open($fh,">:via(Some::Other::Package)",...);

=head1 DESCRIPTION

The PerlIO::via module allows you to develop PerlIO layers in Perl, without
having to go into the nitty gritty of programming C with XS as the interface
to Perl.

One example module, L<PerlIO::via::QuotedPrint>, is included with Perl
5.8.0, and more example modules are available from CPAN, such as
L<PerlIO::via::StripHTML> and L<PerlIO::via::Base64>.  The
PerlIO::via::StripHTML module for instance, allows you to say:

	use PerlIO::via::StripHTML;
	open( my $fh, "<:via(StripHTML)", "index.html" );
        my @line = <$fh>;

to obtain the text of an HTML-file in an array with all the HTML-tags
automagically removed.

Please note that if the layer is created in the PerlIO::via:: namespace, it
does B<not> have to be fully qualified.  The PerlIO::via module will prefix
the PerlIO::via:: namespace if the specified modulename does not exist as a
fully qualified module name.

=head1 EXPECTED METHODS

To create a Perl module that implements a PerlIO layer in Perl (as opposed to
in C using XS as the interface to Perl), you need to supply some of the
following subroutines.  It is recommended to create these Perl modules in the
PerlIO::via:: namespace, so that they can easily be located on CPAN and use
the default namespace feature of the PerlIO::via module itself.

Please note that this is an area of recent development in Perl and that the
interface described here is therefore still subject to change (and hopefully
will have better documentation and more examples).

In the method descriptions below I<$fh> will be
a reference to a glob which can be treated as a perl file handle.
It refers to the layer below. I<$fh> is not passed if the layer
is at the bottom of the stack, for this reason and to maintain
some level of "compatibility" with TIEHANDLE classes it is passed last.

=over 4

=item $class->PUSHED([$mode,[$fh]])

Should return an object or the class, or -1 on failure.  (Compare
TIEHANDLE.)  The arguments are an optional mode string ("r", "w",
"w+", ...) and a filehandle for the PerlIO layer below.  Mandatory.

When the layer is pushed as part of an C<open> call, C<PUSHED> will be called
I<before> the actual open occurs, whether that be via C<OPEN>, C<SYSOPEN>,
C<FDOPEN> or by letting a lower layer do the open.

=item $obj->POPPED([$fh])

Optional - called when the layer is about to be removed.

=item $obj->UTF8($belowFlag,[$fh])

Optional - if present it will be called immediately after PUSHED has
returned. It should return a true value if the layer expects data to be
UTF-8 encoded. If it returns true, the result is as if the caller had done

   ":via(YourClass):utf8"

If not present or if it returns false, then the stream is left with
the UTF-8 flag clear.
The I<$belowFlag> argument will be true if there is a layer below
and that layer was expecting UTF-8.

=item $obj->OPEN($path,$mode,[$fh])

Optional - if not present a lower layer does the open.
If present, called for normal opens after the layer is pushed.
This function is subject to change as there is no easy way
to get a lower layer to do the open and then regain control.

=item $obj->BINMODE([$fh])

Optional - if not present the layer is popped on binmode($fh) or when C<:raw>
is pushed. If present it should return 0 on success, -1 on error, or undef
to pop the layer.

=item $obj->FDOPEN($fd,[$fh])

Optional - if not present a lower layer does the open.
If present, called after the layer is pushed for opens which pass
a numeric file descriptor.
This function is subject to change as there is no easy way
to get a lower layer to do the open and then regain control.

=item $obj->SYSOPEN($path,$imode,$perm,[$fh])

Optional - if not present a lower layer does the open.
If present, called after the layer is pushed for sysopen style opens
which pass a numeric mode and permissions.
This function is subject to change as there is no easy way
to get a lower layer to do the open and then regain control.

=item $obj->FILENO($fh)

Returns a numeric value for a Unix-like file descriptor. Returns -1 if
there isn't one.  Optional.  Default is fileno($fh).

=item $obj->READ($buffer,$len,$fh)

Returns the number of octets placed in $buffer (must be less than or
equal to $len).  Optional.  Default is to use FILL instead.

=item $obj->WRITE($buffer,$fh)

Returns the number of octets from $buffer that have been successfully written.

=item $obj->FILL($fh)

Should return a string to be placed in the buffer.  Optional. If not
provided, must provide READ or reject handles open for reading in
PUSHED.

=item $obj->CLOSE($fh)

Should return 0 on success, -1 on error.
Optional.

=item $obj->SEEK($posn,$whence,$fh)

Should return 0 on success, -1 on error.
Optional.  Default is to fail, but that is likely to be changed
in future.

=item $obj->TELL($fh)

Returns file position.
Optional.  Default to be determined.

=item $obj->UNREAD($buffer,$fh)

Returns the number of octets from $buffer that have been successfully
saved to be returned on future FILL/READ calls.  Optional.  Default is
to push data into a temporary layer above this one.

=item $obj->FLUSH($fh)

Flush any buffered write data.  May possibly be called on readable
handles too.  Should return 0 on success, -1 on error.

=item $obj->SETLINEBUF($fh)

Optional. No return.

=item $obj->CLEARERR($fh)

Optional. No return.

=item $obj->ERROR($fh)

Optional. Returns error state. Default is no error until a mechanism
to signal error (die?) is worked out.

=item $obj->EOF($fh)

Optional. Returns end-of-file state. Default is a function of the return
value of FILL or READ.

=back

=head1 EXAMPLES

Check the PerlIO::via:: namespace on CPAN for examples of PerlIO layers
implemented in Perl.  To give you an idea how simple the implementation of
a PerlIO layer can look, a simple example is included here.

=head2 Example - a Hexadecimal Handle

Given the following module, PerlIO::via::Hex :

    package PerlIO::via::Hex;

    sub PUSHED
    {
     my ($class,$mode,$fh) = @_;
     # When writing we buffer the data
     my $buf = '';
     return bless \$buf,$class;
    }

    sub FILL
    {
     my ($obj,$fh) = @_;
     my $line = <$fh>;
     return (defined $line) ? pack("H*", $line) : undef;
    }

    sub WRITE
    {
     my ($obj,$buf,$fh) = @_;
     $$obj .= unpack("H*", $buf);
     return length($buf);
    }

    sub FLUSH
    {
     my ($obj,$fh) = @_;
     print $fh $$obj or return -1;
     $$obj = '';
     return 0;
    }

    1;

The following code opens up an output handle that will convert any
output to a hexadecimal dump of the output bytes: for example "A" will
be converted to "41" (on ASCII-based machines, on EBCDIC platforms
the "A" will become "c1")

    use PerlIO::via::Hex;
    open(my $fh, ">:via(Hex)", "foo.hex");

and the following code will read the hexdump in and convert it
on the fly back into bytes:

    open(my $fh, "<:via(Hex)", "foo.hex");

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 # Copyright (c) 2014 Paul Evans <leonerd@leonerd.org.uk>. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.

package Sub::Util;

use strict;
use warnings;

require Exporter;

our @ISA = qw( Exporter );
our @EXPORT_OK = qw(
  prototype set_prototype
  subname set_subname
);

our $VERSION    = "1.42_02";
$VERSION   = eval $VERSION;

require List::Util; # as it has the XS
List::Util->VERSION( $VERSION ); # Ensure we got the right XS version (RT#100863)

=head1 NAME

Sub::Util - A selection of utility subroutines for subs and CODE references

=head1 SYNOPSIS

    use Sub::Util qw( prototype set_prototype subname set_subname );

=head1 DESCRIPTION

C<Sub::Util> contains a selection of utility subroutines that are useful for
operating on subs and CODE references.

The rationale for inclusion in this module is that the function performs some
work for which an XS implementation is essential because it cannot be
implemented in Pure Perl, and which is sufficiently-widely used across CPAN
that its popularity warrants inclusion in a core module, which this is.

=cut

=head1 FUNCTIONS

=cut

=head2 prototype

    my $proto = prototype( $code )

I<Since version 1.40.>

Returns the prototype of the given C<$code> reference, if it has one, as a
string. This is the same as the C<CORE::prototype> operator; it is included
here simply for symmetry and completeness with the other functions.

=cut

sub prototype
{
  my ( $code ) = @_;
  return CORE::prototype( $code );
}

=head2 set_prototype

    my $code = set_prototype $prototype, $code;

I<Since version 1.40.>

Sets the prototype of the function given by the C<$code> reference, or deletes
it if C<$prototype> is C<undef>. Returns the C<$code> reference itself.

I<Caution>: This function takes arguments in a different order to the previous
copy of the code from C<Scalar::Util>. This is to match the order of
C<set_subname>, and other potential additions in this file. This order has
been chosen as it allows a neat and simple chaining of other
C<Sub::Util::set_*> functions as might become available, such as:

 my $code =
    set_subname   name_here =>
    set_prototype '&@'      =>
    set_attribute ':lvalue' =>
       sub { ...... };

=cut

=head2 subname

    my $name = subname( $code )

I<Since version 1.40.>

Returns the name of the given C<$code> reference, if it has one. Normal named
subs will give a fully-qualified name consisting of the package and the
localname separated by C<::>. Anonymous code references will give C<__ANON__>
as the localname. If a name has been set using L</set_subname>, this name will
be returned instead.

This function was inspired by C<sub_fullname> from L<Sub::Identify>. The
remaining functions that C<Sub::Identify> implements can easily be emulated
using regexp operations, such as

 sub get_code_info { return (subname $_[0]) =~ m/^(.+)::(.+?)$/ }
 sub sub_name      { return (get_code_info $_[0])[0] }
 sub stash_name    { return (get_code_info $_[0])[1] }

I<Users of Sub::Name beware>: This function is B<not> the same as
C<Sub::Name::subname>; it returns the existing name of the sub rather than
changing it. To set or change a name, see instead L</set_subname>.

=cut

=head2 set_subname

    my $code = set_subname $name, $code;

I<Since version 1.40.>

Sets the name of the function given by the C<$code> reference. Returns the
C<$code> reference itself. If the C<$name> is unqualified, the package of the
caller is used to qualify it.

This is useful for applying names to anonymous CODE references so that stack
traces and similar situations, to give a useful name rather than having the
default of C<__ANON__>. Note that this name is only used for this situation;
the C<set_subname> will not install it into the symbol table; you will have to
do that yourself if required.

However, since the name is not used by perl except as the return value of
C<caller>, for stack traces or similar, there is no actual requirement that
the name be syntactically valid as a perl function name. This could be used to
attach extra information that could be useful in debugging stack traces.

This function was copied from C<Sub::Name::subname> and renamed to the naming
convention of this module.

=cut

=head1 AUTHOR

The general structure of this module was written by Paul Evans
<leonerd@leonerd.org.uk>.

The XS implementation of L</set_subname> was copied from L<Sub::Name> by
Matthijs van Duin <xmath@cpan.org>

=cut

1;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           package Sys::Hostname;

use strict;

use Carp;

require Exporter;

our @ISA     = qw/ Exporter /;
our @EXPORT  = qw/ hostname /;

our $VERSION;

our $host;

BEGIN {
    $VERSION = '1.20';
    {
	local $SIG{__DIE__};
	eval {
	    require XSLoader;
	    XSLoader::load();
	};
	warn $@ if $@;
    }
}


sub hostname {

  # method 1 - we already know it
  return $host if defined $host;

  # method 1' - try to ask the system
  $host = ghname() if defined &ghname;
  return $host if defined $host;

  if ($^O eq 'VMS') {

    # method 2 - no sockets ==> return DECnet node name
    eval { local $SIG{__DIE__}; $host = (gethostbyname('me'))[0] };
    if ($@) { return $host = $ENV{'SYS$NODE'}; }

    # method 3 - has someone else done the job already?  It's common for the
    #    TCP/IP stack to advertise the hostname via a logical name.  (Are
    #    there any other logicals which TCP/IP stacks use for the host name?)
    $host = $ENV{'ARPANET_HOST_NAME'}  || $ENV{'INTERNET_HOST_NAME'} ||
            $ENV{'MULTINET_HOST_NAME'} || $ENV{'UCX$INET_HOST'}      ||
            $ENV{'TCPWARE_DOMAINNAME'} || $ENV{'NEWS_ADDRESS'};
    return $host if $host;

    # method 4 - does hostname happen to work?
    my($rslt) = `hostname`;
    if ($rslt !~ /IVVERB/) { ($host) = $rslt =~ /^(\S+)/; }
    return $host if $host;

    # rats!
    $host = '';
    croak "Cannot get host name of local machine";  

  }
  elsif ($^O eq 'MSWin32') {
    ($host) = gethostbyname('localhost');
    chomp($host = `hostname 2> NUL`) unless defined $host;
    return $host;
  }
  else {  # Unix
    # is anyone going to make it here?

    local $ENV{PATH} = '/usr/bin:/bin:/usr/sbin:/sbin'; # Paranoia.

    # method 2 - syscall is preferred since it avoids tainting problems
    # XXX: is it such a good idea to return hostname untainted?
    eval {
	local $SIG{__DIE__};
	require "syscall.ph";
	$host = "\0" x 65; ## preload scalar
	syscall(&SYS_gethostname, $host, 65) == 0;
    }

    # method 2a - syscall using systeminfo instead of gethostname
    #           -- needed on systems like Solaris
    || eval {
	local $SIG{__DIE__};
	require "sys/syscall.ph";
	require "sys/systeminfo.ph";
	$host = "\0" x 65; ## preload scalar
	syscall(&SYS_systeminfo, &SI_HOSTNAME, $host, 65) != -1;
    }

    # method 3 - trusty old hostname command
    || eval {
	local $SIG{__DIE__};
	local $SIG{CHLD};
	$host = `(hostname) 2>/dev/null`; # BSDish
    }

    # method 4 - use POSIX::uname(), which strictly can't be expected to be
    # correct
    || eval {
	local $SIG{__DIE__};
	require POSIX;
	$host = (POSIX::uname())[1];
    }

    # method 5 - sysV uname command (may truncate)
    || eval {
	local $SIG{__DIE__};
	$host = `uname -n 2>/dev/null`; ## sysVish
    }

    # bummer
    || croak "Cannot get host name of local machine";  

    # remove garbage 
    $host =~ tr/\0\r\n//d;
    $host;
  }
}

1;

__END__

=head1 NAME

Sys::Hostname - Try every conceivable way to get hostname

=head1 SYNOPSIS

    use Sys::Hostname;
    $host = hostname;

=head1 DESCRIPTION

Attempts several methods of getting the system hostname and
then caches the result.  It tries the first available of the C
library's gethostname(), C<`$Config{aphostname}`>, uname(2),
C<syscall(SYS_gethostname)>, C<`hostname`>, C<`uname -n`>,
and the file F</com/host>.  If all that fails it C<croak>s.

All NULs, returns, and newlines are removed from the result.

=head1 AUTHOR

David Sundstrom E<lt>F<sunds@asictest.sc.ti.com>E<gt>

Texas Instruments

XS code added by Greg Bacon E<lt>F<gbacon@cs.uah.edu>E<gt>

=cut

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             package Sys::Syslog;
use strict;
use warnings;
use warnings::register;
use Carp;
use Exporter        qw< import >;
use File::Basename;
use POSIX           qw< strftime setlocale LC_TIME >;
use Socket          qw< :all >;
require 5.005;


{   no strict 'vars';
    $VERSION = '0.33_01';

    %EXPORT_TAGS = (
        standard => [qw(openlog syslog closelog setlogmask)],
        extended => [qw(setlogsock)],
        macros => [
            # levels
            qw(
                LOG_ALERT LOG_CRIT LOG_DEBUG LOG_EMERG LOG_ERR 
                LOG_INFO LOG_NOTICE LOG_WARNING
            ), 

            # standard facilities
            qw(
                LOG_AUTH LOG_AUTHPRIV LOG_CRON LOG_DAEMON LOG_FTP LOG_KERN
                LOG_LOCAL0 LOG_LOCAL1 LOG_LOCAL2 LOG_LOCAL3 LOG_LOCAL4
                LOG_LOCAL5 LOG_LOCAL6 LOG_LOCAL7 LOG_LPR LOG_MAIL LOG_NEWS
                LOG_SYSLOG LOG_USER LOG_UUCP
            ),
            # Mac OS X specific facilities
            qw( LOG_INSTALL LOG_LAUNCHD LOG_NETINFO LOG_RAS LOG_REMOTEAUTH ),
            # modern BSD specific facilities
            qw( LOG_CONSOLE LOG_NTP LOG_SECURITY ),
            # IRIX specific facilities
            qw( LOG_AUDIT LOG_LFMT ),

            # options
            qw(
                LOG_CONS LOG_PID LOG_NDELAY LOG_NOWAIT LOG_ODELAY LOG_PERROR 
            ), 

            # others macros
            qw(
                LOG_FACMASK LOG_NFACILITIES LOG_PRIMASK 
                LOG_MASK LOG_UPTO
            ), 
        ],
    );

    @EXPORT = (
        @{$EXPORT_TAGS{standard}}, 
    );

    @EXPORT_OK = (
        @{$EXPORT_TAGS{extended}}, 
        @{$EXPORT_TAGS{macros}}, 
    );

    eval {
        require XSLoader;
        XSLoader::load('Sys::Syslog', $VERSION);
        1
    } or do {
        require DynaLoader;
        push @ISA, 'DynaLoader';
        bootstrap Sys::Syslog $VERSION;
    };
}


# 
# Public variables
# 
use vars qw($host);             # host to send syslog messages to (see notes at end)

#
# Prototypes
#
sub silent_eval (&);

# 
# Global variables
# 
use vars qw($facility);
my $connected       = 0;        # flag to indicate if we're connected or not
my $syslog_send;                # coderef of the function used to send messages
my $syslog_path     = undef;    # syslog path for "stream" and "unix" mechanisms
my $syslog_xobj     = undef;    # if defined, holds the external object used to send messages
my $transmit_ok     = 0;        # flag to indicate if the last message was transmitted
my $sock_port       = undef;    # socket port
my $sock_timeout    = 0;        # socket timeout, see below
my $current_proto   = undef;    # current mechanism used to transmit messages
my $ident           = '';       # identifiant prepended to each message
$facility           = '';       # current facility
my $maskpri         = LOG_UPTO(&LOG_DEBUG);     # current log mask

my %options = (
    ndelay  => 0, 
    noeol   => 0,
    nofatal => 0, 
    nonul   => 0,
    nowait  => 0, 
    perror  => 0, 
    pid     => 0, 
);

# Default is now to first use the native mechanism, so Perl programs 
# behave like other normal Unix programs, then try other mechanisms.
my @connectMethods = qw(native tcp udp unix pipe stream console);
if ($^O eq "freebsd" or $^O eq "linux") {
    @connectMethods = grep { $_ ne 'udp' } @connectMethods;
}

# And on Win32 systems, we try to use the native mechanism for this 
# platform, the events logger, available through Win32::EventLog.
EVENTLOG: {
    my $is_Win32 = $^O =~ /Win32/i;

    if (can_load("Sys::Syslog::Win32", $is_Win32)) {
        unshift @connectMethods, 'eventlog';
    }
}

my @defaultMethods = @connectMethods;
my @fallbackMethods = ();

# The timeout in connection_ok() was pushed up to 0.25 sec in 
# Sys::Syslog v0.19 in order to address a heisenbug on MacOSX:
# http://london.pm.org/pipermail/london.pm/Week-of-Mon-20061211/005961.html
# 
# However, this also had the effect of slowing this test for 
# all other operating systems, which apparently impacted some 
# users (cf. CPAN-RT #34753). So, in order to make everybody 
# happy, the timeout is now zero by default on all systems 
# except on OSX where it is set to 250 msec, and can be set 
# with the infamous setlogsock() function.
#
# Update 2011-08: this issue is also been seen on multiprocessor
# Debian GNU/kFreeBSD systems. See http://bugs.debian.org/627821
# and https://rt.cpan.org/Ticket/Display.html?id=69997
# Also, lowering the delay to 1 ms, which should be enough.

$sock_timeout = 0.001 if $^O =~ /darwin|gnukfreebsd/;


# Perl 5.6.0's warnings.pm doesn't have warnings::warnif()
if (not defined &warnings::warnif) {
    *warnings::warnif = sub {
        goto &warnings::warn if warnings::enabled(__PACKAGE__)
    }
}

# coderef for a nicer handling of errors
my $err_sub = $options{nofatal} ? \&warnings::warnif : \&croak;


sub AUTOLOAD {
    # This AUTOLOAD is used to 'autoload' constants from the constant()
    # XS function.
    no strict 'vars';
    my $constname;
    ($constname = $AUTOLOAD) =~ s/.*:://;
    croak "Sys::Syslog::constant() not defined" if $constname eq 'constant';
    my ($error, $val) = constant($constname);
    croak $error if $error;
    no strict 'refs';
    *$AUTOLOAD = sub { $val };
    goto &$AUTOLOAD;
}


sub openlog {
    ($ident, my $logopt, $facility) = @_;

    # default values
    $ident    ||= basename($0) || getlogin() || getpwuid($<) || 'syslog';
    $logopt   ||= '';
    $facility ||= LOG_USER();

    for my $opt (split /\b/, $logopt) {
        $options{$opt} = 1 if exists $options{$opt}
    }

    $err_sub = delete $options{nofatal} ? \&warnings::warnif : \&croak;
    return 1 unless $options{ndelay};
    connect_log();
} 

sub closelog {
    disconnect_log() if $connected;
    $options{$_} = 0 for keys %options;
    $facility = $ident = "";
    $connected = 0;
    return 1
} 

sub setlogmask {
    my $oldmask = $maskpri;
    $maskpri = shift unless $_[0] == 0;
    $oldmask;
}


my %mechanism = (
    console => {
        check   => sub { 1 },
    },
    eventlog => {
        check   => sub { return can_load("Win32::EventLog") },
        err_msg => "no Win32 API available",
    },
    inet => {
        check   => sub { 1 },
    },
    native => {
        check   => sub { 1 },
    },
    pipe => {
        check   => sub {
            ($syslog_path) = grep { defined && length && -p && -w _ }
                                $syslog_path, &_PATH_LOG, "/dev/log";
            return $syslog_path ? 1 : 0
        },
        err_msg => "path not available",
    },
    stream => {
        check   => sub {
            if (not defined $syslog_path) {
                my @try = qw(/dev/log /dev/conslog);
                unshift @try, &_PATH_LOG  if length &_PATH_LOG;
                ($syslog_path) = grep { -w } @try;
            }
            return defined $syslog_path && -w $syslog_path
        },
        err_msg => "could not find any writable device",
    },
    tcp => {
        check   => sub {
            return 1 if defined $sock_port;

            if (getservbyname('syslog', 'tcp') || getservbyname('syslogng', 'tcp')) {
                $host = $syslog_path;
                return 1
            }
            else {
                return
            }
        },
        err_msg => "TCP service unavailable",
    },
    udp => {
        check   => sub {
            return 1 if defined $sock_port;

            if (getservbyname('syslog', 'udp')) {
                $host = $syslog_path;
                return 1
            }
            else {
                return
            }
        },
        err_msg => "UDP service unavailable",
    },
    unix => {
        check   => sub {
            my @try = ($syslog_path, &_PATH_LOG);
            ($syslog_path) = grep { defined && length && -w } @try;
            return defined $syslog_path && -w $syslog_path
        },
        err_msg => "path not available",
    },
);
 
sub setlogsock {
    my %opt;

    # handle arguments
    # - old API: setlogsock($sock_type, $sock_path, $sock_timeout)
    # - new API: setlogsock(\%options)
    croak "setlogsock(): Invalid number of arguments"
        unless @_ >= 1 and @_ <= 3;

    if (my $ref = ref $_[0]) {
        if ($ref eq "HASH") {
            %opt = %{ $_[0] };
            croak "setlogsock(): No argument given" unless keys %opt;
        }
        elsif ($ref eq "ARRAY") {
            @opt{qw< type path timeout >} = @_;
        }
        else {
            croak "setlogsock(): Unexpected \L$ref\E reference"
        }
    }
    else {
        @opt{qw< type path timeout >} = @_;
    }

    # check socket type, remove invalid ones
    my $diag_invalid_type = "setlogsock(): Invalid type%s; must be one of "
                          . join ", ", map { "'$_'" } sort keys %mechanism;
    croak sprintf $diag_invalid_type, "" unless defined $opt{type};
    my @sock_types = ref $opt{type} eq "ARRAY" ? @{$opt{type}} : ($opt{type});
    my @tmp;

    for my $sock_type (@sock_types) {
        carp sprintf $diag_invalid_type, " '$sock_type'" and next
            unless exists $mechanism{$sock_type};
        push @tmp, "tcp", "udp" and next  if $sock_type eq "inet";
        push @tmp, $sock_type;
    }

    @sock_types = @tmp;

    # set global options
    $syslog_path  = $opt{path}    if defined $opt{path};
    $host         = $opt{host}    if defined $opt{host};
    $sock_timeout = $opt{timeout} if defined $opt{timeout};
    $sock_port    = $opt{port}    if defined $opt{port};

    disconnect_log() if $connected;
    $transmit_ok = 0;
    @fallbackMethods = ();
    @connectMethods = ();
    my $found = 0;

    # check each given mechanism and test if it can be used on the current system
    for my $sock_type (@sock_types) {
        if ( $mechanism{$sock_type}{check}->() ) {
            push @connectMethods, $sock_type;
            $found = 1;
        }
        else {
            warnings::warnif("setlogsock(): type='$sock_type': "
                           . $mechanism{$sock_type}{err_msg});
        }
    }

    # if no mechanism worked from the given ones, use the default ones
    @connectMethods = @defaultMethods unless @connectMethods;

    return $found;
}

sub syslog {
    my ($priority, $mask, @args) = @_;
    my ($message, $buf);
    my (@words, $num, $numpri, $numfac, $sum);
    my $failed = undef;
    my $fail_time = undef;
    my $error = $!;

    # if $ident is undefined, it means openlog() wasn't previously called
    # so do it now in order to have sensible defaults
    openlog() unless $ident;

    local $facility = $facility;    # may need to change temporarily.

    croak "syslog: expecting argument \$priority" unless defined $priority;
    croak "syslog: expecting argument \$format"   unless defined $mask;

    if ($priority =~ /^\d+$/) {
        $numpri = LOG_PRI($priority);
        $numfac = LOG_FAC($priority) << 3;
    }
    elsif ($priority =~ /^\w+/) {
        # Allow "level" or "level|facility".
        @words = split /\W+/, $priority, 2;

        undef $numpri;
        undef $numfac;

        for my $word (@words) {
            next if length $word == 0;

            # Translate word to number.
            $num = xlate($word);

            if ($num < 0) {
                croak "syslog: invalid level/facility: $word"
            }
            elsif ($num <= LOG_PRIMASK() and $word ne "kern") {
                croak "syslog: too many levels given: $word"
                    if defined $numpri;
                $numpri = $num;
            }
            else {
                croak "syslog: too many facilities given: $word"
                    if defined $numfac;
                $facility = $word if $word =~ /^[A-Za-z]/;
                $numfac = $num;
            }
        }
    }
    else {
        croak "syslog: invalid level/facility: $priority"
    }

    croak "syslog: level must be given" unless defined $numpri;

    # don't log if priority is below mask level
    return 0 unless LOG_MASK($numpri) & $maskpri;

    if (not defined $numfac) {  # Facility not specified in this call.
	$facility = 'user' unless $facility;
	$numfac = xlate($facility);
    }

    connect_log() unless $connected;

    if ($mask =~ /%m/) {
        # escape percent signs for sprintf()
        $error =~ s/%/%%/g if @args;
        # replace %m with $error, if preceded by an even number of percent signs
        $mask =~ s/(?<!%)((?:%%)*)%m/$1$error/g;
    }

    $mask .= "\n" unless $mask =~ /\n$/;
    $message = @args ? sprintf($mask, @args) : $mask;

    if ($current_proto eq 'native') {
        $buf = $message;
    }
    elsif ($current_proto eq 'eventlog') {
        $buf = $message;
    }
    else {
        my $whoami = $ident;
        $whoami .= "[$$]" if $options{pid};

        $sum = $numpri + $numfac;
        my $oldlocale = setlocale(LC_TIME);
        setlocale(LC_TIME, 'C');
        my $timestamp = strftime "%b %d %H:%M:%S", localtime;
        setlocale(LC_TIME, $oldlocale);

        # construct the stream that will be transmitted
        $buf = "<$sum>$timestamp $whoami: $message";

        # add (or not) a newline
        $buf .= "\n" if !$options{noeol} and rindex($buf, "\n") == -1;

        # add (or not) a NUL character
        $buf .= "\0" if !$options{nonul};
    }

    # handle PERROR option
    # "native" mechanism already handles it by itself
    if ($options{perror} and $current_proto ne 'native') {
        my $whoami = $ident;
        $whoami .= "[$$]" if $options{pid};
        print STDERR "$whoami: $message\n";
    }

    # it's possible that we'll get an error from sending
    # (e.g. if method is UDP and there is no UDP listener,
    # then we'll get ECONNREFUSED on the send). So what we
    # want to do at this point is to fallback onto a different
    # connection method.
    while (scalar @fallbackMethods || $syslog_send) {
	if ($failed && (time - $fail_time) > 60) {
	    # it's been a while... maybe things have been fixed
	    @fallbackMethods = ();
	    disconnect_log();
	    $transmit_ok = 0; # make it look like a fresh attempt
	    connect_log();
        }

	if ($connected && !connection_ok()) {
	    # Something was OK, but has now broken. Remember coz we'll
	    # want to go back to what used to be OK.
	    $failed = $current_proto unless $failed;
	    $fail_time = time;
	    disconnect_log();
	}

	connect_log() unless $connected;
	$failed = undef if ($current_proto && $failed && $current_proto eq $failed);

	if ($syslog_send) {
            if ($syslog_send->($buf, $numpri, $numfac)) {
		$transmit_ok++;
		return 1;
	    }
	    # typically doesn't happen, since errors are rare from write().
	    disconnect_log();
	}
    }
    # could not send, could not fallback onto a working
    # connection method. Lose.
    return 0;
}

sub _syslog_send_console {
    my ($buf) = @_;

    # The console print is a method which could block
    # so we do it in a child process and always return success
    # to the caller.
    if (my $pid = fork) {

	if ($options{nowait}) {
	    return 1;
	} else {
	    if (waitpid($pid, 0) >= 0) {
	    	return ($? >> 8);
	    } else {
		# it's possible that the caller has other
		# plans for SIGCHLD, so let's not interfere
		return 1;
	    }
	}
    } else {
        if (open(CONS, ">/dev/console")) {
	    my $ret = print CONS $buf . "\r";  # XXX: should this be \x0A ?
	    POSIX::_exit($ret) if defined $pid;
	    close CONS;
	}

	POSIX::_exit(0) if defined $pid;
    }
}

sub _syslog_send_stream {
    my ($buf) = @_;
    # XXX: this only works if the OS stream implementation makes a write 
    # look like a putmsg() with simple header. For instance it works on 
    # Solaris 8 but not Solaris 7.
    # To be correct, it should use a STREAMS API, but perl doesn't have one.
    return syswrite(SYSLOG, $buf, length($buf));
}

sub _syslog_send_pipe {
    my ($buf) = @_;
    return print SYSLOG $buf;
}

sub _syslog_send_socket {
    my ($buf) = @_;
    return syswrite(SYSLOG, $buf, length($buf));
    #return send(SYSLOG, $buf, 0);
}

sub _syslog_send_native {
    my ($buf, $numpri, $numfac) = @_;
    syslog_xs($numpri|$numfac, $buf);
    return 1;
}


# xlate()
# -----
# private function to translate names to numeric values
# 
sub xlate {
    my ($name) = @_;

    return $name+0 if $name =~ /^\s*\d+\s*$/;
    $name = uc $name;
    $name = "LOG_$name" unless $name =~ /^LOG_/;

    # ExtUtils::Constant 0.20 introduced a new way to implement
    # constants, called ProxySubs.  When it was used to generate
    # the C code, the constant() function no longer returns the 
    # correct value.  Therefore, we first try a direct call to 
    # constant(), and if the value is an error we try to call the 
    # constant by its full name. 
    my $value = constant($name);

    if (index($value, "not a valid") >= 0) {
        $name = "Sys::Syslog::$name";
        $value = eval { no strict "refs"; &$name };
        $value = $@ unless defined $value;
    }

    $value = -1 if index($value, "not a valid") >= 0;

    return defined $value ? $value : -1;
}


# connect_log()
# -----------
# This function acts as a kind of front-end: it tries to connect to 
# a syslog service using the selected methods, trying each one in the 
# selected order. 
# 
sub connect_log {
    @fallbackMethods = @connectMethods unless scalar @fallbackMethods;

    if ($transmit_ok && $current_proto) {
        # Retry what we were on, because it has worked in the past.
	unshift(@fallbackMethods, $current_proto);
    }

    $connected = 0;
    my @errs = ();
    my $proto = undef;

    while ($proto = shift @fallbackMethods) {
	no strict 'refs';
	my $fn = "connect_$proto";
	$connected = &$fn(\@errs) if defined &$fn;
	last if $connected;
    }

    $transmit_ok = 0;
    if ($connected) {
	$current_proto = $proto;
        my ($old) = select(SYSLOG); $| = 1; select($old);
    } else {
	@fallbackMethods = ();
        $err_sub->(join "\n\t- ", "no connection to syslog available", @errs);
        return undef;
    }
}

sub connect_tcp {
    my ($errs) = @_;

    my $proto = getprotobyname('tcp');
    if (!defined $proto) {
	push @$errs, "getprotobyname failed for tcp";
	return 0;
    }

    my $port = $sock_port || getservbyname('syslog', 'tcp');
    $port = getservbyname('syslogng', 'tcp') unless defined $port;
    if (!defined $port) {
	push @$errs, "getservbyname failed for syslog/tcp and syslogng/tcp";
	return 0;
    }

    my $addr;
    if (defined $host) {
        $addr = inet_aton($host);
        if (!$addr) {
	    push @$errs, "can't lookup $host";
	    return 0;
	}
    } else {
        $addr = INADDR_LOOPBACK;
    }
    $addr = sockaddr_in($port, $addr);

    if (!socket(SYSLOG, AF_INET, SOCK_STREAM, $proto)) {
	push @$errs, "tcp socket: $!";
	return 0;
    }

    setsockopt(SYSLOG, SOL_SOCKET, SO_KEEPALIVE, 1);
    if (silent_eval { IPPROTO_TCP() }) {
        # These constants don't exist in 5.005. They were added in 1999
        setsockopt(SYSLOG, IPPROTO_TCP(), TCP_NODELAY(), 1);
    }
    if (!connect(SYSLOG, $addr)) {
	push @$errs, "tcp connect: $!";
	return 0;
    }

    $syslog_send = \&_syslog_send_socket;

    return 1;
}

sub connect_udp {
    my ($errs) = @_;

    my $proto = getprotobyname('udp');
    if (!defined $proto) {
	push @$errs, "getprotobyname failed for udp";
	return 0;
    }

    my $port = $sock_port || getservbyname('syslog', 'udp');
    if (!defined $port) {
	push @$errs, "getservbyname failed for syslog/udp";
	return 0;
    }

    my $addr;
    if (defined $host) {
        $addr = inet_aton($host);
        if (!$addr) {
	    push @$errs, "can't lookup $host";
	    return 0;
	}
    } else {
        $addr = INADDR_LOOPBACK;
    }
    $addr = sockaddr_in($port, $addr);

    if (!socket(SYSLOG, AF_INET, SOCK_DGRAM, $proto)) {
	push @$errs, "udp socket: $!";
	return 0;
    }
    if (!connect(SYSLOG, $addr)) {
	push @$errs, "udp connect: $!";
	return 0;
    }

    # We want to check that the UDP connect worked. However the only
    # way to do that is to send a message and see if an ICMP is returned
    _syslog_send_socket("");
    if (!connection_ok()) {
	push @$errs, "udp connect: nobody listening";
	return 0;
    }

    $syslog_send = \&_syslog_send_socket;

    return 1;
}

sub connect_stream {
    my ($errs) = @_;
    # might want syslog_path to be variable based on syslog.h (if only
    # it were in there!)
    $syslog_path = '/dev/conslog' unless defined $syslog_path; 

    if (!-w $syslog_path) {
	push @$errs, "stream $syslog_path is not writable";
	return 0;
    }

    require Fcntl;

    if (!sysopen(SYSLOG, $syslog_path, Fcntl::O_WRONLY(), 0400)) {
	push @$errs, "stream can't open $syslog_path: $!";
	return 0;
    }

    $syslog_send = \&_syslog_send_stream;

    return 1;
}

sub connect_pipe {
    my ($errs) = @_;

    $syslog_path ||= &_PATH_LOG || "/dev/log";

    if (not -w $syslog_path) {
        push @$errs, "$syslog_path is not writable";
        return 0;
    }

    if (not open(SYSLOG, ">$syslog_path")) {
        push @$errs, "can't write to $syslog_path: $!";
        return 0;
    }

    $syslog_send = \&_syslog_send_pipe;

    return 1;
}

sub connect_unix {
    my ($errs) = @_;

    $syslog_path ||= _PATH_LOG() if length _PATH_LOG();

    if (not defined $syslog_path) {
        push @$errs, "_PATH_LOG not available in syslog.h and no user-supplied socket path";
	return 0;
    }

    if (not (-S $syslog_path or -c _)) {
        push @$errs, "$syslog_path is not a socket";
	return 0;
    }

    my $addr = sockaddr_un($syslog_path);
    if (!$addr) {
	push @$errs, "can't locate $syslog_path";
	return 0;
    }
    if (!socket(SYSLOG, AF_UNIX, SOCK_STREAM, 0)) {
        push @$errs, "unix stream socket: $!";
	return 0;
    }

    if (!connect(SYSLOG, $addr)) {
        if (!socket(SYSLOG, AF_UNIX, SOCK_DGRAM, 0)) {
	    push @$errs, "unix dgram socket: $!";
	    return 0;
	}
        if (!connect(SYSLOG, $addr)) {
	    push @$errs, "unix dgram connect: $!";
	    return 0;
	}
    }

    $syslog_send = \&_syslog_send_socket;

    return 1;
}

sub connect_native {
    my ($errs) = @_;
    my $logopt = 0;

    # reconstruct the numeric equivalent of the options
    for my $opt (keys %options) {
        $logopt += xlate($opt) if $options{$opt}
    }

    openlog_xs($ident, $logopt, xlate($facility));
    $syslog_send = \&_syslog_send_native;

    return 1;
}

sub connect_eventlog {
    my ($errs) = @_;

    $syslog_xobj = Sys::Syslog::Win32::_install();
    $syslog_send = \&Sys::Syslog::Win32::_syslog_send;

    return 1;
}

sub connect_console {
    my ($errs) = @_;
    if (!-w '/dev/console') {
	push @$errs, "console is not writable";
	return 0;
    }
    $syslog_send = \&_syslog_send_console;
    return 1;
}

# To test if the connection is still good, we need to check if any
# errors are present on the connection. The errors will not be raised
# by a write. Instead, sockets are made readable and the next read
# would cause the error to be returned. Unfortunately the syslog 
# 'protocol' never provides anything for us to read. But with 
# judicious use of select(), we can see if it would be readable...
sub connection_ok {
    return 1 if defined $current_proto and (
        $current_proto eq 'native' or $current_proto eq 'console'
        or $current_proto eq 'eventlog'
    );

    my $rin = '';
    vec($rin, fileno(SYSLOG), 1) = 1;
    my $ret = select $rin, undef, $rin, $sock_timeout;
    return ($ret ? 0 : 1);
}

sub disconnect_log {
    $connected = 0;
    $syslog_send = undef;

    if (defined $current_proto and $current_proto eq 'native') {
        closelog_xs();
        unshift @fallbackMethods, $current_proto;
        $current_proto = undef;
        return 1;
    }
    elsif (defined $current_proto and $current_proto eq 'eventlog') {
        $syslog_xobj->Close();
        unshift @fallbackMethods, $current_proto;
        $current_proto = undef;
        return 1;
    }

    return close SYSLOG;
}


#
# Wrappers around eval() that makes sure that nobody, and I say NOBODY, 
# ever knows that I wanted to test if something was here or not. 
# It is needed because some applications are trying to be too smart,
# do it wrong, and it ends up in EPIC FAIL. 
# Yes I'm speaking of YOU, SpamAssassin.
#
sub silent_eval (&) {
    local($SIG{__DIE__}, $SIG{__WARN__}, $@);
    return eval { $_[0]->() }
}

sub can_load {
    my ($module, $verbose) = @_;
    local($SIG{__DIE__}, $SIG{__WARN__}, $@);
    local @INC = @INC;
    pop @INC if $INC[-1] eq '.';
    my $loaded = eval "use $module; 1";
    warn $@ if not $loaded and $verbose;
    return $loaded
}


"Eighth Rule: read the documentation."

__END__

=head1 NAME

Sys::Syslog - Perl interface to the UNIX syslog(3) calls

=head1 VERSION

This is the documentation of version 0.33

=head1 SYNOPSIS

    use Sys::Syslog;                        # all except setlogsock()
    use Sys::Syslog qw(:standard :macros);  # standard functions & macros

    openlog($ident, $logopt, $facility);    # don't forget this
    syslog($priority, $format, @args);
    $oldmask = setlogmask($mask_priority);
    closelog();


=head1 DESCRIPTION

C<Sys::Syslog> is an interface to the UNIX C<syslog(3)> program.
Call C<syslog()> with a string priority and a list of C<printf()> args
just like C<syslog(3)>.


=head1 EXPORTS

C<Sys::Syslog> exports the following C<Exporter> tags: 

=over 4

=item *

C<:standard> exports the standard C<syslog(3)> functions: 

    openlog closelog setlogmask syslog

=item *

C<:extended> exports the Perl specific functions for C<syslog(3)>: 

    setlogsock

=item *

C<:macros> exports the symbols corresponding to most of your C<syslog(3)> 
macros and the C<LOG_UPTO()> and C<LOG_MASK()> functions. 
See L<"CONSTANTS"> for the supported constants and their meaning. 

=back

By default, C<Sys::Syslog> exports the symbols from the C<:standard> tag. 


=head1 FUNCTIONS

=over 4

=item B<openlog($ident, $logopt, $facility)>

Opens the syslog.
C<$ident> is prepended to every message.  C<$logopt> contains zero or
more of the options detailed below.  C<$facility> specifies the part 
of the system to report about, for example C<LOG_USER> or C<LOG_LOCAL0>:
see L<"Facilities"> for a list of well-known facilities, and your 
C<syslog(3)> documentation for the facilities available in your system. 
Check L<"SEE ALSO"> for useful links. Facility can be given as a string 
or a numeric macro. 

This function will croak if it can't connect to the syslog daemon.

Note that C<openlog()> now takes three arguments, just like C<openlog(3)>.

B<You should use C<openlog()> before calling C<syslog()>.>

B<Options>

=over 4

=item *

C<cons> - This option is ignored, since the failover mechanism will drop 
down to the console automatically if all other media fail.

=item *

C<ndelay> - Open the connection immediately (normally, the connection is
opened when the first message is logged).

=item *

C<noeol> - When set to true, no end of line character (C<\n>) will be
appended to the message. This can be useful for some buggy syslog daemons.

=item *

C<nofatal> - When set to true, C<openlog()> and C<syslog()> will only 
emit warnings instead of dying if the connection to the syslog can't 
be established. 

=item *

C<nonul> - When set to true, no C<NUL> character (C<\0>) will be
appended to the message. This can be useful for some buggy syslog daemons.

=item *

C<nowait> - Don't wait for child processes that may have been created 
while logging the message.  (The GNU C library does not create a child
process, so this option has no effect on Linux.)

=item *

C<perror> - Write the message to standard error output as well to the
system log (added in C<Sys::Syslog> 0.22).

=item *

C<pid> - Include PID with each message.

=back

B<Examples>

Open the syslog with options C<ndelay> and C<pid>, and with facility C<LOCAL0>: 

    openlog($name, "ndelay,pid", "local0");

Same thing, but this time using the macro corresponding to C<LOCAL0>: 

    openlog($name, "ndelay,pid", LOG_LOCAL0);


=item B<syslog($priority, $message)>

=item B<syslog($priority, $format, @args)>

If C<$priority> permits, logs C<$message> or C<sprintf($format, @args)>
with the addition that C<%m> in $message or C<$format> is replaced with
C<"$!"> (the latest error message). 

C<$priority> can specify a level, or a level and a facility.  Levels and 
facilities can be given as strings or as macros.  When using the C<eventlog>
mechanism, priorities C<DEBUG> and C<INFO> are mapped to event type 
C<informational>, C<NOTICE> and C<WARNING> to C<warning> and C<ERR> to 
C<EMERG> to C<error>.

If you didn't use C<openlog()> before using C<syslog()>, C<syslog()> will 
try to guess the C<$ident> by extracting the shortest prefix of 
C<$format> that ends in a C<":">.

B<Examples>

    # informational level
    syslog("info", $message);
    syslog(LOG_INFO, $message);

    # information level, Local0 facility
    syslog("info|local0", $message);
    syslog(LOG_INFO|LOG_LOCAL0, $message);

=over 4

=item B<Note>

C<Sys::Syslog> version v0.07 and older passed the C<$message> as the 
formatting string to C<sprintf()> even when no formatting arguments
were provided.  If the code calling C<syslog()> might execute with 
older versions of this module, make sure to call the function as
C<syslog($priority, "%s", $message)> instead of C<syslog($priority,
$message)>.  This protects against hostile formatting sequences that
might show up if $message contains tainted data.

=back


=item B<setlogmask($mask_priority)>

Sets the log mask for the current process to C<$mask_priority> and 
returns the old mask.  If the mask argument is 0, the current log mask 
is not modified.  See L<"Levels"> for the list of available levels. 
You can use the C<LOG_UPTO()> function to allow all levels up to a 
given priority (but it only accept the numeric macros as arguments).

B<Examples>

Only log errors: 

    setlogmask( LOG_MASK(LOG_ERR) );

Log everything except informational messages: 

    setlogmask( ~(LOG_MASK(LOG_INFO)) );

Log critical messages, errors and warnings: 

    setlogmask( LOG_MASK(LOG_CRIT)
              | LOG_MASK(LOG_ERR)
              | LOG_MASK(LOG_WARNING) );

Log all messages up to debug: 

    setlogmask( LOG_UPTO(LOG_DEBUG) );


=item B<setlogsock()>

Sets the socket type and options to be used for the next call to C<openlog()>
or C<syslog()>.  Returns true on success, C<undef> on failure.

Being Perl-specific, this function has evolved along time.  It can currently
be called as follow:

=over

=item *

C<setlogsock($sock_type)>

=item *

C<setlogsock($sock_type, $stream_location)> (added in Perl 5.004_02)

=item *

C<setlogsock($sock_type, $stream_location, $sock_timeout)> (added in
C<Sys::Syslog> 0.25)

=item *

C<setlogsock(\%options)> (added in C<Sys::Syslog> 0.28)

=back

The available options are:

=over

=item *

C<type> - equivalent to C<$sock_type>, selects the socket type (or
"mechanism").  An array reference can be passed to specify several
mechanisms to try, in the given order.

=item *

C<path> - equivalent to C<$stream_location>, sets the stream location.
Defaults to standard Unix location, or C<_PATH_LOG>.

=item *

C<timeout> - equivalent to C<$sock_timeout>, sets the socket timeout
in seconds.  Defaults to 0 on all systems except S<Mac OS X> where it
is set to 0.25 sec.

=item *

C<host> - sets the hostname to send the messages to.  Defaults to 
the local host.

=item *

C<port> - sets the TCP or UDP port to connect to.  Defaults to the
first standard syslog port available on the system.

=back


The available mechanisms are: 

=over

=item *

C<"native"> - use the native C functions from your C<syslog(3)> library
(added in C<Sys::Syslog> 0.15).

=item *

C<"eventlog"> - send messages to the Win32 events logger (Win32 only; 
added in C<Sys::Syslog> 0.19).

=item *

C<"tcp"> - connect to a TCP socket, on the C<syslog/tcp> or C<syslogng/tcp> 
service.  See also the C<host>, C<port> and C<timeout> options.

=item *

C<"udp"> - connect to a UDP socket, on the C<syslog/udp> service.
See also the C<host>, C<port> and C<timeout> options.

=item *

C<"inet"> - connect to an INET socket, either TCP or UDP, tried in that 
order.  See also the C<host>, C<port> and C<timeout> options.

=item *

C<"unix"> - connect to a UNIX domain socket (in some systems a character 
special device).  The name of that socket is given by the C<path> option
or, if omitted, the value returned by the C<_PATH_LOG> macro (if your
system defines it), F</dev/log> or F</dev/conslog>, whichever is writable.

=item *

C<"stream"> - connect to the stream indicated by the C<path> option, or,
if omitted, the value returned by the C<_PATH_LOG> macro (if your system
defines it), F</dev/log> or F</dev/conslog>, whichever is writable.  For
example Solaris and IRIX system may prefer C<"stream"> instead of C<"unix">. 

=item *

C<"pipe"> - connect to the named pipe indicated by the C<path> option,
or, if omitted, to the value returned by the C<_PATH_LOG> macro (if your
system defines it), or F</dev/log> (added in C<Sys::Syslog> 0.21).
HP-UX is a system which uses such a named pipe.

=item *

C<"console"> - send messages directly to the console, as for the C<"cons"> 
option of C<openlog()>.

=back

The default is to try C<native>, C<tcp>, C<udp>, C<unix>, C<pipe>, C<stream>, 
C<console>.
Under systems with the Win32 API, C<eventlog> will be added as the first 
mechanism to try if C<Win32::EventLog> is available.

Giving an invalid value for C<$sock_type> will C<croak>.

B<Examples>

Select the UDP socket mechanism:

    setlogsock("udp");

Send messages using the TCP socket mechanism on a custom port:

    setlogsock({ type => "tcp", port => 2486 });

Send messages to a remote host using the TCP socket mechanism:

    setlogsock({ type => "tcp", host => $loghost });

Try the native, UDP socket then UNIX domain socket mechanisms: 

    setlogsock(["native", "udp", "unix"]);

=over

=item B<Note>

Now that the "native" mechanism is supported by C<Sys::Syslog> and selected 
by default, the use of the C<setlogsock()> function is discouraged because 
other mechanisms are less portable across operating systems.  Authors of 
modules and programs that use this function, especially its cargo-cult form 
C<setlogsock("unix")>, are advised to remove any occurrence of it unless they 
specifically want to use a given mechanism (like TCP or UDP to connect to 
a remote host).

=back

=item B<closelog()>

Closes the log file and returns true on success.

=back


=head1 THE RULES OF SYS::SYSLOG

I<The First Rule of Sys::Syslog is:>
You do not call C<setlogsock>.

I<The Second Rule of Sys::Syslog is:>
You B<do not> call C<setlogsock>.

I<The Third Rule of Sys::Syslog is:>
The program crashes, C<die>s, calls C<closelog>, the log is over.

I<The Fourth Rule of Sys::Syslog is:>
One facility, one priority.

I<The Fifth Rule of Sys::Syslog is:>
One log at a time.

I<The Sixth Rule of Sys::Syslog is:>
No C<syslog> before C<openlog>.

I<The Seventh Rule of Sys::Syslog is:>
Logs will go on as long as they have to. 

I<The Eighth, and Final Rule of Sys::Syslog is:>
If this is your first use of Sys::Syslog, you must read the doc.


=head1 EXAMPLES

An example:

    openlog($program, 'cons,pid', 'user');
    syslog('info', '%s', 'this is another test');
    syslog('mail|warning', 'this is a better test: %d', time);
    closelog();

    syslog('debug', 'this is the last test');

Another example:

    openlog("$program $$", 'ndelay', 'user');
    syslog('notice', 'fooprogram: this is really done');

Example of use of C<%m>:

    $! = 55;
    syslog('info', 'problem was %m');   # %m == $! in syslog(3)

Log to UDP port on C<$remotehost> instead of logging locally:

    setlogsock("udp", $remotehost);
    openlog($program, 'ndelay', 'user');
    syslog('info', 'something happened over here');


=head1 CONSTANTS

=head2 Facilities

=over 4

=item *

C<LOG_AUDIT> - audit daemon (IRIX); falls back to C<LOG_AUTH>

=item *

C<LOG_AUTH> - security/authorization messages

=item *

C<LOG_AUTHPRIV> - security/authorization messages (private)

=item *

C<LOG_CONSOLE> - C</dev/console> output (FreeBSD); falls back to C<LOG_USER>

=item *

C<LOG_CRON> - clock daemons (B<cron> and B<at>)

=item *

C<LOG_DAEMON> - system daemons without separate facility value

=item *

C<LOG_FTP> - FTP daemon

=item *

C<LOG_KERN> - kernel messages

=item *

C<LOG_INSTALL> - installer subsystem (Mac OS X); falls back to C<LOG_USER>

=item *

C<LOG_LAUNCHD> - launchd - general bootstrap daemon (Mac OS X);
falls back to C<LOG_DAEMON>

=item *

C<LOG_LFMT> - logalert facility; falls back to C<LOG_USER>

=item *

C<LOG_LOCAL0> through C<LOG_LOCAL7> - reserved for local use

=item *

C<LOG_LPR> - line printer subsystem

=item *

C<LOG_MAIL> - mail subsystem

=item *

C<LOG_NETINFO> - NetInfo subsystem (Mac OS X); falls back to C<LOG_DAEMON>

=item *

C<LOG_NEWS> - USENET news subsystem

=item *

C<LOG_NTP> - NTP subsystem (FreeBSD, NetBSD); falls back to C<LOG_DAEMON>

=item *

C<LOG_RAS> - Remote Access Service (VPN / PPP) (Mac OS X);
falls back to C<LOG_AUTH>

=item *

C<LOG_REMOTEAUTH> - remote authentication/authorization (Mac OS X);
falls back to C<LOG_AUTH>

=item *

C<LOG_SECURITY> - security subsystems (firewalling, etc.) (FreeBSD);
falls back to C<LOG_AUTH>

=item *

C<LOG_SYSLOG> - messages generated internally by B<syslogd>

=item *

C<LOG_USER> (default) - generic user-level messages

=item *

C<LOG_UUCP> - UUCP subsystem

=back


=head2 Levels

=over 4

=item *

C<LOG_EMERG> - system is unusable

=item *

C<LOG_ALERT> - action must be taken immediately

=item *

C<LOG_CRIT> - critical conditions

=item *

C<LOG_ERR> - error conditions

=item *

C<LOG_WARNING> - warning conditions

=item *

C<LOG_NOTICE> - normal, but significant, condition

=item *

C<LOG_INFO> - informational message

=item *

C<LOG_DEBUG> - debug-level message

=back


=head1 DIAGNOSTICS

=over

=item C<Invalid argument passed to setlogsock>

B<(F)> You gave C<setlogsock()> an invalid value for C<$sock_type>. 

=item C<eventlog passed to setlogsock, but no Win32 API available>

B<(W)> You asked C<setlogsock()> to use the Win32 event logger but the 
operating system running the program isn't Win32 or does not provides Win32
compatible facilities.

=item C<no connection to syslog available>

B<(F)> C<syslog()> failed to connect to the specified socket.

=item C<stream passed to setlogsock, but %s is not writable>

B<(W)> You asked C<setlogsock()> to use a stream socket, but the given 
path is not writable. 

=item C<stream passed to setlogsock, but could not find any device>

B<(W)> You asked C<setlogsock()> to use a stream socket, but didn't 
provide a path, and C<Sys::Syslog> was unable to find an appropriate one.

=item C<tcp passed to setlogsock, but tcp service unavailable>

B<(W)> You asked C<setlogsock()> to use a TCP socket, but the service 
is not available on the system. 

=item C<syslog: expecting argument %s>

B<(F)> You forgot to give C<syslog()> the indicated argument.

=item C<syslog: invalid level/facility: %s>

B<(F)> You specified an invalid level or facility.

=item C<syslog: too many levels given: %s>

B<(F)> You specified too many levels. 

=item C<syslog: too many facilities given: %s>

B<(F)> You specified too many facilities. 

=item C<syslog: level must be given>

B<(F)> You forgot to specify a level.

=item C<udp passed to setlogsock, but udp service unavailable>

B<(W)> You asked C<setlogsock()> to use a UDP socket, but the service 
is not available on the system. 

=item C<unix passed to setlogsock, but path not available>

B<(W)> You asked C<setlogsock()> to use a UNIX socket, but C<Sys::Syslog> 
was unable to find an appropriate an appropriate device.

=back


=head1 HISTORY

C<Sys::Syslog> is a core module, part of the standard Perl distribution
since 1990.  At this time, modules as we know them didn't exist, the
Perl library was a collection of F<.pl> files, and the one for sending
syslog messages with was simply F<lib/syslog.pl>, included with Perl 3.0.
It was converted as a module with Perl 5.0, but had a version number
only starting with Perl 5.6.  Here is a small table with the matching
Perl and C<Sys::Syslog> versions.

    Sys::Syslog     Perl
    -----------     ----
       undef        5.0.0 ~ 5.5.4
       0.01         5.6.*
       0.03         5.8.0
       0.04         5.8.1, 5.8.2, 5.8.3
       0.05         5.8.4, 5.8.5, 5.8.6
       0.06         5.8.7
       0.13         5.8.8
       0.22         5.10.0
       0.27         5.8.9, 5.10.1 ~ 5.14.2
       0.29         5.16.0, 5.16.1


=head1 SEE ALSO

=head2 Other modules

L<Log::Log4perl> - Perl implementation of the Log4j API

L<Log::Dispatch> - Dispatches messages to one or more outputs

L<Log::Report> - Report a problem, with exceptions and language support

=head2 Manual Pages

L<syslog(3)>

SUSv3 issue 6, IEEE Std 1003.1, 2004 edition, 
L<http://www.opengroup.org/onlinepubs/000095399/basedefs/syslog.h.html>

GNU C Library documentation on syslog, 
L<http://www.gnu.org/software/libc/manual/html_node/Syslog.html>

Solaris 10 documentation on syslog, 
L<http://docs.sun.com/app/docs/doc/816-5168/syslog-3c?a=view>

Mac OS X documentation on syslog,
L<http://developer.apple.com/documentation/Darwin/Reference/ManPages/man3/syslog.3.html>

IRIX 6.5 documentation on syslog,
L<http://techpubs.sgi.com/library/tpl/cgi-bin/getdoc.cgi?coll=0650&db=man&fname=3c+syslog>

AIX 5L 5.3 documentation on syslog, 
L<http://publib.boulder.ibm.com/infocenter/pseries/v5r3/index.jsp?topic=/com.ibm.aix.basetechref/doc/basetrf2/syslog.htm>

HP-UX 11i documentation on syslog, 
L<http://docs.hp.com/en/B2355-60130/syslog.3C.html>

Tru64 5.1 documentation on syslog, 
L<http://h30097.www3.hp.com/docs/base_doc/DOCUMENTATION/V51_HTML/MAN/MAN3/0193____.HTM>

Stratus VOS 15.1, 
L<http://stratadoc.stratus.com/vos/15.1.1/r502-01/wwhelp/wwhimpl/js/html/wwhelp.htm?context=r502-01&file=ch5r502-01bi.html>

=head2 RFCs

I<RFC 3164 - The BSD syslog Protocol>, L<http://www.faqs.org/rfcs/rfc3164.html>
-- Please note that this is an informational RFC, and therefore does not 
specify a standard of any kind.

I<RFC 3195 - Reliable Delivery for syslog>, L<http://www.faqs.org/rfcs/rfc3195.html>

=head2 Articles

I<Syslogging with Perl>, L<http://lexington.pm.org/meetings/022001.html>

=head2 Event Log

Windows Event Log,
L<http://msdn.microsoft.com/library/default.asp?url=/library/en-us/wes/wes/windows_event_log.asp>


=head1 AUTHORS & ACKNOWLEDGEMENTS

Tom Christiansen E<lt>F<tchrist (at) perl.com>E<gt> and Larry Wall
E<lt>F<larry (at) wall.org>E<gt>.

UNIX domain sockets added by Sean Robinson
E<lt>F<robinson_s (at) sc.maricopa.edu>E<gt> with support from Tim Bunce 
E<lt>F<Tim.Bunce (at) ig.co.uk>E<gt> and the C<perl5-porters> mailing list.

Dependency on F<syslog.ph> replaced with XS code by Tom Hughes
E<lt>F<tom (at) compton.nu>E<gt>.

Code for C<constant()>s regenerated by Nicholas Clark E<lt>F<nick (at) ccl4.org>E<gt>.

Failover to different communication modes by Nick Williams
E<lt>F<Nick.Williams (at) morganstanley.com>E<gt>.

Extracted from core distribution for publishing on the CPAN by 
SE<eacute>bastien Aperghis-Tramoni E<lt>sebastien (at) aperghis.netE<gt>.

XS code for using native C functions borrowed from C<L<Unix::Syslog>>, 
written by Marcus Harnisch E<lt>F<marcus.harnisch (at) gmx.net>E<gt>.

Yves Orton suggested and helped for making C<Sys::Syslog> use the native 
event logger under Win32 systems.

Jerry D. Hedden and Reini Urban provided greatly appreciated help to 
debug and polish C<Sys::Syslog> under Cygwin.


=head1 BUGS

Please report any bugs or feature requests to
C<bug-sys-syslog (at) rt.cpan.org>, or through the web interface at
L<http://rt.cpan.org/Public/Dist/Display.html?Name=Sys-Syslog>.
I will be notified, and then you'll automatically be notified of progress on
your bug as I make changes.


=head1 SUPPORT

You can find documentation for this module with the perldoc command.

    perldoc Sys::Syslog

You can also look for information at:

=over 4

=item * AnnoCPAN: Annotated CPAN documentation

L<http://annocpan.org/dist/Sys-Syslog>

=item * CPAN Ratings

L<http://cpanratings.perl.org/d/Sys-Syslog>

=item * RT: CPAN's request tracker

L<http://rt.cpan.org/Dist/Display.html?Queue=Sys-Syslog>

=item * Search CPAN

L<http://search.cpan.org/dist/Sys-Syslog/>

=item * MetaCPAN

L<https://metacpan.org/module/Sys::Syslog>

=item * Perl Documentation

L<http://perldoc.perl.org/Sys/Syslog.html>

=back


=head1 COPYRIGHT

Copyright (C) 1990-2012 by Larry Wall and others.


=head1 LICENSE

This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

=cut

=begin comment

Notes for the future maintainer (even if it's still me..)
- - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Using Google Code Search, I search who on Earth was relying on $host being 
public. It found 5 hits: 

* First was inside Indigo Star Perl2exe documentation. Just an old version 
of Sys::Syslog. 


* One real hit was inside DalWeathDB, a weather related program. It simply 
does a 

    $Sys::Syslog::host = '127.0.0.1';

- L<http://www.gallistel.net/nparker/weather/code/>


* Two hits were in TPC, a fax server thingy. It does a 

    $Sys::Syslog::host = $TPC::LOGHOST;

but also has this strange piece of code:

    # work around perl5.003 bug
    sub Sys::Syslog::hostname {}

I don't know what bug the author referred to.

- L<http://www.tpc.int/>
- L<ftp://ftp-usa.tpc.int/pub/tpc/server/UNIX/>


* Last hit was in Filefix, which seems to be a FIDOnet mail program (!).
This one does not use $host, but has the following piece of code:

    sub Sys::Syslog::hostname
    {
        use Sys::Hostname;
        return hostname;
    }

I guess this was a more elaborate form of the previous bit, maybe because 
of a bug in Sys::Syslog back then?

- L<ftp://ftp.kiae.su/pub/unix/fido/>


Links
-----
Linux Fast-STREAMS
- L<http://www.openss7.org/streams.html>

II12021: SYSLOGD HOWTO TCPIPINFO (z/OS, OS/390, MVS)
- L<http://www-1.ibm.com/support/docview.wss?uid=isg1II12021>

Getting the most out of the Event Viewer
- L<http://www.codeproject.com/dotnet/evtvwr.asp?print=true>

Log events to the Windows NT Event Log with JNI
- L<http://www.javaworld.com/javaworld/jw-09-2001/jw-0928-ntmessages.html>

=end comment

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             use strict;
package Tie::Hash::NamedCapture;

our $VERSION = "0.09";

require XSLoader;
XSLoader::load(); # This returns true, which makes require happy.

__END__

=head1 NAME

Tie::Hash::NamedCapture - Named regexp capture buffers

=head1 SYNOPSIS

    tie my %hash, "Tie::Hash::NamedCapture";
    # %hash now behaves like %+

    tie my %hash, "Tie::Hash::NamedCapture", all => 1;
    # %hash now access buffers from regexp in $qr like %-

=head1 DESCRIPTION

This module is used to implement the special hashes C<%+> and C<%->, but it
can be used to tie other variables as you choose.

When the C<all> parameter is provided, then the tied hash elements will be
array refs listing the contents of each capture buffer whose name is the
same as the associated hash key. If none of these buffers were involved in
the match, the contents of that array ref will be as many C<undef> values
as there are capture buffers with that name. In other words, the tied hash
will behave as C<%->.

When the C<all> parameter is omitted or false, then the tied hash elements
will be the contents of the leftmost defined buffer with the name of the
associated hash key. In other words, the tied hash will behave as
C<%+>.

The keys of C<%->-like hashes correspond to all buffer names found in the
regular expression; the keys of C<%+>-like hashes list only the names of
buffers that have captured (and that are thus associated to defined values).

=head1 SEE ALSO

L<perlreapi>, L<re>, L<perlmodlib/Pragmatic Modules>, L<perlvar/"%+">,
L<perlvar/"%-">.

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          package Time::HiRes;

{ use 5.006; }
use strict;

require Exporter;
require DynaLoader;

our @ISA = qw(Exporter DynaLoader);

our @EXPORT = qw( );
our @EXPORT_OK = qw (usleep sleep ualarm alarm gettimeofday time tv_interval
		 getitimer setitimer nanosleep clock_gettime clock_getres
		 clock clock_nanosleep
		 CLOCK_BOOTTIME CLOCK_HIGHRES
		 CLOCK_MONOTONIC CLOCK_MONOTONIC_COARSE
		 CLOCK_MONOTONIC_PRECISE CLOCK_MONOTONIC_RAW
		 CLOCK_PROCESS_CPUTIME_ID
		 CLOCK_REALTIME CLOCK_REALTIME_COARSE
		 CLOCK_REALTIME_FAST CLOCK_REALTIME_PRECISE
		 CLOCK_SECOND CLOCK_SOFTTIME CLOCK_THREAD_CPUTIME_ID
		 CLOCK_TIMEOFDAY CLOCKS_PER_SEC
		 ITIMER_REAL ITIMER_VIRTUAL ITIMER_PROF ITIMER_REALPROF
		 TIMER_ABSTIME
		 d_usleep d_ualarm d_gettimeofday d_getitimer d_setitimer
		 d_nanosleep d_clock_gettime d_clock_getres
		 d_clock d_clock_nanosleep
		 stat lstat
		);

our $VERSION = '1.9733';
our $XS_VERSION = $VERSION;
$VERSION = eval $VERSION;

our $AUTOLOAD;
sub AUTOLOAD {
    my $constname;
    ($constname = $AUTOLOAD) =~ s/.*:://;
    # print "AUTOLOAD: constname = $constname ($AUTOLOAD)\n";
    die "&Time::HiRes::constant not defined" if $constname eq 'constant';
    my ($error, $val) = constant($constname);
    # print "AUTOLOAD: error = $error, val = $val\n";
    if ($error) {
        my (undef,$file,$line) = caller;
        die "$error at $file line $line.\n";
    }
    {
	no strict 'refs';
	*$AUTOLOAD = sub { $val };
    }
    goto &$AUTOLOAD;
}

sub import {
    my $this = shift;
    for my $i (@_) {
	if (($i eq 'clock_getres'    && !&d_clock_getres)    ||
	    ($i eq 'clock_gettime'   && !&d_clock_gettime)   ||
	    ($i eq 'clock_nanosleep' && !&d_clock_nanosleep) ||
	    ($i eq 'clock'           && !&d_clock)           ||
	    ($i eq 'nanosleep'       && !&d_nanosleep)       ||
	    ($i eq 'usleep'          && !&d_usleep)          ||
	    ($i eq 'ualarm'          && !&d_ualarm)) {
	    require Carp;
	    Carp::croak("Time::HiRes::$i(): unimplemented in this platform");
	}
    }
    Time::HiRes->export_to_level(1, $this, @_);
}

bootstrap Time::HiRes;

# Preloaded methods go here.

sub tv_interval {
    # probably could have been done in C
    my ($a, $b) = @_;
    $b = [gettimeofday()] unless defined($b);
    (${$b}[0] - ${$a}[0]) + ((${$b}[1] - ${$a}[1]) / 1_000_000);
}

# Autoload methods go after =cut, and are processed by the autosplit program.

1;
__END__

=head1 NAME

Time::HiRes - High resolution alarm, sleep, gettimeofday, interval timers

=head1 SYNOPSIS

  use Time::HiRes qw( usleep ualarm gettimeofday tv_interval nanosleep
		      clock_gettime clock_getres clock_nanosleep clock
                      stat lstat );

  usleep ($microseconds);
  nanosleep ($nanoseconds);

  ualarm ($microseconds);
  ualarm ($microseconds, $interval_microseconds);

  $t0 = [gettimeofday];
  ($seconds, $microseconds) = gettimeofday;

  $elapsed = tv_interval ( $t0, [$seconds, $microseconds]);
  $elapsed = tv_interval ( $t0, [gettimeofday]);
  $elapsed = tv_interval ( $t0 );

  use Time::HiRes qw ( time alarm sleep );

  $now_fractions = time;
  sleep ($floating_seconds);
  alarm ($floating_seconds);
  alarm ($floating_seconds, $floating_interval);

  use Time::HiRes qw( setitimer getitimer );

  setitimer ($which, $floating_seconds, $floating_interval );
  getitimer ($which);

  use Time::HiRes qw( clock_gettime clock_getres clock_nanosleep
		      ITIMER_REAL ITIMER_VIRTUAL ITIMER_PROF
                      ITIMER_REALPROF );

  $realtime   = clock_gettime(CLOCK_REALTIME);
  $resolution = clock_getres(CLOCK_REALTIME);

  clock_nanosleep(CLOCK_REALTIME, 1.5e9);
  clock_nanosleep(CLOCK_REALTIME, time()*1e9 + 10e9, TIMER_ABSTIME);

  my $ticktock = clock();

  use Time::HiRes qw( stat lstat );

  my @stat = stat("file");
  my @stat = stat(FH);
  my @stat = lstat("file");

=head1 DESCRIPTION

The C<Time::HiRes> module implements a Perl interface to the
C<usleep>, C<nanosleep>, C<ualarm>, C<gettimeofday>, and
C<setitimer>/C<getitimer> system calls, in other words, high
resolution time and timers. See the L</EXAMPLES> section below and the
test scripts for usage; see your system documentation for the
description of the underlying C<nanosleep> or C<usleep>, C<ualarm>,
C<gettimeofday>, and C<setitimer>/C<getitimer> calls.

If your system lacks C<gettimeofday()> or an emulation of it you don't
get C<gettimeofday()> or the one-argument form of C<tv_interval()>.
If your system lacks all of C<nanosleep()>, C<usleep()>,
C<select()>, and C<poll>, you don't get C<Time::HiRes::usleep()>,
C<Time::HiRes::nanosleep()>, or C<Time::HiRes::sleep()>.
If your system lacks both C<ualarm()> and C<setitimer()> you don't get
C<Time::HiRes::ualarm()> or C<Time::HiRes::alarm()>.

If you try to import an unimplemented function in the C<use> statement
it will fail at compile time.

If your subsecond sleeping is implemented with C<nanosleep()> instead
of C<usleep()>, you can mix subsecond sleeping with signals since
C<nanosleep()> does not use signals.  This, however, is not portable,
and you should first check for the truth value of
C<&Time::HiRes::d_nanosleep> to see whether you have nanosleep, and
then carefully read your C<nanosleep()> C API documentation for any
peculiarities.

If you are using C<nanosleep> for something else than mixing sleeping
with signals, give some thought to whether Perl is the tool you should
be using for work requiring nanosecond accuracies.

Remember that unless you are working on a I<hard realtime> system,
any clocks and timers will be imprecise, especially so if you are working
in a pre-emptive multiuser system.  Understand the difference between
I<wallclock time> and process time (in UNIX-like systems the sum of
I<user> and I<system> times).  Any attempt to sleep for X seconds will
most probably end up sleeping B<more> than that, but don't be surprised
if you end up sleeping slightly B<less>.

The following functions can be imported from this module.
No functions are exported by default.

=over 4

=item gettimeofday ()

In array context returns a two-element array with the seconds and
microseconds since the epoch.  In scalar context returns floating
seconds like C<Time::HiRes::time()> (see below).

=item usleep ( $useconds )

Sleeps for the number of microseconds (millionths of a second)
specified.  Returns the number of microseconds actually slept.
Can sleep for more than one second, unlike the C<usleep> system call.
Can also sleep for zero seconds, which often works like a I<thread yield>.
See also C<Time::HiRes::usleep()>, C<Time::HiRes::sleep()>, and
C<Time::HiRes::clock_nanosleep()>.

Do not expect usleep() to be exact down to one microsecond.

=item nanosleep ( $nanoseconds )

Sleeps for the number of nanoseconds (1e9ths of a second) specified.
Returns the number of nanoseconds actually slept (accurate only to
microseconds, the nearest thousand of them).  Can sleep for more than
one second.  Can also sleep for zero seconds, which often works like
a I<thread yield>.  See also C<Time::HiRes::sleep()>,
C<Time::HiRes::usleep()>, and C<Time::HiRes::clock_nanosleep()>.

Do not expect nanosleep() to be exact down to one nanosecond.
Getting even accuracy of one thousand nanoseconds is good.

=item ualarm ( $useconds [, $interval_useconds ] )

Issues a C<ualarm> call; the C<$interval_useconds> is optional and
will be zero if unspecified, resulting in C<alarm>-like behaviour.

Returns the remaining time in the alarm in microseconds, or C<undef>
if an error occurred.

ualarm(0) will cancel an outstanding ualarm().

Note that the interaction between alarms and sleeps is unspecified.

=item tv_interval 

tv_interval ( $ref_to_gettimeofday [, $ref_to_later_gettimeofday] )

Returns the floating seconds between the two times, which should have
been returned by C<gettimeofday()>. If the second argument is omitted,
then the current time is used.

=item time ()

Returns a floating seconds since the epoch. This function can be
imported, resulting in a nice drop-in replacement for the C<time>
provided with core Perl; see the L</EXAMPLES> below.

B<NOTE 1>: This higher resolution timer can return values either less
or more than the core C<time()>, depending on whether your platform
rounds the higher resolution timer values up, down, or to the nearest second
to get the core C<time()>, but naturally the difference should be never
more than half a second.  See also L</clock_getres>, if available
in your system.

B<NOTE 2>: Since Sunday, September 9th, 2001 at 01:46:40 AM GMT, when
the C<time()> seconds since epoch rolled over to 1_000_000_000, the
default floating point format of Perl and the seconds since epoch have
conspired to produce an apparent bug: if you print the value of
C<Time::HiRes::time()> you seem to be getting only five decimals, not
six as promised (microseconds).  Not to worry, the microseconds are
there (assuming your platform supports such granularity in the first
place).  What is going on is that the default floating point format of
Perl only outputs 15 digits.  In this case that means ten digits
before the decimal separator and five after.  To see the microseconds
you can use either C<printf>/C<sprintf> with C<"%.6f">, or the
C<gettimeofday()> function in list context, which will give you the
seconds and microseconds as two separate values.

=item sleep ( $floating_seconds )

Sleeps for the specified amount of seconds.  Returns the number of
seconds actually slept (a floating point value).  This function can
be imported, resulting in a nice drop-in replacement for the C<sleep>
provided with perl, see the L</EXAMPLES> below.

Note that the interaction between alarms and sleeps is unspecified.

=item alarm ( $floating_seconds [, $interval_floating_seconds ] )

The C<SIGALRM> signal is sent after the specified number of seconds.
Implemented using C<setitimer()> if available, C<ualarm()> if not.
The C<$interval_floating_seconds> argument is optional and will be
zero if unspecified, resulting in C<alarm()>-like behaviour.  This
function can be imported, resulting in a nice drop-in replacement for
the C<alarm> provided with perl, see the L</EXAMPLES> below.

Returns the remaining time in the alarm in seconds, or C<undef>
if an error occurred.

B<NOTE 1>: With some combinations of operating systems and Perl
releases C<SIGALRM> restarts C<select()>, instead of interrupting it.
This means that an C<alarm()> followed by a C<select()> may together
take the sum of the times specified for the C<alarm()> and the
C<select()>, not just the time of the C<alarm()>.

Note that the interaction between alarms and sleeps is unspecified.

=item setitimer ( $which, $floating_seconds [, $interval_floating_seconds ] )

Start up an interval timer: after a certain time, a signal ($which) arrives,
and more signals may keep arriving at certain intervals.  To disable
an "itimer", use C<$floating_seconds> of zero.  If the
C<$interval_floating_seconds> is set to zero (or unspecified), the
timer is disabled B<after> the next delivered signal.

Use of interval timers may interfere with C<alarm()>, C<sleep()>,
and C<usleep()>.  In standard-speak the "interaction is unspecified",
which means that I<anything> may happen: it may work, it may not.

In scalar context, the remaining time in the timer is returned.

In list context, both the remaining time and the interval are returned.

There are usually three or four interval timers (signals) available: the
C<$which> can be C<ITIMER_REAL>, C<ITIMER_VIRTUAL>, C<ITIMER_PROF>, or
C<ITIMER_REALPROF>.  Note that which ones are available depends: true
UNIX platforms usually have the first three, but only Solaris seems to
have C<ITIMER_REALPROF> (which is used to profile multithreaded programs).
Win32 unfortunately does not have interval timers.

C<ITIMER_REAL> results in C<alarm()>-like behaviour.  Time is counted in
I<real time>; that is, wallclock time.  C<SIGALRM> is delivered when
the timer expires.

C<ITIMER_VIRTUAL> counts time in (process) I<virtual time>; that is,
only when the process is running.  In multiprocessor/user/CPU systems
this may be more or less than real or wallclock time.  (This time is
also known as the I<user time>.)  C<SIGVTALRM> is delivered when the
timer expires.

C<ITIMER_PROF> counts time when either the process virtual time or when
the operating system is running on behalf of the process (such as I/O).
(This time is also known as the I<system time>.)  (The sum of user
time and system time is known as the I<CPU time>.)  C<SIGPROF> is
delivered when the timer expires.  C<SIGPROF> can interrupt system calls.

The semantics of interval timers for multithreaded programs are
system-specific, and some systems may support additional interval
timers.  For example, it is unspecified which thread gets the signals.
See your C<setitimer()> documentation.

=item getitimer ( $which )

Return the remaining time in the interval timer specified by C<$which>.

In scalar context, the remaining time is returned.

In list context, both the remaining time and the interval are returned.
The interval is always what you put in using C<setitimer()>.

=item clock_gettime ( $which )

Return as seconds the current value of the POSIX high resolution timer
specified by C<$which>.  All implementations that support POSIX high
resolution timers are supposed to support at least the C<$which> value
of C<CLOCK_REALTIME>, which is supposed to return results close to the
results of C<gettimeofday>, or the number of seconds since 00:00:00:00
January 1, 1970 Greenwich Mean Time (GMT).  Do not assume that
CLOCK_REALTIME is zero, it might be one, or something else.
Another potentially useful (but not available everywhere) value is
C<CLOCK_MONOTONIC>, which guarantees a monotonically increasing time
value (unlike time() or gettimeofday(), which can be adjusted).
See your system documentation for other possibly supported values.

=item clock_getres ( $which )

Return as seconds the resolution of the POSIX high resolution timer
specified by C<$which>.  All implementations that support POSIX high
resolution timers are supposed to support at least the C<$which> value
of C<CLOCK_REALTIME>, see L</clock_gettime>.

B<NOTE>: the resolution returned may be highly optimistic.  Even if
the resolution is high (a small number), all it means is that you'll
be able to specify the arguments to clock_gettime() and clock_nanosleep()
with that resolution.  The system might not actually be able to measure
events at that resolution, and the various overheads and the overall system
load are certain to affect any timings.

=item clock_nanosleep ( $which, $nanoseconds, $flags = 0)

Sleeps for the number of nanoseconds (1e9ths of a second) specified.
Returns the number of nanoseconds actually slept.  The $which is the
"clock id", as with clock_gettime() and clock_getres().  The flags
default to zero but C<TIMER_ABSTIME> can specified (must be exported
explicitly) which means that C<$nanoseconds> is not a time interval
(as is the default) but instead an absolute time.  Can sleep for more
than one second.  Can also sleep for zero seconds, which often works
like a I<thread yield>.  See also C<Time::HiRes::sleep()>,
C<Time::HiRes::usleep()>, and C<Time::HiRes::nanosleep()>.

Do not expect clock_nanosleep() to be exact down to one nanosecond.
Getting even accuracy of one thousand nanoseconds is good.

=item clock()

Return as seconds the I<process time> (user + system time) spent by
the process since the first call to clock() (the definition is B<not>
"since the start of the process", though if you are lucky these times
may be quite close to each other, depending on the system).  What this
means is that you probably need to store the result of your first call
to clock(), and subtract that value from the following results of clock().

The time returned also includes the process times of the terminated
child processes for which wait() has been executed.  This value is
somewhat like the second value returned by the times() of core Perl,
but not necessarily identical.  Note that due to backward
compatibility limitations the returned value may wrap around at about
2147 seconds or at about 36 minutes.

=item stat

=item stat FH

=item stat EXPR

=item lstat

=item lstat FH

=item lstat EXPR

As L<perlfunc/stat> or L<perlfunc/lstat>
but with the access/modify/change file timestamps
in subsecond resolution, if the operating system and the filesystem
both support such timestamps.  To override the standard stat():

    use Time::HiRes qw(stat);

Test for the value of &Time::HiRes::d_hires_stat to find out whether
the operating system supports subsecond file timestamps: a value
larger than zero means yes. There are unfortunately no easy
ways to find out whether the filesystem supports such timestamps.
UNIX filesystems often do; NTFS does; FAT doesn't (FAT timestamp
granularity is B<two> seconds).

A zero return value of &Time::HiRes::d_hires_stat means that
Time::HiRes::stat is a no-op passthrough for CORE::stat()
(and likewise for lstat),
and therefore the timestamps will stay integers.  The same
thing will happen if the filesystem does not do subsecond timestamps,
even if the &Time::HiRes::d_hires_stat is non-zero.

In any case do not expect nanosecond resolution, or even a microsecond
resolution.  Also note that the modify/access timestamps might have
different resolutions, and that they need not be synchronized, e.g.
if the operations are

    write
    stat # t1
    read
    stat # t2

the access time stamp from t2 need not be greater-than the modify
time stamp from t1: it may be equal or I<less>.

=back

=head1 EXAMPLES

  use Time::HiRes qw(usleep ualarm gettimeofday tv_interval);

  $microseconds = 750_000;
  usleep($microseconds);

  # signal alarm in 2.5s & every .1s thereafter
  ualarm(2_500_000, 100_000);
  # cancel that ualarm
  ualarm(0);

  # get seconds and microseconds since the epoch
  ($s, $usec) = gettimeofday();

  # measure elapsed time 
  # (could also do by subtracting 2 gettimeofday return values)
  $t0 = [gettimeofday];
  # do bunch of stuff here
  $t1 = [gettimeofday];
  # do more stuff here
  $t0_t1 = tv_interval $t0, $t1;

  $elapsed = tv_interval ($t0, [gettimeofday]);
  $elapsed = tv_interval ($t0);	# equivalent code

  #
  # replacements for time, alarm and sleep that know about
  # floating seconds
  #
  use Time::HiRes;
  $now_fractions = Time::HiRes::time;
  Time::HiRes::sleep (2.5);
  Time::HiRes::alarm (10.6666666);

  use Time::HiRes qw ( time alarm sleep );
  $now_fractions = time;
  sleep (2.5);
  alarm (10.6666666);

  # Arm an interval timer to go off first at 10 seconds and
  # after that every 2.5 seconds, in process virtual time

  use Time::HiRes qw ( setitimer ITIMER_VIRTUAL time );

  $SIG{VTALRM} = sub { print time, "\n" };
  setitimer(ITIMER_VIRTUAL, 10, 2.5);

  use Time::HiRes qw( clock_gettime clock_getres CLOCK_REALTIME );
  # Read the POSIX high resolution timer.
  my $high = clock_gettime(CLOCK_REALTIME);
  # But how accurate we can be, really?
  my $reso = clock_getres(CLOCK_REALTIME);

  use Time::HiRes qw( clock_nanosleep TIMER_ABSTIME );
  clock_nanosleep(CLOCK_REALTIME, 1e6);
  clock_nanosleep(CLOCK_REALTIME, 2e9, TIMER_ABSTIME);

  use Time::HiRes qw( clock );
  my $clock0 = clock();
  ... # Do something.
  my $clock1 = clock();
  my $clockd = $clock1 - $clock0;

  use Time::HiRes qw( stat );
  my ($atime, $mtime, $ctime) = (stat("istics"))[8, 9, 10];

=head1 C API

In addition to the perl API described above, a C API is available for
extension writers.  The following C functions are available in the
modglobal hash:

  name             C prototype
  ---------------  ----------------------
  Time::NVtime     NV (*)()
  Time::U2time     void (*)(pTHX_ UV ret[2])

Both functions return equivalent information (like C<gettimeofday>)
but with different representations.  The names C<NVtime> and C<U2time>
were selected mainly because they are operating system independent.
(C<gettimeofday> is Unix-centric, though some platforms like Win32 and
VMS have emulations for it.)

Here is an example of using C<NVtime> from C:

  NV (*myNVtime)(); /* Returns -1 on failure. */
  SV **svp = hv_fetch(PL_modglobal, "Time::NVtime", 12, 0);
  if (!svp)         croak("Time::HiRes is required");
  if (!SvIOK(*svp)) croak("Time::NVtime isn't a function pointer");
  myNVtime = INT2PTR(NV(*)(), SvIV(*svp));
  printf("The current time is: %" NVff "\n", (*myNVtime)());

=head1 DIAGNOSTICS

=head2 useconds or interval more than ...

In ualarm() you tried to use number of microseconds or interval (also
in microseconds) more than 1_000_000 and setitimer() is not available
in your system to emulate that case.

=head2 negative time not invented yet

You tried to use a negative time argument.

=head2 internal error: useconds < 0 (unsigned ... signed ...)

Something went horribly wrong-- the number of microseconds that cannot
become negative just became negative.  Maybe your compiler is broken?

=head2 useconds or uinterval equal to or more than 1000000

In some platforms it is not possible to get an alarm with subsecond
resolution and later than one second.

=head2 unimplemented in this platform

Some calls simply aren't available, real or emulated, on every platform.

=head1 CAVEATS

Notice that the core C<time()> maybe rounding rather than truncating.
What this means is that the core C<time()> may be reporting the time
as one second later than C<gettimeofday()> and C<Time::HiRes::time()>.

Adjusting the system clock (either manually or by services like ntp)
may cause problems, especially for long running programs that assume
a monotonously increasing time (note that all platforms do not adjust
time as gracefully as UNIX ntp does).  For example in Win32 (and derived
platforms like Cygwin and MinGW) the Time::HiRes::time() may temporarily
drift off from the system clock (and the original time())  by up to 0.5
seconds. Time::HiRes will notice this eventually and recalibrate.
Note that since Time::HiRes 1.77 the clock_gettime(CLOCK_MONOTONIC)
might help in this (in case your system supports CLOCK_MONOTONIC).

Some systems have APIs but not implementations: for example QNX and Haiku
have the interval timer APIs but not the functionality.

In OS X clock_getres(), clock_gettime() and clock_nanosleep() are
emulated using the Mach timers; as a side effect of being emulated
the CLOCK_REALTIME and CLOCK_MONOTONIC are the same timer.

=head1 SEE ALSO

Perl modules L<BSD::Resource>, L<Time::TAI64>.

Your system documentation for C<clock>, C<clock_gettime>,
C<clock_getres>, C<clock_nanosleep>, C<clock_settime>, C<getitimer>,
C<gettimeofday>, C<setitimer>, C<sleep>, C<stat>, C<ualarm>.

=head1 AUTHORS

D. Wegscheid <wegscd@whirlpool.com>
R. Schertler <roderick@argon.org>
J. Hietaniemi <jhi@iki.fi>
G. Aas <gisle@aas.no>

=head1 COPYRIGHT AND LICENSE

Copyright (c) 1996-2002 Douglas E. Wegscheid.  All rights reserved.

Copyright (c) 2002, 2003, 2004, 2005, 2006, 2007, 2008 Jarkko Hietaniemi.
All rights reserved.

Copyright (C) 2011, 2012, 2013 Andrew Main (Zefram) <zefram@fysh.org>

This program is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        package Time::Piece;

use strict;

require DynaLoader;
use Time::Seconds;
use Carp;
use Time::Local;

our @ISA = qw(DynaLoader);
 
use Exporter ();

our @EXPORT = qw(
    localtime
    gmtime
);

our %EXPORT_TAGS = (
    ':override' => 'internal',
    );

our $VERSION = '1.31';

bootstrap Time::Piece $VERSION;

my $DATE_SEP = '-';
my $TIME_SEP = ':';
my @MON_LIST = qw(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec);
my @FULLMON_LIST = qw(January February March April May June July
                      August September October November December);
my @DAY_LIST = qw(Sun Mon Tue Wed Thu Fri Sat);
my @FULLDAY_LIST = qw(Sunday Monday Tuesday Wednesday Thursday Friday Saturday);

use constant {
    'c_sec' => 0,
    'c_min' => 1,
    'c_hour' => 2,
    'c_mday' => 3,
    'c_mon' => 4,
    'c_year' => 5,
    'c_wday' => 6,
    'c_yday' => 7,
    'c_isdst' => 8,
    'c_epoch' => 9,
    'c_islocal' => 10,
};

sub localtime {
    unshift @_, __PACKAGE__ unless eval { $_[0]->isa('Time::Piece') };
    my $class = shift;
    my $time  = shift;
    $time = time if (!defined $time);
    $class->_mktime($time, 1);
}

sub gmtime {
    unshift @_, __PACKAGE__ unless eval { $_[0]->isa('Time::Piece') };
    my $class = shift;
    my $time  = shift;
    $time = time if (!defined $time);
    $class->_mktime($time, 0);
}

sub new {
    my $class = shift;
    my ($time) = @_;

    my $self;

    if (defined($time)) {
        $self = $class->localtime($time);
    }
    elsif (ref($class) && $class->isa(__PACKAGE__)) {
        $self = $class->_mktime($class->epoch, $class->[c_islocal]);
    }
    else {
        $self = $class->localtime();
    }

    return bless $self, ref($class) || $class;
}

sub parse {
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my @components;

    warnings::warnif("deprecated", 
        "parse() is deprecated, use strptime() instead.");

    if (@_ > 1) {
        @components = @_;
    }
    else {
        @components = shift =~ /(\d+)$DATE_SEP(\d+)$DATE_SEP(\d+)(?:(?:T|\s+)(\d+)$TIME_SEP(\d+)(?:$TIME_SEP(\d+)))/;
        @components = reverse(@components[0..5]);
    }
    return $class->new(_strftime("%s", timelocal(@components)));
}

sub _mktime {
    my ($class, $time, $islocal) = @_;
    $class = eval { (ref $class) && (ref $class)->isa('Time::Piece') }
           ? ref $class
           : $class;
    if (ref($time)) {
        my @tm_parts = (@{$time}[c_sec .. c_mon], $time->[c_year]+1900);
        $time->[c_epoch] = $islocal ? timelocal(@tm_parts) : timegm(@tm_parts);

        return wantarray ? @$time : bless [@$time[0..9], $islocal], $class;
    }
    _tzset();
    my @time = $islocal ?
            CORE::localtime($time)
                :
            CORE::gmtime($time);
    wantarray ? @time : bless [@time, $time, $islocal], $class;
}

my %_special_exports = (
  localtime => sub { my $c = $_[0]; sub { $c->localtime(@_) } },
  gmtime    => sub { my $c = $_[0]; sub { $c->gmtime(@_)    } },
);

sub export {
  my ($class, $to, @methods) = @_;
  for my $method (@methods) {
    if (exists $_special_exports{$method}) {
      no strict 'refs';
      no warnings 'redefine';
      *{$to . "::$method"} = $_special_exports{$method}->($class);
    } else {
      $class->Exporter::export($to, $method);
    }
  }
}

sub import {
    # replace CORE::GLOBAL localtime and gmtime if passed :override
    my $class = shift;
    my %params;
    map($params{$_}++,@_,@EXPORT);
    if (delete $params{':override'}) {
        $class->export('CORE::GLOBAL', keys %params);
    }
    else {
        $class->export(scalar caller, keys %params);
    }
}

## Methods ##

sub sec {
    my $time = shift;
    $time->[c_sec];
}

*second = \&sec;

sub min {
    my $time = shift;
    $time->[c_min];
}

*minute = \&min;

sub hour {
    my $time = shift;
    $time->[c_hour];
}

sub mday {
    my $time = shift;
    $time->[c_mday];
}

*day_of_month = \&mday;

sub mon {
    my $time = shift;
    $time->[c_mon] + 1;
}

sub _mon {
    my $time = shift;
    $time->[c_mon];
}

sub month {
    my $time = shift;
    if (@_) {
        return $_[$time->[c_mon]];
    }
    elsif (@MON_LIST) {
        return $MON_LIST[$time->[c_mon]];
    }
    else {
        return $time->strftime('%b');
    }
}

*monname = \&month;

sub fullmonth {
    my $time = shift;
    if (@_) {
        return $_[$time->[c_mon]];
    }
    elsif (@FULLMON_LIST) {
        return $FULLMON_LIST[$time->[c_mon]];
    }
    else {
        return $time->strftime('%B');
    }
}

sub year {
    my $time = shift;
    $time->[c_year] + 1900;
}

sub _year {
    my $time = shift;
    $time->[c_year];
}

sub yy {
    my $time = shift;
    my $res = $time->[c_year] % 100;
    return $res > 9 ? $res : "0$res";
}

sub wday {
    my $time = shift;
    $time->[c_wday] + 1;
}

sub _wday {
    my $time = shift;
    $time->[c_wday];
}

*day_of_week = \&_wday;

sub wdayname {
    my $time = shift;
    if (@_) {
        return $_[$time->[c_wday]];
    }
    elsif (@DAY_LIST) {
        return $DAY_LIST[$time->[c_wday]];
    }
    else {
        return $time->strftime('%a');
    }
}

*day = \&wdayname;

sub fullday {
    my $time = shift;
    if (@_) {
        return $_[$time->[c_wday]];
    }
    elsif (@FULLDAY_LIST) {
        return $FULLDAY_LIST[$time->[c_wday]];
    }
    else {
        return $time->strftime('%A');
    }
}

sub yday {
    my $time = shift;
    $time->[c_yday];
}

*day_of_year = \&yday;

sub isdst {
    my $time = shift;
    $time->[c_isdst];
}

*daylight_savings = \&isdst;

# Thanks to Tony Olekshy <olekshy@cs.ualberta.ca> for this algorithm
sub tzoffset {
    my $time = shift;

    return Time::Seconds->new(0) unless $time->[c_islocal];

    my $epoch = $time->epoch;

    my $j = sub {

        my ($s,$n,$h,$d,$m,$y) = @_; $m += 1; $y += 1900;

        $time->_jd($y, $m, $d, $h, $n, $s);

    };

    # Compute floating offset in hours.
    #
    # Note use of crt methods so the tz is properly set...
    # See: http://perlmonks.org/?node_id=820347
    my $delta = 24 * ($j->(_crt_localtime($epoch)) - $j->(_crt_gmtime($epoch)));

    # Return value in seconds rounded to nearest minute.
    return Time::Seconds->new( int($delta * 60 + ($delta >= 0 ? 0.5 : -0.5)) * 60 );
}

sub epoch {
    my $time = shift;
    if (defined($time->[c_epoch])) {
        return $time->[c_epoch];
    }
    else {
        my $epoch = $time->[c_islocal] ?
          timelocal(@{$time}[c_sec .. c_mon], $time->[c_year]+1900)
          :
          timegm(@{$time}[c_sec .. c_mon], $time->[c_year]+1900);
        $time->[c_epoch] = $epoch;
        return $epoch;
    }
}

sub hms {
    my $time = shift;
    my $sep = @_ ? shift(@_) : $TIME_SEP;
    sprintf("%02d$sep%02d$sep%02d", $time->[c_hour], $time->[c_min], $time->[c_sec]);
}

*time = \&hms;

sub ymd {
    my $time = shift;
    my $sep = @_ ? shift(@_) : $DATE_SEP;
    sprintf("%d$sep%02d$sep%02d", $time->year, $time->mon, $time->[c_mday]);
}

*date = \&ymd;

sub mdy {
    my $time = shift;
    my $sep = @_ ? shift(@_) : $DATE_SEP;
    sprintf("%02d$sep%02d$sep%d", $time->mon, $time->[c_mday], $time->year);
}

sub dmy {
    my $time = shift;
    my $sep = @_ ? shift(@_) : $DATE_SEP;
    sprintf("%02d$sep%02d$sep%d", $time->[c_mday], $time->mon, $time->year);
}

sub datetime {
    my $time = shift;
    my %seps = (date => $DATE_SEP, T => 'T', time => $TIME_SEP, @_);
    return join($seps{T}, $time->date($seps{date}), $time->time($seps{time}));
}



# Julian Day is always calculated for UT regardless
# of local time
sub julian_day {
    my $time = shift;
    # Correct for localtime
    $time = $time->gmtime( $time->epoch ) if $time->[c_islocal];

    # Calculate the Julian day itself
    my $jd = $time->_jd( $time->year, $time->mon, $time->mday,
                        $time->hour, $time->min, $time->sec);

    return $jd;
}

# MJD is defined as JD - 2400000.5 days
sub mjd {
    return shift->julian_day - 2_400_000.5;
}

# Internal calculation of Julian date. Needed here so that
# both tzoffset and mjd/jd methods can share the code
# Algorithm from Hatcher 1984 (QJRAS 25, 53-55), and
#  Hughes et al, 1989, MNRAS, 238, 15
# See: http://adsabs.harvard.edu/cgi-bin/nph-bib_query?bibcode=1989MNRAS.238.1529H&db_key=AST
# for more details

sub _jd {
    my $self = shift;
    my ($y, $m, $d, $h, $n, $s) = @_;

    # Adjust input parameters according to the month
    $y = ( $m > 2 ? $y : $y - 1);
    $m = ( $m > 2 ? $m - 3 : $m + 9);

    # Calculate the Julian Date (assuming Julian calendar)
    my $J = int( 365.25 *( $y + 4712) )
      + int( (30.6 * $m) + 0.5)
        + 59
          + $d
            - 0.5;

    # Calculate the Gregorian Correction (since we have Gregorian dates)
    my $G = 38 - int( 0.75 * int(49+($y/100)));

    # Calculate the actual Julian Date
    my $JD = $J + $G;

    # Modify to include hours/mins/secs in floating portion.
    return $JD + ($h + ($n + $s / 60) / 60) / 24;
}

sub week {
    my $self = shift;

    my $J  = $self->julian_day;
    # Julian day is independent of time zone so add on tzoffset
    # if we are using local time here since we want the week day
    # to reflect the local time rather than UTC
    $J += ($self->tzoffset/(24*3600)) if $self->[c_islocal];

    # Now that we have the Julian day including fractions
    # convert it to an integer Julian Day Number using nearest
    # int (since the day changes at midday we convert all Julian
    # dates to following midnight).
    $J = int($J+0.5);

    use integer;
    my $d4 = ((($J + 31741 - ($J % 7)) % 146097) % 36524) % 1461;
    my $L  = $d4 / 1460;
    my $d1 = (($d4 - $L) % 365) + $L;
    return $d1 / 7 + 1;
}

sub _is_leap_year {
    my $year = shift;
    return (($year %4 == 0) && !($year % 100 == 0)) || ($year % 400 == 0)
               ? 1 : 0;
}

sub is_leap_year {
    my $time = shift;
    my $year = $time->year;
    return _is_leap_year($year);
}

my @MON_LAST = qw(31 28 31 30 31 30 31 31 30 31 30 31);

sub month_last_day {
    my $time = shift;
    my $year = $time->year;
    my $_mon = $time->_mon;
    return $MON_LAST[$_mon] + ($_mon == 1 ? _is_leap_year($year) : 0);
}

#since %z and %Z are not portable lets just
#parse it out before calling native strftime
#(but only if we are in UTC time)
my %GMT_REPR = (
    '%z' => '+0000',
    '%Z' => 'UTC',
);

sub strftime {
    my $time = shift;
    my $format = @_ ? shift(@_) : '%a, %d %b %Y %H:%M:%S %Z';
    if (! $time->[c_islocal]) {
        $format =~ s/(%.)/$GMT_REPR{$1} || $1/eg;
    }

    return _strftime($format, $time->epoch, $time->[c_islocal]);
}

sub strptime {
    my $time = shift;
    my $string = shift;
    my $format = @_ ? shift(@_) : "%a, %d %b %Y %H:%M:%S %Z";
    my @vals = _strptime($string, $format);
#    warn(sprintf("got vals: %d-%d-%d %d:%d:%d\n", reverse(@vals)));
    return scalar $time->_mktime(\@vals, (ref($time) ? $time->[c_islocal] : 0));
}

sub day_list {
    shift if ref($_[0]) && $_[0]->isa(__PACKAGE__); # strip first if called as a method
    my @old = @DAY_LIST;
    if (@_) {
        @DAY_LIST = @_;
    }
    return @old;
}

sub mon_list {
    shift if ref($_[0]) && $_[0]->isa(__PACKAGE__); # strip first if called as a method
    my @old = @MON_LIST;
    if (@_) {
        @MON_LIST = @_;
    }
    return @old;
}

sub time_separator {
    shift if ref($_[0]) && $_[0]->isa(__PACKAGE__);
    my $old = $TIME_SEP;
    if (@_) {
        $TIME_SEP = $_[0];
    }
    return $old;
}

sub date_separator {
    shift if ref($_[0]) && $_[0]->isa(__PACKAGE__);
    my $old = $DATE_SEP;
    if (@_) {
        $DATE_SEP = $_[0];
    }
    return $old;
}

use overload '""' => \&cdate,
             'cmp' => \&str_compare,
             'fallback' => undef;

sub cdate {
    my $time = shift;
    if ($time->[c_islocal]) {
        return scalar(CORE::localtime($time->epoch));
    }
    else {
        return scalar(CORE::gmtime($time->epoch));
    }
}

sub str_compare {
    my ($lhs, $rhs, $reverse) = @_;
    if (UNIVERSAL::isa($rhs, 'Time::Piece')) {
        $rhs = "$rhs";
    }
    return $reverse ? $rhs cmp $lhs->cdate : $lhs->cdate cmp $rhs;
}

use overload
        '-' => \&subtract,
        '+' => \&add;

sub subtract {
    my $time = shift;
    my $rhs = shift;
    if (UNIVERSAL::isa($rhs, 'Time::Seconds')) {
        $rhs = $rhs->seconds;
    }

    if (shift)
    {
	# SWAPED is set (so someone tried an expression like NOTDATE - DATE).
	# Imitate Perl's standard behavior and return the result as if the
	# string $time resolves to was subtracted from NOTDATE.  This way,
	# classes which override this one and which have a stringify function
	# that resolves to something that looks more like a number don't need
	# to override this function.
	return $rhs - "$time";
    }

    if (UNIVERSAL::isa($rhs, 'Time::Piece')) {
        return Time::Seconds->new($time->epoch - $rhs->epoch);
    }
    else {
        # rhs is seconds.
        return $time->_mktime(($time->epoch - $rhs), $time->[c_islocal]);
    }
}

sub add {
    my $time = shift;
    my $rhs = shift;
    if (UNIVERSAL::isa($rhs, 'Time::Seconds')) {
        $rhs = $rhs->seconds;
    }
    croak "Invalid rhs of addition: $rhs" if ref($rhs);

    return $time->_mktime(($time->epoch + $rhs), $time->[c_islocal]);
}

use overload
        '<=>' => \&compare;

sub get_epochs {
    my ($lhs, $rhs, $reverse) = @_;
    if (!UNIVERSAL::isa($rhs, 'Time::Piece')) {
        $rhs = $lhs->new($rhs);
    }
    if ($reverse) {
        return $rhs->epoch, $lhs->epoch;
    }
    return $lhs->epoch, $rhs->epoch;
}

sub compare {
    my ($lhs, $rhs) = get_epochs(@_);
    return $lhs <=> $rhs;
}

sub add_months {
    my ($time, $num_months) = @_;

    croak("add_months requires a number of months") unless defined($num_months);

    my $final_month = $time->_mon + $num_months;
    my $num_years = 0;
    if ($final_month > 11 || $final_month < 0) {
        # these two ops required because we have no POSIX::floor and don't
        # want to load POSIX.pm
        if ($final_month < 0 && $final_month % 12 == 0) {
            $num_years = int($final_month / 12) + 1;
        }
        else {
            $num_years = int($final_month / 12);
        }
        $num_years-- if ($final_month < 0);

        $final_month = $final_month % 12;
    }

    my @vals = _mini_mktime($time->sec, $time->min, $time->hour,
                            $time->mday, $final_month, $time->year - 1900 + $num_years);
    # warn(sprintf("got %d vals: %d-%d-%d %d:%d:%d [%d]\n", scalar(@vals), reverse(@vals), $time->[c_islocal]));
    return scalar $time->_mktime(\@vals, $time->[c_islocal]);
}

sub add_years {
    my ($time, $years) = @_;
    $time->add_months($years * 12);
}

1;
__END__

=head1 NAME

Time::Piece - Object Oriented time objects

=head1 SYNOPSIS

    use Time::Piece;
    
    my $t = localtime;
    print "Time is $t\n";
    print "Year is ", $t->year, "\n";

=head1 DESCRIPTION

This module replaces the standard C<localtime> and C<gmtime> functions with
implementations that return objects. It does so in a backwards
compatible manner, so that using localtime/gmtime in the way documented
in perlfunc will still return what you expect.

The module actually implements most of an interface described by
Larry Wall on the perl5-porters mailing list here:
http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/2000-01/msg00241.html

=head1 USAGE

After importing this module, when you use localtime or gmtime in a scalar
context, rather than getting an ordinary scalar string representing the
date and time, you get a Time::Piece object, whose stringification happens
to produce the same effect as the localtime and gmtime functions. There is 
also a new() constructor provided, which is the same as localtime(), except
when passed a Time::Piece object, in which case it's a copy constructor. The
following methods are available on the object:

    $t->sec                 # also available as $t->second
    $t->min                 # also available as $t->minute
    $t->hour                # 24 hour
    $t->mday                # also available as $t->day_of_month
    $t->mon                 # 1 = January
    $t->_mon                # 0 = January
    $t->monname             # Feb
    $t->month               # same as $t->monname
    $t->fullmonth           # February
    $t->year                # based at 0 (year 0 AD is, of course 1 BC)
    $t->_year               # year minus 1900
    $t->yy                  # 2 digit year
    $t->wday                # 1 = Sunday
    $t->_wday               # 0 = Sunday
    $t->day_of_week         # 0 = Sunday
    $t->wdayname            # Tue
    $t->day                 # same as wdayname
    $t->fullday             # Tuesday
    $t->yday                # also available as $t->day_of_year, 0 = Jan 01
    $t->isdst               # also available as $t->daylight_savings

    $t->hms                 # 12:34:56
    $t->hms(".")            # 12.34.56
    $t->time                # same as $t->hms

    $t->ymd                 # 2000-02-29
    $t->date                # same as $t->ymd
    $t->mdy                 # 02-29-2000
    $t->mdy("/")            # 02/29/2000
    $t->dmy                 # 29-02-2000
    $t->dmy(".")            # 29.02.2000
    $t->datetime            # 2000-02-29T12:34:56 (ISO 8601)
    $t->cdate               # Tue Feb 29 12:34:56 2000
    "$t"                    # same as $t->cdate

    $t->epoch               # seconds since the epoch
    $t->tzoffset            # timezone offset in a Time::Seconds object

    $t->julian_day          # number of days since Julian period began
    $t->mjd                 # modified Julian date (JD-2400000.5 days)

    $t->week                # week number (ISO 8601)

    $t->is_leap_year        # true if it's a leap year
    $t->month_last_day      # 28-31

    $t->time_separator($s)  # set the default separator (default ":")
    $t->date_separator($s)  # set the default separator (default "-")
    $t->day_list(@days)     # set the default weekdays
    $t->mon_list(@days)     # set the default months

    $t->strftime(FORMAT)    # same as POSIX::strftime (without the overhead
                            # of the full POSIX extension)
    $t->strftime()          # "Tue, 29 Feb 2000 12:34:56 GMT"
    
    Time::Piece->strptime(STRING, FORMAT)
                            # see strptime man page. Creates a new
                            # Time::Piece object

Note that C<localtime> and C<gmtime> are not listed above.  If called as
methods on a Time::Piece object, they act as constructors, returning a new
Time::Piece object for the current time.  In other words: they're not useful as
methods.

=head2 Local Locales

Both wdayname (day) and monname (month) allow passing in a list to use
to index the name of the days against. This can be useful if you need
to implement some form of localisation without actually installing or
using locales.

  my @days = qw( Dimanche Lundi Merdi Mercredi Jeudi Vendredi Samedi );

  my $french_day = localtime->day(@days);

These settings can be overridden globally too:

  Time::Piece::day_list(@days);

Or for months:

  Time::Piece::mon_list(@months);

And locally for months:

  print localtime->month(@months);

=head2 Date Calculations

It's possible to use simple addition and subtraction of objects:

    use Time::Seconds;
    
    my $seconds = $t1 - $t2;
    $t1 += ONE_DAY; # add 1 day (constant from Time::Seconds)

The following are valid ($t1 and $t2 are Time::Piece objects):

    $t1 - $t2; # returns Time::Seconds object
    $t1 - 42; # returns Time::Piece object
    $t1 + 533; # returns Time::Piece object

However adding a Time::Piece object to another Time::Piece object
will cause a runtime error.

Note that the first of the above returns a Time::Seconds object, so
while examining the object will print the number of seconds (because
of the overloading), you can also get the number of minutes, hours,
days, weeks and years in that delta, using the Time::Seconds API.

In addition to adding seconds, there are two APIs for adding months and
years:

    $t = $t->add_months(6);
    $t = $t->add_years(5);

The months and years can be negative for subtractions. Note that there
is some "strange" behaviour when adding and subtracting months at the
ends of months. Generally when the resulting month is shorter than the
starting month then the number of overlap days is added. For example
subtracting a month from 2008-03-31 will not result in 2008-02-31 as this
is an impossible date. Instead you will get 2008-03-02. This appears to
be consistent with other date manipulation tools.

=head2 Date Comparisons

Date comparisons are also possible, using the full suite of "<", ">",
"<=", ">=", "<=>", "==" and "!=".

=head2 Date Parsing

Time::Piece has a built-in strptime() function (from FreeBSD), allowing
you incredibly flexible date parsing routines. For example:

  my $t = Time::Piece->strptime("Sunday 3rd Nov, 1943",
                                "%A %drd %b, %Y");
  
  print $t->strftime("%a, %d %b %Y");

Outputs:

  Wed, 03 Nov 1943

(see, it's even smart enough to fix my obvious date bug)

For more information see "man strptime", which should be on all unix
systems.

Alternatively look here: http://www.unix.com/man-page/FreeBSD/3/strftime/

=head2 YYYY-MM-DDThh:mm:ss

The ISO 8601 standard defines the date format to be YYYY-MM-DD, and
the time format to be hh:mm:ss (24 hour clock), and if combined, they
should be concatenated with date first and with a capital 'T' in front
of the time.

=head2 Week Number

The I<week number> may be an unknown concept to some readers.  The ISO
8601 standard defines that weeks begin on a Monday and week 1 of the
year is the week that includes both January 4th and the first Thursday
of the year.  In other words, if the first Monday of January is the
2nd, 3rd, or 4th, the preceding days of the January are part of the
last week of the preceding year.  Week numbers range from 1 to 53.

=head2 Global Overriding

Finally, it's possible to override localtime and gmtime everywhere, by
including the ':override' tag in the import list:

    use Time::Piece ':override';

=head1 CAVEATS

=head2 Setting $ENV{TZ} in Threads on Win32

Note that when using perl in the default build configuration on Win32
(specifically, when perl is built with PERL_IMPLICIT_SYS), each perl
interpreter maintains its own copy of the environment and only the main
interpreter will update the process environment seen by strftime.

Therefore, if you make changes to $ENV{TZ} from inside a thread other than
the main thread then those changes will not be seen by strftime if you
subsequently call that with the %Z formatting code. You must change $ENV{TZ}
in the main thread to have the desired effect in this case (and you must
also call _tzset() in the main thread to register the environment change).

Furthermore, remember that this caveat also applies to fork(), which is
emulated by threads on Win32.

=head2 Use of epoch seconds

This module internally uses the epoch seconds system that is provided via
the perl C<time()> function and supported by C<gmtime()> and C<localtime()>.

If your perl does not support times larger than C<2^31> seconds then this
module is likely to fail at processing dates beyond the year 2038. There are
moves afoot to fix that in perl. Alternatively use 64 bit perl. Or if none
of those are options, use the L<DateTime> module which has support for years
well into the future and past.

=head1 AUTHOR

Matt Sergeant, matt@sergeant.org
Jarkko Hietaniemi, jhi@iki.fi (while creating Time::Piece for core perl)

=head1 COPYRIGHT AND LICENSE

Copyright 2001, Larry Wall.

This module is free software, you may distribute it under the same terms
as Perl.

=head1 SEE ALSO

The excellent Calendar FAQ at http://www.tondering.dk/claus/calendar.html

=head1 BUGS

The test harness leaves much to be desired. Patches welcome.

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   package Time::Seconds;
use strict;

our $VERSION = '1.31';

use Exporter 5.57 'import';

our @EXPORT = qw(
    ONE_MINUTE
    ONE_HOUR
    ONE_DAY
    ONE_WEEK
    ONE_MONTH
    ONE_YEAR
    ONE_FINANCIAL_MONTH
    LEAP_YEAR
    NON_LEAP_YEAR
);

our @EXPORT_OK = qw(cs_sec cs_mon);

use constant {
    ONE_MINUTE => 60,
    ONE_HOUR => 3_600,
    ONE_DAY => 86_400,
    ONE_WEEK => 604_800,
    ONE_MONTH => 2_629_744, # ONE_YEAR / 12
    ONE_YEAR => 31_556_930, # 365.24225 days
    ONE_FINANCIAL_MONTH => 2_592_000, # 30 days
    LEAP_YEAR => 31_622_400, # 366 * ONE_DAY
    NON_LEAP_YEAR => 31_536_000, # 365 * ONE_DAY
    # hacks to make Time::Piece compile once again
    cs_sec => 0,
    cs_mon => 1,
};

use overload
    'fallback' => 'undef',
    '0+' => \&seconds,
    '""' => \&seconds,
    '<=>' => \&compare,
    '+' => \&add,
    '-' => \&subtract,
    '-=' => \&subtract_from,
    '+=' => \&add_to,
    '=' => \&copy;

sub new {
    my $class = shift;
    my ($val) = @_;
    $val = 0 unless defined $val;
    bless \$val, $class;
}

sub _get_ovlvals {
    my ($lhs, $rhs, $reverse) = @_;
    $lhs = $lhs->seconds;

    if (UNIVERSAL::isa($rhs, 'Time::Seconds')) {
        $rhs = $rhs->seconds;
    }
    elsif (ref($rhs)) {
        die "Can't use non Seconds object in operator overload";
    }

    if ($reverse) {
        return $rhs, $lhs;
    }

    return $lhs, $rhs;
}

sub compare {
    my ($lhs, $rhs) = _get_ovlvals(@_);
    return $lhs <=> $rhs;
}

sub add {
    my ($lhs, $rhs) = _get_ovlvals(@_);
    return Time::Seconds->new($lhs + $rhs);
}

sub add_to {
    my $lhs = shift;
    my $rhs = shift;
    $rhs = $rhs->seconds if UNIVERSAL::isa($rhs, 'Time::Seconds');
    $$lhs += $rhs;
    return $lhs;
}

sub subtract {
    my ($lhs, $rhs) = _get_ovlvals(@_);
    return Time::Seconds->new($lhs - $rhs);
}

sub subtract_from {
    my $lhs = shift;
    my $rhs = shift;
    $rhs = $rhs->seconds if UNIVERSAL::isa($rhs, 'Time::Seconds');
    $$lhs -= $rhs;
    return $lhs;
}

sub copy {
	Time::Seconds->new(${$_[0]});
}

sub seconds {
    my $s = shift;
    return $$s;
}

sub minutes {
    my $s = shift;
    return $$s / 60;
}

sub hours {
    my $s = shift;
    $s->minutes / 60;
}

sub days {
    my $s = shift;
    $s->hours / 24;
}

sub weeks {
    my $s = shift;
    $s->days / 7;
}

sub months {
    my $s = shift;
    $s->days / 30.4368541;
}

sub financial_months {
    my $s = shift;
    $s->days / 30;
}

sub years {
    my $s = shift;
    $s->days / 365.24225;
}

sub pretty {
    my $s = shift;
    my $str = "";
    if ($s < 0) {
        $s = -$s;
        $str = "minus ";
    }
    if ($s >= ONE_MINUTE) {
        if ($s >= ONE_HOUR) {
            if ($s >= ONE_DAY) {
                my $days = sprintf("%d", $s->days); # does a "floor"
                $str .= $days . " days, ";
                $s -= ($days * ONE_DAY);
            }
            my $hours = sprintf("%d", $s->hours);
            $str .= $hours . " hours, ";
            $s -= ($hours * ONE_HOUR);
        }
        my $mins = sprintf("%d", $s->minutes);
        $str .= $mins . " minutes, ";
        $s -= ($mins * ONE_MINUTE);
    }
    $str .= $s->seconds . " seconds";
    return $str;
}

1;
__END__

=encoding utf8

=head1 NAME

Time::Seconds - a simple API to convert seconds to other date values

=head1 SYNOPSIS

    use Time::Piece;
    use Time::Seconds;
    
    my $t = localtime;
    $t += ONE_DAY;
    
    my $t2 = localtime;
    my $s = $t - $t2;
    
    print "Difference is: ", $s->days, "\n";

=head1 DESCRIPTION

This module is part of the Time::Piece distribution. It allows the user
to find out the number of minutes, hours, days, weeks or years in a given
number of seconds. It is returned by Time::Piece when you delta two
Time::Piece objects.

Time::Seconds also exports the following constants:

    ONE_DAY
    ONE_WEEK
    ONE_HOUR
    ONE_MINUTE
    ONE_MONTH
    ONE_YEAR
    ONE_FINANCIAL_MONTH
    LEAP_YEAR
    NON_LEAP_YEAR

Since perl does not (yet?) support constant objects, these constants are in
seconds only, so you cannot, for example, do this: C<print ONE_WEEK-E<gt>minutes;>

=head1 METHODS

The following methods are available:

    my $val = Time::Seconds->new(SECONDS)
    $val->seconds;
    $val->minutes;
    $val->hours;
    $val->days;
    $val->weeks;
    $val->months;
    $val->financial_months; # 30 days
    $val->years;
    $val->pretty; # gives English representation of the delta

The usual arithmetic (+,-,+=,-=) is also available on the objects.

The methods make the assumption that there are 24 hours in a day, 7 days in
a week, 365.24225 days in a year and 12 months in a year.
(from The Calendar FAQ at http://www.tondering.dk/claus/calendar.html)

=head1 AUTHOR

Matt Sergeant, matt@sergeant.org

Tobias Brox, tobiasb@tobiasb.funcom.com

Balzs Szab (dLux), dlux@kapu.hu

=head1 COPYRIGHT AND LICENSE

Copyright 2001, Larry Wall.

This module is free software, you may distribute it under the same terms
as Perl.

=head1 Bugs

Currently the methods aren't as efficient as they could be, for reasons of
clarity. This is probably a bad idea.

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          require '_h2ph_pre.ph';

no warnings qw(redefine misc);

unless(defined(&__ASM_GENERIC_BITS_PER_LONG)) {
    eval 'sub __ASM_GENERIC_BITS_PER_LONG () {1;}' unless defined(&__ASM_GENERIC_BITS_PER_LONG);
    unless(defined(&__BITS_PER_LONG)) {
	eval 'sub __BITS_PER_LONG () {32;}' unless defined(&__BITS_PER_LONG);
    }
}
1;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            require '_h2ph_pre.ph';

no warnings qw(redefine misc);

unless(defined(&_ASM_GENERIC_IOCTL_H)) {
    eval 'sub _ASM_GENERIC_IOCTL_H () {1;}' unless defined(&_ASM_GENERIC_IOCTL_H);
    eval 'sub _IOC_NRBITS () {8;}' unless defined(&_IOC_NRBITS);
    eval 'sub _IOC_TYPEBITS () {8;}' unless defined(&_IOC_TYPEBITS);
    unless(defined(&_IOC_SIZEBITS)) {
	eval 'sub _IOC_SIZEBITS () {14;}' unless defined(&_IOC_SIZEBITS);
    }
    unless(defined(&_IOC_DIRBITS)) {
	eval 'sub _IOC_DIRBITS () {2;}' unless defined(&_IOC_DIRBITS);
    }
    eval 'sub _IOC_NRMASK () {((1<<  &_IOC_NRBITS)-1);}' unless defined(&_IOC_NRMASK);
    eval 'sub _IOC_TYPEMASK () {((1<<  &_IOC_TYPEBITS)-1);}' unless defined(&_IOC_TYPEMASK);
    eval 'sub _IOC_SIZEMASK () {((1<<  &_IOC_SIZEBITS)-1);}' unless defined(&_IOC_SIZEMASK);
    eval 'sub _IOC_DIRMASK () {((1<<  &_IOC_DIRBITS)-1);}' unless defined(&_IOC_DIRMASK);
    eval 'sub _IOC_NRSHIFT () {0;}' unless defined(&_IOC_NRSHIFT);
    eval 'sub _IOC_TYPESHIFT () {( &_IOC_NRSHIFT+ &_IOC_NRBITS);}' unless defined(&_IOC_TYPESHIFT);
    eval 'sub _IOC_SIZESHIFT () {( &_IOC_TYPESHIFT+ &_IOC_TYPEBITS);}' unless defined(&_IOC_SIZESHIFT);
    eval 'sub _IOC_DIRSHIFT () {( &_IOC_SIZESHIFT+ &_IOC_SIZEBITS);}' unless defined(&_IOC_DIRSHIFT);
    unless(defined(&_IOC_NONE)) {
	eval 'sub _IOC_NONE () {0;}' unless defined(&_IOC_NONE);
    }
    unless(defined(&_IOC_WRITE)) {
	eval 'sub _IOC_WRITE () {1;}' unless defined(&_IOC_WRITE);
    }
    unless(defined(&_IOC_READ)) {
	eval 'sub _IOC_READ () {2;}' unless defined(&_IOC_READ);
    }
    eval 'sub _IOC {
        my($dir,$type,$nr,$size) = @_;
	    eval q(((($dir) <<  &_IOC_DIRSHIFT) | (($type) <<  &_IOC_TYPESHIFT) | (($nr) <<  &_IOC_NRSHIFT) | (($size) <<  &_IOC_SIZESHIFT)));
    }' unless defined(&_IOC);
    eval 'sub _IOC_TYPECHECK {
        my($t) = @_;
	    eval q(($sizeof{$t}));
    }' unless defined(&_IOC_TYPECHECK);
    eval 'sub _IO {
        my($type,$nr) = @_;
	    eval q( &_IOC( &_IOC_NONE,($type),($nr),0));
    }' unless defined(&_IO);
    eval 'sub _IOR {
        my($type,$nr,$size) = @_;
	    eval q( &_IOC( &_IOC_READ,($type),($nr),( &_IOC_TYPECHECK($size))));
    }' unless defined(&_IOR);
    eval 'sub _IOW {
        my($type,$nr,$size) = @_;
	    eval q( &_IOC( &_IOC_WRITE,($type),($nr),( &_IOC_TYPECHECK($size))));
    }' unless defined(&_IOW);
    eval 'sub _IOWR {
        my($type,$nr,$size) = @_;
	    eval q( &_IOC( &_IOC_READ| &_IOC_WRITE,($type),($nr),( &_IOC_TYPECHECK($size))));
    }' unless defined(&_IOWR);
    eval 'sub _IOR_BAD {
        my($type,$nr,$size) = @_;
	    eval q( &_IOC( &_IOC_READ,($type),($nr),$sizeof{$size}));
    }' unless defined(&_IOR_BAD);
    eval 'sub _IOW_BAD {
        my($type,$nr,$size) = @_;
	    eval q( &_IOC( &_IOC_WRITE,($type),($nr),$sizeof{$size}));
    }' unless defined(&_IOW_BAD);
    eval 'sub _IOWR_BAD {
        my($type,$nr,$size) = @_;
	    eval q( &_IOC( &_IOC_READ| &_IOC_WRITE,($type),($nr),$sizeof{$size}));
    }' unless defined(&_IOWR_BAD);
    eval 'sub _IOC_DIR {
        my($nr) = @_;
	    eval q(((($nr) >>  &_IOC_DIRSHIFT) &  &_IOC_DIRMASK));
    }' unless defined(&_IOC_DIR);
    eval 'sub _IOC_TYPE {
        my($nr) = @_;
	    eval q(((($nr) >>  &_IOC_TYPESHIFT) &  &_IOC_TYPEMASK));
    }' unless defined(&_IOC_TYPE);
    eval 'sub _IOC_NR {
        my($nr) = @_;
	    eval q(((($nr) >>  &_IOC_NRSHIFT) &  &_IOC_NRMASK));
    }' unless defined(&_IOC_NR);
    eval 'sub _IOC_SIZE {
        my($nr) = @_;
	    eval q(((($nr) >>  &_IOC_SIZESHIFT) &  &_IOC_SIZEMASK));
    }' unless defined(&_IOC_SIZE);
    eval 'sub IOC_IN () {( &_IOC_WRITE <<  &_IOC_DIRSHIFT);}' unless defined(&IOC_IN);
    eval 'sub IOC_OUT () {( &_IOC_READ <<  &_IOC_DIRSHIFT);}' unless defined(&IOC_OUT);
    eval 'sub IOC_INOUT () {(( &_IOC_WRITE| &_IOC_READ) <<  &_IOC_DIRSHIFT);}' unless defined(&IOC_INOUT);
    eval 'sub IOCSIZE_MASK () {( &_IOC_SIZEMASK <<  &_IOC_SIZESHIFT);}' unless defined(&IOCSIZE_MASK);
    eval 'sub IOCSIZE_SHIFT () {( &_IOC_SIZESHIFT);}' unless defined(&IOCSIZE_SHIFT);
}
1;
                                    package Unicode::Collate;

BEGIN {
    unless ("A" eq pack('U', 0x41)) {
	die "Unicode::Collate cannot stringify a Unicode code point\n";
    }
    unless (0x41 == unpack('U', 'A')) {
	die "Unicode::Collate cannot get a Unicode code point\n";
    }
}

use 5.006;
use strict;
use warnings;
use Carp;
use File::Spec;

no warnings 'utf8';

our $VERSION = '1.14';
our $PACKAGE = __PACKAGE__;

### begin XS only ###
require DynaLoader;
our @ISA = qw(DynaLoader);
bootstrap Unicode::Collate $VERSION;
### end XS only ###

my @Path = qw(Unicode Collate);
my $KeyFile = "allkeys.txt";

# Perl's boolean
use constant TRUE  => 1;
use constant FALSE => "";
use constant NOMATCHPOS => -1;

# A coderef to get combining class imported from Unicode::Normalize
# (i.e. \&Unicode::Normalize::getCombinClass).
# This is also used as a HAS_UNICODE_NORMALIZE flag.
my $CVgetCombinClass;

# Supported Levels
use constant MinLevel => 1;
use constant MaxLevel => 4;

# Minimum weights at level 2 and 3, respectively
use constant Min2Wt => 0x20;
use constant Min3Wt => 0x02;

# Shifted weight at 4th level
use constant Shift4Wt => 0xFFFF;

# A boolean for Variable and 16-bit weights at 4 levels of Collation Element
use constant VCE_TEMPLATE => 'Cn4';

# A sort key: 16-bit weights
use constant KEY_TEMPLATE => 'n*';

# The tie-breaking: 32-bit weights
use constant TIE_TEMPLATE => 'N*';

# Level separator in a sort key:
# i.e. pack(KEY_TEMPLATE, 0)
use constant LEVEL_SEP => "\0\0";

# As Unicode code point separator for hash keys.
# A joined code point string (denoted by JCPS below)
# like "65;768" is used for internal processing
# instead of Perl's Unicode string like "\x41\x{300}",
# as the native code point is different from the Unicode code point
# on EBCDIC platform.
# This character must not be included in any stringified
# representation of an integer.
use constant CODE_SEP => ';';
	# NOTE: in regex /;/ is used for $jcps!

# boolean values of variable weights
use constant NON_VAR => 0; # Non-Variable character
use constant VAR     => 1; # Variable character

# specific code points
use constant Hangul_SIni   => 0xAC00;
use constant Hangul_SFin   => 0xD7A3;

# Logical_Order_Exception in PropList.txt
my $DefaultRearrange = [ 0x0E40..0x0E44, 0x0EC0..0x0EC4 ];

# for highestFFFF and minimalFFFE
my $HighestVCE = pack(VCE_TEMPLATE, 0, 0xFFFE, 0x20, 0x5, 0xFFFF);
my $minimalVCE = pack(VCE_TEMPLATE, 0,      1, 0x20, 0x5, 0xFFFE);

sub UCA_Version { "30" }

sub Base_Unicode_Version { "7.0.0" }

######

sub pack_U {
    return pack('U*', @_);
}

sub unpack_U {
    return unpack('U*', shift(@_).pack('U*'));
}

######

my (%VariableOK);
@VariableOK{ qw/
    blanked  non-ignorable  shifted  shift-trimmed
  / } = (); # keys lowercased

our @ChangeOK = qw/
    alternate backwards level normalization rearrange
    katakana_before_hiragana upper_before_lower ignore_level2
    overrideCJK overrideHangul overrideOut preprocess UCA_Version
    hangul_terminator variable identical highestFFFF minimalFFFE
    long_contraction
  /;

our @ChangeNG = qw/
    entry mapping table maxlength contraction
    ignoreChar ignoreName undefChar undefName rewrite
    versionTable alternateTable backwardsTable forwardsTable
    rearrangeTable variableTable
    derivCode normCode rearrangeHash backwardsFlag
    suppress suppressHash
    __useXS /; ### XS only
# The hash key 'ignored' was deleted at v 0.21.
# The hash key 'isShift' was deleted at v 0.23.
# The hash key 'combining' was deleted at v 0.24.
# The hash key 'entries' was deleted at v 0.30.
# The hash key 'L3_ignorable' was deleted at v 0.40.

sub version {
    my $self = shift;
    return $self->{versionTable} || 'unknown';
}

my (%ChangeOK, %ChangeNG);
@ChangeOK{ @ChangeOK } = ();
@ChangeNG{ @ChangeNG } = ();

sub change {
    my $self = shift;
    my %hash = @_;
    my %old;
    if (exists $hash{alternate}) {
	if (exists $hash{variable}) {
	    delete $hash{alternate};
	} else {
	    $hash{variable} = $hash{alternate};
	}
    }
    foreach my $k (keys %hash) {
	if (exists $ChangeOK{$k}) {
	    $old{$k} = $self->{$k};
	    $self->{$k} = $hash{$k};
	} elsif (exists $ChangeNG{$k}) {
	    croak "change of $k via change() is not allowed!";
	}
	# else => ignored
    }
    $self->checkCollator();
    return wantarray ? %old : $self;
}

sub _checkLevel {
    my $level = shift;
    my $key   = shift; # 'level' or 'backwards'
    MinLevel <= $level or croak sprintf
	"Illegal level %d (in value for key '%s') lower than %d.",
	    $level, $key, MinLevel;
    $level <= MaxLevel or croak sprintf
	"Unsupported level %d (in value for key '%s') higher than %d.",
	    $level, $key, MaxLevel;
}

my %DerivCode = (
    8 => \&_derivCE_8,
    9 => \&_derivCE_9,
   11 => \&_derivCE_9, # 11 == 9
   14 => \&_derivCE_14,
   16 => \&_derivCE_14, # 16 == 14
   18 => \&_derivCE_18,
   20 => \&_derivCE_20,
   22 => \&_derivCE_22,
   24 => \&_derivCE_24,
   26 => \&_derivCE_24, # 26 == 24
   28 => \&_derivCE_24, # 28 == 24
   30 => \&_derivCE_24, # 30 == 24
);

sub checkCollator {
    my $self = shift;
    _checkLevel($self->{level}, "level");

    $self->{derivCode} = $DerivCode{ $self->{UCA_Version} }
	or croak "Illegal UCA version (passed $self->{UCA_Version}).";

    $self->{variable} ||= $self->{alternate} || $self->{variableTable} ||
				$self->{alternateTable} || 'shifted';
    $self->{variable} = $self->{alternate} = lc($self->{variable});
    exists $VariableOK{ $self->{variable} }
	or croak "$PACKAGE unknown variable parameter name: $self->{variable}";

    if (! defined $self->{backwards}) {
	$self->{backwardsFlag} = 0;
    } elsif (! ref $self->{backwards}) {
	_checkLevel($self->{backwards}, "backwards");
	$self->{backwardsFlag} = 1 << $self->{backwards};
    } else {
	my %level;
	$self->{backwardsFlag} = 0;
	for my $b (@{ $self->{backwards} }) {
	    _checkLevel($b, "backwards");
	    $level{$b} = 1;
	}
	for my $v (sort keys %level) {
	    $self->{backwardsFlag} += 1 << $v;
	}
    }

    defined $self->{rearrange} or $self->{rearrange} = [];
    ref $self->{rearrange}
	or croak "$PACKAGE: list for rearrangement must be store in ARRAYREF";

    # keys of $self->{rearrangeHash} are $self->{rearrange}.
    $self->{rearrangeHash} = undef;

    if (@{ $self->{rearrange} }) {
	@{ $self->{rearrangeHash} }{ @{ $self->{rearrange} } } = ();
    }

    $self->{normCode} = undef;

    if (defined $self->{normalization}) {
	eval { require Unicode::Normalize };
	$@ and croak "Unicode::Normalize is required to normalize strings";

	$CVgetCombinClass ||= \&Unicode::Normalize::getCombinClass;

	if ($self->{normalization} =~ /^(?:NF)D\z/) { # tweak for default
	    $self->{normCode} = \&Unicode::Normalize::NFD;
	}
	elsif ($self->{normalization} ne 'prenormalized') {
	    my $norm = $self->{normalization};
	    $self->{normCode} = sub {
		Unicode::Normalize::normalize($norm, shift);
	    };
	    eval { $self->{normCode}->("") }; # try
	    $@ and croak "$PACKAGE unknown normalization form name: $norm";
	}
    }
    return;
}

sub new
{
    my $class = shift;
    my $self = bless { @_ }, $class;

### begin XS only ###
    if (! exists $self->{table}     && !defined $self->{rewrite} &&
	!defined $self->{undefName} && !defined $self->{ignoreName} &&
	!defined $self->{undefChar} && !defined $self->{ignoreChar}) {
	$self->{__useXS} = \&_fetch_simple;
    } else {
	$self->{__useXS} = undef;
    }
### end XS only ###

    # keys of $self->{suppressHash} are $self->{suppress}.
    if ($self->{suppress} && @{ $self->{suppress} }) {
	@{ $self->{suppressHash} }{ @{ $self->{suppress} } } = ();
    } # before read_table()

    # If undef is passed explicitly, no file is read.
    $self->{table} = $KeyFile if ! exists $self->{table};
    $self->read_table() if defined $self->{table};

    if ($self->{entry}) {
	while ($self->{entry} =~ /([^\n]+)/g) {
	    $self->parseEntry($1, TRUE);
	}
    }

    # only in new(), not in change()
    $self->{level} ||= MaxLevel;
    $self->{UCA_Version} ||= UCA_Version();

    $self->{overrideHangul} = FALSE
	if ! exists $self->{overrideHangul};
    $self->{overrideCJK} = FALSE
	if ! exists $self->{overrideCJK};
    $self->{normalization} = 'NFD'
	if ! exists $self->{normalization};
    $self->{rearrange} = $self->{rearrangeTable} ||
	($self->{UCA_Version} <= 11 ? $DefaultRearrange : [])
	if ! exists $self->{rearrange};
    $self->{backwards} = $self->{backwardsTable}
	if ! exists $self->{backwards};
    exists $self->{long_contraction} or $self->{long_contraction}
	= 22 <= $self->{UCA_Version} && $self->{UCA_Version} <= 24;

    # checkCollator() will be called in change()
    $self->checkCollator();

    return $self;
}

sub parseAtmark {
    my $self = shift;
    my $line = shift; # after s/^\s*\@//

    if ($line =~ /^version\s*(\S*)/) {
	$self->{versionTable} ||= $1;
    }
    elsif ($line =~ /^variable\s+(\S*)/) { # since UTS #10-9
	$self->{variableTable} ||= $1;
    }
    elsif ($line =~ /^alternate\s+(\S*)/) { # till UTS #10-8
	$self->{alternateTable} ||= $1;
    }
    elsif ($line =~ /^backwards\s+(\S*)/) {
	push @{ $self->{backwardsTable} }, $1;
    }
    elsif ($line =~ /^forwards\s+(\S*)/) { # perhaps no use
	push @{ $self->{forwardsTable} }, $1;
    }
    elsif ($line =~ /^rearrange\s+(.*)/) { # (\S*) is NG
	push @{ $self->{rearrangeTable} }, _getHexArray($1);
    }
}

sub read_table {
    my $self = shift;

### begin XS only ###
    if ($self->{__useXS}) {
	my @rest = _fetch_rest(); # complex matter need to parse
	for my $line (@rest) {
	    next if $line =~ /^\s*#/;

	    if ($line =~ s/^\s*\@//) {
		$self->parseAtmark($line);
	    } else {
		$self->parseEntry($line);
	    }
	}
	return;
    }
### end XS only ###

    my($f, $fh);
    foreach my $d (@INC) {
	$f = File::Spec->catfile($d, @Path, $self->{table});
	last if open($fh, $f);
	$f = undef;
    }
    if (!defined $f) {
	$f = File::Spec->catfile(@Path, $self->{table});
	croak("$PACKAGE: Can't locate $f in \@INC (\@INC contains: @INC)");
    }

    while (my $line = <$fh>) {
	next if $line =~ /^\s*#/;

	if ($line =~ s/^\s*\@//) {
	    $self->parseAtmark($line);
	} else {
	    $self->parseEntry($line);
	}
    }
    close $fh;
}


##
## get $line, parse it, and write an entry in $self
##
sub parseEntry
{
    my $self = shift;
    my $line = shift;
    my $tailoring = shift;
    my($name, $entry, @uv, @key);

    if (defined $self->{rewrite}) {
	$line = $self->{rewrite}->($line);
    }

    return if $line !~ /^\s*[0-9A-Fa-f]/;

    # removes comment and gets name
    $name = $1
	if $line =~ s/[#%]\s*(.*)//;
    return if defined $self->{undefName} && $name =~ /$self->{undefName}/;

    # gets element
    my($e, $k) = split /;/, $line;
    croak "Wrong Entry: <charList> must be separated by ';' from <collElement>"
	if ! $k;

    @uv = _getHexArray($e);
    return if !@uv;
    return if @uv > 1 && $self->{suppressHash} && !$tailoring &&
		  exists $self->{suppressHash}{$uv[0]};
    $entry = join(CODE_SEP, @uv); # in JCPS

    if (defined $self->{undefChar} || defined $self->{ignoreChar}) {
	my $ele = pack_U(@uv);

	# regarded as if it were not stored in the table
	return
	    if defined $self->{undefChar} && $ele =~ /$self->{undefChar}/;

	# replaced as completely ignorable
	$k = '[.0000.0000.0000.0000]'
	    if defined $self->{ignoreChar} && $ele =~ /$self->{ignoreChar}/;
    }

    # replaced as completely ignorable
    $k = '[.0000.0000.0000.0000]'
	if defined $self->{ignoreName} && $name =~ /$self->{ignoreName}/;

    my $is_L3_ignorable = TRUE;

    foreach my $arr ($k =~ /\[([^\[\]]+)\]/g) { # SPACEs allowed
	my $var = $arr =~ /\*/; # exactly /^\*/ but be lenient.
	my @wt = _getHexArray($arr);
	push @key, pack(VCE_TEMPLATE, $var, @wt);
	$is_L3_ignorable = FALSE
	    if $wt[0] || $wt[1] || $wt[2];
	# Conformance Test for 3.1.1 and 4.0.0 shows Level 3 ignorable
	# is completely ignorable.
	# For expansion, an entry $is_L3_ignorable
	# if and only if "all" CEs are [.0000.0000.0000].
    }

    $self->{mapping}{$entry} = $is_L3_ignorable ? [] : \@key;

    if (@uv > 1) {
	if (!$self->{maxlength}{$uv[0]} || $self->{maxlength}{$uv[0]} < @uv) {
	    $self->{maxlength}{$uv[0]} = @uv;
	}
    }
    while (@uv > 2) {
	pop @uv;
	my $fake_entry = join(CODE_SEP, @uv); # in JCPS
	$self->{contraction}{$fake_entry} = 1;
    }
}


sub viewSortKey
{
    my $self = shift;
    my $str  = shift;
    $self->visualizeSortKey($self->getSortKey($str));
}


sub process
{
    my $self = shift;
    my $str  = shift;
    my $prep = $self->{preprocess};
    my $norm = $self->{normCode};

    $str = &$prep($str) if ref $prep;
    $str = &$norm($str) if ref $norm;
    return $str;
}

##
## arrayref of JCPS   = splitEnt(string to be collated)
## arrayref of arrayref[JCPS, ini_pos, fin_pos] = splitEnt(string, TRUE)
##
sub splitEnt
{
    my $self = shift;
    my $str  = shift;
    my $wLen = shift; # with Length

    my $map  = $self->{mapping};
    my $max  = $self->{maxlength};
    my $reH  = $self->{rearrangeHash};
    my $vers = $self->{UCA_Version};
    my $ver9 = $vers >= 9 && $vers <= 11;
    my $long = $self->{long_contraction};
    my $uXS  = $self->{__useXS}; ### XS only

    my @buf;

    # get array of Unicode code point of string.
    my @src = unpack_U($str);

    # rearrangement:
    # Character positions are not kept if rearranged,
    # then neglected if $wLen is true.
    if ($reH && ! $wLen) {
	for (my $i = 0; $i < @src; $i++) {
	    if (exists $reH->{ $src[$i] } && $i + 1 < @src) {
		($src[$i], $src[$i+1]) = ($src[$i+1], $src[$i]);
		$i++;
	    }
	}
    }

    # remove a code point marked as a completely ignorable.
    for (my $i = 0; $i < @src; $i++) {
	if ($vers <= 20 && _isIllegal($src[$i])) {
	    $src[$i] = undef;
	} elsif ($ver9) {
	    $src[$i] = undef if $map->{ $src[$i] }
			   ? @{ $map->{ $src[$i] } } == 0
			   : $uXS && _ignorable_simple($src[$i]); ### XS only
	}
    }

    for (my $i = 0; $i < @src; $i++) {
	my $jcps = $src[$i];

	# skip removed code point
	if (! defined $jcps) {
	    if ($wLen && @buf) {
		$buf[-1][2] = $i + 1;
	    }
	    next;
	}

	my $i_orig = $i;

	# find contraction
	if ($max->{$jcps}) {
	    my $temp_jcps = $jcps;
	    my $jcpsLen = 1;
	    my $maxLen = $max->{$jcps};

	    for (my $p = $i + 1; $jcpsLen < $maxLen && $p < @src; $p++) {
		next if ! defined $src[$p];
		$temp_jcps .= CODE_SEP . $src[$p];
		$jcpsLen++;
		if ($map->{$temp_jcps}) {
		    $jcps = $temp_jcps;
		    $i = $p;
		}
	    }

	# discontiguous contraction with Combining Char (cf. UTS#10, S2.1).
	# This process requires Unicode::Normalize.
	# If "normalization" is undef, here should be skipped *always*
	# (in spite of bool value of $CVgetCombinClass),
	# since canonical ordering cannot be expected.
	# Blocked combining character should not be contracted.

	    # $self->{normCode} is false in the case of "prenormalized".
	    if ($self->{normalization}) {
		my $cont = $self->{contraction};
		my $preCC = 0;
		my $preCC_uc = 0;
		my $jcps_uc = $jcps;
		my(@out, @out_uc);

		for (my $p = $i + 1; $p < @src; $p++) {
		    next if ! defined $src[$p];
		    my $curCC = $CVgetCombinClass->($src[$p]);
		    last unless $curCC;
		    my $tail = CODE_SEP . $src[$p];

		    if ($preCC != $curCC && $map->{$jcps.$tail}) {
			$jcps .= $tail;
			push @out, $p;
		    } else {
			$preCC = $curCC;
		    }

		    next if !$long;

		    if ($preCC_uc != $curCC && ($map->{$jcps_uc.$tail} ||
					       $cont->{$jcps_uc.$tail})) {
			$jcps_uc .= $tail;
			push @out_uc, $p;
		    } else {
			$preCC_uc = $curCC;
		    }
		}

		if (@out_uc && $map->{$jcps_uc}) {
		    $jcps = $jcps_uc;
		    $src[$_] = undef for @out_uc;
		} else {
		    $src[$_] = undef for @out;
		}
	    }
	}

	# skip completely ignorable
	if ($map->{$jcps} ? @{ $map->{$jcps} } == 0 :
	    $uXS && $jcps !~ /;/ && _ignorable_simple($jcps)) { ### XS only
	    if ($wLen && @buf) {
		$buf[-1][2] = $i + 1;
	    }
	    next;
	}

	push @buf, $wLen ? [$jcps, $i_orig, $i + 1] : $jcps;
    }
    return \@buf;
}

##
## VCE = _pack_override(input, codepoint, derivCode)
##
sub _pack_override ($$$) {
    my $r = shift;
    my $u = shift;
    my $der = shift;

    if (ref $r) {
	return pack(VCE_TEMPLATE, NON_VAR, @$r);
    } elsif (defined $r) {
	return pack(VCE_TEMPLATE, NON_VAR, $r, Min2Wt, Min3Wt, $u);
    } else {
	$u = 0xFFFD if 0x10FFFF < $u;
	return $der->($u);
    }
}

##
## list of VCE = getWt(JCPS)
##
sub getWt
{
    my $self = shift;
    my $u    = shift;
    my $map  = $self->{mapping};
    my $der  = $self->{derivCode};
    my $out  = $self->{overrideOut};
    my $uXS  = $self->{__useXS}; ### XS only

    return if !defined $u;
    return $self->varCE($HighestVCE) if $u eq 0xFFFF && $self->{highestFFFF};
    return $self->varCE($minimalVCE) if $u eq 0xFFFE && $self->{minimalFFFE};
    $u = 0xFFFD if $u !~ /;/ && 0x10FFFF < $u && !$out;

    my @ce;
    if ($map->{$u}) {
	@ce = @{ $map->{$u} }; # $u may be a contraction
### begin XS only ###
    } elsif ($uXS && _exists_simple($u)) {
	@ce = _fetch_simple($u);
### end XS only ###
    } elsif (Hangul_SIni <= $u && $u <= Hangul_SFin) {
	my $hang = $self->{overrideHangul};
	if ($hang) {
	    @ce = map _pack_override($_, $u, $der), $hang->($u);
	} elsif (!defined $hang) {
	    @ce = $der->($u);
	} else {
	    my $max  = $self->{maxlength};
	    my @decH = _decompHangul($u);

	    if (@decH == 2) {
		my $contract = join(CODE_SEP, @decH);
		@decH = ($contract) if $map->{$contract};
	    } else { # must be <@decH == 3>
		if ($max->{$decH[0]}) {
		    my $contract = join(CODE_SEP, @decH);
		    if ($map->{$contract}) {
			@decH = ($contract);
		    } else {
			$contract = join(CODE_SEP, @decH[0,1]);
			$map->{$contract} and @decH = ($contract, $decH[2]);
		    }
		    # even if V's ignorable, LT contraction is not supported.
		    # If such a situation were required, NFD should be used.
		}
		if (@decH == 3 && $max->{$decH[1]}) {
		    my $contract = join(CODE_SEP, @decH[1,2]);
		    $map->{$contract} and @decH = ($decH[0], $contract);
		}
	    }

	    @ce = map({
		    $map->{$_} ? @{ $map->{$_} } :
		$uXS && _exists_simple($_) ? _fetch_simple($_) : ### XS only
		    $der->($_);
		} @decH);
	}
    } elsif ($out && 0x10FFFF < $u) {
	@ce = map _pack_override($_, $u, $der), $out->($u);
    } else {
	my $cjk  = $self->{overrideCJK};
	my $vers = $self->{UCA_Version};
	if ($cjk && _isUIdeo($u, $vers)) {
	    @ce = map _pack_override($_, $u, $der), $cjk->($u);
	} elsif ($vers == 8 && defined $cjk && _isUIdeo($u, 0)) {
	    @ce = _uideoCE_8($u);
	} else {
	    @ce = $der->($u);
	}
    }
    return map $self->varCE($_), @ce;
}


##
## string sortkey = getSortKey(string arg)
##
sub getSortKey
{
    my $self = shift;
    my $orig = shift;
    my $str  = $self->process($orig);
    my $rEnt = $self->splitEnt($str); # get an arrayref of JCPS
    my $vers = $self->{UCA_Version};
    my $term = $self->{hangul_terminator};
    my $lev  = $self->{level};
    my $iden = $self->{identical};

    my @buf; # weight arrays
    if ($term) {
	my $preHST = '';
	my $termCE = $self->varCE(pack(VCE_TEMPLATE, NON_VAR, $term, 0,0,0));
	foreach my $jcps (@$rEnt) {
	    # weird things like VL, TL-contraction are not considered!
	    my $curHST = join '', map getHST($_, $vers), split /;/, $jcps;
	    if ($preHST && !$curHST || # hangul before non-hangul
		$preHST =~ /L\z/ && $curHST =~ /^T/ ||
		$preHST =~ /V\z/ && $curHST =~ /^L/ ||
		$preHST =~ /T\z/ && $curHST =~ /^[LV]/) {
		push @buf, $termCE;
	    }
	    $preHST = $curHST;
	    push @buf, $self->getWt($jcps);
	}
	push @buf, $termCE if $preHST; # end at hangul
    } else {
	foreach my $jcps (@$rEnt) {
	    push @buf, $self->getWt($jcps);
	}
    }

    my $rkey = $self->mk_SortKey(\@buf); ### XS only

    if ($iden || $vers >= 26 && $lev == MaxLevel) {
	$rkey .= LEVEL_SEP;
	$rkey .= pack(TIE_TEMPLATE, unpack_U($str)) if $iden;
    }
    return $rkey;
}


##
## int compare = cmp(string a, string b)
##
sub cmp { $_[0]->getSortKey($_[1]) cmp $_[0]->getSortKey($_[2]) }
sub eq  { $_[0]->getSortKey($_[1]) eq  $_[0]->getSortKey($_[2]) }
sub ne  { $_[0]->getSortKey($_[1]) ne  $_[0]->getSortKey($_[2]) }
sub lt  { $_[0]->getSortKey($_[1]) lt  $_[0]->getSortKey($_[2]) }
sub le  { $_[0]->getSortKey($_[1]) le  $_[0]->getSortKey($_[2]) }
sub gt  { $_[0]->getSortKey($_[1]) gt  $_[0]->getSortKey($_[2]) }
sub ge  { $_[0]->getSortKey($_[1]) ge  $_[0]->getSortKey($_[2]) }

##
## list[strings] sorted = sort(list[strings] arg)
##
sub sort {
    my $obj = shift;
    return
	map { $_->[1] }
	    sort{ $a->[0] cmp $b->[0] }
		map [ $obj->getSortKey($_), $_ ], @_;
}


##
## bool _nonIgnorAtLevel(arrayref weights, int level)
##
sub _nonIgnorAtLevel($$)
{
    my $wt = shift;
    return if ! defined $wt;
    my $lv = shift;
    return grep($wt->[$_-1] != 0, MinLevel..$lv) ? TRUE : FALSE;
}

##
## bool _eqArray(
##    arrayref of arrayref[weights] source,
##    arrayref of arrayref[weights] substr,
##    int level)
## * comparison of graphemes vs graphemes.
##   @$source >= @$substr must be true (check it before call this);
##
sub _eqArray($$$)
{
    my $source = shift;
    my $substr = shift;
    my $lev = shift;

    for my $g (0..@$substr-1){
	# Do the $g'th graphemes have the same number of AV weights?
	return if @{ $source->[$g] } != @{ $substr->[$g] };

	for my $w (0..@{ $substr->[$g] }-1) {
	    for my $v (0..$lev-1) {
		return if $source->[$g][$w][$v] != $substr->[$g][$w][$v];
	    }
	}
    }
    return 1;
}

##
## (int position, int length)
## int position = index(string, substring, position, [undoc'ed global])
##
## With "global" (only for the list context),
##  returns list of arrayref[position, length].
##
sub index
{
    my $self = shift;
    $self->{preprocess} and
	croak "Don't use Preprocess with index(), match(), etc.";
    $self->{normCode} and
	croak "Don't use Normalization with index(), match(), etc.";

    my $str  = shift;
    my $len  = length($str);
    my $sub  = shift;
    my $subE = $self->splitEnt($sub);
    my $pos  = @_ ? shift : 0;
       $pos  = 0 if $pos < 0;
    my $glob = shift;

    my $lev  = $self->{level};
    my $v2i  = $self->{UCA_Version} >= 9 &&
		$self->{variable} ne 'non-ignorable';

    if (! @$subE) {
	my $temp = $pos <= 0 ? 0 : $len <= $pos ? $len : $pos;
	return $glob
	    ? map([$_, 0], $temp..$len)
	    : wantarray ? ($temp,0) : $temp;
    }
    $len < $pos
	and return wantarray ? () : NOMATCHPOS;
    my $strE = $self->splitEnt($pos ? substr($str, $pos) : $str, TRUE);
    @$strE
	or return wantarray ? () : NOMATCHPOS;

    my(@strWt, @iniPos, @finPos, @subWt, @g_ret);

    my $last_is_variable;
    for my $vwt (map $self->getWt($_), @$subE) {
	my($var, @wt) = unpack(VCE_TEMPLATE, $vwt);
	my $to_be_pushed = _nonIgnorAtLevel(\@wt,$lev);

	# "Ignorable (L1, L2) after Variable" since track. v. 9
	if ($v2i) {
	    if ($var) {
		$last_is_variable = TRUE;
	    }
	    elsif (!$wt[0]) { # ignorable
		$to_be_pushed = FALSE if $last_is_variable;
	    }
	    else {
		$last_is_variable = FALSE;
	    }
	}

	if (@subWt && !$var && !$wt[0]) {
	    push @{ $subWt[-1] }, \@wt if $to_be_pushed;
	} elsif ($to_be_pushed) {
	    push @subWt, [ \@wt ];
	}
	# else ===> skipped
    }

    my $count = 0;
    my $end = @$strE - 1;

    $last_is_variable = FALSE; # reuse
    for (my $i = 0; $i <= $end; ) { # no $i++
	my $found_base = 0;

	# fetch a grapheme
	while ($i <= $end && $found_base == 0) {
	    for my $vwt ($self->getWt($strE->[$i][0])) {
		my($var, @wt) = unpack(VCE_TEMPLATE, $vwt);
		my $to_be_pushed = _nonIgnorAtLevel(\@wt,$lev);

		# "Ignorable (L1, L2) after Variable" since track. v. 9
		if ($v2i) {
		    if ($var) {
			$last_is_variable = TRUE;
		    }
		    elsif (!$wt[0]) { # ignorable
			$to_be_pushed = FALSE if $last_is_variable;
		    }
		    else {
			$last_is_variable = FALSE;
		    }
		}

		if (@strWt && !$var && !$wt[0]) {
		    push @{ $strWt[-1] }, \@wt if $to_be_pushed;
		    $finPos[-1] = $strE->[$i][2];
		} elsif ($to_be_pushed) {
		    push @strWt, [ \@wt ];
		    push @iniPos, $found_base ? NOMATCHPOS : $strE->[$i][1];
		    $finPos[-1] = NOMATCHPOS if $found_base;
		    push @finPos, $strE->[$i][2];
		    $found_base++;
		}
		# else ===> no-op
	    }
	    $i++;
	}

	# try to match
	while ( @strWt > @subWt || (@strWt == @subWt && $i > $end) ) {
	    if ($iniPos[0] != NOMATCHPOS &&
		    $finPos[$#subWt] != NOMATCHPOS &&
			_eqArray(\@strWt, \@subWt, $lev)) {
		my $temp = $iniPos[0] + $pos;

		if ($glob) {
		    push @g_ret, [$temp, $finPos[$#subWt] - $iniPos[0]];
		    splice @strWt,  0, $#subWt;
		    splice @iniPos, 0, $#subWt;
		    splice @finPos, 0, $#subWt;
		}
		else {
		    return wantarray
			? ($temp, $finPos[$#subWt] - $iniPos[0])
			:  $temp;
		}
	    }
	    shift @strWt;
	    shift @iniPos;
	    shift @finPos;
	}
    }

    return $glob
	? @g_ret
	: wantarray ? () : NOMATCHPOS;
}

##
## scalarref to matching part = match(string, substring)
##
sub match
{
    my $self = shift;
    if (my($pos,$len) = $self->index($_[0], $_[1])) {
	my $temp = substr($_[0], $pos, $len);
	return wantarray ? $temp : \$temp;
	# An lvalue ref \substr should be avoided,
	# since its value is affected by modification of its referent.
    }
    else {
	return;
    }
}

##
## arrayref matching parts = gmatch(string, substring)
##
sub gmatch
{
    my $self = shift;
    my $str  = shift;
    my $sub  = shift;
    return map substr($str, $_->[0], $_->[1]),
		$self->index($str, $sub, 0, 'g');
}

##
## bool subst'ed = subst(string, substring, replace)
##
sub subst
{
    my $self = shift;
    my $code = ref $_[2] eq 'CODE' ? $_[2] : FALSE;

    if (my($pos,$len) = $self->index($_[0], $_[1])) {
	if ($code) {
	    my $mat = substr($_[0], $pos, $len);
	    substr($_[0], $pos, $len, $code->($mat));
	} else {
	    substr($_[0], $pos, $len, $_[2]);
	}
	return TRUE;
    }
    else {
	return FALSE;
    }
}

##
## int count = gsubst(string, substring, replace)
##
sub gsubst
{
    my $self = shift;
    my $code = ref $_[2] eq 'CODE' ? $_[2] : FALSE;
    my $cnt = 0;

    # Replacement is carried out from the end, then use reverse.
    for my $pos_len (reverse $self->index($_[0], $_[1], 0, 'g')) {
	if ($code) {
	    my $mat = substr($_[0], $pos_len->[0], $pos_len->[1]);
	    substr($_[0], $pos_len->[0], $pos_len->[1], $code->($mat));
	} else {
	    substr($_[0], $pos_len->[0], $pos_len->[1], $_[2]);
	}
	$cnt++;
    }
    return $cnt;
}

1;
__END__

=head1 NAME

Unicode::Collate - Unicode Collation Algorithm

=head1 SYNOPSIS

  use Unicode::Collate;

  #construct
  $Collator = Unicode::Collate->new(%tailoring);

  #sort
  @sorted = $Collator->sort(@not_sorted);

  #compare
  $result = $Collator->cmp($a, $b); # returns 1, 0, or -1.

B<Note:> Strings in C<@not_sorted>, C<$a> and C<$b> are interpreted
according to Perl's Unicode support. See L<perlunicode>,
L<perluniintro>, L<perlunitut>, L<perlunifaq>, L<utf8>.
Otherwise you can use C<preprocess> or should decode them before.

=head1 DESCRIPTION

This module is an implementation of Unicode Technical Standard #10
(a.k.a. UTS #10) - Unicode Collation Algorithm (a.k.a. UCA).

=head2 Constructor and Tailoring

The C<new> method returns a collator object. If new() is called
with no parameters, the collator should do the default collation.

   $Collator = Unicode::Collate->new(
      UCA_Version => $UCA_Version,
      alternate => $alternate, # alias for 'variable'
      backwards => $levelNumber, # or \@levelNumbers
      entry => $element,
      hangul_terminator => $term_primary_weight,
      highestFFFF => $bool,
      identical => $bool,
      ignoreName => qr/$ignoreName/,
      ignoreChar => qr/$ignoreChar/,
      ignore_level2 => $bool,
      katakana_before_hiragana => $bool,
      level => $collationLevel,
      long_contraction => $bool,
      minimalFFFE => $bool,
      normalization  => $normalization_form,
      overrideCJK => \&overrideCJK,
      overrideHangul => \&overrideHangul,
      preprocess => \&preprocess,
      rearrange => \@charList,
      rewrite => \&rewrite,
      suppress => \@charList,
      table => $filename,
      undefName => qr/$undefName/,
      undefChar => qr/$undefChar/,
      upper_before_lower => $bool,
      variable => $variable,
   );

=over 4

=item UCA_Version

If the revision (previously "tracking version") number of UCA is given,
behavior of that revision is emulated on collating.
If omitted, the return value of C<UCA_Version()> is used.

The following revisions are supported.  The default is 30.

     UCA       Unicode Standard         DUCET (@version)
   -------------------------------------------------------
      8              3.1                3.0.1 (3.0.1d9)
      9     3.1 with Corrigendum 3      3.1.1 (3.1.1)
     11              4.0                4.0.0 (4.0.0)
     14             4.1.0               4.1.0 (4.1.0)
     16              5.0                5.0.0 (5.0.0)
     18             5.1.0               5.1.0 (5.1.0)
     20             5.2.0               5.2.0 (5.2.0)
     22             6.0.0               6.0.0 (6.0.0)
     24             6.1.0               6.1.0 (6.1.0)
     26             6.2.0               6.2.0 (6.2.0)
     28             6.3.0               6.3.0 (6.3.0)
     30             7.0.0               7.0.0 (7.0.0)

* See below C<long_contraction> with C<UCA_Version> 22 and 24.

* Noncharacters (e.g. U+FFFF) are not ignored, and can be overridden
since C<UCA_Version> 22.

* Out-of-range codepoints (greater than U+10FFFF) are not ignored,
and can be overridden since C<UCA_Version> 22.

* Fully ignorable characters were ignored, and would not interrupt
contractions with C<UCA_Version> 9 and 11.

* Treatment of ignorables after variables and some behaviors
were changed at C<UCA_Version> 9.

* Characters regarded as CJK unified ideographs (cf. C<overrideCJK>)
depend on C<UCA_Version>.

* Many hangul jamo are assigned at C<UCA_Version> 20, that will affect
C<hangul_terminator>.

=item alternate

-- see 3.2.2 Alternate Weighting, version 8 of UTS #10

For backward compatibility, C<alternate> (old name) can be used
as an alias for C<variable>.

=item backwards

-- see 3.4 Backward Accents, UTS #10.

     backwards => $levelNumber or \@levelNumbers

Weights in reverse order; ex. level 2 (diacritic ordering) in French.
If omitted (or C<$levelNumber> is C<undef> or C<\@levelNumbers> is C<[]>),
forwards at all the levels.

=item entry

-- see 5 Tailoring; 9.1 Allkeys File Format, UTS #10.

If the same character (or a sequence of characters) exists
in the collation element table through C<table>,
mapping to collation elements is overridden.
If it does not exist, the mapping is defined additionally.

    entry => <<'ENTRY', # for DUCET v4.0.0 (allkeys-4.0.0.txt)
0063 0068 ; [.0E6A.0020.0002.0063] # ch
0043 0068 ; [.0E6A.0020.0007.0043] # Ch
0043 0048 ; [.0E6A.0020.0008.0043] # CH
006C 006C ; [.0F4C.0020.0002.006C] # ll
004C 006C ; [.0F4C.0020.0007.004C] # Ll
004C 004C ; [.0F4C.0020.0008.004C] # LL
00F1      ; [.0F7B.0020.0002.00F1] # n-tilde
006E 0303 ; [.0F7B.0020.0002.00F1] # n-tilde
00D1      ; [.0F7B.0020.0008.00D1] # N-tilde
004E 0303 ; [.0F7B.0020.0008.00D1] # N-tilde
ENTRY

    entry => <<'ENTRY', # for DUCET v4.0.0 (allkeys-4.0.0.txt)
00E6 ; [.0E33.0020.0002.00E6][.0E8B.0020.0002.00E6] # ae ligature as <a><e>
00C6 ; [.0E33.0020.0008.00C6][.0E8B.0020.0008.00C6] # AE ligature as <A><E>
ENTRY

B<NOTE:> The code point in the UCA file format (before C<';'>)
B<must> be a Unicode code point (defined as hexadecimal),
but not a native code point.
So C<0063> must always denote C<U+0063>,
but not a character of C<"\x63">.

Weighting may vary depending on collation element table.
So ensure the weights defined in C<entry> will be consistent with
those in the collation element table loaded via C<table>.

In DUCET v4.0.0, primary weight of C<C> is C<0E60>
and that of C<D> is C<0E6D>. So setting primary weight of C<CH> to C<0E6A>
(as a value between C<0E60> and C<0E6D>)
makes ordering as C<C E<lt> CH E<lt> D>.
Exactly speaking DUCET already has some characters between C<C> and C<D>:
C<small capital C> (C<U+1D04>) with primary weight C<0E64>,
C<c-hook/C-hook> (C<U+0188/U+0187>) with C<0E65>,
and C<c-curl> (C<U+0255>) with C<0E69>.
Then primary weight C<0E6A> for C<CH> makes C<CH>
ordered between C<c-curl> and C<D>.

=item hangul_terminator

-- see 7.1.4 Trailing Weights, UTS #10.

If a true value is given (non-zero but should be positive),
it will be added as a terminator primary weight to the end of
every standard Hangul syllable. Secondary and any higher weights
for terminator are set to zero.
If the value is false or C<hangul_terminator> key does not exist,
insertion of terminator weights will not be performed.

Boundaries of Hangul syllables are determined
according to conjoining Jamo behavior in F<the Unicode Standard>
and F<HangulSyllableType.txt>.

B<Implementation Note:>
(1) For expansion mapping (Unicode character mapped
to a sequence of collation elements), a terminator will not be added
between collation elements, even if Hangul syllable boundary exists there.
Addition of terminator is restricted to the next position
to the last collation element.

(2) Non-conjoining Hangul letters
(Compatibility Jamo, halfwidth Jamo, and enclosed letters) are not
automatically terminated with a terminator primary weight.
These characters may need terminator included in a collation element
table beforehand.

=item highestFFFF

-- see 5.14 Collation Elements, UTS #35.

If the parameter is made true, C<U+FFFF> has a highest primary weight.
When a boolean of C<$coll-E<gt>ge($str, "abc")> and
C<$coll-E<gt>le($str, "abc\x{FFFF}")> is true, it is expected that C<$str>
begins with C<"abc">, or another primary equivalent.
C<$str> may be C<"abcd">, C<"abc012">, but should not include C<U+FFFF>
such as C<"abc\x{FFFF}xyz">.

C<$coll-E<gt>le($str, "abc\x{FFFF}")> works like C<$coll-E<gt>lt($str, "abd")>
almost, but the latter has a problem that you should know which letter is
next to C<c>. For a certain language where C<ch> as the next letter,
C<"abch"> is greater than C<"abc\x{FFFF}">, but less than C<"abd">.

Note:
This is equivalent to C<(entry =E<gt> 'FFFF ; [.FFFE.0020.0005.FFFF]')>.
Any other character than C<U+FFFF> can be tailored by C<entry>.

=item identical

-- see A.3 Deterministic Comparison, UTS #10.

By default, strings whose weights are equal should be equal,
even though their code points are not equal.
Completely ignorable characters are ignored.

If the parameter is made true, a final, tie-breaking level is used.
If no difference of weights is found after the comparison through
all the level specified by C<level>, the comparison with code points
will be performed.
For the tie-breaking comparison, the sort key has code points
of the original string appended.
Completely ignorable characters are not ignored.

If C<preprocess> and/or C<normalization> is applied, the code points
of the string after them (in NFD by default) are used.

=item ignoreChar

=item ignoreName

-- see 3.6 Variable Weighting, UTS #10.

Makes the entry in the table completely ignorable;
i.e. as if the weights were zero at all level.

Through C<ignoreChar>, any character matching C<qr/$ignoreChar/>
will be ignored. Through C<ignoreName>, any character whose name
(given in the C<table> file as a comment) matches C<qr/$ignoreName/>
will be ignored.

E.g. when 'a' and 'e' are ignorable,
'element' is equal to 'lament' (or 'lmnt').

=item ignore_level2

-- see 5.1 Parametric Tailoring, UTS #10.

By default, case-sensitive comparison (that is level 3 difference)
won't ignore accents (that is level 2 difference).

If the parameter is made true, accents (and other primary ignorable
characters) are ignored, even though cases are taken into account.

B<NOTE>: C<level> should be 3 or greater.

=item katakana_before_hiragana

-- see 7.2 Tertiary Weight Table, UTS #10.

By default, hiragana is before katakana.
If the parameter is made true, this is reversed.

B<NOTE>: This parameter simplemindedly assumes that any hiragana/katakana
distinctions must occur in level 3, and their weights at level 3 must be
same as those mentioned in 7.3.1, UTS #10.
If you define your collation elements which violate this requirement,
this parameter does not work validly.

=item level

-- see 4.3 Form Sort Key, UTS #10.

Set the maximum level.
Any higher levels than the specified one are ignored.

  Level 1: alphabetic ordering
  Level 2: diacritic ordering
  Level 3: case ordering
  Level 4: tie-breaking (e.g. in the case when variable is 'shifted')

  ex.level => 2,

If omitted, the maximum is the 4th.

B<NOTE:> The DUCET includes weights over 0xFFFF at the 4th level.
But this module only uses weights within 0xFFFF.
When C<variable> is 'blanked' or 'non-ignorable' (other than 'shifted'
and 'shift-trimmed'), the level 4 may be unreliable.

See also C<identical>.

=item long_contraction

-- see 3.8.2 Well-Formedness of the DUCET, 4.2 Produce Array, UTS #10.

If the parameter is made true, for a contraction with three or more
characters (here nicknamed "long contraction"), initial substrings
will be handled.
For example, a contraction ABC, where A is a starter, and B and C
are non-starters (character with non-zero combining character class),
will be detected even if there is not AB as a contraction.

B<Default:> Usually false.
If C<UCA_Version> is 22 or 24, and the value of C<long_contraction>
is not specified in C<new()>, a true value is set implicitly.
This is a workaround to pass Conformance Tests for Unicode 6.0.0 and 6.1.0.

C<change()> handles C<long_contraction> explicitly only.
If C<long_contraction> is not specified in C<change()>, even though
C<UCA_Version> is changed, C<long_contraction> will not be changed.

B<Limitation:> Scanning non-starters is one-way (no back tracking).
If AB is found but not ABC is not found, other long contraction where
the first character is A and the second is not B may not be found.

Under C<(normalization =E<gt> undef)>, detection step of discontiguous
contractions will be skipped.

B<Note:> The following contractions in DUCET are not considered
in steps S2.1.1 to S2.1.3, where they are discontiguous.

    0FB2 0F71 0F80 (TIBETAN VOWEL SIGN VOCALIC RR)
    0FB3 0F71 0F80 (TIBETAN VOWEL SIGN VOCALIC LL)

For example C<TIBETAN VOWEL SIGN VOCALIC RR> with C<COMBINING TILDE OVERLAY>
(C<U+0344>) is C<0FB2 0344 0F71 0F80> in NFD.
In this case C<0FB2 0F80> (C<TIBETAN VOWEL SIGN VOCALIC R>) is detected,
instead of C<0FB2 0F71 0F80>.
Inserted C<0344> makes C<0FB2 0F71 0F80> discontiguous and lack of
contraction C<0FB2 0F71> prohibits C<0FB2 0F71 0F80> from being detected.

=item minimalFFFE

-- see 5.14 Collation Elements, UTS #35.

If the parameter is made true, C<U+FFFE> has a minimal primary weight.
The comparison between C<"$a1\x{FFFE}$a2"> and C<"$b1\x{FFFE}$b2">
first compares C<$a1> and C<$b1> at level 1, and
then C<$a2> and C<$b2> at level 1, as followed.

        "ab\x{FFFE}a"
        "Ab\x{FFFE}a"
        "ab\x{FFFE}c"
        "Ab\x{FFFE}c"
        "ab\x{FFFE}xyz"
        "abc\x{FFFE}def"
        "abc\x{FFFE}xYz"
        "aBc\x{FFFE}xyz"
        "abcX\x{FFFE}def"
        "abcx\x{FFFE}xyz"
        "b\x{FFFE}aaa"
        "bbb\x{FFFE}a"

Note:
This is equivalent to C<(entry =E<gt> 'FFFE ; [.0001.0020.0005.FFFE]')>.
Any other character than C<U+FFFE> can be tailored by C<entry>.

=item normalization

-- see 4.1 Normalize, UTS #10.

If specified, strings are normalized before preparation of sort keys
(the normalization is executed after preprocess).

A form name C<Unicode::Normalize::normalize()> accepts will be applied
as C<$normalization_form>.
Acceptable names include C<'NFD'>, C<'NFC'>, C<'NFKD'>, and C<'NFKC'>.
See C<Unicode::Normalize::normalize()> for detail.
If omitted, C<'NFD'> is used.

C<normalization> is performed after C<preprocess> (if defined).

Furthermore, special values, C<undef> and C<"prenormalized">, can be used,
though they are not concerned with C<Unicode::Normalize::normalize()>.

If C<undef> (not a string C<"undef">) is passed explicitly
as the value for this key,
any normalization is not carried out (this may make tailoring easier
if any normalization is not desired). Under C<(normalization =E<gt> undef)>,
only contiguous contractions are resolved;
e.g. even if C<A-ring> (and C<A-ring-cedilla>) is ordered after C<Z>,
C<A-cedilla-ring> would be primary equal to C<A>.
In this point,
C<(normalization =E<gt> undef, preprocess =E<gt> sub { NFD(shift) })>
B<is not> equivalent to C<(normalization =E<gt> 'NFD')>.

In the case of C<(normalization =E<gt> "prenormalized")>,
any normalization is not performed, but
discontiguous contractions with combining characters are performed.
Therefore
C<(normalization =E<gt> 'prenormalized', preprocess =E<gt> sub { NFD(shift) })>
B<is> equivalent to C<(normalization =E<gt> 'NFD')>.
If source strings are finely prenormalized,
C<(normalization =E<gt> 'prenormalized')> may save time for normalization.

Except C<(normalization =E<gt> undef)>,
B<Unicode::Normalize> is required (see also B<CAVEAT>).

=item overrideCJK

-- see 7.1 Derived Collation Elements, UTS #10.

By default, CJK unified ideographs are ordered in Unicode codepoint
order, but those in the CJK Unified Ideographs block are less than
those in the CJK Unified Ideographs Extension A etc.

    In the CJK Unified Ideographs block:
    U+4E00..U+9FA5 if UCA_Version is 8, 9 or 11.
    U+4E00..U+9FBB if UCA_Version is 14 or 16.
    U+4E00..U+9FC3 if UCA_Version is 18.
    U+4E00..U+9FCB if UCA_Version is 20 or 22.
    U+4E00..U+9FCC if UCA_Version is 24 or later.

    In the CJK Unified Ideographs Extension blocks:
    Ext.A (U+3400..U+4DB5) and Ext.B (U+20000..U+2A6D6) in any UCA_Version.
    Ext.C (U+2A700..U+2B734) if UCA_Version is 20 or later.
    Ext.D (U+2B740..U+2B81D) if UCA_Version is 22 or later.

Through C<overrideCJK>, ordering of CJK unified ideographs (including
extensions) can be overridden.

ex. CJK unified ideographs in the JIS code point order.

  overrideCJK => sub {
      my $u = shift;             # get a Unicode codepoint
      my $b = pack('n', $u);     # to UTF-16BE
      my $s = your_unicode_to_sjis_converter($b); # convert
      my $n = unpack('n', $s);   # convert sjis to short
      [ $n, 0x20, 0x2, $u ];     # return the collation element
  },

The return value may be an arrayref of 1st to 4th weights as shown
above. The return value may be an integer as the primary weight
as shown below.  If C<undef> is returned, the default derived
collation element will be used.

  overrideCJK => sub {
      my $u = shift;             # get a Unicode codepoint
      my $b = pack('n', $u);     # to UTF-16BE
      my $s = your_unicode_to_sjis_converter($b); # convert
      my $n = unpack('n', $s);   # convert sjis to short
      return $n;                 # return the primary weight
  },

The return value may be a list containing zero or more of
an arrayref, an integer, or C<undef>.

ex. ignores all CJK unified ideographs.

  overrideCJK => sub {()}, # CODEREF returning empty list

   # where ->eq("Pe\x{4E00}rl", "Perl") is true
   # as U+4E00 is a CJK unified ideograph and to be ignorable.

If a false value (including C<undef>) is passed, C<overrideCJK>
has no effect.
C<$Collator-E<gt>change(overrideCJK =E<gt> 0)> resets the old one.

But assignment of weight for CJK unified ideographs
in C<table> or C<entry> is still valid.
If C<undef> is passed explicitly as the value for this key,
weights for CJK unified ideographs are treated as undefined.
However when C<UCA_Version> E<gt> 8, C<(overrideCJK =E<gt> undef)>
has no special meaning.

B<Note:> In addition to them, 12 CJK compatibility ideographs (C<U+FA0E>,
C<U+FA0F>, C<U+FA11>, C<U+FA13>, C<U+FA14>, C<U+FA1F>, C<U+FA21>, C<U+FA23>,
C<U+FA24>, C<U+FA27>, C<U+FA28>, C<U+FA29>) are also treated as CJK unified
ideographs. But they can't be overridden via C<overrideCJK> when you use
DUCET, as the table includes weights for them. C<table> or C<entry> has
priority over C<overrideCJK>.

=item overrideHangul

-- see 7.1 Derived Collation Elements, UTS #10.

By default, Hangul syllables are decomposed into Hangul Jamo,
even if C<(normalization =E<gt> undef)>.
But the mapping of Hangul syllables may be overridden.

This parameter works like C<overrideCJK>, so see there for examples.

If you want to override the mapping of Hangul syllables,
NFD and NFKD are not appropriate, since NFD and NFKD will decompose
Hangul syllables before overriding. FCD may decompose Hangul syllables
as the case may be.

If a false value (but not C<undef>) is passed, C<overrideHangul>
has no effect.
C<$Collator-E<gt>change(overrideHangul =E<gt> 0)> resets the old one.

If C<undef> is passed explicitly as the value for this key,
weight for Hangul syllables is treated as undefined
without decomposition into Hangul Jamo.
But definition of weight for Hangul syllables
in C<table> or C<entry> is still valid.

=item overrideOut

-- see 7.1.1 Handling Ill-Formed Code Unit Sequences, UTS #10.

Perl seems to allow out-of-range values (greater than 0x10FFFF).
By default, out-of-range values are replaced with C<U+FFFD>
(REPLACEMENT CHARACTER) when C<UCA_Version> E<gt>= 22,
or ignored when C<UCA_Version> E<lt>= 20.

When C<UCA_Version> E<gt>= 22, the weights of out-of-range values
can be overridden. Though C<table> or C<entry> are available for them,
out-of-range values are too many.

C<overrideOut> can perform it algorithmically.
This parameter works like C<overrideCJK>, so see there for examples.

ex. ignores all out-of-range values.

  overrideOut => sub {()}, # CODEREF returning empty list

If a false value (including C<undef>) is passed, C<overrideOut>
has no effect.
C<$Collator-E<gt>change(overrideOut =E<gt> 0)> resets the old one.

B<NOTE ABOUT U+FFFD:>

UCA recommends that out-of-range values should not be ignored for security
reasons. Say, C<"pe\x{110000}rl"> should not be equal to C<"perl">.
However, C<U+FFFD> is wrongly mapped to a variable collation element
in DUCET for Unicode 6.0.0 to 6.2.0, that means out-of-range values will be
ignored when C<variable> isn't C<Non-ignorable>.

The mapping of C<U+FFFD> is corrected in Unicode 6.3.0.
see L<http://www.unicode.org/reports/tr10/tr10-28.html#Trailing_Weights>
(7.1.4 Trailing Weights). Such a correction is reproduced by this.

  overrideOut => sub { 0xFFFD }, # CODEREF returning a very large integer

This workaround is unnecessary since Unicode 6.3.0.

=item preprocess

-- see 5.4 Preprocessing, UTS #10.

If specified, the coderef is used to preprocess each string
before the formation of sort keys.

ex. dropping English articles, such as "a" or "the".
Then, "the pen" is before "a pencil".

     preprocess => sub {
           my $str = shift;
           $str =~ s/\b(?:an?|the)\s+//gi;
           return $str;
        },

C<preprocess> is performed before C<normalization> (if defined).

ex. decoding strings in a legacy encoding such as shift-jis:

    $sjis_collator = Unicode::Collate->new(
        preprocess => \&your_shiftjis_to_unicode_decoder,
    );
    @result = $sjis_collator->sort(@shiftjis_strings);

B<Note:> Strings returned from the coderef will be interpreted
according to Perl's Unicode support. See L<perlunicode>,
L<perluniintro>, L<perlunitut>, L<perlunifaq>, L<utf8>.

=item rearrange

-- see 3.5 Rearrangement, UTS #10.

Characters that are not coded in logical order and to be rearranged.
If C<UCA_Version> is equal to or less than 11, default is:

    rearrange => [ 0x0E40..0x0E44, 0x0EC0..0x0EC4 ],

If you want to disallow any rearrangement, pass C<undef> or C<[]>
(a reference to empty list) as the value for this key.

If C<UCA_Version> is equal to or greater than 14, default is C<[]>
(i.e. no rearrangement).

B<According to the version 9 of UCA, this parameter shall not be used;
but it is not warned at present.>

=item rewrite

If specified, the coderef is used to rewrite lines in C<table> or C<entry>.
The coderef will get each line, and then should return a rewritten line
according to the UCA file format.
If the coderef returns an empty line, the line will be skipped.

e.g. any primary ignorable characters into tertiary ignorable:

    rewrite => sub {
        my $line = shift;
        $line =~ s/\[\.0000\..{4}\..{4}\./[.0000.0000.0000./g;
        return $line;
    },

This example shows rewriting weights. C<rewrite> is allowed to
affect code points, weights, and the name.

B<NOTE>: C<table> is available to use another table file;
preparing a modified table once would be more efficient than
rewriting lines on reading an unmodified table every time.

=item suppress

-- see suppress contractions in 5.14.11 Special-Purpose Commands,
UTS #35 (LDML).

Contractions beginning with the specified characters are suppressed,
even if those contractions are defined in C<table>.

An example for Russian and some languages using the Cyrillic script:

    suppress => [0x0400..0x0417, 0x041A..0x0437, 0x043A..0x045F],

where 0x0400 stands for C<U+0400>, CYRILLIC CAPITAL LETTER IE WITH GRAVE.

B<NOTE>: Contractions via C<entry> are not be suppressed.

=item table

-- see 3.8 Default Unicode Collation Element Table, UTS #10.

You can use another collation element table if desired.

The table file should locate in the F<Unicode/Collate> directory
on C<@INC>. Say, if the filename is F<Foo.txt>,
the table file is searched as F<Unicode/Collate/Foo.txt> in C<@INC>.

By default, F<allkeys.txt> (as the filename of DUCET) is used.
If you will prepare your own table file, any name other than F<allkeys.txt>
may be better to avoid namespace conflict.

B<NOTE>: When XSUB is used, the DUCET is compiled on building this
module, and it may save time at the run time.
Explicit saying C<(table =E<gt> 'allkeys.txt')>, or using another table,
or using C<ignoreChar>, C<ignoreName>, C<undefChar>, C<undefName> or
C<rewrite> will prevent this module from using the compiled DUCET.

If C<undef> is passed explicitly as the value for this key,
no file is read (but you can define collation elements via C<entry>).

A typical way to define a collation element table
without any file of table:

   $onlyABC = Unicode::Collate->new(
       table => undef,
       entry => << 'ENTRIES',
0061 ; [.0101.0020.0002.0061] # LATIN SMALL LETTER A
0041 ; [.0101.0020.0008.0041] # LATIN CAPITAL LETTER A
0062 ; [.0102.0020.0002.0062] # LATIN SMALL LETTER B
0042 ; [.0102.0020.0008.0042] # LATIN CAPITAL LETTER B
0063 ; [.0103.0020.0002.0063] # LATIN SMALL LETTER C
0043 ; [.0103.0020.0008.0043] # LATIN CAPITAL LETTER C
ENTRIES
    );

If C<ignoreName> or C<undefName> is used, character names should be
specified as a comment (following C<#>) on each line.

=item undefChar

=item undefName

-- see 6.3.4 Reducing the Repertoire, UTS #10.

Undefines the collation element as if it were unassigned in the C<table>.
This reduces the size of the table.
If an unassigned character appears in the string to be collated,
the sort key is made from its codepoint
as a single-character collation element,
as it is greater than any other assigned collation elements
(in the codepoint order among the unassigned characters).
But, it'd be better to ignore characters
unfamiliar to you and maybe never used.

Through C<undefChar>, any character matching C<qr/$undefChar/>
will be undefined. Through C<undefName>, any character whose name
(given in the C<table> file as a comment) matches C<qr/$undefName/>
will be undefined.

ex. Collation weights for beyond-BMP characters are not stored in object:

    undefChar => qr/[^\0-\x{fffd}]/,

=item upper_before_lower

-- see 6.6 Case Comparisons, UTS #10.

By default, lowercase is before uppercase.
If the parameter is made true, this is reversed.

B<NOTE>: This parameter simplemindedly assumes that any lowercase/uppercase
distinctions must occur in level 3, and their weights at level 3 must be
same as those mentioned in 7.3.1, UTS #10.
If you define your collation elements which differs from this requirement,
this parameter doesn't work validly.

=item variable

-- see 3.6 Variable Weighting, UTS #10.

This key allows for variable weighting of variable collation elements,
which are marked with an ASTERISK in the table
(NOTE: Many punctuation marks and symbols are variable in F<allkeys.txt>).

   variable => 'blanked', 'non-ignorable', 'shifted', or 'shift-trimmed'.

These names are case-insensitive.
By default (if specification is omitted), 'shifted' is adopted.

   'Blanked'        Variable elements are made ignorable at levels 1 through 3;
                    considered at the 4th level.

   'Non-Ignorable'  Variable elements are not reset to ignorable.

   'Shifted'        Variable elements are made ignorable at levels 1 through 3
                    their level 4 weight is replaced by the old level 1 weight.
                    Level 4 weight for Non-Variable elements is 0xFFFF.

   'Shift-Trimmed'  Same as 'shifted', but all FFFF's at the 4th level
                    are trimmed.

=back

=head2 Methods for Collation

=over 4

=item C<@sorted = $Collator-E<gt>sort(@not_sorted)>

Sorts a list of strings.

=item C<$result = $Collator-E<gt>cmp($a, $b)>

Returns 1 (when C<$a> is greater than C<$b>)
or 0 (when C<$a> is equal to C<$b>)
or -1 (when C<$a> is less than C<$b>).

=item C<$result = $Collator-E<gt>eq($a, $b)>

=item C<$result = $Collator-E<gt>ne($a, $b)>

=item C<$result = $Collator-E<gt>lt($a, $b)>

=item C<$result = $Collator-E<gt>le($a, $b)>

=item C<$result = $Collator-E<gt>gt($a, $b)>

=item C<$result = $Collator-E<gt>ge($a, $b)>

They works like the same name operators as theirs.

   eq : whether $a is equal to $b.
   ne : whether $a is not equal to $b.
   lt : whether $a is less than $b.
   le : whether $a is less than $b or equal to $b.
   gt : whether $a is greater than $b.
   ge : whether $a is greater than $b or equal to $b.

=item C<$sortKey = $Collator-E<gt>getSortKey($string)>

-- see 4.3 Form Sort Key, UTS #10.

Returns a sort key.

You compare the sort keys using a binary comparison
and get the result of the comparison of the strings using UCA.

   $Collator->getSortKey($a) cmp $Collator->getSortKey($b)

      is equivalent to

   $Collator->cmp($a, $b)

=item C<$sortKeyForm = $Collator-E<gt>viewSortKey($string)>

Converts a sorting key into its representation form.
If C<UCA_Version> is 8, the output is slightly different.

   use Unicode::Collate;
   my $c = Unicode::Collate->new();
   print $c->viewSortKey("Perl"),"\n";

   # output:
   # [0B67 0A65 0B7F 0B03 | 0020 0020 0020 0020 | 0008 0002 0002 0002 | FFFF FFFF FFFF FFFF]
   #  Level 1               Level 2               Level 3               Level 4

=back

=head2 Methods for Searching

The C<match>, C<gmatch>, C<subst>, C<gsubst> methods work
like C<m//>, C<m//g>, C<s///>, C<s///g>, respectively,
but they are not aware of any pattern, but only a literal substring.

B<DISCLAIMER:> If C<preprocess> or C<normalization> parameter is true
for C<$Collator>, calling these methods (C<index>, C<match>, C<gmatch>,
C<subst>, C<gsubst>) is croaked, as the position and the length might
differ from those on the specified string.

C<rearrange> and C<hangul_terminator> parameters are neglected.
C<katakana_before_hiragana> and C<upper_before_lower> don't affect
matching and searching, as it doesn't matter whether greater or less.

=over 4

=item C<$position = $Collator-E<gt>index($string, $substring[, $position])>

=item C<($position, $length) = $Collator-E<gt>index($string, $substring[, $position])>

If C<$substring> matches a part of C<$string>, returns
the position of the first occurrence of the matching part in scalar context;
in list context, returns a two-element list of
the position and the length of the matching part.

If C<$substring> does not match any part of C<$string>,
returns C<-1> in scalar context and
an empty list in list context.

e.g. when the content of C<$str> is C<"Ich mu>E<szlig>C< studieren Perl.">,
you say the following where C<$sub> is C<"M>E<uuml>C<SS">,

  my $Collator = Unicode::Collate->new( normalization => undef, level => 1 );
                                     # (normalization => undef) is REQUIRED.
  my $match;
  if (my($pos,$len) = $Collator->index($str, $sub)) {
      $match = substr($str, $pos, $len);
  }

and get C<"mu>E<szlig>C<"> in C<$match>, since C<"mu>E<szlig>C<">
is primary equal to C<"M>E<uuml>C<SS">.

=item C<$match_ref = $Collator-E<gt>match($string, $substring)>

=item C<($match)   = $Collator-E<gt>match($string, $substring)>

If C<$substring> matches a part of C<$string>, in scalar context, returns
B<a reference to> the first occurrence of the matching part
(C<$match_ref> is always true if matches,
since every reference is B<true>);
in list context, returns the first occurrence of the matching part.

If C<$substring> does not match any part of C<$string>,
returns C<undef> in scalar context and
an empty list in list context.

e.g.

    if ($match_ref = $Collator->match($str, $sub)) { # scalar context
	print "matches [$$match_ref].\n";
    } else {
	print "doesn't match.\n";
    }

     or

    if (($match) = $Collator->match($str, $sub)) { # list context
	print "matches [$match].\n";
    } else {
	print "doesn't match.\n";
    }

=item C<@match = $Collator-E<gt>gmatch($string, $substring)>

If C<$substring> matches a part of C<$string>, returns
all the matching parts (or matching count in scalar context).

If C<$substring> does not match any part of C<$string>,
returns an empty list.

=item C<$count = $Collator-E<gt>subst($string, $substring, $replacement)>

If C<$substring> matches a part of C<$string>,
the first occurrence of the matching part is replaced by C<$replacement>
(C<$string> is modified) and C<$count> (always equals to C<1>) is returned.

C<$replacement> can be a C<CODEREF>,
taking the matching part as an argument,
and returning a string to replace the matching part
(a bit similar to C<s/(..)/$coderef-E<gt>($1)/e>).

=item C<$count = $Collator-E<gt>gsubst($string, $substring, $replacement)>

If C<$substring> matches a part of C<$string>,
all the occurrences of the matching part are replaced by C<$replacement>
(C<$string> is modified) and C<$count> is returned.

C<$replacement> can be a C<CODEREF>,
taking the matching part as an argument,
and returning a string to replace the matching part
(a bit similar to C<s/(..)/$coderef-E<gt>($1)/eg>).

e.g.

  my $Collator = Unicode::Collate->new( normalization => undef, level => 1 );
                                     # (normalization => undef) is REQUIRED.
  my $str = "Camel donkey zebra came\x{301}l CAMEL horse cam\0e\0l...";
  $Collator->gsubst($str, "camel", sub { "<b>$_[0]</b>" });

  # now $str is "<b>Camel</b> donkey zebra <b>came\x{301}l</b> <b>CAMEL</b> horse <b>cam\0e\0l</b>...";
  # i.e., all the camels are made bold-faced.

   Examples: levels and ignore_level2 - what does camel match?
  ---------------------------------------------------------------------------
   level  ignore_level2  |  camel  Camel  came\x{301}l  c-a-m-e-l  cam\0e\0l
  -----------------------|---------------------------------------------------
     1        false      |   yes    yes      yes          yes        yes
     2        false      |   yes    yes      no           yes        yes
     3        false      |   yes    no       no           yes        yes
     4        false      |   yes    no       no           no         yes
  -----------------------|---------------------------------------------------
     1        true       |   yes    yes      yes          yes        yes
     2        true       |   yes    yes      yes          yes        yes
     3        true       |   yes    no       yes          yes        yes
     4        true       |   yes    no       yes          no         yes
  ---------------------------------------------------------------------------
   note: if variable => non-ignorable, camel doesn't match c-a-m-e-l
         at any level.

=back

=head2 Other Methods

=over 4

=item C<%old_tailoring = $Collator-E<gt>change(%new_tailoring)>

=item C<$modified_collator = $Collator-E<gt>change(%new_tailoring)>

Changes the value of specified keys and returns the changed part.

    $Collator = Unicode::Collate->new(level => 4);

    $Collator->eq("perl", "PERL"); # false

    %old = $Collator->change(level => 2); # returns (level => 4).

    $Collator->eq("perl", "PERL"); # true

    $Collator->change(%old); # returns (level => 2).

    $Collator->eq("perl", "PERL"); # false

Not all C<(key,value)>s are allowed to be changed.
See also C<@Unicode::Collate::ChangeOK> and C<@Unicode::Collate::ChangeNG>.

In the scalar context, returns the modified collator
(but it is B<not> a clone from the original).

    $Collator->change(level => 2)->eq("perl", "PERL"); # true

    $Collator->eq("perl", "PERL"); # true; now max level is 2nd.

    $Collator->change(level => 4)->eq("perl", "PERL"); # false

=item C<$version = $Collator-E<gt>version()>

Returns the version number (a string) of the Unicode Standard
which the C<table> file used by the collator object is based on.
If the table does not include a version line (starting with C<@version>),
returns C<"unknown">.

=item C<UCA_Version()>

Returns the revision number of UTS #10 this module consults,
that should correspond with the DUCET incorporated.

=item C<Base_Unicode_Version()>

Returns the version number of UTS #10 this module consults,
that should correspond with the DUCET incorporated.

=back

=head1 EXPORT

No method will be exported.

=head1 INSTALL

Though this module can be used without any C<table> file,
to use this module easily, it is recommended to install a table file
in the UCA format, by copying it under the directory
<a place in @INC>/Unicode/Collate.

The most preferable one is "The Default Unicode Collation Element Table"
(aka DUCET), available from the Unicode Consortium's website:

   http://www.unicode.org/Public/UCA/

   http://www.unicode.org/Public/UCA/latest/allkeys.txt (latest version)

If DUCET is not installed, it is recommended to copy the file
from http://www.unicode.org/Public/UCA/latest/allkeys.txt
to <a place in @INC>/Unicode/Collate/allkeys.txt
manually.

=head1 CAVEATS

=over 4

=item Normalization

Use of the C<normalization> parameter requires the B<Unicode::Normalize>
module (see L<Unicode::Normalize>).

If you need not it (say, in the case when you need not
handle any combining characters),
assign C<(normalization =E<gt> undef)> explicitly.

-- see 6.5 Avoiding Normalization, UTS #10.

=item Conformance Test

The Conformance Test for the UCA is available
under L<http://www.unicode.org/Public/UCA/>.

For F<CollationTest_SHIFTED.txt>,
a collator via C<Unicode::Collate-E<gt>new( )> should be used;
for F<CollationTest_NON_IGNORABLE.txt>, a collator via
C<Unicode::Collate-E<gt>new(variable =E<gt> "non-ignorable", level =E<gt> 3)>.

If C<UCA_Version> is 26 or later, the C<identical> level is preferred;
C<Unicode::Collate-E<gt>new(identical =E<gt> 1)> and
C<Unicode::Collate-E<gt>new(identical =E<gt> 1,>
C<variable =E<gt> "non-ignorable", level =E<gt> 3)> should be used.

B<Unicode::Normalize is required to try The Conformance Test.>

=back

=head1 AUTHOR, COPYRIGHT AND LICENSE

The Unicode::Collate module for perl was written by SADAHIRO Tomoyuki,
<SADAHIRO@cpan.org>. This module is Copyright(C) 2001-2014,
SADAHIRO Tomoyuki. Japan. All rights reserved.

This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

The file Unicode/Collate/allkeys.txt was copied verbatim
from L<http://www.unicode.org/Public/UCA/6.3.0/allkeys.txt>.
For this file, Copyright (c) 2001-2012 Unicode, Inc.
Distributed under the Terms of Use in L<http://www.unicode.org/copyright.html>.

=head1 SEE ALSO

=over 4

=item Unicode Collation Algorithm - UTS #10

L<http://www.unicode.org/reports/tr10/>

=item The Default Unicode Collation Element Table (DUCET)

L<http://www.unicode.org/Public/UCA/latest/allkeys.txt>

=item The conformance test for the UCA

L<http://www.unicode.org/Public/UCA/latest/CollationTest.html>

L<http://www.unicode.org/Public/UCA/latest/CollationTest.zip>

=item Hangul Syllable Type

L<http://www.unicode.org/Public/UNIDATA/HangulSyllableType.txt>

=item Unicode Normalization Forms - UAX #15

L<http://www.unicode.org/reports/tr15/>

=item Unicode Locale Data Markup Language (LDML) - UTS #35

L<http://www.unicode.org/reports/tr35/>

=back

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      package Unicode::Normalize;

BEGIN {
    unless ('A' eq pack('U', 0x41)) {
	die "Unicode::Normalize cannot stringify a Unicode code point\n";
    }
    unless (0x41 == unpack('U', 'A')) {
	die "Unicode::Normalize cannot get Unicode code point\n";
    }
}

use 5.006;
use strict;
use warnings;
use Carp;

no warnings 'utf8';

our $VERSION = '1.25';
our $PACKAGE = __PACKAGE__;

our @EXPORT = qw( NFC NFD NFKC NFKD );
our @EXPORT_OK = qw(
    normalize decompose reorder compose
    checkNFD checkNFKD checkNFC checkNFKC check
    getCanon getCompat getComposite getCombinClass
    isExclusion isSingleton isNonStDecomp isComp2nd isComp_Ex
    isNFD_NO isNFC_NO isNFC_MAYBE isNFKD_NO isNFKC_NO isNFKC_MAYBE
    FCD checkFCD FCC checkFCC composeContiguous splitOnLastStarter
    normalize_partial NFC_partial NFD_partial NFKC_partial NFKD_partial
);
our %EXPORT_TAGS = (
    all       => [ @EXPORT, @EXPORT_OK ],
    normalize => [ @EXPORT, qw/normalize decompose reorder compose/ ],
    check     => [ qw/checkNFD checkNFKD checkNFC checkNFKC check/ ],
    fast      => [ qw/FCD checkFCD FCC checkFCC composeContiguous/ ],
);

##
## utilities for tests
##

sub pack_U {
    return pack('U*', @_);
}

sub unpack_U {

    # The empty pack returns an empty UTF-8 string, so the effect is to force
    # the shifted parameter into being UTF-8.  This allows this to work on
    # Perl 5.6, where there is no utf8::upgrade().
    return unpack('U*', shift(@_).pack('U*'));
}

require Exporter;

##### The above part is common to XS and PP #####

our @ISA = qw(Exporter DynaLoader);
require DynaLoader;
bootstrap Unicode::Normalize $VERSION;

##### The below part is common to XS and PP #####

##
## normalize
##

sub FCD ($) {
    my $str = shift;
    return checkFCD($str) ? $str : NFD($str);
}

our %formNorm = (
    NFC  => \&NFC,	C  => \&NFC,
    NFD  => \&NFD,	D  => \&NFD,
    NFKC => \&NFKC,	KC => \&NFKC,
    NFKD => \&NFKD,	KD => \&NFKD,
    FCD  => \&FCD,	FCC => \&FCC,
);

sub normalize($$)
{
    my $form = shift;
    my $str = shift;
    if (exists $formNorm{$form}) {
	return $formNorm{$form}->($str);
    }
    croak($PACKAGE."::normalize: invalid form name: $form");
}

##
## partial
##

sub normalize_partial ($$) {
    if (exists $formNorm{$_[0]}) {
	my $n = normalize($_[0], $_[1]);
	my($p, $u) = splitOnLastStarter($n);
	$_[1] = $u;
	return $p;
    }
    croak($PACKAGE."::normalize_partial: invalid form name: $_[0]");
}

sub NFD_partial ($) { return normalize_partial('NFD', $_[0]) }
sub NFC_partial ($) { return normalize_partial('NFC', $_[0]) }
sub NFKD_partial($) { return normalize_partial('NFKD',$_[0]) }
sub NFKC_partial($) { return normalize_partial('NFKC',$_[0]) }

##
## check
##

our %formCheck = (
    NFC  => \&checkNFC, 	C  => \&checkNFC,
    NFD  => \&checkNFD, 	D  => \&checkNFD,
    NFKC => \&checkNFKC,	KC => \&checkNFKC,
    NFKD => \&checkNFKD,	KD => \&checkNFKD,
    FCD  => \&checkFCD, 	FCC => \&checkFCC,
);

sub check($$)
{
    my $form = shift;
    my $str = shift;
    if (exists $formCheck{$form}) {
	return $formCheck{$form}->($str);
    }
    croak($PACKAGE."::check: invalid form name: $form");
}

1;
__END__

=head1 NAME

Unicode::Normalize - Unicode Normalization Forms

=head1 SYNOPSIS

(1) using function names exported by default:

  use Unicode::Normalize;

  $NFD_string  = NFD($string);  # Normalization Form D
  $NFC_string  = NFC($string);  # Normalization Form C
  $NFKD_string = NFKD($string); # Normalization Form KD
  $NFKC_string = NFKC($string); # Normalization Form KC

(2) using function names exported on request:

  use Unicode::Normalize 'normalize';

  $NFD_string  = normalize('D',  $string);  # Normalization Form D
  $NFC_string  = normalize('C',  $string);  # Normalization Form C
  $NFKD_string = normalize('KD', $string);  # Normalization Form KD
  $NFKC_string = normalize('KC', $string);  # Normalization Form KC

=head1 DESCRIPTION

Parameters:

C<$string> is used as a string under character semantics (see F<perlunicode>).

C<$code_point> should be an unsigned integer representing a Unicode code point.

Note: Between XSUB and pure Perl, there is an incompatibility
about the interpretation of C<$code_point> as a decimal number.
XSUB converts C<$code_point> to an unsigned integer, but pure Perl does not.
Do not use a floating point nor a negative sign in C<$code_point>.

=head2 Normalization Forms

=over 4

=item C<$NFD_string = NFD($string)>

It returns the Normalization Form D (formed by canonical decomposition).

=item C<$NFC_string = NFC($string)>

It returns the Normalization Form C (formed by canonical decomposition
followed by canonical composition).

=item C<$NFKD_string = NFKD($string)>

It returns the Normalization Form KD (formed by compatibility decomposition).

=item C<$NFKC_string = NFKC($string)>

It returns the Normalization Form KC (formed by compatibility decomposition
followed by B<canonical> composition).

=item C<$FCD_string = FCD($string)>

If the given string is in FCD ("Fast C or D" form; cf. UTN #5),
it returns the string without modification; otherwise it returns an FCD string.

Note: FCD is not always unique, then plural forms may be equivalent
each other. C<FCD()> will return one of these equivalent forms.

=item C<$FCC_string = FCC($string)>

It returns the FCC form ("Fast C Contiguous"; cf. UTN #5).

Note: FCC is unique, as well as four normalization forms (NF*).

=item C<$normalized_string = normalize($form_name, $string)>

It returns the normalization form of C<$form_name>.

As C<$form_name>, one of the following names must be given.

  'C'  or 'NFC'  for Normalization Form C  (UAX #15)
  'D'  or 'NFD'  for Normalization Form D  (UAX #15)
  'KC' or 'NFKC' for Normalization Form KC (UAX #15)
  'KD' or 'NFKD' for Normalization Form KD (UAX #15)

  'FCD'          for "Fast C or D" Form  (UTN #5)
  'FCC'          for "Fast C Contiguous" (UTN #5)

=back

=head2 Decomposition and Composition

=over 4

=item C<$decomposed_string = decompose($string [, $useCompatMapping])>

It returns the concatenation of the decomposition of each character
in the string.

If the second parameter (a boolean) is omitted or false,
the decomposition is canonical decomposition;
if the second parameter (a boolean) is true,
the decomposition is compatibility decomposition.

The string returned is not always in NFD/NFKD. Reordering may be required.

    $NFD_string  = reorder(decompose($string));       # eq. to NFD()
    $NFKD_string = reorder(decompose($string, TRUE)); # eq. to NFKD()

=item C<$reordered_string = reorder($string)>

It returns the result of reordering the combining characters
according to Canonical Ordering Behavior.

For example, when you have a list of NFD/NFKD strings,
you can get the concatenated NFD/NFKD string from them, by saying

    $concat_NFD  = reorder(join '', @NFD_strings);
    $concat_NFKD = reorder(join '', @NFKD_strings);

=item C<$composed_string = compose($string)>

It returns the result of canonical composition
without applying any decomposition.

For example, when you have a NFD/NFKD string,
you can get its NFC/NFKC string, by saying

    $NFC_string  = compose($NFD_string);
    $NFKC_string = compose($NFKD_string);

=item C<($processed, $unprocessed) = splitOnLastStarter($normalized)>

It returns two strings: the first one, C<$processed>, is a part
before the last starter, and the second one, C<$unprocessed> is
another part after the first part. A starter is a character having
a combining class of zero (see UAX #15).

Note that C<$processed> may be empty (when C<$normalized> contains no
starter or starts with the last starter), and then C<$unprocessed>
should be equal to the entire C<$normalized>.

When you have a C<$normalized> string and an C<$unnormalized> string
following it, a simple concatenation is wrong:

    $concat = $normalized . normalize($form, $unnormalized); # wrong!

Instead of it, do like this:

    ($processed, $unprocessed) = splitOnLastStarter($normalized);
     $concat = $processed . normalize($form, $unprocessed.$unnormalized);

C<splitOnLastStarter()> should be called with a pre-normalized parameter
C<$normalized>, that is in the same form as C<$form> you want.

If you have an array of C<@string> that should be concatenated and then
normalized, you can do like this:

    my $result = "";
    my $unproc = "";
    foreach my $str (@string) {
        $unproc .= $str;
        my $n = normalize($form, $unproc);
        my($p, $u) = splitOnLastStarter($n);
        $result .= $p;
        $unproc  = $u;
    }
    $result .= $unproc;
    # instead of normalize($form, join('', @string))

=item C<$processed = normalize_partial($form, $unprocessed)>

A wrapper for the combination of C<normalize()> and C<splitOnLastStarter()>.
Note that C<$unprocessed> will be modified as a side-effect.

If you have an array of C<@string> that should be concatenated and then
normalized, you can do like this:

    my $result = "";
    my $unproc = "";
    foreach my $str (@string) {
        $unproc .= $str;
        $result .= normalize_partial($form, $unproc);
    }
    $result .= $unproc;
    # instead of normalize($form, join('', @string))

=item C<$processed = NFD_partial($unprocessed)>

It does like C<normalize_partial('NFD', $unprocessed)>.
Note that C<$unprocessed> will be modified as a side-effect.

=item C<$processed = NFC_partial($unprocessed)>

It does like C<normalize_partial('NFC', $unprocessed)>.
Note that C<$unprocessed> will be modified as a side-effect.

=item C<$processed = NFKD_partial($unprocessed)>

It does like C<normalize_partial('NFKD', $unprocessed)>.
Note that C<$unprocessed> will be modified as a side-effect.

=item C<$processed = NFKC_partial($unprocessed)>

It does like C<normalize_partial('NFKC', $unprocessed)>.
Note that C<$unprocessed> will be modified as a side-effect.

=back

=head2 Quick Check

(see Annex 8, UAX #15; and F<DerivedNormalizationProps.txt>)

The following functions check whether the string is in that normalization form.

The result returned will be one of the following:

    YES     The string is in that normalization form.
    NO      The string is not in that normalization form.
    MAYBE   Dubious. Maybe yes, maybe no.

=over 4

=item C<$result = checkNFD($string)>

It returns true (C<1>) if C<YES>; false (C<empty string>) if C<NO>.

=item C<$result = checkNFC($string)>

It returns true (C<1>) if C<YES>; false (C<empty string>) if C<NO>;
C<undef> if C<MAYBE>.

=item C<$result = checkNFKD($string)>

It returns true (C<1>) if C<YES>; false (C<empty string>) if C<NO>.

=item C<$result = checkNFKC($string)>

It returns true (C<1>) if C<YES>; false (C<empty string>) if C<NO>;
C<undef> if C<MAYBE>.

=item C<$result = checkFCD($string)>

It returns true (C<1>) if C<YES>; false (C<empty string>) if C<NO>.

=item C<$result = checkFCC($string)>

It returns true (C<1>) if C<YES>; false (C<empty string>) if C<NO>;
C<undef> if C<MAYBE>.

Note: If a string is not in FCD, it must not be in FCC.
So C<checkFCC($not_FCD_string)> should return C<NO>.

=item C<$result = check($form_name, $string)>

It returns true (C<1>) if C<YES>; false (C<empty string>) if C<NO>;
C<undef> if C<MAYBE>.

As C<$form_name>, one of the following names must be given.

  'C'  or 'NFC'  for Normalization Form C  (UAX #15)
  'D'  or 'NFD'  for Normalization Form D  (UAX #15)
  'KC' or 'NFKC' for Normalization Form KC (UAX #15)
  'KD' or 'NFKD' for Normalization Form KD (UAX #15)

  'FCD'          for "Fast C or D" Form  (UTN #5)
  'FCC'          for "Fast C Contiguous" (UTN #5)

=back

B<Note>

In the cases of NFD, NFKD, and FCD, the answer must be
either C<YES> or C<NO>. The answer C<MAYBE> may be returned
in the cases of NFC, NFKC, and FCC.

A C<MAYBE> string should contain at least one combining character
or the like. For example, C<COMBINING ACUTE ACCENT> has
the MAYBE_NFC/MAYBE_NFKC property.

Both C<checkNFC("A\N{COMBINING ACUTE ACCENT}")>
and C<checkNFC("B\N{COMBINING ACUTE ACCENT}")> will return C<MAYBE>.
C<"A\N{COMBINING ACUTE ACCENT}"> is not in NFC
(its NFC is C<"\N{LATIN CAPITAL LETTER A WITH ACUTE}">),
while C<"B\N{COMBINING ACUTE ACCENT}"> is in NFC.

If you want to check exactly, compare the string with its NFC/NFKC/FCC.

    if ($string eq NFC($string)) {
        # $string is exactly normalized in NFC;
    } else {
        # $string is not normalized in NFC;
    }

    if ($string eq NFKC($string)) {
        # $string is exactly normalized in NFKC;
    } else {
        # $string is not normalized in NFKC;
    }

=head2 Character Data

These functions are interface of character data used internally.
If you want only to get Unicode normalization forms, you don't need
call them yourself.

=over 4

=item C<$canonical_decomposition = getCanon($code_point)>

If the character is canonically decomposable (including Hangul Syllables),
it returns the (full) canonical decomposition as a string.
Otherwise it returns C<undef>.

B<Note:> According to the Unicode standard, the canonical decomposition
of the character that is not canonically decomposable is same as
the character itself.

=item C<$compatibility_decomposition = getCompat($code_point)>

If the character is compatibility decomposable (including Hangul Syllables),
it returns the (full) compatibility decomposition as a string.
Otherwise it returns C<undef>.

B<Note:> According to the Unicode standard, the compatibility decomposition
of the character that is not compatibility decomposable is same as
the character itself.

=item C<$code_point_composite = getComposite($code_point_here, $code_point_next)>

If two characters here and next (as code points) are composable
(including Hangul Jamo/Syllables and Composition Exclusions),
it returns the code point of the composite.

If they are not composable, it returns C<undef>.

=item C<$combining_class = getCombinClass($code_point)>

It returns the combining class (as an integer) of the character.

=item C<$may_be_composed_with_prev_char = isComp2nd($code_point)>

It returns a boolean whether the character of the specified codepoint
may be composed with the previous one in a certain composition
(including Hangul Compositions, but excluding
Composition Exclusions and Non-Starter Decompositions).

=item C<$is_exclusion = isExclusion($code_point)>

It returns a boolean whether the code point is a composition exclusion.

=item C<$is_singleton = isSingleton($code_point)>

It returns a boolean whether the code point is a singleton

=item C<$is_non_starter_decomposition = isNonStDecomp($code_point)>

It returns a boolean whether the code point has Non-Starter Decomposition.

=item C<$is_Full_Composition_Exclusion = isComp_Ex($code_point)>

It returns a boolean of the derived property Comp_Ex
(Full_Composition_Exclusion). This property is generated from
Composition Exclusions + Singletons + Non-Starter Decompositions.

=item C<$NFD_is_NO = isNFD_NO($code_point)>

It returns a boolean of the derived property NFD_NO
(NFD_Quick_Check=No).

=item C<$NFC_is_NO = isNFC_NO($code_point)>

It returns a boolean of the derived property NFC_NO
(NFC_Quick_Check=No).

=item C<$NFC_is_MAYBE = isNFC_MAYBE($code_point)>

It returns a boolean of the derived property NFC_MAYBE
(NFC_Quick_Check=Maybe).

=item C<$NFKD_is_NO = isNFKD_NO($code_point)>

It returns a boolean of the derived property NFKD_NO
(NFKD_Quick_Check=No).

=item C<$NFKC_is_NO = isNFKC_NO($code_point)>

It returns a boolean of the derived property NFKC_NO
(NFKC_Quick_Check=No).

=item C<$NFKC_is_MAYBE = isNFKC_MAYBE($code_point)>

It returns a boolean of the derived property NFKC_MAYBE
(NFKC_Quick_Check=Maybe).

=back

=head1 EXPORT

C<NFC>, C<NFD>, C<NFKC>, C<NFKD>: by default.

C<normalize> and other some functions: on request.

=head1 CAVEATS

=over 4

=item Perl's version vs. Unicode version

Since this module refers to perl core's Unicode database in the directory
F</lib/unicore> (or formerly F</lib/unicode>), the Unicode version of
normalization implemented by this module depends on what has been
compiled into your perl.  The following table lists the default Unicode
version that comes with various perl versions.  (It is possible to change
the Unicode version in any perl version to be any earlier Unicode version,
so one could cause Unicode 3.2 to be used in any perl version starting with
5.8.0.  See C<$Config{privlib}>/F<unicore/README.perl>.

    perl's version     implemented Unicode version
       5.6.1              3.0.1
       5.7.2              3.1.0
       5.7.3              3.1.1 (normalization is same as 3.1.0)
       5.8.0              3.2.0
         5.8.1-5.8.3      4.0.0
         5.8.4-5.8.6      4.0.1 (normalization is same as 4.0.0)
         5.8.7-5.8.8      4.1.0
       5.10.0             5.0.0
        5.8.9, 5.10.1     5.1.0
       5.12.x             5.2.0
       5.14.x             6.0.0
       5.16.x             6.1.0
       5.18.x             6.2.0
       5.20.x             6.3.0
       5.22.x             7.0.0

=item Correction of decomposition mapping

In older Unicode versions, a small number of characters (all of which are
CJK compatibility ideographs as far as they have been found) may have
an erroneous decomposition mapping (see F<NormalizationCorrections.txt>).
Anyhow, this module will neither refer to F<NormalizationCorrections.txt>
nor provide any specific version of normalization. Therefore this module
running on an older perl with an older Unicode database may use
the erroneous decomposition mapping blindly conforming to the Unicode database.

=item Revised definition of canonical composition

In Unicode 4.1.0, the definition D2 of canonical composition (which
affects NFC and NFKC) has been changed (see Public Review Issue #29
and recent UAX #15). This module has used the newer definition
since the version 0.07 (Oct 31, 2001).
This module will not support the normalization according to the older
definition, even if the Unicode version implemented by perl is
lower than 4.1.0.

=back

=head1 AUTHOR

SADAHIRO Tomoyuki <SADAHIRO@cpan.org>

Currently maintained by <perl5-porters@perl.org> 

Copyright(C) 2001-2012, SADAHIRO Tomoyuki. Japan. All rights reserved.

=head1 LICENSE

This module is free software; you can redistribute it
and/or modify it under the same terms as Perl itself.

=head1 SEE ALSO

=over 4

=item http://www.unicode.org/reports/tr15/

Unicode Normalization Forms - UAX #15

=item http://www.unicode.org/Public/UNIDATA/CompositionExclusions.txt

Composition Exclusion Table

=item http://www.unicode.org/Public/UNIDATA/DerivedNormalizationProps.txt

Derived Normalization Properties

=item http://www.unicode.org/Public/UNIDATA/NormalizationCorrections.txt

Normalization Corrections

=item http://www.unicode.org/review/pr-29.html

Public Review Issue #29: Normalization Issue

=item http://www.unicode.org/notes/tn5/

Canonical Equivalence in Applications - UTN #5

=back

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    package Unicode::Collate::Locale;

use strict;
use warnings;
use Carp;
use base qw(Unicode::Collate);

our $VERSION = '1.14';

my $PL_EXT  = '.pl';

my %LocaleFile = map { ($_, $_) } qw(
   af ar as az be bg bn ca cs cy da ee eo es et fa fi fil fo fr
   gu ha haw hi hr hu hy ig is ja kk kl kn ko kok ln lt lv
   mk ml mr mt nb nn nso om or pa pl ro ru sa se si sk sl sq
   sr sv ta te th tn to tr uk ur vi wae wo yo zh
);
   $LocaleFile{'default'} = '';
# aliases
   $LocaleFile{'bs'}      = 'hr';
   $LocaleFile{'bs_Cyrl'} = 'sr';
   $LocaleFile{'sr_Latn'} = 'hr';
# short file names
   $LocaleFile{'de__phonebook'}   = 'de_phone';
   $LocaleFile{'es__traditional'} = 'es_trad';
   $LocaleFile{'fi__phonebook'}   = 'fi_phone';
   $LocaleFile{'si__dictionary'}  = 'si_dict';
   $LocaleFile{'sv__reformed'}    = 'sv_refo';
   $LocaleFile{'zh__big5han'}     = 'zh_big5';
   $LocaleFile{'zh__gb2312han'}   = 'zh_gb';
   $LocaleFile{'zh__pinyin'}      = 'zh_pin';
   $LocaleFile{'zh__stroke'}      = 'zh_strk';
   $LocaleFile{'zh__zhuyin'}      = 'zh_zhu';

my %TypeAlias = qw(
    phone     phonebook
    phonebk   phonebook
    dict      dictionary
    reform    reformed
    trad      traditional
    big5      big5han
    gb2312    gb2312han
);

sub _locale {
    my $locale = shift;
    if ($locale) {
	$locale = lc $locale;
	$locale =~ tr/\-\ \./_/;
	$locale =~ s/_([0-9a-z]+)\z/$TypeAlias{$1} ?
				  "_$TypeAlias{$1}" : "_$1"/e;
	$LocaleFile{$locale} and return $locale;

	my @code = split /_/, $locale;
	my $lan = shift @code;
	my $scr = @code && length $code[0] == 4 ? ucfirst shift @code : '';
	my $reg = @code && length $code[0] <  4 ? uc      shift @code : '';
	my $var = @code                         ?         shift @code : '';

	my @list;
	push @list, (
	    "${lan}_${scr}_${reg}_$var",
	    "${lan}_${scr}__$var", # empty $scr should not be ${lan}__$var.
	    "${lan}_${reg}_$var",  # empty $reg may be ${lan}__$var.
	    "${lan}__$var",
	) if $var ne '';
	push @list, (
	    "${lan}_${scr}_${reg}",
	    "${lan}_${scr}",
	    "${lan}_${reg}",
	     ${lan},
	);
	for my $loc (@list) {
	    $LocaleFile{$loc} and return $loc;
	}
    }
    return 'default';
}

sub getlocale {
    return shift->{accepted_locale};
}

sub locale_version {
    return shift->{locale_version};
}

sub _fetchpl {
    my $accepted = shift;
    my $f = $LocaleFile{$accepted};
    return if !$f;
    $f .= $PL_EXT;

    # allow to search @INC
#   use File::Spec;
#   my $path = File::Spec->catfile('Unicode', 'Collate', 'Locale', $f);
    my $path = "Unicode/Collate/Locale/$f";
    my $h = do $path;
    croak "Unicode/Collate/Locale/$f can't be found" if !$h;
    return $h;
}

sub new {
    my $class = shift;
    my %hash = @_;
    $hash{accepted_locale} = _locale($hash{locale});

    if (exists $hash{table}) {
	croak "your table can't be used with Unicode::Collate::Locale";
    }

    my $href = _fetchpl($hash{accepted_locale});
    while (my($k,$v) = each %$href) {
	if (!exists $hash{$k}) {
	    $hash{$k} = $v;
	} elsif ($k eq 'entry') {
	    $hash{$k} = $v.$hash{$k};
	} else {
	    croak "$k is reserved by $hash{locale}, can't be overwritten";
	}
    }
    return $class->SUPER::new(%hash);
}

1;
__END__

MEMORANDA for developing

locale            based CLDR
----------------------------------------------------------------------------
af                22.1 = 1.8.1
ar                22.1 = 1.9.0
as                22.1 = 1.8.1
az                22.1 = 1.8.1 (type="standard")
be                22.1 = 1.9.0
bg                22.1 = 1.9.0
bn                22.1 = 2.0.1 (type="standard")
bs                22.1 = 1.9.0 (alias source="hr")
bs_Cyrl           22.1 = 22    (alias source="sr")
ca                22.1 = 1.8.1 (alt="proposed" type="standard")
cs                22.1 = 1.8.1 (type="standard")
cy                22.1 = 1.8.1
da                22.1 = 1.8.1 (type="standard") [mod aA to pass CLDR test]
de__phonebook     22.1 = 2.0   (type="phonebook")
ee                22.1 = 22
eo                22.1 = 1.8.1
es                22.1 = 1.9.0 (type="standard")
es__traditional   22.1 = 1.8.1 (type="traditional")
et                22.1 = 1.8.1
fa                22.1 = 1.8.1
fi                22.1 = 1.8.1 (type="standard" alt="proposed")
fi__phonebook     22.1 = 1.8.1 (type="phonebook")
fil               22.1 = 1.9.0 (type="standard") = 1.8.1
fo                22.1 = 1.8.1 (alt="proposed" type="standard")
fr                22.1 = 1.9.0 (fr_CA, backwards="on")
gu                22.1 = 1.9.0 (type="standard")
ha                22.1 = 1.9.0
haw               22.1 = 1.8.1
hi                22.1 = 1.9.0 (type="standard")
hr                22.1 = 1.9.0 (type="standard")
hu                22.1 = 1.8.1 (alt="proposed" type="standard")
hy                22.1 = 1.8.1
ig                22.1 = 1.8.1
is                22.1 = 1.8.1 (type="standard")
ja                22.1 = 1.8.1 (type="standard")
kk                22.1 = 1.9.0
kl                22.1 = 1.8.1 (type="standard")
kn                22.1 = 1.9.0 (type="standard")
ko                22.1 = 1.8.1 (type="standard")
kok               22.1 = 1.8.1
ln                22.1 = 2.0   (type="standard") = 1.8.1
lt                22.1 = 1.9.0
lv                22.1 = 1.9.0 (type="standard") = 1.8.1
mk                22.1 = 1.9.0
ml                22.1 = 1.9.0
mr                22.1 = 1.8.1
mt                22.1 = 1.9.0
nb                22.1 = 2.0   (type="standard")
nn                22.1 = 2.0   (type="standard")
nso               22.1 = 1.8.1
om                22.1 = 1.8.1
or                22.1 = 1.9.0
pa                22.1 = 1.8.1
pl                22.1 = 1.8.1
ro                22.1 = 1.9.0 (type="standard")
ru                22.1 = 1.9.0
sa                1.9.1 = 1.8.1 (type="standard" alt="proposed") [now /seed]
se                22.1 = 1.8.1 (type="standard")
si                22.1 = 1.9.0 (type="standard")
si__dictionary    22.1 = 1.9.0 (type="dictionary")
sk                22.1 = 1.9.0 (type="standard")
sl                22.1 = 1.8.1 (type="standard" alt="proposed")
sq                22.1 = 1.8.1 (alt="proposed" type="standard")
sr                22.1 = 1.9.0 (type="standard")
sr_Latn           22.1 = 1.8.1 (alias source="hr")
sv                22.1 = 1.9.0 (type="standard")
sv__reformed      22.1 = 1.8.1 (type="reformed")
ta                22.1 = 1.9.0
te                22.1 = 1.9.0
th                22.1 = 22
tn                22.1 = 1.8.1
to                22.1 = 22
tr                22.1 = 1.8.1 (type="standard")
uk                22.1 = 21
ur                22.1 = 1.9.0
vi                22.1 = 1.8.1
wae               22.1 = 2.0
wo                1.9.1 = 1.8.1 [now /seed]
yo                22.1 = 1.8.1
zh                22.1 = 1.8.1 (type="standard")
zh__big5han       22.1 = 1.8.1 (type="big5han")
zh__gb2312han     22.1 = 1.8.1 (type="gb2312han")
zh__pinyin        22.1 = 2.0   (type='pinyin' alt='short')
zh__stroke        22.1 = 1.9.1 (type='stroke' alt='short')
zh__zhuyin        22.1 = 22    (type='zhuyin' alt='short')
----------------------------------------------------------------------------

=head1 NAME

Unicode::Collate::Locale - Linguistic tailoring for DUCET via Unicode::Collate

=head1 SYNOPSIS

  use Unicode::Collate::Locale;

  #construct
  $Collator = Unicode::Collate::Locale->
      new(locale => $locale_name, %tailoring);

  #sort
  @sorted = $Collator->sort(@not_sorted);

  #compare
  $result = $Collator->cmp($a, $b); # returns 1, 0, or -1.

B<Note:> Strings in C<@not_sorted>, C<$a> and C<$b> are interpreted
according to Perl's Unicode support. See L<perlunicode>,
L<perluniintro>, L<perlunitut>, L<perlunifaq>, L<utf8>.
Otherwise you can use C<preprocess> (cf. C<Unicode::Collate>)
or should decode them before.

=head1 DESCRIPTION

This module provides linguistic tailoring for it
taking advantage of C<Unicode::Collate>.

=head2 Constructor

The C<new> method returns a collator object.

A parameter list for the constructor is a hash, which can include
a special key C<locale> and its value (case-insensitive) standing
for a Unicode base language code (two or three-letter).
For example, C<Unicode::Collate::Locale-E<gt>new(locale =E<gt> 'FR')>
returns a collator tailored for French.

C<$locale_name> may be suffixed with a Unicode script code (four-letter),
a Unicode region code, a Unicode language variant code. These codes are
case-insensitive, and separated with C<'_'> or C<'-'>.
E.g. C<en_US> for English in USA,
C<az_Cyrl> for Azerbaijani in the Cyrillic script,
C<es_ES_traditional> for Spanish in Spain (Traditional).

If C<$locale_name> is not available,
fallback is selected in the following order:

    1. language with a variant code
    2. language with a script code
    3. language with a region code
    4. language
    5. default

Tailoring tags provided by C<Unicode::Collate> are allowed as long as
they are not used for C<locale> support.  Esp. the C<table> tag
is always untailorable, since it is reserved for DUCET.

However C<entry> is allowed, even if it is used for C<locale> support,
to add or override mappings.

E.g. a collator for French, which ignores diacritics and case difference
(i.e. level 1), with reversed case ordering and no normalization.

    Unicode::Collate::Locale->new(
        level => 1,
        locale => 'fr',
        upper_before_lower => 1,
        normalization => undef
    )

Overriding a behavior already tailored by C<locale> is disallowed
if such a tailoring is passed to C<new()>.

    Unicode::Collate::Locale->new(
        locale => 'da',
        upper_before_lower => 0, # causes error as reserved by 'da'
    )

However C<change()> inherited from C<Unicode::Collate> allows
such a tailoring that is reserved by C<locale>. Examples:

    new(locale => 'ca')->change(backwards => undef)
    new(locale => 'da')->change(upper_before_lower => 0)
    new(locale => 'ja')->change(overrideCJK => undef)

=head2 Methods

C<Unicode::Collate::Locale> is a subclass of C<Unicode::Collate>
and methods other than C<new> are inherited from C<Unicode::Collate>.

Here is a list of additional methods:

=over 4

=item C<$Collator-E<gt>getlocale>

Returns a language code accepted and used actually on collation.
If linguistic tailoring is not provided for a language code you passed
(intensionally for some languages, or due to the incomplete implementation),
this method returns a string C<'default'> meaning no special tailoring.

=item C<$Collator-E<gt>locale_version>

(Since Unicode::Collate::Locale 0.87)
Returns the version number (perhaps C</\d\.\d\d/>) of the locale, as that
of F<Locale/*.pl>.

B<Note:> F<Locale/*.pl> that a collator uses should be identified by
a combination of return values from C<getlocale> and C<locale_version>.

=back

=head2 A list of tailorable locales

      locale name       description
    --------------------------------------------------------------
      af                Afrikaans
      ar                Arabic
      as                Assamese
      az                Azerbaijani (Azeri)
      be                Belarusian
      bg                Bulgarian
      bn                Bengali
      bs                Bosnian
      bs_Cyrl           Bosnian in Cyrillic (tailored as Serbian)
      ca                Catalan
      cs                Czech
      cy                Welsh
      da                Danish
      de__phonebook     German (umlaut as 'ae', 'oe', 'ue')
      ee                Ewe
      eo                Esperanto
      es                Spanish
      es__traditional   Spanish ('ch' and 'll' as a grapheme)
      et                Estonian
      fa                Persian
      fi                Finnish (v and w are primary equal)
      fi__phonebook     Finnish (v and w as separate characters)
      fil               Filipino
      fo                Faroese
      fr                French
      gu                Gujarati
      ha                Hausa
      haw               Hawaiian
      hi                Hindi
      hr                Croatian
      hu                Hungarian
      hy                Armenian
      ig                Igbo
      is                Icelandic
      ja                Japanese [1]
      kk                Kazakh
      kl                Kalaallisut
      kn                Kannada
      ko                Korean [2]
      kok               Konkani
      ln                Lingala
      lt                Lithuanian
      lv                Latvian
      mk                Macedonian
      ml                Malayalam
      mr                Marathi
      mt                Maltese
      nb                Norwegian Bokmal
      nn                Norwegian Nynorsk
      nso               Northern Sotho
      om                Oromo
      or                Oriya
      pa                Punjabi
      pl                Polish
      ro                Romanian
      ru                Russian
      sa                Sanskrit
      se                Northern Sami
      si                Sinhala
      si__dictionary    Sinhala (U+0DA5 = U+0DA2,0DCA,0DA4)
      sk                Slovak
      sl                Slovenian
      sq                Albanian
      sr                Serbian
      sr_Latn           Serbian in Latin (tailored as Croatian)
      sv                Swedish (v and w are primary equal)
      sv__reformed      Swedish (v and w as separate characters)
      ta                Tamil
      te                Telugu
      th                Thai
      tn                Tswana
      to                Tonga
      tr                Turkish
      uk                Ukrainian
      ur                Urdu
      vi                Vietnamese
      wae               Walser
      wo                Wolof
      yo                Yoruba
      zh                Chinese
      zh__big5han       Chinese (ideographs: big5 order)
      zh__gb2312han     Chinese (ideographs: GB-2312 order)
      zh__pinyin        Chinese (ideographs: pinyin order) [3]
      zh__stroke        Chinese (ideographs: stroke order) [3]
      zh__zhuyin        Chinese (ideographs: zhuyin order) [3]
    --------------------------------------------------------------

Locales according to the default UCA rules include
chr (Cherokee),
de (German),
en (English),
ga (Irish),
id (Indonesian),
it (Italian),
ka (Georgian),
ms (Malay),
nl (Dutch),
pt (Portuguese),
st (Southern Sotho),
sw (Swahili),
xh (Xhosa),
zu (Zulu).

B<Note>

[1] ja: Ideographs are sorted in JIS X 0208 order.
Fullwidth and halfwidth forms are identical to their regular form.
The difference between hiragana and katakana is at the 4th level,
the comparison also requires C<(variable =E<gt> 'Non-ignorable')>,
and then C<katakana_before_hiragana> has no effect.

[2] ko: Plenty of ideographs are sorted by their reading. Such
an ideograph is primary (level 1) equal to, and secondary (level 2)
greater than, the corresponding hangul syllable.

[3] zh__pinyin, zh__stroke and zh__zhuyin: implemented alt='short',
where a smaller number of ideographs are tailored.

Note: 'pinyin' is in latin, 'zhuyin' is in bopomofo.

=head1 INSTALL

Installation of C<Unicode::Collate::Locale> requires F<Collate/Locale.pm>,
F<Collate/Locale/*.pm>, F<Collate/CJK/*.pm> and F<Collate/allkeys.txt>.
On building, C<Unicode::Collate::Locale> doesn't require any of F<data/*.txt>,
F<gendata/*>, and F<mklocale>.
Tests for C<Unicode::Collate::Locale> are named F<t/loc_*.t>.

=head1 CAVEAT

=over 4

=item tailoring is not maximum

Even if a certain letter is tailored, its equivalent would not always
tailored as well as it. For example, even though W is tailored,
fullwidth W (C<U+FF37>), W with acute (C<U+1E82>), etc. are not
tailored. The result may depend on whether source strings are
normalized or not, and whether decomposed or composed.
Thus C<(normalization =E<gt> undef)> is less preferred.

=back

=head1 AUTHOR

The Unicode::Collate::Locale module for perl was written
by SADAHIRO Tomoyuki, <SADAHIRO@cpan.org>.
This module is Copyright(C) 2004-2013, SADAHIRO Tomoyuki. Japan.
All rights reserved.

This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

=head1 SEE ALSO

=over 4

=item Unicode Collation Algorithm - UTS #10

L<http://www.unicode.org/reports/tr10/>

=item The Default Unicode Collation Element Table (DUCET)

L<http://www.unicode.org/Public/UCA/latest/allkeys.txt>

=item Unicode Locale Data Markup Language (LDML) - UTS #35

L<http://www.unicode.org/reports/tr35/>

=item CLDR - Unicode Common Locale Data Repository

L<http://cldr.unicode.org/>

=item L<Unicode::Collate>

=item L<Unicode::Normalize>

=back

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     require '_h2ph_pre.ph';

no warnings qw(redefine misc);

unless(defined(&__ASM_GENERIC_IOCTLS_H)) {
    eval 'sub __ASM_GENERIC_IOCTLS_H () {1;}' unless defined(&__ASM_GENERIC_IOCTLS_H);
    require 'linux/ioctl.ph';
    eval 'sub TCGETS () {0x5401;}' unless defined(&TCGETS);
    eval 'sub TCSETS () {0x5402;}' unless defined(&TCSETS);
    eval 'sub TCSETSW () {0x5403;}' unless defined(&TCSETSW);
    eval 'sub TCSETSF () {0x5404;}' unless defined(&TCSETSF);
    eval 'sub TCGETA () {0x5405;}' unless defined(&TCGETA);
    eval 'sub TCSETA () {0x5406;}' unless defined(&TCSETA);
    eval 'sub TCSETAW () {0x5407;}' unless defined(&TCSETAW);
    eval 'sub TCSETAF () {0x5408;}' unless defined(&TCSETAF);
    eval 'sub TCSBRK () {0x5409;}' unless defined(&TCSBRK);
    eval 'sub TCXONC () {0x540a;}' unless defined(&TCXONC);
    eval 'sub TCFLSH () {0x540b;}' unless defined(&TCFLSH);
    eval 'sub TIOCEXCL () {0x540c;}' unless defined(&TIOCEXCL);
    eval 'sub TIOCNXCL () {0x540d;}' unless defined(&TIOCNXCL);
    eval 'sub TIOCSCTTY () {0x540e;}' unless defined(&TIOCSCTTY);
    eval 'sub TIOCGPGRP () {0x540f;}' unless defined(&TIOCGPGRP);
    eval 'sub TIOCSPGRP () {0x5410;}' unless defined(&TIOCSPGRP);
    eval 'sub TIOCOUTQ () {0x5411;}' unless defined(&TIOCOUTQ);
    eval 'sub TIOCSTI () {0x5412;}' unless defined(&TIOCSTI);
    eval 'sub TIOCGWINSZ () {0x5413;}' unless defined(&TIOCGWINSZ);
    eval 'sub TIOCSWINSZ () {0x5414;}' unless defined(&TIOCSWINSZ);
    eval 'sub TIOCMGET () {0x5415;}' unless defined(&TIOCMGET);
    eval 'sub TIOCMBIS () {0x5416;}' unless defined(&TIOCMBIS);
    eval 'sub TIOCMBIC () {0x5417;}' unless defined(&TIOCMBIC);
    eval 'sub TIOCMSET () {0x5418;}' unless defined(&TIOCMSET);
    eval 'sub TIOCGSOFTCAR () {0x5419;}' unless defined(&TIOCGSOFTCAR);
    eval 'sub TIOCSSOFTCAR () {0x541a;}' unless defined(&TIOCSSOFTCAR);
    eval 'sub FIONREAD () {0x541b;}' unless defined(&FIONREAD);
    eval 'sub TIOCINQ () { &FIONREAD;}' unless defined(&TIOCINQ);
    eval 'sub TIOCLINUX () {0x541c;}' unless defined(&TIOCLINUX);
    eval 'sub TIOCCONS () {0x541d;}' unless defined(&TIOCCONS);
    eval 'sub TIOCGSERIAL () {0x541e;}' unless defined(&TIOCGSERIAL);
    eval 'sub TIOCSSERIAL () {0x541f;}' unless defined(&TIOCSSERIAL);
    eval 'sub TIOCPKT () {0x5420;}' unless defined(&TIOCPKT);
    eval 'sub FIONBIO () {0x5421;}' unless defined(&FIONBIO);
    eval 'sub TIOCNOTTY () {0x5422;}' unless defined(&TIOCNOTTY);
    eval 'sub TIOCSETD () {0x5423;}' unless defined(&TIOCSETD);
    eval 'sub TIOCGETD () {0x5424;}' unless defined(&TIOCGETD);
    eval 'sub TCSBRKP () {0x5425;}' unless defined(&TCSBRKP);
    eval 'sub TIOCSBRK () {0x5427;}' unless defined(&TIOCSBRK);
    eval 'sub TIOCCBRK () {0x5428;}' unless defined(&TIOCCBRK);
    eval 'sub TIOCGSID () {0x5429;}' unless defined(&TIOCGSID);
    eval 'sub TCGETS2 () { &_IOR(ord(\'T\'), 0x2a, 1;}' unless defined(&TCGETS2);
    eval 'sub TCSETS2 () { &_IOW(ord(\'T\'), 0x2b, 1;}' unless defined(&TCSETS2);
    eval 'sub TCSETSW2 () { &_IOW(ord(\'T\'), 0x2c, 1;}' unless defined(&TCSETSW2);
    eval 'sub TCSETSF2 () { &_IOW(ord(\'T\'), 0x2d, 1;}' unless defined(&TCSETSF2);
    eval 'sub TIOCGRS485 () {0x542e;}' unless defined(&TIOCGRS485);
    unless(defined(&TIOCSRS485)) {
	eval 'sub TIOCSRS485 () {0x542f;}' unless defined(&TIOCSRS485);
    }
    eval 'sub TIOCGPTN () { &_IOR(ord(\'T\'), 0x30, \'unsigned int\');}' unless defined(&TIOCGPTN);
    eval 'sub TIOCSPTLCK () { &_IOW(ord(\'T\'), 0x31, \'int\');}' unless defined(&TIOCSPTLCK);
    eval 'sub TIOCGDEV () { &_IOR(ord(\'T\'), 0x32, \'unsigned int\');}' unless defined(&TIOCGDEV);
    eval 'sub TCGETX () {0x5432;}' unless defined(&TCGETX);
    eval 'sub TCSETX () {0x5433;}' unless defined(&TCSETX);
    eval 'sub TCSETXF () {0x5434;}' unless defined(&TCSETXF);
    eval 'sub TCSETXW () {0x5435;}' unless defined(&TCSETXW);
    eval 'sub TIOCSIG () { &_IOW(ord(\'T\'), 0x36, \'int\');}' unless defined(&TIOCSIG);
    eval 'sub TIOCVHANGUP () {0x5437;}' unless defined(&TIOCVHANGUP);
    eval 'sub TIOCGPKT () { &_IOR(ord(\'T\'), 0x38, \'int\');}' unless defined(&TIOCGPKT);
    eval 'sub TIOCGPTLCK () { &_IOR(ord(\'T\'), 0x39, \'int\');}' unless defined(&TIOCGPTLCK);
    eval 'sub TIOCGEXCL () { &_IOR(ord(\'T\'), 0x40, \'int\');}' unless defined(&TIOCGEXCL);
    eval 'sub FIONCLEX () {0x5450;}' unless defined(&FIONCLEX);
    eval 'sub FIOCLEX () {0x5451;}' unless defined(&FIOCLEX);
    eval 'sub FIOASYNC () {0x5452;}' unless defined(&FIOASYNC);
    eval 'sub TIOCSERCONFIG () {0x5453;}' unless defined(&TIOCSERCONFIG);
    eval 'sub TIOCSERGWILD () {0x5454;}' unless defined(&TIOCSERGWILD);
    eval 'sub TIOCSERSWILD () {0x5455;}' unless defined(&TIOCSERSWILD);
    eval 'sub TIOCGLCKTRMIOS () {0x5456;}' unless defined(&TIOCGLCKTRMIOS);
    eval 'sub TIOCSLCKTRMIOS () {0x5457;}' unless defined(&TIOCSLCKTRMIOS);
    eval 'sub TIOCSERGSTRUCT () {0x5458;}' unless defined(&TIOCSERGSTRUCT);
    eval 'sub TIOCSERGETLSR () {0x5459;}' unless defined(&TIOCSERGETLSR);
    eval 'sub TIOCSERGETMULTI () {0x545a;}' unless defined(&TIOCSERGETMULTI);
    eval 'sub TIOCSERSETMULTI () {0x545b;}' unless defined(&TIOCSERSETMULTI);
    eval 'sub TIOCMIWAIT () {0x545c;}' unless defined(&TIOCMIWAIT);
    eval 'sub TIOCGICOUNT () {0x545d;}' unless defined(&TIOCGICOUNT);
    unless(defined(&FIOQSIZE)) {
	eval 'sub FIOQSIZE () {0x5460;}' unless defined(&FIOQSIZE);
    }
    eval 'sub TIOCPKT_DATA () {0;}' unless defined(&TIOCPKT_DATA);
    eval 'sub TIOCPKT_FLUSHREAD () {1;}' unless defined(&TIOCPKT_FLUSHREAD);
    eval 'sub TIOCPKT_FLUSHWRITE () {2;}' unless defined(&TIOCPKT_FLUSHWRITE);
    eval 'sub TIOCPKT_STOP () {4;}' unless defined(&TIOCPKT_STOP);
    eval 'sub TIOCPKT_START () {8;}' unless defined(&TIOCPKT_START);
    eval 'sub TIOCPKT_NOSTOP () {16;}' unless defined(&TIOCPKT_NOSTOP);
    eval 'sub TIOCPKT_DOSTOP () {32;}' unless defined(&TIOCPKT_DOSTOP);
    eval 'sub TIOCPKT_IOCTL () {64;}' unless defined(&TIOCPKT_IOCTL);
    eval 'sub TIOCSER_TEMT () {0x1;}' unless defined(&TIOCSER_TEMT);
}
1;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 require '_h2ph_pre.ph';

no warnings qw(redefine misc);

unless(defined(&__ASM_GENERIC_POSIX_TYPES_H)) {
    eval 'sub __ASM_GENERIC_POSIX_TYPES_H () {1;}' unless defined(&__ASM_GENERIC_POSIX_TYPES_H);
    require 'asm/bitsperlong.ph';
    unless(defined(&__kernel_long_t)) {
    }
    unless(defined(&__kernel_ino_t)) {
    }
    unless(defined(&__kernel_mode_t)) {
    }
    unless(defined(&__kernel_pid_t)) {
    }
    unless(defined(&__kernel_ipc_pid_t)) {
    }
    unless(defined(&__kernel_uid_t)) {
    }
    unless(defined(&__kernel_suseconds_t)) {
    }
    unless(defined(&__kernel_daddr_t)) {
    }
    unless(defined(&__kernel_uid32_t)) {
    }
    unless(defined(&__kernel_old_uid_t)) {
    }
    unless(defined(&__kernel_old_dev_t)) {
    }
    unless(defined(&__kernel_size_t)) {
	if((defined(&__BITS_PER_LONG) ? &__BITS_PER_LONG : undef) != 64) {
	} else {
	}
    }
    unless(defined(&__kernel_fsid_t)) {
    }
}
1;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           require '_h2ph_pre.ph';

no warnings qw(redefine misc);

unless(defined(&__ASM_GENERIC_SOCKIOS_H)) {
    eval 'sub __ASM_GENERIC_SOCKIOS_H () {1;}' unless defined(&__ASM_GENERIC_SOCKIOS_H);
    eval 'sub FIOSETOWN () {0x8901;}' unless defined(&FIOSETOWN);
    eval 'sub SIOCSPGRP () {0x8902;}' unless defined(&SIOCSPGRP);
    eval 'sub FIOGETOWN () {0x8903;}' unless defined(&FIOGETOWN);
    eval 'sub SIOCGPGRP () {0x8904;}' unless defined(&SIOCGPGRP);
    eval 'sub SIOCATMARK () {0x8905;}' unless defined(&SIOCATMARK);
    eval 'sub SIOCGSTAMP () {0x8906;}' unless defined(&SIOCGSTAMP);
    eval 'sub SIOCGSTAMPNS () {0x8907;}' unless defined(&SIOCGSTAMPNS);
}
1;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     require '_h2ph_pre.ph';

no warnings qw(redefine misc);

unless(defined(&__ASM_GENERIC_SOCKET_H)) {
    eval 'sub __ASM_GENERIC_SOCKET_H () {1;}' unless defined(&__ASM_GENERIC_SOCKET_H);
    require 'asm/sockios.ph';
    eval 'sub SOL_SOCKET () {1;}' unless defined(&SOL_SOCKET);
    eval 'sub SO_DEBUG () {1;}' unless defined(&SO_DEBUG);
    eval 'sub SO_REUSEADDR () {2;}' unless defined(&SO_REUSEADDR);
    eval 'sub SO_TYPE () {3;}' unless defined(&SO_TYPE);
    eval 'sub SO_ERROR () {4;}' unless defined(&SO_ERROR);
    eval 'sub SO_DONTROUTE () {5;}' unless defined(&SO_DONTROUTE);
    eval 'sub SO_BROADCAST () {6;}' unless defined(&SO_BROADCAST);
    eval 'sub SO_SNDBUF () {7;}' unless defined(&SO_SNDBUF);
    eval 'sub SO_RCVBUF () {8;}' unless defined(&SO_RCVBUF);
    eval 'sub SO_SNDBUFFORCE () {32;}' unless defined(&SO_SNDBUFFORCE);
    eval 'sub SO_RCVBUFFORCE () {33;}' unless defined(&SO_RCVBUFFORCE);
    eval 'sub SO_KEEPALIVE () {9;}' unless defined(&SO_KEEPALIVE);
    eval 'sub SO_OOBINLINE () {10;}' unless defined(&SO_OOBINLINE);
    eval 'sub SO_NO_CHECK () {11;}' unless defined(&SO_NO_CHECK);
    eval 'sub SO_PRIORITY () {12;}' unless defined(&SO_PRIORITY);
    eval 'sub SO_LINGER () {13;}' unless defined(&SO_LINGER);
    eval 'sub SO_BSDCOMPAT () {14;}' unless defined(&SO_BSDCOMPAT);
    eval 'sub SO_REUSEPORT () {15;}' unless defined(&SO_REUSEPORT);
    unless(defined(&SO_PASSCRED)) {
	eval 'sub SO_PASSCRED () {16;}' unless defined(&SO_PASSCRED);
	eval 'sub SO_PEERCRED () {17;}' unless defined(&SO_PEERCRED);
	eval 'sub SO_RCVLOWAT () {18;}' unless defined(&SO_RCVLOWAT);
	eval 'sub SO_SNDLOWAT () {19;}' unless defined(&SO_SNDLOWAT);
	eval 'sub SO_RCVTIMEO () {20;}' unless defined(&SO_RCVTIMEO);
	eval 'sub SO_SNDTIMEO () {21;}' unless defined(&SO_SNDTIMEO);
    }
    eval 'sub SO_SECURITY_AUTHENTICATION () {22;}' unless defined(&SO_SECURITY_AUTHENTICATION);
    eval 'sub SO_SECURITY_ENCRYPTION_TRANSPORT () {23;}' unless defined(&SO_SECURITY_ENCRYPTION_TRANSPORT);
    eval 'sub SO_SECURITY_ENCRYPTION_NETWORK () {24;}' unless defined(&SO_SECURITY_ENCRYPTION_NETWORK);
    eval 'sub SO_BINDTODEVICE () {25;}' unless defined(&SO_BINDTODEVICE);
    eval 'sub SO_ATTACH_FILTER () {26;}' unless defined(&SO_ATTACH_FILTER);
    eval 'sub SO_DETACH_FILTER () {27;}' unless defined(&SO_DETACH_FILTER);
    eval 'sub SO_GET_FILTER () { &SO_ATTACH_FILTER;}' unless defined(&SO_GET_FILTER);
    eval 'sub SO_PEERNAME () {28;}' unless defined(&SO_PEERNAME);
    eval 'sub SO_TIMESTAMP () {29;}' unless defined(&SO_TIMESTAMP);
    eval 'sub SCM_TIMESTAMP () { &SO_TIMESTAMP;}' unless defined(&SCM_TIMESTAMP);
    eval 'sub SO_ACCEPTCONN () {30;}' unless defined(&SO_ACCEPTCONN);
    eval 'sub SO_PEERSEC () {31;}' unless defined(&SO_PEERSEC);
    eval 'sub SO_PASSSEC () {34;}' unless defined(&SO_PASSSEC);
    eval 'sub SO_TIMESTAMPNS () {35;}' unless defined(&SO_TIMESTAMPNS);
    eval 'sub SCM_TIMESTAMPNS () { &SO_TIMESTAMPNS;}' unless defined(&SCM_TIMESTAMPNS);
    eval 'sub SO_MARK () {36;}' unless defined(&SO_MARK);
    eval 'sub SO_TIMESTAMPING () {37;}' unless defined(&SO_TIMESTAMPING);
    eval 'sub SCM_TIMESTAMPING () { &SO_TIMESTAMPING;}' unless defined(&SCM_TIMESTAMPING);
    eval 'sub SO_PROTOCOL () {38;}' unless defined(&SO_PROTOCOL);
    eval 'sub SO_DOMAIN () {39;}' unless defined(&SO_DOMAIN);
    eval 'sub SO_RXQ_OVFL () {40;}' unless defined(&SO_RXQ_OVFL);
    eval 'sub SO_WIFI_STATUS () {41;}' unless defined(&SO_WIFI_STATUS);
    eval 'sub SCM_WIFI_STATUS () { &SO_WIFI_STATUS;}' unless defined(&SCM_WIFI_STATUS);
    eval 'sub SO_PEEK_OFF () {42;}' unless defined(&SO_PEEK_OFF);
    eval 'sub SO_NOFCS () {43;}' unless defined(&SO_NOFCS);
    eval 'sub SO_LOCK_FILTER () {44;}' unless defined(&SO_LOCK_FILTER);
    eval 'sub SO_SELECT_ERR_QUEUE () {45;}' unless defined(&SO_SELECT_ERR_QUEUE);
    eval 'sub SO_BUSY_POLL () {46;}' unless defined(&SO_BUSY_POLL);
    eval 'sub SO_MAX_PACING_RATE () {47;}' unless defined(&SO_MAX_PACING_RATE);
    eval 'sub SO_BPF_EXTENSIONS () {48;}' unless defined(&SO_BPF_EXTENSIONS);
    eval 'sub SO_INCOMING_CPU () {49;}' unless defined(&SO_INCOMING_CPU);
    eval 'sub SO_ATTACH_BPF () {50;}' unless defined(&SO_ATTACH_BPF);
    eval 'sub SO_DETACH_BPF () { &SO_DETACH_FILTER;}' unless defined(&SO_DETACH_BPF);
    eval 'sub SO_ATTACH_REUSEPORT_CBPF () {51;}' unless defined(&SO_ATTACH_REUSEPORT_CBPF);
    eval 'sub SO_ATTACH_REUSEPORT_EBPF () {52;}' unless defined(&SO_ATTACH_REUSEPORT_EBPF);
    eval 'sub SO_CNX_ADVICE () {53;}' unless defined(&SO_CNX_ADVICE);
}
1;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   require '_h2ph_pre.ph';

no warnings qw(redefine misc);

unless(defined(&__ASM_GENERIC_TERMBITS_H)) {
    eval 'sub __ASM_GENERIC_TERMBITS_H () {1;}' unless defined(&__ASM_GENERIC_TERMBITS_H);
    require 'linux/posix_types.ph';
    eval 'sub NCCS () {19;}' unless defined(&NCCS);
    eval 'sub VINTR () {0;}' unless defined(&VINTR);
    eval 'sub VQUIT () {1;}' unless defined(&VQUIT);
    eval 'sub VERASE () {2;}' unless defined(&VERASE);
    eval 'sub VKILL () {3;}' unless defined(&VKILL);
    eval 'sub VEOF () {4;}' unless defined(&VEOF);
    eval 'sub VTIME () {5;}' unless defined(&VTIME);
    eval 'sub VMIN () {6;}' unless defined(&VMIN);
    eval 'sub VSWTC () {7;}' unless defined(&VSWTC);
    eval 'sub VSTART () {8;}' unless defined(&VSTART);
    eval 'sub VSTOP () {9;}' unless defined(&VSTOP);
    eval 'sub VSUSP () {10;}' unless defined(&VSUSP);
    eval 'sub VEOL () {11;}' unless defined(&VEOL);
    eval 'sub VREPRINT () {12;}' unless defined(&VREPRINT);
    eval 'sub VDISCARD () {13;}' unless defined(&VDISCARD);
    eval 'sub VWERASE () {14;}' unless defined(&VWERASE);
    eval 'sub VLNEXT () {15;}' unless defined(&VLNEXT);
    eval 'sub VEOL2 () {16;}' unless defined(&VEOL2);
    eval 'sub IGNBRK () {0000001;}' unless defined(&IGNBRK);
    eval 'sub BRKINT () {0000002;}' unless defined(&BRKINT);
    eval 'sub IGNPAR () {0000004;}' unless defined(&IGNPAR);
    eval 'sub PARMRK () {0000010;}' unless defined(&PARMRK);
    eval 'sub INPCK () {0000020;}' unless defined(&INPCK);
    eval 'sub ISTRIP () {0000040;}' unless defined(&ISTRIP);
    eval 'sub INLCR () {0000100;}' unless defined(&INLCR);
    eval 'sub IGNCR () {0000200;}' unless defined(&IGNCR);
    eval 'sub ICRNL () {0000400;}' unless defined(&ICRNL);
    eval 'sub IUCLC () {0001000;}' unless defined(&IUCLC);
    eval 'sub IXON () {0002000;}' unless defined(&IXON);
    eval 'sub IXANY () {0004000;}' unless defined(&IXANY);
    eval 'sub IXOFF () {0010000;}' unless defined(&IXOFF);
    eval 'sub IMAXBEL () {0020000;}' unless defined(&IMAXBEL);
    eval 'sub IUTF8 () {0040000;}' unless defined(&IUTF8);
    eval 'sub OPOST () {0000001;}' unless defined(&OPOST);
    eval 'sub OLCUC () {0000002;}' unless defined(&OLCUC);
    eval 'sub ONLCR () {0000004;}' unless defined(&ONLCR);
    eval 'sub OCRNL () {0000010;}' unless defined(&OCRNL);
    eval 'sub ONOCR () {0000020;}' unless defined(&ONOCR);
    eval 'sub ONLRET () {0000040;}' unless defined(&ONLRET);
    eval 'sub OFILL () {0000100;}' unless defined(&OFILL);
    eval 'sub OFDEL () {0000200;}' unless defined(&OFDEL);
    eval 'sub NLDLY () {0000400;}' unless defined(&NLDLY);
    eval 'sub NL0 () {0000000;}' unless defined(&NL0);
    eval 'sub NL1 () {0000400;}' unless defined(&NL1);
    eval 'sub CRDLY () {0003000;}' unless defined(&CRDLY);
    eval 'sub CR0 () {0000000;}' unless defined(&CR0);
    eval 'sub CR1 () {0001000;}' unless defined(&CR1);
    eval 'sub CR2 () {0002000;}' unless defined(&CR2);
    eval 'sub CR3 () {0003000;}' unless defined(&CR3);
    eval 'sub TABDLY () {0014000;}' unless defined(&TABDLY);
    eval 'sub TAB0 () {0000000;}' unless defined(&TAB0);
    eval 'sub TAB1 () {0004000;}' unless defined(&TAB1);
    eval 'sub TAB2 () {0010000;}' unless defined(&TAB2);
    eval 'sub TAB3 () {0014000;}' unless defined(&TAB3);
    eval 'sub XTABS () {0014000;}' unless defined(&XTABS);
    eval 'sub BSDLY () {0020000;}' unless defined(&BSDLY);
    eval 'sub BS0 () {0000000;}' unless defined(&BS0);
    eval 'sub BS1 () {0020000;}' unless defined(&BS1);
    eval 'sub VTDLY () {0040000;}' unless defined(&VTDLY);
    eval 'sub VT0 () {0000000;}' unless defined(&VT0);
    eval 'sub VT1 () {0040000;}' unless defined(&VT1);
    eval 'sub FFDLY () {0100000;}' unless defined(&FFDLY);
    eval 'sub FF0 () {0000000;}' unless defined(&FF0);
    eval 'sub FF1 () {0100000;}' unless defined(&FF1);
    eval 'sub CBAUD () {0010017;}' unless defined(&CBAUD);
    eval 'sub B0 () {0000000;}' unless defined(&B0);
    eval 'sub B50 () {0000001;}' unless defined(&B50);
    eval 'sub B75 () {0000002;}' unless defined(&B75);
    eval 'sub B110 () {0000003;}' unless defined(&B110);
    eval 'sub B134 () {0000004;}' unless defined(&B134);
    eval 'sub B150 () {0000005;}' unless defined(&B150);
    eval 'sub B200 () {0000006;}' unless defined(&B200);
    eval 'sub B300 () {0000007;}' unless defined(&B300);
    eval 'sub B600 () {0000010;}' unless defined(&B600);
    eval 'sub B1200 () {0000011;}' unless defined(&B1200);
    eval 'sub B1800 () {0000012;}' unless defined(&B1800);
    eval 'sub B2400 () {0000013;}' unless defined(&B2400);
    eval 'sub B4800 () {0000014;}' unless defined(&B4800);
    eval 'sub B9600 () {0000015;}' unless defined(&B9600);
    eval 'sub B19200 () {0000016;}' unless defined(&B19200);
    eval 'sub B38400 () {0000017;}' unless defined(&B38400);
    eval 'sub EXTA () { &B19200;}' unless defined(&EXTA);
    eval 'sub EXTB () { &B38400;}' unless defined(&EXTB);
    eval 'sub CSIZE () {0000060;}' unless defined(&CSIZE);
    eval 'sub CS5 () {0000000;}' unless defined(&CS5);
    eval 'sub CS6 () {0000020;}' unless defined(&CS6);
    eval 'sub CS7 () {0000040;}' unless defined(&CS7);
    eval 'sub CS8 () {0000060;}' unless defined(&CS8);
    eval 'sub CSTOPB () {0000100;}' unless defined(&CSTOPB);
    eval 'sub CREAD () {0000200;}' unless defined(&CREAD);
    eval 'sub PARENB () {0000400;}' unless defined(&PARENB);
    eval 'sub PARODD () {0001000;}' unless defined(&PARODD);
    eval 'sub HUPCL () {0002000;}' unless defined(&HUPCL);
    eval 'sub CLOCAL () {0004000;}' unless defined(&CLOCAL);
    eval 'sub CBAUDEX () {0010000;}' unless defined(&CBAUDEX);
    eval 'sub BOTHER () {0010000;}' unless defined(&BOTHER);
    eval 'sub B57600 () {0010001;}' unless defined(&B57600);
    eval 'sub B115200 () {0010002;}' unless defined(&B115200);
    eval 'sub B230400 () {0010003;}' unless defined(&B230400);
    eval 'sub B460800 () {0010004;}' unless defined(&B460800);
    eval 'sub B500000 () {0010005;}' unless defined(&B500000);
    eval 'sub B576000 () {0010006;}' unless defined(&B576000);
    eval 'sub B921600 () {0010007;}' unless defined(&B921600);
    eval 'sub B1000000 () {0010010;}' unless defined(&B1000000);
    eval 'sub B1152000 () {0010011;}' unless defined(&B1152000);
    eval 'sub B1500000 () {0010012;}' unless defined(&B1500000);
    eval 'sub B2000000 () {0010013;}' unless defined(&B2000000);
    eval 'sub B2500000 () {0010014;}' unless defined(&B2500000);
    eval 'sub B3000000 () {0010015;}' unless defined(&B3000000);
    eval 'sub B3500000 () {0010016;}' unless defined(&B3500000);
    eval 'sub B4000000 () {0010017;}' unless defined(&B4000000);
    eval 'sub CIBAUD () {002003600000;}' unless defined(&CIBAUD);
    eval 'sub CMSPAR () {010000000000;}' unless defined(&CMSPAR);
    eval 'sub CRTSCTS () {020000000000;}' unless defined(&CRTSCTS);
    eval 'sub IBSHIFT () {16;}' unless defined(&IBSHIFT);
    eval 'sub ISIG () {0000001;}' unless defined(&ISIG);
    eval 'sub ICANON () {0000002;}' unless defined(&ICANON);
    eval 'sub XCASE () {0000004;}' unless defined(&XCASE);
    eval 'sub ECHO () {0000010;}' unless defined(&ECHO);
    eval 'sub ECHOE () {0000020;}' unless defined(&ECHOE);
    eval 'sub ECHOK () {0000040;}' unless defined(&ECHOK);
    eval 'sub ECHONL () {0000100;}' unless defined(&ECHONL);
    eval 'sub NOFLSH () {0000200;}' unless defined(&NOFLSH);
    eval 'sub TOSTOP () {0000400;}' unless defined(&TOSTOP);
    eval 'sub ECHOCTL () {0001000;}' unless defined(&ECHOCTL);
    eval 'sub ECHOPRT () {0002000;}' unless defined(&ECHOPRT);
    eval 'sub ECHOKE () {0004000;}' unless defined(&ECHOKE);
    eval 'sub FLUSHO () {0010000;}' unless defined(&FLUSHO);
    eval 'sub PENDIN () {0040000;}' unless defined(&PENDIN);
    eval 'sub IEXTEN () {0100000;}' unless defined(&IEXTEN);
    eval 'sub EXTPROC () {0200000;}' unless defined(&EXTPROC);
    eval 'sub TCOOFF () {0;}' unless defined(&TCOOFF);
    eval 'sub TCOON () {1;}' unless defined(&TCOON);
    eval 'sub TCIOFF () {2;}' unless defined(&TCIOFF);
    eval 'sub TCION () {3;}' unless defined(&TCION);
    eval 'sub TCIFLUSH () {0;}' unless defined(&TCIFLUSH);
    eval 'sub TCOFLUSH () {1;}' unless defined(&TCOFLUSH);
    eval 'sub TCIOFLUSH () {2;}' unless defined(&TCIOFLUSH);
    eval 'sub TCSANOW () {0;}' unless defined(&TCSANOW);
    eval 'sub TCSADRAIN () {1;}' unless defined(&TCSADRAIN);
    eval 'sub TCSAFLUSH () {2;}' unless defined(&TCSAFLUSH);
}
1;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       require '_h2ph_pre.ph';

no warnings qw(redefine misc);

unless(defined(&_ASM_GENERIC_TERMIOS_H)) {
    eval 'sub _ASM_GENERIC_TERMIOS_H () {1;}' unless defined(&_ASM_GENERIC_TERMIOS_H);
    require 'asm/termbits.ph';
    require 'asm/ioctls.ph';
    eval 'sub NCC () {8;}' unless defined(&NCC);
    eval 'sub TIOCM_LE () {0x1;}' unless defined(&TIOCM_LE);
    eval 'sub TIOCM_DTR () {0x2;}' unless defined(&TIOCM_DTR);
    eval 'sub TIOCM_RTS () {0x4;}' unless defined(&TIOCM_RTS);
    eval 'sub TIOCM_ST () {0x8;}' unless defined(&TIOCM_ST);
    eval 'sub TIOCM_SR () {0x10;}' unless defined(&TIOCM_SR);
    eval 'sub TIOCM_CTS () {0x20;}' unless defined(&TIOCM_CTS);
    eval 'sub TIOCM_CAR () {0x40;}' unless defined(&TIOCM_CAR);
    eval 'sub TIOCM_RNG () {0x80;}' unless defined(&TIOCM_RNG);
    eval 'sub TIOCM_DSR () {0x100;}' unless defined(&TIOCM_DSR);
    eval 'sub TIOCM_CD () { &TIOCM_CAR;}' unless defined(&TIOCM_CD);
    eval 'sub TIOCM_RI () { &TIOCM_RNG;}' unless defined(&TIOCM_RI);
    eval 'sub TIOCM_OUT1 () {0x2000;}' unless defined(&TIOCM_OUT1);
    eval 'sub TIOCM_OUT2 () {0x4000;}' unless defined(&TIOCM_OUT2);
    eval 'sub TIOCM_LOOP () {0x8000;}' unless defined(&TIOCM_LOOP);
}
1;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      require '_h2ph_pre.ph';

no warnings qw(redefine misc);

require 'asm-generic/bitsperlong.ph';
1;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              require '_h2ph_pre.ph';

no warnings qw(redefine misc);

require 'asm-generic/ioctl.ph';
1;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    require '_h2ph_pre.ph';

no warnings qw(redefine misc);

unless(defined(&__ASM_ARM_IOCTLS_H)) {
    eval 'sub __ASM_ARM_IOCTLS_H () {1;}' unless defined(&__ASM_ARM_IOCTLS_H);
    eval 'sub FIOQSIZE () {0x545e;}' unless defined(&FIOQSIZE);
    require 'asm-generic/ioctls.ph';
}
1;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       require '_h2ph_pre.ph';

no warnings qw(redefine misc);

unless(defined(&__ARCH_ARM_POSIX_TYPES_H)) {
    eval 'sub __ARCH_ARM_POSIX_TYPES_H () {1;}' unless defined(&__ARCH_ARM_POSIX_TYPES_H);
    require 'asm-generic/posix_types.ph';
}
1;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                require '_h2ph_pre.ph';

no warnings qw(redefine misc);

unless(defined(&_ASMARM_SIGCONTEXT_H)) {
    eval 'sub _ASMARM_SIGCONTEXT_H () {1;}' unless defined(&_ASMARM_SIGCONTEXT_H);
}
1;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      require '_h2ph_pre.ph';

no warnings qw(redefine misc);

require 'asm-generic/socket.ph';
1;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   require '_h2ph_pre.ph';

no warnings qw(redefine misc);

require 'asm-generic/sockios.ph';
1;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  require '_h2ph_pre.ph';

no warnings qw(redefine misc);

require 'asm-generic/termbits.ph';
1;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 require '_h2ph_pre.ph';

no warnings qw(redefine misc);

require 'asm-generic/termios.ph';
1;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  require '_h2ph_pre.ph';

no warnings qw(redefine misc);

unless(defined(&__ASM_ARM_UNISTD_H)) {
    eval 'sub __ASM_ARM_UNISTD_H () {1;}' unless defined(&__ASM_ARM_UNISTD_H);
    eval 'sub __NR_OABI_SYSCALL_BASE () {0x900000;}' unless defined(&__NR_OABI_SYSCALL_BASE);
    if(defined(&__thumb__) || defined(&__ARM_EABI__)) {
	eval 'sub __NR_SYSCALL_BASE () {0;}' unless defined(&__NR_SYSCALL_BASE);
    } else {
	eval 'sub __NR_SYSCALL_BASE () { &__NR_OABI_SYSCALL_BASE;}' unless defined(&__NR_SYSCALL_BASE);
    }
    eval 'sub __NR_restart_syscall () {( &__NR_SYSCALL_BASE+ 0);}' unless defined(&__NR_restart_syscall);
    eval 'sub __NR_exit () {( &__NR_SYSCALL_BASE+ 1);}' unless defined(&__NR_exit);
    eval 'sub __NR_fork () {( &__NR_SYSCALL_BASE+ 2);}' unless defined(&__NR_fork);
    eval 'sub __NR_read () {( &__NR_SYSCALL_BASE+ 3);}' unless defined(&__NR_read);
    eval 'sub __NR_write () {( &__NR_SYSCALL_BASE+ 4);}' unless defined(&__NR_write);
    eval 'sub __NR_open () {( &__NR_SYSCALL_BASE+ 5);}' unless defined(&__NR_open);
    eval 'sub __NR_close () {( &__NR_SYSCALL_BASE+ 6);}' unless defined(&__NR_close);
    eval 'sub __NR_creat () {( &__NR_SYSCALL_BASE+ 8);}' unless defined(&__NR_creat);
    eval 'sub __NR_link () {( &__NR_SYSCALL_BASE+ 9);}' unless defined(&__NR_link);
    eval 'sub __NR_unlink () {( &__NR_SYSCALL_BASE+ 10);}' unless defined(&__NR_unlink);
    eval 'sub __NR_execve () {( &__NR_SYSCALL_BASE+ 11);}' unless defined(&__NR_execve);
    eval 'sub __NR_chdir () {( &__NR_SYSCALL_BASE+ 12);}' unless defined(&__NR_chdir);
    eval 'sub __NR_time () {( &__NR_SYSCALL_BASE+ 13);}' unless defined(&__NR_time);
    eval 'sub __NR_mknod () {( &__NR_SYSCALL_BASE+ 14);}' unless defined(&__NR_mknod);
    eval 'sub __NR_chmod () {( &__NR_SYSCALL_BASE+ 15);}' unless defined(&__NR_chmod);
    eval 'sub __NR_lchown () {( &__NR_SYSCALL_BASE+ 16);}' unless defined(&__NR_lchown);
    eval 'sub __NR_lseek () {( &__NR_SYSCALL_BASE+ 19);}' unless defined(&__NR_lseek);
    eval 'sub __NR_getpid () {( &__NR_SYSCALL_BASE+ 20);}' unless defined(&__NR_getpid);
    eval 'sub __NR_mount () {( &__NR_SYSCALL_BASE+ 21);}' unless defined(&__NR_mount);
    eval 'sub __NR_umount () {( &__NR_SYSCALL_BASE+ 22);}' unless defined(&__NR_umount);
    eval 'sub __NR_setuid () {( &__NR_SYSCALL_BASE+ 23);}' unless defined(&__NR_setuid);
    eval 'sub __NR_getuid () {( &__NR_SYSCALL_BASE+ 24);}' unless defined(&__NR_getuid);
    eval 'sub __NR_stime () {( &__NR_SYSCALL_BASE+ 25);}' unless defined(&__NR_stime);
    eval 'sub __NR_ptrace () {( &__NR_SYSCALL_BASE+ 26);}' unless defined(&__NR_ptrace);
    eval 'sub __NR_alarm () {( &__NR_SYSCALL_BASE+ 27);}' unless defined(&__NR_alarm);
    eval 'sub __NR_pause () {( &__NR_SYSCALL_BASE+ 29);}' unless defined(&__NR_pause);
    eval 'sub __NR_utime () {( &__NR_SYSCALL_BASE+ 30);}' unless defined(&__NR_utime);
    eval 'sub __NR_access () {( &__NR_SYSCALL_BASE+ 33);}' unless defined(&__NR_access);
    eval 'sub __NR_nice () {( &__NR_SYSCALL_BASE+ 34);}' unless defined(&__NR_nice);
    eval 'sub __NR_sync () {( &__NR_SYSCALL_BASE+ 36);}' unless defined(&__NR_sync);
    eval 'sub __NR_kill () {( &__NR_SYSCALL_BASE+ 37);}' unless defined(&__NR_kill);
    eval 'sub __NR_rename () {( &__NR_SYSCALL_BASE+ 38);}' unless defined(&__NR_rename);
    eval 'sub __NR_mkdir () {( &__NR_SYSCALL_BASE+ 39);}' unless defined(&__NR_mkdir);
    eval 'sub __NR_rmdir () {( &__NR_SYSCALL_BASE+ 40);}' unless defined(&__NR_rmdir);
    eval 'sub __NR_dup () {( &__NR_SYSCALL_BASE+ 41);}' unless defined(&__NR_dup);
    eval 'sub __NR_pipe () {( &__NR_SYSCALL_BASE+ 42);}' unless defined(&__NR_pipe);
    eval 'sub __NR_times () {( &__NR_SYSCALL_BASE+ 43);}' unless defined(&__NR_times);
    eval 'sub __NR_brk () {( &__NR_SYSCALL_BASE+ 45);}' unless defined(&__NR_brk);
    eval 'sub __NR_setgid () {( &__NR_SYSCALL_BASE+ 46);}' unless defined(&__NR_setgid);
    eval 'sub __NR_getgid () {( &__NR_SYSCALL_BASE+ 47);}' unless defined(&__NR_getgid);
    eval 'sub __NR_geteuid () {( &__NR_SYSCALL_BASE+ 49);}' unless defined(&__NR_geteuid);
    eval 'sub __NR_getegid () {( &__NR_SYSCALL_BASE+ 50);}' unless defined(&__NR_getegid);
    eval 'sub __NR_acct () {( &__NR_SYSCALL_BASE+ 51);}' unless defined(&__NR_acct);
    eval 'sub __NR_umount2 () {( &__NR_SYSCALL_BASE+ 52);}' unless defined(&__NR_umount2);
    eval 'sub __NR_ioctl () {( &__NR_SYSCALL_BASE+ 54);}' unless defined(&__NR_ioctl);
    eval 'sub __NR_fcntl () {( &__NR_SYSCALL_BASE+ 55);}' unless defined(&__NR_fcntl);
    eval 'sub __NR_setpgid () {( &__NR_SYSCALL_BASE+ 57);}' unless defined(&__NR_setpgid);
    eval 'sub __NR_umask () {( &__NR_SYSCALL_BASE+ 60);}' unless defined(&__NR_umask);
    eval 'sub __NR_chroot () {( &__NR_SYSCALL_BASE+ 61);}' unless defined(&__NR_chroot);
    eval 'sub __NR_ustat () {( &__NR_SYSCALL_BASE+ 62);}' unless defined(&__NR_ustat);
    eval 'sub __NR_dup2 () {( &__NR_SYSCALL_BASE+ 63);}' unless defined(&__NR_dup2);
    eval 'sub __NR_getppid () {( &__NR_SYSCALL_BASE+ 64);}' unless defined(&__NR_getppid);
    eval 'sub __NR_getpgrp () {( &__NR_SYSCALL_BASE+ 65);}' unless defined(&__NR_getpgrp);
    eval 'sub __NR_setsid () {( &__NR_SYSCALL_BASE+ 66);}' unless defined(&__NR_setsid);
    eval 'sub __NR_sigaction () {( &__NR_SYSCALL_BASE+ 67);}' unless defined(&__NR_sigaction);
    eval 'sub __NR_setreuid () {( &__NR_SYSCALL_BASE+ 70);}' unless defined(&__NR_setreuid);
    eval 'sub __NR_setregid () {( &__NR_SYSCALL_BASE+ 71);}' unless defined(&__NR_setregid);
    eval 'sub __NR_sigsuspend () {( &__NR_SYSCALL_BASE+ 72);}' unless defined(&__NR_sigsuspend);
    eval 'sub __NR_sigpending () {( &__NR_SYSCALL_BASE+ 73);}' unless defined(&__NR_sigpending);
    eval 'sub __NR_sethostname () {( &__NR_SYSCALL_BASE+ 74);}' unless defined(&__NR_sethostname);
    eval 'sub __NR_setrlimit () {( &__NR_SYSCALL_BASE+ 75);}' unless defined(&__NR_setrlimit);
    eval 'sub __NR_getrlimit () {( &__NR_SYSCALL_BASE+ 76);}' unless defined(&__NR_getrlimit);
    eval 'sub __NR_getrusage () {( &__NR_SYSCALL_BASE+ 77);}' unless defined(&__NR_getrusage);
    eval 'sub __NR_gettimeofday () {( &__NR_SYSCALL_BASE+ 78);}' unless defined(&__NR_gettimeofday);
    eval 'sub __NR_settimeofday () {( &__NR_SYSCALL_BASE+ 79);}' unless defined(&__NR_settimeofday);
    eval 'sub __NR_getgroups () {( &__NR_SYSCALL_BASE+ 80);}' unless defined(&__NR_getgroups);
    eval 'sub __NR_setgroups () {( &__NR_SYSCALL_BASE+ 81);}' unless defined(&__NR_setgroups);
    eval 'sub __NR_select () {( &__NR_SYSCALL_BASE+ 82);}' unless defined(&__NR_select);
    eval 'sub __NR_symlink () {( &__NR_SYSCALL_BASE+ 83);}' unless defined(&__NR_symlink);
    eval 'sub __NR_readlink () {( &__NR_SYSCALL_BASE+ 85);}' unless defined(&__NR_readlink);
    eval 'sub __NR_uselib () {( &__NR_SYSCALL_BASE+ 86);}' unless defined(&__NR_uselib);
    eval 'sub __NR_swapon () {( &__NR_SYSCALL_BASE+ 87);}' unless defined(&__NR_swapon);
    eval 'sub __NR_reboot () {( &__NR_SYSCALL_BASE+ 88);}' unless defined(&__NR_reboot);
    eval 'sub __NR_readdir () {( &__NR_SYSCALL_BASE+ 89);}' unless defined(&__NR_readdir);
    eval 'sub __NR_mmap () {( &__NR_SYSCALL_BASE+ 90);}' unless defined(&__NR_mmap);
    eval 'sub __NR_munmap () {( &__NR_SYSCALL_BASE+ 91);}' unless defined(&__NR_munmap);
    eval 'sub __NR_truncate () {( &__NR_SYSCALL_BASE+ 92);}' unless defined(&__NR_truncate);
    eval 'sub __NR_ftruncate () {( &__NR_SYSCALL_BASE+ 93);}' unless defined(&__NR_ftruncate);
    eval 'sub __NR_fchmod () {( &__NR_SYSCALL_BASE+ 94);}' unless defined(&__NR_fchmod);
    eval 'sub __NR_fchown () {( &__NR_SYSCALL_BASE+ 95);}' unless defined(&__NR_fchown);
    eval 'sub __NR_getpriority () {( &__NR_SYSCALL_BASE+ 96);}' unless defined(&__NR_getpriority);
    eval 'sub __NR_setpriority () {( &__NR_SYSCALL_BASE+ 97);}' unless defined(&__NR_setpriority);
    eval 'sub __NR_statfs () {( &__NR_SYSCALL_BASE+ 99);}' unless defined(&__NR_statfs);
    eval 'sub __NR_fstatfs () {( &__NR_SYSCALL_BASE+100);}' unless defined(&__NR_fstatfs);
    eval 'sub __NR_socketcall () {( &__NR_SYSCALL_BASE+102);}' unless defined(&__NR_socketcall);
    eval 'sub __NR_syslog () {( &__NR_SYSCALL_BASE+103);}' unless defined(&__NR_syslog);
    eval 'sub __NR_setitimer () {( &__NR_SYSCALL_BASE+104);}' unless defined(&__NR_setitimer);
    eval 'sub __NR_getitimer () {( &__NR_SYSCALL_BASE+105);}' unless defined(&__NR_getitimer);
    eval 'sub __NR_stat () {( &__NR_SYSCALL_BASE+106);}' unless defined(&__NR_stat);
    eval 'sub __NR_lstat () {( &__NR_SYSCALL_BASE+107);}' unless defined(&__NR_lstat);
    eval 'sub __NR_fstat () {( &__NR_SYSCALL_BASE+108);}' unless defined(&__NR_fstat);
    eval 'sub __NR_vhangup () {( &__NR_SYSCALL_BASE+111);}' unless defined(&__NR_vhangup);
    eval 'sub __NR_syscall () {( &__NR_SYSCALL_BASE+113);}' unless defined(&__NR_syscall);
    eval 'sub __NR_wait4 () {( &__NR_SYSCALL_BASE+114);}' unless defined(&__NR_wait4);
    eval 'sub __NR_swapoff () {( &__NR_SYSCALL_BASE+115);}' unless defined(&__NR_swapoff);
    eval 'sub __NR_sysinfo () {( &__NR_SYSCALL_BASE+116);}' unless defined(&__NR_sysinfo);
    eval 'sub __NR_ipc () {( &__NR_SYSCALL_BASE+117);}' unless defined(&__NR_ipc);
    eval 'sub __NR_fsync () {( &__NR_SYSCALL_BASE+118);}' unless defined(&__NR_fsync);
    eval 'sub __NR_sigreturn () {( &__NR_SYSCALL_BASE+119);}' unless defined(&__NR_sigreturn);
    eval 'sub __NR_clone () {( &__NR_SYSCALL_BASE+120);}' unless defined(&__NR_clone);
    eval 'sub __NR_setdomainname () {( &__NR_SYSCALL_BASE+121);}' unless defined(&__NR_setdomainname);
    eval 'sub __NR_uname () {( &__NR_SYSCALL_BASE+122);}' unless defined(&__NR_uname);
    eval 'sub __NR_adjtimex () {( &__NR_SYSCALL_BASE+124);}' unless defined(&__NR_adjtimex);
    eval 'sub __NR_mprotect () {( &__NR_SYSCALL_BASE+125);}' unless defined(&__NR_mprotect);
    eval 'sub __NR_sigprocmask () {( &__NR_SYSCALL_BASE+126);}' unless defined(&__NR_sigprocmask);
    eval 'sub __NR_init_module () {( &__NR_SYSCALL_BASE+128);}' unless defined(&__NR_init_module);
    eval 'sub __NR_delete_module () {( &__NR_SYSCALL_BASE+129);}' unless defined(&__NR_delete_module);
    eval 'sub __NR_quotactl () {( &__NR_SYSCALL_BASE+131);}' unless defined(&__NR_quotactl);
    eval 'sub __NR_getpgid () {( &__NR_SYSCALL_BASE+132);}' unless defined(&__NR_getpgid);
    eval 'sub __NR_fchdir () {( &__NR_SYSCALL_BASE+133);}' unless defined(&__NR_fchdir);
    eval 'sub __NR_bdflush () {( &__NR_SYSCALL_BASE+134);}' unless defined(&__NR_bdflush);
    eval 'sub __NR_sysfs () {( &__NR_SYSCALL_BASE+135);}' unless defined(&__NR_sysfs);
    eval 'sub __NR_personality () {( &__NR_SYSCALL_BASE+136);}' unless defined(&__NR_personality);
    eval 'sub __NR_setfsuid () {( &__NR_SYSCALL_BASE+138);}' unless defined(&__NR_setfsuid);
    eval 'sub __NR_setfsgid () {( &__NR_SYSCALL_BASE+139);}' unless defined(&__NR_setfsgid);
    eval 'sub __NR__llseek () {( &__NR_SYSCALL_BASE+140);}' unless defined(&__NR__llseek);
    eval 'sub __NR_getdents () {( &__NR_SYSCALL_BASE+141);}' unless defined(&__NR_getdents);
    eval 'sub __NR__newselect () {( &__NR_SYSCALL_BASE+142);}' unless defined(&__NR__newselect);
    eval 'sub __NR_flock () {( &__NR_SYSCALL_BASE+143);}' unless defined(&__NR_flock);
    eval 'sub __NR_msync () {( &__NR_SYSCALL_BASE+144);}' unless defined(&__NR_msync);
    eval 'sub __NR_readv () {( &__NR_SYSCALL_BASE+145);}' unless defined(&__NR_readv);
    eval 'sub __NR_writev () {( &__NR_SYSCALL_BASE+146);}' unless defined(&__NR_writev);
    eval 'sub __NR_getsid () {( &__NR_SYSCALL_BASE+147);}' unless defined(&__NR_getsid);
    eval 'sub __NR_fdatasync () {( &__NR_SYSCALL_BASE+148);}' unless defined(&__NR_fdatasync);
    eval 'sub __NR__sysctl () {( &__NR_SYSCALL_BASE+149);}' unless defined(&__NR__sysctl);
    eval 'sub __NR_mlock () {( &__NR_SYSCALL_BASE+150);}' unless defined(&__NR_mlock);
    eval 'sub __NR_munlock () {( &__NR_SYSCALL_BASE+151);}' unless defined(&__NR_munlock);
    eval 'sub __NR_mlockall () {( &__NR_SYSCALL_BASE+152);}' unless defined(&__NR_mlockall);
    eval 'sub __NR_munlockall () {( &__NR_SYSCALL_BASE+153);}' unless defined(&__NR_munlockall);
    eval 'sub __NR_sched_setparam () {( &__NR_SYSCALL_BASE+154);}' unless defined(&__NR_sched_setparam);
    eval 'sub __NR_sched_getparam () {( &__NR_SYSCALL_BASE+155);}' unless defined(&__NR_sched_getparam);
    eval 'sub __NR_sched_setscheduler () {( &__NR_SYSCALL_BASE+156);}' unless defined(&__NR_sched_setscheduler);
    eval 'sub __NR_sched_getscheduler () {( &__NR_SYSCALL_BASE+157);}' unless defined(&__NR_sched_getscheduler);
    eval 'sub __NR_sched_yield () {( &__NR_SYSCALL_BASE+158);}' unless defined(&__NR_sched_yield);
    eval 'sub __NR_sched_get_priority_max () {( &__NR_SYSCALL_BASE+159);}' unless defined(&__NR_sched_get_priority_max);
    eval 'sub __NR_sched_get_priority_min () {( &__NR_SYSCALL_BASE+160);}' unless defined(&__NR_sched_get_priority_min);
    eval 'sub __NR_sched_rr_get_interval () {( &__NR_SYSCALL_BASE+161);}' unless defined(&__NR_sched_rr_get_interval);
    eval 'sub __NR_nanosleep () {( &__NR_SYSCALL_BASE+162);}' unless defined(&__NR_nanosleep);
    eval 'sub __NR_mremap () {( &__NR_SYSCALL_BASE+163);}' unless defined(&__NR_mremap);
    eval 'sub __NR_setresuid () {( &__NR_SYSCALL_BASE+164);}' unless defined(&__NR_setresuid);
    eval 'sub __NR_getresuid () {( &__NR_SYSCALL_BASE+165);}' unless defined(&__NR_getresuid);
    eval 'sub __NR_poll () {( &__NR_SYSCALL_BASE+168);}' unless defined(&__NR_poll);
    eval 'sub __NR_nfsservctl () {( &__NR_SYSCALL_BASE+169);}' unless defined(&__NR_nfsservctl);
    eval 'sub __NR_setresgid () {( &__NR_SYSCALL_BASE+170);}' unless defined(&__NR_setresgid);
    eval 'sub __NR_getresgid () {( &__NR_SYSCALL_BASE+171);}' unless defined(&__NR_getresgid);
    eval 'sub __NR_prctl () {( &__NR_SYSCALL_BASE+172);}' unless defined(&__NR_prctl);
    eval 'sub __NR_rt_sigreturn () {( &__NR_SYSCALL_BASE+173);}' unless defined(&__NR_rt_sigreturn);
    eval 'sub __NR_rt_sigaction () {( &__NR_SYSCALL_BASE+174);}' unless defined(&__NR_rt_sigaction);
    eval 'sub __NR_rt_sigprocmask () {( &__NR_SYSCALL_BASE+175);}' unless defined(&__NR_rt_sigprocmask);
    eval 'sub __NR_rt_sigpending () {( &__NR_SYSCALL_BASE+176);}' unless defined(&__NR_rt_sigpending);
    eval 'sub __NR_rt_sigtimedwait () {( &__NR_SYSCALL_BASE+177);}' unless defined(&__NR_rt_sigtimedwait);
    eval 'sub __NR_rt_sigqueueinfo () {( &__NR_SYSCALL_BASE+178);}' unless defined(&__NR_rt_sigqueueinfo);
    eval 'sub __NR_rt_sigsuspend () {( &__NR_SYSCALL_BASE+179);}' unless defined(&__NR_rt_sigsuspend);
    eval 'sub __NR_pread64 () {( &__NR_SYSCALL_BASE+180);}' unless defined(&__NR_pread64);
    eval 'sub __NR_pwrite64 () {( &__NR_SYSCALL_BASE+181);}' unless defined(&__NR_pwrite64);
    eval 'sub __NR_chown () {( &__NR_SYSCALL_BASE+182);}' unless defined(&__NR_chown);
    eval 'sub __NR_getcwd () {( &__NR_SYSCALL_BASE+183);}' unless defined(&__NR_getcwd);
    eval 'sub __NR_capget () {( &__NR_SYSCALL_BASE+184);}' unless defined(&__NR_capget);
    eval 'sub __NR_capset () {( &__NR_SYSCALL_BASE+185);}' unless defined(&__NR_capset);
    eval 'sub __NR_sigaltstack () {( &__NR_SYSCALL_BASE+186);}' unless defined(&__NR_sigaltstack);
    eval 'sub __NR_sendfile () {( &__NR_SYSCALL_BASE+187);}' unless defined(&__NR_sendfile);
    eval 'sub __NR_vfork () {( &__NR_SYSCALL_BASE+190);}' unless defined(&__NR_vfork);
    eval 'sub __NR_ugetrlimit () {( &__NR_SYSCALL_BASE+191);}' unless defined(&__NR_ugetrlimit);
    eval 'sub __NR_mmap2 () {( &__NR_SYSCALL_BASE+192);}' unless defined(&__NR_mmap2);
    eval 'sub __NR_truncate64 () {( &__NR_SYSCALL_BASE+193);}' unless defined(&__NR_truncate64);
    eval 'sub __NR_ftruncate64 () {( &__NR_SYSCALL_BASE+194);}' unless defined(&__NR_ftruncate64);
    eval 'sub __NR_stat64 () {( &__NR_SYSCALL_BASE+195);}' unless defined(&__NR_stat64);
    eval 'sub __NR_lstat64 () {( &__NR_SYSCALL_BASE+196);}' unless defined(&__NR_lstat64);
    eval 'sub __NR_fstat64 () {( &__NR_SYSCALL_BASE+197);}' unless defined(&__NR_fstat64);
    eval 'sub __NR_lchown32 () {( &__NR_SYSCALL_BASE+198);}' unless defined(&__NR_lchown32);
    eval 'sub __NR_getuid32 () {( &__NR_SYSCALL_BASE+199);}' unless defined(&__NR_getuid32);
    eval 'sub __NR_getgid32 () {( &__NR_SYSCALL_BASE+200);}' unless defined(&__NR_getgid32);
    eval 'sub __NR_geteuid32 () {( &__NR_SYSCALL_BASE+201);}' unless defined(&__NR_geteuid32);
    eval 'sub __NR_getegid32 () {( &__NR_SYSCALL_BASE+202);}' unless defined(&__NR_getegid32);
    eval 'sub __NR_setreuid32 () {( &__NR_SYSCALL_BASE+203);}' unless defined(&__NR_setreuid32);
    eval 'sub __NR_setregid32 () {( &__NR_SYSCALL_BASE+204);}' unless defined(&__NR_setregid32);
    eval 'sub __NR_getgroups32 () {( &__NR_SYSCALL_BASE+205);}' unless defined(&__NR_getgroups32);
    eval 'sub __NR_setgroups32 () {( &__NR_SYSCALL_BASE+206);}' unless defined(&__NR_setgroups32);
    eval 'sub __NR_fchown32 () {( &__NR_SYSCALL_BASE+207);}' unless defined(&__NR_fchown32);
    eval 'sub __NR_setresuid32 () {( &__NR_SYSCALL_BASE+208);}' unless defined(&__NR_setresuid32);
    eval 'sub __NR_getresuid32 () {( &__NR_SYSCALL_BASE+209);}' unless defined(&__NR_getresuid32);
    eval 'sub __NR_setresgid32 () {( &__NR_SYSCALL_BASE+210);}' unless defined(&__NR_setresgid32);
    eval 'sub __NR_getresgid32 () {( &__NR_SYSCALL_BASE+211);}' unless defined(&__NR_getresgid32);
    eval 'sub __NR_chown32 () {( &__NR_SYSCALL_BASE+212);}' unless defined(&__NR_chown32);
    eval 'sub __NR_setuid32 () {( &__NR_SYSCALL_BASE+213);}' unless defined(&__NR_setuid32);
    eval 'sub __NR_setgid32 () {( &__NR_SYSCALL_BASE+214);}' unless defined(&__NR_setgid32);
    eval 'sub __NR_setfsuid32 () {( &__NR_SYSCALL_BASE+215);}' unless defined(&__NR_setfsuid32);
    eval 'sub __NR_setfsgid32 () {( &__NR_SYSCALL_BASE+216);}' unless defined(&__NR_setfsgid32);
    eval 'sub __NR_getdents64 () {( &__NR_SYSCALL_BASE+217);}' unless defined(&__NR_getdents64);
    eval 'sub __NR_pivot_root () {( &__NR_SYSCALL_BASE+218);}' unless defined(&__NR_pivot_root);
    eval 'sub __NR_mincore () {( &__NR_SYSCALL_BASE+219);}' unless defined(&__NR_mincore);
    eval 'sub __NR_madvise () {( &__NR_SYSCALL_BASE+220);}' unless defined(&__NR_madvise);
    eval 'sub __NR_fcntl64 () {( &__NR_SYSCALL_BASE+221);}' unless defined(&__NR_fcntl64);
    eval 'sub __NR_gettid () {( &__NR_SYSCALL_BASE+224);}' unless defined(&__NR_gettid);
    eval 'sub __NR_readahead () {( &__NR_SYSCALL_BASE+225);}' unless defined(&__NR_readahead);
    eval 'sub __NR_setxattr () {( &__NR_SYSCALL_BASE+226);}' unless defined(&__NR_setxattr);
    eval 'sub __NR_lsetxattr () {( &__NR_SYSCALL_BASE+227);}' unless defined(&__NR_lsetxattr);
    eval 'sub __NR_fsetxattr () {( &__NR_SYSCALL_BASE+228);}' unless defined(&__NR_fsetxattr);
    eval 'sub __NR_getxattr () {( &__NR_SYSCALL_BASE+229);}' unless defined(&__NR_getxattr);
    eval 'sub __NR_lgetxattr () {( &__NR_SYSCALL_BASE+230);}' unless defined(&__NR_lgetxattr);
    eval 'sub __NR_fgetxattr () {( &__NR_SYSCALL_BASE+231);}' unless defined(&__NR_fgetxattr);
    eval 'sub __NR_listxattr () {( &__NR_SYSCALL_BASE+232);}' unless defined(&__NR_listxattr);
    eval 'sub __NR_llistxattr () {( &__NR_SYSCALL_BASE+233);}' unless defined(&__NR_llistxattr);
    eval 'sub __NR_flistxattr () {( &__NR_SYSCALL_BASE+234);}' unless defined(&__NR_flistxattr);
    eval 'sub __NR_removexattr () {( &__NR_SYSCALL_BASE+235);}' unless defined(&__NR_removexattr);
    eval 'sub __NR_lremovexattr () {( &__NR_SYSCALL_BASE+236);}' unless defined(&__NR_lremovexattr);
    eval 'sub __NR_fremovexattr () {( &__NR_SYSCALL_BASE+237);}' unless defined(&__NR_fremovexattr);
    eval 'sub __NR_tkill () {( &__NR_SYSCALL_BASE+238);}' unless defined(&__NR_tkill);
    eval 'sub __NR_sendfile64 () {( &__NR_SYSCALL_BASE+239);}' unless defined(&__NR_sendfile64);
    eval 'sub __NR_futex () {( &__NR_SYSCALL_BASE+240);}' unless defined(&__NR_futex);
    eval 'sub __NR_sched_setaffinity () {( &__NR_SYSCALL_BASE+241);}' unless defined(&__NR_sched_setaffinity);
    eval 'sub __NR_sched_getaffinity () {( &__NR_SYSCALL_BASE+242);}' unless defined(&__NR_sched_getaffinity);
    eval 'sub __NR_io_setup () {( &__NR_SYSCALL_BASE+243);}' unless defined(&__NR_io_setup);
    eval 'sub __NR_io_destroy () {( &__NR_SYSCALL_BASE+244);}' unless defined(&__NR_io_destroy);
    eval 'sub __NR_io_getevents () {( &__NR_SYSCALL_BASE+245);}' unless defined(&__NR_io_getevents);
    eval 'sub __NR_io_submit () {( &__NR_SYSCALL_BASE+246);}' unless defined(&__NR_io_submit);
    eval 'sub __NR_io_cancel () {( &__NR_SYSCALL_BASE+247);}' unless defined(&__NR_io_cancel);
    eval 'sub __NR_exit_group () {( &__NR_SYSCALL_BASE+248);}' unless defined(&__NR_exit_group);
    eval 'sub __NR_lookup_dcookie () {( &__NR_SYSCALL_BASE+249);}' unless defined(&__NR_lookup_dcookie);
    eval 'sub __NR_epoll_create () {( &__NR_SYSCALL_BASE+250);}' unless defined(&__NR_epoll_create);
    eval 'sub __NR_epoll_ctl () {( &__NR_SYSCALL_BASE+251);}' unless defined(&__NR_epoll_ctl);
    eval 'sub __NR_epoll_wait () {( &__NR_SYSCALL_BASE+252);}' unless defined(&__NR_epoll_wait);
    eval 'sub __NR_remap_file_pages () {( &__NR_SYSCALL_BASE+253);}' unless defined(&__NR_remap_file_pages);
    eval 'sub __NR_set_tid_address () {( &__NR_SYSCALL_BASE+256);}' unless defined(&__NR_set_tid_address);
    eval 'sub __NR_timer_create () {( &__NR_SYSCALL_BASE+257);}' unless defined(&__NR_timer_create);
    eval 'sub __NR_timer_settime () {( &__NR_SYSCALL_BASE+258);}' unless defined(&__NR_timer_settime);
    eval 'sub __NR_timer_gettime () {( &__NR_SYSCALL_BASE+259);}' unless defined(&__NR_timer_gettime);
    eval 'sub __NR_timer_getoverrun () {( &__NR_SYSCALL_BASE+260);}' unless defined(&__NR_timer_getoverrun);
    eval 'sub __NR_timer_delete () {( &__NR_SYSCALL_BASE+261);}' unless defined(&__NR_timer_delete);
    eval 'sub __NR_clock_settime () {( &__NR_SYSCALL_BASE+262);}' unless defined(&__NR_clock_settime);
    eval 'sub __NR_clock_gettime () {( &__NR_SYSCALL_BASE+263);}' unless defined(&__NR_clock_gettime);
    eval 'sub __NR_clock_getres () {( &__NR_SYSCALL_BASE+264);}' unless defined(&__NR_clock_getres);
    eval 'sub __NR_clock_nanosleep () {( &__NR_SYSCALL_BASE+265);}' unless defined(&__NR_clock_nanosleep);
    eval 'sub __NR_statfs64 () {( &__NR_SYSCALL_BASE+266);}' unless defined(&__NR_statfs64);
    eval 'sub __NR_fstatfs64 () {( &__NR_SYSCALL_BASE+267);}' unless defined(&__NR_fstatfs64);
    eval 'sub __NR_tgkill () {( &__NR_SYSCALL_BASE+268);}' unless defined(&__NR_tgkill);
    eval 'sub __NR_utimes () {( &__NR_SYSCALL_BASE+269);}' unless defined(&__NR_utimes);
    eval 'sub __NR_arm_fadvise64_64 () {( &__NR_SYSCALL_BASE+270);}' unless defined(&__NR_arm_fadvise64_64);
    eval 'sub __NR_pciconfig_iobase () {( &__NR_SYSCALL_BASE+271);}' unless defined(&__NR_pciconfig_iobase);
    eval 'sub __NR_pciconfig_read () {( &__NR_SYSCALL_BASE+272);}' unless defined(&__NR_pciconfig_read);
    eval 'sub __NR_pciconfig_write () {( &__NR_SYSCALL_BASE+273);}' unless defined(&__NR_pciconfig_write);
    eval 'sub __NR_mq_open () {( &__NR_SYSCALL_BASE+274);}' unless defined(&__NR_mq_open);
    eval 'sub __NR_mq_unlink () {( &__NR_SYSCALL_BASE+275);}' unless defined(&__NR_mq_unlink);
    eval 'sub __NR_mq_timedsend () {( &__NR_SYSCALL_BASE+276);}' unless defined(&__NR_mq_timedsend);
    eval 'sub __NR_mq_timedreceive () {( &__NR_SYSCALL_BASE+277);}' unless defined(&__NR_mq_timedreceive);
    eval 'sub __NR_mq_notify () {( &__NR_SYSCALL_BASE+278);}' unless defined(&__NR_mq_notify);
    eval 'sub __NR_mq_getsetattr () {( &__NR_SYSCALL_BASE+279);}' unless defined(&__NR_mq_getsetattr);
    eval 'sub __NR_waitid () {( &__NR_SYSCALL_BASE+280);}' unless defined(&__NR_waitid);
    eval 'sub __NR_socket () {( &__NR_SYSCALL_BASE+281);}' unless defined(&__NR_socket);
    eval 'sub __NR_bind () {( &__NR_SYSCALL_BASE+282);}' unless defined(&__NR_bind);
    eval 'sub __NR_connect () {( &__NR_SYSCALL_BASE+283);}' unless defined(&__NR_connect);
    eval 'sub __NR_listen () {( &__NR_SYSCALL_BASE+284);}' unless defined(&__NR_listen);
    eval 'sub __NR_accept () {( &__NR_SYSCALL_BASE+285);}' unless defined(&__NR_accept);
    eval 'sub __NR_getsockname () {( &__NR_SYSCALL_BASE+286);}' unless defined(&__NR_getsockname);
    eval 'sub __NR_getpeername () {( &__NR_SYSCALL_BASE+287);}' unless defined(&__NR_getpeername);
    eval 'sub __NR_socketpair () {( &__NR_SYSCALL_BASE+288);}' unless defined(&__NR_socketpair);
    eval 'sub __NR_send () {( &__NR_SYSCALL_BASE+289);}' unless defined(&__NR_send);
    eval 'sub __NR_sendto () {( &__NR_SYSCALL_BASE+290);}' unless defined(&__NR_sendto);
    eval 'sub __NR_recv () {( &__NR_SYSCALL_BASE+291);}' unless defined(&__NR_recv);
    eval 'sub __NR_recvfrom () {( &__NR_SYSCALL_BASE+292);}' unless defined(&__NR_recvfrom);
    eval 'sub __NR_shutdown () {( &__NR_SYSCALL_BASE+293);}' unless defined(&__NR_shutdown);
    eval 'sub __NR_setsockopt () {( &__NR_SYSCALL_BASE+294);}' unless defined(&__NR_setsockopt);
    eval 'sub __NR_getsockopt () {( &__NR_SYSCALL_BASE+295);}' unless defined(&__NR_getsockopt);
    eval 'sub __NR_sendmsg () {( &__NR_SYSCALL_BASE+296);}' unless defined(&__NR_sendmsg);
    eval 'sub __NR_recvmsg () {( &__NR_SYSCALL_BASE+297);}' unless defined(&__NR_recvmsg);
    eval 'sub __NR_semop () {( &__NR_SYSCALL_BASE+298);}' unless defined(&__NR_semop);
    eval 'sub __NR_semget () {( &__NR_SYSCALL_BASE+299);}' unless defined(&__NR_semget);
    eval 'sub __NR_semctl () {( &__NR_SYSCALL_BASE+300);}' unless defined(&__NR_semctl);
    eval 'sub __NR_msgsnd () {( &__NR_SYSCALL_BASE+301);}' unless defined(&__NR_msgsnd);
    eval 'sub __NR_msgrcv () {( &__NR_SYSCALL_BASE+302);}' unless defined(&__NR_msgrcv);
    eval 'sub __NR_msgget () {( &__NR_SYSCALL_BASE+303);}' unless defined(&__NR_msgget);
    eval 'sub __NR_msgctl () {( &__NR_SYSCALL_BASE+304);}' unless defined(&__NR_msgctl);
    eval 'sub __NR_shmat () {( &__NR_SYSCALL_BASE+305);}' unless defined(&__NR_shmat);
    eval 'sub __NR_shmdt () {( &__NR_SYSCALL_BASE+306);}' unless defined(&__NR_shmdt);
    eval 'sub __NR_shmget () {( &__NR_SYSCALL_BASE+307);}' unless defined(&__NR_shmget);
    eval 'sub __NR_shmctl () {( &__NR_SYSCALL_BASE+308);}' unless defined(&__NR_shmctl);
    eval 'sub __NR_add_key () {( &__NR_SYSCALL_BASE+309);}' unless defined(&__NR_add_key);
    eval 'sub __NR_request_key () {( &__NR_SYSCALL_BASE+310);}' unless defined(&__NR_request_key);
    eval 'sub __NR_keyctl () {( &__NR_SYSCALL_BASE+311);}' unless defined(&__NR_keyctl);
    eval 'sub __NR_semtimedop () {( &__NR_SYSCALL_BASE+312);}' unless defined(&__NR_semtimedop);
    eval 'sub __NR_vserver () {( &__NR_SYSCALL_BASE+313);}' unless defined(&__NR_vserver);
    eval 'sub __NR_ioprio_set () {( &__NR_SYSCALL_BASE+314);}' unless defined(&__NR_ioprio_set);
    eval 'sub __NR_ioprio_get () {( &__NR_SYSCALL_BASE+315);}' unless defined(&__NR_ioprio_get);
    eval 'sub __NR_inotify_init () {( &__NR_SYSCALL_BASE+316);}' unless defined(&__NR_inotify_init);
    eval 'sub __NR_inotify_add_watch () {( &__NR_SYSCALL_BASE+317);}' unless defined(&__NR_inotify_add_watch);
    eval 'sub __NR_inotify_rm_watch () {( &__NR_SYSCALL_BASE+318);}' unless defined(&__NR_inotify_rm_watch);
    eval 'sub __NR_mbind () {( &__NR_SYSCALL_BASE+319);}' unless defined(&__NR_mbind);
    eval 'sub __NR_get_mempolicy () {( &__NR_SYSCALL_BASE+320);}' unless defined(&__NR_get_mempolicy);
    eval 'sub __NR_set_mempolicy () {( &__NR_SYSCALL_BASE+321);}' unless defined(&__NR_set_mempolicy);
    eval 'sub __NR_openat () {( &__NR_SYSCALL_BASE+322);}' unless defined(&__NR_openat);
    eval 'sub __NR_mkdirat () {( &__NR_SYSCALL_BASE+323);}' unless defined(&__NR_mkdirat);
    eval 'sub __NR_mknodat () {( &__NR_SYSCALL_BASE+324);}' unless defined(&__NR_mknodat);
    eval 'sub __NR_fchownat () {( &__NR_SYSCALL_BASE+325);}' unless defined(&__NR_fchownat);
    eval 'sub __NR_futimesat () {( &__NR_SYSCALL_BASE+326);}' unless defined(&__NR_futimesat);
    eval 'sub __NR_fstatat64 () {( &__NR_SYSCALL_BASE+327);}' unless defined(&__NR_fstatat64);
    eval 'sub __NR_unlinkat () {( &__NR_SYSCALL_BASE+328);}' unless defined(&__NR_unlinkat);
    eval 'sub __NR_renameat () {( &__NR_SYSCALL_BASE+329);}' unless defined(&__NR_renameat);
    eval 'sub __NR_linkat () {( &__NR_SYSCALL_BASE+330);}' unless defined(&__NR_linkat);
    eval 'sub __NR_symlinkat () {( &__NR_SYSCALL_BASE+331);}' unless defined(&__NR_symlinkat);
    eval 'sub __NR_readlinkat () {( &__NR_SYSCALL_BASE+332);}' unless defined(&__NR_readlinkat);
    eval 'sub __NR_fchmodat () {( &__NR_SYSCALL_BASE+333);}' unless defined(&__NR_fchmodat);
    eval 'sub __NR_faccessat () {( &__NR_SYSCALL_BASE+334);}' unless defined(&__NR_faccessat);
    eval 'sub __NR_pselect6 () {( &__NR_SYSCALL_BASE+335);}' unless defined(&__NR_pselect6);
    eval 'sub __NR_ppoll () {( &__NR_SYSCALL_BASE+336);}' unless defined(&__NR_ppoll);
    eval 'sub __NR_unshare () {( &__NR_SYSCALL_BASE+337);}' unless defined(&__NR_unshare);
    eval 'sub __NR_set_robust_list () {( &__NR_SYSCALL_BASE+338);}' unless defined(&__NR_set_robust_list);
    eval 'sub __NR_get_robust_list () {( &__NR_SYSCALL_BASE+339);}' unless defined(&__NR_get_robust_list);
    eval 'sub __NR_splice () {( &__NR_SYSCALL_BASE+340);}' unless defined(&__NR_splice);
    eval 'sub __NR_arm_sync_file_range () {( &__NR_SYSCALL_BASE+341);}' unless defined(&__NR_arm_sync_file_range);
    eval 'sub __NR_sync_file_range2 () { &__NR_arm_sync_file_range;}' unless defined(&__NR_sync_file_range2);
    eval 'sub __NR_tee () {( &__NR_SYSCALL_BASE+342);}' unless defined(&__NR_tee);
    eval 'sub __NR_vmsplice () {( &__NR_SYSCALL_BASE+343);}' unless defined(&__NR_vmsplice);
    eval 'sub __NR_move_pages () {( &__NR_SYSCALL_BASE+344);}' unless defined(&__NR_move_pages);
    eval 'sub __NR_getcpu () {( &__NR_SYSCALL_BASE+345);}' unless defined(&__NR_getcpu);
    eval 'sub __NR_epoll_pwait () {( &__NR_SYSCALL_BASE+346);}' unless defined(&__NR_epoll_pwait);
    eval 'sub __NR_kexec_load () {( &__NR_SYSCALL_BASE+347);}' unless defined(&__NR_kexec_load);
    eval 'sub __NR_utimensat () {( &__NR_SYSCALL_BASE+348);}' unless defined(&__NR_utimensat);
    eval 'sub __NR_signalfd () {( &__NR_SYSCALL_BASE+349);}' unless defined(&__NR_signalfd);
    eval 'sub __NR_timerfd_create () {( &__NR_SYSCALL_BASE+350);}' unless defined(&__NR_timerfd_create);
    eval 'sub __NR_eventfd () {( &__NR_SYSCALL_BASE+351);}' unless defined(&__NR_eventfd);
    eval 'sub __NR_fallocate () {( &__NR_SYSCALL_BASE+352);}' unless defined(&__NR_fallocate);
    eval 'sub __NR_timerfd_settime () {( &__NR_SYSCALL_BASE+353);}' unless defined(&__NR_timerfd_settime);
    eval 'sub __NR_timerfd_gettime () {( &__NR_SYSCALL_BASE+354);}' unless defined(&__NR_timerfd_gettime);
    eval 'sub __NR_signalfd4 () {( &__NR_SYSCALL_BASE+355);}' unless defined(&__NR_signalfd4);
    eval 'sub __NR_eventfd2 () {( &__NR_SYSCALL_BASE+356);}' unless defined(&__NR_eventfd2);
    eval 'sub __NR_epoll_create1 () {( &__NR_SYSCALL_BASE+357);}' unless defined(&__NR_epoll_create1);
    eval 'sub __NR_dup3 () {( &__NR_SYSCALL_BASE+358);}' unless defined(&__NR_dup3);
    eval 'sub __NR_pipe2 () {( &__NR_SYSCALL_BASE+359);}' unless defined(&__NR_pipe2);
    eval 'sub __NR_inotify_init1 () {( &__NR_SYSCALL_BASE+360);}' unless defined(&__NR_inotify_init1);
    eval 'sub __NR_preadv () {( &__NR_SYSCALL_BASE+361);}' unless defined(&__NR_preadv);
    eval 'sub __NR_pwritev () {( &__NR_SYSCALL_BASE+362);}' unless defined(&__NR_pwritev);
    eval 'sub __NR_rt_tgsigqueueinfo () {( &__NR_SYSCALL_BASE+363);}' unless defined(&__NR_rt_tgsigqueueinfo);
    eval 'sub __NR_perf_event_open () {( &__NR_SYSCALL_BASE+364);}' unless defined(&__NR_perf_event_open);
    eval 'sub __NR_recvmmsg () {( &__NR_SYSCALL_BASE+365);}' unless defined(&__NR_recvmmsg);
    eval 'sub __NR_accept4 () {( &__NR_SYSCALL_BASE+366);}' unless defined(&__NR_accept4);
    eval 'sub __NR_fanotify_init () {( &__NR_SYSCALL_BASE+367);}' unless defined(&__NR_fanotify_init);
    eval 'sub __NR_fanotify_mark () {( &__NR_SYSCALL_BASE+368);}' unless defined(&__NR_fanotify_mark);
    eval 'sub __NR_prlimit64 () {( &__NR_SYSCALL_BASE+369);}' unless defined(&__NR_prlimit64);
    eval 'sub __NR_name_to_handle_at () {( &__NR_SYSCALL_BASE+370);}' unless defined(&__NR_name_to_handle_at);
    eval 'sub __NR_open_by_handle_at () {( &__NR_SYSCALL_BASE+371);}' unless defined(&__NR_open_by_handle_at);
    eval 'sub __NR_clock_adjtime () {( &__NR_SYSCALL_BASE+372);}' unless defined(&__NR_clock_adjtime);
    eval 'sub __NR_syncfs () {( &__NR_SYSCALL_BASE+373);}' unless defined(&__NR_syncfs);
    eval 'sub __NR_sendmmsg () {( &__NR_SYSCALL_BASE+374);}' unless defined(&__NR_sendmmsg);
    eval 'sub __NR_setns () {( &__NR_SYSCALL_BASE+375);}' unless defined(&__NR_setns);
    eval 'sub __NR_process_vm_readv () {( &__NR_SYSCALL_BASE+376);}' unless defined(&__NR_process_vm_readv);
    eval 'sub __NR_process_vm_writev () {( &__NR_SYSCALL_BASE+377);}' unless defined(&__NR_process_vm_writev);
    eval 'sub __NR_kcmp () {( &__NR_SYSCALL_BASE+378);}' unless defined(&__NR_kcmp);
    eval 'sub __NR_finit_module () {( &__NR_SYSCALL_BASE+379);}' unless defined(&__NR_finit_module);
    eval 'sub __NR_sched_setattr () {( &__NR_SYSCALL_BASE+380);}' unless defined(&__NR_sched_setattr);
    eval 'sub __NR_sched_getattr () {( &__NR_SYSCALL_BASE+381);}' unless defined(&__NR_sched_getattr);
    eval 'sub __NR_renameat2 () {( &__NR_SYSCALL_BASE+382);}' unless defined(&__NR_renameat2);
    eval 'sub __NR_seccomp () {( &__NR_SYSCALL_BASE+383);}' unless defined(&__NR_seccomp);
    eval 'sub __NR_getrandom () {( &__NR_SYSCALL_BASE+384);}' unless defined(&__NR_getrandom);
    eval 'sub __NR_memfd_create () {( &__NR_SYSCALL_BASE+385);}' unless defined(&__NR_memfd_create);
    eval 'sub __NR_bpf () {( &__NR_SYSCALL_BASE+386);}' unless defined(&__NR_bpf);
    eval 'sub __NR_execveat () {( &__NR_SYSCALL_BASE+387);}' unless defined(&__NR_execveat);
    eval 'sub __NR_userfaultfd () {( &__NR_SYSCALL_BASE+388);}' unless defined(&__NR_userfaultfd);
    eval 'sub __NR_membarrier () {( &__NR_SYSCALL_BASE+389);}' unless defined(&__NR_membarrier);
    eval 'sub __NR_mlock2 () {( &__NR_SYSCALL_BASE+390);}' unless defined(&__NR_mlock2);
    eval 'sub __NR_copy_file_range () {( &__NR_SYSCALL_BASE+391);}' unless defined(&__NR_copy_file_range);
    eval 'sub __NR_preadv2 () {( &__NR_SYSCALL_BASE+392);}' unless defined(&__NR_preadv2);
    eval 'sub __NR_pwritev2 () {( &__NR_SYSCALL_BASE+393);}' unless defined(&__NR_pwritev2);
    eval 'sub __NR_pkey_mprotect () {( &__NR_SYSCALL_BASE+394);}' unless defined(&__NR_pkey_mprotect);
    eval 'sub __NR_pkey_alloc () {( &__NR_SYSCALL_BASE+395);}' unless defined(&__NR_pkey_alloc);
    eval 'sub __NR_pkey_free () {( &__NR_SYSCALL_BASE+396);}' unless defined(&__NR_pkey_free);
    eval 'sub __ARM_NR_BASE () {( &__NR_SYSCALL_BASE+0xf0000);}' unless defined(&__ARM_NR_BASE);
    eval 'sub __ARM_NR_breakpoint () {( &__ARM_NR_BASE+1);}' unless defined(&__ARM_NR_breakpoint);
    eval 'sub __ARM_NR_cacheflush () {( &__ARM_NR_BASE+2);}' unless defined(&__ARM_NR_cacheflush);
    eval 'sub __ARM_NR_usr26 () {( &__ARM_NR_BASE+3);}' unless defined(&__ARM_NR_usr26);
    eval 'sub __ARM_NR_usr32 () {( &__ARM_NR_BASE+4);}' unless defined(&__ARM_NR_usr32);
    eval 'sub __ARM_NR_set_tls () {( &__ARM_NR_BASE+5);}' unless defined(&__ARM_NR_set_tls);
    if(defined(&__ARM_EABI__)) {
	undef(&__NR_time) if defined(&__NR_time);
	undef(&__NR_umount) if defined(&__NR_umount);
	undef(&__NR_stime) if defined(&__NR_stime);
	undef(&__NR_alarm) if defined(&__NR_alarm);
	undef(&__NR_utime) if defined(&__NR_utime);
	undef(&__NR_getrlimit) if defined(&__NR_getrlimit);
	undef(&__NR_select) if defined(&__NR_select);
	undef(&__NR_readdir) if defined(&__NR_readdir);
	undef(&__NR_mmap) if defined(&__NR_mmap);
	undef(&__NR_socketcall) if defined(&__NR_socketcall);
	undef(&__NR_syscall) if defined(&__NR_syscall);
	undef(&__NR_ipc) if defined(&__NR_ipc);
    }
}
1;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ELF          (    x$  4      4    (                                                                           $   $         Qtd                          Rtd    4  4                 GNU zKj)I   a          5 Ba   d   g    4BE|WqXvT<Z
Yy                    h        	                          (                                       L           "                                                         <             :                          X                                       ^                          E             4             G                                                    v             x                                       w             ]             6             /                                                                                           k                            o                           $             M                                                                                           |                          j                           !                                                     e                                                    *                          U             S                          $                                       [               b             {                                                                                r                                        2                                         H                                                                                                           ?                                       [         9         n         Z         @           h        	 L            ,        L    T#    f          __gmon_start__ _fini _ITM_deregisterTMCloneTable _ITM_registerTMCloneTable __cxa_finalize _Jv_RegisterClasses Perl_croak_xs_usage Perl_sv_newmortal Perl_newSVrv Perl_sv_setiv Perl_gv_fetchpvn_flags Perl_sv_2iv_flags Perl_croak_nocontext Perl_sv_setuv_mg Perl_sv_setpvn Perl_stack_grow Perl_mg_set Perl_sv_2mortal Perl_newSVhek Perl_newSViv Perl_newSVuv Perl_markstack_grow Perl_sv_setiv_mg Perl_refcounted_he_chain_2hv Perl_newRV Perl_newSVpvn_flags Perl_hv_placeholders_get Perl_hv_iterinit Perl_hv_iternext_flags Perl_hv_riter_p Perl_hv_fill Perl_cvgv_from_hek Perl_cv_const_sv Perl_custom_op_get_field Perl_warn_nocontext PL_opargs PL_op_name Perl_mg_size Perl_sv_2pv_flags strcmp Perl_PerlIO_stderr Perl_PerlIO_stdin Perl_PerlIO_stdout Perl_gv_fetchfile Perl_croak Perl_sv_setuv strlen Perl_mg_find Perl_sv_2nv_flags Perl_sv_setnv_mg __stack_chk_fail __stack_chk_guard Perl_newSVpv Perl_newSVnv Perl_av_fetch Perl_newSVpvn Perl_multideref_stringify Perl_newSV Perl_sv_catpvf Perl_sv_catpvn_flags Perl_sv_uni_display strchr PL_charclass Perl_sv_setpvf strncmp Perl_sv_2bool_flags Perl_call_method Perl_gv_stashpv Perl_sv_bless Perl_sv_backoff Perl_hv_common_key_len Perl_newCONSTSUB Perl_sv_upgrade Perl_get_sv Perl_hv_common Perl_newSVpvf Perl_cop_fetch_label Perl_emulate_cop_io Perl_sv_magicext Perl_sv_free2 PL_op_desc Perl_sv_2pvbyte PL_hash_seed boot_B Perl_xs_handshake Perl_newXS_deffile PL_thr_key pthread_getspecific Perl_get_hv Perl_get_av Perl_av_push Perl_mro_method_changed_in Perl_my_cxt_init Perl_newXS Perl_sv_setsv_flags Perl_xs_boot_epilog libc.so.6 ld-linux-armhf.so.3 _edata __bss_start __bss_start__ __bss_end__ __end__ _end GLIBC_2.4                                                                                                                                                                                                         %         ii   s                 ii   s                                                                                            $    (    ,    0    4    8    <    @    D    H    L    P    X    `    h    p    x                                                                                          (    0    8    @    H    P    X    `    h    p    x                                                                                     8    H    X    h    x                                            (    8    H    X    h    x                                            (    8    H    X    h    x                                            (    8    H    X    h    x                                            (    8    H    X    h    x                                            (    8    H    X    h    x                                            (    8    H    X    h    x                                              (     8     H     X     h     x                                                     (    8    H    X    h    x                                            (    8    H    X    h    x                                            (    8    H    X    h    x                                            (    8    H    X    h    x                                            (    8    H    X    h    x                                            (    8    H    X    h    x                                            (    8    H    X    h    x                                            (    8    H    X    h    x                                    	    	    (	    8	    H	    X	    h	    x	    	    	    	    	    	    	    	    	    
    
    (
    8
    H
    X
    h
    x
    
    
    
    
    
    
    
    
            (    8    H    X    h    x                                            (    8    H    X    h    x                                            (    8    H    X    h    x                                            (    8    H    X    h    x                                        \   ` 	  d   h   l %  p )  t 4  x E  | H   P   S   ^                     $ 
  (   ,   0   4   8   <   @   D   H   L   P   T   X   \   `   d   h   l   p   t    x !  | "   #   $   &   '   (   )   *   +   ,   -   .   /   0   1   2   3   5   6   7   8   9   :   ;   <   =   >   ?   @   A   B   C   D    F   G   I   J   K   L   M   N    O  $ Q  ( R  , T  0 U  4 V  8 W  < X  @ Y  D Z  H [  L \  P ]  T _  X `  @- -|  | t l d \ T L D < 4 , $                     | t l d \ T L D < 4 , $                     | t l d \ T L D < 4 , $        0 0   R/bx p  404 0  0 0C S 00/ 0  S//  < `  88    A,0A0/ 0  S//     L0L 0  0  S/80@-0  S  
(0 0 0  L  \    8 80    0  R     0  S
@-3/@$ H |  D 0BD   10B#  0B 0/ @-$  @-D 0BD    1 B"!     R %$ 0   A- p`g0(0 @ 0 P10C   R  
@ P  U T D0@0 P! ) 0  <     4  p@-D0` CD  0  1 B"!
    P @0 00 0p   p@- @D 0 BD      10B#   PB P`     `p ,  0@-MD0@ CD  0 A@L$1  P0     P@L0  0  00 \     p@-` P,   @    0   p  A-D0P CD    0QPC%!   %PC  R @% 0,pP   W  `D    0   0` 0 0      A-D0 CD  P  Q0 BB! RB  ,1 @0S5  
 `P0 7  
0 0S*  
    V   0 V   w  `  p K0   ^0p0P P0 a`  V p  
T    0` 0  ,$                H  A-D0 CD P 0Q0CC1 S-  P0 %  
0 @ 0S  
 70  p#|   W  `  
  0   
0`0P P 0 (       |     x      A-D0 CD P 0Q0CC1 S5  P0 -  
0 @ 0S#  
   80`   ,p  W !  
       p`   0   00P P 0 0   a $0 `              p@-D0 CD @ 0 A0C`C1 S)  @0 '  
0 P 0S  
   V  0  S	  0 00@ @p0)	R  
0 0 s0	0C S           p@-D0 CD 0 !0LC ^   @L0  
t0 P 0S  
 `0  
 0  0p 0 $                p@-D0 CD  0!@CD \   @C0
  
 P0  0p    @  t  A-D0 CD  P 0Q 0CC1 S9  0 @  ,  
 0ap0 0  
0 0S  
   e0  0#  $ P 00  SP  
 0 0`0p p 0  `  B   l   \  T  A-D 0BD P  Q BB! R8    @ &  
 ap (  
    R  
  0e   "   P     RP  
  0!`0p p0 `  0 b   "      x  A-D0 CD  P 0Q 0CC1 S8  0 @  +  
 0ap0 /  
0 0S  
  ae0   0# R 00  S  P  
 0 0`0p p 0 5 `            A-D0 CD  P 0Q 0CC1 S9  0 @  ,  
 0ap0 0  
0 0S  
  e0   0#  8  P 00  S P  
 0 0`0p p 0  `  Q   {   $    A-D 0BD P  Q BB! R:    @ ,  
 ap 1  
    R  
  0 e ' !  \   Q#P  
r  0 !`0p p   0 ` 0 l    (       A-D0 CD  P 0Q 0CC1 S9  0 @  ,  
 0ap0 0  
0 0S  
  ke0  0#  $  P 00  S!P  
 0 0`0p p 0 > `            A-D 0BD P  Q BB! R8    @ &  
 ap (  
    R  
  0e   "   P     RP  
   0!`0p p0 `   0     [     d  A-D0 CD  P 0  Q0CC1 S<  0 @  /  
 0ap0 3  
0 0S  
    X   e0 0#   P 00  SP  
 0 0`0p p   0  ` t    0       A-D0` CD  P 0  Q`0C#1)  0 @    
 0qe0   X0#p <  \ 00  S   
, p0PP PX`` p  0 1 <  A-D 0BD p Pq0 EB \:  PE @  $  
 a0 1  
0 0S  
  50   020  00C S   `   0 00 ` 0 % P  u      (     O-D 0BD   @1 DB \A  0@D 9  
0 P 0S/  
   0  S'  ` p
`F   0p S@   0  S 
     0   00C S 0  @ @ 0    N      l       G-D 0BD   @1 DB \`  0@D _  
1 P 0SB  
  p 0  S 9  0  :  
 0`0! 0   S$!  K  0    ]0(  00C S(   0   S  @   @   0 S
  00C S0 g    0p ?   0 S @          L  P  L  A-D 0BD   P1 EB \/  0PE '  
0 p 0S  
  0@  T     !P  @  T  
00C S`0   ` P 0     _   ~  t  p@-D0 CD P 0Q0CC1 S%  P0   
0 @ 0S  
  08 	
   y0 0P Pp 0 $     V %   |}  t  A-D 0BD @   A B`B! R5  @p0 3  
0 P 0S  
 pp  V   08     0 m  4  0@ @ 08  
   
 0 0   0        D  0|  p@-D0 CD P 0Q0CC1 S#  P0   
0 @ 0S  
 O 08  ,  0   0 0P Pp 0        `{  X  A-D0 CD P 0 Q0CpC1 S6  P`0 4  
0 @ 0S  
 `  W`  
 W  

  
 0 001  Q  
0  S      0P P 0  W  00( Q   {   (  (z  p@-D0 CD P 0 Q0C`C1 S.  P0 &  
0 @ 0S  
 F(v0r  R   
 R  
  >0 0P Pp   0 ^  U 0      : 	   y  xy  A-pD 0BD ` Pa0EN! Rd  PE @\5  
00 0 Q  
X1 0S*  
  v `  X   0 X
  00C S,    `  `  X  D  0H  0C PD  0(  
 0C0CC1 0 A   0`00C S  0 `  ` 0 I P 0 B P  0       w  w  A-D 0BD P  Q BB! R6    @ )  
 ap -  
    R  
   0e!   ^   QP?  
!`0p p   0 `  D   n   u  u  A-D 0BD P  Q BB! R7    @ *  
 ap .  
    R  
  0  e ! <  \   QP?  
 !`0p p   0 `          t  A-D 0BD P  Q BB! R8    @ &  
 ap (  
    R  
  a0e   "   P     RP  
   0!`0p p:0 `   0        Dt  ,t  A-D0 CD P 0Q0CC1 S7  0 @ *  
0ap0.  
0  0S  
   e00# \ 00  SP       
`0p p 0   ` 1 V      <x  <r  A-D0 CD P 0Q0CC1 SE  0 @ 3  
0ap0 5  
0 0S  
    00S  
  e0 0# \ 00  SP  
, `0p p 0 0  `  0    )    p  w  A-D0 CD P 0Q0CC1 S5  p0 @ 0S  
 t0     
 0ae0 0#   P 00   SP?   
!`0p p 00   > `     xp  G-D0 CD p 0qP0CC1 S'  0 @   
 0ae0x 0#  R 00  S    
 `0  P `	  L qu  A-D0` CD  P 0Q`0C#1%  0 @    
 0qe0x 0#  R 00D!  S?  
!p0PP P`` p  9  p@-D0 CD P 0Q0CC1 S#  P0   
0 @ 0S  
       r  Q0 0P Pp 0   3    m  Ls  p@-D0 CD P 0Q0CC1 S!  P`0   
t0 @ 0S  
 z``  ;    0P Pp 0       Hl  (s  p@-D 0BD    1 L`B ^+  0PL *  
0 @ 0S  
 D  V`  
0  
  r	  
 d0  7        `p 0           k  k  G-D 0BD   P 1 EpB \m  0PE l  
1 @ 0S;  
   W;  
 WH  
0  1  
 0a  W  e0P!0#  R 00  S  0?  
!p` p e0 0#    P 00  S,"%  
r  0!p` p 0  `   7d   B B p 0 ph.  0 v     .     p  i  O-D 0BD   P1 EB \Z  0PE Y  
h1 @ 0SE  
 y  0A   P  
 g P7  
  0A   P  
 [  F0/  J  BBS+  `   0 0 
00  P` 	   pP  
0 
 r0  S
   P 0  = P          $h  h  A-D0 CD P 0Q0CC1 S9  0 @ ,  
0ap0 0  
0 0S  
    pe0 0#  R 00   SP  ?  
!`0p p 0  `  ?   i   f  f  A-D0 CD  P 0Q 0CC1 S:  0 @  ,  
 0ap0 1  
0 0S  
    e00# \ 00  SP  
 0 0`0p p 0 `   Z       e  e  p@-D0 CD @ 0A0CC1 S'  @`0   
0 P 0S  
 ``` 08 	$	     0@ @p 0           c  u  p@-D0 CD 0 !0LC ^   @L0  
`0 P 0S	  
 &U  0  0p 0     }   b  t  p@- 0QRPF  
++  R    B R6  0 1  
 p% R1  
 R   
@B R T  _R@/  
T201<S  
G  Ss  
S  Sd  
  Sg  
SF   pSB  0  
  
 pPZ  
l  P
P  
  P   p p0@  p p  `P
PD  
K  P5  
V  P8  
P
;;_S     0   pS'  
  S
S
  S
00	S  

S
S0 	 pS  
S  
S p0@ ~ 
 p p
 p0 r p p	P

P
PP
P
PP
   8b  t  p@- @`E P ?000 1 @   0  ) p A-D 0BD    1 L`B ^!  0PL   
x0 @ 0S  
 & 0p8       V    p 0     w   ^  p  G- @QpX  
0 U  
 `PPq   S$  0@   
 @  P @  T  
0   
00000C S+     10! S(  @  T P 1<S  
	S$         P  P 	0  P0 000  PP     p@-D 0BD   1PBE \  0PB   
X0 @ 0S  
    ~  p 0       ]  |_  p@-D 0BD    10B#
  (  \$PB @0  0p P}  A-D 0BD ` Pa0EN! R_  PE @\3  
H00 p0 S  
P1 0S(  
  8 `  W  0"   0   P    W
  00C S(    `  `00C S$  0 `  `  p 0`   P0 0 
 z  W 0 	 P 0  P V      [  [  G-D 0BD   @1 DB \J  0@D B  
1 P 0S0  
  p0/   0     P  
 `H   0   V  00C S   70` @0
 !  V @ 	0  @ 0p0
      &    8Z  tj  A-D0 CD  P 0Q 0CC1 SA  0 @  4  
 0ap0 8  
0 0S  
  f0   0 e00# \ 00  SP  ?  
!`0p p 0 0
  1 ` z       i  X  A-D0 CD  P 0Q 0CC1 SE  ,! @ R0  
  m `P0 2  
0 0S#  
  	 p   P  
   P  
   P    0 P   00 0` 0p ( 8   r ,A$   j      ,X  4X  $X  W  pW  W  p@-D 0BD   1 LB ^!  0PL   
x0 @ 0S  
 0`(  Q  
 d  +  `p 0    4    U  Z  A-pD0 CD @ 0 A0C`C1 S?  @0 7  
1 P 0S  
 y   R  
F80v  
 S    0   0 0@ @    0   08 	$     P  
 0  H <   4 (      U  U  S  Y  `U  A-D 0BD   @ 1 D`B \  0@D   
2 P 0S%  
  p V  !  ,  5  >  G  P  V  c  
0r S  `  Q    d0 0 B B 7f @ @ 0p00C SX   `  Q 
   0@     >
7  D0 @ @  0@     * @     ? @0 @  Q%  
   R   r   
0 @
0r S#    0@      0 @7 0  @ 0     $         R  R  R  R  p@-D0 CD P 0 Q0C`C1 Sf  P0 e  
1 @ 0S-  
 ^ V-  
 V3  
  V  
 r0 SD  
`1`0 S`>  
 7   ` 0P Pp0%  s  R.  
   R)  
 7 0 V B  P+  
 7 r0 S  
00 S	  
  7   27 00`  27  (j           
  U  N  P  A-D0 CD P 0Q0CC1 SD  0 @ 4  
0ap0 4  
0 0S   
    00S  
  8e0 0# Q 00  SP  
 0", `00 0 0 0  `     9       8M  T  H!A- D<1@N`D@ @ 0MA0C C1 S 009  @p0 0  
0 P 0S  
 up  Xp  
 0! S R00 00 @ @ 0 R   0  X  7  0<          d     K  R  p@-D0 CD P 0 Q0C`C1 Sj  P0 i  
1 @ 0S  
 $F8  v s0 SP  B  E  K  
  	        %  )  0     0   0   0 0P Pp         9  7  U  ?    ?   Y    v (   ] ,   V   HL  P  I  O-MD 0BD @  A0PI E! R    
 p\  
00 `0   
3 0S  
  1;; S   0`I,0 @0  R 00  0	0CCR   0 U     0   S R7   R4  I  c  E  B  `  @  A  ,  N    /  K  -   
0 	`    00   S Ru  
O    S  RX  
  S0 Rc   
0 `   @  00<  3<#@P 
0 `   

@ `0   0  00   S R  
(    S  R  
  S0 R$   00   S R    0  0 1C 01 0 
0   ` 0
@  003<#@	Pb  [    `- 0 70@ @	 	0  @$   O   L    `E  F  H  A-D 0BD P  Q BB! R:  `09  
0 @0S#  
0 p0 -  
0 0S  
  1;; S  
   g  0 0` ` 0p 0     $         e  F  TE  C  G-D 0BD   @p1 0up00  @!`P01    p@`P ( O-,M'
D LDp   0 `1F PL!  R$ `F Y @p 
0  s Q  
 Q    7 j  Y  P  
  60SV  
0   C   Qc  
6006006 p00600600'   Q ? S   Q  
 ? Q, 
LLQ  

 SV  
 S\  
	 Sb  
 So  
 St  
 S  
  Y S  
   A  Q (  
 0" S  
\ S  
  Y
$ SM  
@ S%0 0   0  |%0 0  `%0 0  D%0 0 0 0$ P  0 R1 ,0 00 $0 0  {$0 0  s0 0  l$0 0  d0 0  ]0 0  V@7 P + 0 0 1  $ 0 p  S
#  #  #
    
  0  P    p"0p  S
" SE  
$ SQ  
@ S\  
\ S
 0  0 0  	?$7^ 20S P<    0' SL  
\ SR  
" \  

 Sb  
 Sh  
	 Sn  
 St  
 Sz  
 S  
 SF  
"  "0 0 0 C 0  0 0   0  	0    0  !0  !0 0  !0 0  !0 0  0   00 T!0 0  8!0 0  ~!0 0  v !0 0  n 0 0  f 0 0  ^} y d   
  E     E  E  E  D  D  D  l  @@  D  C  C  C  C  B  B  B  B  $B  ,B  B  B   A  @  x@  ?  ?  ?  ?  <?   ?  ?  >  >  >  B  A-D 0BD P  pQ BpB! R&  P ` @0 R  
 0`    X    @6 X  0P PD0@ 0  1 0 L    t  d=  0=  G-D 0BD   Q		 BPB! R6   		@ 0 R+  
0  0	@ `     @v  P`  W  0 @P  @ T  
   P ?     0 	0	 `     <  t  d:  G- PD0 CD @0 p	 @pG@  
 a!  W  p  	  ^  
I    |  R  
\!\  R  
e0 HAD0# Q 00A  S *  
<0`0@@ @  
    R  
  R+  00-0 `,  
  
     
  {@{0  b  !  P0   R
   0 R  
  O-M
 @pP  `8  0 Q @  0"<:#: S[  
    P  0  0 0  S  
D H0  PD {  
00FC1 000C Sl  P   	`D H0  PD [  
00FC1 000C SL  P  `   W  
0   
`  V	  
0  `  V 0 P  P  1;; S  
$p  W 0  S
 Qq  P
)      P 0  Q
     0 0 r `  0 h `  00ln  9    p@-D0 CD P 0Q 0CC1 S&   @\  
     `0   
p0 0S  
  $ 0  0P Pp` 0 {         6  6  C-M   p0` PP%  
@0  s A R       R
  
  Q  
;0`0 300 	    0  P 
  85  O-$MD0 CD P 0 Q0C`C1 S\;00 P0  
8; @ 0Sc  
  8 V ;q00   x|3  P>  
0;  
0 S6  	  0 p 00000 0    2  X 0  
  R  B   S  
0  S  
   
0 S        0
  +  P	  
    R  
0 0P P$90p} Q  
7	 Q T      X    T  Z  a   0   0    p0p0P P$0F7 S u        s              Z                |  {  z  l  a         6  5  6    0  !  w k  j  i  h  g  l d \ P      p     p     p    p   p1;;0C S    1;;#0C S ` H7   4 p  Q
 {  b px1;;! S(
 1;; Sq 
$ P pf0    S   
0    S  0S VW 
  V    
/ V"!   
0 V!   
1 V""   
2 V"   
3 V"# #r  051 V;;/ 
_S~ 
D& 	 \,& 0  !! 7!  R  
0s Q- 
 7  p1`%; ;! 6   0 p0 S%0  0    Br       R7 0 S  
  p 06  
( 7  Q6
04  
  0  1  Q+
0  S  
   Q%
# 0	  e     ,	 `   0  s  R  
`$`  R  
  R  B   n p,4(0( 0 1   0  \|  
X  Y  X    `  30!  p  0     0	   R B p l 7 1 Q ) pa1;; S
1;; S  8 pN ~"   p T,  0  g@
    O0|
   
 b& V p_  
   d0  0 @ 0@ &0020 K"   p ! 	0  4c  p_ST  
! W! 0++r  )$  0 p  4
  
 0  1  Q  
0  S  = 0    
   ,7  , r  } p  0  i7, p p    d   	    	    p    h 4  g t  X+  x/  l  @   
  | xa ,  T,  H,  H'  x  '  p)  )  A-MpD l1BpD P` 0Q 0C  C1 S F  P,1 @` 0S8  
 ` `  P 00  * 5  \#3#0 5 #3#05 #3#   0    ,, %"#"!%"'r  -   0P P 0 R
   0   v d       (  d+  ?O-M0 0/? @0  / p
 `	_P  /  /  
  t
  0 p\
 T
 0 `@  0 $  0 `	  0 p	  0 p.  0 `.  .  .  .  |.|  l.l  {\.\  uL  p< 4 0 `g   0 p`  0 X ]P 0 `O-  0 pG-  A
  <
  0 4|+
  0 ,`
  0 $D
  0 (
  0 
  0 .
  0 -
  0 *
  0 
  0 
  0 d
  0 H
  0 ,,
  0 !
  0 
  0 
  0 

  0 	
  0 5
  0 h6
  0 L8
  0 0
  0 
  0 |2
  0 t3
  0 l
  0 d
  0 `]
  0 Up4
  0 MT
  0 E8
  0 =0
  0 5 
  0 p.
  0 &/
  0  
  0 1
  0 x
  0 \
  0 @(
  0 $
  0 '
  0 
  0 
  0 
  0 7
  0 "
  0 d
  0 L$
  0 0#
  0 %
  0 &
  0 )
  0 
  0 
  0 '  0 vl'l  p\'\  jL  e<   0 ]   0 U  0 M  0 `F  0 <&  0 3&  -  (tt  0  X  0 @@  0 ((  0   00      0   0  	 0   0   0 tt  0 \L  0 @@  0 (D  0   0   0   0   0 4 00       pp    ~X<    v<<    n$5    0f    ^    V    OL3 
  0 E(0   0=    5ll    -TT   %08P  0 ` SP 0 p #   0 `	 ^ `(  @(  @(  @	4(  \'  '  '  '  '  x'  '  '  '  '  p'  l'  `'  <\'  (P'  @D'  @4'  ,'  $'  '  &  &  $&  @&  &  &  &  &  &  x&  h&  \&  H&  8&  (&  &  &  %  %  %  %  %  %  %  %  %  %  l%  \%  L%  <%  (%  %  %  $  $  $  $  $  $  $  $  t$  `$  L$  <$  0$   $  $  $  #  #  #  #  #  #  #  #  #  #  t#    \#  L#  PH#  L#  D#  4#   #  #   #  "  "  "   	 "  "  8  "  (  "  "  4  x"  l"  `"  H"  8"    $"  "  H  "  !  @  !  Q  !  P  !  !  0  !  t   !  (  !  p!  8  `!  L!    8!    $!  !   !     $           ,                         |}          D  x  p  d  \  L  D  4  $    x0               ,@    x  h    X  D  0           |  <  x    T         L~        |l  tv\  T  P  H  D0  4   @    X   x        h{        X s  (  X  ly    q        
          x  p    d  \  T  vD  h  t= (    < 	  W l                    p  X  \  @  (        l        p  T  $    L       	  0 `	  0 	 	 0 p"  0   $  0 x@  0 `qX d 0 gx#x  0 p_
  Z
  0 R
  0 J
  0 `C
  0 ;
  0 p4$
  0 ,@
  0 $\
 h
 0 |$|  0 $      0 p  TP 0 `	  0 	 	 0 p %   0 `8  H  0 d  0 ||  0    0   0   0   0    0  &   0 `8&8  H&H  X&X  ~h&h  xx&x  r&  l&  f&  `	  [	  0 pS&  0 `K&  E'  ?  :( 0WP 0 `1D'D  0 p)\'\  #l'l  |'|  '  '      0 p' p 0 `'   
  
 
 0 `,(,  0 `D(D  T(T  d(d  t(t  (     X	`P 0   0   0   0   0 $  0 @@  0 ~X  0 wp)p  0 o)  i90	    p     0   `   0	    
   'P  U0Z0jP  0&^
`    D 0	    
   
`  V	    Z:P 0	p ``   ` 0    $$0    @0    ``0    ||0    R0    0    t0    x0    {0    4G0   TT  0  0   p0  } p0  P u 0   p0  i 0  | p0  ] p0  P U0   h< p0  IT p0  P A0   T p0   5 p0  P -0   @ O@-                   0            (   0         B::SPECIAL     B::MAGIC    B::PADLIST  B::NULL B::PADNAME  pnl, idx    pnl is not a reference  B::PADNAMELIST  padlist padlist is not a reference  cv is not a reference   gv is not a reference   sv is not a reference   argument is not SvROK   argument is not a reference pn  pn is not a reference   he  he is not a reference   pnl padlist, idx    format  format is not a reference   i   h is not a reference    hv  hv is not a reference   can't determine class of operator %s, assuming BASEOP
  o is not a reference    av, idx av is not a reference   io, name    stdin   io is not a reference   stdout  stderr  Invalid value '%s'  ??? NULL gp in B::GV::%s    Illegal alias 0x%08x for B::*SV mg  mg is not a reference   REGEX is only meaningful on r-magic precomp is only meaningful on r-magic   argument to B::BM::TABLE is not a PVBM  Illegal alias 0x%08x for B::*IVX    o, cv   '   \'  \\  \n  \r  \t  \a  \b  \f  \v  \%03o   0   "   \"  \$  \@  nrftax\ opnum   pp_%s   pp_ walkoptree_debug    op, method  op is not a reference   Couldn't add key '%s' to %%B::  Illegal alias %d for B::*OP::next   B::overlay  PL_ppaddr[OP_%s]    B::RHE  method %s not implemented   Illegal type 0x%x for B::*OP::%s    0x%Lx   HEf_SVKEY   SVTYPEMASK  v5.24.0 B.c 1.62    B::formfeed B::amagic_generation    B::comppadlist  B::sv_no    B::sv_undef B::sv_yes   B::main_root    B::main_start   B::dowarn   B::sub_generation   B::walkoptree   B::walkoptree_debug B::address  B::svref_2object    B::opnumber B::ppname   B::hash B::cast_I32 B::minus_c  B::save_BEGINs  B::cchar    B::cstring  B::perlstring   B::threadsv_names   B::CLONE    B::BINOP::last  B::COP::arybase B::COP::cop_seq B::COP::file    B::COP::filegv  B::COP::hints   B::COP::hints_hash  B::COP::io  B::COP::label   B::COP::line    B::COP::stash   B::COP::stashoff    B::COP::stashpv B::COP::warnings    B::LISTOP::children B::LOGOP::other B::LOOP::lastop B::LOOP::nextop B::LOOP::redoop B::METHOP::first    B::METHOP::meth_sv  B::METHOP::rclass   B::OP::desc B::OP::flags    B::OP::folded   B::OP::moresib  B::OP::name B::OP::next B::OP::opt  B::OP::parent   B::OP::ppaddr   B::OP::private  B::OP::savefree B::OP::sibling  B::OP::size B::OP::slabbed  B::OP::spare    B::OP::static   B::OP::targ B::OP::type B::PADOP::gv    B::PADOP::padix B::PADOP::sv    B::PMOP::code_list  B::PMOP::pmflags    B::PMOP::pmoffset   B::PMOP::pmregexp   B::PMOP::pmreplroot B::PMOP::pmreplstart    B::PMOP::pmstash    B::PMOP::pmstashpv  B::PMOP::precomp    B::PMOP::reflags    B::PVOP::pv B::SVOP::gv B::SVOP::sv B::UNOP::first  B::OP::oplist   B::UNOP_AUX::string B::UNOP_AUX::aux_list   B::SV::FLAGS    B::SV::MAGICAL  B::SV::POK  B::SV::REFCNT   B::SV::ROK  B::SV::SvTYPE   B::SV::object_2svref    B::IV::IV   B::AV::MAX  B::BM::USEFUL   B::CV::CvFLAGS  B::CV::FILE B::CV::OUTSIDE  B::CV::OUTSIDE_SEQ  B::CV::STASH    B::GV::GvFLAGS  B::GV::STASH    B::HV::KEYS B::HV::MAX  B::IO::BOTTOM_GV    B::IO::BOTTOM_NAME  B::IO::FMT_GV   B::IO::FMT_NAME B::IO::IoFLAGS  B::IO::IoTYPE   B::IO::LINES    B::IO::LINES_LEFT   B::IO::PAGE B::IO::PAGE_LEN B::IO::TOP_GV   B::IO::TOP_NAME B::IV::IVX  B::IV::UVX  B::NV::NVX  B::PV::CUR  B::PV::LEN  B::PVLV::TARG   B::PVLV::TARGLEN    B::PVLV::TARGOFF    B::PVLV::TYPE   B::PVMG::SvSTASH    B::IV::needs64bits  B::IV::packiv   B::NV::NV   B::REGEXP::REGEX    B::REGEXP::compflags    B::REGEXP::precomp  B::REGEXP::qr_anoncv    B::PV::RV   B::BM::TABLE    B::PV::PV   B::PV::PVBM B::PV::PVX  B::PVMG::MAGIC  B::MAGIC::FLAGS B::MAGIC::LENGTH    B::MAGIC::MOREMAGIC B::MAGIC::OBJ   B::MAGIC::PRIVATE   B::MAGIC::PTR   B::MAGIC::REGEX B::MAGIC::TYPE  B::MAGIC::precomp   B::BM::PREVIOUS B::BM::RARE B::GV::FILE B::GV::NAME B::HV::NAME B::GV::isGV_with_GP B::GV::is_empty B::GV::GP   B::GV::AV   B::GV::CV   B::GV::CVGEN    B::GV::EGV  B::GV::FORM B::GV::GvREFCNT B::GV::HV   B::GV::IO   B::GV::SV   B::GV::LINE B::GV::GPFLAGS  B::GV::FILEGV   B::IO::IsSTD    B::AV::FILL B::AV::ARRAY    B::AV::ARRAYelt B::FM::LINES    B::CV::CONST    B::CV::ROOT B::CV::START    B::CV::DEPTH    B::CV::PADLIST  B::CV::HSCXT    B::CV::XSUB B::CV::XSUBANY  B::CV::const_sv B::CV::GV   B::CV::NAME_HEK B::HV::FILL B::HV::RITER    B::HV::ARRAY    B::HE::SVKEY_force  B::HE::VAL  B::HE::HASH B::RHE::HASH    B::PADLIST::MAX B::PADNAMELIST::MAX B::PADLIST::NAMES   B::PADLIST::ARRAY   B::PADLIST::ARRAYelt    B::PADLIST::REFCNT  B::PADNAMELIST::ARRAY   B::PADNAMELIST::ARRAYelt    B::PADLIST::id  B::PADLIST::outid   B::PADNAME::COP_SEQ_RANGE_HIGH  B::PADNAME::COP_SEQ_RANGE_LOW   B::PADNAME::LEN B::PADNAME::OURSTASH    B::PADNAME::REFCNT  B::PADNAME::TYPE    B::PADNAMELIST::REFCNT  B::PADNAME::PV  B::PADNAME::FLAGS   B:: B::EXPORT_OK    B.xs    B::init_av  B::check_av B::unitcheck_av B::begin_av B::end_av   B::main_cv  B::inc_gv   B::defstash B::curstash B::regex_padav  B::warnhook B::diehook  B::OP::does_parent  B::PADNAME::SvSTASH B::PADNAME::PROTOCV B::PADNAME::PVX B::PADNAME::PARENT_PAD_INDEX    B::PADNAME::PARENT_FAKELEX_FLAGS    SVt_PVGV    SVt_PVHV    PAD_FAKELEX_ANON    PAD_FAKELEX_MULTI   SVpad_STATE SVpad_TYPED SVpad_OUR   CXTYPEMASK  CXt_NULL    CXt_WHEN    CXt_BLOCK   CXt_GIVEN   CXt_LOOP_ARY    CXt_LOOP_LAZYSV CXt_LOOP_LAZYIV CXt_LOOP_LIST   CXt_LOOP_PLAIN  CXt_SUB CXt_FORMAT  CXt_EVAL    CXt_SUBST   CXp_MULTICALL   CXp_HASARGS CXp_SUB_RE  CXp_SUB_RE_FAKE CXp_REAL    CXp_TRYBLOCK    CXp_FOR_DEF CXp_FOR_LVREF   CXp_FOR_GV  CXp_FOR_PAD CXp_ONCE    G_SCALAR    G_ARRAY G_VOID  G_WANT  G_DISCARD   G_EVAL  G_NOARGS    G_KEEPERR   G_NODEBUG   G_METHOD    G_FAKINGEVAL    G_UNDEF_FILL    G_WRITING_TO_STDERR G_RE_REPARSING  G_METHOD_NAMED  EVAL_NULL   EVAL_INEVAL EVAL_WARNONLY   EVAL_KEEPERR    EVAL_INREQUIRE  EVAL_RE_REPARSING   PERLSI_UNDEF    PERLSI_MAIN PERLSI_MAGIC    PERLSI_SORT PERLSI_SIGNAL   PERLSI_OVERLOAD PERLSI_DESTROY  PERLSI_WARNHOOK PERLSI_DIEHOOK  PERLSI_REQUIRE  PERLSI_MULTICALL    CVf_METHOD  CVf_LVALUE  CVf_CONST   CVf_ISXSUB  CVf_WEAKOUTSIDE CVf_CLONE   CVf_CLONED  CVf_ANON    CVf_UNIQUE  CVf_NODEBUG CVf_CVGV_RC CVf_DYNFILE CVf_AUTOLOAD    CVf_HASEVAL CVf_NAMED   CVf_LEXICAL CVf_ANONCONST   GVf_INTRO   GVf_MULTI   GVf_ASSUMECV    GVf_IMPORTED    GVf_IMPORTED_SV GVf_IMPORTED_AV GVf_IMPORTED_HV GVf_IMPORTED_CV OPf_WANT    OPf_WANT_VOID   OPf_WANT_SCALAR OPf_WANT_LIST   OPf_KIDS    OPf_PARENS  OPf_REF OPf_MOD OPf_STACKED OPf_SPECIAL OPf_FOLDED  PMf_RETAINT PMf_ONCE    PMf_USED    PMf_CONST   PMf_KEEP    PMf_GLOBAL  PMf_CONTINUE    PMf_EVAL    PMf_NONDESTRUCT PMf_HAS_CV  PMf_CODELIST_PRIVATE    PMf_IS_QR   PMf_USE_RE_EVAL OA_MARK OA_FOLDCONST    OA_RETSCALAR    OA_TARGET   OA_TARGLEX  OA_OTHERINT OA_DANGEROUS    OA_DEFGV    OCSHIFT OA_CLASS_MASK   OA_BASEOP   OA_UNOP OA_BINOP    OA_LOGOP    OA_LISTOP   OA_PMOP OA_SVOP OA_PADOP    OA_PVOP_OR_SVOP OA_LOOP OA_COP  OA_BASEOP_OR_UNOP   OA_FILESTATOP   OA_LOOPEXOP OA_METHOP   OA_UNOP_AUX OASHIFT OA_SCALAR   OA_LIST OA_AVREF    OA_HVREF    OA_CVREF    OA_FILEREF  OA_SCALARREF    OA_OPTIONAL PERL_LOADMOD_DENY   PERL_LOADMOD_NOIMPORT   PERL_LOADMOD_IMPORT_OPS BHKf_bhk_start  BHKf_bhk_pre_end    BHKf_bhk_post_end   BHKf_bhk_eval   RV2CVOPCV_MARK_EARLY    RV2CVOPCV_RETURN_NAME_GV    RV2CVOPCV_RETURN_STUB   RV2CVOPCV_FLAG_MASK OP_LVALUE_NO_CROAK  XOPf_xop_name   XOPf_xop_desc   XOPf_xop_class  XOPf_xop_peep   MDEREF_reload   MDEREF_AV_pop_rv2av_aelem   MDEREF_AV_gvsv_vivify_rv2av_aelem   MDEREF_AV_padsv_vivify_rv2av_aelem  MDEREF_AV_vivify_rv2av_aelem    MDEREF_AV_padav_aelem   MDEREF_AV_gvav_aelem    MDEREF_HV_pop_rv2hv_helem   MDEREF_HV_gvsv_vivify_rv2hv_helem   MDEREF_HV_padsv_vivify_rv2hv_helem  MDEREF_HV_vivify_rv2hv_helem    MDEREF_HV_padhv_helem   MDEREF_HV_gvhv_helem    MDEREF_ACTION_MASK  MDEREF_INDEX_none   MDEREF_INDEX_const  MDEREF_INDEX_padsv  MDEREF_INDEX_gvsv   MDEREF_INDEX_MASK   MDEREF_FLAG_last    MDEREF_MASK MDEREF_SHIFT    OPpLVREF_SV OPpARG1_MASK    OPpCOREARGS_DEREF1  OPpENTERSUB_INARGS  OPpSORT_NUMERIC OPpTRANS_FROM_UTF   OPpCONST_NOVER  OPpCOREARGS_DEREF2  OPpEVAL_HAS_HH  OPpFT_ACCESS    OPpHINT_STRICT_REFS OPpITER_REVERSED    OPpSORT_INTEGER OPpTRANS_TO_UTF OPpARG2_MASK    OPpCONST_SHORTCIRCUIT   OPpDONT_INIT_GV OPpENTERSUB_HASTARG OPpEVAL_UNICODE OPpFT_STACKED   OPpLVREF_ELEM   OPpSLICEWARNING OPpSORT_REVERSE OPpTRANS_IDENTICAL  OPpARG3_MASK    OPpPADRANGE_COUNTSHIFT  OPpCONST_STRICT OPpENTERSUB_AMPER   OPpEVAL_BYTES   OPpFT_STACKING  OPpITER_DEF OPpLVREF_ITER   OPpMAYBE_LVSUB  OPpREVERSE_INPLACE  OPpSORT_INPLACE OPpTRANS_SQUASH OPpARG4_MASK    OPpASSIGN_COMMON_AGG    OPpCONST_ENTERED    OPpDEREF_AV OPpEVAL_COPHH   OPpFT_AFTER_t   OPpLVREF_AV OPpMAYBE_TRUEBOOL   OPpMULTIDEREF_EXISTS    OPpOPEN_IN_RAW  OPpSORT_DESCEND OPpSUBSTR_REPL_FIRST    OPpTARGET_MY    OPpASSIGN_COMMON_RC1    OPpDEREF_HV OPpEARLY_CV OPpEVAL_RE_REPARSING    OPpHUSH_VMSISH  OPpLVREF_HV OPpMAY_RETURN_CONSTANT  OPpMULTIDEREF_DELETE    OPpOPEN_IN_CRLF OPpSORT_QSORT   OPpTRANS_COMPLEMENT OPpTRUEBOOL OPpDEREF    OPpDEREF_SV OPpLVREF_CV OPpLVREF_TYPE   OPpALLOW_FAKE   OPpASSIGN_BACKWARDS OPpASSIGN_COMMON_SCALAR OPpCONST_BARE   OPpCOREARGS_SCALARMOD   OPpENTERSUB_DB  OPpEXISTS_SUB   OPpFLIP_LINENUM OPpLIST_GUESSED OPpLVAL_DEFER   OPpOPEN_OUT_RAW OPpOUR_INTRO    OPpPAD_STATE    OPpREFCOUNTED   OPpREPEAT_DOLIST    OPpRUNTIME  OPpSLICE    OPpSORT_STABLE  OPpTRANS_GROWS  OPpPADRANGE_COUNTMASK   OPpASSIGN_CV_TO_GV  OPpCOREARGS_PUSHMARK    OPpENTERSUB_NOPAREN OPpLVALUE   OPpLVAL_INTRO   OPpOFFBYONE OPpOPEN_OUT_CRLF    OPpPV_IS_UTF8   OPpSPLIT_IMPLIM OPpTRANS_DELETE RXf_PMf_STD_PMMOD_SHIFT RXf_PMf_MULTILINE   RXf_PMf_SINGLELINE  RXf_PMf_FOLD    RXf_PMf_EXTENDED    RXf_PMf_EXTENDED_MORE   RXf_PMf_NOCAPTURE   RXf_PMf_KEEPCOPY    RXf_PMf_CHARSET RXf_PMf_STRICT  RXf_PMf_SPLIT   PADNAMEt_OUTER  PADNAMEt_STATE  PADNAMEt_LVALUE PADNAMEt_TYPED  PADNAMEt_OUR    RXf_NO_INPLACE_SUBST    RXf_EVAL_SEEN   RXf_UNBOUNDED_QUANTIFIER_SEEN   RXf_CHECK_ALL   RXf_MATCH_UTF8  RXf_USE_INTUIT_NOML RXf_USE_INTUIT_ML   RXf_INTUIT_TAIL RXf_IS_ANCHORED RXf_COPY_DONE   RXf_TAINTED_SEEN    RXf_TAINTED RXf_START_ONLY  RXf_SKIPWHITE   RXf_WHITE   RXf_NULL    SVf_IOK SVf_NOK SVf_POK SVf_ROK SVp_IOK SVp_NOK SVp_POK SVp_SCREAM  SVf_PROTECT SVs_PADTMP  SVs_PADSTALE    SVs_TEMP    SVs_OBJECT  SVs_GMG SVs_SMG SVs_RMG SVf_FAKE    SVf_OOK SVf_BREAK   SVf_READONLY    SVf_AMAGIC  SVf_IsCOW   SVf_UTF8    SVf_IVisUV  SVs_PADMY   next    sibling targ    flags   private first   other   pmreplstart redoop  nextop  lastop  pmflags code_list   padix   pmoffset    size    desc    ppaddr  type    opt spare   children    pmreplroot  pmstashpv   pmstash precomp reflags slabbed savefree    static  folded  moresib meth_sv pmregexp    rclass  B::OP   B::UNOP B::BINOP    B::LOGOP    B::LISTOP   B::PMOP B::SVOP B::PADOP    B::PVOP B::LOOP B::COP  B::METHOP   B::UNOP_AUX B::IV   B::NV   B::PV   B::INVLIST  B::PVIV B::PVNV B::PVMG B::REGEXP   B::GV   B::PVLV B::AV   B::HV   B::CV   B::FM   B::IO                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       %  8%        H  P  X  `  l  t  |                                         (  0  <                                         $       	,               $ X                 h        x                (    0    8    <    D    P  
  \  	  h    p    x                 H            <    (  
                      d                    (  	                   4  
               	                                            (            4            @  	          L  
          X             d            p  	          |  	                                                                           	         
   
                     	                                      
   @       ,            <             H     @       X            d             t  
   @                                                                                 	                                    	             	   @                                                         4            D            T  	           `            l            |                                                                                                                                     (            8     	       H     
       \  
          h  
          t  	            
                        	             
   @                     
                                                                  @        	                      $            4  	          @  	          L            \            l            |                  @                                                                                 
                                         @                   (  
          4            @            L             X  	     @     d            p  
          |                                      
                         	      @                                                       	            
          (             4     @       D            P            X            h  	           t            |                          	                                                                	            
                                             	                      $            ,  	          8            @            L            X            d  
          p                                                                                                                        0            L            d            x                                                                                       !            "          @            `            x                          !   	         "   
                               ,            D            X             l                              0            0            @                                                                                0            @            T            d            x                                                                                                                        ,            <            L            \            l            |                                                                                                                        (            <            L            \            l                                                                                                                                    4            D             \             h             t                                                                                                                          0       $     0       0     0       <     0       L     @       \     @       p     @            @            @            @            @            @            @            @             @            @             @       0     @       @     @       T  
   @       `     @       l     @       |     @                                                         	                                                            0            @            P             h            |                                                                  @                                          l                                                                              @                    
            	          $            4            D            T            d            t                                                                                @                             $            4            H            T            d             t  	      @                                                                                               @        
                        
                                    
                              @                  (            4            <  	          H            X  
          d  	          p             |  
            	                                   %     h      ,                      o          d  
   }                                              oh  o   o  o                                                   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t   t                                                    A,   aeabi "   6 	
"B.so    X .shstrtab .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .text .fini .rodata .eh_frame .init_array .fini_array .jcr .data.rel.ro .dynamic .got .data .bss .ARM.attributes .gnu_debuglink                                                           $                     o       L                (         d  d                0             }                 8   o                       E   o   h  h  @                T   	                          ]   	   B                     f         h   h                     a         t   t                   l         x$  x$                   r         ,  ,                    x         4  4  *                                                                                                                                                    @                                                                                                                                        p         -                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ELF          (      4   b    4    (                  X  X           _  _ _              _  _ _                         $   $         Qtd                          Rtd_  _ _                      GNU hM7~Su   8          "3 B8   ;   >    4BE|WqXvT<F/	Xy)cn                    `       	     _                                                            R           "                               V                                       u                           C                          8                          J             u                                                     x                                                                              s                                                       6                          L                                                     k             ^             ,                                       Y             i                                                     a               +                           8                                            `         `       !  `         `         `          `       	   `          L        [  ,I         `       m  DI  D     __gmon_start__ _init _fini _ITM_deregisterTMCloneTable _ITM_registerTMCloneTable __cxa_finalize _Jv_RegisterClasses Perl_sv_derived_from Perl_sv_2iv_flags Perl_sv_newmortal Perl_sv_setuv_mg Perl_croak_nocontext Perl_croak_xs_usage BZ2_bzDecompressEnd Perl_safesysfree BZ2_bzlibVersion Perl_sv_setpv Perl_mg_set pthread_getspecific Perl_newSVpv Perl_sv_2mortal Perl_mg_get PL_thr_key Perl_sv_pvbyten_force Perl_sv_upgrade __stack_chk_fail __stack_chk_guard Perl_sv_2pv_flags BZ2_bzDecompress Perl_sv_grow Perl_sv_setnv Perl_sv_pvn_force_flags Perl_sv_utf8_downgrade Perl_sv_utf8_upgrade_flags_grow memmove __printf_chk putchar puts Perl_sv_2pvbyte BZ2_bzCompress BZ2_bzCompressEnd Perl_safesysmalloc memset BZ2_bzDecompressInit Perl_sv_setref_pv Perl_newSViv Perl_dowantarray Perl_stack_grow BZ2_bzCompressInit Perl_newSVpvf_nocontext memcmp Perl_sv_setiv_mg bz_internal_error boot_Compress__Raw__Bzip2 Perl_xs_handshake Perl_newXS_deffile Perl_xs_boot_epilog libbz2.so.1.0 libc.so.6 ld-linux-armhf.so.3 _edata __bss_start __bss_start__ __bss_end__ __end__ _end GLIBC_2.4                                                                                                                                ii   &                 ii   &      _    _    `    `   ` 	  `   `   `   ` 2  ` 5  `   `   `   `   `    `   $` 
  (`   ,`   0`   4`   8`   <`   @`   D`   H`   L`   P`   T`   X`   \`   ``   d`   h`   l`   p`   t`    x` !  |` "  ` #  ` $  ` %  ` &  ` '  ` (  ` )  ` *  ` +  ` ,  ` -  ` .  ` /  ` 0  ` 1  ` 3  ` 4  ` 6  ` 7  @-  -S   | t l d \ T L D < 4 , $                     | t l d \ T L D < 4 , $   0 0   R/0Q    404 0  0 0C S 00/ 0  S//Q Q P    88    A,0A0/ 0  S//Q Q P    L0L 0  0  S/80@-0  S  
(0 <0 0  \Q lP    ,Q Q 8 80    0  R     0  S
@-3/@O  P        A-D0 CD P 0Q0CC1 SH  0 @ 2  
0ap02  
     P,  
0  0S  
  e0 0#  R 00  SD P  
 0 0`0p p 0 X  ` L808 88 0     =     <  l>  <  $=  T>  A-D0 CD P 0Q0CC1 SH  0 @ 2  
0ap02  
     P,  
0  0S  
  e0 0#  R 00  S@ P  
 0 0`0p p 0   ` 808 88 0     8<     d;  <  ;  ;  <  A-D0 CD P 0Q0CC1 SH  0 @ 2  
0ap02  
   J  P,  
0  0S  
  %e0 0#  R 00  S P  
 0 0`0p p 0   ` 808 88 0   T  A:     9  \;  \:  :  D;  A-D0 CD P 0Q0CC1 SH  0 @ 2  
0ap02  
     P,  
0  0S  
  e0 0#  R 00  S P  
 0 0`0p p 0 2  ` &808 88 0     (9     T8  9  8  8  9  A-D0 CD P 0Q0CC1 SH  0 @ 2  
0ap02  
     P,  
0  0S  
  ae0 0#  R 00  S8 P  
 0 0`0p p 0   ` 808 88 0     }7     6  L8  7  7  48  A-D0 CD P 0Q0CC1 SH  0 @ 2  
0ap02  
   $  P,  
0  0S  
  e0 0#  R 00  S< P  
 0 0`0p p 0 n  ` b808 88 0   .  6     D5  6  46  |5  6  A-D0 CD P 0Q0CC1 SH  0 @ 2  
0ap02  
     P,  
0  0S  
  e0 0#  R 00  SD P  
 0 0`0p p 0   `  808 88 0     5     4  <5  4  3  $5  A-D0 CD P 0Q0CC1 SH  0 @ 2  
0ap02  
   `  P,  
0  0S  
  ;e0 0#  R 00  S@ P  
 0 0`0p p 0   ` 808 88 0   j  W(4     T3  3  3  l2  3  A-D0 CD P 0Q0CC1 SH  0 @ 2  
0ap02  
     P,  
0  0S  
  e0 0#  R 00  S P  
 0 0`0p p 0 H  ` <808 88 0     2     1  ,2  ,2  0  2  A-D0 CD P 0Q0CC1 SH  0 @ 2  
0ap02  
     P,  
0  0S  
  we0 0#  R 00  S P  
 0 0`0p p 0   ` 808 88 0     1     D0  0  0  \/  0  p@-D0 CD P 0Q 0CC1 S  0   
t0 @ 0S
  
 & ` P 0P Pp 0`( ((    m Z   /  0  (0  /  A-D0 CD P 0Q 0C#1  0 @    
 0a
   !0pp  `0PP Po ` I &$3  0 0p@- @ P  0 `$  	  
@0  s  B R"    ,  s Q  
   Q  
t 
  p@! p 00,       >     
  2  .  h.  10A-p`!M  @0  0 T  \ P  s  R  
tQt!PPUP  
@0>  \s  P&  
 B RE  >  ,!   R  s0 S"    U&   10S  
    0  R+  W.|  Q
    R
PPPUP  _  U
x   d 00@   C0   {=        
     9x-  0  ,  |,  O-,MED 5@B0D  P0! 00C @C1 S$@X 0@0P0`< 
P% p   P6 
 85  0S  
   @ 4P 0    0  
|      
$ R  
 0    0	  00 2  
|0 0  0  
0 00  0 00  0  S0  
       
 C  B U     R  *0 00 0KK0  <   S	  

   P   0 0    S3   0	    PP  
   P
 P `8   
 j @  n4#`f " 0"<00$ @00 00 0 R  ,   R `8`@ D H0H A <0D @ 0  
2<;0<000    Q  00Y  0k   0   
0  0  R ]     0 00]   j  @ !  V 
0!0   RZ  ! R
  
0  0!0 a       0 0 0# 0@     P1  
0    0P0   1 	 $0
     	  00 0 	 (  $0  0   p   h   0 X L;    )     ,,     +  %  +     (  $  8&  X'  $  '  `'  '  A-P   @   U  
x  
   T  
X  H0  8$  (  0  S  
  `PFp`   U
   0  S  
 `PFp`   U
 p  `  P4  @  0        }    x 0      o 0      f 0      ]
 AW      x A  ,'  '  '  '  '  '  (  '  '  '  '  `'  h'  p'  x'  '  '  '  '  %  '  %  '  %  |'  l%  `%  T%  p%  A-D0 CD ` Pa0PEEQ0E SF  p08  
! @   P2  
 0  0S$  
   U p"  000  s  R  
   R     R	  
     0` ` 0 Up @0@ @@ 0    (       
       H!  %      %  A-D0 CD ` Pa0PEEQ0E SF  p08  
! @ h  P2  
 0  0S$  
  C U p"  000  s  R  
   R     R	  
   ]  0` ` 0 Up @0@ @@ 0   l (YH       
     \    <$  t  #  O-MD0 CD 0 @1@DDA T  0p 0P0  
" `   P  
 2  0S|  
   @h 0 04P?0   
|0 0 l  
 0  S  0  000 0ppG0p	  
  @/o"/ 0  0  S 0	   pPP  @ p B  P8 @   
  !0:  @ 08!  S "   0  "<00@00 0  
",+ pGp    0(  @ l0 0c " 0@   n  Pl    	 0L0L LL 0    4      ?     #  !    !  4    D!  L  $!  O-MD0 CD 0 @1@DDA T  0p 0P0  
" ` 5  P  
 2  0S|  
   @l 0 04Pr0   
|0 0 l  
 0  S  0  000 0ppG0p	  
 @ @/o"/ 0  0  S 0	   *pPP  @ p B  P8 @   
  T0:  @ 0<!  S "   0  "<00@00 0  
",+ pGp    0+)  @ 0 0c " 0@     Pp    	 0P0P PP 0    8        @|          d       `  p      O-D 3BM0D  @`0! 00C C1 S  00`0p  
x# P ^  P  
 `3  0S  
  9 @8 4`X    
|0 0   
30S  
 0  X0	  0   
|0 0 |  
 00  0   0    ppGp   
 S  P 0    Q  
  R 0	   =p``  D @p G  @ S80@ D!  
 0b0:  @ 0!  S '   0"<00 @00 00 0 RF    
",+ pGp &   04:  @ 0 0c " 0@c 0 00u     P|        P  
 Z	 00p0p pp 0   \    L        ?)               l      |    P        <  p@-D0 CD P 0Q 0CC1 S  0   
t0 @ 0S
  
 B `  0P Pp 0`( ((     v   0  H      @-H bH   @| O-MD0 CD ` Pa ELqG ^   @PE z  r  Pw  
   Pr  
 Wz  #   R     W00  
T#   R     W  
$#   R     W    
"   R     W 0 0
  
 2` 0S|   00 0 `P  
	   Py  0 p 0p  Zp  Sp   p48  /0   00C S `i  `0P  C  
 @o  P   P  P
  
    W  	 {	 ?     ` rX!  Y 4   0"<000C S6  `P P  Y W d 	    K m  F \  A    < l  `x i " 0 8 P 0 1 P ,j 	 \ 
        d    $  O-D 0BD ` Pa0 EBqG \   @PE0d  s  Ra  
#   R\  
 Wd   3  0S   0 W  
 2  0S   0 W 
`  
 2  0S   0 W `	  
 h2` 0Sm   0` pP`  
 
0  `Pj   9 8`40 <0   00C S pa  p0P  @  
 @o  P   P! R
  
    W  
` ?   j  p ,!  V -   0"<000C S/  pP P  h W z 
`   [ x  V `  Q |  ph `f " 0 M P 0 F P  
          $	    C-D4PN `DP  PM0 E B \& PE @  ;  
 q4 0S-  
0  < 0 0C S  K  T    Z  c    n  |                0D S  
E S  
  i  W0   0 0 R   00 0` 0 p    P 00C S  00e0 X0# Q 00  S  
, 0p$    P       P
    P 0H Sc  
K S    P
0F SL  
I S|    P 
0M SY  
N SD    P 
0N S@  
O Sz  }  P 
p  s  P 
f0F SE  
G Sa  d  P {
W  Z  P  q
Mh  P  PF fD  F  P
;(  >  P U
1  4  P K
'  *  P A
     P 7
 	0 "C 0  P- \9         P          x  X  <  $      D    0    0        @-  ,  x20@-M0 0h"h2 @0  X?T"T  P @"@  0"0   "   "   "   !  !  !  !  !  !  !  !  p!p  `!`  P!P  @!@  0!0   !   !   !   S 01 S   0@oJ          @	L|    |  @   
  `    x
  ,X
    x  \8    	  T8  p  |4  4       T`       @-End of Stream                   Finish OK                       Flush OK                        Run OK                                                          Sequence Error                  Param Error                     Memory Error                    Data Error                      Magic Error                     IO Error                        Unexpected EOF                  Output Buffer Full              Config Error                                                    Compress::Raw::Bunzip2  Compress::Raw::Bunzip2::uncompressedBytes   %s: %s is not of type %s    Compress::Raw::Bunzip2::compressedBytes Compress::Raw::Bunzip2::total_out_lo32  Compress::Raw::Bunzip2::total_in_lo32   Compress::Raw::Bunzip2::status  Compress::Raw::Bunzip2::inflateCount    Compress::Raw::Bzip2    Compress::Raw::Bzip2::uncompressedBytes Compress::Raw::Bzip2::compressedBytes   Compress::Raw::Bzip2::total_out_lo32    Compress::Raw::Bzip2::total_in_lo32 Compress::Raw::Bunzip2::DESTROY %s: %s is not a reference   %s: buffer parameter is not a SCALAR reference  %s: buffer parameter is a reference to a reference  %s: buffer parameter is read-only   s, buf, output  Compress::Raw::Bunzip2::bzinflate   Compress::Raw::Bunzip2::bzinflate input parameter cannot be read-only when ConsumeInput is specified    Wide character in Compress::Raw::Bunzip2::bzinflate input parameter Wide character in Compress::Raw::Bunzip2::bzinflate output parameter    Enabled Disabled    DispStream 0x%p  - %s 
     stream pointer is NULL      stream           0x%p
             opaque    0x%p
             state     0x%p
             next_in   0x%p              next_out  0x%p    =>  %02x              avail_in  %lu
              avail_out %lu
       bufsize          %lu
         total_in_lo32  %u
          total_in_hi32  %u
          total_out_lo32 %u
          total_out_hi32 %u
        flags            0x%x
             APPEND    %s
               CONSUME   %s
               LIMIT     %s
    s, message=NULL Compress::Raw::Bunzip2::DispStream  Compress::Raw::Bzip2::DispStream    s, output   Compress::Raw::Bzip2::bzflush   Wide character in Compress::Raw::Bzip2::bzflush input parameter Compress::Raw::Bzip2::bzclose   Wide character in Compress::Raw::Bzip2::bzclose input parameter Compress::Raw::Bzip2::bzdeflate Wide character in Compress::Raw::Bzip2::bzdeflate input parameter   Wide character in Compress::Raw::Bzip2::bzdeflate output parameter  Compress::Raw::Bzip2::DESTROY   className, appendOut=1, consume=1, small=0, verbosity=0, limitOutput=0  className, appendOut=1, blockSize100k=1, workfactor=0, verbosity=0  sv  BZ_OK   BZ_RUN  BZ_FLUSH    BZ_FINIS    BZ_RUN_O    BZ_FLUSH_OK BZ_IO_ERROR BZ_MEM_ERROR    BZ_FINISH_OK    BZ_STREAM_END   BZ_DATA_ERROR   BZ_PARAM_ERROR  BZ_OUTBUFF_FULL BZ_CONFIG_ERROR BZ_UNEXPECTED_EOF   BZ_SEQUENCE_ERROR   BZ_DATA_ERROR_MAGIC %s is not a valid Bzip2 macro   bz_internal_error %d
   v5.24.0 Bzip2.c 2.069   Compress::Raw::Bzip2::constant  Compress::Raw::Bzip2::bzlibversion  Compress::Raw::Bzip2::new   Compress::Raw::Bunzip2::new Compress::Raw::Bzip2 needs bzip2 version 1.x, you have %s
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                `     L     _          _       o          h  
   0            `               
     
     P         oP
  o   o	  o                                           _         l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l                              ` A,   aeabi "   6 	
"Bzip2.so    > .shstrtab .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .text .fini .rodata .eh_frame .init_array .fini_array .jcr .dynamic .got .data .bss .ARM.attributes .gnu_debuglink                                                        $                     o       P                (         h  h  0              0             0                 8   o   	  	                  E   o   P
  P
  @                T   	      
  
  P                ]   	   B   
  
                f         `  `                    a         l  l  T                l             =                 r         L  L                    x         L  L  0                          X  X                             _ _                            _ _                            _ _                             _ _                            `  `                            ` `                             ` `                         p        `  -                                a                                  )a                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ELF          (      4   h    4    (                  h  h               L  P                                       $   $         Qtd                          Rtd                         GNU 6cY,FAU   O           @( A%DO   T   W    4BE|sFWqXvT<1Yy                    x       	                                       8                                       R           "                                            *                                                                                            ;                          r             ]             y                                       L                          m             (                                                                  t                          )                                         .                          2             T             "             .             ?                                                                               !                          !                                                    Z                                                                               G                          a               Z                          B             f                           9             8                                                                                                 p         T         P       2  T       u   h         T         P          x       	   P       i    |               *  T        __gmon_start__ _init _fini _ITM_deregisterTMCloneTable _ITM_registerTMCloneTable __cxa_finalize _Jv_RegisterClasses my_zcalloc Perl_safesysmalloc my_zcfree Perl_safesysfree Perl_sv_derived_from Perl_sv_2iv_flags Perl_sv_newmortal Perl_sv_setuv_mg Perl_croak_nocontext Perl_croak_xs_usage memset Perl_sv_2pvbyte Perl_sv_2bool_flags Perl_sv_setpv Perl_mg_set zlibVersion pthread_getspecific Perl_newSVpv Perl_sv_2mortal Perl_mg_get PL_thr_key crc32 Perl_sv_2uv_flags Perl_sv_utf8_downgrade __stack_chk_fail __stack_chk_guard adler32 __printf_chk putchar puts inflateEnd Perl_sv_free2 Perl_sv_pvbyten_force Perl_sv_upgrade deflateTune Perl_sv_setiv_mg deflateEnd adler32_combine crc32_combine zlibCompileFlags __errno_location strerror Perl_sv_setnv Perl_sv_pvn_force_flags inflateSync memmove Perl_sv_2pv_flags inflate Perl_sv_grow inflateSetDictionary Perl_sv_utf8_upgrade_flags_grow deflateParams deflate deflateInit2_ Perl_sv_setref_pv deflateSetDictionary deflatePrime Perl_newSViv Perl_dowantarray Perl_stack_grow inflateReset deflateReset inflateInit2_ Perl_sv_len Perl_newSVsv memcmp Perl_newSVpvf_nocontext Perl_sv_setpvn boot_Compress__Raw__Zlib Perl_xs_handshake Perl_newXS_deffile Perl_get_sv Perl_sv_setiv Perl_xs_boot_epilog libz.so.1 libc.so.6 ld-linux-armhf.so.3 _edata __bss_start __bss_start__ __bss_end__ __end__ _end ZLIB_1.2.0.2 ZLIB_1.2.0.8 ZLIB_1.2.2.3 ZLIB_1.2.2 GLIBC_2.4                                                                                                                                                                     P   2   7     8   D     3   Q     '   ^                 ii   i                 ii   i              L    ( O  ,   0   4   8   < &  @ S  D A  H H                     $ 	  ( 
  ,   0   4   8   <   @   D   H   L   P   T   X   \   `   d   h   l   p   t    x !  | "   #   $   %   &   '   (   )   *   +   ,   -   .   /   0   1   2   3   4   5   6   7   8   9   :   ;   <   =  