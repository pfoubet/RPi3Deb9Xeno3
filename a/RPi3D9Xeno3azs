"""distutils.extension

Provides the Extension class, used to describe C/C++ extension
modules in setup scripts."""

__revision__ = "$Id$"

import os, string, sys
from types import *

try:
    import warnings
except ImportError:
    warnings = None

# This class is really only used by the "build_ext" command, so it might
# make sense to put it in distutils.command.build_ext.  However, that
# module is already big enough, and I want to make this class a bit more
# complex to simplify some common cases ("foo" module in "foo.c") and do
# better error-checking ("foo.c" actually exists).
#
# Also, putting this in build_ext.py means every setup script would have to
# import that large-ish module (indirectly, through distutils.core) in
# order to do anything.

class Extension:
    """Just a collection of attributes that describes an extension
    module and everything needed to build it (hopefully in a portable
    way, but there are hooks that let you be as unportable as you need).

    Instance attributes:
      name : string
        the full name of the extension, including any packages -- ie.
        *not* a filename or pathname, but Python dotted name
      sources : [string]
        list of source filenames, relative to the distribution root
        (where the setup script lives), in Unix form (slash-separated)
        for portability.  Source files may be C, C++, SWIG (.i),
        platform-specific resource files, or whatever else is recognized
        by the "build_ext" command as source for a Python extension.
      include_dirs : [string]
        list of directories to search for C/C++ header files (in Unix
        form for portability)
      define_macros : [(name : string, value : string|None)]
        list of macros to define; each macro is defined using a 2-tuple,
        where 'value' is either the string to define it to or None to
        define it without a particular value (equivalent of "#define
        FOO" in source or -DFOO on Unix C compiler command line)
      undef_macros : [string]
        list of macros to undefine explicitly
      library_dirs : [string]
        list of directories to search for C/C++ libraries at link time
      libraries : [string]
        list of library names (not filenames or paths) to link against
      runtime_library_dirs : [string]
        list of directories to search for C/C++ libraries at run time
        (for shared extensions, this is when the extension is loaded)
      extra_objects : [string]
        list of extra files to link with (eg. object files not implied
        by 'sources', static library that must be explicitly specified,
        binary resource files, etc.)
      extra_compile_args : [string]
        any extra platform- and compiler-specific information to use
        when compiling the source files in 'sources'.  For platforms and
        compilers where "command line" makes sense, this is typically a
        list of command-line arguments, but for other platforms it could
        be anything.
      extra_link_args : [string]
        any extra platform- and compiler-specific information to use
        when linking object files together to create the extension (or
        to create a new static Python interpreter).  Similar
        interpretation as for 'extra_compile_args'.
      export_symbols : [string]
        list of symbols to be exported from a shared extension.  Not
        used on all platforms, and not generally necessary for Python
        extensions, which typically export exactly one symbol: "init" +
        extension_name.
      swig_opts : [string]
        any extra options to pass to SWIG if a source file has the .i
        extension.
      depends : [string]
        list of files that the extension depends on
      language : string
        extension language (i.e. "c", "c++", "objc"). Will be detected
        from the source extensions if not provided.
    """

    # When adding arguments to this constructor, be sure to update
    # setup_keywords in core.py.
    def __init__ (self, name, sources,
                  include_dirs=None,
                  define_macros=None,
                  undef_macros=None,
                  library_dirs=None,
                  libraries=None,
                  runtime_library_dirs=None,
                  extra_objects=None,
                  extra_compile_args=None,
                  extra_link_args=None,
                  export_symbols=None,
                  swig_opts = None,
                  depends=None,
                  language=None,
                  **kw                      # To catch unknown keywords
                 ):
        assert type(name) is StringType, "'name' must be a string"
        assert (type(sources) is ListType and
                map(type, sources) == [StringType]*len(sources)), \
                "'sources' must be a list of strings"

        self.name = name
        self.sources = sources
        self.include_dirs = include_dirs or []
        self.define_macros = define_macros or []
        self.undef_macros = undef_macros or []
        self.library_dirs = library_dirs or []
        self.libraries = libraries or []
        self.runtime_library_dirs = runtime_library_dirs or []
        self.extra_objects = extra_objects or []
        self.extra_compile_args = extra_compile_args or []
        self.extra_link_args = extra_link_args or []
        self.export_symbols = export_symbols or []
        self.swig_opts = swig_opts or []
        self.depends = depends or []
        self.language = language

        # If there are unknown keyword options, warn about them
        if len(kw):
            L = kw.keys() ; L.sort()
            L = map(repr, L)
            msg = "Unknown Extension options: " + string.join(L, ', ')
            if warnings is not None:
                warnings.warn(msg)
            else:
                sys.stderr.write(msg + '\n')
# class Extension


def read_setup_file (filename):
    from distutils.sysconfig import \
         parse_makefile, expand_makefile_vars, _variable_rx
    from distutils.text_file import TextFile
    from distutils.util import split_quoted

    # First pass over the file to gather "VAR = VALUE" assignments.
    vars = parse_makefile(filename)

    # Second pass to gobble up the real content: lines of the form
    #   <module> ... [<sourcefile> ...] [<cpparg> ...] [<library> ...]
    file = TextFile(filename,
                    strip_comments=1, skip_blanks=1, join_lines=1,
                    lstrip_ws=1, rstrip_ws=1)
    try:
        extensions = []

        while 1:
            line = file.readline()
            if line is None:                # eof
                break
            if _variable_rx.match(line):    # VAR=VALUE, handled in first pass
                continue

                if line[0] == line[-1] == "*":
                    file.warn("'%s' lines not handled yet" % line)
                    continue

            #print "original line: " + line
            line = expand_makefile_vars(line, vars)
            words = split_quoted(line)
            #print "expanded line: " + line

            # NB. this parses a slightly different syntax than the old
            # makesetup script: here, there must be exactly one extension per
            # line, and it must be the first word of the line.  I have no idea
            # why the old syntax supported multiple extensions per line, as
            # they all wind up being the same.

            module = words[0]
            ext = Extension(module, [])
            append_next_word = None

            for word in words[1:]:
                if append_next_word is not None:
                    append_next_word.append(word)
                    append_next_word = None
                    continue

                suffix = os.path.splitext(word)[1]
                switch = word[0:2] ; value = word[2:]

                if suffix in (".c", ".cc", ".cpp", ".cxx", ".c++", ".m", ".mm"):
                    # hmm, should we do something about C vs. C++ sources?
                    # or leave it up to the CCompiler implementation to
                    # worry about?
                    ext.sources.append(word)
                elif switch == "-I":
                    ext.include_dirs.append(value)
                elif switch == "-D":
                    equals = string.find(value, "=")
                    if equals == -1:        # bare "-DFOO" -- no value
                        ext.define_macros.append((value, None))
                    else:                   # "-DFOO=blah"
                        ext.define_macros.append((value[0:equals],
                                                  value[equals+2:]))
                elif switch == "-U":
                    ext.undef_macros.append(value)
                elif switch == "-C":        # only here 'cause makesetup has it!
                    ext.extra_compile_args.append(word)
                elif switch == "-l":
                    ext.libraries.append(value)
                elif switch == "-L":
                    ext.library_dirs.append(value)
                elif switch == "-R":
                    ext.runtime_library_dirs.append(value)
                elif word == "-rpath":
                    append_next_word = ext.runtime_library_dirs
                elif word == "-Xlinker":
                    append_next_word = ext.extra_link_args
                elif word == "-Xcompiler":
                    append_next_word = ext.extra_compile_args
                elif switch == "-u":
                    ext.extra_link_args.append(word)
                    if not value:
                        append_next_word = ext.extra_link_args
                elif word == "-Xcompiler":
                    append_next_word = ext.extra_compile_args
                elif switch == "-u":
                    ext.extra_link_args.append(word)
                    if not value:
                        append_next_word = ext.extra_link_args
                elif suffix in (".a", ".so", ".sl", ".o", ".dylib"):
                    # NB. a really faithful emulation of makesetup would
                    # append a .o file to extra_objects only if it
                    # had a slash in it; otherwise, it would s/.o/.c/
                    # and append it to sources.  Hmmmm.
                    ext.extra_objects.append(word)
                else:
                    file.warn("unrecognized argument '%s'" % word)

            extensions.append(ext)
    finally:
        file.close()

        #print "module:", module
        #print "source files:", source_files
        #print "cpp args:", cpp_args
        #print "lib args:", library_args

        #extensions[module] = { 'sources': source_files,
        #                       'cpp_args': cpp_args,
        #                       'lib_args': library_args }

    return extensions

# read_setup_file ()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        """A simple log mechanism styled after PEP 282."""

# The class here is styled after PEP 282 so that it could later be
# replaced with a standard Python logging implementation.

DEBUG = 1
INFO = 2
WARN = 3
ERROR = 4
FATAL = 5

import sys

class Log:

    def __init__(self, threshold=WARN):
        self.threshold = threshold

    def _log(self, level, msg, args):
        if level not in (DEBUG, INFO, WARN, ERROR, FATAL):
            raise ValueError('%s wrong log level' % str(level))

        if level >= self.threshold:
            if args:
                msg = msg % args
            if level in (WARN, ERROR, FATAL):
                stream = sys.stderr
            else:
                stream = sys.stdout
            stream.write('%s\n' % msg)
            stream.flush()

    def log(self, level, msg, *args):
        self._log(level, msg, args)

    def debug(self, msg, *args):
        self._log(DEBUG, msg, args)

    def info(self, msg, *args):
        self._log(INFO, msg, args)

    def warn(self, msg, *args):
        self._log(WARN, msg, args)

    def error(self, msg, *args):
        self._log(ERROR, msg, args)

    def fatal(self, msg, *args):
        self._log(FATAL, msg, args)

_global_log = Log()
log = _global_log.log
debug = _global_log.debug
info = _global_log.info
warn = _global_log.warn
error = _global_log.error
fatal = _global_log.fatal

def set_threshold(level):
    # return the old threshold for use from tests
    old = _global_log.threshold
    _global_log.threshold = level
    return old

def set_verbosity(v):
    if v <= 0:
        set_threshold(WARN)
    elif v == 1:
        set_threshold(INFO)
    elif v >= 2:
        set_threshold(DEBUG)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          Û
”´[c           @   sÑ   d  Z  d Z d d l Z d d l Z d d l Z d d l Ty d d l Z Wn e k
 rc d Z n Xd d d Ñ  É  YZ	 d Ñ  Z
 d S(	   sm   distutils.extension

Provides the Extension class, used to describe C/C++ extension
modules in setup scripts.s   $Id$iˇˇˇˇN(   t   *t	   Extensionc           B   s>   e  Z d  Z d d d d d d d d d d d d d d Ñ Z RS(   s4  Just a collection of attributes that describes an extension
    module and everything needed to build it (hopefully in a portable
    way, but there are hooks that let you be as unportable as you need).

    Instance attributes:
      name : string
        the full name of the extension, including any packages -- ie.
        *not* a filename or pathname, but Python dotted name
      sources : [string]
        list of source filenames, relative to the distribution root
        (where the setup script lives), in Unix form (slash-separated)
        for portability.  Source files may be C, C++, SWIG (.i),
        platform-specific resource files, or whatever else is recognized
        by the "build_ext" command as source for a Python extension.
      include_dirs : [string]
        list of directories to search for C/C++ header files (in Unix
        form for portability)
      define_macros : [(name : string, value : string|None)]
        list of macros to define; each macro is defined using a 2-tuple,
        where 'value' is either the string to define it to or None to
        define it without a particular value (equivalent of "#define
        FOO" in source or -DFOO on Unix C compiler command line)
      undef_macros : [string]
        list of macros to undefine explicitly
      library_dirs : [string]
        list of directories to search for C/C++ libraries at link time
      libraries : [string]
        list of library names (not filenames or paths) to link against
      runtime_library_dirs : [string]
        list of directories to search for C/C++ libraries at run time
        (for shared extensions, this is when the extension is loaded)
      extra_objects : [string]
        list of extra files to link with (eg. object files not implied
        by 'sources', static library that must be explicitly specified,
        binary resource files, etc.)
      extra_compile_args : [string]
        any extra platform- and compiler-specific information to use
        when compiling the source files in 'sources'.  For platforms and
        compilers where "command line" makes sense, this is typically a
        list of command-line arguments, but for other platforms it could
        be anything.
      extra_link_args : [string]
        any extra platform- and compiler-specific information to use
        when linking object files together to create the extension (or
        to create a new static Python interpreter).  Similar
        interpretation as for 'extra_compile_args'.
      export_symbols : [string]
        list of symbols to be exported from a shared extension.  Not
        used on all platforms, and not generally necessary for Python
        extensions, which typically export exactly one symbol: "init" +
        extension_name.
      swig_opts : [string]
        any extra options to pass to SWIG if a source file has the .i
        extension.
      depends : [string]
        list of files that the extension depends on
      language : string
        extension language (i.e. "c", "c++", "objc"). Will be detected
        from the source extensions if not provided.
    c         K   s´  t  | É t k s t d É Ç t  | É t k rR t t  | É t g t | É k s^ t d É Ç | |  _ | |  _ | py g  |  _ | pà g  |  _	 | pó g  |  _
 | p¶ g  |  _ | pµ g  |  _ | pƒ g  |  _ |	 p” g  |  _ |
 p‚ g  |  _ | pÒ g  |  _ | p g  |  _ | pg  |  _ | pg  |  _ | |  _ t | É rß| j É  } | j É  t t | É } d t j | d É } t d  k	 rêt j | É qßt j j | d É n  d  S(   Ns   'name' must be a strings#   'sources' must be a list of stringss   Unknown Extension options: s   , s   
(    t   typet
   StringTypet   AssertionErrort   ListTypet   mapt   lent   namet   sourcest   include_dirst   define_macrost   undef_macrost   library_dirst	   librariest   runtime_library_dirst   extra_objectst   extra_compile_argst   extra_link_argst   export_symbolst	   swig_optst   dependst   languaget   keyst   sortt   reprt   stringt   joint   warningst   Nonet   warnt   syst   stderrt   write(   t   selfR   R	   R
   R   R   R   R   R   R   R   R   R   R   R   R   t   kwt   Lt   msg(    (    s)   /usr/lib/python2.7/distutils/extension.pyt   __init__Z   s6    %				 
N(   t   __name__t
   __module__t   __doc__R   R&   (    (    (    s)   /usr/lib/python2.7/distutils/extension.pyR      s   <c         C   sÂ  d d l  m } m } m } d d l m } d d l m } | |  É } | |  d d d d d d d	 d d
 d É} zag  } xT| j É  }	 |	 d  k rö Pn  | j
 |	 É rÍ q~ |	 d |	 d k oÀ d k n rÍ | j d |	 É q~ qÍ n  | |	 | É }	 | |	 É }
 |
 d } t | g  É } d  } xö|
 d D]é} | d  k	 rZ| j | É d  } q/n  t j j | É d } | d d !} | d } | d( k r¶| j j | É q/| d k r≈| j j | É q/| d k r0t j | d É } | d k r| j j | d  f É qΩ| j j | d | !| | d f É q/| d k rO| j j | É q/| d k rn| j j | É q/| d k rç| j j | É q/| d k r¨| j j | É q/| d k rÀ| j j | É q/| d k r„| j } q/| d k r˚| j } q/| d  k r| j } q/| d! k rD| j j | É | sΩ| j } qΩq/| d  k r\| j } q/| d! k rç| j j | É | sΩ| j } qΩq/| d) k r¨| j j | É q/| j d' | É q/W| j | É q~ WWd  | j É  X| S(*   Niˇˇˇˇ(   t   parse_makefilet   expand_makefile_varst   _variable_rx(   t   TextFile(   t   split_quotedt   strip_commentsi   t   skip_blankst
   join_linest	   lstrip_wst	   rstrip_wsi    R    s   '%s' lines not handled yeti   s   .cs   .ccs   .cpps   .cxxs   .c++s   .ms   .mms   -Is   -Dt   =s   -Us   -Cs   -ls   -Ls   -Rs   -rpaths   -Xlinkers
   -Xcompilers   -us   .as   .sos   .sls   .os   .dylibs   unrecognized argument '%s'(   s   .cs   .ccs   .cpps   .cxxs   .c++s   .ms   .mm(   s   .as   .sos   .sls   .os   .dylib(   t   distutils.sysconfigR*   R+   R,   t   distutils.text_fileR-   t   distutils.utilR.   t   readlineR   t   matchR   R   t   appendt   ost   patht   splitextR	   R
   R   t   findR   R   R   R   R   R   R   R   t   close(   t   filenameR*   R+   R,   R-   R.   t   varst   filet
   extensionst   linet   wordst   modulet   extt   append_next_wordt   wordt   suffixt   switcht   valuet   equals(    (    s)   /usr/lib/python2.7/distutils/extension.pyt   read_setup_fileã   sí    	$		
 
(    (   R)   t   __revision__R;   R   R   t   typesR   t   ImportErrorR   R   RN   (    (    (    s)   /usr/lib/python2.7/distutils/extension.pyt   <module>   s   $

q                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    """distutils.fancy_getopt

Wrapper around the standard getopt module that provides the following
additional features:
  * short and long options are tied together
  * options have help strings, so fancy_getopt could potentially
    create a complete usage summary
  * options set attributes of a passed-in object
"""

__revision__ = "$Id$"

import sys
import string
import re
import getopt
from distutils.errors import DistutilsGetoptError, DistutilsArgError

# Much like command_re in distutils.core, this is close to but not quite
# the same as a Python NAME -- except, in the spirit of most GNU
# utilities, we use '-' in place of '_'.  (The spirit of LISP lives on!)
# The similarities to NAME are again not a coincidence...
longopt_pat = r'[a-zA-Z](?:[a-zA-Z0-9-]*)'
longopt_re = re.compile(r'^%s$' % longopt_pat)

# For recognizing "negative alias" options, eg. "quiet=!verbose"
neg_alias_re = re.compile("^(%s)=!(%s)$" % (longopt_pat, longopt_pat))

# This is used to translate long options to legitimate Python identifiers
# (for use as attributes of some object).
longopt_xlate = string.maketrans('-', '_')

class FancyGetopt:
    """Wrapper around the standard 'getopt()' module that provides some
    handy extra functionality:
      * short and long options are tied together
      * options have help strings, and help text can be assembled
        from them
      * options set attributes of a passed-in object
      * boolean options can have "negative aliases" -- eg. if
        --quiet is the "negative alias" of --verbose, then "--quiet"
        on the command line sets 'verbose' to false
    """

    def __init__ (self, option_table=None):

        # The option table is (currently) a list of tuples.  The
        # tuples may have 3 or four values:
        #   (long_option, short_option, help_string [, repeatable])
        # if an option takes an argument, its long_option should have '='
        # appended; short_option should just be a single character, no ':'
        # in any case.  If a long_option doesn't have a corresponding
        # short_option, short_option should be None.  All option tuples
        # must have long options.
        self.option_table = option_table

        # 'option_index' maps long option names to entries in the option
        # table (ie. those 3-tuples).
        self.option_index = {}
        if self.option_table:
            self._build_index()

        # 'alias' records (duh) alias options; {'foo': 'bar'} means
        # --foo is an alias for --bar
        self.alias = {}

        # 'negative_alias' keeps track of options that are the boolean
        # opposite of some other option
        self.negative_alias = {}

        # These keep track of the information in the option table.  We
        # don't actually populate these structures until we're ready to
        # parse the command-line, since the 'option_table' passed in here
        # isn't necessarily the final word.
        self.short_opts = []
        self.long_opts = []
        self.short2long = {}
        self.attr_name = {}
        self.takes_arg = {}

        # And 'option_order' is filled up in 'getopt()'; it records the
        # original order of options (and their values) on the command-line,
        # but expands short options, converts aliases, etc.
        self.option_order = []

    # __init__ ()


    def _build_index (self):
        self.option_index.clear()
        for option in self.option_table:
            self.option_index[option[0]] = option

    def set_option_table (self, option_table):
        self.option_table = option_table
        self._build_index()

    def add_option (self, long_option, short_option=None, help_string=None):
        if long_option in self.option_index:
            raise DistutilsGetoptError, \
                  "option conflict: already an option '%s'" % long_option
        else:
            option = (long_option, short_option, help_string)
            self.option_table.append(option)
            self.option_index[long_option] = option


    def has_option (self, long_option):
        """Return true if the option table for this parser has an
        option with long name 'long_option'."""
        return long_option in self.option_index

    def get_attr_name (self, long_option):
        """Translate long option name 'long_option' to the form it
        has as an attribute of some object: ie., translate hyphens
        to underscores."""
        return string.translate(long_option, longopt_xlate)


    def _check_alias_dict (self, aliases, what):
        assert isinstance(aliases, dict)
        for (alias, opt) in aliases.items():
            if alias not in self.option_index:
                raise DistutilsGetoptError, \
                      ("invalid %s '%s': "
                       "option '%s' not defined") % (what, alias, alias)
            if opt not in self.option_index:
                raise DistutilsGetoptError, \
                      ("invalid %s '%s': "
                       "aliased option '%s' not defined") % (what, alias, opt)

    def set_aliases (self, alias):
        """Set the aliases for this option parser."""
        self._check_alias_dict(alias, "alias")
        self.alias = alias

    def set_negative_aliases (self, negative_alias):
        """Set the negative aliases for this option parser.
        'negative_alias' should be a dictionary mapping option names to
        option names, both the key and value must already be defined
        in the option table."""
        self._check_alias_dict(negative_alias, "negative alias")
        self.negative_alias = negative_alias


    def _grok_option_table (self):
        """Populate the various data structures that keep tabs on the
        option table.  Called by 'getopt()' before it can do anything
        worthwhile.
        """
        self.long_opts = []
        self.short_opts = []
        self.short2long.clear()
        self.repeat = {}

        for option in self.option_table:
            if len(option) == 3:
                long, short, help = option
                repeat = 0
            elif len(option) == 4:
                long, short, help, repeat = option
            else:
                # the option table is part of the code, so simply
                # assert that it is correct
                raise ValueError, "invalid option tuple: %r" % (option,)

            # Type- and value-check the option names
            if not isinstance(long, str) or len(long) < 2:
                raise DistutilsGetoptError, \
                      ("invalid long option '%s': "
                       "must be a string of length >= 2") % long

            if (not ((short is None) or
                     (isinstance(short, str) and len(short) == 1))):
                raise DistutilsGetoptError, \
                      ("invalid short option '%s': "
                       "must a single character or None") % short

            self.repeat[long] = repeat
            self.long_opts.append(long)

            if long[-1] == '=':             # option takes an argument?
                if short: short = short + ':'
                long = long[0:-1]
                self.takes_arg[long] = 1
            else:

                # Is option is a "negative alias" for some other option (eg.
                # "quiet" == "!verbose")?
                alias_to = self.negative_alias.get(long)
                if alias_to is not None:
                    if self.takes_arg[alias_to]:
                        raise DistutilsGetoptError, \
                              ("invalid negative alias '%s': "
                               "aliased option '%s' takes a value") % \
                               (long, alias_to)

                    self.long_opts[-1] = long # XXX redundant?!
                    self.takes_arg[long] = 0

                else:
                    self.takes_arg[long] = 0

            # If this is an alias option, make sure its "takes arg" flag is
            # the same as the option it's aliased to.
            alias_to = self.alias.get(long)
            if alias_to is not None:
                if self.takes_arg[long] != self.takes_arg[alias_to]:
                    raise DistutilsGetoptError, \
                          ("invalid alias '%s': inconsistent with "
                           "aliased option '%s' (one of them takes a value, "
                           "the other doesn't") % (long, alias_to)


            # Now enforce some bondage on the long option name, so we can
            # later translate it to an attribute name on some object.  Have
            # to do this a bit late to make sure we've removed any trailing
            # '='.
            if not longopt_re.match(long):
                raise DistutilsGetoptError, \
                      ("invalid long option name '%s' " +
                       "(must be letters, numbers, hyphens only") % long

            self.attr_name[long] = self.get_attr_name(long)
            if short:
                self.short_opts.append(short)
                self.short2long[short[0]] = long

        # for option_table

    # _grok_option_table()


    def getopt (self, args=None, object=None):
        """Parse command-line options in args. Store as attributes on object.

        If 'args' is None or not supplied, uses 'sys.argv[1:]'.  If
        'object' is None or not supplied, creates a new OptionDummy
        object, stores option values there, and returns a tuple (args,
        object).  If 'object' is supplied, it is modified in place and
        'getopt()' just returns 'args'; in both cases, the returned
        'args' is a modified copy of the passed-in 'args' list, which
        is left untouched.
        """
        if args is None:
            args = sys.argv[1:]
        if object is None:
            object = OptionDummy()
            created_object = 1
        else:
            created_object = 0

        self._grok_option_table()

        short_opts = string.join(self.short_opts)
        try:
            opts, args = getopt.getopt(args, short_opts, self.long_opts)
        except getopt.error, msg:
            raise DistutilsArgError, msg

        for opt, val in opts:
            if len(opt) == 2 and opt[0] == '-': # it's a short option
                opt = self.short2long[opt[1]]
            else:
                assert len(opt) > 2 and opt[:2] == '--'
                opt = opt[2:]

            alias = self.alias.get(opt)
            if alias:
                opt = alias

            if not self.takes_arg[opt]:     # boolean option?
                assert val == '', "boolean option can't have value"
                alias = self.negative_alias.get(opt)
                if alias:
                    opt = alias
                    val = 0
                else:
                    val = 1

            attr = self.attr_name[opt]
            # The only repeating option at the moment is 'verbose'.
            # It has a negative option -q quiet, which should set verbose = 0.
            if val and self.repeat.get(attr) is not None:
                val = getattr(object, attr, 0) + 1
            setattr(object, attr, val)
            self.option_order.append((opt, val))

        # for opts
        if created_object:
            return args, object
        else:
            return args

    # getopt()


    def get_option_order (self):
        """Returns the list of (option, value) tuples processed by the
        previous run of 'getopt()'.  Raises RuntimeError if
        'getopt()' hasn't been called yet.
        """
        if self.option_order is None:
            raise RuntimeError, "'getopt()' hasn't been called yet"
        else:
            return self.option_order


    def generate_help (self, header=None):
        """Generate help text (a list of strings, one per suggested line of
        output) from the option table for this FancyGetopt object.
        """
        # Blithely assume the option table is good: probably wouldn't call
        # 'generate_help()' unless you've already called 'getopt()'.

        # First pass: determine maximum length of long option names
        max_opt = 0
        for option in self.option_table:
            long = option[0]
            short = option[1]
            l = len(long)
            if long[-1] == '=':
                l = l - 1
            if short is not None:
                l = l + 5                   # " (-x)" where short == 'x'
            if l > max_opt:
                max_opt = l

        opt_width = max_opt + 2 + 2 + 2     # room for indent + dashes + gutter

        # Typical help block looks like this:
        #   --foo       controls foonabulation
        # Help block for longest option looks like this:
        #   --flimflam  set the flim-flam level
        # and with wrapped text:
        #   --flimflam  set the flim-flam level (must be between
        #               0 and 100, except on Tuesdays)
        # Options with short names will have the short name shown (but
        # it doesn't contribute to max_opt):
        #   --foo (-f)  controls foonabulation
        # If adding the short option would make the left column too wide,
        # we push the explanation off to the next line
        #   --flimflam (-l)
        #               set the flim-flam level
        # Important parameters:
        #   - 2 spaces before option block start lines
        #   - 2 dashes for each long option name
        #   - min. 2 spaces between option and explanation (gutter)
        #   - 5 characters (incl. space) for short option name

        # Now generate lines of help text.  (If 80 columns were good enough
        # for Jesus, then 78 columns are good enough for me!)
        line_width = 78
        text_width = line_width - opt_width
        big_indent = ' ' * opt_width
        if header:
            lines = [header]
        else:
            lines = ['Option summary:']

        for option in self.option_table:
            long, short, help = option[:3]
            text = wrap_text(help, text_width)
            if long[-1] == '=':
                long = long[0:-1]

            # Case 1: no short option at all (makes life easy)
            if short is None:
                if text:
                    lines.append("  --%-*s  %s" % (max_opt, long, text[0]))
                else:
                    lines.append("  --%-*s  " % (max_opt, long))

            # Case 2: we have a short option, so we have to include it
            # just after the long option
            else:
                opt_names = "%s (-%s)" % (long, short)
                if text:
                    lines.append("  --%-*s  %s" %
                                 (max_opt, opt_names, text[0]))
                else:
                    lines.append("  --%-*s" % opt_names)

            for l in text[1:]:
                lines.append(big_indent + l)

        # for self.option_table

        return lines

    # generate_help ()

    def print_help (self, header=None, file=None):
        if file is None:
            file = sys.stdout
        for line in self.generate_help(header):
            file.write(line + "\n")

# class FancyGetopt


def fancy_getopt (options, negative_opt, object, args):
    parser = FancyGetopt(options)
    parser.set_negative_aliases(negative_opt)
    return parser.getopt(args, object)


WS_TRANS = string.maketrans(string.whitespace, ' ' * len(string.whitespace))

def wrap_text (text, width):
    """wrap_text(text : string, width : int) -> [string]

    Split 'text' into multiple lines of no more than 'width' characters
    each, and return the list of strings that results.
    """

    if text is None:
        return []
    if len(text) <= width:
        return [text]

    text = string.expandtabs(text)
    text = string.translate(text, WS_TRANS)
    chunks = re.split(r'( +|-+)', text)
    chunks = filter(None, chunks)      # ' - ' results in empty strings
    lines = []

    while chunks:

        cur_line = []                   # list of chunks (to-be-joined)
        cur_len = 0                     # length of current line

        while chunks:
            l = len(chunks[0])
            if cur_len + l <= width:    # can squeeze (at least) this chunk in
                cur_line.append(chunks[0])
                del chunks[0]
                cur_len = cur_len + l
            else:                       # this line is full
                # drop last chunk if all space
                if cur_line and cur_line[-1][0] == ' ':
                    del cur_line[-1]
                break

        if chunks:                      # any chunks left to process?

            # if the current line is still empty, then we had a single
            # chunk that's too big too fit on a line -- so we break
            # down and break it up at the line width
            if cur_len == 0:
                cur_line.append(chunks[0][0:width])
                chunks[0] = chunks[0][width:]

            # all-whitespace chunks at the end of a line can be discarded
            # (and we know from the re.split above that if a chunk has
            # *any* whitespace, it is *all* whitespace)
            if chunks[0][0] == ' ':
                del chunks[0]

        # and store this line in the list-of-all-lines -- as a single
        # string, of course!
        lines.append(string.join(cur_line, ''))

    # while chunks

    return lines


def translate_longopt(opt):
    """Convert a long option name to a valid Python identifier by
    changing "-" to "_".
    """
    return string.translate(opt, longopt_xlate)


class OptionDummy:
    """Dummy class just used as a place to hold command-line option
    values as instance attributes."""

    def __init__ (self, options=[]):
        """Create a new OptionDummy instance.  The attributes listed in
        'options' will be initialized to None."""
        for opt in options:
            setattr(self, opt, None)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Û
”´[c           @   s˝   d  Z  d Z d d l Z d d l Z d d l Z d d l Z d d l m Z m Z d Z	 e j
 d e	 É Z e j
 d e	 e	 f É Z e j d d	 É Z d
 f  d Ñ  É  YZ d Ñ  Z e j e j d e e j É É Z d Ñ  Z d Ñ  Z d f  d Ñ  É  YZ d S(   s6  distutils.fancy_getopt

Wrapper around the standard getopt module that provides the following
additional features:
  * short and long options are tied together
  * options have help strings, so fancy_getopt could potentially
    create a complete usage summary
  * options set attributes of a passed-in object
s   $Id$iˇˇˇˇN(   t   DistutilsGetoptErrort   DistutilsArgErrors   [a-zA-Z](?:[a-zA-Z0-9-]*)s   ^%s$s   ^(%s)=!(%s)$t   -t   _t   FancyGetoptc           B   s§   e  Z d  Z d d Ñ Z d Ñ  Z d Ñ  Z d d d Ñ Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d Ñ  Z d	 Ñ  Z d
 Ñ  Z d d d Ñ Z d Ñ  Z d d Ñ Z d d d Ñ Z RS(   s’  Wrapper around the standard 'getopt()' module that provides some
    handy extra functionality:
      * short and long options are tied together
      * options have help strings, and help text can be assembled
        from them
      * options set attributes of a passed-in object
      * boolean options can have "negative aliases" -- eg. if
        --quiet is the "negative alias" of --verbose, then "--quiet"
        on the command line sets 'verbose' to false
    c         C   st   | |  _  i  |  _ |  j  r( |  j É  n  i  |  _ i  |  _ g  |  _ g  |  _ i  |  _ i  |  _ i  |  _	 g  |  _
 d  S(   N(   t   option_tablet   option_indext   _build_indext   aliast   negative_aliast
   short_optst	   long_optst
   short2longt	   attr_namet	   takes_argt   option_order(   t   selfR   (    (    s,   /usr/lib/python2.7/distutils/fancy_getopt.pyt   __init__-   s    
										c         C   s6   |  j  j É  x" |  j D] } | |  j  | d <q Wd  S(   Ni    (   R   t   clearR   (   R   t   option(    (    s,   /usr/lib/python2.7/distutils/fancy_getopt.pyR   Y   s    c         C   s   | |  _  |  j É  d  S(   N(   R   R   (   R   R   (    (    s,   /usr/lib/python2.7/distutils/fancy_getopt.pyt   set_option_table^   s    	c         C   sO   | |  j  k r t d | Ç n, | | | f } |  j j | É | |  j  | <d  S(   Ns'   option conflict: already an option '%s'(   R   R    R   t   append(   R   t   long_optiont   short_optiont   help_stringR   (    (    s,   /usr/lib/python2.7/distutils/fancy_getopt.pyt
   add_optionb   s    c         C   s   | |  j  k S(   sc   Return true if the option table for this parser has an
        option with long name 'long_option'.(   R   (   R   R   (    (    s,   /usr/lib/python2.7/distutils/fancy_getopt.pyt
   has_optionl   s    c         C   s   t  j | t É S(   sí   Translate long option name 'long_option' to the form it
        has as an attribute of some object: ie., translate hyphens
        to underscores.(   t   stringt	   translatet   longopt_xlate(   R   R   (    (    s,   /usr/lib/python2.7/distutils/fancy_getopt.pyt   get_attr_nameq   s    c         C   sÜ   t  | t É s t Ç xj | j É  D]\ \ } } | |  j k rV t d | | | f Ç n  | |  j k r" t d | | | f Ç q" q" Wd  S(   Ns(   invalid %s '%s': option '%s' not defineds0   invalid %s '%s': aliased option '%s' not defined(   t
   isinstancet   dictt   AssertionErrort   itemsR   R    (   R   t   aliasest   whatR   t   opt(    (    s,   /usr/lib/python2.7/distutils/fancy_getopt.pyt   _check_alias_dictx   s    c         C   s   |  j  | d É | |  _ d S(   s'   Set the aliases for this option parser.R   N(   R&   R   (   R   R   (    (    s,   /usr/lib/python2.7/distutils/fancy_getopt.pyt   set_aliasesÑ   s    c         C   s   |  j  | d É | |  _ d S(   s⁄   Set the negative aliases for this option parser.
        'negative_alias' should be a dictionary mapping option names to
        option names, both the key and value must already be defined
        in the option table.s   negative aliasN(   R&   R	   (   R   R	   (    (    s,   /usr/lib/python2.7/distutils/fancy_getopt.pyt   set_negative_aliasesâ   s    c         C   så  g  |  _  g  |  _ |  j j É  i  |  _ x]|  j D]R} t | É d k rb | \ } } } d } n7 t | É d k râ | \ } } } } n t d | f Ç t | t	 É sª t | É d k  rÀ t
 d | Ç n  | d k pı t | t	 É oı t | É d k st
 d | Ç n  | |  j | <|  j  j | É | d	 d
 k re| rH| d } n  | d d	 !} d |  j | <nk |  j j | É } | d k	 r√|  j | r¶t
 d | | f Ç n  | |  j  d	 <d |  j | <n d |  j | <|  j j | É } | d k	 r!|  j | |  j | k r!t
 d | | f Ç q!n  t j | É sDt
 d d | Ç n  |  j | É |  j | <| r2 |  j j | É | |  j | d <q2 q2 Wd S(   sù   Populate the various data structures that keep tabs on the
        option table.  Called by 'getopt()' before it can do anything
        worthwhile.
        i   i    i   s   invalid option tuple: %ri   s9   invalid long option '%s': must be a string of length >= 2i   s:   invalid short option '%s': must a single character or Noneiˇˇˇˇt   =t   :s>   invalid negative alias '%s': aliased option '%s' takes a valuesg   invalid alias '%s': inconsistent with aliased option '%s' (one of them takes a value, the other doesn'ts   invalid long option name '%s' s'   (must be letters, numbers, hyphens onlyN(   R   R
   R   R   t   repeatR   t   lent
   ValueErrorR   t   strR    t   NoneR   R   R	   t   getR   t
   longopt_ret   matchR   R   (   R   R   t   longt   shortt   helpR+   t   alias_to(    (    s,   /usr/lib/python2.7/distutils/fancy_getopt.pyt   _grok_option_tableí   sd    				"
!
 c         C   s  | d k r t j d } n  | d k r: t É  } d } n d } |  j É  t j |  j É } y" t j | | |  j	 É \ } } Wn t j
 k
 rü } t | Ç n Xx\| D]T\ } } t | É d k rÈ | d d k rÈ |  j | d } n2 t | É d k r| d  d k st Ç | d } |  j j | É }	 |	 r<|	 } n  |  j | së| d k sat d É Ç |  j j | É }	 |	 rà|	 } d } qëd } n  |  j | }
 | r’|  j j |
 É d k	 r’t | |
 d É d } n  t | |
 | É |  j j | | f É qß W| r| | f S| Sd S(	   s  Parse command-line options in args. Store as attributes on object.

        If 'args' is None or not supplied, uses 'sys.argv[1:]'.  If
        'object' is None or not supplied, creates a new OptionDummy
        object, stores option values there, and returns a tuple (args,
        object).  If 'object' is supplied, it is modified in place and
        'getopt()' just returns 'args'; in both cases, the returned
        'args' is a modified copy of the passed-in 'args' list, which
        is left untouched.
        i   i    i   R   s   --t    s   boolean option can't have valueN(   R/   t   syst   argvt   OptionDummyR7   R   t   joinR
   t   getoptR   t   errorR   R,   R   R!   R   R0   R   R	   R   R+   t   getattrt   setattrR   R   (   R   t   argst   objectt   created_objectR
   t   optst   msgR%   t   valR   t   attr(    (    s,   /usr/lib/python2.7/distutils/fancy_getopt.pyR=   Í   sF    		
""(
			
c         C   s&   |  j  d k r t d Ç n |  j  Sd S(   s´   Returns the list of (option, value) tuples processed by the
        previous run of 'getopt()'.  Raises RuntimeError if
        'getopt()' hasn't been called yet.
        s!   'getopt()' hasn't been called yetN(   R   R/   t   RuntimeError(   R   (    (    s,   /usr/lib/python2.7/distutils/fancy_getopt.pyt   get_option_order*  s    c         C   s·  d } x| |  j  D]q } | d } | d } t | É } | d d k rS | d } n  | d k	 rl | d } n  | | k r | } q q W| d d d } d } | | }	 d | }
 | r√ | g } n	 d	 g } x|  j  D]} | d
  \ } } } t | |	 É } | d d k r| d d !} n  | d k rk| rQ| j d | | | d f É q≥| j d | | f É nH d | | f } | r¢| j d | | | d f É n | j d | É x# | d D] } | j |
 | É qæWq÷ W| S(   så   Generate help text (a list of strings, one per suggested line of
        output) from the option table for this FancyGetopt object.
        i    i   iˇˇˇˇR)   i   i   iN   t    s   Option summary:i   s     --%-*s  %ss
     --%-*s  s   %s (-%s)s     --%-*sN(   R   R,   R/   t	   wrap_textR   (   R   t   headert   max_optR   R3   R4   t   lt	   opt_widtht
   line_widtht
   text_widtht
   big_indentt   linesR5   t   textt	   opt_names(    (    s,   /usr/lib/python2.7/distutils/fancy_getopt.pyt   generate_help5  sF    



	!	c         C   sG   | d  k r t j } n  x( |  j | É D] } | j | d É q( Wd  S(   Ns   
(   R/   R9   t   stdoutRV   t   write(   R   RL   t   filet   line(    (    s,   /usr/lib/python2.7/distutils/fancy_getopt.pyt
   print_helpâ  s    N(   t   __name__t
   __module__t   __doc__R/   R   R   R   R   R   R   R&   R'   R(   R7   R=   RI   RV   R[   (    (    (    s,   /usr/lib/python2.7/distutils/fancy_getopt.pyR   !   s   
,		
							X@	Tc         C   s)   t  |  É } | j | É | j | | É S(   N(   R   R(   R=   (   t   optionst   negative_optRB   RA   t   parser(    (    s,   /usr/lib/python2.7/distutils/fancy_getopt.pyt   fancy_getoptí  s    RJ   c         C   s~  |  d k r g  St |  É | k r) |  g St j |  É }  t j |  t É }  t j d |  É } t d | É } g  } x| ryg  } d } xt | r¸ t | d É } | | | k r‘ | j	 | d É | d =| | } qâ | r¯ | d d d k r¯ | d =n  Pqâ W| r]| d k r<| j	 | d d | !É | d | | d <n  | d d d k r]| d =q]n  | j	 t j
 | d É É qt W| S(   s∂   wrap_text(text : string, width : int) -> [string]

    Split 'text' into multiple lines of no more than 'width' characters
    each, and return the list of strings that results.
    s   ( +|-+)i    iˇˇˇˇRJ   R8   N(   R/   R,   R   t
   expandtabsR   t   WS_TRANSt   ret   splitt   filterR   R<   (   RT   t   widtht   chunksRS   t   cur_linet   cur_lenRN   (    (    s,   /usr/lib/python2.7/distutils/fancy_getopt.pyRK   ö  s:    		
c         C   s   t  j |  t É S(   sX   Convert a long option name to a valid Python identifier by
    changing "-" to "_".
    (   R   R   R   (   R%   (    (    s,   /usr/lib/python2.7/distutils/fancy_getopt.pyt   translate_longopt’  s    R;   c           B   s   e  Z d  Z g  d Ñ Z RS(   s_   Dummy class just used as a place to hold command-line option
    values as instance attributes.c         C   s%   x | D] } t  |  | d É q Wd S(   sk   Create a new OptionDummy instance.  The attributes listed in
        'options' will be initialized to None.N(   R@   R/   (   R   R_   R%   (    (    s,   /usr/lib/python2.7/distutils/fancy_getopt.pyR   ‡  s    (   R\   R]   R^   R   (    (    (    s,   /usr/lib/python2.7/distutils/fancy_getopt.pyR;   ‹  s   (   R^   t   __revision__R9   R   Re   R=   t   distutils.errorsR    R   t   longopt_patt   compileR1   t   neg_alias_ret	   maketransR   R   Rb   t
   whitespaceR,   Rd   RK   Rl   R;   (    (    (    s,   /usr/lib/python2.7/distutils/fancy_getopt.pyt   <module>	   s"   ˇ r	"	;	                                                                                                                                                                                                                                                                                                                                                                                    """distutils.file_util

Utility functions for operating on single files.
"""

__revision__ = "$Id$"

import os
from distutils.errors import DistutilsFileError
from distutils import log

# for generating verbose output in 'copy_file()'
_copy_action = {None: 'copying',
                'hard': 'hard linking',
                'sym': 'symbolically linking'}


def _copy_file_contents(src, dst, buffer_size=16*1024):
    """Copy the file 'src' to 'dst'.

    Both must be filenames. Any error opening either file, reading from
    'src', or writing to 'dst', raises DistutilsFileError.  Data is
    read/written in chunks of 'buffer_size' bytes (default 16k).  No attempt
    is made to handle anything apart from regular files.
    """
    # Stolen from shutil module in the standard library, but with
    # custom error-handling added.
    fsrc = None
    fdst = None
    try:
        try:
            fsrc = open(src, 'rb')
        except os.error, (errno, errstr):
            raise DistutilsFileError("could not open '%s': %s" % (src, errstr))

        if os.path.exists(dst):
            try:
                os.unlink(dst)
            except os.error, (errno, errstr):
                raise DistutilsFileError(
                      "could not delete '%s': %s" % (dst, errstr))

        try:
            fdst = open(dst, 'wb')
        except os.error, (errno, errstr):
            raise DistutilsFileError(
                  "could not create '%s': %s" % (dst, errstr))

        while 1:
            try:
                buf = fsrc.read(buffer_size)
            except os.error, (errno, errstr):
                raise DistutilsFileError(
                      "could not read from '%s': %s" % (src, errstr))

            if not buf:
                break

            try:
                fdst.write(buf)
            except os.error, (errno, errstr):
                raise DistutilsFileError(
                      "could not write to '%s': %s" % (dst, errstr))

    finally:
        if fdst:
            fdst.close()
        if fsrc:
            fsrc.close()

def copy_file(src, dst, preserve_mode=1, preserve_times=1, update=0,
              link=None, verbose=1, dry_run=0):
    """Copy a file 'src' to 'dst'.

    If 'dst' is a directory, then 'src' is copied there with the same name;
    otherwise, it must be a filename.  (If the file exists, it will be
    ruthlessly clobbered.)  If 'preserve_mode' is true (the default),
    the file's mode (type and permission bits, or whatever is analogous on
    the current platform) is copied.  If 'preserve_times' is true (the
    default), the last-modified and last-access times are copied as well.
    If 'update' is true, 'src' will only be copied if 'dst' does not exist,
    or if 'dst' does exist but is older than 'src'.

    'link' allows you to make hard links (os.link) or symbolic links
    (os.symlink) instead of copying: set it to "hard" or "sym"; if it is
    None (the default), files are copied.  Don't set 'link' on systems that
    don't support it: 'copy_file()' doesn't check if hard or symbolic
    linking is available. If hardlink fails, falls back to
    _copy_file_contents().

    Under Mac OS, uses the native file copy function in macostools; on
    other systems, uses '_copy_file_contents()' to copy file contents.

    Return a tuple (dest_name, copied): 'dest_name' is the actual name of
    the output file, and 'copied' is true if the file was copied (or would
    have been copied, if 'dry_run' true).
    """
    # XXX if the destination file already exists, we clobber it if
    # copying, but blow up if linking.  Hmmm.  And I don't know what
    # macostools.copyfile() does.  Should definitely be consistent, and
    # should probably blow up if destination exists and we would be
    # changing it (ie. it's not already a hard/soft link to src OR
    # (not update) and (src newer than dst).

    from distutils.dep_util import newer
    from stat import ST_ATIME, ST_MTIME, ST_MODE, S_IMODE

    if not os.path.isfile(src):
        raise DistutilsFileError(
              "can't copy '%s': doesn't exist or not a regular file" % src)

    if os.path.isdir(dst):
        dir = dst
        dst = os.path.join(dst, os.path.basename(src))
    else:
        dir = os.path.dirname(dst)

    if update and not newer(src, dst):
        if verbose >= 1:
            log.debug("not copying %s (output up-to-date)", src)
        return dst, 0

    try:
        action = _copy_action[link]
    except KeyError:
        raise ValueError("invalid value '%s' for 'link' argument" % link)

    if verbose >= 1:
        if os.path.basename(dst) == os.path.basename(src):
            log.info("%s %s -> %s", action, src, dir)
        else:
            log.info("%s %s -> %s", action, src, dst)

    if dry_run:
        return (dst, 1)

    # If linking (hard or symbolic), use the appropriate system call
    # (Unix only, of course, but that's the caller's responsibility)
    if link == 'hard':
        if not (os.path.exists(dst) and os.path.samefile(src, dst)):
            try:
                os.link(src, dst)
                return (dst, 1)
            except OSError:
                # If hard linking fails, fall back on copying file
                # (some special filesystems don't support hard linking
                #  even under Unix, see issue #8876).
                pass
    elif link == 'sym':
        if not (os.path.exists(dst) and os.path.samefile(src, dst)):
            os.symlink(src, dst)
            return (dst, 1)

    # Otherwise (non-Mac, not linking), copy the file contents and
    # (optionally) copy the times and mode.
    _copy_file_contents(src, dst)
    if preserve_mode or preserve_times:
        st = os.stat(src)

        # According to David Ascher <da@ski.org>, utime() should be done
        # before chmod() (at least under NT).
        if preserve_times:
            os.utime(dst, (st[ST_ATIME], st[ST_MTIME]))
        if preserve_mode:
            os.chmod(dst, S_IMODE(st[ST_MODE]))

    return (dst, 1)

# XXX I suspect this is Unix-specific -- need porting help!
def move_file (src, dst, verbose=1, dry_run=0):
    """Move a file 'src' to 'dst'.

    If 'dst' is a directory, the file will be moved into it with the same
    name; otherwise, 'src' is just renamed to 'dst'.  Return the new
    full name of the file.

    Handles cross-device moves on Unix using 'copy_file()'.  What about
    other systems???
    """
    from os.path import exists, isfile, isdir, basename, dirname
    import errno

    if verbose >= 1:
        log.info("moving %s -> %s", src, dst)

    if dry_run:
        return dst

    if not isfile(src):
        raise DistutilsFileError("can't move '%s': not a regular file" % src)

    if isdir(dst):
        dst = os.path.join(dst, basename(src))
    elif exists(dst):
        raise DistutilsFileError(
              "can't move '%s': destination '%s' already exists" %
              (src, dst))

    if not isdir(dirname(dst)):
        raise DistutilsFileError(
              "can't move '%s': destination '%s' not a valid path" % \
              (src, dst))

    copy_it = 0
    try:
        os.rename(src, dst)
    except os.error, (num, msg):
        if num == errno.EXDEV:
            copy_it = 1
        else:
            raise DistutilsFileError(
                  "couldn't move '%s' to '%s': %s" % (src, dst, msg))

    if copy_it:
        copy_file(src, dst, verbose=verbose)
        try:
            os.unlink(src)
        except os.error, (num, msg):
            try:
                os.unlink(dst)
            except os.error:
                pass
            raise DistutilsFileError(
                  ("couldn't move '%s' to '%s' by copy/delete: " +
                   "delete '%s' failed: %s") %
                  (src, dst, src, msg))
    return dst


def write_file (filename, contents):
    """Create a file with the specified name and write 'contents' (a
    sequence of strings without line terminators) to it.
    """
    f = open(filename, "w")
    try:
        for line in contents:
            f.write(line + "\n")
    finally:
        f.close()
                                                             Û
”´[c           @   sñ   d  Z  d Z d d l Z d d l m Z d d l m Z i d d 6d d 6d	 d
 6Z d d Ñ Z	 d d d d d d d Ñ Z
 d d d Ñ Z d Ñ  Z d S(   sF   distutils.file_util

Utility functions for operating on single files.
s   $Id$iˇˇˇˇN(   t   DistutilsFileError(   t   logt   copyings   hard linkingt   hards   symbolically linkingt   symi   i   c         C   s»  d } d } zéy t |  d É } Wn2 t j k
 rV \ } } t d |  | f É Ç n Xt j j | É r≤ y t j | É Wq≤ t j k
 rÆ \ } } t d | | f É Ç q≤ Xn  y t | d É } Wn2 t j k
 r˘ \ } } t d | | f É Ç n Xxú y | j | É } Wn2 t j k
 rD\ } } t d |  | f É Ç n X| sOPn  y | j	 | É Wq˝ t j k
 rî\ } } t d | | f É Ç q˝ Xq˝ WWd | r∞| j
 É  n  | r√| j
 É  n  Xd S(	   s5  Copy the file 'src' to 'dst'.

    Both must be filenames. Any error opening either file, reading from
    'src', or writing to 'dst', raises DistutilsFileError.  Data is
    read/written in chunks of 'buffer_size' bytes (default 16k).  No attempt
    is made to handle anything apart from regular files.
    t   rbs   could not open '%s': %ss   could not delete '%s': %st   wbs   could not create '%s': %ss   could not read from '%s': %ss   could not write to '%s': %sN(   t   Nonet   opent   ost   errorR    t   patht   existst   unlinkt   readt   writet   close(   t   srct   dstt   buffer_sizet   fsrct   fdstt   errnot   errstrt   buf(    (    s)   /usr/lib/python2.7/distutils/file_util.pyt   _copy_file_contents   sF    
i   i    c         C   s¬  d d l  m } d d l m }	 m }
 m } m } t j j	 |  É sW t
 d |  É Ç n  t j j | É rì | } t j j | t j j |  É É } n t j j | É } | r‰ | |  | É r‰ | d k r⁄ t j d |  É n  | d f Sy t | } Wn! t k
 rt d | É Ç n X| d k rxt j j | É t j j |  É k r_t j d	 | |  | É qxt j d	 | |  | É n  | rà| d f S| d
 k rÛt j j | É o∏t j j |  | É sCy t j |  | É | d f SWqt k
 rÏqXqCnP | d k rCt j j | É o#t j j |  | É sCt j |  | É | d f Sn  t |  | É | s\| r∏t j |  É } | rít j | | |	 | |
 f É n  | r∏t j | | | | É É q∏n  | d f S(   s  Copy a file 'src' to 'dst'.

    If 'dst' is a directory, then 'src' is copied there with the same name;
    otherwise, it must be a filename.  (If the file exists, it will be
    ruthlessly clobbered.)  If 'preserve_mode' is true (the default),
    the file's mode (type and permission bits, or whatever is analogous on
    the current platform) is copied.  If 'preserve_times' is true (the
    default), the last-modified and last-access times are copied as well.
    If 'update' is true, 'src' will only be copied if 'dst' does not exist,
    or if 'dst' does exist but is older than 'src'.

    'link' allows you to make hard links (os.link) or symbolic links
    (os.symlink) instead of copying: set it to "hard" or "sym"; if it is
    None (the default), files are copied.  Don't set 'link' on systems that
    don't support it: 'copy_file()' doesn't check if hard or symbolic
    linking is available. If hardlink fails, falls back to
    _copy_file_contents().

    Under Mac OS, uses the native file copy function in macostools; on
    other systems, uses '_copy_file_contents()' to copy file contents.

    Return a tuple (dest_name, copied): 'dest_name' is the actual name of
    the output file, and 'copied' is true if the file was copied (or would
    have been copied, if 'dry_run' true).
    iˇˇˇˇ(   t   newer(   t   ST_ATIMEt   ST_MTIMEt   ST_MODEt   S_IMODEs4   can't copy '%s': doesn't exist or not a regular filei   s"   not copying %s (output up-to-date)i    s&   invalid value '%s' for 'link' arguments   %s %s -> %sR   R   (   t   distutils.dep_utilR   t   statR   R   R   R   R	   R   t   isfileR    t   isdirt   joint   basenamet   dirnameR   t   debugt   _copy_actiont   KeyErrort
   ValueErrort   infoR   t   samefilet   linkt   OSErrort   symlinkR   t   utimet   chmod(   R   R   t   preserve_modet   preserve_timest   updateR,   t   verboset   dry_runR   R   R   R   R   t   dirt   actiont   st(    (    s)   /usr/lib/python2.7/distutils/file_util.pyt	   copy_fileG   sT    ""$
$
'
'! c         C   s˚  d d l  m } m } m } m } m } d d l }	 | d k rV t j d |  | É n  | r` | S| |  É s t	 d |  É Ç n  | | É r© t
 j j | | |  É É } n% | | É rŒ t	 d |  | f É Ç n  | | | É É s˘ t	 d |  | f É Ç n  d	 }
 y t
 j |  | É WnM t
 j k
 rb\ } } | |	 j k rFd }
 qct	 d
 |  | | f É Ç n X|
 r˜t |  | d | Éy t
 j |  É Wq˜t
 j k
 rÛ\ } } y t
 j | É Wn t
 j k
 rœn Xt	 d d |  | |  | f É Ç q˜Xn  | S(   s)  Move a file 'src' to 'dst'.

    If 'dst' is a directory, the file will be moved into it with the same
    name; otherwise, 'src' is just renamed to 'dst'.  Return the new
    full name of the file.

    Handles cross-device moves on Unix using 'copy_file()'.  What about
    other systems???
    iˇˇˇˇ(   R   R!   R"   R$   R%   Ni   s   moving %s -> %ss#   can't move '%s': not a regular files0   can't move '%s': destination '%s' already existss2   can't move '%s': destination '%s' not a valid pathi    s   couldn't move '%s' to '%s': %sR4   s+   couldn't move '%s' to '%s' by copy/delete: s   delete '%s' failed: %s(   t   os.pathR   R!   R"   R$   R%   R   R   R*   R    R	   R   R#   t   renameR
   t   EXDEVR9   R   (   R   R   R4   R5   R   R!   R"   R$   R%   R   t   copy_itt   numt   msg(    (    s)   /usr/lib/python2.7/distutils/file_util.pyt	   move_file™   sP    
(	c         C   sG   t  |  d É } z& x | D] } | j | d É q WWd | j É  Xd S(   s{   Create a file with the specified name and write 'contents' (a
    sequence of strings without line terminators) to it.
    t   ws   
N(   R   R   R   (   t   filenamet   contentst   ft   line(    (    s)   /usr/lib/python2.7/distutils/file_util.pyt
   write_fileÊ   s
    i @  (   t   __doc__t   __revision__R	   t   distutils.errorsR    t	   distutilsR   R   R'   R   R9   R@   RF   (    (    (    s)   /usr/lib/python2.7/distutils/file_util.pyt   <module>   s   

5	b<                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Û
”´[c           @   sÈ   d  Z  d Z d d l Z d d l Z d d l m Z m Z d d l m Z d d l	 m
 Z
 d d d d	 Ñ Z d
 Ñ  Z d d d d Ñ Z d d d d Ñ Z e j d k r« d d l	 m Z d a d a n  d d d d Ñ Z d d Ñ Z d S(   sÏ   distutils.spawn

Provides the 'spawn()' function, a front-end to various platform-
specific functions for launching another program in a sub-process.
Also provides the 'find_executable()' to search the path for a given
executable name.
s   $Id$iˇˇˇˇN(   t   DistutilsPlatformErrort   DistutilsExecError(   t   DEBUG(   t   logi   i    c         C   sè   t  |  É }  t j d k r1 t |  | d | ÉnZ t j d k rV t |  | d | Én5 t j d k r{ t |  | d | Én t d t j Ç d S(   sè  Run another program, specified as a command list 'cmd', in a new process.

    'cmd' is just the argument list for the new process, ie.
    cmd[0] is the program to run and cmd[1:] are the rest of its arguments.
    There is no way to run a program with a name different from that of its
    executable.

    If 'search_path' is true (the default), the system's executable
    search path will be used to find the program; otherwise, cmd[0]
    must be the exact path to the executable.  If 'dry_run' is true,
    the command will not actually be run.

    Raise DistutilsExecError if running the program fails in any way; just
    return on success.
    t   posixt   dry_runt   ntt   os2s1   don't know how to spawn programs on platform '%s'N(   t   listt   ost   namet   _spawn_posixt	   _spawn_ntt
   _spawn_os2R    (   t   cmdt   search_patht   verboseR   (    (    s%   /usr/lib/python2.7/distutils/spawn.pyt   spawn   s    c         C   s>   x7 t  |  É D]) \ } } d | k r d | |  | <q q W|  S(   s™   Quote command-line arguments for DOS/Windows conventions.

    Just wraps every argument which contains blanks in double quotes, and
    returns a new argument list.
    t    s   "%s"(   t	   enumerate(   t   argst   it   arg(    (    s%   /usr/lib/python2.7/distutils/spawn.pyt   _nt_quote_args/   s    c         C   sË   |  d } t  |  É }  | r1 t | É p+ | } n  t j d j | g |  d É É | s‰ y t j t j | |  É } Wn9 t k
 rØ } t	 sï | }  n  t
 d |  | d f Ç n X| d k r‰ t	 sÀ | }  n  t
 d |  | f Ç q‰ n  d  S(   Ni    R   i   s   command %r failed: %siˇˇˇˇs%   command %r failed with exit status %d(   R   t   find_executableR   t   infot   joinR	   t   spawnvt   P_WAITt   OSErrorR   R   (   R   R   R   R   t
   executablet   rct   exc(    (    s%   /usr/lib/python2.7/distutils/spawn.pyR   ?   s$    
!		c         C   sÛ   |  d } | r% t  | É p | } n  t j d j | g |  d É É | sÔ y t j t j | |  É } Wn9 t k
 r£ } t sâ | }  n  t	 d |  | d f Ç n X| d k rÔ t sø | }  n  t j
 d |  | f É t	 d |  | f Ç qÔ n  d  S(   Ni    R   i   s   command %r failed: %siˇˇˇˇs%   command %r failed with exit status %d(   R   R   R   R   R	   R   R   R   R   R   t   debug(   R   R   R   R   R   R   R    (    (    s%   /usr/lib/python2.7/distutils/spawn.pyR   W   s$    
!		t   darwin(   t	   sysconfigc         C   s_  t  j d j |  É É | r  d  S|  d } | r9 t j p? t j } d  } t j d k rGt	 d  k r¨ t
 j d É pu d a	 t	 r¨ g  t	 j d É D] } t | É ^ qé a q¨ n  t	 rGt j j d t	 É } t g  | j d É D] } t | É ^ q⁄ k rd | t	 f }	 t |	 É Ç n  t t j d | É} | r8t j p>t j } qGn  t j É  }
 |
 d k ry0 | d  k r~| | |  É n | | |  | É WnL t k
 r›} t s∞| }  n  t j j d |  | j f É t j d	 É n Xt sÌ| }  n  t j j d
 |  É t j d	 É nJxGy t j |
 d É \ }
 } Wn] t k
 rè} d d  l } | j | j k rfqn  t su| }  n  t d |  | d f Ç n Xt j  | É rÕt sÆ| }  n  t d |  t j! | É f Ç qt j" | É r t j# | É } | d k r˚d  St s
| }  n  t d |  | f Ç qt j$ | É r5qqt sD| }  n  t d |  | f Ç qWd  S(   NR   i    R"   t   MACOSX_DEPLOYMENT_TARGETt    t   .sF   $MACOSX_DEPLOYMENT_TARGET mismatch: now "%s" but "%s" during configures   unable to execute %r: %s
i   s(   unable to execute %r for unknown reasonsiˇˇˇˇs   command %r failed: %ss"   command %r terminated by signal %ds%   command %r failed with exit status %ds1   unknown error executing %r: termination status %d(%   R   R   R   R	   t   execvpt   execvt   Nonet   syst   platformt   _cfg_targetR#   t   get_config_vart   splitt   intt   _cfg_target_splitt   environt   getR    t   dictt   execvpet   execvet   forkR   R   t   stderrt   writet   strerrort   _exitt   waitpidt   errnot   EINTRR   t   WIFSIGNALEDt   WTERMSIGt	   WIFEXITEDt   WEXITSTATUSt
   WIFSTOPPED(   R   R   R   R   R   t   exec_fnt   envt   xt
   cur_targett   my_msgt   pidt   et   statusR    R<   t   exit_status(    (    s%   /usr/lib/python2.7/distutils/spawn.pyR   t   så    
..							c         C   s◊   | d k r t j d } n  | j t j É } t j j |  É \ } } t j d k sd t j	 d k r} | d k r} |  d }  n  t j j
 |  É sœ x9 | D]1 } t j j | |  É } t j j
 | É rñ | Sqñ Wd S|  Sd S(   s⁄   Tries to find 'executable' in the directories listed in 'path'.

    A string listing directories separated by 'os.pathsep'; defaults to
    os.environ['PATH'].  Returns the complete filename or None if not found.
    t   PATHt   win32R   s   .exeN(   R)   R	   R1   R.   t   pathsept   patht   splitextR*   R+   R
   t   isfileR   (   R   RO   t   pathst   baset   extt   pt   f(    (    s%   /usr/lib/python2.7/distutils/spawn.pyR   Ã   s    *(   t   __doc__t   __revision__R*   R	   t   distutils.errorsR    R   t   distutils.debugR   t	   distutilsR   R   R   R   R   R+   R#   R)   R,   R0   R   R   (    (    (    s%   /usr/lib/python2.7/distutils/spawn.pyt   <module>   s    		X                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               """distutils.filelist

Provides the FileList class, used for poking about the filesystem
and building lists of files.
"""

__revision__ = "$Id$"

import os, re
import fnmatch
from distutils.util import convert_path
from distutils.errors import DistutilsTemplateError, DistutilsInternalError
from distutils import log

class FileList:
    """A list of files built by on exploring the filesystem and filtered by
    applying various patterns to what we find there.

    Instance attributes:
      dir
        directory from which files will be taken -- only used if
        'allfiles' not supplied to constructor
      files
        list of filenames currently being built/filtered/manipulated
      allfiles
        complete list of files under consideration (ie. without any
        filtering applied)
    """

    def __init__(self, warn=None, debug_print=None):
        # ignore argument to FileList, but keep them for backwards
        # compatibility
        self.allfiles = None
        self.files = []

    def set_allfiles(self, allfiles):
        self.allfiles = allfiles

    def findall(self, dir=os.curdir):
        self.allfiles = findall(dir)

    def debug_print(self, msg):
        """Print 'msg' to stdout if the global DEBUG (taken from the
        DISTUTILS_DEBUG environment variable) flag is true.
        """
        from distutils.debug import DEBUG
        if DEBUG:
            print msg

    # -- List-like methods ---------------------------------------------

    def append(self, item):
        self.files.append(item)

    def extend(self, items):
        self.files.extend(items)

    def sort(self):
        # Not a strict lexical sort!
        sortable_files = map(os.path.split, self.files)
        sortable_files.sort()
        self.files = []
        for sort_tuple in sortable_files:
            self.files.append(os.path.join(*sort_tuple))


    # -- Other miscellaneous utility methods ---------------------------

    def remove_duplicates(self):
        # Assumes list has been sorted!
        for i in range(len(self.files) - 1, 0, -1):
            if self.files[i] == self.files[i - 1]:
                del self.files[i]


    # -- "File template" methods ---------------------------------------

    def _parse_template_line(self, line):
        words = line.split()
        action = words[0]

        patterns = dir = dir_pattern = None

        if action in ('include', 'exclude',
                      'global-include', 'global-exclude'):
            if len(words) < 2:
                raise DistutilsTemplateError, \
                      "'%s' expects <pattern1> <pattern2> ..." % action

            patterns = map(convert_path, words[1:])

        elif action in ('recursive-include', 'recursive-exclude'):
            if len(words) < 3:
                raise DistutilsTemplateError, \
                      "'%s' expects <dir> <pattern1> <pattern2> ..." % action

            dir = convert_path(words[1])
            patterns = map(convert_path, words[2:])

        elif action in ('graft', 'prune'):
            if len(words) != 2:
                raise DistutilsTemplateError, \
                     "'%s' expects a single <dir_pattern>" % action

            dir_pattern = convert_path(words[1])

        else:
            raise DistutilsTemplateError, "unknown action '%s'" % action

        return (action, patterns, dir, dir_pattern)

    def process_template_line(self, line):
        # Parse the line: split it up, make sure the right number of words
        # is there, and return the relevant words.  'action' is always
        # defined: it's the first word of the line.  Which of the other
        # three are defined depends on the action; it'll be either
        # patterns, (dir and patterns), or (dir_pattern).
        action, patterns, dir, dir_pattern = self._parse_template_line(line)

        # OK, now we know that the action is valid and we have the
        # right number of words on the line for that action -- so we
        # can proceed with minimal error-checking.
        if action == 'include':
            self.debug_print("include " + ' '.join(patterns))
            for pattern in patterns:
                if not self.include_pattern(pattern, anchor=1):
                    log.warn("warning: no files found matching '%s'",
                             pattern)

        elif action == 'exclude':
            self.debug_print("exclude " + ' '.join(patterns))
            for pattern in patterns:
                if not self.exclude_pattern(pattern, anchor=1):
                    log.warn(("warning: no previously-included files "
                              "found matching '%s'"), pattern)

        elif action == 'global-include':
            self.debug_print("global-include " + ' '.join(patterns))
            for pattern in patterns:
                if not self.include_pattern(pattern, anchor=0):
                    log.warn(("warning: no files found matching '%s' " +
                              "anywhere in distribution"), pattern)

        elif action == 'global-exclude':
            self.debug_print("global-exclude " + ' '.join(patterns))
            for pattern in patterns:
                if not self.exclude_pattern(pattern, anchor=0):
                    log.warn(("warning: no previously-included files matching "
                              "'%s' found anywhere in distribution"),
                             pattern)

        elif action == 'recursive-include':
            self.debug_print("recursive-include %s %s" %
                             (dir, ' '.join(patterns)))
            for pattern in patterns:
                if not self.include_pattern(pattern, prefix=dir):
                    log.warn(("warning: no files found matching '%s' " +
                                "under directory '%s'"),
                             pattern, dir)

        elif action == 'recursive-exclude':
            self.debug_print("recursive-exclude %s %s" %
                             (dir, ' '.join(patterns)))
            for pattern in patterns:
                if not self.exclude_pattern(pattern, prefix=dir):
                    log.warn(("warning: no previously-included files matching "
                              "'%s' found under directory '%s'"),
                             pattern, dir)

        elif action == 'graft':
            self.debug_print("graft " + dir_pattern)
            if not self.include_pattern(None, prefix=dir_pattern):
                log.warn("warning: no directories found matching '%s'",
                         dir_pattern)

        elif action == 'prune':
            self.debug_print("prune " + dir_pattern)
            if not self.exclude_pattern(None, prefix=dir_pattern):
                log.warn(("no previously-included directories found " +
                          "matching '%s'"), dir_pattern)
        else:
            raise DistutilsInternalError, \
                  "this cannot happen: invalid action '%s'" % action

    # -- Filtering/selection methods -----------------------------------

    def include_pattern(self, pattern, anchor=1, prefix=None, is_regex=0):
        """Select strings (presumably filenames) from 'self.files' that
        match 'pattern', a Unix-style wildcard (glob) pattern.

        Patterns are not quite the same as implemented by the 'fnmatch'
        module: '*' and '?'  match non-special characters, where "special"
        is platform-dependent: slash on Unix; colon, slash, and backslash on
        DOS/Windows; and colon on Mac OS.

        If 'anchor' is true (the default), then the pattern match is more
        stringent: "*.py" will match "foo.py" but not "foo/bar.py".  If
        'anchor' is false, both of these will match.

        If 'prefix' is supplied, then only filenames starting with 'prefix'
        (itself a pattern) and ending with 'pattern', with anything in between
        them, will match.  'anchor' is ignored in this case.

        If 'is_regex' is true, 'anchor' and 'prefix' are ignored, and
        'pattern' is assumed to be either a string containing a regex or a
        regex object -- no translation is done, the regex is just compiled
        and used as-is.

        Selected strings will be added to self.files.

        Return 1 if files are found.
        """
        # XXX docstring lying about what the special chars are?
        files_found = 0
        pattern_re = translate_pattern(pattern, anchor, prefix, is_regex)
        self.debug_print("include_pattern: applying regex r'%s'" %
                         pattern_re.pattern)

        # delayed loading of allfiles list
        if self.allfiles is None:
            self.findall()

        for name in self.allfiles:
            if pattern_re.search(name):
                self.debug_print(" adding " + name)
                self.files.append(name)
                files_found = 1

        return files_found


    def exclude_pattern(self, pattern, anchor=1, prefix=None, is_regex=0):
        """Remove strings (presumably filenames) from 'files' that match
        'pattern'.

        Other parameters are the same as for 'include_pattern()', above.
        The list 'self.files' is modified in place. Return 1 if files are
        found.
        """
        files_found = 0
        pattern_re = translate_pattern(pattern, anchor, prefix, is_regex)
        self.debug_print("exclude_pattern: applying regex r'%s'" %
                         pattern_re.pattern)
        for i in range(len(self.files)-1, -1, -1):
            if pattern_re.search(self.files[i]):
                self.debug_print(" removing " + self.files[i])
                del self.files[i]
                files_found = 1

        return files_found


# ----------------------------------------------------------------------
# Utility functions

def findall(dir = os.curdir):
    """Find all files under 'dir' and return the list of full filenames
    (relative to 'dir').
    """
    from stat import ST_MODE, S_ISREG, S_ISDIR, S_ISLNK

    list = []
    stack = [dir]
    pop = stack.pop
    push = stack.append

    while stack:
        dir = pop()
        names = os.listdir(dir)

        for name in names:
            if dir != os.curdir:        # avoid the dreaded "./" syndrome
                fullname = os.path.join(dir, name)
            else:
                fullname = name

            # Avoid excess stat calls -- just one will do, thank you!
            stat = os.stat(fullname)
            mode = stat[ST_MODE]
            if S_ISREG(mode):
                list.append(fullname)
            elif S_ISDIR(mode) and not S_ISLNK(mode):
                push(fullname)

    return list


def glob_to_re(pattern):
    """Translate a shell-like glob pattern to a regular expression.

    Return a string containing the regex.  Differs from
    'fnmatch.translate()' in that '*' does not match "special characters"
    (which are platform-specific).
    """
    pattern_re = fnmatch.translate(pattern)

    # '?' and '*' in the glob pattern become '.' and '.*' in the RE, which
    # IMHO is wrong -- '?' and '*' aren't supposed to match slash in Unix,
    # and by extension they shouldn't match such "special characters" under
    # any OS.  So change all non-escaped dots in the RE to match any
    # character except the special characters (currently: just os.sep).
    sep = os.sep
    if os.sep == '\\':
        # we're using a regex to manipulate a regex, so we need
        # to escape the backslash twice
        sep = r'\\\\'
    escaped = r'\1[^%s]' % sep
    pattern_re = re.sub(r'((?<!\\)(\\\\)*)\.', escaped, pattern_re)
    return pattern_re


def translate_pattern(pattern, anchor=1, prefix=None, is_regex=0):
    """Translate a shell-like wildcard pattern to a compiled regular
    expression.

    Return the compiled regex.  If 'is_regex' true,
    then 'pattern' is directly compiled to a regex (if it's a string)
    or just returned as-is (assumes it's a regex object).
    """
    if is_regex:
        if isinstance(pattern, str):
            return re.compile(pattern)
        else:
            return pattern

    if pattern:
        pattern_re = glob_to_re(pattern)
    else:
        pattern_re = ''

    if prefix is not None:
        # ditch end of pattern character
        empty_pattern = glob_to_re('')
        prefix_re = glob_to_re(prefix)[:-len(empty_pattern)]
        sep = os.sep
        if os.sep == '\\':
            sep = r'\\'
        pattern_re = "^" + sep.join((prefix_re, ".*" + pattern_re))
    else:                               # no prefix -- respect anchor flag
        if anchor:
            pattern_re = "^" + pattern_re

    return re.compile(pattern_re)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               Û
”´[c           @   sß   d  Z  d Z d d l Z d d l Z d d l Z d d l m Z d d l m Z m	 Z	 d d l
 m Z d d d Ñ  É  YZ e j d	 Ñ Z d
 Ñ  Z d d d d Ñ Z d S(   ss   distutils.filelist

Provides the FileList class, used for poking about the filesystem
and building lists of files.
s   $Id$iˇˇˇˇN(   t   convert_path(   t   DistutilsTemplateErrort   DistutilsInternalError(   t   logt   FileListc           B   sò   e  Z d  Z d d d Ñ Z d Ñ  Z e j d Ñ Z d Ñ  Z	 d Ñ  Z
 d Ñ  Z d Ñ  Z d Ñ  Z d	 Ñ  Z d
 Ñ  Z d d d d Ñ Z d d d d Ñ Z RS(   s—  A list of files built by on exploring the filesystem and filtered by
    applying various patterns to what we find there.

    Instance attributes:
      dir
        directory from which files will be taken -- only used if
        'allfiles' not supplied to constructor
      files
        list of filenames currently being built/filtered/manipulated
      allfiles
        complete list of files under consideration (ie. without any
        filtering applied)
    c         C   s   d  |  _ g  |  _ d  S(   N(   t   Nonet   allfilest   files(   t   selft   warnt   debug_print(    (    s(   /usr/lib/python2.7/distutils/filelist.pyt   __init__   s    	c         C   s   | |  _  d  S(   N(   R   (   R   R   (    (    s(   /usr/lib/python2.7/distutils/filelist.pyt   set_allfiles$   s    c         C   s   t  | É |  _ d  S(   N(   t   findallR   (   R   t   dir(    (    s(   /usr/lib/python2.7/distutils/filelist.pyR   '   s    c         C   s"   d d l  m } | r | GHn  d S(   s~   Print 'msg' to stdout if the global DEBUG (taken from the
        DISTUTILS_DEBUG environment variable) flag is true.
        iˇˇˇˇ(   t   DEBUGN(   t   distutils.debugR   (   R   t   msgR   (    (    s(   /usr/lib/python2.7/distutils/filelist.pyR
   *   s    c         C   s   |  j  j | É d  S(   N(   R   t   append(   R   t   item(    (    s(   /usr/lib/python2.7/distutils/filelist.pyR   4   s    c         C   s   |  j  j | É d  S(   N(   R   t   extend(   R   t   items(    (    s(   /usr/lib/python2.7/distutils/filelist.pyR   7   s    c         C   s\   t  t j j |  j É } | j É  g  |  _ x* | D]" } |  j j t j j | å  É q2 Wd  S(   N(   t   mapt   ost   patht   splitR   t   sortR   t   join(   R   t   sortable_filest
   sort_tuple(    (    s(   /usr/lib/python2.7/distutils/filelist.pyR   :   s
    
	c         C   sY   xR t  t |  j É d d d É D]1 } |  j | |  j | d k r  |  j | =q  q  Wd  S(   Ni   i    iˇˇˇˇ(   t   ranget   lenR   (   R   t   i(    (    s(   /usr/lib/python2.7/distutils/filelist.pyt   remove_duplicatesE   s    &c         C   s  | j  É  } | d } d  } } } | d k rh t | É d k  rR t d | Ç n  t t | d É } n¢ | d k rº t | É d k  rñ t d | Ç n  t | d É } t t | d É } nN | d k r˝ t | É d k rÍ t d | Ç n  t | d É } n t d | Ç | | | | f S(   Ni    t   includet   excludes   global-includes   global-excludei   s&   '%s' expects <pattern1> <pattern2> ...i   s   recursive-includes   recursive-excludei   s,   '%s' expects <dir> <pattern1> <pattern2> ...t   graftt   prunes#   '%s' expects a single <dir_pattern>s   unknown action '%s'(   R"   R#   s   global-includes   global-exclude(   s   recursive-includes   recursive-exclude(   R$   R%   (   R   R   R   R   R   R    (   R   t   linet   wordst   actiont   patternsR   t   dir_pattern(    (    s(   /usr/lib/python2.7/distutils/filelist.pyt   _parse_template_lineN   s,    
	c         C   s&  |  j  | É \ } } } } | d k r} |  j d d j | É É xﬁ| D]. } |  j | d d ÉsH t j d | É qH qH Wn•| d k rﬂ |  j d d j | É É x|| D]. } |  j | d d És™ t j d	 | É q™ q™ WnC| d
 k rE|  j d d j | É É x| D]2 } |  j | d d Ést j d d | É qqWn›| d k rß|  j d d j | É É x¥| D]. } |  j | d d Ésrt j d | É qrqrWn{| d k r|  j d | d j | É f É xL| D]5 } |  j | d | És⁄t j d d | | É q⁄q⁄Wn| d k rÅ|  j d | d j | É f É x› | D]1 } |  j | d | ÉsIt j d | | É qIqIWn° | d k r…|  j d | É |  j d  d | És"t j d | É q"nY | d k r|  j d | É |  j d  d | És"t j d d | É q"n t d  | Ç d  S(!   NR"   s   include t    t   anchori   s%   warning: no files found matching '%s'R#   s   exclude s9   warning: no previously-included files found matching '%s's   global-includes   global-include i    s&   warning: no files found matching '%s' s   anywhere in distributions   global-excludes   global-exclude sR   warning: no previously-included files matching '%s' found anywhere in distributions   recursive-includes   recursive-include %s %st   prefixs   under directory '%s's   recursive-excludes   recursive-exclude %s %ssN   warning: no previously-included files matching '%s' found under directory '%s'R$   s   graft s+   warning: no directories found matching '%s'R%   s   prune s)   no previously-included directories found s   matching '%s's'   this cannot happen: invalid action '%s'(	   R+   R
   R   t   include_patternR   R	   t   exclude_patternR   R   (   R   R&   R(   R)   R   R*   t   pattern(    (    s(   /usr/lib/python2.7/distutils/filelist.pyt   process_template_linep   sh    										i   i    c         C   sú   d } t  | | | | É } |  j d | j É |  j d k rK |  j É  n  xJ |  j D]? } | j | É rU |  j d | É |  j j | É d } qU qU W| S(   sÇ  Select strings (presumably filenames) from 'self.files' that
        match 'pattern', a Unix-style wildcard (glob) pattern.

        Patterns are not quite the same as implemented by the 'fnmatch'
        module: '*' and '?'  match non-special characters, where "special"
        is platform-dependent: slash on Unix; colon, slash, and backslash on
        DOS/Windows; and colon on Mac OS.

        If 'anchor' is true (the default), then the pattern match is more
        stringent: "*.py" will match "foo.py" but not "foo/bar.py".  If
        'anchor' is false, both of these will match.

        If 'prefix' is supplied, then only filenames starting with 'prefix'
        (itself a pattern) and ending with 'pattern', with anything in between
        them, will match.  'anchor' is ignored in this case.

        If 'is_regex' is true, 'anchor' and 'prefix' are ignored, and
        'pattern' is assumed to be either a string containing a regex or a
        regex object -- no translation is done, the regex is just compiled
        and used as-is.

        Selected strings will be added to self.files.

        Return 1 if files are found.
        i    s%   include_pattern: applying regex r'%s's    adding i   N(	   t   translate_patternR
   R1   R   R   R   t   searchR   R   (   R   R1   R-   R.   t   is_regext   files_foundt
   pattern_ret   name(    (    s(   /usr/lib/python2.7/distutils/filelist.pyR/   ª   s    	c         C   sû   d } t  | | | | É } |  j d | j É xh t t |  j É d d d É D]G } | j |  j | É rO |  j d |  j | É |  j | =d } qO qO W| S(   s¸   Remove strings (presumably filenames) from 'files' that match
        'pattern'.

        Other parameters are the same as for 'include_pattern()', above.
        The list 'self.files' is modified in place. Return 1 if files are
        found.
        i    s%   exclude_pattern: applying regex r'%s'i   iˇˇˇˇs
    removing (   R3   R
   R1   R   R   R   R4   (   R   R1   R-   R.   R5   R6   R7   R    (    (    s(   /usr/lib/python2.7/distutils/filelist.pyR0   Ë   s    	&
N(   t   __name__t
   __module__t   __doc__R   R   R   R   t   curdirR   R
   R   R   R   R!   R+   R2   R/   R0   (    (    (    s(   /usr/lib/python2.7/distutils/filelist.pyR      s   		
						"	K-c         C   s  d d l  m } m } m } m } g  } |  g } | j } | j } xª | r | É  }  t j |  É }	 xñ |	 D]é }
 |  t j	 k rò t j
 j |  |
 É } n |
 } t j  | É } | | } | | É r” | j | É qk | | É rk | | É rk | | É qk qk WqF W| S(   s^   Find all files under 'dir' and return the list of full filenames
    (relative to 'dir').
    iˇˇˇˇ(   t   ST_MODEt   S_ISREGt   S_ISDIRt   S_ISLNK(   t   statR=   R>   R?   R@   t   popR   R   t   listdirR<   R   R   (   R   R=   R>   R?   R@   t   listt   stackRB   t   pusht   namesR8   t   fullnameRA   t   mode(    (    s(   /usr/lib/python2.7/distutils/filelist.pyR      s&    "					
c         C   sS   t  j |  É } t j } t j d k r0 d } n  d | } t j d | | É } | S(   sÁ   Translate a shell-like glob pattern to a regular expression.

    Return a string containing the regex.  Differs from
    'fnmatch.translate()' in that '*' does not match "special characters"
    (which are platform-specific).
    s   \s   \\\\s   \1[^%s]s   ((?<!\\)(\\\\)*)\.(   t   fnmatcht	   translateR   t   sept   ret   sub(   R1   R7   RL   t   escaped(    (    s(   /usr/lib/python2.7/distutils/filelist.pyt
   glob_to_re   s    		
i   i    c         C   s‘   | r) t  |  t É r" t j |  É S|  Sn  |  r> t |  É } n d } | d k	 r¥ t d É } t | É t | É  } t j } t j d k rî d } n  d | j	 | d | f É } n | r« d | } n  t j | É S(   s  Translate a shell-like wildcard pattern to a compiled regular
    expression.

    Return the compiled regex.  If 'is_regex' true,
    then 'pattern' is directly compiled to a regex (if it's a string)
    or just returned as-is (assumes it's a regex object).
    t    s   \s   \\t   ^s   .*N(
   t
   isinstancet   strRM   t   compileRP   R   R   R   RL   R   (   R1   R-   R.   R5   R7   t   empty_patternt	   prefix_reRL   (    (    s(   /usr/lib/python2.7/distutils/filelist.pyR3   8  s"    		 (    (   R;   t   __revision__R   RM   RJ   t   distutils.utilR    t   distutils.errorsR   R   t	   distutilsR   R   R<   R   RP   R   R3   (    (    (    s(   /usr/lib/python2.7/distutils/filelist.pyt   <module>   s   Ò 	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              Û
”´[c           @   sò   d  Z  d Z d Z d Z d Z d Z d d l Z d d d	 Ñ  É  YZ e É  Z e j	 Z	 e j
 Z
 e j Z e j Z e j Z e j Z d
 Ñ  Z d Ñ  Z d S(   s,   A simple log mechanism styled after PEP 282.i   i   i   i   i   iˇˇˇˇNt   Logc           B   sS   e  Z e d  Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 RS(   c         C   s   | |  _  d  S(   N(   t	   threshold(   t   selfR   (    (    s#   /usr/lib/python2.7/distutils/log.pyt   __init__   s    c         C   s¢   | t  t t t t f k r4 t d t | É É Ç n  | |  j k rû | rV | | } n  | t t t f k rw t j	 } n	 t j
 } | j d | É | j É  n  d  S(   Ns   %s wrong log levels   %s
(   t   DEBUGt   INFOt   WARNt   ERRORt   FATALt
   ValueErrort   strR   t   syst   stderrt   stdoutt   writet   flush(   R   t   levelt   msgt   argst   stream(    (    s#   /usr/lib/python2.7/distutils/log.pyt   _log   s    	c         G   s   |  j  | | | É d  S(   N(   R   (   R   R   R   R   (    (    s#   /usr/lib/python2.7/distutils/log.pyt   log!   s    c         G   s   |  j  t | | É d  S(   N(   R   R   (   R   R   R   (    (    s#   /usr/lib/python2.7/distutils/log.pyt   debug$   s    c         G   s   |  j  t | | É d  S(   N(   R   R   (   R   R   R   (    (    s#   /usr/lib/python2.7/distutils/log.pyt   info'   s    c         G   s   |  j  t | | É d  S(   N(   R   R   (   R   R   R   (    (    s#   /usr/lib/python2.7/distutils/log.pyt   warn*   s    c         G   s   |  j  t | | É d  S(   N(   R   R   (   R   R   R   (    (    s#   /usr/lib/python2.7/distutils/log.pyt   error-   s    c         G   s   |  j  t | | É d  S(   N(   R   R   (   R   R   R   (    (    s#   /usr/lib/python2.7/distutils/log.pyt   fatal0   s    (   t   __name__t
   __module__R   R   R   R   R   R   R   R   R   (    (    (    s#   /usr/lib/python2.7/distutils/log.pyR       s   						c         C   s   t  j } |  t  _ | S(   N(   t   _global_logR   (   R   t   old(    (    s#   /usr/lib/python2.7/distutils/log.pyt   set_threshold;   s    		c         C   sO   |  d k r t  t É n2 |  d k r2 t  t É n |  d k rK t  t É n  d  S(   Ni    i   i   (   R   R   R   R   (   t   v(    (    s#   /usr/lib/python2.7/distutils/log.pyt   set_verbosityA   s    (    (   t   __doc__R   R   R   R   R   R   R    R   R   R   R   R   R   R   R   R!   (    (    (    s#   /usr/lib/python2.7/distutils/log.pyt   <module>   s    %								                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      Û
”´[c           @   s©  d  Z  d Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l m Z e j	 j
 e j É Z e j	 j
 e j É Z e j	 j e j	 j e j É É Z e j d k rÚ d e d j É  k rÚ e j	 j e j	 j e e j	 j É É Z n  e j d k rJd e d	 j É  k rJe j	 j e j	 j e e j	 j e j	 j É É Z n  e j d k r¢d
 e d j É  k r¢e j	 j e j	 j e e j	 j e j	 j É É Z n  d e j k rÕe j	 j
 e j d É Z n  d Ñ  Z e É  Z d Ñ  Z d d d Ñ Z d d d d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z  d d Ñ Z! e j" d É Z# e j" d É Z$ e j" d É Z% d d Ñ Z& d Ñ  Z' d a( d Ñ  Z) d Ñ  Z* d Ñ  Z+ d Ñ  Z, d Ñ  Z- d S(    sç  Provide access to Python's configuration information.  The specific
configuration variables available depend heavily on the platform and
configuration.  The values may be retrieved using
get_config_var(name), and the list of variables is available via
get_config_vars().keys().  Additional convenience functions are also
available.

Written by:   Fred L. Drake, Jr.
Email:        <fdrake@acm.org>
s   $Id$iˇˇˇˇN(   t   DistutilsPlatformErrort   ntt   pcbuildi¯ˇˇˇs   \pc\viˆˇˇˇs   \pcbuild\amd64iÚˇˇˇt   _PYTHON_PROJECT_BASEc          C   s=   x6 d D]. }  t  j j t  j j t d |  É É r t Sq Wt S(   Ns
   Setup.dists   Setup.localt   Modules(   s
   Setup.dists   Setup.local(   t   ost   patht   isfilet   joint   project_baset   Truet   False(   t   fn(    (    s)   /usr/lib/python2.7/distutils/sysconfig.pyt   _python_build3   s    $c           C   s   t  j d  S(   sñ   Return a string containing the major and minor Python version,
    leaving off the patchlevel.  Sample return values could be '1.5'
    or '2.2'.
    i   (   t   syst   version(    (    (    s)   /usr/lib/python2.7/distutils/sysconfig.pyt   get_python_version;   s    i    c         C   s-  t  j d k r“ t ry t  j j t j É } |  r9 | } n< t  j j t  j j | t	 d É É É } t  j j | d É } | S| d k	 rµ t  j j | d d t É  É t j r∞ d p≥ d S|  r≈ t	 d É St	 d	 É SnW t  j d
 k rÙ t  j j | d É St  j d k rt  j j | d É St d t  j É Ç d S(   sö  Return the directory containing installed Python header files.

    If 'plat_specific' is false (the default), this is the path to the
    non-platform-specific header files, i.e. Python.h and so on;
    otherwise, this is the path to platform-specific header files
    (namely pyconfig.h).

    If 'prefix' is supplied, use it instead of sys.prefix or
    sys.exec_prefix -- i.e., ignore 'plat_specific'.
    t   posixt   srcdirt   Includet   includet   pythont   _dt    t   CONFINCLUDEPYt	   INCLUDEPYR   t   os2sF   I don't know where Python installs its C header files on platform '%s'N(   R   t   namet   python_buildR   t   dirnameR   t
   executablet   abspathR   t   get_config_vart   NoneR   t   pydebugR    (   t   plat_specifict   prefixt   buildirt   inc_dirR   (    (    s)   /usr/lib/python2.7/distutils/sysconfig.pyt   get_python_incC   s,    	!
c         C   sq  | p t  j j | É d k } | d k r@ |  r7 t p: t } n  t  j d k r≈ t  j j | d d t É  É } | rx | S| rØ d t  j	 k rØ d t
 j k rØ t  j j | d É St  j j | d	 É Sn® t  j d
 k r| rÌ t  j j | d É St É  d k  r | St  j j | d d	 É SnT t  j d k rZ| rAt  j j | d É St  j j | d d	 É Sn t d t  j É Ç d S(   sI  Return the directory containing the Python library (standard or
    site additions).

    If 'plat_specific' is true, return the directory containing
    platform-specific modules, i.e. any module from a non-pure-Python
    module distribution; otherwise, return the platform-shared library
    directory.  If 'standard_lib' is true, return the directory
    containing standard Python library modules; otherwise, return the
    directory for site-specific modules.

    If 'prefix' is supplied, use it instead of sys.prefix or
    sys.exec_prefix -- i.e., ignore 'plat_specific'.
    s   /usrs
   /usr/localR   t   libR   t   PYTHONUSERBASEt   real_prefixs   dist-packagess   site-packagesR   t   Libs   2.2R   s?   I don't know where Python installs its library on platform '%s'N(   s   /usrs
   /usr/local(   R   R   t   normpathR!   t   EXEC_PREFIXt   PREFIXR   R   R   t   environR   t   __dict__R    (   R#   t   standard_libR$   t   is_default_prefixt	   libpython(    (    s)   /usr/lib/python2.7/distutils/sysconfig.pyt   get_python_libn   s0    $c         C   s0  |  j  d k r,t j d k rS t d É sS d d l } | j t É d t d <qS n  t d d d	 d
 d d d d d d d d d d É \ } } } } } } } }	 }
 } } } } } d t j	 k rt j	 d } t j d k rd t j	 k r|	 j
 | É r| |	 t | É }	 n  | } n  d t j	 k r8t j	 d } n  t j | | g d É râ| j d d É } |	 j d d É }	 | j d d É } n  d t j	 k r®t j	 d }	 n  d t j	 k r«t j	 d } n
 | d } d t j	 k r¯|	 d t j	 d }	 n | r|	 d | }	 n  d t j	 k r.t j	 d } n  d	 t j	 k rMt j	 d	 } n  d j d Ñ  | | | f DÉ É } d
 t j	 k r¬d j d Ñ  | | t j	 d
 | f DÉ É } |	 d t j	 d
 }	 n< | r˛d j d Ñ  | | | | f DÉ É } |	 d | }	 n  d t j	 k rO| d t j	 d } | d t j	 d } |	 d t j	 d }	 n3 | rÇ| d | } | d | } |	 d | }	 n  d t j	 k r°t j	 d } n  d t j	 k r»| d t j	 d } n | d | } | d | } |  j d  | d! | d" | d | d# | d$ |	 d% | d& | É |
 |  _ n  d S('   sƒ   Do any platform-specific customization of a CCompiler instance.

    Mainly needed on Unix, so we can plug in the information that
    varies across Unices and is stored in Python's Makefile.
    t   unixt   darwint   CUSTOMIZED_OSX_COMPILERiˇˇˇˇNR
   t   CCt   CXXt   OPTt   CFLAGSt   EXTRA_CFLAGSt
   BASECFLAGSt   CCSHAREDt   LDSHAREDt   SOt   ARt   ARFLAGSt   CONFIGURE_CPPFLAGSt   CONFIGURE_CFLAGSt   CONFIGURE_LDFLAGSs	   *-4.[0-8]s   -fstack-protector-strongs   -fstack-protectort   CPPs    -Et   LDFLAGSt    c         s   s!   |  ] } | r t  | É Vq d  S(   N(   t   str(   t   .0t   x(    (    s)   /usr/lib/python2.7/distutils/sysconfig.pys	   <genexpr>€   s    c         s   s!   |  ] } | r t  | É Vq d  S(   N(   RI   (   RJ   RK   (    (    s)   /usr/lib/python2.7/distutils/sysconfig.pys	   <genexpr>›   s    c         s   s!   |  ] } | r t  | É Vq d  S(   N(   RI   (   RJ   RK   (    (    s)   /usr/lib/python2.7/distutils/sysconfig.pys	   <genexpr>‡   s    t   CPPFLAGSt   preprocessort   compilert   compiler_sot   compiler_cxxt	   linker_sot
   linker_exet   archiver(   t   compiler_typeR   t   platformR    t   _osx_supportt   customize_compilert   _config_varst   get_config_varsR   R/   t
   startswitht   lent   fnmatcht   filtert   replaceR   t   set_executablest   shared_lib_extension(   RN   RV   t   cct   cxxt   optt   cflagst   extra_cflagst
   basecflagst   ccsharedt   ldsharedt   so_extt   art   ar_flagst   configure_cppflagst   configure_cflagst   configure_ldflagst   newcct   cppRS   t   cc_cmd(    (    s)   /usr/lib/python2.7/distutils/sysconfig.pyRW   †   sÇ    9	
",%	c          C   sv   t  r6 t j d k r- t j j t d É }  qE t }  n t d d É }  t É  d k  r] d } n d } t j j |  | É S(   s2   Return full pathname of installed pyconfig.h file.R   t   PCR#   i   s   2.2s   config.hs
   pyconfig.h(   R   R   R   R   R   R	   R'   R   (   R&   t   config_h(    (    s)   /usr/lib/python2.7/distutils/sysconfig.pyt   get_config_h_filename˛   s    		c          C   sG   t  r t j j t d É St d d d d É }  t j j t d É d É S(   sA   Return full pathname of installed Makefile from the Python build.t   MakefileR#   i   R1   t   LIBPL(   R   R   R   R   R	   R4   R    (   t   lib_dir(    (    s)   /usr/lib/python2.7/distutils/sysconfig.pyt   get_makefile_filename  s    c         C   s›   | d k r i  } n  t j d É } t j d É } x£ |  j É  } | sL Pn  | j | É } | r™ | j d d É \ } } y t | É } Wn t k
 rú n X| | | <q6 | j | É } | r6 d | | j d É <q6 q6 W| S(   sÃ   Parse a config.h-style file.

    A dictionary containing name/value pairs is returned.  If an
    optional dictionary is passed in as the second argument, it is
    used instead of a new dictionary.
    s"   #define ([A-Z][A-Za-z0-9_]+) (.*)
s&   /[*] #undef ([A-Z][A-Za-z0-9_]+) [*]/
i   i   i    N(   R!   t   ret   compilet   readlinet   matcht   groupt   intt
   ValueError(   t   fpt   gt	   define_rxt   undef_rxt   linet   mt   nt   v(    (    s)   /usr/lib/python2.7/distutils/sysconfig.pyt   parse_config_h  s(    	  s"   ([a-zA-Z][a-zA-Z0-9_]+)\s*=\s*(.*)s   \$\(([A-Za-z][A-Za-z0-9_]*)\)s   \${([A-Za-z][A-Za-z0-9_]*)}c         C   s∑  d d l  m } | |  d d d d d d É} | d k rC i  } n  i  } i  } xÀ | j É  } | d k rn Pn  t j | É } | rR | j d d É \ } }	 |	 j É  }	 |	 j d d	 É }
 d
 |
 k r“ |	 | | <qy t	 |	 É }	 Wn' t
 k
 r|	 j d d
 É | | <qX|	 | | <qR qR Wt | j É  É } d } x/t | É d k rfxt | É D]} | | } t j | É pÇt j | É } | d k	 rH| j d É } t } | | k r≈t | | É } n¶ | | k r⁄t } në | t j k r˘t j | } nr | | k r]| j d É r-| d | k r-d	 } qkd | | k rFt } qkt | d | É } n d	 | | <} | r_| | j É  } | | j É   | | } d
 | k r≤| | | <qEy t	 | É } Wn! t
 k
 rÂ| j É  | | <n X| | | <| j | É | j d É rE| d | k rE| d } | | k rB| | | <qBqEq_qW| | | <| j | É qWWq8Wx< | j É  D]. \ } }	 t |	 t É rt|	 j É  | | <qtqtW| j | É | S(   sÃ   Parse a Makefile-style file.

    A dictionary containing name/value pairs is returned.  If an
    optional dictionary is passed in as the second argument, it is
    used instead of a new dictionary.
    iˇˇˇˇ(   t   TextFilet   strip_commentsi   t   skip_blankst
   join_linesi   s   $$R   t   $R;   RG   RL   i    t   PY_i   N(   R;   RG   RL   (   t   distutils.text_fileRâ   R!   R{   t   _variable_rxR|   R}   t   stripR^   R~   R   t   listt   keysR[   t   tuplet   _findvar1_rxt   searcht   _findvar2_rxR
   RI   R   R   R/   RZ   t   endt   startt   removet   itemst
   isinstancet   update(   R   RÅ   Râ   RÄ   t   donet   notdoneRÑ   RÖ   RÜ   Rá   t   tmpvt	   variablest   renamed_variablesR   t   valuet   foundt   itemt   aftert   k(    (    s)   /usr/lib/python2.7/distutils/sysconfig.pyt   parse_makefile:  sÜ    	
			


c         C   sp   xi t  j |  É p t j |  É } | rg | j É  \ } } |  d | !| j | j d É É |  | }  q Pq W|  S(   s®  Expand Makefile-style variables -- "${foo}" or "$(foo)" -- in
    'string' according to 'vars' (a dictionary mapping variable names to
    values).  Variables not present in 'vars' are silently expanded to the
    empty string.  The variable values in 'vars' should not contain further
    variable expansions; if 'vars' is the output of 'parse_makefile()',
    you're fine.  Returns a variable-expanded version of 's'.
    i    i   (   Rï   Rñ   Ró   t   spant   getR}   (   t   st   varsRÖ   t   begRò   (    (    s)   /usr/lib/python2.7/distutils/sysconfig.pyt   expand_makefile_vars´  s    .c          C   s'   d d l  m }  i  a t j |  É d S(   s7   Initialize the module as appropriate for POSIX systems.iˇˇˇˇ(   t   build_time_varsN(   t   _sysconfigdataRØ   RX   Rù   (   RØ   (    (    s)   /usr/lib/python2.7/distutils/sysconfig.pyt   _init_posix∆  s    c          C   sß   i  }  t  d d d d É |  d <t  d d d d É |  d <t d d É |  d <d |  d	 <d
 |  d <t É  j d d É |  d <t j j t j j t j	 É É |  d <|  a
 d S(   s+   Initialize the module as appropriate for NTR#   i    R1   i   t   LIBDESTt
   BINLIBDESTR   s   .pydR@   s   .exet   EXEt   .R   t   VERSIONt   BINDIRN(   R4   R'   R   R^   R   R   R   R   R   R   RX   (   RÅ   (    (    s)   /usr/lib/python2.7/distutils/sysconfig.pyt   _init_ntœ  s    

%c          C   si   i  }  t  d d d d É |  d <t  d d d d É |  d <t d d É |  d <d |  d	 <d
 |  d <|  a d S(   s-   Initialize the module as appropriate for OS/2R#   i    R1   i   R≤   R≥   R   s   .pydR@   s   .exeR¥   N(   R4   R'   RX   (   RÅ   (    (    s)   /usr/lib/python2.7/distutils/sysconfig.pyt	   _init_os2‚  s    

c          G   sº   t  d k r} t É  j d t j É } | r5 | É  n i  a  t t  d <t t  d <t j	 d k r} d d l
 } | j t  É q} n  |  r¥ g  } x$ |  D] } | j t  j | É É qê W| St  Sd S(   sÍ  With no arguments, return a dictionary of all configuration
    variables relevant for the current platform.  Generally this includes
    everything needed to build extensions and install both pure modules and
    extensions.  On Unix, this means every variable defined in Python's
    installed Makefile; on Windows and Mac OS it's a much smaller set.

    With arguments, return a list of values that result from looking up
    each argument in the configuration variable dictionary.
    t   _init_R$   t   exec_prefixR6   iˇˇˇˇN(   RX   R!   t   globalsR™   R   R   R.   R-   R   RU   RV   t   customize_config_varst   append(   t   argst   funcRV   t   valsR   (    (    s)   /usr/lib/python2.7/distutils/sysconfig.pyRY   Û  s     


c         C   s   t  É  j |  É S(   sì   Return the value of a single variable using the dictionary
    returned by 'get_config_vars()'.  Equivalent to
    get_config_vars().get(name)
    (   RY   R™   (   R   (    (    s)   /usr/lib/python2.7/distutils/sysconfig.pyR      s    (.   t   __doc__t   __revision__R   Ry   t   stringR   R\   t   distutils.errorsR    R   R,   R$   R.   Rª   R-   R   R   R   R	   R   t   lowerR   t   pardirR/   R   R   R   R!   R'   R4   RW   Rt   Rx   Rà   Rz   Rê   Rï   Ró   R®   RÆ   RX   R±   R∏   Rπ   RY   R    (    (    (    s)   /usr/lib/python2.7/distutils/sysconfig.pyt   <module>
   sP   !%*%%			+2	^		q						&                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 """distutils.msvc9compiler

Contains MSVCCompiler, an implementation of the abstract CCompiler class
for the Microsoft Visual Studio 2008.

The module is compatible with VS 2005 and VS 2008. You can find legacy support
for older versions of VS in distutils.msvccompiler.
"""

# Written by Perry Stoll
# hacked by Robin Becker and Thomas Heller to do a better job of
#   finding DevStudio (through the registry)
# ported to VS2005 and VS 2008 by Christian Heimes

__revision__ = "$Id$"

import os
import subprocess
import sys
import re

from distutils.errors import (DistutilsExecError, DistutilsPlatformError,
                              CompileError, LibError, LinkError)
from distutils.ccompiler import CCompiler, gen_lib_options
from distutils import log
from distutils.util import get_platform

import _winreg

RegOpenKeyEx = _winreg.OpenKeyEx
RegEnumKey = _winreg.EnumKey
RegEnumValue = _winreg.EnumValue
RegError = _winreg.error

HKEYS = (_winreg.HKEY_USERS,
         _winreg.HKEY_CURRENT_USER,
         _winreg.HKEY_LOCAL_MACHINE,
         _winreg.HKEY_CLASSES_ROOT)

NATIVE_WIN64 = (sys.platform == 'win32' and sys.maxsize > 2**32)
if NATIVE_WIN64:
    # Visual C++ is a 32-bit application, so we need to look in
    # the corresponding registry branch, if we're running a
    # 64-bit Python on Win64
    VS_BASE = r"Software\Wow6432Node\Microsoft\VisualStudio\%0.1f"
    VSEXPRESS_BASE = r"Software\Wow6432Node\Microsoft\VCExpress\%0.1f"
    WINSDK_BASE = r"Software\Wow6432Node\Microsoft\Microsoft SDKs\Windows"
    NET_BASE = r"Software\Wow6432Node\Microsoft\.NETFramework"
else:
    VS_BASE = r"Software\Microsoft\VisualStudio\%0.1f"
    VSEXPRESS_BASE = r"Software\Microsoft\VCExpress\%0.1f"
    WINSDK_BASE = r"Software\Microsoft\Microsoft SDKs\Windows"
    NET_BASE = r"Software\Microsoft\.NETFramework"

# A map keyed by get_platform() return values to values accepted by
# 'vcvarsall.bat'.  Note a cross-compile may combine these (eg, 'x86_amd64' is
# the param to cross-compile on x86 targeting amd64.)
PLAT_TO_VCVARS = {
    'win32' : 'x86',
    'win-amd64' : 'amd64',
    'win-ia64' : 'ia64',
}

class Reg:
    """Helper class to read values from the registry
    """

    def get_value(cls, path, key):
        for base in HKEYS:
            d = cls.read_values(base, path)
            if d and key in d:
                return d[key]
        raise KeyError(key)
    get_value = classmethod(get_value)

    def read_keys(cls, base, key):
        """Return list of registry keys."""
        try:
            handle = RegOpenKeyEx(base, key)
        except RegError:
            return None
        L = []
        i = 0
        while True:
            try:
                k = RegEnumKey(handle, i)
            except RegError:
                break
            L.append(k)
            i += 1
        return L
    read_keys = classmethod(read_keys)

    def read_values(cls, base, key):
        """Return dict of registry keys and values.

        All names are converted to lowercase.
        """
        try:
            handle = RegOpenKeyEx(base, key)
        except RegError:
            return None
        d = {}
        i = 0
        while True:
            try:
                name, value, type = RegEnumValue(handle, i)
            except RegError:
                break
            name = name.lower()
            d[cls.convert_mbcs(name)] = cls.convert_mbcs(value)
            i += 1
        return d
    read_values = classmethod(read_values)

    def convert_mbcs(s):
        dec = getattr(s, "decode", None)
        if dec is not None:
            try:
                s = dec("mbcs")
            except UnicodeError:
                pass
        return s
    convert_mbcs = staticmethod(convert_mbcs)

class MacroExpander:

    def __init__(self, version):
        self.macros = {}
        self.vsbase = VS_BASE % version
        self.load_macros(version)

    def set_macro(self, macro, path, key):
        self.macros["$(%s)" % macro] = Reg.get_value(path, key)

    def load_macros(self, version):
        self.set_macro("VCInstallDir", self.vsbase + r"\Setup\VC", "productdir")
        self.set_macro("VSInstallDir", self.vsbase + r"\Setup\VS", "productdir")
        self.set_macro("FrameworkDir", NET_BASE, "installroot")
        try:
            if version >= 8.0:
                self.set_macro("FrameworkSDKDir", NET_BASE,
                               "sdkinstallrootv2.0")
            else:
                raise KeyError("sdkinstallrootv2.0")
        except KeyError:
            raise DistutilsPlatformError(
            """Python was built with Visual Studio 2008;
extensions must be built with a compiler than can generate compatible binaries.
Visual Studio 2008 was not found on this system. If you have Cygwin installed,
you can try compiling with MingW32, by passing "-c mingw32" to setup.py.""")

        if version >= 9.0:
            self.set_macro("FrameworkVersion", self.vsbase, "clr version")
            self.set_macro("WindowsSdkDir", WINSDK_BASE, "currentinstallfolder")
        else:
            p = r"Software\Microsoft\NET Framework Setup\Product"
            for base in HKEYS:
                try:
                    h = RegOpenKeyEx(base, p)
                except RegError:
                    continue
                key = RegEnumKey(h, 0)
                d = Reg.get_value(base, r"%s\%s" % (p, key))
                self.macros["$(FrameworkVersion)"] = d["version"]

    def sub(self, s):
        for k, v in self.macros.items():
            s = s.replace(k, v)
        return s

def get_build_version():
    """Return the version of MSVC that was used to build Python.

    For Python 2.3 and up, the version number is included in
    sys.version.  For earlier versions, assume the compiler is MSVC 6.
    """
    prefix = "MSC v."
    i = sys.version.find(prefix)
    if i == -1:
        return 6
    i = i + len(prefix)
    s, rest = sys.version[i:].split(" ", 1)
    majorVersion = int(s[:-2]) - 6
    minorVersion = int(s[2:3]) / 10.0
    # I don't think paths are affected by minor version in version 6
    if majorVersion == 6:
        minorVersion = 0
    if majorVersion >= 6:
        return majorVersion + minorVersion
    # else we don't know what version of the compiler this is
    return None

def normalize_and_reduce_paths(paths):
    """Return a list of normalized paths with duplicates removed.

    The current order of paths is maintained.
    """
    # Paths are normalized so things like:  /a and /a/ aren't both preserved.
    reduced_paths = []
    for p in paths:
        np = os.path.normpath(p)
        # XXX(nnorwitz): O(n**2), if reduced_paths gets long perhaps use a set.
        if np not in reduced_paths:
            reduced_paths.append(np)
    return reduced_paths

def removeDuplicates(variable):
    """Remove duplicate values of an environment variable.
    """
    oldList = variable.split(os.pathsep)
    newList = []
    for i in oldList:
        if i not in newList:
            newList.append(i)
    newVariable = os.pathsep.join(newList)
    return newVariable

def find_vcvarsall(version):
    """Find the vcvarsall.bat file

    At first it tries to find the productdir of VS 2008 in the registry. If
    that fails it falls back to the VS90COMNTOOLS env var.
    """
    vsbase = VS_BASE % version
    try:
        productdir = Reg.get_value(r"%s\Setup\VC" % vsbase,
                                   "productdir")
    except KeyError:
        productdir = None

    # trying Express edition
    if productdir is None:
        vsbase = VSEXPRESS_BASE % version
        try:
            productdir = Reg.get_value(r"%s\Setup\VC" % vsbase,
                                       "productdir")
        except KeyError:
            productdir = None
            log.debug("Unable to find productdir in registry")

    if not productdir or not os.path.isdir(productdir):
        toolskey = "VS%0.f0COMNTOOLS" % version
        toolsdir = os.environ.get(toolskey, None)

        if toolsdir and os.path.isdir(toolsdir):
            productdir = os.path.join(toolsdir, os.pardir, os.pardir, "VC")
            productdir = os.path.abspath(productdir)
            if not os.path.isdir(productdir):
                log.debug("%s is not a valid directory" % productdir)
                return None
        else:
            log.debug("Env var %s is not set or invalid" % toolskey)
    if not productdir:
        log.debug("No productdir found")
        return None
    vcvarsall = os.path.join(productdir, "vcvarsall.bat")
    if os.path.isfile(vcvarsall):
        return vcvarsall
    log.debug("Unable to find vcvarsall.bat")
    return None

def query_vcvarsall(version, arch="x86"):
    """Launch vcvarsall.bat and read the settings from its environment
    """
    vcvarsall = find_vcvarsall(version)
    interesting = set(("include", "lib", "libpath", "path"))
    result = {}

    if vcvarsall is None:
        raise DistutilsPlatformError("Unable to find vcvarsall.bat")
    log.debug("Calling 'vcvarsall.bat %s' (version=%s)", arch, version)
    popen = subprocess.Popen('"%s" %s & set' % (vcvarsall, arch),
                             stdout=subprocess.PIPE,
                             stderr=subprocess.PIPE)
    try:
        stdout, stderr = popen.communicate()
        if popen.wait() != 0:
            raise DistutilsPlatformError(stderr.decode("mbcs"))

        stdout = stdout.decode("mbcs")
        for line in stdout.split("\n"):
            line = Reg.convert_mbcs(line)
            if '=' not in line:
                continue
            line = line.strip()
            key, value = line.split('=', 1)
            key = key.lower()
            if key in interesting:
                if value.endswith(os.pathsep):
                    value = value[:-1]
                result[key] = removeDuplicates(value)

    finally:
        popen.stdout.close()
        popen.stderr.close()

    if len(result) != len(interesting):
        raise ValueError(str(list(result.keys())))

    return result

# More globals
VERSION = get_build_version()
if VERSION < 8.0:
    raise DistutilsPlatformError("VC %0.1f is not supported by this module" % VERSION)
# MACROS = MacroExpander(VERSION)

class MSVCCompiler(CCompiler) :
    """Concrete class that implements an interface to Microsoft Visual C++,
       as defined by the CCompiler abstract class."""

    compiler_type = 'msvc'

    # Just set this so CCompiler's constructor doesn't barf.  We currently
    # don't use the 'set_executables()' bureaucracy provided by CCompiler,
    # as it really isn't necessary for this sort of single-compiler class.
    # Would be nice to have a consistent interface with UnixCCompiler,
    # though, so it's worth thinking about.
    executables = {}

    # Private class data (need to distinguish C from C++ source for compiler)
    _c_extensions = ['.c']
    _cpp_extensions = ['.cc', '.cpp', '.cxx']
    _rc_extensions = ['.rc']
    _mc_extensions = ['.mc']

    # Needed for the filename generation methods provided by the
    # base class, CCompiler.
    src_extensions = (_c_extensions + _cpp_extensions +
                      _rc_extensions + _mc_extensions)
    res_extension = '.res'
    obj_extension = '.obj'
    static_lib_extension = '.lib'
    shared_lib_extension = '.dll'
    static_lib_format = shared_lib_format = '%s%s'
    exe_extension = '.exe'

    def __init__(self, verbose=0, dry_run=0, force=0):
        CCompiler.__init__ (self, verbose, dry_run, force)
        self.__version = VERSION
        self.__root = r"Software\Microsoft\VisualStudio"
        # self.__macros = MACROS
        self.__paths = []
        # target platform (.plat_name is consistent with 'bdist')
        self.plat_name = None
        self.__arch = None # deprecated name
        self.initialized = False

    def initialize(self, plat_name=None):
        # multi-init means we would need to check platform same each time...
        assert not self.initialized, "don't init multiple times"
        if plat_name is None:
            plat_name = get_platform()
        # sanity check for platforms to prevent obscure errors later.
        ok_plats = 'win32', 'win-amd64', 'win-ia64'
        if plat_name not in ok_plats:
            raise DistutilsPlatformError("--plat-name must be one of %s" %
                                         (ok_plats,))

        if "DISTUTILS_USE_SDK" in os.environ and "MSSdk" in os.environ and self.find_exe("cl.exe"):
            # Assume that the SDK set up everything alright; don't try to be
            # smarter
            self.cc = "cl.exe"
            self.linker = "link.exe"
            self.lib = "lib.exe"
            self.rc = "rc.exe"
            self.mc = "mc.exe"
        else:
            # On x86, 'vcvars32.bat amd64' creates an env that doesn't work;
            # to cross compile, you use 'x86_amd64'.
            # On AMD64, 'vcvars32.bat amd64' is a native build env; to cross
            # compile use 'x86' (ie, it runs the x86 compiler directly)
            # No idea how itanium handles this, if at all.
            if plat_name == get_platform() or plat_name == 'win32':
                # native build or cross-compile to win32
                plat_spec = PLAT_TO_VCVARS[plat_name]
            else:
                # cross compile from win32 -> some 64bit
                plat_spec = PLAT_TO_VCVARS[get_platform()] + '_' + \
                            PLAT_TO_VCVARS[plat_name]

            vc_env = query_vcvarsall(VERSION, plat_spec)

            # take care to only use strings in the environment.
            self.__paths = vc_env['path'].encode('mbcs').split(os.pathsep)
            os.environ['lib'] = vc_env['lib'].encode('mbcs')
            os.environ['include'] = vc_env['include'].encode('mbcs')

            if len(self.__paths) == 0:
                raise DistutilsPlatformError("Python was built with %s, "
                       "and extensions need to be built with the same "
                       "version of the compiler, but it isn't installed."
                       % self.__product)

            self.cc = self.find_exe("cl.exe")
            self.linker = self.find_exe("link.exe")
            self.lib = self.find_exe("lib.exe")
            self.rc = self.find_exe("rc.exe")   # resource compiler
            self.mc = self.find_exe("mc.exe")   # message compiler
            #self.set_path_env_var('lib')
            #self.set_path_env_var('include')

        # extend the MSVC path with the current path
        try:
            for p in os.environ['path'].split(';'):
                self.__paths.append(p)
        except KeyError:
            pass
        self.__paths = normalize_and_reduce_paths(self.__paths)
        os.environ['path'] = ";".join(self.__paths)

        self.preprocess_options = None
        if self.__arch == "x86":
            self.compile_options = [ '/nologo', '/Ox', '/MD', '/W3',
                                     '/DNDEBUG']
            self.compile_options_debug = ['/nologo', '/Od', '/MDd', '/W3',
                                          '/Z7', '/D_DEBUG']
        else:
            # Win64
            self.compile_options = [ '/nologo', '/Ox', '/MD', '/W3', '/GS-' ,
                                     '/DNDEBUG']
            self.compile_options_debug = ['/nologo', '/Od', '/MDd', '/W3', '/GS-',
                                          '/Z7', '/D_DEBUG']

        self.ldflags_shared = ['/DLL', '/nologo', '/INCREMENTAL:NO']
        if self.__version >= 7:
            self.ldflags_shared_debug = [
                '/DLL', '/nologo', '/INCREMENTAL:no', '/DEBUG'
                ]
        self.ldflags_static = [ '/nologo']

        self.initialized = True

    # -- Worker methods ------------------------------------------------

    def object_filenames(self,
                         source_filenames,
                         strip_dir=0,
                         output_dir=''):
        # Copied from ccompiler.py, extended to return .res as 'object'-file
        # for .rc input file
        if output_dir is None: output_dir = ''
        obj_names = []
        for src_name in source_filenames:
            (base, ext) = os.path.splitext (src_name)
            base = os.path.splitdrive(base)[1] # Chop off the drive
            base = base[os.path.isabs(base):]  # If abs, chop off leading /
            if ext not in self.src_extensions:
                # Better to raise an exception instead of silently continuing
                # and later complain about sources and targets having
                # different lengths
                raise CompileError ("Don't know how to compile %s" % src_name)
            if strip_dir:
                base = os.path.basename (base)
            if ext in self._rc_extensions:
                obj_names.append (os.path.join (output_dir,
                                                base + self.res_extension))
            elif ext in self._mc_extensions:
                obj_names.append (os.path.join (output_dir,
                                                base + self.res_extension))
            else:
                obj_names.append (os.path.join (output_dir,
                                                base + self.obj_extension))
        return obj_names


    def compile(self, sources,
                output_dir=None, macros=None, include_dirs=None, debug=0,
                extra_preargs=None, extra_postargs=None, depends=None):

        if not self.initialized:
            self.initialize()
        compile_info = self._setup_compile(output_dir, macros, include_dirs,
                                           sources, depends, extra_postargs)
        macros, objects, extra_postargs, pp_opts, build = compile_info

        compile_opts = extra_preargs or []
        compile_opts.append ('/c')
        if debug:
            compile_opts.extend(self.compile_options_debug)
        else:
            compile_opts.extend(self.compile_options)

        for obj in objects:
            try:
                src, ext = build[obj]
            except KeyError:
                continue
            if debug:
                # pass the full pathname to MSVC in debug mode,
                # this allows the debugger to find the source file
                # without asking the user to browse for it
                src = os.path.abspath(src)

            if ext in self._c_extensions:
                input_opt = "/Tc" + src
            elif ext in self._cpp_extensions:
                input_opt = "/Tp" + src
            elif ext in self._rc_extensions:
                # compile .RC to .RES file
                input_opt = src
                output_opt = "/fo" + obj
                try:
                    self.spawn([self.rc] + pp_opts +
                               [output_opt] + [input_opt])
                except DistutilsExecError, msg:
                    raise CompileError(msg)
                continue
            elif ext in self._mc_extensions:
                # Compile .MC to .RC file to .RES file.
                #   * '-h dir' specifies the directory for the
                #     generated include file
                #   * '-r dir' specifies the target directory of the
                #     generated RC file and the binary message resource
                #     it includes
                #
                # For now (since there are no options to change this),
                # we use the source-directory for the include file and
                # the build directory for the RC file and message
                # resources. This works at least for win32all.
                h_dir = os.path.dirname(src)
                rc_dir = os.path.dirname(obj)
                try:
                    # first compile .MC to .RC and .H file
                    self.spawn([self.mc] +
                               ['-h', h_dir, '-r', rc_dir] + [src])
                    base, _ = os.path.splitext (os.path.basename (src))
                    rc_file = os.path.join (rc_dir, base + '.rc')
                    # then compile .RC to .RES file
                    self.spawn([self.rc] +
                               ["/fo" + obj] + [rc_file])

                except DistutilsExecError, msg:
                    raise CompileError(msg)
                continue
            else:
                # how to handle this file?
                raise CompileError("Don't know how to compile %s to %s"
                                   % (src, obj))

            output_opt = "/Fo" + obj
            try:
                self.spawn([self.cc] + compile_opts + pp_opts +
                           [input_opt, output_opt] +
                           extra_postargs)
            except DistutilsExecError, msg:
                raise CompileError(msg)

        return objects


    def create_static_lib(self,
                          objects,
                          output_libname,
                          output_dir=None,
                          debug=0,
                          target_lang=None):

        if not self.initialized:
            self.initialize()
        (objects, output_dir) = self._fix_object_args(objects, output_dir)
        output_filename = self.library_filename(output_libname,
                                                output_dir=output_dir)

        if self._need_link(objects, output_filename):
            lib_args = objects + ['/OUT:' + output_filename]
            if debug:
                pass # XXX what goes here?
            try:
                self.spawn([self.lib] + lib_args)
            except DistutilsExecError, msg:
                raise LibError(msg)
        else:
            log.debug("skipping %s (up-to-date)", output_filename)


    def link(self,
             target_desc,
             objects,
             output_filename,
             output_dir=None,
             libraries=None,
             library_dirs=None,
             runtime_library_dirs=None,
             export_symbols=None,
             debug=0,
             extra_preargs=None,
             extra_postargs=None,
             build_temp=None,
             target_lang=None):

        if not self.initialized:
            self.initialize()
        (objects, output_dir) = self._fix_object_args(objects, output_dir)
        fixed_args = self._fix_lib_args(libraries, library_dirs,
                                        runtime_library_dirs)
        (libraries, library_dirs, runtime_library_dirs) = fixed_args

        if runtime_library_dirs:
            self.warn ("I don't know what to do with 'runtime_library_dirs': "
                       + str (runtime_library_dirs))

        lib_opts = gen_lib_options(self,
                                   library_dirs, runtime_library_dirs,
                                   libraries)
        if output_dir is not None:
            output_filename = os.path.join(output_dir, output_filename)

        if self._need_link(objects, output_filename):
            if target_desc == CCompiler.EXECUTABLE:
                if debug:
                    ldflags = self.ldflags_shared_debug[1:]
                else:
                    ldflags = self.ldflags_shared[1:]
            else:
                if debug:
                    ldflags = self.ldflags_shared_debug
                else:
                    ldflags = self.ldflags_shared

            export_opts = []
            for sym in (export_symbols or []):
                export_opts.append("/EXPORT:" + sym)

            ld_args = (ldflags + lib_opts + export_opts +
                       objects + ['/OUT:' + output_filename])

            # The MSVC linker generates .lib and .exp files, which cannot be
            # suppressed by any linker switches. The .lib files may even be
            # needed! Make sure they are generated in the temporary build
            # directory. Since they have different names for debug and release
            # builds, they can go into the same directory.
            build_temp = os.path.dirname(objects[0])
            if export_symbols is not None:
                (dll_name, dll_ext) = os.path.splitext(
                    os.path.basename(output_filename))
                implib_file = os.path.join(
                    build_temp,
                    self.library_filename(dll_name))
                ld_args.append ('/IMPLIB:' + implib_file)

            self.manifest_setup_ldargs(output_filename, build_temp, ld_args)

            if extra_preargs:
                ld_args[:0] = extra_preargs
            if extra_postargs:
                ld_args.extend(extra_postargs)

            self.mkpath(os.path.dirname(output_filename))
            try:
                self.spawn([self.linker] + ld_args)
            except DistutilsExecError, msg:
                raise LinkError(msg)

            # embed the manifest
            # XXX - this is somewhat fragile - if mt.exe fails, distutils
            # will still consider the DLL up-to-date, but it will not have a
            # manifest.  Maybe we should link to a temp file?  OTOH, that
            # implies a build environment error that shouldn't go undetected.
            mfinfo = self.manifest_get_embed_info(target_desc, ld_args)
            if mfinfo is not None:
                mffilename, mfid = mfinfo
                out_arg = '-outputresource:%s;%s' % (output_filename, mfid)
                try:
                    self.spawn(['mt.exe', '-nologo', '-manifest',
                                mffilename, out_arg])
                except DistutilsExecError, msg:
                    raise LinkError(msg)
        else:
            log.debug("skipping %s (up-to-date)", output_filename)

    def manifest_setup_ldargs(self, output_filename, build_temp, ld_args):
        # If we need a manifest at all, an embedded manifest is recommended.
        # See MSDN article titled
        # "How to: Embed a Manifest Inside a C/C++ Application"
        # (currently at http://msdn2.microsoft.com/en-us/library/ms235591(VS.80).aspx)
        # Ask the linker to generate the manifest in the temp dir, so
        # we can check it, and possibly embed it, later.
        temp_manifest = os.path.join(
                build_temp,
                os.path.basename(output_filename) + ".manifest")
        ld_args.append('/MANIFESTFILE:' + temp_manifest)

    def manifest_get_embed_info(self, target_desc, ld_args):
        # If a manifest should be embedded, return a tuple of
        # (manifest_filename, resource_id).  Returns None if no manifest
        # should be embedded.  See http://bugs.python.org/issue7833 for why
        # we want to avoid any manifest for extension modules if we can)
        for arg in ld_args:
            if arg.startswith("/MANIFESTFILE:"):
                temp_manifest = arg.split(":", 1)[1]
                break
        else:
            # no /MANIFESTFILE so nothing to do.
            return None
        if target_desc == CCompiler.EXECUTABLE:
            # by default, executables always get the manifest with the
            # CRT referenced.
            mfid = 1
        else:
            # Extension modules try and avoid any manifest if possible.
            mfid = 2
            temp_manifest = self._remove_visual_c_ref(temp_manifest)
        if temp_manifest is None:
            return None
        return temp_manifest, mfid

    def _remove_visual_c_ref(self, manifest_file):
        try:
            # Remove references to the Visual C runtime, so they will
            # fall through to the Visual C dependency of Python.exe.
            # This way, when installed for a restricted user (e.g.
            # runtimes are not in WinSxS folder, but in Python's own
            # folder), the runtimes do not need to be in every folder
            # with .pyd's.
            # Returns either the filename of the modified manifest or
            # None if no manifest should be embedded.
            manifest_f = open(manifest_file)
            try:
                manifest_buf = manifest_f.read()
            finally:
                manifest_f.close()
            pattern = re.compile(
                r"""<assemblyIdentity.*?name=("|')Microsoft\."""\
                r"""VC\d{2}\.CRT("|').*?(/>|</assemblyIdentity>)""",
                re.DOTALL)
            manifest_buf = re.sub(pattern, "", manifest_buf)
            pattern = "<dependentAssembly>\s*</dependentAssembly>"
            manifest_buf = re.sub(pattern, "", manifest_buf)
            # Now see if any other assemblies are referenced - if not, we
            # don't want a manifest embedded.
            pattern = re.compile(
                r"""<assemblyIdentity.*?name=(?:"|')(.+?)(?:"|')"""
                r""".*?(?:/>|</assemblyIdentity>)""", re.DOTALL)
            if re.search(pattern, manifest_buf) is None:
                return None

            manifest_f = open(manifest_file, 'w')
            try:
                manifest_f.write(manifest_buf)
                return manifest_file
            finally:
                manifest_f.close()
        except IOError:
            pass

    # -- Miscellaneous methods -----------------------------------------
    # These are all used by the 'gen_lib_options() function, in
    # ccompiler.py.

    def library_dir_option(self, dir):
        return "/LIBPATH:" + dir

    def runtime_library_dir_option(self, dir):
        raise DistutilsPlatformError(
              "don't know how to set runtime library search path for MSVC++")

    def library_option(self, lib):
        return self.library_filename(lib)


    def find_library_file(self, dirs, lib, debug=0):
        # Prefer a debugging library if found (and requested), but deal
        # with it if we don't have one.
        if debug:
            try_names = [lib + "_d", lib]
        else:
            try_names = [lib]
        for dir in dirs:
            for name in try_names:
                libfile = os.path.join(dir, self.library_filename (name))
                if os.path.exists(libfile):
                    return libfile
        else:
            # Oops, didn't find it in *any* of 'dirs'
            return None

    # Helper methods for using the MSVC registry settings

    def find_exe(self, exe):
        """Return path to an MSVC executable program.

        Tries to find the program in several places: first, one of the
        MSVC program search paths from the registry; next, the directories
        in the PATH environment variable.  If any of those work, return an
        absolute path that is known to exist.  If none of them work, just
        return the original program name, 'exe'.
        """
        for p in self.__paths:
            fn = os.path.join(os.path.abspath(p), exe)
            if os.path.isfile(fn):
                return fn

        # didn't find it; try existing path
        for p in os.environ['Path'].split(';'):
            fn = os.path.join(os.path.abspath(p),exe)
            if os.path.isfile(fn):
                return fn

        return exe
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Û
”´[c           @   sÚ  d  Z  d Z d d l Z d d l Z d d l Z d d l Z d d l m Z m Z m	 Z	 m
 Z
 m Z d d l m Z m Z d d l m Z d d l m Z d d l Z e j Z e j Z e j Z e j Z e j e j e j e j f Z  e j! d k oe j" d% k Z# e# r'd Z$ d Z% d Z& d Z' n d Z$ d Z% d Z& d Z' i d d 6d d 6d d 6Z( d d& d Ñ  É  YZ) d d' d Ñ  É  YZ* d Ñ  Z+ d Ñ  Z, d Ñ  Z- d Ñ  Z. d d  Ñ Z/ e+ É  Z0 e0 d! k  rÿe d" e0 É Ç n  d# e f d$ Ñ  É  YZ1 d S((   s  distutils.msvc9compiler

Contains MSVCCompiler, an implementation of the abstract CCompiler class
for the Microsoft Visual Studio 2008.

The module is compatible with VS 2005 and VS 2008. You can find legacy support
for older versions of VS in distutils.msvccompiler.
s   $Id$iˇˇˇˇN(   t   DistutilsExecErrort   DistutilsPlatformErrort   CompileErrort   LibErrort	   LinkError(   t	   CCompilert   gen_lib_options(   t   log(   t   get_platformt   win32i   i    s1   Software\Wow6432Node\Microsoft\VisualStudio\%0.1fs.   Software\Wow6432Node\Microsoft\VCExpress\%0.1fs5   Software\Wow6432Node\Microsoft\Microsoft SDKs\Windowss,   Software\Wow6432Node\Microsoft\.NETFrameworks%   Software\Microsoft\VisualStudio\%0.1fs"   Software\Microsoft\VCExpress\%0.1fs)   Software\Microsoft\Microsoft SDKs\Windowss    Software\Microsoft\.NETFrameworkt   x86t   amd64s	   win-amd64t   ia64s   win-ia64t   Regc           B   sb   e  Z d  Z d Ñ  Z e e É Z d Ñ  Z e e É Z d Ñ  Z e e É Z d Ñ  Z e e É Z RS(   s2   Helper class to read values from the registry
    c         C   sM   x: t  D]2 } |  j | | É } | r | | k r | | Sq Wt | É Ç d  S(   N(   t   HKEYSt   read_valuest   KeyError(   t   clst   patht   keyt   baset   d(    (    s-   /usr/lib/python2.7/distutils/msvc9compiler.pyt	   get_valueD   s
    c         C   sÑ   y t  | | É } Wn t k
 r' d SXg  } d } xI t r y t | | É } Wn t k
 rd Pn X| j | É | d 7} q7 W| S(   s   Return list of registry keys.i    i   N(   t   RegOpenKeyExt   RegErrort   Nonet   Truet
   RegEnumKeyt   append(   R   R   R   t   handlet   Lt   it   k(    (    s-   /usr/lib/python2.7/distutils/msvc9compiler.pyt	   read_keysL   s    	c   	      C   s®   y t  | | É } Wn t k
 r' d SXi  } d } xm t r£ y t | | É \ } } } Wn t k
 rm Pn X| j É  } |  j | É | |  j | É <| d 7} q7 W| S(   s`   Return dict of registry keys and values.

        All names are converted to lowercase.
        i    i   N(   R   R   R   R   t   RegEnumValuet   lowert   convert_mbcs(	   R   R   R   R   R   R   t   namet   valuet   type(    (    s-   /usr/lib/python2.7/distutils/msvc9compiler.pyR   ^   s    	c         C   sI   t  |  d d  É } | d  k	 rE y | d É }  WqE t k
 rA qE Xn  |  S(   Nt   decodet   mbcs(   t   getattrR   t   UnicodeError(   t   st   dec(    (    s-   /usr/lib/python2.7/distutils/msvc9compiler.pyR$   t   s    (	   t   __name__t
   __module__t   __doc__R   t   classmethodR!   R   R$   t   staticmethod(    (    (    s-   /usr/lib/python2.7/distutils/msvc9compiler.pyR   @   s   				t   MacroExpanderc           B   s,   e  Z d  Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   c         C   s'   i  |  _  t | |  _ |  j | É d  S(   N(   t   macrost   VS_BASEt   vsbaset   load_macros(   t   selft   version(    (    s-   /usr/lib/python2.7/distutils/msvc9compiler.pyt   __init__Ä   s    	c         C   s!   t  j | | É |  j d | <d  S(   Ns   $(%s)(   R   R   R4   (   R8   t   macroR   R   (    (    s-   /usr/lib/python2.7/distutils/msvc9compiler.pyt	   set_macroÖ   s    c         C   sR  |  j  d |  j d d É |  j  d |  j d d É |  j  d t d É y2 | d k rl |  j  d	 t d
 É n t d
 É Ç Wn t k
 rò t d É Ç n X| d k r— |  j  d |  j d É |  j  d t d É n} d } xt t D]l } y t | | É } Wn t k
 rqﬁ n Xt	 | d É } t
 j | d | | f É } | d |  j d <qﬁ Wd  S(   Nt   VCInstallDirs	   \Setup\VCt
   productdirt   VSInstallDirs	   \Setup\VSt   FrameworkDirt   installrootg       @t   FrameworkSDKDirs   sdkinstallrootv2.0s  Python was built with Visual Studio 2008;
extensions must be built with a compiler than can generate compatible binaries.
Visual Studio 2008 was not found on this system. If you have Cygwin installed,
you can try compiling with MingW32, by passing "-c mingw32" to setup.py.g      "@t   FrameworkVersions   clr versiont   WindowsSdkDirt   currentinstallfolders.   Software\Microsoft\NET Framework Setup\Producti    s   %s\%sR9   s   $(FrameworkVersion)(   R<   R6   t   NET_BASER   R   t   WINSDK_BASER   R   R   R   R   R   R4   (   R8   R9   t   pR   t   hR   R   (    (    s-   /usr/lib/python2.7/distutils/msvc9compiler.pyR7   à   s.    
c         C   s6   x/ |  j  j É  D] \ } } | j | | É } q W| S(   N(   R4   t   itemst   replace(   R8   R,   R    t   v(    (    s-   /usr/lib/python2.7/distutils/msvc9compiler.pyt   subß   s    (   R.   R/   R:   R<   R7   RM   (    (    (    s-   /usr/lib/python2.7/distutils/msvc9compiler.pyR3   ~   s   			c          C   sØ   d }  t  j j |  É } | d k r( d S| t |  É } t  j | j d d É \ } } t | d  É d } t | d d !É d	 } | d k ró d
 } n  | d k r´ | | Sd S(   s√   Return the version of MSVC that was used to build Python.

    For Python 2.3 and up, the version number is included in
    sys.version.  For earlier versions, assume the compiler is MSVC 6.
    s   MSC v.iˇˇˇˇi   t    i   i˛ˇˇˇi   i   g      $@i    N(   t   sysR9   t   findt   lent   splitt   intR   (   t   prefixR   R,   t   restt   majorVersiont   minorVersion(    (    s-   /usr/lib/python2.7/distutils/msvc9compiler.pyt   get_build_version¨   s    	c         C   sI   g  } x< |  D]4 } t  j j | É } | | k r | j | É q q W| S(   sn   Return a list of normalized paths with duplicates removed.

    The current order of paths is maintained.
    (   t   osR   t   normpathR   (   t   pathst   reduced_pathsRH   t   np(    (    s-   /usr/lib/python2.7/distutils/msvc9compiler.pyt   normalize_and_reduce_paths¬   s    c         C   s[   |  j  t j É } g  } x* | D]" } | | k r | j | É q q Wt j j | É } | S(   s8   Remove duplicate values of an environment variable.
    (   RR   RY   t   pathsepR   t   join(   t   variablet   oldListt   newListR   t   newVariable(    (    s-   /usr/lib/python2.7/distutils/msvc9compiler.pyt   removeDuplicates–   s    c         C   s≠  t  |  } y t j d | d É } Wn t k
 r= d } n X| d k rò t |  } y t j d | d É } Wqò t k
 rî d } t j d É qò Xn  | s≤ t j	 j
 | É rZd |  } t j j | d É } | rFt j	 j
 | É rFt j	 j | t j t j d É } t j	 j | É } t j	 j
 | É sWt j d | É d SqZt j d | É n  | sqt j d É d St j	 j | d	 É } t j	 j | É rú| St j d
 É d S(   s®   Find the vcvarsall.bat file

    At first it tries to find the productdir of VS 2008 in the registry. If
    that fails it falls back to the VS90COMNTOOLS env var.
    s   %s\Setup\VCR>   s%   Unable to find productdir in registrys   VS%0.f0COMNTOOLSt   VCs   %s is not a valid directorys    Env var %s is not set or invalids   No productdir founds   vcvarsall.bats   Unable to find vcvarsall.batN(   R5   R   R   R   R   t   VSEXPRESS_BASER   t   debugRY   R   t   isdirt   environt   getR`   t   pardirt   abspatht   isfile(   R9   R6   R>   t   toolskeyt   toolsdirt	   vcvarsall(    (    s-   /usr/lib/python2.7/distutils/msvc9compiler.pyt   find_vcvarsall€   s@    



!c         C   s   t  |  É } t d É } i  } | d k r9 t d É Ç n  t j d | |  É t j d | | f d t j d	 t j É} z¯ | j	 É  \ } } | j
 É  d
 k r∂ t | j d É É Ç n  | j d É } x¶ | j d É D]ï } t j | É } d | k r¸ q’ n  | j É  } | j d d É \ }	 }
 |	 j É  }	 |	 | k r’ |
 j t j É rW|
 d  }
 n  t |
 É | |	 <q’ q’ WWd | j j É  | j j É  Xt | É t | É k r∆t t t | j É  É É É Ç n  | S(   sD   Launch vcvarsall.bat and read the settings from its environment
    t   includet   libt   libpathR   s   Unable to find vcvarsall.bats'   Calling 'vcvarsall.bat %s' (version=%s)s   "%s" %s & sett   stdoutt   stderri    R)   s   
t   =i   iˇˇˇˇN(   Rs   Rt   Ru   R   (   Rr   t   setR   R   R   Rh   t
   subprocesst   Popent   PIPEt   communicatet   waitR(   RR   R   R$   t   stripR#   t   endswithRY   R_   Re   Rv   t   closeRw   RQ   t
   ValueErrort   strt   listt   keys(   R9   t   archRq   t   interestingt   resultt   popenRv   Rw   t   lineR   R&   (    (    s-   /usr/lib/python2.7/distutils/msvc9compiler.pyt   query_vcvarsall  s<    	!g       @s(   VC %0.1f is not supported by this modulet   MSVCCompilerc           B   sM  e  Z d  Z d Z i  Z d g Z d d d g Z d g Z d g Z e e e e Z	 d Z
 d	 Z d
 Z d Z d Z Z d Z d d d d Ñ Z d d Ñ Z d d d Ñ Z d d d d d d d d Ñ Z d d d d Ñ Z d d d d d d d d d d d Ñ
 Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d d Ñ Z d Ñ  Z RS(   sw   Concrete class that implements an interface to Microsoft Visual C++,
       as defined by the CCompiler abstract class.t   msvcs   .cs   .ccs   .cpps   .cxxs   .rcs   .mcs   .ress   .objs   .libs   .dlls   %s%ss   .exei    c         C   sP   t  j |  | | | É t |  _ d |  _ g  |  _ d  |  _ d  |  _ t	 |  _
 d  S(   Ns   Software\Microsoft\VisualStudio(   R   R:   t   VERSIONt   _MSVCCompiler__versiont   _MSVCCompiler__roott   _MSVCCompiler__pathsR   t	   plat_namet   _MSVCCompiler__archt   Falset   initialized(   R8   t   verboset   dry_runt   force(    (    s-   /usr/lib/python2.7/distutils/msvc9compiler.pyR:   S  s    					c         C   s+  |  j  s t d É Ç | d  k r. t É  } n  d% } | | k rV t d | f É Ç n  d t j k r≥ d t j k r≥ |  j d É r≥ d |  _ d	 |  _	 d
 |  _
 d |  _ d |  _ n+| t É  k sŒ | d k r€ t | } n t t É  d t | } t t | É } | d j d É j t j É |  _ | d j d É t j d <| d j d É t j d <t |  j É d k rÑt d |  j É Ç n  |  j d É |  _ |  j d	 É |  _	 |  j d
 É |  _
 |  j d É |  _ |  j d É |  _ y5 x. t j d j d É D] } |  j j | É q¯WWn t k
 r&n Xt |  j É |  _ d j |  j É t j d <d  |  _ |  j d k r†d d d d d g |  _ d d d d d d g |  _ n9 d d d d d d g |  _ d d d d d d d g |  _ d  d d! g |  _ |  j d" k rd  d d# d$ g |  _  n  d g |  _! t" |  _  d  S(&   Ns   don't init multiple timesR	   s	   win-amd64s   win-ia64s   --plat-name must be one of %st   DISTUTILS_USE_SDKt   MSSdks   cl.exes   link.exes   lib.exes   rc.exes   mc.exet   _R   R)   Rt   Rs   i    sx   Python was built with %s, and extensions need to be built with the same version of the compiler, but it isn't installed.t   ;R
   s   /nologos   /Oxs   /MDs   /W3s   /DNDEBUGs   /Ods   /MDds   /Z7s   /D_DEBUGs   /GS-s   /DLLs   /INCREMENTAL:NOi   s   /INCREMENTAL:nos   /DEBUG(   R	   s	   win-amd64s   win-ia64(#   Rï   t   AssertionErrorR   R   R   RY   Rj   t   find_exet   cct   linkerRt   t   rct   mct   PLAT_TO_VCVARSRã   Ré   t   encodeRR   R_   Rë   RQ   t   _MSVCCompiler__productR   R   R^   R`   t   preprocess_optionsRì   t   compile_optionst   compile_options_debugt   ldflags_sharedRè   t   ldflags_shared_debugt   ldflags_staticR   (   R8   Rí   t   ok_platst	   plat_spect   vc_envRH   (    (    s-   /usr/lib/python2.7/distutils/msvc9compiler.pyt
   initialize^  sf    -				"	t    c         C   s>  | d  k r d } n  g  } x| D]} t j j | É \ } } t j j | É d } | t j j | É } | |  j k ré t d | É Ç n  | r© t j j | É } n  | |  j	 k rﬁ | j
 t j j | | |  j É É q" | |  j k r| j
 t j j | | |  j É É q" | j
 t j j | | |  j É É q" W| S(   NR∞   i   s   Don't know how to compile %s(   R   RY   R   t   splitextt
   splitdrivet   isabst   src_extensionsR   t   basenamet   _rc_extensionsR   R`   t   res_extensiont   _mc_extensionst   obj_extension(   R8   t   source_filenamest	   strip_dirt
   output_dirt	   obj_namest   src_nameR   t   ext(    (    s-   /usr/lib/python2.7/distutils/msvc9compiler.pyt   object_filenamesµ  s(     	c	         C   sË  |  j  s |  j É  n  |  j | | | | | | É }	 |	 \ } }
 } } } | pR g  } | j d É | r{ | j |  j É n | j |  j É xV|
 D]N} y | | \ } } Wn t k
 r¬ qí n X| rﬁ t j	 j
 | É } n  | |  j k r˙ d | } nç| |  j k rd | } nq| |  j k rÜ| } d | } y) |  j |  j g | | g | g É Wqí t k
 r} t | É Ç qí Xqí n| |  j k rqt j	 j | É } t j	 j | É } yê |  j |  j g d | d | g | g É t j	 j t j	 j | É É \ } } t j	 j | | d É } |  j |  j g d | g | g É Wqí t k
 rj} t | É Ç qí Xqí n t d | | f É Ç d	 | } y- |  j |  j g | | | | g | É Wqí t k
 rﬂ} t | É Ç qí Xqí W|
 S(
   Ns   /cs   /Tcs   /Tps   /fos   -hs   -rs   .rcs"   Don't know how to compile %s to %ss   /Fo(   Rï   RØ   t   _setup_compileR   t   extendR®   Rß   R   RY   R   Rm   t   _c_extensionst   _cpp_extensionsR∂   t   spawnR°   R    R   R∏   t   dirnameR¢   R±   Rµ   R`   Rü   (   R8   t   sourcesRº   R4   t   include_dirsRh   t   extra_preargst   extra_postargst   dependst   compile_infot   objectst   pp_optst   buildt   compile_optst   objt   srcRø   t	   input_optt
   output_optt   msgt   h_dirt   rc_dirR   Rõ   t   rc_file(    (    s-   /usr/lib/python2.7/distutils/msvc9compiler.pyt   compile‘  sj    	
#$$#
c   	      C   s√   |  j  s |  j É  n  |  j | | É \ } } |  j | d | É} |  j | | É rØ | d | g } | ro n  y |  j |  j g | É Wqø t k
 r´ } t | É Ç qø Xn t	 j
 d | É d  S(   NRº   s   /OUT:s   skipping %s (up-to-date)(   Rï   RØ   t   _fix_object_argst   library_filenamet
   _need_linkR≈   Rt   R    R   R   Rh   (	   R8   RÕ   t   output_libnameRº   Rh   t   target_langt   output_filenamet   lib_argsR’   (    (    s-   /usr/lib/python2.7/distutils/msvc9compiler.pyt   create_static_lib)  s    		c         C   s¯  |  j  s |  j É  n  |  j | | É \ } } |  j | | | É } | \ } } } | rr |  j d t | É É n  t |  | | | É } | d  k	 r´ t j	 j
 | | É } n  |  j | | É r‰| t j k rÚ |	 r‚ |  j d } q|  j d } n |	 r|  j } n	 |  j } g  } x% | pg  D] } | j d | É q W| | | | d | g } t j	 j | d É } | d  k	 r–t j	 j t j	 j | É É \ } } t j	 j
 | |  j | É É } | j d | É n  |  j | | | É |
 rˆ|
 | d *n  | r| j | É n  |  j t j	 j | É É y |  j |  j g | É Wn t k
 ra} t | É Ç n X|  j | | É } | d  k	 rÙ| \ } } d | | f } y  |  j d d	 d
 | | g É Wq·t k
 r›} t | É Ç q·XqÙn t j d | É d  S(   Ns5   I don't know what to do with 'runtime_library_dirs': i   s   /EXPORT:s   /OUT:i    s   /IMPLIB:s   -outputresource:%s;%ss   mt.exes   -nologos	   -manifests   skipping %s (up-to-date)(   Rï   RØ   R⁄   t   _fix_lib_argst   warnRÉ   R   R   RY   R   R`   R‹   R   t
   EXECUTABLER™   R©   R   R∆   R±   Rµ   R€   t   manifest_setup_ldargsR¬   t   mkpathR≈   R†   R    R   t   manifest_get_embed_infoR   Rh   (   R8   t   target_descRÕ   Rﬂ   Rº   t	   librariest   library_dirst   runtime_library_dirst   export_symbolsRh   R…   R    t
   build_tempRﬁ   t
   fixed_argst   lib_optst   ldflagst   export_optst   symt   ld_argst   dll_namet   dll_extt   implib_fileR’   t   mfinfot
   mffilenamet   mfidt   out_arg(    (    s-   /usr/lib/python2.7/distutils/msvc9compiler.pyt   linkB  sl    							c         C   s:   t  j j | t  j j | É d É } | j d | É d  S(   Ns	   .manifests   /MANIFESTFILE:(   RY   R   R`   Rµ   R   (   R8   Rﬂ   RÌ   RÛ   t   temp_manifest(    (    s-   /usr/lib/python2.7/distutils/msvc9compiler.pyRÂ   °  s    	c         C   sÖ   x; | D]/ } | j  d É r | j d d É d } Pq q Wd  S| t j k rV d } n d } |  j | É } | d  k r{ d  S| | f S(   Ns   /MANIFESTFILE:t   :i   i   (   t
   startswithRR   R   R   R‰   t   _remove_visual_c_ref(   R8   RË   RÛ   t   argR¸   R˘   (    (    s-   /usr/lib/python2.7/distutils/msvc9compiler.pyRÁ   ≠  s    	c         C   sÓ   y÷ t  | É } z | j É  } Wd  | j É  Xt j d t j É } t j | d | É } d } t j | d | É } t j d t j É } t j | | É d  k r£ d  St  | d É } z | j	 | É | SWd  | j É  XWn t
 k
 rÈ n Xd  S(   NsU   <assemblyIdentity.*?name=("|')Microsoft\.VC\d{2}\.CRT("|').*?(/>|</assemblyIdentity>)R∞   s*   <dependentAssembly>\s*</dependentAssembly>sI   <assemblyIdentity.*?name=(?:"|')(.+?)(?:"|').*?(?:/>|</assemblyIdentity>)t   w(   t   opent   readRÅ   t   reRŸ   t   DOTALLRM   t   searchR   t   writet   IOError(   R8   t   manifest_filet
   manifest_ft   manifest_buft   pattern(    (    s-   /usr/lib/python2.7/distutils/msvc9compiler.pyRˇ   ≈  s.    	c         C   s   d | S(   Ns	   /LIBPATH:(    (   R8   t   dir(    (    s-   /usr/lib/python2.7/distutils/msvc9compiler.pyt   library_dir_option  s    c         C   s   t  d É Ç d  S(   Ns<   don't know how to set runtime library search path for MSVC++(   R   (   R8   R  (    (    s-   /usr/lib/python2.7/distutils/msvc9compiler.pyt   runtime_library_dir_optionÛ  s    c         C   s   |  j  | É S(   N(   R€   (   R8   Rt   (    (    s-   /usr/lib/python2.7/distutils/msvc9compiler.pyt   library_option˜  s    c         C   sÄ   | r | d | g } n	 | g } xW | D]K } xB | D]: } t  j j | |  j | É É } t  j j | É r6 | Sq6 Wq) Wd  Sd  S(   Nt   _d(   RY   R   R`   R€   t   existsR   (   R8   t   dirsRt   Rh   t	   try_namesR  R%   t   libfile(    (    s-   /usr/lib/python2.7/distutils/msvc9compiler.pyt   find_library_file˚  s    	c         C   sß   xH |  j  D]= } t j j t j j | É | É } t j j | É r
 | Sq
 WxU t j d j d É D]= } t j j t j j | É | É } t j j | É rb | Sqb W| S(   så  Return path to an MSVC executable program.

        Tries to find the program in several places: first, one of the
        MSVC program search paths from the registry; next, the directories
        in the PATH environment variable.  If any of those work, return an
        absolute path that is known to exist.  If none of them work, just
        return the original program name, 'exe'.
        t   PathRú   (   Rë   RY   R   R`   Rm   Rn   Rj   RR   (   R8   t   exeRH   t   fn(    (    s-   /usr/lib/python2.7/distutils/msvc9compiler.pyRû     s    	!!N(    R.   R/   R0   t   compiler_typet   executablesR√   Rƒ   R∂   R∏   R¥   R∑   Rπ   t   static_lib_extensiont   shared_lib_extensiont   static_lib_formatt   shared_lib_formatt   exe_extensionR:   R   RØ   R¿   RŸ   R·   R˚   RÂ   RÁ   Rˇ   R  R  R  R  Rû   (    (    (    s-   /usr/lib/python2.7/distutils/msvc9compiler.pyRå   5  sR   			
YVR			+			l        (    (    (2   R0   t   __revision__RY   Rz   RO   R  t   distutils.errorsR    R   R   R   R   t   distutils.ccompilerR   R   t	   distutilsR   t   distutils.utilR   t   _winregt	   OpenKeyExR   t   EnumKeyR   t	   EnumValueR"   t   errorR   t
   HKEY_USERSt   HKEY_CURRENT_USERt   HKEY_LOCAL_MACHINEt   HKEY_CLASSES_ROOTR   t   platformt   maxsizet   NATIVE_WIN64R5   Rg   RG   RF   R£   R   R3   RX   R^   Re   Rr   Rã   Ré   Rå   (    (    (    s-   /usr/lib/python2.7/distutils/msvc9compiler.pyt   <module>   sV   (					
>.				,)	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   """distutils.msvccompiler

Contains MSVCCompiler, an implementation of the abstract CCompiler class
for the Microsoft Visual Studio.
"""

# Written by Perry Stoll
# hacked by Robin Becker and Thomas Heller to do a better job of
#   finding DevStudio (through the registry)

__revision__ = "$Id$"

import sys
import os
import string

from distutils.errors import (DistutilsExecError, DistutilsPlatformError,
                              CompileError, LibError, LinkError)
from distutils.ccompiler import CCompiler, gen_lib_options
from distutils import log

_can_read_reg = 0
try:
    import _winreg

    _can_read_reg = 1
    hkey_mod = _winreg

    RegOpenKeyEx = _winreg.OpenKeyEx
    RegEnumKey = _winreg.EnumKey
    RegEnumValue = _winreg.EnumValue
    RegError = _winreg.error

except ImportError:
    try:
        import win32api
        import win32con
        _can_read_reg = 1
        hkey_mod = win32con

        RegOpenKeyEx = win32api.RegOpenKeyEx
        RegEnumKey = win32api.RegEnumKey
        RegEnumValue = win32api.RegEnumValue
        RegError = win32api.error

    except ImportError:
        log.info("Warning: Can't read registry to find the "
                 "necessary compiler setting\n"
                 "Make sure that Python modules _winreg, "
                 "win32api or win32con are installed.")
        pass

if _can_read_reg:
    HKEYS = (hkey_mod.HKEY_USERS,
             hkey_mod.HKEY_CURRENT_USER,
             hkey_mod.HKEY_LOCAL_MACHINE,
             hkey_mod.HKEY_CLASSES_ROOT)

def read_keys(base, key):
    """Return list of registry keys."""

    try:
        handle = RegOpenKeyEx(base, key)
    except RegError:
        return None
    L = []
    i = 0
    while 1:
        try:
            k = RegEnumKey(handle, i)
        except RegError:
            break
        L.append(k)
        i = i + 1
    return L

def read_values(base, key):
    """Return dict of registry keys and values.

    All names are converted to lowercase.
    """
    try:
        handle = RegOpenKeyEx(base, key)
    except RegError:
        return None
    d = {}
    i = 0
    while 1:
        try:
            name, value, type = RegEnumValue(handle, i)
        except RegError:
            break
        name = name.lower()
        d[convert_mbcs(name)] = convert_mbcs(value)
        i = i + 1
    return d

def convert_mbcs(s):
    enc = getattr(s, "encode", None)
    if enc is not None:
        try:
            s = enc("mbcs")
        except UnicodeError:
            pass
    return s

class MacroExpander:

    def __init__(self, version):
        self.macros = {}
        self.load_macros(version)

    def set_macro(self, macro, path, key):
        for base in HKEYS:
            d = read_values(base, path)
            if d:
                self.macros["$(%s)" % macro] = d[key]
                break

    def load_macros(self, version):
        vsbase = r"Software\Microsoft\VisualStudio\%0.1f" % version
        self.set_macro("VCInstallDir", vsbase + r"\Setup\VC", "productdir")
        self.set_macro("VSInstallDir", vsbase + r"\Setup\VS", "productdir")
        net = r"Software\Microsoft\.NETFramework"
        self.set_macro("FrameworkDir", net, "installroot")
        try:
            if version > 7.0:
                self.set_macro("FrameworkSDKDir", net, "sdkinstallrootv1.1")
            else:
                self.set_macro("FrameworkSDKDir", net, "sdkinstallroot")
        except KeyError:
            raise DistutilsPlatformError, \
                  ("""Python was built with Visual Studio 2003;
extensions must be built with a compiler than can generate compatible binaries.
Visual Studio 2003 was not found on this system. If you have Cygwin installed,
you can try compiling with MingW32, by passing "-c mingw32" to setup.py.""")

        p = r"Software\Microsoft\NET Framework Setup\Product"
        for base in HKEYS:
            try:
                h = RegOpenKeyEx(base, p)
            except RegError:
                continue
            key = RegEnumKey(h, 0)
            d = read_values(base, r"%s\%s" % (p, key))
            self.macros["$(FrameworkVersion)"] = d["version"]

    def sub(self, s):
        for k, v in self.macros.items():
            s = string.replace(s, k, v)
        return s

def get_build_version():
    """Return the version of MSVC that was used to build Python.

    For Python 2.3 and up, the version number is included in
    sys.version.  For earlier versions, assume the compiler is MSVC 6.
    """

    prefix = "MSC v."
    i = string.find(sys.version, prefix)
    if i == -1:
        return 6
    i = i + len(prefix)
    s, rest = sys.version[i:].split(" ", 1)
    majorVersion = int(s[:-2]) - 6
    minorVersion = int(s[2:3]) / 10.0
    # I don't think paths are affected by minor version in version 6
    if majorVersion == 6:
        minorVersion = 0
    if majorVersion >= 6:
        return majorVersion + minorVersion
    # else we don't know what version of the compiler this is
    return None

def get_build_architecture():
    """Return the processor architecture.

    Possible results are "Intel", "Itanium", or "AMD64".
    """

    prefix = " bit ("
    i = string.find(sys.version, prefix)
    if i == -1:
        return "Intel"
    j = string.find(sys.version, ")", i)
    return sys.version[i+len(prefix):j]

def normalize_and_reduce_paths(paths):
    """Return a list of normalized paths with duplicates removed.

    The current order of paths is maintained.
    """
    # Paths are normalized so things like:  /a and /a/ aren't both preserved.
    reduced_paths = []
    for p in paths:
        np = os.path.normpath(p)
        # XXX(nnorwitz): O(n**2), if reduced_paths gets long perhaps use a set.
        if np not in reduced_paths:
            reduced_paths.append(np)
    return reduced_paths


class MSVCCompiler (CCompiler) :
    """Concrete class that implements an interface to Microsoft Visual C++,
       as defined by the CCompiler abstract class."""

    compiler_type = 'msvc'

    # Just set this so CCompiler's constructor doesn't barf.  We currently
    # don't use the 'set_executables()' bureaucracy provided by CCompiler,
    # as it really isn't necessary for this sort of single-compiler class.
    # Would be nice to have a consistent interface with UnixCCompiler,
    # though, so it's worth thinking about.
    executables = {}

    # Private class data (need to distinguish C from C++ source for compiler)
    _c_extensions = ['.c']
    _cpp_extensions = ['.cc', '.cpp', '.cxx']
    _rc_extensions = ['.rc']
    _mc_extensions = ['.mc']

    # Needed for the filename generation methods provided by the
    # base class, CCompiler.
    src_extensions = (_c_extensions + _cpp_extensions +
                      _rc_extensions + _mc_extensions)
    res_extension = '.res'
    obj_extension = '.obj'
    static_lib_extension = '.lib'
    shared_lib_extension = '.dll'
    static_lib_format = shared_lib_format = '%s%s'
    exe_extension = '.exe'

    def __init__ (self, verbose=0, dry_run=0, force=0):
        CCompiler.__init__ (self, verbose, dry_run, force)
        self.__version = get_build_version()
        self.__arch = get_build_architecture()
        if self.__arch == "Intel":
            # x86
            if self.__version >= 7:
                self.__root = r"Software\Microsoft\VisualStudio"
                self.__macros = MacroExpander(self.__version)
            else:
                self.__root = r"Software\Microsoft\Devstudio"
            self.__product = "Visual Studio version %s" % self.__version
        else:
            # Win64. Assume this was built with the platform SDK
            self.__product = "Microsoft SDK compiler %s" % (self.__version + 6)

        self.initialized = False

    def initialize(self):
        self.__paths = []
        if "DISTUTILS_USE_SDK" in os.environ and "MSSdk" in os.environ and self.find_exe("cl.exe"):
            # Assume that the SDK set up everything alright; don't try to be
            # smarter
            self.cc = "cl.exe"
            self.linker = "link.exe"
            self.lib = "lib.exe"
            self.rc = "rc.exe"
            self.mc = "mc.exe"
        else:
            self.__paths = self.get_msvc_paths("path")

            if len (self.__paths) == 0:
                raise DistutilsPlatformError, \
                      ("Python was built with %s, "
                       "and extensions need to be built with the same "
                       "version of the compiler, but it isn't installed." % self.__product)

            self.cc = self.find_exe("cl.exe")
            self.linker = self.find_exe("link.exe")
            self.lib = self.find_exe("lib.exe")
            self.rc = self.find_exe("rc.exe")   # resource compiler
            self.mc = self.find_exe("mc.exe")   # message compiler
            self.set_path_env_var('lib')
            self.set_path_env_var('include')

        # extend the MSVC path with the current path
        try:
            for p in string.split(os.environ['path'], ';'):
                self.__paths.append(p)
        except KeyError:
            pass
        self.__paths = normalize_and_reduce_paths(self.__paths)
        os.environ['path'] = string.join(self.__paths, ';')

        self.preprocess_options = None
        if self.__arch == "Intel":
            self.compile_options = [ '/nologo', '/Ox', '/MD', '/W3', '/GX' ,
                                     '/DNDEBUG']
            self.compile_options_debug = ['/nologo', '/Od', '/MDd', '/W3', '/GX',
                                          '/Z7', '/D_DEBUG']
        else:
            # Win64
            self.compile_options = [ '/nologo', '/Ox', '/MD', '/W3', '/GS-' ,
                                     '/DNDEBUG']
            self.compile_options_debug = ['/nologo', '/Od', '/MDd', '/W3', '/GS-',
                                          '/Z7', '/D_DEBUG']

        self.ldflags_shared = ['/DLL', '/nologo', '/INCREMENTAL:NO']
        if self.__version >= 7:
            self.ldflags_shared_debug = [
                '/DLL', '/nologo', '/INCREMENTAL:no', '/DEBUG'
                ]
        else:
            self.ldflags_shared_debug = [
                '/DLL', '/nologo', '/INCREMENTAL:no', '/pdb:None', '/DEBUG'
                ]
        self.ldflags_static = [ '/nologo']

        self.initialized = True

    # -- Worker methods ------------------------------------------------

    def object_filenames (self,
                          source_filenames,
                          strip_dir=0,
                          output_dir=''):
        # Copied from ccompiler.py, extended to return .res as 'object'-file
        # for .rc input file
        if output_dir is None: output_dir = ''
        obj_names = []
        for src_name in source_filenames:
            (base, ext) = os.path.splitext (src_name)
            base = os.path.splitdrive(base)[1] # Chop off the drive
            base = base[os.path.isabs(base):]  # If abs, chop off leading /
            if ext not in self.src_extensions:
                # Better to raise an exception instead of silently continuing
                # and later complain about sources and targets having
                # different lengths
                raise CompileError ("Don't know how to compile %s" % src_name)
            if strip_dir:
                base = os.path.basename (base)
            if ext in self._rc_extensions:
                obj_names.append (os.path.join (output_dir,
                                                base + self.res_extension))
            elif ext in self._mc_extensions:
                obj_names.append (os.path.join (output_dir,
                                                base + self.res_extension))
            else:
                obj_names.append (os.path.join (output_dir,
                                                base + self.obj_extension))
        return obj_names

    # object_filenames ()


    def compile(self, sources,
                output_dir=None, macros=None, include_dirs=None, debug=0,
                extra_preargs=None, extra_postargs=None, depends=None):

        if not self.initialized: self.initialize()
        macros, objects, extra_postargs, pp_opts, build = \
                self._setup_compile(output_dir, macros, include_dirs, sources,
                                    depends, extra_postargs)

        compile_opts = extra_preargs or []
        compile_opts.append ('/c')
        if debug:
            compile_opts.extend(self.compile_options_debug)
        else:
            compile_opts.extend(self.compile_options)

        for obj in objects:
            try:
                src, ext = build[obj]
            except KeyError:
                continue
            if debug:
                # pass the full pathname to MSVC in debug mode,
                # this allows the debugger to find the source file
                # without asking the user to browse for it
                src = os.path.abspath(src)

            if ext in self._c_extensions:
                input_opt = "/Tc" + src
            elif ext in self._cpp_extensions:
                input_opt = "/Tp" + src
            elif ext in self._rc_extensions:
                # compile .RC to .RES file
                input_opt = src
                output_opt = "/fo" + obj
                try:
                    self.spawn ([self.rc] + pp_opts +
                                [output_opt] + [input_opt])
                except DistutilsExecError, msg:
                    raise CompileError, msg
                continue
            elif ext in self._mc_extensions:

                # Compile .MC to .RC file to .RES file.
                #   * '-h dir' specifies the directory for the
                #     generated include file
                #   * '-r dir' specifies the target directory of the
                #     generated RC file and the binary message resource
                #     it includes
                #
                # For now (since there are no options to change this),
                # we use the source-directory for the include file and
                # the build directory for the RC file and message
                # resources. This works at least for win32all.

                h_dir = os.path.dirname (src)
                rc_dir = os.path.dirname (obj)
                try:
                    # first compile .MC to .RC and .H file
                    self.spawn ([self.mc] +
                                ['-h', h_dir, '-r', rc_dir] + [src])
                    base, _ = os.path.splitext (os.path.basename (src))
                    rc_file = os.path.join (rc_dir, base + '.rc')
                    # then compile .RC to .RES file
                    self.spawn ([self.rc] +
                                ["/fo" + obj] + [rc_file])

                except DistutilsExecError, msg:
                    raise CompileError, msg
                continue
            else:
                # how to handle this file?
                raise CompileError (
                    "Don't know how to compile %s to %s" % \
                    (src, obj))

            output_opt = "/Fo" + obj
            try:
                self.spawn ([self.cc] + compile_opts + pp_opts +
                            [input_opt, output_opt] +
                            extra_postargs)
            except DistutilsExecError, msg:
                raise CompileError, msg

        return objects

    # compile ()


    def create_static_lib (self,
                           objects,
                           output_libname,
                           output_dir=None,
                           debug=0,
                           target_lang=None):

        if not self.initialized: self.initialize()
        (objects, output_dir) = self._fix_object_args (objects, output_dir)
        output_filename = \
            self.library_filename (output_libname, output_dir=output_dir)

        if self._need_link (objects, output_filename):
            lib_args = objects + ['/OUT:' + output_filename]
            if debug:
                pass                    # XXX what goes here?
            try:
                self.spawn ([self.lib] + lib_args)
            except DistutilsExecError, msg:
                raise LibError, msg

        else:
            log.debug("skipping %s (up-to-date)", output_filename)

    # create_static_lib ()

    def link (self,
              target_desc,
              objects,
              output_filename,
              output_dir=None,
              libraries=None,
              library_dirs=None,
              runtime_library_dirs=None,
              export_symbols=None,
              debug=0,
              extra_preargs=None,
              extra_postargs=None,
              build_temp=None,
              target_lang=None):

        if not self.initialized: self.initialize()
        (objects, output_dir) = self._fix_object_args (objects, output_dir)
        (libraries, library_dirs, runtime_library_dirs) = \
            self._fix_lib_args (libraries, library_dirs, runtime_library_dirs)

        if runtime_library_dirs:
            self.warn ("I don't know what to do with 'runtime_library_dirs': "
                       + str (runtime_library_dirs))

        lib_opts = gen_lib_options (self,
                                    library_dirs, runtime_library_dirs,
                                    libraries)
        if output_dir is not None:
            output_filename = os.path.join (output_dir, output_filename)

        if self._need_link (objects, output_filename):

            if target_desc == CCompiler.EXECUTABLE:
                if debug:
                    ldflags = self.ldflags_shared_debug[1:]
                else:
                    ldflags = self.ldflags_shared[1:]
            else:
                if debug:
                    ldflags = self.ldflags_shared_debug
                else:
                    ldflags = self.ldflags_shared

            export_opts = []
            for sym in (export_symbols or []):
                export_opts.append("/EXPORT:" + sym)

            ld_args = (ldflags + lib_opts + export_opts +
                       objects + ['/OUT:' + output_filename])

            # The MSVC linker generates .lib and .exp files, which cannot be
            # suppressed by any linker switches. The .lib files may even be
            # needed! Make sure they are generated in the temporary build
            # directory. Since they have different names for debug and release
            # builds, they can go into the same directory.
            if export_symbols is not None:
                (dll_name, dll_ext) = os.path.splitext(
                    os.path.basename(output_filename))
                implib_file = os.path.join(
                    os.path.dirname(objects[0]),
                    self.library_filename(dll_name))
                ld_args.append ('/IMPLIB:' + implib_file)

            if extra_preargs:
                ld_args[:0] = extra_preargs
            if extra_postargs:
                ld_args.extend(extra_postargs)

            self.mkpath (os.path.dirname (output_filename))
            try:
                self.spawn ([self.linker] + ld_args)
            except DistutilsExecError, msg:
                raise LinkError, msg

        else:
            log.debug("skipping %s (up-to-date)", output_filename)

    # link ()


    # -- Miscellaneous methods -----------------------------------------
    # These are all used by the 'gen_lib_options() function, in
    # ccompiler.py.

    def library_dir_option (self, dir):
        return "/LIBPATH:" + dir

    def runtime_library_dir_option (self, dir):
        raise DistutilsPlatformError, \
              "don't know how to set runtime library search path for MSVC++"

    def library_option (self, lib):
        return self.library_filename (lib)


    def find_library_file (self, dirs, lib, debug=0):
        # Prefer a debugging library if found (and requested), but deal
        # with it if we don't have one.
        if debug:
            try_names = [lib + "_d", lib]
        else:
            try_names = [lib]
        for dir in dirs:
            for name in try_names:
                libfile = os.path.join(dir, self.library_filename (name))
                if os.path.exists(libfile):
                    return libfile
        else:
            # Oops, didn't find it in *any* of 'dirs'
            return None

    # find_library_file ()

    # Helper methods for using the MSVC registry settings

    def find_exe(self, exe):
        """Return path to an MSVC executable program.

        Tries to find the program in several places: first, one of the
        MSVC program search paths from the registry; next, the directories
        in the PATH environment variable.  If any of those work, return an
        absolute path that is known to exist.  If none of them work, just
        return the original program name, 'exe'.
        """

        for p in self.__paths:
            fn = os.path.join(os.path.abspath(p), exe)
            if os.path.isfile(fn):
                return fn

        # didn't find it; try existing path
        for p in string.split(os.environ['Path'],';'):
            fn = os.path.join(os.path.abspath(p),exe)
            if os.path.isfile(fn):
                return fn

        return exe

    def get_msvc_paths(self, path, platform='x86'):
        """Get a list of devstudio directories (include, lib or path).

        Return a list of strings.  The list will be empty if unable to
        access the registry or appropriate registry keys not found.
        """

        if not _can_read_reg:
            return []

        path = path + " dirs"
        if self.__version >= 7:
            key = (r"%s\%0.1f\VC\VC_OBJECTS_PLATFORM_INFO\Win32\Directories"
                   % (self.__root, self.__version))
        else:
            key = (r"%s\6.0\Build System\Components\Platforms"
                   r"\Win32 (%s)\Directories" % (self.__root, platform))

        for base in HKEYS:
            d = read_values(base, key)
            if d:
                if self.__version >= 7:
                    return string.split(self.__macros.sub(d[path]), ";")
                else:
                    return string.split(d[path], ";")
        # MSVC 6 seems to create the registry entries we need only when
        # the GUI is run.
        if self.__version == 6:
            for base in HKEYS:
                if read_values(base, r"%s\6.0" % self.__root) is not None:
                    self.warn("It seems you have Visual Studio 6 installed, "
                        "but the expected registry settings are not present.\n"
                        "You must at least run the Visual Studio GUI once "
                        "so that these entries are created.")
                    break
        return []

    def set_path_env_var(self, name):
        """Set environment variable 'name' to an MSVC path type value.

        This is equivalent to a SET command prior to execution of spawned
        commands.
        """

        if name == "lib":
            p = self.get_msvc_paths("library")
        else:
            p = self.get_msvc_paths(name)
        if p:
            os.environ[name] = string.join(p, ';')


if get_build_version() >= 8.0:
    log.debug("Importing new compiler from distutils.msvc9compiler")
    OldMSVCCompiler = MSVCCompiler
    from distutils.msvc9compiler import MSVCCompiler
    # get_build_architecture not really relevant now we support cross-compile
    from distutils.msvc9compiler import MacroExpander
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Û
”´[c           @   s  d  Z  d Z d d l Z d d l Z d d l Z d d l m Z m Z m Z m	 Z	 m
 Z
 d d l m Z m Z d d l m Z d Z y@ d d l Z d Z e Z e j Z e j Z e j Z e j Z Wn~ e k
 rDyL d d l Z d d l Z d Z e Z e j Z e j Z e j Z e j Z Wn e k
 r@e j d	 É n Xn Xe rle j e j  e j! e j" f Z# n  d
 Ñ  Z$ d Ñ  Z% d Ñ  Z& d f  d Ñ  É  YZ' d Ñ  Z( d Ñ  Z) d Ñ  Z* d e f d Ñ  É  YZ+ e( É  d k re j, d É e+ Z- d d l. m+ Z+ d d l. m' Z' n  d S(   sÇ   distutils.msvccompiler

Contains MSVCCompiler, an implementation of the abstract CCompiler class
for the Microsoft Visual Studio.
s   $Id$iˇˇˇˇN(   t   DistutilsExecErrort   DistutilsPlatformErrort   CompileErrort   LibErrort	   LinkError(   t	   CCompilert   gen_lib_options(   t   logi    i   sé   Warning: Can't read registry to find the necessary compiler setting
Make sure that Python modules _winreg, win32api or win32con are installed.c         C   s~   y t  |  | É } Wn t k
 r' d SXg  } d } xC y t | | É } Wn t k
 r^ Pn X| j | É | d } q7 W| S(   s   Return list of registry keys.i    i   N(   t   RegOpenKeyExt   RegErrort   Nonet
   RegEnumKeyt   append(   t   baset   keyt   handlet   Lt   it   k(    (    s,   /usr/lib/python2.7/distutils/msvccompiler.pyt	   read_keys;   s    c         C   sú   y t  |  | É } Wn t k
 r' d SXi  } d } xa y t | | É \ } } } Wn t k
 rg Pn X| j É  } t | É | t | É <| d } q7 W| S(   sX   Return dict of registry keys and values.

    All names are converted to lowercase.
    i    i   N(   R   R	   R
   t   RegEnumValuet   lowert   convert_mbcs(   R   R   R   t   dR   t   namet   valuet   type(    (    s,   /usr/lib/python2.7/distutils/msvccompiler.pyt   read_valuesM   s    c         C   sI   t  |  d d  É } | d  k	 rE y | d É }  WqE t k
 rA qE Xn  |  S(   Nt   encodet   mbcs(   t   getattrR
   t   UnicodeError(   t   st   enc(    (    s,   /usr/lib/python2.7/distutils/msvccompiler.pyR   b   s    t   MacroExpanderc           B   s,   e  Z d  Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   c         C   s   i  |  _  |  j | É d  S(   N(   t   macrost   load_macros(   t   selft   version(    (    s,   /usr/lib/python2.7/distutils/msvccompiler.pyt   __init__m   s    	c         C   sC   x< t  D]4 } t | | É } | r | | |  j d | <Pq q Wd  S(   Ns   $(%s)(   t   HKEYSR   R#   (   R%   t   macrot   pathR   R   R   (    (    s,   /usr/lib/python2.7/distutils/msvccompiler.pyt	   set_macroq   s
    c   	      C   s%  d | } |  j  d | d d É |  j  d | d d É d } |  j  d | d	 É y9 | d
 k rv |  j  d | d É n |  j  d | d É Wn t k
 r¶ t d Ç n Xd } xq t D]i } y t | | É } Wn t k
 r„ q¥ n Xt | d É } t | d | | f É } | d |  j d <q¥ Wd  S(   Ns%   Software\Microsoft\VisualStudio\%0.1ft   VCInstallDirs	   \Setup\VCt
   productdirt   VSInstallDirs	   \Setup\VSs    Software\Microsoft\.NETFrameworkt   FrameworkDirt   installrootg      @t   FrameworkSDKDirs   sdkinstallrootv1.1t   sdkinstallroots  Python was built with Visual Studio 2003;
extensions must be built with a compiler than can generate compatible binaries.
Visual Studio 2003 was not found on this system. If you have Cygwin installed,
you can try compiling with MingW32, by passing "-c mingw32" to setup.py.s.   Software\Microsoft\NET Framework Setup\Producti    s   %s\%sR&   s   $(FrameworkVersion)(	   R+   t   KeyErrorR   R(   R   R	   R   R   R#   (	   R%   R&   t   vsbaset   nett   pR   t   hR   R   (    (    s,   /usr/lib/python2.7/distutils/msvccompiler.pyR$   x   s*    

c         C   s9   x2 |  j  j É  D]! \ } } t j | | | É } q W| S(   N(   R#   t   itemst   stringt   replace(   R%   R    R   t   v(    (    s,   /usr/lib/python2.7/distutils/msvccompiler.pyt   subî   s    (   t   __name__t
   __module__R'   R+   R$   R<   (    (    (    s,   /usr/lib/python2.7/distutils/msvccompiler.pyR"   k   s   			c          C   s≤   d }  t  j t j |  É } | d k r+ d S| t |  É } t j | j d d É \ } } t | d  É d } t | d d !É d	 } | d k rö d
 } n  | d k rÆ | | Sd S(   s√   Return the version of MSVC that was used to build Python.

    For Python 2.3 and up, the version number is included in
    sys.version.  For earlier versions, assume the compiler is MSVC 6.
    s   MSC v.iˇˇˇˇi   t    i   i˛ˇˇˇi   i   g      $@i    N(   R9   t   findt   sysR&   t   lent   splitt   intR
   (   t   prefixR   R    t   restt   majorVersiont   minorVersion(    (    s,   /usr/lib/python2.7/distutils/msvccompiler.pyt   get_build_versionô   s    	c          C   s[   d }  t  j t j |  É } | d k r+ d St  j t j d | É } t j | t |  É | !S(   sa   Return the processor architecture.

    Possible results are "Intel", "Itanium", or "AMD64".
    s    bit (iˇˇˇˇt   Intelt   )(   R9   R@   RA   R&   RB   (   RE   R   t   j(    (    s,   /usr/lib/python2.7/distutils/msvccompiler.pyt   get_build_architecture∞   s    c         C   sI   g  } x< |  D]4 } t  j j | É } | | k r | j | É q q W| S(   sn   Return a list of normalized paths with duplicates removed.

    The current order of paths is maintained.
    (   t   osR*   t   normpathR   (   t   pathst   reduced_pathsR6   t   np(    (    s,   /usr/lib/python2.7/distutils/msvccompiler.pyt   normalize_and_reduce_pathsΩ   s    t   MSVCCompilerc           B   sD  e  Z d  Z d Z i  Z d g Z d d d g Z d g Z d g Z e e e e Z	 d Z
 d	 Z d
 Z d Z d Z Z d Z d d d d Ñ Z d Ñ  Z d d d Ñ Z d d d d d d d d Ñ Z d d d d Ñ Z d d d d d d d d d d d Ñ
 Z d Ñ  Z d Ñ  Z d Ñ  Z d d Ñ Z d Ñ  Z d d Ñ Z d Ñ  Z RS(   sw   Concrete class that implements an interface to Microsoft Visual C++,
       as defined by the CCompiler abstract class.t   msvcs   .cs   .ccs   .cpps   .cxxs   .rcs   .mcs   .ress   .objs   .libs   .dlls   %s%ss   .exei    c         C   sß   t  j |  | | | É t É  |  _ t É  |  _ |  j d k rÜ |  j d k rj d |  _ t |  j É |  _ n	 d |  _ d |  j |  _	 n d |  j d |  _	 t
 |  _ d  S(   NRJ   i   s   Software\Microsoft\VisualStudios   Software\Microsoft\Devstudios   Visual Studio version %ss   Microsoft SDK compiler %si   (   R   R'   RI   t   _MSVCCompiler__versionRM   t   _MSVCCompiler__archt   _MSVCCompiler__rootR"   t   _MSVCCompiler__macrost   _MSVCCompiler__productt   Falset   initialized(   R%   t   verboset   dry_runt   force(    (    s,   /usr/lib/python2.7/distutils/msvccompiler.pyR'   Í   s    		c         C   sÖ  g  |  _  d t j k rf d t j k rf |  j d É rf d |  _ d |  _ d |  _ d |  _ d |  _ nÆ |  j	 d É |  _  t
 |  j  É d	 k r† t d
 |  j Ç n  |  j d É |  _ |  j d É |  _ |  j d É |  _ |  j d É |  _ |  j d É |  _ |  j d É |  j d É y8 x1 t j t j d d É D] } |  j  j | É q1WWn t k
 r_n Xt |  j  É |  _  t j |  j  d É t j d <d  |  _ |  j d k r‚d d d d d d g |  _ d d d d d d d g |  _ n9 d d d d d d g |  _ d d d d d d d g |  _ d d d g |  _ |  j d k rTd d d d g |  _ n d d d d d g |  _ d g |  _ t |  _ d  S(    Nt   DISTUTILS_USE_SDKt   MSSdks   cl.exes   link.exes   lib.exes   rc.exes   mc.exeR*   i    sx   Python was built with %s, and extensions need to be built with the same version of the compiler, but it isn't installed.t   libt   includet   ;RJ   s   /nologos   /Oxs   /MDs   /W3s   /GXs   /DNDEBUGs   /Ods   /MDds   /Z7s   /D_DEBUGs   /GS-s   /DLLs   /INCREMENTAL:NOi   s   /INCREMENTAL:nos   /DEBUGs	   /pdb:None(   t   _MSVCCompiler__pathsRN   t   environt   find_exet   cct   linkerRb   t   rct   mct   get_msvc_pathsRB   R   RZ   t   set_path_env_varR9   RC   R   R3   RS   t   joinR
   t   preprocess_optionsRW   t   compile_optionst   compile_options_debugt   ldflags_sharedRV   t   ldflags_shared_debugt   ldflags_statict   TrueR\   (   R%   R6   (    (    s,   /usr/lib/python2.7/distutils/msvccompiler.pyt
   initialize¸   sT    	-				 	t    c         C   s>  | d  k r d } n  g  } x| D]} t j j | É \ } } t j j | É d } | t j j | É } | |  j k ré t d | É Ç n  | r© t j j | É } n  | |  j	 k rﬁ | j
 t j j | | |  j É É q" | |  j k r| j
 t j j | | |  j É É q" | j
 t j j | | |  j É É q" W| S(   NRw   i   s   Don't know how to compile %s(   R
   RN   R*   t   splitextt
   splitdrivet   isabst   src_extensionsR   t   basenamet   _rc_extensionsR   Rn   t   res_extensiont   _mc_extensionst   obj_extension(   R%   t   source_filenamest	   strip_dirt
   output_dirt	   obj_namest   src_nameR   t   ext(    (    s,   /usr/lib/python2.7/distutils/msvccompiler.pyt   object_filenames<  s(     	c	         C   sŸ  |  j  s |  j É  n  |  j | | | | | | É \ } }	 } }
 } | pL g  } | j d É | ru | j |  j É n | j |  j É xM|	 D]E} y | | \ } } Wn t k
 rº qå n X| rÿ t j	 j
 | É } n  | |  j k rÙ d | } ná| |  j k rd | } nk| |  j k r}| } d | } y) |  j |  j g |
 | g | g É Wqå t k
 rv} t | Ç qå Xqå n˛ | |  j k ret j	 j | É } t j	 j | É } yê |  j |  j g d | d | g | g É t j	 j t j	 j | É É \ } } t j	 j | | d É } |  j |  j g d | g | g É Wqå t k
 r^} t | Ç qå Xqå n t d | | f É Ç d	 | } y- |  j |  j g | |
 | | g | É Wqå t k
 r–} t | Ç qå Xqå W|	 S(
   Ns   /cs   /Tcs   /Tps   /fos   -hs   -rs   .rcs"   Don't know how to compile %s to %ss   /Fo(   R\   Rv   t   _setup_compileR   t   extendRq   Rp   R3   RN   R*   t   abspatht   _c_extensionst   _cpp_extensionsR}   t   spawnRj   R    R   R   t   dirnameRk   Rx   R|   Rn   Rh   (   R%   t   sourcesRÉ   R#   t   include_dirst   debugt   extra_preargst   extra_postargst   dependst   objectst   pp_optst   buildt   compile_optst   objt   srcRÜ   t	   input_optt
   output_optt   msgt   h_dirt   rc_dirR   t   _t   rc_file(    (    s,   /usr/lib/python2.7/distutils/msvccompiler.pyt   compile]  sj    	 
#$$#
c   	      C   s¿   |  j  s |  j É  n  |  j | | É \ } } |  j | d | É} |  j | | É r¨ | d | g } | ro n  y |  j |  j g | É Wqº t k
 r® } t | Ç qº Xn t	 j
 d | É d  S(   NRÉ   s   /OUT:s   skipping %s (up-to-date)(   R\   Rv   t   _fix_object_argst   library_filenamet
   _need_linkRç   Rb   R    R   R   Rë   (	   R%   Rï   t   output_libnameRÉ   Rë   t   target_langt   output_filenamet   lib_argsRù   (    (    s,   /usr/lib/python2.7/distutils/msvccompiler.pyt   create_static_lib∂  s    	 c         C   sW  |  j  s |  j É  n  |  j | | É \ } } |  j | | | É \ } } } | rl |  j d t | É É n  t |  | | | É } | d  k	 r• t j	 j
 | | É } n  |  j | | É rC| t j k rÏ |	 r‹ |  j d } q|  j d } n |	 r˛ |  j } n	 |  j } g  } x% | pg  D] } | j d | É qW| | | | d | g } | d  k	 rƒt j	 j t j	 j | É É \ } } t j	 j
 t j	 j | d É |  j | É É } | j d | É n  |
 r◊|
 | d *n  | rÌ| j | É n  |  j t j	 j | É É y |  j |  j g | É WqSt k
 r?} t | Ç qSXn t j d | É d  S(   Ns5   I don't know what to do with 'runtime_library_dirs': i   s   /EXPORT:s   /OUT:i    s   /IMPLIB:s   skipping %s (up-to-date)(   R\   Rv   R£   t   _fix_lib_argst   warnt   strR   R
   RN   R*   Rn   R•   R   t
   EXECUTABLERs   Rr   R   Rx   R|   Ré   R§   Râ   t   mkpathRç   Ri   R    R   R   Rë   (   R%   t   target_descRï   R®   RÉ   t	   librariest   library_dirst   runtime_library_dirst   export_symbolsRë   Rí   Rì   t
   build_tempRß   t   lib_optst   ldflagst   export_optst   symt   ld_argst   dll_namet   dll_extt   implib_fileRù   (    (    s,   /usr/lib/python2.7/distutils/msvccompiler.pyt   link–  sR    	 					c         C   s   d | S(   Ns	   /LIBPATH:(    (   R%   t   dir(    (    s,   /usr/lib/python2.7/distutils/msvccompiler.pyt   library_dir_option$  s    c         C   s   t  d Ç d  S(   Ns<   don't know how to set runtime library search path for MSVC++(   R   (   R%   Rø   (    (    s,   /usr/lib/python2.7/distutils/msvccompiler.pyt   runtime_library_dir_option'  s    c         C   s   |  j  | É S(   N(   R§   (   R%   Rb   (    (    s,   /usr/lib/python2.7/distutils/msvccompiler.pyt   library_option+  s    c         C   sÄ   | r | d | g } n	 | g } xW | D]K } xB | D]: } t  j j | |  j | É É } t  j j | É r6 | Sq6 Wq) Wd  Sd  S(   Nt   _d(   RN   R*   Rn   R§   t   existsR
   (   R%   t   dirsRb   Rë   t	   try_namesRø   R   t   libfile(    (    s,   /usr/lib/python2.7/distutils/msvccompiler.pyt   find_library_file/  s    	c         C   s™   xH |  j  D]= } t j j t j j | É | É } t j j | É r
 | Sq
 WxX t j t j d d É D]= } t j j t j j | É | É } t j j | É re | Sqe W| S(   så  Return path to an MSVC executable program.

        Tries to find the program in several places: first, one of the
        MSVC program search paths from the registry; next, the directories
        in the PATH environment variable.  If any of those work, return an
        absolute path that is known to exist.  If none of them work, just
        return the original program name, 'exe'.
        t   PathRd   (	   Re   RN   R*   Rn   Rä   t   isfileR9   RC   Rf   (   R%   t   exeR6   t   fn(    (    s,   /usr/lib/python2.7/distutils/msvccompiler.pyRg   C  s    
! !t   x86c         C   s  t  s
 g  S| d } |  j d k r< d |  j |  j f } n d |  j | f } xi t D]a } t | | É } | rV |  j d k r† t j |  j j | | É d É St j | | d É SqV qV W|  j d k rx> t D]3 } t | d |  j É d	 k	 r— |  j
 d É Pq— q— Wn  g  S(
   s–   Get a list of devstudio directories (include, lib or path).

        Return a list of strings.  The list will be empty if unable to
        access the registry or appropriate registry keys not found.
        s    dirsi   s6   %s\%0.1f\VC\VC_OBJECTS_PLATFORM_INFO\Win32\Directoriess?   %s\6.0\Build System\Components\Platforms\Win32 (%s)\DirectoriesRd   i   s   %s\6.0s¥   It seems you have Visual Studio 6 installed, but the expected registry settings are not present.
You must at least run the Visual Studio GUI once so that these entries are created.N(   t   _can_read_regRV   RX   R(   R   R9   RC   RY   R<   R
   R¨   (   R%   R*   t   platformR   R   R   (    (    s,   /usr/lib/python2.7/distutils/msvccompiler.pyRl   Z  s(    
 c         C   sS   | d k r |  j  d É } n |  j  | É } | rO t j | d É t j | <n  d S(   s°   Set environment variable 'name' to an MSVC path type value.

        This is equivalent to a SET command prior to execution of spawned
        commands.
        Rb   t   libraryRd   N(   Rl   R9   Rn   RN   Rf   (   R%   R   R6   (    (    s,   /usr/lib/python2.7/distutils/msvccompiler.pyRm     s
    N(   R=   R>   t   __doc__t   compiler_typet   executablesRã   Rå   R}   R   R{   R~   RÄ   t   static_lib_extensiont   shared_lib_extensiont   static_lib_formatt   shared_lib_formatt   exe_extensionR'   Rv   Rá   R
   R¢   R™   Ræ   R¿   R¡   R¬   R»   Rg   Rl   Rm   (    (    (    s,   /usr/lib/python2.7/distutils/msvccompiler.pyRT   Ã   sP   			
	BZG				%g       @s3   Importing new compiler from distutils.msvc9compiler(   RT   (   R"   (/   R—   t   __revision__RA   RN   R9   t   distutils.errorsR    R   R   R   R   t   distutils.ccompilerR   R   t	   distutilsR   RŒ   t   _winregt   hkey_modt	   OpenKeyExR   t   EnumKeyR   t	   EnumValueR   t   errorR	   t   ImportErrort   win32apit   win32cont   infot
   HKEY_USERSt   HKEY_CURRENT_USERt   HKEY_LOCAL_MACHINEt   HKEY_CLASSES_ROOTR(   R   R   R   R"   RI   RM   RS   RT   Rë   t   OldMSVCCompilert   distutils.msvc9compiler(    (    (    s,   /usr/lib/python2.7/distutils/msvccompiler.pyt   <module>   s`   (										.			ˇ √                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               """distutils.spawn

Provides the 'spawn()' function, a front-end to various platform-
specific functions for launching another program in a sub-process.
Also provides the 'find_executable()' to search the path for a given
executable name.
"""

__revision__ = "$Id$"

import sys
import os

from distutils.errors import DistutilsPlatformError, DistutilsExecError
from distutils.debug import DEBUG
from distutils import log

def spawn(cmd, search_path=1, verbose=0, dry_run=0):
    """Run another program, specified as a command list 'cmd', in a new process.

    'cmd' is just the argument list for the new process, ie.
    cmd[0] is the program to run and cmd[1:] are the rest of its arguments.
    There is no way to run a program with a name different from that of its
    executable.

    If 'search_path' is true (the default), the system's executable
    search path will be used to find the program; otherwise, cmd[0]
    must be the exact path to the executable.  If 'dry_run' is true,
    the command will not actually be run.

    Raise DistutilsExecError if running the program fails in any way; just
    return on success.
    """
    # cmd is documented as a list, but just in case some code passes a tuple
    # in, protect our %-formatting code against horrible death
    cmd = list(cmd)
    if os.name == 'posix':
        _spawn_posix(cmd, search_path, dry_run=dry_run)
    elif os.name == 'nt':
        _spawn_nt(cmd, search_path, dry_run=dry_run)
    elif os.name == 'os2':
        _spawn_os2(cmd, search_path, dry_run=dry_run)
    else:
        raise DistutilsPlatformError, \
              "don't know how to spawn programs on platform '%s'" % os.name

def _nt_quote_args(args):
    """Quote command-line arguments for DOS/Windows conventions.

    Just wraps every argument which contains blanks in double quotes, and
    returns a new argument list.
    """
    # XXX this doesn't seem very robust to me -- but if the Windows guys
    # say it'll work, I guess I'll have to accept it.  (What if an arg
    # contains quotes?  What other magic characters, other than spaces,
    # have to be escaped?  Is there an escaping mechanism other than
    # quoting?)
    for i, arg in enumerate(args):
        if ' ' in arg:
            args[i] = '"%s"' % arg
    return args

def _spawn_nt(cmd, search_path=1, verbose=0, dry_run=0):
    executable = cmd[0]
    cmd = _nt_quote_args(cmd)
    if search_path:
        # either we find one or it stays the same
        executable = find_executable(executable) or executable
    log.info(' '.join([executable] + cmd[1:]))
    if not dry_run:
        # spawn for NT requires a full path to the .exe
        try:
            rc = os.spawnv(os.P_WAIT, executable, cmd)
        except OSError, exc:
            # this seems to happen when the command isn't found
            if not DEBUG:
                cmd = executable
            raise DistutilsExecError, \
                  "command %r failed: %s" % (cmd, exc[-1])
        if rc != 0:
            # and this reflects the command running but failing
            if not DEBUG:
                cmd = executable
            raise DistutilsExecError, \
                  "command %r failed with exit status %d" % (cmd, rc)

def _spawn_os2(cmd, search_path=1, verbose=0, dry_run=0):
    executable = cmd[0]
    if search_path:
        # either we find one or it stays the same
        executable = find_executable(executable) or executable
    log.info(' '.join([executable] + cmd[1:]))
    if not dry_run:
        # spawnv for OS/2 EMX requires a full path to the .exe
        try:
            rc = os.spawnv(os.P_WAIT, executable, cmd)
        except OSError, exc:
            # this seems to happen when the command isn't found
            if not DEBUG:
                cmd = executable
            raise DistutilsExecError, \
                  "command %r failed: %s" % (cmd, exc[-1])
        if rc != 0:
            # and this reflects the command running but failing
            if not DEBUG:
                cmd = executable
            log.debug("command %r failed with exit status %d" % (cmd, rc))
            raise DistutilsExecError, \
                  "command %r failed with exit status %d" % (cmd, rc)

if sys.platform == 'darwin':
    from distutils import sysconfig
    _cfg_target = None
    _cfg_target_split = None

def _spawn_posix(cmd, search_path=1, verbose=0, dry_run=0):
    log.info(' '.join(cmd))
    if dry_run:
        return
    executable = cmd[0]
    exec_fn = search_path and os.execvp or os.execv
    env = None
    if sys.platform == 'darwin':
        global _cfg_target, _cfg_target_split
        if _cfg_target is None:
            _cfg_target = sysconfig.get_config_var(
                                  'MACOSX_DEPLOYMENT_TARGET') or ''
            if _cfg_target:
                _cfg_target_split = [int(x) for x in _cfg_target.split('.')]
        if _cfg_target:
            # ensure that the deployment target of build process is not less
            # than that used when the interpreter was built. This ensures
            # extension modules are built with correct compatibility values
            cur_target = os.environ.get('MACOSX_DEPLOYMENT_TARGET', _cfg_target)
            if _cfg_target_split > [int(x) for x in cur_target.split('.')]:
                my_msg = ('$MACOSX_DEPLOYMENT_TARGET mismatch: '
                          'now "%s" but "%s" during configure'
                                % (cur_target, _cfg_target))
                raise DistutilsPlatformError(my_msg)
            env = dict(os.environ,
                       MACOSX_DEPLOYMENT_TARGET=cur_target)
            exec_fn = search_path and os.execvpe or os.execve
    pid = os.fork()

    if pid == 0:  # in the child
        try:
            if env is None:
                exec_fn(executable, cmd)
            else:
                exec_fn(executable, cmd, env)
        except OSError, e:
            if not DEBUG:
                cmd = executable
            sys.stderr.write("unable to execute %r: %s\n" %
                             (cmd, e.strerror))
            os._exit(1)

        if not DEBUG:
            cmd = executable
        sys.stderr.write("unable to execute %r for unknown reasons" % cmd)
        os._exit(1)
    else:   # in the parent
        # Loop until the child either exits or is terminated by a signal
        # (ie. keep waiting if it's merely stopped)
        while 1:
            try:
                pid, status = os.waitpid(pid, 0)
            except OSError, exc:
                import errno
                if exc.errno == errno.EINTR:
                    continue
                if not DEBUG:
                    cmd = executable
                raise DistutilsExecError, \
                      "command %r failed: %s" % (cmd, exc[-1])
            if os.WIFSIGNALED(status):
                if not DEBUG:
                    cmd = executable
                raise DistutilsExecError, \
                      "command %r terminated by signal %d" % \
                      (cmd, os.WTERMSIG(status))

            elif os.WIFEXITED(status):
                exit_status = os.WEXITSTATUS(status)
                if exit_status == 0:
                    return   # hey, it succeeded!
                else:
                    if not DEBUG:
                        cmd = executable
                    raise DistutilsExecError, \
                          "command %r failed with exit status %d" % \
                          (cmd, exit_status)

            elif os.WIFSTOPPED(status):
                continue

            else:
                if not DEBUG:
                    cmd = executable
                raise DistutilsExecError, \
                      "unknown error executing %r: termination status %d" % \
                      (cmd, status)

def find_executable(executable, path=None):
    """Tries to find 'executable' in the directories listed in 'path'.

    A string listing directories separated by 'os.pathsep'; defaults to
    os.environ['PATH'].  Returns the complete filename or None if not found.
    """
    if path is None:
        path = os.environ['PATH']
    paths = path.split(os.pathsep)
    base, ext = os.path.splitext(executable)

    if (sys.platform == 'win32' or os.name == 'os2') and (ext != '.exe'):
        executable = executable + '.exe'

    if not os.path.isfile(executable):
        for p in paths:
            f = os.path.join(p, executable)
            if os.path.isfile(f):
                # the file exists, we have a shot at spawn working
                return f
        return None
    else:
        return executable
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         """Provide access to Python's configuration information.  The specific
configuration variables available depend heavily on the platform and
configuration.  The values may be retrieved using
get_config_var(name), and the list of variables is available via
get_config_vars().keys().  Additional convenience functions are also
available.

Written by:   Fred L. Drake, Jr.
Email:        <fdrake@acm.org>
"""

__revision__ = "$Id$"

import os
import re
import string
import sys
import fnmatch

from distutils.errors import DistutilsPlatformError

# These are needed in a couple of spots, so just compute them once.
PREFIX = os.path.normpath(sys.prefix)
EXEC_PREFIX = os.path.normpath(sys.exec_prefix)

# Path to the base directory of the project. On Windows the binary may
# live in project/PCBuild9.  If we're dealing with an x64 Windows build,
# it'll live in project/PCbuild/amd64.
project_base = os.path.dirname(os.path.abspath(sys.executable))
if os.name == "nt" and "pcbuild" in project_base[-8:].lower():
    project_base = os.path.abspath(os.path.join(project_base, os.path.pardir))
# PC/VS7.1
if os.name == "nt" and "\\pc\\v" in project_base[-10:].lower():
    project_base = os.path.abspath(os.path.join(project_base, os.path.pardir,
                                                os.path.pardir))
# PC/AMD64
if os.name == "nt" and "\\pcbuild\\amd64" in project_base[-14:].lower():
    project_base = os.path.abspath(os.path.join(project_base, os.path.pardir,
                                                os.path.pardir))

# set for cross builds
if "_PYTHON_PROJECT_BASE" in os.environ:
    # this is the build directory, at least for posix
    project_base = os.path.normpath(os.environ["_PYTHON_PROJECT_BASE"])

# python_build: (Boolean) if true, we're either building Python or
# building an extension with an un-installed Python, so we use
# different (hard-wired) directories.
# Setup.local is available for Makefile builds including VPATH builds,
# Setup.dist is available on Windows
def _python_build():
    for fn in ("Setup.dist", "Setup.local"):
        if os.path.isfile(os.path.join(project_base, "Modules", fn)):
            return True
    return False
python_build = _python_build()


def get_python_version():
    """Return a string containing the major and minor Python version,
    leaving off the patchlevel.  Sample return values could be '1.5'
    or '2.2'.
    """
    return sys.version[:3]


def get_python_inc(plat_specific=0, prefix=None):
    """Return the directory containing installed Python header files.

    If 'plat_specific' is false (the default), this is the path to the
    non-platform-specific header files, i.e. Python.h and so on;
    otherwise, this is the path to platform-specific header files
    (namely pyconfig.h).

    If 'prefix' is supplied, use it instead of sys.prefix or
    sys.exec_prefix -- i.e., ignore 'plat_specific'.
    """

    if os.name == "posix":
        if python_build:
            buildir = os.path.dirname(sys.executable)
            if plat_specific:
                # python.h is located in the buildir
                inc_dir = buildir
            else:
                # the source dir is relative to the buildir
                srcdir = os.path.abspath(os.path.join(buildir,
                                         get_config_var('srcdir')))
                # Include is located in the srcdir
                inc_dir = os.path.join(srcdir, "Include")
            return inc_dir
        else:
            if not (prefix is None):
                return os.path.join(prefix, "include",
                                    "python" + get_python_version())+(sys.pydebug and "_d" or "")
            if plat_specific:
                return get_config_var('CONFINCLUDEPY')
            else:
                return get_config_var('INCLUDEPY')
    elif os.name == "nt":
        return os.path.join(prefix, "include")
    elif os.name == "os2":
        return os.path.join(prefix, "Include")
    else:
        raise DistutilsPlatformError(
            "I don't know where Python installs its C header files "
            "on platform '%s'" % os.name)


def get_python_lib(plat_specific=0, standard_lib=0, prefix=None):
    """Return the directory containing the Python library (standard or
    site additions).

    If 'plat_specific' is true, return the directory containing
    platform-specific modules, i.e. any module from a non-pure-Python
    module distribution; otherwise, return the platform-shared library
    directory.  If 'standard_lib' is true, return the directory
    containing standard Python library modules; otherwise, return the
    directory for site-specific modules.

    If 'prefix' is supplied, use it instead of sys.prefix or
    sys.exec_prefix -- i.e., ignore 'plat_specific'.
    """
    is_default_prefix = not prefix or os.path.normpath(prefix) in ('/usr', '/usr/local')
    if prefix is None:
        prefix = plat_specific and EXEC_PREFIX or PREFIX

    if os.name == "posix":
        libpython = os.path.join(prefix,
                                 "lib", "python" + get_python_version())
        if standard_lib:
            return libpython
        elif is_default_prefix and 'PYTHONUSERBASE' not in os.environ and 'real_prefix' not in sys.__dict__:
            return os.path.join(libpython, "dist-packages")
        else:
            return os.path.join(libpython, "site-packages")

    elif os.name == "nt":
        if standard_lib:
            return os.path.join(prefix, "Lib")
        else:
            if get_python_version() < "2.2":
                return prefix
            else:
                return os.path.join(prefix, "Lib", "site-packages")

    elif os.name == "os2":
        if standard_lib:
            return os.path.join(prefix, "Lib")
        else:
            return os.path.join(prefix, "Lib", "site-packages")

    else:
        raise DistutilsPlatformError(
            "I don't know where Python installs its library "
            "on platform '%s'" % os.name)



def customize_compiler(compiler):
    """Do any platform-specific customization of a CCompiler instance.

    Mainly needed on Unix, so we can plug in the information that
    varies across Unices and is stored in Python's Makefile.
    """
    if compiler.compiler_type == "unix":
        if sys.platform == "darwin":
            # Perform first-time customization of compiler-related
            # config vars on OS X now that we know we need a compiler.
            # This is primarily to support Pythons from binary
            # installers.  The kind and paths to build tools on
            # the user system may vary significantly from the system
            # that Python itself was built on.  Also the user OS
            # version and build tools may not support the same set
            # of CPU architectures for universal builds.
            global _config_vars
            # Use get_config_var() to ensure _config_vars is initialized.
            if not get_config_var('CUSTOMIZED_OSX_COMPILER'):
                import _osx_support
                _osx_support.customize_compiler(_config_vars)
                _config_vars['CUSTOMIZED_OSX_COMPILER'] = 'True'

        (cc, cxx, opt, cflags, extra_cflags, basecflags,
         ccshared, ldshared, so_ext, ar, ar_flags,
         configure_cppflags, configure_cflags, configure_ldflags) = \
            get_config_vars('CC', 'CXX', 'OPT', 'CFLAGS', 'EXTRA_CFLAGS', 'BASECFLAGS',
                            'CCSHARED', 'LDSHARED', 'SO', 'AR', 'ARFLAGS',
                            'CONFIGURE_CPPFLAGS', 'CONFIGURE_CFLAGS', 'CONFIGURE_LDFLAGS')

        if 'CC' in os.environ:
            newcc = os.environ['CC']
            if (sys.platform == 'darwin'
                    and 'LDSHARED' not in os.environ
                    and ldshared.startswith(cc)):
                # On OS X, if CC is overridden, use that as the default
                #       command for LDSHARED as well
                ldshared = newcc + ldshared[len(cc):]
            cc = newcc
        if 'CXX' in os.environ:
            cxx = os.environ['CXX']
        if fnmatch.filter([cc, cxx], '*-4.[0-8]'):
            configure_cflags = configure_cflags.replace('-fstack-protector-strong', '-fstack-protector')
            ldshared = ldshared.replace('-fstack-protector-strong', '-fstack-protector')
            cflags = cflags.replace('-fstack-protector-strong', '-fstack-protector')
        if 'LDSHARED' in os.environ:
            ldshared = os.environ['LDSHARED']
        if 'CPP' in os.environ:
            cpp = os.environ['CPP']
        else:
            cpp = cc + " -E"           # not always
        if 'LDFLAGS' in os.environ:
            ldshared = ldshared + ' ' + os.environ['LDFLAGS']
        elif configure_ldflags:
            ldshared = ldshared + ' ' + configure_ldflags
        if 'BASECFLAGS' in os.environ:
            basecflags = os.environ['BASECFLAGS']
        if 'OPT' in os.environ:
            opt = os.environ['OPT']
        cflags = ' '.join(str(x) for x in (basecflags, opt, extra_cflags) if x)
        if 'CFLAGS' in os.environ:
            cflags = ' '.join(str(x) for x in (opt, basecflags, os.environ['CFLAGS'], extra_cflags) if x)
            ldshared = ldshared + ' ' + os.environ['CFLAGS']
        elif configure_cflags:
            cflags = ' '.join(str(x) for x in (opt, basecflags, configure_cflags, extra_cflags) if x)
            ldshared = ldshared + ' ' + configure_cflags
        if 'CPPFLAGS' in os.environ:
            cpp = cpp + ' ' + os.environ['CPPFLAGS']
            cflags = cflags + ' ' + os.environ['CPPFLAGS']
            ldshared = ldshared + ' ' + os.environ['CPPFLAGS']
        elif configure_cppflags:
            cpp = cpp + ' ' + configure_cppflags
            cflags = cflags + ' ' + configure_cppflags
            ldshared = ldshared + ' ' + configure_cppflags
        if 'AR' in os.environ:
            ar = os.environ['AR']
        if 'ARFLAGS' in os.environ:
            archiver = ar + ' ' + os.environ['ARFLAGS']
        else:
            archiver = ar + ' ' + ar_flags

        cc_cmd = cc + ' ' + cflags
        compiler.set_executables(
            preprocessor=cpp,
            compiler=cc_cmd,
            compiler_so=cc_cmd + ' ' + ccshared,
            compiler_cxx=cxx,
            linker_so=ldshared,
            linker_exe=cc,
            archiver=archiver)

        compiler.shared_lib_extension = so_ext


def get_config_h_filename():
    """Return full pathname of installed pyconfig.h file."""
    if python_build:
        if os.name == "nt":
            inc_dir = os.path.join(project_base, "PC")
        else:
            inc_dir = project_base
    else:
        inc_dir = get_python_inc(plat_specific=1)
    if get_python_version() < '2.2':
        config_h = 'config.h'
    else:
        # The name of the config.h file changed in 2.2
        config_h = 'pyconfig.h'
    return os.path.join(inc_dir, config_h)


def get_makefile_filename():
    """Return full pathname of installed Makefile from the Python build."""
    if python_build:
        return os.path.join(project_base, "Makefile")
    lib_dir = get_python_lib(plat_specific=1, standard_lib=1)
    return os.path.join(get_config_var('LIBPL'), "Makefile")


def parse_config_h(fp, g=None):
    """Parse a config.h-style file.

    A dictionary containing name/value pairs is returned.  If an
    optional dictionary is passed in as the second argument, it is
    used instead of a new dictionary.
    """
    if g is None:
        g = {}
    define_rx = re.compile("#define ([A-Z][A-Za-z0-9_]+) (.*)\n")
    undef_rx = re.compile("/[*] #undef ([A-Z][A-Za-z0-9_]+) [*]/\n")
    #
    while 1:
        line = fp.readline()
        if not line:
            break
        m = define_rx.match(line)
        if m:
            n, v = m.group(1, 2)
            try: v = int(v)
            except ValueError: pass
            g[n] = v
        else:
            m = undef_rx.match(line)
            if m:
                g[m.group(1)] = 0
    return g


# Regexes needed for parsing Makefile (and similar syntaxes,
# like old-style Setup files).
_variable_rx = re.compile("([a-zA-Z][a-zA-Z0-9_]+)\s*=\s*(.*)")
_findvar1_rx = re.compile(r"\$\(([A-Za-z][A-Za-z0-9_]*)\)")
_findvar2_rx = re.compile(r"\${([A-Za-z][A-Za-z0-9_]*)}")

def parse_makefile(fn, g=None):
    """Parse a Makefile-style file.

    A dictionary containing name/value pairs is returned.  If an
    optional dictionary is passed in as the second argument, it is
    used instead of a new dictionary.
    """
    from distutils.text_file import TextFile
    fp = TextFile(fn, strip_comments=1, skip_blanks=1, join_lines=1)

    if g is None:
        g = {}
    done = {}
    notdone = {}

    while 1:
        line = fp.readline()
        if line is None:  # eof
            break
        m = _variable_rx.match(line)
        if m:
            n, v = m.group(1, 2)
            v = v.strip()
            # `$$' is a literal `$' in make
            tmpv = v.replace('$$', '')

            if "$" in tmpv:
                notdone[n] = v
            else:
                try:
                    v = int(v)
                except ValueError:
                    # insert literal `$'
                    done[n] = v.replace('$$', '$')
                else:
                    done[n] = v

    # do variable interpolation here
    variables = list(notdone.keys())

    # Variables with a 'PY_' prefix in the makefile. These need to
    # be made available without that prefix through sysconfig.
    # Special care is needed to ensure that variable expansion works, even
    # if the expansion uses the name without a prefix.
    renamed_variables = ('CFLAGS', 'LDFLAGS', 'CPPFLAGS')

    while len(variables) > 0:
        for name in tuple(variables):
            value = notdone[name]
            m = _findvar1_rx.search(value) or _findvar2_rx.search(value)
            if m is not None:
                n = m.group(1)
                found = True
                if n in done:
                    item = str(done[n])
                elif n in notdone:
                    # get it on a subsequent round
                    found = False
                elif n in os.environ:
                    # do it like make: fall back to environment
                    item = os.environ[n]

                elif n in renamed_variables:
                    if name.startswith('PY_') and name[3:] in renamed_variables:
                        item = ""

                    elif 'PY_' + n in notdone:
                        found = False

                    else:
                        item = str(done['PY_' + n])

                else:
                    done[n] = item = ""

                if found:
                    after = value[m.end():]
                    value = value[:m.start()] + item + after
                    if "$" in after:
                        notdone[name] = value
                    else:
                        try:
                            value = int(value)
                        except ValueError:
                            done[name] = value.strip()
                        else:
                            done[name] = value
                        variables.remove(name)

                        if name.startswith('PY_') \
                        and name[3:] in renamed_variables:

                            name = name[3:]
                            if name not in done:
                                done[name] = value


            else:
                # bogus variable reference (e.g. "prefix=$/opt/python");
                # just drop it since we can't deal
                done[name] = value
                variables.remove(name)

    # strip spurious spaces
    for k, v in done.items():
        if isinstance(v, str):
            done[k] = v.strip()

    # save the results in the global dictionary
    g.update(done)
    return g


def expand_makefile_vars(s, vars):
    """Expand Makefile-style variables -- "${foo}" or "$(foo)" -- in
    'string' according to 'vars' (a dictionary mapping variable names to
    values).  Variables not present in 'vars' are silently expanded to the
    empty string.  The variable values in 'vars' should not contain further
    variable expansions; if 'vars' is the output of 'parse_makefile()',
    you're fine.  Returns a variable-expanded version of 's'.
    """

    # This algorithm does multiple expansion, so if vars['foo'] contains
    # "${bar}", it will expand ${foo} to ${bar}, and then expand
    # ${bar}... and so forth.  This is fine as long as 'vars' comes from
    # 'parse_makefile()', which takes care of such expansions eagerly,
    # according to make's variable expansion semantics.

    while 1:
        m = _findvar1_rx.search(s) or _findvar2_rx.search(s)
        if m:
            (beg, end) = m.span()
            s = s[0:beg] + vars.get(m.group(1)) + s[end:]
        else:
            break
    return s


_config_vars = None

def _init_posix():
    """Initialize the module as appropriate for POSIX systems."""
    # _sysconfigdata is generated at build time, see the sysconfig module
    from _sysconfigdata import build_time_vars
    global _config_vars
    _config_vars = {}
    _config_vars.update(build_time_vars)


def _init_nt():
    """Initialize the module as appropriate for NT"""
    g = {}
    # set basic install directories
    g['LIBDEST'] = get_python_lib(plat_specific=0, standard_lib=1)
    g['BINLIBDEST'] = get_python_lib(plat_specific=1, standard_lib=1)

    # XXX hmmm.. a normal install puts include files here
    g['INCLUDEPY'] = get_python_inc(plat_specific=0)

    g['SO'] = '.pyd'
    g['EXE'] = ".exe"
    g['VERSION'] = get_python_version().replace(".", "")
    g['BINDIR'] = os.path.dirname(os.path.abspath(sys.executable))

    global _config_vars
    _config_vars = g


def _init_os2():
    """Initialize the module as appropriate for OS/2"""
    g = {}
    # set basic install directories
    g['LIBDEST'] = get_python_lib(plat_specific=0, standard_lib=1)
    g['BINLIBDEST'] = get_python_lib(plat_specific=1, standard_lib=1)

    # XXX hmmm.. a normal install puts include files here
    g['INCLUDEPY'] = get_python_inc(plat_specific=0)

    g['SO'] = '.pyd'
    g['EXE'] = ".exe"

    global _config_vars
    _config_vars = g


def get_config_vars(*args):
    """With no arguments, return a dictionary of all configuration
    variables relevant for the current platform.  Generally this includes
    everything needed to build extensions and install both pure modules and
    extensions.  On Unix, this means every variable defined in Python's
    installed Makefile; on Windows and Mac OS it's a much smaller set.

    With arguments, return a list of values that result from looking up
    each argument in the configuration variable dictionary.
    """
    global _config_vars
    if _config_vars is None:
        func = globals().get("_init_" + os.name)
        if func:
            func()
        else:
            _config_vars = {}

        # Normalized versions of prefix and exec_prefix are handy to have;
        # in fact, these are the standard versions used most places in the
        # Distutils.
        _config_vars['prefix'] = PREFIX
        _config_vars['exec_prefix'] = EXEC_PREFIX

        # OS X platforms require special customization to handle
        # multi-architecture, multi-os-version installers
        if sys.platform == 'darwin':
            import _osx_support
            _osx_support.customize_config_vars(_config_vars)

    if args:
        vals = []
        for name in args:
            vals.append(_config_vars.get(name))
        return vals
    else:
        return _config_vars

def get_config_var(name):
    """Return the value of a single variable using the dictionary
    returned by 'get_config_vars()'.  Equivalent to
    get_config_vars().get(name)
    """
    return get_config_vars().get(name)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Û
”´[c           @   s/   d  Z  d Z d d l Z d d d Ñ  É  YZ d S(   sº   text_file

provides the TextFile class, which gives an interface to text files
that (optionally) takes care of stripping comments, ignoring blank
lines, and joining lines with backslashes.s   $Id$iˇˇˇˇNt   TextFilec           B   sû   e  Z d  Z i d d 6d d 6d d 6d d 6d d 6d d 6Z d d d	 Ñ Z d
 Ñ  Z d Ñ  Z d d Ñ Z d d Ñ Z	 d d Ñ Z
 d Ñ  Z d Ñ  Z d Ñ  Z RS(   sß  Provides a file-like object that takes care of all the things you
       commonly want to do when processing a text file that has some
       line-by-line syntax: strip comments (as long as "#" is your
       comment character), skip blank lines, join adjacent lines by
       escaping the newline (ie. backslash at end of line), strip
       leading and/or trailing whitespace.  All of these are optional
       and independently controllable.

       Provides a 'warn()' method so you can generate warning messages that
       report physical line number, even if the logical line in question
       spans multiple physical lines.  Also provides 'unreadline()' for
       implementing line-at-a-time lookahead.

       Constructor is called as:

           TextFile (filename=None, file=None, **options)

       It bombs (RuntimeError) if both 'filename' and 'file' are None;
       'filename' should be a string, and 'file' a file object (or
       something that provides 'readline()' and 'close()' methods).  It is
       recommended that you supply at least 'filename', so that TextFile
       can include it in warning messages.  If 'file' is not supplied,
       TextFile creates its own using the 'open()' builtin.

       The options are all boolean, and affect the value returned by
       'readline()':
         strip_comments [default: true]
           strip from "#" to end-of-line, as well as any whitespace
           leading up to the "#" -- unless it is escaped by a backslash
         lstrip_ws [default: false]
           strip leading whitespace from each line before returning it
         rstrip_ws [default: true]
           strip trailing whitespace (including line terminator!) from
           each line before returning it
         skip_blanks [default: true}
           skip lines that are empty *after* stripping comments and
           whitespace.  (If both lstrip_ws and rstrip_ws are false,
           then some lines may consist of solely whitespace: these will
           *not* be skipped, even if 'skip_blanks' is true.)
         join_lines [default: false]
           if a backslash is the last non-newline character on a line
           after stripping comments and whitespace, join the following line
           to it to form one "logical line"; if N consecutive lines end
           with a backslash, then N+1 physical lines will be joined to
           form one logical line.
         collapse_join [default: false]
           strip leading whitespace from lines that are joined to their
           predecessor; only matters if (join_lines and not lstrip_ws)

       Note that since 'rstrip_ws' can strip the trailing newline, the
       semantics of 'readline()' must differ from those of the builtin file
       object's 'readline()' method!  In particular, 'readline()' returns
       None for end-of-file: an empty string might just be a blank line (or
       an all-whitespace line), if 'rstrip_ws' is true but 'skip_blanks' is
       not.i   t   strip_commentst   skip_blanksi    t	   lstrip_wst	   rstrip_wst
   join_linest   collapse_joinc         K   sÚ   | d k r$ | d k r$ t d Ç n  xQ |  j j É  D]@ } | | k r] t |  | | | É q4 t |  | |  j | É q4 Wx3 | j É  D]% } | |  j k rÖ t d | Ç qÖ qÖ W| d k r  |  j | É n | |  _ | |  _ d |  _	 g  |  _
 d S(   s¸   Construct a new TextFile object.  At least one of 'filename'
           (a string) and 'file' (a file-like object) must be supplied.
           They keyword argument options are described above and affect
           the values returned by 'readline()'.s7   you must supply either or both of 'filename' and 'file's   invalid TextFile option '%s'i    N(   t   Nonet   RuntimeErrort   default_optionst   keyst   setattrt   KeyErrort   opent   filenamet   filet   current_linet   linebuf(   t   selfR   R   t   optionst   opt(    (    s)   /usr/lib/python2.7/distutils/text_file.pyt   __init__N   s     				c         C   s+   | |  _  t |  j  d É |  _ d |  _ d S(   sy   Open a new file named 'filename'.  This overrides both the
           'filename' and 'file' arguments to the constructor.t   ri    N(   R   R   R   R   (   R   R   (    (    s)   /usr/lib/python2.7/distutils/text_file.pyR   s   s    	c         C   s2   |  j  } d |  _  d |  _ d |  _ | j É  d S(   si   Close the current file and forget everything we know about it
           (filename, current line number).N(   R   R   R   R   t   close(   R   R   (    (    s)   /usr/lib/python2.7/distutils/text_file.pyR   |   s
    				c         C   sí   g  } | d  k r |  j } n  | j |  j d É t | t t f É ra | j d t | É É n | j d | É | j t | É É d j | É S(   Ns   , s   lines %d-%d: s	   line %d: t    (	   R   R   t   appendR   t
   isinstancet   listt   tuplet   strt   join(   R   t   msgt   linet   outmsg(    (    s)   /usr/lib/python2.7/distutils/text_file.pyt	   gen_errorÜ   s    c         C   s   t  d |  j | | É Ç d  S(   Ns   error: (   t
   ValueErrorR"   (   R   R   R    (    (    s)   /usr/lib/python2.7/distutils/text_file.pyt   errorì   s    c         C   s(   t  j j d |  j | | É d É d S(   s¡  Print (to stderr) a warning message tied to the current logical
           line in the current file.  If the current logical line in the
           file spans multiple physical lines, the warning refers to the
           whole range, eg. "lines 3-5".  If 'line' supplied, it overrides
           the current line number; it may be a list or tuple to indicate a
           range of physical lines, or an integer for a single physical
           line.s	   warning: s   
N(   t   syst   stderrt   writeR"   (   R   R   R    (    (    s)   /usr/lib/python2.7/distutils/text_file.pyt   warnñ   s    c         C   sØ  |  j  r$ |  j  d } |  j  d =| Sd } x~|  j j É  } | d k rQ d } n  |  j r˚ | r˚ | j d É } | d k r~ q˚ | d k sû | | d d k rÊ | d d k r¥ d p∑ d } | d | !| } | j É  d k r¯ q- q¯ q˚ | j d d É } n  |  j rí| rí| d k r'|  j	 d	 É | S|  j
 r?| j É  } n  | | } t |  j t É rv|  j d d |  j d <q€|  j |  j d g |  _ nI | d k r¢d St |  j t É rÀ|  j d d |  _ n |  j d |  _ |  j r¸|  j r¸| j É  } n0 |  j r| j É  } n |  j r,| j É  } n  | d k sD| d k rS|  j rSq- n  |  j r¶| d d k r|| d  } q- n  | d
 d k r¶| d d
 !d } q- q¶n  | SWd S(   sU  Read and return a single logical line from the current file (or
           from an internal buffer if lines have previously been "unread"
           with 'unreadline()').  If the 'join_lines' option is true, this
           may involve reading multiple physical lines concatenated into a
           single string.  Updates the current line number, so calling
           'warn()' after 'readline()' emits a warning about the physical
           line(s) just read.  Returns None on end-of-file, since the empty
           string can occur if 'rstrip_ws' is true but 'strip_blanks' is
           not.iˇˇˇˇR   t   #i    i   s   \s   
s   \#s2   continuation line immediately precedes end-of-filei˛ˇˇˇs   \
N(   R   R   t   readlineR   R   t   findt   stript   replaceR   R(   R   t   lstripR   R   R   R   R   t   rstripR   (   R   R    t   buildup_linet   post   eol(    (    s)   /usr/lib/python2.7/distutils/text_file.pyR*   °   sf    	
 	
 			
		!	
	c         C   s:   g  } x- |  j  É  } | d k r% | S| j | É q	 Wd S(   sW   Read and return the list of all logical lines remaining in the
           current file.N(   R*   R   R   (   R   t   linesR    (    (    s)   /usr/lib/python2.7/distutils/text_file.pyt	   readlines  s    c         C   s   |  j  j | É d S(   s∑   Push 'line' (a string) onto an internal buffer that will be
           checked by future 'readline()' calls.  Handy for implementing
           a parser with line-at-a-time lookahead.N(   R   R   (   R   R    (    (    s)   /usr/lib/python2.7/distutils/text_file.pyt
   unreadline+  s    N(   t   __name__t
   __module__t   __doc__R	   R   R   R   R   R"   R$   R(   R*   R4   R5   (    (    (    s)   /usr/lib/python2.7/distutils/text_file.pyR       s    8

%			
	~	(    (   R8   t   __revision__R%   R    (    (    (    s)   /usr/lib/python2.7/distutils/text_file.pyt   <module>   s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              """text_file

provides the TextFile class, which gives an interface to text files
that (optionally) takes care of stripping comments, ignoring blank
lines, and joining lines with backslashes."""

__revision__ = "$Id$"

import sys


class TextFile:

    """Provides a file-like object that takes care of all the things you
       commonly want to do when processing a text file that has some
       line-by-line syntax: strip comments (as long as "#" is your
       comment character), skip blank lines, join adjacent lines by
       escaping the newline (ie. backslash at end of line), strip
       leading and/or trailing whitespace.  All of these are optional
       and independently controllable.

       Provides a 'warn()' method so you can generate warning messages that
       report physical line number, even if the logical line in question
       spans multiple physical lines.  Also provides 'unreadline()' for
       implementing line-at-a-time lookahead.

       Constructor is called as:

           TextFile (filename=None, file=None, **options)

       It bombs (RuntimeError) if both 'filename' and 'file' are None;
       'filename' should be a string, and 'file' a file object (or
       something that provides 'readline()' and 'close()' methods).  It is
       recommended that you supply at least 'filename', so that TextFile
       can include it in warning messages.  If 'file' is not supplied,
       TextFile creates its own using the 'open()' builtin.

       The options are all boolean, and affect the value returned by
       'readline()':
         strip_comments [default: true]
           strip from "#" to end-of-line, as well as any whitespace
           leading up to the "#" -- unless it is escaped by a backslash
         lstrip_ws [default: false]
           strip leading whitespace from each line before returning it
         rstrip_ws [default: true]
           strip trailing whitespace (including line terminator!) from
           each line before returning it
         skip_blanks [default: true}
           skip lines that are empty *after* stripping comments and
           whitespace.  (If both lstrip_ws and rstrip_ws are false,
           then some lines may consist of solely whitespace: these will
           *not* be skipped, even if 'skip_blanks' is true.)
         join_lines [default: false]
           if a backslash is the last non-newline character on a line
           after stripping comments and whitespace, join the following line
           to it to form one "logical line"; if N consecutive lines end
           with a backslash, then N+1 physical lines will be joined to
           form one logical line.
         collapse_join [default: false]
           strip leading whitespace from lines that are joined to their
           predecessor; only matters if (join_lines and not lstrip_ws)

       Note that since 'rstrip_ws' can strip the trailing newline, the
       semantics of 'readline()' must differ from those of the builtin file
       object's 'readline()' method!  In particular, 'readline()' returns
       None for end-of-file: an empty string might just be a blank line (or
       an all-whitespace line), if 'rstrip_ws' is true but 'skip_blanks' is
       not."""

    default_options = { 'strip_comments': 1,
                        'skip_blanks':    1,
                        'lstrip_ws':      0,
                        'rstrip_ws':      1,
                        'join_lines':     0,
                        'collapse_join':  0,
                      }

    def __init__ (self, filename=None, file=None, **options):
        """Construct a new TextFile object.  At least one of 'filename'
           (a string) and 'file' (a file-like object) must be supplied.
           They keyword argument options are described above and affect
           the values returned by 'readline()'."""

        if filename is None and file is None:
            raise RuntimeError, \
                  "you must supply either or both of 'filename' and 'file'"

        # set values for all options -- either from client option hash
        # or fallback to default_options
        for opt in self.default_options.keys():
            if opt in options:
                setattr (self, opt, options[opt])

            else:
                setattr (self, opt, self.default_options[opt])

        # sanity check client option hash
        for opt in options.keys():
            if opt not in self.default_options:
                raise KeyError, "invalid TextFile option '%s'" % opt

        if file is None:
            self.open (filename)
        else:
            self.filename = filename
            self.file = file
            self.current_line = 0       # assuming that file is at BOF!

        # 'linebuf' is a stack of lines that will be emptied before we
        # actually read from the file; it's only populated by an
        # 'unreadline()' operation
        self.linebuf = []


    def open (self, filename):
        """Open a new file named 'filename'.  This overrides both the
           'filename' and 'file' arguments to the constructor."""

        self.filename = filename
        self.file = open (self.filename, 'r')
        self.current_line = 0


    def close (self):
        """Close the current file and forget everything we know about it
           (filename, current line number)."""
        file = self.file
        self.file = None
        self.filename = None
        self.current_line = None
        file.close()


    def gen_error (self, msg, line=None):
        outmsg = []
        if line is None:
            line = self.current_line
        outmsg.append(self.filename + ", ")
        if isinstance(line, (list, tuple)):
            outmsg.append("lines %d-%d: " % tuple (line))
        else:
            outmsg.append("line %d: " % line)
        outmsg.append(str(msg))
        return ''.join(outmsg)


    def error (self, msg, line=None):
        raise ValueError, "error: " + self.gen_error(msg, line)

    def warn (self, msg, line=None):
        """Print (to stderr) a warning message tied to the current logical
           line in the current file.  If the current logical line in the
           file spans multiple physical lines, the warning refers to the
           whole range, eg. "lines 3-5".  If 'line' supplied, it overrides
           the current line number; it may be a list or tuple to indicate a
           range of physical lines, or an integer for a single physical
           line."""
        sys.stderr.write("warning: " + self.gen_error(msg, line) + "\n")


    def readline (self):
        """Read and return a single logical line from the current file (or
           from an internal buffer if lines have previously been "unread"
           with 'unreadline()').  If the 'join_lines' option is true, this
           may involve reading multiple physical lines concatenated into a
           single string.  Updates the current line number, so calling
           'warn()' after 'readline()' emits a warning about the physical
           line(s) just read.  Returns None on end-of-file, since the empty
           string can occur if 'rstrip_ws' is true but 'strip_blanks' is
           not."""

        # If any "unread" lines waiting in 'linebuf', return the top
        # one.  (We don't actually buffer read-ahead data -- lines only
        # get put in 'linebuf' if the client explicitly does an
        # 'unreadline()'.
        if self.linebuf:
            line = self.linebuf[-1]
            del self.linebuf[-1]
            return line

        buildup_line = ''

        while 1:
            # read the line, make it None if EOF
            line = self.file.readline()
            if line == '': line = None

            if self.strip_comments and line:

                # Look for the first "#" in the line.  If none, never
                # mind.  If we find one and it's the first character, or
                # is not preceded by "\", then it starts a comment --
                # strip the comment, strip whitespace before it, and
                # carry on.  Otherwise, it's just an escaped "#", so
                # unescape it (and any other escaped "#"'s that might be
                # lurking in there) and otherwise leave the line alone.

                pos = line.find("#")
                if pos == -1:           # no "#" -- no comments
                    pass

                # It's definitely a comment -- either "#" is the first
                # character, or it's elsewhere and unescaped.
                elif pos == 0 or line[pos-1] != "\\":
                    # Have to preserve the trailing newline, because it's
                    # the job of a later step (rstrip_ws) to remove it --
                    # and if rstrip_ws is false, we'd better preserve it!
                    # (NB. this means that if the final line is all comment
                    # and has no trailing newline, we will think that it's
                    # EOF; I think that's OK.)
                    eol = (line[-1] == '\n') and '\n' or ''
                    line = line[0:pos] + eol

                    # If all that's left is whitespace, then skip line
                    # *now*, before we try to join it to 'buildup_line' --
                    # that way constructs like
                    #   hello \\
                    #   # comment that should be ignored
                    #   there
                    # result in "hello there".
                    if line.strip() == "":
                        continue

                else:                   # it's an escaped "#"
                    line = line.replace("\\#", "#")


            # did previous line end with a backslash? then accumulate
            if self.join_lines and buildup_line:
                # oops: end of file
                if line is None:
                    self.warn ("continuation line immediately precedes "
                               "end-of-file")
                    return buildup_line

                if self.collapse_join:
                    line = line.lstrip()
                line = buildup_line + line

                # careful: pay attention to line number when incrementing it
                if isinstance(self.current_line, list):
                    self.current_line[1] = self.current_line[1] + 1
                else:
                    self.current_line = [self.current_line,
                                         self.current_line+1]
            # just an ordinary line, read it as usual
            else:
                if line is None:        # eof
                    return None

                # still have to be careful about incrementing the line number!
                if isinstance(self.current_line, list):
                    self.current_line = self.current_line[1] + 1
                else:
                    self.current_line = self.current_line + 1


            # strip whitespace however the client wants (leading and
            # trailing, or one or the other, or neither)
            if self.lstrip_ws and self.rstrip_ws:
                line = line.strip()
            elif self.lstrip_ws:
                line = line.lstrip()
            elif self.rstrip_ws:
                line = line.rstrip()

            # blank line (whether we rstrip'ed or not)? skip to next line
            # if appropriate
            if (line == '' or line == '\n') and self.skip_blanks:
                continue

            if self.join_lines:
                if line[-1] == '\\':
                    buildup_line = line[:-1]
                    continue

                if line[-2:] == '\\\n':
                    buildup_line = line[0:-2] + '\n'
                    continue

            # well, I guess there's some actual content there: return it
            return line

    # readline ()


    def readlines (self):
        """Read and return the list of all logical lines remaining in the
           current file."""

        lines = []
        while 1:
            line = self.readline()
            if line is None:
                return lines
            lines.append (line)


    def unreadline (self, line):
        """Push 'line' (a string) onto an internal buffer that will be
           checked by future 'readline()' calls.  Handy for implementing
           a parser with line-at-a-time lookahead."""

        self.linebuf.append (line)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    """distutils.unixccompiler

Contains the UnixCCompiler class, a subclass of CCompiler that handles
the "typical" Unix-style command-line C compiler:
  * macros defined with -Dname[=value]
  * macros undefined with -Uname
  * include search directories specified with -Idir
  * libraries specified with -lllib
  * library search directories specified with -Ldir
  * compile handled by 'cc' (or similar) executable with -c option:
    compiles .c to .o
  * link static library handled by 'ar' command (possibly with 'ranlib')
  * link shared library handled by 'cc -shared'
"""

__revision__ = "$Id$"

import os, sys, re
from types import StringType, NoneType

from distutils import sysconfig
from distutils.dep_util import newer
from distutils.ccompiler import \
     CCompiler, gen_preprocess_options, gen_lib_options
from distutils.errors import \
     DistutilsExecError, CompileError, LibError, LinkError
from distutils import log

if sys.platform == 'darwin':
    import _osx_support

# XXX Things not currently handled:
#   * optimization/debug/warning flags; we just use whatever's in Python's
#     Makefile and live with it.  Is this adequate?  If not, we might
#     have to have a bunch of subclasses GNUCCompiler, SGICCompiler,
#     SunCCompiler, and I suspect down that road lies madness.
#   * even if we don't know a warning flag from an optimization flag,
#     we need some way for outsiders to feed preprocessor/compiler/linker
#     flags in to us -- eg. a sysadmin might want to mandate certain flags
#     via a site config file, or a user might want to set something for
#     compiling this module distribution only via the setup.py command
#     line, whatever.  As long as these options come from something on the
#     current system, they can be as system-dependent as they like, and we
#     should just happily stuff them into the preprocessor/compiler/linker
#     options and carry on.


class UnixCCompiler(CCompiler):

    compiler_type = 'unix'

    # These are used by CCompiler in two places: the constructor sets
    # instance attributes 'preprocessor', 'compiler', etc. from them, and
    # 'set_executable()' allows any of these to be set.  The defaults here
    # are pretty generic; they will probably have to be set by an outsider
    # (eg. using information discovered by the sysconfig about building
    # Python extensions).
    executables = {'preprocessor' : None,
                   'compiler'     : ["cc"],
                   'compiler_so'  : ["cc"],
                   'compiler_cxx' : ["cc"],
                   'linker_so'    : ["cc", "-shared"],
                   'linker_exe'   : ["cc"],
                   'archiver'     : ["ar", "-cr"],
                   'ranlib'       : None,
                  }

    if sys.platform[:6] == "darwin":
        executables['ranlib'] = ["ranlib"]

    # Needed for the filename generation methods provided by the base
    # class, CCompiler.  NB. whoever instantiates/uses a particular
    # UnixCCompiler instance should set 'shared_lib_ext' -- we set a
    # reasonable common default here, but it's not necessarily used on all
    # Unices!

    src_extensions = [".c",".C",".cc",".cxx",".cpp",".m"]
    obj_extension = ".o"
    static_lib_extension = ".a"
    shared_lib_extension = ".so"
    dylib_lib_extension = ".dylib"
    xcode_stub_lib_extension = ".tbd"
    static_lib_format = shared_lib_format = dylib_lib_format = "lib%s%s"
    xcode_stub_lib_format = dylib_lib_format
    if sys.platform == "cygwin":
        exe_extension = ".exe"

    def preprocess(self, source,
                   output_file=None, macros=None, include_dirs=None,
                   extra_preargs=None, extra_postargs=None):
        ignore, macros, include_dirs = \
            self._fix_compile_args(None, macros, include_dirs)
        pp_opts = gen_preprocess_options(macros, include_dirs)
        pp_args = self.preprocessor + pp_opts
        if output_file:
            pp_args.extend(['-o', output_file])
        if extra_preargs:
            pp_args[:0] = extra_preargs
        if extra_postargs:
            pp_args.extend(extra_postargs)
        pp_args.append(source)

        # We need to preprocess: either we're being forced to, or we're
        # generating output to stdout, or there's a target output file and
        # the source file is newer than the target (or the target doesn't
        # exist).
        if self.force or output_file is None or newer(source, output_file):
            if output_file:
                self.mkpath(os.path.dirname(output_file))
            try:
                self.spawn(pp_args)
            except DistutilsExecError, msg:
                raise CompileError, msg

    def _compile(self, obj, src, ext, cc_args, extra_postargs, pp_opts):
        compiler_so = self.compiler_so
        if sys.platform == 'darwin':
            compiler_so = _osx_support.compiler_fixup(compiler_so,
                                                    cc_args + extra_postargs)
        try:
            self.spawn(compiler_so + cc_args + [src, '-o', obj] +
                       extra_postargs)
        except DistutilsExecError, msg:
            raise CompileError, msg

    def create_static_lib(self, objects, output_libname,
                          output_dir=None, debug=0, target_lang=None):
        objects, output_dir = self._fix_object_args(objects, output_dir)

        output_filename = \
            self.library_filename(output_libname, output_dir=output_dir)

        if self._need_link(objects, output_filename):
            self.mkpath(os.path.dirname(output_filename))
            self.spawn(self.archiver +
                       [output_filename] +
                       objects + self.objects)

            # Not many Unices required ranlib anymore -- SunOS 4.x is, I
            # think the only major Unix that does.  Maybe we need some
            # platform intelligence here to skip ranlib if it's not
            # needed -- or maybe Python's configure script took care of
            # it for us, hence the check for leading colon.
            if self.ranlib:
                try:
                    self.spawn(self.ranlib + [output_filename])
                except DistutilsExecError, msg:
                    raise LibError, msg
        else:
            log.debug("skipping %s (up-to-date)", output_filename)

    def link(self, target_desc, objects,
             output_filename, output_dir=None, libraries=None,
             library_dirs=None, runtime_library_dirs=None,
             export_symbols=None, debug=0, extra_preargs=None,
             extra_postargs=None, build_temp=None, target_lang=None):
        objects, output_dir = self._fix_object_args(objects, output_dir)
        libraries, library_dirs, runtime_library_dirs = \
            self._fix_lib_args(libraries, library_dirs, runtime_library_dirs)
        # filter out standard library paths, which are not explicitely needed
        # for linking
        library_dirs = [dir for dir in library_dirs
                        if not dir in ('/lib', '/lib64', '/usr/lib', '/usr/lib64')]
        runtime_library_dirs = [dir for dir in runtime_library_dirs
                                if not dir in ('/lib', '/lib64', '/usr/lib', '/usr/lib64')]
        lib_opts = gen_lib_options(self, library_dirs, runtime_library_dirs,
                                   libraries)
        if type(output_dir) not in (StringType, NoneType):
            raise TypeError, "'output_dir' must be a string or None"
        if output_dir is not None:
            output_filename = os.path.join(output_dir, output_filename)

        if self._need_link(objects, output_filename):
            ld_args = (objects + self.objects +
                       lib_opts + ['-o', output_filename])
            if debug:
                ld_args[:0] = ['-g']
            if extra_preargs:
                ld_args[:0] = extra_preargs
            if extra_postargs:
                ld_args.extend(extra_postargs)
            self.mkpath(os.path.dirname(output_filename))
            try:
                if target_desc == CCompiler.EXECUTABLE:
                    linker = self.linker_exe[:]
                else:
                    linker = self.linker_so[:]
                if target_lang == "c++" and self.compiler_cxx:
                    # skip over environment variable settings if /usr/bin/env
                    # is used to set up the linker's environment.
                    # This is needed on OSX. Note: this assumes that the
                    # normal and C++ compiler have the same environment
                    # settings.
                    i = 0
                    if os.path.basename(linker[0]) == "env":
                        i = 1
                        while '=' in linker[i]:
                            i = i + 1

                    linker[i] = self.compiler_cxx[i]

                if sys.platform == 'darwin':
                    linker = _osx_support.compiler_fixup(linker, ld_args)

                self.spawn(linker + ld_args)
            except DistutilsExecError, msg:
                raise LinkError, msg
        else:
            log.debug("skipping %s (up-to-date)", output_filename)

    # -- Miscellaneous methods -----------------------------------------
    # These are all used by the 'gen_lib_options() function, in
    # ccompiler.py.

    def library_dir_option(self, dir):
        return "-L" + dir

    def _is_gcc(self, compiler_name):
        return "gcc" in compiler_name or "g++" in compiler_name

    def runtime_library_dir_option(self, dir):
        # XXX Hackish, at the very least.  See Python bug #445902:
        # http://sourceforge.net/tracker/index.php
        #   ?func=detail&aid=445902&group_id=5470&atid=105470
        # Linkers on different platforms need different options to
        # specify that directories need to be added to the list of
        # directories searched for dependencies when a dynamic library
        # is sought.  GCC has to be told to pass the -R option through
        # to the linker, whereas other compilers just know this.
        # Other compilers may need something slightly different.  At
        # this time, there's no way to determine this information from
        # the configuration data stored in the Python installation, so
        # we use this hack.
        compiler = os.path.basename(sysconfig.get_config_var("CC"))
        if sys.platform[:6] == "darwin":
            # MacOSX's linker doesn't understand the -R flag at all
            return "-L" + dir
        elif sys.platform[:7] == "freebsd":
            return "-Wl,-rpath=" + dir
        elif sys.platform[:5] == "hp-ux":
            if self._is_gcc(compiler):
                return ["-Wl,+s", "-L" + dir]
            return ["+s", "-L" + dir]
        elif sys.platform[:7] == "irix646" or sys.platform[:6] == "osf1V5":
            return ["-rpath", dir]
        elif self._is_gcc(compiler):
            return "-Wl,-R" + dir
        else:
            return "-R" + dir

    def library_option(self, lib):
        return "-l" + lib

    def find_library_file(self, dirs, lib, debug=0):
        shared_f = self.library_filename(lib, lib_type='shared')
        dylib_f = self.library_filename(lib, lib_type='dylib')
        xcode_stub_f = self.library_filename(lib, lib_type='xcode_stub')
        static_f = self.library_filename(lib, lib_type='static')

        if sys.platform == 'darwin':
            # On OSX users can specify an alternate SDK using
            # '-isysroot', calculate the SDK root if it is specified
            # (and use it further on)
            #
            # Note that, as of Xcode 7, Apple SDKs may contain textual stub
            # libraries with .tbd extensions rather than the normal .dylib
            # shared libraries installed in /.  The Apple compiler tool
            # chain handles this transparently but it can cause problems
            # for programs that are being built with an SDK and searching
            # for specific libraries.  Callers of find_library_file need to
            # keep in mind that the base filename of the returned SDK library
            # file might have a different extension from that of the library
            # file installed on the running system, for example:
            #   /Applications/Xcode.app/Contents/Developer/Platforms/
            #       MacOSX.platform/Developer/SDKs/MacOSX10.11.sdk/
            #       usr/lib/libedit.tbd
            # vs
            #   /usr/lib/libedit.dylib
            cflags = sysconfig.get_config_var('CFLAGS')
            m = re.search(r'-isysroot\s+(\S+)', cflags)
            if m is None:
                sysroot = '/'
            else:
                sysroot = m.group(1)



        for dir in dirs:
            shared = os.path.join(dir, shared_f)
            dylib = os.path.join(dir, dylib_f)
            static = os.path.join(dir, static_f)
            xcode_stub = os.path.join(dir, xcode_stub_f)

            if sys.platform == 'darwin' and (
                dir.startswith('/System/') or (
                dir.startswith('/usr/') and not dir.startswith('/usr/local/'))):

                shared = os.path.join(sysroot, dir[1:], shared_f)
                dylib = os.path.join(sysroot, dir[1:], dylib_f)
                static = os.path.join(sysroot, dir[1:], static_f)
                xcode_stub = os.path.join(sysroot, dir[1:], xcode_stub_f)

            # We're second-guessing the linker here, with not much hard
            # data to go on: GCC seems to prefer the shared library, so I'm
            # assuming that *all* Unix C compilers do.  And of course I'm
            # ignoring even GCC's "-static" option.  So sue me.
            if os.path.exists(dylib):
                return dylib
            elif os.path.exists(xcode_stub):
                return xcode_stub
            elif os.path.exists(shared):
                return shared
            elif os.path.exists(static):
                return static

        # Oops, didn't find it in *any* of 'dirs'
        return None
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        Û
”´[c           @   sÏ   d  Z  d Z d d l Z d d l Z d d l Z d d l m Z m Z d d l m	 Z	 d d l
 m Z d d l m Z m Z m Z d d l m Z m Z m Z m Z d d	 l m Z e j d
 k r“ d d l Z n  d e f d Ñ  É  YZ d S(   s9  distutils.unixccompiler

Contains the UnixCCompiler class, a subclass of CCompiler that handles
the "typical" Unix-style command-line C compiler:
  * macros defined with -Dname[=value]
  * macros undefined with -Uname
  * include search directories specified with -Idir
  * libraries specified with -lllib
  * library search directories specified with -Ldir
  * compile handled by 'cc' (or similar) executable with -c option:
    compiles .c to .o
  * link static library handled by 'ar' command (possibly with 'ranlib')
  * link shared library handled by 'cc -shared'
s   $Id$iˇˇˇˇN(   t
   StringTypet   NoneType(   t	   sysconfig(   t   newer(   t	   CCompilert   gen_preprocess_optionst   gen_lib_options(   t   DistutilsExecErrort   CompileErrort   LibErrort	   LinkError(   t   logt   darwint   UnixCCompilerc           B   ss  e  Z d  Z i d' d 6d g d 6d g d 6d g d 6d d g d 6d g d 6d	 d
 g d 6d' d 6Z e j d  d k rÖ d g e d <n  d d d d d d g Z d Z d Z	 d Z
 d Z d Z d Z Z Z e Z e j d k rÁ d Z n  d' d' d' d' d' d Ñ Z d Ñ  Z d' d d' d  Ñ Z d' d' d' d' d' d d' d' d' d' d! Ñ
 Z d" Ñ  Z d# Ñ  Z d$ Ñ  Z d% Ñ  Z d d& Ñ Z RS((   t   unixt   preprocessort   cct   compilert   compiler_sot   compiler_cxxs   -sharedt	   linker_sot
   linker_exet   ars   -crt   archivert   ranlibi   R   s   .cs   .Cs   .ccs   .cxxs   .cpps   .ms   .os   .as   .sos   .dylibs   .tbds   lib%s%st   cygwins   .exec         C   s	  |  j  d  | | É \ } } } t | | É } |  j | }	 | rV |	 j d | g É n  | ri | |	 d *n  | r |	 j | É n  |	 j | É |  j s∞ | d  k s∞ t | | É r| r“ |  j t	 j
 j | É É n  y |  j |	 É Wqt k
 r}
 t |
 Ç qXn  d  S(   Ns   -oi    (   t   _fix_compile_argst   NoneR   R   t   extendt   appendt   forceR   t   mkpatht   ost   patht   dirnamet   spawnR   R   (   t   selft   sourcet   output_filet   macrost   include_dirst   extra_preargst   extra_postargst   ignoret   pp_optst   pp_argst   msg(    (    s-   /usr/lib/python2.7/distutils/unixccompiler.pyt
   preprocessX   s"    $c   	      C   sz   |  j  } t j d k r1 t j | | | É } n  y& |  j | | | d | g | É Wn t k
 ru } t | Ç n Xd  S(   NR   s   -o(   R   t   syst   platformt   _osx_supportt   compiler_fixupR#   R   R   (	   R$   t   objt   srct   extt   cc_argsR*   R,   R   R.   (    (    s-   /usr/lib/python2.7/distutils/unixccompiler.pyt   _compiles   s    		i    c         C   s◊   |  j  | | É \ } } |  j | d | É} |  j | | É r√ |  j t j j | É É |  j |  j | g | |  j	 É |  j
 r” y |  j |  j
 | g É Wq¿ t k
 rº } t | Ç q¿ Xq” n t j d | É d  S(   Nt
   output_dirs   skipping %s (up-to-date)(   t   _fix_object_argst   library_filenamet
   _need_linkR   R    R!   R"   R#   R   t   objectsR   R   R	   R   t   debug(   R$   R=   t   output_libnameR9   R>   t   target_langt   output_filenameR.   (    (    s-   /usr/lib/python2.7/distutils/unixccompiler.pyt   create_static_lib~   s    	c         C   sl  |  j  | | É \ } } |  j | | | É \ } } } g  | D] } | d k r= | ^ q= } g  | D] } | d k rb | ^ qb } t |  | | | É } t | É t t f k rπ t d Ç n  | d  k	 r› t j	 j
 | | É } n  |  j | | É rX| |  j | d | g } |	 r d g | d *n  |
 r3|
 | d *n  | rI| j | É n  |  j t j	 j | É É y‘ | t j k rÅ|  j } n
 |  j } | d	 k r |  j r d } t j	 j | d É d
 k rÏd } x! d | | k rË| d } qÀWn  |  j | | | <n  t j d k r$t j | | É } n  |  j | | É Wqht k
 rT} t | Ç qhXn t j d | É d  S(   Ns   /libs   /lib64s   /usr/libs
   /usr/lib64s%   'output_dir' must be a string or Nones   -os   -gi    s   c++t   envi   t   =R   s   skipping %s (up-to-date)(   s   /libs   /lib64s   /usr/libs
   /usr/lib64(   s   /libs   /lib64s   /usr/libs
   /usr/lib64(   R:   t   _fix_lib_argsR   t   typeR    R   t	   TypeErrorR   R    R!   t   joinR<   R=   R   R   R"   R   t
   EXECUTABLER   R   R   t   basenameR0   R1   R2   R3   R#   R   R
   R   R>   (   R$   t   target_descR=   RA   R9   t	   librariest   library_dirst   runtime_library_dirst   export_symbolsR>   R)   R*   t
   build_tempR@   t   dirt   lib_optst   ld_argst   linkert   iR.   (    (    s-   /usr/lib/python2.7/distutils/unixccompiler.pyt   linkò   sL    	
c         C   s   d | S(   Ns   -L(    (   R$   RQ   (    (    s-   /usr/lib/python2.7/distutils/unixccompiler.pyt   library_dir_option◊   s    c         C   s   d | k p d | k S(   Nt   gccs   g++(    (   R$   t   compiler_name(    (    s-   /usr/lib/python2.7/distutils/unixccompiler.pyt   _is_gcc⁄   s    c         C   s‚   t  j j t j d É É } t j d  d k r6 d | St j d  d k rQ d | St j d  d	 k rè |  j | É rÅ d
 d | g Sd d | g St j d  d k sµ t j d  d k rø d | g S|  j | É r÷ d | Sd | Sd  S(   Nt   CCi   R   s   -Li   t   freebsds   -Wl,-rpath=i   s   hp-uxs   -Wl,+ss   +st   irix646t   osf1V5s   -rpaths   -Wl,-Rs   -R(   R    R!   RJ   R   t   get_config_varR0   R1   RZ   (   R$   RQ   R   (    (    s-   /usr/lib/python2.7/distutils/unixccompiler.pyt   runtime_library_dir_option›   s    &
c         C   s   d | S(   Ns   -l(    (   R$   t   lib(    (    s-   /usr/lib/python2.7/distutils/unixccompiler.pyt   library_option˚   s    c         C   s  |  j  | d d É} |  j  | d d É} |  j  | d d É} |  j  | d d É} t j d k r´ t j d É } t j d | É }	 |	 d  k rô d	 }
 q´ |	 j d
 É }
 n  xj| D]b} t	 j
 j | | É } t	 j
 j | | É } t	 j
 j | | É } t	 j
 j | | É } t j d k rº| j d É sI| j d É rº| j d É rºt	 j
 j |
 | d
 | É } t	 j
 j |
 | d
 | É } t	 j
 j |
 | d
 | É } t	 j
 j |
 | d
 | É } n  t	 j
 j | É r“| St	 j
 j | É rË| St	 j
 j | É r˛| St	 j
 j | É r≤ | Sq≤ Wd  S(   Nt   lib_typet   sharedt   dylibt
   xcode_stubt   staticR   t   CFLAGSs   -isysroot\s+(\S+)t   /i   s   /System/s   /usr/s   /usr/local/(   R;   R0   R1   R   R_   t   ret   searchR   t   groupR    R!   RH   t
   startswitht   exists(   R$   t   dirsRa   R>   t   shared_ft   dylib_ft   xcode_stub_ft   static_ft   cflagst   mt   sysrootRQ   Rd   Re   Rg   Rf   (    (    s-   /usr/lib/python2.7/distutils/unixccompiler.pyt   find_library_file˛   s>    	N(   t   __name__t
   __module__t   compiler_typeR   t   executablesR0   R1   t   src_extensionst   obj_extensiont   static_lib_extensiont   shared_lib_extensiont   dylib_lib_extensiont   xcode_stub_lib_extensiont   static_lib_formatt   shared_lib_formatt   dylib_lib_formatt   xcode_stub_lib_formatt   exe_extensionR/   R8   RB   RV   RW   RZ   R`   Rb   Rw   (    (    (    s-   /usr/lib/python2.7/distutils/unixccompiler.pyR   0   sD   





				;				(   t   __doc__t   __revision__R    R0   Rj   t   typesR    R   t	   distutilsR   t   distutils.dep_utilR   t   distutils.ccompilerR   R   R   t   distutils.errorsR   R   R	   R
   R   R1   R2   R   (    (    (    s-   /usr/lib/python2.7/distutils/unixccompiler.pyt   <module>   s   $"                                                                                                 """distutils.util

Miscellaneous utility functions -- anything that doesn't fit into
one of the other *util.py modules.
"""

__revision__ = "$Id$"

import sys, os, string, re
from distutils.errors import DistutilsPlatformError
from distutils.dep_util import newer
from distutils.spawn import spawn
from distutils import log
from distutils.errors import DistutilsByteCompileError

def get_platform ():
    """Return a string that identifies the current platform.  This is used
    mainly to distinguish platform-specific build directories and
    platform-specific built distributions.  Typically includes the OS name
    and version and the architecture (as supplied by 'os.uname()'),
    although the exact information included depends on the OS; eg. for IRIX
    the architecture isn't particularly important (IRIX only runs on SGI
    hardware), but for Linux the kernel version isn't particularly
    important.

    Examples of returned values:
       linux-i586
       linux-alpha (?)
       solaris-2.6-sun4u
       irix-5.3
       irix64-6.2

    Windows will return one of:
       win-amd64 (64bit Windows on AMD64 (aka x86_64, Intel64, EM64T, etc)
       win-ia64 (64bit Windows on Itanium)
       win32 (all others - specifically, sys.platform is returned)

    For other non-POSIX platforms, currently just returns 'sys.platform'.
    """
    if os.name == 'nt':
        # sniff sys.version for architecture.
        prefix = " bit ("
        i = string.find(sys.version, prefix)
        if i == -1:
            return sys.platform
        j = string.find(sys.version, ")", i)
        look = sys.version[i+len(prefix):j].lower()
        if look=='amd64':
            return 'win-amd64'
        if look=='itanium':
            return 'win-ia64'
        return sys.platform

    # Set for cross builds explicitly
    if "_PYTHON_HOST_PLATFORM" in os.environ:
        return os.environ["_PYTHON_HOST_PLATFORM"]

    if os.name != "posix" or not hasattr(os, 'uname'):
        # XXX what about the architecture? NT is Intel or Alpha,
        # Mac OS is M68k or PPC, etc.
        return sys.platform

    # Try to distinguish various flavours of Unix

    (osname, host, release, version, machine) = os.uname()

    # Convert the OS name to lowercase, remove '/' characters
    # (to accommodate BSD/OS), and translate spaces (for "Power Macintosh")
    osname = string.lower(osname)
    osname = string.replace(osname, '/', '')
    machine = string.replace(machine, ' ', '_')
    machine = string.replace(machine, '/', '-')

    if osname[:5] == "linux":
        # At least on Linux/Intel, 'machine' is the processor --
        # i386, etc.
        # XXX what about Alpha, SPARC, etc?
        return  "%s-%s" % (osname, machine)
    elif osname[:5] == "sunos":
        if release[0] >= "5":           # SunOS 5 == Solaris 2
            osname = "solaris"
            release = "%d.%s" % (int(release[0]) - 3, release[2:])
            # We can't use "platform.architecture()[0]" because a
            # bootstrap problem. We use a dict to get an error
            # if some suspicious happens.
            bitness = {2147483647:"32bit", 9223372036854775807:"64bit"}
            machine += ".%s" % bitness[sys.maxint]
        # fall through to standard osname-release-machine representation
    elif osname[:4] == "irix":              # could be "irix64"!
        return "%s-%s" % (osname, release)
    elif osname[:3] == "aix":
        return "%s-%s.%s" % (osname, version, release)
    elif osname[:6] == "cygwin":
        osname = "cygwin"
        rel_re = re.compile (r'[\d.]+')
        m = rel_re.match(release)
        if m:
            release = m.group()
    elif osname[:6] == "darwin":
        import _osx_support, distutils.sysconfig
        osname, release, machine = _osx_support.get_platform_osx(
                                        distutils.sysconfig.get_config_vars(),
                                        osname, release, machine)

    return "%s-%s-%s" % (osname, release, machine)

# get_platform ()


def convert_path (pathname):
    """Return 'pathname' as a name that will work on the native filesystem,
    i.e. split it on '/' and put it back together again using the current
    directory separator.  Needed because filenames in the setup script are
    always supplied in Unix style, and have to be converted to the local
    convention before we can actually use them in the filesystem.  Raises
    ValueError on non-Unix-ish systems if 'pathname' either starts or
    ends with a slash.
    """
    if os.sep == '/':
        return pathname
    if not pathname:
        return pathname
    if pathname[0] == '/':
        raise ValueError, "path '%s' cannot be absolute" % pathname
    if pathname[-1] == '/':
        raise ValueError, "path '%s' cannot end with '/'" % pathname

    paths = string.split(pathname, '/')
    while '.' in paths:
        paths.remove('.')
    if not paths:
        return os.curdir
    return os.path.join(*paths)

# convert_path ()


def change_root (new_root, pathname):
    """Return 'pathname' with 'new_root' prepended.  If 'pathname' is
    relative, this is equivalent to "os.path.join(new_root,pathname)".
    Otherwise, it requires making 'pathname' relative and then joining the
    two, which is tricky on DOS/Windows and Mac OS.
    """
    if os.name == 'posix':
        if not os.path.isabs(pathname):
            return os.path.join(new_root, pathname)
        else:
            return os.path.join(new_root, pathname[1:])

    elif os.name == 'nt':
        (drive, path) = os.path.splitdrive(pathname)
        if path[0] == '\\':
            path = path[1:]
        return os.path.join(new_root, path)

    elif os.name == 'os2':
        (drive, path) = os.path.splitdrive(pathname)
        if path[0] == os.sep:
            path = path[1:]
        return os.path.join(new_root, path)

    else:
        raise DistutilsPlatformError, \
              "nothing known about platform '%s'" % os.name


_environ_checked = 0
def check_environ ():
    """Ensure that 'os.environ' has all the environment variables we
    guarantee that users can use in config files, command-line options,
    etc.  Currently this includes:
      HOME - user's home directory (Unix only)
      PLAT - description of the current platform, including hardware
             and OS (see 'get_platform()')
    """
    global _environ_checked
    if _environ_checked:
        return

    if os.name == 'posix' and 'HOME' not in os.environ:
        import pwd
        os.environ['HOME'] = pwd.getpwuid(os.getuid())[5]

    if 'PLAT' not in os.environ:
        os.environ['PLAT'] = get_platform()

    _environ_checked = 1


def subst_vars (s, local_vars):
    """Perform shell/Perl-style variable substitution on 'string'.  Every
    occurrence of '$' followed by a name is considered a variable, and
    variable is substituted by the value found in the 'local_vars'
    dictionary, or in 'os.environ' if it's not in 'local_vars'.
    'os.environ' is first checked/augmented to guarantee that it contains
    certain values: see 'check_environ()'.  Raise ValueError for any
    variables not found in either 'local_vars' or 'os.environ'.
    """
    check_environ()
    def _subst (match, local_vars=local_vars):
        var_name = match.group(1)
        if var_name in local_vars:
            return str(local_vars[var_name])
        else:
            return os.environ[var_name]

    try:
        return re.sub(r'\$([a-zA-Z_][a-zA-Z_0-9]*)', _subst, s)
    except KeyError, var:
        raise ValueError, "invalid variable '$%s'" % var

# subst_vars ()


def grok_environment_error (exc, prefix="error: "):
    # Function kept for backward compatibility.
    # Used to try clever things with EnvironmentErrors,
    # but nowadays str(exception) produces good messages.
    return prefix + str(exc)


# Needed by 'split_quoted()'
_wordchars_re = _squote_re = _dquote_re = None
def _init_regex():
    global _wordchars_re, _squote_re, _dquote_re
    _wordchars_re = re.compile(r'[^\\\'\"%s ]*' % string.whitespace)
    _squote_re = re.compile(r"'(?:[^'\\]|\\.)*'")
    _dquote_re = re.compile(r'"(?:[^"\\]|\\.)*"')

def split_quoted (s):
    """Split a string up according to Unix shell-like rules for quotes and
    backslashes.  In short: words are delimited by spaces, as long as those
    spaces are not escaped by a backslash, or inside a quoted string.
    Single and double quotes are equivalent, and the quote characters can
    be backslash-escaped.  The backslash is stripped from any two-character
    escape sequence, leaving only the escaped character.  The quote
    characters are stripped from any quoted string.  Returns a list of
    words.
    """

    # This is a nice algorithm for splitting up a single string, since it
    # doesn't require character-by-character examination.  It was a little
    # bit of a brain-bender to get it working right, though...
    if _wordchars_re is None: _init_regex()

    s = string.strip(s)
    words = []
    pos = 0

    while s:
        m = _wordchars_re.match(s, pos)
        end = m.end()
        if end == len(s):
            words.append(s[:end])
            break

        if s[end] in string.whitespace: # unescaped, unquoted whitespace: now
            words.append(s[:end])       # we definitely have a word delimiter
            s = string.lstrip(s[end:])
            pos = 0

        elif s[end] == '\\':            # preserve whatever is being escaped;
                                        # will become part of the current word
            s = s[:end] + s[end+1:]
            pos = end+1

        else:
            if s[end] == "'":           # slurp singly-quoted string
                m = _squote_re.match(s, end)
            elif s[end] == '"':         # slurp doubly-quoted string
                m = _dquote_re.match(s, end)
            else:
                raise RuntimeError, \
                      "this can't happen (bad char '%c')" % s[end]

            if m is None:
                raise ValueError, \
                      "bad string (mismatched %s quotes?)" % s[end]

            (beg, end) = m.span()
            s = s[:beg] + s[beg+1:end-1] + s[end:]
            pos = m.end() - 2

        if pos >= len(s):
            words.append(s)
            break

    return words

# split_quoted ()


def execute (func, args, msg=None, verbose=0, dry_run=0):
    """Perform some action that affects the outside world (eg.  by
    writing to the filesystem).  Such actions are special because they
    are disabled by the 'dry_run' flag.  This method takes care of all
    that bureaucracy for you; all you have to do is supply the
    function to call and an argument tuple for it (to embody the
    "external action" being performed), and an optional message to
    print.
    """
    if msg is None:
        msg = "%s%r" % (func.__name__, args)
        if msg[-2:] == ',)':        # correct for singleton tuple
            msg = msg[0:-2] + ')'

    log.info(msg)
    if not dry_run:
        func(*args)


def strtobool (val):
    """Convert a string representation of truth to true (1) or false (0).

    True values are 'y', 'yes', 't', 'true', 'on', and '1'; false values
    are 'n', 'no', 'f', 'false', 'off', and '0'.  Raises ValueError if
    'val' is anything else.
    """
    val = string.lower(val)
    if val in ('y', 'yes', 't', 'true', 'on', '1'):
        return 1
    elif val in ('n', 'no', 'f', 'false', 'off', '0'):
        return 0
    else:
        raise ValueError, "invalid truth value %r" % (val,)


def byte_compile (py_files,
                  optimize=0, force=0,
                  prefix=None, base_dir=None,
                  verbose=1, dry_run=0,
                  direct=None):
    """Byte-compile a collection of Python source files to either .pyc
    or .pyo files in the same directory.  'py_files' is a list of files
    to compile; any files that don't end in ".py" are silently skipped.
    'optimize' must be one of the following:
      0 - don't optimize (generate .pyc)
      1 - normal optimization (like "python -O")
      2 - extra optimization (like "python -OO")
    If 'force' is true, all files are recompiled regardless of
    timestamps.

    The source filename encoded in each bytecode file defaults to the
    filenames listed in 'py_files'; you can modify these with 'prefix' and
    'basedir'.  'prefix' is a string that will be stripped off of each
    source filename, and 'base_dir' is a directory name that will be
    prepended (after 'prefix' is stripped).  You can supply either or both
    (or neither) of 'prefix' and 'base_dir', as you wish.

    If 'dry_run' is true, doesn't actually do anything that would
    affect the filesystem.

    Byte-compilation is either done directly in this interpreter process
    with the standard py_compile module, or indirectly by writing a
    temporary script and executing it.  Normally, you should let
    'byte_compile()' figure out to use direct compilation or not (see
    the source for details).  The 'direct' flag is used by the script
    generated in indirect mode; unless you know what you're doing, leave
    it set to None.
    """
    # nothing is done if sys.dont_write_bytecode is True
    if sys.dont_write_bytecode:
        raise DistutilsByteCompileError('byte-compiling is disabled.')

    # First, if the caller didn't force us into direct or indirect mode,
    # figure out which mode we should be in.  We take a conservative
    # approach: choose direct mode *only* if the current interpreter is
    # in debug mode and optimize is 0.  If we're not in debug mode (-O
    # or -OO), we don't know which level of optimization this
    # interpreter is running with, so we can't do direct
    # byte-compilation and be certain that it's the right thing.  Thus,
    # always compile indirectly if the current interpreter is in either
    # optimize mode, or if either optimization level was requested by
    # the caller.
    if direct is None:
        direct = (__debug__ and optimize == 0)

    # "Indirect" byte-compilation: write a temporary script and then
    # run it with the appropriate flags.
    if not direct:
        try:
            from tempfile import mkstemp
            (script_fd, script_name) = mkstemp(".py")
        except ImportError:
            from tempfile import mktemp
            (script_fd, script_name) = None, mktemp(".py")
        log.info("writing byte-compilation script '%s'", script_name)
        if not dry_run:
            if script_fd is not None:
                script = os.fdopen(script_fd, "w")
            else:
                script = open(script_name, "w")

            script.write("""\
from distutils.util import byte_compile
files = [
""")

            # XXX would be nice to write absolute filenames, just for
            # safety's sake (script should be more robust in the face of
            # chdir'ing before running it).  But this requires abspath'ing
            # 'prefix' as well, and that breaks the hack in build_lib's
            # 'byte_compile()' method that carefully tacks on a trailing
            # slash (os.sep really) to make sure the prefix here is "just
            # right".  This whole prefix business is rather delicate -- the
            # problem is that it's really a directory, but I'm treating it
            # as a dumb string, so trailing slashes and so forth matter.

            #py_files = map(os.path.abspath, py_files)
            #if prefix:
            #    prefix = os.path.abspath(prefix)

            script.write(string.join(map(repr, py_files), ",\n") + "]\n")
            script.write("""
byte_compile(files, optimize=%r, force=%r,
             prefix=%r, base_dir=%r,
             verbose=%r, dry_run=0,
             direct=1)
""" % (optimize, force, prefix, base_dir, verbose))

            script.close()

        cmd = [sys.executable, script_name]
        if optimize == 1:
            cmd.insert(1, "-O")
        elif optimize == 2:
            cmd.insert(1, "-OO")
        spawn(cmd, dry_run=dry_run)
        execute(os.remove, (script_name,), "removing %s" % script_name,
                dry_run=dry_run)

    # "Direct" byte-compilation: use the py_compile module to compile
    # right here, right now.  Note that the script generated in indirect
    # mode simply calls 'byte_compile()' in direct mode, a weird sort of
    # cross-process recursion.  Hey, it works!
    else:
        from py_compile import compile

        for file in py_files:
            if file[-3:] != ".py":
                # This lets us be lazy and not filter filenames in
                # the "install_lib" command.
                continue

            # Terminology from the py_compile module:
            #   cfile - byte-compiled file
            #   dfile - purported source filename (same as 'file' by default)
            cfile = file + (__debug__ and "c" or "o")
            dfile = file
            if prefix:
                if file[:len(prefix)] != prefix:
                    raise ValueError, \
                          ("invalid prefix: filename %r doesn't start with %r"
                           % (file, prefix))
                dfile = dfile[len(prefix):]
            if base_dir:
                dfile = os.path.join(base_dir, dfile)

            cfile_base = os.path.basename(cfile)
            if direct:
                if force or newer(file, cfile):
                    log.info("byte-compiling %s to %s", file, cfile_base)
                    if not dry_run:
                        compile(file, cfile, dfile)
                else:
                    log.debug("skipping byte-compilation of %s to %s",
                              file, cfile_base)

# byte_compile ()

def rfc822_escape (header):
    """Return a version of the string escaped for inclusion in an
    RFC-822 header, by ensuring there are 8 spaces space after each newline.
    """
    lines = string.split(header, '\n')
    header = string.join(lines, '\n' + 8*' ')
    return header
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           """distutils.command

Package containing implementation of all the standard Distutils
commands."""

__revision__ = "$Id$"

__all__ = ['build',
           'build_py',
           'build_ext',
           'build_clib',
           'build_scripts',
           'clean',
           'install',
           'install_lib',
           'install_headers',
           'install_scripts',
           'install_data',
           'sdist',
           'register',
           'bdist',
           'bdist_dumb',
           'bdist_rpm',
           'bdist_wininst',
           'upload',
           'check',
           # These two are reserved for future use:
           #'bdist_sdux',
           #'bdist_pkgtool',
           # Note:
           # bdist_packager is not included because it only provides
           # an abstract base class
          ]
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          Û
”´[c           @   s1  d  Z  d Z d d l Z d d l Z d d l Z d d l Z d d l m Z d d l m	 Z	 d d l
 m Z d d l m Z d d l m Z d	 Ñ  Z d
 Ñ  Z d Ñ  Z d a d Ñ  Z d Ñ  Z d d Ñ Z d a a a d Ñ  Z d Ñ  Z d d d d Ñ Z d Ñ  Z d d d d d d d d Ñ Z d Ñ  Z d S(   su   distutils.util

Miscellaneous utility functions -- anything that doesn't fit into
one of the other *util.py modules.
s   $Id$iˇˇˇˇN(   t   DistutilsPlatformError(   t   newer(   t   spawn(   t   log(   t   DistutilsByteCompileErrorc          C   sÀ  t  j d k rú d }  t j t j |  É } | d k r= t j St j t j d | É } t j | t |  É | !j É  } | d k rÖ d S| d k rï d St j Sd	 t  j	 k r∂ t  j	 d	 St  j d
 k s’ t
 t  d É r‹ t j St  j É  \ } } } } } t j | É } t j | d d É } t j | d d É } t j | d d É } | d  d k rcd | | f S| d  d k r⁄| d d k r∫d } d t | d É d | d f } i d d 6d d 6}	 | d |	 t j 7} q∫n‡ | d   d! k r¯d | | f S| d  d" k rd# | | | f S| d$  d% k red% } t j d& É }
 |
 j | É } | r∫| j É  } q∫nU | d$  d' k r∫d d( l } d d( l } | j | j j É  | | | É \ } } } n  d) | | | f S(*   s´  Return a string that identifies the current platform.  This is used
    mainly to distinguish platform-specific build directories and
    platform-specific built distributions.  Typically includes the OS name
    and version and the architecture (as supplied by 'os.uname()'),
    although the exact information included depends on the OS; eg. for IRIX
    the architecture isn't particularly important (IRIX only runs on SGI
    hardware), but for Linux the kernel version isn't particularly
    important.

    Examples of returned values:
       linux-i586
       linux-alpha (?)
       solaris-2.6-sun4u
       irix-5.3
       irix64-6.2

    Windows will return one of:
       win-amd64 (64bit Windows on AMD64 (aka x86_64, Intel64, EM64T, etc)
       win-ia64 (64bit Windows on Itanium)
       win32 (all others - specifically, sys.platform is returned)

    For other non-POSIX platforms, currently just returns 'sys.platform'.
    t   nts    bit (iˇˇˇˇt   )t   amd64s	   win-amd64t   itaniums   win-ia64t   _PYTHON_HOST_PLATFORMt   posixt   unamet   /t    t    t   _t   -i   t   linuxs   %s-%st   sunosi    t   5t   solariss   %d.%si   i   t   32bitiˇˇˇt   64bitl   ˇˇˇˇ s   .%si   t   irixt   aixs   %s-%s.%si   t   cygwins   [\d.]+t   darwinNs   %s-%s-%s(   t   ost   namet   stringt   findt   syst   versiont   platformt   lent   lowert   environt   hasattrR   t   replacet   intt   maxintt   ret   compilet   matcht   groupt   _osx_supportt   distutils.sysconfigt   get_platform_osxt	   sysconfigt   get_config_vars(   t   prefixt   it   jt   lookt   osnamet   hostt   releaseR    t   machinet   bitnesst   rel_ret   mR-   t	   distutils(    (    s$   /usr/lib/python2.7/distutils/util.pyt   get_platform   sZ     "c         C   s¨   t  j d k r |  S|  s |  S|  d d k r= t d |  Ç n  |  d d k r] t d |  Ç n  t j |  d É } x d | k ré | j d É qr W| sú t  j St  j j | å  S(   sŒ  Return 'pathname' as a name that will work on the native filesystem,
    i.e. split it on '/' and put it back together again using the current
    directory separator.  Needed because filenames in the setup script are
    always supplied in Unix style, and have to be converted to the local
    convention before we can actually use them in the filesystem.  Raises
    ValueError on non-Unix-ish systems if 'pathname' either starts or
    ends with a slash.
    R   i    s   path '%s' cannot be absoluteiˇˇˇˇs   path '%s' cannot end with '/'t   .(	   R   t   sept
   ValueErrorR   t   splitt   removet   curdirt   patht   join(   t   pathnamet   paths(    (    s$   /usr/lib/python2.7/distutils/util.pyt   convert_pathn   s    	c         C   s  t  j d k rN t  j j | É s4 t  j j |  | É St  j j |  | d É Sn¡ t  j d k r• t  j j | É \ } } | d d k rí | d } n  t  j j |  | É St  j d k rˇ t  j j | É \ } } | d t  j k rÏ | d } n  t  j j |  | É St d t  j Ç d S(	   s	  Return 'pathname' with 'new_root' prepended.  If 'pathname' is
    relative, this is equivalent to "os.path.join(new_root,pathname)".
    Otherwise, it requires making 'pathname' relative and then joining the
    two, which is tricky on DOS/Windows and Mac OS.
    R
   i   R   i    s   \t   os2s!   nothing known about platform '%s'N(   R   R   RE   t   isabsRF   t
   splitdriveR@   R    (   t   new_rootRG   t   driveRE   (    (    s$   /usr/lib/python2.7/distutils/util.pyt   change_rootä   s     i    c          C   sÉ   t  r
 d St j d k rW d t j k rW d d l }  |  j t j É  É d t j d <n  d t j k ry t É  t j d <n  d a  d S(   sL  Ensure that 'os.environ' has all the environment variables we
    guarantee that users can use in config files, command-line options,
    etc.  Currently this includes:
      HOME - user's home directory (Unix only)
      PLAT - description of the current platform, including hardware
             and OS (see 'get_platform()')
    NR
   t   HOMEiˇˇˇˇi   t   PLATi   (   t   _environ_checkedR   R   R$   t   pwdt   getpwuidt   getuidR>   (   RS   (    (    s$   /usr/lib/python2.7/distutils/util.pyt   check_environ®   s    	#c         C   sQ   t  É  | d Ñ } y t j d | |  É SWn  t k
 rL } t d | Ç n Xd S(   s‡  Perform shell/Perl-style variable substitution on 'string'.  Every
    occurrence of '$' followed by a name is considered a variable, and
    variable is substituted by the value found in the 'local_vars'
    dictionary, or in 'os.environ' if it's not in 'local_vars'.
    'os.environ' is first checked/augmented to guarantee that it contains
    certain values: see 'check_environ()'.  Raise ValueError for any
    variables not found in either 'local_vars' or 'os.environ'.
    c         S   s8   |  j  d É } | | k r) t | | É St j | Sd  S(   Ni   (   R,   t   strR   R$   (   R+   t
   local_varst   var_name(    (    s$   /usr/lib/python2.7/distutils/util.pyt   _subst»   s    s   \$([a-zA-Z_][a-zA-Z_0-9]*)s   invalid variable '$%s'N(   RV   R)   t   subt   KeyErrorRA   (   t   sRX   RZ   t   var(    (    s$   /usr/lib/python2.7/distutils/util.pyt
   subst_varsæ   s    	s   error: c         C   s   | t  |  É S(   N(   RW   (   t   excR2   (    (    s$   /usr/lib/python2.7/distutils/util.pyt   grok_environment_error◊   s    c           C   s8   t  j d t j É a t  j d É a t  j d É a d  S(   Ns   [^\\\'\"%s ]*s   '(?:[^'\\]|\\.)*'s   "(?:[^"\\]|\\.)*"(   R)   R*   R   t
   whitespacet   _wordchars_ret
   _squote_ret
   _dquote_re(    (    (    s$   /usr/lib/python2.7/distutils/util.pyt   _init_regex‡   s    c         C   sﬂ  t  d	 k r t É  n  t j |  É }  g  } d } xß|  r⁄t  j |  | É } | j É  } | t |  É k r | j |  |  É Pn  |  | t j	 k rø | j |  |  É t j
 |  | É }  d } nı |  | d k rÚ |  |  |  | d }  | d } n¬ |  | d k rt j |  | É } n6 |  | d k r<t j |  | É } n t d |  | Ç | d	 k rmt d |  | Ç n  | j É  \ } } |  |  |  | d | d !|  | }  | j É  d } | t |  É k r4 | j |  É Pq4 q4 W| S(
   s  Split a string up according to Unix shell-like rules for quotes and
    backslashes.  In short: words are delimited by spaces, as long as those
    spaces are not escaped by a backslash, or inside a quoted string.
    Single and double quotes are equivalent, and the quote characters can
    be backslash-escaped.  The backslash is stripped from any two-character
    escape sequence, leaving only the escaped character.  The quote
    characters are stripped from any quoted string.  Returns a list of
    words.
    i    s   \i   t   't   "s!   this can't happen (bad char '%c')s"   bad string (mismatched %s quotes?)i   N(   Rc   t   NoneRf   R   t   stripR+   t   endR"   t   appendRb   t   lstripRd   Re   t   RuntimeErrorRA   t   span(   R]   t   wordst   posR<   Rk   t   beg(    (    s$   /usr/lib/python2.7/distutils/util.pyt   split_quotedÊ   sD     
		%c         C   sj   | d k rF d |  j | f } | d d k rF | d d !d } qF n  t j | É | sf |  | å  n  d S(   sú  Perform some action that affects the outside world (eg.  by
    writing to the filesystem).  Such actions are special because they
    are disabled by the 'dry_run' flag.  This method takes care of all
    that bureaucracy for you; all you have to do is supply the
    function to call and an argument tuple for it (to embody the
    "external action" being performed), and an optional message to
    print.
    s   %s%ri˛ˇˇˇs   ,)i    R   N(   Ri   t   __name__R   t   info(   t   funct   argst   msgt   verboset   dry_run(    (    s$   /usr/lib/python2.7/distutils/util.pyt   execute%  s    	c         C   sC   t  j |  É }  |  d k r d S|  d k r/ d St d |  f Ç d S(   sÙ   Convert a string representation of truth to true (1) or false (0).

    True values are 'y', 'yes', 't', 'true', 'on', and '1'; false values
    are 'n', 'no', 'f', 'false', 'off', and '0'.  Raises ValueError if
    'val' is anything else.
    t   yt   yest   tt   truet   ont   1i   t   nt   not   ft   falset   offt   0i    s   invalid truth value %rN(   R|   R}   R~   R   RÄ   RÅ   (   RÇ   RÉ   RÑ   RÖ   RÜ   Rá   (   R   R#   RA   (   t   val(    (    s$   /usr/lib/python2.7/distutils/util.pyt	   strtobool8  s    i   c         C   sÓ  t  j r t d É Ç n  | d k r9 t o3 | d k } n  | s¬y& d d l m } | d É \ }	 }
 Wn4 t k
 rõ d d l m } d | d É }	 }
 n Xt	 j
 d |
 É | sB|	 d k	 r” t j |	 d É } n t |
 d É } | j d	 É | j t j t t |  É d
 É d É | j d | | | | | f É | j É  n  t  j |
 g } | d k rp| j d d É n | d k rè| j d d É n  t | d | Ét t j |
 f d |
 d | Én(d d l m } x|  D]} | d d k rıqŸn  | t rd pd } | } | rV| t | É  | k rCt d | | f Ç n  | t | É } n  | rtt j j | | É } n  t j j | É } | rŸ| s°t | | É r–t	 j
 d | | É | s„| | | | É q„qÊt	 j  d | | É qŸqŸWd S(   sî  Byte-compile a collection of Python source files to either .pyc
    or .pyo files in the same directory.  'py_files' is a list of files
    to compile; any files that don't end in ".py" are silently skipped.
    'optimize' must be one of the following:
      0 - don't optimize (generate .pyc)
      1 - normal optimization (like "python -O")
      2 - extra optimization (like "python -OO")
    If 'force' is true, all files are recompiled regardless of
    timestamps.

    The source filename encoded in each bytecode file defaults to the
    filenames listed in 'py_files'; you can modify these with 'prefix' and
    'basedir'.  'prefix' is a string that will be stripped off of each
    source filename, and 'base_dir' is a directory name that will be
    prepended (after 'prefix' is stripped).  You can supply either or both
    (or neither) of 'prefix' and 'base_dir', as you wish.

    If 'dry_run' is true, doesn't actually do anything that would
    affect the filesystem.

    Byte-compilation is either done directly in this interpreter process
    with the standard py_compile module, or indirectly by writing a
    temporary script and executing it.  Normally, you should let
    'byte_compile()' figure out to use direct compilation or not (see
    the source for details).  The 'direct' flag is used by the script
    generated in indirect mode; unless you know what you're doing, leave
    it set to None.
    s   byte-compiling is disabled.i    iˇˇˇˇ(   t   mkstemps   .py(   t   mktemps$   writing byte-compilation script '%s't   ws2   from distutils.util import byte_compile
files = [
s   ,
s   ]
så   
byte_compile(files, optimize=%r, force=%r,
             prefix=%r, base_dir=%r,
             verbose=%r, dry_run=0,
             direct=1)
i   s   -Oi   s   -OORz   s   removing %s(   R*   i˝ˇˇˇt   ct   os1   invalid prefix: filename %r doesn't start with %rs   byte-compiling %s to %ss%   skipping byte-compilation of %s to %sN(!   R   t   dont_write_bytecodeR   Ri   t	   __debug__t   tempfileRä   t   ImportErrorRã   R   Ru   R   t   fdopent   opent   writeR   RF   t   mapt   reprt   closet
   executablet   insertR   R{   RC   t
   py_compileR*   R"   RA   RE   t   basenameR   t   debug(   t   py_filest   optimizet   forceR2   t   base_dirRy   Rz   t   directRä   t	   script_fdt   script_nameRã   t   scriptt   cmdR*   t   filet   cfilet   dfilet
   cfile_base(    (    s$   /usr/lib/python2.7/distutils/util.pyt   byte_compileH  sh    "	&
	c         C   s,   t  j |  d É } t  j | d d É }  |  S(   så   Return a version of the string escaped for inclusion in an
    RFC-822 header, by ensuring there are 8 spaces space after each newline.
    s   
i   R   s           (   R   RB   RF   (   t   headert   lines(    (    s$   /usr/lib/python2.7/distutils/util.pyt   rfc822_escape◊  s    (    t   __doc__t   __revision__R   R   R   R)   t   distutils.errorsR    t   distutils.dep_utilR   t   distutils.spawnR   R=   R   R   R>   RI   RO   RR   RV   R_   Ra   Ri   Rc   Rd   Re   Rf   Rs   R{   Râ   R´   RÆ   (    (    (    s$   /usr/lib/python2.7/distutils/util.pyt   <module>   s0   0	^						?	ã                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  #
# distutils/version.py
#
# Implements multiple version numbering conventions for the
# Python Module Distribution Utilities.
#
# $Id$
#

"""Provides classes to represent module version numbers (one class for
each style of version numbering).  There are currently two such classes
implemented: StrictVersion and LooseVersion.

Every version number class implements the following interface:
  * the 'parse' method takes a string and parses it to some internal
    representation; if the string is an invalid version number,
    'parse' raises a ValueError exception
  * the class constructor takes an optional string argument which,
    if supplied, is passed to 'parse'
  * __str__ reconstructs the string that was passed to 'parse' (or
    an equivalent string -- ie. one that will generate an equivalent
    version number instance)
  * __repr__ generates Python code to recreate the version number instance
  * __cmp__ compares the current instance with either another instance
    of the same class or a string (which will be parsed to an instance
    of the same class, thus must follow the same rules)
"""

import string, re
from types import StringType

class Version:
    """Abstract base class for version numbering classes.  Just provides
    constructor (__init__) and reproducer (__repr__), because those
    seem to be the same for all version numbering classes.
    """

    def __init__ (self, vstring=None):
        if vstring:
            self.parse(vstring)

    def __repr__ (self):
        return "%s ('%s')" % (self.__class__.__name__, str(self))


# Interface for version-number classes -- must be implemented
# by the following classes (the concrete ones -- Version should
# be treated as an abstract class).
#    __init__ (string) - create and take same action as 'parse'
#                        (string parameter is optional)
#    parse (string)    - convert a string representation to whatever
#                        internal representation is appropriate for
#                        this style of version numbering
#    __str__ (self)    - convert back to a string; should be very similar
#                        (if not identical to) the string supplied to parse
#    __repr__ (self)   - generate Python code to recreate
#                        the instance
#    __cmp__ (self, other) - compare two version numbers ('other' may
#                        be an unparsed version string, or another
#                        instance of your version class)


class StrictVersion (Version):

    """Version numbering for anal retentives and software idealists.
    Implements the standard interface for version number classes as
    described above.  A version number consists of two or three
    dot-separated numeric components, with an optional "pre-release" tag
    on the end.  The pre-release tag consists of the letter 'a' or 'b'
    followed by a number.  If the numeric components of two version
    numbers are equal, then one with a pre-release tag will always
    be deemed earlier (lesser) than one without.

    The following are valid version numbers (shown in the order that
    would be obtained by sorting according to the supplied cmp function):

        0.4       0.4.0  (these two are equivalent)
        0.4.1
        0.5a1
        0.5b3
        0.5
        0.9.6
        1.0
        1.0.4a3
        1.0.4b1
        1.0.4

    The following are examples of invalid version numbers:

        1
        2.7.2.2
        1.3.a4
        1.3pl1
        1.3c4

    The rationale for this version numbering system will be explained
    in the distutils documentation.
    """

    version_re = re.compile(r'^(\d+) \. (\d+) (\. (\d+))? ([ab](\d+))?$',
                            re.VERBOSE)


    def parse (self, vstring):
        match = self.version_re.match(vstring)
        if not match:
            raise ValueError, "invalid version number '%s'" % vstring

        (major, minor, patch, prerelease, prerelease_num) = \
            match.group(1, 2, 4, 5, 6)

        if patch:
            self.version = tuple(map(string.atoi, [major, minor, patch]))
        else:
            self.version = tuple(map(string.atoi, [major, minor]) + [0])

        if prerelease:
            self.prerelease = (prerelease[0], string.atoi(prerelease_num))
        else:
            self.prerelease = None


    def __str__ (self):

        if self.version[2] == 0:
            vstring = string.join(map(str, self.version[0:2]), '.')
        else:
            vstring = string.join(map(str, self.version), '.')

        if self.prerelease:
            vstring = vstring + self.prerelease[0] + str(self.prerelease[1])

        return vstring


    def __cmp__ (self, other):
        if isinstance(other, StringType):
            other = StrictVersion(other)

        compare = cmp(self.version, other.version)
        if (compare == 0):              # have to compare prerelease

            # case 1: neither has prerelease; they're equal
            # case 2: self has prerelease, other doesn't; other is greater
            # case 3: self doesn't have prerelease, other does: self is greater
            # case 4: both have prerelease: must compare them!

            if (not self.prerelease and not other.prerelease):
                return 0
            elif (self.prerelease and not other.prerelease):
                return -1
            elif (not self.prerelease and other.prerelease):
                return 1
            elif (self.prerelease and other.prerelease):
                return cmp(self.prerelease, other.prerelease)

        else:                           # numeric versions don't match --
            return compare              # prerelease stuff doesn't matter


# end class StrictVersion


# The rules according to Greg Stein:
# 1) a version number has 1 or more numbers separated by a period or by
#    sequences of letters. If only periods, then these are compared
#    left-to-right to determine an ordering.
# 2) sequences of letters are part of the tuple for comparison and are
#    compared lexicographically
# 3) recognize the numeric components may have leading zeroes
#
# The LooseVersion class below implements these rules: a version number
# string is split up into a tuple of integer and string components, and
# comparison is a simple tuple comparison.  This means that version
# numbers behave in a predictable and obvious way, but a way that might
# not necessarily be how people *want* version numbers to behave.  There
# wouldn't be a problem if people could stick to purely numeric version
# numbers: just split on period and compare the numbers as tuples.
# However, people insist on putting letters into their version numbers;
# the most common purpose seems to be:
#   - indicating a "pre-release" version
#     ('alpha', 'beta', 'a', 'b', 'pre', 'p')
#   - indicating a post-release patch ('p', 'pl', 'patch')
# but of course this can't cover all version number schemes, and there's
# no way to know what a programmer means without asking him.
#
# The problem is what to do with letters (and other non-numeric
# characters) in a version number.  The current implementation does the
# obvious and predictable thing: keep them as strings and compare
# lexically within a tuple comparison.  This has the desired effect if
# an appended letter sequence implies something "post-release":
# eg. "0.99" < "0.99pl14" < "1.0", and "5.001" < "5.001m" < "5.002".
#
# However, if letters in a version number imply a pre-release version,
# the "obvious" thing isn't correct.  Eg. you would expect that
# "1.5.1" < "1.5.2a2" < "1.5.2", but under the tuple/lexical comparison
# implemented here, this just isn't so.
#
# Two possible solutions come to mind.  The first is to tie the
# comparison algorithm to a particular set of semantic rules, as has
# been done in the StrictVersion class above.  This works great as long
# as everyone can go along with bondage and discipline.  Hopefully a
# (large) subset of Python module programmers will agree that the
# particular flavour of bondage and discipline provided by StrictVersion
# provides enough benefit to be worth using, and will submit their
# version numbering scheme to its domination.  The free-thinking
# anarchists in the lot will never give in, though, and something needs
# to be done to accommodate them.
#
# Perhaps a "moderately strict" version class could be implemented that
# lets almost anything slide (syntactically), and makes some heuristic
# assumptions about non-digits in version number strings.  This could
# sink into special-case-hell, though; if I was as talented and
# idiosyncratic as Larry Wall, I'd go ahead and implement a class that
# somehow knows that "1.2.1" < "1.2.2a2" < "1.2.2" < "1.2.2pl3", and is
# just as happy dealing with things like "2g6" and "1.13++".  I don't
# think I'm smart enough to do it right though.
#
# In any case, I've coded the test suite for this module (see
# ../test/test_version.py) specifically to fail on things like comparing
# "1.2a2" and "1.2".  That's not because the *code* is doing anything
# wrong, it's because the simple, obvious design doesn't match my
# complicated, hairy expectations for real-world version numbers.  It
# would be a snap to fix the test suite to say, "Yep, LooseVersion does
# the Right Thing" (ie. the code matches the conception).  But I'd rather
# have a conception that matches common notions about version numbers.

class LooseVersion (Version):

    """Version numbering for anarchists and software realists.
    Implements the standard interface for version number classes as
    described above.  A version number consists of a series of numbers,
    separated by either periods or strings of letters.  When comparing
    version numbers, the numeric components will be compared
    numerically, and the alphabetic components lexically.  The following
    are all valid version numbers, in no particular order:

        1.5.1
        1.5.2b2
        161
        3.10a
        8.02
        3.4j
        1996.07.12
        3.2.pl0
        3.1.1.6
        2g6
        11g
        0.960923
        2.2beta29
        1.13++
        5.5.kw
        2.0b1pl0

    In fact, there is no such thing as an invalid version number under
    this scheme; the rules for comparison are simple and predictable,
    but may not always give the results you want (for some definition
    of "want").
    """

    component_re = re.compile(r'(\d+ | [a-z]+ | \.)', re.VERBOSE)

    def __init__ (self, vstring=None):
        if vstring:
            self.parse(vstring)


    def parse (self, vstring):
        # I've given up on thinking I can reconstruct the version string
        # from the parsed tuple -- so I just store the string here for
        # use by __str__
        self.vstring = vstring
        components = filter(lambda x: x and x != '.',
                            self.component_re.split(vstring))
        for i in range(len(components)):
            try:
                components[i] = int(components[i])
            except ValueError:
                pass

        self.version = components


    def __str__ (self):
        return self.vstring


    def __repr__ (self):
        return "LooseVersion ('%s')" % str(self)


    def __cmp__ (self, other):
        if isinstance(other, StringType):
            other = LooseVersion(other)

        return cmp(self.version, other.version)


# end class LooseVersion
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Û
”´[c           @   sO   d  Z  d Z d d d d d d d d	 d
 d d d d d d d d d d g Z d S(   s\   distutils.command

Package containing implementation of all the standard Distutils
commands.s   $Id$t   buildt   build_pyt	   build_extt
   build_clibt   build_scriptst   cleant   installt   install_libt   install_headerst   install_scriptst   install_datat   sdistt   registert   bdistt
   bdist_dumbt	   bdist_rpmt   bdist_wininstt   uploadt   checkN(   t   __doc__t   __revision__t   __all__(    (    (    s0   /usr/lib/python2.7/distutils/command/__init__.pyt   <module>   s(                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Û
”´[c           @   sq   d  Z  d d l Z d d l Z d d l m Z d d
 d Ñ  É  YZ d e f d Ñ  É  YZ d e f d	 Ñ  É  YZ d S(   s«  Provides classes to represent module version numbers (one class for
each style of version numbering).  There are currently two such classes
implemented: StrictVersion and LooseVersion.

Every version number class implements the following interface:
  * the 'parse' method takes a string and parses it to some internal
    representation; if the string is an invalid version number,
    'parse' raises a ValueError exception
  * the class constructor takes an optional string argument which,
    if supplied, is passed to 'parse'
  * __str__ reconstructs the string that was passed to 'parse' (or
    an equivalent string -- ie. one that will generate an equivalent
    version number instance)
  * __repr__ generates Python code to recreate the version number instance
  * __cmp__ compares the current instance with either another instance
    of the same class or a string (which will be parsed to an instance
    of the same class, thus must follow the same rules)
iˇˇˇˇN(   t
   StringTypet   Versionc           B   s#   e  Z d  Z d d Ñ Z d Ñ  Z RS(   s≈   Abstract base class for version numbering classes.  Just provides
    constructor (__init__) and reproducer (__repr__), because those
    seem to be the same for all version numbering classes.
    c         C   s   | r |  j  | É n  d  S(   N(   t   parse(   t   selft   vstring(    (    s'   /usr/lib/python2.7/distutils/version.pyt   __init__&   s    c         C   s   d |  j  j t |  É f S(   Ns	   %s ('%s')(   t	   __class__t   __name__t   str(   R   (    (    s'   /usr/lib/python2.7/distutils/version.pyt   __repr__*   s    N(   R   t
   __module__t   __doc__t   NoneR   R	   (    (    (    s'   /usr/lib/python2.7/distutils/version.pyR       s   t   StrictVersionc           B   s>   e  Z d  Z e j d e j É Z d Ñ  Z d Ñ  Z d Ñ  Z	 RS(   s?  Version numbering for anal retentives and software idealists.
    Implements the standard interface for version number classes as
    described above.  A version number consists of two or three
    dot-separated numeric components, with an optional "pre-release" tag
    on the end.  The pre-release tag consists of the letter 'a' or 'b'
    followed by a number.  If the numeric components of two version
    numbers are equal, then one with a pre-release tag will always
    be deemed earlier (lesser) than one without.

    The following are valid version numbers (shown in the order that
    would be obtained by sorting according to the supplied cmp function):

        0.4       0.4.0  (these two are equivalent)
        0.4.1
        0.5a1
        0.5b3
        0.5
        0.9.6
        1.0
        1.0.4a3
        1.0.4b1
        1.0.4

    The following are examples of invalid version numbers:

        1
        2.7.2.2
        1.3.a4
        1.3pl1
        1.3c4

    The rationale for this version numbering system will be explained
    in the distutils documentation.
    s)   ^(\d+) \. (\d+) (\. (\d+))? ([ab](\d+))?$c         C   sŸ   |  j  j | É } | s( t d | Ç n  | j d d d d d É \ } } } } } | r t t t j | | | g É É |  _ n( t t t j | | g É d g É |  _ | rÃ | d t j | É f |  _	 n	 d  |  _	 d  S(   Ns   invalid version number '%s'i   i   i   i   i   i    (   t
   version_ret   matcht
   ValueErrort   groupt   tuplet   mapt   stringt   atoit   versiont
   prereleaseR   (   R   R   R   t   majort   minort   patchR   t   prerelease_num(    (    s'   /usr/lib/python2.7/distutils/version.pyR   h   s    *'(c         C   sã   |  j  d d k r; t j t t |  j  d d !É d É } n t j t t |  j  É d É } |  j rá | |  j d t |  j d É } n  | S(   Ni   i    t   .i   (   R   R   t   joinR   R   R   (   R   R   (    (    s'   /usr/lib/python2.7/distutils/version.pyt   __str__{   s    (	%c         C   sµ   t  | t É r t | É } n  t |  j | j É } | d k r≠ |  j rW | j rW d S|  j rn | j rn d S|  j rÖ | j rÖ d S|  j r± | j r± t |  j | j É Sn | Sd  S(   Ni    iˇˇˇˇi   (   t
   isinstanceR    R   t   cmpR   R   (   R   t   othert   compare(    (    s'   /usr/lib/python2.7/distutils/version.pyt   __cmp__à   s    (
   R   R
   R   t   ret   compilet   VERBOSER   R   R   R#   (    (    (    s'   /usr/lib/python2.7/distutils/version.pyR   ?   s   #			t   LooseVersionc           B   sS   e  Z d  Z e j d e j É Z d d Ñ Z d Ñ  Z	 d Ñ  Z
 d Ñ  Z d Ñ  Z RS(   s§  Version numbering for anarchists and software realists.
    Implements the standard interface for version number classes as
    described above.  A version number consists of a series of numbers,
    separated by either periods or strings of letters.  When comparing
    version numbers, the numeric components will be compared
    numerically, and the alphabetic components lexically.  The following
    are all valid version numbers, in no particular order:

        1.5.1
        1.5.2b2
        161
        3.10a
        8.02
        3.4j
        1996.07.12
        3.2.pl0
        3.1.1.6
        2g6
        11g
        0.960923
        2.2beta29
        1.13++
        5.5.kw
        2.0b1pl0

    In fact, there is no such thing as an invalid version number under
    this scheme; the rules for comparison are simple and predictable,
    but may not always give the results you want (for some definition
    of "want").
    s   (\d+ | [a-z]+ | \.)c         C   s   | r |  j  | É n  d  S(   N(   R   (   R   R   (    (    s'   /usr/lib/python2.7/distutils/version.pyR     s    c         C   s}   | |  _  t d Ñ  |  j j | É É } xF t t | É É D]2 } y t | | É | | <Wq: t k
 rk q: Xq: W| |  _ d  S(   Nc         S   s   |  o |  d k S(   NR   (    (   t   x(    (    s'   /usr/lib/python2.7/distutils/version.pyt   <lambda>  s    (	   R   t   filtert   component_ret   splitt   ranget   lent   intR   R   (   R   R   t
   componentst   i(    (    s'   /usr/lib/python2.7/distutils/version.pyR     s    		c         C   s   |  j  S(   N(   R   (   R   (    (    s'   /usr/lib/python2.7/distutils/version.pyR     s    c         C   s   d t  |  É S(   Ns   LooseVersion ('%s')(   R   (   R   (    (    s'   /usr/lib/python2.7/distutils/version.pyR	      s    c         C   s1   t  | t É r t | É } n  t |  j | j É S(   N(   R   R    R'   R    R   (   R   R!   (    (    s'   /usr/lib/python2.7/distutils/version.pyR#   $  s    N(   R   R
   R   R$   R%   R&   R+   R   R   R   R   R	   R#   (    (    (    s'   /usr/lib/python2.7/distutils/version.pyR'   ‰   s   			(    (   R   R   R$   t   typesR    R   R   R'   (    (    (    s'   /usr/lib/python2.7/distutils/version.pyt   <module>   s
   •                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      """Module for parsing and testing package version predicate strings.
"""
import re
import distutils.version
import operator


re_validPackage = re.compile(r"(?i)^\s*([a-z_]\w*(?:\.[a-z_]\w*)*)(.*)")
# (package) (rest)

re_paren = re.compile(r"^\s*\((.*)\)\s*$") # (list) inside of parentheses
re_splitComparison = re.compile(r"^\s*(<=|>=|<|>|!=|==)\s*([^\s,]+)\s*$")
# (comp) (version)


def splitUp(pred):
    """Parse a single version comparison.

    Return (comparison string, StrictVersion)
    """
    res = re_splitComparison.match(pred)
    if not res:
        raise ValueError("bad package restriction syntax: %r" % pred)
    comp, verStr = res.groups()
    return (comp, distutils.version.StrictVersion(verStr))

compmap = {"<": operator.lt, "<=": operator.le, "==": operator.eq,
           ">": operator.gt, ">=": operator.ge, "!=": operator.ne}

class VersionPredicate:
    """Parse and test package version predicates.

    >>> v = VersionPredicate('pyepat.abc (>1.0, <3333.3a1, !=1555.1b3)')

    The `name` attribute provides the full dotted name that is given::

    >>> v.name
    'pyepat.abc'

    The str() of a `VersionPredicate` provides a normalized
    human-readable version of the expression::

    >>> print v
    pyepat.abc (> 1.0, < 3333.3a1, != 1555.1b3)

    The `satisfied_by()` method can be used to determine with a given
    version number is included in the set described by the version
    restrictions::

    >>> v.satisfied_by('1.1')
    True
    >>> v.satisfied_by('1.4')
    True
    >>> v.satisfied_by('1.0')
    False
    >>> v.satisfied_by('4444.4')
    False
    >>> v.satisfied_by('1555.1b3')
    False

    `VersionPredicate` is flexible in accepting extra whitespace::

    >>> v = VersionPredicate(' pat( ==  0.1  )  ')
    >>> v.name
    'pat'
    >>> v.satisfied_by('0.1')
    True
    >>> v.satisfied_by('0.2')
    False

    If any version numbers passed in do not conform to the
    restrictions of `StrictVersion`, a `ValueError` is raised::

    >>> v = VersionPredicate('p1.p2.p3.p4(>=1.0, <=1.3a1, !=1.2zb3)')
    Traceback (most recent call last):
      ...
    ValueError: invalid version number '1.2zb3'

    It the module or package name given does not conform to what's
    allowed as a legal module or package name, `ValueError` is
    raised::

    >>> v = VersionPredicate('foo-bar')
    Traceback (most recent call last):
      ...
    ValueError: expected parenthesized list: '-bar'

    >>> v = VersionPredicate('foo bar (12.21)')
    Traceback (most recent call last):
      ...
    ValueError: expected parenthesized list: 'bar (12.21)'

    """

    def __init__(self, versionPredicateStr):
        """Parse a version predicate string.
        """
        # Fields:
        #    name:  package name
        #    pred:  list of (comparison string, StrictVersion)

        versionPredicateStr = versionPredicateStr.strip()
        if not versionPredicateStr:
            raise ValueError("empty package restriction")
        match = re_validPackage.match(versionPredicateStr)
        if not match:
            raise ValueError("bad package name in %r" % versionPredicateStr)
        self.name, paren = match.groups()
        paren = paren.strip()
        if paren:
            match = re_paren.match(paren)
            if not match:
                raise ValueError("expected parenthesized list: %r" % paren)
            str = match.groups()[0]
            self.pred = [splitUp(aPred) for aPred in str.split(",")]
            if not self.pred:
                raise ValueError("empty parenthesized list in %r"
                                 % versionPredicateStr)
        else:
            self.pred = []

    def __str__(self):
        if self.pred:
            seq = [cond + " " + str(ver) for cond, ver in self.pred]
            return self.name + " (" + ", ".join(seq) + ")"
        else:
            return self.name

    def satisfied_by(self, version):
        """True if version is compatible with all the predicates in self.
        The parameter version must be acceptable to the StrictVersion
        constructor.  It may be either a string or StrictVersion.
        """
        for cond, ver in self.pred:
            if not compmap[cond](version, ver):
                return False
        return True


_provision_rx = None

def split_provision(value):
    """Return the name and optional version number of a provision.

    The version number, if given, will be returned as a `StrictVersion`
    instance, otherwise it will be `None`.

    >>> split_provision('mypkg')
    ('mypkg', None)
    >>> split_provision(' mypkg( 1.2 ) ')
    ('mypkg', StrictVersion ('1.2'))
    """
    global _provision_rx
    if _provision_rx is None:
        _provision_rx = re.compile(
            "([a-zA-Z_]\w*(?:\.[a-zA-Z_]\w*)*)(?:\s*\(\s*([^)\s]+)\s*\))?$")
    value = value.strip()
    m = _provision_rx.match(value)
    if not m:
        raise ValueError("illegal provides specification: %r" % value)
    ver = m.group(2) or None
    if ver:
        ver = distutils.version.StrictVersion(ver)
    return m.group(1), ver
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         Û
”´[c           @   s»   d  Z  d d l Z d d l Z d d l Z e j d É Z e j d É Z e j d É Z d Ñ  Z	 i e j
 d 6e j d 6e j d	 6e j d
 6e j d 6e j d 6Z d d d Ñ  É  YZ d a d Ñ  Z d S(   sB   Module for parsing and testing package version predicate strings.
iˇˇˇˇNs'   (?i)^\s*([a-z_]\w*(?:\.[a-z_]\w*)*)(.*)s   ^\s*\((.*)\)\s*$s%   ^\s*(<=|>=|<|>|!=|==)\s*([^\s,]+)\s*$c         C   sP   t  j |  É } | s( t d |  É Ç n  | j É  \ } } | t j j | É f S(   sV   Parse a single version comparison.

    Return (comparison string, StrictVersion)
    s"   bad package restriction syntax: %r(   t   re_splitComparisont   matcht
   ValueErrort   groupst	   distutilst   versiont   StrictVersion(   t   predt   rest   compt   verStr(    (    s0   /usr/lib/python2.7/distutils/versionpredicate.pyt   splitUp   s
    t   <s   <=s   ==t   >s   >=s   !=t   VersionPredicatec           B   s)   e  Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   sª  Parse and test package version predicates.

    >>> v = VersionPredicate('pyepat.abc (>1.0, <3333.3a1, !=1555.1b3)')

    The `name` attribute provides the full dotted name that is given::

    >>> v.name
    'pyepat.abc'

    The str() of a `VersionPredicate` provides a normalized
    human-readable version of the expression::

    >>> print v
    pyepat.abc (> 1.0, < 3333.3a1, != 1555.1b3)

    The `satisfied_by()` method can be used to determine with a given
    version number is included in the set described by the version
    restrictions::

    >>> v.satisfied_by('1.1')
    True
    >>> v.satisfied_by('1.4')
    True
    >>> v.satisfied_by('1.0')
    False
    >>> v.satisfied_by('4444.4')
    False
    >>> v.satisfied_by('1555.1b3')
    False

    `VersionPredicate` is flexible in accepting extra whitespace::

    >>> v = VersionPredicate(' pat( ==  0.1  )  ')
    >>> v.name
    'pat'
    >>> v.satisfied_by('0.1')
    True
    >>> v.satisfied_by('0.2')
    False

    If any version numbers passed in do not conform to the
    restrictions of `StrictVersion`, a `ValueError` is raised::

    >>> v = VersionPredicate('p1.p2.p3.p4(>=1.0, <=1.3a1, !=1.2zb3)')
    Traceback (most recent call last):
      ...
    ValueError: invalid version number '1.2zb3'

    It the module or package name given does not conform to what's
    allowed as a legal module or package name, `ValueError` is
    raised::

    >>> v = VersionPredicate('foo-bar')
    Traceback (most recent call last):
      ...
    ValueError: expected parenthesized list: '-bar'

    >>> v = VersionPredicate('foo bar (12.21)')
    Traceback (most recent call last):
      ...
    ValueError: expected parenthesized list: 'bar (12.21)'

    c         C   sˇ   | j  É  } | s! t d É Ç n  t j | É } | sI t d | É Ç n  | j É  \ |  _ } | j  É  } | rÚ t j | É } | sò t d | É Ç n  | j É  d } g  | j d É D] } t | É ^ q∏ |  _	 |  j	 s˚ t d | É Ç q˚ n	 g  |  _	 d S(   s*   Parse a version predicate string.
        s   empty package restrictions   bad package name in %rs   expected parenthesized list: %ri    t   ,s   empty parenthesized list in %rN(
   t   stripR   t   re_validPackageR   R   t   namet   re_parent   splitR   R   (   t   selft   versionPredicateStrR   t   parent   strt   aPred(    (    s0   /usr/lib/python2.7/distutils/versionpredicate.pyt   __init___   s$    +	c         C   s`   |  j  rU g  |  j  D]  \ } } | d t | É ^ q } |  j d d j | É d S|  j Sd  S(   Nt    s    (s   , t   )(   R   R   R   t   join(   R   t   condt   vert   seq(    (    s0   /usr/lib/python2.7/distutils/versionpredicate.pyt   __str__z   s    	0c         C   s5   x. |  j  D]# \ } } t | | | É s
 t Sq
 Wt S(   sœ   True if version is compatible with all the predicates in self.
        The parameter version must be acceptable to the StrictVersion
        constructor.  It may be either a string or StrictVersion.
        (   R   t   compmapt   Falset   True(   R   R   R   R   (    (    s0   /usr/lib/python2.7/distutils/versionpredicate.pyt   satisfied_byÅ   s    (   t   __name__t
   __module__t   __doc__R   R!   R%   (    (    (    s0   /usr/lib/python2.7/distutils/versionpredicate.pyR      s   ?		c         C   sï   t  d k r t j d É a  n  |  j É  }  t  j |  É } | sR t d |  É Ç n  | j d É pd d } | rÇ t j	 j
 | É } n  | j d É | f S(   s9  Return the name and optional version number of a provision.

    The version number, if given, will be returned as a `StrictVersion`
    instance, otherwise it will be `None`.

    >>> split_provision('mypkg')
    ('mypkg', None)
    >>> split_provision(' mypkg( 1.2 ) ')
    ('mypkg', StrictVersion ('1.2'))
    s=   ([a-zA-Z_]\w*(?:\.[a-zA-Z_]\w*)*)(?:\s*\(\s*([^)\s]+)\s*\))?$s"   illegal provides specification: %ri   i   N(   t   _provision_rxt   Nonet   ret   compileR   R   R   t   groupR   R   R   (   t   valuet   mR   (    (    s0   /usr/lib/python2.7/distutils/versionpredicate.pyt   split_provisioné   s    (    (   R(   R+   t   distutils.versionR   t   operatorR,   R   R   R    R   t   ltt   let   eqt   gtt   get   neR"   R   R*   R)   R0   (    (    (    s0   /usr/lib/python2.7/distutils/versionpredicate.pyt   <module>   s   	!!n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        """distutils.command.bdist

Implements the Distutils 'bdist' command (create a built [binary]
distribution)."""

__revision__ = "$Id$"

import os

from distutils.util import get_platform
from distutils.core import Command
from distutils.errors import DistutilsPlatformError, DistutilsOptionError


def show_formats():
    """Print list of available formats (arguments to "--format" option).
    """
    from distutils.fancy_getopt import FancyGetopt
    formats = []
    for format in bdist.format_commands:
        formats.append(("formats=" + format, None,
                        bdist.format_command[format][1]))
    pretty_printer = FancyGetopt(formats)
    pretty_printer.print_help("List of available distribution formats:")


class bdist(Command):

    description = "create a built (binary) distribution"

    user_options = [('bdist-base=', 'b',
                     "temporary directory for creating built distributions"),
                    ('plat-name=', 'p',
                     "platform name to embed in generated filenames "
                     "(default: %s)" % get_platform()),
                    ('formats=', None,
                     "formats for distribution (comma-separated list)"),
                    ('dist-dir=', 'd',
                     "directory to put final built distributions in "
                     "[default: dist]"),
                    ('skip-build', None,
                     "skip rebuilding everything (for testing/debugging)"),
                    ('owner=', 'u',
                     "Owner name used when creating a tar file"
                     " [default: current user]"),
                    ('group=', 'g',
                     "Group name used when creating a tar file"
                     " [default: current group]"),
                   ]

    boolean_options = ['skip-build']

    help_options = [
        ('help-formats', None,
         "lists available distribution formats", show_formats),
        ]

    # The following commands do not take a format option from bdist
    no_format_option = ('bdist_rpm',)

    # This won't do in reality: will need to distinguish RPM-ish Linux,
    # Debian-ish Linux, Solaris, FreeBSD, ..., Windows, Mac OS.
    default_format = {'posix': 'gztar',
                      'nt': 'zip',
                      'os2': 'zip'}

    # Establish the preferred order (for the --help-formats option).
    format_commands = ['rpm', 'gztar', 'bztar', 'ztar', 'tar',
                       'wininst', 'zip', 'msi']

    # And the real information.
    format_command = {'rpm':   ('bdist_rpm',  "RPM distribution"),
                      'gztar': ('bdist_dumb', "gzip'ed tar file"),
                      'bztar': ('bdist_dumb', "bzip2'ed tar file"),
                      'ztar':  ('bdist_dumb', "compressed tar file"),
                      'tar':   ('bdist_dumb', "tar file"),
                      'wininst': ('bdist_wininst',
                                  "Windows executable installer"),
                      'zip':   ('bdist_dumb', "ZIP file"),
                      'msi':   ('bdist_msi',  "Microsoft Installer")
                      }


    def initialize_options(self):
        self.bdist_base = None
        self.plat_name = None
        self.formats = None
        self.dist_dir = None
        self.skip_build = 0
        self.group = None
        self.owner = None

    def finalize_options(self):
        # have to finalize 'plat_name' before 'bdist_base'
        if self.plat_name is None:
            if self.skip_build:
                self.plat_name = get_platform()
            else:
                self.plat_name = self.get_finalized_command('build').plat_name

        # 'bdist_base' -- parent of per-built-distribution-format
        # temporary directories (eg. we'll probably have
        # "build/bdist.<plat>/dumb", "build/bdist.<plat>/rpm", etc.)
        if self.bdist_base is None:
            build_base = self.get_finalized_command('build').build_base
            self.bdist_base = os.path.join(build_base,
                                           'bdist.' + self.plat_name)

        self.ensure_string_list('formats')
        if self.formats is None:
            try:
                self.formats = [self.default_format[os.name]]
            except KeyError:
                raise DistutilsPlatformError, \
                      "don't know how to create built distributions " + \
                      "on platform %s" % os.name

        if self.dist_dir is None:
            self.dist_dir = "dist"

    def run(self):
        # Figure out which sub-commands we need to run.
        commands = []
        for format in self.formats:
            try:
                commands.append(self.format_command[format][0])
            except KeyError:
                raise DistutilsOptionError, "invalid format '%s'" % format

        # Reinitialize and run each command.
        for i in range(len(self.formats)):
            cmd_name = commands[i]
            sub_cmd = self.reinitialize_command(cmd_name)
            if cmd_name not in self.no_format_option:
                sub_cmd.format = self.formats[i]

            # passing the owner and group names for tar archiving
            if cmd_name == 'bdist_dumb':
                sub_cmd.owner = self.owner
                sub_cmd.group = self.group

            # If we're going to need to run this command again, tell it to
            # keep its temporary files around so subsequent runs go faster.
            if cmd_name in commands[i+1:]:
                sub_cmd.keep_temp = 1
            self.run_command(cmd_name)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Û
”´[c           @   sq   d  Z  d Z d d l Z d d l m Z d d l m Z d d l m Z m	 Z	 d Ñ  Z
 d e f d	 Ñ  É  YZ d S(
   si   distutils.command.bdist

Implements the Distutils 'bdist' command (create a built [binary]
distribution).s   $Id$iˇˇˇˇN(   t   get_platform(   t   Command(   t   DistutilsPlatformErrort   DistutilsOptionErrorc          C   sl   d d l  m }  g  } x6 t j D]+ } | j d | d t j | d f É q  W|  | É } | j d É d S(   sF   Print list of available formats (arguments to "--format" option).
    iˇˇˇˇ(   t   FancyGetopts   formats=i   s'   List of available distribution formats:N(   t   distutils.fancy_getoptR   t   bdistt   format_commandst   appendt   Nonet   format_commandt
   print_help(   R   t   formatst   formatt   pretty_printer(    (    s-   /usr/lib/python2.7/distutils/command/bdist.pyt   show_formats   s    R   c        	   B   sÔ   e  Z d  Z d0 d d d e É  f d2 d3 d4 d5 d6 g Z d g Z d d1 d e f g Z d7 Z	 i d d 6d d 6d d 6Z
 d d d d d d  d d! g Z i d8 d 6d9 d 6d: d 6d; d 6d< d 6d= d  6d> d 6d? d! 6Z d- Ñ  Z d. Ñ  Z d/ Ñ  Z RS(@   s$   create a built (binary) distributions   bdist-base=t   bs4   temporary directory for creating built distributionss
   plat-name=t   ps;   platform name to embed in generated filenames (default: %s)s   formats=s/   formats for distribution (comma-separated list)s	   dist-dir=t   ds=   directory to put final built distributions in [default: dist]s
   skip-builds2   skip rebuilding everything (for testing/debugging)s   owner=t   us@   Owner name used when creating a tar file [default: current user]s   group=t   gsA   Group name used when creating a tar file [default: current group]s   help-formatss$   lists available distribution formatst	   bdist_rpmt   gztart   posixt   zipt   ntt   os2t   rpmt   bztart   ztart   tart   wininstt   msis   RPM distributiont
   bdist_dumbs   gzip'ed tar files   bzip2'ed tar files   compressed tar files   tar filet   bdist_wininsts   Windows executable installers   ZIP filet	   bdist_msis   Microsoft Installerc         C   sC   d  |  _ d  |  _ d  |  _ d  |  _ d |  _ d  |  _ d  |  _ d  S(   Ni    (   R	   t
   bdist_baset	   plat_nameR   t   dist_dirt
   skip_buildt   groupt   owner(   t   self(    (    s-   /usr/lib/python2.7/distutils/command/bdist.pyt   initialize_optionsT   s    						c         C   s  |  j  d  k r? |  j r' t É  |  _  q? |  j d É j  |  _  n  |  j d  k rÇ |  j d É j } t j j	 | d |  j  É |  _ n  |  j
 d É |  j d  k r„ y |  j t j g |  _ Wq„ t k
 rﬂ t d d t j Ç q„ Xn  |  j d  k r˛ d |  _ n  d  S(   Nt   builds   bdist.R   s-   don't know how to create built distributions s   on platform %st   dist(   R%   R	   R'   R    t   get_finalized_commandR$   t
   build_baset   ost   patht   joint   ensure_string_listR   t   default_formatt   namet   KeyErrorR   R&   (   R*   R/   (    (    s-   /usr/lib/python2.7/distutils/command/bdist.pyt   finalize_options]   s$    	c         C   s
  g  } xN |  j  D]C } y | j |  j | d É Wq t k
 rR t d | Ç q Xq Wx¨ t t |  j  É É D]ï } | | } |  j | É } | |  j k rÆ |  j  | | _	 n  | d k r’ |  j
 | _
 |  j | _ n  | | | d k rı d | _ n  |  j | É qm Wd  S(   Ni    s   invalid format '%s'R!   i   (   R   R   R
   R6   R   t   ranget   lent   reinitialize_commandt   no_format_optionR   R)   R(   t	   keep_tempt   run_command(   R*   t   commandsR   t   it   cmd_namet   sub_cmd(    (    s-   /usr/lib/python2.7/distutils/command/bdist.pyt   runy   s"    
(   s   bdist-base=R   s4   temporary directory for creating built distributionsN(   s   formats=Ns/   formats for distribution (comma-separated list)(   s	   dist-dir=R   s=   directory to put final built distributions in [default: dist](   s
   skip-buildNs2   skip rebuilding everything (for testing/debugging)(   s   owner=R   s@   Owner name used when creating a tar file [default: current user](   s   group=R   sA   Group name used when creating a tar file [default: current group](   R   (   R   s   RPM distribution(   R!   s   gzip'ed tar file(   R!   s   bzip2'ed tar file(   R!   s   compressed tar file(   R!   s   tar file(   R"   s   Windows executable installer(   R!   s   ZIP file(   R#   s   Microsoft Installer(   t   __name__t
   __module__t   descriptionR    R	   t   user_optionst   boolean_optionsR   t   help_optionsR;   R4   R   R
   R+   R7   RB   (    (    (    s-   /usr/lib/python2.7/distutils/command/bdist.pyR      sJ    
     		


 
			(   t   __doc__t   __revision__R0   t   distutils.utilR    t   distutils.coreR   t   distutils.errorsR   R   R   R   (    (    (    s-   /usr/lib/python2.7/distutils/command/bdist.pyt   <module>   s   	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           """distutils.command.bdist_dumb

Implements the Distutils 'bdist_dumb' command (create a "dumb" built
distribution -- i.e., just an archive to be unpacked under $prefix or
$exec_prefix)."""

__revision__ = "$Id$"

import os

from sysconfig import get_python_version

from distutils.util import get_platform
from distutils.core import Command
from distutils.dir_util import remove_tree, ensure_relative
from distutils.errors import DistutilsPlatformError
from distutils import log

class bdist_dumb (Command):

    description = 'create a "dumb" built distribution'

    user_options = [('bdist-dir=', 'd',
                     "temporary directory for creating the distribution"),
                    ('plat-name=', 'p',
                     "platform name to embed in generated filenames "
                     "(default: %s)" % get_platform()),
                    ('format=', 'f',
                     "archive format to create (tar, ztar, gztar, zip)"),
                    ('keep-temp', 'k',
                     "keep the pseudo-installation tree around after " +
                     "creating the distribution archive"),
                    ('dist-dir=', 'd',
                     "directory to put final built distributions in"),
                    ('skip-build', None,
                     "skip rebuilding everything (for testing/debugging)"),
                    ('relative', None,
                     "build the archive using relative paths"
                     "(default: false)"),
                    ('owner=', 'u',
                     "Owner name used when creating a tar file"
                     " [default: current user]"),
                    ('group=', 'g',
                     "Group name used when creating a tar file"
                     " [default: current group]"),
                   ]

    boolean_options = ['keep-temp', 'skip-build', 'relative']

    default_format = { 'posix': 'gztar',
                       'nt': 'zip',
                       'os2': 'zip' }


    def initialize_options (self):
        self.bdist_dir = None
        self.plat_name = None
        self.format = None
        self.keep_temp = 0
        self.dist_dir = None
        self.skip_build = None
        self.relative = 0
        self.owner = None
        self.group = None

    def finalize_options(self):
        if self.bdist_dir is None:
            bdist_base = self.get_finalized_command('bdist').bdist_base
            self.bdist_dir = os.path.join(bdist_base, 'dumb')

        if self.format is None:
            try:
                self.format = self.default_format[os.name]
            except KeyError:
                raise DistutilsPlatformError, \
                      ("don't know how to create dumb built distributions " +
                       "on platform %s") % os.name

        self.set_undefined_options('bdist',
                                   ('dist_dir', 'dist_dir'),
                                   ('plat_name', 'plat_name'),
                                   ('skip_build', 'skip_build'))

    def run(self):
        if not self.skip_build:
            self.run_command('build')

        install = self.reinitialize_command('install', reinit_subcommands=1)
        install.root = self.bdist_dir
        install.skip_build = self.skip_build
        install.warn_dir = 0

        log.info("installing to %s" % self.bdist_dir)
        self.run_command('install')

        # And make an archive relative to the root of the
        # pseudo-installation tree.
        archive_basename = "%s.%s" % (self.distribution.get_fullname(),
                                      self.plat_name)

        # OS/2 objects to any ":" characters in a filename (such as when
        # a timestamp is used in a version) so change them to hyphens.
        if os.name == "os2":
            archive_basename = archive_basename.replace(":", "-")

        pseudoinstall_root = os.path.join(self.dist_dir, archive_basename)
        if not self.relative:
            archive_root = self.bdist_dir
        else:
            if (self.distribution.has_ext_modules() and
                (install.install_base != install.install_platbase)):
                raise DistutilsPlatformError, \
                      ("can't make a dumb built distribution where "
                       "base and platbase are different (%s, %s)"
                       % (repr(install.install_base),
                          repr(install.install_platbase)))
            else:
                archive_root = os.path.join(self.bdist_dir,
                                   ensure_relative(install.install_base))

        # Make the archive
        filename = self.make_archive(pseudoinstall_root,
                                     self.format, root_dir=archive_root,
                                     owner=self.owner, group=self.group)
        if self.distribution.has_ext_modules():
            pyversion = get_python_version()
        else:
            pyversion = 'any'
        self.distribution.dist_files.append(('bdist_dumb', pyversion,
                                             filename))

        if not self.keep_temp:
            remove_tree(self.bdist_dir, dry_run=self.dry_run)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     Û
”´[c           @   sò   d  Z  d Z d d l Z d d l m Z d d l m Z d d l m Z d d l	 m
 Z
 m Z d d l m Z d d	 l m Z d
 e f d Ñ  É  YZ d S(   s∑   distutils.command.bdist_dumb

Implements the Distutils 'bdist_dumb' command (create a "dumb" built
distribution -- i.e., just an archive to be unpacked under $prefix or
$exec_prefix).s   $Id$iˇˇˇˇN(   t   get_python_version(   t   get_platform(   t   Command(   t   remove_treet   ensure_relative(   t   DistutilsPlatformError(   t   logt
   bdist_dumbc           B   së   e  Z d  Z d" d d d e É  f d# d
 d d d f d$ d& d' d( d) g	 Z d
 d d g Z i d d 6d d 6d d 6Z d Ñ  Z d  Ñ  Z	 d! Ñ  Z
 RS(*   s"   create a "dumb" built distributions
   bdist-dir=t   ds1   temporary directory for creating the distributions
   plat-name=t   ps;   platform name to embed in generated filenames (default: %s)s   format=t   fs0   archive format to create (tar, ztar, gztar, zip)s	   keep-tempt   ks/   keep the pseudo-installation tree around after s!   creating the distribution archives	   dist-dir=s-   directory to put final built distributions ins
   skip-builds2   skip rebuilding everything (for testing/debugging)t   relatives6   build the archive using relative paths(default: false)s   owner=t   us@   Owner name used when creating a tar file [default: current user]s   group=t   gsA   Group name used when creating a tar file [default: current group]t   gztart   posixt   zipt   ntt   os2c         C   sU   d  |  _ d  |  _ d  |  _ d |  _ d  |  _ d  |  _ d |  _ d  |  _ d  |  _	 d  S(   Ni    (
   t   Nonet	   bdist_dirt	   plat_namet   formatt	   keep_tempt   dist_dirt
   skip_buildR   t   ownert   group(   t   self(    (    s2   /usr/lib/python2.7/distutils/command/bdist_dumb.pyt   initialize_options7   s    								c         C   sß   |  j  d  k r< |  j d É j } t j j | d É |  _  n  |  j d  k rç y |  j t j	 |  _ Wqç t
 k
 râ t d d t j	 Ç qç Xn  |  j d d d	 d
 É d  S(   Nt   bdistt   dumbs2   don't know how to create dumb built distributions s   on platform %sR   R   R   (   R   R   (   R   R   (   R   R   (   R   R   t   get_finalized_commandt
   bdist_baset   ost   patht   joinR   t   default_formatt   namet   KeyErrorR   t   set_undefined_options(   R   R"   (    (    s2   /usr/lib/python2.7/distutils/command/bdist_dumb.pyt   finalize_optionsB   s    	c      	   C   s◊  |  j  s |  j d É n  |  j d d d É} |  j | _ |  j  | _  d | _ t j d |  j É |  j d É d |  j j	 É  |  j
 f } t j d k r∞ | j d	 d
 É } n  t j j |  j | É } |  j s› |  j } nj |  j j É  r&| j | j k r&t d t | j É t | j É f Ç n! t j j |  j t | j É É } |  j | |  j d | d |  j d |  j É} |  j j É  rèt É  } n d } |  j j j d | | f É |  j s”t  |  j d |  j! Én  d  S(   Nt   buildt   installt   reinit_subcommandsi   i    s   installing to %ss   %s.%sR   t   :t   -sS   can't make a dumb built distribution where base and platbase are different (%s, %s)t   root_dirR   R   t   anyR   t   dry_run("   R   t   run_commandt   reinitialize_commandR   t   roott   warn_dirR   t   infot   distributiont   get_fullnameR   R#   R'   t   replaceR$   R%   R   R   t   has_ext_modulest   install_baset   install_platbaseR   t   reprR   t   make_archiveR   R   R   R    t
   dist_filest   appendR   R   R2   (   R   R,   t   archive_basenamet   pseudoinstall_roott   archive_roott   filenamet	   pyversion(    (    s2   /usr/lib/python2.7/distutils/command/bdist_dumb.pyt   runT   sB    				
	(   s
   bdist-dir=R   s1   temporary directory for creating the distribution(   s   format=R
   s0   archive format to create (tar, ztar, gztar, zip)(   s	   dist-dir=R   s-   directory to put final built distributions inN(   s
   skip-buildNs2   skip rebuilding everything (for testing/debugging)(   R   Ns6   build the archive using relative paths(default: false)(   s   owner=R   s@   Owner name used when creating a tar file [default: current user](   s   group=R   sA   Group name used when creating a tar file [default: current group](   t   __name__t
   __module__t   descriptionR   R   t   user_optionst   boolean_optionsR&   R   R*   RG   (    (    (    s2   /usr/lib/python2.7/distutils/command/bdist_dumb.pyR      s8    
      	

		(   t   __doc__t   __revision__R#   t	   sysconfigR    t   distutils.utilR   t   distutils.coreR   t   distutils.dir_utilR   R   t   distutils.errorsR   t	   distutilsR   R   (    (    (    s2   /usr/lib/python2.7/distutils/command/bdist_dumb.pyt   <module>   s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # -*- coding: iso-8859-1 -*-
# Copyright (C) 2005, 2006 Martin von Lˆwis
# Licensed to PSF under a Contributor Agreement.
# The bdist_wininst command proper
# based on bdist_wininst
"""
Implements the bdist_msi command.
"""
import sys, os
from sysconfig import get_python_version

from distutils.core import Command
from distutils.dir_util import remove_tree
from distutils.version import StrictVersion
from distutils.errors import DistutilsOptionError
from distutils import log
from distutils.util import get_platform

import msilib
from msilib import schema, sequence, text
from msilib import Directory, Feature, Dialog, add_data

class PyDialog(Dialog):
    """Dialog class with a fixed layout: controls at the top, then a ruler,
    then a list of buttons: back, next, cancel. Optionally a bitmap at the
    left."""
    def __init__(self, *args, **kw):
        """Dialog(database, name, x, y, w, h, attributes, title, first,
        default, cancel, bitmap=true)"""
        Dialog.__init__(self, *args)
        ruler = self.h - 36
        #if kw.get("bitmap", True):
        #    self.bitmap("Bitmap", 0, 0, bmwidth, ruler, "PythonWin")
        self.line("BottomLine", 0, ruler, self.w, 0)

    def title(self, title):
        "Set the title text of the dialog at the top."
        # name, x, y, w, h, flags=Visible|Enabled|Transparent|NoPrefix,
        # text, in VerdanaBold10
        self.text("Title", 15, 10, 320, 60, 0x30003,
                  r"{\VerdanaBold10}%s" % title)

    def back(self, title, next, name = "Back", active = 1):
        """Add a back button with a given title, the tab-next button,
        its name in the Control table, possibly initially disabled.

        Return the button, so that events can be associated"""
        if active:
            flags = 3 # Visible|Enabled
        else:
            flags = 1 # Visible
        return self.pushbutton(name, 180, self.h-27 , 56, 17, flags, title, next)

    def cancel(self, title, next, name = "Cancel", active = 1):
        """Add a cancel button with a given title, the tab-next button,
        its name in the Control table, possibly initially disabled.

        Return the button, so that events can be associated"""
        if active:
            flags = 3 # Visible|Enabled
        else:
            flags = 1 # Visible
        return self.pushbutton(name, 304, self.h-27, 56, 17, flags, title, next)

    def next(self, title, next, name = "Next", active = 1):
        """Add a Next button with a given title, the tab-next button,
        its name in the Control table, possibly initially disabled.

        Return the button, so that events can be associated"""
        if active:
            flags = 3 # Visible|Enabled
        else:
            flags = 1 # Visible
        return self.pushbutton(name, 236, self.h-27, 56, 17, flags, title, next)

    def xbutton(self, name, title, next, xpos):
        """Add a button with a given title, the tab-next button,
        its name in the Control table, giving its x position; the
        y-position is aligned with the other buttons.

        Return the button, so that events can be associated"""
        return self.pushbutton(name, int(self.w*xpos - 28), self.h-27, 56, 17, 3, title, next)

class bdist_msi (Command):

    description = "create a Microsoft Installer (.msi) binary distribution"

    user_options = [('bdist-dir=', None,
                     "temporary directory for creating the distribution"),
                    ('plat-name=', 'p',
                     "platform name to embed in generated filenames "
                     "(default: %s)" % get_platform()),
                    ('keep-temp', 'k',
                     "keep the pseudo-installation tree around after " +
                     "creating the distribution archive"),
                    ('target-version=', None,
                     "require a specific python version" +
                     " on the target system"),
                    ('no-target-compile', 'c',
                     "do not compile .py to .pyc on the target system"),
                    ('no-target-optimize', 'o',
                     "do not compile .py to .pyo (optimized)"
                     "on the target system"),
                    ('dist-dir=', 'd',
                     "directory to put final built distributions in"),
                    ('skip-build', None,
                     "skip rebuilding everything (for testing/debugging)"),
                    ('install-script=', None,
                     "basename of installation script to be run after"
                     "installation or before deinstallation"),
                    ('pre-install-script=', None,
                     "Fully qualified filename of a script to be run before "
                     "any files are installed.  This script need not be in the "
                     "distribution"),
                   ]

    boolean_options = ['keep-temp', 'no-target-compile', 'no-target-optimize',
                       'skip-build']

    all_versions = ['2.0', '2.1', '2.2', '2.3', '2.4',
                    '2.5', '2.6', '2.7', '2.8', '2.9',
                    '3.0', '3.1', '3.2', '3.3', '3.4',
                    '3.5', '3.6', '3.7', '3.8', '3.9']
    other_version = 'X'

    def initialize_options (self):
        self.bdist_dir = None
        self.plat_name = None
        self.keep_temp = 0
        self.no_target_compile = 0
        self.no_target_optimize = 0
        self.target_version = None
        self.dist_dir = None
        self.skip_build = None
        self.install_script = None
        self.pre_install_script = None
        self.versions = None

    def finalize_options (self):
        self.set_undefined_options('bdist', ('skip_build', 'skip_build'))

        if self.bdist_dir is None:
            bdist_base = self.get_finalized_command('bdist').bdist_base
            self.bdist_dir = os.path.join(bdist_base, 'msi')

        short_version = get_python_version()
        if (not self.target_version) and self.distribution.has_ext_modules():
            self.target_version = short_version

        if self.target_version:
            self.versions = [self.target_version]
            if not self.skip_build and self.distribution.has_ext_modules()\
               and self.target_version != short_version:
                raise DistutilsOptionError, \
                      "target version can only be %s, or the '--skip-build'" \
                      " option must be specified" % (short_version,)
        else:
            self.versions = list(self.all_versions)

        self.set_undefined_options('bdist',
                                   ('dist_dir', 'dist_dir'),
                                   ('plat_name', 'plat_name'),
                                   )

        if self.pre_install_script:
            raise DistutilsOptionError, "the pre-install-script feature is not yet implemented"

        if self.install_script:
            for script in self.distribution.scripts:
                if self.install_script == os.path.basename(script):
                    break
            else:
                raise DistutilsOptionError, \
                      "install_script '%s' not found in scripts" % \
                      self.install_script
        self.install_script_key = None
    # finalize_options()


    def run (self):
        if not self.skip_build:
            self.run_command('build')

        install = self.reinitialize_command('install', reinit_subcommands=1)
        install.prefix = self.bdist_dir
        install.skip_build = self.skip_build
        install.warn_dir = 0

        install_lib = self.reinitialize_command('install_lib')
        # we do not want to include pyc or pyo files
        install_lib.compile = 0
        install_lib.optimize = 0

        if self.distribution.has_ext_modules():
            # If we are building an installer for a Python version other
            # than the one we are currently running, then we need to ensure
            # our build_lib reflects the other Python version rather than ours.
            # Note that for target_version!=sys.version, we must have skipped the
            # build step, so there is no issue with enforcing the build of this
            # version.
            target_version = self.target_version
            if not target_version:
                assert self.skip_build, "Should have already checked this"
                target_version = sys.version[0:3]
            plat_specifier = ".%s-%s" % (self.plat_name, target_version)
            build = self.get_finalized_command('build')
            build.build_lib = os.path.join(build.build_base,
                                           'lib' + plat_specifier)

        log.info("installing to %s", self.bdist_dir)
        install.ensure_finalized()

        # avoid warning of 'install_lib' about installing
        # into a directory not in sys.path
        sys.path.insert(0, os.path.join(self.bdist_dir, 'PURELIB'))

        install.run()

        del sys.path[0]

        self.mkpath(self.dist_dir)
        fullname = self.distribution.get_fullname()
        installer_name = self.get_installer_filename(fullname)
        installer_name = os.path.abspath(installer_name)
        if os.path.exists(installer_name): os.unlink(installer_name)

        metadata = self.distribution.metadata
        author = metadata.author
        if not author:
            author = metadata.maintainer
        if not author:
            author = "UNKNOWN"
        version = metadata.get_version()
        # ProductVersion must be strictly numeric
        # XXX need to deal with prerelease versions
        sversion = "%d.%d.%d" % StrictVersion(version).version
        # Prefix ProductName with Python x.y, so that
        # it sorts together with the other Python packages
        # in Add-Remove-Programs (APR)
        fullname = self.distribution.get_fullname()
        if self.target_version:
            product_name = "Python %s %s" % (self.target_version, fullname)
        else:
            product_name = "Python %s" % (fullname)
        self.db = msilib.init_database(installer_name, schema,
                product_name, msilib.gen_uuid(),
                sversion, author)
        msilib.add_tables(self.db, sequence)
        props = [('DistVersion', version)]
        email = metadata.author_email or metadata.maintainer_email
        if email:
            props.append(("ARPCONTACT", email))
        if metadata.url:
            props.append(("ARPURLINFOABOUT", metadata.url))
        if props:
            add_data(self.db, 'Property', props)

        self.add_find_python()
        self.add_files()
        self.add_scripts()
        self.add_ui()
        self.db.Commit()

        if hasattr(self.distribution, 'dist_files'):
            tup = 'bdist_msi', self.target_version or 'any', fullname
            self.distribution.dist_files.append(tup)

        if not self.keep_temp:
            remove_tree(self.bdist_dir, dry_run=self.dry_run)

    def add_files(self):
        db = self.db
        cab = msilib.CAB("distfiles")
        rootdir = os.path.abspath(self.bdist_dir)

        root = Directory(db, cab, None, rootdir, "TARGETDIR", "SourceDir")
        f = Feature(db, "Python", "Python", "Everything",
                    0, 1, directory="TARGETDIR")

        items = [(f, root, '')]
        for version in self.versions + [self.other_version]:
            target = "TARGETDIR" + version
            name = default = "Python" + version
            desc = "Everything"
            if version is self.other_version:
                title = "Python from another location"
                level = 2
            else:
                title = "Python %s from registry" % version
                level = 1
            f = Feature(db, name, title, desc, 1, level, directory=target)
            dir = Directory(db, cab, root, rootdir, target, default)
            items.append((f, dir, version))
        db.Commit()

        seen = {}
        for feature, dir, version in items:
            todo = [dir]
            while todo:
                dir = todo.pop()
                for file in os.listdir(dir.absolute):
                    afile = os.path.join(dir.absolute, file)
                    if os.path.isdir(afile):
                        short = "%s|%s" % (dir.make_short(file), file)
                        default = file + version
                        newdir = Directory(db, cab, dir, file, default, short)
                        todo.append(newdir)
                    else:
                        if not dir.component:
                            dir.start_component(dir.logical, feature, 0)
                        if afile not in seen:
                            key = seen[afile] = dir.add_file(file)
                            if file==self.install_script:
                                if self.install_script_key:
                                    raise DistutilsOptionError(
                                          "Multiple files with name %s" % file)
                                self.install_script_key = '[#%s]' % key
                        else:
                            key = seen[afile]
                            add_data(self.db, "DuplicateFile",
                                [(key + version, dir.component, key, None, dir.logical)])
            db.Commit()
        cab.commit(db)

    def add_find_python(self):
        """Adds code to the installer to compute the location of Python.

        Properties PYTHON.MACHINE.X.Y and PYTHON.USER.X.Y will be set from the
        registry for each version of Python.

        Properties TARGETDIRX.Y will be set from PYTHON.USER.X.Y if defined,
        else from PYTHON.MACHINE.X.Y.

        Properties PYTHONX.Y will be set to TARGETDIRX.Y\\python.exe"""

        start = 402
        for ver in self.versions:
            install_path = r"SOFTWARE\Python\PythonCore\%s\InstallPath" % ver
            machine_reg = "python.machine." + ver
            user_reg = "python.user." + ver
            machine_prop = "PYTHON.MACHINE." + ver
            user_prop = "PYTHON.USER." + ver
            machine_action = "PythonFromMachine" + ver
            user_action = "PythonFromUser" + ver
            exe_action = "PythonExe" + ver
            target_dir_prop = "TARGETDIR" + ver
            exe_prop = "PYTHON" + ver
            if msilib.Win64:
                # type: msidbLocatorTypeRawValue + msidbLocatorType64bit
                Type = 2+16
            else:
                Type = 2
            add_data(self.db, "RegLocator",
                    [(machine_reg, 2, install_path, None, Type),
                     (user_reg, 1, install_path, None, Type)])
            add_data(self.db, "AppSearch",
                    [(machine_prop, machine_reg),
                     (user_prop, user_reg)])
            add_data(self.db, "CustomAction",
                    [(machine_action, 51+256, target_dir_prop, "[" + machine_prop + "]"),
                     (user_action, 51+256, target_dir_prop, "[" + user_prop + "]"),
                     (exe_action, 51+256, exe_prop, "[" + target_dir_prop + "]\\python.exe"),
                    ])
            add_data(self.db, "InstallExecuteSequence",
                    [(machine_action, machine_prop, start),
                     (user_action, user_prop, start + 1),
                     (exe_action, None, start + 2),
                    ])
            add_data(self.db, "InstallUISequence",
                    [(machine_action, machine_prop, start),
                     (user_action, user_prop, start + 1),
                     (exe_action, None, start + 2),
                    ])
            add_data(self.db, "Condition",
                    [("Python" + ver, 0, "NOT TARGETDIR" + ver)])
            start += 4
            assert start < 500

    def add_scripts(self):
        if self.install_script:
            start = 6800
            for ver in self.versions + [self.other_version]:
                install_action = "install_script." + ver
                exe_prop = "PYTHON" + ver
                add_data(self.db, "CustomAction",
                        [(install_action, 50, exe_prop, self.install_script_key)])
                add_data(self.db, "InstallExecuteSequence",
                        [(install_action, "&Python%s=3" % ver, start)])
                start += 1
        # XXX pre-install scripts are currently refused in finalize_options()
        #     but if this feature is completed, it will also need to add
        #     entries for each version as the above code does
        if self.pre_install_script:
            scriptfn = os.path.join(self.bdist_dir, "preinstall.bat")
            f = open(scriptfn, "w")
            # The batch file will be executed with [PYTHON], so that %1
            # is the path to the Python interpreter; %0 will be the path
            # of the batch file.
            # rem ="""
            # %1 %0
            # exit
            # """
            # <actual script>
            f.write('rem ="""\n%1 %0\nexit\n"""\n')
            f.write(open(self.pre_install_script).read())
            f.close()
            add_data(self.db, "Binary",
                [("PreInstall", msilib.Binary(scriptfn))
                ])
            add_data(self.db, "CustomAction",
                [("PreInstall", 2, "PreInstall", None)
                ])
            add_data(self.db, "InstallExecuteSequence",
                    [("PreInstall", "NOT Installed", 450)])


    def add_ui(self):
        db = self.db
        x = y = 50
        w = 370
        h = 300
        title = "[ProductName] Setup"

        # see "Dialog Style Bits"
        modal = 3      # visible | modal
        modeless = 1   # visible

        # UI customization properties
        add_data(db, "Property",
                 # See "DefaultUIFont Property"
                 [("DefaultUIFont", "DlgFont8"),
                  # See "ErrorDialog Style Bit"
                  ("ErrorDialog", "ErrorDlg"),
                  ("Progress1", "Install"),   # modified in maintenance type dlg
                  ("Progress2", "installs"),
                  ("MaintenanceForm_Action", "Repair"),
                  # possible values: ALL, JUSTME
                  ("WhichUsers", "ALL")
                 ])

        # Fonts, see "TextStyle Table"
        add_data(db, "TextStyle",
                 [("DlgFont8", "Tahoma", 9, None, 0),
                  ("DlgFontBold8", "Tahoma", 8, None, 1), #bold
                  ("VerdanaBold10", "Verdana", 10, None, 1),
                  ("VerdanaRed9", "Verdana", 9, 255, 0),
                 ])

        # UI Sequences, see "InstallUISequence Table", "Using a Sequence Table"
        # Numbers indicate sequence; see sequence.py for how these action integrate
        add_data(db, "InstallUISequence",
                 [("PrepareDlg", "Not Privileged or Windows9x or Installed", 140),
                  ("WhichUsersDlg", "Privileged and not Windows9x and not Installed", 141),
                  # In the user interface, assume all-users installation if privileged.
                  ("SelectFeaturesDlg", "Not Installed", 1230),
                  # XXX no support for resume installations yet
                  #("ResumeDlg", "Installed AND (RESUME OR Preselected)", 1240),
                  ("MaintenanceTypeDlg", "Installed AND NOT RESUME AND NOT Preselected", 1250),
                  ("ProgressDlg", None, 1280)])

        add_data(db, 'ActionText', text.ActionText)
        add_data(db, 'UIText', text.UIText)
        #####################################################################
        # Standard dialogs: FatalError, UserExit, ExitDialog
        fatal=PyDialog(db, "FatalError", x, y, w, h, modal, title,
                     "Finish", "Finish", "Finish")
        fatal.title("[ProductName] Installer ended prematurely")
        fatal.back("< Back", "Finish", active = 0)
        fatal.cancel("Cancel", "Back", active = 0)
        fatal.text("Description1", 15, 70, 320, 80, 0x30003,
                   "[ProductName] setup ended prematurely because of an error.  Your system has not been modified.  To install this program at a later time, please run the installation again.")
        fatal.text("Description2", 15, 155, 320, 20, 0x30003,
                   "Click the Finish button to exit the Installer.")
        c=fatal.next("Finish", "Cancel", name="Finish")
        c.event("EndDialog", "Exit")

        user_exit=PyDialog(db, "UserExit", x, y, w, h, modal, title,
                     "Finish", "Finish", "Finish")
        user_exit.title("[ProductName] Installer was interrupted")
        user_exit.back("< Back", "Finish", active = 0)
        user_exit.cancel("Cancel", "Back", active = 0)
        user_exit.text("Description1", 15, 70, 320, 80, 0x30003,
                   "[ProductName] setup was interrupted.  Your system has not been modified.  "
                   "To install this program at a later time, please run the installation again.")
        user_exit.text("Description2", 15, 155, 320, 20, 0x30003,
                   "Click the Finish button to exit the Installer.")
        c = user_exit.next("Finish", "Cancel", name="Finish")
        c.event("EndDialog", "Exit")

        exit_dialog = PyDialog(db, "ExitDialog", x, y, w, h, modal, title,
                             "Finish", "Finish", "Finish")
        exit_dialog.title("Completing the [ProductName] Installer")
        exit_dialog.back("< Back", "Finish", active = 0)
        exit_dialog.cancel("Cancel", "Back", active = 0)
        exit_dialog.text("Description", 15, 235, 320, 20, 0x30003,
                   "Click the Finish button to exit the Installer.")
        c = exit_dialog.next("Finish", "Cancel", name="Finish")
        c.event("EndDialog", "Return")

        #####################################################################
        # Required dialog: FilesInUse, ErrorDlg
        inuse = PyDialog(db, "FilesInUse",
                         x, y, w, h,
                         19,                # KeepModeless|Modal|Visible
                         title,
                         "Retry", "Retry", "Retry", bitmap=False)
        inuse.text("Title", 15, 6, 200, 15, 0x30003,
                   r"{\DlgFontBold8}Files in Use")
        inuse.text("Description", 20, 23, 280, 20, 0x30003,
               "Some files that need to be updated are currently in use.")
        inuse.text("Text", 20, 55, 330, 50, 3,
                   "The following applications are using files that need to be updated by this setup. Close these applications and then click Retry to continue the installation or Cancel to exit it.")
        inuse.control("List", "ListBox", 20, 107, 330, 130, 7, "FileInUseProcess",
                      None, None, None)
        c=inuse.back("Exit", "Ignore", name="Exit")
        c.event("EndDialog", "Exit")
        c=inuse.next("Ignore", "Retry", name="Ignore")
        c.event("EndDialog", "Ignore")
        c=inuse.cancel("Retry", "Exit", name="Retry")
        c.event("EndDialog","Retry")

        # See "Error Dialog". See "ICE20" for the required names of the controls.
        error = Dialog(db, "ErrorDlg",
                       50, 10, 330, 101,
                       65543,       # Error|Minimize|Modal|Visible
                       title,
                       "ErrorText", None, None)
        error.text("ErrorText", 50,9,280,48,3, "")
        #error.control("ErrorIcon", "Icon", 15, 9, 24, 24, 5242881, None, "py.ico", None, None)
        error.pushbutton("N",120,72,81,21,3,"No",None).event("EndDialog","ErrorNo")
        error.pushbutton("Y",240,72,81,21,3,"Yes",None).event("EndDialog","ErrorYes")
        error.pushbutton("A",0,72,81,21,3,"Abort",None).event("EndDialog","ErrorAbort")
        error.pushbutton("C",42,72,81,21,3,"Cancel",None).event("EndDialog","ErrorCancel")
        error.pushbutton("I",81,72,81,21,3,"Ignore",None).event("EndDialog","ErrorIgnore")
        error.pushbutton("O",159,72,81,21,3,"Ok",None).event("EndDialog","ErrorOk")
        error.pushbutton("R",198,72,81,21,3,"Retry",None).event("EndDialog","ErrorRetry")

        #####################################################################
        # Global "Query Cancel" dialog
        cancel = Dialog(db, "CancelDlg", 50, 10, 260, 85, 3, title,
                        "No", "No", "No")
        cancel.text("Text", 48, 15, 194, 30, 3,
                    "Are you sure you want to cancel [ProductName] installation?")
        #cancel.control("Icon", "Icon", 15, 15, 24, 24, 5242881, None,
        #               "py.ico", None, None)
        c=cancel.pushbutton("Yes", 72, 57, 56, 17, 3, "Yes", "No")
        c.event("EndDialog", "Exit")

        c=cancel.pushbutton("No", 132, 57, 56, 17, 3, "No", "Yes")
        c.event("EndDialog", "Return")

        #####################################################################
        # Global "Wait for costing" dialog
        costing = Dialog(db, "WaitForCostingDlg", 50, 10, 260, 85, modal, title,
                         "Return", "Return", "Return")
        costing.text("Text", 48, 15, 194, 30, 3,
                     "Please wait while the installer finishes determining your disk space requirements.")
        c = costing.pushbutton("Return", 102, 57, 56, 17, 3, "Return", None)
        c.event("EndDialog", "Exit")

        #####################################################################
        # Preparation dialog: no user input except cancellation
        prep = PyDialog(db, "PrepareDlg", x, y, w, h, modeless, title,
                        "Cancel", "Cancel", "Cancel")
        prep.text("Description", 15, 70, 320, 40, 0x30003,
                  "Please wait while the Installer prepares to guide you through the installation.")
        prep.title("Welcome to the [ProductName] Installer")
        c=prep.text("ActionText", 15, 110, 320, 20, 0x30003, "Pondering...")
        c.mapping("ActionText", "Text")
        c=prep.text("ActionData", 15, 135, 320, 30, 0x30003, None)
        c.mapping("ActionData", "Text")
        prep.back("Back", None, active=0)
        prep.next("Next", None, active=0)
        c=prep.cancel("Cancel", None)
        c.event("SpawnDialog", "CancelDlg")

        #####################################################################
        # Feature (Python directory) selection
        seldlg = PyDialog(db, "SelectFeaturesDlg", x, y, w, h, modal, title,
                        "Next", "Next", "Cancel")
        seldlg.title("Select Python Installations")

        seldlg.text("Hint", 15, 30, 300, 20, 3,
                    "Select the Python locations where %s should be installed."
                    % self.distribution.get_fullname())

        seldlg.back("< Back", None, active=0)
        c = seldlg.next("Next >", "Cancel")
        order = 1
        c.event("[TARGETDIR]", "[SourceDir]", ordering=order)
        for version in self.versions + [self.other_version]:
            order += 1
            c.event("[TARGETDIR]", "[TARGETDIR%s]" % version,
                    "FEATURE_SELECTED AND &Python%s=3" % version,
                    ordering=order)
        c.event("SpawnWaitDialog", "WaitForCostingDlg", ordering=order + 1)
        c.event("EndDialog", "Return", ordering=order + 2)
        c = seldlg.cancel("Cancel", "Features")
        c.event("SpawnDialog", "CancelDlg")

        c = seldlg.control("Features", "SelectionTree", 15, 60, 300, 120, 3,
                           "FEATURE", None, "PathEdit", None)
        c.event("[FEATURE_SELECTED]", "1")
        ver = self.other_version
        install_other_cond = "FEATURE_SELECTED AND &Python%s=3" % ver
        dont_install_other_cond = "FEATURE_SELECTED AND &Python%s<>3" % ver

        c = seldlg.text("Other", 15, 200, 300, 15, 3,
                        "Provide an alternate Python location")
        c.condition("Enable", install_other_cond)
        c.condition("Show", install_other_cond)
        c.condition("Disable", dont_install_other_cond)
        c.condition("Hide", dont_install_other_cond)

        c = seldlg.control("PathEdit", "PathEdit", 15, 215, 300, 16, 1,
                           "TARGETDIR" + ver, None, "Next", None)
        c.condition("Enable", install_other_cond)
        c.condition("Show", install_other_cond)
        c.condition("Disable", dont_install_other_cond)
        c.condition("Hide", dont_install_other_cond)

        #####################################################################
        # Disk cost
        cost = PyDialog(db, "DiskCostDlg", x, y, w, h, modal, title,
                        "OK", "OK", "OK", bitmap=False)
        cost.text("Title", 15, 6, 200, 15, 0x30003,
                  "{\DlgFontBold8}Disk Space Requirements")
        cost.text("Description", 20, 20, 280, 20, 0x30003,
                  "The disk space required for the installation of the selected features.")
        cost.text("Text", 20, 53, 330, 60, 3,
                  "The highlighted volumes (if any) do not have enough disk space "
              "available for the currently selected features.  You can either "
              "remove some files from the highlighted volumes, or choose to "
              "install less features onto local drive(s), or select different "
              "destination drive(s).")
        cost.control("VolumeList", "VolumeCostList", 20, 100, 330, 150, 393223,
                     None, "{120}{70}{70}{70}{70}", None, None)
        cost.xbutton("OK", "Ok", None, 0.5).event("EndDialog", "Return")

        #####################################################################
        # WhichUsers Dialog. Only available on NT, and for privileged users.
        # This must be run before FindRelatedProducts, because that will
        # take into account whether the previous installation was per-user
        # or per-machine. We currently don't support going back to this
        # dialog after "Next" was selected; to support this, we would need to
        # find how to reset the ALLUSERS property, and how to re-run
        # FindRelatedProducts.
        # On Windows9x, the ALLUSERS property is ignored on the command line
        # and in the Property table, but installer fails according to the documentation
        # if a dialog attempts to set ALLUSERS.
        whichusers = PyDialog(db, "WhichUsersDlg", x, y, w, h, modal, title,
                            "AdminInstall", "Next", "Cancel")
        whichusers.title("Select whether to install [ProductName] for all users of this computer.")
        # A radio group with two options: allusers, justme
        g = whichusers.radiogroup("AdminInstall", 15, 60, 260, 50, 3,
                                  "WhichUsers", "", "Next")
        g.add("ALL", 0, 5, 150, 20, "Install for all users")
        g.add("JUSTME", 0, 25, 150, 20, "Install just for me")

        whichusers.back("Back", None, active=0)

        c = whichusers.next("Next >", "Cancel")
        c.event("[ALLUSERS]", "1", 'WhichUsers="ALL"', 1)
        c.event("EndDialog", "Return", ordering = 2)

        c = whichusers.cancel("Cancel", "AdminInstall")
        c.event("SpawnDialog", "CancelDlg")

        #####################################################################
        # Installation Progress dialog (modeless)
        progress = PyDialog(db, "ProgressDlg", x, y, w, h, modeless, title,
                            "Cancel", "Cancel", "Cancel", bitmap=False)
        progress.text("Title", 20, 15, 200, 15, 0x30003,
                      "{\DlgFontBold8}[Progress1] [ProductName]")
        progress.text("Text", 35, 65, 300, 30, 3,
                      "Please wait while the Installer [Progress2] [ProductName]. "
                      "This may take several minutes.")
        progress.text("StatusLabel", 35, 100, 35, 20, 3, "Status:")

        c=progress.text("ActionText", 70, 100, w-70, 20, 3, "Pondering...")
        c.mapping("ActionText", "Text")

        #c=progress.text("ActionData", 35, 140, 300, 20, 3, None)
        #c.mapping("ActionData", "Text")

        c=progress.control("ProgressBar", "ProgressBar", 35, 120, 300, 10, 65537,
                           None, "Progress done", None, None)
        c.mapping("SetProgress", "Progress")

        progress.back("< Back", "Next", active=False)
        progress.next("Next >", "Cancel", active=False)
        progress.cancel("Cancel", "Back").event("SpawnDialog", "CancelDlg")

        ###################################################################
        # Maintenance type: repair/uninstall
        maint = PyDialog(db, "MaintenanceTypeDlg", x, y, w, h, modal, title,
                         "Next", "Next", "Cancel")
        maint.title("Welcome to the [ProductName] Setup Wizard")
        maint.text("BodyText", 15, 63, 330, 42, 3,
                   "Select whether you want to repair or remove [ProductName].")
        g=maint.radiogroup("RepairRadioGroup", 15, 108, 330, 60, 3,
                            "MaintenanceForm_Action", "", "Next")
        #g.add("Change", 0, 0, 200, 17, "&Change [ProductName]")
        g.add("Repair", 0, 18, 200, 17, "&Repair [ProductName]")
        g.add("Remove", 0, 36, 200, 17, "Re&move [ProductName]")

        maint.back("< Back", None, active=False)
        c=maint.next("Finish", "Cancel")
        # Change installation: Change progress dialog to "Change", then ask
        # for feature selection
        #c.event("[Progress1]", "Change", 'MaintenanceForm_Action="Change"', 1)
        #c.event("[Progress2]", "changes", 'MaintenanceForm_Action="Change"', 2)

        # Reinstall: Change progress dialog to "Repair", then invoke reinstall
        # Also set list of reinstalled features to "ALL"
        c.event("[REINSTALL]", "ALL", 'MaintenanceForm_Action="Repair"', 5)
        c.event("[Progress1]", "Repairing", 'MaintenanceForm_Action="Repair"', 6)
        c.event("[Progress2]", "repairs", 'MaintenanceForm_Action="Repair"', 7)
        c.event("Reinstall", "ALL", 'MaintenanceForm_Action="Repair"', 8)

        # Uninstall: Change progress to "Remove", then invoke uninstall
        # Also set list of removed features to "ALL"
        c.event("[REMOVE]", "ALL", 'MaintenanceForm_Action="Remove"', 11)
        c.event("[Progress1]", "Removing", 'MaintenanceForm_Action="Remove"', 12)
        c.event("[Progress2]", "removes", 'MaintenanceForm_Action="Remove"', 13)
        c.event("Remove", "ALL", 'MaintenanceForm_Action="Remove"', 14)

        # Close dialog when maintenance action scheduled
        c.event("EndDialog", "Return", 'MaintenanceForm_Action<>"Change"', 20)
        #c.event("NewDialog", "SelectFeaturesDlg", 'MaintenanceForm_Action="Change"', 21)

        maint.cancel("Cancel", "RepairRadioGroup").event("SpawnDialog", "CancelDlg")

    def get_installer_filename(self, fullname):
        # Factored out to allow overriding in subclasses
        if self.target_version:
            base_name = "%s.%s-py%s.msi" % (fullname, self.plat_name,
                                            self.target_version)
        else:
            base_name = "%s.%s.msi" % (fullname, self.plat_name)
        installer_name = os.path.join(self.dist_dir, base_name)
        return installer_name
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         Û
”´[c           @   s  d  Z  d d l Z d d l Z d d l m Z d d l m Z d d l m Z d d l	 m
 Z
 d d l m Z d d l m Z d d	 l m Z d d l Z d d
 l m Z m Z m Z d d l m Z m Z m Z m Z d e f d Ñ  É  YZ d e f d Ñ  É  YZ d S(   s#   
Implements the bdist_msi command.
iˇˇˇˇN(   t   get_python_version(   t   Command(   t   remove_tree(   t   StrictVersion(   t   DistutilsOptionError(   t   log(   t   get_platform(   t   schemat   sequencet   text(   t	   Directoryt   Featuret   Dialogt   add_datat   PyDialogc           B   sV   e  Z d  Z d Ñ  Z d Ñ  Z d d d Ñ Z d d d Ñ Z d d d	 Ñ Z d
 Ñ  Z RS(   sô   Dialog class with a fixed layout: controls at the top, then a ruler,
    then a list of buttons: back, next, cancel. Optionally a bitmap at the
    left.c         O   s=   t  j |  | å |  j d } |  j d d | |  j d É d S(   sb   Dialog(database, name, x, y, w, h, attributes, title, first,
        default, cancel, bitmap=true)i$   t
   BottomLinei    N(   R   t   __init__t   ht   linet   w(   t   selft   argst   kwt   ruler(    (    s1   /usr/lib/python2.7/distutils/command/bdist_msi.pyR      s    c      	   C   s'   |  j  d d d d d d d | É d S(	   s,   Set the title text of the dialog at the top.t   Titlei   i
   i@  i<   i  s   {\VerdanaBold10}%sN(   R	   (   R   t   title(    (    s1   /usr/lib/python2.7/distutils/command/bdist_msi.pyR   $   s    t   Backi   c      	   C   s>   | r d } n d } |  j  | d |  j d d d | | | É S(   sª   Add a back button with a given title, the tab-next button,
        its name in the Control table, possibly initially disabled.

        Return the button, so that events can be associatedi   i   i¥   i   i8   i   (   t
   pushbuttonR   (   R   R   t   nextt   namet   activet   flags(    (    s1   /usr/lib/python2.7/distutils/command/bdist_msi.pyt   back+   s    	t   Cancelc      	   C   s>   | r d } n d } |  j  | d |  j d d d | | | É S(   sΩ   Add a cancel button with a given title, the tab-next button,
        its name in the Control table, possibly initially disabled.

        Return the button, so that events can be associatedi   i   i0  i   i8   i   (   R   R   (   R   R   R   R   R   R   (    (    s1   /usr/lib/python2.7/distutils/command/bdist_msi.pyt   cancel6   s    	t   Nextc      	   C   s>   | r d } n d } |  j  | d |  j d d d | | | É S(   sª   Add a Next button with a given title, the tab-next button,
        its name in the Control table, possibly initially disabled.

        Return the button, so that events can be associatedi   i   iÏ   i   i8   i   (   R   R   (   R   R   R   R   R   R   (    (    s1   /usr/lib/python2.7/distutils/command/bdist_msi.pyR   A   s    	c      	   C   s:   |  j  | t |  j | d É |  j d d d d | | É S(   sÍ   Add a button with a given title, the tab-next button,
        its name in the Control table, giving its x position; the
        y-position is aligned with the other buttons.

        Return the button, so that events can be associatedi   i   i8   i   i   (   R   t   intR   R   (   R   R   R   R   t   xpos(    (    s1   /usr/lib/python2.7/distutils/command/bdist_msi.pyt   xbuttonL   s    (	   t   __name__t
   __module__t   __doc__R   R   R    R"   R   R&   (    (    (    s1   /usr/lib/python2.7/distutils/command/bdist_msi.pyR      s   			t	   bdist_msic           B   s=  e  Z d  Z d e d f d d d e É  f d d d d	 f d
 e d d f d d d f d d d f d d d f d e d f d e d f d e d f g
 Z d d d d g Z d d d d d  d! d" d# d$ d% d& d' d( d) d* d+ d, d- d. d/ g Z d0 Z d1 Ñ  Z	 d2 Ñ  Z
 d3 Ñ  Z d4 Ñ  Z d5 Ñ  Z d6 Ñ  Z d7 Ñ  Z d8 Ñ  Z RS(9   s7   create a Microsoft Installer (.msi) binary distributions
   bdist-dir=s1   temporary directory for creating the distributions
   plat-name=t   ps;   platform name to embed in generated filenames (default: %s)s	   keep-tempt   ks/   keep the pseudo-installation tree around after s!   creating the distribution archives   target-version=s!   require a specific python versions    on the target systems   no-target-compilet   cs/   do not compile .py to .pyc on the target systems   no-target-optimizet   os:   do not compile .py to .pyo (optimized)on the target systems	   dist-dir=t   ds-   directory to put final built distributions ins
   skip-builds2   skip rebuilding everything (for testing/debugging)s   install-script=sT   basename of installation script to be run afterinstallation or before deinstallations   pre-install-script=s{   Fully qualified filename of a script to be run before any files are installed.  This script need not be in the distributions   2.0s   2.1s   2.2s   2.3s   2.4s   2.5s   2.6s   2.7s   2.8s   2.9s   3.0s   3.1s   3.2s   3.3s   3.4s   3.5s   3.6s   3.7s   3.8s   3.9t   Xc         C   sg   d  |  _ d  |  _ d |  _ d |  _ d |  _ d  |  _ d  |  _ d  |  _ d  |  _	 d  |  _
 d  |  _ d  S(   Ni    (   t   Nonet	   bdist_dirt	   plat_namet	   keep_tempt   no_target_compilet   no_target_optimizet   target_versiont   dist_dirt
   skip_buildt   install_scriptt   pre_install_scriptt   versions(   R   (    (    s1   /usr/lib/python2.7/distutils/command/bdist_msi.pyt   initialize_options~   s    										c         C   si  |  j  d d	 É |  j d  k rL |  j d É j } t j j | d É |  _ n  t É  } |  j	 rz |  j
 j É  rz | |  _	 n  |  j	 r– |  j	 g |  _ |  j r‚ |  j
 j É  r‚ |  j	 | k r‚ t d | f Ç q‚ n t |  j É |  _ |  j  d d
 d É |  j r
t d Ç n  |  j r\xF |  j
 j D]% } |  j t j j | É k r Pq q Wt d |  j Ç n  d  |  _ d  S(   Nt   bdistR9   t   msisM   target version can only be %s, or the '--skip-build' option must be specifiedR8   R3   s5   the pre-install-script feature is not yet implementeds(   install_script '%s' not found in scripts(   R9   R9   (   R8   R8   (   R3   R3   (   t   set_undefined_optionsR2   R1   t   get_finalized_commandt
   bdist_baset   ost   patht   joinR    R7   t   distributiont   has_ext_modulesR<   R9   R   t   listt   all_versionsR;   R:   t   scriptst   basenamet   install_script_key(   R   RB   t   short_versiont   script(    (    s1   /usr/lib/python2.7/distutils/command/bdist_msi.pyt   finalize_optionsã   s8    					c         C   sè  |  j  s |  j d É n  |  j d d d É} |  j | _ |  j  | _  d | _ |  j d É } d | _ d | _ |  j j	 É  r˙ |  j
 } | s∂ |  j  s£ t d É Ç t j d d !} n  d	 |  j | f } |  j d É } t j j | j d
 | É | _ n  t j d |  j É | j É  t j j d t j j |  j d É É | j É  t j d =|  j |  j É |  j j É  } |  j | É } t j j | É } t j j | É r≤t j  | É n  |  j j! } | j" }	 |	 sŸ| j# }	 n  |	 sËd }	 n  | j$ É  }
 d t% |
 É j } |  j j É  } |  j
 r5d |  j
 | f } n
 d | } t& j' | t( | t& j) É  | |	 É |  _* t& j+ |  j* t, É d |
 f g } | j- pó| j. } | r∂| j/ d | f É n  | j0 rÿ| j/ d | j0 f É n  | rÙt1 |  j* d | É n  |  j2 É  |  j3 É  |  j4 É  |  j5 É  |  j* j6 É  t7 |  j d É rid |  j
 pJd | f } |  j j8 j/ | É n  |  j9 sãt: |  j d |  j; Én  d  S(   Nt   buildt   installt   reinit_subcommandsi   i    t   install_libs    Should have already checked thisi   s   .%s-%st   libs   installing to %st   PURELIBt   UNKNOWNs   %d.%d.%ds   Python %s %ss	   Python %st   DistVersiont
   ARPCONTACTt   ARPURLINFOABOUTt   Propertyt
   dist_filesR*   t   anyt   dry_run(<   R9   t   run_commandt   reinitialize_commandR2   t   prefixt   warn_dirt   compilet   optimizeRF   RG   R7   t   AssertionErrort   syst   versionR3   RA   RC   RD   RE   t
   build_baset	   build_libR   t   infot   ensure_finalizedt   insertt   runt   mkpathR8   t   get_fullnamet   get_installer_filenamet   abspatht   existst   unlinkt   metadatat   authort
   maintainert   get_versionR   t   msilibt   init_databaseR   t   gen_uuidt   dbt
   add_tablesR   t   author_emailt   maintainer_emailt   appendt   urlR   t   add_find_pythont	   add_filest   add_scriptst   add_uit   Committ   hasattrR[   R4   R   R]   (   R   RQ   RS   R7   t   plat_specifierRP   t   fullnamet   installer_nameRs   Rt   Rf   t   sversiont   product_namet   propst   emailt   tup(    (    s1   /usr/lib/python2.7/distutils/command/bdist_msi.pyRl   ¥   s~    					
%

 			
	



	c      
   C   sÔ  |  j  } t j d É } t j j |  j É } t | | d  | d d É } t	 | d d d d d d d É} | | d	 f g } xπ |  j
 |  j g D]§ } d | } d | }	 }
 d } | |  j k r— d
 } d } n d | } d } t	 | |	 | | d | d | É} t | | | | | |
 É } | j | | | f É qè W| j É  i  } xî| D]å\ } } } | g } xg| rœ| j É  } xNt j | j É D]:} t j j | j | É } t j j | É rd | j | É | f } | | }
 t | | | | |
 | É } | j | É qé| j s.| j | j | d É n  | | k rè| j | É } | | <| |  j k r»|  j r|t d | É Ç n  d | |  _ q»qé| | } t |  j  d | | | j | d  | j f g É qéWqiW| j É  qNW| j | É d  S(   Nt	   distfilest	   TARGETDIRt	   SourceDirt   Pythont
   Everythingi    i   t	   directoryt    s   Python from another locationi   s   Python %s from registrys   %s|%ss   Multiple files with name %ss   [#%s]t   DuplicateFile(   Rz   Rw   t   CABRC   RD   Rp   R2   R
   R1   R   R<   t   other_versionR~   RÑ   t   popt   listdirt   absoluteRE   t   isdirt
   make_shortt	   componentt   start_componentt   logicalt   add_fileR:   RL   R   R   t   commit(   R   Rz   t   cabt   rootdirt   roott   ft   itemsRf   t   targetR   t   defaultt   descR   t   levelt   dirt   seent   featuret   todot   filet   afilet   shortt   newdirt   key(    (    s1   /usr/lib/python2.7/distutils/command/bdist_msi.pyRÅ     s\    	
	
!
		
		
+c         C   s  d } x|  j  D]˜} d | } d | } d | } d | } d | } d | } d | }	 d	 | }
 d
 | } d | } t j rå d  } n d } t |  j d | d | d | f | d | d | f g É t |  j d | | f | | f g É t |  j d | d! | d | d f |	 d" | d | d f |
 d# | d | d f g É t |  j d | | | f |	 | | d f |
 d | d f g É t |  j d | | | f |	 | | d f |
 d | d f g É t |  j d d | d d | f g É | d 7} | d k  s t Ç q Wd S($   ss  Adds code to the installer to compute the location of Python.

        Properties PYTHON.MACHINE.X.Y and PYTHON.USER.X.Y will be set from the
        registry for each version of Python.

        Properties TARGETDIRX.Y will be set from PYTHON.USER.X.Y if defined,
        else from PYTHON.MACHINE.X.Y.

        Properties PYTHONX.Y will be set to TARGETDIRX.Y\python.exeií  s)   SOFTWARE\Python\PythonCore\%s\InstallPaths   python.machine.s   python.user.s   PYTHON.MACHINE.s   PYTHON.USER.t   PythonFromMachinet   PythonFromUsert	   PythonExeRè   t   PYTHONi   i   t
   RegLocatori   t	   AppSearcht   CustomActioni3   i   t   [t   ]s   ]\python.exet   InstallExecuteSequencet   InstallUISequencet	   ConditionRë   i    s   NOT TARGETDIRi   iÙ  Ni   i3  i3  i3  (   R<   Rw   t   Win64R   Rz   R1   Rd   (   R   t   startt   vert   install_patht   machine_regt   user_regt   machine_propt	   user_propt   machine_actiont   user_actiont
   exe_actiont   target_dir_propt   exe_propt   Type(    (    s1   /usr/lib/python2.7/distutils/command/bdist_msi.pyRÄ   E  sJ    









			
c         C   sQ  |  j  rñ d } xÑ |  j |  j g D]l } d | } d | } t |  j d | d | |  j f g É t |  j d | d | | f g É | d 7} q# Wn  |  j rMt j j	 |  j
 d	 É } t | d
 É } | j d É | j t |  j É j É  É | j É  t |  j d d t j | É f g É t |  j d d g É t |  j d d g É n  d  S(   Niê  s   install_script.R∑   R∫   i2   RΩ   s   &Python%s=3i   s   preinstall.batR   s   rem ="""
%1 %0
exit
"""
t   Binaryt
   PreInstalli   s   NOT Installedi¬  (   Rœ   i   Rœ   N(   Rœ   s   NOT Installedi¬  (   R:   R<   Ró   R   Rz   RL   R;   RC   RD   RE   R2   t   opent   writet   readt   closeRw   RŒ   R1   (   R   R¡   R¬   t   install_actionRÃ   t   scriptfnR•   (    (    s1   /usr/lib/python2.7/distutils/command/bdist_msi.pyRÇ   {  s,    	

		

c         C   sA  |  j  } d } } d } d } d } d } d } t | d d dÒ dÚ dÛ dÙ dı g É t | d dˆ d˜ d¯ d˘ g É t | d d˙ d˚ d¸ d˝ d˛ g É t | d. t j É t | d/ t j É t | d0 | | | | | | d1 d1 d1 É }	 |	 j d2 É |	 j d3 d1 d4 d É|	 j	 d5 d6 d4 d É|	 j d7 d8 d9 d: d; d< d= É |	 j d> d8 d? d: d@ d< dA É |	 j
 d1 d5 dB d1 É}
 |
 j dC dD É t | dE | | | | | | d1 d1 d1 É } | j dF É | j d3 d1 d4 d É| j	 d5 d6 d4 d É| j d7 d8 d9 d: d; d< dG É | j d> d8 d? d: d@ d< dA É | j
 d1 d5 dB d1 É}
 |
 j dC dD É t | dH | | | | | | d1 d1 d1 É } | j dI É | j d3 d1 d4 d É| j	 d5 d6 d4 d É| j dJ d8 dK d: d@ d< dA É | j
 d1 d5 dB d1 É}
 |
 j dC dL É t | dM | | | | dN | dO dO dO dP t É} | j dQ d8 dR dS d8 d< dT É | j dJ d@ dU dV d@ d< dW É | j dX d@ dY dZ d d d[ É | j d\ d] d@ d^ dZ d_ d` da d  d  d  É | j dD db dB dD É}
 |
 j dC dD É | j
 db dO dB db É}
 |
 j dC db É | j	 dO dD dB dO É}
 |
 j dC dO É t | d d d dZ dc dd | de d  d  É } | j de d d dV df d dg É | j dh di dj dk dl d dm d  É j dC dn É | j do dp dj dk dl d dq d  É j dC dr É | j ds d dj dk dl d dt d  É j dC du É | j dv dw dj dk dl d d5 d  É j dC dx É | j dy dk dj dk dl d db d  É j dC dz É | j d{ d| dj dk dl d d} d  É j dC d~ É | j d dÄ dj dk dl d dO d  É j dC dÅ É t | dÇ d d dÉ dÑ d | dm dm dm É } | j dX df d8 dÖ dÜ d dá É | j dq dj dà dâ dä d dq dm É }
 |
 j dC dD É | j dm dã dà dâ dä d dm dq É }
 |
 j dC dL É t | då d d dÉ dÑ | | dL dL dL É } | j dX df d8 dÖ dÜ d dç É | j dL dé dà dâ dä d dL d  É }
 |
 j dC dD É t | d  | | | | | | d5 d5 d5 É } | j dJ d8 d9 d: dè d< dê É | j dë É | j d. d8 dí d: d@ d< dì É }
 |
 j d. dX É | j dî d8 dï d: dÜ d< d  É }
 |
 j dî dX É | j d6 d  d4 d É| j
 dñ d  d4 d É| j	 d5 d  É }
 |
 j dó dÇ É t | d& | | | | | | dñ dñ d5 É } | j dò É | j dô d8 dÜ d d@ d dö |  j j É  É | j d3 d  d4 d É| j
 dõ d5 É }
 d } |
 j dú dù dû | ÉxF |  j |  j g D]1 } | d 7} |
 j dú dü | d† | dû | ÉqöW|
 j d° då dû | d É|
 j dC dL dû | d¢ É| j	 d5 d£ É }
 |
 j dó dÇ É | j d£ d§ d8 d• d di d d¶ d  dß d  É }
 |
 j d® d© É |  j } d† | } d™ | } | j d´ d8 dS d d8 d d¨ É }
 |
 j d≠ | É |
 j dÆ | É |
 j dØ | É |
 j d∞ | É | j dß dß d8 d± d d≤ d d≥ | d  dñ d  É }
 |
 j d≠ | É |
 j dÆ | É |
 j dØ | É |
 j d∞ | É t | d¥ | | | | | | dµ dµ dµ dP t É} | j dQ d8 dR dS d8 d< d∂ É | j dJ d@ d@ dV d@ d< d∑ É | j dX d@ d∏ dZ d• d dπ É | j d∫ dª d@ dº dZ dΩ dæ d  dø d  d  É | j dµ d} d  d¿ É j dC dL É t | d# | | | | | | d¡ dñ d5 É } | j d¬ É | j d¡ d8 d• dÉ d d d dg dñ É	 } | j d d d√ dΩ d@ dƒ É | j d≈ d d∆ dΩ d@ d« É | j d6 d  d4 d É| j
 dõ d5 É }
 |
 j d» d© d… d É |
 j dC dL dû d¢ É| j	 d5 d¡ É }
 |
 j dó dÇ É t | d, | | | | | | d5 d5 d5 dP t É} | j dQ d@ d8 dS d8 d< d  É | j dX dÀ dÃ d dÜ d dÕ É | j dŒ dÀ dº dÀ d@ d dœ É | j d. d9 dº | d9 d@ d dì É }
 |
 j d. dX É | j d– d– dÀ di d d d— d  d“ d  d  É }
 |
 j d” d‘ É | j d3 dñ d4 t É| j
 dõ d5 d4 t É| j	 d5 d6 É j dó dÇ É t | d) | | | | | | dñ dñ d5 É } | j d’ É | j d÷ d8 d◊ dZ dw d dÿ É | j dŸ d8 d⁄ dZ d• d d dg dñ É	 } | j d d d€ dS dä d‹ É | j d› d dﬁ dS dä dﬂ É | j d3 d  d4 t É| j
 d1 d5 É }
 |
 j d‡ d d· d√ É |
 j d‚ d„ d· dR É |
 j d‰ dÂ d· d` É |
 j dÊ d d· d É |
 j dÁ d dË dÈ É |
 j d‚ dÍ dË dÎ É |
 j d‰ dÏ dË dÌ É |
 j d› d dË dÓ É |
 j dC dL dÔ d@ É | j	 d5 dŸ É j dó dÇ É d  S(ˇ   Ni2   ir  i,  s   [ProductName] Setupi   i   RZ   t   DefaultUIFontt   DlgFont8t   ErrorDialogt   ErrorDlgt	   Progress1t   Installt	   Progress2t   installst   MaintenanceForm_Actiont   Repairt
   WhichUserst   ALLt	   TextStylet   Tahomai	   i    t   DlgFontBold8i   t   VerdanaBold10t   Verdanai
   t   VerdanaRed9iˇ   Ræ   t
   PrepareDlgs(   Not Privileged or Windows9x or Installediå   t   WhichUsersDlgs.   Privileged and not Windows9x and not Installediç   t   SelectFeaturesDlgs   Not InstallediŒ  t   MaintenanceTypeDlgs,   Installed AND NOT RESUME AND NOT Preselectedi‚  t   ProgressDlgi   t
   ActionTextt   UITextt
   FatalErrort   Finishs)   [ProductName] Installer ended prematurelys   < BackR   R!   R   t   Description1i   iF   i@  iP   i  s´   [ProductName] setup ended prematurely because of an error.  Your system has not been modified.  To install this program at a later time, please run the installation again.t   Description2iõ   i   s.   Click the Finish button to exit the Installer.R   t	   EndDialogt   Exitt   UserExits'   [ProductName] Installer was interruptedsï   [ProductName] setup was interrupted.  Your system has not been modified.  To install this program at a later time, please run the installation again.t
   ExitDialogs&   Completing the [ProductName] Installert   DescriptioniÎ   t   Returnt
   FilesInUsei   t   Retryt   bitmapR   i   i»   s   {\DlgFontBold8}Files in Usei   i  s8   Some files that need to be updated are currently in use.t   Texti7   iJ  s≤   The following applications are using files that need to be updated by this setup. Close these applications and then click Retry to continue the installation or Cancel to exit it.t   Listt   ListBoxik   iÇ   i   t   FileInUseProcesst   Ignoreie   i  t	   ErrorTexti0   Rî   t   Nix   iH   iQ   i   t   Not   ErrorNot   Yi   t   Yest   ErrorYest   At   Abortt
   ErrorAbortt   Ci*   t   ErrorCancelt   It   ErrorIgnoret   Oiü   t   Okt   ErrorOkt   Ri∆   t
   ErrorRetryt	   CancelDlgi  iU   i¬   i   s;   Are you sure you want to cancel [ProductName] installation?i9   i8   i   iÑ   t   WaitForCostingDlgsR   Please wait while the installer finishes determining your disk space requirements.if   i(   sO   Please wait while the Installer prepares to guide you through the installation.s&   Welcome to the [ProductName] Installerin   s   Pondering...t
   ActionDataiá   R#   t   SpawnDialogs   Select Python Installationst   Hints9   Select the Python locations where %s should be installed.s   Next >s   [TARGETDIR]s   [SourceDir]t   orderings   [TARGETDIR%s]s    FEATURE_SELECTED AND &Python%s=3t   SpawnWaitDialogi   t   Featurest   SelectionTreei<   t   FEATUREt   PathEdits   [FEATURE_SELECTED]t   1s!   FEATURE_SELECTED AND &Python%s<>3t   Others$   Provide an alternate Python locationt   Enablet   Showt   Disablet   Hidei◊   i   Rè   t   DiskCostDlgt   OKs&   {\DlgFontBold8}Disk Space RequirementssF   The disk space required for the installation of the selected features.i5   s  The highlighted volumes (if any) do not have enough disk space available for the currently selected features.  You can either remove some files from the highlighted volumes, or choose to install less features onto local drive(s), or select different destination drive(s).t
   VolumeListt   VolumeCostListid   iñ   i  s   {120}{70}{70}{70}{70}g      ‡?t   AdminInstallsG   Select whether to install [ProductName] for all users of this computer.i   s   Install for all userst   JUSTMEi   s   Install just for mes
   [ALLUSERS]s   WhichUsers="ALL"s(   {\DlgFontBold8}[Progress1] [ProductName]i#   iA   sY   Please wait while the Installer [Progress2] [ProductName]. This may take several minutes.t   StatusLabels   Status:t   ProgressBari  s   Progress donet   SetProgresst   Progresss)   Welcome to the [ProductName] Setup Wizardt   BodyTexti?   s:   Select whether you want to repair or remove [ProductName].t   RepairRadioGroupil   i   s   &Repair [ProductName]t   Removei$   s   Re&move [ProductName]s   [REINSTALL]s   MaintenanceForm_Action="Repair"s   [Progress1]t	   Repairings   [Progress2]t   repairst	   Reinstalls   [REMOVE]s   MaintenanceForm_Action="Remove"i   t   Removingi   t   removesi   i   s    MaintenanceForm_Action<>"Change"(   R÷   R◊   (   Rÿ   RŸ   (   R⁄   R€   (   R‹   R›   (   Rﬁ   Rﬂ   (   R‡   R·   (   R◊   R„   i	   Ni    (   R‰   R„   i   Ni   (   RÂ   RÊ   i
   Ni   (   RÁ   RÊ   i	   iˇ   i    (   RË   s(   Not Privileged or Windows9x or Installediå   (   RÈ   s.   Privileged and not Windows9x and not Installediç   (   RÍ   s   Not InstallediŒ  (   RÎ   s,   Installed AND NOT RESUME AND NOT Preselectedi‚  (   RÏ   Ni   (   Rz   R   R1   R	   RÌ   RÓ   R   R   R    R"   R   t   eventt   Falset   controlR   R   t   mappingRF   Rn   R<   Ró   t	   conditionR&   t
   radiogroupt   add(   R   Rz   t   xt   yR   R   R   t   modalt   modelesst   fatalR-   t	   user_exitt   exit_dialogt   inuset   errorR"   t   costingt   prept   seldlgt   orderRf   R¬   t   install_other_condt   dont_install_other_condt   costt
   whichuserst   gt   progresst   maint(    (    s1   /usr/lib/python2.7/distutils/command/bdist_msi.pyRÉ   °  s¨   	
	
	
	
		.......$$$!!

	

	"%c         C   sT   |  j  r% d | |  j |  j  f } n d | |  j f } t j j |  j | É } | S(   Ns   %s.%s-py%s.msis	   %s.%s.msi(   R7   R3   RC   RD   RE   R8   (   R   Rá   t	   base_nameRà   (    (    s1   /usr/lib/python2.7/distutils/command/bdist_msi.pyRo   ﬁ  s    	(   R'   R(   t   descriptionR1   R   t   user_optionst   boolean_optionsRI   Ró   R=   RO   Rl   RÅ   RÄ   RÇ   RÉ   Ro   (    (    (    s1   /usr/lib/python2.7/distutils/command/bdist_msi.pyR*   T   sP   
				)	[	6	6	&	ˇ >(   R)   Re   RC   t	   sysconfigR    t   distutils.coreR   t   distutils.dir_utilR   t   distutils.versionR   t   distutils.errorsR   t	   distutilsR   t   distutils.utilR   Rw   R   R   R	   R
   R   R   R   R   R*   (    (    (    s1   /usr/lib/python2.7/distutils/command/bdist_msi.pyt   <module>   s   "=                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           """distutils.command.bdist_rpm

Implements the Distutils 'bdist_rpm' command (create RPM source and binary
distributions)."""

__revision__ = "$Id$"

import sys
import os
import string

from distutils.core import Command
from distutils.debug import DEBUG
from distutils.file_util import write_file
from distutils.sysconfig import get_python_version
from distutils.errors import (DistutilsOptionError, DistutilsPlatformError,
                              DistutilsFileError, DistutilsExecError)
from distutils import log

class bdist_rpm (Command):

    description = "create an RPM distribution"

    user_options = [
        ('bdist-base=', None,
         "base directory for creating built distributions"),
        ('rpm-base=', None,
         "base directory for creating RPMs (defaults to \"rpm\" under "
         "--bdist-base; must be specified for RPM 2)"),
        ('dist-dir=', 'd',
         "directory to put final RPM files in "
         "(and .spec files if --spec-only)"),
        ('python=', None,
         "path to Python interpreter to hard-code in the .spec file "
         "(default: \"python\")"),
        ('fix-python', None,
         "hard-code the exact path to the current Python interpreter in "
         "the .spec file"),
        ('spec-only', None,
         "only regenerate spec file"),
        ('source-only', None,
         "only generate source RPM"),
        ('binary-only', None,
         "only generate binary RPM"),
        ('use-bzip2', None,
         "use bzip2 instead of gzip to create source distribution"),

        # More meta-data: too RPM-specific to put in the setup script,
        # but needs to go in the .spec file -- so we make these options
        # to "bdist_rpm".  The idea is that packagers would put this
        # info in setup.cfg, although they are of course free to
        # supply it on the command line.
        ('distribution-name=', None,
         "name of the (Linux) distribution to which this "
         "RPM applies (*not* the name of the module distribution!)"),
        ('group=', None,
         "package classification [default: \"Development/Libraries\"]"),
        ('release=', None,
         "RPM release number"),
        ('serial=', None,
         "RPM serial number"),
        ('vendor=', None,
         "RPM \"vendor\" (eg. \"Joe Blow <joe@example.com>\") "
         "[default: maintainer or author from setup script]"),
        ('packager=', None,
         "RPM packager (eg. \"Jane Doe <jane@example.net>\")"
         "[default: vendor]"),
        ('doc-files=', None,
         "list of documentation files (space or comma-separated)"),
        ('changelog=', None,
         "RPM changelog"),
        ('icon=', None,
         "name of icon file"),
        ('provides=', None,
         "capabilities provided by this package"),
        ('requires=', None,
         "capabilities required by this package"),
        ('conflicts=', None,
         "capabilities which conflict with this package"),
        ('build-requires=', None,
         "capabilities required to build this package"),
        ('obsoletes=', None,
         "capabilities made obsolete by this package"),
        ('no-autoreq', None,
         "do not automatically calculate dependencies"),

        # Actions to take when building RPM
        ('keep-temp', 'k',
         "don't clean up RPM build directory"),
        ('no-keep-temp', None,
         "clean up RPM build directory [default]"),
        ('use-rpm-opt-flags', None,
         "compile with RPM_OPT_FLAGS when building from source RPM"),
        ('no-rpm-opt-flags', None,
         "do not pass any RPM CFLAGS to compiler"),
        ('rpm3-mode', None,
         "RPM 3 compatibility mode (default)"),
        ('rpm2-mode', None,
         "RPM 2 compatibility mode"),

        # Add the hooks necessary for specifying custom scripts
        ('prep-script=', None,
         "Specify a script for the PREP phase of RPM building"),
        ('build-script=', None,
         "Specify a script for the BUILD phase of RPM building"),

        ('pre-install=', None,
         "Specify a script for the pre-INSTALL phase of RPM building"),
        ('install-script=', None,
         "Specify a script for the INSTALL phase of RPM building"),
        ('post-install=', None,
         "Specify a script for the post-INSTALL phase of RPM building"),

        ('pre-uninstall=', None,
         "Specify a script for the pre-UNINSTALL phase of RPM building"),
        ('post-uninstall=', None,
         "Specify a script for the post-UNINSTALL phase of RPM building"),

        ('clean-script=', None,
         "Specify a script for the CLEAN phase of RPM building"),

        ('verify-script=', None,
         "Specify a script for the VERIFY phase of the RPM build"),

        # Allow a packager to explicitly force an architecture
        ('force-arch=', None,
         "Force an architecture onto the RPM build process"),

        ('quiet', 'q',
         "Run the INSTALL phase of RPM building in quiet mode"),
        ]

    boolean_options = ['keep-temp', 'use-rpm-opt-flags', 'rpm3-mode',
                       'no-autoreq', 'quiet']

    negative_opt = {'no-keep-temp': 'keep-temp',
                    'no-rpm-opt-flags': 'use-rpm-opt-flags',
                    'rpm2-mode': 'rpm3-mode'}


    def initialize_options (self):
        self.bdist_base = None
        self.rpm_base = None
        self.dist_dir = None
        self.python = None
        self.fix_python = None
        self.spec_only = None
        self.binary_only = None
        self.source_only = None
        self.use_bzip2 = None

        self.distribution_name = None
        self.group = None
        self.release = None
        self.serial = None
        self.vendor = None
        self.packager = None
        self.doc_files = None
        self.changelog = None
        self.icon = None

        self.prep_script = None
        self.build_script = None
        self.install_script = None
        self.clean_script = None
        self.verify_script = None
        self.pre_install = None
        self.post_install = None
        self.pre_uninstall = None
        self.post_uninstall = None
        self.prep = None
        self.provides = None
        self.requires = None
        self.conflicts = None
        self.build_requires = None
        self.obsoletes = None

        self.keep_temp = 0
        self.use_rpm_opt_flags = 1
        self.rpm3_mode = 1
        self.no_autoreq = 0

        self.force_arch = None
        self.quiet = 0

    # initialize_options()


    def finalize_options (self):
        self.set_undefined_options('bdist', ('bdist_base', 'bdist_base'))
        if self.rpm_base is None:
            if not self.rpm3_mode:
                raise DistutilsOptionError, \
                      "you must specify --rpm-base in RPM 2 mode"
            self.rpm_base = os.path.join(self.bdist_base, "rpm")

        if self.python is None:
            if self.fix_python:
                self.python = sys.executable
            else:
                self.python = "python"
        elif self.fix_python:
            raise DistutilsOptionError, \
                  "--python and --fix-python are mutually exclusive options"

        if os.name != 'posix':
            raise DistutilsPlatformError, \
                  ("don't know how to create RPM "
                   "distributions on platform %s" % os.name)
        if self.binary_only and self.source_only:
            raise DistutilsOptionError, \
                  "cannot supply both '--source-only' and '--binary-only'"

        # don't pass CFLAGS to pure python distributions
        if not self.distribution.has_ext_modules():
            self.use_rpm_opt_flags = 0

        self.set_undefined_options('bdist', ('dist_dir', 'dist_dir'))
        self.finalize_package_data()

    # finalize_options()

    def finalize_package_data (self):
        self.ensure_string('group', "Development/Libraries")
        self.ensure_string('vendor',
                           "%s <%s>" % (self.distribution.get_contact(),
                                        self.distribution.get_contact_email()))
        self.ensure_string('packager')
        self.ensure_string_list('doc_files')
        if isinstance(self.doc_files, list):
            for readme in ('README', 'README.txt'):
                if os.path.exists(readme) and readme not in self.doc_files:
                    self.doc_files.append(readme)

        self.ensure_string('release', "1")
        self.ensure_string('serial')   # should it be an int?

        self.ensure_string('distribution_name')

        self.ensure_string('changelog')
          # Format changelog correctly
        self.changelog = self._format_changelog(self.changelog)

        self.ensure_filename('icon')

        self.ensure_filename('prep_script')
        self.ensure_filename('build_script')
        self.ensure_filename('install_script')
        self.ensure_filename('clean_script')
        self.ensure_filename('verify_script')
        self.ensure_filename('pre_install')
        self.ensure_filename('post_install')
        self.ensure_filename('pre_uninstall')
        self.ensure_filename('post_uninstall')

        # XXX don't forget we punted on summaries and descriptions -- they
        # should be handled here eventually!

        # Now *this* is some meta-data that belongs in the setup script...
        self.ensure_string_list('provides')
        self.ensure_string_list('requires')
        self.ensure_string_list('conflicts')
        self.ensure_string_list('build_requires')
        self.ensure_string_list('obsoletes')

        self.ensure_string('force_arch')
    # finalize_package_data ()


    def run (self):

        if DEBUG:
            print "before _get_package_data():"
            print "vendor =", self.vendor
            print "packager =", self.packager
            print "doc_files =", self.doc_files
            print "changelog =", self.changelog

        # make directories
        if self.spec_only:
            spec_dir = self.dist_dir
            self.mkpath(spec_dir)
        else:
            rpm_dir = {}
            for d in ('SOURCES', 'SPECS', 'BUILD', 'RPMS', 'SRPMS'):
                rpm_dir[d] = os.path.join(self.rpm_base, d)
                self.mkpath(rpm_dir[d])
            spec_dir = rpm_dir['SPECS']

        # Spec file goes into 'dist_dir' if '--spec-only specified',
        # build/rpm.<plat> otherwise.
        spec_path = os.path.join(spec_dir,
                                 "%s.spec" % self.distribution.get_name())
        self.execute(write_file,
                     (spec_path,
                      self._make_spec_file()),
                     "writing '%s'" % spec_path)

        if self.spec_only: # stop if requested
            return

        # Make a source distribution and copy to SOURCES directory with
        # optional icon.
        saved_dist_files = self.distribution.dist_files[:]
        sdist = self.reinitialize_command('sdist')
        if self.use_bzip2:
            sdist.formats = ['bztar']
        else:
            sdist.formats = ['gztar']
        self.run_command('sdist')
        self.distribution.dist_files = saved_dist_files

        source = sdist.get_archive_files()[0]
        source_dir = rpm_dir['SOURCES']
        self.copy_file(source, source_dir)

        if self.icon:
            if os.path.exists(self.icon):
                self.copy_file(self.icon, source_dir)
            else:
                raise DistutilsFileError, \
                      "icon file '%s' does not exist" % self.icon


        # build package
        log.info("building RPMs")
        rpm_cmd = ['rpm']
        if os.path.exists('/usr/bin/rpmbuild') or \
           os.path.exists('/bin/rpmbuild'):
            rpm_cmd = ['rpmbuild']

        if self.source_only: # what kind of RPMs?
            rpm_cmd.append('-bs')
        elif self.binary_only:
            rpm_cmd.append('-bb')
        else:
            rpm_cmd.append('-ba')
        if self.rpm3_mode:
            rpm_cmd.extend(['--define',
                             '_topdir %s' % os.path.abspath(self.rpm_base)])
        if not self.keep_temp:
            rpm_cmd.append('--clean')

        if self.quiet:
            rpm_cmd.append('--quiet')

        rpm_cmd.append(spec_path)
        # Determine the binary rpm names that should be built out of this spec
        # file
        # Note that some of these may not be really built (if the file
        # list is empty)
        nvr_string = "%{name}-%{version}-%{release}"
        src_rpm = nvr_string + ".src.rpm"
        non_src_rpm = "%{arch}/" + nvr_string + ".%{arch}.rpm"
        q_cmd = r"rpm -q --qf '%s %s\n' --specfile '%s'" % (
            src_rpm, non_src_rpm, spec_path)

        out = os.popen(q_cmd)
        try:
            binary_rpms = []
            source_rpm = None
            while 1:
                line = out.readline()
                if not line:
                    break
                l = string.split(string.strip(line))
                assert(len(l) == 2)
                binary_rpms.append(l[1])
                # The source rpm is named after the first entry in the spec file
                if source_rpm is None:
                    source_rpm = l[0]

            status = out.close()
            if status:
                raise DistutilsExecError("Failed to execute: %s" % repr(q_cmd))

        finally:
            out.close()

        self.spawn(rpm_cmd)

        if not self.dry_run:
            if self.distribution.has_ext_modules():
                pyversion = get_python_version()
            else:
                pyversion = 'any'

            if not self.binary_only:
                srpm = os.path.join(rpm_dir['SRPMS'], source_rpm)
                assert(os.path.exists(srpm))
                self.move_file(srpm, self.dist_dir)
                filename = os.path.join(self.dist_dir, source_rpm)
                self.distribution.dist_files.append(
                    ('bdist_rpm', pyversion, filename))

            if not self.source_only:
                for rpm in binary_rpms:
                    rpm = os.path.join(rpm_dir['RPMS'], rpm)
                    if os.path.exists(rpm):
                        self.move_file(rpm, self.dist_dir)
                        filename = os.path.join(self.dist_dir,
                                                os.path.basename(rpm))
                        self.distribution.dist_files.append(
                            ('bdist_rpm', pyversion, filename))
    # run()

    def _dist_path(self, path):
        return os.path.join(self.dist_dir, os.path.basename(path))

    def _make_spec_file(self):
        """Generate the text of an RPM spec file and return it as a
        list of strings (one per line).
        """
        # definitions and headers
        spec_file = [
            '%define name ' + self.distribution.get_name(),
            '%define version ' + self.distribution.get_version().replace('-','_'),
            '%define unmangled_version ' + self.distribution.get_version(),
            '%define release ' + self.release.replace('-','_'),
            '',
            'Summary: ' + self.distribution.get_description(),
            ]

        # put locale summaries into spec file
        # XXX not supported for now (hard to put a dictionary
        # in a config file -- arg!)
        #for locale in self.summaries.keys():
        #    spec_file.append('Summary(%s): %s' % (locale,
        #                                          self.summaries[locale]))

        spec_file.extend([
            'Name: %{name}',
            'Version: %{version}',
            'Release: %{release}',])

        # XXX yuck! this filename is available from the "sdist" command,
        # but only after it has run: and we create the spec file before
        # running "sdist", in case of --spec-only.
        if self.use_bzip2:
            spec_file.append('Source0: %{name}-%{unmangled_version}.tar.bz2')
        else:
            spec_file.append('Source0: %{name}-%{unmangled_version}.tar.gz')

        spec_file.extend([
            'License: ' + self.distribution.get_license(),
            'Group: ' + self.group,
            'BuildRoot: %{_tmppath}/%{name}-%{version}-%{release}-buildroot',
            'Prefix: %{_prefix}', ])

        if not self.force_arch:
            # noarch if no extension modules
            if not self.distribution.has_ext_modules():
                spec_file.append('BuildArch: noarch')
        else:
            spec_file.append( 'BuildArch: %s' % self.force_arch )

        for field in ('Vendor',
                      'Packager',
                      'Provides',
                      'Requires',
                      'Conflicts',
                      'Obsoletes',
                      ):
            val = getattr(self, string.lower(field))
            if isinstance(val, list):
                spec_file.append('%s: %s' % (field, string.join(val)))
            elif val is not None:
                spec_file.append('%s: %s' % (field, val))


        if self.distribution.get_url() != 'UNKNOWN':
            spec_file.append('Url: ' + self.distribution.get_url())

        if self.distribution_name:
            spec_file.append('Distribution: ' + self.distribution_name)

        if self.build_requires:
            spec_file.append('BuildRequires: ' +
                             string.join(self.build_requires))

        if self.icon:
            spec_file.append('Icon: ' + os.path.basename(self.icon))

        if self.no_autoreq:
            spec_file.append('AutoReq: 0')

        spec_file.extend([
            '',
            '%description',
            self.distribution.get_long_description()
            ])

        # put locale descriptions into spec file
        # XXX again, suppressed because config file syntax doesn't
        # easily support this ;-(
        #for locale in self.descriptions.keys():
        #    spec_file.extend([
        #        '',
        #        '%description -l ' + locale,
        #        self.descriptions[locale],
        #        ])

        # rpm scripts
        # figure out default build script
        def_setup_call = "%s %s" % (self.python,os.path.basename(sys.argv[0]))
        def_build = "%s build" % def_setup_call
        if self.use_rpm_opt_flags:
            def_build = 'env CFLAGS="$RPM_OPT_FLAGS" ' + def_build

        # insert contents of files

        # XXX this is kind of misleading: user-supplied options are files
        # that we open and interpolate into the spec file, but the defaults
        # are just text that we drop in as-is.  Hmmm.

        install_cmd = ('%s install -O1 --root=$RPM_BUILD_ROOT '
                       '--record=INSTALLED_FILES') % def_setup_call

        script_options = [
            ('prep', 'prep_script', "%setup -n %{name}-%{unmangled_version}"),
            ('build', 'build_script', def_build),
            ('install', 'install_script', install_cmd),
            ('clean', 'clean_script', "rm -rf $RPM_BUILD_ROOT"),
            ('verifyscript', 'verify_script', None),
            ('pre', 'pre_install', None),
            ('post', 'post_install', None),
            ('preun', 'pre_uninstall', None),
            ('postun', 'post_uninstall', None),
        ]

        for (rpm_opt, attr, default) in script_options:
            # Insert contents of file referred to, if no file is referred to
            # use 'default' as contents of script
            val = getattr(self, attr)
            if val or default:
                spec_file.extend([
                    '',
                    '%' + rpm_opt,])
                if val:
                    spec_file.extend(string.split(open(val, 'r').read(), '\n'))
                else:
                    spec_file.append(default)


        # files section
        spec_file.extend([
            '',
            '%files -f INSTALLED_FILES',
            '%defattr(-,root,root)',
            ])

        if self.doc_files:
            spec_file.append('%doc ' + string.join(self.doc_files))

        if self.changelog:
            spec_file.extend([
                '',
                '%changelog',])
            spec_file.extend(self.changelog)

        return spec_file

    # _make_spec_file ()

    def _format_changelog(self, changelog):
        """Format the changelog correctly and convert it to a list of strings
        """
        if not changelog:
            return changelog
        new_changelog = []
        for line in string.split(string.strip(changelog), '\n'):
            line = string.strip(line)
            if line[0] == '*':
                new_changelog.extend(['', line])
            elif line[0] == '-':
                new_changelog.append(line)
            else:
                new_changelog.append('  ' + line)

        # strip trailing newline inserted by first changelog entry
        if not new_changelog[0]:
            del new_changelog[0]

        return new_changelog

    # _format_changelog()

# class bdist_rpm
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        Û
”´[c           @   sº   d  Z  d Z d d l Z d d l Z d d l Z d d l m Z d d l m Z d d l	 m
 Z
 d d l m Z d d l m Z m Z m Z m Z d d	 l m Z d
 e f d Ñ  É  YZ d S(   sw   distutils.command.bdist_rpm

Implements the Distutils 'bdist_rpm' command (create RPM source and binary
distributions).s   $Id$iˇˇˇˇN(   t   Command(   t   DEBUG(   t
   write_file(   t   get_python_version(   t   DistutilsOptionErrort   DistutilsPlatformErrort   DistutilsFileErrort   DistutilsExecError(   t   logt	   bdist_rpmc        +   B   s˛   e  Z d  Z d^ d_ d` da db dc dd de df dg dh di dj dk dl dm dn do dp dq dr ds dt du dv dw dx dy dz d{ d| d} d~ d dÄ dÅ dÇ dÉ dÑ dÖ dÜ g) Z d2 d7 d; d0 dS g Z i d2 d5 6d7 d9 6d; d= 6Z dV Ñ  Z dW Ñ  Z dX Ñ  Z	 dY Ñ  Z
 dZ Ñ  Z d[ Ñ  Z d\ Ñ  Z RS(á   s   create an RPM distributions   bdist-base=s/   base directory for creating built distributionss	   rpm-base=sd   base directory for creating RPMs (defaults to "rpm" under --bdist-base; must be specified for RPM 2)s	   dist-dir=t   dsD   directory to put final RPM files in (and .spec files if --spec-only)s   python=sM   path to Python interpreter to hard-code in the .spec file (default: "python")s
   fix-pythonsL   hard-code the exact path to the current Python interpreter in the .spec files	   spec-onlys   only regenerate spec files   source-onlys   only generate source RPMs   binary-onlys   only generate binary RPMs	   use-bzip2s7   use bzip2 instead of gzip to create source distributions   distribution-name=sg   name of the (Linux) distribution to which this RPM applies (*not* the name of the module distribution!)s   group=s9   package classification [default: "Development/Libraries"]s   release=s   RPM release numbers   serial=s   RPM serial numbers   vendor=sa   RPM "vendor" (eg. "Joe Blow <joe@example.com>") [default: maintainer or author from setup script]s	   packager=sA   RPM packager (eg. "Jane Doe <jane@example.net>")[default: vendor]s
   doc-files=s6   list of documentation files (space or comma-separated)s
   changelog=s   RPM changelogs   icon=s   name of icon files	   provides=s%   capabilities provided by this packages	   requires=s%   capabilities required by this packages
   conflicts=s-   capabilities which conflict with this packages   build-requires=s+   capabilities required to build this packages
   obsoletes=s*   capabilities made obsolete by this packages
   no-autoreqs+   do not automatically calculate dependenciess	   keep-tempt   ks"   don't clean up RPM build directorys   no-keep-temps&   clean up RPM build directory [default]s   use-rpm-opt-flagss8   compile with RPM_OPT_FLAGS when building from source RPMs   no-rpm-opt-flagss&   do not pass any RPM CFLAGS to compilers	   rpm3-modes"   RPM 3 compatibility mode (default)s	   rpm2-modes   RPM 2 compatibility modes   prep-script=s3   Specify a script for the PREP phase of RPM buildings   build-script=s4   Specify a script for the BUILD phase of RPM buildings   pre-install=s:   Specify a script for the pre-INSTALL phase of RPM buildings   install-script=s6   Specify a script for the INSTALL phase of RPM buildings   post-install=s;   Specify a script for the post-INSTALL phase of RPM buildings   pre-uninstall=s<   Specify a script for the pre-UNINSTALL phase of RPM buildings   post-uninstall=s=   Specify a script for the post-UNINSTALL phase of RPM buildings   clean-script=s4   Specify a script for the CLEAN phase of RPM buildings   verify-script=s6   Specify a script for the VERIFY phase of the RPM builds   force-arch=s0   Force an architecture onto the RPM build processt   quiett   qs3   Run the INSTALL phase of RPM building in quiet modec         C   sc  d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _	 d  |  _
 d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _  d  |  _! d |  _" d |  _# d |  _$ d |  _% d  |  _& d |  _' d  S(   Ni    i   ((   t   Nonet
   bdist_baset   rpm_baset   dist_dirt   pythont
   fix_pythont	   spec_onlyt   binary_onlyt   source_onlyt	   use_bzip2t   distribution_namet   groupt   releaset   serialt   vendort   packagert	   doc_filest	   changelogt   icont   prep_scriptt   build_scriptt   install_scriptt   clean_scriptt   verify_scriptt   pre_installt   post_installt   pre_uninstallt   post_uninstallt   prept   providest   requirest	   conflictst   build_requirest	   obsoletest	   keep_tempt   use_rpm_opt_flagst	   rpm3_modet
   no_autoreqt
   force_archR   (   t   self(    (    s1   /usr/lib/python2.7/distutils/command/bdist_rpm.pyt   initialize_optionsç   sN    																																						c         C   s  |  j  d d É |  j d  k rR |  j s4 t d Ç n  t j j |  j d É |  _ n  |  j	 d  k rÖ |  j
 ry t j |  _	 qö d |  _	 n |  j
 rö t d Ç n  t j d k rº t d t j Ç n  |  j r⁄ |  j r⁄ t d	 Ç n  |  j j É  sı d
 |  _ n  |  j  d d É |  j É  d  S(   Nt   bdistR   s)   you must specify --rpm-base in RPM 2 modet   rpmR   s8   --python and --fix-python are mutually exclusive optionst   posixs9   don't know how to create RPM distributions on platform %ss6   cannot supply both '--source-only' and '--binary-only'i    R   (   R   R   (   R   R   (   t   set_undefined_optionsR   R   R2   R   t   ost   patht   joinR   R   R   t   syst
   executablet   nameR   R   R   t   distributiont   has_ext_modulesR1   t   finalize_package_data(   R5   (    (    s1   /usr/lib/python2.7/distutils/command/bdist_rpm.pyt   finalize_optionsΩ   s0    						c         C   s–  |  j  d d É |  j  d d |  j j É  |  j j É  f É |  j  d É |  j d É t |  j t É r∞ xE d D]: } t j	 j
 | É ro | |  j k ro |  j j | É qo qo Wn  |  j  d	 d
 É |  j  d É |  j  d É |  j  d É |  j |  j É |  _ |  j d É |  j d É |  j d É |  j d É |  j d É |  j d É |  j d É |  j d É |  j d É |  j d É |  j d É |  j d É |  j d É |  j d É |  j d É |  j  d É d  S(   NR   s   Development/LibrariesR   s   %s <%s>R   R   t   READMEs
   README.txtR   t   1R   R   R   R    R!   R"   R#   R$   R%   R&   R'   R(   R)   R+   R,   R-   R.   R/   R4   (   RE   s
   README.txt(   t   ensure_stringRA   t   get_contactt   get_contact_emailt   ensure_string_listt
   isinstanceR   t   listR;   R<   t   existst   appendt   _format_changelogR   t   ensure_filename(   R5   t   readme(    (    s1   /usr/lib/python2.7/distutils/command/bdist_rpm.pyRC   ﬂ   s>    	!c         C   s   t  r> d GHd G|  j GHd G|  j GHd G|  j GHd G|  j GHn  |  j r` |  j } |  j | É nN i  } x; d( D]3 } t j	 j
 |  j | É | | <|  j | | É qm W| d } t j	 j
 | d |  j j É  É } |  j t | |  j É  f d | É |  j r d  S|  j j } |  j d É } |  j r4d g | _ n d g | _ |  j d É | |  j _ | j É  d } | d } |  j | | É |  j r t j	 j |  j É r∑|  j |  j | É q t d |  j Ç n  t j d É d g }	 t j	 j d É st j	 j d É rd g }	 n  |  j r)|	 j d É n& |  j rB|	 j d É n |	 j d É |  j  rÅ|	 j! d d t j	 j" |  j É g É n  |  j# sö|	 j d É n  |  j$ r≥|	 j d É n  |	 j | É d }
 |
 d } d  |
 d! } d" | | | f } t j% | É } z≤ g  } d  } xt | j' É  } | s(Pn  t( j) t( j* | É É } t+ | É d# k sXt, Ç | j | d$ É | d  k r| d } qqW| j- É  } | r±t. d% t/ | É É Ç n  Wd  | j- É  X|  j0 |	 É |  j1 s|  j j2 É  rÒt3 É  } n d& } |  j s{t j	 j
 | d
 | É } t j	 j | É s1t, Ç |  j4 | |  j É t j	 j
 |  j | É } |  j j j d' | | f É n  |  j sxí | D]á } t j	 j
 | d	 | É } t j	 j | É rã|  j4 | |  j É t j	 j
 |  j t j	 j5 | É É } |  j j j d' | | f É qãqãWqn  d  S()   Ns   before _get_package_data():s   vendor =s
   packager =s   doc_files =s   changelog =t   SOURCESt   SPECSt   BUILDt   RPMSt   SRPMSs   %s.specs   writing '%s't   sdistt   bztart   gztari    s   icon file '%s' does not exists   building RPMsR8   s   /usr/bin/rpmbuilds   /bin/rpmbuildt   rpmbuilds   -bss   -bbs   -bas   --defines
   _topdir %ss   --cleans   --quiets   %{name}-%{version}-%{release}s   .src.rpms   %{arch}/s   .%{arch}.rpms%   rpm -q --qf '%s %s\n' --specfile '%s'i   i   s   Failed to execute: %st   anyR	   (   RR   RS   RT   RU   RV   (6   R   R   R   R   R   R   R   t   mkpathR;   R<   R=   R   RA   t   get_namet   executeR   t   _make_spec_filet
   dist_filest   reinitialize_commandR   t   formatst   run_commandt   get_archive_filest	   copy_fileR    RM   R   R   t   infoR   RN   R   R2   t   extendt   abspathR0   R   t   popenR   t   readlinet   stringt   splitt   stript   lent   AssertionErrort   closeR   t   reprt   spawnt   dry_runRB   R   t	   move_filet   basename(   R5   t   spec_dirt   rpm_dirR
   t	   spec_patht   saved_dist_filesRW   t   sourcet
   source_dirt   rpm_cmdt
   nvr_stringt   src_rpmt   non_src_rpmt   q_cmdt   outt   binary_rpmst
   source_rpmt   linet   lt   statust	   pyversiont   srpmt   filenameR8   (    (    s1   /usr/lib/python2.7/distutils/command/bdist_rpm.pyt   run  sƒ    		
			
						 		
			c         C   s"   t  j j |  j t  j j | É É S(   N(   R;   R<   R=   R   Ru   (   R5   R<   (    (    s1   /usr/lib/python2.7/distutils/command/bdist_rpm.pyt
   _dist_pathó  s    c         C   sı  d |  j  j É  d |  j  j É  j d d É d |  j  j É  d |  j j d d É d d |  j  j É  g } | j d	 d
 d g É |  j rö | j d É n | j d É | j d |  j  j	 É  d |  j
 d d g É |  j sˇ |  j  j É  s| j d É qn | j d |  j É x~ dB D]v } t |  t j | É É } t | t É rj| j d | t j | É f É q| dC k	 r| j d | | f É qqW|  j  j É  d k r∆| j d |  j  j É  É n  |  j rÊ| j d |  j É n  |  j r| j d t j |  j É É n  |  j r;| j d t j j |  j É É n  |  j rT| j d  É n  | j d d! |  j  j É  g É d" |  j t j j t j d# É f } d$ | } |  j  rπd% | } n  d& | } dD d* d+ | f d, d- | f dE dF dG dH dI dJ g	 } xä | D]Ç \ } }	 }
 t |  |	 É } | s'|
 r˝| j d d; | g É | ro| j t j! t" | d< É j# É  d= É É q| j |
 É q˝q˝W| j d d> d? g É |  j$ r¬| j d@ t j |  j$ É É n  |  j% rÒ| j d dA g É | j |  j% É n  | S(K   si   Generate the text of an RPM spec file and return it as a
        list of strings (one per line).
        s   %define name s   %define version t   -t   _s   %define unmangled_version s   %define release t    s	   Summary: s   Name: %{name}s   Version: %{version}s   Release: %{release}s-   Source0: %{name}-%{unmangled_version}.tar.bz2s,   Source0: %{name}-%{unmangled_version}.tar.gzs	   License: s   Group: s>   BuildRoot: %{_tmppath}/%{name}-%{version}-%{release}-buildroots   Prefix: %{_prefix}s   BuildArch: noarchs   BuildArch: %st   Vendort   Packagert   Providest   Requirest	   Conflictst	   Obsoletess   %s: %st   UNKNOWNs   Url: s   Distribution: s   BuildRequires: s   Icon: s
   AutoReq: 0s   %descriptions   %s %si    s   %s builds   env CFLAGS="$RPM_OPT_FLAGS" s>   %s install -O1 --root=$RPM_BUILD_ROOT --record=INSTALLED_FILESR*   R!   s&   %setup -n %{name}-%{unmangled_version}t   buildR"   t   installR#   t   cleanR$   s   rm -rf $RPM_BUILD_ROOTt   verifyscriptR%   t   preR&   t   postR'   t   preunR(   t   postunR)   t   %t   rs   
s   %files -f INSTALLED_FILESs   %defattr(-,root,root)s   %doc s
   %changelog(   Rè   Rê   Rë   Rí   Rì   Rî   N(   R*   R!   s&   %setup -n %{name}-%{unmangled_version}(   Rò   R$   s   rm -rf $RPM_BUILD_ROOT(   Rô   R%   N(   Rö   R&   N(   Rõ   R'   N(   Rú   R(   N(   Rù   R)   N(&   RA   R]   t   get_versiont   replaceR   t   get_descriptionRg   R   RN   t   get_licenseR   R4   RB   t   getattrRk   t   lowerRK   RL   R=   R   t   get_urlR   R.   R    R;   R<   Ru   R3   t   get_long_descriptionR   R>   t   argvR1   Rl   t   opent   readR   R   (   R5   t	   spec_filet   fieldt   valt   def_setup_callt	   def_buildt   install_cmdt   script_optionst   rpm_optt   attrt   default(    (    s1   /usr/lib/python2.7/distutils/command/bdist_rpm.pyR_   ö  s®    

	

	    
#				#	&
		+
	 	
c         C   s¥   | s
 | Sg  } xâ t  j t  j | É d É D]l } t  j | É } | d d k rg | j d | g É q, | d d k rá | j | É q, | j d | É q, W| d s∞ | d =n  | S(   sK   Format the changelog correctly and convert it to a list of strings
        s   
i    t   *Ré   Rå   s     (   Rk   Rl   Rm   Rg   RN   (   R5   R   t   new_changelogRÑ   (    (    s1   /usr/lib/python2.7/distutils/command/bdist_rpm.pyRO   5  s    "

N(   s   bdist-base=Ns/   base directory for creating built distributions(   s	   rpm-base=Nsd   base directory for creating RPMs (defaults to "rpm" under --bdist-base; must be specified for RPM 2)(   s	   dist-dir=R
   sD   directory to put final RPM files in (and .spec files if --spec-only)(   s   python=NsM   path to Python interpreter to hard-code in the .spec file (default: "python")(   s
   fix-pythonNsL   hard-code the exact path to the current Python interpreter in the .spec file(   s	   spec-onlyNs   only regenerate spec file(   s   source-onlyNs   only generate source RPM(   s   binary-onlyNs   only generate binary RPM(   s	   use-bzip2Ns7   use bzip2 instead of gzip to create source distribution(   s   distribution-name=Nsg   name of the (Linux) distribution to which this RPM applies (*not* the name of the module distribution!)(   s   group=Ns9   package classification [default: "Development/Libraries"](   s   release=Ns   RPM release number(   s   serial=Ns   RPM serial number(   s   vendor=Nsa   RPM "vendor" (eg. "Joe Blow <joe@example.com>") [default: maintainer or author from setup script](   s	   packager=NsA   RPM packager (eg. "Jane Doe <jane@example.net>")[default: vendor](   s
   doc-files=Ns6   list of documentation files (space or comma-separated)(   s
   changelog=Ns   RPM changelog(   s   icon=Ns   name of icon file(   s	   provides=Ns%   capabilities provided by this package(   s	   requires=Ns%   capabilities required by this package(   s
   conflicts=Ns-   capabilities which conflict with this package(   s   build-requires=Ns+   capabilities required to build this package(   s
   obsoletes=Ns*   capabilities made obsolete by this package(   s
   no-autoreqNs+   do not automatically calculate dependencies(   s	   keep-tempR   s"   don't clean up RPM build directory(   s   no-keep-tempNs&   clean up RPM build directory [default](   s   use-rpm-opt-flagsNs8   compile with RPM_OPT_FLAGS when building from source RPM(   s   no-rpm-opt-flagsNs&   do not pass any RPM CFLAGS to compiler(   s	   rpm3-modeNs"   RPM 3 compatibility mode (default)(   s	   rpm2-modeNs   RPM 2 compatibility mode(   s   prep-script=Ns3   Specify a script for the PREP phase of RPM building(   s   build-script=Ns4   Specify a script for the BUILD phase of RPM building(   s   pre-install=Ns:   Specify a script for the pre-INSTALL phase of RPM building(   s   install-script=Ns6   Specify a script for the INSTALL phase of RPM building(   s   post-install=Ns;   Specify a script for the post-INSTALL phase of RPM building(   s   pre-uninstall=Ns<   Specify a script for the pre-UNINSTALL phase of RPM building(   s   post-uninstall=Ns=   Specify a script for the post-UNINSTALL phase of RPM building(   s   clean-script=Ns4   Specify a script for the CLEAN phase of RPM building(   s   verify-script=Ns6   Specify a script for the VERIFY phase of the RPM build(   s   force-arch=Ns0   Force an architecture onto the RPM build process(   R   R   s3   Run the INSTALL phase of RPM building in quiet mode(   t   __name__t
   __module__t   descriptionR   t   user_optionst   boolean_optionst   negative_optR6   RD   RC   Rä   Rã   R_   RO   (    (    (    s1   /usr/lib/python2.7/distutils/command/bdist_rpm.pyR	      sæ                                            		

	0	"	/	â		õ(   t   __doc__t   __revision__R>   R;   Rk   t   distutils.coreR    t   distutils.debugR   t   distutils.file_utilR   t   distutils.sysconfigR   t   distutils.errorsR   R   R   R   t	   distutilsR   R	   (    (    (    s1   /usr/lib/python2.7/distutils/command/bdist_rpm.pyt   <module>   s   "                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            """distutils.command.bdist_wininst

Implements the Distutils 'bdist_wininst' command: create a windows installer
exe-program."""

__revision__ = "$Id$"

import sys
import os
import string

from sysconfig import get_python_version

from distutils.core import Command
from distutils.dir_util import remove_tree
from distutils.errors import DistutilsOptionError, DistutilsPlatformError
from distutils.errors import DistutilsFileError
from distutils import log
from distutils.util import get_platform

class bdist_wininst (Command):

    description = "create an executable installer for MS Windows"

    user_options = [('bdist-dir=', None,
                     "temporary directory for creating the distribution"),
                    ('plat-name=', 'p',
                     "platform name to embed in generated filenames "
                     "(default: %s)" % get_platform()),
                    ('keep-temp', 'k',
                     "keep the pseudo-installation tree around after " +
                     "creating the distribution archive"),
                    ('target-version=', None,
                     "require a specific python version" +
                     " on the target system"),
                    ('no-target-compile', 'c',
                     "do not compile .py to .pyc on the target system"),
                    ('no-target-optimize', 'o',
                     "do not compile .py to .pyo (optimized)"
                     "on the target system"),
                    ('dist-dir=', 'd',
                     "directory to put final built distributions in"),
                    ('bitmap=', 'b',
                     "bitmap to use for the installer instead of python-powered logo"),
                    ('title=', 't',
                     "title to display on the installer background instead of default"),
                    ('skip-build', None,
                     "skip rebuilding everything (for testing/debugging)"),
                    ('install-script=', None,
                     "basename of installation script to be run after"
                     "installation or before deinstallation"),
                    ('pre-install-script=', None,
                     "Fully qualified filename of a script to be run before "
                     "any files are installed.  This script need not be in the "
                     "distribution"),
                    ('user-access-control=', None,
                     "specify Vista's UAC handling - 'none'/default=no "
                     "handling, 'auto'=use UAC if target Python installed for "
                     "all users, 'force'=always use UAC"),
                   ]

    boolean_options = ['keep-temp', 'no-target-compile', 'no-target-optimize',
                       'skip-build']

    def initialize_options (self):
        self.bdist_dir = None
        self.plat_name = None
        self.keep_temp = 0
        self.no_target_compile = 0
        self.no_target_optimize = 0
        self.target_version = None
        self.dist_dir = None
        self.bitmap = None
        self.title = None
        self.skip_build = None
        self.install_script = None
        self.pre_install_script = None
        self.user_access_control = None

    # initialize_options()


    def finalize_options (self):
        self.set_undefined_options('bdist', ('skip_build', 'skip_build'))

        if self.bdist_dir is None:
            if self.skip_build and self.plat_name:
                # If build is skipped and plat_name is overridden, bdist will
                # not see the correct 'plat_name' - so set that up manually.
                bdist = self.distribution.get_command_obj('bdist')
                bdist.plat_name = self.plat_name
                # next the command will be initialized using that name
            bdist_base = self.get_finalized_command('bdist').bdist_base
            self.bdist_dir = os.path.join(bdist_base, 'wininst')

        if not self.target_version:
            self.target_version = ""

        if not self.skip_build and self.distribution.has_ext_modules():
            short_version = get_python_version()
            if self.target_version and self.target_version != short_version:
                raise DistutilsOptionError, \
                      "target version can only be %s, or the '--skip-build'" \
                      " option must be specified" % (short_version,)
            self.target_version = short_version

        self.set_undefined_options('bdist',
                                   ('dist_dir', 'dist_dir'),
                                   ('plat_name', 'plat_name'),
                                  )

        if self.install_script:
            for script in self.distribution.scripts:
                if self.install_script == os.path.basename(script):
                    break
            else:
                raise DistutilsOptionError, \
                      "install_script '%s' not found in scripts" % \
                      self.install_script
    # finalize_options()


    def run (self):
        if (sys.platform != "win32" and
            (self.distribution.has_ext_modules() or
             self.distribution.has_c_libraries())):
            raise DistutilsPlatformError \
                  ("distribution contains extensions and/or C libraries; "
                   "must be compiled on a Windows 32 platform")

        if not self.skip_build:
            self.run_command('build')

        install = self.reinitialize_command('install', reinit_subcommands=1)
        install.root = self.bdist_dir
        install.skip_build = self.skip_build
        install.warn_dir = 0
        install.plat_name = self.plat_name

        install_lib = self.reinitialize_command('install_lib')
        # we do not want to include pyc or pyo files
        install_lib.compile = 0
        install_lib.optimize = 0

        if self.distribution.has_ext_modules():
            # If we are building an installer for a Python version other
            # than the one we are currently running, then we need to ensure
            # our build_lib reflects the other Python version rather than ours.
            # Note that for target_version!=sys.version, we must have skipped the
            # build step, so there is no issue with enforcing the build of this
            # version.
            target_version = self.target_version
            if not target_version:
                assert self.skip_build, "Should have already checked this"
                target_version = sys.version[0:3]
            plat_specifier = ".%s-%s" % (self.plat_name, target_version)
            build = self.get_finalized_command('build')
            build.build_lib = os.path.join(build.build_base,
                                           'lib' + plat_specifier)

        # Use a custom scheme for the zip-file, because we have to decide
        # at installation time which scheme to use.
        for key in ('purelib', 'platlib', 'headers', 'scripts', 'data'):
            value = string.upper(key)
            if key == 'headers':
                value = value + '/Include/$dist_name'
            setattr(install,
                    'install_' + key,
                    value)

        log.info("installing to %s", self.bdist_dir)
        install.ensure_finalized()

        # avoid warning of 'install_lib' about installing
        # into a directory not in sys.path
        sys.path.insert(0, os.path.join(self.bdist_dir, 'PURELIB'))

        install.run()

        del sys.path[0]

        # And make an archive relative to the root of the
        # pseudo-installation tree.
        from tempfile import mktemp
        archive_basename = mktemp()
        fullname = self.distribution.get_fullname()
        arcname = self.make_archive(archive_basename, "zip",
                                    root_dir=self.bdist_dir)
        # create an exe containing the zip-file
        self.create_exe(arcname, fullname, self.bitmap)
        if self.distribution.has_ext_modules():
            pyversion = get_python_version()
        else:
            pyversion = 'any'
        self.distribution.dist_files.append(('bdist_wininst', pyversion,
                                             self.get_installer_filename(fullname)))
        # remove the zip-file again
        log.debug("removing temporary file '%s'", arcname)
        os.remove(arcname)

        if not self.keep_temp:
            remove_tree(self.bdist_dir, dry_run=self.dry_run)

    # run()

    def get_inidata (self):
        # Return data describing the installation.

        lines = []
        metadata = self.distribution.metadata

        # Write the [metadata] section.
        lines.append("[metadata]")

        # 'info' will be displayed in the installer's dialog box,
        # describing the items to be installed.
        info = (metadata.long_description or '') + '\n'

        # Escape newline characters
        def escape(s):
            return string.replace(s, "\n", "\\n")

        for name in ["author", "author_email", "description", "maintainer",
                     "maintainer_email", "name", "url", "version"]:
            data = getattr(metadata, name, "")
            if data:
                info = info + ("\n    %s: %s" % \
                               (string.capitalize(name), escape(data)))
                lines.append("%s=%s" % (name, escape(data)))

        # The [setup] section contains entries controlling
        # the installer runtime.
        lines.append("\n[Setup]")
        if self.install_script:
            lines.append("install_script=%s" % self.install_script)
        lines.append("info=%s" % escape(info))
        lines.append("target_compile=%d" % (not self.no_target_compile))
        lines.append("target_optimize=%d" % (not self.no_target_optimize))
        if self.target_version:
            lines.append("target_version=%s" % self.target_version)
        if self.user_access_control:
            lines.append("user_access_control=%s" % self.user_access_control)

        title = self.title or self.distribution.get_fullname()
        lines.append("title=%s" % escape(title))
        import time
        import distutils
        build_info = "Built %s with distutils-%s" % \
                     (time.ctime(time.time()), distutils.__version__)
        lines.append("build_info=%s" % build_info)
        return string.join(lines, "\n")

    # get_inidata()

    def create_exe (self, arcname, fullname, bitmap=None):
        import struct

        self.mkpath(self.dist_dir)

        cfgdata = self.get_inidata()

        installer_name = self.get_installer_filename(fullname)
        self.announce("creating %s" % installer_name)

        if bitmap:
            bitmapdata = open(bitmap, "rb").read()
            bitmaplen = len(bitmapdata)
        else:
            bitmaplen = 0

        file = open(installer_name, "wb")
        file.write(self.get_exe_bytes())
        if bitmap:
            file.write(bitmapdata)

        # Convert cfgdata from unicode to ascii, mbcs encoded
        try:
            unicode
        except NameError:
            pass
        else:
            if isinstance(cfgdata, unicode):
                cfgdata = cfgdata.encode("mbcs")

        # Append the pre-install script
        cfgdata = cfgdata + "\0"
        if self.pre_install_script:
            script_data = open(self.pre_install_script, "r").read()
            cfgdata = cfgdata + script_data + "\n\0"
        else:
            # empty pre-install script
            cfgdata = cfgdata + "\0"
        file.write(cfgdata)

        # The 'magic number' 0x1234567B is used to make sure that the
        # binary layout of 'cfgdata' is what the wininst.exe binary
        # expects.  If the layout changes, increment that number, make
        # the corresponding changes to the wininst.exe sources, and
        # recompile them.
        header = struct.pack("<iii",
                             0x1234567B,       # tag
                             len(cfgdata),     # length
                             bitmaplen,        # number of bytes in bitmap
                             )
        file.write(header)
        file.write(open(arcname, "rb").read())

    # create_exe()

    def get_installer_filename(self, fullname):
        # Factored out to allow overriding in subclasses
        if self.target_version:
            # if we create an installer for a specific python version,
            # it's better to include this in the name
            installer_name = os.path.join(self.dist_dir,
                                          "%s.%s-py%s.exe" %
                                           (fullname, self.plat_name, self.target_version))
        else:
            installer_name = os.path.join(self.dist_dir,
                                          "%s.%s.exe" % (fullname, self.plat_name))
        return installer_name
    # get_installer_filename()

    def get_exe_bytes (self):
        from distutils.msvccompiler import get_build_version
        # If a target-version other than the current version has been
        # specified, then using the MSVC version from *this* build is no good.
        # Without actually finding and executing the target version and parsing
        # its sys.version, we just hard-code our knowledge of old versions.
        # NOTE: Possible alternative is to allow "--target-version" to
        # specify a Python executable rather than a simple version string.
        # We can then execute this program to obtain any info we need, such
        # as the real sys.version string for the build.
        cur_version = get_python_version()
        if self.target_version and self.target_version != cur_version:
            # If the target version is *later* than us, then we assume they
            # use what we use
            # string compares seem wrong, but are what sysconfig.py itself uses
            if self.target_version > cur_version:
                bv = get_build_version()
            else:
                if self.target_version < "2.4":
                    bv = 6.0
                else:
                    bv = 7.1
        else:
            # for current version - use authoritative check.
            bv = get_build_version()

        # wininst-x.y.exe is in the same directory as this file
        directory = os.path.dirname(__file__)
        # we must use a wininst-x.y.exe built with the same C compiler
        # used for python.  XXX What about mingw, borland, and so on?

        # if plat_name starts with "win" but is not "win32"
        # we want to strip "win" and leave the rest (e.g. -amd64)
        # for all other cases, we don't want any suffix
        if self.plat_name != 'win32' and self.plat_name[:3] == 'win':
            sfix = self.plat_name[3:]
        else:
            sfix = ''

        filename = os.path.join(directory, "wininst-%.1f%s.exe" % (bv, sfix))
        try:
            f = open(filename, "rb")
        except IOError, msg:
            raise DistutilsFileError, str(msg) + ', %s not included in the Debian packages.' % filename
        try:
            return f.read()
        finally:
            f.close()
# class bdist_wininst
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     Û
”´[c           @   s¿   d  Z  d Z d d l Z d d l Z d d l Z d d l m Z d d l m Z d d l	 m
 Z
 d d l m Z m Z d d l m Z d d	 l m Z d d
 l m Z d e f d Ñ  É  YZ d S(   sz   distutils.command.bdist_wininst

Implements the Distutils 'bdist_wininst' command: create a windows installer
exe-program.s   $Id$iˇˇˇˇN(   t   get_python_version(   t   Command(   t   remove_tree(   t   DistutilsOptionErrort   DistutilsPlatformError(   t   DistutilsFileError(   t   log(   t   get_platformt   bdist_wininstc           B   sπ   e  Z d  Z d, d d d e É  f d d d d	 f d
 d+ d d f d- d. d/ d0 d1 d2 d3 d4 d5 g Z d d d d g Z d$ Ñ  Z d% Ñ  Z d& Ñ  Z	 d' Ñ  Z
 d+ d( Ñ Z d) Ñ  Z d* Ñ  Z RS(6   s-   create an executable installer for MS Windowss
   bdist-dir=s1   temporary directory for creating the distributions
   plat-name=t   ps;   platform name to embed in generated filenames (default: %s)s	   keep-tempt   ks/   keep the pseudo-installation tree around after s!   creating the distribution archives   target-version=s!   require a specific python versions    on the target systems   no-target-compilet   cs/   do not compile .py to .pyc on the target systems   no-target-optimizet   os:   do not compile .py to .pyo (optimized)on the target systems	   dist-dir=t   ds-   directory to put final built distributions ins   bitmap=t   bs>   bitmap to use for the installer instead of python-powered logos   title=t   ts?   title to display on the installer background instead of defaults
   skip-builds2   skip rebuilding everything (for testing/debugging)s   install-script=sT   basename of installation script to be run afterinstallation or before deinstallations   pre-install-script=s{   Fully qualified filename of a script to be run before any files are installed.  This script need not be in the distributions   user-access-control=sä   specify Vista's UAC handling - 'none'/default=no handling, 'auto'=use UAC if target Python installed for all users, 'force'=always use UACc         C   sy   d  |  _ d  |  _ d |  _ d |  _ d |  _ d  |  _ d  |  _ d  |  _ d  |  _	 d  |  _
 d  |  _ d  |  _ d  |  _ d  S(   Ni    (   t   Nonet	   bdist_dirt	   plat_namet	   keep_tempt   no_target_compilet   no_target_optimizet   target_versiont   dist_dirt   bitmapt   titlet
   skip_buildt   install_scriptt   pre_install_scriptt   user_access_control(   t   self(    (    s5   /usr/lib/python2.7/distutils/command/bdist_wininst.pyt   initialize_optionsA   s    												c         C   sV  |  j  d d	 É |  j d  k r |  j rR |  j rR |  j j d É } |  j | _ n  |  j d É j } t	 j
 j | d É |  _ n  |  j sî d |  _ n  |  j rÌ |  j j É  rÌ t É  } |  j r· |  j | k r· t d | f Ç n  | |  _ n  |  j  d d
 d É |  j rRxF |  j j D]% } |  j t	 j
 j | É k rPqqWt d |  j Ç n  d  S(   Nt   bdistR   t   wininstt    sM   target version can only be %s, or the '--skip-build' option must be specifiedR   R   s(   install_script '%s' not found in scripts(   R   R   (   R   R   (   R   R   (   t   set_undefined_optionsR   R   R   R   t   distributiont   get_command_objt   get_finalized_commandt
   bdist_baset   ost   patht   joinR   t   has_ext_modulesR    R   R   t   scriptst   basename(   R   R    R'   t   short_versiont   script(    (    s5   /usr/lib/python2.7/distutils/command/bdist_wininst.pyt   finalize_optionsS   s4    				c         C   s«  t  j d k r< |  j j É  s- |  j j É  r< t d É Ç n  |  j sU |  j d É n  |  j d d d É} |  j	 | _
 |  j | _ d | _ |  j | _ |  j d É } d | _ d | _ |  j j É  rB|  j } | s˛ |  j sÎ t d	 É Ç t  j d d
 !} n  d |  j | f } |  j d É } t j j | j d | É | _ n  xJ d D]B } t j | É } | d k rw| d } n  t | d | | É qIWt j d |  j	 É | j É  t  j j d t j j |  j	 d É É | j É  t  j d =d d l  m! } | É  }	 |  j j" É  }
 |  j# |	 d d |  j	 É} |  j$ | |
 |  j% É |  j j É  rYt& É  } n d } |  j j' j( d | |  j) |
 É f É t j* d | É t j+ | É |  j, s√t- |  j	 d |  j. Én  d  S(   Nt   win32s^   distribution contains extensions and/or C libraries; must be compiled on a Windows 32 platformt   buildt   installt   reinit_subcommandsi   i    t   install_libs    Should have already checked thisi   s   .%s-%st   libt   purelibt   platlibt   headersR,   t   datas   /Include/$dist_namet   install_s   installing to %st   PURELIBiˇˇˇˇ(   t   mktempt   zipt   root_dirt   anyR   s   removing temporary file '%s't   dry_run(   R7   R8   R9   R,   R:   (/   t   syst   platformR$   R+   t   has_c_librariesR   R   t   run_commandt   reinitialize_commandR   t   roott   warn_dirR   t   compilet   optimizeR   t   AssertionErrort   versionR&   R(   R)   R*   t
   build_baset	   build_libt   stringt   uppert   setattrR   t   infot   ensure_finalizedt   insertt   runt   tempfileR=   t   get_fullnamet   make_archivet
   create_exeR   R    t
   dist_filest   appendt   get_installer_filenamet   debugt   removeR   R   RA   (   R   R3   R5   R   t   plat_specifierR2   t   keyt   valueR=   t   archive_basenamet   fullnamet   arcnamet	   pyversion(    (    s5   /usr/lib/python2.7/distutils/command/bdist_wininst.pyRU   {   sf    					
%

		c         C   s˜  g  } |  j  j } | j d É | j p+ d d } d Ñ  } xÅ d d d d d	 d
 d d g D]a } t | | d É } | rZ | d t j | É | | É f } | j d | | | É f É qZ qZ W| j d É |  j rÏ | j d |  j É n  | j d | | É É | j d |  j É | j d |  j	 É |  j
 rM| j d |  j
 É n  |  j rm| j d |  j É n  |  j pÇ|  j  j É  } | j d | | É É d d  l } d d  l }	 d | j | j É  É |	 j f }
 | j d |
 É t j | d É S(   Ns
   [metadata]R"   s   
c         S   s   t  j |  d d É S(   Ns   
s   \n(   RO   t   replace(   t   s(    (    s5   /usr/lib/python2.7/distutils/command/bdist_wininst.pyt   escape‹   s    t   authort   author_emailt   descriptiont
   maintainert   maintainer_emailt   namet   urlRL   s   
    %s: %ss   %s=%ss   
[Setup]s   install_script=%ss   info=%ss   target_compile=%ds   target_optimize=%ds   target_version=%ss   user_access_control=%ss   title=%siˇˇˇˇs   Built %s with distutils-%ss   build_info=%s(   R$   t   metadataR[   t   long_descriptiont   getattrRO   t
   capitalizeR   R   R   R   R   R   RW   t   timet	   distutilst   ctimet   __version__R*   (   R   t   linesRp   RR   Rh   Rn   R:   R   Rt   Ru   t
   build_info(    (    s5   /usr/lib/python2.7/distutils/command/bdist_wininst.pyt   get_inidataŒ   s<    	$			c         C   sã  d d  l  } |  j |  j É |  j É  } |  j | É } |  j d | É | rr t | d É j É  } t | É } n d } t | d É }	 |	 j	 |  j
 É  É | r∞ |	 j	 | É n  y t Wn t k
 rÀ n" Xt | t É rÌ | j d É } n  | d } |  j r)t |  j d É j É  }
 | |
 d	 } n
 | d } |	 j	 | É | j d
 d t | É | É } |	 j	 | É |	 j	 t | d É j É  É d  S(   Niˇˇˇˇs   creating %st   rbi    t   wbt   mbcss    t   rs   
 s   <iiii{V4(   t   structt   mkpathR   Rz   R\   t   announcet   opent   readt   lent   writet   get_exe_bytest   unicodet	   NameErrort
   isinstancet   encodeR   t   pack(   R   Rd   Rc   R   R   t   cfgdatat   installer_namet
   bitmapdatat	   bitmaplent   filet   script_datat   header(    (    s5   /usr/lib/python2.7/distutils/command/bdist_wininst.pyRY   ˇ   s>    
	
			c         C   s`   |  j  r7 t j j |  j d | |  j |  j  f É } n% t j j |  j d | |  j f É } | S(   Ns   %s.%s-py%s.exes	   %s.%s.exe(   R   R(   R)   R*   R   R   (   R   Rc   Rç   (    (    s5   /usr/lib/python2.7/distutils/command/bdist_wininst.pyR\   6  s    	c   	      C   s?  d d l  m } t É  } |  j rm |  j | k rm |  j | k rL | É  } qv |  j d k  rd d } qv d } n	 | É  } t j j t É } |  j d k r∫ |  j d  d k r∫ |  j d } n d	 } t j j	 | d
 | | f É } y t
 | d É } Wn* t k
 r} t t | É d | Ç n Xz | j É  SWd  | j É  Xd  S(   Niˇˇˇˇ(   t   get_build_versions   2.4g      @gffffff@R1   i   t   winR"   s   wininst-%.1f%s.exeR{   s)   , %s not included in the Debian packages.(   t   distutils.msvccompilerRì   R    R   R(   R)   t   dirnamet   __file__R   R*   RÇ   t   IOErrorR   t   strRÉ   t   close(	   R   Rì   t   cur_versiont   bvt	   directoryt   sfixt   filenamet   ft   msg(    (    s5   /usr/lib/python2.7/distutils/command/bdist_wininst.pyRÜ   D  s*    					"N(   s
   bdist-dir=Ns1   temporary directory for creating the distribution(   s   no-target-compileR   s/   do not compile .py to .pyc on the target system(   s   no-target-optimizeR   s:   do not compile .py to .pyo (optimized)on the target system(   s	   dist-dir=R   s-   directory to put final built distributions in(   s   bitmap=R   s>   bitmap to use for the installer instead of python-powered logo(   s   title=R   s?   title to display on the installer background instead of default(   s
   skip-buildNs2   skip rebuilding everything (for testing/debugging)(   s   install-script=NsT   basename of installation script to be run afterinstallation or before deinstallation(   s   pre-install-script=Ns{   Fully qualified filename of a script to be run before any files are installed.  This script need not be in the distribution(   s   user-access-control=Nsä   specify Vista's UAC handling - 'none'/default=no handling, 'auto'=use UAC if target Python installed for all users, 'force'=always use UAC(   t   __name__t
   __module__Rk   R   R   t   user_optionst   boolean_optionsR   R0   RU   Rz   RY   R\   RÜ   (    (    (    s5   /usr/lib/python2.7/distutils/command/bdist_wininst.pyR      sN    
         					(	S	17	(   t   __doc__t   __revision__RB   R(   RO   t	   sysconfigR    t   distutils.coreR   t   distutils.dir_utilR   t   distutils.errorsR   R   R   Ru   R   t   distutils.utilR   R   (    (    (    s5   /usr/lib/python2.7/distutils/command/bdist_wininst.pyt   <module>   s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             """distutils.command.clean

Implements the Distutils 'clean' command."""

# contributed by Bastian Kleineidam <calvin@cs.uni-sb.de>, added 2000-03-18

__revision__ = "$Id$"

import os
from distutils.core import Command
from distutils.dir_util import remove_tree
from distutils import log

class clean(Command):

    description = "clean up temporary files from 'build' command"
    user_options = [
        ('build-base=', 'b',
         "base build directory (default: 'build.build-base')"),
        ('build-lib=', None,
         "build directory for all modules (default: 'build.build-lib')"),
        ('build-temp=', 't',
         "temporary build directory (default: 'build.build-temp')"),
        ('build-scripts=', None,
         "build directory for scripts (default: 'build.build-scripts')"),
        ('bdist-base=', None,
         "temporary directory for built distributions"),
        ('all', 'a',
         "remove all build output, not just temporary by-products")
    ]

    boolean_options = ['all']

    def initialize_options(self):
        self.build_base = None
        self.build_lib = None
        self.build_temp = None
        self.build_scripts = None
        self.bdist_base = None
        self.all = None

    def finalize_options(self):
        self.set_undefined_options('build',
                                   ('build_base', 'build_base'),
                                   ('build_lib', 'build_lib'),
                                   ('build_scripts', 'build_scripts'),
                                   ('build_temp', 'build_temp'))
        self.set_undefined_options('bdist',
                                   ('bdist_base', 'bdist_base'))

    def run(self):
        # remove the build/temp.<plat> directory (unless it's already
        # gone)
        if os.path.exists(self.build_temp):
            remove_tree(self.build_temp, dry_run=self.dry_run)
        else:
            log.debug("'%s' does not exist -- can't clean it",
                      self.build_temp)

        if self.all:
            # remove build directories
            for directory in (self.build_lib,
                              self.bdist_base,
                              self.build_scripts):
                if os.path.exists(directory):
                    remove_tree(directory, dry_run=self.dry_run)
                else:
                    log.warn("'%s' does not exist -- can't clean it",
                             directory)

        # just for the heck of it, try to remove the base build directory:
        # we might have emptied it right now, but if not we don't care
        if not self.dry_run:
            try:
                os.rmdir(self.build_base)
                log.info("removing '%s'", self.build_base)
            except OSError:
                pass

# class clean
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  """distutils.command.build

Implements the Distutils 'build' command."""

__revision__ = "$Id$"

import sys, os

from distutils.util import get_platform
from distutils.core import Command
from distutils.errors import DistutilsOptionError

def show_compilers():
    from distutils.ccompiler import show_compilers
    show_compilers()

class build(Command):

    description = "build everything needed to install"

    user_options = [
        ('build-base=', 'b',
         "base directory for build library"),
        ('build-purelib=', None,
         "build directory for platform-neutral distributions"),
        ('build-platlib=', None,
         "build directory for platform-specific distributions"),
        ('build-lib=', None,
         "build directory for all distribution (defaults to either " +
         "build-purelib or build-platlib"),
        ('build-scripts=', None,
         "build directory for scripts"),
        ('build-temp=', 't',
         "temporary build directory"),
        ('plat-name=', 'p',
         "platform name to build for, if supported "
         "(default: %s)" % get_platform()),
        ('compiler=', 'c',
         "specify the compiler type"),
        ('debug', 'g',
         "compile extensions and libraries with debugging information"),
        ('force', 'f',
         "forcibly build everything (ignore file timestamps)"),
        ('executable=', 'e',
         "specify final destination interpreter path (build.py)"),
        ]

    boolean_options = ['debug', 'force']

    help_options = [
        ('help-compiler', None,
         "list available compilers", show_compilers),
        ]

    def initialize_options(self):
        self.build_base = 'build'
        # these are decided only after 'build_base' has its final value
        # (unless overridden by the user or client)
        self.build_purelib = None
        self.build_platlib = None
        self.build_lib = None
        self.build_temp = None
        self.build_scripts = None
        self.compiler = None
        self.plat_name = None
        self.debug = None
        self.force = 0
        self.executable = None

    def finalize_options(self):
        if self.plat_name is None:
            self.plat_name = get_platform()
        else:
            # plat-name only supported for windows (other platforms are
            # supported via ./configure flags, if at all).  Avoid misleading
            # other platforms.
            if os.name != 'nt':
                raise DistutilsOptionError(
                            "--plat-name only supported on Windows (try "
                            "using './configure --help' on your platform)")

        plat_specifier = ".%s-%s" % (self.plat_name, sys.version[0:3])

        # Make it so Python 2.x and Python 2.x with --with-pydebug don't
        # share the same build directories. Doing so confuses the build
        # process for C modules
        if hasattr(sys, 'gettotalrefcount'):
            plat_specifier += '-pydebug'

        # 'build_purelib' and 'build_platlib' just default to 'lib' and
        # 'lib.<plat>' under the base build directory.  We only use one of
        # them for a given distribution, though --
        if self.build_purelib is None:
            self.build_purelib = os.path.join(self.build_base,
                                              'lib' + plat_specifier)
        if self.build_platlib is None:
            self.build_platlib = os.path.join(self.build_base,
                                              'lib' + plat_specifier)

        # 'build_lib' is the actual directory that we will use for this
        # particular module distribution -- if user didn't supply it, pick
        # one of 'build_purelib' or 'build_platlib'.
        if self.build_lib is None:
            if self.distribution.ext_modules:
                self.build_lib = self.build_platlib
            else:
                self.build_lib = self.build_purelib

        # 'build_temp' -- temporary directory for compiler turds,
        # "build/temp.<plat>"
        if self.build_temp is None:
            self.build_temp = os.path.join(self.build_base,
                                           'temp' + plat_specifier)
        if self.build_scripts is None:
            self.build_scripts = os.path.join(self.build_base,
                                              'scripts-' + sys.version[0:3])

        if self.executable is None:
            self.executable = os.path.normpath(sys.executable)

    def run(self):
        # Run all relevant sub-commands.  This will be some subset of:
        #  - build_py      - pure Python modules
        #  - build_clib    - standalone C libraries
        #  - build_ext     - Python extensions
        #  - build_scripts - (Python) scripts
        for cmd_name in self.get_sub_commands():
            self.run_command(cmd_name)

    # -- Predicates for the sub-command list ---------------------------

    def has_pure_modules (self):
        return self.distribution.has_pure_modules()

    def has_c_libraries (self):
        return self.distribution.has_c_libraries()

    def has_ext_modules (self):
        return self.distribution.has_ext_modules()

    def has_scripts (self):
        return self.distribution.has_scripts()

    sub_commands = [('build_py',      has_pure_modules),
                    ('build_clib',    has_c_libraries),
                    ('build_ext',     has_ext_modules),
                    ('build_scripts', has_scripts),
                   ]
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Û
”´[c           @   sw   d  Z  d Z d d l Z d d l Z d d l m Z d d l m Z d d l m	 Z	 d Ñ  Z
 d e f d	 Ñ  É  YZ d S(
   sB   distutils.command.build

Implements the Distutils 'build' command.s   $Id$iˇˇˇˇN(   t   get_platform(   t   Command(   t   DistutilsOptionErrorc          C   s   d d l  m }  |  É  d  S(   Niˇˇˇˇ(   t   show_compilers(   t   distutils.ccompilerR   (   R   (    (    s-   /usr/lib/python2.7/distutils/command/build.pyR      s    t   buildc           B   s‹   e  Z d  Z d, d. d/ d d- d	 d
 f d0 d1 d d d e É  f d2 d3 d4 d5 g Z d d g Z d d- d  e f g Z d! Ñ  Z	 d" Ñ  Z
 d# Ñ  Z d$ Ñ  Z d% Ñ  Z d& Ñ  Z d' Ñ  Z d( e f d) e f d* e f d+ e f g Z RS(6   s"   build everything needed to installs   build-base=t   bs    base directory for build librarys   build-purelib=s2   build directory for platform-neutral distributionss   build-platlib=s3   build directory for platform-specific distributionss
   build-lib=s9   build directory for all distribution (defaults to either s   build-purelib or build-platlibs   build-scripts=s   build directory for scriptss   build-temp=t   ts   temporary build directorys
   plat-name=t   ps6   platform name to build for, if supported (default: %s)s	   compiler=t   cs   specify the compiler typet   debugt   gs;   compile extensions and libraries with debugging informationt   forcet   fs2   forcibly build everything (ignore file timestamps)s   executable=t   es5   specify final destination interpreter path (build.py)s   help-compilers   list available compilersc         C   sg   d |  _  d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _	 d |  _
 d  |  _ d  S(   NR   i    (   t
   build_baset   Nonet   build_purelibt   build_platlibt	   build_libt
   build_tempt   build_scriptst   compilert	   plat_nameR
   R   t
   executable(   t   self(    (    s-   /usr/lib/python2.7/distutils/command/build.pyt   initialize_options7   s    										c         C   s™  |  j  d  k r t É  |  _  n t j d k r< t d É Ç n  d |  j  t j d d !f } t t d É ru | d 7} n  |  j	 d  k r¶ t j
 j |  j d | É |  _	 n  |  j d  k r◊ t j
 j |  j d | É |  _ n  |  j d  k r|  j j r|  j |  _ q|  j	 |  _ n  |  j d  k rAt j
 j |  j d	 | É |  _ n  |  j d  k r|t j
 j |  j d
 t j d d !É |  _ n  |  j d  k r¶t j
 j t j É |  _ n  d  S(   Nt   ntsW   --plat-name only supported on Windows (try using './configure --help' on your platform)s   .%s-%si    i   t   gettotalrefcounts   -pydebugt   libt   temps   scripts-(   R   R   R    t   ost   nameR   t   syst   versiont   hasattrR   t   patht   joinR   R   R   t   distributiont   ext_modulesR   R   R   t   normpath(   R   t   plat_specifier(    (    s-   /usr/lib/python2.7/distutils/command/build.pyt   finalize_optionsF   s4    c         C   s(   x! |  j  É  D] } |  j | É q Wd  S(   N(   t   get_sub_commandst   run_command(   R   t   cmd_name(    (    s-   /usr/lib/python2.7/distutils/command/build.pyt   runy   s    c         C   s   |  j  j É  S(   N(   R&   t   has_pure_modules(   R   (    (    s-   /usr/lib/python2.7/distutils/command/build.pyR/   Ñ   s    c         C   s   |  j  j É  S(   N(   R&   t   has_c_libraries(   R   (    (    s-   /usr/lib/python2.7/distutils/command/build.pyR0   á   s    c         C   s   |  j  j É  S(   N(   R&   t   has_ext_modules(   R   (    (    s-   /usr/lib/python2.7/distutils/command/build.pyR1   ä   s    c         C   s   |  j  j É  S(   N(   R&   t   has_scripts(   R   (    (    s-   /usr/lib/python2.7/distutils/command/build.pyR2   ç   s    t   build_pyt
   build_clibt	   build_extR   (   s   build-base=R   s    base directory for build libraryN(   s   build-purelib=Ns2   build directory for platform-neutral distributions(   s   build-platlib=Ns3   build directory for platform-specific distributions(   s   build-scripts=Ns   build directory for scripts(   s   build-temp=R   s   temporary build directory(   s	   compiler=R	   s   specify the compiler type(   R
   R   s;   compile extensions and libraries with debugging information(   R   R   s2   forcibly build everything (ignore file timestamps)(   s   executable=R   s5   specify final destination interpreter path (build.py)(   t   __name__t
   __module__t   descriptionR   R    t   user_optionst   boolean_optionsR   t   help_optionsR   R*   R.   R/   R0   R1   R2   t   sub_commands(    (    (    s-   /usr/lib/python2.7/distutils/command/build.pyR      sN        
    			3								(   t   __doc__t   __revision__R!   R   t   distutils.utilR    t   distutils.coreR   t   distutils.errorsR   R   R   (    (    (    s-   /usr/lib/python2.7/distutils/command/build.pyt   <module>   s   	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             """distutils.command.build_clib

Implements the Distutils 'build_clib' command, to build a C/C++ library
that is included in the module distribution and needed by an extension
module."""

__revision__ = "$Id$"


# XXX this module has *lots* of code ripped-off quite transparently from
# build_ext.py -- not surprisingly really, as the work required to build
# a static library from a collection of C source files is not really all
# that different from what's required to build a shared object file from
# a collection of C source files.  Nevertheless, I haven't done the
# necessary refactoring to account for the overlap in code between the
# two modules, mainly because a number of subtle details changed in the
# cut 'n paste.  Sigh.

import os
from distutils.core import Command
from distutils.errors import DistutilsSetupError
from distutils.sysconfig import customize_compiler
from distutils import log

def show_compilers():
    from distutils.ccompiler import show_compilers
    show_compilers()


class build_clib(Command):

    description = "build C/C++ libraries used by Python extensions"

    user_options = [
        ('build-clib=', 'b',
         "directory to build C/C++ libraries to"),
        ('build-temp=', 't',
         "directory to put temporary build by-products"),
        ('debug', 'g',
         "compile with debugging information"),
        ('force', 'f',
         "forcibly build everything (ignore file timestamps)"),
        ('compiler=', 'c',
         "specify the compiler type"),
        ]

    boolean_options = ['debug', 'force']

    help_options = [
        ('help-compiler', None,
         "list available compilers", show_compilers),
        ]

    def initialize_options(self):
        self.build_clib = None
        self.build_temp = None

        # List of libraries to build
        self.libraries = None

        # Compilation options for all libraries
        self.include_dirs = None
        self.define = None
        self.undef = None
        self.debug = None
        self.force = 0
        self.compiler = None


    def finalize_options(self):
        # This might be confusing: both build-clib and build-temp default
        # to build-temp as defined by the "build" command.  This is because
        # I think that C libraries are really just temporary build
        # by-products, at least from the point of view of building Python
        # extensions -- but I want to keep my options open.
        self.set_undefined_options('build',
                                   ('build_temp', 'build_clib'),
                                   ('build_temp', 'build_temp'),
                                   ('compiler', 'compiler'),
                                   ('debug', 'debug'),
                                   ('force', 'force'))

        self.libraries = self.distribution.libraries
        if self.libraries:
            self.check_library_list(self.libraries)

        if self.include_dirs is None:
            self.include_dirs = self.distribution.include_dirs or []
        if isinstance(self.include_dirs, str):
            self.include_dirs = self.include_dirs.split(os.pathsep)

        # XXX same as for build_ext -- what about 'self.define' and
        # 'self.undef' ?

    def run(self):
        if not self.libraries:
            return

        # Yech -- this is cut 'n pasted from build_ext.py!
        from distutils.ccompiler import new_compiler
        self.compiler = new_compiler(compiler=self.compiler,
                                     dry_run=self.dry_run,
                                     force=self.force)
        customize_compiler(self.compiler)

        if self.include_dirs is not None:
            self.compiler.set_include_dirs(self.include_dirs)
        if self.define is not None:
            # 'define' option is a list of (name,value) tuples
            for (name,value) in self.define:
                self.compiler.define_macro(name, value)
        if self.undef is not None:
            for macro in self.undef:
                self.compiler.undefine_macro(macro)

        self.build_libraries(self.libraries)


    def check_library_list(self, libraries):
        """Ensure that the list of libraries is valid.

        `library` is presumably provided as a command option 'libraries'.
        This method checks that it is a list of 2-tuples, where the tuples
        are (library_name, build_info_dict).

        Raise DistutilsSetupError if the structure is invalid anywhere;
        just returns otherwise.
        """
        if not isinstance(libraries, list):
            raise DistutilsSetupError, \
                  "'libraries' option must be a list of tuples"

        for lib in libraries:
            if not isinstance(lib, tuple) and len(lib) != 2:
                raise DistutilsSetupError, \
                      "each element of 'libraries' must a 2-tuple"

            name, build_info = lib

            if not isinstance(name, str):
                raise DistutilsSetupError, \
                      "first element of each tuple in 'libraries' " + \
                      "must be a string (the library name)"
            if '/' in name or (os.sep != '/' and os.sep in name):
                raise DistutilsSetupError, \
                      ("bad library name '%s': " +
                       "may not contain directory separators") % \
                      lib[0]

            if not isinstance(build_info, dict):
                raise DistutilsSetupError, \
                      "second element of each tuple in 'libraries' " + \
                      "must be a dictionary (build info)"

    def get_library_names(self):
        # Assume the library list is valid -- 'check_library_list()' is
        # called from 'finalize_options()', so it should be!
        if not self.libraries:
            return None

        lib_names = []
        for (lib_name, build_info) in self.libraries:
            lib_names.append(lib_name)
        return lib_names


    def get_source_files(self):
        self.check_library_list(self.libraries)
        filenames = []
        for (lib_name, build_info) in self.libraries:
            sources = build_info.get('sources')
            if sources is None or not isinstance(sources, (list, tuple)):
                raise DistutilsSetupError, \
                      ("in 'libraries' option (library '%s'), "
                       "'sources' must be present and must be "
                       "a list of source filenames") % lib_name

            filenames.extend(sources)
        return filenames

    def build_libraries(self, libraries):
        for (lib_name, build_info) in libraries:
            sources = build_info.get('sources')
            if sources is None or not isinstance(sources, (list, tuple)):
                raise DistutilsSetupError, \
                      ("in 'libraries' option (library '%s'), " +
                       "'sources' must be present and must be " +
                       "a list of source filenames") % lib_name
            sources = list(sources)

            log.info("building '%s' library", lib_name)

            # First, compile the source code to object files in the library
            # directory.  (This should probably change to putting object
            # files in a temporary build directory.)
            macros = build_info.get('macros')
            include_dirs = build_info.get('include_dirs')
            objects = self.compiler.compile(sources,
                                            output_dir=self.build_temp,
                                            macros=macros,
                                            include_dirs=include_dirs,
                                            debug=self.debug)

            # Now "link" the object files together into a static library.
            # (On Unix at least, this isn't really linking -- it just
            # builds an archive.  Whatever.)
            self.compiler.create_static_lib(objects, lib_name,
                                            output_dir=self.build_clib,
                                            debug=self.debug)
                                                             Û
”´[c           @   s{   d  Z  d Z d d l Z d d l m Z d d l m Z d d l m Z d d l	 m
 Z
 d Ñ  Z d	 e f d
 Ñ  É  YZ d S(   s¥   distutils.command.build_clib

Implements the Distutils 'build_clib' command, to build a C/C++ library
that is included in the module distribution and needed by an extension
module.s   $Id$iˇˇˇˇN(   t   Command(   t   DistutilsSetupError(   t   customize_compiler(   t   logc          C   s   d d l  m }  |  É  d  S(   Niˇˇˇˇ(   t   show_compilers(   t   distutils.ccompilerR   (   R   (    (    s2   /usr/lib/python2.7/distutils/command/build_clib.pyR      s    t
   build_clibc           B   sÉ   e  Z d  Z d d d d d g Z d d
 g Z d d d e f g Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   s/   build C/C++ libraries used by Python extensionss   build-clib=t   bs%   directory to build C/C++ libraries tos   build-temp=t   ts,   directory to put temporary build by-productst   debugt   gs"   compile with debugging informationt   forcet   fs2   forcibly build everything (ignore file timestamps)s	   compiler=t   cs   specify the compiler types   help-compilers   list available compilersc         C   sU   d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d |  _ d  |  _	 d  S(   Ni    (
   t   NoneR   t
   build_tempt	   librariest   include_dirst   definet   undefR	   R   t   compiler(   t   self(    (    s2   /usr/lib/python2.7/distutils/command/build_clib.pyt   initialize_options6   s    								c         C   sü   |  j  d d d d	 d
 d É |  j j |  _ |  j rG |  j |  j É n  |  j d  k rn |  j j pe g  |  _ n  t |  j t É rõ |  j j t	 j
 É |  _ n  d  S(   Nt   buildR   R   R   R	   R   (   R   R   (   R   R   (   R   R   (   R	   R	   (   R   R   (   t   set_undefined_optionst   distributionR   t   check_library_listR   R   t
   isinstancet   strt   splitt   ost   pathsep(   R   (    (    s2   /usr/lib/python2.7/distutils/command/build_clib.pyt   finalize_optionsF   s    		c         C   sˇ   |  j  s d  Sd d l m } | d |  j d |  j d |  j É |  _ t |  j É |  j d  k	 rv |  j j	 |  j É n  |  j
 d  k	 rµ x- |  j
 D] \ } } |  j j | | É qè Wn  |  j d  k	 rÎ x$ |  j D] } |  j j | É qŒ Wn  |  j |  j  É d  S(   Niˇˇˇˇ(   t   new_compilerR   t   dry_runR   (   R   R   R!   R   R"   R   R   R   R   t   set_include_dirsR   t   define_macroR   t   undefine_macrot   build_libraries(   R   R!   t   namet   valuet   macro(    (    s2   /usr/lib/python2.7/distutils/command/build_clib.pyt   run_   s     		c         C   sÍ   t  | t É s t d Ç n  x» | D]¿ } t  | t É rV t | É d k rV t d Ç n  | \ } } t  | t É sÅ t d d Ç n  d | k s´ t j d k r√ t j | k r√ t d d | d	 Ç n  t  | t É s" t d
 d Ç q" q" Wd S(   s`  Ensure that the list of libraries is valid.

        `library` is presumably provided as a command option 'libraries'.
        This method checks that it is a list of 2-tuples, where the tuples
        are (library_name, build_info_dict).

        Raise DistutilsSetupError if the structure is invalid anywhere;
        just returns otherwise.
        s+   'libraries' option must be a list of tuplesi   s*   each element of 'libraries' must a 2-tuples+   first element of each tuple in 'libraries' s#   must be a string (the library name)t   /s   bad library name '%s': s$   may not contain directory separatorsi    s,   second element of each tuple in 'libraries' s!   must be a dictionary (build info)N(	   R   t   listR   t   tuplet   lenR   R   t   sept   dict(   R   R   t   libR'   t
   build_info(    (    s2   /usr/lib/python2.7/distutils/command/build_clib.pyR   w   s*    
	"	
*c         C   s>   |  j  s d  Sg  } x$ |  j  D] \ } } | j | É q W| S(   N(   R   R   t   append(   R   t	   lib_namest   lib_nameR2   (    (    s2   /usr/lib/python2.7/distutils/command/build_clib.pyt   get_library_namesõ   s    	c         C   sÇ   |  j  |  j É g  } xe |  j D]Z \ } } | j d É } | d  k s] t | t t f É rm t d | Ç n  | j | É q  W| S(   Nt   sourcessf   in 'libraries' option (library '%s'), 'sources' must be present and must be a list of source filenames(	   R   R   t   getR   R   R,   R-   R   t   extend(   R   t	   filenamesR5   R2   R7   (    (    s2   /usr/lib/python2.7/distutils/command/build_clib.pyt   get_source_filesß   s    "
c         C   sÛ   xÏ | D]‰ \ } } | j  d É } | d  k sD t | t t f É r\ t d d d | Ç n  t | É } t j d | É | j  d É } | j  d É } |  j j	 | d |  j
 d | d | d	 |  j É} |  j j | | d |  j d	 |  j Éq Wd  S(
   NR7   s&   in 'libraries' option (library '%s'), s&   'sources' must be present and must be s   a list of source filenamess   building '%s' libraryt   macrosR   t
   output_dirR	   (   R8   R   R   R,   R-   R   R   t   infoR   t   compileR   R	   t   create_static_libR   (   R   R   R5   R2   R7   R<   R   t   objects(    (    s2   /usr/lib/python2.7/distutils/command/build_clib.pyR&   µ   s$    "		(   s   build-clib=R   s%   directory to build C/C++ libraries to(   s   build-temp=R   s,   directory to put temporary build by-products(   R	   R
   s"   compile with debugging information(   R   R   s2   forcibly build everything (ignore file timestamps)(   s	   compiler=R   s   specify the compiler typeN(   t   __name__t
   __module__t   descriptiont   user_optionst   boolean_optionsR   R   t   help_optionsR   R    R*   R   R6   R;   R&   (    (    (    s2   /usr/lib/python2.7/distutils/command/build_clib.pyR      s*        					$		(   t   __doc__t   __revision__R   t   distutils.coreR    t   distutils.errorsR   t   distutils.sysconfigR   t	   distutilsR   R   R   (    (    (    s2   /usr/lib/python2.7/distutils/command/build_clib.pyt   <module>   s   	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         """distutils.command.build_py

Implements the Distutils 'build_py' command."""

__revision__ = "$Id$"

import os
import sys
from glob import glob

from distutils.core import Command
from distutils.errors import DistutilsOptionError, DistutilsFileError
from distutils.util import convert_path
from distutils import log

class build_py(Command):

    description = "\"build\" pure Python modules (copy to build directory)"

    user_options = [
        ('build-lib=', 'd', "directory to \"build\" (copy) to"),
        ('compile', 'c', "compile .py to .pyc"),
        ('no-compile', None, "don't compile .py files [default]"),
        ('optimize=', 'O',
         "also compile with optimization: -O1 for \"python -O\", "
         "-O2 for \"python -OO\", and -O0 to disable [default: -O0]"),
        ('force', 'f', "forcibly build everything (ignore file timestamps)"),
        ]

    boolean_options = ['compile', 'force']
    negative_opt = {'no-compile' : 'compile'}

    def initialize_options(self):
        self.build_lib = None
        self.py_modules = None
        self.package = None
        self.package_data = None
        self.package_dir = None
        self.compile = 0
        self.optimize = 0
        self.force = None

    def finalize_options(self):
        self.set_undefined_options('build',
                                   ('build_lib', 'build_lib'),
                                   ('force', 'force'))

        # Get the distribution options that are aliases for build_py
        # options -- list of packages and list of modules.
        self.packages = self.distribution.packages
        self.py_modules = self.distribution.py_modules
        self.package_data = self.distribution.package_data
        self.package_dir = {}
        if self.distribution.package_dir:
            for name, path in self.distribution.package_dir.items():
                self.package_dir[name] = convert_path(path)
        self.data_files = self.get_data_files()

        # Ick, copied straight from install_lib.py (fancy_getopt needs a
        # type system!  Hell, *everything* needs a type system!!!)
        if not isinstance(self.optimize, int):
            try:
                self.optimize = int(self.optimize)
                assert 0 <= self.optimize <= 2
            except (ValueError, AssertionError):
                raise DistutilsOptionError("optimize must be 0, 1, or 2")

    def run(self):
        # XXX copy_file by default preserves atime and mtime.  IMHO this is
        # the right thing to do, but perhaps it should be an option -- in
        # particular, a site administrator might want installed files to
        # reflect the time of installation rather than the last
        # modification time before the installed release.

        # XXX copy_file by default preserves mode, which appears to be the
        # wrong thing to do: if a file is read-only in the working
        # directory, we want it to be installed read/write so that the next
        # installation of the same module distribution can overwrite it
        # without problems.  (This might be a Unix-specific issue.)  Thus
        # we turn off 'preserve_mode' when copying to the build directory,
        # since the build directory is supposed to be exactly what the
        # installation will look like (ie. we preserve mode when
        # installing).

        # Two options control which modules will be installed: 'packages'
        # and 'py_modules'.  The former lets us work with whole packages, not
        # specifying individual modules at all; the latter is for
        # specifying modules one-at-a-time.

        if self.py_modules:
            self.build_modules()
        if self.packages:
            self.build_packages()
            self.build_package_data()

        self.byte_compile(self.get_outputs(include_bytecode=0))

    def get_data_files(self):
        """Generate list of '(package,src_dir,build_dir,filenames)' tuples"""
        data = []
        if not self.packages:
            return data
        for package in self.packages:
            # Locate package source directory
            src_dir = self.get_package_dir(package)

            # Compute package build directory
            build_dir = os.path.join(*([self.build_lib] + package.split('.')))

            # Length of path to strip from found files
            plen = 0
            if src_dir:
                plen = len(src_dir)+1

            # Strip directory from globbed filenames
            filenames = [
                file[plen:] for file in self.find_data_files(package, src_dir)
                ]
            data.append((package, src_dir, build_dir, filenames))
        return data

    def find_data_files(self, package, src_dir):
        """Return filenames for package's data files in 'src_dir'"""
        globs = (self.package_data.get('', [])
                 + self.package_data.get(package, []))
        files = []
        for pattern in globs:
            # Each pattern has to be converted to a platform-specific path
            filelist = glob(os.path.join(src_dir, convert_path(pattern)))
            # Files that match more than one pattern are only added once
            files.extend([fn for fn in filelist if fn not in files
                and os.path.isfile(fn)])
        return files

    def build_package_data(self):
        """Copy data files into build directory"""
        for package, src_dir, build_dir, filenames in self.data_files:
            for filename in filenames:
                target = os.path.join(build_dir, filename)
                self.mkpath(os.path.dirname(target))
                self.copy_file(os.path.join(src_dir, filename), target,
                               preserve_mode=False)

    def get_package_dir(self, package):
        """Return the directory, relative to the top of the source
           distribution, where package 'package' should be found
           (at least according to the 'package_dir' option, if any)."""

        path = package.split('.')

        if not self.package_dir:
            if path:
                return os.path.join(*path)
            else:
                return ''
        else:
            tail = []
            while path:
                try:
                    pdir = self.package_dir['.'.join(path)]
                except KeyError:
                    tail.insert(0, path[-1])
                    del path[-1]
                else:
                    tail.insert(0, pdir)
                    return os.path.join(*tail)
            else:
                # Oops, got all the way through 'path' without finding a
                # match in package_dir.  If package_dir defines a directory
                # for the root (nameless) package, then fallback on it;
                # otherwise, we might as well have not consulted
                # package_dir at all, as we just use the directory implied
                # by 'tail' (which should be the same as the original value
                # of 'path' at this point).
                pdir = self.package_dir.get('')
                if pdir is not None:
                    tail.insert(0, pdir)

                if tail:
                    return os.path.join(*tail)
                else:
                    return ''

    def check_package(self, package, package_dir):
        # Empty dir name means current directory, which we can probably
        # assume exists.  Also, os.path.exists and isdir don't know about
        # my "empty string means current dir" convention, so we have to
        # circumvent them.
        if package_dir != "":
            if not os.path.exists(package_dir):
                raise DistutilsFileError(
                      "package directory '%s' does not exist" % package_dir)
            if not os.path.isdir(package_dir):
                raise DistutilsFileError(
                       "supposed package directory '%s' exists, "
                       "but is not a directory" % package_dir)

        # Require __init__.py for all but the "root package"
        if package:
            init_py = os.path.join(package_dir, "__init__.py")
            if os.path.isfile(init_py):
                return init_py
            else:
                log.warn(("package init file '%s' not found " +
                          "(or not a regular file)"), init_py)

        # Either not in a package at all (__init__.py not expected), or
        # __init__.py doesn't exist -- so don't return the filename.
        return None

    def check_module(self, module, module_file):
        if not os.path.isfile(module_file):
            log.warn("file %s (for module %s) not found", module_file, module)
            return False
        else:
            return True

    def find_package_modules(self, package, package_dir):
        self.check_package(package, package_dir)
        module_files = glob(os.path.join(package_dir, "*.py"))
        modules = []
        setup_script = os.path.abspath(self.distribution.script_name)

        for f in module_files:
            abs_f = os.path.abspath(f)
            if abs_f != setup_script:
                module = os.path.splitext(os.path.basename(f))[0]
                modules.append((package, module, f))
            else:
                self.debug_print("excluding %s" % setup_script)
        return modules

    def find_modules(self):
        """Finds individually-specified Python modules, ie. those listed by
        module name in 'self.py_modules'.  Returns a list of tuples (package,
        module_base, filename): 'package' is a tuple of the path through
        package-space to the module; 'module_base' is the bare (no
        packages, no dots) module name, and 'filename' is the path to the
        ".py" file (relative to the distribution root) that implements the
        module.
        """
        # Map package names to tuples of useful info about the package:
        #    (package_dir, checked)
        # package_dir - the directory where we'll find source files for
        #   this package
        # checked - true if we have checked that the package directory
        #   is valid (exists, contains __init__.py, ... ?)
        packages = {}

        # List of (package, module, filename) tuples to return
        modules = []

        # We treat modules-in-packages almost the same as toplevel modules,
        # just the "package" for a toplevel is empty (either an empty
        # string or empty list, depending on context).  Differences:
        #   - don't check for __init__.py in directory for empty package
        for module in self.py_modules:
            path = module.split('.')
            package = '.'.join(path[0:-1])
            module_base = path[-1]

            try:
                (package_dir, checked) = packages[package]
            except KeyError:
                package_dir = self.get_package_dir(package)
                checked = 0

            if not checked:
                init_py = self.check_package(package, package_dir)
                packages[package] = (package_dir, 1)
                if init_py:
                    modules.append((package, "__init__", init_py))

            # XXX perhaps we should also check for just .pyc files
            # (so greedy closed-source bastards can distribute Python
            # modules too)
            module_file = os.path.join(package_dir, module_base + ".py")
            if not self.check_module(module, module_file):
                continue

            modules.append((package, module_base, module_file))

        return modules

    def find_all_modules(self):
        """Compute the list of all modules that will be built, whether
        they are specified one-module-at-a-time ('self.py_modules') or
        by whole packages ('self.packages').  Return a list of tuples
        (package, module, module_file), just like 'find_modules()' and
        'find_package_modules()' do."""
        modules = []
        if self.py_modules:
            modules.extend(self.find_modules())
        if self.packages:
            for package in self.packages:
                package_dir = self.get_package_dir(package)
                m = self.find_package_modules(package, package_dir)
                modules.extend(m)
        return modules

    def get_source_files(self):
        return [module[-1] for module in self.find_all_modules()]

    def get_module_outfile(self, build_dir, package, module):
        outfile_path = [build_dir] + list(package) + [module + ".py"]
        return os.path.join(*outfile_path)

    def get_outputs(self, include_bytecode=1):
        modules = self.find_all_modules()
        outputs = []
        for (package, module, module_file) in modules:
            package = package.split('.')
            filename = self.get_module_outfile(self.build_lib, package, module)
            outputs.append(filename)
            if include_bytecode:
                if self.compile:
                    outputs.append(filename + "c")
                if self.optimize > 0:
                    outputs.append(filename + "o")

        outputs += [
            os.path.join(build_dir, filename)
            for package, src_dir, build_dir, filenames in self.data_files
            for filename in filenames
            ]

        return outputs

    def build_module(self, module, module_file, package):
        if isinstance(package, str):
            package = package.split('.')
        elif not isinstance(package, (list, tuple)):
            raise TypeError(
                  "'package' must be a string (dot-separated), list, or tuple")

        # Now put the module source file into the "build" area -- this is
        # easy, we just copy it somewhere under self.build_lib (the build
        # directory for Python source).
        outfile = self.get_module_outfile(self.build_lib, package, module)
        dir = os.path.dirname(outfile)
        self.mkpath(dir)
        return self.copy_file(module_file, outfile, preserve_mode=0)

    def build_modules(self):
        modules = self.find_modules()
        for (package, module, module_file) in modules:

            # Now "build" the module -- ie. copy the source file to
            # self.build_lib (the build directory for Python source).
            # (Actually, it gets copied to the directory for this package
            # under self.build_lib.)
            self.build_module(module, module_file, package)

    def build_packages(self):
        for package in self.packages:

            # Get list of (package, module, module_file) tuples based on
            # scanning the package directory.  'package' is only included
            # in the tuple so that 'find_modules()' and
            # 'find_package_tuples()' have a consistent interface; it's
            # ignored here (apart from a sanity check).  Also, 'module' is
            # the *unqualified* module name (ie. no dots, no package -- we
            # already know its package!), and 'module_file' is the path to
            # the .py file, relative to the current directory
            # (ie. including 'package_dir').
            package_dir = self.get_package_dir(package)
            modules = self.find_package_modules(package, package_dir)

            # Now loop over the modules we found, "building" each one (just
            # copy it to self.build_lib).
            for (package_, module, module_file) in modules:
                assert package == package_
                self.build_module(module, module_file, package)

    def byte_compile(self, files):
        if sys.dont_write_bytecode:
            self.warn('byte-compiling is disabled, skipping.')
            return

        from distutils.util import byte_compile
        prefix = self.build_lib
        if prefix[-1] != os.sep:
            prefix = prefix + os.sep

        # XXX this code is essentially the same as the 'byte_compile()
        # method of the "install_lib" command, except for the determination
        # of the 'prefix' string.  Hmmm.

        if self.compile:
            byte_compile(files, optimize=0,
                         force=self.force, prefix=prefix, dry_run=self.dry_run)
        if self.optimize > 0:
            byte_compile(files, optimize=self.optimize,
                         force=self.force, prefix=prefix, dry_run=self.dry_run)
                                              """distutils.command.build_ext

Implements the Distutils 'build_ext' command, for building extension
modules (currently limited to C extensions, should accommodate C++
extensions ASAP)."""

# This module should be kept compatible with Python 2.1.

__revision__ = "$Id$"

import sys, os, string, re
from types import *
from site import USER_BASE, USER_SITE
from distutils.core import Command
from distutils.errors import *
from distutils.sysconfig import customize_compiler, get_python_version
from distutils.dep_util import newer_group
from distutils.extension import Extension
from distutils.util import get_platform
from distutils import log

if os.name == 'nt':
    from distutils.msvccompiler import get_build_version
    MSVC_VERSION = int(get_build_version())

# An extension name is just a dot-separated list of Python NAMEs (ie.
# the same as a fully-qualified module name).
extension_name_re = re.compile \
    (r'^[a-zA-Z_][a-zA-Z_0-9]*(\.[a-zA-Z_][a-zA-Z_0-9]*)*$')


def show_compilers ():
    from distutils.ccompiler import show_compilers
    show_compilers()


class build_ext (Command):

    description = "build C/C++ extensions (compile/link to build directory)"

    # XXX thoughts on how to deal with complex command-line options like
    # these, i.e. how to make it so fancy_getopt can suck them off the
    # command line and make it look like setup.py defined the appropriate
    # lists of tuples of what-have-you.
    #   - each command needs a callback to process its command-line options
    #   - Command.__init__() needs access to its share of the whole
    #     command line (must ultimately come from
    #     Distribution.parse_command_line())
    #   - it then calls the current command class' option-parsing
    #     callback to deal with weird options like -D, which have to
    #     parse the option text and churn out some custom data
    #     structure
    #   - that data structure (in this case, a list of 2-tuples)
    #     will then be present in the command object by the time
    #     we get to finalize_options() (i.e. the constructor
    #     takes care of both command-line and client options
    #     in between initialize_options() and finalize_options())

    sep_by = " (separated by '%s')" % os.pathsep
    user_options = [
        ('build-lib=', 'b',
         "directory for compiled extension modules"),
        ('build-temp=', 't',
         "directory for temporary files (build by-products)"),
        ('plat-name=', 'p',
         "platform name to cross-compile for, if supported "
         "(default: %s)" % get_platform()),
        ('inplace', 'i',
         "ignore build-lib and put compiled extensions into the source " +
         "directory alongside your pure Python modules"),
        ('include-dirs=', 'I',
         "list of directories to search for header files" + sep_by),
        ('define=', 'D',
         "C preprocessor macros to define"),
        ('undef=', 'U',
         "C preprocessor macros to undefine"),
        ('libraries=', 'l',
         "external C libraries to link with"),
        ('library-dirs=', 'L',
         "directories to search for external C libraries" + sep_by),
        ('rpath=', 'R',
         "directories to search for shared C libraries at runtime"),
        ('link-objects=', 'O',
         "extra explicit link objects to include in the link"),
        ('debug', 'g',
         "compile/link with debugging information"),
        ('force', 'f',
         "forcibly build everything (ignore file timestamps)"),
        ('compiler=', 'c',
         "specify the compiler type"),
        ('swig-cpp', None,
         "make SWIG create C++ files (default is C)"),
        ('swig-opts=', None,
         "list of SWIG command line options"),
        ('swig=', None,
         "path to the SWIG executable"),
        ('user', None,
         "add user include, library and rpath"),
        ]

    boolean_options = ['inplace', 'debug', 'force', 'swig-cpp', 'user']

    help_options = [
        ('help-compiler', None,
         "list available compilers", show_compilers),
        ]

    def initialize_options (self):
        self.extensions = None
        self.build_lib = None
        self.plat_name = None
        self.build_temp = None
        self.inplace = 0
        self.package = None

        self.include_dirs = None
        self.define = None
        self.undef = None
        self.libraries = None
        self.library_dirs = None
        self.rpath = None
        self.link_objects = None
        self.debug = None
        self.force = None
        self.compiler = None
        self.swig = None
        self.swig_cpp = None
        self.swig_opts = None
        self.user = None

    def finalize_options(self):
        from distutils import sysconfig

        self.set_undefined_options('build',
                                   ('build_lib', 'build_lib'),
                                   ('build_temp', 'build_temp'),
                                   ('compiler', 'compiler'),
                                   ('debug', 'debug'),
                                   ('force', 'force'),
                                   ('plat_name', 'plat_name'),
                                   )

        if self.package is None:
            self.package = self.distribution.ext_package

        self.extensions = self.distribution.ext_modules

        # Make sure Python's include directories (for Python.h, pyconfig.h,
        # etc.) are in the include search path.
        py_include = sysconfig.get_python_inc()
        plat_py_include = sysconfig.get_python_inc(plat_specific=1)
        if self.include_dirs is None:
            self.include_dirs = self.distribution.include_dirs or []
        if isinstance(self.include_dirs, str):
            self.include_dirs = self.include_dirs.split(os.pathsep)

        # Put the Python "system" include dir at the end, so that
        # any local include dirs take precedence.
        self.include_dirs.append(py_include)
        if plat_py_include != py_include:
            self.include_dirs.append(plat_py_include)

        self.ensure_string_list('libraries')
        self.ensure_string_list('link_objects')

        # Life is easier if we're not forever checking for None, so
        # simplify these options to empty lists if unset
        if self.libraries is None:
            self.libraries = []
        if self.library_dirs is None:
            self.library_dirs = []
        elif type(self.library_dirs) is StringType:
            self.library_dirs = string.split(self.library_dirs, os.pathsep)

        if self.rpath is None:
            self.rpath = []
        elif type(self.rpath) is StringType:
            self.rpath = string.split(self.rpath, os.pathsep)

        # for extensions under windows use different directories
        # for Release and Debug builds.
        # also Python's library directory must be appended to library_dirs
        if os.name == 'nt':
            # the 'libs' directory is for binary installs - we assume that
            # must be the *native* platform.  But we don't really support
            # cross-compiling via a binary install anyway, so we let it go.
            self.library_dirs.append(os.path.join(sys.exec_prefix, 'libs'))
            if self.debug:
                self.build_temp = os.path.join(self.build_temp, "Debug")
            else:
                self.build_temp = os.path.join(self.build_temp, "Release")

            # Append the source distribution include and library directories,
            # this allows distutils on windows to work in the source tree
            self.include_dirs.append(os.path.join(sys.exec_prefix, 'PC'))
            if MSVC_VERSION == 9:
                # Use the .lib files for the correct architecture
                if self.plat_name == 'win32':
                    suffix = ''
                else:
                    # win-amd64 or win-ia64
                    suffix = self.plat_name[4:]
                # We could have been built in one of two places; add both
                for d in ('PCbuild',), ('PC', 'VS9.0'):
                    new_lib = os.path.join(sys.exec_prefix, *d)
                    if suffix:
                        new_lib = os.path.join(new_lib, suffix)
                    self.library_dirs.append(new_lib)

            elif MSVC_VERSION == 8:
                self.library_dirs.append(os.path.join(sys.exec_prefix,
                                         'PC', 'VS8.0'))
            elif MSVC_VERSION == 7:
                self.library_dirs.append(os.path.join(sys.exec_prefix,
                                         'PC', 'VS7.1'))
            else:
                self.library_dirs.append(os.path.join(sys.exec_prefix,
                                         'PC', 'VC6'))

        # OS/2 (EMX) doesn't support Debug vs Release builds, but has the
        # import libraries in its "Config" subdirectory
        if os.name == 'os2':
            self.library_dirs.append(os.path.join(sys.exec_prefix, 'Config'))

        # for extensions under Cygwin and AtheOS Python's library directory must be
        # appended to library_dirs
        if sys.platform[:6] == 'cygwin' or sys.platform[:6] == 'atheos':
            if sys.executable.startswith(os.path.join(sys.exec_prefix, "bin")):
                # building third party extensions
                self.library_dirs.append(os.path.join(sys.prefix, "lib",
                                                      "python" + get_python_version(),
                                                      "config"))
            else:
                # building python standard extensions
                self.library_dirs.append('.')

        # For building extensions with a shared Python library,
        # Python's library directory must be appended to library_dirs
        # See Issues: #1600860, #4366
        if False and (sysconfig.get_config_var('Py_ENABLE_SHARED')):
            if not sysconfig.python_build:
                # building third party extensions
                self.library_dirs.append(sysconfig.get_config_var('LIBDIR'))
            else:
                # building python standard extensions
                self.library_dirs.append('.')

        # The argument parsing will result in self.define being a string, but
        # it has to be a list of 2-tuples.  All the preprocessor symbols
        # specified by the 'define' option will be set to '1'.  Multiple
        # symbols can be separated with commas.

        if self.define:
            defines = self.define.split(',')
            self.define = map(lambda symbol: (symbol, '1'), defines)

        # The option for macros to undefine is also a string from the
        # option parsing, but has to be a list.  Multiple symbols can also
        # be separated with commas here.
        if self.undef:
            self.undef = self.undef.split(',')

        if self.swig_opts is None:
            self.swig_opts = []
        else:
            self.swig_opts = self.swig_opts.split(' ')

        # Finally add the user include and library directories if requested
        if self.user:
            user_include = os.path.join(USER_BASE, "include")
            user_lib = os.path.join(USER_BASE, "lib")
            if os.path.isdir(user_include):
                self.include_dirs.append(user_include)
            if os.path.isdir(user_lib):
                self.library_dirs.append(user_lib)
                self.rpath.append(user_lib)

    def run(self):
        from distutils.ccompiler import new_compiler

        # 'self.extensions', as supplied by setup.py, is a list of
        # Extension instances.  See the documentation for Extension (in
        # distutils.extension) for details.
        #
        # For backwards compatibility with Distutils 0.8.2 and earlier, we
        # also allow the 'extensions' list to be a list of tuples:
        #    (ext_name, build_info)
        # where build_info is a dictionary containing everything that
        # Extension instances do except the name, with a few things being
        # differently named.  We convert these 2-tuples to Extension
        # instances as needed.

        if not self.extensions:
            return

        # If we were asked to build any C/C++ libraries, make sure that the
        # directory where we put them is in the library search path for
        # linking extensions.
        if self.distribution.has_c_libraries():
            build_clib = self.get_finalized_command('build_clib')
            self.libraries.extend(build_clib.get_library_names() or [])
            self.library_dirs.append(build_clib.build_clib)

        # Setup the CCompiler object that we'll use to do all the
        # compiling and linking
        self.compiler = new_compiler(compiler=self.compiler,
                                     verbose=self.verbose,
                                     dry_run=self.dry_run,
                                     force=self.force)
        customize_compiler(self.compiler)
        # If we are cross-compiling, init the compiler now (if we are not
        # cross-compiling, init would not hurt, but people may rely on
        # late initialization of compiler even if they shouldn't...)
        if os.name == 'nt' and self.plat_name != get_platform():
            self.compiler.initialize(self.plat_name)

        # And make sure that any compile/link-related options (which might
        # come from the command-line or from the setup script) are set in
        # that CCompiler object -- that way, they automatically apply to
        # all compiling and linking done here.
        if self.include_dirs is not None:
            self.compiler.set_include_dirs(self.include_dirs)
        if self.define is not None:
            # 'define' option is a list of (name,value) tuples
            for (name, value) in self.define:
                self.compiler.define_macro(name, value)
        if self.undef is not None:
            for macro in self.undef:
                self.compiler.undefine_macro(macro)
        if self.libraries is not None:
            self.compiler.set_libraries(self.libraries)
        if self.library_dirs is not None:
            self.compiler.set_library_dirs(self.library_dirs)
        if self.rpath is not None:
            self.compiler.set_runtime_library_dirs(self.rpath)
        if self.link_objects is not None:
            self.compiler.set_link_objects(self.link_objects)

        # Now actually compile and link everything.
        self.build_extensions()

    def check_extensions_list(self, extensions):
        """Ensure that the list of extensions (presumably provided as a
        command option 'extensions') is valid, i.e. it is a list of
        Extension objects.  We also support the old-style list of 2-tuples,
        where the tuples are (ext_name, build_info), which are converted to
        Extension instances here.

        Raise DistutilsSetupError if the structure is invalid anywhere;
        just returns otherwise.
        """
        if not isinstance(extensions, list):
            raise DistutilsSetupError, \
                  "'ext_modules' option must be a list of Extension instances"

        for i, ext in enumerate(extensions):
            if isinstance(ext, Extension):
                continue                # OK! (assume type-checking done
                                        # by Extension constructor)

            if not isinstance(ext, tuple) or len(ext) != 2:
                raise DistutilsSetupError, \
                      ("each element of 'ext_modules' option must be an "
                       "Extension instance or 2-tuple")

            ext_name, build_info = ext

            log.warn(("old-style (ext_name, build_info) tuple found in "
                      "ext_modules for extension '%s'"
                      "-- please convert to Extension instance" % ext_name))

            if not (isinstance(ext_name, str) and
                    extension_name_re.match(ext_name)):
                raise DistutilsSetupError, \
                      ("first element of each tuple in 'ext_modules' "
                       "must be the extension name (a string)")

            if not isinstance(build_info, dict):
                raise DistutilsSetupError, \
                      ("second element of each tuple in 'ext_modules' "
                       "must be a dictionary (build info)")

            # OK, the (ext_name, build_info) dict is type-safe: convert it
            # to an Extension instance.
            ext = Extension(ext_name, build_info['sources'])

            # Easy stuff: one-to-one mapping from dict elements to
            # instance attributes.
            for key in ('include_dirs', 'library_dirs', 'libraries',
                        'extra_objects', 'extra_compile_args',
                        'extra_link_args'):
                val = build_info.get(key)
                if val is not None:
                    setattr(ext, key, val)

            # Medium-easy stuff: same syntax/semantics, different names.
            ext.runtime_library_dirs = build_info.get('rpath')
            if 'def_file' in build_info:
                log.warn("'def_file' element of build info dict "
                         "no longer supported")

            # Non-trivial stuff: 'macros' split into 'define_macros'
            # and 'undef_macros'.
            macros = build_info.get('macros')
            if macros:
                ext.define_macros = []
                ext.undef_macros = []
                for macro in macros:
                    if not (isinstance(macro, tuple) and len(macro) in (1, 2)):
                        raise DistutilsSetupError, \
                              ("'macros' element of build info dict "
                               "must be 1- or 2-tuple")
                    if len(macro) == 1:
                        ext.undef_macros.append(macro[0])
                    elif len(macro) == 2:
                        ext.define_macros.append(macro)

            extensions[i] = ext

    def get_source_files(self):
        self.check_extensions_list(self.extensions)
        filenames = []

        # Wouldn't it be neat if we knew the names of header files too...
        for ext in self.extensions:
            filenames.extend(ext.sources)

        return filenames

    def get_outputs(self):
        # Sanity check the 'extensions' list -- can't assume this is being
        # done in the same run as a 'build_extensions()' call (in fact, we
        # can probably assume that it *isn't*!).
        self.check_extensions_list(self.extensions)

        # And build the list of output (built) filenames.  Note that this
        # ignores the 'inplace' flag, and assumes everything goes in the
        # "build" tree.
        outputs = []
        for ext in self.extensions:
            outputs.append(self.get_ext_fullpath(ext.name))
        return outputs

    def build_extensions(self):
        # First, sanity-check the 'extensions' list
        self.check_extensions_list(self.extensions)

        for ext in self.extensions:
            self.build_extension(ext)

    def build_extension(self, ext):
        sources = ext.sources
        if sources is None or type(sources) not in (ListType, TupleType):
            raise DistutilsSetupError, \
                  ("in 'ext_modules' option (extension '%s'), " +
                   "'sources' must be present and must be " +
                   "a list of source filenames") % ext.name
        sources = list(sources)

        ext_path = self.get_ext_fullpath(ext.name)
        depends = sources + ext.depends
        if not (self.force or newer_group(depends, ext_path, 'newer')):
            log.debug("skipping '%s' extension (up-to-date)", ext.name)
            return
        else:
            log.info("building '%s' extension", ext.name)

        # First, scan the sources for SWIG definition files (.i), run
        # SWIG on 'em to create .c files, and modify the sources list
        # accordingly.
        sources = self.swig_sources(sources, ext)

        # Next, compile the source code to object files.

        # XXX not honouring 'define_macros' or 'undef_macros' -- the
        # CCompiler API needs to change to accommodate this, and I
        # want to do one thing at a time!

        # Two possible sources for extra compiler arguments:
        #   - 'extra_compile_args' in Extension object
        #   - CFLAGS environment variable (not particularly
        #     elegant, but people seem to expect it and I
        #     guess it's useful)
        # The environment variable should take precedence, and
        # any sensible compiler will give precedence to later
        # command line args.  Hence we combine them in order:
        extra_args = ext.extra_compile_args or []

        macros = ext.define_macros[:]
        for undef in ext.undef_macros:
            macros.append((undef,))

        objects = self.compiler.compile(sources,
                                         output_dir=self.build_temp,
                                         macros=macros,
                                         include_dirs=ext.include_dirs,
                                         debug=self.debug,
                                         extra_postargs=extra_args,
                                         depends=ext.depends)

        # XXX -- this is a Vile HACK!
        #
        # The setup.py script for Python on Unix needs to be able to
        # get this list so it can perform all the clean up needed to
        # avoid keeping object files around when cleaning out a failed
        # build of an extension module.  Since Distutils does not
        # track dependencies, we have to get rid of intermediates to
        # ensure all the intermediates will be properly re-built.
        #
        self._built_objects = objects[:]

        # Now link the object files together into a "shared object" --
        # of course, first we have to figure out all the other things
        # that go into the mix.
        if ext.extra_objects:
            objects.extend(ext.extra_objects)
        extra_args = ext.extra_link_args or []

        # Detect target language, if not provided
        language = ext.language or self.compiler.detect_language(sources)

        self.compiler.link_shared_object(
            objects, ext_path,
            libraries=self.get_libraries(ext),
            library_dirs=ext.library_dirs,
            runtime_library_dirs=ext.runtime_library_dirs,
            extra_postargs=extra_args,
            export_symbols=self.get_export_symbols(ext),
            debug=self.debug,
            build_temp=self.build_temp,
            target_lang=language)


    def swig_sources (self, sources, extension):

        """Walk the list of source files in 'sources', looking for SWIG
        interface (.i) files.  Run SWIG on all that are found, and
        return a modified 'sources' list with SWIG source files replaced
        by the generated C (or C++) files.
        """

        new_sources = []
        swig_sources = []
        swig_targets = {}

        # XXX this drops generated C/C++ files into the source tree, which
        # is fine for developers who want to distribute the generated
        # source -- but there should be an option to put SWIG output in
        # the temp dir.

        if self.swig_cpp:
            log.warn("--swig-cpp is deprecated - use --swig-opts=-c++")

        if self.swig_cpp or ('-c++' in self.swig_opts) or \
           ('-c++' in extension.swig_opts):
            target_ext = '.cpp'
        else:
            target_ext = '.c'

        for source in sources:
            (base, ext) = os.path.splitext(source)
            if ext == ".i":             # SWIG interface file
                new_sources.append(base + '_wrap' + target_ext)
                swig_sources.append(source)
                swig_targets[source] = new_sources[-1]
            else:
                new_sources.append(source)

        if not swig_sources:
            return new_sources

        swig = self.swig or self.find_swig()
        swig_cmd = [swig, "-python"]
        swig_cmd.extend(self.swig_opts)
        if self.swig_cpp:
            swig_cmd.append("-c++")

        # Do not override commandline arguments
        if not self.swig_opts:
            for o in extension.swig_opts:
                swig_cmd.append(o)

        for source in swig_sources:
            target = swig_targets[source]
            log.info("swigging %s to %s", source, target)
            self.spawn(swig_cmd + ["-o", target, source])

        return new_sources

    # swig_sources ()

    def find_swig (self):
        """Return the name of the SWIG executable.  On Unix, this is
        just "swig" -- it should be in the PATH.  Tries a bit harder on
        Windows.
        """

        if os.name == "posix":
            return "swig"
        elif os.name == "nt":

            # Look for SWIG in its standard installation directory on
            # Windows (or so I presume!).  If we find it there, great;
            # if not, act like Unix and assume it's in the PATH.
            for vers in ("1.3", "1.2", "1.1"):
                fn = os.path.join("c:\\swig%s" % vers, "swig.exe")
                if os.path.isfile(fn):
                    return fn
            else:
                return "swig.exe"

        elif os.name == "os2":
            # assume swig available in the PATH.
            return "swig.exe"

        else:
            raise DistutilsPlatformError, \
                  ("I don't know how to find (much less run) SWIG "
                   "on platform '%s'") % os.name

    # find_swig ()

    # -- Name generators -----------------------------------------------
    # (extension names, filenames, whatever)
    def get_ext_fullpath(self, ext_name):
        """Returns the path of the filename for a given extension.

        The file is located in `build_lib` or directly in the package
        (inplace option).
        """
        # makes sure the extension name is only using dots
        all_dots = string.maketrans('/'+os.sep, '..')
        ext_name = ext_name.translate(all_dots)

        fullname = self.get_ext_fullname(ext_name)
        modpath = fullname.split('.')
        filename = self.get_ext_filename(ext_name)
        filename = os.path.split(filename)[-1]

        if not self.inplace:
            # no further work needed
            # returning :
            #   build_dir/package/path/filename
            filename = os.path.join(*modpath[:-1]+[filename])
            return os.path.join(self.build_lib, filename)

        # the inplace option requires to find the package directory
        # using the build_py command for that
        package = '.'.join(modpath[0:-1])
        build_py = self.get_finalized_command('build_py')
        package_dir = os.path.abspath(build_py.get_package_dir(package))

        # returning
        #   package_dir/filename
        return os.path.join(package_dir, filename)

    def get_ext_fullname(self, ext_name):
        """Returns the fullname of a given extension name.

        Adds the `package.` prefix"""
        if self.package is None:
            return ext_name
        else:
            return self.package + '.' + ext_name

    def get_ext_filename(self, ext_name):
        r"""Convert the name of an extension (eg. "foo.bar") into the name
        of the file from which it will be loaded (eg. "foo/bar.so", or
        "foo\bar.pyd").
        """
        from distutils.sysconfig import get_config_var
        ext_path = string.split(ext_name, '.')
        # OS/2 has an 8 character module (extension) limit :-(
        if os.name == "os2":
            ext_path[len(ext_path) - 1] = ext_path[len(ext_path) - 1][:8]
        # extensions in debug_mode are named 'module_d.pyd' under windows
        so_ext = get_config_var('SO')
        if os.name == 'nt' and self.debug:
            return os.path.join(*ext_path) + '_d' + so_ext
        return os.path.join(*ext_path) + so_ext

    def get_export_symbols (self, ext):
        """Return the list of symbols that a shared extension has to
        export.  This either uses 'ext.export_symbols' or, if it's not
        provided, "init" + module_name.  Only relevant on Windows, where
        the .pyd file (DLL) must export the module "init" function.
        """
        initfunc_name = "init" + ext.name.split('.')[-1]
        if initfunc_name not in ext.export_symbols:
            ext.export_symbols.append(initfunc_name)
        return ext.export_symbols

    def get_libraries (self, ext):
        """Return the list of libraries to link against when building a
        shared extension.  On most platforms, this is just 'ext.libraries';
        on Windows and OS/2, we add the Python library (eg. python20.dll).
        """
        # The python library is always needed on Windows.  For MSVC, this
        # is redundant, since the library is mentioned in a pragma in
        # pyconfig.h that MSVC groks.  The other Windows compilers all seem
        # to need it mentioned explicitly, though, so that's what we do.
        # Append '_d' to the python import library on debug builds.
        if sys.platform == "win32":
            from distutils.msvccompiler import MSVCCompiler
            if not isinstance(self.compiler, MSVCCompiler):
                template = "python%d%d"
                if self.debug:
                    template = template + '_d'
                pythonlib = (template %
                       (sys.hexversion >> 24, (sys.hexversion >> 16) & 0xff))
                # don't extend ext.libraries, it may be shared with other
                # extensions, it is a reference to the original list
                return ext.libraries + [pythonlib]
            else:
                return ext.libraries
        elif sys.platform == "os2emx":
            # EMX/GCC requires the python library explicitly, and I
            # believe VACPP does as well (though not confirmed) - AIM Apr01
            template = "python%d%d"
            # debug versions of the main DLL aren't supported, at least
            # not at this time - AIM Apr01
            #if self.debug:
            #    template = template + '_d'
            pythonlib = (template %
                   (sys.hexversion >> 24, (sys.hexversion >> 16) & 0xff))
            # don't extend ext.libraries, it may be shared with other
            # extensions, it is a reference to the original list
            return ext.libraries + [pythonlib]
        elif sys.platform[:6] == "cygwin":
            template = "python%d.%d"
            pythonlib = (template %
                   (sys.hexversion >> 24, (sys.hexversion >> 16) & 0xff))
            # don't extend ext.libraries, it may be shared with other
            # extensions, it is a reference to the original list
            return ext.libraries + [pythonlib]
        elif sys.platform[:6] == "atheos":
            from distutils import sysconfig

            template = "python%d.%d"
            pythonlib = (template %
                   (sys.hexversion >> 24, (sys.hexversion >> 16) & 0xff))
            # Get SHLIBS from Makefile
            extra = []
            for lib in sysconfig.get_config_var('SHLIBS').split():
                if lib.startswith('-l'):
                    extra.append(lib[2:])
                else:
                    extra.append(lib)
            # don't extend ext.libraries, it may be shared with other
            # extensions, it is a reference to the original list
            return ext.libraries + [pythonlib, "m"] + extra

        elif sys.platform == 'darwin':
            # Don't use the default code below
            return ext.libraries
        elif sys.platform[:3] == 'aix':
            # Don't use the default code below
            return ext.libraries
        else:
            from distutils import sysconfig
            if False and sysconfig.get_config_var('Py_ENABLE_SHARED'):
                template = "python%d.%d"
                pythonlib = (template %
                             (sys.hexversion >> 24, (sys.hexversion >> 16) & 0xff))
                return ext.libraries + [pythonlib]
            else:
                return ext.libraries

# class build_ext
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               Û
”´[c           @   s/  d  Z  d Z d d l Z d d l Z d d l Z d d l Z d d l Td d l m Z m	 Z	 d d l
 m Z d d l Td d l m Z m Z d d l m Z d d	 l m Z d d
 l m Z d d l m Z e j d k r˝ d d l m Z e e É  É Z n  e j d É Z d Ñ  Z d e f d Ñ  É  YZ  d S(   s∂   distutils.command.build_ext

Implements the Distutils 'build_ext' command, for building extension
modules (currently limited to C extensions, should accommodate C++
extensions ASAP).s   $Id$iˇˇˇˇN(   t   *(   t	   USER_BASEt	   USER_SITE(   t   Command(   t   customize_compilert   get_python_version(   t   newer_group(   t	   Extension(   t   get_platform(   t   logt   nt(   t   get_build_versions3   ^[a-zA-Z_][a-zA-Z_0-9]*(\.[a-zA-Z_][a-zA-Z_0-9]*)*$c          C   s   d d l  m }  |  É  d  S(   Niˇˇˇˇ(   t   show_compilers(   t   distutils.ccompilerR   (   R   (    (    s1   /usr/lib/python2.7/distutils/command/build_ext.pyR       s    t	   build_extc           B   s?  e  Z d  Z d e j Z dF dG d d	 d
 e É  f d d d d f d d d e f dH dI dJ d d d e f dK dL dM dN dO dQ dR dS dT g Z d d$ d' d- d3 g Z	 d5 dP d6 e
 f g Z d7 Ñ  Z d8 Ñ  Z d9 Ñ  Z d: Ñ  Z d; Ñ  Z d< Ñ  Z d= Ñ  Z d> Ñ  Z d? Ñ  Z d@ Ñ  Z dA Ñ  Z dB Ñ  Z dC Ñ  Z dD Ñ  Z dE Ñ  Z RS(U   s8   build C/C++ extensions (compile/link to build directory)s    (separated by '%s')s
   build-lib=t   bs(   directory for compiled extension moduless   build-temp=t   ts1   directory for temporary files (build by-products)s
   plat-name=t   ps>   platform name to cross-compile for, if supported (default: %s)t   inplacet   is=   ignore build-lib and put compiled extensions into the source s,   directory alongside your pure Python moduless   include-dirs=t   Is.   list of directories to search for header filess   define=t   Ds   C preprocessor macros to defines   undef=t   Us!   C preprocessor macros to undefines
   libraries=t   ls!   external C libraries to link withs   library-dirs=t   Ls.   directories to search for external C librariess   rpath=t   Rs7   directories to search for shared C libraries at runtimes   link-objects=t   Os2   extra explicit link objects to include in the linkt   debugt   gs'   compile/link with debugging informationt   forcet   fs2   forcibly build everything (ignore file timestamps)s	   compiler=t   cs   specify the compiler types   swig-cpps)   make SWIG create C++ files (default is C)s
   swig-opts=s!   list of SWIG command line optionss   swig=s   path to the SWIG executablet   users#   add user include, library and rpaths   help-compilers   list available compilersc         C   s∏   d  |  _ d  |  _ d  |  _ d  |  _ d |  _ d  |  _ d  |  _ d  |  _ d  |  _	 d  |  _
 d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  S(   Ni    (   t   Nonet
   extensionst	   build_libt	   plat_namet
   build_tempR   t   packaget   include_dirst   definet   undeft	   librariest   library_dirst   rpatht   link_objectsR   R   t   compilert   swigt   swig_cppt	   swig_optsR    (   t   self(    (    s1   /usr/lib/python2.7/distutils/command/build_ext.pyt   initialize_optionsl   s(    																			c   
   	   C   sØ  d d l  m } |  j d d. d/ d0 d1 d2 d3 É |  j d  k rP |  j j |  _ n  |  j j |  _ | j	 É  } | j	 d
 d É } |  j
 d  k r§ |  j j
 põ g  |  _
 n  t |  j
 t É r— |  j
 j t j É |  _
 n  |  j
 j | É | | k r |  j
 j | É n  |  j d É |  j d É |  j d  k r5g  |  _ n  |  j d  k rPg  |  _ n3 t |  j É t k rÉt j |  j t j É |  _ n  |  j d  k rûg  |  _ n3 t |  j É t k r—t j |  j t j É |  _ n  t j d k rá|  j j t j j t j d É É |  j r)t j j |  j d É |  _ n t j j |  j d É |  _ |  j
 j t j j t j d É É t d k r˜|  j  d k räd } n |  j  d } xÍ d4 d5 f D]L } t j j t j | å } | r‡t j j | | É } n  |  j j | É q§Wqát d k r+|  j j t j j t j d d É É qát d k r_|  j j t j j t j d d É É qá|  j j t j j t j d d É É n  t j d k rª|  j j t j j t j d É É n  t j! d   d! k s·t j! d   d" k rJt j" j# t j j t j d# É É r7|  j j t j j t j$ d$ d% t% É  d& É É qJ|  j j d' É n  t& ró| j' d( É ró| j( sÑ|  j j | j' d) É É qó|  j j d' É n  |  j) r |  j) j d* É } t* d+ Ñ  | É |  _) n  |  j+ rÎ|  j+ j d* É |  _+ n  |  j, d  k rg  |  _, n |  j, j d, É |  _, |  j- r´t j j t. d- É } t j j t. d$ É }	 t j j/ | É rs|  j
 j | É n  t j j/ |	 É r´|  j j |	 É |  j j |	 É q´n  d  S(6   Niˇˇˇˇ(   t	   sysconfigt   buildR#   R%   R.   R   R   R$   t   plat_specifici   R*   R-   R
   t   libst   Debugt   Releaset   PCi	   t   win32t    i   t   PCbuilds   VS9.0i   s   VS8.0i   s   VS7.1t   VC6t   os2t   Configi   t   cygwint   atheost   bint   libt   pythont   configt   .t   Py_ENABLE_SHAREDt   LIBDIRt   ,c         S   s
   |  d f S(   Nt   1(    (   t   symbol(    (    s1   /usr/lib/python2.7/distutils/command/build_ext.pyt   <lambda>ˇ   s    t    t   include(   R#   R#   (   R%   R%   (   R.   R.   (   R   R   (   R   R   (   R$   R$   (   R=   (   R:   s   VS9.0(0   t	   distutilsR4   t   set_undefined_optionsR&   R!   t   distributiont   ext_packaget   ext_modulesR"   t   get_python_incR'   t
   isinstancet   strt   splitt   ost   pathsept   appendt   ensure_string_listR*   R+   t   typet
   StringTypet   stringR,   t   namet   patht   joint   syst   exec_prefixR   R%   t   MSVC_VERSIONR$   t   platformt
   executablet
   startswitht   prefixR   t   Falset   get_config_vart   python_buildR(   t   mapR)   R1   R    R   t   isdir(
   R2   R4   t
   py_includet   plat_py_includet   suffixt   dt   new_libt   definest   user_includet   user_lib(    (    s1   /usr/lib/python2.7/distutils/command/build_ext.pyt   finalize_optionsÉ   s¶    	"	"	%&$
				c      	   C   s  d d l  m } |  j s d  S|  j j É  rm |  j d É } |  j j | j É  pS g  É |  j	 j
 | j É n  | d |  j d |  j d |  j d |  j É |  _ t |  j É t j d k r· |  j t É  k r· |  j j |  j É n  |  j d  k	 r|  j j |  j É n  |  j d  k	 rEx- |  j D] \ } } |  j j | | É qWn  |  j d  k	 r{x$ |  j D] } |  j j | É q^Wn  |  j d  k	 r†|  j j |  j É n  |  j	 d  k	 r≈|  j j |  j	 É n  |  j d  k	 rÍ|  j j  |  j É n  |  j! d  k	 r|  j j" |  j! É n  |  j# É  d  S(	   Niˇˇˇˇ(   t   new_compilert
   build_clibR.   t   verboset   dry_runR   R
   ($   R   Rx   R"   RR   t   has_c_librariest   get_finalized_commandR*   t   extendt   get_library_namesR+   R[   Ry   R.   Rz   R{   R   R   RY   R`   R$   R   t
   initializeR'   R!   t   set_include_dirsR(   t   define_macroR)   t   undefine_macrot   set_librariest   set_library_dirsR,   t   set_runtime_library_dirsR-   t   set_link_objectst   build_extensions(   R2   Rx   Ry   R`   t   valuet   macro(    (    s1   /usr/lib/python2.7/distutils/command/build_ext.pyt   run  s>    			!c   
      C   s!  t  | t É s t d Ç n  xˇt | É D]Ò\ } } t  | t É rI q( n  t  | t É sk t | É d k rw t d Ç n  | \ } } t j d | É t  | t	 É oØ t
 j | É sæ t d Ç n  t  | t É sŸ t d Ç n  t | | d É } x< d D]4 } | j | É } | d k	 rÛ t | | | É qÛ qÛ W| j d É | _ d | k rYt j d É n  | j d É } | rg  | _ g  | _ xå | D]Å }	 t  |	 t É o´t |	 É d k s∫t d Ç n  t |	 É d k r„| j j |	 d É qát |	 É d k rá| j j |	 É qáqáWn  | | | <q( Wd S(   s¨  Ensure that the list of extensions (presumably provided as a
        command option 'extensions') is valid, i.e. it is a list of
        Extension objects.  We also support the old-style list of 2-tuples,
        where the tuples are (ext_name, build_info), which are converted to
        Extension instances here.

        Raise DistutilsSetupError if the structure is invalid anywhere;
        just returns otherwise.
        s:   'ext_modules' option must be a list of Extension instancesi   sM   each element of 'ext_modules' option must be an Extension instance or 2-tuplesu   old-style (ext_name, build_info) tuple found in ext_modules for extension '%s'-- please convert to Extension instancesR   first element of each tuple in 'ext_modules' must be the extension name (a string)sO   second element of each tuple in 'ext_modules' must be a dictionary (build info)t   sourcesR'   R+   R*   t   extra_objectst   extra_compile_argst   extra_link_argsR,   t   def_files9   'def_file' element of build info dict no longer supportedt   macrosi   s9   'macros' element of build info dict must be 1- or 2-tuplei    N(   R'   R+   R*   Rç   Ré   Rè   (   i   i   (   RV   t   listt   DistutilsSetupErrort	   enumerateR   t   tuplet   lenR	   t   warnRW   t   extension_name_ret   matcht   dictt   getR!   t   setattrt   runtime_library_dirst   define_macrost   undef_macrosR[   (
   R2   R"   R   t   extt   ext_namet
   build_infot   keyt   valRë   Rä   (    (    s1   /usr/lib/python2.7/distutils/command/build_ext.pyt   check_extensions_listV  sT    
	"				 
		!	c         C   s>   |  j  |  j É g  } x! |  j D] } | j | j É q  W| S(   N(   R•   R"   R~   Rå   (   R2   t	   filenamesR†   (    (    s1   /usr/lib/python2.7/distutils/command/build_ext.pyt   get_source_files§  s
    c         C   sG   |  j  |  j É g  } x* |  j D] } | j |  j | j É É q  W| S(   N(   R•   R"   R[   t   get_ext_fullpathR`   (   R2   t   outputsR†   (    (    s1   /usr/lib/python2.7/distutils/command/build_ext.pyt   get_outputsÆ  s
    c         C   s5   |  j  |  j É x |  j D] } |  j | É q Wd  S(   N(   R•   R"   t   build_extension(   R2   R†   (    (    s1   /usr/lib/python2.7/distutils/command/build_ext.pyRà   º  s    c   
      C   s˛  | j  } | d  k s- t | É t t f k rH t d d d | j Ç n  t | É } |  j | j É } | | j	 } |  j
 pã t | | d É s• t j d | j É d  St j d | j É |  j | | É } | j p÷ g  } | j } x! | j D] } | j | f É qÌ W|  j j | d |  j d | d	 | j d
 |  j d | d | j	 É} | |  _ | j ro| j | j É n  | j p{g  } | j pñ|  j j | É }	 |  j j | | d |  j | É d | j  d | j! d | d |  j" | É d
 |  j d |  j d |	 Éd  S(   Ns*   in 'ext_modules' option (extension '%s'), s&   'sources' must be present and must be s   a list of source filenamest   newers$   skipping '%s' extension (up-to-date)s   building '%s' extensiont
   output_dirRë   R'   R   t   extra_postargst   dependsR*   R+   Rù   t   export_symbolsR%   t   target_lang(#   Rå   R!   R]   t   ListTypet	   TupleTypeRì   R`   Rí   R®   RØ   R   R   R	   R   t   infot   swig_sourcesRé   Rû   Rü   R[   R.   t   compileR%   R'   t   _built_objectsRç   R~   Rè   t   languaget   detect_languaget   link_shared_objectt   get_librariesR+   Rù   t   get_export_symbols(
   R2   R†   Rå   t   ext_pathRØ   t
   extra_argsRë   R)   t   objectsR∏   (    (    s1   /usr/lib/python2.7/distutils/command/build_ext.pyR´   √  sN    	$
			
							c         C   s£  g  } g  } i  } |  j  r+ t j d É n  |  j  sR d |  j k sR d | j k r[ d } n d } xr | D]j } t j j | É \ } }	 |	 d k r≈ | j | d | É | j | É | d | | <qh | j | É qh W| s‡ | S|  j pÚ |  j	 É  }
 |
 d g } | j
 |  j É |  j  r*| j d É n  |  j sWx! | j D] } | j | É q=Wn  xE | D]= } | | } t j d	 | | É |  j | d
 | | g É q^W| S(   s¸   Walk the list of source files in 'sources', looking for SWIG
        interface (.i) files.  Run SWIG on all that are found, and
        return a modified 'sources' list with SWIG source files replaced
        by the generated C (or C++) files.
        s/   --swig-cpp is deprecated - use --swig-opts=-c++s   -c++s   .cpps   .cs   .it   _wrapiˇˇˇˇs   -pythons   swigging %s to %ss   -o(   R0   R	   Ró   R1   RY   Ra   t   splitextR[   R/   t	   find_swigR~   R¥   t   spawn(   R2   Rå   t	   extensiont   new_sourcesRµ   t   swig_targetst
   target_extt   sourcet   baseR†   R/   t   swig_cmdt   ot   target(    (    s1   /usr/lib/python2.7/distutils/command/build_ext.pyRµ     s>    				
c         C   sê   t  j d k r d St  j d k ri xg d D]5 } t  j j d | d É } t  j j | É r) | Sq) Wd Sn# t  j d	 k r| d St d
 t  j Ç d S(   sõ   Return the name of the SWIG executable.  On Unix, this is
        just "swig" -- it should be in the PATH.  Tries a bit harder on
        Windows.
        t   posixR/   R
   s   1.3s   1.2s   1.1s	   c:\swig%ss   swig.exeR?   s>   I don't know how to find (much less run) SWIG on platform '%s'N(   s   1.3s   1.2s   1.1(   RY   R`   Ra   Rb   t   isfilet   DistutilsPlatformError(   R2   t   verst   fn(    (    s1   /usr/lib/python2.7/distutils/command/build_ext.pyR¬   P  s    c   	      C   s˙   t  j d t j d É } | j | É } |  j | É } | j d É } |  j | É } t j j | É d } |  j	 sß t j j
 | d  | g å  } t j j
 |  j | É Sd j
 | d d !É } |  j d É } t j j | j | É É } t j j
 | | É S(   s°   Returns the path of the filename for a given extension.

        The file is located in `build_lib` or directly in the package
        (inplace option).
        t   /s   ..RG   iˇˇˇˇi    t   build_py(   R_   t	   maketransRY   t   sept	   translatet   get_ext_fullnameRX   t   get_ext_filenameRa   R   Rb   R#   R}   t   abspatht   get_package_dir(	   R2   R°   t   all_dotst   fullnamet   modpatht   filenameR&   R”   t   package_dir(    (    s1   /usr/lib/python2.7/distutils/command/build_ext.pyR®   q  s    	c         C   s&   |  j  d k r | S|  j  d | Sd S(   sS   Returns the fullname of a given extension name.

        Adds the `package.` prefixRG   N(   R&   R!   (   R2   R°   (    (    s1   /usr/lib/python2.7/distutils/command/build_ext.pyR◊   ë  s    c         C   s™   d d l  m } t j | d É } t j d k rZ | t | É d d  | t | É d <n  | d É } t j d k rñ |  j rñ t j j	 | å  d	 | St j j	 | å  | S(
   s¶   Convert the name of an extension (eg. "foo.bar") into the name
        of the file from which it will be loaded (eg. "foo/bar.so", or
        "foo\bar.pyd").
        iˇˇˇˇ(   Rk   RG   R?   i   i   t   SOR
   t   _d(
   t   distutils.sysconfigRk   R_   RX   RY   R`   Rñ   R   Ra   Rb   (   R2   R°   Rk   RΩ   t   so_ext(    (    s1   /usr/lib/python2.7/distutils/command/build_ext.pyRÿ   ö  s    )c         C   sC   d | j  j d É d } | | j k r< | j j | É n  | j S(   s  Return the list of symbols that a shared extension has to
        export.  This either uses 'ext.export_symbols' or, if it's not
        provided, "init" + module_name.  Only relevant on Windows, where
        the .pyd file (DLL) must export the module "init" function.
        t   initRG   iˇˇˇˇ(   R`   RX   R∞   R[   (   R2   R†   t   initfunc_name(    (    s1   /usr/lib/python2.7/distutils/command/build_ext.pyRº   ™  s    c         C   sa  t  j d k rá d d l m } t |  j | É s} d } |  j rM | d } n  | t  j d ?t  j d ?d @f } | j | g S| j Sn÷t  j d	 k rÃ d } | t  j d ?t  j d ?d @f } | j | g St  j d
  d k rd } | t  j d ?t  j d ?d @f } | j | g St  j d
  d k rÀd d l	 m
 } d } | t  j d ?t  j d ?d @f } g  } xM | j d É j É  D]6 } | j d É r•| j | d É q|| j | É q|W| j | d g | St  j d k r·| j St  j d  d k r˚| j Sd d l	 m
 } t rV| j d É rVd } | t  j d ?t  j d ?d @f } | j | g S| j Sd S(   s‹   Return the list of libraries to link against when building a
        shared extension.  On most platforms, this is just 'ext.libraries';
        on Windows and OS/2, we add the Python library (eg. python20.dll).
        R;   iˇˇˇˇ(   t   MSVCCompilers
   python%d%dR·   i   i   iˇ   t   os2emxi   RA   s   python%d.%dRB   (   R4   t   SHLIBSs   -li   t   mt   darwini   t   aixRH   N(   Rc   Rf   t   distutils.msvccompilerRÊ   RV   R.   R   t
   hexversionR*   RP   R4   Rk   RX   Rh   R[   Rj   (   R2   R†   RÊ   t   templatet	   pythonlibR4   t   extraRD   (    (    s1   /usr/lib/python2.7/distutils/command/build_ext.pyRª   µ  sT    
	
(   s
   build-lib=R   s(   directory for compiled extension modules(   s   build-temp=R   s1   directory for temporary files (build by-products)(   s   define=R   s   C preprocessor macros to define(   s   undef=R   s!   C preprocessor macros to undefine(   s
   libraries=R   s!   external C libraries to link with(   s   rpath=R   s7   directories to search for shared C libraries at runtime(   s   link-objects=R   s2   extra explicit link objects to include in the link(   R   R   s'   compile/link with debugging information(   R   R   s2   forcibly build everything (ignore file timestamps)(   s	   compiler=R   s   specify the compiler typeN(   s   swig-cppNs)   make SWIG create C++ files (default is C)(   s
   swig-opts=Ns!   list of SWIG command line options(   s   swig=Ns   path to the SWIG executable(   R    Ns#   add user include, library and rpath(   t   __name__t
   __module__t   descriptionRY   RZ   t   sep_byR   R!   t   user_optionst   boolean_optionsR   t   help_optionsR3   Rw   Rã   R•   Rß   R™   Rà   R´   Rµ   R¬   R®   R◊   Rÿ   Rº   Rª   (    (    (    s1   /usr/lib/python2.7/distutils/command/build_ext.pyR   %   st     

   
         			ì	@	N	
			S	:	!	 				(!   t   __doc__t   __revision__Rc   RY   R_   t   ret   typest   siteR   R   t   distutils.coreR   t   distutils.errorsR‚   R   R   t   distutils.dep_utilR   t   distutils.extensionR   t   distutils.utilR   RP   R	   R`   RÏ   R   t   intRe   R∂   Rò   R   R   (    (    (    s1   /usr/lib/python2.7/distutils/command/build_ext.pyt   <module>   s$   0

		                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Û
”´[c           @   sî   d  Z  d Z d d l Z d d l Z d d l m Z d d l m Z d d l m Z m	 Z	 d d l
 m Z d d l m Z d	 e f d
 Ñ  É  YZ d S(   sH   distutils.command.build_py

Implements the Distutils 'build_py' command.s   $Id$iˇˇˇˇN(   t   glob(   t   Command(   t   DistutilsOptionErrort   DistutilsFileError(   t   convert_path(   t   logt   build_pyc           B   sÍ   e  Z d  Z d# d$ d& d' d( g Z d d g Z i d d 6Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d d Ñ Z d Ñ  Z d  Ñ  Z d! Ñ  Z d" Ñ  Z RS()   s5   "build" pure Python modules (copy to build directory)s
   build-lib=t   ds   directory to "build" (copy) tot   compilet   cs   compile .py to .pycs
   no-compiles!   don't compile .py files [default]s	   optimize=t   Osl   also compile with optimization: -O1 for "python -O", -O2 for "python -OO", and -O0 to disable [default: -O0]t   forcet   fs2   forcibly build everything (ignore file timestamps)c         C   sL   d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d |  _ d |  _ d  |  _ d  S(   Ni    (	   t   Nonet	   build_libt
   py_modulest   packaget   package_datat   package_dirR   t   optimizeR   (   t   self(    (    s0   /usr/lib/python2.7/distutils/command/build_py.pyt   initialize_options!   s    							c         C   s  |  j  d d d É |  j j |  _ |  j j |  _ |  j j |  _ i  |  _ |  j j ré x6 |  j j j É  D] \ } } t | É |  j | <qh Wn  |  j É  |  _	 t
 |  j t É sy; t |  j É |  _ d |  j k oﬁ d k n sÈ t Ç Wqt t f k
 rt d É Ç qXn  d  S(	   Nt   buildR   R   i    i   s   optimize must be 0, 1, or 2(   R   R   (   R   R   (   t   set_undefined_optionst   distributiont   packagesR   R   R   t   itemsR   t   get_data_filest
   data_filest
   isinstanceR   t   intt   AssertionErrort
   ValueErrorR   (   R   t   namet   path(    (    s0   /usr/lib/python2.7/distutils/command/build_py.pyt   finalize_options+   s"    		)c         C   sS   |  j  r |  j É  n  |  j r6 |  j É  |  j É  n  |  j |  j d d É É d  S(   Nt   include_bytecodei    (   R   t   build_modulesR   t   build_packagest   build_package_datat   byte_compilet   get_outputs(   R   (    (    s0   /usr/lib/python2.7/distutils/command/build_py.pyt   runD   s    		
c         C   s¿   g  } |  j  s | Sx¶ |  j  D]õ } |  j | É } t j j |  j g | j d É å  } d } | rv t | É d } n  g  |  j | | É D] } | | ^ qâ } | j	 | | | | f É q W| S(   s?   Generate list of '(package,src_dir,build_dir,filenames)' tuplest   .i    i   (
   R   t   get_package_dirt   osR"   t   joinR   t   splitt   lent   find_data_filest   append(   R   t   dataR   t   src_dirt	   build_dirt   plent   filet	   filenames(    (    s0   /usr/lib/python2.7/distutils/command/build_py.pyR   b   s    	%)c         C   s¢   |  j  j d g  É |  j  j | g  É } g  } xm | D]e } t t j j | t | É É É } | j g  | D]* } | | k ri t j j | É ri | ^ qi É q5 W| S(   s6   Return filenames for package's data files in 'src_dir't    (	   R   t   getR    R-   R"   R.   R   t   extendt   isfile(   R   R   R4   t   globst   filest   patternt   filelistt   fn(    (    s0   /usr/lib/python2.7/distutils/command/build_py.pyR1   z   s    !#c         C   sà   xÅ |  j  D]v \ } } } } xa | D]Y } t j j | | É } |  j t j j | É É |  j t j j | | É | d t Éq# Wq
 Wd S(   s$   Copy data files into build directoryt   preserve_modeN(   R   R-   R"   R.   t   mkpatht   dirnamet	   copy_filet   False(   R   R   R4   R5   R8   t   filenamet   target(    (    s0   /usr/lib/python2.7/distutils/command/build_py.pyR'   á   s    c         C   s   | j  d É } |  j s5 | r. t j j | å  Sd Sn« g  } xæ | r∞ y |  j d j | É } Wn, t k
 rå | j d | d É | d =q> X| j d | É t j j | å  Sq> W|  j j d É } | d k	 r‚ | j d | É n  | r¯ t j j | å  Sd Sd S(   sΩ   Return the directory, relative to the top of the source
           distribution, where package 'package' should be found
           (at least according to the 'package_dir' option, if any).R+   R9   i    iˇˇˇˇN(	   R/   R   R-   R"   R.   t   KeyErrort   insertR:   R   (   R   R   R"   t   tailt   pdir(    (    s0   /usr/lib/python2.7/distutils/command/build_py.pyR,   ê   s(    			c         C   s•   | d k rY t  j j | É s1 t d | É Ç n  t  j j | É sY t d | É Ç qY n  | r° t  j j | d É } t  j j | É rä | St j d d | É n  d  S(   NR9   s%   package directory '%s' does not exists>   supposed package directory '%s' exists, but is not a directorys   __init__.pys!   package init file '%s' not found s   (or not a regular file)(
   R-   R"   t   existsR   t   isdirR.   R<   R   t   warnR   (   R   R   R   t   init_py(    (    s0   /usr/lib/python2.7/distutils/command/build_py.pyt   check_package∏   s    	c         C   s1   t  j j | É s) t j d | | É t St Sd  S(   Ns!   file %s (for module %s) not found(   R-   R"   R<   R   RO   RF   t   True(   R   t   modulet   module_file(    (    s0   /usr/lib/python2.7/distutils/command/build_py.pyt   check_module”   s    c   	      C   s»   |  j  | | É t t j j | d É É } g  } t j j |  j j É } xx | D]p } t j j | É } | | k rØ t j j t j j	 | É É d } | j
 | | | f É qP |  j d | É qP W| S(   Ns   *.pyi    s   excluding %s(   RQ   R    R-   R"   R.   t   abspathR   t   script_namet   splitextt   basenameR2   t   debug_print(	   R   R   R   t   module_filest   modulest   setup_scriptR   t   abs_fRS   (    (    s0   /usr/lib/python2.7/distutils/command/build_py.pyt   find_package_modules⁄   s    "c         C   s!  i  } g  } x|  j  D]} | j d É } d j | d d !É } | d } y | | \ } } Wn& t k
 rá |  j | É } d } n X| s“ |  j | | É }	 | d f | | <|	 r“ | j | d |	 f É q“ n  t j j | | d É }
 |  j	 | |
 É sq n  | j | | |
 f É q W| S(   s»  Finds individually-specified Python modules, ie. those listed by
        module name in 'self.py_modules'.  Returns a list of tuples (package,
        module_base, filename): 'package' is a tuple of the path through
        package-space to the module; 'module_base' is the bare (no
        packages, no dots) module name, and 'filename' is the path to the
        ".py" file (relative to the distribution root) that implements the
        module.
        R+   i    iˇˇˇˇi   t   __init__s   .py(
   R   R/   R.   RI   R,   RQ   R2   R-   R"   RU   (   R   R   R\   RS   R"   R   t   module_baseR   t   checkedRP   RT   (    (    s0   /usr/lib/python2.7/distutils/command/build_py.pyt   find_modulesÈ   s*    

c         C   sw   g  } |  j  r% | j |  j É  É n  |  j rs xB |  j D]4 } |  j | É } |  j | | É } | j | É q8 Wn  | S(   s4  Compute the list of all modules that will be built, whether
        they are specified one-module-at-a-time ('self.py_modules') or
        by whole packages ('self.packages').  Return a list of tuples
        (package, module, module_file), just like 'find_modules()' and
        'find_package_modules()' do.(   R   R;   Rc   R   R,   R_   (   R   R\   R   R   t   m(    (    s0   /usr/lib/python2.7/distutils/command/build_py.pyt   find_all_modules  s    		c         C   s!   g  |  j  É  D] } | d ^ q S(   Niˇˇˇˇ(   Re   (   R   RS   (    (    s0   /usr/lib/python2.7/distutils/command/build_py.pyt   get_source_files-  s    c         C   s.   | g t  | É | d g } t j j | å  S(   Ns   .py(   t   listR-   R"   R.   (   R   R5   R   RS   t   outfile_path(    (    s0   /usr/lib/python2.7/distutils/command/build_py.pyt   get_module_outfile0  s    i   c         C   sı   |  j  É  } g  } xî | D]å \ } } } | j d É } |  j |  j | | É } | j | É | r |  j r | j | d É n  |  j d k r• | j | d É q• q q W| g  |  j D]4 \ } } }	 }
 |
 D] } t j	 j
 |	 | É ^ qÃ q∂ 7} | S(   NR+   R	   i    t   o(   Re   R/   Ri   R   R2   R   R   R   R-   R"   R.   (   R   R$   R\   t   outputsR   RS   RT   RG   R4   R5   R8   (    (    s0   /usr/lib/python2.7/distutils/command/build_py.pyR)   4  s     	)c         C   sí   t  | t É r! | j d É } n$ t  | t t f É sE t d É Ç n  |  j |  j | | É } t j	 j
 | É } |  j | É |  j | | d d ÉS(   NR+   s:   'package' must be a string (dot-separated), list, or tupleRB   i    (   R   t   strR/   Rg   t   tuplet	   TypeErrorRi   R   R-   R"   RD   RC   RE   (   R   RS   RT   R   t   outfilet   dir(    (    s0   /usr/lib/python2.7/distutils/command/build_py.pyt   build_moduleI  s    c         C   s=   |  j  É  } x* | D]" \ } } } |  j | | | É q Wd  S(   N(   Rc   Rq   (   R   R\   R   RS   RT   (    (    s0   /usr/lib/python2.7/distutils/command/build_py.pyR%   X  s    c         C   sx   xq |  j  D]f } |  j | É } |  j | | É } x< | D]4 \ } } } | | k sY t Ç |  j | | | É q8 Wq
 Wd  S(   N(   R   R,   R_   R   Rq   (   R   R   R   R\   t   package_RS   RT   (    (    s0   /usr/lib/python2.7/distutils/command/build_py.pyR&   b  s    c      
   C   sÀ   t  j r |  j d É d  Sd d l m } |  j } | d t j k rV | t j } n  |  j rä | | d d d |  j	 d | d |  j
 Én  |  j d k r« | | d |  j d |  j	 d | d |  j
 Én  d  S(	   Ns%   byte-compiling is disabled, skipping.iˇˇˇˇ(   R(   R   i    R   t   prefixt   dry_run(   t   syst   dont_write_bytecodeRO   t   distutils.utilR(   R   R-   t   sepR   R   Rt   R   (   R   R>   R(   Rs   (    (    s0   /usr/lib/python2.7/distutils/command/build_py.pyR(   w  s    			(   s
   build-lib=R   s   directory to "build" (copy) to(   R   R	   s   compile .py to .pycN(   s
   no-compileNs!   don't compile .py files [default](   s	   optimize=R
   sl   also compile with optimization: -O1 for "python -O", -O2 for "python -OO", and -O0 to disable [default: -O0](   R   R   s2   forcibly build everything (ignore file timestamps)(   t   __name__t
   __module__t   descriptionR   t   user_optionst   boolean_optionst   negative_optR   R#   R*   R   R1   R'   R,   RQ   RU   R_   Rc   Re   Rf   Ri   R)   Rq   R%   R&   R(   (    (    (    s0   /usr/lib/python2.7/distutils/command/build_py.pyR      s8    		
							(				4					
	(   t   __doc__t   __revision__R-   Ru   R    t   distutils.coreR   t   distutils.errorsR   R   Rw   R   t	   distutilsR   R   (    (    (    s0   /usr/lib/python2.7/distutils/command/build_py.pyt   <module>   s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        """distutils.command.build_scripts

Implements the Distutils 'build_scripts' command."""

__revision__ = "$Id$"

import os, re
from stat import ST_MODE
from distutils.core import Command
from distutils.dep_util import newer
from distutils.util import convert_path
from distutils import log

# check if Python is called on the first line with this expression
first_line_re = re.compile('^#!.*python[0-9.]*([ \t].*)?$')

class build_scripts (Command):

    description = "\"build\" scripts (copy and fixup #! line)"

    user_options = [
        ('build-dir=', 'd', "directory to \"build\" (copy) to"),
        ('force', 'f', "forcibly build everything (ignore file timestamps"),
        ('executable=', 'e', "specify final destination interpreter path"),
        ]

    boolean_options = ['force']


    def initialize_options (self):
        self.build_dir = None
        self.scripts = None
        self.force = None
        self.executable = None
        self.outfiles = None

    def finalize_options (self):
        self.set_undefined_options('build',
                                   ('build_scripts', 'build_dir'),
                                   ('force', 'force'),
                                   ('executable', 'executable'))
        self.scripts = self.distribution.scripts

    def get_source_files(self):
        return self.scripts

    def run (self):
        if not self.scripts:
            return
        self.copy_scripts()


    def copy_scripts (self):
        """Copy each script listed in 'self.scripts'; if it's marked as a
        Python script in the Unix way (first line matches 'first_line_re',
        ie. starts with "\#!" and contains "python"), then adjust the first
        line to refer to the current Python interpreter as we copy.
        """
        _sysconfig = __import__('sysconfig')
        self.mkpath(self.build_dir)
        outfiles = []
        for script in self.scripts:
            adjust = 0
            script = convert_path(script)
            outfile = os.path.join(self.build_dir, os.path.basename(script))
            outfiles.append(outfile)

            if not self.force and not newer(script, outfile):
                log.debug("not copying %s (up-to-date)", script)
                continue

            # Always open the file, but ignore failures in dry-run mode --
            # that way, we'll get accurate feedback if we can read the
            # script.
            try:
                f = open(script, "r")
            except IOError:
                if not self.dry_run:
                    raise
                f = None
            else:
                first_line = f.readline()
                if not first_line:
                    self.warn("%s is an empty file (skipping)" % script)
                    continue

                match = first_line_re.match(first_line)
                if match:
                    adjust = 1
                    post_interp = match.group(1) or ''

            if adjust:
                log.info("copying and adjusting %s -> %s", script,
                         self.build_dir)
                if not self.dry_run:
                    outf = open(outfile, "w")
                    if not _sysconfig.is_python_build():
                        outf.write("#!%s%s\n" %
                                   (self.executable,
                                    post_interp))
                    else:
                        outf.write("#!%s%s\n" %
                                   (os.path.join(
                            _sysconfig.get_config_var("BINDIR"),
                           "python%s%s" % (_sysconfig.get_config_var("VERSION"),
                                           _sysconfig.get_config_var("EXE"))),
                                    post_interp))
                    outf.writelines(f.readlines())
                    outf.close()
                if f:
                    f.close()
            else:
                if f:
                    f.close()
                self.copy_file(script, outfile)

        if os.name == 'posix':
            for file in outfiles:
                if self.dry_run:
                    log.info("changing mode of %s", file)
                else:
                    oldmode = os.stat(file)[ST_MODE] & 07777
                    newmode = (oldmode | 0555) & 07777
                    if newmode != oldmode:
                        log.info("changing mode of %s from %o to %o",
                                 file, oldmode, newmode)
                        os.chmod(file, newmode)

    # copy_scripts ()

# class build_scripts
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          Û
”´[c           @   sù   d  Z  d Z d d l Z d d l Z d d l m Z d d l m Z d d l m	 Z	 d d l
 m Z d d l m Z e j d	 É Z d
 e f d Ñ  É  YZ d S(   sR   distutils.command.build_scripts

Implements the Distutils 'build_scripts' command.s   $Id$iˇˇˇˇN(   t   ST_MODE(   t   Command(   t   newer(   t   convert_path(   t   logs   ^#!.*python[0-9.]*([ 	].*)?$t   build_scriptsc           B   sS   e  Z d  Z d d d g Z d g Z d
 Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 RS(   s(   "build" scripts (copy and fixup #! line)s
   build-dir=t   ds   directory to "build" (copy) tot   forcet   fs1   forcibly build everything (ignore file timestampss   executable=t   es*   specify final destination interpreter pathc         C   s1   d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  S(   N(   t   Nonet	   build_dirt   scriptsR   t
   executablet   outfiles(   t   self(    (    s5   /usr/lib/python2.7/distutils/command/build_scripts.pyt   initialize_options   s
    				c         C   s)   |  j  d d d d É |  j j |  _ d  S(	   Nt   buildR   R   R   R   (   R   R   (   R   R   (   R   R   (   t   set_undefined_optionst   distributionR   (   R   (    (    s5   /usr/lib/python2.7/distutils/command/build_scripts.pyt   finalize_options%   s
    	c         C   s   |  j  S(   N(   R   (   R   (    (    s5   /usr/lib/python2.7/distutils/command/build_scripts.pyt   get_source_files,   s    c         C   s   |  j  s d  S|  j É  d  S(   N(   R   t   copy_scripts(   R   (    (    s5   /usr/lib/python2.7/distutils/command/build_scripts.pyt   run/   s    	c      	   C   sﬂ  t  d É } |  j |  j É g  } x|  j D]} d } t | É } t j j |  j t j j | É É } | j	 | É |  j
 r• t | | É r• t j d | É q, n  y t | d É } Wn& t k
 r‡ |  j s◊ Ç  n  d } n] X| j É  } | s
|  j d | É q, n  t j | É } | r=d } | j d É p7d }	 n  | rt j d | |  j É |  j st | d	 É }
 | j É  sö|
 j d
 |  j |	 f É nK |
 j d
 t j j | j d É d | j d É | j d É f É |	 f É |
 j | j É  É |
 j É  n  | r>| j É  q>q, | r.| j É  n  |  j | | É q, Wt j  d k r€xá | D]| } |  j rzt j d | É qXt j! | É t" d @} | d Bd @} | | k rXt j d | | | É t j# | | É qXqXWn  d S(   s"  Copy each script listed in 'self.scripts'; if it's marked as a
        Python script in the Unix way (first line matches 'first_line_re',
        ie. starts with "\#!" and contains "python"), then adjust the first
        line to refer to the current Python interpreter as we copy.
        t	   sysconfigi    s   not copying %s (up-to-date)t   rs   %s is an empty file (skipping)i   t    s   copying and adjusting %s -> %st   ws   #!%s%s
t   BINDIRs
   python%s%st   VERSIONt   EXEt   posixs   changing mode of %siˇ  im  s!   changing mode of %s from %o to %oN($   t
   __import__t   mkpathR   R   R   t   ost   patht   joint   basenamet   appendR   R   R   t   debugt   opent   IOErrort   dry_runR
   t   readlinet   warnt   first_line_ret   matcht   groupt   infot   is_python_buildt   writeR   t   get_config_vart
   writelinest	   readlinest   closet	   copy_filet   namet   statR    t   chmod(   R   t
   _sysconfigR   t   scriptt   adjustt   outfileR   t
   first_lineR.   t   post_interpt   outft   filet   oldmodet   newmode(    (    s5   /usr/lib/python2.7/distutils/command/build_scripts.pyR   5   sr    $	

						(   s
   build-dir=R   s   directory to "build" (copy) to(   R   R   s1   forcibly build everything (ignore file timestamps(   s   executable=R	   s*   specify final destination interpreter path(
   t   __name__t
   __module__t   descriptiont   user_optionst   boolean_optionsR   R   R   R   R   (    (    (    s5   /usr/lib/python2.7/distutils/command/build_scripts.pyR      s   						(   t   __doc__t   __revision__R"   t   reR9   R    t   distutils.coreR   t   distutils.dep_utilR   t   distutils.utilR   t	   distutilsR   t   compileR-   R   (    (    (    s5   /usr/lib/python2.7/distutils/command/build_scripts.pyt   <module>   s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    """distutils.command.check

Implements the Distutils 'check' command.
"""
__revision__ = "$Id$"

from distutils.core import Command
from distutils.dist import PKG_INFO_ENCODING
from distutils.errors import DistutilsSetupError

try:
    # docutils is installed
    from docutils.utils import Reporter
    from docutils.parsers.rst import Parser
    from docutils import frontend
    from docutils import nodes
    from StringIO import StringIO

    class SilentReporter(Reporter):

        def __init__(self, source, report_level, halt_level, stream=None,
                     debug=0, encoding='ascii', error_handler='replace'):
            self.messages = []
            Reporter.__init__(self, source, report_level, halt_level, stream,
                              debug, encoding, error_handler)

        def system_message(self, level, message, *children, **kwargs):
            self.messages.append((level, message, children, kwargs))
            return nodes.system_message(message, level=level,
                                        type=self.levels[level],
                                        *children, **kwargs)

    HAS_DOCUTILS = True
except ImportError:
    # docutils is not installed
    HAS_DOCUTILS = False

class check(Command):
    """This command checks the meta-data of the package.
    """
    description = ("perform some checks on the package")
    user_options = [('metadata', 'm', 'Verify meta-data'),
                    ('restructuredtext', 'r',
                     ('Checks if long string meta-data syntax '
                      'are reStructuredText-compliant')),
                    ('strict', 's',
                     'Will exit with an error if a check fails')]

    boolean_options = ['metadata', 'restructuredtext', 'strict']

    def initialize_options(self):
        """Sets default values for options."""
        self.restructuredtext = 0
        self.metadata = 1
        self.strict = 0
        self._warnings = 0

    def finalize_options(self):
        pass

    def warn(self, msg):
        """Counts the number of warnings that occurs."""
        self._warnings += 1
        return Command.warn(self, msg)

    def run(self):
        """Runs the command."""
        # perform the various tests
        if self.metadata:
            self.check_metadata()
        if self.restructuredtext:
            if HAS_DOCUTILS:
                self.check_restructuredtext()
            elif self.strict:
                raise DistutilsSetupError('The docutils package is needed.')

        # let's raise an error in strict mode, if we have at least
        # one warning
        if self.strict and self._warnings > 0:
            raise DistutilsSetupError('Please correct your package.')

    def check_metadata(self):
        """Ensures that all required elements of meta-data are supplied.

        name, version, URL, (author and author_email) or
        (maintainer and maintainer_email)).

        Warns if any are missing.
        """
        metadata = self.distribution.metadata

        missing = []
        for attr in ('name', 'version', 'url'):
            if not (hasattr(metadata, attr) and getattr(metadata, attr)):
                missing.append(attr)

        if missing:
            self.warn("missing required meta-data: %s"  % ', '.join(missing))
        if metadata.author:
            if not metadata.author_email:
                self.warn("missing meta-data: if 'author' supplied, " +
                          "'author_email' must be supplied too")
        elif metadata.maintainer:
            if not metadata.maintainer_email:
                self.warn("missing meta-data: if 'maintainer' supplied, " +
                          "'maintainer_email' must be supplied too")
        else:
            self.warn("missing meta-data: either (author and author_email) " +
                      "or (maintainer and maintainer_email) " +
                      "must be supplied")

    def check_restructuredtext(self):
        """Checks if the long string fields are reST-compliant."""
        data = self.distribution.get_long_description()
        if not isinstance(data, unicode):
            data = data.decode(PKG_INFO_ENCODING)
        for warning in self._check_rst_data(data):
            line = warning[-1].get('line')
            if line is None:
                warning = warning[1]
            else:
                warning = '%s (line %s)' % (warning[1], line)
            self.warn(warning)

    def _check_rst_data(self, data):
        """Returns warnings when the provided data doesn't compile."""
        source_path = StringIO()
        parser = Parser()
        settings = frontend.OptionParser(components=(Parser,)).get_default_values()
        settings.tab_width = 4
        settings.pep_references = None
        settings.rfc_references = None
        reporter = SilentReporter(source_path,
                          settings.report_level,
                          settings.halt_level,
                          stream=settings.warning_stream,
                          debug=settings.debug,
                          encoding=settings.error_encoding,
                          error_handler=settings.error_encoding_error_handler)

        document = nodes.document(settings, reporter, source=source_path)
        document.note_source(source_path, -1)
        try:
            parser.parse(data, document)
        except AttributeError as e:
            reporter.messages.append(
                (-1, 'Could not finish the parsing: %s.' % e, '', {}))

        return reporter.messages
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               Û
”´[c           @   s‡   d  Z  d Z d d l m Z d d l m Z d d l m Z yp d d l m	 Z	 d d l
 m Z d d l m Z d d	 l m Z d d
 l m Z d e	 f d Ñ  É  YZ e Z Wn e k
 r≈ e Z n Xd e f d Ñ  É  YZ d S(   sC   distutils.command.check

Implements the Distutils 'check' command.
s   $Id$iˇˇˇˇ(   t   Command(   t   PKG_INFO_ENCODING(   t   DistutilsSetupError(   t   Reporter(   t   Parser(   t   frontend(   t   nodes(   t   StringIOt   SilentReporterc           B   s&   e  Z d d  d d d Ñ Z d Ñ  Z RS(   i    t   asciit   replacec      	   C   s/   g  |  _  t j |  | | | | | | | É d  S(   N(   t   messagesR   t   __init__(   t   selft   sourcet   report_levelt
   halt_levelt   streamt   debugt   encodingt   error_handler(    (    s-   /usr/lib/python2.7/distutils/command/check.pyR      s    	c         O   sB   |  j  j | | | | f É t j | d | d |  j | | | éS(   Nt   levelt   type(   R   t   appendR   t   system_messaget   levels(   R   R   t   messaget   childrent   kwargs(    (    s-   /usr/lib/python2.7/distutils/command/check.pyR      s    
N(   t   __name__t
   __module__t   NoneR   R   (    (    (    s-   /usr/lib/python2.7/distutils/command/check.pyR      s   t   checkc           B   sq   e  Z d  Z d Z d d d g Z d d d g Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d Ñ  Z d Ñ  Z RS(   s6   This command checks the meta-data of the package.
    s"   perform some checks on the packaget   metadatat   ms   Verify meta-datat   restructuredtextt   rsE   Checks if long string meta-data syntax are reStructuredText-compliantt   strictt   ss(   Will exit with an error if a check failsc         C   s(   d |  _  d |  _ d |  _ d |  _ d S(   s    Sets default values for options.i    i   N(   R#   R!   R%   t	   _warnings(   R   (    (    s-   /usr/lib/python2.7/distutils/command/check.pyt   initialize_options3   s    			c         C   s   d  S(   N(    (   R   (    (    s-   /usr/lib/python2.7/distutils/command/check.pyt   finalize_options:   s    c         C   s   |  j  d 7_  t j |  | É S(   s*   Counts the number of warnings that occurs.i   (   R'   R    t   warn(   R   t   msg(    (    s-   /usr/lib/python2.7/distutils/command/check.pyR*   =   s    c         C   sx   |  j  r |  j É  n  |  j rM t r2 |  j É  qM |  j rM t d É Ç qM n  |  j rt |  j d k rt t d É Ç n  d S(   s   Runs the command.s   The docutils package is needed.i    s   Please correct your package.N(   R!   t   check_metadataR#   t   HAS_DOCUTILSt   check_restructuredtextR%   R   R'   (   R   (    (    s-   /usr/lib/python2.7/distutils/command/check.pyt   runB   s    			c         C   sﬂ   |  j  j } g  } x< d D]4 } t | | É o: t | | É s | j | É q q W| rt |  j d d j | É É n  | j rù | j s€ |  j d d É q€ n> | j	 r∆ | j
 s€ |  j d d	 É q€ n |  j d
 d d É d S(   sœ   Ensures that all required elements of meta-data are supplied.

        name, version, URL, (author and author_email) or
        (maintainer and maintainer_email)).

        Warns if any are missing.
        t   namet   versiont   urls   missing required meta-data: %ss   , s)   missing meta-data: if 'author' supplied, s#   'author_email' must be supplied toos-   missing meta-data: if 'maintainer' supplied, s'   'maintainer_email' must be supplied toos4   missing meta-data: either (author and author_email) s%   or (maintainer and maintainer_email) s   must be suppliedN(   R0   R1   R2   (   t   distributionR!   t   hasattrt   getattrR   R*   t   joint   authort   author_emailt
   maintainert   maintainer_email(   R   R!   t   missingt   attr(    (    s-   /usr/lib/python2.7/distutils/command/check.pyR,   R   s$    						c         C   sõ   |  j  j É  } t | t É s0 | j t É } n  xd |  j | É D]S } | d j d É } | d k rr | d } n d | d | f } |  j	 | É q@ Wd S(   s4   Checks if the long string fields are reST-compliant.iˇˇˇˇt   linei   s   %s (line %s)N(
   R3   t   get_long_descriptiont
   isinstancet   unicodet   decodeR   t   _check_rst_datat   getR   R*   (   R   t   datat   warningR=   (    (    s-   /usr/lib/python2.7/distutils/command/check.pyR.   p   s    c         C   s˝   t  É  } t É  } t j d t f É j É  } d | _ d | _ d | _ t	 | | j
 | j d | j d | j d | j d | j É} t j | | d | É} | j | d É y | j | | É Wn3 t k
 rı } | j j d d	 | d
 i  f É n X| j S(   s8   Returns warnings when the provided data doesn't compile.t
   componentsi   R   R   R   R   R   iˇˇˇˇs!   Could not finish the parsing: %s.t    N(   R   R   R   t   OptionParsert   get_default_valuest	   tab_widthR   t   pep_referencest   rfc_referencesR   R   R   t   warning_streamR   t   error_encodingt   error_encoding_error_handlerR   t   documentt   note_sourcet   parset   AttributeErrorR   R   (   R   RD   t   source_patht   parsert   settingst   reporterRP   t   e(    (    s-   /usr/lib/python2.7/distutils/command/check.pyRB   }   s*    										(   R!   R"   s   Verify meta-data(   R#   R$   sE   Checks if long string meta-data syntax are reStructuredText-compliant(   R%   R&   s(   Will exit with an error if a check fails(   R   R   t   __doc__t   descriptiont   user_optionst   boolean_optionsR(   R)   R*   R/   R,   R.   RB   (    (    (    s-   /usr/lib/python2.7/distutils/command/check.pyR    &   s     							N(   RY   t   __revision__t   distutils.coreR    t   distutils.distR   t   distutils.errorsR   t   docutils.utilsR   t   docutils.parsers.rstR   t   docutilsR   R   R   R   t   TrueR-   t   ImportErrort   FalseR    (    (    (    s-   /usr/lib/python2.7/distutils/command/check.pyt   <module>   s   

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        Û
”´[c           @   sb   d  Z  d Z d d l Z d d l m Z d d l m Z d d l m Z d e f d Ñ  É  YZ	 d S(	   sB   distutils.command.clean

Implements the Distutils 'clean' command.s   $Id$iˇˇˇˇN(   t   Command(   t   remove_tree(   t   logt   cleanc           B   sJ   e  Z d  Z d d d d d d g Z d g Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   s-   clean up temporary files from 'build' commands   build-base=t   bs2   base build directory (default: 'build.build-base')s
   build-lib=s<   build directory for all modules (default: 'build.build-lib')s   build-temp=t   ts7   temporary build directory (default: 'build.build-temp')s   build-scripts=s<   build directory for scripts (default: 'build.build-scripts')s   bdist-base=s+   temporary directory for built distributionst   allt   as7   remove all build output, not just temporary by-productsc         C   s:   d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  S(   N(   t   Nonet
   build_baset	   build_libt
   build_tempt   build_scriptst
   bdist_baseR   (   t   self(    (    s-   /usr/lib/python2.7/distutils/command/clean.pyt   initialize_options"   s    					c         C   s-   |  j  d d d	 d
 d É |  j  d d É d  S(   Nt   buildR	   R
   R   R   t   bdistR   (   R	   R	   (   R
   R
   (   R   R   (   R   R   (   R   R   (   t   set_undefined_options(   R   (    (    s-   /usr/lib/python2.7/distutils/command/clean.pyt   finalize_options*   s    		c         C   sÛ   t  j j |  j É r. t |  j d |  j Én t j d |  j É |  j r® x[ |  j	 |  j
 |  j f D]> } t  j j | É rë t | d |  j Éqc t j d | É qc Wn  |  j sÔ y' t  j |  j É t j d |  j É WqÔ t k
 rÎ qÔ Xn  d  S(   Nt   dry_runs%   '%s' does not exist -- can't clean its   removing '%s'(   t   ost   patht   existsR   R   R   R   t   debugR   R
   R   R   t   warnt   rmdirR	   t   infot   OSError(   R   t	   directory(    (    s-   /usr/lib/python2.7/distutils/command/clean.pyt   run3   s$    	
				(   s   build-base=R   s2   base build directory (default: 'build.build-base')N(   s
   build-lib=Ns<   build directory for all modules (default: 'build.build-lib')(   s   build-temp=R   s7   temporary build directory (default: 'build.build-temp')(   s   build-scripts=Ns<   build directory for scripts (default: 'build.build-scripts')(   s   bdist-base=Ns+   temporary directory for built distributions(   R   R   s7   remove all build output, not just temporary by-products(	   t   __name__t
   __module__t   descriptionR   t   user_optionst   boolean_optionsR   R   R   (    (    (    s-   /usr/lib/python2.7/distutils/command/clean.pyR      s"         					(
   t   __doc__t   __revision__R   t   distutils.coreR    t   distutils.dir_utilR   t	   distutilsR   R   (    (    (    s-   /usr/lib/python2.7/distutils/command/clean.pyt   <module>   s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                """distutils.command.x

Implements the Distutils 'x' command.
"""

# created 2000/mm/dd, John Doe

__revision__ = "$Id$"

from distutils.core import Command


class x (Command):

    # Brief (40-50 characters) description of the command
    description = ""

    # List of option tuples: long name, short name (None if no short
    # name), and help string.
    user_options = [('', '',
                     ""),
                   ]


    def initialize_options (self):
        self. = None
        self. = None
        self. = None

    # initialize_options()


    def finalize_options (self):
        if self.x is None:
            self.x = 

    # finalize_options()


    def run (self):


    # run()

# class x
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 """distutils.command.install_data

Implements the Distutils 'install_data' command, for installing
platform-independent data files."""

# contributed by Bastian Kleineidam

__revision__ = "$Id$"

import os
from distutils.core import Command
from distutils.util import change_root, convert_path

class install_data(Command):

    description = "install data files"

    user_options = [
        ('install-dir=', 'd',
         "base directory for installing data files "
         "(default: installation base dir)"),
        ('root=', None,
         "install everything relative to this alternate root directory"),
        ('force', 'f', "force installation (overwrite existing files)"),
        ]

    boolean_options = ['force']

    def initialize_options(self):
        self.install_dir = None
        self.outfiles = []
        self.root = None
        self.force = 0
        self.data_files = self.distribution.data_files
        self.warn_dir = 1

    def finalize_options(self):
        self.set_undefined_options('install',
                                   ('install_data', 'install_dir'),
                                   ('root', 'root'),
                                   ('force', 'force'),
                                  )

    def run(self):
        self.mkpath(self.install_dir)
        for f in self.data_files:
            if isinstance(f, str):
                # it's a simple file, so copy it
                f = convert_path(f)
                if self.warn_dir:
                    self.warn("setup script did not provide a directory for "
                              "'%s' -- installing right in '%s'" %
                              (f, self.install_dir))
                (out, _) = self.copy_file(f, self.install_dir)
                self.outfiles.append(out)
            else:
                # it's a tuple with path to install to and a list of files
                dir = convert_path(f[0])
                if not os.path.isabs(dir):
                    dir = os.path.join(self.install_dir, dir)
                elif self.root:
                    dir = change_root(self.root, dir)
                self.mkpath(dir)

                if f[1] == []:
                    # If there are no files listed, the user must be
                    # trying to create an empty directory, so add the
                    # directory to the list of output files.
                    self.outfiles.append(dir)
                else:
                    # Copy files, adding them to the list of output files.
                    for data in f[1]:
                        data = convert_path(data)
                        (out, _) = self.copy_file(data, dir)
                        self.outfiles.append(out)

    def get_inputs(self):
        return self.data_files or []

    def get_outputs(self):
        return self.outfiles
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   Û
”´[c           @   sX   d  Z  d Z d d l Z d d l m Z d d l m Z m Z d e f d Ñ  É  YZ d S(   sÄ   distutils.command.install_data

Implements the Distutils 'install_data' command, for installing
platform-independent data files.s   $Id$iˇˇˇˇN(   t   Command(   t   change_roott   convert_patht   install_datac           B   sS   e  Z d  Z d d d g Z d g Z d	 Ñ  Z d
 Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 RS(   s   install data filess   install-dir=t   dsI   base directory for installing data files (default: installation base dir)s   root=s<   install everything relative to this alternate root directoryt   forcet   fs-   force installation (overwrite existing files)c         C   s@   d  |  _ g  |  _ d  |  _ d |  _ |  j j |  _ d |  _ d  S(   Ni    i   (   t   Nonet   install_dirt   outfilest   rootR   t   distributiont
   data_filest   warn_dir(   t   self(    (    s4   /usr/lib/python2.7/distutils/command/install_data.pyt   initialize_options   s    				c         C   s   |  j  d d d d É d  S(	   Nt   installR   R   R
   R   (   R   R   (   R
   R
   (   R   R   (   t   set_undefined_options(   R   (    (    s4   /usr/lib/python2.7/distutils/command/install_data.pyt   finalize_options%   s    	c         C   sk  |  j  |  j É xT|  j D]I} t | t É rè t | É } |  j ra |  j d | |  j f É n  |  j | |  j É \ } } |  j	 j
 | É q t | d É } t j j | É sÃ t j j |  j | É } n |  j rÍ t |  j | É } n  |  j  | É | d g  k r|  j	 j
 | É q xF | d D]: } t | É } |  j | | É \ } } |  j	 j
 | É q%Wq Wd  S(   NsM   setup script did not provide a directory for '%s' -- installing right in '%s'i    i   (   t   mkpathR   R   t
   isinstancet   strR   R   t   warnt	   copy_fileR	   t   appendt   ost   patht   isabst   joinR
   R   (   R   R   t   outt   _t   dirt   data(    (    s4   /usr/lib/python2.7/distutils/command/install_data.pyt   run,   s*    			c         C   s   |  j  p g  S(   N(   R   (   R   (    (    s4   /usr/lib/python2.7/distutils/command/install_data.pyt
   get_inputsM   s    c         C   s   |  j  S(   N(   R	   (   R   (    (    s4   /usr/lib/python2.7/distutils/command/install_data.pyt   get_outputsP   s    (   s   install-dir=R   sI   base directory for installing data files (default: installation base dir)N(   s   root=Ns<   install everything relative to this alternate root directory(   R   R   s-   force installation (overwrite existing files)(   t   __name__t
   __module__t   descriptionR   t   user_optionst   boolean_optionsR   R   R!   R"   R#   (    (    (    s4   /usr/lib/python2.7/distutils/command/install_data.pyR      s     					!	(	   t   __doc__t   __revision__R   t   distutils.coreR    t   distutils.utilR   R   R   (    (    (    s4   /usr/lib/python2.7/distutils/command/install_data.pyt   <module>   s
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   """distutils.command.config

Implements the Distutils 'config' command, a (mostly) empty command class
that exists mainly to be sub-classed by specific module distributions and
applications.  The idea is that while every "config" command is different,
at least they're all named the same, and users always see "config" in the
list of standard commands.  Also, this is a good place to put common
configure-like tasks: "try to compile this C code", or "figure out where
this header file lives".
"""

__revision__ = "$Id$"

import os
import re

from distutils.core import Command
from distutils.errors import DistutilsExecError
from distutils.sysconfig import customize_compiler
from distutils import log

LANG_EXT = {'c': '.c', 'c++': '.cxx'}

class config(Command):

    description = "prepare to build"

    user_options = [
        ('compiler=', None,
         "specify the compiler type"),
        ('cc=', None,
         "specify the compiler executable"),
        ('include-dirs=', 'I',
         "list of directories to search for header files"),
        ('define=', 'D',
         "C preprocessor macros to define"),
        ('undef=', 'U',
         "C preprocessor macros to undefine"),
        ('libraries=', 'l',
         "external C libraries to link with"),
        ('library-dirs=', 'L',
         "directories to search for external C libraries"),

        ('noisy', None,
         "show every action (compile, link, run, ...) taken"),
        ('dump-source', None,
         "dump generated source files before attempting to compile them"),
        ]


    # The three standard command methods: since the "config" command
    # does nothing by default, these are empty.

    def initialize_options(self):
        self.compiler = None
        self.cc = None
        self.include_dirs = None
        self.libraries = None
        self.library_dirs = None

        # maximal output for now
        self.noisy = 1
        self.dump_source = 1

        # list of temporary files generated along-the-way that we have
        # to clean at some point
        self.temp_files = []

    def finalize_options(self):
        if self.include_dirs is None:
            self.include_dirs = self.distribution.include_dirs or []
        elif isinstance(self.include_dirs, str):
            self.include_dirs = self.include_dirs.split(os.pathsep)

        if self.libraries is None:
            self.libraries = []
        elif isinstance(self.libraries, str):
            self.libraries = [self.libraries]

        if self.library_dirs is None:
            self.library_dirs = []
        elif isinstance(self.library_dirs, str):
            self.library_dirs = self.library_dirs.split(os.pathsep)

    def run(self):
        pass


    # Utility methods for actual "config" commands.  The interfaces are
    # loosely based on Autoconf macros of similar names.  Sub-classes
    # may use these freely.

    def _check_compiler(self):
        """Check that 'self.compiler' really is a CCompiler object;
        if not, make it one.
        """
        # We do this late, and only on-demand, because this is an expensive
        # import.
        from distutils.ccompiler import CCompiler, new_compiler
        if not isinstance(self.compiler, CCompiler):
            self.compiler = new_compiler(compiler=self.compiler,
                                         dry_run=self.dry_run, force=1)
            customize_compiler(self.compiler)
            if self.include_dirs:
                self.compiler.set_include_dirs(self.include_dirs)
            if self.libraries:
                self.compiler.set_libraries(self.libraries)
            if self.library_dirs:
                self.compiler.set_library_dirs(self.library_dirs)


    def _gen_temp_sourcefile(self, body, headers, lang):
        filename = "_configtest" + LANG_EXT[lang]
        file = open(filename, "w")
        if headers:
            for header in headers:
                file.write("#include <%s>\n" % header)
            file.write("\n")
        file.write(body)
        if body[-1] != "\n":
            file.write("\n")
        file.close()
        return filename

    def _preprocess(self, body, headers, include_dirs, lang):
        src = self._gen_temp_sourcefile(body, headers, lang)
        out = "_configtest.i"
        self.temp_files.extend([src, out])
        self.compiler.preprocess(src, out, include_dirs=include_dirs)
        return (src, out)

    def _compile(self, body, headers, include_dirs, lang):
        src = self._gen_temp_sourcefile(body, headers, lang)
        if self.dump_source:
            dump_file(src, "compiling '%s':" % src)
        (obj,) = self.compiler.object_filenames([src])
        self.temp_files.extend([src, obj])
        self.compiler.compile([src], include_dirs=include_dirs)
        return (src, obj)

    def _link(self, body, headers, include_dirs, libraries, library_dirs,
              lang):
        (src, obj) = self._compile(body, headers, include_dirs, lang)
        prog = os.path.splitext(os.path.basename(src))[0]
        self.compiler.link_executable([obj], prog,
                                      libraries=libraries,
                                      library_dirs=library_dirs,
                                      target_lang=lang)

        if self.compiler.exe_extension is not None:
            prog = prog + self.compiler.exe_extension
        self.temp_files.append(prog)

        return (src, obj, prog)

    def _clean(self, *filenames):
        if not filenames:
            filenames = self.temp_files
            self.temp_files = []
        log.info("removing: %s", ' '.join(filenames))
        for filename in filenames:
            try:
                os.remove(filename)
            except OSError:
                pass


    # XXX these ignore the dry-run flag: what to do, what to do? even if
    # you want a dry-run build, you still need some sort of configuration
    # info.  My inclination is to make it up to the real config command to
    # consult 'dry_run', and assume a default (minimal) configuration if
    # true.  The problem with trying to do it here is that you'd have to
    # return either true or false from all the 'try' methods, neither of
    # which is correct.

    # XXX need access to the header search path and maybe default macros.

    def try_cpp(self, body=None, headers=None, include_dirs=None, lang="c"):
        """Construct a source file from 'body' (a string containing lines
        of C/C++ code) and 'headers' (a list of header files to include)
        and run it through the preprocessor.  Return true if the
        preprocessor succeeded, false if there were any errors.
        ('body' probably isn't of much use, but what the heck.)
        """
        from distutils.ccompiler import CompileError
        self._check_compiler()
        ok = 1
        try:
            self._preprocess(body, headers, include_dirs, lang)
        except CompileError:
            ok = 0

        self._clean()
        return ok

    def search_cpp(self, pattern, body=None, headers=None, include_dirs=None,
                   lang="c"):
        """Construct a source file (just like 'try_cpp()'), run it through
        the preprocessor, and return true if any line of the output matches
        'pattern'.  'pattern' should either be a compiled regex object or a
        string containing a regex.  If both 'body' and 'headers' are None,
        preprocesses an empty file -- which can be useful to determine the
        symbols the preprocessor and compiler set by default.
        """
        self._check_compiler()
        src, out = self._preprocess(body, headers, include_dirs, lang)

        if isinstance(pattern, str):
            pattern = re.compile(pattern)

        file = open(out)
        match = 0
        while 1:
            line = file.readline()
            if line == '':
                break
            if pattern.search(line):
                match = 1
                break

        file.close()
        self._clean()
        return match

    def try_compile(self, body, headers=None, include_dirs=None, lang="c"):
        """Try to compile a source file built from 'body' and 'headers'.
        Return true on success, false otherwise.
        """
        from distutils.ccompiler import CompileError
        self._check_compiler()
        try:
            self._compile(body, headers, include_dirs, lang)
            ok = 1
        except CompileError:
            ok = 0

        log.info(ok and "success!" or "failure.")
        self._clean()
        return ok

    def try_link(self, body, headers=None, include_dirs=None, libraries=None,
                 library_dirs=None, lang="c"):
        """Try to compile and link a source file, built from 'body' and
        'headers', to executable form.  Return true on success, false
        otherwise.
        """
        from distutils.ccompiler import CompileError, LinkError
        self._check_compiler()
        try:
            self._link(body, headers, include_dirs,
                       libraries, library_dirs, lang)
            ok = 1
        except (CompileError, LinkError):
            ok = 0

        log.info(ok and "success!" or "failure.")
        self._clean()
        return ok

    def try_run(self, body, headers=None, include_dirs=None, libraries=None,
                library_dirs=None, lang="c"):
        """Try to compile, link to an executable, and run a program
        built from 'body' and 'headers'.  Return true on success, false
        otherwise.
        """
        from distutils.ccompiler import CompileError, LinkError
        self._check_compiler()
        try:
            src, obj, exe = self._link(body, headers, include_dirs,
                                       libraries, library_dirs, lang)
            self.spawn([exe])
            ok = 1
        except (CompileError, LinkError, DistutilsExecError):
            ok = 0

        log.info(ok and "success!" or "failure.")
        self._clean()
        return ok


    # -- High-level methods --------------------------------------------
    # (these are the ones that are actually likely to be useful
    # when implementing a real-world config command!)

    def check_func(self, func, headers=None, include_dirs=None,
                   libraries=None, library_dirs=None, decl=0, call=0):

        """Determine if function 'func' is available by constructing a
        source file that refers to 'func', and compiles and links it.
        If everything succeeds, returns true; otherwise returns false.

        The constructed source file starts out by including the header
        files listed in 'headers'.  If 'decl' is true, it then declares
        'func' (as "int func()"); you probably shouldn't supply 'headers'
        and set 'decl' true in the same call, or you might get errors about
        a conflicting declarations for 'func'.  Finally, the constructed
        'main()' function either references 'func' or (if 'call' is true)
        calls it.  'libraries' and 'library_dirs' are used when
        linking.
        """

        self._check_compiler()
        body = []
        if decl:
            body.append("int %s ();" % func)
        body.append("int main () {")
        if call:
            body.append("  %s();" % func)
        else:
            body.append("  %s;" % func)
        body.append("}")
        body = "\n".join(body) + "\n"

        return self.try_link(body, headers, include_dirs,
                             libraries, library_dirs)

    # check_func ()

    def check_lib(self, library, library_dirs=None, headers=None,
                  include_dirs=None, other_libraries=[]):
        """Determine if 'library' is available to be linked against,
        without actually checking that any particular symbols are provided
        by it.  'headers' will be used in constructing the source file to
        be compiled, but the only effect of this is to check if all the
        header files listed are available.  Any libraries listed in
        'other_libraries' will be included in the link, in case 'library'
        has symbols that depend on other libraries.
        """
        self._check_compiler()
        return self.try_link("int main (void) { }",
                             headers, include_dirs,
                             [library]+other_libraries, library_dirs)

    def check_header(self, header, include_dirs=None, library_dirs=None,
                     lang="c"):
        """Determine if the system header file named by 'header_file'
        exists and can be found by the preprocessor; return true if so,
        false otherwise.
        """
        return self.try_cpp(body="/* No body */", headers=[header],
                            include_dirs=include_dirs)


def dump_file(filename, head=None):
    """Dumps a file content into log.info.

    If head is not None, will be dumped before the file content.
    """
    if head is None:
        log.info('%s' % filename)
    else:
        log.info(head)
    file = open(filename)
    try:
        log.info(file.read())
    finally:
        file.close()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      Û
”´[c           @   sû   d  Z  d Z d d l Z d d l Z d d l m Z d d l m Z d d l m	 Z	 d d l
 m Z i d d	 6d
 d 6Z d e f d Ñ  É  YZ e d Ñ Z d S(   sÍ  distutils.command.config

Implements the Distutils 'config' command, a (mostly) empty command class
that exists mainly to be sub-classed by specific module distributions and
applications.  The idea is that while every "config" command is different,
at least they're all named the same, and users always see "config" in the
list of standard commands.  Also, this is a good place to put common
configure-like tasks: "try to compile this C code", or "figure out where
this header file lives".
s   $Id$iˇˇˇˇN(   t   Command(   t   DistutilsExecError(   t   customize_compiler(   t   logs   .ct   cs   .cxxs   c++t   configc           B   s.  e  Z d  Z d, d- d. d/ d0 d1 d2 d3 d4 g	 Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d Ñ  Z d Ñ  Z d  Ñ  Z d+ d+ d+ d! d" Ñ Z d+ d+ d+ d! d# Ñ Z d+ d+ d! d$ Ñ Z d+ d+ d+ d+ d! d% Ñ Z d+ d+ d+ d+ d! d& Ñ Z d+ d+ d+ d+ d' d' d( Ñ Z d+ d+ d+ g  d) Ñ Z d+ d+ d! d* Ñ Z RS(5   s   prepare to builds	   compiler=s   specify the compiler types   cc=s   specify the compiler executables   include-dirs=t   Is.   list of directories to search for header filess   define=t   Ds   C preprocessor macros to defines   undef=t   Us!   C preprocessor macros to undefines
   libraries=t   ls!   external C libraries to link withs   library-dirs=t   Ls.   directories to search for external C librariest   noisys1   show every action (compile, link, run, ...) takens   dump-sources=   dump generated source files before attempting to compile themc         C   sL   d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d |  _ d |  _ g  |  _ d  S(   Ni   (	   t   Nonet   compilert   cct   include_dirst	   librariest   library_dirsR   t   dump_sourcet
   temp_files(   t   self(    (    s.   /usr/lib/python2.7/distutils/command/config.pyt   initialize_options6   s    							c         C   sﬂ   |  j  d  k r' |  j j  p g  |  _  n- t |  j  t É rT |  j  j t j É |  _  n  |  j d  k ro g  |  _ n$ t |  j t É rì |  j g |  _ n  |  j	 d  k rÆ g  |  _	 n- t |  j	 t É r€ |  j	 j t j É |  _	 n  d  S(   N(
   R   R   t   distributiont
   isinstancet   strt   splitt   ost   pathsepR   R   (   R   (    (    s.   /usr/lib/python2.7/distutils/command/config.pyt   finalize_optionsE   s    c         C   s   d  S(   N(    (   R   (    (    s.   /usr/lib/python2.7/distutils/command/config.pyt   runU   s    c         C   sΩ   d d l  m } m } t |  j | É sπ | d |  j d |  j d d É |  _ t |  j É |  j rx |  j j |  j É n  |  j	 ró |  j j
 |  j	 É n  |  j rπ |  j j |  j É qπ n  d S(   s^   Check that 'self.compiler' really is a CCompiler object;
        if not, make it one.
        iˇˇˇˇ(   t	   CCompilert   new_compilerR   t   dry_runt   forcei   N(   t   distutils.ccompilerR   R   R   R   R    R   R   t   set_include_dirsR   t   set_librariesR   t   set_library_dirs(   R   R   R   (    (    s.   /usr/lib/python2.7/distutils/command/config.pyt   _check_compiler]   s    			c         C   sê   d t  | } t | d É } | rU x | D] } | j d | É q* W| j d É n  | j | É | d d k rÇ | j d É n  | j É  | S(   Nt   _configtestt   ws   #include <%s>
s   
iˇˇˇˇ(   t   LANG_EXTt   opent   writet   close(   R   t   bodyt   headerst   langt   filenamet   filet   header(    (    s.   /usr/lib/python2.7/distutils/command/config.pyt   _gen_temp_sourcefilep   s    
c         C   sT   |  j  | | | É } d } |  j j | | g É |  j j | | d | É| | f S(   Ns   _configtest.iR   (   R3   R   t   extendR   t
   preprocess(   R   R-   R.   R   R/   t   srct   out(    (    s.   /usr/lib/python2.7/distutils/command/config.pyt   _preprocess}   s
    c         C   sÉ   |  j  | | | É } |  j r2 t | d | É n  |  j j | g É \ } |  j j | | g É |  j j | g d | É| | f S(   Ns   compiling '%s':R   (   R3   R   t	   dump_fileR   t   object_filenamesR   R4   t   compile(   R   R-   R.   R   R/   R6   t   obj(    (    s.   /usr/lib/python2.7/distutils/command/config.pyt   _compileÑ   s    	c   
   	   C   s™   |  j  | | | | É \ } } t j j t j j | É É d }	 |  j j | g |	 d | d | d | É|  j j d  k	 rç |	 |  j j }	 n  |  j	 j
 |	 É | | |	 f S(   Ni    R   R   t   target_lang(   R=   R   t   patht   splitextt   basenameR   t   link_executablet   exe_extensionR   R   t   append(
   R   R-   R.   R   R   R   R/   R6   R<   t   prog(    (    s.   /usr/lib/python2.7/distutils/command/config.pyt   _linkç   s    "c         G   sn   | s |  j  } g  |  _  n  t j d d j | É É x3 | D]+ } y t j | É Wq; t k
 re q; Xq; Wd  S(   Ns   removing: %st    (   R   R   t   infot   joinR   t   removet   OSError(   R   t	   filenamesR0   (    (    s.   /usr/lib/python2.7/distutils/command/config.pyt   _cleanú   s    	R   c         C   sb   d d l  m } |  j É  d } y |  j | | | | É Wn | k
 rS d } n X|  j É  | S(   sQ  Construct a source file from 'body' (a string containing lines
        of C/C++ code) and 'headers' (a list of header files to include)
        and run it through the preprocessor.  Return true if the
        preprocessor succeeded, false if there were any errors.
        ('body' probably isn't of much use, but what the heck.)
        iˇˇˇˇ(   t   CompileErrori   i    (   R"   RN   R&   R8   RM   (   R   R-   R.   R   R/   RN   t   ok(    (    s.   /usr/lib/python2.7/distutils/command/config.pyt   try_cpp≤   s    


c         C   sØ   |  j  É  |  j | | | | É \ } } t | t É rI t j | É } n  t | É } d }	 x9 | j É  }
 |
 d k rz Pn  | j |
 É r^ d }	 Pq^ q^ W| j	 É  |  j
 É  |	 S(   s¥  Construct a source file (just like 'try_cpp()'), run it through
        the preprocessor, and return true if any line of the output matches
        'pattern'.  'pattern' should either be a compiled regex object or a
        string containing a regex.  If both 'body' and 'headers' are None,
        preprocesses an empty file -- which can be useful to determine the
        symbols the preprocessor and compiler set by default.
        i    t    i   (   R&   R8   R   R   t   reR;   R*   t   readlinet   searchR,   RM   (   R   t   patternR-   R.   R   R/   R6   R7   R1   t   matcht   line(    (    s.   /usr/lib/python2.7/distutils/command/config.pyt
   search_cppƒ   s     	


c         C   s{   d d l  m } |  j É  y  |  j | | | | É d } Wn | k
 rS d } n Xt j | rf d pi d É |  j É  | S(   sw   Try to compile a source file built from 'body' and 'headers'.
        Return true on success, false otherwise.
        iˇˇˇˇ(   RN   i   i    s   success!s   failure.(   R"   RN   R&   R=   R   RH   RM   (   R   R-   R.   R   R/   RN   RO   (    (    s.   /usr/lib/python2.7/distutils/command/config.pyt   try_compile·   s    



c   
      C   sç   d d l  m } m } |  j É  y& |  j | | | | | | É d }	 Wn | | f k
 re d }	 n Xt j |	 rx d p{ d É |  j É  |	 S(   sû   Try to compile and link a source file, built from 'body' and
        'headers', to executable form.  Return true on success, false
        otherwise.
        iˇˇˇˇ(   RN   t	   LinkErrori   i    s   success!s   failure.(   R"   RN   RZ   R&   RF   R   RH   RM   (
   R   R-   R.   R   R   R   R/   RN   RZ   RO   (    (    s.   /usr/lib/python2.7/distutils/command/config.pyt   try_linkÒ   s    



c         C   s´   d d l  m } m } |  j É  yA |  j | | | | | | É \ }	 }
 } |  j | g É d } Wn  | | t f k
 rÉ d } n Xt j | rñ d pô d É |  j	 É  | S(   sú   Try to compile, link to an executable, and run a program
        built from 'body' and 'headers'.  Return true on success, false
        otherwise.
        iˇˇˇˇ(   RN   RZ   i   i    s   success!s   failure.(
   R"   RN   RZ   R&   RF   t   spawnR   R   RH   RM   (   R   R-   R.   R   R   R   R/   RN   RZ   R6   R<   t   exeRO   (    (    s.   /usr/lib/python2.7/distutils/command/config.pyt   try_run  s    



i    c   	      C   sõ   |  j  É  g  } | r* | j d | É n  | j d É | rQ | j d | É n | j d | É | j d É d j | É d } |  j | | | | | É S(   s€  Determine if function 'func' is available by constructing a
        source file that refers to 'func', and compiles and links it.
        If everything succeeds, returns true; otherwise returns false.

        The constructed source file starts out by including the header
        files listed in 'headers'.  If 'decl' is true, it then declares
        'func' (as "int func()"); you probably shouldn't supply 'headers'
        and set 'decl' true in the same call, or you might get errors about
        a conflicting declarations for 'func'.  Finally, the constructed
        'main()' function either references 'func' or (if 'call' is true)
        calls it.  'libraries' and 'library_dirs' are used when
        linking.
        s
   int %s ();s   int main () {s     %s();s     %s;t   }s   
(   R&   RD   RI   R[   (	   R   t   funcR.   R   R   R   t   declt   callR-   (    (    s.   /usr/lib/python2.7/distutils/command/config.pyt
   check_func  s    
c         C   s*   |  j  É  |  j d | | | g | | É S(   s·  Determine if 'library' is available to be linked against,
        without actually checking that any particular symbols are provided
        by it.  'headers' will be used in constructing the source file to
        be compiled, but the only effect of this is to check if all the
        header files listed are available.  Any libraries listed in
        'other_libraries' will be included in the link, in case 'library'
        has symbols that depend on other libraries.
        s   int main (void) { }(   R&   R[   (   R   t   libraryR   R.   R   t   other_libraries(    (    s.   /usr/lib/python2.7/distutils/command/config.pyt	   check_lib?  s    

	c         C   s   |  j  d d d | g d | É S(   s§   Determine if the system header file named by 'header_file'
        exists and can be found by the preprocessor; return true if so,
        false otherwise.
        R-   s   /* No body */R.   R   (   RP   (   R   R2   R   R   R/   (    (    s.   /usr/lib/python2.7/distutils/command/config.pyt   check_headerN  s    N(   s	   compiler=Ns   specify the compiler type(   s   cc=Ns   specify the compiler executable(   s   include-dirs=R   s.   list of directories to search for header files(   s   define=R   s   C preprocessor macros to define(   s   undef=R   s!   C preprocessor macros to undefine(   s
   libraries=R	   s!   external C libraries to link with(   s   library-dirs=R
   s.   directories to search for external C libraries(   R   Ns1   show every action (compile, link, run, ...) taken(   s   dump-sourceNs=   dump generated source files before attempting to compile them(   t   __name__t
   __module__t   descriptionR   t   user_optionsR   R   R   R&   R3   R8   R=   RF   RM   RP   RX   RY   R[   R^   Rc   Rf   Rg   (    (    (    s.   /usr/lib/python2.7/distutils/command/config.pyR      sT            														!c         C   sb   | d k r  t j d |  É n t j | É t |  É } z t j | j É  É Wd | j É  Xd S(   sj   Dumps a file content into log.info.

    If head is not None, will be dumped before the file content.
    s   %sN(   R   R   RH   R*   t   readR,   (   R0   t   headR1   (    (    s.   /usr/lib/python2.7/distutils/command/config.pyR9   X  s    (   t   __doc__t   __revision__R   RR   t   distutils.coreR    t   distutils.errorsR   t   distutils.sysconfigR   t	   distutilsR   R)   R   R   R9   (    (    (    s.   /usr/lib/python2.7/distutils/command/config.pyt   <module>
   s   ˇ A                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           """distutils.command.install

Implements the Distutils 'install' command."""

from distutils import log

# This module should be kept compatible with Python 2.1.

__revision__ = "$Id$"

import sys, os, string
from types import *
from distutils.core import Command
from distutils.debug import DEBUG
from distutils.sysconfig import get_config_vars
from distutils.errors import DistutilsPlatformError
from distutils.file_util import write_file
from distutils.util import convert_path, subst_vars, change_root
from distutils.util import get_platform
from distutils.errors import DistutilsOptionError
from site import USER_BASE
from site import USER_SITE


if sys.version < "2.2":
    WINDOWS_SCHEME = {
        'purelib': '$base',
        'platlib': '$base',
        'headers': '$base/Include/$dist_name',
        'scripts': '$base/Scripts',
        'data'   : '$base',
    }
else:
    WINDOWS_SCHEME = {
        'purelib': '$base/Lib/site-packages',
        'platlib': '$base/Lib/site-packages',
        'headers': '$base/Include/$dist_name',
        'scripts': '$base/Scripts',
        'data'   : '$base',
    }

INSTALL_SCHEMES = {
    'unix_prefix': {
        'purelib': '$base/lib/python$py_version_short/site-packages',
        'platlib': '$platbase/lib/python$py_version_short/site-packages',
        'headers': '$base/include/python$py_version_short/$dist_name',
        'scripts': '$base/bin',
        'data'   : '$base',
        },
    'unix_local': {
        'purelib': '$base/local/lib/python$py_version_short/dist-packages',
        'platlib': '$platbase/local/lib/python$py_version_short/dist-packages',
        'headers': '$base/local/include/python$py_version_short/$dist_name',
        'scripts': '$base/local/bin',
        'data'   : '$base/local',
        },
    'deb_system': {
        'purelib': '$base/lib/python$py_version_short/dist-packages',
        'platlib': '$platbase/lib/python$py_version_short/dist-packages',
        'headers': '$base/include/python$py_version_short/$dist_name',
        'scripts': '$base/bin',
        'data'   : '$base',
        },
    'unix_home': {
        'purelib': '$base/lib/python',
        'platlib': '$base/lib/python',
        'headers': '$base/include/python/$dist_name',
        'scripts': '$base/bin',
        'data'   : '$base',
        },
    'unix_user': {
        'purelib': '$usersite',
        'platlib': '$usersite',
        'headers': '$userbase/include/python$py_version_short/$dist_name',
        'scripts': '$userbase/bin',
        'data'   : '$userbase',
        },
    'nt': WINDOWS_SCHEME,
    'nt_user': {
        'purelib': '$usersite',
        'platlib': '$usersite',
        'headers': '$userbase/Python$py_version_nodot/Include/$dist_name',
        'scripts': '$userbase/Scripts',
        'data'   : '$userbase',
        },
    'os2': {
        'purelib': '$base/Lib/site-packages',
        'platlib': '$base/Lib/site-packages',
        'headers': '$base/Include/$dist_name',
        'scripts': '$base/Scripts',
        'data'   : '$base',
        },
    'os2_home': {
        'purelib': '$usersite',
        'platlib': '$usersite',
        'headers': '$userbase/include/python$py_version_short/$dist_name',
        'scripts': '$userbase/bin',
        'data'   : '$userbase',
        },
    }

# The keys to an installation scheme; if any new types of files are to be
# installed, be sure to add an entry to every installation scheme above,
# and to SCHEME_KEYS here.
SCHEME_KEYS = ('purelib', 'platlib', 'headers', 'scripts', 'data')


class install (Command):

    description = "install everything from build directory"

    user_options = [
        # Select installation scheme and set base director(y|ies)
        ('prefix=', None,
         "installation prefix"),
        ('exec-prefix=', None,
         "(Unix only) prefix for platform-specific files"),
        ('home=', None,
         "(Unix only) home directory to install under"),
        ('user', None,
         "install in user site-package '%s'" % USER_SITE),

        # Or, just set the base director(y|ies)
        ('install-base=', None,
         "base installation directory (instead of --prefix or --home)"),
        ('install-platbase=', None,
         "base installation directory for platform-specific files " +
         "(instead of --exec-prefix or --home)"),
        ('root=', None,
         "install everything relative to this alternate root directory"),

        # Or, explicitly set the installation scheme
        ('install-purelib=', None,
         "installation directory for pure Python module distributions"),
        ('install-platlib=', None,
         "installation directory for non-pure module distributions"),
        ('install-lib=', None,
         "installation directory for all module distributions " +
         "(overrides --install-purelib and --install-platlib)"),

        ('install-headers=', None,
         "installation directory for C/C++ headers"),
        ('install-scripts=', None,
         "installation directory for Python scripts"),
        ('install-data=', None,
         "installation directory for data files"),

        # Byte-compilation options -- see install_lib.py for details, as
        # these are duplicated from there (but only install_lib does
        # anything with them).
        ('compile', 'c', "compile .py to .pyc [default]"),
        ('no-compile', None, "don't compile .py files"),
        ('optimize=', 'O',
         "also compile with optimization: -O1 for \"python -O\", "
         "-O2 for \"python -OO\", and -O0 to disable [default: -O0]"),

        # Miscellaneous control options
        ('force', 'f',
         "force installation (overwrite any existing files)"),
        ('skip-build', None,
         "skip rebuilding everything (for testing/debugging)"),

        # Where to install documentation (eventually!)
        #('doc-format=', None, "format of documentation to generate"),
        #('install-man=', None, "directory for Unix man pages"),
        #('install-html=', None, "directory for HTML documentation"),
        #('install-info=', None, "directory for GNU info files"),

        ('record=', None,
         "filename in which to record list of installed files"),

        ('install-layout=', None,
         "installation layout to choose (known values: deb, unix)"),
        ]

    boolean_options = ['compile', 'force', 'skip-build', 'user']
    negative_opt = {'no-compile' : 'compile'}


    def initialize_options (self):

        # High-level options: these select both an installation base
        # and scheme.
        self.prefix = None
        self.exec_prefix = None
        self.home = None
        self.user = 0
        self.prefix_option = None

        # These select only the installation base; it's up to the user to
        # specify the installation scheme (currently, that means supplying
        # the --install-{platlib,purelib,scripts,data} options).
        self.install_base = None
        self.install_platbase = None
        self.root = None

        # These options are the actual installation directories; if not
        # supplied by the user, they are filled in using the installation
        # scheme implied by prefix/exec-prefix/home and the contents of
        # that installation scheme.
        self.install_purelib = None     # for pure module distributions
        self.install_platlib = None     # non-pure (dists w/ extensions)
        self.install_headers = None     # for C/C++ headers
        self.install_lib = None         # set to either purelib or platlib
        self.install_scripts = None
        self.install_data = None
        self.install_userbase = USER_BASE
        self.install_usersite = USER_SITE

        # enable custom installation, known values: deb
        self.install_layout = None

        self.compile = None
        self.optimize = None

        # These two are for putting non-packagized distributions into their
        # own directory and creating a .pth file if it makes sense.
        # 'extra_path' comes from the setup file; 'install_path_file' can
        # be turned off if it makes no sense to install a .pth file.  (But
        # better to install it uselessly than to guess wrong and not
        # install it when it's necessary and would be used!)  Currently,
        # 'install_path_file' is always true unless some outsider meddles
        # with it.
        self.extra_path = None
        self.install_path_file = 1

        # 'force' forces installation, even if target files are not
        # out-of-date.  'skip_build' skips running the "build" command,
        # handy if you know it's not necessary.  'warn_dir' (which is *not*
        # a user option, it's just there so the bdist_* commands can turn
        # it off) determines whether we warn about installing to a
        # directory not in sys.path.
        self.force = 0
        self.skip_build = 0
        self.warn_dir = 1

        # These are only here as a conduit from the 'build' command to the
        # 'install_*' commands that do the real work.  ('build_base' isn't
        # actually used anywhere, but it might be useful in future.)  They
        # are not user options, because if the user told the install
        # command where the build directory is, that wouldn't affect the
        # build command.
        self.build_base = None
        self.build_lib = None

        # Not defined yet because we don't know anything about
        # documentation yet.
        #self.install_man = None
        #self.install_html = None
        #self.install_info = None

        self.record = None


    # -- Option finalizing methods -------------------------------------
    # (This is rather more involved than for most commands,
    # because this is where the policy for installing third-
    # party Python modules on various platforms given a wide
    # array of user input is decided.  Yes, it's quite complex!)

    def finalize_options (self):

        # This method (and its pliant slaves, like 'finalize_unix()',
        # 'finalize_other()', and 'select_scheme()') is where the default
        # installation directories for modules, extension modules, and
        # anything else we care to install from a Python module
        # distribution.  Thus, this code makes a pretty important policy
        # statement about how third-party stuff is added to a Python
        # installation!  Note that the actual work of installation is done
        # by the relatively simple 'install_*' commands; they just take
        # their orders from the installation directory options determined
        # here.

        # Check for errors/inconsistencies in the options; first, stuff
        # that's wrong on any platform.

        if ((self.prefix or self.exec_prefix or self.home) and
            (self.install_base or self.install_platbase)):
            raise DistutilsOptionError, \
                  ("must supply either prefix/exec-prefix/home or " +
                   "install-base/install-platbase -- not both")

        if self.home and (self.prefix or self.exec_prefix):
            raise DistutilsOptionError, \
                  "must supply either home or prefix/exec-prefix -- not both"

        if self.user and (self.prefix or self.exec_prefix or self.home or
                self.install_base or self.install_platbase):
            raise DistutilsOptionError("can't combine user with prefix, "
                                       "exec_prefix/home, or install_(plat)base")

        # Next, stuff that's wrong (or dubious) only on certain platforms.
        if os.name != "posix":
            if self.exec_prefix:
                self.warn("exec-prefix option ignored on this platform")
                self.exec_prefix = None

        # Now the interesting logic -- so interesting that we farm it out
        # to other methods.  The goal of these methods is to set the final
        # values for the install_{lib,scripts,data,...}  options, using as
        # input a heady brew of prefix, exec_prefix, home, install_base,
        # install_platbase, user-supplied versions of
        # install_{purelib,platlib,lib,scripts,data,...}, and the
        # INSTALL_SCHEME dictionary above.  Phew!

        self.dump_dirs("pre-finalize_{unix,other}")

        if os.name == 'posix':
            self.finalize_unix()
        else:
            self.finalize_other()

        self.dump_dirs("post-finalize_{unix,other}()")

        # Expand configuration variables, tilde, etc. in self.install_base
        # and self.install_platbase -- that way, we can use $base or
        # $platbase in the other installation directories and not worry
        # about needing recursive variable expansion (shudder).

        py_version = (string.split(sys.version))[0]
        (prefix, exec_prefix) = get_config_vars('prefix', 'exec_prefix')
        self.config_vars = {'dist_name': self.distribution.get_name(),
                            'dist_version': self.distribution.get_version(),
                            'dist_fullname': self.distribution.get_fullname(),
                            'py_version': py_version,
                            'py_version_short': py_version[0:3],
                            'py_version_nodot': py_version[0] + py_version[2],
                            'sys_prefix': prefix,
                            'prefix': prefix,
                            'sys_exec_prefix': exec_prefix,
                            'exec_prefix': exec_prefix,
                            'userbase': self.install_userbase,
                            'usersite': self.install_usersite,
                           }
        self.expand_basedirs()

        self.dump_dirs("post-expand_basedirs()")

        # Now define config vars for the base directories so we can expand
        # everything else.
        self.config_vars['base'] = self.install_base
        self.config_vars['platbase'] = self.install_platbase

        if DEBUG:
            from pprint import pprint
            print "config vars:"
            pprint(self.config_vars)

        # Expand "~" and configuration variables in the installation
        # directories.
        self.expand_dirs()

        self.dump_dirs("post-expand_dirs()")

        # Create directories in the home dir:
        if self.user:
            self.create_home_path()

        # Pick the actual directory to install all modules to: either
        # install_purelib or install_platlib, depending on whether this
        # module distribution is pure or not.  Of course, if the user
        # already specified install_lib, use their selection.
        if self.install_lib is None:
            if self.distribution.ext_modules: # has extensions: non-pure
                self.install_lib = self.install_platlib
            else:
                self.install_lib = self.install_purelib


        # Convert directories from Unix /-separated syntax to the local
        # convention.
        self.convert_paths('lib', 'purelib', 'platlib',
                           'scripts', 'data', 'headers',
                           'userbase', 'usersite')

        # Well, we're not actually fully completely finalized yet: we still
        # have to deal with 'extra_path', which is the hack for allowing
        # non-packagized module distributions (hello, Numerical Python!) to
        # get their own directories.
        self.handle_extra_path()
        self.install_libbase = self.install_lib # needed for .pth file
        self.install_lib = os.path.join(self.install_lib, self.extra_dirs)

        # If a new root directory was supplied, make all the installation
        # dirs relative to it.
        if self.root is not None:
            self.change_roots('libbase', 'lib', 'purelib', 'platlib',
                              'scripts', 'data', 'headers')

        self.dump_dirs("after prepending root")

        # Find out the build directories, ie. where to install from.
        self.set_undefined_options('build',
                                   ('build_base', 'build_base'),
                                   ('build_lib', 'build_lib'))

        # Punt on doc directories for now -- after all, we're punting on
        # documentation completely!

    # finalize_options ()


    def dump_dirs (self, msg):
        if DEBUG:
            from distutils.fancy_getopt import longopt_xlate
            print msg + ":"
            for opt in self.user_options:
                opt_name = opt[0]
                if opt_name[-1] == "=":
                    opt_name = opt_name[0:-1]
                if opt_name in self.negative_opt:
                    opt_name = string.translate(self.negative_opt[opt_name],
                                                longopt_xlate)
                    val = not getattr(self, opt_name)
                else:
                    opt_name = string.translate(opt_name, longopt_xlate)
                    val = getattr(self, opt_name)
                print "  %s: %s" % (opt_name, val)


    def finalize_unix (self):

        if self.install_base is not None or self.install_platbase is not None:
            if ((self.install_lib is None and
                 self.install_purelib is None and
                 self.install_platlib is None) or
                self.install_headers is None or
                self.install_scripts is None or
                self.install_data is None):
                raise DistutilsOptionError, \
                      ("install-base or install-platbase supplied, but "
                      "installation scheme is incomplete")
            return

        if self.user:
            if self.install_userbase is None:
                raise DistutilsPlatformError(
                    "User base directory is not specified")
            self.install_base = self.install_platbase = self.install_userbase
            self.select_scheme("unix_user")
        elif self.home is not None:
            self.install_base = self.install_platbase = self.home
            self.select_scheme("unix_home")
        else:
            self.prefix_option = self.prefix
            if self.prefix is None:
                if self.exec_prefix is not None:
                    raise DistutilsOptionError, \
                          "must not supply exec-prefix without prefix"

                self.prefix = os.path.normpath(sys.prefix)
                self.exec_prefix = os.path.normpath(sys.exec_prefix)

            else:
                if self.exec_prefix is None:
                    self.exec_prefix = self.prefix

            self.install_base = self.prefix
            self.install_platbase = self.exec_prefix
            if self.install_layout:
                if self.install_layout.lower() in ['deb']:
                    self.select_scheme("deb_system")
                elif self.install_layout.lower() in ['posix', 'unix']:
                    self.select_scheme("unix_prefix")
                else:
                    raise DistutilsOptionError(
                        "unknown value for --install-layout")
            elif (self.prefix_option and os.path.normpath(self.prefix) != '/usr/local') \
                    or 'PYTHONUSERBASE' in os.environ \
                    or 'real_prefix' in sys.__dict__:
                self.select_scheme("unix_prefix")
            else:
                if os.path.normpath(self.prefix) == '/usr/local':
                    self.select_scheme("deb_system")
                else:
                    self.select_scheme("unix_local")

    # finalize_unix ()


    def finalize_other (self):          # Windows and Mac OS for now

        if self.user:
            if self.install_userbase is None:
                raise DistutilsPlatformError(
                    "User base directory is not specified")
            self.install_base = self.install_platbase = self.install_userbase
            self.select_scheme(os.name + "_user")
        elif self.home is not None:
            self.install_base = self.install_platbase = self.home
            self.select_scheme("unix_home")
        else:
            if self.prefix is None:
                self.prefix = os.path.normpath(sys.prefix)

            self.install_base = self.install_platbase = self.prefix
            try:
                self.select_scheme(os.name)
            except KeyError:
                raise DistutilsPlatformError, \
                      "I don't know how to install stuff on '%s'" % os.name

    # finalize_other ()


    def select_scheme (self, name):
        # it's the caller's problem if they supply a bad name!
        scheme = INSTALL_SCHEMES[name]
        for key in SCHEME_KEYS:
            attrname = 'install_' + key
            if getattr(self, attrname) is None:
                setattr(self, attrname, scheme[key])


    def _expand_attrs (self, attrs):
        for attr in attrs:
            val = getattr(self, attr)
            if val is not None:
                if os.name == 'posix' or os.name == 'nt':
                    val = os.path.expanduser(val)
                val = subst_vars(val, self.config_vars)
                setattr(self, attr, val)


    def expand_basedirs (self):
        self._expand_attrs(['install_base',
                            'install_platbase',
                            'root'])

    def expand_dirs (self):
        self._expand_attrs(['install_purelib',
                            'install_platlib',
                            'install_lib',
                            'install_headers',
                            'install_scripts',
                            'install_data',])


    def convert_paths (self, *names):
        for name in names:
            attr = "install_" + name
            setattr(self, attr, convert_path(getattr(self, attr)))


    def handle_extra_path (self):

        if self.extra_path is None:
            self.extra_path = self.distribution.extra_path

        if self.extra_path is not None:
            if type(self.extra_path) is StringType:
                self.extra_path = string.split(self.extra_path, ',')

            if len(self.extra_path) == 1:
                path_file = extra_dirs = self.extra_path[0]
            elif len(self.extra_path) == 2:
                (path_file, extra_dirs) = self.extra_path
            else:
                raise DistutilsOptionError, \
                      ("'extra_path' option must be a list, tuple, or "
                      "comma-separated string with 1 or 2 elements")

            # convert to local form in case Unix notation used (as it
            # should be in setup scripts)
            extra_dirs = convert_path(extra_dirs)

        else:
            path_file = None
            extra_dirs = ''

        # XXX should we warn if path_file and not extra_dirs? (in which
        # case the path file would be harmless but pointless)
        self.path_file = path_file
        self.extra_dirs = extra_dirs

    # handle_extra_path ()


    def change_roots (self, *names):
        for name in names:
            attr = "install_" + name
            setattr(self, attr, change_root(self.root, getattr(self, attr)))

    def create_home_path(self):
        """Create directories under ~
        """
        if not self.user:
            return
        home = convert_path(os.path.expanduser("~"))
        for name, path in self.config_vars.iteritems():
            if path.startswith(home) and not os.path.isdir(path):
                self.debug_print("os.makedirs('%s', 0700)" % path)
                os.makedirs(path, 0700)

    # -- Command execution methods -------------------------------------

    def run (self):

        # Obviously have to build before we can install
        if not self.skip_build:
            self.run_command('build')
            # If we built for any other platform, we can't install.
            build_plat = self.distribution.get_command_obj('build').plat_name
            # check warn_dir - it is a clue that the 'install' is happening
            # internally, and not to sys.path, so we don't check the platform
            # matches what we are running.
            if self.warn_dir and build_plat != get_platform():
                raise DistutilsPlatformError("Can't install when "
                                             "cross-compiling")

        # Run all sub-commands (at least those that need to be run)
        for cmd_name in self.get_sub_commands():
            self.run_command(cmd_name)

        if self.path_file:
            self.create_path_file()

        # write list of installed files, if requested.
        if self.record:
            outputs = self.get_outputs()
            if self.root:               # strip any package prefix
                root_len = len(self.root)
                for counter in xrange(len(outputs)):
                    outputs[counter] = outputs[counter][root_len:]
            self.execute(write_file,
                         (self.record, outputs),
                         "writing list of installed files to '%s'" %
                         self.record)

        sys_path = map(os.path.normpath, sys.path)
        sys_path = map(os.path.normcase, sys_path)
        install_lib = os.path.normcase(os.path.normpath(self.install_lib))
        if (self.warn_dir and
            not (self.path_file and self.install_path_file) and
            install_lib not in sys_path):
            log.debug(("modules installed to '%s', which is not in "
                       "Python's module search path (sys.path) -- "
                       "you'll have to change the search path yourself"),
                       self.install_lib)

    # run ()

    def create_path_file (self):
        filename = os.path.join(self.install_libbase,
                                self.path_file + ".pth")
        if self.install_path_file:
            self.execute(write_file,
                         (filename, [self.extra_dirs]),
                         "creating %s" % filename)
        else:
            self.warn("path file '%s' not created" % filename)


    # -- Reporting methods ---------------------------------------------

    def get_outputs (self):
        # Assemble the outputs of all the sub-commands.
        outputs = []
        for cmd_name in self.get_sub_commands():
            cmd = self.get_finalized_command(cmd_name)
            # Add the contents of cmd.get_outputs(), ensuring
            # that outputs doesn't contain duplicate entries
            for filename in cmd.get_outputs():
                if filename not in outputs:
                    outputs.append(filename)

        if self.path_file and self.install_path_file:
            outputs.append(os.path.join(self.install_libbase,
                                        self.path_file + ".pth"))

        return outputs

    def get_inputs (self):
        # XXX gee, this looks familiar ;-(
        inputs = []
        for cmd_name in self.get_sub_commands():
            cmd = self.get_finalized_command(cmd_name)
            inputs.extend(cmd.get_inputs())

        return inputs


    # -- Predicates for sub-command list -------------------------------

    def has_lib (self):
        """Return true if the current distribution has any Python
        modules to install."""
        return (self.distribution.has_pure_modules() or
                self.distribution.has_ext_modules())

    def has_headers (self):
        return self.distribution.has_headers()

    def has_scripts (self):
        return self.distribution.has_scripts()

    def has_data (self):
        return self.distribution.has_data_files()


    # 'sub_commands': a list of commands this command might have to run to
    # get its work done.  See cmd.py for more info.
    sub_commands = [('install_lib',     has_lib),
                    ('install_headers', has_headers),
                    ('install_scripts', has_scripts),
                    ('install_data',    has_data),
                    ('install_egg_info', lambda self:True),
                   ]

# class install
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  Û
”´[c           @   s◊  d  Z  d d l m Z d Z d d l Z d d l Z d d l Z d d l Td d l m	 Z	 d d l
 m Z d d l m Z d d	 l m Z d d
 l m Z d d l m Z m Z m Z d d l m Z d d l m Z d d l m Z d d l m Z e j d k  r1i d d 6d d 6d d 6d d 6d d 6Z n) i d d 6d d 6d d 6d d 6d d 6Z i	 i d d 6d d 6d d 6d d 6d d 6d 6i d d 6d  d 6d! d 6d" d 6d# d 6d$ 6i d% d 6d& d 6d d 6d d 6d d 6d' 6i d( d 6d( d 6d) d 6d d 6d d 6d* 6i d+ d 6d+ d 6d, d 6d- d 6d. d 6d/ 6e d0 6i d+ d 6d+ d 6d1 d 6d2 d 6d. d 6d3 6i d d 6d d 6d d 6d d 6d d 6d4 6i d+ d 6d+ d 6d, d 6d- d 6d. d 6d5 6Z d8 Z d6 e	 f d7 Ñ  É  YZ d S(9   sF   distutils.command.install

Implements the Distutils 'install' command.iˇˇˇˇ(   t   logs   $Id$N(   t   *(   t   Command(   t   DEBUG(   t   get_config_vars(   t   DistutilsPlatformError(   t
   write_file(   t   convert_patht
   subst_varst   change_root(   t   get_platform(   t   DistutilsOptionError(   t	   USER_BASE(   t	   USER_SITEs   2.2s   $baset   purelibt   platlibs   $base/Include/$dist_namet   headerss   $base/Scriptst   scriptst   datas   $base/Lib/site-packagess/   $base/lib/python$py_version_short/site-packagess3   $platbase/lib/python$py_version_short/site-packagess0   $base/include/python$py_version_short/$dist_names	   $base/bint   unix_prefixs5   $base/local/lib/python$py_version_short/dist-packagess9   $platbase/local/lib/python$py_version_short/dist-packagess6   $base/local/include/python$py_version_short/$dist_names   $base/local/bins   $base/localt
   unix_locals/   $base/lib/python$py_version_short/dist-packagess3   $platbase/lib/python$py_version_short/dist-packagest
   deb_systems   $base/lib/pythons   $base/include/python/$dist_namet	   unix_homes	   $usersites4   $userbase/include/python$py_version_short/$dist_names   $userbase/bins	   $userbaset	   unix_usert   nts4   $userbase/Python$py_version_nodot/Include/$dist_names   $userbase/Scriptst   nt_usert   os2t   os2_homet   installc           B   sâ  e  Z d  Z dJ dK dL d dI d e f dM d dI d d f dN dO dP d dI d d f dQ dR dS dT dU dV dW dX dY dZ g Z d d% d( d g Z i d d  6Z d. Ñ  Z d/ Ñ  Z	 d0 Ñ  Z
 d1 Ñ  Z d2 Ñ  Z d3 Ñ  Z d4 Ñ  Z d5 Ñ  Z d6 Ñ  Z d7 Ñ  Z d8 Ñ  Z d9 Ñ  Z d: Ñ  Z d; Ñ  Z d< Ñ  Z d= Ñ  Z d> Ñ  Z d? Ñ  Z d@ Ñ  Z dA Ñ  Z dB Ñ  Z dC e f dD e f dE e f dF e f dG dH Ñ  f g Z RS([   s'   install everything from build directorys   prefix=s   installation prefixs   exec-prefix=s.   (Unix only) prefix for platform-specific filess   home=s+   (Unix only) home directory to install undert   users!   install in user site-package '%s's   install-base=s;   base installation directory (instead of --prefix or --home)s   install-platbase=s8   base installation directory for platform-specific files s$   (instead of --exec-prefix or --home)s   root=s<   install everything relative to this alternate root directorys   install-purelib=s;   installation directory for pure Python module distributionss   install-platlib=s8   installation directory for non-pure module distributionss   install-lib=s4   installation directory for all module distributions s3   (overrides --install-purelib and --install-platlib)s   install-headers=s(   installation directory for C/C++ headerss   install-scripts=s)   installation directory for Python scriptss   install-data=s%   installation directory for data filest   compilet   cs   compile .py to .pyc [default]s
   no-compiles   don't compile .py filess	   optimize=t   Osl   also compile with optimization: -O1 for "python -O", -O2 for "python -OO", and -O0 to disable [default: -O0]t   forcet   fs1   force installation (overwrite any existing files)s
   skip-builds2   skip rebuilding everything (for testing/debugging)s   record=s3   filename in which to record list of installed filess   install-layout=s7   installation layout to choose (known values: deb, unix)c         C   s˜   d  |  _ d  |  _ d  |  _ d |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _	 d  |  _
 d  |  _ d  |  _ d  |  _ d  |  _ t |  _ t |  _ d  |  _ d  |  _ d  |  _ d  |  _ d |  _ d |  _ d |  _ d |  _ d  |  _ d  |  _ d  |  _ d  S(   Ni    i   (   t   Nonet   prefixt   exec_prefixt   homeR   t   prefix_optiont   install_baset   install_platbaset   roott   install_purelibt   install_platlibt   install_headerst   install_libt   install_scriptst   install_dataR   t   install_userbaseR   t   install_usersitet   install_layoutR   t   optimizet
   extra_patht   install_path_fileR!   t
   skip_buildt   warn_dirt
   build_baset	   build_libt   record(   t   self(    (    s/   /usr/lib/python2.7/distutils/command/install.pyt   initialize_options¥   s6    																			
							c      	   C   sL  |  j  s |  j s |  j r= |  j s- |  j r= t d d Ç n  |  j rd |  j  sX |  j rd t d Ç n  |  j r© |  j  sö |  j sö |  j sö |  j sö |  j r© t d É Ç n  t j d k r› |  j r› |  j	 d É d  |  _ q› n  |  j d É t j d k r|  j É  n
 |  j É  |  j d É t j t j É d	 } t d
 d É \ } } i |  j j É  d 6|  j j É  d 6|  j j É  d 6| d 6| d	 d !d 6| d	 | d d 6| d 6| d
 6| d 6| d 6|  j d 6|  j d 6|  _ |  j É  |  j d É |  j |  j d <|  j |  j d <t r;d d l m } d GH| |  j É n  |  j É  |  j d É |  j rh|  j É  n  |  j d  k r°|  j j  rí|  j! |  _ q°|  j" |  _ n  |  j# d d  d! d" d# d$ d d É |  j$ É  |  j |  _% t j& j' |  j |  j( É |  _ |  j) d  k	 r(|  j* d% d d  d! d" d# d$ É n  |  j d& É |  j+ d' d* d+ É d  S(,   Ns.   must supply either prefix/exec-prefix/home or s)   install-base/install-platbase -- not boths9   must supply either home or prefix/exec-prefix -- not bothsG   can't combine user with prefix, exec_prefix/home, or install_(plat)baset   posixs+   exec-prefix option ignored on this platforms   pre-finalize_{unix,other}s   post-finalize_{unix,other}()i    R$   R%   t	   dist_namet   dist_versiont   dist_fullnamet
   py_versioni   t   py_version_shorti   t   py_version_nodott
   sys_prefixt   sys_exec_prefixt   userbaset   usersites   post-expand_basedirs()t   baset   platbaseiˇˇˇˇ(   t   pprints   config vars:s   post-expand_dirs()t   libR   R   R   R   R   t   libbases   after prepending roott   buildR9   R:   (   R9   R9   (   R:   R:   (,   R$   R%   R&   R(   R)   R   R   t   ost   namet   warnR#   t	   dump_dirst   finalize_unixt   finalize_othert   stringt   splitt   syst   versionR   t   distributiont   get_namet   get_versiont   get_fullnameR1   R2   t   config_varst   expand_basedirsR   RK   t   expand_dirst   create_home_pathR.   t   ext_modulesR,   R+   t   convert_pathst   handle_extra_patht   install_libbaset   patht   joint
   extra_dirsR*   t   change_rootst   set_undefined_options(   R<   RB   R$   R%   RK   (    (    s/   /usr/lib/python2.7/distutils/command/install.pyt   finalize_options  s~    
	$	




		

	c         C   sœ   t  rÀ d d l m } | d GHx© |  j D]õ } | d } | d d k rY | d d !} n  | |  j k rî t j |  j | | É } t |  | É } n! t j | | É } t |  | É } d | | f GHq) Wn  d  S(   Niˇˇˇˇ(   t   longopt_xlatet   :i    t   =s     %s: %s(   R   t   distutils.fancy_getoptRk   t   user_optionst   negative_optRU   t	   translatet   getattr(   R<   t   msgRk   t   optt   opt_namet   val(    (    s/   /usr/lib/python2.7/distutils/command/install.pyRR   ì  s    	
	c         C   sì  |  j  d  k	 s |  j d  k	 rà |  j d  k rK |  j d  k rK |  j d  k sx |  j d  k sx |  j d  k sx |  j d  k rÑ t	 d Ç n  d  S|  j
 r“ |  j d  k rØ t d É Ç n  |  j |  _  |  _ |  j d É nΩ|  j d  k	 r|  j |  _  |  _ |  j d É nã|  j |  _ |  j d  k rm|  j d  k	 r:t	 d Ç n  t j j t j É |  _ t j j t j É |  _ n |  j d  k rã|  j |  _ n  |  j |  _  |  j |  _ |  j r|  j j É  d k r—|  j d É qè|  j j É  d k rˆ|  j d
 É qèt	 d É Ç nä |  j r)t j j |  j É d k sGd t j k sGd t j k rW|  j d
 É n8 t j j |  j É d k rÇ|  j d É n |  j d É d  S(   NsP   install-base or install-platbase supplied, but installation scheme is incompletes$   User base directory is not specifiedR   R   s*   must not supply exec-prefix without prefixt   debR   R>   t   unixR   s"   unknown value for --install-layouts
   /usr/localt   PYTHONUSERBASEt   real_prefixR   (   Rw   (   R>   Rx   (   R(   R#   R)   R.   R+   R,   R-   R/   R0   R   R   R1   R   t   select_schemeR&   R$   R'   R%   RO   Re   t   normpathRW   R3   t   lowert   environt   __dict__(   R<   (    (    s/   /usr/lib/python2.7/distutils/command/install.pyRS   •  sX    				$c         C   s¸   |  j  rQ |  j d  k r' t d É Ç n  |  j |  _ |  _ |  j t j d É nß |  j	 d  k	 rÉ |  j	 |  _ |  _ |  j d É nu |  j
 d  k r≠ t j j t j
 É |  _
 n  |  j
 |  _ |  _ y |  j t j É Wn! t k
 r˜ t d t j Ç n Xd  S(   Ns$   User base directory is not specifiedt   _userR   s)   I don't know how to install stuff on '%s'(   R   R1   R#   R   R(   R)   R{   RO   RP   R&   R$   Re   R|   RW   t   KeyError(   R<   (    (    s/   /usr/lib/python2.7/distutils/command/install.pyRT   ·  s"    	c         C   sU   t  | } xD t D]< } d | } t |  | É d  k r t |  | | | É q q Wd  S(   Nt   install_(   t   INSTALL_SCHEMESt   SCHEME_KEYSRr   R#   t   setattr(   R<   RP   t   schemet   keyt   attrname(    (    s/   /usr/lib/python2.7/distutils/command/install.pyR{   ˙  s
    

c         C   sà   xÅ | D]y } t  |  | É } | d  k	 r t j d k sF t j d k r[ t j j | É } n  t | |  j É } t |  | | É q q Wd  S(   NR>   R   (	   Rr   R#   RO   RP   Re   t
   expanduserR   R]   RÖ   (   R<   t   attrst   attrRv   (    (    s/   /usr/lib/python2.7/distutils/command/install.pyt   _expand_attrs  s    c         C   s   |  j  d d d g É d  S(   NR(   R)   R*   (   Rå   (   R<   (    (    s/   /usr/lib/python2.7/distutils/command/install.pyR^     s    	c         C   s#   |  j  d d d d d d g É d  S(   NR+   R,   R.   R-   R/   R0   (   Rå   (   R<   (    (    s/   /usr/lib/python2.7/distutils/command/install.pyR_     s    	c         G   s>   x7 | D]/ } d | } t  |  | t t |  | É É É q Wd  S(   NRÇ   (   RÖ   R   Rr   (   R<   t   namesRP   Rã   (    (    s/   /usr/lib/python2.7/distutils/command/install.pyRb     s    
c         C   sÍ   |  j  d  k r! |  j j  |  _  n  |  j  d  k	 r» t |  j  É t k r` t j |  j  d É |  _  n  t |  j  É d k râ |  j  d } } n0 t |  j  É d k r∞ |  j  \ } } n	 t d Ç t	 | É } n d  } d } | |  _
 | |  _ d  S(   Nt   ,i   i    i   sY   'extra_path' option must be a list, tuple, or comma-separated string with 1 or 2 elementst    (   R5   R#   RY   t   typet
   StringTypeRU   RV   t   lenR   R   t	   path_fileRg   (   R<   Rì   Rg   (    (    s/   /usr/lib/python2.7/distutils/command/install.pyRc   !  s     	c      	   G   sD   x= | D]5 } d | } t  |  | t |  j t |  | É É É q Wd  S(   NRÇ   (   RÖ   R	   R*   Rr   (   R<   Rç   RP   Rã   (    (    s/   /usr/lib/python2.7/distutils/command/install.pyRh   C  s    
c         C   sè   |  j  s d St t j j d É É } xc |  j j É  D]R \ } } | j | É r5 t j j | É r5 |  j	 d | É t j
 | d É q5 q5 Wd S(   s#   Create directories under ~
        Nt   ~s   os.makedirs('%s', 0700)i¿  (   R   R   RO   Re   Râ   R]   t	   iteritemst
   startswitht   isdirt   debug_printt   makedirs(   R<   R&   RP   Re   (    (    s/   /usr/lib/python2.7/distutils/command/install.pyR`   H  s    	"c         C   s§  |  j  sU |  j d É |  j j d É j } |  j rU | t É  k rU t d É Ç qU n  x! |  j É  D] } |  j | É qb W|  j	 rè |  j
 É  n  |  j r|  j É  } |  j rÓ t |  j É } x/ t t | É É D] } | | | | | <qœ Wn  |  j t |  j | f d |  j É n  t t j j t j É } t t j j | É } t j j t j j |  j É É } |  j r†|  j	 oz|  j r†| | k r†t j d |  j É n  d  S(   NRN   s"   Can't install when cross-compilings'   writing list of installed files to '%s'sÉ   modules installed to '%s', which is not in Python's module search path (sys.path) -- you'll have to change the search path yourself(   R7   t   run_commandRY   t   get_command_objt	   plat_nameR8   R
   R   t   get_sub_commandsRì   t   create_path_fileR;   t   get_outputsR*   Rí   t   xranget   executeR   t   mapRO   Re   R|   RW   t   normcaseR.   R6   R    t   debug(   R<   t
   build_platt   cmd_namet   outputst   root_lent   countert   sys_pathR.   (    (    s/   /usr/lib/python2.7/distutils/command/install.pyt   runU  s6    					!		c         C   sc   t  j j |  j |  j d É } |  j rN |  j t | |  j g f d | É n |  j	 d | É d  S(   Ns   .pths   creating %ss   path file '%s' not created(
   RO   Re   Rf   Rd   Rì   R6   R°   R   Rg   RQ   (   R<   t   filename(    (    s/   /usr/lib/python2.7/distutils/command/install.pyRû   É  s    		c         C   sû   g  } xV |  j  É  D]H } |  j | É } x0 | j É  D]" } | | k r5 | j | É q5 q5 Wq W|  j rö |  j rö | j t j j |  j	 |  j d É É n  | S(   Ns   .pth(
   Rù   t   get_finalized_commandRü   t   appendRì   R6   RO   Re   Rf   Rd   (   R<   Rß   R¶   t   cmdR¨   (    (    s/   /usr/lib/python2.7/distutils/command/install.pyRü   ê  s    c         C   sC   g  } x6 |  j  É  D]( } |  j | É } | j | j É  É q W| S(   N(   Rù   R≠   t   extendt
   get_inputs(   R<   t   inputsR¶   RØ   (    (    s/   /usr/lib/python2.7/distutils/command/install.pyR±   °  s
    c         C   s   |  j  j É  p |  j  j É  S(   sR   Return true if the current distribution has any Python
        modules to install.(   RY   t   has_pure_modulest   has_ext_modules(   R<   (    (    s/   /usr/lib/python2.7/distutils/command/install.pyt   has_lib≠  s    c         C   s   |  j  j É  S(   N(   RY   t   has_headers(   R<   (    (    s/   /usr/lib/python2.7/distutils/command/install.pyR∂   ≥  s    c         C   s   |  j  j É  S(   N(   RY   t   has_scripts(   R<   (    (    s/   /usr/lib/python2.7/distutils/command/install.pyR∑   ∂  s    c         C   s   |  j  j É  S(   N(   RY   t   has_data_files(   R<   (    (    s/   /usr/lib/python2.7/distutils/command/install.pyt   has_dataπ  s    R.   R-   R/   R0   t   install_egg_infoc         C   s   t  S(   N(   t   True(   R<   (    (    s/   /usr/lib/python2.7/distutils/command/install.pyt   <lambda>√  s    N(   s   prefix=Ns   installation prefix(   s   exec-prefix=Ns.   (Unix only) prefix for platform-specific files(   s   home=Ns+   (Unix only) home directory to install under(   s   install-base=Ns;   base installation directory (instead of --prefix or --home)(   s   root=Ns<   install everything relative to this alternate root directory(   s   install-purelib=Ns;   installation directory for pure Python module distributions(   s   install-platlib=Ns8   installation directory for non-pure module distributions(   s   install-headers=Ns(   installation directory for C/C++ headers(   s   install-scripts=Ns)   installation directory for Python scripts(   s   install-data=Ns%   installation directory for data files(   R   R   s   compile .py to .pyc [default](   s
   no-compileNs   don't compile .py files(   s	   optimize=R    sl   also compile with optimization: -O1 for "python -O", -O2 for "python -OO", and -O0 to disable [default: -O0](   R!   R"   s1   force installation (overwrite any existing files)(   s
   skip-buildNs2   skip rebuilding everything (for testing/debugging)(   s   record=Ns3   filename in which to record list of installed files(   s   install-layout=Ns7   installation layout to choose (known values: deb, unix)(   t   __name__t
   __module__t   descriptionR#   R   Ro   t   boolean_optionsRp   R=   Rj   RR   RS   RT   R{   Rå   R^   R_   Rb   Rc   Rh   R`   R´   Rû   Rü   R±   Rµ   R∂   R∑   Rπ   t   sub_commands(    (    (    s/   /usr/lib/python2.7/distutils/command/install.pyR   l   sä      
            		Q	é		<				
					"			.											(   R   R   R   R   R   (    t   __doc__t	   distutilsR    t   __revision__RW   RO   RU   t   typest   distutils.coreR   t   distutils.debugR   t   distutils.sysconfigR   t   distutils.errorsR   t   distutils.file_utilR   t   distutils.utilR   R   R	   R
   R   t   siteR   R   RX   t   WINDOWS_SCHEMERÉ   RÑ   R   (    (    (    s/   /usr/lib/python2.7/distutils/command/install.pyt   <module>   sû   $

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            """distutils.command.install_egg_info

Implements the Distutils 'install_egg_info' command, for installing
a package's PKG-INFO metadata."""


from distutils.cmd import Command
from distutils import log, dir_util
import os, sys, re

class install_egg_info(Command):
    """Install an .egg-info file for the package"""

    description = "Install package's PKG-INFO metadata as an .egg-info file"
    user_options = [
        ('install-dir=', 'd', "directory to install to"),
        ('install-layout', None, "custom installation layout"),
    ]

    def initialize_options(self):
        self.install_dir = None
        self.install_layout = None
        self.prefix_option = None

    def finalize_options(self):
        self.set_undefined_options('install_lib',('install_dir','install_dir'))
        self.set_undefined_options('install',('install_layout','install_layout'))
        self.set_undefined_options('install',('prefix_option','prefix_option'))
        if self.install_layout:
            basename = "%s-%s.egg-info" % (
                to_filename(safe_name(self.distribution.get_name())),
                to_filename(safe_version(self.distribution.get_version()))
                )
            if not self.install_layout.lower() in ['deb']:
                raise DistutilsOptionError(
                    "unknown value for --install-layout")
        elif self.prefix_option or 'real_prefix' in sys.__dict__:
            basename = "%s-%s-py%s.egg-info" % (
                to_filename(safe_name(self.distribution.get_name())),
                to_filename(safe_version(self.distribution.get_version())),
                sys.version[:3]
                )
        else:
            basename = "%s-%s.egg-info" % (
                to_filename(safe_name(self.distribution.get_name())),
                to_filename(safe_version(self.distribution.get_version()))
                )
        self.target = os.path.join(self.install_dir, basename)
        self.outputs = [self.target]

    def run(self):
        target = self.target
        if os.path.isdir(target) and not os.path.islink(target):
            dir_util.remove_tree(target, dry_run=self.dry_run)
        elif os.path.exists(target):
            self.execute(os.unlink,(self.target,),"Removing "+target)
        elif not os.path.isdir(self.install_dir):
            self.execute(os.makedirs, (self.install_dir,),
                         "Creating "+self.install_dir)
        log.info("Writing %s", target)
        if not self.dry_run:
            f = open(target, 'w')
            self.distribution.metadata.write_pkg_file(f)
            f.close()

    def get_outputs(self):
        return self.outputs


# The following routines are taken from setuptools' pkg_resources module and
# can be replaced by importing them from pkg_resources once it is included
# in the stdlib.

def safe_name(name):
    """Convert an arbitrary string to a standard distribution name

    Any runs of non-alphanumeric/. characters are replaced with a single '-'.
    """
    return re.sub('[^A-Za-z0-9.]+', '-', name)


def safe_version(version):
    """Convert an arbitrary string to a standard version string

    Spaces become dots, and all other non-alphanumeric characters become
    dashes, with runs of multiple dashes condensed to a single dash.
    """
    version = version.replace(' ','.')
    return re.sub('[^A-Za-z0-9.]+', '-', version)


def to_filename(name):
    """Convert a project or version name to its filename-escaped form

    Any '-' characters are currently replaced with '_'.
    """
    return name.replace('-','_')
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       """distutils.command.install_headers

Implements the Distutils 'install_headers' command, to install C/C++ header
files to the Python include directory."""

__revision__ = "$Id$"

from distutils.core import Command


# XXX force is never used
class install_headers(Command):

    description = "install C/C++ header files"

    user_options = [('install-dir=', 'd',
                     "directory to install header files to"),
                    ('force', 'f',
                     "force installation (overwrite existing files)"),
                   ]

    boolean_options = ['force']

    def initialize_options(self):
        self.install_dir = None
        self.force = 0
        self.outfiles = []

    def finalize_options(self):
        self.set_undefined_options('install',
                                   ('install_headers', 'install_dir'),
                                   ('force', 'force'))


    def run(self):
        headers = self.distribution.headers
        if not headers:
            return

        self.mkpath(self.install_dir)
        for header in headers:
            (out, _) = self.copy_file(header, self.install_dir)
            self.outfiles.append(out)

    def get_inputs(self):
        return self.distribution.headers or []

    def get_outputs(self):
        return self.outfiles

# class install_headers
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              Û
”´[c           @   sÖ   d  Z  d d l m Z d d l m Z m Z d d l Z d d l Z d d l Z d e f d Ñ  É  YZ	 d Ñ  Z
 d Ñ  Z d	 Ñ  Z d S(
   sÜ   distutils.command.install_egg_info

Implements the Distutils 'install_egg_info' command, for installing
a package's PKG-INFO metadata.iˇˇˇˇ(   t   Command(   t   logt   dir_utilNt   install_egg_infoc           B   sD   e  Z d  Z d Z d d g Z d Ñ  Z d Ñ  Z d	 Ñ  Z d
 Ñ  Z	 RS(   s)   Install an .egg-info file for the packages8   Install package's PKG-INFO metadata as an .egg-info files   install-dir=t   ds   directory to install tos   install-layouts   custom installation layoutc         C   s   d  |  _ d  |  _ d  |  _ d  S(   N(   t   Nonet   install_dirt   install_layoutt   prefix_option(   t   self(    (    s8   /usr/lib/python2.7/distutils/command/install_egg_info.pyt   initialize_options   s    		c         C   sa  |  j  d d É |  j  d d É |  j  d d É |  j rö d t t |  j j É  É É t t |  j j É  É É f } |  j j É  d k r3t	 d É Ç q3nô |  j
 s≤ d	 t j k r˘ d
 t t |  j j É  É É t t |  j j É  É É t j d  f } n: d t t |  j j É  É É t t |  j j É  É É f } t j j |  j | É |  _ |  j g |  _ d  S(   Nt   install_libR   t   installR   R   s   %s-%s.egg-infot   debs"   unknown value for --install-layoutt   real_prefixs   %s-%s-py%s.egg-infoi   (   R   R   (   R   R   (   R   R   (   R   (   t   set_undefined_optionsR   t   to_filenamet	   safe_namet   distributiont   get_namet   safe_versiont   get_versiont   lowert   DistutilsOptionErrorR   t   syst   __dict__t   versiont   ost   patht   joinR   t   targett   outputs(   R	   t   basename(    (    s8   /usr/lib/python2.7/distutils/command/install_egg_info.pyt   finalize_options   s(    	c         C   s  |  j  } t j j | É rG t j j | É rG t j | d |  j Énp t j j | É r| |  j	 t j
 |  j  f d | É n; t j j |  j É s∑ |  j	 t j |  j f d |  j É n  t j d | É |  j sˇ t | d É } |  j j j | É | j É  n  d  S(   Nt   dry_runs	   Removing s	   Creating s
   Writing %st   w(   R   R   R   t   isdirt   islinkR   t   remove_treeR"   t   existst   executet   unlinkR   t   makedirsR   t   infot   openR   t   metadatat   write_pkg_filet   close(   R	   R   t   f(    (    s8   /usr/lib/python2.7/distutils/command/install_egg_info.pyt   run3   s    	%#	c         C   s   |  j  S(   N(   R   (   R	   (    (    s8   /usr/lib/python2.7/distutils/command/install_egg_info.pyt   get_outputsB   s    (   s   install-dir=R   s   directory to install toN(   s   install-layoutNs   custom installation layout(
   t   __name__t
   __module__t   __doc__t   descriptionR   t   user_optionsR
   R!   R1   R2   (    (    (    s8   /usr/lib/python2.7/distutils/command/install_egg_info.pyR      s   				c         C   s   t  j d d |  É S(   sè   Convert an arbitrary string to a standard distribution name

    Any runs of non-alphanumeric/. characters are replaced with a single '-'.
    s   [^A-Za-z0-9.]+t   -(   t   ret   sub(   t   name(    (    s8   /usr/lib/python2.7/distutils/command/install_egg_info.pyR   J   s    c         C   s%   |  j  d d É }  t j d d |  É S(   sÃ   Convert an arbitrary string to a standard version string

    Spaces become dots, and all other non-alphanumeric characters become
    dashes, with runs of multiple dashes condensed to a single dash.
    t    t   .s   [^A-Za-z0-9.]+R8   (   t   replaceR9   R:   (   R   (    (    s8   /usr/lib/python2.7/distutils/command/install_egg_info.pyR   R   s    c         C   s   |  j  d d É S(   s|   Convert a project or version name to its filename-escaped form

    Any '-' characters are currently replaced with '_'.
    R8   t   _(   R>   (   R;   (    (    s8   /usr/lib/python2.7/distutils/command/install_egg_info.pyR   \   s    (   R5   t   distutils.cmdR    t	   distutilsR   R   R   R   R9   R   R   R   R   (    (    (    s8   /usr/lib/python2.7/distutils/command/install_egg_info.pyt   <module>   s   $?		
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               Û
”´[c           @   s6   d  Z  d Z d d l m Z d e f d Ñ  É  YZ d S(   sï   distutils.command.install_headers

Implements the Distutils 'install_headers' command, to install C/C++ header
files to the Python include directory.s   $Id$iˇˇˇˇ(   t   Commandt   install_headersc           B   sP   e  Z d  Z d d g Z d g Z d Ñ  Z d Ñ  Z d	 Ñ  Z d
 Ñ  Z d Ñ  Z	 RS(   s   install C/C++ header filess   install-dir=t   ds$   directory to install header files tot   forcet   fs-   force installation (overwrite existing files)c         C   s   d  |  _ d |  _ g  |  _ d  S(   Ni    (   t   Nonet   install_dirR   t   outfiles(   t   self(    (    s7   /usr/lib/python2.7/distutils/command/install_headers.pyt   initialize_options   s    		c         C   s   |  j  d d d É d  S(   Nt   installR   R   R   (   R   R   (   R   R   (   t   set_undefined_options(   R   (    (    s7   /usr/lib/python2.7/distutils/command/install_headers.pyt   finalize_options   s    	c         C   sf   |  j  j } | s d  S|  j |  j É x9 | D]1 } |  j | |  j É \ } } |  j j | É q- Wd  S(   N(   t   distributiont   headerst   mkpathR   t	   copy_fileR   t   append(   R   R   t   headert   outt   _(    (    s7   /usr/lib/python2.7/distutils/command/install_headers.pyt   run#   s    c         C   s   |  j  j p g  S(   N(   R   R   (   R   (    (    s7   /usr/lib/python2.7/distutils/command/install_headers.pyt
   get_inputs-   s    c         C   s   |  j  S(   N(   R   (   R   (    (    s7   /usr/lib/python2.7/distutils/command/install_headers.pyt   get_outputs0   s    (   s   install-dir=R   s$   directory to install header files to(   R   R   s-   force installation (overwrite existing files)(
   t   __name__t
   __module__t   descriptiont   user_optionst   boolean_optionsR	   R   R   R   R   (    (    (    s7   /usr/lib/python2.7/distutils/command/install_headers.pyR      s     					
	N(   t   __doc__t   __revision__t   distutils.coreR    R   (    (    (    s7   /usr/lib/python2.7/distutils/command/install_headers.pyt   <module>   s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  """distutils.command.install_lib

Implements the Distutils 'install_lib' command
(install all Python modules)."""

__revision__ = "$Id$"

import os
import sys

from distutils.core import Command
from distutils.errors import DistutilsOptionError


# Extension for Python source files.
if hasattr(os, 'extsep'):
    PYTHON_SOURCE_EXTENSION = os.extsep + "py"
else:
    PYTHON_SOURCE_EXTENSION = ".py"

class install_lib(Command):

    description = "install all Python modules (extensions and pure Python)"

    # The byte-compilation options are a tad confusing.  Here are the
    # possible scenarios:
    #   1) no compilation at all (--no-compile --no-optimize)
    #   2) compile .pyc only (--compile --no-optimize; default)
    #   3) compile .pyc and "level 1" .pyo (--compile --optimize)
    #   4) compile "level 1" .pyo only (--no-compile --optimize)
    #   5) compile .pyc and "level 2" .pyo (--compile --optimize-more)
    #   6) compile "level 2" .pyo only (--no-compile --optimize-more)
    #
    # The UI for this is two option, 'compile' and 'optimize'.
    # 'compile' is strictly boolean, and only decides whether to
    # generate .pyc files.  'optimize' is three-way (0, 1, or 2), and
    # decides both whether to generate .pyo files and what level of
    # optimization to use.

    user_options = [
        ('install-dir=', 'd', "directory to install to"),
        ('build-dir=','b', "build directory (where to install from)"),
        ('force', 'f', "force installation (overwrite existing files)"),
        ('compile', 'c', "compile .py to .pyc [default]"),
        ('no-compile', None, "don't compile .py files"),
        ('optimize=', 'O',
         "also compile with optimization: -O1 for \"python -O\", "
         "-O2 for \"python -OO\", and -O0 to disable [default: -O0]"),
        ('skip-build', None, "skip the build steps"),
        ]

    boolean_options = ['force', 'compile', 'skip-build']
    negative_opt = {'no-compile' : 'compile'}

    def initialize_options(self):
        # let the 'install' command dictate our installation directory
        self.install_dir = None
        self.build_dir = None
        self.force = 0
        self.compile = None
        self.optimize = None
        self.skip_build = None

    def finalize_options(self):
        # Get all the information we need to install pure Python modules
        # from the umbrella 'install' command -- build (source) directory,
        # install (target) directory, and whether to compile .py files.
        self.set_undefined_options('install',
                                   ('build_lib', 'build_dir'),
                                   ('install_lib', 'install_dir'),
                                   ('force', 'force'),
                                   ('compile', 'compile'),
                                   ('optimize', 'optimize'),
                                   ('skip_build', 'skip_build'),
                                  )

        if self.compile is None:
            self.compile = 1
        if self.optimize is None:
            self.optimize = 0

        if not isinstance(self.optimize, int):
            try:
                self.optimize = int(self.optimize)
                if self.optimize not in (0, 1, 2):
                    raise AssertionError
            except (ValueError, AssertionError):
                raise DistutilsOptionError, "optimize must be 0, 1, or 2"

    def run(self):
        # Make sure we have built everything we need first
        self.build()

        # Install everything: simply dump the entire contents of the build
        # directory to the installation directory (that's the beauty of
        # having a build directory!)
        outfiles = self.install()

        # (Optionally) compile .py to .pyc
        if outfiles is not None and self.distribution.has_pure_modules():
            self.byte_compile(outfiles)

    # -- Top-level worker functions ------------------------------------
    # (called from 'run()')

    def build(self):
        if not self.skip_build:
            if self.distribution.has_pure_modules():
                self.run_command('build_py')
            if self.distribution.has_ext_modules():
                self.run_command('build_ext')

    def install(self):
        if os.path.isdir(self.build_dir):
            outfiles = self.copy_tree(self.build_dir, self.install_dir)
        else:
            self.warn("'%s' does not exist -- no Python modules to install" %
                      self.build_dir)
            return
        return outfiles

    def byte_compile(self, files):
        if sys.dont_write_bytecode:
            self.warn('byte-compiling is disabled, skipping.')
            return

        from distutils.util import byte_compile

        # Get the "--root" directory supplied to the "install" command,
        # and use it as a prefix to strip off the purported filename
        # encoded in bytecode files.  This is far from complete, but it
        # should at least generate usable bytecode in RPM distributions.
        install_root = self.get_finalized_command('install').root

        if self.compile:
            byte_compile(files, optimize=0,
                         force=self.force, prefix=install_root,
                         dry_run=self.dry_run)
        if self.optimize > 0:
            byte_compile(files, optimize=self.optimize,
                         force=self.force, prefix=install_root,
                         verbose=self.verbose, dry_run=self.dry_run)


    # -- Utility methods -----------------------------------------------

    def _mutate_outputs(self, has_any, build_cmd, cmd_option, output_dir):
        if not has_any:
            return []

        build_cmd = self.get_finalized_command(build_cmd)
        build_files = build_cmd.get_outputs()
        build_dir = getattr(build_cmd, cmd_option)

        prefix_len = len(build_dir) + len(os.sep)
        outputs = []
        for file in build_files:
            outputs.append(os.path.join(output_dir, file[prefix_len:]))

        return outputs

    def _bytecode_filenames(self, py_filenames):
        bytecode_files = []
        for py_file in py_filenames:
            # Since build_py handles package data installation, the
            # list of outputs can contain more than just .py files.
            # Make sure we only report bytecode for the .py files.
            ext = os.path.splitext(os.path.normcase(py_file))[1]
            if ext != PYTHON_SOURCE_EXTENSION:
                continue
            if self.compile:
                bytecode_files.append(py_file + "c")
            if self.optimize > 0:
                bytecode_files.append(py_file + "o")

        return bytecode_files


    # -- External interface --------------------------------------------
    # (called by outsiders)

    def get_outputs(self):
        """Return the list of files that would be installed if this command
        were actually run.  Not affected by the "dry-run" flag or whether
        modules have actually been built yet.
        """
        pure_outputs = \
            self._mutate_outputs(self.distribution.has_pure_modules(),
                                 'build_py', 'build_lib',
                                 self.install_dir)
        if self.compile:
            bytecode_outputs = self._bytecode_filenames(pure_outputs)
        else:
            bytecode_outputs = []

        ext_outputs = \
            self._mutate_outputs(self.distribution.has_ext_modules(),
                                 'build_ext', 'build_lib',
                                 self.install_dir)

        return pure_outputs + bytecode_outputs + ext_outputs

    def get_inputs(self):
        """Get the list of files that are input to this command, ie. the
        files that get installed as they are named in the build tree.
        The files in this list correspond one-to-one to the output
        filenames returned by 'get_outputs()'.
        """
        inputs = []

        if self.distribution.has_pure_modules():
            build_py = self.get_finalized_command('build_py')
            inputs.extend(build_py.get_outputs())

        if self.distribution.has_ext_modules():
            build_ext = self.get_finalized_command('build_ext')
            inputs.extend(build_ext.get_outputs())

        return inputs
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              Û
”´[c           @   sÉ   d  Z  d Z d d l Z d d l Z d d l m Z d d l m Z e e d É rc e j	 d Z
 n d Z
 d	 e f d
 Ñ  É  YZ d S(   sk   distutils.command.install_lib

Implements the Distutils 'install_lib' command
(install all Python modules).s   $Id$iˇˇˇˇN(   t   Command(   t   DistutilsOptionErrort   extsept   pys   .pyt   install_libc        	   B   sü   e  Z d  Z d d d  d! d# d$ d% g Z d d
 d g Z i d
 d 6Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(&   s7   install all Python modules (extensions and pure Python)s   install-dir=t   ds   directory to install tos
   build-dir=t   bs'   build directory (where to install from)t   forcet   fs-   force installation (overwrite existing files)t   compilet   cs   compile .py to .pyc [default]s
   no-compiles   don't compile .py filess	   optimize=t   Osl   also compile with optimization: -O1 for "python -O", -O2 for "python -OO", and -O0 to disable [default: -O0]s
   skip-builds   skip the build stepsc         C   s:   d  |  _ d  |  _ d |  _ d  |  _ d  |  _ d  |  _ d  S(   Ni    (   t   Nonet   install_dirt	   build_dirR   R	   t   optimizet
   skip_build(   t   self(    (    s3   /usr/lib/python2.7/distutils/command/install_lib.pyt   initialize_options7   s    					c      	   C   sø   |  j  d d d d d d d É |  j d  k r: d
 |  _ n  |  j d  k rU d |  _ n  t |  j t É sª y. t |  j É |  _ |  j d k rî t Ç n  Wqª t t f k
 r∑ t d Ç qª Xn  d  S(   Nt   installt	   build_libR   R   R   R   R	   R   R   i   i    i   s   optimize must be 0, 1, or 2(   R   R   (   R   R   (   R   R   (   R	   R	   (   R   R   (   R   R   (   i    i   i   (	   t   set_undefined_optionsR	   R   R   t
   isinstancet   intt   AssertionErrort
   ValueErrorR   (   R   (    (    s3   /usr/lib/python2.7/distutils/command/install_lib.pyt   finalize_options@   s$    	c         C   sE   |  j  É  |  j É  } | d  k	 rA |  j j É  rA |  j | É n  d  S(   N(   t   buildR   R   t   distributiont   has_pure_modulest   byte_compile(   R   t   outfiles(    (    s3   /usr/lib/python2.7/distutils/command/install_lib.pyt   runZ   s    
c         C   sN   |  j  sJ |  j j É  r( |  j d É n  |  j j É  rJ |  j d É qJ n  d  S(   Nt   build_pyt	   build_ext(   R   R   R   t   run_commandt   has_ext_modules(   R   (    (    s3   /usr/lib/python2.7/distutils/command/install_lib.pyR   j   s
    	c         C   sL   t  j j |  j É r0 |  j |  j |  j É } n |  j d |  j É d  S| S(   Ns3   '%s' does not exist -- no Python modules to install(   t   ost   patht   isdirR   t	   copy_treeR   t   warn(   R   R   (    (    s3   /usr/lib/python2.7/distutils/command/install_lib.pyR   q   s    	c         C   s∫   t  j r |  j d É d  Sd d l m } |  j d É j } |  j rp | | d d d |  j d | d	 |  j	 Én  |  j
 d k r∂ | | d |  j
 d |  j d | d
 |  j d	 |  j	 Én  d  S(   Ns%   byte-compiling is disabled, skipping.iˇˇˇˇ(   R   R   R   i    R   t   prefixt   dry_runt   verbose(   t   syst   dont_write_bytecodeR)   t   distutils.utilR   t   get_finalized_commandt   rootR	   R   R+   R   R,   (   R   t   filesR   t   install_root(    (    s3   /usr/lib/python2.7/distutils/command/install_lib.pyR   z   s    		c   
      C   sà   | s
 g  S|  j  | É } | j É  } t | | É } t | É t t j É } g  } x. | D]& }	 | j t j j | |	 | É É qZ W| S(   N(	   R0   t   get_outputst   getattrt   lenR%   t   sept   appendR&   t   join(
   R   t   has_anyt	   build_cmdt
   cmd_optiont
   output_dirt   build_filesR   t
   prefix_lent   outputst   file(    (    s3   /usr/lib/python2.7/distutils/command/install_lib.pyt   _mutate_outputsì   s    $c         C   sè   g  } xÇ | D]z } t  j j t  j j | É É d } | t k rG q n  |  j rd | j | d É n  |  j d k r | j | d É q q W| S(   Ni   R
   i    t   o(   R%   R&   t   splitextt   normcaset   PYTHON_SOURCE_EXTENSIONR	   R8   R   (   R   t   py_filenamest   bytecode_filest   py_filet   ext(    (    s3   /usr/lib/python2.7/distutils/command/install_lib.pyt   _bytecode_filenames¢   s    "	c         C   su   |  j  |  j j É  d d |  j É } |  j r? |  j | É } n g  } |  j  |  j j É  d d |  j É } | | | S(   s¡   Return the list of files that would be installed if this command
        were actually run.  Not affected by the "dry-run" flag or whether
        modules have actually been built yet.
        R!   R   R"   (   RB   R   R   R   R	   RK   R$   (   R   t   pure_outputst   bytecode_outputst   ext_outputs(    (    s3   /usr/lib/python2.7/distutils/command/install_lib.pyR4   ∂   s    	c         C   sr   g  } |  j  j É  r: |  j d É } | j | j É  É n  |  j  j É  rn |  j d É } | j | j É  É n  | S(   s˛   Get the list of files that are input to this command, ie. the
        files that get installed as they are named in the build tree.
        The files in this list correspond one-to-one to the output
        filenames returned by 'get_outputs()'.
        R!   R"   (   R   R   R0   t   extendR4   R$   (   R   t   inputsR!   R"   (    (    s3   /usr/lib/python2.7/distutils/command/install_lib.pyt
   get_inputsÀ   s    (   s   install-dir=R   s   directory to install to(   s
   build-dir=R   s'   build directory (where to install from)(   R   R   s-   force installation (overwrite existing files)(   R	   R
   s   compile .py to .pyc [default]N(   s
   no-compileNs   don't compile .py files(   s	   optimize=R   sl   also compile with optimization: -O1 for "python -O", -O2 for "python -OO", and -O0 to disable [default: -O0](   s
   skip-buildNs   skip the build steps(   t   __name__t
   __module__t   descriptionR   t   user_optionst   boolean_optionst   negative_optR   R   R    R   R   R   RB   RK   R4   RQ   (    (    (    s3   /usr/lib/python2.7/distutils/command/install_lib.pyR      s*    												(   t   __doc__t   __revision__R%   R-   t   distutils.coreR    t   distutils.errorsR   t   hasattrR   RF   R   (    (    (    s3   /usr/lib/python2.7/distutils/command/install_lib.pyt   <module>   s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  """distutils.command.install_scripts

Implements the Distutils 'install_scripts' command, for installing
Python scripts."""

# contributed by Bastian Kleineidam

__revision__ = "$Id$"

import os
from distutils.core import Command
from distutils import log
from stat import ST_MODE

class install_scripts (Command):

    description = "install scripts (Python or otherwise)"

    user_options = [
        ('install-dir=', 'd', "directory to install scripts to"),
        ('build-dir=','b', "build directory (where to install from)"),
        ('force', 'f', "force installation (overwrite existing files)"),
        ('skip-build', None, "skip the build steps"),
    ]

    boolean_options = ['force', 'skip-build']


    def initialize_options (self):
        self.install_dir = None
        self.force = 0
        self.build_dir = None
        self.skip_build = None

    def finalize_options (self):
        self.set_undefined_options('build', ('build_scripts', 'build_dir'))
        self.set_undefined_options('install',
                                   ('install_scripts', 'install_dir'),
                                   ('force', 'force'),
                                   ('skip_build', 'skip_build'),
                                  )

    def run (self):
        if not self.skip_build:
            self.run_command('build_scripts')
        self.outfiles = self.copy_tree(self.build_dir, self.install_dir)
        if os.name == 'posix':
            # Set the executable bits (owner, group, and world) on
            # all the scripts we just installed.
            for file in self.get_outputs():
                if self.dry_run:
                    log.info("changing mode of %s", file)
                else:
                    mode = ((os.stat(file)[ST_MODE]) | 0555) & 07777
                    log.info("changing mode of %s to %o", file, mode)
                    os.chmod(file, mode)

    def get_inputs (self):
        return self.distribution.scripts or []

    def get_outputs(self):
        return self.outfiles or []

# class install_scripts
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Û
”´[c           @   sb   d  Z  d Z d d l Z d d l m Z d d l m Z d d l m Z d e f d Ñ  É  YZ	 d S(	   su   distutils.command.install_scripts

Implements the Distutils 'install_scripts' command, for installing
Python scripts.s   $Id$iˇˇˇˇN(   t   Command(   t   log(   t   ST_MODEt   install_scriptsc           B   sY   e  Z d  Z d d d d g Z d d
 g Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 RS(   s%   install scripts (Python or otherwise)s   install-dir=t   ds   directory to install scripts tos
   build-dir=t   bs'   build directory (where to install from)t   forcet   fs-   force installation (overwrite existing files)s
   skip-builds   skip the build stepsc         C   s(   d  |  _ d |  _ d  |  _ d  |  _ d  S(   Ni    (   t   Nonet   install_dirR   t	   build_dirt
   skip_build(   t   self(    (    s7   /usr/lib/python2.7/distutils/command/install_scripts.pyt   initialize_options   s    			c         C   s*   |  j  d d	 É |  j  d d
 d d É d  S(   Nt   buildt   build_scriptsR
   t   installR   R	   R   R   (   R   R
   (   R   R	   (   R   R   (   R   R   (   t   set_undefined_options(   R   (    (    s7   /usr/lib/python2.7/distutils/command/install_scripts.pyt   finalize_options#   s
    	c         C   sª   |  j  s |  j d É n  |  j |  j |  j É |  _ t j d k r∑ xq |  j É  D]` } |  j	 rr t
 j d | É qP t j | É t d Bd @} t
 j d | | É t j | | É qP Wn  d  S(   NR   t   posixs   changing mode of %sim  iˇ  s   changing mode of %s to %o(   R   t   run_commandt	   copy_treeR
   R	   t   outfilest   ost   namet   get_outputst   dry_runR   t   infot   statR   t   chmod(   R   t   filet   mode(    (    s7   /usr/lib/python2.7/distutils/command/install_scripts.pyt   run+   s    		c         C   s   |  j  j p g  S(   N(   t   distributiont   scripts(   R   (    (    s7   /usr/lib/python2.7/distutils/command/install_scripts.pyt
   get_inputs:   s    c         C   s   |  j  p g  S(   N(   R   (   R   (    (    s7   /usr/lib/python2.7/distutils/command/install_scripts.pyR   =   s    (   s   install-dir=R   s   directory to install scripts to(   s
   build-dir=R   s'   build directory (where to install from)(   R   R   s-   force installation (overwrite existing files)N(   s
   skip-buildNs   skip the build steps(   t   __name__t
   __module__t   descriptionR   t   user_optionst   boolean_optionsR   R   R    R#   R   (    (    (    s7   /usr/lib/python2.7/distutils/command/install_scripts.pyR      s   					(
   t   __doc__t   __revision__R   t   distutils.coreR    t	   distutilsR   R   R   R   (    (    (    s7   /usr/lib/python2.7/distutils/command/install_scripts.pyt   <module>   s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 """distutils.command.register

Implements the Distutils 'register' command (register with the repository).
"""

# created 2002/10/21, Richard Jones

__revision__ = "$Id$"

import urllib2
import getpass
import urlparse
from warnings import warn

from distutils.core import PyPIRCCommand
from distutils import log

class register(PyPIRCCommand):

    description = ("register the distribution with the Python package index")
    user_options = PyPIRCCommand.user_options + [
        ('list-classifiers', None,
         'list the valid Trove classifiers'),
        ('strict', None ,
         'Will stop the registering if the meta-data are not fully compliant')
        ]
    boolean_options = PyPIRCCommand.boolean_options + [
        'verify', 'list-classifiers', 'strict']

    sub_commands = [('check', lambda self: True)]

    def initialize_options(self):
        PyPIRCCommand.initialize_options(self)
        self.list_classifiers = 0
        self.strict = 0

    def finalize_options(self):
        PyPIRCCommand.finalize_options(self)
        # setting options for the `check` subcommand
        check_options = {'strict': ('register', self.strict),
                         'restructuredtext': ('register', 1)}
        self.distribution.command_options['check'] = check_options

    def run(self):
        self.finalize_options()
        self._set_config()

        # Run sub commands
        for cmd_name in self.get_sub_commands():
            self.run_command(cmd_name)

        if self.dry_run:
            self.verify_metadata()
        elif self.list_classifiers:
            self.classifiers()
        else:
            self.send_metadata()

    def check_metadata(self):
        """Deprecated API."""
        warn("distutils.command.register.check_metadata is deprecated, \
              use the check command instead", PendingDeprecationWarning)
        check = self.distribution.get_command_obj('check')
        check.ensure_finalized()
        check.strict = self.strict
        check.restructuredtext = 1
        check.run()

    def _set_config(self):
        ''' Reads the configuration file and set attributes.
        '''
        config = self._read_pypirc()
        if config != {}:
            self.username = config['username']
            self.password = config['password']
            self.repository = config['repository']
            self.realm = config['realm']
            self.has_config = True
        else:
            if self.repository not in ('pypi', self.DEFAULT_REPOSITORY):
                raise ValueError('%s not found in .pypirc' % self.repository)
            if self.repository == 'pypi':
                self.repository = self.DEFAULT_REPOSITORY
            self.has_config = False

    def classifiers(self):
        ''' Fetch the list of classifiers from the server.
        '''
        response = urllib2.urlopen(self.repository+'?:action=list_classifiers')
        log.info(response.read())

    def verify_metadata(self):
        ''' Send the metadata to the package index server to be checked.
        '''
        # send the info to the server and report the result
        (code, result) = self.post_to_server(self.build_post_data('verify'))
        log.info('Server response (%s): %s' % (code, result))


    def send_metadata(self):
        ''' Send the metadata to the package index server.

            Well, do the following:
            1. figure who the user is, and then
            2. send the data as a Basic auth'ed POST.

            First we try to read the username/password from $HOME/.pypirc,
            which is a ConfigParser-formatted file with a section
            [distutils] containing username and password entries (both
            in clear text). Eg:

                [distutils]
                index-servers =
                    pypi

                [pypi]
                username: fred
                password: sekrit

            Otherwise, to figure who the user is, we offer the user three
            choices:

             1. use existing login,
             2. register as a new user, or
             3. set the password to a random string and email the user.

        '''
        # see if we can short-cut and get the username/password from the
        # config
        if self.has_config:
            choice = '1'
            username = self.username
            password = self.password
        else:
            choice = 'x'
            username = password = ''

        # get the user's login info
        choices = '1 2 3 4'.split()
        while choice not in choices:
            self.announce('''\
We need to know who you are, so please choose either:
 1. use your existing login,
 2. register as a new user,
 3. have the server generate a new password for you (and email it to you), or
 4. quit
Your selection [default 1]: ''', log.INFO)

            choice = raw_input()
            if not choice:
                choice = '1'
            elif choice not in choices:
                print 'Please choose one of the four options!'

        if choice == '1':
            # get the username and password
            while not username:
                username = raw_input('Username: ')
            while not password:
                password = getpass.getpass('Password: ')

            # set up the authentication
            auth = urllib2.HTTPPasswordMgr()
            host = urlparse.urlparse(self.repository)[1]
            auth.add_password(self.realm, host, username, password)
            # send the info to the server and report the result
            code, result = self.post_to_server(self.build_post_data('submit'),
                auth)
            self.announce('Server response (%s): %s' % (code, result),
                          log.INFO)

            # possibly save the login
            if code == 200:
                if self.has_config:
                    # sharing the password in the distribution instance
                    # so the upload command can reuse it
                    self.distribution.password = password
                else:
                    self.announce(('I can store your PyPI login so future '
                                   'submissions will be faster.'), log.INFO)
                    self.announce('(the login will be stored in %s)' % \
                                  self._get_rc_file(), log.INFO)
                    choice = 'X'
                    while choice.lower() not in 'yn':
                        choice = raw_input('Save your login (y/N)?')
                        if not choice:
                            choice = 'n'
                    if choice.lower() == 'y':
                        self._store_pypirc(username, password)

        elif choice == '2':
            data = {':action': 'user'}
            data['name'] = data['password'] = data['email'] = ''
            data['confirm'] = None
            while not data['name']:
                data['name'] = raw_input('Username: ')
            while data['password'] != data['confirm']:
                while not data['password']:
                    data['password'] = getpass.getpass('Password: ')
                while not data['confirm']:
                    data['confirm'] = getpass.getpass(' Confirm: ')
                if data['password'] != data['confirm']:
                    data['password'] = ''
                    data['confirm'] = None
                    print "Password and confirm don't match!"
            while not data['email']:
                data['email'] = raw_input('   EMail: ')
            code, result = self.post_to_server(data)
            if code != 200:
                log.info('Server response (%s): %s' % (code, result))
            else:
                log.info('You will receive an email shortly.')
                log.info(('Follow the instructions in it to '
                          'complete registration.'))
        elif choice == '3':
            data = {':action': 'password_reset'}
            data['email'] = ''
            while not data['email']:
                data['email'] = raw_input('Your email address: ')
            code, result = self.post_to_server(data)
            log.info('Server response (%s): %s' % (code, result))

    def build_post_data(self, action):
        # figure the data to send - the metadata plus some additional
        # information used by the package server
        meta = self.distribution.metadata
        data = {
            ':action': action,
            'metadata_version' : '1.0',
            'name': meta.get_name(),
            'version': meta.get_version(),
            'summary': meta.get_description(),
            'home_page': meta.get_url(),
            'author': meta.get_contact(),
            'author_email': meta.get_contact_email(),
            'license': meta.get_licence(),
            'description': meta.get_long_description(),
            'keywords': meta.get_keywords(),
            'platform': meta.get_platforms(),
            'classifiers': meta.get_classifiers(),
            'download_url': meta.get_download_url(),
            # PEP 314
            'provides': meta.get_provides(),
            'requires': meta.get_requires(),
            'obsoletes': meta.get_obsoletes(),
        }
        if data['provides'] or data['requires'] or data['obsoletes']:
            data['metadata_version'] = '1.1'
        return data

    def post_to_server(self, data, auth=None):
        ''' Post a query to the server, and return a string response.
        '''
        if 'name' in data:
            self.announce('Registering %s to %s' % (data['name'],
                                                   self.repository),
                                                   log.INFO)
        # Build up the MIME payload for the urllib2 POST data
        boundary = '--------------GHSKFJDLGDS7543FJKLFHRE75642756743254'
        sep_boundary = '\n--' + boundary
        end_boundary = sep_boundary + '--'
        chunks = []
        for key, value in data.items():
            # handle multiple entries for the same name
            if type(value) not in (type([]), type( () )):
                value = [value]
            for value in value:
                chunks.append(sep_boundary)
                chunks.append('\nContent-Disposition: form-data; name="%s"'%key)
                chunks.append("\n\n")
                chunks.append(value)
                if value and value[-1] == '\r':
                    chunks.append('\n')  # write an extra newline (lurve Macs)
        chunks.append(end_boundary)
        chunks.append("\n")

        # chunks may be bytes (str) or unicode objects that we need to encode
        body = []
        for chunk in chunks:
            if isinstance(chunk, unicode):
                body.append(chunk.encode('utf-8'))
            else:
                body.append(chunk)

        body = ''.join(body)

        # build the Request
        headers = {
            'Content-type': 'multipart/form-data; boundary=%s; charset=utf-8'%boundary,
            'Content-length': str(len(body))
        }
        req = urllib2.Request(self.repository, body, headers)

        # handle HTTP and include the Basic Auth handler
        opener = urllib2.build_opener(
            urllib2.HTTPBasicAuthHandler(password_mgr=auth)
        )
        data = ''
        try:
            result = opener.open(req)
        except urllib2.HTTPError, e:
            if self.show_response:
                data = e.fp.read()
            result = e.code, e.msg
        except urllib2.URLError, e:
            result = 500, str(e)
        else:
            if self.show_response:
                data = result.read()
            result = 200, 'OK'
        if self.show_response:
            dashes = '-' * 75
            self.announce('%s%s%s' % (dashes, data, dashes))

        return result
                                                                                                                                                                                                                                                                                                                                                                                                                                                                 Û
”´[c           @   sz   d  Z  d Z d d l Z d d l Z d d l Z d d l m Z d d l m Z d d l	 m
 Z
 d e f d Ñ  É  YZ d S(	   sh   distutils.command.register

Implements the Distutils 'register' command (register with the repository).
s   $Id$iˇˇˇˇN(   t   warn(   t   PyPIRCCommand(   t   logt   registerc           B   s¶   e  Z d  Z e j d d g Z e j d d d g Z d d Ñ  f g Z d Ñ  Z d	 Ñ  Z	 d
 Ñ  Z
 d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d d Ñ Z RS(   s7   register the distribution with the Python package indexs   list-classifierss    list the valid Trove classifierst   strictsB   Will stop the registering if the meta-data are not fully compliantt   verifyt   checkc         C   s   t  S(   N(   t   True(   t   self(    (    s0   /usr/lib/python2.7/distutils/command/register.pyt   <lambda>   s    c         C   s#   t  j |  É d |  _ d |  _ d  S(   Ni    (   R   t   initialize_optionst   list_classifiersR   (   R   (    (    s0   /usr/lib/python2.7/distutils/command/register.pyR
       s    	c         C   s>   t  j |  É i d |  j f d 6d d 6} | |  j j d <d  S(   NR   R   i   t   restructuredtextR   (   R   i   (   R   t   finalize_optionsR   t   distributiont   command_options(   R   t   check_options(    (    s0   /usr/lib/python2.7/distutils/command/register.pyR   %   s    
c         C   sr   |  j  É  |  j É  x! |  j É  D] } |  j | É q! W|  j rN |  j É  n  |  j rd |  j É  n
 |  j É  d  S(   N(	   R   t   _set_configt   get_sub_commandst   run_commandt   dry_runt   verify_metadataR   t   classifierst   send_metadata(   R   t   cmd_name(    (    s0   /usr/lib/python2.7/distutils/command/register.pyt   run,   s    

		c         C   sL   t  d t É |  j j d É } | j É  |  j | _ d | _ | j É  d S(   s   Deprecated API.sd   distutils.command.register.check_metadata is deprecated,               use the check command insteadR   i   N(   R    t   PendingDeprecationWarningR   t   get_command_objt   ensure_finalizedR   R   R   (   R   R   (    (    s0   /usr/lib/python2.7/distutils/command/register.pyt   check_metadata;   s    

	c         C   s±   |  j  É  } | i  k rX | d |  _ | d |  _ | d |  _ | d |  _ t |  _ nU |  j d |  j f k rÜ t d |  j É Ç n  |  j d k r§ |  j |  _ n  t	 |  _ d S(   s:    Reads the configuration file and set attributes.
        t   usernamet   passwordt
   repositoryt   realmt   pypis   %s not found in .pypircN(
   t   _read_pypircR   R   R    R!   R   t
   has_configt   DEFAULT_REPOSITORYt
   ValueErrort   False(   R   t   config(    (    s0   /usr/lib/python2.7/distutils/command/register.pyR   E   s    c         C   s-   t  j |  j d É } t j | j É  É d S(   s8    Fetch the list of classifiers from the server.
        s   ?:action=list_classifiersN(   t   urllib2t   urlopenR    R   t   infot   read(   R   t   response(    (    s0   /usr/lib/python2.7/distutils/command/register.pyR   V   s    c         C   s9   |  j  |  j d É É \ } } t j d | | f É d S(   sF    Send the metadata to the package index server to be checked.
        R   s   Server response (%s): %sN(   t   post_to_servert   build_post_dataR   R+   (   R   t   codet   result(    (    s0   /usr/lib/python2.7/distutils/command/register.pyR   \   s    c   
      C   sÊ  |  j  r$ d } |  j } |  j } n d } d } } d j É  } xO | | k rë |  j d t j É t É  } | sz d } qC | | k rC d GHqC qC W| d k rx | s∂ t d É } q° Wx | s“ t j d É } q∫ Wt	 j
 É  } t j |  j É d	 } | j |  j | | | É |  j |  j d
 É | É \ } } |  j d | | f t j É | d k r‚|  j  rp| |  j _ q|  j d t j É |  j d |  j É  t j É d } x1 | j É  d k rŸt d É } | s©d } q©q©W| j É  d k r|  j | | É qq‚n›| d k roi d d 6}	 d |	 d <|	 d <|	 d <d# |	 d <x |	 d sbt d É |	 d <qEWxê |	 d |	 d k rıx! |	 d sùt j d É |	 d <q}Wx! |	 d s¡t j d É |	 d <q°W|	 d |	 d k rfd |	 d <d# |	 d <d GHqfqfWx |	 d st d É |	 d <q˘W|  j |	 É \ } } | d k rRt j d | | f É q‚t j d É t j d É ns | d  k r‚i d! d 6}	 d |	 d <x |	 d s≤t d" É |	 d <qïW|  j |	 É \ } } t j d | | f É n  d# S($   s_   Send the metadata to the package index server.

            Well, do the following:
            1. figure who the user is, and then
            2. send the data as a Basic auth'ed POST.

            First we try to read the username/password from $HOME/.pypirc,
            which is a ConfigParser-formatted file with a section
            [distutils] containing username and password entries (both
            in clear text). Eg:

                [distutils]
                index-servers =
                    pypi

                [pypi]
                username: fred
                password: sekrit

            Otherwise, to figure who the user is, we offer the user three
            choices:

             1. use existing login,
             2. register as a new user, or
             3. set the password to a random string and email the user.

        t   1t   xt    s   1 2 3 4s‚   We need to know who you are, so please choose either:
 1. use your existing login,
 2. register as a new user,
 3. have the server generate a new password for you (and email it to you), or
 4. quit
Your selection [default 1]: s&   Please choose one of the four options!s
   Username: s
   Password: i   t   submits   Server response (%s): %si»   sA   I can store your PyPI login so future submissions will be faster.s    (the login will be stored in %s)t   Xt   yns   Save your login (y/N)?t   nt   yt   2t   users   :actiont   nameR   t   emailt   confirms
    Confirm: s!   Password and confirm don't match!s
      EMail: s"   You will receive an email shortly.s7   Follow the instructions in it to complete registration.t   3t   password_resets   Your email address: N(   R$   R   R   t   splitt   announceR   t   INFOt	   raw_inputt   getpassR)   t   HTTPPasswordMgrt   urlparseR    t   add_passwordR!   R.   R/   R   t   _get_rc_filet   lowert   _store_pypirct   NoneR+   (
   R   t   choiceR   R   t   choicest   autht   hostR0   R1   t   data(    (    s0   /usr/lib/python2.7/distutils/command/register.pyR   d   så    		
				
		
	



c         C   s  |  j  j } i | d 6d d 6| j É  d 6| j É  d 6| j É  d 6| j É  d 6| j É  d 6| j É  d	 6| j É  d
 6| j	 É  d 6| j
 É  d 6| j É  d 6| j É  d 6| j É  d 6| j É  d 6| j É  d 6| j É  d 6} | d s| d s| d rd | d <n  | S(   Ns   :actions   1.0t   metadata_versionR<   t   versiont   summaryt	   home_paget   authort   author_emailt   licenset   descriptiont   keywordst   platformR   t   download_urlt   providest   requirest	   obsoletess   1.1(   R   t   metadatat   get_namet   get_versiont   get_descriptiont   get_urlt   get_contactt   get_contact_emailt   get_licencet   get_long_descriptiont   get_keywordst   get_platformst   get_classifierst   get_download_urlt   get_providest   get_requirest   get_obsoletes(   R   t   actiont   metaRQ   (    (    s0   /usr/lib/python2.7/distutils/command/register.pyR/   ﬂ   s,    c         C   s≥  d | k r3 |  j  d | d |  j f t j É n  d } d | } | d } g  } xπ | j É  D]´ \ } } t | É t g  É t d É f k rú | g } n  xl | D]d } | j | É | j d | É | j d É | j | É | r£ | d d	 k r£ | j d
 É q£ q£ Wq` W| j | É | j d
 É g  }	 xC | D]; }
 t |
 t É rd|	 j |
 j	 d É É q6|	 j |
 É q6Wd j
 |	 É }	 i d | d 6t t |	 É É d 6} t j |  j |	 | É } t j t j d | É É } d } y | j | É } Wnj t j k
 r9} |  j r$| j j É  } n  | j | j f } nF t j k
 r`} d t | É f } n X|  j ry| j É  } n  d } |  j rØd d } |  j  d | | | f É n  | S(   sC    Post a query to the server, and return a string response.
        R<   s   Registering %s to %ss3   --------------GHSKFJDLGDS7543FJKLFHRE75642756743254s   
--s   --s*   
Content-Disposition: form-data; name="%s"s   

iˇˇˇˇs   s   
s   utf-8R4   s/   multipart/form-data; boundary=%s; charset=utf-8s   Content-types   Content-lengtht   password_mgriÙ  i»   t   OKt   -iK   s   %s%s%s(    (   i»   Rs   (   RB   R    R   RC   t   itemst   typet   appendt
   isinstancet   unicodet   encodet   joint   strt   lenR)   t   Requestt   build_openert   HTTPBasicAuthHandlert   opent	   HTTPErrort   show_responset   fpR,   R0   t   msgt   URLError(   R   RQ   RO   t   boundaryt   sep_boundaryt   end_boundaryt   chunkst   keyt   valuet   bodyt   chunkt   headerst   reqt   openerR1   t   et   dashes(    (    s0   /usr/lib/python2.7/distutils/command/register.pyR.   ˚   s`    


$			
N(   s   list-classifiersNs    list the valid Trove classifiers(   R   NsB   Will stop the registering if the meta-data are not fully compliant(   t   __name__t
   __module__RY   R   t   user_optionsRL   t   boolean_optionst   sub_commandsR
   R   R   R   R   R   R   R   R/   R.   (    (    (    s0   /usr/lib/python2.7/distutils/command/register.pyR      s&     
				
				{	(   t   __doc__t   __revision__R)   RE   RG   t   warningsR    t   distutils.coreR   t	   distutilsR   R   (    (    (    s0   /usr/lib/python2.7/distutils/command/register.pyt   <module>   s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             """distutils.command.sdist

Implements the Distutils 'sdist' command (create a source distribution)."""

__revision__ = "$Id$"

import os
import string
import sys
from glob import glob
from warnings import warn

from distutils.core import Command
from distutils import dir_util, dep_util, file_util, archive_util
from distutils.text_file import TextFile
from distutils.errors import (DistutilsPlatformError, DistutilsOptionError,
                              DistutilsTemplateError)
from distutils.filelist import FileList
from distutils import log
from distutils.util import convert_path

def show_formats():
    """Print all possible values for the 'formats' option (used by
    the "--help-formats" command-line option).
    """
    from distutils.fancy_getopt import FancyGetopt
    from distutils.archive_util import ARCHIVE_FORMATS
    formats = []
    for format in ARCHIVE_FORMATS.keys():
        formats.append(("formats=" + format, None,
                        ARCHIVE_FORMATS[format][2]))
    formats.sort()
    FancyGetopt(formats).print_help(
        "List of available source distribution formats:")

class sdist(Command):

    description = "create a source distribution (tarball, zip file, etc.)"

    def checking_metadata(self):
        """Callable used for the check sub-command.

        Placed here so user_options can view it"""
        return self.metadata_check

    user_options = [
        ('template=', 't',
         "name of manifest template file [default: MANIFEST.in]"),
        ('manifest=', 'm',
         "name of manifest file [default: MANIFEST]"),
        ('use-defaults', None,
         "include the default file set in the manifest "
         "[default; disable with --no-defaults]"),
        ('no-defaults', None,
         "don't include the default file set"),
        ('prune', None,
         "specifically exclude files/directories that should not be "
         "distributed (build tree, RCS/CVS dirs, etc.) "
         "[default; disable with --no-prune]"),
        ('no-prune', None,
         "don't automatically exclude anything"),
        ('manifest-only', 'o',
         "just regenerate the manifest and then stop "
         "(implies --force-manifest)"),
        ('force-manifest', 'f',
         "forcibly regenerate the manifest and carry on as usual. "
         "Deprecated: now the manifest is always regenerated."),
        ('formats=', None,
         "formats for source distribution (comma-separated list)"),
        ('keep-temp', 'k',
         "keep the distribution tree around after creating " +
         "archive file(s)"),
        ('dist-dir=', 'd',
         "directory to put the source distribution archive(s) in "
         "[default: dist]"),
        ('metadata-check', None,
         "Ensure that all required elements of meta-data "
         "are supplied. Warn if any missing. [default]"),
        ('owner=', 'u',
         "Owner name used when creating a tar file [default: current user]"),
        ('group=', 'g',
         "Group name used when creating a tar file [default: current group]"),
        ]

    boolean_options = ['use-defaults', 'prune',
                       'manifest-only', 'force-manifest',
                       'keep-temp', 'metadata-check']

    help_options = [
        ('help-formats', None,
         "list available distribution formats", show_formats),
        ]

    negative_opt = {'no-defaults': 'use-defaults',
                    'no-prune': 'prune' }

    default_format = {'posix': 'gztar',
                      'nt': 'zip' }

    sub_commands = [('check', checking_metadata)]

    def initialize_options(self):
        # 'template' and 'manifest' are, respectively, the names of
        # the manifest template and manifest file.
        self.template = None
        self.manifest = None

        # 'use_defaults': if true, we will include the default file set
        # in the manifest
        self.use_defaults = 1
        self.prune = 1

        self.manifest_only = 0
        self.force_manifest = 0

        self.formats = None
        self.keep_temp = 0
        self.dist_dir = None

        self.archive_files = None
        self.metadata_check = 1
        self.owner = None
        self.group = None

    def finalize_options(self):
        if self.manifest is None:
            self.manifest = "MANIFEST"
        if self.template is None:
            self.template = "MANIFEST.in"

        self.ensure_string_list('formats')
        if self.formats is None:
            try:
                self.formats = [self.default_format[os.name]]
            except KeyError:
                raise DistutilsPlatformError, \
                      "don't know how to create source distributions " + \
                      "on platform %s" % os.name

        bad_format = archive_util.check_archive_formats(self.formats)
        if bad_format:
            raise DistutilsOptionError, \
                  "unknown archive format '%s'" % bad_format

        if self.dist_dir is None:
            self.dist_dir = "dist"

    def run(self):
        # 'filelist' contains the list of files that will make up the
        # manifest
        self.filelist = FileList()

        # Run sub commands
        for cmd_name in self.get_sub_commands():
            self.run_command(cmd_name)

        # Do whatever it takes to get the list of files to process
        # (process the manifest template, read an existing manifest,
        # whatever).  File list is accumulated in 'self.filelist'.
        self.get_file_list()

        # If user just wanted us to regenerate the manifest, stop now.
        if self.manifest_only:
            return

        # Otherwise, go ahead and create the source distribution tarball,
        # or zipfile, or whatever.
        self.make_distribution()

    def check_metadata(self):
        """Deprecated API."""
        warn("distutils.command.sdist.check_metadata is deprecated, \
              use the check command instead", PendingDeprecationWarning)
        check = self.distribution.get_command_obj('check')
        check.ensure_finalized()
        check.run()

    def get_file_list(self):
        """Figure out the list of files to include in the source
        distribution, and put it in 'self.filelist'.  This might involve
        reading the manifest template (and writing the manifest), or just
        reading the manifest, or just using the default file set -- it all
        depends on the user's options.
        """
        # new behavior when using a template:
        # the file list is recalculated every time because
        # even if MANIFEST.in or setup.py are not changed
        # the user might have added some files in the tree that
        # need to be included.
        #
        #  This makes --force the default and only behavior with templates.
        template_exists = os.path.isfile(self.template)
        if not template_exists and self._manifest_is_not_generated():
            self.read_manifest()
            self.filelist.sort()
            self.filelist.remove_duplicates()
            return

        if not template_exists:
            self.warn(("manifest template '%s' does not exist " +
                        "(using default file list)") %
                        self.template)
        self.filelist.findall()

        if self.use_defaults:
            self.add_defaults()

        if template_exists:
            self.read_template()

        if self.prune:
            self.prune_file_list()

        self.filelist.sort()
        self.filelist.remove_duplicates()
        self.write_manifest()

    def add_defaults(self):
        """Add all the default files to self.filelist:
          - README or README.txt
          - setup.py
          - test/test*.py
          - all pure Python modules mentioned in setup script
          - all files pointed by package_data (build_py)
          - all files defined in data_files.
          - all files defined as scripts.
          - all C sources listed as part of extensions or C libraries
            in the setup script (doesn't catch C headers!)
        Warns if (README or README.txt) or setup.py are missing; everything
        else is optional.
        """

        standards = [('README', 'README.txt'), self.distribution.script_name]
        for fn in standards:
            if isinstance(fn, tuple):
                alts = fn
                got_it = 0
                for fn in alts:
                    if os.path.exists(fn):
                        got_it = 1
                        self.filelist.append(fn)
                        break

                if not got_it:
                    self.warn("standard file not found: should have one of " +
                              string.join(alts, ', '))
            else:
                if os.path.exists(fn):
                    self.filelist.append(fn)
                else:
                    self.warn("standard file '%s' not found" % fn)

        optional = ['test/test*.py', 'setup.cfg']
        for pattern in optional:
            files = filter(os.path.isfile, glob(pattern))
            if files:
                self.filelist.extend(files)

        # build_py is used to get:
        #  - python modules
        #  - files defined in package_data
        build_py = self.get_finalized_command('build_py')

        # getting python files
        if self.distribution.has_pure_modules():
            self.filelist.extend(build_py.get_source_files())

        # getting package_data files
        # (computed in build_py.data_files by build_py.finalize_options)
        for pkg, src_dir, build_dir, filenames in build_py.data_files:
            for filename in filenames:
                self.filelist.append(os.path.join(src_dir, filename))

        # getting distribution.data_files
        if self.distribution.has_data_files():
            for item in self.distribution.data_files:
                if isinstance(item, str): # plain file
                    item = convert_path(item)
                    if os.path.isfile(item):
                        self.filelist.append(item)
                else:    # a (dirname, filenames) tuple
                    dirname, filenames = item
                    for f in filenames:
                        f = convert_path(f)
                        if os.path.isfile(f):
                            self.filelist.append(f)

        if self.distribution.has_ext_modules():
            build_ext = self.get_finalized_command('build_ext')
            self.filelist.extend(build_ext.get_source_files())

        if self.distribution.has_c_libraries():
            build_clib = self.get_finalized_command('build_clib')
            self.filelist.extend(build_clib.get_source_files())

        if self.distribution.has_scripts():
            build_scripts = self.get_finalized_command('build_scripts')
            self.filelist.extend(build_scripts.get_source_files())

    def read_template(self):
        """Read and parse manifest template file named by self.template.

        (usually "MANIFEST.in") The parsing and processing is done by
        'self.filelist', which updates itself accordingly.
        """
        log.info("reading manifest template '%s'", self.template)
        template = TextFile(self.template,
                            strip_comments=1,
                            skip_blanks=1,
                            join_lines=1,
                            lstrip_ws=1,
                            rstrip_ws=1,
                            collapse_join=1)

        try:
            while 1:
                line = template.readline()
                if line is None:            # end of file
                    break

                try:
                    self.filelist.process_template_line(line)
                # the call above can raise a DistutilsTemplateError for
                # malformed lines, or a ValueError from the lower-level
                # convert_path function
                except (DistutilsTemplateError, ValueError) as msg:
                    self.warn("%s, line %d: %s" % (template.filename,
                                                   template.current_line,
                                                   msg))
        finally:
            template.close()

    def prune_file_list(self):
        """Prune off branches that might slip into the file list as created
        by 'read_template()', but really don't belong there:
          * the build tree (typically "build")
          * the release tree itself (only an issue if we ran "sdist"
            previously with --keep-temp, or it aborted)
          * any RCS, CVS, .svn, .hg, .git, .bzr, _darcs directories
        """
        build = self.get_finalized_command('build')
        base_dir = self.distribution.get_fullname()

        self.filelist.exclude_pattern(None, prefix=build.build_base)
        self.filelist.exclude_pattern(None, prefix=base_dir)

        # pruning out vcs directories
        # both separators are used under win32
        if sys.platform == 'win32':
            seps = r'/|\\'
        else:
            seps = '/'

        vcs_dirs = ['RCS', 'CVS', r'\.svn', r'\.hg', r'\.git', r'\.bzr',
                    '_darcs']
        vcs_ptrn = r'(^|%s)(%s)(%s).*' % (seps, '|'.join(vcs_dirs), seps)
        self.filelist.exclude_pattern(vcs_ptrn, is_regex=1)

    def write_manifest(self):
        """Write the file list in 'self.filelist' (presumably as filled in
        by 'add_defaults()' and 'read_template()') to the manifest file
        named by 'self.manifest'.
        """
        if self._manifest_is_not_generated():
            log.info("not writing to manually maintained "
                     "manifest file '%s'" % self.manifest)
            return

        content = self.filelist.files[:]
        content.insert(0, '# file GENERATED by distutils, do NOT edit')
        self.execute(file_util.write_file, (self.manifest, content),
                     "writing manifest file '%s'" % self.manifest)

    def _manifest_is_not_generated(self):
        # check for special comment used in 2.7.1 and higher
        if not os.path.isfile(self.manifest):
            return False

        fp = open(self.manifest, 'rU')
        try:
            first_line = fp.readline()
        finally:
            fp.close()
        return first_line != '# file GENERATED by distutils, do NOT edit\n'

    def read_manifest(self):
        """Read the manifest file (named by 'self.manifest') and use it to
        fill in 'self.filelist', the list of files to include in the source
        distribution.
        """
        log.info("reading manifest file '%s'", self.manifest)
        manifest = open(self.manifest)
        for line in manifest:
            # ignore comments and blank lines
            line = line.strip()
            if line.startswith('#') or not line:
                continue
            self.filelist.append(line)
        manifest.close()

    def make_release_tree(self, base_dir, files):
        """Create the directory tree that will become the source
        distribution archive.  All directories implied by the filenames in
        'files' are created under 'base_dir', and then we hard link or copy
        (if hard linking is unavailable) those files into place.
        Essentially, this duplicates the developer's source tree, but in a
        directory named after the distribution, containing only the files
        to be distributed.
        """
        # Create all the directories under 'base_dir' necessary to
        # put 'files' there; the 'mkpath()' is just so we don't die
        # if the manifest happens to be empty.
        self.mkpath(base_dir)
        dir_util.create_tree(base_dir, files, dry_run=self.dry_run)

        # And walk over the list of files, either making a hard link (if
        # os.link exists) to each one that doesn't already exist in its
        # corresponding location under 'base_dir', or copying each file
        # that's out-of-date in 'base_dir'.  (Usually, all files will be
        # out-of-date, because by default we blow away 'base_dir' when
        # we're done making the distribution archives.)

        if hasattr(os, 'link'):        # can make hard links on this system
            link = 'hard'
            msg = "making hard links in %s..." % base_dir
        else:                           # nope, have to copy
            link = None
            msg = "copying files to %s..." % base_dir

        if not files:
            log.warn("no files to distribute -- empty manifest?")
        else:
            log.info(msg)
        for file in files:
            if not os.path.isfile(file):
                log.warn("'%s' not a regular file -- skipping" % file)
            else:
                dest = os.path.join(base_dir, file)
                self.copy_file(file, dest, link=link)

        self.distribution.metadata.write_pkg_info(base_dir)

    def make_distribution(self):
        """Create the source distribution(s).  First, we create the release
        tree with 'make_release_tree()'; then, we create all required
        archive files (according to 'self.formats') from the release tree.
        Finally, we clean up by blowing away the release tree (unless
        'self.keep_temp' is true).  The list of archive files created is
        stored so it can be retrieved later by 'get_archive_files()'.
        """
        # Don't warn about missing meta-data here -- should be (and is!)
        # done elsewhere.
        base_dir = self.distribution.get_fullname()
        base_name = os.path.join(self.dist_dir, base_dir)

        self.make_release_tree(base_dir, self.filelist.files)
        archive_files = []              # remember names of files we create
        # tar archive must be created last to avoid overwrite and remove
        if 'tar' in self.formats:
            self.formats.append(self.formats.pop(self.formats.index('tar')))

        for fmt in self.formats:
            file = self.make_archive(base_name, fmt, base_dir=base_dir,
                                     owner=self.owner, group=self.group)
            archive_files.append(file)
            self.distribution.dist_files.append(('sdist', '', file))

        self.archive_files = archive_files

        if not self.keep_temp:
            dir_util.remove_tree(base_dir, dry_run=self.dry_run)

    def get_archive_files(self):
        """Return the list of archive files created when the command
        was run, or None if the command hasn't run yet.
        """
        return self.archive_files
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   Û
”´[c           @   s  d  Z  d Z d d l Z d d l Z d d l Z d d l m Z d d l m Z d d l m	 Z	 d d l
 m Z m Z m Z m Z d d l m Z d d	 l m Z m Z m Z d d
 l m Z d d l
 m Z d d l m Z d Ñ  Z d e	 f d Ñ  É  YZ d S(   sa   distutils.command.sdist

Implements the Distutils 'sdist' command (create a source distribution).s   $Id$iˇˇˇˇN(   t   glob(   t   warn(   t   Command(   t   dir_utilt   dep_utilt	   file_utilt   archive_util(   t   TextFile(   t   DistutilsPlatformErrort   DistutilsOptionErrort   DistutilsTemplateError(   t   FileList(   t   log(   t   convert_pathc          C   sÄ   d d l  m }  d d l m } g  } x6 | j É  D]( } | j d | d | | d f É q3 W| j É  |  | É j d É d S(   so   Print all possible values for the 'formats' option (used by
    the "--help-formats" command-line option).
    iˇˇˇˇ(   t   FancyGetopt(   t   ARCHIVE_FORMATSs   formats=i   s.   List of available source distribution formats:N(	   t   distutils.fancy_getoptR   t   distutils.archive_utilR   t   keyst   appendt   Nonet   sortt
   print_help(   R   R   t   formatst   format(    (    s-   /usr/lib/python2.7/distutils/command/sdist.pyt   show_formats   s    
t   sdistc           B   s6  e  Z d  Z d Ñ  Z d< d= d? d@ dA dB dC dD dE d d d d f dF dG dH dI g Z d d d d d d g Z d' d> d( e f g Z i d d
 6d d 6Z	 i d) d* 6d+ d, 6Z
 d- e f g Z d. Ñ  Z d/ Ñ  Z d0 Ñ  Z d1 Ñ  Z d2 Ñ  Z d3 Ñ  Z d4 Ñ  Z d5 Ñ  Z d6 Ñ  Z d7 Ñ  Z d8 Ñ  Z d9 Ñ  Z d: Ñ  Z d; Ñ  Z RS(J   s6   create a source distribution (tarball, zip file, etc.)c         C   s   |  j  S(   sY   Callable used for the check sub-command.

        Placed here so user_options can view it(   t   metadata_check(   t   self(    (    s-   /usr/lib/python2.7/distutils/command/sdist.pyt   checking_metadata(   s    s	   template=t   ts5   name of manifest template file [default: MANIFEST.in]s	   manifest=t   ms)   name of manifest file [default: MANIFEST]s   use-defaultssR   include the default file set in the manifest [default; disable with --no-defaults]s   no-defaultss"   don't include the default file sett   prunesâ   specifically exclude files/directories that should not be distributed (build tree, RCS/CVS dirs, etc.) [default; disable with --no-prune]s   no-prunes$   don't automatically exclude anythings   manifest-onlyt   osE   just regenerate the manifest and then stop (implies --force-manifest)s   force-manifestt   fsk   forcibly regenerate the manifest and carry on as usual. Deprecated: now the manifest is always regenerated.s   formats=s6   formats for source distribution (comma-separated list)s	   keep-tempt   ks1   keep the distribution tree around after creating s   archive file(s)s	   dist-dir=t   dsF   directory to put the source distribution archive(s) in [default: dist]s   metadata-checks[   Ensure that all required elements of meta-data are supplied. Warn if any missing. [default]s   owner=t   us@   Owner name used when creating a tar file [default: current user]s   group=t   gsA   Group name used when creating a tar file [default: current group]s   help-formatss#   list available distribution formatst   gztart   posixt   zipt   ntt   checkc         C   sy   d  |  _ d  |  _ d |  _ d |  _ d |  _ d |  _ d  |  _ d |  _ d  |  _	 d  |  _
 d |  _ d  |  _ d  |  _ d  S(   Ni   i    (   R   t   templatet   manifestt   use_defaultsR    t   manifest_onlyt   force_manifestR   t	   keep_tempt   dist_dirt   archive_filesR   t   ownert   group(   R   (    (    s-   /usr/lib/python2.7/distutils/command/sdist.pyt   initialize_optionsf   s    												c         C   sﬁ   |  j  d  k r d |  _  n  |  j d  k r6 d |  _ n  |  j d É |  j d  k ró y |  j t j g |  _ Wqó t k
 rì t	 d d t j Ç qó Xn  t
 j |  j É } | rø t d | Ç n  |  j d  k r⁄ d |  _ n  d  S(   Nt   MANIFESTs   MANIFEST.inR   s.   don't know how to create source distributions s   on platform %ss   unknown archive format '%s't   dist(   R-   R   R,   t   ensure_string_listR   t   default_formatt   ost   namet   KeyErrorR   R   t   check_archive_formatsR	   R2   (   R   t
   bad_format(    (    s-   /usr/lib/python2.7/distutils/command/sdist.pyt   finalize_options}   s$    c         C   sU   t  É  |  _ x! |  j É  D] } |  j | É q W|  j É  |  j rG d  S|  j É  d  S(   N(   R   t   filelistt   get_sub_commandst   run_commandt   get_file_listR/   t   make_distribution(   R   t   cmd_name(    (    s-   /usr/lib/python2.7/distutils/command/sdist.pyt   runî   s    
	c         C   s7   t  d t É |  j j d É } | j É  | j É  d S(   s   Deprecated API.sa   distutils.command.sdist.check_metadata is deprecated,               use the check command insteadR+   N(   R   t   PendingDeprecationWarningt   distributiont   get_command_objt   ensure_finalizedRG   (   R   R+   (    (    s-   /usr/lib/python2.7/distutils/command/sdist.pyt   check_metadata™   s
    

c         C   sÂ   t  j j |  j É } | rP |  j É  rP |  j É  |  j j É  |  j j É  d S| sq |  j	 d d |  j É n  |  j j
 É  |  j rî |  j É  n  | rß |  j É  n  |  j rΩ |  j É  n  |  j j É  |  j j É  |  j É  d S(   sC  Figure out the list of files to include in the source
        distribution, and put it in 'self.filelist'.  This might involve
        reading the manifest template (and writing the manifest), or just
        reading the manifest, or just using the default file set -- it all
        depends on the user's options.
        Ns&   manifest template '%s' does not exist s   (using default file list)(   R;   t   patht   isfileR,   t   _manifest_is_not_generatedt   read_manifestRA   R   t   remove_duplicatesR   t   findallR.   t   add_defaultst   read_templateR    t   prune_file_listt   write_manifest(   R   t   template_exists(    (    s-   /usr/lib/python2.7/distutils/command/sdist.pyRD   ≤   s(    
			c         C   s  d |  j  j g } x≈ | D]Ω } t | t É r† | } d } x: | D]2 } t j j | É rA d } |  j j | É PqA qA W| s÷ |  j	 d t
 j | d É É q÷ q t j j | É r≈ |  j j | É q |  j	 d | É q Wd d	 g } xB | D]: } t t j j t | É É } | rÌ |  j j | É qÌ qÌ W|  j d
 É } |  j  j É  rb|  j j | j É  É n  xM | j D]B \ }	 }
 } } x- | D]% } |  j j t j j |
 | É É qÖWqlW|  j  j É  rlx® |  j  j D]ó } t | t É rt | É } t j j | É re|  j j | É qeqŒ| \ } } x? | D]7 } t | É } t j j | É r*|  j j | É q*q*WqŒWn  |  j  j É  r£|  j d É } |  j j | j É  É n  |  j  j É  r⁄|  j d É } |  j j | j É  É n  |  j  j É  r|  j d É } |  j j | j É  É n  d S(   s9  Add all the default files to self.filelist:
          - README or README.txt
          - setup.py
          - test/test*.py
          - all pure Python modules mentioned in setup script
          - all files pointed by package_data (build_py)
          - all files defined in data_files.
          - all files defined as scripts.
          - all C sources listed as part of extensions or C libraries
            in the setup script (doesn't catch C headers!)
        Warns if (README or README.txt) or setup.py are missing; everything
        else is optional.
        t   READMEs
   README.txti    i   s,   standard file not found: should have one of s   , s   standard file '%s' not founds   test/test*.pys	   setup.cfgt   build_pyt	   build_extt
   build_clibt   build_scriptsN(   RX   s
   README.txt(   RI   t   script_namet
   isinstancet   tupleR;   RM   t   existsRA   R   R   t   stringt   joint   filterRN   R    t   extendt   get_finalized_commandt   has_pure_modulest   get_source_filest
   data_filest   has_data_filest   strR   t   has_ext_modulest   has_c_librariest   has_scripts(   R   t	   standardst   fnt   altst   got_itt   optionalt   patternt   filesRY   t   pkgt   src_dirt	   build_dirt	   filenamest   filenamet   itemt   dirnameR"   RZ   R[   R\   (    (    s-   /usr/lib/python2.7/distutils/command/sdist.pyRS   ⁄   s^    	'c         C   sœ   t  j d |  j É t |  j d d d d d d d d d d d d É} zw xp | j É  } | d
 k rh Pn  y |  j j | É WqL t t	 f k
 r∑ } |  j
 d	 | j | j | f É qL XqL WWd
 | j É  Xd
 S(   s»   Read and parse manifest template file named by self.template.

        (usually "MANIFEST.in") The parsing and processing is done by
        'self.filelist', which updates itself accordingly.
        s   reading manifest template '%s't   strip_commentsi   t   skip_blankst
   join_linest	   lstrip_wst	   rstrip_wst   collapse_joins   %s, line %d: %sN(   R   t   infoR,   R   t   readlineR   RA   t   process_template_lineR
   t
   ValueErrorR   Ry   t   current_linet   close(   R   R,   t   linet   msg(    (    s-   /usr/lib/python2.7/distutils/command/sdist.pyRT   ,  s(    	c         C   sº   |  j  d É } |  j j É  } |  j j d d | j É|  j j d d | Ét j d k re d } n d } d d d d	 d
 d d g } d | d j	 | É | f } |  j j | d d Éd S(   sv  Prune off branches that might slip into the file list as created
        by 'read_template()', but really don't belong there:
          * the build tree (typically "build")
          * the release tree itself (only an issue if we ran "sdist"
            previously with --keep-temp, or it aborted)
          * any RCS, CVS, .svn, .hg, .git, .bzr, _darcs directories
        t   buildt   prefixt   win32s   /|\\t   /t   RCSt   CVSs   \.svns   \.hgs   \.gits   \.bzrt   _darcss   (^|%s)(%s)(%s).*t   |t   is_regexi   N(
   Re   RI   t   get_fullnameRA   t   exclude_patternR   t
   build_baset   syst   platformRb   (   R   Rä   t   base_dirt   sepst   vcs_dirst   vcs_ptrn(    (    s-   /usr/lib/python2.7/distutils/command/sdist.pyRU   M  s    		c         C   sk   |  j  É  r$ t j d |  j É d S|  j j } | j d d É |  j t j	 |  j | f d |  j É d S(   s≤   Write the file list in 'self.filelist' (presumably as filled in
        by 'add_defaults()' and 'read_template()') to the manifest file
        named by 'self.manifest'.
        s5   not writing to manually maintained manifest file '%s'Ni    s*   # file GENERATED by distutils, do NOT edits   writing manifest file '%s'(
   RO   R   RÇ   R-   RA   Rt   t   insertt   executeR   t
   write_file(   R   t   content(    (    s-   /usr/lib/python2.7/distutils/command/sdist.pyRV   g  s    	c         C   sS   t  j j |  j É s t St |  j d É } z | j É  } Wd  | j É  X| d k S(   Nt   rUs+   # file GENERATED by distutils, do NOT edit
(   R;   RM   RN   R-   t   Falset   openRÉ   Rá   (   R   t   fpt
   first_line(    (    s-   /usr/lib/python2.7/distutils/command/sdist.pyRO   v  s    c         C   sy   t  j d |  j É t |  j É } xF | D]> } | j É  } | j d É s) | rW q) n  |  j j | É q) W| j É  d S(   s™   Read the manifest file (named by 'self.manifest') and use it to
        fill in 'self.filelist', the list of files to include in the source
        distribution.
        s   reading manifest file '%s't   #N(	   R   RÇ   R-   R¢   t   stript
   startswithRA   R   Rá   (   R   R-   Rà   (    (    s-   /usr/lib/python2.7/distutils/command/sdist.pyRP   Ç  s    c         C   sÙ   |  j  | É t j | | d |  j Ét t d É rH d } d | } n d } d | } | sn t j d É n t j	 | É x_ | D]W } t j
 j | É sÆ t j d | É qÇ t j
 j | | É } |  j | | d | ÉqÇ W|  j j j | É d S(	   s∆  Create the directory tree that will become the source
        distribution archive.  All directories implied by the filenames in
        'files' are created under 'base_dir', and then we hard link or copy
        (if hard linking is unavailable) those files into place.
        Essentially, this duplicates the developer's source tree, but in a
        directory named after the distribution, containing only the files
        to be distributed.
        t   dry_runt   linkt   hards   making hard links in %s...s   copying files to %s...s)   no files to distribute -- empty manifest?s#   '%s' not a regular file -- skippingN(   t   mkpathR   t   create_treeR®   t   hasattrR;   R   R   R   RÇ   RM   RN   Rb   t	   copy_fileRI   t   metadatat   write_pkg_info(   R   Rò   Rt   R©   Râ   t   filet   dest(    (    s-   /usr/lib/python2.7/distutils/command/sdist.pyt   make_release_treeë  s     	
c      
   C   s  |  j  j É  } t j j |  j | É } |  j | |  j j É g  } d |  j	 k r} |  j	 j
 |  j	 j |  j	 j d É É É n  xd |  j	 D]Y } |  j | | d | d |  j d |  j É} | j
 | É |  j  j j
 d d | f É qá W| |  _ |  j st j | d |  j Én  d S(	   sØ  Create the source distribution(s).  First, we create the release
        tree with 'make_release_tree()'; then, we create all required
        archive files (according to 'self.formats') from the release tree.
        Finally, we clean up by blowing away the release tree (unless
        'self.keep_temp' is true).  The list of archive files created is
        stored so it can be retrieved later by 'get_archive_files()'.
        t   tarRò   R4   R5   R   t    R®   N(   RI   Rì   R;   RM   Rb   R2   R≥   RA   Rt   R   R   t   popt   indext   make_archiveR4   R5   t
   dist_filesR3   R1   R   t   remove_treeR®   (   R   Rò   t	   base_nameR3   t   fmtR±   (    (    s-   /usr/lib/python2.7/distutils/command/sdist.pyRE   ª  s    
+ 		c         C   s   |  j  S(   sz   Return the list of archive files created when the command
        was run, or None if the command hasn't run yet.
        (   R3   (   R   (    (    s-   /usr/lib/python2.7/distutils/command/sdist.pyt   get_archive_filesŸ  s    (   s	   template=R   s5   name of manifest template file [default: MANIFEST.in](   s	   manifest=R   s)   name of manifest file [default: MANIFEST]N(   s   use-defaultsNsR   include the default file set in the manifest [default; disable with --no-defaults](   s   no-defaultsNs"   don't include the default file set(   R    Nsâ   specifically exclude files/directories that should not be distributed (build tree, RCS/CVS dirs, etc.) [default; disable with --no-prune](   s   no-pruneNs$   don't automatically exclude anything(   s   manifest-onlyR!   sE   just regenerate the manifest and then stop (implies --force-manifest)(   s   force-manifestR"   sk   forcibly regenerate the manifest and carry on as usual. Deprecated: now the manifest is always regenerated.(   s   formats=Ns6   formats for source distribution (comma-separated list)(   s	   dist-dir=R$   sF   directory to put the source distribution archive(s) in [default: dist](   s   metadata-checkNs[   Ensure that all required elements of meta-data are supplied. Warn if any missing. [default](   s   owner=R%   s@   Owner name used when creating a tar file [default: current user](   s   group=R&   sA   Group name used when creating a tar file [default: current group](   t   __name__t
   __module__t   descriptionR   R   t   user_optionst   boolean_optionsR   t   help_optionst   negative_optR:   t   sub_commandsR6   R@   RG   RL   RD   RS   RT   RU   RV   RO   RP   R≥   RE   RΩ   (    (    (    s-   /usr/lib/python2.7/distutils/command/sdist.pyR   $   sn   	             	



					(	R	!					*	(   t   __doc__t   __revision__R;   Ra   Rñ   R    t   warningsR   t   distutils.coreR   t	   distutilsR   R   R   R   t   distutils.text_fileR   t   distutils.errorsR   R	   R
   t   distutils.filelistR   R   t   distutils.utilR   R   R   (    (    (    s-   /usr/lib/python2.7/distutils/command/sdist.pyt   <module>   s   "	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            """distutils.command.upload

Implements the Distutils 'upload' subcommand (upload package to PyPI)."""
import os
import socket
import platform
from urllib2 import urlopen, Request, HTTPError
from base64 import standard_b64encode
import urlparse
import cStringIO as StringIO
from hashlib import md5

from distutils.errors import DistutilsError, DistutilsOptionError
from distutils.core import PyPIRCCommand
from distutils.spawn import spawn
from distutils import log

class upload(PyPIRCCommand):

    description = "upload binary package to PyPI"

    user_options = PyPIRCCommand.user_options + [
        ('sign', 's',
         'sign files to upload using gpg'),
        ('identity=', 'i', 'GPG identity used to sign files'),
        ]

    boolean_options = PyPIRCCommand.boolean_options + ['sign']

    def initialize_options(self):
        PyPIRCCommand.initialize_options(self)
        self.username = ''
        self.password = ''
        self.show_response = 0
        self.sign = False
        self.identity = None

    def finalize_options(self):
        PyPIRCCommand.finalize_options(self)
        if self.identity and not self.sign:
            raise DistutilsOptionError(
                "Must use --sign for --identity to have meaning"
            )
        config = self._read_pypirc()
        if config != {}:
            self.username = config['username']
            self.password = config['password']
            self.repository = config['repository']
            self.realm = config['realm']

        # getting the password from the distribution
        # if previously set by the register command
        if not self.password and self.distribution.password:
            self.password = self.distribution.password

    def run(self):
        if not self.distribution.dist_files:
            raise DistutilsOptionError("No dist file created in earlier command")
        for command, pyversion, filename in self.distribution.dist_files:
            self.upload_file(command, pyversion, filename)

    def upload_file(self, command, pyversion, filename):
        # Makes sure the repository URL is compliant
        schema, netloc, url, params, query, fragments = \
            urlparse.urlparse(self.repository)
        if params or query or fragments:
            raise AssertionError("Incompatible url %s" % self.repository)

        if schema not in ('http', 'https'):
            raise AssertionError("unsupported schema " + schema)

        # Sign if requested
        if self.sign:
            gpg_args = ["gpg", "--detach-sign", "-a", filename]
            if self.identity:
                gpg_args[2:2] = ["--local-user", self.identity]
            spawn(gpg_args,
                  dry_run=self.dry_run)

        # Fill in the data - send all the meta-data in case we need to
        # register a new release
        f = open(filename,'rb')
        try:
            content = f.read()
        finally:
            f.close()
        meta = self.distribution.metadata
        data = {
            # action
            ':action': 'file_upload',
            'protcol_version': '1',

            # identify release
            'name': meta.get_name(),
            'version': meta.get_version(),

            # file content
            'content': (os.path.basename(filename),content),
            'filetype': command,
            'pyversion': pyversion,
            'md5_digest': md5(content).hexdigest(),

            # additional meta-data
            'metadata_version' : '1.0',
            'summary': meta.get_description(),
            'home_page': meta.get_url(),
            'author': meta.get_contact(),
            'author_email': meta.get_contact_email(),
            'license': meta.get_licence(),
            'description': meta.get_long_description(),
            'keywords': meta.get_keywords(),
            'platform': meta.get_platforms(),
            'classifiers': meta.get_classifiers(),
            'download_url': meta.get_download_url(),
            # PEP 314
            'provides': meta.get_provides(),
            'requires': meta.get_requires(),
            'obsoletes': meta.get_obsoletes(),
            }
        comment = ''
        if command == 'bdist_rpm':
            dist, version, id = platform.dist()
            if dist:
                comment = 'built for %s %s' % (dist, version)
        elif command == 'bdist_dumb':
            comment = 'built for %s' % platform.platform(terse=1)
        data['comment'] = comment

        if self.sign:
            data['gpg_signature'] = (os.path.basename(filename) + ".asc",
                                     open(filename+".asc").read())

        # set up the authentication
        auth = "Basic " + standard_b64encode(self.username + ":" +
                                             self.password)

        # Build up the MIME payload for the POST data
        boundary = '--------------GHSKFJDLGDS7543FJKLFHRE75642756743254'
        sep_boundary = '\r\n--' + boundary
        end_boundary = sep_boundary + '--\r\n'
        body = StringIO.StringIO()
        for key, value in data.items():
            # handle multiple entries for the same name
            if not isinstance(value, list):
                value = [value]
            for value in value:
                if isinstance(value, tuple):
                    fn = ';filename="%s"' % value[0]
                    value = value[1]
                else:
                    fn = ""

                body.write(sep_boundary)
                body.write('\r\nContent-Disposition: form-data; name="%s"' % key)
                body.write(fn)
                body.write("\r\n\r\n")
                body.write(value)
                if value and value[-1] == '\r':
                    body.write('\n')  # write an extra newline (lurve Macs)
        body.write(end_boundary)
        body = body.getvalue()

        self.announce("Submitting %s to %s" % (filename, self.repository), log.INFO)

        # build the Request
        headers = {'Content-type':
                        'multipart/form-data; boundary=%s' % boundary,
                   'Content-length': str(len(body)),
                   'Authorization': auth}

        request = Request(self.repository, data=body,
                          headers=headers)
        # send the data
        try:
            result = urlopen(request)
            status = result.getcode()
            reason = result.msg
            if self.show_response:
                msg = '\n'.join(('-' * 75, result.read(), '-' * 75))
                self.announce(msg, log.INFO)
        except socket.error, e:
            self.announce(str(e), log.ERROR)
            raise
        except HTTPError, e:
            status = e.code
            reason = e.msg

        if status == 200:
            self.announce('Server response (%s): %s' % (status, reason),
                          log.INFO)
        else:
            msg = 'Upload failed (%s): %s' % (status, reason)
            self.announce(msg, log.ERROR)
            raise DistutilsError(msg)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Û
”´[c           @   sﬁ   d  Z  d d l Z d d l Z d d l Z d d l m Z m Z m Z d d l m	 Z	 d d l
 Z
 d d l Z d d l m Z d d l m Z m Z d d l m Z d d l m Z d d	 l m Z d
 e f d Ñ  É  YZ d S(   s`   distutils.command.upload

Implements the Distutils 'upload' subcommand (upload package to PyPI).iˇˇˇˇN(   t   urlopent   Requestt	   HTTPError(   t   standard_b64encode(   t   md5(   t   DistutilsErrort   DistutilsOptionError(   t   PyPIRCCommand(   t   spawn(   t   logt   uploadc           B   sU   e  Z d  Z e j d d g Z e j d g Z d Ñ  Z d Ñ  Z d	 Ñ  Z d
 Ñ  Z	 RS(   s   upload binary package to PyPIt   signt   ss   sign files to upload using gpgs	   identity=t   is   GPG identity used to sign filesc         C   s>   t  j |  É d |  _ d |  _ d |  _ t |  _ d  |  _ d  S(   Nt    i    (	   R   t   initialize_optionst   usernamet   passwordt   show_responset   FalseR   t   Nonet   identity(   t   self(    (    s.   /usr/lib/python2.7/distutils/command/upload.pyR      s    				c         C   s™   t  j |  É |  j r/ |  j r/ t d É Ç n  |  j É  } | i  k r~ | d |  _ | d |  _ | d |  _ | d |  _	 n  |  j r¶ |  j
 j r¶ |  j
 j |  _ n  d  S(   Ns.   Must use --sign for --identity to have meaningR   R   t
   repositoryt   realm(   R   t   finalize_optionsR   R   R   t   _read_pypircR   R   R   R   t   distribution(   R   t   config(    (    s.   /usr/lib/python2.7/distutils/command/upload.pyR   &   s    c         C   sR   |  j  j s t d É Ç n  x0 |  j  j D]" \ } } } |  j | | | É q( Wd  S(   Ns'   No dist file created in earlier command(   R   t
   dist_filesR   t   upload_file(   R   t   commandt	   pyversiont   filename(    (    s.   /usr/lib/python2.7/distutils/command/upload.pyt   run8   s    c   "      C   sÜ  t  j  |  j É \ } } } } } }	 | s6 | s6 |	 rL t d |  j É Ç n  | dG k rk t d | É Ç n  |  j ræ d d d | g }
 |  j r® d |  j g |
 d	 d	 +n  t |
 d
 |  j Én  t | d É } z | j É  } Wd  | j	 É  X|  j
 j } i d d 6d d 6| j É  d 6| j É  d 6t j j | É | f d 6| d 6| d 6t | É j É  d 6d d 6| j É  d 6| j É  d 6| j É  d 6| j É  d 6| j É  d 6| j É  d 6| j É  d 6| j É  d 6| j É  d  6| j É  d! 6| j É  d" 6| j É  d# 6| j É  d$ 6} d% } | d& k rRt  j! É  \ } } } | rwd' | | f } qwn% | d( k rwd) t  j  d* d+ É } n  | | d, <|  j rΩt j j | É d- t | d- É j É  f | d. <n  d/ t" |  j# d0 |  j$ É } d1 } d2 | } | d3 } t% j% É  } x· | j& É  D]” \ } } t' | t( É s5| g } n  x© | D]° } t' | t) É rld4 | d5 } | d+ } n d% } | j* | É | j* d6 | É | j* | É | j* d7 É | j* | É | r<| d8 d9 k r<| j* d: É q<q<WqW| j* | É | j+ É  } |  j, d; | |  j f t- j. É i d< | d= 6t/ t0 | É É d> 6| d? 6} t1 |  j d@ | dA | É} yj t2 | É } | j3 É  } | j4 } |  j5 rÕd: j6 dB dC | j É  dB dC f É }  |  j, |  t- j. É n  WnV t7 j8 k
 r}! |  j, t/ |! É t- j9 É Ç  n% t: k
 r&}! |! j; } |! j4 } n X| dD k rS|  j, dE | | f t- j. É n/ dF | | f }  |  j, |  t- j9 É t< |  É Ç d  S(H   Ns   Incompatible url %st   httpt   httpss   unsupported schema t   gpgs   --detach-signs   -as   --local-useri   t   dry_runt   rbt   file_uploads   :actiont   1t   protcol_versiont   namet   versiont   contentt   filetypeR    t
   md5_digests   1.0t   metadata_versiont   summaryt	   home_paget   authort   author_emailt   licenset   descriptiont   keywordst   platformt   classifierst   download_urlt   providest   requirest	   obsoletesR   t	   bdist_rpms   built for %s %st
   bdist_dumbs   built for %st   tersei   t   comments   .asct   gpg_signatures   Basic t   :s3   --------------GHSKFJDLGDS7543FJKLFHRE75642756743254s   
--s   --
s   ;filename="%s"i    s+   
Content-Disposition: form-data; name="%s"s   

iˇˇˇˇs   s   
s   Submitting %s to %ss    multipart/form-data; boundary=%ss   Content-types   Content-lengtht   Authorizationt   datat   headerst   -iK   i»   s   Server response (%s): %ss   Upload failed (%s): %s(   R#   R$   (=   t   urlparseR   t   AssertionErrorR   R   R   R&   t   opent   readt   closeR   t   metadatat   get_namet   get_versiont   ost   patht   basenameR   t	   hexdigestt   get_descriptiont   get_urlt   get_contactt   get_contact_emailt   get_licencet   get_long_descriptiont   get_keywordst   get_platformst   get_classifierst   get_download_urlt   get_providest   get_requirest   get_obsoletesR8   t   distR   R   R   t   StringIOt   itemst
   isinstancet   listt   tuplet   writet   getvaluet   announceR	   t   INFOt   strt   lenR   R    t   getcodet   msgR   t   joint   sockett   errort   ERRORR   t   codeR   ("   R   R   R    R!   t   schemat   netloct   urlt   paramst   queryt	   fragmentst   gpg_argst   fR-   t   metaRE   RA   Ra   R,   t   idt   autht   boundaryt   sep_boundaryt   end_boundaryt   bodyt   keyt   valuet   fnRF   t   requestt   resultt   statust   reasonRn   t   e(    (    s.   /usr/lib/python2.7/distutils/command/upload.pyR   >   s∆    $			
	 

 
			&	(   R   R   s   sign files to upload using gpg(   s	   identity=R   s   GPG identity used to sign files(
   t   __name__t
   __module__R6   R   t   user_optionst   boolean_optionsR   R   R"   R   (    (    (    s.   /usr/lib/python2.7/distutils/command/upload.pyR
      s    
			(   t   __doc__RP   Rp   R8   t   urllib2R    R   R   t   base64R   RH   t	   cStringIORb   t   hashlibR   t   distutils.errorsR   R   t   distutils.coreR   t   distutils.spawnR   t	   distutilsR	   R
   (    (    (    s.   /usr/lib/python2.7/distutils/command/upload.pyt   <module>   s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    # Copyright (C) 2001-2006 Python Software Foundation
# Author: Barry Warsaw
# Contact: email-sig@python.org

"""A package for parsing, handling, and generating email messages."""

__version__ = '4.0.3'

__all__ = [
    # Old names
    'base64MIME',
    'Charset',
    'Encoders',
    'Errors',
    'Generator',
    'Header',
    'Iterators',
    'Message',
    'MIMEAudio',
    'MIMEBase',
    'MIMEImage',
    'MIMEMessage',
    'MIMEMultipart',
    'MIMENonMultipart',
    'MIMEText',
    'Parser',
    'quopriMIME',
    'Utils',
    'message_from_string',
    'message_from_file',
    # new names
    'base64mime',
    'charset',
    'encoders',
    'errors',
    'generator',
    'header',
    'iterators',
    'message',
    'mime',
    'parser',
    'quoprimime',
    'utils',
    ]



# Some convenience routines.  Don't import Parser and Message as side-effects
# of importing email since those cascadingly import most of the rest of the
# email package.
def message_from_string(s, *args, **kws):
    """Parse a string into a Message object model.

    Optional _class and strict are passed to the Parser constructor.
    """
    from email.parser import Parser
    return Parser(*args, **kws).parsestr(s)


def message_from_file(fp, *args, **kws):
    """Read a file and parse its contents into a Message object model.

    Optional _class and strict are passed to the Parser constructor.
    """
    from email.parser import Parser
    return Parser(*args, **kws).parse(fp)



# Lazy loading to provide name mapping from new-style names (PEP 8 compatible
# email 4.0 module names), to old-style names (email 3.0 module names).
import sys

class LazyImporter(object):
    def __init__(self, module_name):
        self.__name__ = 'email.' + module_name

    def __getattr__(self, name):
        __import__(self.__name__)
        mod = sys.modules[self.__name__]
        self.__dict__.update(mod.__dict__)
        return getattr(mod, name)


_LOWERNAMES = [
    # email.<old name> -> email.<new name is lowercased old name>
    'Charset',
    'Encoders',
    'Errors',
    'FeedParser',
    'Generator',
    'Header',
    'Iterators',
    'Message',
    'Parser',
    'Utils',
    'base64MIME',
    'quopriMIME',
    ]

_MIMENAMES = [
    # email.MIME<old name> -> email.mime.<new name is lowercased old name>
    'Audio',
    'Base',
    'Image',
    'Message',
    'Multipart',
    'NonMultipart',
    'Text',
    ]

for _name in _LOWERNAMES:
    importer = LazyImporter(_name.lower())
    sys.modules['email.' + _name] = importer
    setattr(sys.modules['email'], _name, importer)


import email.mime
for _name in _MIMENAMES:
    importer = LazyImporter('mime.' + _name.lower())
    sys.modules['email.MIME' + _name] = importer
    setattr(sys.modules['email'], 'MIME' + _name, importer)
    setattr(sys.modules['email.mime'], _name, importer)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        Û
”´[c            @   s∞  d  Z  d Z d d d d d d d d	 d
 d d d d d d d d d d d d d d d d d d d d d d  d! g  Z d" Ñ  Z d# Ñ  Z d$ d% l Z d& e f d' Ñ  É  YZ d d d d( d d d d	 d d d d g Z d) d* d+ d	 d, d- d. g Z	 xH e D]@ Z
 e e
 j É  É Z e e j d/ e
 <e e j d0 e
 e É qÚ Wd$ d% l Z xg e	 D]_ Z
 e d1 e
 j É  É Z e e j d2 e
 <e e j d0 d3 e
 e É e e j d4 e
 e É qIWd% S(5   s?   A package for parsing, handling, and generating email messages.s   4.0.3t
   base64MIMEt   Charsett   Encoderst   Errorst	   Generatort   Headert	   Iteratorst   Messaget	   MIMEAudiot   MIMEBaset	   MIMEImaget   MIMEMessaget   MIMEMultipartt   MIMENonMultipartt   MIMETextt   Parsert
   quopriMIMEt   Utilst   message_from_stringt   message_from_filet
   base64mimet   charsett   encoderst   errorst	   generatort   headert	   iteratorst   messaget   mimet   parsert
   quoprimimet   utilsc         O   s&   d d l  m } | | | é  j |  É S(   sv   Parse a string into a Message object model.

    Optional _class and strict are passed to the Parser constructor.
    iˇˇˇˇ(   R   (   t   email.parserR   t   parsestr(   t   st   argst   kwsR   (    (    s$   /usr/lib/python2.7/email/__init__.pyR   3   s    c         O   s&   d d l  m } | | | é  j |  É S(   sä   Read a file and parse its contents into a Message object model.

    Optional _class and strict are passed to the Parser constructor.
    iˇˇˇˇ(   R   (   R    R   t   parse(   t   fpR#   R$   R   (    (    s$   /usr/lib/python2.7/email/__init__.pyR   <   s    iˇˇˇˇNt   LazyImporterc           B   s   e  Z d  Ñ  Z d Ñ  Z RS(   c         C   s   d | |  _  d  S(   Ns   email.(   t   __name__(   t   selft   module_name(    (    s$   /usr/lib/python2.7/email/__init__.pyt   __init__K   s    c         C   s=   t  |  j É t j |  j } |  j j | j É t | | É S(   N(   t
   __import__R(   t   syst   modulest   __dict__t   updatet   getattr(   R)   t   namet   mod(    (    s$   /usr/lib/python2.7/email/__init__.pyt   __getattr__N   s    (   R(   t
   __module__R+   R4   (    (    (    s$   /usr/lib/python2.7/email/__init__.pyR'   J   s   	t
   FeedParsert   Audiot   Baset   Imaget	   Multipartt   NonMultipartt   Texts   email.t   emails   mime.s
   email.MIMEt   MIMEs
   email.mime(   t   __doc__t   __version__t   __all__R   R   R-   t   objectR'   t   _LOWERNAMESt
   _MIMENAMESt   _namet   lowert   importerR.   t   setattrt
   email.mimeR=   (    (    (    s$   /usr/lib/python2.7/email/__init__.pyt   <module>   sÑ   						                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    # Copyright (C) 2002-2006 Python Software Foundation
# Author: Ben Gertzfield
# Contact: email-sig@python.org

"""Base64 content transfer encoding per RFCs 2045-2047.

This module handles the content transfer encoding method defined in RFC 2045
to encode arbitrary 8-bit data using the three 8-bit bytes in four 7-bit
characters encoding known as Base64.

It is used in the MIME standards for email to attach images, audio, and text
using some 8-bit character sets to messages.

This module provides an interface to encode and decode both headers and bodies
with Base64 encoding.

RFC 2045 defines a method for including character set information in an
`encoded-word' in a header.  This method is commonly used for 8-bit real names
in To:, From:, Cc:, etc. fields, as well as Subject: lines.

This module does not do the line wrapping or end-of-line character conversion
necessary for proper internationalized headers; it only does dumb encoding and
decoding.  To deal with the various line wrapping issues, use the email.header
module.
"""

__all__ = [
    'base64_len',
    'body_decode',
    'body_encode',
    'decode',
    'decodestring',
    'encode',
    'encodestring',
    'header_encode',
    ]


from binascii import b2a_base64, a2b_base64
from email.utils import fix_eols

CRLF = '\r\n'
NL = '\n'
EMPTYSTRING = ''

# See also Charset.py
MISC_LEN = 7



# Helpers
def base64_len(s):
    """Return the length of s when it is encoded with base64."""
    groups_of_3, leftover = divmod(len(s), 3)
    # 4 bytes out for each 3 bytes (or nonzero fraction thereof) in.
    # Thanks, Tim!
    n = groups_of_3 * 4
    if leftover:
        n += 4
    return n



def header_encode(header, charset='iso-8859-1', keep_eols=False,
                  maxlinelen=76, eol=NL):
    """Encode a single header line with Base64 encoding in a given charset.

    Defined in RFC 2045, this Base64 encoding is identical to normal Base64
    encoding, except that each line must be intelligently wrapped (respecting
    the Base64 encoding), and subsequent lines must start with a space.

    charset names the character set to use to encode the header.  It defaults
    to iso-8859-1.

    End-of-line characters (\\r, \\n, \\r\\n) will be automatically converted
    to the canonical email line separator \\r\\n unless the keep_eols
    parameter is True (the default is False).

    Each line of the header will be terminated in the value of eol, which
    defaults to "\\n".  Set this to "\\r\\n" if you are using the result of
    this function directly in email.

    The resulting string will be in the form:

    "=?charset?b?WW/5ciBtYXp66XLrIHf8eiBhIGhhbXBzdGHuciBBIFlv+XIgbWF6euly?=\\n
      =?charset?b?6yB3/HogYSBoYW1wc3Rh7nIgQkMgWW/5ciBtYXp66XLrIHf8eiBhIGhh?="

    with each line wrapped at, at most, maxlinelen characters (defaults to 76
    characters).
    """
    # Return empty headers unchanged
    if not header:
        return header

    if not keep_eols:
        header = fix_eols(header)

    # Base64 encode each line, in encoded chunks no greater than maxlinelen in
    # length, after the RFC chrome is added in.
    base64ed = []
    max_encoded = maxlinelen - len(charset) - MISC_LEN
    max_unencoded = max_encoded * 3 // 4

    for i in range(0, len(header), max_unencoded):
        base64ed.append(b2a_base64(header[i:i+max_unencoded]))

    # Now add the RFC chrome to each encoded chunk
    lines = []
    for line in base64ed:
        # Ignore the last character of each line if it is a newline
        if line.endswith(NL):
            line = line[:-1]
        # Add the chrome
        lines.append('=?%s?b?%s?=' % (charset, line))
    # Glue the lines together and return it.  BAW: should we be able to
    # specify the leading whitespace in the joiner?
    joiner = eol + ' '
    return joiner.join(lines)



def encode(s, binary=True, maxlinelen=76, eol=NL):
    """Encode a string with base64.

    Each line will be wrapped at, at most, maxlinelen characters (defaults to
    76 characters).

    If binary is False, end-of-line characters will be converted to the
    canonical email end-of-line sequence \\r\\n.  Otherwise they will be left
    verbatim (this is the default).

    Each line of encoded text will end with eol, which defaults to "\\n".  Set
    this to "\\r\\n" if you will be using the result of this function directly
    in an email.
    """
    if not s:
        return s

    if not binary:
        s = fix_eols(s)

    encvec = []
    max_unencoded = maxlinelen * 3 // 4
    for i in range(0, len(s), max_unencoded):
        # BAW: should encode() inherit b2a_base64()'s dubious behavior in
        # adding a newline to the encoded string?
        enc = b2a_base64(s[i:i + max_unencoded])
        if enc.endswith(NL) and eol != NL:
            enc = enc[:-1] + eol
        encvec.append(enc)
    return EMPTYSTRING.join(encvec)


# For convenience and backwards compatibility w/ standard base64 module
body_encode = encode
encodestring = encode



def decode(s, convert_eols=None):
    """Decode a raw base64 string.

    If convert_eols is set to a string value, all canonical email linefeeds,
    e.g. "\\r\\n", in the decoded text will be converted to the value of
    convert_eols.  os.linesep is a good choice for convert_eols if you are
    decoding a text attachment.

    This function does not parse a full MIME header value encoded with
    base64 (like =?iso-8859-1?b?bmloISBuaWgh?=) -- please use the high
    level email.header class for that functionality.
    """
    if not s:
        return s

    dec = a2b_base64(s)
    if convert_eols:
        return dec.replace(CRLF, convert_eols)
    return dec


# For convenience and backwards compatibility w/ standard base64 module
body_decode = decode
decodestring = decode
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              # Copyright (C) 2002-2007 Python Software Foundation
# Contact: email-sig@python.org

"""Email address parsing code.

Lifted directly from rfc822.py.  This should eventually be rewritten.
"""

__all__ = [
    'mktime_tz',
    'parsedate',
    'parsedate_tz',
    'quote',
    ]

import time, calendar

SPACE = ' '
EMPTYSTRING = ''
COMMASPACE = ', '

# Parse a date field
_monthnames = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul',
               'aug', 'sep', 'oct', 'nov', 'dec',
               'january', 'february', 'march', 'april', 'may', 'june', 'july',
               'august', 'september', 'october', 'november', 'december']

_daynames = ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun']

# The timezone table does not include the military time zones defined
# in RFC822, other than Z.  According to RFC1123, the description in
# RFC822 gets the signs wrong, so we can't rely on any such time
# zones.  RFC1123 recommends that numeric timezone indicators be used
# instead of timezone names.

_timezones = {'UT':0, 'UTC':0, 'GMT':0, 'Z':0,
              'AST': -400, 'ADT': -300,  # Atlantic (used in Canada)
              'EST': -500, 'EDT': -400,  # Eastern
              'CST': -600, 'CDT': -500,  # Central
              'MST': -700, 'MDT': -600,  # Mountain
              'PST': -800, 'PDT': -700   # Pacific
              }


def parsedate_tz(data):
    """Convert a date string to a time tuple.

    Accounts for military timezones.
    """
    data = data.split()
    # The FWS after the comma after the day-of-week is optional, so search and
    # adjust for this.
    if data[0].endswith(',') or data[0].lower() in _daynames:
        # There's a dayname here. Skip it
        del data[0]
    else:
        i = data[0].rfind(',')
        if i >= 0:
            data[0] = data[0][i+1:]
    if len(data) == 3: # RFC 850 date, deprecated
        stuff = data[0].split('-')
        if len(stuff) == 3:
            data = stuff + data[1:]
    if len(data) == 4:
        s = data[3]
        i = s.find('+')
        if i > 0:
            data[3:] = [s[:i], s[i+1:]]
        else:
            data.append('') # Dummy tz
    if len(data) < 5:
        return None
    data = data[:5]
    [dd, mm, yy, tm, tz] = data
    mm = mm.lower()
    if mm not in _monthnames:
        dd, mm = mm, dd.lower()
        if mm not in _monthnames:
            return None
    mm = _monthnames.index(mm) + 1
    if mm > 12:
        mm -= 12
    if dd[-1] == ',':
        dd = dd[:-1]
    i = yy.find(':')
    if i > 0:
        yy, tm = tm, yy
    if yy[-1] == ',':
        yy = yy[:-1]
    if not yy[0].isdigit():
        yy, tz = tz, yy
    if tm[-1] == ',':
        tm = tm[:-1]
    tm = tm.split(':')
    if len(tm) == 2:
        [thh, tmm] = tm
        tss = '0'
    elif len(tm) == 3:
        [thh, tmm, tss] = tm
    else:
        return None
    try:
        yy = int(yy)
        dd = int(dd)
        thh = int(thh)
        tmm = int(tmm)
        tss = int(tss)
    except ValueError:
        return None
    # Check for a yy specified in two-digit format, then convert it to the
    # appropriate four-digit format, according to the POSIX standard. RFC 822
    # calls for a two-digit yy, but RFC 2822 (which obsoletes RFC 822)
    # mandates a 4-digit yy. For more information, see the documentation for
    # the time module.
    if yy < 100:
        # The year is between 1969 and 1999 (inclusive).
        if yy > 68:
            yy += 1900
        # The year is between 2000 and 2068 (inclusive).
        else:
            yy += 2000
    tzoffset = None
    tz = tz.upper()
    if tz in _timezones:
        tzoffset = _timezones[tz]
    else:
        try:
            tzoffset = int(tz)
        except ValueError:
            pass
    # Convert a timezone offset into seconds ; -0500 -> -18000
    if tzoffset:
        if tzoffset < 0:
            tzsign = -1
            tzoffset = -tzoffset
        else:
            tzsign = 1
        tzoffset = tzsign * ( (tzoffset//100)*3600 + (tzoffset % 100)*60)
    # Daylight Saving Time flag is set to -1, since DST is unknown.
    return yy, mm, dd, thh, tmm, tss, 0, 1, -1, tzoffset


def parsedate(data):
    """Convert a time string to a time tuple."""
    t = parsedate_tz(data)
    if isinstance(t, tuple):
        return t[:9]
    else:
        return t


def mktime_tz(data):
    """Turn a 10-tuple as returned by parsedate_tz() into a POSIX timestamp."""
    if data[9] is None:
        # No zone info, so localtime is better assumption than GMT
        return time.mktime(data[:8] + (-1,))
    else:
        t = calendar.timegm(data)
        return t - data[9]


def quote(str):
    """Prepare string to be used in a quoted string.

    Turns backslash and double quote characters into quoted pairs.  These
    are the only characters that need to be quoted inside a quoted string.
    Does not add the surrounding double quotes.
    """
    return str.replace('\\', '\\\\').replace('"', '\\"')


class AddrlistClass:
    """Address parser class by Ben Escoto.

    To understand what this class does, it helps to have a copy of RFC 2822 in
    front of you.

    Note: this class interface is deprecated and may be removed in the future.
    Use rfc822.AddressList instead.
    """

    def __init__(self, field):
        """Initialize a new instance.

        `field' is an unparsed address header field, containing
        one or more addresses.
        """
        self.specials = '()<>@,:;.\"[]'
        self.pos = 0
        self.LWS = ' \t'
        self.CR = '\r\n'
        self.FWS = self.LWS + self.CR
        self.atomends = self.specials + self.LWS + self.CR
        # Note that RFC 2822 now specifies `.' as obs-phrase, meaning that it
        # is obsolete syntax.  RFC 2822 requires that we recognize obsolete
        # syntax, so allow dots in phrases.
        self.phraseends = self.atomends.replace('.', '')
        self.field = field
        self.commentlist = []

    def gotonext(self):
        """Parse up to the start of the next address."""
        while self.pos < len(self.field):
            if self.field[self.pos] in self.LWS + '\n\r':
                self.pos += 1
            elif self.field[self.pos] == '(':
                self.commentlist.append(self.getcomment())
            else:
                break

    def getaddrlist(self):
        """Parse all addresses.

        Returns a list containing all of the addresses.
        """
        result = []
        while self.pos < len(self.field):
            ad = self.getaddress()
            if ad:
                result += ad
            else:
                result.append(('', ''))
        return result

    def getaddress(self):
        """Parse the next address."""
        self.commentlist = []
        self.gotonext()

        oldpos = self.pos
        oldcl = self.commentlist
        plist = self.getphraselist()

        self.gotonext()
        returnlist = []

        if self.pos >= len(self.field):
            # Bad email address technically, no domain.
            if plist:
                returnlist = [(SPACE.join(self.commentlist), plist[0])]

        elif self.field[self.pos] in '.@':
            # email address is just an addrspec
            # this isn't very efficient since we start over
            self.pos = oldpos
            self.commentlist = oldcl
            addrspec = self.getaddrspec()
            returnlist = [(SPACE.join(self.commentlist), addrspec)]

        elif self.field[self.pos] == ':':
            # address is a group
            returnlist = []

            fieldlen = len(self.field)
            self.pos += 1
            while self.pos < len(self.field):
                self.gotonext()
                if self.pos < fieldlen and self.field[self.pos] == ';':
                    self.pos += 1
                    break
                returnlist = returnlist + self.getaddress()

        elif self.field[self.pos] == '<':
            # Address is a phrase then a route addr
            routeaddr = self.getrouteaddr()

            if self.commentlist:
                returnlist = [(SPACE.join(plist) + ' (' +
                               ' '.join(self.commentlist) + ')', routeaddr)]
            else:
                returnlist = [(SPACE.join(plist), routeaddr)]

        else:
            if plist:
                returnlist = [(SPACE.join(self.commentlist), plist[0])]
            elif self.field[self.pos] in self.specials:
                self.pos += 1

        self.gotonext()
        if self.pos < len(self.field) and self.field[self.pos] == ',':
            self.pos += 1
        return returnlist

    def getrouteaddr(self):
        """Parse a route address (Return-path value).

        This method just skips all the route stuff and returns the addrspec.
        """
        if self.field[self.pos] != '<':
            return

        expectroute = False
        self.pos += 1
        self.gotonext()
        adlist = ''
        while self.pos < len(self.field):
            if expectroute:
                self.getdomain()
                expectroute = False
            elif self.field[self.pos] == '>':
                self.pos += 1
                break
            elif self.field[self.pos] == '@':
                self.pos += 1
                expectroute = True
            elif self.field[self.pos] == ':':
                self.pos += 1
            else:
                adlist = self.getaddrspec()
                self.pos += 1
                break
            self.gotonext()

        return adlist

    def getaddrspec(self):
        """Parse an RFC 2822 addr-spec."""
        aslist = []

        self.gotonext()
        while self.pos < len(self.field):
            if self.field[self.pos] == '.':
                aslist.append('.')
                self.pos += 1
            elif self.field[self.pos] == '"':
                aslist.append('"%s"' % quote(self.getquote()))
            elif self.field[self.pos] in self.atomends:
                break
            else:
                aslist.append(self.getatom())
            self.gotonext()

        if self.pos >= len(self.field) or self.field[self.pos] != '@':
            return EMPTYSTRING.join(aslist)

        aslist.append('@')
        self.pos += 1
        self.gotonext()
        return EMPTYSTRING.join(aslist) + self.getdomain()

    def getdomain(self):
        """Get the complete domain name from an address."""
        sdlist = []
        while self.pos < len(self.field):
            if self.field[self.pos] in self.LWS:
                self.pos += 1
            elif self.field[self.pos] == '(':
                self.commentlist.append(self.getcomment())
            elif self.field[self.pos] == '[':
                sdlist.append(self.getdomainliteral())
            elif self.field[self.pos] == '.':
                self.pos += 1
                sdlist.append('.')
            elif self.field[self.pos] in self.atomends:
                break
            else:
                sdlist.append(self.getatom())
        return EMPTYSTRING.join(sdlist)

    def getdelimited(self, beginchar, endchars, allowcomments=True):
        """Parse a header fragment delimited by special characters.

        `beginchar' is the start character for the fragment.
        If self is not looking at an instance of `beginchar' then
        getdelimited returns the empty string.

        `endchars' is a sequence of allowable end-delimiting characters.
        Parsing stops when one of these is encountered.

        If `allowcomments' is non-zero, embedded RFC 2822 comments are allowed
        within the parsed fragment.
        """
        if self.field[self.pos] != beginchar:
            return ''

        slist = ['']
        quote = False
        self.pos += 1
        while self.pos < len(self.field):
            if quote:
                slist.append(self.field[self.pos])
                quote = False
            elif self.field[self.pos] in endchars:
                self.pos += 1
                break
            elif allowcomments and self.field[self.pos] == '(':
                slist.append(self.getcomment())
                continue        # have already advanced pos from getcomment
            elif self.field[self.pos] == '\\':
                quote = True
            else:
                slist.append(self.field[self.pos])
            self.pos += 1

        return EMPTYSTRING.join(slist)

    def getquote(self):
        """Get a quote-delimited fragment from self's field."""
        return self.getdelimited('"', '"\r', False)

    def getcomment(self):
        """Get a parenthesis-delimited fragment from self's field."""
        return self.getdelimited('(', ')\r', True)

    def getdomainliteral(self):
        """Parse an RFC 2822 domain-literal."""
        return '[%s]' % self.getdelimited('[', ']\r', False)

    def getatom(self, atomends=None):
        """Parse an RFC 2822 atom.

        Optional atomends specifies a different set of end token delimiters
        (the default is to use self.atomends).  This is used e.g. in
        getphraselist() since phrase endings must not include the `.' (which
        is legal in phrases)."""
        atomlist = ['']
        if atomends is None:
            atomends = self.atomends

        while self.pos < len(self.field):
            if self.field[self.pos] in atomends:
                break
            else:
                atomlist.append(self.field[self.pos])
            self.pos += 1

        return EMPTYSTRING.join(atomlist)

    def getphraselist(self):
        """Parse a sequence of RFC 2822 phrases.

        A phrase is a sequence of words, which are in turn either RFC 2822
        atoms or quoted-strings.  Phrases are canonicalized by squeezing all
        runs of continuous whitespace into one space.
        """
        plist = []

        while self.pos < len(self.field):
            if self.field[self.pos] in self.FWS:
                self.pos += 1
            elif self.field[self.pos] == '"':
                plist.append(self.getquote())
            elif self.field[self.pos] == '(':
                self.commentlist.append(self.getcomment())
            elif self.field[self.pos] in self.phraseends:
                break
            else:
                plist.append(self.getatom(self.phraseends))

        return plist

class AddressList(AddrlistClass):
    """An AddressList encapsulates a list of parsed RFC 2822 addresses."""
    def __init__(self, field):
        AddrlistClass.__init__(self, field)
        if field:
            self.addresslist = self.getaddrlist()
        else:
            self.addresslist = []

    def __len__(self):
        return len(self.addresslist)

    def __add__(self, other):
        # Set union
        newaddr = AddressList(None)
        newaddr.addresslist = self.addresslist[:]
        for x in other.addresslist:
            if not x in self.addresslist:
                newaddr.addresslist.append(x)
        return newaddr

    def __iadd__(self, other):
        # Set union, in-place
        for x in other.addresslist:
            if not x in self.addresslist:
                self.addresslist.append(x)
        return self

    def __sub__(self, other):
        # Set difference
        newaddr = AddressList(None)
        for x in self.addresslist:
            if not x in other.addresslist:
                newaddr.addresslist.append(x)
        return newaddr

    def __isub__(self, other):
        # Set difference, in-place
        for x in other.addresslist:
            if x in self.addresslist:
                self.addresslist.remove(x)
        return self

    def __getitem__(self, index):
        # Make indexing, slices, and 'in' work
        return self.addresslist[index]
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Û
”´[c           @   sd  d  Z  d d d d g Z d d l Z d d l Z d Z d Z d	 Z d
 d d d d d d d d d d d d d d d d d d d d d d d  g Z d! d" d# d$ d% d& d' g Z i d( d) 6d( d* 6d( d+ 6d( d, 6d- d. 6d/ d0 6d1 d2 6d- d3 6d4 d5 6d1 d6 6d7 d8 6d4 d9 6d: d; 6d7 d< 6Z	 d= Ñ  Z
 d> Ñ  Z d? Ñ  Z d@ Ñ  Z dA f  dB Ñ  É  YZ dC e f dD Ñ  É  YZ d S(E   sc   Email address parsing code.

Lifted directly from rfc822.py.  This should eventually be rewritten.
t	   mktime_tzt	   parsedatet   parsedate_tzt   quoteiˇˇˇˇNt    t    s   , t   jant   febt   mart   aprt   mayt   junt   jult   augt   sept   octt   novt   dect   januaryt   februaryt   marcht   aprilt   junet   julyt   augustt	   septembert   octobert   novembert   decembert   mont   tuet   wedt   thut   frit   satt   suni    t   UTt   UTCt   GMTt   Zip˛ˇˇt   ASTi‘˛ˇˇt   ADTi˛ˇˇt   ESTt   EDTi®˝ˇˇt   CSTt   CDTiD˝ˇˇt   MSTt   MDTi‡¸ˇˇt   PSTt   PDTc      
   C   s  |  j  É  }  |  d j d É s5 |  d j É  t k r? |  d =n8 |  d j d É } | d k rw |  d | d |  d <n  t |  É d k r¬ |  d j  d É } t | É d k r¬ | |  d }  q¬ n  t |  É d k r(|  d } | j d É } | d k r| |  | | d g |  d )q(|  j d É n  t |  É d	 k  r>d S|  d	  }  |  \ } } } } } | j É  } | t	 k rõ| | j É  } } | t	 k rõd Sn  t	 j
 | É d } | d
 k r«| d
 8} n  | d d k r‰| d  } n  | j d É } | d k r| | } } n  | d d k r,| d  } n  | d j É  sL| | } } n  | d d k ri| d  } n  | j  d É } t | É d k rü| \ }	 }
 d } n( t | É d k r√| \ }	 }
 } n d Sy@ t | É } t | É } t |	 É }	 t |
 É }
 t | É } Wn t k
 rd SX| d k  rN| d k rA| d 7} qN| d 7} n  d } | j É  } | t k ryt | } n$ y t | É } Wn t k
 rún X| rÊ| d k  rød } | } n d } | | d d | d d } n  | | | |	 |
 | d d d | f
 S(   sQ   Convert a date string to a time tuple.

    Accounts for military timezones.
    i    t   ,i   i   t   -i   t   +R   i   i   iˇˇˇˇt   :i   t   0id   iD   il  i–  i  i<   N(   t   splitt   endswitht   lowert	   _daynamest   rfindt   lent   findt   appendt   Nonet   _monthnamest   indext   isdigitt   intt
   ValueErrort   uppert
   _timezones(   t   datat   it   stufft   st   ddt   mmt   yyt   tmt   tzt   thht   tmmt   tsst   tzoffsett   tzsign(    (    s&   /usr/lib/python2.7/email/_parseaddr.pyR   -   sí    )


	
!c         C   s+   t  |  É } t | t É r# | d  S| Sd S(   s&   Convert a time string to a time tuple.i	   N(   R   t
   isinstancet   tuple(   RG   t   t(    (    s&   /usr/lib/python2.7/email/_parseaddr.pyR   è   s    c         C   sD   |  d d k r% t j |  d  d É St j |  É } | |  d Sd S(   sE   Turn a 10-tuple as returned by parsedate_tz() into a POSIX timestamp.i	   i   iˇˇˇˇN(   iˇˇˇˇ(   R?   t   timet   mktimet   calendart   timegm(   RG   RW   (    (    s&   /usr/lib/python2.7/email/_parseaddr.pyR    ò   s    c         C   s   |  j  d d É j  d d É S(   s¯   Prepare string to be used in a quoted string.

    Turns backslash and double quote characters into quoted pairs.  These
    are the only characters that need to be quoted inside a quoted string.
    Does not add the surrounding double quotes.
    s   \s   \\t   "s   \"(   t   replace(   t   str(    (    s&   /usr/lib/python2.7/email/_parseaddr.pyR   ¢   s    t   AddrlistClassc           B   sâ   e  Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 e
 d Ñ Z d	 Ñ  Z d
 Ñ  Z d Ñ  Z d d Ñ Z d Ñ  Z RS(   s˛   Address parser class by Ben Escoto.

    To understand what this class does, it helps to have a copy of RFC 2822 in
    front of you.

    Note: this class interface is deprecated and may be removed in the future.
    Use rfc822.AddressList instead.
    c         C   s   d |  _  d |  _ d |  _ d |  _ |  j |  j |  _ |  j  |  j |  j |  _ |  j j d d É |  _ | |  _ g  |  _	 d S(   sÉ   Initialize a new instance.

        `field' is an unparsed address header field, containing
        one or more addresses.
        s   ()<>@,:;."[]i    s    	s   
t   .R   N(
   t   specialst   post   LWSt   CRt   FWSt   atomendsR]   t
   phraseendst   fieldt   commentlist(   t   selfRh   (    (    s&   /usr/lib/python2.7/email/_parseaddr.pyt   __init__∂   s    					c         C   sÇ   x{ |  j  t |  j É k  r} |  j |  j  |  j d k rJ |  j  d 7_  q |  j |  j  d k ry |  j j |  j É  É q Pq Wd S(   s*   Parse up to the start of the next address.s   
i   t   (N(   Rb   R<   Rh   Rc   Ri   R>   t
   getcomment(   Rj   (    (    s&   /usr/lib/python2.7/email/_parseaddr.pyt   gotonext…   s    c         C   sU   g  } xH |  j  t |  j É k  rP |  j É  } | r@ | | 7} q	 | j d É q	 W| S(   sV   Parse all addresses.

        Returns a list containing all of the addresses.
        R   (   R   R   (   Rb   R<   Rh   t
   getaddressR>   (   Rj   t   resultt   ad(    (    s&   /usr/lib/python2.7/email/_parseaddr.pyt   getaddrlist”   s    c         C   sû  g  |  _  |  j É  |  j } |  j  } |  j É  } |  j É  g  } |  j t |  j É k rÑ | rPt j |  j  É | d f g } qPnÃ|  j |  j d k r÷ | |  _ | |  _  |  j É  } t j |  j  É | f g } nz|  j |  j d k rÑg  } t |  j É } |  j d 7_ x=|  j t |  j É k  rÄ|  j É  |  j | k  rm|  j |  j d k rm|  j d 7_ Pn  | |  j	 É  } qWnÃ |  j |  j d k r˝|  j
 É  } |  j  r‚t j | É d d j |  j  É d	 | f g } qPt j | É | f g } nS | r%t j |  j  É | d f g } n+ |  j |  j |  j k rP|  j d 7_ n  |  j É  |  j t |  j É k  rö|  j |  j d
 k rö|  j d 7_ n  | S(   s   Parse the next address.i    s   .@R5   i   t   ;t   <s    (R   t   )R2   (   Ri   Rn   Rb   t   getphraselistR<   Rh   t   SPACEt   joint   getaddrspecRo   t   getrouteaddrRa   (   Rj   t   oldpost   oldclt   plistt
   returnlistt   addrspect   fieldlent	   routeaddr(    (    s&   /usr/lib/python2.7/email/_parseaddr.pyRo   ·   sL    	
		
%		
%	3"
.c         C   s   |  j  |  j d k r d St } |  j d 7_ |  j É  d } x⁄ |  j t |  j  É k  r| rs |  j É  t } nõ |  j  |  j d k rú |  j d 7_ Pnr |  j  |  j d k r  |  j d 7_ t } nD |  j  |  j d k rÚ |  j d 7_ n |  j É  } |  j d 7_ P|  j É  qB W| S(   sÅ   Parse a route address (Return-path value).

        This method just skips all the route stuff and returns the addrspec.
        Rt   Ni   R   t   >t   @R5   (   Rh   Rb   t   FalseRn   R<   t	   getdomaint   TrueRy   (   Rj   t   expectroutet   adlist(    (    s&   /usr/lib/python2.7/email/_parseaddr.pyRz     s.    

		c         C   sL  g  } |  j  É  x¡ |  j t |  j É k  r” |  j |  j d k r` | j d É |  j d 7_ nf |  j |  j d k rñ | j d t |  j É  É É n0 |  j |  j |  j k r≥ Pn | j |  j É  É |  j  É  q W|  j t |  j É k s|  j |  j d k rt	 j
 | É S| j d É |  j d 7_ |  j  É  t	 j
 | É |  j É  S(   s   Parse an RFC 2822 addr-spec.R`   i   R\   s   "%s"RÉ   (   Rn   Rb   R<   Rh   R>   R   t   getquoteRf   t   getatomt   EMPTYSTRINGRx   RÖ   (   Rj   t   aslist(    (    s&   /usr/lib/python2.7/email/_parseaddr.pyRy   <  s$    
 .
c         C   s  g  } x|  j  t |  j É k  r|  j |  j  |  j k rL |  j  d 7_  q	 |  j |  j  d k r{ |  j j |  j É  É q	 |  j |  j  d k rß | j |  j É  É q	 |  j |  j  d k r‹ |  j  d 7_  | j d É q	 |  j |  j  |  j k r˘ Pq	 | j |  j	 É  É q	 Wt
 j | É S(   s-   Get the complete domain name from an address.i   Rl   t   [R`   (   Rb   R<   Rh   Rc   Ri   R>   Rm   t   getdomainliteralRf   Rä   Rã   Rx   (   Rj   t   sdlist(    (    s&   /usr/lib/python2.7/email/_parseaddr.pyRÖ   U  s    c         C   s-  |  j  |  j | k r d Sd g } t } |  j d 7_ xÂ |  j t |  j  É k  r| ry | j |  j  |  j É t } nî |  j  |  j | k r¢ |  j d 7_ Pnk | r◊ |  j  |  j d k r◊ | j |  j É  É q; n6 |  j  |  j d k rˆ t } n | j |  j  |  j É |  j d 7_ q; Wt j | É S(   sÊ  Parse a header fragment delimited by special characters.

        `beginchar' is the start character for the fragment.
        If self is not looking at an instance of `beginchar' then
        getdelimited returns the empty string.

        `endchars' is a sequence of allowable end-delimiting characters.
        Parsing stops when one of these is encountered.

        If `allowcomments' is non-zero, embedded RFC 2822 comments are allowed
        within the parsed fragment.
        R   i   Rl   s   \(	   Rh   Rb   RÑ   R<   R>   Rm   RÜ   Rã   Rx   (   Rj   t	   beginchart   endcharst   allowcommentst   slistR   (    (    s&   /usr/lib/python2.7/email/_parseaddr.pyt   getdelimitedh  s(    			c         C   s   |  j  d d t É S(   s1   Get a quote-delimited fragment from self's field.R\   s   "(   Rî   RÑ   (   Rj   (    (    s&   /usr/lib/python2.7/email/_parseaddr.pyRâ   ç  s    c         C   s   |  j  d d t É S(   s7   Get a parenthesis-delimited fragment from self's field.Rl   s   )(   Rî   RÜ   (   Rj   (    (    s&   /usr/lib/python2.7/email/_parseaddr.pyRm   ë  s    c         C   s   d |  j  d d t É S(   s!   Parse an RFC 2822 domain-literal.s   [%s]Rç   s   ](   Rî   RÑ   (   Rj   (    (    s&   /usr/lib/python2.7/email/_parseaddr.pyRé   ï  s    c         C   sç   d g } | d k r! |  j } n  x\ |  j t |  j É k  r |  j |  j | k rV Pn | j |  j |  j É |  j d 7_ q$ Wt j | É S(   s  Parse an RFC 2822 atom.

        Optional atomends specifies a different set of end token delimiters
        (the default is to use self.atomends).  This is used e.g. in
        getphraselist() since phrase endings must not include the `.' (which
        is legal in phrases).R   i   N(   R?   Rf   Rb   R<   Rh   R>   Rã   Rx   (   Rj   Rf   t   atomlist(    (    s&   /usr/lib/python2.7/email/_parseaddr.pyRä   ô  s    	c         C   sÂ   g  } xÿ |  j  t |  j É k  r‡ |  j |  j  |  j k rL |  j  d 7_  q	 |  j |  j  d k rx | j |  j É  É q	 |  j |  j  d k rß |  j j |  j É  É q	 |  j |  j  |  j k rƒ Pq	 | j |  j	 |  j É É q	 W| S(   s˝   Parse a sequence of RFC 2822 phrases.

        A phrase is a sequence of words, which are in turn either RFC 2822
        atoms or quoted-strings.  Phrases are canonicalized by squeezing all
        runs of continuous whitespace into one space.
        i   R\   Rl   (
   Rb   R<   Rh   Re   R>   Râ   Ri   Rm   Rg   Rä   (   Rj   R}   (    (    s&   /usr/lib/python2.7/email/_parseaddr.pyRv   ≠  s    N(   t   __name__t
   __module__t   __doc__Rk   Rn   Rr   Ro   Rz   Ry   RÖ   RÜ   Rî   Râ   Rm   Ré   R?   Rä   Rv   (    (    (    s&   /usr/lib/python2.7/email/_parseaddr.pyR_   ¨   s   		
		;	 		%			t   AddressListc           B   sM   e  Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 RS(   s@   An AddressList encapsulates a list of parsed RFC 2822 addresses.c         C   s5   t  j |  | É | r( |  j É  |  _ n	 g  |  _ d  S(   N(   R_   Rk   Rr   t   addresslist(   Rj   Rh   (    (    s&   /usr/lib/python2.7/email/_parseaddr.pyRk   ∆  s    c         C   s   t  |  j É S(   N(   R<   Rö   (   Rj   (    (    s&   /usr/lib/python2.7/email/_parseaddr.pyt   __len__Õ  s    c         C   sS   t  d  É } |  j | _ x3 | j D]( } | |  j k r# | j j | É q# q# W| S(   N(   Rô   R?   Rö   R>   (   Rj   t   othert   newaddrt   x(    (    s&   /usr/lib/python2.7/email/_parseaddr.pyt   __add__–  s    c         C   s:   x3 | j  D]( } | |  j  k r
 |  j  j | É q
 q
 W|  S(   N(   Rö   R>   (   Rj   Rú   Rû   (    (    s&   /usr/lib/python2.7/email/_parseaddr.pyt   __iadd__Ÿ  s    c         C   sF   t  d  É } x3 |  j D]( } | | j k r | j j | É q q W| S(   N(   Rô   R?   Rö   R>   (   Rj   Rú   Rù   Rû   (    (    s&   /usr/lib/python2.7/email/_parseaddr.pyt   __sub__‡  s
    c         C   s:   x3 | j  D]( } | |  j  k r
 |  j  j | É q
 q
 W|  S(   N(   Rö   t   remove(   Rj   Rú   Rû   (    (    s&   /usr/lib/python2.7/email/_parseaddr.pyt   __isub__Ë  s    c         C   s   |  j  | S(   N(   Rö   (   Rj   RA   (    (    s&   /usr/lib/python2.7/email/_parseaddr.pyt   __getitem__Ô  s    (
   Rñ   Ró   Rò   Rk   Rõ   Rü   R†   R°   R£   R§   (    (    (    s&   /usr/lib/python2.7/email/_parseaddr.pyRô   ƒ  s   							(   Rò   t   __all__RX   RZ   Rw   Rã   t
   COMMASPACER@   R:   RF   R   R   R    R   R_   Rô   (    (    (    s&   /usr/lib/python2.7/email/_parseaddr.pyt   <module>   s4   		b			
	
ˇ                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      Û
”´[c           @   s∫   d  Z  d d d d d d d d g Z d	 d
 l m Z m Z d	 d l m Z d Z d Z d Z	 d Z
 d Ñ  Z d e d e d Ñ Z e d e d Ñ Z e Z e Z d d Ñ Z e Z e Z d S(   sõ  Base64 content transfer encoding per RFCs 2045-2047.

This module handles the content transfer encoding method defined in RFC 2045
to encode arbitrary 8-bit data using the three 8-bit bytes in four 7-bit
characters encoding known as Base64.

It is used in the MIME standards for email to attach images, audio, and text
using some 8-bit character sets to messages.

This module provides an interface to encode and decode both headers and bodies
with Base64 encoding.

RFC 2045 defines a method for including character set information in an
`encoded-word' in a header.  This method is commonly used for 8-bit real names
in To:, From:, Cc:, etc. fields, as well as Subject: lines.

This module does not do the line wrapping or end-of-line character conversion
necessary for proper internationalized headers; it only does dumb encoding and
decoding.  To deal with the various line wrapping issues, use the email.header
module.
t
   base64_lent   body_decodet   body_encodet   decodet   decodestringt   encodet   encodestringt   header_encodeiˇˇˇˇ(   t
   b2a_base64t
   a2b_base64(   t   fix_eolss   
s   
t    i   c         C   s<   t  t |  É d É \ } } | d } | r8 | d 7} n  | S(   s6   Return the length of s when it is encoded with base64.i   i   (   t   divmodt   len(   t   st   groups_of_3t   leftovert   n(    (    s&   /usr/lib/python2.7/email/base64mime.pyR    4   s
    
s
   iso-8859-1iL   c         C   sÈ   |  s
 |  S| s t  |  É }  n  g  } | t | É t } | d d } x> t d t |  É | É D]$ } | j t |  | | | !É É q` Wg  }	 xA | D]9 }
 |
 j t É r∑ |
 d  }
 n  |	 j d | |
 f É qï W| d } | j |	 É S(   s0  Encode a single header line with Base64 encoding in a given charset.

    Defined in RFC 2045, this Base64 encoding is identical to normal Base64
    encoding, except that each line must be intelligently wrapped (respecting
    the Base64 encoding), and subsequent lines must start with a space.

    charset names the character set to use to encode the header.  It defaults
    to iso-8859-1.

    End-of-line characters (\r, \n, \r\n) will be automatically converted
    to the canonical email line separator \r\n unless the keep_eols
    parameter is True (the default is False).

    Each line of the header will be terminated in the value of eol, which
    defaults to "\n".  Set this to "\r\n" if you are using the result of
    this function directly in email.

    The resulting string will be in the form:

    "=?charset?b?WW/5ciBtYXp66XLrIHf8eiBhIGhhbXBzdGHuciBBIFlv+XIgbWF6euly?=\n
      =?charset?b?6yB3/HogYSBoYW1wc3Rh7nIgQkMgWW/5ciBtYXp66XLrIHf8eiBhIGhh?="

    with each line wrapped at, at most, maxlinelen characters (defaults to 76
    characters).
    i   i   i    iˇˇˇˇs   =?%s?b?%s?=t    (	   R
   R   t   MISC_LENt   ranget   appendR   t   endswitht   NLt   join(   t   headert   charsett	   keep_eolst
   maxlinelent   eolt   base64edt   max_encodedt   max_unencodedt   it   linest   linet   joiner(    (    s&   /usr/lib/python2.7/email/base64mime.pyR   @   s     "
c         C   s≥   |  s
 |  S| s t  |  É }  n  g  } | d d } xp t d t |  É | É D]V } t |  | | | !É } | j t É rï | t k rï | d  | } n  | j | É qL Wt j | É S(   sÍ  Encode a string with base64.

    Each line will be wrapped at, at most, maxlinelen characters (defaults to
    76 characters).

    If binary is False, end-of-line characters will be converted to the
    canonical email end-of-line sequence \r\n.  Otherwise they will be left
    verbatim (this is the default).

    Each line of encoded text will end with eol, which defaults to "\n".  Set
    this to "\r\n" if you will be using the result of this function directly
    in an email.
    i   i   i    iˇˇˇˇ(	   R
   R   R   R   R   R   R   t   EMPTYSTRINGR   (   R   t   binaryR   R   t   encvecR    R!   t   enc(    (    s&   /usr/lib/python2.7/email/base64mime.pyR   z   s    c         C   s0   |  s
 |  St  |  É } | r, | j t | É S| S(   s‰  Decode a raw base64 string.

    If convert_eols is set to a string value, all canonical email linefeeds,
    e.g. "\r\n", in the decoded text will be converted to the value of
    convert_eols.  os.linesep is a good choice for convert_eols if you are
    decoding a text attachment.

    This function does not parse a full MIME header value encoded with
    base64 (like =?iso-8859-1?b?bmloISBuaWgh?=) -- please use the high
    level email.header class for that functionality.
    (   R	   t   replacet   CRLF(   R   t   convert_eolst   dec(    (    s&   /usr/lib/python2.7/email/base64mime.pyR   †   s    N(   t   __doc__t   __all__t   binasciiR   R	   t   email.utilsR
   R*   R   R%   R   R    t   FalseR   t   TrueR   R   R   t   NoneR   R   R   (    (    (    s&   /usr/lib/python2.7/email/base64mime.pyt   <module>   s.   		9!                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               # Copyright (C) 2001-2006 Python Software Foundation
# Author: Barry Warsaw
# Contact: email-sig@python.org

"""Encodings and related functions."""

__all__ = [
    'encode_7or8bit',
    'encode_base64',
    'encode_noop',
    'encode_quopri',
    ]

import base64

from quopri import encodestring as _encodestring



def _qencode(s):
    enc = _encodestring(s, quotetabs=True)
    # Must encode spaces, which quopri.encodestring() doesn't do
    return enc.replace(' ', '=20')


def _bencode(s):
    # We can't quite use base64.encodestring() since it tacks on a "courtesy
    # newline".  Blech!
    if not s:
        return s
    hasnewline = (s[-1] == '\n')
    value = base64.encodestring(s)
    if not hasnewline and value[-1] == '\n':
        return value[:-1]
    return value



def encode_base64(msg):
    """Encode the message's payload in Base64.

    Also, add an appropriate Content-Transfer-Encoding header.
    """
    orig = msg.get_payload()
    encdata = _bencode(orig)
    msg.set_payload(encdata)
    msg['Content-Transfer-Encoding'] = 'base64'



def encode_quopri(msg):
    """Encode the message's payload in quoted-printable.

    Also, add an appropriate Content-Transfer-Encoding header.
    """
    orig = msg.get_payload()
    encdata = _qencode(orig)
    msg.set_payload(encdata)
    msg['Content-Transfer-Encoding'] = 'quoted-printable'



def encode_7or8bit(msg):
    """Set the Content-Transfer-Encoding header to 7bit or 8bit."""
    orig = msg.get_payload()
    if orig is None:
        # There's no payload.  For backwards compatibility we use 7bit
        msg['Content-Transfer-Encoding'] = '7bit'
        return
    # We play a trick to make this go fast.  If encoding to ASCII succeeds, we
    # know the data must be 7bit, otherwise treat it as 8bit.
    try:
        orig.encode('ascii')
    except UnicodeError:
        msg['Content-Transfer-Encoding'] = '8bit'
    else:
        msg['Content-Transfer-Encoding'] = '7bit'



def encode_noop(msg):
    """Do nothing."""
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 Û
”´[c           @   sn   d  Z  d d d d g Z d d l Z d d l m Z d Ñ  Z d	 Ñ  Z d
 Ñ  Z d Ñ  Z	 d Ñ  Z
 d Ñ  Z d S(   s    Encodings and related functions.t   encode_7or8bitt   encode_base64t   encode_noopt   encode_quopriiˇˇˇˇN(   t   encodestringc         C   s"   t  |  d t É} | j d d É S(   Nt	   quotetabst    s   =20(   t   _encodestringt   Truet   replace(   t   st   enc(    (    s$   /usr/lib/python2.7/email/encoders.pyt   _qencode   s    c         C   sL   |  s
 |  S|  d d k } t  j |  É } | rH | d d k rH | d  S| S(   Niˇˇˇˇs   
(   t   base64R   (   R
   t
   hasnewlinet   value(    (    s$   /usr/lib/python2.7/email/encoders.pyt   _bencode   s    c         C   s3   |  j  É  } t | É } |  j | É d |  d <d S(   sl   Encode the message's payload in Base64.

    Also, add an appropriate Content-Transfer-Encoding header.
    R   s   Content-Transfer-EncodingN(   t   get_payloadR   t   set_payload(   t   msgt   origt   encdata(    (    s$   /usr/lib/python2.7/email/encoders.pyR   '   s    c         C   s3   |  j  É  } t | É } |  j | É d |  d <d S(   sv   Encode the message's payload in quoted-printable.

    Also, add an appropriate Content-Transfer-Encoding header.
    s   quoted-printables   Content-Transfer-EncodingN(   R   R   R   (   R   R   R   (    (    s$   /usr/lib/python2.7/email/encoders.pyR   3   s    c         C   sc   |  j  É  } | d k r& d |  d <d Sy | j d É Wn t k
 rT d |  d <n Xd |  d <d S(   s9   Set the Content-Transfer-Encoding header to 7bit or 8bit.t   7bits   Content-Transfer-EncodingNt   asciit   8bit(   R   t   Nonet   encodet   UnicodeError(   R   R   (    (    s$   /usr/lib/python2.7/email/encoders.pyR    ?   s    
c         C   s   d S(   s   Do nothing.N(    (   R   (    (    s$   /usr/lib/python2.7/email/encoders.pyR   Q   s    (   t   __doc__t   __all__R   t   quopriR   R   R   R   R   R   R    R   (    (    (    s$   /usr/lib/python2.7/email/encoders.pyt   <module>   s   						                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      # Copyright (C) 2001-2006 Python Software Foundation
# Author: Ben Gertzfield, Barry Warsaw
# Contact: email-sig@python.org

__all__ = [
    'Charset',
    'add_alias',
    'add_charset',
    'add_codec',
    ]

import codecs
import email.base64mime
import email.quoprimime

from email import errors
from email.encoders import encode_7or8bit



# Flags for types of header encodings
QP          = 1 # Quoted-Printable
BASE64      = 2 # Base64
SHORTEST    = 3 # the shorter of QP and base64, but only for headers

# In "=?charset?q?hello_world?=", the =?, ?q?, and ?= add up to 7
MISC_LEN = 7

DEFAULT_CHARSET = 'us-ascii'



# Defaults
CHARSETS = {
    # input        header enc  body enc output conv
    'iso-8859-1':  (QP,        QP,      None),
    'iso-8859-2':  (QP,        QP,      None),
    'iso-8859-3':  (QP,        QP,      None),
    'iso-8859-4':  (QP,        QP,      None),
    # iso-8859-5 is Cyrillic, and not especially used
    # iso-8859-6 is Arabic, also not particularly used
    # iso-8859-7 is Greek, QP will not make it readable
    # iso-8859-8 is Hebrew, QP will not make it readable
    'iso-8859-9':  (QP,        QP,      None),
    'iso-8859-10': (QP,        QP,      None),
    # iso-8859-11 is Thai, QP will not make it readable
    'iso-8859-13': (QP,        QP,      None),
    'iso-8859-14': (QP,        QP,      None),
    'iso-8859-15': (QP,        QP,      None),
    'iso-8859-16': (QP,        QP,      None),
    'windows-1252':(QP,        QP,      None),
    'viscii':      (QP,        QP,      None),
    'us-ascii':    (None,      None,    None),
    'big5':        (BASE64,    BASE64,  None),
    'gb2312':      (BASE64,    BASE64,  None),
    'euc-jp':      (BASE64,    None,    'iso-2022-jp'),
    'shift_jis':   (BASE64,    None,    'iso-2022-jp'),
    'iso-2022-jp': (BASE64,    None,    None),
    'koi8-r':      (BASE64,    BASE64,  None),
    'utf-8':       (SHORTEST,  BASE64, 'utf-8'),
    # We're making this one up to represent raw unencoded 8-bit
    '8bit':        (None,      BASE64, 'utf-8'),
    }

# Aliases for other commonly-used names for character sets.  Map
# them to the real ones used in email.
ALIASES = {
    'latin_1': 'iso-8859-1',
    'latin-1': 'iso-8859-1',
    'latin_2': 'iso-8859-2',
    'latin-2': 'iso-8859-2',
    'latin_3': 'iso-8859-3',
    'latin-3': 'iso-8859-3',
    'latin_4': 'iso-8859-4',
    'latin-4': 'iso-8859-4',
    'latin_5': 'iso-8859-9',
    'latin-5': 'iso-8859-9',
    'latin_6': 'iso-8859-10',
    'latin-6': 'iso-8859-10',
    'latin_7': 'iso-8859-13',
    'latin-7': 'iso-8859-13',
    'latin_8': 'iso-8859-14',
    'latin-8': 'iso-8859-14',
    'latin_9': 'iso-8859-15',
    'latin-9': 'iso-8859-15',
    'latin_10':'iso-8859-16',
    'latin-10':'iso-8859-16',
    'cp949':   'ks_c_5601-1987',
    'euc_jp':  'euc-jp',
    'euc_kr':  'euc-kr',
    'ascii':   'us-ascii',
    }


# Map charsets to their Unicode codec strings.
CODEC_MAP = {
    'gb2312':      'eucgb2312_cn',
    'big5':        'big5_tw',
    # Hack: We don't want *any* conversion for stuff marked us-ascii, as all
    # sorts of garbage might be sent to us in the guise of 7-bit us-ascii.
    # Let that stuff pass through without conversion to/from Unicode.
    'us-ascii':    None,
    }



# Convenience functions for extending the above mappings
def add_charset(charset, header_enc=None, body_enc=None, output_charset=None):
    """Add character set properties to the global registry.

    charset is the input character set, and must be the canonical name of a
    character set.

    Optional header_enc and body_enc is either Charset.QP for
    quoted-printable, Charset.BASE64 for base64 encoding, Charset.SHORTEST for
    the shortest of qp or base64 encoding, or None for no encoding.  SHORTEST
    is only valid for header_enc.  It describes how message headers and
    message bodies in the input charset are to be encoded.  Default is no
    encoding.

    Optional output_charset is the character set that the output should be
    in.  Conversions will proceed from input charset, to Unicode, to the
    output charset when the method Charset.convert() is called.  The default
    is to output in the same character set as the input.

    Both input_charset and output_charset must have Unicode codec entries in
    the module's charset-to-codec mapping; use add_codec(charset, codecname)
    to add codecs the module does not know about.  See the codecs module's
    documentation for more information.
    """
    if body_enc == SHORTEST:
        raise ValueError('SHORTEST not allowed for body_enc')
    CHARSETS[charset] = (header_enc, body_enc, output_charset)


def add_alias(alias, canonical):
    """Add a character set alias.

    alias is the alias name, e.g. latin-1
    canonical is the character set's canonical name, e.g. iso-8859-1
    """
    ALIASES[alias] = canonical


def add_codec(charset, codecname):
    """Add a codec that map characters in the given charset to/from Unicode.

    charset is the canonical name of a character set.  codecname is the name
    of a Python codec, as appropriate for the second argument to the unicode()
    built-in, or to the encode() method of a Unicode string.
    """
    CODEC_MAP[charset] = codecname



class Charset:
    """Map character sets to their email properties.

    This class provides information about the requirements imposed on email
    for a specific character set.  It also provides convenience routines for
    converting between character sets, given the availability of the
    applicable codecs.  Given a character set, it will do its best to provide
    information on how to use that character set in an email in an
    RFC-compliant way.

    Certain character sets must be encoded with quoted-printable or base64
    when used in email headers or bodies.  Certain character sets must be
    converted outright, and are not allowed in email.  Instances of this
    module expose the following information about a character set:

    input_charset: The initial character set specified.  Common aliases
                   are converted to their `official' email names (e.g. latin_1
                   is converted to iso-8859-1).  Defaults to 7-bit us-ascii.

    header_encoding: If the character set must be encoded before it can be
                     used in an email header, this attribute will be set to
                     Charset.QP (for quoted-printable), Charset.BASE64 (for
                     base64 encoding), or Charset.SHORTEST for the shortest of
                     QP or BASE64 encoding.  Otherwise, it will be None.

    body_encoding: Same as header_encoding, but describes the encoding for the
                   mail message's body, which indeed may be different than the
                   header encoding.  Charset.SHORTEST is not allowed for
                   body_encoding.

    output_charset: Some character sets must be converted before they can be
                    used in email headers or bodies.  If the input_charset is
                    one of them, this attribute will contain the name of the
                    charset output will be converted to.  Otherwise, it will
                    be None.

    input_codec: The name of the Python codec used to convert the
                 input_charset to Unicode.  If no conversion codec is
                 necessary, this attribute will be None.

    output_codec: The name of the Python codec used to convert Unicode
                  to the output_charset.  If no conversion codec is necessary,
                  this attribute will have the same value as the input_codec.
    """
    def __init__(self, input_charset=DEFAULT_CHARSET):
        # RFC 2046, $4.1.2 says charsets are not case sensitive.  We coerce to
        # unicode because its .lower() is locale insensitive.  If the argument
        # is already a unicode, we leave it at that, but ensure that the
        # charset is ASCII, as the standard (RFC XXX) requires.
        try:
            if isinstance(input_charset, unicode):
                input_charset.encode('ascii')
            else:
                input_charset = unicode(input_charset, 'ascii')
        except UnicodeError:
            raise errors.CharsetError(input_charset)
        input_charset = input_charset.lower().encode('ascii')
        # Set the input charset after filtering through the aliases and/or codecs
        if not (input_charset in ALIASES or input_charset in CHARSETS):
            try:
                input_charset = codecs.lookup(input_charset).name
            except LookupError:
                pass
        self.input_charset = ALIASES.get(input_charset, input_charset)
        # We can try to guess which encoding and conversion to use by the
        # charset_map dictionary.  Try that first, but let the user override
        # it.
        henc, benc, conv = CHARSETS.get(self.input_charset,
                                        (SHORTEST, BASE64, None))
        if not conv:
            conv = self.input_charset
        # Set the attributes, allowing the arguments to override the default.
        self.header_encoding = henc
        self.body_encoding = benc
        self.output_charset = ALIASES.get(conv, conv)
        # Now set the codecs.  If one isn't defined for input_charset,
        # guess and try a Unicode codec with the same name as input_codec.
        self.input_codec = CODEC_MAP.get(self.input_charset,
                                         self.input_charset)
        self.output_codec = CODEC_MAP.get(self.output_charset,
                                          self.output_charset)

    def __str__(self):
        return self.input_charset.lower()

    __repr__ = __str__

    def __eq__(self, other):
        return str(self) == str(other).lower()

    def __ne__(self, other):
        return not self.__eq__(other)

    def get_body_encoding(self):
        """Return the content-transfer-encoding used for body encoding.

        This is either the string `quoted-printable' or `base64' depending on
        the encoding used, or it is a function in which case you should call
        the function with a single argument, the Message object being
        encoded.  The function should then set the Content-Transfer-Encoding
        header itself to whatever is appropriate.

        Returns "quoted-printable" if self.body_encoding is QP.
        Returns "base64" if self.body_encoding is BASE64.
        Returns "7bit" otherwise.
        """
        assert self.body_encoding != SHORTEST
        if self.body_encoding == QP:
            return 'quoted-printable'
        elif self.body_encoding == BASE64:
            return 'base64'
        else:
            return encode_7or8bit

    def convert(self, s):
        """Convert a string from the input_codec to the output_codec."""
        if self.input_codec != self.output_codec:
            return unicode(s, self.input_codec).encode(self.output_codec)
        else:
            return s

    def to_splittable(self, s):
        """Convert a possibly multibyte string to a safely splittable format.

        Uses the input_codec to try and convert the string to Unicode, so it
        can be safely split on character boundaries (even for multibyte
        characters).

        Returns the string as-is if it isn't known how to convert it to
        Unicode with the input_charset.

        Characters that could not be converted to Unicode will be replaced
        with the Unicode replacement character U+FFFD.
        """
        if isinstance(s, unicode) or self.input_codec is None:
            return s
        try:
            return unicode(s, self.input_codec, 'replace')
        except LookupError:
            # Input codec not installed on system, so return the original
            # string unchanged.
            return s

    def from_splittable(self, ustr, to_output=True):
        """Convert a splittable string back into an encoded string.

        Uses the proper codec to try and convert the string from Unicode back
        into an encoded format.  Return the string as-is if it is not Unicode,
        or if it could not be converted from Unicode.

        Characters that could not be converted from Unicode will be replaced
        with an appropriate character (usually '?').

        If to_output is True (the default), uses output_codec to convert to an
        encoded format.  If to_output is False, uses input_codec.
        """
        if to_output:
            codec = self.output_codec
        else:
            codec = self.input_codec
        if not isinstance(ustr, unicode) or codec is None:
            return ustr
        try:
            return ustr.encode(codec, 'replace')
        except LookupError:
            # Output codec not installed
            return ustr

    def get_output_charset(self):
        """Return the output character set.

        This is self.output_charset if that is not None, otherwise it is
        self.input_charset.
        """
        return self.output_charset or self.input_charset

    def encoded_header_len(self, s):
        """Return the length of the encoded header string."""
        cset = self.get_output_charset()
        # The len(s) of a 7bit encoding is len(s)
        if self.header_encoding == BASE64:
            return email.base64mime.base64_len(s) + len(cset) + MISC_LEN
        elif self.header_encoding == QP:
            return email.quoprimime.header_quopri_len(s) + len(cset) + MISC_LEN
        elif self.header_encoding == SHORTEST:
            lenb64 = email.base64mime.base64_len(s)
            lenqp = email.quoprimime.header_quopri_len(s)
            return min(lenb64, lenqp) + len(cset) + MISC_LEN
        else:
            return len(s)

    def header_encode(self, s, convert=False):
        """Header-encode a string, optionally converting it to output_charset.

        If convert is True, the string will be converted from the input
        charset to the output charset automatically.  This is not useful for
        multibyte character sets, which have line length issues (multibyte
        characters must be split on a character, not a byte boundary); use the
        high-level Header class to deal with these issues.  convert defaults
        to False.

        The type of encoding (base64 or quoted-printable) will be based on
        self.header_encoding.
        """
        cset = self.get_output_charset()
        if convert:
            s = self.convert(s)
        # 7bit/8bit encodings return the string unchanged (modulo conversions)
        if self.header_encoding == BASE64:
            return email.base64mime.header_encode(s, cset)
        elif self.header_encoding == QP:
            return email.quoprimime.header_encode(s, cset, maxlinelen=None)
        elif self.header_encoding == SHORTEST:
            lenb64 = email.base64mime.base64_len(s)
            lenqp = email.quoprimime.header_quopri_len(s)
            if lenb64 < lenqp:
                return email.base64mime.header_encode(s, cset)
            else:
                return email.quoprimime.header_encode(s, cset, maxlinelen=None)
        else:
            return s

    def body_encode(self, s, convert=True):
        """Body-encode a string and convert it to output_charset.

        If convert is True (the default), the string will be converted from
        the input charset to output charset automatically.  Unlike
        header_encode(), there are no issues with byte boundaries and
        multibyte charsets in email bodies, so this is usually pretty safe.

        The type of encoding (base64 or quoted-printable) will be based on
        self.body_encoding.
        """
        if convert:
            s = self.convert(s)
        # 7bit/8bit encodings return the string unchanged (module conversions)
        if self.body_encoding is BASE64:
            return email.base64mime.body_encode(s)
        elif self.body_encoding is QP:
            return email.quoprimime.body_encode(s)
        else:
            return s
                                                                                                                                                                                                                                                                                                                                                    Û
”´[c           @   s≈  d  d d d g Z  d d l Z d d l Z d d l Z d d l m Z d d l m Z d Z d	 Z	 d
 Z
 d Z d Z i e e d f d 6e e d f d 6e e d f d 6e e d f d 6e e d f d 6e e d f d 6e e d f d 6e e d f d 6e e d f d 6e e d f d 6e e d f d 6e e d f d 6dA d 6e	 e	 d f d 6e	 e	 d f d 6e	 d d f d 6e	 d d f d 6e	 d d f d 6e	 e	 d f d 6e
 e	 d f d 6d e	 d f d  6Z i d d! 6d d" 6d d# 6d d$ 6d d% 6d d& 6d d' 6d d( 6d d) 6d d* 6d d+ 6d d, 6d d- 6d d. 6d d/ 6d d0 6d d1 6d d2 6d d3 6d d4 6d5 d6 6d d7 6d8 d9 6d d: 6Z i d; d 6d< d 6d d 6Z d d d d= Ñ Z d> Ñ  Z d? Ñ  Z d  dB d@ Ñ  É  YZ d S(C   t   Charsett	   add_aliast   add_charsett	   add_codeciˇˇˇˇN(   t   errors(   t   encode_7or8biti   i   i   i   s   us-asciis
   iso-8859-1s
   iso-8859-2s
   iso-8859-3s
   iso-8859-4s
   iso-8859-9s   iso-8859-10s   iso-8859-13s   iso-8859-14s   iso-8859-15s   iso-8859-16s   windows-1252t   visciit   big5t   gb2312s   iso-2022-jps   euc-jpt	   shift_jiss   koi8-rs   utf-8t   8bitt   latin_1s   latin-1t   latin_2s   latin-2t   latin_3s   latin-3t   latin_4s   latin-4t   latin_5s   latin-5t   latin_6s   latin-6t   latin_7s   latin-7t   latin_8s   latin-8t   latin_9s   latin-9t   latin_10s   latin-10s   ks_c_5601-1987t   cp949t   euc_jps   euc-krt   euc_krt   asciit   eucgb2312_cnt   big5_twc         C   s2   | t  k r t d É Ç n  | | | f t |  <d S(   s>  Add character set properties to the global registry.

    charset is the input character set, and must be the canonical name of a
    character set.

    Optional header_enc and body_enc is either Charset.QP for
    quoted-printable, Charset.BASE64 for base64 encoding, Charset.SHORTEST for
    the shortest of qp or base64 encoding, or None for no encoding.  SHORTEST
    is only valid for header_enc.  It describes how message headers and
    message bodies in the input charset are to be encoded.  Default is no
    encoding.

    Optional output_charset is the character set that the output should be
    in.  Conversions will proceed from input charset, to Unicode, to the
    output charset when the method Charset.convert() is called.  The default
    is to output in the same character set as the input.

    Both input_charset and output_charset must have Unicode codec entries in
    the module's charset-to-codec mapping; use add_codec(charset, codecname)
    to add codecs the module does not know about.  See the codecs module's
    documentation for more information.
    s!   SHORTEST not allowed for body_encN(   t   SHORTESTt
   ValueErrort   CHARSETS(   t   charsett
   header_enct   body_enct   output_charset(    (    s#   /usr/lib/python2.7/email/charset.pyR   l   s    c         C   s   | t  |  <d S(   sè   Add a character set alias.

    alias is the alias name, e.g. latin-1
    canonical is the character set's canonical name, e.g. iso-8859-1
    N(   t   ALIASES(   t   aliast	   canonical(    (    s#   /usr/lib/python2.7/email/charset.pyR   à   s    c         C   s   | t  |  <d S(   s$  Add a codec that map characters in the given charset to/from Unicode.

    charset is the canonical name of a character set.  codecname is the name
    of a Python codec, as appropriate for the second argument to the unicode()
    built-in, or to the encode() method of a Unicode string.
    N(   t	   CODEC_MAP(   R   t	   codecname(    (    s#   /usr/lib/python2.7/email/charset.pyR   ë   s    c           B   så   e  Z d  Z e d Ñ Z d Ñ  Z e Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d Ñ  Z e d Ñ Z d	 Ñ  Z d
 Ñ  Z e d Ñ Z e d Ñ Z RS(   s@	  Map character sets to their email properties.

    This class provides information about the requirements imposed on email
    for a specific character set.  It also provides convenience routines for
    converting between character sets, given the availability of the
    applicable codecs.  Given a character set, it will do its best to provide
    information on how to use that character set in an email in an
    RFC-compliant way.

    Certain character sets must be encoded with quoted-printable or base64
    when used in email headers or bodies.  Certain character sets must be
    converted outright, and are not allowed in email.  Instances of this
    module expose the following information about a character set:

    input_charset: The initial character set specified.  Common aliases
                   are converted to their `official' email names (e.g. latin_1
                   is converted to iso-8859-1).  Defaults to 7-bit us-ascii.

    header_encoding: If the character set must be encoded before it can be
                     used in an email header, this attribute will be set to
                     Charset.QP (for quoted-printable), Charset.BASE64 (for
                     base64 encoding), or Charset.SHORTEST for the shortest of
                     QP or BASE64 encoding.  Otherwise, it will be None.

    body_encoding: Same as header_encoding, but describes the encoding for the
                   mail message's body, which indeed may be different than the
                   header encoding.  Charset.SHORTEST is not allowed for
                   body_encoding.

    output_charset: Some character sets must be converted before they can be
                    used in email headers or bodies.  If the input_charset is
                    one of them, this attribute will contain the name of the
                    charset output will be converted to.  Otherwise, it will
                    be None.

    input_codec: The name of the Python codec used to convert the
                 input_charset to Unicode.  If no conversion codec is
                 necessary, this attribute will be None.

    output_codec: The name of the Python codec used to convert Unicode
                  to the output_charset.  If no conversion codec is necessary,
                  this attribute will have the same value as the input_codec.
    c         C   s^  y2 t  | t É r" | j d É n t | d É } Wn  t k
 rT t j | É Ç n X| j É  j d É } | t k p | t k sØ y t	 j
 | É j } WqØ t k
 r´ qØ Xn  t j | | É |  _ t j |  j t t d  f É \ } } } | s˝ |  j } n  | |  _ | |  _ t j | | É |  _ t j |  j |  j É |  _ t j |  j |  j É |  _ d  S(   NR   (   t
   isinstancet   unicodet   encodet   UnicodeErrorR   t   CharsetErrort   lowerR"   R   t   codecst   lookupt   namet   LookupErrort   gett   input_charsetR   t   BASE64t   Nonet   header_encodingt   body_encodingR!   R%   t   input_codect   output_codec(   t   selfR2   t   henct   benct   conv(    (    s#   /usr/lib/python2.7/email/charset.pyt   __init__»   s0    		c         C   s   |  j  j É  S(   N(   R2   R,   (   R9   (    (    s#   /usr/lib/python2.7/email/charset.pyt   __str__Ó   s    c         C   s   t  |  É t  | É j É  k S(   N(   t   strR,   (   R9   t   other(    (    s#   /usr/lib/python2.7/email/charset.pyt   __eq__Û   s    c         C   s   |  j  | É S(   N(   RA   (   R9   R@   (    (    s#   /usr/lib/python2.7/email/charset.pyt   __ne__ˆ   s    c         C   sC   |  j  t k s t Ç |  j  t k r( d S|  j  t k r; d St Sd S(   sC  Return the content-transfer-encoding used for body encoding.

        This is either the string `quoted-printable' or `base64' depending on
        the encoding used, or it is a function in which case you should call
        the function with a single argument, the Message object being
        encoded.  The function should then set the Content-Transfer-Encoding
        header itself to whatever is appropriate.

        Returns "quoted-printable" if self.body_encoding is QP.
        Returns "base64" if self.body_encoding is BASE64.
        Returns "7bit" otherwise.
        s   quoted-printablet   base64N(   R6   R   t   AssertionErrort   QPR3   R   (   R9   (    (    s#   /usr/lib/python2.7/email/charset.pyt   get_body_encoding˘   s    c         C   s6   |  j  |  j k r. t | |  j  É j |  j É S| Sd S(   s:   Convert a string from the input_codec to the output_codec.N(   R7   R8   R(   R)   (   R9   t   s(    (    s#   /usr/lib/python2.7/email/charset.pyt   convert  s    c         C   sR   t  | t É s |  j d k r" | Sy t | |  j d É SWn t k
 rM | SXd S(   sÍ  Convert a possibly multibyte string to a safely splittable format.

        Uses the input_codec to try and convert the string to Unicode, so it
        can be safely split on character boundaries (even for multibyte
        characters).

        Returns the string as-is if it isn't known how to convert it to
        Unicode with the input_charset.

        Characters that could not be converted to Unicode will be replaced
        with the Unicode replacement character U+FFFD.
        t   replaceN(   R'   R(   R7   R4   R0   (   R9   RG   (    (    s#   /usr/lib/python2.7/email/charset.pyt   to_splittable  s    c         C   sh   | r |  j  } n	 |  j } t | t É s7 | d k r; | Sy | j | d É SWn t k
 rc | SXd S(   s*  Convert a splittable string back into an encoded string.

        Uses the proper codec to try and convert the string from Unicode back
        into an encoded format.  Return the string as-is if it is not Unicode,
        or if it could not be converted from Unicode.

        Characters that could not be converted from Unicode will be replaced
        with an appropriate character (usually '?').

        If to_output is True (the default), uses output_codec to convert to an
        encoded format.  If to_output is False, uses input_codec.
        RI   N(   R8   R7   R'   R(   R4   R)   R0   (   R9   t   ustrt	   to_outputt   codec(    (    s#   /usr/lib/python2.7/email/charset.pyt   from_splittable+  s    	c         C   s   |  j  p |  j S(   sè   Return the output character set.

        This is self.output_charset if that is not None, otherwise it is
        self.input_charset.
        (   R!   R2   (   R9   (    (    s#   /usr/lib/python2.7/email/charset.pyt   get_output_charsetD  s    c         C   s¬   |  j  É  } |  j t k r9 t j j | É t | É t S|  j t k rf t j	 j
 | É t | É t S|  j t k r¥ t j j | É } t j	 j
 | É } t | | É t | É t St | É Sd S(   s/   Return the length of the encoded header string.N(   RO   R5   R3   t   emailt
   base64mimet
   base64_lent   lent   MISC_LENRE   t
   quoprimimet   header_quopri_lenR   t   min(   R9   RG   t   csett   lenb64t   lenqp(    (    s#   /usr/lib/python2.7/email/charset.pyt   encoded_header_lenL  s    c         C   s‰   |  j  É  } | r$ |  j | É } n  |  j t k rF t j j | | É S|  j t k rn t j j | | d d ÉS|  j t
 k r‹ t j j | É } t j j | É } | | k  r¿ t j j | | É St j j | | d d ÉSn | Sd S(   sE  Header-encode a string, optionally converting it to output_charset.

        If convert is True, the string will be converted from the input
        charset to the output charset automatically.  This is not useful for
        multibyte character sets, which have line length issues (multibyte
        characters must be split on a character, not a byte boundary); use the
        high-level Header class to deal with these issues.  convert defaults
        to False.

        The type of encoding (base64 or quoted-printable) will be based on
        self.header_encoding.
        t
   maxlinelenN(   RO   RH   R5   R3   RP   RQ   t   header_encodeRE   RU   R4   R   RR   RV   (   R9   RG   RH   RX   RY   RZ   (    (    s#   /usr/lib/python2.7/email/charset.pyR]   [  s    c         C   s^   | r |  j  | É } n  |  j t k r7 t j j | É S|  j t k rV t j j | É S| Sd S(   s…  Body-encode a string and convert it to output_charset.

        If convert is True (the default), the string will be converted from
        the input charset to output charset automatically.  Unlike
        header_encode(), there are no issues with byte boundaries and
        multibyte charsets in email bodies, so this is usually pretty safe.

        The type of encoding (base64 or quoted-printable) will be based on
        self.body_encoding.
        N(   RH   R6   R3   RP   RQ   t   body_encodeRE   RU   (   R9   RG   RH   (    (    s#   /usr/lib/python2.7/email/charset.pyR^   z  s    (   t   __name__t
   __module__t   __doc__t   DEFAULT_CHARSETR=   R>   t   __repr__RA   RB   RF   RH   RJ   t   TrueRN   RO   R[   t   FalseR]   R^   (    (    (    s#   /usr/lib/python2.7/email/charset.pyR    ú   s   +&								(   NNN(    (   t   __all__R-   t   email.base64mimeRP   t   email.quoprimimeR   t   email.encodersR   RE   R3   R   RT   Rb   R4   R   R"   R%   R   R   R   R    (    (    (    s#   /usr/lib/python2.7/email/charset.pyt   <module>   sà   	

			                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             